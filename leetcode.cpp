#include <algorithm>
#include <bitset>
#include <deque>
#include <iostream>
#include <map>
#include <multimap>
#include <numeric>
#include <pair>
#include <queue> // including priority_queue
#include <set>
#include <multiset>
#include <stack>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "trie.h"
#include "unionfind.h"

using namespace std;

class Solution {
public:

    /*1. Two Sum (Easy)
    Given an array of integers nums and an integer target, return indices of
    the two numbers such that they add up to target. You may assume that each
    input would have exactly one solution, and you may not use the same element
    twice. You can return the answer in any order.

    Example 1:
    Input: nums = [2,7,11,15], target = 9
    Output: [0,1]
    Output: Because nums[0] + nums[1] == 9, we return [0, 1].

    Example 2:
    Input: nums = [3,2,4], target = 6
    Output: [1,2]

    Example 3:
    Input: nums = [3,3], target = 6
    Output: [0,1]

    Constraints:
    * 2 <= nums.length <= 10^3
    * -10^9 <= nums[i] <= 10^9
    * -10^9 <= target <= 10^9
    * Only one valid answer exists.*/

    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> seen;
        for (int i = 0; i < nums.size(); ++i) {
            if (seen.count(target - nums[i])) return {seen[target-nums[i]], i};
            seen[nums[i]] = i;
        }
        return {};
    }


    /*2. Add Two Numbers (Medium)
    You are given two non-empty linked lists representing two non-negative
    integers. The digits are stored in reverse order, and each of their nodes
    contains a single digit. Add the two numbers and return the sum as a linked
    list. You may assume the two numbers do not contain any leading zero,
    except the number 0 itself.

    Example 1:
    Input: l1 = [2,4,3], l2 = [5,6,4]
    Output: [7,0,8]
    Explanation: 342 + 465 = 807.

    Example 2:
    Input: l1 = [0], l2 = [0]
    Output: [0]

    Example 3:
    Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
    Output: [8,9,9,9,0,0,0,1]

    Constraints:
    * The number of nodes in each linked list is in the range [1, 100].
    * 0 <= Node.val <= 9
    * It is guaranteed that the list represents a number that does not have
      leading zeros.*/

    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy = ListNode(), *node = &dummy;
        for (int carry = 0; l1 || l2 || carry; carry /= 10) {
            if (l1) {
                carry += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                carry += l2->val;
                l2 = l2->next;
            }
            node = node->next = new ListNode(carry%10);
        }
        return dummy.next;
    }


    /*3. Longest Substring Without Repeating Characters (Medium)
    Given a string s, find the length of the longest substring without
    repeating characters.

    Example 1:
    Input: s = "abcabcbb"
    Output: 3
    Explanation: The answer is "abc", with the length of 3.

    Example 2:
    Input: s = "bbbbb"
    Output: 1
    Explanation: The answer is "b", with the length of 1.

    Example 3:
    Input: s = "pwwkew"
    Output: 3
    Explanation: The answer is "wke", with the length of 3. Notice that the
                 answer must be a substring, "pwke" is a subsequence and not a
                 substring.

    Example 4:
    Input: s = ""
    Output: 0

    Constraints:
    * 0 <= s.length <= 5 * 10^4
    * s consists of English letters, digits, symbols and spaces.*/

    int lengthOfLongestSubstring(string s) {
        int ans = 0;
        unordered_map<char, int> loc;
        for (int i = 0, ii = 0; i < s.size(); ++i) {
            if (loc.count(s[i])) ii = max(ii, loc[s[i]]+1);
            ans = max(ans, i - ii + 1);
            loc[s[i]] = i;
        }
        return ans;
    }


    /*5. Longest Palindromic Substring (Medium)
    Given a string s, return the longest palindromic substring in s.

    Example 1:
    Input: s = "babad"
    Output: "bab"
    Note: "aba" is also a valid answer.

    Example 2:
    Input: s = "cbbd"
    Output: "bb"

    Example 3:
    Input: s = "a"
    Output: "a"

    Example 4:
    Input: s = "ac"
    Output: "a"

    Constraints:
    * 1 <= s.length <= 1000
    * s consist of only digits and English letters.*/

    string longestPalindrome(string s) {
        // Manacher's algo
        string ss = "#";
        for (auto& ch : s) {
            ss.push_back(ch);
            ss.push_back('#');
        }

        int n = ss.size(), ii = 0, most = 0;
        vector<int> hlen(n);
        for (int i = 0, center = 0, right = 0; i < n; ++i) {
            if (i < right) hlen[i] = min(right-i, hlen[2*center-i]);
            while (0 <= i-1-hlen[i] && i+1+hlen[i] < n && ss[i-1-hlen[i]] == ss[i+1+hlen[i]]) ++hlen[i];
            if (right < i+hlen[i]) center = i, right = i+hlen[i];
            if (most < hlen[i]) ii = i, most = hlen[i];
        }
        return s.substr((ii-most)/2, most);
    }


    /*7. Reverse Integer (Easy)
    Given a 32-bit signed integer, reverse digits of an integer. Note that
    assume we are dealing with an environment that could only store integers
    within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose
    of this problem, assume that your function returns 0 when the reversed
    integer overflows.

    Example 1:
    Input: x = 123
    Output: 321

    Example 2:
    Input: x = -123
    Output: -321

    Example 3:
    Input: x = 120
    Output: 21

    Example 4:
    Input: x = 0
    Output: 0

    Constraints: -2^31 <= x <= 2^31 - 1*/

    int reverse(int x) {
        int ans = 0;
        while (x) {
            if ((ans > INT_MAX/10) or (ans == INT_MAX/10 and x > INT_MAX%10)) return 0;
            if ((ans < INT_MIN/10) or (ans == INT_MIN/10 and x < INT_MIN%10)) return 0;
            ans = 10*ans + x%10;
            x /= 10;
        }
        return ans;
    }


    /*8. String to Integer (atoi) (Medium)
    Implement the myAtoi(string s) function, which converts a string to a 32-
    bit signed integer (similar to C/C++'s atoi function). The algorithm for
    myAtoi(string s) is as follows:
    * Read in and ignore any leading whitespace.
    * Check if the next character (if not already at the end of the string) is
      '-' or '+'. Read this character in if it is either. This determines if
      the final result is negative or positive respectively. Assume the result
      is positive if neither is present.
    * Read in next the characters until the next non-digit character or the end
      of the input is reached. The rest of the string is ignored.
    * Convert these digits into an integer (i.e. "123" -> 123, "0032" -> 32).
      If no digits were read, then the integer is 0. Change the sign as
      necessary (from step 2).
    * If the integer is out of the 32-bit signed integer range [-2^31, 2^31 - 1],
      then clamp the integer so that it remains in the range. Specifically,
      integers less than -2^31 should be clamped to -2^31, and integers greater
      than 2^31 - 1 should be clamped to 2^31 - 1.
    * Return the integer as the final result.

    Note:
    * Only the space character ' ' is considered a whitespace character.
    * Do not ignore any characters other than the leading whitespace or the
      rest of the string after the digits.

    Example 1:
    Input: s = "42"
    Output: 42
    Explanation: The underlined characters are what is read in, the caret is the current reader position.
                 Step 1: "42" (no characters read because there is no leading whitespace)
                          ^
                 Step 2: "42" (no characters read because there is neither a '-' nor '+')
                          ^
                 Step 3: "42" ("42" is read in)
                            ^
                 The parsed integer is 42.
                 Since 42 is in the range [-2^31, 2^31 - 1], the final result is 42.

    Example 2:
    Input: s = "   -42"
    Output: -42
    Explanation: Step 1: "   -42" (leading whitespace is read and ignored)
                             ^
                 Step 2: "   -42" ('-' is read, so the result should be negative)
                              ^
                 Step 3: "   -42" ("42" is read in)
                                ^
                 The parsed integer is -42.
                 Since -42 is in the range [-2^31, 2^31 - 1], the final result is -42.

    Example 3:
    Input: s = "4193 with words"
    Output: 4193
    Explanation: Step 1: "4193 with words" (no characters read because there is no leading whitespace)
                          ^
                 Step 2: "4193 with words" (no characters read because there is neither a '-' nor '+')
                          ^
                 Step 3: "4193 with words" ("4193" is read in; reading stops because the next character is a non-digit)
                              ^
                 The parsed integer is 4193.
                 Since 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193.

    Constraints:
    * 0 <= s.length <= 200
    * s consists of English letters (lower-case and upper-case), digits (0-9),
      ' ', '+', '-', and '.'.*/

    int myAtoi(string s) {
        int sign = 1, base = 0, i = s.find_first_not_of(' ');
        if (i < s.size() && (s[i] == '+' || s[i] == '-'))
            if (s[i++] == '-') sign = -1;
        for (; i < s.size() && isdigit(s[i]); ++i) {
            if (base > INT_MAX/10 || (base == INT_MAX/10 && s[i] >= '8'))
                return sign == 1 ? INT_MAX : INT_MIN;
            base = 10*base + (s[i] - '0');
        }
        return sign * base;
    }


    /*9. Palindrome Number (Easy)
    Determine whether an integer is a palindrome. An integer is a palindrome
    when it reads the same backward as forward.
    Follow up: Could you solve it without converting the integer to a string?

    Example 1:
    Input: x = 121
    Output: true

    Example 2:
    Input: x = -121
    Output: false
    Explanation: From left to right, it reads -121. From right to left, it
                 becomes 121-. Therefore it is not a palindrome.

    Example 3:
    Input: x = 10
    Output: false
    Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

    Example 4:
    Input: x = -101
    Output: false

    Constraints: -2^31 <= x <= 2^31 - 1*/

    bool isPalindrome(int x) {
        if (x < 0) return false; // edge case

        long val = x, rev = 0;
        while (x) {
            rev = 10*rev + x%10;
            x /= 10;
        }
        return val == rev;
    }


    /*11. Container With Most Water (Medium)
    Given n non-negative integers a1, a2, ..., an , where each represents a
    point at coordinate (i, ai). n vertical lines are drawn such that the two
    endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which,
    together with the x-axis forms a container, such that the container
    contains the most water. Notice that you may not slant the container.

    Example 1:
    Input: height = [1,8,6,2,5,4,8,3,7]
    Output: 49
    Explanation: The above vertical lines are represented by array
                 [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue
                 section) the container can contain is 49.

    Example 2:
    Input: height = [1,1]
    Output: 1

    Example 3:
    Input: height = [4,3,2,1,4]
    Output: 16

    Example 4:
    Input: height = [1,2,1]
    Output: 2

    Constraints:
    * n == height.length
    * 2 <= n <= 10^5
    * 0 <= height[i] <= 10^4*/

    int maxArea(vector<int>& height) {
        int ans = 0;
        for (int lo = 0, hi = height.size()-1; lo < hi; ) {
            ans = max(ans, (hi - lo) * min(height[lo], height[hi]));
            if (height[lo] <= height[hi]) ++lo;
            else --hi;
        }
        return ans;
    }


    /*13. Roman to Integer (Easy)
    Roman numerals are represented by seven different symbols: I, V, X, L, C, D
    and M.
    Symbol       Value
    I             1
    V             5
    X             10
    L             50
    C             100
    D             500
    M             1000
    For example, 2 is written as II in Roman numeral, just two one's added
    together. 12 is written as XII, which is simply X + II. The number 27 is
    written as XXVII, which is XX + V + II. Roman numerals are usually written
    largest to smallest from left to right. However, the numeral for four is
    not IIII. Instead, the number four is written as IV. Because the one is
    before the five we subtract it making four. The same principle applies to
    the number nine, which is written as IX. There are six instances where
    subtraction is used:
    * I can be placed before V (5) and X (10) to make 4 and 9.
    * X can be placed before L (50) and C (100) to make 40 and 90.
    * C can be placed before D (500) and M (1000) to make 400 and 900.
    Given a roman numeral, convert it to an integer.

    Example 1:
    Input: s = "III"
    Output: 3

    Example 2:
    Input: s = "IV"
    Output: 4

    Example 3:
    Input: s = "IX"
    Output: 9

    Example 4:
    Input: s = "LVIII"
    Output: 58
    Explanation: L = 50, V= 5, III = 3.

    Example 5:
    Input: s = "MCMXCIV"
    Output: 1994
    Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

    Constraints:
    * 1 <= s.length <= 15
    * s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
    * It is guaranteed that s is a valid roman numeral in the range [1, 3999].*/

    int romanToInt(string s) {
        unordered_map<char, int> mp = {
            {'I', 1},
            {'V', 5},
            {'X', 10},
            {'L', 50},
            {'C', 100},
            {'D', 500},
            {'M', 1000}};
        int ans = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (i+1 < s.size() and mp[s[i]] < mp[s[i+1]])
                ans -= mp[s[i]];
            else
                ans += mp[s[i]];
        }
        return ans;
    }


    /*15. 3Sum (Medium)
    Given an integer array nums, return all the triplets
    [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and
    nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not
    contain duplicate triplets.

    Example 1:
    Input: nums = [-1,0,1,2,-1,-4]
    Output: [[-1,-1,2],[-1,0,1]]

    Example 2:
    Input: nums = []
    Output: []

    Example 3:
    Input: nums = [0]
    Output: []

    Constraints:
    * 0 <= nums.length <= 3000
    * -10^5 <= nums[i] <= 10^5*/

    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        for (int i = 0; i < nums.size(); ++i)
            if (i == 0 || nums[i-1] != nums[i])
                for (int lo = i+1, hi = nums.size()-1; lo < hi; ) {
                    int sm = nums[i] + nums[lo] + nums[hi];
                    if (sm < 0) ++lo;
                    else if (sm == 0) {
                        ans.push_back({nums[i], nums[lo], nums[hi]});
                        for (++lo; lo < hi && nums[lo-1] == nums[lo]; ++lo);
                    } else --hi;
                }
        return ans;
    }


    /*16. 3Sum Closest (Medium)
    Given an array nums of n integers and an integer target, find three
    integers in nums such that the sum is closest to target. Return the sum of
    the three integers. You may assume that each input would have exactly one
    solution.

    Example 1:
    Input: nums = [-1,2,1,-4], target = 1
    Output: 2
    Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

    Constraints:
    * 3 <= nums.length <= 10^3
    * -10^3 <= nums[i] <= 10^3
    * -10^4 <= target <= 10^4*/

    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int ans = nums[0] + nums[1] + nums[2];
        for (int i = 0; i < nums.size(); ++i) {
            int lo = i+1, hi = nums.size()-1;
            while (lo < hi) {
                int sm = nums[i] + nums[lo] + nums[hi];
                if (abs(sm - target) < abs(ans - target)) ans = sm;
                if (sm < target) ++lo;
                else --hi;
            }
        }
        return ans;
    }


    /*17. Letter Combinations of a Phone Number (Medium)
    Given a string containing digits from 2-9 inclusive, return all possible
    letter combinations that the number could represent. Return the answer in
    any order. A mapping of digit to letters (just like on the telephone
    buttons) is given below. Note that 1 does not map to any letters.

    Example 1:
    Input: digits = "23"
    Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

    Example 2:
    Input: digits = ""
    Output: []

    Example 3:
    Input: digits = "2"
    Output: ["a","b","c"]

    Constraints:
    * 0 <= digits.length <= 4
    * digits[i] is a digit in the range ['2', '9'].*/

    vector<string> letterCombinations(string digits) {
        if (digits.empty()) return {};
        const vector<string> phone = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        vector<string> ans = {""};
        for (auto& ch : digits) {
            vector<string> tmp;
            for (auto& x : ans)
                for (auto& xx : phone[ch-'2'])
                    tmp.push_back(x + xx);
            ans = tmp;
        }
        return ans;
    }


    /*18. 4Sum (Medium)
    Given an array nums of n integers, return an array of all the unique
    quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
    * 0 <= a, b, c, d < n
    * a, b, c, and d are distinct.
    * nums[a] + nums[b] + nums[c] + nums[d] == target
    You may return the answer in any order.

    Example 1:
    Input: nums = [1,0,-1,0,-2,2], target = 0
    Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

    Example 2:
    Input: nums = [2,2,2,2,2], target = 8
    Output: [[2,2,2,2]]

    Constraints:
    * 1 <= nums.length <= 200
    * -10^9 <= nums[i] <= 10^9
    * -10^9 <= target <= 10^9*/

    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());

        vector<vector<int>> ans;
        for (int i = 0; i < nums.size(); ++i) {
            if (i && nums[i-1] == nums[i]) continue;
            for (int j = i+1; j < nums.size(); ++j) {
                if (i+1 < j && nums[j-1] == nums[j]) continue;
                int lo = j+1, hi = nums.size()-1;
                while (lo < hi) {
                    int sm = nums[i] + nums[j] + nums[lo] + nums[hi];
                    if (sm < target || (j+1 < lo && nums[lo-1] == nums[lo])) ++lo;
                    else if (sm > target || (hi+1 < nums.size() && nums[hi] == nums[hi+1])) --hi;
                    else ans.push_back({nums[i], nums[j], nums[lo++], nums[hi--]});
                }
            }
        }
        return ans;
    }


    /*19. Remove Nth Node From End of List (Medium)
    Given the head of a linked list, remove the nth node from the end of the
    list and return its head. Follow up: Could you do this in one pass?

    Example 1:
    Input: head = [1,2,3,4,5], n = 2
    Output: [1,2,3,5]

    Example 2:
    Input: head = [1], n = 1
    Output: []

    Example 3:
    Input: head = [1,2], n = 1
    Output: [1]

    Constraints:
    * The number of nodes in the list is sz.
    * 1 <= sz <= 30
    * 0 <= Node.val <= 100
    * 1 <= n <= sz*/

    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode dummy(0, head), *fast = &dummy, *slow = &dummy;
        while (fast) {
            fast = fast->next;
            if (n-- < 0) slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummy.next;
    }


    /*20. Valid Parentheses (Easy)
    Given a string s containing just the characters '(', ')', '{', '}', '[' and
    ']', determine if the input string is valid. An input string is valid if:
    * Open brackets must be closed by the same type of brackets.
    * Open brackets must be closed in the correct order.

    Example 1:
    Input: s = "()"
    Output: true

    Example 2:
    Input: s = "()[]{}"
    Output: true

    Example 3:
    Input: s = "(]"
    Output: false

    Example 4:
    Input: s = "([)]"
    Output: false

    Example 5:
    Input: s = "{[]}"
    Output: true

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of parentheses only '()[]{}'.*/

    bool isValid(string s) {
        unordered_map<char, char> mp = {{'(', ')'}, {'[', ']'}, {'{', '}'}};
        stack<char> stk;
        for (auto& ch : s)
            if (mp.count(ch)) stk.push(ch);
            else {
                if (stk.empty() || mp[stk.top()] != ch) return false;
                stk.pop();
            }
        return stk.empty();
    }


    /*21. Merge Two Sorted Lists (Easy)
    Merge two sorted linked lists and return it as a new sorted list. The new
    list should be made by splicing together the nodes of the first two lists.

    Example 1:
    Input: l1 = [1,2,4], l2 = [1,3,4]
    Output: [1,1,2,3,4,4]

    Example 2:
    Input: l1 = [], l2 = []
    Output: []

    Example 3:
    Input: l1 = [], l2 = [0]
    Output: [0]

    Constraints:
    * The number of nodes in both lists is in the range [0, 50].
    * -100 <= Node.val <= 100
    * Both l1 and l2 are sorted in non-decreasing order.

    Definition for singly-linked list.
    struct ListNode {
        int val;
        ListNode *next;
        ListNode() : val(0), next(nullptr) {}
        ListNode(int x) : val(x), next(nullptr) {}
        ListNode(int x, ListNode *next) : val(x), next(next) {}
    };

    */

    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy(0), *node = &dummy;
        while (list1 && list2) {
            if (list1->val > list2->val) swap(list1, list2);
            node = node->next = list1;
            list1 = list1->next;
        }
        node->next = list1 ? list1 : list2;
        return dummy.next;
    }


    /*22. Generate Parentheses (Medium)
    Given n pairs of parentheses, write a function to generate all combinations
    of well-formed parentheses.

    Example 1:
    Input: n = 3
    Output: ["((()))","(()())","(())()","()(())","()()()"]

    Example 2:
    Input: n = 1
    Output: ["()"]

    Constraints: 1 <= n <= 8*/

    vector<string> generateParenthesis(int n) {
        vector<vector<string>> dp = {{""}};
        for (int k = 1; k <= n; ++k) {
            dp.push_back({});
            for (int i = 0; i < k; ++i)
                for (auto& x : dp[i])
                    for (auto& y : dp[k-i-1])
                        dp.back().push_back(x + "(" + y + ")");
        }
        return dp.back();
    }


    /*23. Merge k Sorted Lists (Hard)
    You are given an array of k linked-lists lists, each linked-list is sorted
    in ascending order. Merge all the linked-lists into one sorted linked-list
    and return it.

    Example 1:
    Input: lists = [[1,4,5],[1,3,4],[2,6]]
    Output: [1,1,2,3,4,4,5,6]
    Explanation: The linked-lists are:
                 [ 1->4->5,
                   1->3->4,
                   2->6 ]
                 merging them into one sorted list:
                 1->1->2->3->4->4->5->6

    Example 2:
    Input: lists = []
    Output: []

    Example 3:
    Input: lists = [[]]
    Output: []

    Constraints:
    * k == lists.length
    * 0 <= k <= 10^4
    * 0 <= lists[i].length <= 500
    * -10^4 <= lists[i][j] <= 10^4
    * lists[i] is sorted in ascending order.
    * The sum of lists[i].length won't exceed 10^4.*/

    ListNode* mergeKLists(vector<ListNode*>& lists) {

        struct Compare {
            bool operator() (ListNode* lhs, ListNode* rhs) {return lhs->val > rhs->val;}
        };

        priority_queue<ListNode*, vector<ListNode*>, Compare> pq;
        for (auto& x : lists)
            if (x) pq.push(x);
        ListNode dummy = ListNode(), *node = &dummy;
        while (pq.size()) {
            auto x = pq.top(); pq.pop();
            node = node->next = x;
            if (x->next) pq.push(x->next);
        }
        return dummy.next;
    }


    /*24. Swap Nodes in Pairs (Medium)
    Given a linked list, swap every two adjacent nodes and return its head. You
    must solve the problem without modifying the values in the list's nodes
    (i.e., only nodes themselves may be changed.)

    Example 1:
    Input: head = [1,2,3,4]
    Output: [2,1,4,3]

    Example 2:
    Input: head = []
    Output: []

    Example 3:
    Input: head = [1]
    Output: [1]

    Constraints:
    * The number of nodes in the list is in the range [0, 100].
    * 0 <= Node.val <= 100*/

    ListNode* swapPairs(ListNode* head) {
        ListNode dummy(0, head), *node = &dummy;
        for (; node->next && node->next->next; node = node->next->next) {
            ListNode *temp = node->next->next;
            node->next->next = temp->next;
            temp->next = node->next;
            node->next = temp;
        }
        return dummy.next;
    }


    /*25. Reverse Nodes in k-Group (Hard)
    Given a linked list, reverse the nodes of a linked list k at a time and
    return its modified list. k is a positive integer and is less than or equal
    to the length of the linked list. If the number of nodes is not a multiple
    of k then left-out nodes, in the end, should remain as it is. You may not
    alter the values in the list's nodes, only nodes themselves may be changed.

    Example 1:
    Input: head = [1,2,3,4,5], k = 2
    Output: [2,1,4,3,5]

    Example 2:
    Input: head = [1,2,3,4,5], k = 3
    Output: [3,2,1,4,5]

    Example 3:
    Input: head = [1,2,3,4,5], k = 1
    Output: [1,2,3,4,5]

    Example 4:
    Input: head = [1], k = 1
    Output: [1]

    Constraints:
    * The number of nodes in the list is in the range sz.
    * 1 <= sz <= 5000
    * 0 <= Node.val <= 1000
    * 1 <= k <= sz

    Follow-up: Can you solve the problem in O(1) extra memory space?*/

    ListNode* reverseKGroup(ListNode* head, int k) {
        int sz = 0;
        for (ListNode* node = head; node; node = node->next, ++sz);
        ListNode dummy(0, head), *node = &dummy;
        for (sz /= k; sz; --sz) {
            ListNode *prev = node, *curr = node->next;
            for (int i = 0; i < k; ++i) {
                ListNode *temp = curr->next;
                curr->next = prev;
                prev = curr;
                curr = temp;
            }
            ListNode *temp = node->next;
            node->next->next = curr;
            node->next = prev;
            node = temp;
        }
        return dummy.next;
    }


    /*26. Remove Duplicates from Sorted Array (Easy)
    Given a sorted array nums, remove the duplicates in-place such that each
    element appears only once and returns the new length. Do not allocate extra
    space for another array, you must do this by modifying the input array in-
    place with O(1) extra memory.

    Clarification:
    Confused why the returned value is an integer but your answer is an array?
    Note that the input array is passed in by reference, which means a
    modification to the input array will be known to the caller as well.

    Internally you can think of this:
    // nums is passed in by reference. (i.e., without making a copy)
    int len = removeDuplicates(nums);
    // any modification to nums in your function would be known by the caller.
    // using the length returned by your function, it prints the first len elements.
    for (int i = 0; i < len; i++) {
        print(nums[i]);
    }

    Example 1:
    Input: nums = [1,1,2]
    Output: 2, nums = [1,2]
    Explanation: Your function should return length = 2, with the first two
                 elements of nums being 1 and 2 respectively. It doesn't matter
                 what you leave beyond the returned length.

    Example 2:
    Input: nums = [0,0,1,1,1,2,2,3,3,4]
    Output: 5, nums = [0,1,2,3,4]
    Explanation: Your function should return length = 5, with the first five
                 elements of nums being modified to 0, 1, 2, 3, and 4
                 respectively. It doesn't matter what values are set beyond the
                 returned length.

    Constraints:
    * 0 <= nums.length <= 3 * 10^4
    * -10^4 <= nums[i] <= 10^4
    * nums is sorted in ascending order.*/

    int removeDuplicates(vector<int>& nums) {
        int i = 0;
        for (auto& x : nums) {
            if (i == 0 or nums[i-1] < x) {
                nums[i++] = x;
            }
        }
        return i;
    }


    /*28. Implement strStr() (Easy)
    Implement strStr(). Return the index of the first occurrence of needle in
    haystack, or -1 if needle is not part of haystack.

    Clarification:
    What should we return when needle is an empty string? This is a great
    question to ask during an interview. For the purpose of this problem, we
    will return 0 when needle is an empty string. This is consistent to C's
    strstr() and Java's indexOf().

    Example 1:
    Input: haystack = "hello", needle = "ll"
    Output: 2

    Example 2:
    Input: haystack = "aaaaa", needle = "bba"
    Output: -1

    Example 3:
    Input: haystack = "", needle = ""
    Output: 0

    Constraints:
    * 0 <= haystack.length, needle.length <= 5 * 10^4
    * haystack and needle consist of only lower-case English characters.*/

    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0; // edge case

        int n = (int) needle.size();
        vector<int> lps(n, 0); // longest prefix-suffix array
        int k = 0;
        for (int i = 1; i < n; ++i) {
            while (k > 0 and needle[k] != needle[i]) k = lps[k-1];
            if (needle[k] == needle[i]) k++;
            lps[i] = k;
        }

        int m = (int) haystack.size();
        k = 0;
        for (int i = 0; i < m; ++i) {
            while (k > 0 and needle[k] != haystack[i]) k = lps[k-1];
            if (needle[k] == haystack[i]) k++;
            if (k == n) return i + 1 - n;
        }
        return -1;
    }


    /*33. Search in Rotated Sorted Array (Medium)
    There is an integer array nums sorted in ascending order (with distinct
    values). Prior to being passed to your function, nums is possibly rotated
    at an unknown pivot index k (1 <= k < nums.length) such that the resulting
    array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ...,
    nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at
    pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the
    possible rotation and an integer target, return the index of target if it
    is in nums, or -1 if it is not in nums. You must write an algorithm with
    O(log n) runtime complexity.

    Example 1:
    Input: nums = [4,5,6,7,0,1,2], target = 0
    Output: 4

    Example 2:
    Input: nums = [4,5,6,7,0,1,2], target = 3
    Output: -1

    Example 3:
    Input: nums = [1], target = 0
    Output: -1

    Constraints:
    * 1 <= nums.length <= 5000
    * -10^4 <= nums[i] <= 10^4
    * All values of nums are unique.
    * nums is an ascending array that is possibly rotated.
    * -10^4 <= target <= 10^4*/

    int search(vector<int>& nums, int target) {
        for (int lo = 0, hi = nums.size()-1; lo <= hi; ) {
            int mid = lo + (hi - lo)/2;
            if (nums[mid] == target) return mid;
            else if (nums[lo] <= nums[mid])
                if (nums[lo] <= target && target < nums[mid]) hi = mid - 1;
                else lo = mid + 1;
            else
                if (nums[mid] < target && target <= nums[hi]) lo = mid + 1;
                else hi = mid - 1;
        }
        return -1;
    }


    /*34. Find First and Last Position of Element in Sorted Array (Medium)
    Given an array of integers nums sorted in ascending order, find the starting
    and ending position of a given target value. If target is not found in the
    array, return [-1, -1].

    Follow up: Could you write an algorithm with O(log n) runtime complexity?

    Example 1:
    Input: nums = [5,7,7,8,8,10], target = 8
    Output: [3,4]

    Example 2:
    Input: nums = [5,7,7,8,8,10], target = 6
    Output: [-1,-1]

    Example 3:
    Input: nums = [], target = 0
    Output: [-1,-1]

    Constraints:
    * 0 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9
    * nums is a non-decreasing array.
    * -10^9 <= target <= 10^9*/

    vector<int> searchRange(vector<int>& nums, int target) {
        int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
        int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1;
        if (lo < nums.size() && nums[lo] == target) return {lo, hi};
        return {-1, -1};
    }


    /*35. Search Insert Position (Easy)
    Given a sorted array of distinct integers and a target value, return the
    index if the target is found. If not, return the index where it would be if
    it were inserted in order. You must write an algorithm with O(log n)
    runtime complexity.

    Example 1:
    Input: nums = [1,3,5,6], target = 5
    Output: 2

    Example 2:
    Input: nums = [1,3,5,6], target = 2
    Output: 1

    Example 3:
    Input: nums = [1,3,5,6], target = 7
    Output: 4

    Example 4:
    Input: nums = [1,3,5,6], target = 0
    Output: 0

    Example 5:
    Input: nums = [1], target = 0
    Output: 0

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^4 <= nums[i] <= 10^4
    * nums contains distinct values sorted in ascending order.
    * -10^4 <= target <= 10^4*/

    int searchInsert(vector<int>& nums, int target) {
        int lo = 0, hi = nums.size();
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (nums[mid] < target) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*36. Valid Sudoku (Medium)
    Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to
    be validated according to the following rules:
    * Each row must contain the digits 1-9 without repetition.
    * Each column must contain the digits 1-9 without repetition.
    * Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9
      without repetition.

    Note:
    * A Sudoku board (partially filled) could be valid but is not necessarily
      solvable.
    * Only the filled cells need to be validated according to the mentioned
      rules.

    Example 1:
    Input: board = [["5","3",".",".","7",".",".",".","."]
                   ,["6",".",".","1","9","5",".",".","."]
                   ,[".","9","8",".",".",".",".","6","."]
                   ,["8",".",".",".","6",".",".",".","3"]
                   ,["4",".",".","8",".","3",".",".","1"]
                   ,["7",".",".",".","2",".",".",".","6"]
                   ,[".","6",".",".",".",".","2","8","."]
                   ,[".",".",".","4","1","9",".",".","5"]
                   ,[".",".",".",".","8",".",".","7","9"]]
    Output: true

    Example 2:
    Input: board = [["8","3",".",".","7",".",".",".","."]
                   ,["6",".",".","1","9","5",".",".","."]
                   ,[".","9","8",".",".",".",".","6","."]
                   ,["8",".",".",".","6",".",".",".","3"]
                   ,["4",".",".","8",".","3",".",".","1"]
                   ,["7",".",".",".","2",".",".",".","6"]
                   ,[".","6",".",".",".",".","2","8","."]
                   ,[".",".",".","4","1","9",".",".","5"]
                   ,[".",".",".",".","8",".",".","7","9"]]
    Output: false
    Explanation: Same as Example 1, except with the 5 in the top left corner
                 being modified to 8. Since there are two 8's in the top left
                 3x3 sub-box, it is invalid.

    Constraints:
    * board.length == 9
    * board[i].length == 9
    * board[i][j] is a digit or '.'.*/

    bool isValidSudoku(vector<vector<char>>& board) {
        bool rows[9][9] = {false}, cols[9][9] = {false}, subs[9][9] = {false};
        for (int i = 0; i < 9; ++i)
            for (int j = 0; j < 9; ++j)
                if (board[i][j] != '.') {
                    int x = board[i][j] - '1', k = i/3*3 + j/3;
                    if (rows[i][x] || cols[j][x] || subs[k][x]) return false;
                    rows[i][x] = cols[j][x] = subs[k][x] = true;
                }
        return true;
    }


    /*39. Combination Sum (Medium)
    Given an array of distinct integers candidates and a target integer target,
    return a list of all unique combinations of candidates where the chosen
    numbers sum to target. You may return the combinations in any order. The
    same number may be chosen from candidates an unlimited number of times. Two
    combinations are unique if the frequency of at least one of the chosen
    numbers is different. It is guaranteed that the number of unique
    combinations that sum up to target is less than 150 combinations for the
    given input.

    Example 1:
    Input: candidates = [2,3,6,7], target = 7
    Output: [[2,2,3],[7]]
    Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be
                 used multiple times. 7 is a candidate, and 7 = 7. These are
                 the only two combinations.

    Example 2:
    Input: candidates = [2,3,5], target = 8
    Output: [[2,2,2,2],[2,3,3],[3,5]]

    Example 3:
    Input: candidates = [2], target = 1
    Output: []

    Example 4:
    Input: candidates = [1], target = 1
    Output: [[1]]

    Example 5:
    Input: candidates = [1], target = 2
    Output: [[1,1]]

    Constraints:
    * 1 <= candidates.length <= 30
    * 1 <= candidates[i] <= 200
    * All elements of candidates are distinct.
    * 1 <= target <= 500*/

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<vector<int>>> dp(target+1);
        dp[0].push_back({});
        for (auto& x : candidates)
            for (int i = 0; i < target; ++i)
                if (i + x <= target)
                    for (auto seq : dp[i]) {
                        seq.push_back(x);
                        dp[i+x].push_back(seq);
                    }
        return dp[target];
    }


    /*40. Combination Sum II (Medium)
    Given a collection of candidate numbers (candidates) and a target number
    (target), find all unique combinations in candidates where the candidate
    numbers sum to target. Each number in candidates may only be used once in
    the combination. Note: The solution set must not contain duplicate
    combinations.

    Example 1:
    Input: candidates = [10,1,2,7,6,1,5], target = 8
    Output: [[1,1,6],
             [1,2,5],
             [1,7],
             [2,6]]

    Example 2:
    Input: candidates = [2,5,2,1,2], target = 5
    Output: [[1,2,2],
             [5]]

    Constraints:
    * 1 <= candidates.length <= 100
    * 1 <= candidates[i] <= 50
    * 1 <= target <= 30*/

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector<vector<int>> ans;
        vector<int> stk;

        function<void(int, int, bool)> fn = [&](int i, int x, bool prev) {
            if (x == 0) ans.push_back(stk);
            else if (i < candidates.size()) {
                if (candidates[i] > x) return;
                fn(i+1, x, false);
                if (i == 0 || candidates[i-1] != candidates[i] || prev) {
                    stk.push_back(candidates[i]);
                    fn(i+1, x-candidates[i], true);
                    stk.pop_back();
                }
            }
        };

        fn(0, target, false);
        return ans;
    }


    /*41. First Missing Positive (Hard)
    Given an unsorted integer array nums. Return the smallest positive integer
    that is not present in nums. You must implement an algorithm that runs in
    O(n) time and uses O(1) auxiliary space.

    Example 1:
    Input: nums = [1,2,0]
    Output: 3
    Explanation: The numbers in the range [1,2] are all in the array.

    Example 2:
    Input: nums = [3,4,-1,1]
    Output: 2
    Explanation: 1 is in the array but 2 is missing.

    Example 3:
    Input: nums = [7,8,9,11,12]
    Output: 1
    Explanation: The smallest positive integer 1 is missing.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -2^31 <= nums[i] <= 2^31 - 1*/

    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (auto& x : nums)
            while (0 < x && x <= n && nums[x-1] != x)
                swap(x, nums[x-1]);
        for (int i = 0; i < n; ++i)
            if (nums[i] != i+1) return i+1;
        return n+1;
    }


    /*42. Trapping Rain Water (Hard)
    Given n non-negative integers representing an elevation map where the width
    of each bar is 1, compute how much water it can trap after raining.

    Example 1:
    Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
    Output: 6
    Explanation: The above elevation map (black section) is represented by
                 array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain
                 water (blue section) are being trapped.

    Example 2:
    Input: height = [4,2,0,3,2,5]
    Output: 9

    Constraints:
    * n == height.length
    * 0 <= n <= 3 * 10^4
    * 0 <= height[i] <= 10^5*/

    int trap(vector<int>& height) {
        int ans = 0;
        for (int lo = 0, hi = height.size()-1, val = 0; lo < hi; )
            if (height[lo] <= height[hi]) {
                val = max(val, height[lo]);
                ans += val - height[lo++];
            } else {
                val = max(val, height[hi]);
                ans += val - height[hi--];
            }
        return ans;
    }


    /*43. Multiply Strings (Medium)
    Given two non-negative integers num1 and num2 represented as strings,
    return the product of num1 and num2, also represented as a string.
    Note: You must not use any built-in BigInteger library or convert the
    inputs to integer directly.

    Example 1:
    Input: num1 = "2", num2 = "3"
    Output: "6"

    Example 2:
    Input: num1 = "123", num2 = "456"
    Output: "56088"

    Constraints:
    * 1 <= num1.length, num2.length <= 200
    * num1 and num2 consist of digits only.
    * Both num1 and num2 do not contain any leading zero, except the number 0
      itself.*/

    string multiply(string num1, string num2) {
        int m = num1.size(), n = num2.size();
        string ans(m+n, '0');
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                for (int k = i+j+1, carry = (num1[i]-'0') * (num2[j] - '0'); carry; --k, carry /= 10) {
                    carry += ans[k] - '0';
                    ans[k] = carry % 10 + '0';
                }
        int k = ans.find_first_not_of("0");
        return k == string::npos ? "0" : ans.substr(k);
    }


    /*45. Jump Game II (Medium)
    Given an array of non-negative integers nums, you are initially positioned
    at the first index of the array. Each element in the array represents your
    maximum jump length at that position. Your goal is to reach the last index
    in the minimum number of jumps. You can assume that you can always reach
    the last index.

    Example 1:
    Input: nums = [2,3,1,1,4]
    Output: 2
    Explanation: The minimum number of jumps to reach the last index is 2. Jump
                 1 step from index 0 to 1, then 3 steps to the last index.

    Example 2:
    Input: nums = [2,3,0,1,4]
    Output: 2

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 10^5*/

    int jump(vector<int>& nums) {
        int ans = 0;
        for (int i = 0, prev = 0, curr = 0; i < nums.size(); ++i) {
            if (prev < i) {
                ++ans;
                prev = curr;
            }
            curr = max(curr, i + nums[i]);
        }
        return ans;
    }


    /*46. Permutations (Medium)
    Given an array nums of distinct integers, return all the possible
    permutations. You can return the answer in any order.

    Example 1:
    Input: nums = [1,2,3]
    Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

    Example 2:
    Input: nums = [0,1]
    Output: [[0,1],[1,0]]

    Example 3:
    Input: nums = [1]
    Output: [[1]]

    Constraints:
    * 1 <= nums.length <= 6
    * -10 <= nums[i] <= 10
    * All the integers of nums are unique.*/

    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;

        function<void(int)> fn = [&](int i) {
            if (i == nums.size()) ans.push_back(nums);
            for (int ii = i; ii < nums.size(); ++ii) {
                swap(nums[i], nums[ii]);
                fn(i+1);
                swap(nums[i], nums[ii]);
            }
        };

        fn(0);
        return ans;
    }


    /*48. Rotate Image (Medium)
    You are given an n x n 2D matrix representing an image, rotate the image by
    90 degrees (clockwise). You have to rotate the image in-place, which means
    you have to modify the input 2D matrix directly. DO NOT allocate another 2D
    matrix and do the rotation.

    Example 1:
    Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
    Output: [[7,4,1],[8,5,2],[9,6,3]]

    Example 2:
    Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
    Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

    Example 3:
    Input: matrix = [[1]]
    Output: [[1]]

    Example 4:
    Input: matrix = [[1,2],[3,4]]
    Output: [[3,1],[4,2]]

    Constraints:
    * matrix.length == n
    * matrix[i].length == n
    * 1 <= n <= 20
    * -1000 <= matrix[i][j] <= 1000*/

    void rotate(vector<vector<int>>& matrix) {
        int m = matrix.size();
        reverse(matrix.begin(), matrix.end());
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < i; ++j)
                swap(matrix[i][j], matrix[j][i]);
    }


    /*49. Group Anagrams (Medium)
    Given an array of strings strs, group the anagrams together. You can return
    the answer in any order. An Anagram is a word or phrase formed by
    rearranging the letters of a different word or phrase, typically using all
    the original letters exactly once.

    Example 1:
    Input: strs = ["eat","tea","tan","ate","nat","bat"]
    Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

    Example 2:
    Input: strs = [""]
    Output: [[""]]

    Example 3:
    Input: strs = ["a"]
    Output: [["a"]]

    Constraints:
    * 1 <= strs.length <= 10^4
    * 0 <= strs[i].length <= 100
    * strs[i] consists of lower-case English letters.*/

    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;
        for (auto& s : strs) {
            string k = s;
            sort(k.begin(), k.end());
            mp[k].push_back(s);
        }
        review views::values(mp);
    }


    /*51. N-Queens (Hard)
    The n-queens puzzle is the problem of placing n queens on an n x n
    chessboard such that no two queens attack each other. Given an integer n,
    return all distinct solutions to the n-queens puzzle. Each solution
    contains a distinct board configuration of the n-queens' placement, where
    'Q' and '.' both indicate a queen and an empty space, respectively.

    Example 1:
    Input: n = 4
    Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
    Explanation: There exist two distinct solutions to the 4-queens puzzle as
                 shown above

    Example 2:
    Input: n = 1
    Output: [["Q"]]

    Constraints: 1 <= n <= 9*/

    vector<vector<string>> solveNQueens(int n) {
        vector<string> board(n, string(n, '.'));
        vector<bool> cols(n, false), diag(2*n-1, false), anti(2*n-1, false);
        vector<vector<string>> ans;

        function<void(int)> fn = [&](int i) {
            if (i == n) {
                ans.push_back(board);
            } else {
                for (int j = 0; j < n; ++j) {
                    if (!cols[j] && !diag[i-j+n-1] && !anti[i+j]) {
                        board[i][j] = 'Q';
                        cols[j] = diag[i-j+n-1] = anti[i+j] = true;
                        fn(i+1);
                        board[i][j] = '.';
                        cols[j] = diag[i-j+n-1] = anti[i+j] = false;
                    }
                }
            }
        };

        fn(0);
        return ans;
    }


    /*53. Maximum Subarray (Easy)
    Given an integer array nums, find the contiguous subarray (containing at
    least one number) which has the largest sum and return its sum. A subarray
    is a contiguous part of an array.

    Example 1:
    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
    Output: 6
    Explanation: [4,-1,2,1] has the largest sum = 6.

    Example 2:
    Input: nums = [1]
    Output: 1

    Example 3:
    Input: nums = [5,4,-1,7,8]
    Output: 23

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^4 <= nums[i] <= 10^4

    Follow up: If you have figured out the O(n) solution, try coding another
               solution using the divide and conquer approach, which is more
               subtle.*/

    int maxSubArray(vector<int>& nums) {
        int ans = INT_MIN, val = 0;
        for (auto& x : nums) {
            val = max(0, val) + x;
            ans = max(ans, val);
        }
        return ans;
    }


    /*54. Spiral Matrix (Medium)
    Given an m x n matrix, return all elements of the matrix in spiral order.

    Example 1:
    Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
    Output: [1,2,3,6,9,8,7,4,5]

    Example 2:
    Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
    Output: [1,2,3,4,8,12,11,10,9,5,6,7]

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 10
    * -100 <= matrix[i][j] <= 100*/

    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<int> ans;
        for (int k = m*n, i = 0, j = 0, di = 0, dj = 1; k; --k, i += di, j += dj) {
            ans.push_back(matrix[i][j]);
            matrix[i][j] = 101; // mark "visited"
            if (!(0 <= i+di && i+di < m && 0 <= j+dj && j+dj < n && matrix[i+di][j+dj] <= 100)) {
                swap(di, dj); // rotate clockwise
                dj *= -1;
            }
        }
        return ans;
    }


    /*55. Jump Game (Medium)
    You are given an integer array nums. You are initially positioned at the
    array's first index, and each element in the array represents your maximum
    jump length at that position. Return true if you can reach the last index,
    or false otherwise.

    Example 1:
    Input: nums = [2,3,1,1,4]
    Output: true
    Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

    Example 2:
    Input: nums = [3,2,1,0,4]
    Output: false
    Explanation: You will always arrive at index 3 no matter what. Its maximum
                 jump length is 0, which makes it impossible to reach the last
                 index.

    Constraints:
    * 1 <= nums.length <= 10^4
    * 0 <= nums[i] <= 10^5*/

    bool canJump(vector<int>& nums) {
        for (int i = 0, hi = 0; i < nums.size(); ++i) {
            if (hi < i) return false;
            hi = max(hi, i + nums[i]);
        }
        return true;
    }


    /*56. Merge Intervals (Medium)
    Given an array of intervals where intervals[i] = [starti, endi], merge all
    overlapping intervals, and return an array of the non-overlapping intervals
    that cover all the intervals in the input.

    Example 1:
    Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
    Output: [[1,6],[8,10],[15,18]]
    Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].

    Example 2:
    Input: intervals = [[1,4],[4,5]]
    Output: [[1,5]]
    Explanation: Intervals [1,4] and [4,5] are considered overlapping.

    Constraints:
    * 1 <= intervals.length <= 10^4
    * intervals[i].length == 2
    * 0 <= starti <= endi <= 10^4*/

    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](auto& lhs, auto& rhs){return lhs[1] < rhs[1];});
        vector<vector<int>> ans;
        for (auto interval : intervals) {
            while (ans.size() && interval[0] <= ans.back()[1]) {
                interval[0] = min(interval[0], ans.back()[0]);
                ans.pop_back();
            }
            ans.push_back(interval);
        }
        return ans;
    }


    /*58. Length of Last Word (Easy)
    Given a string s consisting of words and spaces, return the length of the
    last word in the string. A word is a maximal substring consisting of non-
    space characters only.

    Example 1:
    Input: s = "Hello World"
    Output: 5
    Explanation: The last word is "World" with length 5.

    Example 2:
    Input: s = "   fly me   to   the moon  "
    Output: 4
    Explanation: The last word is "moon" with length 4.

    Example 3:
    Input: s = "luffy is still joyboy"
    Output: 6
    Explanation: The last word is "joyboy" with length 6.

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of only English letters and spaces ' '.
    * There will be at least one word in s.*/

    int lengthOfLastWord(string s) {
        istringstream iss(s);
        string buf;
        while (iss >> buf);
        return buf.size();
    }


    /*59. Spiral Matrix II (Medium)
    Given a positive integer n, generate an n x n matrix filled with elements
    from 1 to n^2 in spiral order.

    Example 1:
    Input: n = 3
    Output: [[1,2,3],[8,9,4],[7,6,5]]

    Example 2:
    Input: n = 1
    Output: [[1]]

    Constraints: 1 <= n <= 20*/

    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> ans(n, vector<int>(n));
        for (int x = 1, i = 0, j = 0, di = 0, dj = 1; x <= n*n; ++x, i+=di, j+=dj) {
            ans[i][j] = x;
            if (!(0 <= i+di && i+di < n && 0 <= j+dj && j+dj < n && ans[i+di][j+dj] == 0)) {
                swap(di, dj);
                dj *= -1;
            }
        }
        return ans;
    }


    /*62. Unique Paths (Medium)
    A robot is located at the top-left corner of a m x n grid (marked 'Start'
    in the diagram below). The robot can only move either down or right at any
    point in time. The robot is trying to reach the bottom-right corner of the
    grid (marked 'Finish' in the diagram below). How many possible unique paths
    are there?

    Example 1:
    Input: m = 3, n = 7
    Output: 28

    Example 2:
    Input: m = 3, n = 2
    Output: 3
    Explanation: From the top-left corner, there are a total of 3 ways to reach
                 the bottom-right corner:
                 1. Right -> Down -> Down
                 2. Down -> Down -> Right
                 3. Down -> Right -> Down

    Example 3:
    Input: m = 7, n = 3
    Output: 28

    Example 4:
    Input: m = 3, n = 3
    Output: 6

    Constraints:
    * 1 <= m, n <= 100
    * It's guaranteed that the answer will be less than or equal to 2 * 10^9.*/

    int uniquePaths(int m, int n) {
        long ans = 1;
        for (int i = 0; i < min(m-1, n-1); ++i) {
            ans *= m+n-2-i;
            ans /= i+1;
        }
        return ans;
    }


    /*63. Unique Paths II (Medium)
    A robot is located at the top-left corner of a m x n grid (marked 'Start'
    in the diagram below). The robot can only move either down or right at any
    point in time. The robot is trying to reach the bottom-right corner of the
    grid (marked 'Finish' in the diagram below). Now consider if some obstacles
    are added to the grids. How many unique paths would there be? An obstacle
    and space is marked as 1 and 0 respectively in the grid.

    Example 1:
    Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
    Output: 2
    Explanation: There is one obstacle in the middle of the 3x3 grid above.
    There are two ways to reach the bottom-right corner:
    1. Right -> Right -> Down -> Down
    2. Down -> Down -> Right -> Right

    Example 2:
    Input: obstacleGrid = [[0,1],[0,0]]
    Output: 1

    Constraints:
    * m == obstacleGrid.length
    * n == obstacleGrid[i].length
    * 1 <= m, n <= 100
    * obstacleGrid[i][j] is 0 or 1.*/

    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector<int> dp(n);
        dp[0] = 1;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (obstacleGrid[i][j]) dp[j] = 0;
                else if (j) dp[j] += dp[j-1];
        return dp.back();
    }


    /*64. Minimum Path Sum (Medium)
    Given a m x n grid filled with non-negative numbers, find a path from top
    left to bottom right, which minimizes the sum of all numbers along its path.
    Note: You can only move either down or right at any point in time.

    Example 1:
    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
    Output: 7
    Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.

    Example 2:
    Input: grid = [[1,2,3],[4,5,6]]
    Output: 12

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 200
    * 0 <= grid[i][j] <= 100*/

    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (i == 0 && j) grid[i][j] += grid[i][j-1];
                else if (i && j == 0) grid[i][j] += grid[i-1][j];
                else if (i && j) grid[i][j] += min(grid[i-1][j], grid[i][j-1]);
        return grid[m-1][n-1];
    }


    /*65. Valid Number (Hard)
    A valid number can be split up into these components (in order):
    * A decimal number or an integer.
    * (Optional) An 'e' or 'E', followed by an integer.
    A decimal number can be split up into these components (in order):
    * (Optional) A sign character (either '+' or '-').
    * One of the following formats:
      + One or more digits, followed by a dot '.'.
      + One or more digits, followed by a dot '.', followed by one or more
        digits.
      + A dot '.', followed by one or more digits.
    An integer can be split up into these components (in order):
    * (Optional) A sign character (either '+' or '-').
    * One or more digits.
    For example, all the following are valid numbers:
    ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"],
    while the following are not valid numbers:
    ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]. Given a
    string s, return true if s is a valid number.

    Example 1:
    Input: s = "0"
    Output: true

    Example 2:
    Input: s = "e"
    Output: false

    Example 3:
    Input: s = "."
    Output: false

    Example 4:
    Input: s = ".1"
    Output: true

    Constraints:
    * 1 <= s.length <= 20
    * s consists of only English letters (both uppercase and lowercase), digits
      (0-9), plus '+', minus '-', or dot '.'.*/

    bool isNumber(string s) {
        vector<unordered_map<string, int>> dfa = {
            {{"space", 0}, {"sign", 1}, {"digit", 2}, {".", 3}},
            {{"digit", 2}, {".", 3}},
            {{"digit", 2}, {".", 4}, {"e", 5}, {"space", 8}},
            {{"digit", 4}},
            {{"digit", 4}, {"e", 5}, {"space", 8}},
            {{"sign", 6}, {"digit", 7}},
            {{"digit", 7}},
            {{"digit", 7}, {"space", 8}},
            {{"space", 8}}};

        int state = 0;
        string ss;
        for (auto& ch : s) {
            ch = tolower(ch);
            if ('0' <= ch && ch <= '9') ss = "digit";
            else if (ch == ' ') ss = "space";
            else if (ch == '+' || ch == '-') ss = "sign";
            else ss = string(1, ch);
            if (!dfa[state].count(ss)) return false;
            state = dfa[state][ss];
        }
        return state == 2 || state == 4 || state == 7 || state == 8;
    }


    /*67. Add Binary (Easy)
    Given two binary strings a and b, return their sum as a binary string.

    Example 1:
    Input: a = "11", b = "1"
    Output: "100"

    Example 2:
    Input: a = "1010", b = "1011"
    Output: "10101"

    Constraints:
    * 1 <= a.length, b.length <= 10^4
    * a and b consist only of '0' or '1' characters.
    * Each string does not contain leading zeros except for the zero itself.*/

    string addBinary(string a, string b) {
        string ans;
        for (int i = a.size()-1, j = b.size()-1, carry = 0; 0 <= i || 0 <= j || carry; carry /= 2) {
            if (0 <= i) carry += a[i--] - '0';
            if (0 <= j) carry += b[j--] - '0';
            ans.push_back(carry % 2 + '0');
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*69. Sqrt(x) (Easy)
    Given a non-negative integer x, return the square root of x rounded down to
    the nearest integer. The returned integer should be non-negative as well.
    You must not use any built-in exponent function or operator. For example,
    do not use pow(x, 0.5) in c++ or x ** 0.5 in python.

    Example 1:
    Input: x = 4
    Output: 2
    Explanation: The square root of 4 is 2, so we return 2.

    Example 2:
    Input: x = 8
    Output: 2
    Explanation: The square root of 8 is 2.82842..., and since we round it down
                 to the nearest integer, 2 is returned.

    Constraints: 0 <= x <= 2^31 - 1*/

    int mySqrt(int x) {
        long ans = x;
        while (ans * ans > x)
            ans = (ans + x/ans)/2;
        return ans;
    }


    /*70. Climbing Stairs (Easy)
    You are climbing a staircase. It takes n steps to reach the top. Each time
    you can either climb 1 or 2 steps. In how many distinct ways can you climb
    to the top?

    Example 1:
    Input: n = 2
    Output: 2
    Explanation: There are two ways to climb to the top.
                 1. 1 step + 1 step
                 2. 2 steps

    Example 2:
    Input: n = 3
    Output: 3
    Explanation: There are three ways to climb to the top.
                 1. 1 step + 1 step + 1 step
                 2. 1 step + 2 steps
                 3. 2 steps + 1 step

    Constraints: 1 <= n <= 45*/

    int climbStairs(int n) {
        int f0 = 1, f1 = 1;
        for (int i = 1; i <= n-1; ++i) {
            swap(f0, f1);
            f1 += f0;
        }
        return f1;
    }


    /*71. Simplify Path (Medium)
    Given a string path, which is an absolute path (starting with a slash '/')
    to a file or directory in a Unix-style file system, convert it to the
    simplified canonical path. In a Unix-style file system, a period '.' refers
    to the current directory, a double period '..' refers to the directory up a
    level, and any multiple consecutive slashes (i.e. '//') are treated as a
    single slash '/'. For this problem, any other format of periods such as
    '...' are treated as file/directory names. The canonical path should have
    the following format:
    * The path starts with a single slash '/'.
    * Any two directories are separated by a single slash '/'.
    * The path does not end with a trailing '/'.
    * The path only contains the directories on the path from the root
      directory to the target file or directory (i.e., no period '.' or double
      period '..')
    Return the simplified canonical path.

    Example 1:
    Input: path = "/home/"
    Output: "/home"
    Explanation: Note that there is no trailing slash after the last directory
                 name.

    Example 2:
    Input: path = "/../"
    Output: "/"
    Explanation: Going one level up from the root directory is a no-op, as the
                 root level is the highest level you can go.

    Example 3:
    Input: path = "/home//foo/"
    Output: "/home/foo"
    Explanation: In the canonical path, multiple consecutive slashes are
                 replaced by a single one.

    Constraints:
    * 1 <= path.length <= 3000
    * path consists of English letters, digits, period '.', slash '/' or '_'.
    * path is a valid absolute Unix path.*/

    string simplifyPath(string path) {
        vector<string> stk;
        istringstream iss(path);
        string buf;
        while (getline(iss, buf, '/'))
            if (buf == "..") {
                if (stk.size()) stk.pop_back();
            } else if (buf.size() && buf != ".")
                stk.push_back(buf);
        string ans;
        for (auto& x : stk) ans += "/" + x;
        return ans.size() ? ans : "/";
    }


    /*72. Edit Distance (Hard)
    Given two strings word1 and word2, return the minimum number of operations
    required to convert word1 to word2. You have the following three operations
    permitted on a word:
    * Insert a character
    * Delete a character
    * Replace a character

    Example 1:
    Input: word1 = "horse", word2 = "ros"
    Output: 3
    Explanation: horse -> rorse (replace 'h' with 'r')
                 rorse -> rose (remove 'r')
                 rose -> ros (remove 'e')

    Example 2:
    Input: word1 = "intention", word2 = "execution"
    Output: 5
    Explanation: intention -> inention (remove 't')
                 inention -> enention (replace 'i' with 'e')
                 enention -> exention (replace 'n' with 'x')
                 exention -> exection (replace 'n' with 'c')
                 exection -> execution (insert 'u')

    Constraints:
    * 0 <= word1.length, word2.length <= 500
    * word1 and word2 consist of lowercase English letters.*/

    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for (int i = 0; i < m; ++i) dp[i][n] = m-i;
        for (int j = 0; j < n; ++j) dp[m][j] = n-j;

        for (int i = m-1; 0 <= i; --i)
            for (int j = n-1; 0 <= j; --j)
                if (word1[i] == word2[j]) dp[i][j] = dp[i+1][j+1];
                else dp[i][j] = 1 + min({dp[i+1][j], dp[i+1][j+1], dp[i][j+1]});
        return dp[0][0];
    }


    /*73. Set Matrix Zeroes (Medium)
    Given an m x n integer matrix matrix, if an element is 0, set its entire
    row and column to 0's, and return the matrix. You must do it in place.

    Example 1:
    Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
    Output: [[1,0,1],[0,0,0],[1,0,1]]

    Example 2:
    Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
    Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]

    Constraints:
    * m == matrix.length
    * n == matrix[0].length
    * 1 <= m, n <= 200
    * -2^31 <= matrix[i][j] <= 2^31 - 1

    Follow up:
    * A straightforward solution using O(mn) space is probably a bad idea.
    * A simple improvement uses O(m + n) space, but still not the best solution.
    * Could you devise a constant space solution?*/

    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size(), flag = 0;
        for (int i = 0; i < m; ++i) {
            if (matrix[i][0] == 0) flag = 1;
            for (int j = 1; j < n; ++j)
                if (matrix[i][j] == 0)
                    matrix[i][0] = matrix[0][j] = 0;
        }

        for (int i = m-1; i >= 0; --i) {
            for (int j = n-1; j >= 1; --j)
                if (matrix[i][0] == 0 || matrix[0][j] == 0)
                    matrix[i][j] = 0;
            if (flag) matrix[i][0] = 0;
        }
    }


    /*74. Search a 2D Matrix (Medium)
    Write an efficient algorithm that searches for a value in an m x n matrix.
    This matrix has the following properties:
    * Integers in each row are sorted from left to right.
    * The first integer of each row is greater than the last integer of the
      previous row.

    Example 1:
    Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
    Output: true

    Example 2:
    Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
    Output: false

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 100
    * -10^4 <= matrix[i][j], target <= 10^4*/

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        for (int lo = 0, hi = m*n; lo < hi; ) {
            int mid = lo + (hi - lo)/2, i = mid/n, j = mid%n;
            if (matrix[i][j] < target) lo = mid + 1;
            else if (matrix[i][j] == target) return true;
            else hi = mid;
        }
        return false;
    }


    /*75. Sort Colors (Medium)
    Given an array nums with n objects colored red, white, or blue, sort them
    in-place so that objects of the same color are adjacent, with the colors in
    the order red, white, and blue. We will use the integers 0, 1, and 2 to
    represent the color red, white, and blue, respectively. You must solve this
    problem without using the library's sort function.

    Example 1:
    Input: nums = [2,0,2,1,1,0]
    Output: [0,0,1,1,2,2]

    Example 2:
    Input: nums = [2,0,1]
    Output: [0,1,2]

    Example 3:
    Input: nums = [0]
    Output: [0]

    Example 4:
    Input: nums = [1]
    Output: [1]

    Constraints:
    * n == nums.length
    * 1 <= n <= 300
    * nums[i] is 0, 1, or 2.

    Follow up: Could you come up with a one-pass algorithm using only constant
               extra space?*/

    void sortColors(vector<int>& nums) {
        // Dijkstra's 3-way partitioning
        for (int lo = 0, mid = 0, hi = nums.size()-1; mid <= hi; )
            if (nums[mid] == 0) swap(nums[lo++], nums[mid++]);
            else if (nums[mid] == 1) ++mid;
            else swap(nums[mid], nums[hi--]);
    }


    /*77. Combinations (Medium)
    Given two integers n and k, return all possible combinations of k numbers
    out of the range [1, n]. You may return the answer in any order.

    Example 1:
    Input: n = 4, k = 2
    Output: [[2,4],
             [3,4],
             [2,3],
             [1,2],
             [1,3],
             [1,4],]

    Example 2:
    Input: n = 1, k = 1
    Output: [[1]]

    Constraints:
    * 1 <= n <= 20
    * 1 <= k <= n*/

    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> stk;
        for (int x = 1; true; ) {
            if (stk.size() == k) ans.push_back(stk);
            if (stk.size() == k || k - stk.size() > n - x + 1) {
                if (stk.empty()) break;
                x = 1 + stk.back(); stk.pop_back();
            } else
                stk.push_back(x++);
        }
        return ans;
    }


    /*78. Subsets (Medium)
    Given an integer array nums of unique elements, return all possible subsets
    (the power set). The solution set must not contain duplicate subsets.
    Return the solution in any order.

    Example 1:
    Input: nums = [1,2,3]
    Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

    Example 2:
    Input: nums = [0]
    Output: [[],[0]]

    Constraints:
    * 1 <= nums.length <= 10
    * -10 <= nums[i] <= 10
    * All the numbers of nums are unique.*/

    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> ans;
        for (int m = 0, n = nums.size(); m < 1<<n; ++m) {
            vector<int> seq;
            for (int i = 0; i < n; ++i)
                if (m & 1<<i) seq.push_back(nums[i]);
            ans.push_back(seq);
        }
        return ans;
    }


    /*79. Word Search (Medium)
    Given an m x n grid of characters board and a string word, return true if
    word exists in the grid. The word can be constructed from letters of
    sequentially adjacent cells, where adjacent cells are horizontally or
    vertically neighboring. The same letter cell may not be used more than once.

    Example 1:
    Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]],
           word = "ABCCED"
    Output: true

    Example 2:
    Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]],
           word = "SEE"
    Output: true

    Example 3:
    Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]],
           word = "ABCB"
    Output: false

    Constraints:
    * m == board.length
    * n = board[i].length
    * 1 <= m, n <= 6
    * 1 <= word.length <= 15
    * board and word consists of only lowercase and uppercase English letters.

    Follow up: Could you use search pruning to make your solution faster with a
               larger board?*/

    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size();

        function<bool(int, int, int)> fn = [&](int i, int j, int k) {
            if (k+1 == word.size()) return true;
            board[i][j] ^= 128;
            for (auto&& [ii, jj] : vector<pair<int, int>>{{i-1, j}, {i, j-1}, {i, j+1}, {i+1, j}})
                if (0 <= ii && ii < m && 0 <= jj && jj < n && board[ii][jj] == word[k+1] && fn(ii, jj, k+1))
                    return true;
            board[i][j] ^= 128;
            return false;
        };

        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (board[i][j] == word[0] && fn(i, j, 0))
                    return true;
        return false;
    }


    /*80. Remove Duplicates from Sorted Array II (Medium)
    Given an integer array nums sorted in non-decreasing order, remove some
    duplicates in-place such that each unique element appears at most twice.
    The relative order of the elements should be kept the same. Since it is
    impossible to change the length of the array in some languages, you must
    instead have the result be placed in the first part of the array nums. More
    formally, if there are k elements after removing the duplicates, then the
    first k elements of nums should hold the final result. It does not matter
    what you leave beyond the first k elements. Return k after placing the
    final result in the first k slots of nums. Do not allocate extra space for
    another array. You must do this by modifying the input array in-place with
    O(1) extra memory.

    Custom Judge:
    The judge will test your solution with the following code:
    int[] nums = [...]; // Input array
    int[] expectedNums = [...]; // The expected answer with correct length
    int k = removeDuplicates(nums); // Calls your implementation
    assert k == expectedNums.length;
    for (int i = 0; i < k; i++) {
        assert nums[i] == expectedNums[i];
    }
    If all assertions pass, then your solution will be accepted.

    Example 1:
    Input: nums = [1,1,1,2,2,3]
    Output: 5, nums = [1,1,2,2,3,_]
    Explanation: Your function should return k = 5, with the first five
                 elements of nums being 1, 1, 2, 2 and 3 respectively. It does
                 not matter what you leave beyond the returned k (hence they
                 are underscores).

    Example 2:
    Input: nums = [0,0,1,1,1,1,2,3,3]
    Output: 7, nums = [0,0,1,1,2,3,3,_,_]
    Explanation: Your function should return k = 7, with the first seven
                 elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It
                 does not matter what you leave beyond the returned k (hence
                 they are underscores).

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * -10^4 <= nums[i] <= 10^4
    * nums is sorted in non-decreasing order.*/

    int removeDuplicates(vector<int>& nums) {
        int i = 0;
        for (auto& x : nums) {
            if (i < 2 || nums[i-2] < x)
                nums[i++] = x;
        }
        return i;
    }


    /*82. Remove Duplicates from Sorted List II (Medium)
    Given the head of a sorted linked list, delete all nodes that have
    duplicate numbers, leaving only distinct numbers from the original list.
    Return the linked list sorted as well.

    Example 1:
    Input: head = [1,2,3,3,4,4,5]
    Output: [1,2,5]

    Example 2:
    Input: head = [1,1,1,2,3]
    Output: [2,3]

    Constraints:
    * The number of nodes in the list is in the range [0, 300].
    * -100 <= Node.val <= 100
    * The list is guaranteed to be sorted in ascending order.*/

    ListNode* deleteDuplicates(ListNode* head) {
        ListNode dummy(0, head), *node = &dummy;
        while (node && node->next) {
            ListNode *temp = node->next;
            while (temp && node->next->val == temp->val) temp = temp->next;
            if (node->next->next == temp) node = node->next;
            else node->next = temp;
        }
        return dummy.next;
    }


    /*83. Remove Duplicates from Sorted List (Easy)
    Given the head of a sorted linked list, delete all duplicates such that
    each element appears only once. Return the linked list sorted as well.

    Example 1:
    Input: head = [1,1,2]
    Output: [1,2]

    Example 2:
    Input: head = [1,1,2,3,3]
    Output: [1,2,3]

    Constraints:
    * The number of nodes in the list is in the range [0, 300].
    * -100 <= Node.val <= 100
    * The list is guaranteed to be sorted in ascending order.*/

    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* node = head;
        while (node)
            if (node->next && node->val == node->next->val) node->next = node->next->next;
            else node = node->next;
        return head;
    }


    /*84. Largest Rectangle in Histogram (Hard)
    Given an array of integers heights representing the histogram's bar height
    where the width of each bar is 1, return the area of the largest rectangle
    in the histogram.

    Example 1:
    Input: heights = [2,1,5,6,2,3]
    Output: 10
    Explanation: The above is a histogram where width of each bar is 1. The
                 largest rectangle is shown in the red area, which has an
                 area = 10 units.

    Example 2:
    Input: heights = [2,4]
    Output: 4

    Constraints:
    * 1 <= heights.length <= 10^5
    * 0 <= heights[i] <= 10^4*/

    int largestRectangleArea(vector<int>& heights) {
        int ans = 0;
        stack<int> stk; // non-decreasing stack
        for (int i = 0; i <= heights.size(); ++i) {
            int ht = i < heights.size() ? heights[i] : 0;
            while (stk.size() && heights[stk.top()] > ht) {
                int h = heights[stk.top()]; stk.pop();
                int w = stk.size() ? i-1-stk.top() : i;
                ans = max(ans, h*w);
            }
            stk.push(i);
        }
        return ans;
    }


    /*85. Maximal Rectangle (Hard)
    Given a rows x cols binary matrix filled with 0's and 1's, find the largest
    rectangle containing only 1's and return its area.

    Example 1:
    Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
    Output: 6
    Explanation: The maximal rectangle is shown in the above picture.

    Example 2:
    Input: matrix = []
    Output: 0

    Example 3:
    Input: matrix = [["0"]]
    Output: 0

    Example 4:
    Input: matrix = [["1"]]
    Output: 1

    Example 5:
    Input: matrix = [["0","0"]]
    Output: 0

    Constraints:
    * rows == matrix.length
    * cols == matrix[i].length
    * 0 <= row, cols <= 200
    * matrix[i][j] is '0' or '1'.*/

    int maximalRectangle(vector<vector<char>>& matrix) {
        int ans = 0;
        if (matrix.size()) {
            int m = matrix.size(), n = matrix[0].size();
            vector<int> lo(n), hi(n, n-1), ht(n);
            for (int i = 0; i < m; ++i) {
                int left = 0, right = n-1;
                for (int j = 0; j < n; ++j) {
                    if (matrix[i][j] == '1') ++ht[j], lo[j] = max(lo[j], left);
                    else ht[j] = lo[j] = 0, left = j+1;

                    if (matrix[i][n-1-j] == '1') hi[n-1-j] = min(hi[n-1-j], right);
                    else hi[n-1-j] = n-1, right = n-2-j;
                }
                for (int j = 0; j < n; ++j)
                    ans = max(ans, (hi[j] - lo[j] + 1) * ht[j]);
            }
        }
        return ans;
    }


    /*86. Partition List (Medium)
    Given the head of a linked list and a value x, partition it such that all
    nodes less than x come before nodes greater than or equal to x. You should
    preserve the original relative order of the nodes in each of the two
    partitions.

    Example 1:
    Input: head = [1,4,3,2,5,2], x = 3
    Output: [1,2,2,4,3,5]

    Example 2:
    Input: head = [2,1], x = 2
    Output: [1,2]

    Constraints:
    * The number of nodes in the list is in the range [0, 200].
    * -100 <= Node.val <= 100
    * -200 <= x <= 200*/

    ListNode* partition(ListNode* head, int x) {
        ListNode dummy1(0), dummy2(0);
        ListNode *node1 = &dummy1, *node2 = &dummy2, *node = head;

        while (node) {
            if (node->val < x) {
                node1 = node1->next = node;
            } else {
                node2 = node2->next = node;
            }
            node = node->next;
        }
        node1->next = dummy2.next;
        node2->next = NULL;
        return dummy1.next;
    }


    /*88. Merge Sorted Array (Easy)
    Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as
    one sorted array. The number of elements initialized in nums1 and nums2 are
    m and n respectively. You may assume that nums1 has a size equal to m + n
    such that it has enough space to hold additional elements from nums2.

    Example 1:
    Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
    Output: [1,2,2,3,5,6]

    Example 2:
    Input: nums1 = [1], m = 1, nums2 = [], n = 0
    Output: [1]

    Constraints:
    * nums1.length == m + n
    * nums2.length == n
    * 0 <= m, n <= 200
    * 1 <= m + n <= 200
    * -10^9 <= nums1[i], nums2[i] <= 10^9*/

    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        while (n)
            if (m && nums1[m-1] >= nums2[n-1]) nums1[m+n] = nums1[--m];
            else nums1[m+n] = nums2[--n];
    }


    /*89. Gray Code (Medium)
    An n-bit gray code sequence is a sequence of 2n integers where:
    * Every integer is in the inclusive range [0, 2n - 1],
    * The first integer is 0,
    * An integer appears no more than once in the sequence,
    * The binary representation of every pair of adjacent integers differs by
      exactly one bit, and
    * The binary representation of the first and last integers differs by
      exactly one bit.
    Given an integer n, return any valid n-bit gray code sequence.

    Example 1:
    Input: n = 2
    Output: [0,1,3,2]
    Explanation: The binary representation of [0,1,3,2] is [00,01,11,10].
                 - 00 and 01 differ by one bit
                 - 01 and 11 differ by one bit
                 - 11 and 10 differ by one bit
                 - 10 and 00 differ by one bit
                 [0,2,3,1] is also a valid gray code sequence, whose binary
                 representation is [00,10,11,01].
                 - 00 and 10 differ by one bit
                 - 10 and 11 differ by one bit
                 - 11 and 01 differ by one bit
                 - 01 and 00 differ by one bit

    Example 2:
    Input: n = 1
    Output: [0,1]

    Constraints: 1 <= n <= 16*/

    vector<int> grayCode(int n) {
        vector<int> ans(1);
        for (int i = 1; i < (1 << n); ++i)
            ans.push_back(ans.back() ^ (i & -i));
        return ans;
    }


    /*90. Subsets II (Medium)
    Given an integer array nums that may contain duplicates, return all
    possible subsets (the power set). The solution set must not contain
    duplicate subsets. Return the solution in any order.

    Example 1:
    Input: nums = [1,2,2]
    Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]

    Example 2:
    Input: nums = [0]
    Output: [[],[0]]

    Constraints:
    * 1 <= nums.length <= 10
    * -10 <= nums[i] <= 10*/

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans(1);
        for (int i = 0, ii = 0, sz = 0; i < nums.size(); ++i) {
            if (i && nums[i-1] == nums[i]) ii = sz;
            else ii = 0;
            for (sz = ans.size(); ii < sz; ++ii) {
                vector<int> elem = ans[ii];
                elem.push_back(nums[i]);
                ans.push_back(elem);
            }
        }
        return ans;
    }


    /*91. Decode Ways (Medium)
    A message containing letters from A-Z can be encoded into numbers using the
    following mapping:
    'A' -> "1"
    'B' -> "2"
    ...
    'Z' -> "26"
    To decode an encoded message, all the digits must be grouped then mapped
    back into letters using the reverse of the mapping above (there may be
    multiple ways). For example, "11106" can be mapped into:
    * "AAJF" with the grouping (1 1 10 6)
    * "KJF" with the grouping (11 10 6)
    Note that the grouping (1 11 06) is invalid because "06" cannot be mapped
    into 'F' since "6" is different from "06". Given a string s containing only
    digits, return the number of ways to decode it. The answer is guaranteed to
    fit in a 32-bit integer.

    Example 1:
    Input: s = "12"
    Output: 2
    Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).

    Example 2:
    Input: s = "226"
    Output: 3
    Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).

    Example 3:
    Input: s = "0"
    Output: 0
    Explanation: There is no character that is mapped to a number starting with
                 0. The only valid mappings with 0 are 'J' -> "10" and
                 'T' -> "20", neither of which start with 0. Hence, there are
                 no valid ways to decode this since all digits need to be
                 mapped.

    Example 4:
    Input: s = "06"
    Output: 0
    Explanation: "06" cannot be mapped to "F" because of the leading zero ("6"
                 is different from "06").

    Constraints:
    * 1 <= s.length <= 100
    * s contains only digits and may contain leading zero(s).*/

    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n+1, 0);
        dp[n] = 1;
        for (int i = n-1; i >= 0; --i)
            if (s[i] != '0') {
                dp[i] = dp[i+1];
                if (i+1 < n && s.substr(i, 2) <= "26") dp[i] += dp[i+2];
            }
        return dp[0];
    }


    /*92. Reverse Linked List II (Medium)
    Given the head of a singly linked list and two integers left and right
    where left <= right, reverse the nodes of the list from position left to
    position right, and return the reversed list.

    Example 1:
    Input: head = [1,2,3,4,5], left = 2, right = 4
    Output: [1,4,3,2,5]

    Example 2:
    Input: head = [5], left = 1, right = 1
    Output: [5]

    Constraints:
    * The number of nodes in the list is n.
    * 1 <= n <= 500
    * -500 <= Node.val <= 500
    * 1 <= left <= right <= n

    Follow up: Could you do it in one pass?*/

    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode *dummy = new ListNode(0, head), *node = dummy, *prev = nullptr;
        for (int i = 0; i < left; ++i) {
            prev = node;
            node = node->next;
        }

        ListNode *pp = prev, *nn = node;
        for (int i = left; i <= right; ++i) {
            ListNode* temp = node->next;
            node->next = prev;
            prev = node;
            node = temp;
        }

        pp->next = prev;
        nn->next = node;

        return dummy->next;
    }


    /*94. Binary Tree Inorder Traversal (Medium)
    Given the root of a binary tree, return the inorder traversal of its
    nodes' values.

    Example 1:
    Input: root = [1,null,2,3]
    Output: [1,3,2]

    Example 2:
    Input: root = []
    Output: []

    Example 3:
    Input: root = [1]
    Output: [1]

    Example 4:
    Input: root = [1,2]
    Output: [2,1]

    Example 5:
    Input: root = [1,null,2]
    Output: [1,2]

    Constraints:
    * The number of nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100

    Follow up: Recursive solution is trivial, could you do it iteratively?*/

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        TreeNode* node = root;
        stack<TreeNode*> stk;
        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top(); stk.pop();
                ans.push_back(node->val);
                node = node->right;
            }
        return ans;
    }


    /*95. Unique Binary Search Trees II (Medium)
    Given an integer n, return all the structurally unique BST's (binary search
    trees), which has exactly n nodes of unique values from 1 to n. Return the
    answer in any order.

    Example 1:
    Input: n = 3
    Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]

    Example 2:
    Input: n = 1
    Output: [[1]]

    Constraints: 1 <= n <= 8*/

    vector<TreeNode*> generateTrees(int n) {
        unordered_map<int, vector<TreeNode*>> memo;

        function<vector<TreeNode*>(int, int)> fn = [&](int lo, int hi) {
            int key = 10*lo + hi;
            if (!memo.count(key))
                if (lo == hi) memo[key].push_back(nullptr);
                else {
                    vector<TreeNode*> ans;
                    for (int mid = lo; mid < hi; ++mid)
                        for (auto& left : fn(lo, mid))
                            for (auto& right : fn(mid+1, hi))
                                memo[key].push_back(new TreeNode(mid, left, right));
                }
            return memo[key];
        };

        return fn(1, n+1);
    }


    /*96. Unique Binary Search Trees (Medium)
    Given an integer n, return the number of structurally unique BST's (binary
    search trees) which has exactly n nodes of unique values from 1 to n.

    Example 1:
    Input: n = 3
    Output: 5

    Example 2:
    Input: n = 1
    Output: 1

    Constraints: 1 <= n <= 19*/

    int numTrees(int n) {
        // Catalan number
        long ans = 1;
        for (int i = 0; i < n; ++i) {
            ans *= 2*n - i;
            ans /= i+1;
        }
        return ans/(n+1);
    }


    /*97. Interleaving String (Medium)
    Given strings s1, s2, and s3, find whether s3 is formed by an interleaving
    of s1 and s2. An interleaving of two strings s and t is a configuration
    where they are divided into non-empty substrings such that:
    * s = s1 + s2 + ... + sn
    * t = t1 + t2 + ... + tm
    * |n - m| <= 1
    * The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or
      t1 + s1 + t2 + s2 + t3 + s3 + ...
    Note: a + b is the concatenation of strings a and b.

    Example 1:
    Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
    Output: true

    Example 2:
    Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
    Output: false

    Example 3:
    Input: s1 = "", s2 = "", s3 = ""
    Output: true

    Constraints:
    * 0 <= s1.length, s2.length <= 100
    * 0 <= s3.length <= 200
    * s1, s2, and s3 consist of lowercase English letters.

    Follow up: Could you solve it using only O(s2.length) additional memory
               space?*/

    bool isInterleave(string s1, string s2, string s3) {
        if (size(s1) + size(s2) != size(s3)) return false;

        vector<bool> dp(size(s2)+1, false);
        dp.back() = true;
        for (int i = size(s1); i >= 0; --i) {
            for (int j = size(s2); j >= 0; --j) {
                if (i < size(s1)) dp[j] = dp[j] && s1[i] == s3[i+j];
                if (j < size(s2)) dp[j] = dp[j] || (dp[j+1] && s2[j] == s3[i+j]);
            }
        }
        return dp[0];
    }


    /*98. Validate Binary Search Tree (Medium)
    Given the root of a binary tree, determine if it is a valid binary search
    tree (BST). A valid BST is defined as follows:
    * The left subtree of a node contains only nodes with keys less than the
      node's key.
    * The right subtree of a node contains only nodes with keys greater than
      the node's key.
    * Both the left and right subtrees must also be binary search trees.

    Example 1:
    Input: root = [2,1,3]
    Output: true

    Example 2:
    Input: root = [5,1,4,null,null,3,6]
    Output: false
    Explanation: The root node's value is 5 but its right child's value is 4.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -2^31 <= Node.val <= 2^31 - 1*/

    bool isValidBST(TreeNode* root) {
        TreeNode* node = root;
        stack<TreeNode*> stk;
        long prev = LONG_MIN;
        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top(); stk.pop();
                if (prev >= node->val) return false;
                prev = node->val;
                node = node->right;
            }
        return true;
    }


    /*100. Same Tree (Easy)
    Given the roots of two binary trees p and q, write a function to check if
    they are the same or not. Two binary trees are considered the same if they
    are structurally identical, and the nodes have the same value.

    Example 1:
    Input: p = [1,2,3], q = [1,2,3]
    Output: true

    Example 2:
    Input: p = [1,2], q = [1,null,2]
    Output: false

    Example 3:
    Input: p = [1,2,1], q = [1,1,2]
    Output: false

    Constraints:
    * The number of nodes in both trees is in the range [0, 100].
    * -10^4 <= Node.val <= 10^4*/

    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr || q == nullptr) return p == q;
        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }


    /*101. Symmetric Tree (Easy)
    Given the root of a binary tree, check whether it is a mirror of itself
    (i.e., symmetric around its center).

    Example 1:
    Input: root = [1,2,2,3,4,4,3]
    Output: true

    Example 2:
    Input: root = [1,2,2,null,3,null,3]
    Output: false

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * -100 <= Node.val <= 100

    Follow up: Could you solve it both recursively and iteratively?*/

    bool isSymmetric(TreeNode* root) {
        stack<pair<TreeNode*, TreeNode*>> stk; stk.emplace(root, root);
        while (stk.size()) {
            auto [p, q] = stk.top(); stk.pop();
            if (!q || p->val != q->val) return false;
            if (p->left) stk.emplace(p->left, q->right);
            if (p->right) stk.emplace(p->right, q->left);
        }
        return true;
    }


    /*102. Binary Tree Level Order Traversal (Medium)
    Given the root of a binary tree, return the level order traversal of its
    nodes' values. (i.e., from left to right, level by level).

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
    Output: [[3],[9,20],[15,7]]

    Example 2:
    Input: root = [1]
    Output: [[1]]

    Example 3:
    Input: root = []
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 2000].
    * -1000 <= Node.val <= 1000*/

    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (root) {
            queue<TreeNode*> q;
            q.push(root);
            while (q.size()) {
                vector<int> vals;
                for (int n = q.size(); n; --n) {
                    TreeNode* node = q.front(); q.pop();
                    vals.push_back(node->val);
                    if (node->left) q.push(node->left);
                    if (node->right) q.push(node->right);
                }
                ans.push_back(vals);
            }
        }
        return ans;
    }


    /*103. Binary Tree Zigzag Level Order Traversal (Medium)
    Given the root of a binary tree, return the zigzag level order traversal of
    its nodes' values. (i.e., from left to right, then right to left for the
    next level and alternate between).

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
    Output: [[3],[20,9],[15,7]]

    Example 2:
    Input: root = [1]
    Output: [[1]]

    Example 3:
    Input: root = []
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 2000].
    * -100 <= Node.val <= 100*/

    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (root) {
            queue<TreeNode*> q;
            q.push(root);
            for (bool tf = false; q.size(); tf = !tf) {
                vector<int> vals;
                for (int sz = q.size(); sz; --sz) {
                    TreeNode* node = q.front(); q.pop();
                    vals.push_back(node->val);
                    if (node->left) q.push(node->left);
                    if (node->right) q.push(node->right);
                }
                if (tf) reverse(vals.begin(), vals.end());
                ans.push_back(vals);
            }
        }
        return ans;
    }


    /*104. Maximum Depth of Binary Tree (Easy)
    Given the root of a binary tree, return its maximum depth. A binary tree's
    maximum depth is the number of nodes along the longest path from the root
    node down to the farthest leaf node.

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
    Output: 3

    Example 2:
    Input: root = [1,null,2]
    Output: 2

    Example 3:
    Input: root = []
    Output: 0

    Example 4:
    Input: root = [0]
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * -100 <= Node.val <= 100*/

    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }


    /*105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)
    Given two integer arrays preorder and inorder where preorder is the
    preorder traversal of a binary tree and inorder is the inorder traversal of
    the same tree, construct and return the binary tree.

    Example 1:
    Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
    Output: [3,9,20,null,null,15,7]

    Example 2:
    Input: preorder = [-1], inorder = [-1]
    Output: [-1]

    Constraints:
    * 1 <= preorder.length <= 3000
    * inorder.length == preorder.length
    * -3000 <= preorder[i], inorder[i] <= 3000
    * preorder and inorder consist of unique values.
    * Each value of inorder also appears in preorder.
    * preorder is guaranteed to be the preorder traversal of the tree.
    * inorder is guaranteed to be the inorder traversal of the tree.*/

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int, int> loc;
        for (int i = 0; i < inorder.size(); ++i) loc[inorder[i]] = i;
        TreeNode *root = nullptr, *node = nullptr;
        stack<TreeNode*> stk;
        for (auto& x : preorder)
            if (!root) node = root = new TreeNode(x);
            else if (loc[x] < loc[node->val]) {
                stk.push(node);
                node = node->left = new TreeNode(x);
            } else {
                while (stk.size() && loc[stk.top()->val] < loc[x]) node = stk.top(), stk.pop();
                node = node->right = new TreeNode(x);
            }
        return root;
    }


    /*106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)
    Given two integer arrays inorder and postorder where inorder is the inorder
    traversal of a binary tree and postorder is the postorder traversal of the
    same tree, construct and return the binary tree.

    Example 1:
    Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
    Output: [3,9,20,null,null,15,7]

    Example 2:
    Input: inorder = [-1], postorder = [-1]
    Output: [-1]

    Constraints:
    * 1 <= inorder.length <= 3000
    * postorder.length == inorder.length
    * -3000 <= inorder[i], postorder[i] <= 3000
    * inorder and postorder consist of unique values.
    * Each value of postorder also appears in inorder.
    * inorder is guaranteed to be the inorder traversal of the tree.
    * postorder is guaranteed to be the postorder traversal of the tree.*/

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        unordered_map<int, int> mp;
        for (int i = 0; i < inorder.size(); ++i) mp[inorder[i]] = i;

        stack<TreeNode*> stk;
        TreeNode *root = nullptr, *node = nullptr;
        for (int i = postorder.size()-1; i >= 0; --i) {
            int x = postorder[i];
            if (!root) root = node = new TreeNode(x);
            else if (mp[node->val] < mp[x]) {
                stk.push(node);
                node = node->right = new TreeNode(x);
            } else {
                while (stk.size() && mp[x] < mp[stk.top()->val]) node = stk.top(), stk.pop();
                node = node->left = new TreeNode(x);
            }
        }
        return root;
    }


    /*108. Convert Sorted Array to Binary Search Tree (Easy)
    Given an integer array nums where the elements are sorted in ascending
    order, convert it to a height-balanced binary search tree. A height-
    balanced binary tree is a binary tree in which the depth of the two
    subtrees of every node never differs by more than one.

    Example 1:
    Input: nums = [-10,-3,0,5,9]
    Output: [0,-3,9,-10,null,5]
    Explanation: [0,-10,5,null,-3,null,9] is also accepted:

    Example 2:
    Input: nums = [1,3]
    Output: [3,1]
    Explanation: [1,3] and [3,1] are both a height-balanced BSTs.

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^4 <= nums[i] <= 10^4
    * nums is sorted in a strictly increasing order.*/

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode *root = nullptr;
        stack<tuple<TreeNode*, int, int, bool>> stk;
        stk.emplace(root, 0, nums.size(), false);
        while (stk.size()) {
            auto [node, lo, hi, tf] = stk.top(); stk.pop();
            if (lo < hi) {
                int mid = (lo+hi)/2;
                if (!root) node = root = new TreeNode(nums[mid]);
                else if (tf) node = node->right = new TreeNode(nums[mid]);
                else node = node->left = new TreeNode(nums[mid]);
                stk.emplace(node, lo, mid, false);
                stk.emplace(node, mid+1, hi, true);
            }
        }
        return root;
    }


    /*110. Balanced Binary Tree (Easy)
    Given a binary tree, determine if it is height-balanced.

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
        3
       / \
      9  20
        /  \
       15   7
    Output: true

    Example 2:
    Input: root = [1,2,2,3,3,null,null,4,4]
           1
          / \
         2   2
        / \
       3   3
      / \
     4   4
    Output: false

    Example 3:
    Input: root = []
    Output: true

    Constraints:
    * The number of nodes in the tree is in the range [0, 5000].
    * -10^4 <= Node.val <= 10^4*/

    bool isBalanced(TreeNode* root) {
        unordered_map<TreeNode*, pair<bool, int>> mp = {{nullptr, {true, 0}}};
        TreeNode *node = root, *prev = nullptr;
        stack<TreeNode*> stk;
        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top();
                if (node->right && node->right != prev) node = node->right;
                else {
                    auto [b0, d0] = mp[node->left];
                    auto [b1, d1] = mp[node->right];
                    mp[node] = make_pair(b0 && b1 && abs(d0-d1) <= 1, 1 + max(d0, d1));
                    stk.pop();
                    prev = node;
                    node = nullptr;
                }
            }
        return mp[root].first;
    }


    /*111. Minimum Depth of Binary Tree (Easy)
    Given a binary tree, find its minimum depth. The minimum depth is the
    number of nodes along the shortest path from the root node down to the
    nearest leaf node. Note that a leaf is a node with no children.

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
    Output: 2

    Example 2:
    Input: root = [2,null,3,null,4,null,5,null,6]
    Output: 5

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^5].
    * -1000 <= Node.val <= 1000*/

    int minDepth(TreeNode* root) {
        if (!root) return 0;
        int left = minDepth(root->left), right = minDepth(root->right);
        return left && right ? 1 + min(left, right) : 1 + max(left, right);
    }


    /*112. Path Sum (Easy)
    Given the root of a binary tree and an integer targetSum, return true if
    the tree has a root-to-leaf path such that adding up all the values along
    the path equals targetSum. A leaf is a node with no children.

    Example 1:
    Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
    Output: true

    Example 2:
    Input: root = [1,2,3], targetSum = 5
    Output: false

    Example 3:
    Input: root = [1,2], targetSum = 0
    Output: false

    Constraints:
    * The number of nodes in the tree is in the range [0, 5000].
    * -1000 <= Node.val <= 1000
    * -1000 <= targetSum <= 1000*/

    bool hasPathSum(TreeNode* root, int targetSum) {
        stack<pair<TreeNode*, int>> stk;
        stk.emplace(root, 0);
        while (stk.size()) {
            auto [node, val] = stk.top(); stk.pop();
            if (node) {
                val += node->val;
                if (!node->left && !node->right && val == targetSum) return true;
                stk.emplace(node->right, val);
                stk.emplace(node->left, val);
            }
        }
        return false;
    }


    /*113. Path Sum II (Medium)
    Given the root of a binary tree and an integer targetSum, return all root-
    to-leaf paths where each path's sum equals targetSum. A leaf is a node with
    no children.

    Example 1:
    Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
    Output: [[5,4,11,2],[5,8,4,5]]

    Example 2:
    Input: root = [1,2,3], targetSum = 5
    Output: []

    Example 3:
    Input: root = [1,2], targetSum = 0
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 5000].
    * -1000 <= Node.val <= 1000
    * -1000 <= targetSum <= 1000*/

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        vector<vector<int>> ans;
        if (root) {
            unordered_map<TreeNode*, TreeNode*> parent = {{root, nullptr}};
            stack<pair<TreeNode*, int>> stk;
            stk.emplace(root, 0);
            while (stk.size()) {
                auto [node, sm] = stk.top(); stk.pop();
                sm += node->val;
                if (!node->left && !node->right) {
                    if (sm == targetSum) {
                        vector<int> vals;
                        for (; node; node = parent[node])
                            vals.push_back(node->val);
                        reverse(vals.begin(), vals.end());
                        ans.push_back(vals);
                    }
                } else {
                    if (node->left) {
                        parent[node->left] = node;
                        stk.emplace(node->left, sm);
                    }
                    if (node->right) {
                        parent[node->right] = node;
                        stk.emplace(node->right, sm);
                    }
                }
            }
        }
        return ans;
    }


    /*114. Flatten Binary Tree to Linked List (Medium)
    Given the root of a binary tree, flatten the tree into a "linked list":
    * The "linked list" should use the same TreeNode class where the right
      child pointer points to the next node in the list and the left child
      pointer is always null.
    * The "linked list" should be in the same order as a pre-order traversal of
      the binary tree.

    Example 1:
    Input: root = [1,2,5,3,4,null,6]
    Output: [1,null,2,null,3,null,4,null,5,null,6]

    Example 2:
    Input: root = []
    Output: []

    Example 3:
    Input: root = [0]
    Output: [0]

    Constraints:
    * The number of nodes in the tree is in the range [0, 2000].
    * -100 <= Node.val <= 100

    Follow up: Can you flatten the tree in-place (with O(1) extra space)?*/

    void flatten(TreeNode* root) {

        function<TreeNode*(TreeNode*, TreeNode*)> fn = [&fn](TreeNode* node, TreeNode* tail) {
            if (!node) return tail;
            node->right = fn(node->left, fn(node->right, tail));
            node->left = NULL;
            return node;
        };

        fn(root, NULL);
    }


    /*115. Distinct Subsequences (Hard)
    Given two strings s and t, return the number of distinct subsequences of s
    which equals t. A string's subsequence is a new string formed from the
    original string by deleting some (can be none) of the characters without
    disturbing the remaining characters' relative positions. (i.e., "ACE" is a
    subsequence of "ABCDE" while "AEC" is not). It is guaranteed the answer
    fits on a 32-bit signed integer.

    Example 1:
    Input: s = "rabbbit", t = "rabbit"
    Output: 3
    Explanation: As shown below, there are 3 ways you can generate "rabbit"
                 from S.
                 rabbbit
                 rabbbit
                 rabbbit

    Example 2:
    Input: s = "babgbag", t = "bag"
    Output: 5
    Explanation: As shown below, there are 5 ways you can generate "bag" from S.
                 babgbag
                 babgbag
                 babgbag
                 babgbag
                 babgbag

    Constraints:
    * 1 <= s.length, t.length <= 1000
    * s and t consist of English letters.*/

    int numDistinct(string s, string t) {
        int m = s.size(), n = t.size();

        unordered_map<char, vector<int>> loc;
        for (int i = 0; i < n; ++i) loc[t[i]].push_back(i);

        vector<unsigned> ans(n+1); // unsigned int "cannot" overflow
        ans[n] = 1;

        for (int i = m-1; i >= 0; --i)
            for (auto& k : loc[s[i]])
                ans[k] += ans[k+1];
        return ans[0];
    }


    /*116. Populating Next Right Pointers in Each Node (Medium)
    You are given a perfect binary tree where all leaves are on the same level,
    and every parent has two children. The binary tree has the following
    definition:
        struct Node {
          int val;
          Node *left;
          Node *right;
          Node *next;
        }
    Populate each next pointer to point to its next right node. If there is no
    next right node, the next pointer should be set to NULL. Initially, all
    next pointers are set to NULL.

    Example 1:
    Input: root = [1,2,3,4,5,6,7]
    Output: [1,#,2,3,#,4,5,6,7,#]
    Explanation: Given the above perfect binary tree (Figure A), your function
                 should populate each next pointer to point to its next right
                 node, just like in Figure B. The serialized output is in level
                 order as connected by the next pointers, with '#' signifying
                 the end of each level.

    Example 2:
    Input: root = []
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 2^12 - 1].
    * -1000 <= Node.val <= 1000

    Follow-up:
    * You may only use constant extra space.
    * The recursive approach is fine. You may assume implicit stack space does
      not count as extra space for this problem.*/

    Node* connect(Node* root) {
        Node* head = root;
        while (head && head->left) {
            for (Node* node = head; node; node = node->next) {
                node->left->next = node->right;
                if (node->next) node->right->next = node->next->left;
            }
            head = head->left;
        }
        return root;
    }


    /*117. Populating Next Right Pointers in Each Node II (Medium)
    Given a binary tree
        struct Node {
          int val;
          Node *left;
          Node *right;
          Node *next;
        }
    Populate each next pointer to point to its next right node. If there is no
    next right node, the next pointer should be set to NULL. Initially, all
    next pointers are set to NULL.

    Example 1:
    Input: root = [1,2,3,4,5,null,7]
    Output: [1,#,2,3,#,4,5,7,#]
    Explanation: Given the above binary tree (Figure A), your function should
                 populate each next pointer to point to its next right node,
                 just like in Figure B. The serialized output is in level order
                 as connected by the next pointers, with '#' signifying the end
                 of each level.

    Example 2:
    Input: root = []
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 6000].
    * -100 <= Node.val <= 100

    Follow-up:
    * You may only use constant extra space.
    * The recursive approach is fine. You may assume implicit stack space does
      not count as extra space for this problem.*/

    Node* connect(Node* root) {
        Node *head = root;
        while (head) {
            Node *node = head, *prev = nullptr, *next = nullptr;
            while (node) {
                if (node->left)
                    if (prev) prev = prev->next = node->left;
                    else prev = next = node->left;
                if (node->right)
                    if (prev) prev = prev->next = node->right;
                    else prev = next = node->right;
                node = node->next;
            }
            head = next;
        }
        return root;
    }


    /*118. Pascal's Triangle (Easy)
    Given an integer numRows, return the first numRows of Pascal's triangle. In
    Pascal's triangle, each number is the sum of the two numbers directly above
    it as shown:

    Example 1:
    Input: numRows = 5
    Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

    Example 2:
    Input: numRows = 1
    Output: [[1]]

    Constraints: 1 <= numRows <= 30*/

    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> ans;
        vector<int> row;
        for (int i = 0; i < numRows; ++i) {
            row.push_back(1);
            for (int j = i-1; j >= 1; --j) row[j] += row[j-1];
            ans.push_back(row);
        }
        return ans;
    }


    /*119. Pascal's Triangle II (Easy)
    Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
    Pascal's triangle. In Pascal's triangle, each number is the sum of the two
    numbers directly above it as shown:

    Example 1:
    Input: rowIndex = 3
    Output: [1,3,3,1]

    Example 2:
    Input: rowIndex = 0
    Output: [1]

    Example 3:
    Input: rowIndex = 1
    Output: [1,1]

    Constraints: 0 <= rowIndex <= 33

    Follow up: Could you optimize your algorithm to use only O(rowIndex) extra
               space?*/

    vector<int> getRow(int rowIndex) {
        vector<int> ans;
        for (int i = 0; i <= rowIndex; ++i) {
            ans.push_back(1);
            for (int j = ans.size()-2; j > 0; --j)
                ans[j] += ans[j-1];
        }
        return ans;
    }


    /*120. Triangle (Medium)
    Given a triangle array, return the minimum path sum from top to bottom. For
    each step, you may move to an adjacent number of the row below. More
    formally, if you are on index i on the current row, you may move to either
    index i or index i + 1 on the next row.

    Example 1:
    Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
    Output: 11
    Explanation: The triangle looks like:
       2
      3 4
     6 5 7
    4 1 8 3
    The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).

    Example 2:
    Input: triangle = [[-10]]
    Output: -10

    Constraints:
    * 1 <= triangle.length <= 200
    * triangle[0].length == 1
    * triangle[i].length == triangle[i - 1].length + 1
    * -10^4 <= triangle[i][j] <= 10^4

    Follow up: Could you do this using only O(n) extra space, where n is the
               total number of rows in the triangle?*/

    int minimumTotal(vector<vector<int>>& triangle) {
        vector<int> dp = triangle.back();
        for (int i = triangle.size()-2; i >= 0; --i)
            for (int j = 0; j <= i; ++j)
                dp[j] = triangle[i][j] + min(dp[j], dp[j+1]);
        return dp[0];
    }


    /*121. Best Time to Buy and Sell Stock (Easy)
    You are given an array prices where prices[i] is the price of a given stock
    on the ith day. You want to maximize your profit by choosing a single day
    to buy one stock and choosing a different day in the future to sell that
    stock. Return the maximum profit you can achieve from this transaction. If
    you cannot achieve any profit, return 0.

    Example 1:
    Input: prices = [7,1,5,3,6,4]
    Output: 5
    Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6),
                 profit = 6-1 = 5. Note that buying on day 2 and selling on day
                 1 is not allowed because you must buy before you sell.

    Example 2:
    Input: prices = [7,6,4,3,1]
    Output: 0
    Explanation: In this case, no transactions are done and the max profit = 0.

    Constraints:
    * 1 <= prices.length <= 10^5
    * 0 <= prices[i] <= 10^4*/

    int maxProfit(vector<int>& prices) {
        int buy = INT_MAX, sell = 0;
        for (auto& x : prices) {
            buy = min(buy, x);
            sell = max(sell, x - buy);
        }
        return sell;
    }


    /*122. Best Time to Buy and Sell Stock II (Medium)
    You are given an integer array prices where prices[i] is the price of a
    given stock on the ith day. On each day, you may decide to buy and/or sell
    the stock. You can only hold at most one share of the stock at any time.
    However, you can buy it then immediately sell it on the same day. Find and
    return the maximum profit you can achieve.

    Example 1:
    Input: prices = [7,1,5,3,6,4]
    Output: 7
    Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5),
                 profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on
                 day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7.

    Example 2:
    Input: prices = [1,2,3,4,5]
    Output: 4
    Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5),
                 profit = 5-1 = 4. Total profit is 4.

    Example 3:
    Input: prices = [7,6,4,3,1]
    Output: 0
    Explanation: There is no way to make a positive profit, so we never buy the
                 stock to achieve the maximum profit of 0.

    Constraints:
    * 1 <= prices.length <= 3 * 10^4
    * 0 <= prices[i] <= 10^4*/

    int maxProfit(vector<int>& prices) {
        // buy low & sell high
        int buy = INT_MAX, sell = 0;
        for (auto& x : prices) {
            buy = min(buy, x - sell);
            sell = max(sell, x - buy);
        }
        return sell;
    }


    /*123. Best Time to Buy and Sell Stock III (Hard)
    You are given an array prices where prices[i] is the price of a given stock
    on the ith day. Find the maximum profit you can achieve. You may complete
    at most two transactions. Note: You may not engage in multiple transactions
    simultaneously (i.e., you must sell the stock before you buy again).

    Example 1:
    Input: prices = [3,3,5,0,0,3,1,4]
    Output: 6
    Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3),
                 profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on
                 day 8 (price = 4), profit = 4-1 = 3.

    Example 2:
    Input: prices = [1,2,3,4,5]
    Output: 4
    Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5),
                 profit = 5-1 = 4. Note that you cannot buy on day 1, buy on
                 day 2 and sell them later, as you are engaging multiple
                 transactions at the same time. You must sell before buying
                 again.

    Example 3:
    Input: prices = [7,6,4,3,1]
    Output: 0
    Explanation: In this case, no transaction is done, i.e. max profit = 0.

    Example 4:
    Input: prices = [1]
    Output: 0

    Constraints:
    * 1 <= prices.length <= 10^5
    * 0 <= prices[i] <= 10^5*/

    int maxProfit(vector<int>& prices) {
        // buy low & sell high
        vector<int> buy(2, INT_MAX), sell(2);
        for (auto& x : prices)
            for (int i = 0; i < 2; ++i) {
                if (i) buy[i] = min(buy[i], x - sell[i-1]);
                else buy[i] = min(buy[i], x);
                sell[i] = max(sell[i], x - buy[i]);
            }
        return sell.back();
    }


    /*126. Word Ladder II (Hard)
    A transformation sequence from word beginWord to word endWord using a
    dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... ->
    sk such that:
    * Every adjacent pair of words differs by a single letter.
    * Every si for 1 <= i <= k is in wordList. Note that beginWord does not
      need to be in wordList.
    * sk == endWord
    Given two words, beginWord and endWord, and a dictionary wordList, return
    all the shortest transformation sequences from beginWord to endWord, or an
    empty list if no such sequence exists. Each sequence should be returned as
    a list of the words [beginWord, s1, s2, ..., sk].

    Example 1:
    Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
    Output: [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
    Explanation: There are 2 shortest transformation sequences:
                 "hit" -> "hot" -> "dot" -> "dog" -> "cog"
                 "hit" -> "hot" -> "lot" -> "log" -> "cog"

    Example 2:
    Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
    Output: []
    Explanation: The endWord "cog" is not in wordList, therefore there is no
                 valid transformation sequence.

    Constraints:
    * 1 <= beginWord.length <= 5
    * endWord.length == beginWord.length
    * 1 <= wordList.length <= 1000
    * wordList[i].length == beginWord.length
    * beginWord, endWord, and wordList[i] consist of lowercase English letters.
    * beginWord != endWord
    * All the words in wordList are unique.*/

    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        auto it = find(wordList.begin(), wordList.end(), endWord);
        if (it == wordList.end()) return {};

        unordered_map<string, vector<string>> graph;
        for (auto& word : wordList)
            for (int i = 0; i < word.size(); ++i) {
                string key = word.substr(0, i) + "*" + word.substr(i+1);
                graph[key].push_back(word);
            }

        queue<string> q;
        q.push(beginWord);
        unordered_map<string, unordered_set<string>> prev({{beginWord, {}}});

        while (q.size()) {
            unordered_map<string, unordered_set<string>> pp;
            for (int n = q.size(); n; --n) {
                string w = q.front(); q.pop();
                for (int i = 0; i < w.size(); ++i) {
                    string key = w.substr(0, i) + "*" + w.substr(i+1);
                    for (auto& ww : graph[key])
                        if (!prev.count(ww)) {
                            q.push(ww);
                            pp[ww].insert(w);
                        }
                }
            }
            for (auto& [k, v] : pp) prev[k] = v;
            if (prev.count(endWord)) break;
        }

        if (!prev.count(endWord)) return {};

        vector<vector<string>> ans = {{endWord}};
        while (prev[ans[0].back()].size()) {
            vector<vector<string>> newq;
            for (auto& x : ans)
                for (auto& ww : prev[x.back()]) {
                    vector<string> xx = x;
                    xx.push_back(ww);
                    newq.push_back(xx);
                }
            ans = newq;
        }
        for (auto& x : ans) reverse(x.begin(), x.end());
        return ans;
    }


    /*127. Word Ladder (Hard)
    A transformation sequence from word beginWord to word endWord using a
    dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ...
    -> sk such that:
    * Every adjacent pair of words differs by a single letter.
    * Every si for 1 <= i <= k is in wordList. Note that beginWord does not
      need to be in wordList.
    * sk == endWord
    Given two words, beginWord and endWord, and a dictionary wordList, return
    the number of words in the shortest transformation sequence from beginWord
    to endWord, or 0 if no such sequence exists.

    Example 1:
    Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
    Output: 5
    Explanation: One shortest transformation sequence is "hit" -> "hot" ->
                 "dot" -> "dog" -> cog", which is 5 words long.

    Example 2:
    Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
    Output: 0
    Explanation: The endWord "cog" is not in wordList, therefore there is no
                 valid transformation sequence.

    Constraints:
    * 1 <= beginWord.length <= 10
    * endWord.length == beginWord.length
    * 1 <= wordList.length <= 5000
    * wordList[i].length == beginWord.length
    * beginWord, endWord, and wordList[i] consist of lowercase English letters.
    * beginWord != endWord
    * All the words in wordList are unique.*/

    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_map<string, vector<string>> mp;
        for (auto& word : wordList)
            for (int i = 0; i < word.size(); ++i) {
                string key = word.substr(0, i) + "*" + word.substr(i+1);
                mp[key].push_back(word);
            }
        int ans = 1;
        deque<string> q; q.push_back(beginWord);
        unordered_set<string> seen = {beginWord};
        for (; q.size(); ++ans)
            for (int sz = q.size(); sz; --sz) {
                string word = q.front(); q.pop_front();
                if (word == endWord) return ans;
                for (int i = 0; i < word.size(); i++) {
                    string key = word.substr(0, i) + "*" + word.substr(i+1);
                    for (auto& w : mp[key])
                        if (!seen.count(w)) {
                            q.push_back(w);
                            seen.insert(w);
                        }
                }
            }
        return 0;
    }


    /*128. Longest Consecutive Sequence (Medium)
    Given an unsorted array of integers nums, return the length of the longest
    consecutive elements sequence. You must write an algorithm that runs in O(n)
    time.

    Example 1:
    Input: nums = [100,4,200,1,3,2]
    Output: 4
    Explanation: The longest consecutive elements sequence is [1, 2, 3, 4].
                 Therefore its length is 4.

    Example 2:
    Input: nums = [0,3,7,2,5,8,4,6,0,1]
    Output: 9

    Constraints:
    * 0 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> seen (begin(nums), end(nums));
        int ans = 0;
        for (auto& x : nums) {
            if (!seen.count(x-1)) {
                int xx = x+1;
                while (seen.count(xx)) ++xx;
                ans = max(ans, xx-x);
            }
        }
        return ans;
    }


    /*129. Sum Root to Leaf Numbers (Medium)
    You are given the root of a binary tree containing digits from 0 to 9 only.
    Each root-to-leaf path in the tree represents a number. For example, the
    root-to-leaf path 1 -> 2 -> 3 represents the number 123. Return the total
    sum of all root-to-leaf numbers. Test cases are generated so that the
    answer will fit in a 32-bit integer. A leaf node is a node with no children.

    Example 1:
    Input: root = [1,2,3]
    Output: 25
    Explanation: The root-to-leaf path 1->2 represents the number 12.
                 The root-to-leaf path 1->3 represents the number 13.
                 Therefore, sum = 12 + 13 = 25.

    Example 2:
    Input: root = [4,9,0,5,1]
    Output: 1026
    Explanation: The root-to-leaf path 4->9->5 represents the number 495.
                 The root-to-leaf path 4->9->1 represents the number 491.
                 The root-to-leaf path 4->0 represents the number 40.
                 Therefore, sum = 495 + 491 + 40 = 1026.

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * 0 <= Node.val <= 9
    * The depth of the tree will not exceed 10.*/

    int sumNumbers(TreeNode* root) {
        int ans = 0;
        stack<pair<TreeNode*, int>> stk;
        stk.emplace(root, 0);
        while (stk.size()) {
            auto [node, val] = stk.top(); stk.pop();
            val = 10*val + node->val;
            if (!node->left && !node->right) ans += val;
            if (node->left) stk.emplace(node->left, val);
            if (node->right) stk.emplace(node->right, val);
        }
        return ans;
    }


    /*130. Surrounded Regions (Medium)
    Given an m x n matrix board containing 'X' and 'O', capture all regions
    that are 4-directionally surrounded by 'X'. A region is captured by
    flipping all 'O's into 'X's in that surrounded region.

    Example 1:
    Input: board = [["X","X","X","X"],
                    ["X","O","O","X"],
                    ["X","X","O","X"],
                    ["X","O","X","X"]]
    Output: [["X","X","X","X"],
             ["X","X","X","X"],
             ["X","X","X","X"],
             ["X","O","X","X"]]
    Explanation: Surrounded regions should not be on the border, which means
                 that any 'O' on the border of the board are not flipped to
                 'X'. Any 'O' that is not on the border and it is not connected
                 to an 'O' on the border will be flipped to 'X'. Two cells are
                 connected if they are adjacent cells connected horizontally or
                 vertically.

    Example 2:
    Input: board = [["X"]]
    Output: [["X"]]

    Constraints:
    * m == board.length
    * n == board[i].length
    * 1 <= m, n <= 200
    * board[i][j] is 'X' or 'O'.*/

    void solve(vector<vector<char>>& board) {
        int m = board.size(), n = board[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        stack<pair<int, int>> stk;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if ((i == 0 || i == m-1 || j == 0 || j == n-1) && board[i][j] == 'O') {
                    stk.emplace(i, j);
                    board[i][j] = '#';
                }

        while (stk.size()) {
            auto [i, j] = stk.top(); stk.pop();
            for (int k = 0; k < 4; ++k) {
                int ii = i + dir[k], jj = j + dir[k+1];
                if (0 <= ii && ii < m && 0 <= jj && jj < n && board[ii][jj] == 'O') {
                    stk.emplace(ii, jj);
                    board[ii][jj] = '#';
                }
            }
        }

        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (board[i][j] == 'O') board[i][j] = 'X';
                else if (board[i][j] == '#') board[i][j] = 'O';
    }


    /*131. Palindrome Partitioning (Medium)
    Given a string s, partition s such that every substring of the partition is
    a palindrome. Return all possible palindrome partitioning of s.

    Example 1:
    Input: s = "aab"
    Output: [["a","a","b"],["aa","b"]]

    Example 2:
    Input: s = "a"
    Output: [["a"]]

    Constraints:
    * 1 <= s.length <= 16
    * s contains only lowercase English letters.*/

    vector<vector<string>> partition(string s) {
        int n = s.size();
        vector<int> part[n];
        for (int i = 0; i < 2*n-1; ++i)
            for (int lo = i/2, hi = (i+1)/2; 0 <= lo && hi < n && s[lo] == s[hi]; --lo, ++hi)
                part[lo].push_back(hi+1);
        vector<vector<string>> ans;

        function<void(int, vector<string>&)> fn = [&](int i, vector<string>& seq) {
            if (i == n) ans.push_back(seq);
            else
                for (auto& j : part[i]) {
                    seq.push_back(s.substr(i, j-i));
                    fn(j, seq);
                    seq.pop_back();
                }
        };

        vector<string> seq;
        fn(0, seq);
        return ans;
    }


    /*133. Clone Graph (Medium)
    Given a reference of a node in a connected undirected graph. Return a deep
    copy (clone) of the graph. Each node in the graph contains a value (int)
    and a list (List[Node]) of its neighbors.

    class Node {
        public int val;
        public List<Node> neighbors;
    }

    Test case format:
    For simplicity, each node's value is the same as the node's index (1-
    indexed). For example, the first node with val == 1, the second node with
    val == 2, and so on. The graph is represented in the test case using an
    adjacency list. An adjacency list is a collection of unordered lists used
    to represent a finite graph. Each list describes the set of neighbors of a
    node in the graph. The given node will always be the first node with
    val = 1. You must return the copy of the given node as a reference to the
    cloned graph.

    Example 1:
    Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
    Output: [[2,4],[1,3],[2,4],[1,3]]
    Explanation: There are 4 nodes in the graph.
    1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
    2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
    3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
    4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).

    Example 2:
    Input: adjList = [[]]
    Output: [[]]
    Explanation: Note that the input contains one empty list. The graph
                 consists of only one node with val = 1 and it does not have
                 any neighbors.

    Example 3:
    Input: adjList = []
    Output: []
    Explanation: This an empty graph, it does not have any nodes.

    Constraints:
    * The number of nodes in the graph is in the range [0, 100].
    * 1 <= Node.val <= 100
    * Node.val is unique for each node.
    * There are no repeated edges and no self-loops in the graph.
    * The Graph is connected and all nodes can be visited starting from the
      given node.*/

    Node* cloneGraph(Node* node) {
        unordered_map<Node*, Node*> mp;
        if (node) {
            mp[node] = new Node(node->val);
            stack<Node*> stk; stk.push(node);
            unordered_set<Node*> seen = {node};
            while (stk.size()) {
                Node* n = stk.top(); stk.pop();
                for (auto& nn : n->neighbors) {
                    if (!mp[nn]) mp[nn] = new Node(nn->val);
                    mp[n]->neighbors.push_back(mp[nn]);
                    if (!seen.count(nn)) {
                        stk.push(nn);
                        seen.insert(nn);
                    }
                }
            }
        }
        return mp[node];
    }


    /*134. Gas Station (Medium)
    There are n gas stations along a circular route, where the amount of gas at
    the ith station is gas[i]. You have a car with an unlimited gas tank and it
    costs cost[i] of gas to travel from the ith station to its next (i + 1)th
    station. You begin the journey with an empty tank at one of the gas
    stations. Given two integer arrays gas and cost, return the starting gas
    station's index if you can travel around the circuit once in the clockwise
    direction, otherwise return -1. If there exists a solution, it is
    guaranteed to be unique

    Example 1:
    Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
    Output: 3
    Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas.
                 Your tank = 0 + 4 = 4
                 Travel to station 4. Your tank = 4 - 1 + 5 = 8
                 Travel to station 0. Your tank = 8 - 2 + 1 = 7
                 Travel to station 1. Your tank = 7 - 3 + 2 = 6
                 Travel to station 2. Your tank = 6 - 4 + 3 = 5
                 Travel to station 3. The cost is 5. Your gas is just enough to
                 travel back to station 3. Therefore, return 3 as the starting
                 index.

    Example 2:
    Input: gas = [2,3,4], cost = [3,4,3]
    Output: -1
    Explanation: You can't start at station 0 or 1, as there is not enough gas
                 to travel to the next station. Let's start at station 2 and
                 fill up with 4 unit of gas. Your tank = 0 + 4 = 4. Travel to
                 station 0. Your tank = 4 - 3 + 2 = 3. Travel to station 1.
                 Your tank = 3 - 3 + 3 = 3. You cannot travel back to station 2,
                 as it requires 4 unit of gas but you only have 3. Therefore,
                 you can't travel around the circuit once no matter where you
                 start.

    Constraints:
    * gas.length == n
    * cost.length == n
    * 1 <= n <= 10^5
    * 0 <= gas[i], cost[i] <= 10^4*/

    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int ans = 0, prefix = 0;
        for (int i = 0, least = 0; i < gas.size(); ++i) {
            prefix += gas[i] - cost[i];
            if (prefix < least) {
                ans = i+1;
                least = prefix;
            }
        }
        return prefix >= 0 ? ans % gas.size() : -1;
    }


    /*136. Single Number (Easy)
    Given a non-empty array of integers nums, every element appears twice
    except for one. Find that single one. You must implement a solution with a
    linear runtime complexity and use only constant extra space.

    Example 1:
    Input: nums = [2,2,1]
    Output: 1

    Example 2:
    Input: nums = [4,1,2,1,2]
    Output: 4

    Example 3:
    Input: nums = [1]
    Output: 1

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * -3 * 10^4 <= nums[i] <= 3 * 10^4
    * Each element in the array appears twice except for one element which
      appears only once.*/

    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (auto& x : nums) ans ^= x;
        return ans;
    }


    /*138. Copy List with Random Pointer (Medium)
    A linked list of length n is given such that each node contains an
    additional random pointer, which could point to any node in the list, or
    null. Construct a deep copy of the list. The deep copy should consist of
    exactly n brand new nodes, where each new node has its value set to the
    value of its corresponding original node. Both the next and random pointer
    of the new nodes should point to new nodes in the copied list such that the
    pointers in the original list and copied list represent the same list state.
    None of the pointers in the new list should point to nodes in the original
    list. For example, if there are two nodes X and Y in the original list,
    where X.random --> Y, then for the corresponding two nodes x and y in the
    copied list, x.random --> y. Return the head of the copied linked list.
    The linked list is represented in the input/output as a list of n nodes.
    Each node is represented as a pair of [val, random_index] where:
    * val: an integer representing Node.val
    * random_index: the index of the node (range from 0 to n-1) that the random
      pointer points to, or null if it does not point to any node.
    Your code will only be given the head of the original linked list.

    Example 1:
    Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
    Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]

    Example 2:
    Input: head = [[1,1],[2,1]]
    Output: [[1,1],[2,1]]

    Example 3:
    Input: head = [[3,null],[3,0],[3,null]]
    Output: [[3,null],[3,0],[3,null]]

    Constraints:
    * 0 <= n <= 1000
    * -10^4 <= Node.val <= 10^4
    * Node.random is null or is pointing to some node in the linked list.*/

    Node* copyRandomList(Node* head) {
        unordered_map<Node*, Node*> mp = {{nullptr, nullptr}};
        for (Node* node = head; node; node = node->next)
            mp[node] = new Node(node->val);
        for (Node* node = head; node; node = node->next) {
            mp[node]->next = mp[node->next];
            mp[node]->random = mp[node->random];
        }
        return mp[head];
    }


    /*139. Word Break (Medium)
    Given a string s and a dictionary of strings wordDict, return true if s can
    be segmented into a space-separated sequence of one or more dictionary
    words. Note that the same word in the dictionary may be reused multiple
    times in the segmentation.

    Example 1:
    Input: s = "leetcode", wordDict = ["leet","code"]
    Output: true
    Explanation: Return true because "leetcode" can be segmented as "leet code".

    Example 2:
    Input: s = "applepenapple", wordDict = ["apple","pen"]
    Output: true
    Explanation: Return true because "applepenapple" can be segmented as "apple
                 pen apple". Note that you are allowed to reuse a dictionary
                 word.

    Example 3:
    Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
    Output: false

    Constraints:
    * 1 <= s.length <= 300
    * 1 <= wordDict.length <= 1000
    * 1 <= wordDict[i].length <= 20
    * s and wordDict[i] consist of only lowercase English letters.
    * All the strings of wordDict are unique.*/

    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.size();
        vector<int> dp(n+1);
        dp[n] = true;
        for (int i = n; i >= 0; --i)
            if (dp[i])
                for (auto& word : wordDict)
                    if (word.size() <= i && s.substr(i-word.size(), word.size()) == word) dp[i-word.size()] = true;
        return dp[0];
    }


    /*141. Linked List Cycle (Easy)
    Given head, the head of a linked list, determine if the linked list has a
    cycle in it. There is a cycle in a linked list if there is some node in the
    list that can be reached again by continuously following the next pointer.
    Internally, pos is used to denote the index of the node that tail's next
    pointer is connected to. Note that pos is not passed as a parameter. Return
    true if there is a cycle in the linked list. Otherwise, return false.

    Example 1:
    Input: head = [3,2,0,-4], pos = 1
    Output: true
    Explanation: There is a cycle in the linked list, where the tail connects
                 to the 1st node (0-indexed).

    Example 2:
    Input: head = [1,2], pos = 0
    Output: true
    Explanation: There is a cycle in the linked list, where the tail connects
                 to the 0th node.

    Example 3:
    Input: head = [1], pos = -1
    Output: false
    Explanation: There is no cycle in the linked list.

    Constraints:
    * The number of the nodes in the list is in the range [0, 10^4].
    * -10^5 <= Node.val <= 10^5
    * pos is -1 or a valid index in the linked-list.

    Follow up: Can you solve it using O(1) (i.e. constant) memory?*/

    bool hasCycle(ListNode *head) {
        ListNode *fast = head, *slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) return true;
        }
        return false;
    }


    /*142. Linked List Cycle II (Medium)
    Given the head of a linked list, return the node where the cycle begins. If
    there is no cycle, return null. There is a cycle in a linked list if there
    is some node in the list that can be reached again by continuously
    following the next pointer. Internally, pos is used to denote the index of
    the node that tail's next pointer is connected to (0-indexed). It is -1 if
    there is no cycle. Note that pos is not passed as a parameter. Do not
    modify the linked list.

    Example 1:
    Input: head = [3,2,0,-4], pos = 1
    Output: tail connects to node index 1
    Explanation: There is a cycle in the linked list, where tail connects to
                 the second node.

    Example 2:
    Input: head = [1,2], pos = 0
    Output: tail connects to node index 0
    Explanation: There is a cycle in the linked list, where tail connects to
                 the first node.

    Example 3:
    Input: head = [1], pos = -1
    Output: no cycle
    Explanation: There is no cycle in the linked list.

    Constraints:
    * The number of the nodes in the list is in the range [0, 10^4].
    * -10^5 <= Node.val <= 10^5
    * pos is -1 or a valid index in the linked-list.

    Follow up: Can you solve it using O(1) (i.e. constant) memory?*/

    ListNode *detectCycle(ListNode *head) {
        for (ListNode *fast = head, *slow = head; fast && fast->next; ) {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) {
                for (fast = head; fast != slow; fast = fast->next, slow = slow->next);
                return slow;
            }
        }
        return nullptr;
    }


    /*143. Reorder List (Medium)
    You are given the head of a singly linked-list. The list can be represented
    as:
    L0 → L1 → … → Ln - 1 → Ln
    Reorder the list to be on the following form:
    L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
    You may not modify the values in the list's nodes. Only nodes themselves
    may be changed.

    Example 1:
    Input: head = [1,2,3,4]
    Output: [1,4,2,3]

    Example 2:
    Input: head = [1,2,3,4,5]
    Output: [1,5,2,4,3]

    Constraints:
    * The number of nodes in the list is in the range [1, 5 * 10^4].
    * 1 <= Node.val <= 1000*/

    void reorderList(ListNode* head) {
        ListNode *fast = head, *slow = head;
        for (; fast && fast->next; fast = fast->next->next, slow = slow->next);

        ListNode *prev = nullptr;
        while (slow)
            tie(slow->next, slow, prev) = make_tuple(prev, slow->next, slow);

        ListNode *node = head;
        while (prev && prev->next) {
            tie(node->next, node) = make_pair(prev, node->next);
            tie(prev->next, prev) = make_pair(node, prev->next);
        }
    }


    /*144. Binary Tree Preorder Traversal (Medium)
    Given the root of a binary tree, return the preorder traversal of its
    nodes' values.

    Example 1:
    Input: root = [1,null,2,3]
    Output: [1,2,3]

    Example 2:
    Input: root = []
    Output: []

    Example 3:
    Input: root = [1]
    Output: [1]

    Example 4:
    Input: root = [1,2]
    Output: [1,2]

    Example 5:
    Input: root = [1,null,2]
    Output: [1,2]

    Constraints:
    * The number of nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100

    Follow up: Recursive solution is trivial, could you do it iteratively?*/

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> stk; stk.push(root);
        while (stk.size()) {
            TreeNode* node = stk.top(); stk.pop();
            if (node) {
                ans.push_back(node->val);
                stk.push(node->right);
                stk.push(node->left);
            }
        }
        return ans;
    }


    /*145. Binary Tree Postorder Traversal (Medium)
    Given the root of a binary tree, return the postorder traversal of its
    nodes' values.

    Example 1:
    Input: root = [1,null,2,3]
    Output: [3,2,1]

    Example 2:
    Input: root = []
    Output: []

    Example 3:
    Input: root = [1]
    Output: [1]

    Example 4:
    Input: root = [1,2]
    Output: [2,1]

    Example 5:
    Input: root = [1,null,2]
    Output: [2,1]

    Constraints:
    * The number of the nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100

    Follow up: Recursive solution is trivial, could you do it iteratively?*/

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        TreeNode *node = root, *prev = nullptr;
        stack<TreeNode*> stk;
        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top();
                if (node->right && prev != node->right) node = node->right;
                else {
                    ans.push_back(node->val);
                    stk.pop();
                    prev = node;
                    node = nullptr;
                }
            }
        return ans;
    }


    /*147. Insertion Sort List (Medium)
    Given the head of a singly linked list, sort the list using insertion sort,
    and return the sorted list's head. The steps of the insertion sort
    algorithm:
    * Insertion sort iterates, consuming one input element each repetition and
      growing a sorted output list.
    * At each iteration, insertion sort removes one element from the input data,
      finds the location it belongs within the sorted list and inserts it there.
    * It repeats until no input elements remain.
    The following is a graphical example of the insertion sort algorithm. The
    partially sorted list (black) initially contains only the first element in
    the list. One element (red) is removed from the input data and inserted in-
    place into the sorted list with each iteration.

    Example 1:
    Input: head = [4,2,1,3]
    Output: [1,2,3,4]

    Example 2:
    Input: head = [-1,5,3,4,0]
    Output: [-1,0,3,4,5]

    Constraints:
    * The number of nodes in the list is in the range [1, 5000].
    * -5000 <= Node.val <= 5000*/

    ListNode* insertionSortList(ListNode* head) {
        ListNode dummy(INT_MIN, head), *node = &dummy;
        while (node->next) {
            if (node->val <= node->next->val) node = node->next;
            else {
                ListNode *temp = node->next, *prev = &dummy;
                while (prev->next->val <= temp->val) prev = prev->next;
                node->next = node->next->next;
                temp->next = prev->next;
                prev->next = temp;
            }
        }
        return dummy.next;
    }


    /*148. Sort List (Medium)
    Given the head of a linked list, return the list after sorting it in
    ascending order.

    Example 1:
    Input: head = [4,2,1,3]
    Output: [1,2,3,4]

    Example 2:
    Input: head = [-1,5,3,4,0]
    Output: [-1,0,3,4,5]

    Example 3:
    Input: head = []
    Output: []

    Constraints:
    * The number of nodes in the list is in the range [0, 5 * 10^4].
    * -10^5 <= Node.val <= 10^5

    Follow up: Can you sort the linked list in O(n logn) time and O(1) memory
               (i.e. constant space)?*/

    ListNode* sortList(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode *fast = head, *prev = head, *slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            prev = slow;
            slow = slow->next;
        }
        prev->next = nullptr;
        ListNode *l1 = sortList(head), *l2 = sortList(slow), dummy, *node = &dummy;
        while (l1 && l2) {
            if (l1->val > l2->val) swap(l1, l2);
            node = node->next = l1;
            l1 = l1->next;
        }
        node->next = l1 ? l1 : l2;
        return dummy.next;
    }


    /*149. Max Points on a Line (Hard)
    Given an array of points where points[i] = [xi, yi] represents a point on
    the X-Y plane, return the maximum number of points that lie on the same
    straight line.

    Example 1:
    Input: points = [[1,1],[2,2],[3,3]]
    Output: 3

    Example 2:
    Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
    Output: 4

    Constraints:
    * 1 <= points.length <= 300
    * points[i].length == 2
    * -10^4 <= xi, yi <= 10^4
    * All the points are unique.*/

    int maxPoints(vector<vector<int>>& points) {
        int ans = 1;
        for (int i = 0; i < points.size(); ++i) {
            map<pair<int, int>, int> freq;
            for (int j = i+1; j < points.size(); ++j) {
                int dx = points[j][0] - points[i][0], dy = points[j][1] - points[i][1], g = gcd(dx, dy);
                dx /= g, dy /= g;
                if (dx < 0 || dx == 0 && dy < 0) dx *= -1, dy *= -1;
                ans = max(ans, ++freq[{dx, dy}] + 1);
            }
        }
        return ans;
    }


    /*150. Evaluate Reverse Polish Notation (Medium)
    Evaluate the value of an arithmetic expression in Reverse Polish Notation.
    Valid operators are +, -, *, and /. Each operand may be an integer or
    another expression. Note that division between two integers should truncate
    toward zero. It is guaranteed that the given RPN expression is always valid.
    That means the expression would always evaluate to a result, and there will
    not be any division by zero operation.

    Example 1:
    Input: tokens = ["2","1","+","3","*"]
    Output: 9
    Explanation: ((2 + 1) * 3) = 9

    Example 2:
    Input: tokens = ["4","13","5","/","+"]
    Output: 6
    Explanation: (4 + (13 / 5)) = 6

    Example 3:
    Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
    Output: 22
    Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
               = ((10 * (6 / (12 * -11))) + 17) + 5
               = ((10 * (6 / -132)) + 17) + 5
               = ((10 * 0) + 17) + 5
               = (0 + 17) + 5
               = 17 + 5
               = 22

    Constraints:
    * 1 <= tokens.length <= 10^4
    * tokens[i] is either an operator: "+", "-", "*", or "/", or an integer in
      the range [-200, 200].*/

    int evalRPN(vector<string>& tokens) {
        stack<int> stk;
        string ops = "+-*/";
        for (auto& token : tokens) {
            if (ops.find(token) != string::npos) {
                int rr = stk.top(); stk.pop();
                int ll = stk.top(); stk.pop();
                if (token == "+") stk.push(ll + rr);
                else if (token == "-") stk.push(ll - rr);
                else if (token == "*") stk.push(ll * rr);
                else stk.push(ll / rr);
            } else
                stk.push(stoi(token));
        }
        return stk.top();
    }


    /*151. Reverse Words in a String (Medium)
    Given an input string s, reverse the order of the words. A word is defined
    as a sequence of non-space characters. The words in s will be separated by
    at least one space. Return a string of the words in reverse order
    concatenated by a single space. Note that s may contain leading or trailing
    spaces or multiple spaces between two words. The returned string should
    only have a single space separating the words. Do not include any extra
    spaces.

    Example 1:
    Input: s = "the sky is blue"
    Output: "blue is sky the"

    Example 2:
    Input: s = "  hello world  "
    Output: "world hello"
    Explanation: Your reversed string should not contain leading or trailing
                 spaces.

    Example 3:
    Input: s = "a good   example"
    Output: "example good a"
    Explanation: You need to reduce multiple spaces between two words to a
                 single space in the reversed string.

    Example 4:
    Input: s = "  Bob    Loves  Alice   "
    Output: "Alice Loves Bob"

    Example 5:
    Input: s = "Alice does not even like bob"
    Output: "bob like even not does Alice"

    Constraints:
    * 1 <= s.length <= 10^4
    * s contains English letters (upper-case and lower-case), digits, and
      spaces ' '.
    * There is at least one word in s.

    Follow-up: If the string data type is mutable in your language, can you
               solve it in-place with O(1) extra space?*/

    string reverseWords(string s) {
        vector<string> words;
        istringstream iss(s);
        string buf, ans;
        while (iss >> buf) words.push_back(buf);
        for (int i = words.size()-1; i >= 0; --i) {
            if (ans.size()) ans.push_back(' ');
            ans += words[i];
        }
        return ans;
    }


    /*152. Maximum Product Subarray (Medium)
    Given an integer array nums, find a contiguous non-empty subarray within
    the array that has the largest product, and return the product. It is
    guaranteed that the answer will fit in a 32-bit integer. A subarray is a
    contiguous subsequence of the array.

    Example 1:
    Input: nums = [2,3,-2,4]
    Output: 6
    Explanation: [2,3] has the largest product 6.

    Example 2:
    Input: nums = [-2,0,-1]
    Output: 0
    Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * -10 <= nums[i] <= 10
    * The product of any prefix or suffix of nums is guaranteed to fit in a
      32-bit integer.*/

    int maxProduct(vector<int>& nums) {
        int ans = INT_MIN, pmin = 1, pmax = 1;
        for (auto& x : nums) {
            if (x < 0) swap(pmin, pmax);
            pmin = min(x, pmin * x);
            pmax = max(x, pmax * x);
            ans = max(ans, pmax);
        }
        return ans;
    }


    /*153. Find Minimum in Rotated Sorted Array (Medium)
    Suppose an array of length n sorted in ascending order is rotated between 1
    and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:
    * [4,5,6,7,0,1,2] if it was rotated 4 times.
    * [0,1,2,4,5,6,7] if it was rotated 7 times.
    Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time
    results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the
    sorted rotated array nums of unique elements, return the minimum element of
    this array. You must write an algorithm that runs in O(log n) time.

    Example 1:
    Input: nums = [3,4,5,1,2]
    Output: 1
    Explanation: The original array was [1,2,3,4,5] rotated 3 times.

    Example 2:
    Input: nums = [4,5,6,7,0,1,2]
    Output: 0
    Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4
                 times.

    Example 3:
    Input: nums = [11,13,15,17]
    Output: 11
    Explanation: The original array was [11,13,15,17] and it was rotated 4
                 times.

    Constraints:
    * n == nums.length
    * 1 <= n <= 5000
    * -5000 <= nums[i] <= 5000
    * All the integers of nums are unique.
    * nums is sorted and rotated between 1 and n times.*/

    int findMin(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1;
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (nums[mid] < nums[hi]) hi = mid;
            else lo = mid + 1;
        }
        return nums[lo];
    }


    /*154. Find Minimum in Rotated Sorted Array II (Hard)
    Suppose an array of length n sorted in ascending order is rotated between 1
    and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:
    * [4,5,6,7,0,1,4] if it was rotated 4 times.
    * [0,1,4,4,5,6,7] if it was rotated 7 times.
    Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time
    results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the
    sorted rotated array nums that may contain duplicates, return the minimum
    element of this array. You must decrease the overall operation steps as
    much as possible.

    Example 1:
    Input: nums = [1,3,5]
    Output: 1

    Example 2:
    Input: nums = [2,2,2,0,1]
    Output: 0

    Constraints:
    * n == nums.length
    * 1 <= n <= 5000
    * -5000 <= nums[i] <= 5000
    * nums is sorted and rotated between 1 and n times.

    Follow up: This problem is similar to Find Minimum in Rotated Sorted Array,
               but nums may contain duplicates. Would this affect the runtime
               complexity? How and why?*/

    int findMin(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1;
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (nums[mid] < nums[hi]) hi = mid;
            else if (nums[mid] == nums[hi]) hi -= 1;
            else lo = mid + 1;
        }
        return nums[lo];
    }


    /*160. Intersection of Two Linked Lists (Easy)
    Given the heads of two singly linked-lists headA and headB, return the node
    at which the two lists intersect. If the two linked lists have no
    intersection at all, return null. The test cases are generated such that
    there are no cycles anywhere in the entire linked structure. Note that the
    linked lists must retain their original structure after the function
    returns.

    Custom Judge:
    The inputs to the judge are given as follows (your program is not given
    these inputs):
    * intersectVal - The value of the node where the intersection occurs. This
      is 0 if there is no intersected node.
    * listA - The first linked list.
    * listB - The second linked list.
    * skipA - The number of nodes to skip ahead in listA (starting from the
      head) to get to the intersected node.
    * skipB - The number of nodes to skip ahead in listB (starting from the
      head) to get to the intersected node.
    The judge will then create the linked structure based on these inputs and
    pass the two heads, headA and headB to your program. If you correctly
    return the intersected node, then your solution will be accepted.

    Example 1:
    Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
    Output: Intersected at '8'
    Explanation: The intersected node's value is 8 (note that this must not be
                 0 if the two lists intersect). From the head of A, it reads as
                 [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5].
                 There are 2 nodes before the intersected node in A; There are
                 3 nodes before the intersected node in B.

    Example 2:
    Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
    Output: Intersected at '2'
    Explanation: The intersected node's value is 2 (note that this must not be
                 0 if the two lists intersect). From the head of A, it reads as
                 [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There
                 are 3 nodes before the intersected node in A; There are 1 node
                 before the intersected node in B.

    Example 3:
    Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
    Output: No intersection
    Explanation: From the head of A, it reads as [2,6,4]. From the head of B,
                 it reads as [1,5]. Since the two lists do not intersect,
                 intersectVal must be 0, while skipA and skipB can be
                 arbitrary values. The two lists do not intersect, so return
                 null.

    Constraints:
    * The number of nodes of listA is in the m.
    * The number of nodes of listB is in the n.
    * 0 <= m, n <= 3 * 10^4
    * 1 <= Node.val <= 10^5
    * 0 <= skipA <= m
    * 0 <= skipB <= n
    * intersectVal is 0 if listA and listB do not intersect.
    * intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect.*/

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *nodeA = headA, *nodeB = headB;
        while (nodeA != nodeB) {
            nodeA = nodeA ? nodeA->next : headB;
            nodeB = nodeB ? nodeB->next : headA;
        }
        return nodeA;
    }


    /*162. Find Peak Element (Medium)
    A peak element is an element that is strictly greater than its neighbors.
    Given an integer array nums, find a peak element, and return its index. If
    the array contains multiple peaks, return the index to any of the peaks.
    You may imagine that nums[-1] = nums[n] = -∞. You must write an algorithm
    that runs in O(log n) time.

    Example 1:
    Input: nums = [1,2,3,1]
    Output: 2
    Explanation: 3 is a peak element and your function should return the index
                 number 2.

    Example 2:
    Input: nums = [1,2,1,3,5,6,4]
    Output: 5
    Explanation: Your function can return either index number 1 where the peak
                 element is 2, or index number 5 where the peak element is 6.

    Constraints:
    * 1 <= nums.length <= 1000
    * -2^31 <= nums[i] <= 2^31 - 1
    * nums[i] != nums[i + 1] for all valid i.*/

    int findPeakElement(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1;
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (nums[mid] < nums[mid+1]) lo = mid+1;
            else hi = mid;
        }
        return lo;
    }


    /*163. Missing Ranges (Easy)
    You are given an inclusive range [lower, upper] and a sorted unique integer
    array nums, where all elements are in the inclusive range. A number x is
    considered missing if x is in the range [lower, upper] and x is not in nums.
    Return the smallest sorted list of ranges that cover every missing number
    exactly. That is, no element of nums is in any of the ranges, and each
    missing number is in one of the ranges. Each range [a,b] in the list should
    be output as:
    * "a->b" if a != b
    * "a" if a == b

    Example 1:
    Input: nums = [0,1,3,50,75], lower = 0, upper = 99
    Output: ["2","4->49","51->74","76->99"]
    Explanation: The ranges are: [2,2] --> "2"
                                 [4,49] --> "4->49"
                                 [51,74] --> "51->74"
                                 [76,99] --> "76->99"

    Example 2:
    Input: nums = [-1], lower = -1, upper = -1
    Output: []
    Explanation: There are no missing ranges since there are no missing numbers.

    Constraints:
    * -10^9 <= lower <= upper <= 10^9
    * 0 <= nums.length <= 100
    * lower <= nums[i] <= upper
    * All the values of nums are unique.*/

    vector<string> findMissingRanges(vector<int>& nums, int lower, int upper) {
        int prev = lower-1;
        nums.push_back(upper+1);
        vector<string> ans;
        for (auto& x : nums) {
            if (prev+1 <= x-1)
                if (prev+1 == x-1) ans.push_back(to_string(prev+1));
                else ans.push_back(to_string(prev+1) + "->" + to_string(x-1));
            prev = x;
        }
        return ans;
    }


    /*165. Compare Version Numbers (Medium)
    Given two version numbers, version1 and version2, compare them. Version
    numbers consist of one or more revisions joined by a dot '.'. Each revision
    consists of digits and may contain leading zeros. Every revision contains
    at least one character. Revisions are 0-indexed from left to right, with
    the leftmost revision being revision 0, the next revision being revision 1,
    and so on. For example 2.5.33 and 0.1 are valid version numbers. To compare
    version numbers, compare their revisions in left-to-right order. Revisions
    are compared using their integer value ignoring any leading zeros. This
    means that revisions 1 and 001 are considered equal. If a version number
    does not specify a revision at an index, then treat the revision as 0. For
    example, version 1.0 is less than version 1.1 because their revision 0s are
    the same, but their revision 1s are 0 and 1 respectively, and 0 < 1. Return
    the following:
    * If version1 < version2, return -1.
    * If version1 > version2, return 1.
    * Otherwise, return 0.

    Example 1:
    Input: version1 = "1.01", version2 = "1.001"
    Output: 0
    Explanation: Ignoring leading zeroes, both "01" and "001" represent the
                 same integer "1".

    Example 2:
    Input: version1 = "1.0", version2 = "1.0.0"
    Output: 0
    Explanation: version1 does not specify revision 2, which means it is
                 treated as "0".

    Example 3:
    Input: version1 = "0.1", version2 = "1.1"
    Output: -1
    Explanation: version1's revision 0 is "0", while version2's revision 0 is
                 "1". 0 < 1, so version1 < version2.

    Constraints:
    * 1 <= version1.length, version2.length <= 500
    * version1 and version2 only contain digits and '.'.
    * version1 and version2 are valid version numbers.
    * All the given revisions in version1 and version2 can be stored in a 32-
      bit integer.*/

    int compareVersion(string version1, string version2) {
        vector<string> vals1, vals2;
        stringstream ss1(version1), ss2(version2);
        string item;
        while (getline(ss1, item, '.')) vals1.push_back(item);
        while (getline(ss2, item, '.')) vals2.push_back(item);
        for (int i = 0, n1 = vals1.size(), n2 = vals2.size(); i < n1 || i < n2; ++i) {
            int v1 = i < n1 ? stoi(vals1[i]) : 0;
            int v2 = i < n2 ? stoi(vals2[i]) : 0;
            if (v1 < v2) return -1;
            else if (v1 > v2) return 1;
        }
        return 0;
    }


    /*167. Two Sum II - Input array is sorted (Easy)
    Given a 1-indexed array of integers numbers that is already sorted in non-
    decreasing order, find two numbers such that they add up to a specific
    target number. Let these two numbers be numbers[index1] and numbers[index2]
    where 1 <= first < second <= numbers.length. Return the indices of the two
    numbers, index1 and index2, as an integer array [index1, index2] of length
    2. The tests are generated such that there is exactly one solution. You may
    not use the same element twice.

    Example 1:
    Input: numbers = [2,7,11,15], target = 9
    Output: [1,2]
    Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.

    Example 2:
    Input: numbers = [2,3,4], target = 6
    Output: [1,3]
    Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3.

    Example 3:
    Input: numbers = [-1,0], target = -1
    Output: [1,2]
    Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2.

    Constraints:
    * 2 <= numbers.length <= 3 * 10^4
    * -1000 <= numbers[i] <= 1000
    * numbers is sorted in non-decreasing order.
    * -1000 <= target <= 1000
    * The tests are generated such that there is exactly one solution.*/

    vector<int> twoSum(vector<int>& numbers, int target) {
        for (int lo = 0, hi = numbers.size()-1; lo < hi; ) {
            int sm = numbers[lo] + numbers[hi];
            if (sm < target) lo++;
            else if (sm == target) return {lo+1, hi+1};
            else hi--;
        }
        return {};
    }


    /*168. Excel Sheet Column Title (Easy)
    Given an integer columnNumber, return its corresponding column title as it
    appears in an Excel sheet. For example:
        A -> 1
        B -> 2
        C -> 3
        ...
        Z -> 26
        AA -> 27
        AB -> 28
        ...

    Example 1:
    Input: columnNumber = 1
    Output: "A"

    Example 2:
    Input: columnNumber = 28
    Output: "AB"

    Example 3:
    Input: columnNumber = 701
    Output: "ZY"

    Constraints: 1 <= columnNumber <= 2^31 - 1*/

    string convertToTitle(int columnNumber) {
        string ans;
        for (; columnNumber; columnNumber /= 26) {
            int x = --columnNumber % 26;
            ans.push_back(x + 'A');
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*169. Majority Element (Easy)
    Given an array nums of size n, return the majority element. The majority
    element is the element that appears more than ⌊n / 2⌋ times. You may assume
    that the majority element always exists in the array.

    Example 1:
    Input: nums = [3,2,3]
    Output: 3

    Example 2:
    Input: nums = [2,2,1,1,1,2,2]
    Output: 2

    Constraints:
    * n == nums.length
    * 1 <= n <= 5 * 10^4
    * -2^31 <= nums[i] <= 2^31 - 1

    Follow-up: Could you solve the problem in linear time and in O(1) space?*/

    int majorityElement(vector<int>& nums) {
        /*Boyer-Moore majority vote algo*/
        int ans = 0, vote = 0;
        for (auto& x : nums) {
            if (vote == 0) ans = x;
            if (x == ans) ++vote;
            else --vote;
        }
        return ans;
    }


    /*171. Excel Sheet Column Number (Easy)
    Given a string columnTitle that represents the column title as appear in an
    Excel sheet, return its corresponding column number. For example:
        A -> 1
        B -> 2
        C -> 3
        ...
        Z -> 26
        AA -> 27
        AB -> 28
        ...

    Example 1:
    Input: columnTitle = "A"
    Output: 1

    Example 2:
    Input: columnTitle = "AB"
    Output: 28

    Example 3:
    Input: columnTitle = "ZY"
    Output: 701

    Constraints:
    * 1 <= columnTitle.length <= 7
    * columnTitle consists only of uppercase English letters.
    * columnTitle is in the range ["A", "FXSHRXW"].*/

    int titleToNumber(string columnTitle) {
        int ans = 0;
        for (auto& ch : columnTitle)
            ans = 26*ans + (ch - 'A' + 1);
        return ans;
    }


    /*174. Dungeon Game (Hard)
    The demons had captured the princess and imprisoned her in the bottom-right
    corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D
    grid. Our valiant knight was initially positioned in the top-left room and
    must fight his way through dungeon to rescue the princess. The knight has
    an initial health point represented by a positive integer. If at any point
    his health point drops to 0 or below, he dies immediately. Some of the
    rooms are guarded by demons (represented by negative integers), so the
    knight loses health upon entering these rooms; other rooms are either empty
    (represented as 0) or contain magic orbs that increase the knight's health
    (represented by positive integers). To reach the princess as quickly as
    possible, the knight decides to move only rightward or downward in each
    step. Return the knight's minimum initial health so that he can rescue the
    princess. Note that any room can contain threats or power-ups, even the
    first room the knight enters and the bottom-right room where the princess
    is imprisoned.

    Example 1:
    Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
    Output: 7
    Explanation: The initial health of the knight must be at least 7 if he
                 follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.

    Example 2:
    Input: dungeon = [[0]]
    Output: 1

    Constraints:
    * m == dungeon.length
    * n == dungeon[i].length
    * 1 <= m, n <= 200
    * -1000 <= dungeon[i][j] <= 1000*/

    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int m = dungeon.size(), n = dungeon[0].size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1]);
        for (int i = m-1; i >= 0; --i)
            for (int j = n-1; j >= 0; --j)
                if (i != m-1 || j != n-1)
                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);
        return dp[0][0];
    }


    /*187. Repeated DNA Sequences (Medium)
    The DNA sequence is composed of a series of nucleotides abbreviated as 'A',
    'C', 'G', and 'T'. For example, "ACGAATTCCG" is a DNA sequence. When
    studying DNA, it is useful to identify repeated sequences within the DNA.
    Given a string s that represents a DNA sequence, return all the 10-letter-
    long sequences (substrings) that occur more than once in a DNA molecule.
    You may return the answer in any order.

    Example 1:
    Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
    Output: ["AAAAACCCCC","CCCCCAAAAA"]

    Example 2:
    Input: s = "AAAAAAAAAAAAA"
    Output: ["AAAAAAAAAA"]

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either 'A', 'C', 'G', or 'T'.*/

    vector<string> findRepeatedDnaSequences(string s) {
        unordered_map<char, int> mp {{'A', 0}, {'C', 1}, {'G', 2}, {'T', 3}};
        unordered_map<int, int> freq;
        vector<string> ans;
        int hs = 0; // rolling hash
        for (int i = 0; i < s.size(); ++i) {
            hs = 4*hs + mp[s[i]];
            if (i >= 10) hs -= mp[s[i-10]]*pow(4, 10);
            if (i >= 9 && ++freq[hs] == 2) ans.push_back(s.substr(i-9, 10));
        }
        return ans;
    }


    /*188. Best Time to Buy and Sell Stock IV (Hard)
    You are given an integer array prices where prices[i] is the price of a
    given stock on the ith day, and an integer k. Find the maximum profit you
    can achieve. You may complete at most k transactions. Note: You may not
    engage in multiple transactions simultaneously (i.e., you must sell the
    stock before you buy again).

    Example 1:
    Input: k = 2, prices = [2,4,1]
    Output: 2
    Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4),
                 profit = 4-2 = 2.

    Example 2:
    Input: k = 2, prices = [3,2,6,5,0,3]
    Output: 7
    Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6),
                 profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on
                 day 6 (price = 3), profit = 3-0 = 3.

    Constraints:
    * 0 <= k <= 100
    * 0 <= prices.length <= 1000
    * 0 <= prices[i] <= 1000*/

    int maxProfit(int k, vector<int>& prices) {
        // buy low & sell high
        k = min(k, (int) prices.size()/2);
        vector<int> buy(k, INT_MAX), sell(k);
        for (auto& x : prices)
            for (int i = 0; i < k; ++i) {
                if (i) buy[i] = min(buy[i], x - sell[i-1]);
                else buy[i] = min(buy[i], x);
                sell[i] = max(sell[i], x - buy[i]);
            }
        return k && prices.size() ? sell.back() : 0;
    }


    /*189. Rotate Array (Medium)
    Given an array, rotate the array to the right by k steps, where k is non-
    negative.

    Example 1:
    Input: nums = [1,2,3,4,5,6,7], k = 3
    Output: [5,6,7,1,2,3,4]
    Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6]
                 rotate 2 steps to the right: [6,7,1,2,3,4,5]
                 rotate 3 steps to the right: [5,6,7,1,2,3,4]

    Example 2:
    Input: nums = [-1,-100,3,99], k = 2
    Output: [3,99,-1,-100]
    Explanation: rotate 1 steps to the right: [99,-1,-100,3]
                 rotate 2 steps to the right: [3,99,-1,-100]

    Constraints:
    * 1 <= nums.length <= 10^5
    * -2^31 <= nums[i] <= 2^31 - 1
    * 0 <= k <= 10^5

    Follow up: Try to come up with as many solutions as you can. There are at
    least three different ways to solve this problem. Could you do it in-place
    with O(1) extra space?*/

    void rotate(vector<int>& nums, int k) {
        for (int i = 0, n = nums.size(); i < gcd(n, k); ++i)
            for (int ii = (i+k)%n; i != ii; ii = (ii+k)%n)
                swap(nums[i], nums[ii]);
    }


    /*190. Reverse Bits (Easy)
    Reverse bits of a given 32 bits unsigned integer.

    Note:
    * Note that in some languages, such as Java, there is no unsigned integer
      type. In this case, both input and output will be given as a signed
      integer type. They should not affect your implementation, as the
      integer's internal binary representation is the same, whether it is
      signed or unsigned.
    * In Java, the compiler represents the signed integers using 2's complement
      notation. Therefore, in Example 2 above, the input represents the signed
      integer -3 and the output represents the signed integer -1073741825.

    Example 1:
    Input: n = 00000010100101000001111010011100
    Output:    964176192 (00111001011110000010100101000000)
    Explanation: The input binary string 00000010100101000001111010011100
                 represents the unsigned integer 43261596, so return 964176192
                 which its binary representation is
                 00111001011110000010100101000000.

    Example 2:
    Input: n = 11111111111111111111111111111101
    Output:   3221225471 (10111111111111111111111111111111)
    Explanation: The input binary string 11111111111111111111111111111101
                 represents the unsigned integer 4294967293, so return
                 3221225471 which its binary representation is
                 10111111111111111111111111111111.

    Constraints: The input must be a binary string of length 32

    Follow up: If this function is called many times, how would you optimize it?*/

    uint32_t reverseBits(uint32_t n) {
        uint32_t ans = 0;
        for (int i = 0; i < 32; ++i, n >>= 1)
            ans = (ans<<1) + (n&1);
        return ans;
    }


    /*191. Number of 1 Bits (Easy)
    Write a function that takes an unsigned integer and returns the number of
    '1' bits it has (also known as the Hamming weight).

    Note:
    * Note that in some languages, such as Java, there is no unsigned integer
      type. In this case, the input will be given as a signed integer type. It
      should not affect your implementation, as the integer's internal binary
      representation is the same, whether it is signed or unsigned.
    * In Java, the compiler represents the signed integers using 2's complement
      notation. Therefore, in Example 3, the input represents the signed
      integer. -3.

    Example 1:
    Input: n = 00000000000000000000000000001011
    Output: 3
    Explanation: The input binary string 00000000000000000000000000001011 has a
                 total of three '1' bits.

    Example 2:
    Input: n = 00000000000000000000000010000000
    Output: 1
    Explanation: The input binary string 00000000000000000000000010000000 has a
                 total of one '1' bit.

    Example 3:
    Input: n = 11111111111111111111111111111101
    Output: 31
    Explanation: The input binary string 11111111111111111111111111111101 has a
                 total of thirty one '1' bits.

    Constraints:
    * The input must be a binary string of length 32.

    Follow up: If this function is called many times, how would you optimize it?*/

    int hammingWeight(uint32_t n) {
        /* Brian Kernighan’s Algo */
        int ans = 0;
        for (; n; ++ans, n &= n-1);
        return ans;
    }


    /*198. House Robber (Medium)
    You are a professional robber planning to rob houses along a street. Each
    house has a certain amount of money stashed, the only constraint stopping
    you from robbing each of them is that adjacent houses have security systems
    connected and it will automatically contact the police if two adjacent
    houses were broken into on the same night. Given an integer array nums
    representing the amount of money of each house, return the maximum amount
    of money you can rob tonight without alerting the police.

    Example 1:
    Input: nums = [1,2,3,1]
    Output: 4
    Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
                 Total amount you can rob = 1 + 3 = 4.

    Example 2:
    Input: nums = [2,7,9,3,1]
    Output: 12
    Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house
                 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 400*/

    int rob(vector<int>& nums) {
        int f0 = 0, f1 = 0;
        for (auto& x : nums) {
            int f2 = max(f0+x, f1);
            f0 = f1;
            f1 = f2;
        }
        return f1;
    }


    /*199. Binary Tree Right Side View (Medium)
    Given the root of a binary tree, imagine yourself standing on the right
    side of it, return the values of the nodes you can see ordered from top to
    bottom.

    Example 1:
    Input: root = [1,2,3,null,5,null,4]
    Output: [1,3,4]

    Example 2:
    Input: root = [1,null,3]
    Output: [1,3]

    Example 3:
    Input: root = []
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100*/

    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        if (root) {
            queue<TreeNode*> q;
            q.push(root);
            while (q.size()) {
                TreeNode* node = nullptr;
                for (int sz = q.size(); sz; --sz) {
                    node = q.front(); q.pop();
                    if (node->left) q.push(node->left);
                    if (node->right) q.push(node->right);
                }
                ans.push_back(node->val);
            }
        }
        return ans;
    }


    /*200. Number of Islands (Medium)
    Given an m x n 2D binary grid grid which represents a map of '1's (land)
    and '0's (water), return the number of islands. An island is surrounded by
    water and is formed by connecting adjacent lands horizontally or vertically.
    You may assume all four edges of the grid are all surrounded by water.

    Example 1:
    Input: grid = [["1","1","1","1","0"],
                   ["1","1","0","1","0"],
                   ["1","1","0","0","0"],
                   ["0","0","0","0","0"]]
    Output: 1

    Example 2:
    Input: grid = [["1","1","0","0","0"],
                   ["1","1","0","0","0"],
                   ["0","0","1","0","0"],
                   ["0","0","0","1","1"]]
    Output: 3

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 300
    * grid[i][j] is '0' or '1'.*/

    int numIslands(vector<vector<char>>& grid) {
        int ans = 0, m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        stack<pair<int, int>> stk;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == '1') {
                    grid[i][j] = '0'; // mark "visited"
                    ++ans;
                    stk.emplace(i, j);
                    while (stk.size()) {
                        auto [i, j] = stk.top(); stk.pop();
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] == '1') {
                                grid[ii][jj] = '0';
                                stk.emplace(ii, jj);
                            }
                        }
                    }
                }
        return ans;
    }


    /*201. Bitwise AND of Numbers Range (Medium)
    Given two integers left and right that represent the range [left, right],
    return the bitwise AND of all numbers in this range, inclusive.

    Example 1:
    Input: left = 5, right = 7
    Output: 4

    Example 2:
    Input: left = 0, right = 0
    Output: 0

    Example 3:
    Input: left = 1, right = 2147483647
    Output: 0

    Constraints: 0 <= left <= right <= 2^31 - 1*/

    int rangeBitwiseAnd(int left, int right) {
        for (; left < right; right &= right - 1);
        return right;
    }


    /*202. Happy Number (Easy)
    Write an algorithm to determine if a number n is happy. A happy number is a
    number defined by the following process:
    * Starting with any positive integer, replace the number by the sum of the
      squares of its digits.
    * Repeat the process until the number equals 1 (where it will stay), or it
      loops endlessly in a cycle which does not include 1.
    * Those numbers for which this process ends in 1 are happy.
    Return true if n is a happy number, and false if not.

    Example 1:
    Input: n = 19
    Output: true
    Explanation: 12 + 92 = 82
                 82 + 22 = 68
                 62 + 82 = 100
                 12 + 02 + 02 = 1

    Example 2:
    Input: n = 2
    Output: false

    Constraints: 1 <= n <= 2^31 - 1*/

    bool isHappy(int n) {

        auto fn = [](int n) {
            int ans = 0;
            for (; n; n /= 10)
                ans += pow(n % 10, 2);
            return ans;
        };

        for (int fast = n, slow = n; fast != 1; ) {
            fast = fn(fn(fast));
            slow = fn(slow);
            if (fast == slow && fast != 1) return false;
        }
        return true;
    }


    /*203. Remove Linked List Elements (Easy)
    Given the head of a linked list and an integer val, remove all the nodes of
    the linked list that has Node.val == val, and return the new head.

    Example 1:
    Input: head = [1,2,6,3,4,5,6], val = 6
    Output: [1,2,3,4,5]

    Example 2:
    Input: head = [], val = 1
    Output: []

    Example 3:
    Input: head = [7,7,7,7], val = 7
    Output: []

    Constraints:
    * The number of nodes in the list is in the range [0, 10^4].
    * 1 <= Node.val <= 50
    * 0 <= val <= 50*/

    ListNode* removeElements(ListNode* head, int val) {
        ListNode dummy(0, head), *node = &dummy;
        while (node->next)
            if (node->next->val == val) node->next = node->next->next;
            else node = node->next;
        return dummy.next;
    }


    /*204. Count Primes (Easy)
    Count the number of prime numbers less than a non-negative number, n.

    Example 1:
    Input: n = 10
    Output: 4
    Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.

    Example 2:
    Input: n = 0
    Output: 0

    Example 3:
    Input: n = 1
    Output: 0

    Constraints: 0 <= n <= 5 * 10^6*/

    int countPrimes(int n) {
        if (n < 2) return false; // edge case

        vector<bool> sieve(n, true);
        sieve[0] = sieve[1] = false;
        for (int i = 2; i < sqrt(n); ++i) {
            if (sieve[i]) {
                for (int ii = i*i; ii < n; ii += i) {
                    sieve[ii] = false;
                }
            }
        }
        return count(sieve.begin(), sieve.end(), true);
    }


    /*205. Isomorphic Strings (Easy)
    Given two strings s and t, determine if they are isomorphic. Two strings s
    and t are isomorphic if the characters in s can be replaced to get t. All
    occurrences of a character must be replaced with another character while
    preserving the order of characters. No two characters may map to the same
    character, but a character may map to itself.

    Example 1:
    Input: s = "egg", t = "add"
    Output: true

    Example 2:
    Input: s = "foo", t = "bar"
    Output: false

    Example 3:
    Input: s = "paper", t = "title"
    Output: true

    Constraints:
    * 1 <= s.length <= 5 * 10^4
    * t.length == s.length
    * s and t consist of any valid ascii character.*/

    bool isIsomorphic(string s, string t) {
        int mps[256] = {0}, mpt[256] = {0};
        for (int i = 0; i < s.size(); ++i) {
            if (mps[s[i]] != mpt[t[i]]) return false;
            mps[s[i]] = mpt[t[i]] = i+1;
        }
        return true;
    }


    /*206. Reverse Linked List (Easy)
    Given the head of a singly linked list, reverse the list, and return the
    reversed list.

    Example 1:
    Input: head = [1,2,3,4,5]
    Output: [5,4,3,2,1]

    Example 2:
    Input: head = [1,2]
    Output: [2,1]

    Example 3:
    Input: head = []
    Output: []

    Constraints:
    * The number of nodes in the list is the range [0, 5000].
    * -5000 <= Node.val <= 5000

    Follow up: A linked list can be reversed either iteratively or recursively.
               Could you implement both?*/

    ListNode* reverseList(ListNode* head) {
        ListNode *prev = nullptr, *node = head;
        while (node) {
            ListNode* temp = node->next;
            node->next = prev;
            prev = node;
            node = temp;
        }
        return prev;
    }


    /*210. Course Schedule II (Medium)
    There are a total of numCourses courses you have to take, labeled from 0 to
    numCourses - 1. You are given an array prerequisites where
    prerequisites[i] = [ai, bi] indicates that you must take course bi first if
    you want to take course ai.
    * For example, the pair [0, 1], indicates that to take course 0 you have to
      first take course 1.
    Return the ordering of courses you should take to finish all courses. If
    there are many valid answers, return any of them. If it is impossible to
    finish all courses, return an empty array.

    Example 1:
    Input: numCourses = 2, prerequisites = [[1,0]]
    Output: [0,1]
    Explanation: There are a total of 2 courses to take. To take course 1 you
                 should have finished course 0. So the correct course order is
                 [0,1].

    Example 2:
    Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
    Output: [0,2,1,3]
    Explanation: There are a total of 4 courses to take. To take course 3 you
                 should have finished both courses 1 and 2. Both courses 1 and
                 2 should be taken after you finished course 0. So one correct
                 course order is [0,1,2,3]. Another correct ordering is
                 [0,2,1,3].

    Example 3:
    Input: numCourses = 1, prerequisites = []
    Output: [0]

    Constraints:
    * 1 <= numCourses <= 2000
    * 0 <= prerequisites.length <= numCourses * (numCourses - 1)
    * prerequisites[i].length == 2
    * 0 <= ai, bi < numCourses
    * ai != bi
    * All the pairs [ai, bi] are distinct.*/

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph(numCourses);
        vector<int> indeg(numCourses);
        for (auto& pre : prerequisites) {
            graph[pre[1]].push_back(pre[0]);
            ++indeg[pre[0]];
        }

        queue<int> q;
        for (int i = 0; i < numCourses; ++i)
            if (indeg[i] == 0) q.push(i);

        vector<int> ans;
        while (q.size()) {
            int u = q.front(); q.pop();
            ans.push_back(u);
            for (auto& v : graph[u])
                if (--indeg[v] == 0) q.push(v);
        }
        return ans.size() == numCourses ? ans : vector<int>();
    }


    /*212. Word Search II (Hard)
    Given an m x n board of characters and a list of strings words, return all
    words on the board. Each word must be constructed from letters of
    sequentially adjacent cells, where adjacent cells are horizontally or
    vertically neighboring. The same letter cell may not be used more than once
    in a word.

    Example 1:
    Input: board = [["o","a","a","n"],
                    ["e","t","a","e"],
                    ["i","h","k","r"],
                    ["i","f","l","v"]],
           words = ["oath","pea","eat","rain"]
    Output: ["eat","oath"]

    Example 2:
    Input: board = [["a","b"],
                    ["c","d"]],
           words = ["abcb"]
    Output: []

    Constraints:
    * m == board.length
    * n == board[i].length
    * 1 <= m, n <= 12
    * board[i][j] is a lowercase English letter.
    * 1 <= words.length <= 3 * 10^4
    * 1 <= words[i].length <= 10
    * words[i] consists of lowercase English letters.
    * All the strings of words are unique.

    class TrieNode {
    public:
        TrieNode* next[26] = {nullptr};
        bool isword = false;
    };

    class Trie {
    public:
        TrieNode* root;
        Trie() {
            root = new TrieNode();
        }

        void insert(string word) {
            TrieNode* node = root;
            for (auto& ch : word) {
                if (!node->next[ch-'a']) node->next[ch-'a'] = new TrieNode();
                node = node->next[ch-'a'];
            }
            node->isword = true;
        }
    }; */

    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        Trie* trie = new Trie();
        for (auto& word : words) trie->insert(word);

        int m = board.size(), n = board[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        vector<string> ans;
        string stk;

        function<void(int, int, TrieNode*)> fn = [&](int i, int j, TrieNode* node) {
            if (node->isword) {
                ans.push_back(stk);
                node->isword = false; // avoid repetitions
            }
            if (0 <= i && i < m && 0 <= j && j < n && board[i][j] != '#' && node->next[board[i][j]-'a']) {
                stk.push_back(board[i][j]);
                board[i][j] = '#';
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    fn(ii, jj, node->next[stk.back()-'a']);
                }
                board[i][j] = stk.back();
                stk.pop_back();
            }
        };

        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                fn(i, j, trie->root);
        return ans;
    }


    /*213. House Robber II (Medium)
    You are a professional robber planning to rob houses along a street. Each
    house has a certain amount of money stashed. All houses at this place are
    arranged in a circle. That means the first house is the neighbor of the
    last one. Meanwhile, adjacent houses have a security system connected, and
    it will automatically contact the police if two adjacent houses were broken
    into on the same night. Given an integer array nums representing the amount
    of money of each house, return the maximum amount of money you can rob
    tonight without alerting the police.

    Example 1:
    Input: nums = [2,3,2]
    Output: 3
    Explanation: You cannot rob house 1 (money = 2) and then rob house 3
                 (money = 2), because they are adjacent houses.

    Example 2:
    Input: nums = [1,2,3,1]
    Output: 4
    Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
                 Total amount you can rob = 1 + 3 = 4.

    Example 3:
    Input: nums = [1,2,3]
    Output: 3

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 1000*/

    int rob(vector<int>& nums) {

        auto fn = [&](int lo, int hi) {
            int f0 = 0, f1 = 0;
            for (int i = lo; i < hi; ++i) {
                int f2 = max(f0 + nums[i], f1);
                f0 = f1;
                f1 = f2;
            }
            return f1;
        };

        if (nums.size() == 1) return nums[0];
        return max(fn(0, nums.size()-1), fn(1, nums.size()));
    }


    /*215. Kth Largest Element in an Array (Medium)
    Given an integer array nums and an integer k, return the kth largest
    element in the array. Note that it is the kth largest element in the
    sorted order, not the kth distinct element.

    Example 1:
    Input: nums = [3,2,1,5,6,4], k = 2
    Output: 5

    Example 2:
    Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
    Output: 4

    Constraints:
    * 1 <= k <= nums.length <= 10^4
    * -10^4 <= nums[i] <= 10^4*/

    int findKthLargest(vector<int>& nums, int k) {
        nth_element(nums.begin(), nums.end()-k, nums.end());
        return nums[nums.size()-k];
    }


    /*216. Combination Sum III (Medium)
    Find all valid combinations of k numbers that sum up to n such that the
    following conditions are true:
    * Only numbers 1 through 9 are used.
    * Each number is used at most once.
    Return a list of all possible valid combinations. The list must not contain
    the same combination twice, and the combinations may be returned in any
    order.

    Example 1:
    Input: k = 3, n = 7
    Output: [[1,2,4]]
    Explanation: 1 + 2 + 4 = 7
                 There are no other valid combinations.

    Example 2:
    Input: k = 3, n = 9
    Output: [[1,2,6],[1,3,5],[2,3,4]]
    Explanation: 1 + 2 + 6 = 9
                 1 + 3 + 5 = 9
                 2 + 3 + 4 = 9
                 There are no other valid combinations.

    Example 3:
    Input: k = 4, n = 1
    Output: []
    Explanation: There are no valid combinations. Using 4 different numbers in
                 the range [1,9], the smallest sum we can get is 1+2+3+4 = 10
                 and since 10 > 1, there are no valid combination.

    Example 4:
    Input: k = 3, n = 2
    Output: []
    Explanation: There are no valid combinations.

    Example 5:
    Input: k = 9, n = 45
    Output: [[1,2,3,4,5,6,7,8,9]]
    Explanation: 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45
                 There are no other valid combinations.

    Constraints:
    * 2 <= k <= 9
    * 1 <= n <= 60*/

    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> ans;
        vector<int> stk;
        for (int x = 1; true; ) {
            if (stk.size() == k && accumulate(stk.begin(), stk.end(), 0) == n) ans.push_back(stk);
            if (stk.size() == k || k - stk.size() > 9 - x + 1) {
                if (stk.empty()) break;
                x = 1 + stk.back(); stk.pop_back();
            } else stk.push_back(x++);
        }
        return ans;
    }


    /*217. Contains Duplicate (Easy)
    Given an integer array nums, return true if any value appears at least
    twice in the array, and return false if every element is distinct.

    Example 1:
    Input: nums = [1,2,3,1]
    Output: true

    Example 2:
    Input: nums = [1,2,3,4]
    Output: false

    Example 3:
    Input: nums = [1,1,1,3,3,4,3,2,4,2]
    Output: true

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> seen;
        for (auto& x : nums) {
            if (seen.count(x)) return true;
            seen.insert(x);
        }
        return false;
    }


    /*221. Maximal Square (Medium)
    Given an m x n binary matrix filled with 0's and 1's, find the largest
    square containing only 1's and return its area.

    Example 1:
    Input: matrix = [["1","0","1","0","0"],
                     ["1","0","1","1","1"],
                     ["1","1","1","1","1"],
                     ["1","0","0","1","0"]]
    Output: 4

    Example 2:
    Input: matrix = [["0","1"],
                     ["1","0"]]
    Output: 1

    Example 3:
    Input: matrix = [["0"]]
    Output: 0

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 300
    * matrix[i][j] is '0' or '1'.*/

    int maximalSquare(vector<vector<char>>& matrix) {
        int ans = 0, m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (matrix[i][j] == '1') {
                    if (i && j) dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});
                    else dp[i][j] = 1;
                    ans = max(ans, dp[i][j]);
                }
        return ans*ans;
    }


    /*226. Invert Binary Tree (Easy)
    Given the root of a binary tree, invert the tree, and return its root.

    Example 1:
    Input: root = [4,2,7,1,3,6,9]
    Output: [4,7,2,9,6,3,1]

    Example 2:
    Input: root = [2,1,3]
    Output: [2,3,1]

    Example 3:
    Input: root = []
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100*/

    TreeNode* invertTree(TreeNode* root) {
        if (root) {
            stack<TreeNode*> stk;
            stk.push(root);
            while (stk.size()) {
                TreeNode* node = stk.top(); stk.pop();
                swap(node->left, node->right);
                if (node->left) stk.push(node->left);
                if (node->right) stk.push(node->right);
            }
        }
        return root;
    }


    /*227. Basic Calculator II (Medium)
    Given a string s which represents an expression, evaluate this expression
    and return its value. The integer division should truncate toward zero. You
    may assume that the given expression is always valid. All intermediate
    results will be in the range of [-2^31, 2^31 - 1]. Note: You are not
    allowed to use any built-in function which evaluates strings as
    mathematical expressions, such as eval().

    Example 1:
    Input: s = "3+2*2"
    Output: 7

    Example 2:
    Input: s = " 3/2 "
    Output: 1

    Example 3:
    Input: s = " 3+5 / 2 "
    Output: 5

    Constraints:
    * 1 <= s.length <= 3 * 10^5
    * s consists of integers and operators ('+', '-', '*', '/') separated by
      some number of spaces.
    * s represents a valid expression.
    * All the integers in the expression are non-negative integers in the range
      [0, 2^31 - 1].
    * The answer is guaranteed to fit in a 32-bit integer.*/

    int calculate(string s) {
        char op = '+';
        int val = 0;
        vector<int> stk;
        for (int i = 0; i < s.size(); ++i) {
            if (isdigit(s[i])) val = 10*val + (s[i] - '0');
            if (i == s.size()-1 || s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') {
                if (op == '+') stk.push_back(val);
                else if (op == '-') stk.push_back(-val);
                else if (op == '*') val *= stk.back(), stk.pop_back(), stk.push_back(val);
                else if (op == '/') val = stk.back()/val, stk.pop_back(), stk.push_back(val);
                op = s[i];
                val = 0;
            }
        }
        return accumulate(stk.begin(), stk.end(), 0);
    }


    /*230. Kth Smallest Element in a BST (Medium)
    Given the root of a binary search tree, and an integer k, return the kth
    smallest value (1-indexed) of all the values of the nodes in the tree.

    Example 1:
    Input: root = [3,1,4,null,2], k = 1
    Output: 1

    Example 2:
    Input: root = [5,3,6,2,4,null,null,1], k = 3
    Output: 3

    Constraints:
    * The number of nodes in the tree is n.
    * 1 <= k <= n <= 10^4
    * 0 <= Node.val <= 10^4

    Follow up: If the BST is modified often (i.e., we can do insert and delete
               operations) and you need to find the kth smallest frequently,
               how would you optimize?*/

    int kthSmallest(TreeNode* root, int k) {
        TreeNode* node = root;
        stack<TreeNode*> stk;
        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top(); stk.pop();
                if (--k == 0) break;
                node = node->right;
            }
        return node->val;
    }


    /*231. Power of Two (Easy)
    Given an integer n, return true if it is a power of two. Otherwise, return
    false. An integer n is a power of two, if there exists an integer x such
    that n == 2^x.

    Example 1:
    Input: n = 1
    Output: true
    Explanation: 20 = 1

    Example 2:
    Input: n = 16
    Output: true
    Explanation: 24 = 16

    Example 3:
    Input: n = 3
    Output: false

    Example 4:
    Input: n = 4
    Output: true

    Example 5:
    Input: n = 5
    Output: false

    Constraints: -2^31 <= n <= 2^31 - 1

    Follow up: Could you solve it without loops/recursion?*/

    bool isPowerOfTwo(int n) {
        return n > 0 && (n & n-1) == 0;
    }


    /*233. Number of Digit One (Hard)
    Given an integer n, count the total number of digit 1 appearing in all non-
    negative integers less than or equal to n.

    Example 1:
    Input: n = 13
    Output: 6

    Example 2:
    Input: n = 0
    Output: 0

    Constraints: 0 <= n <= 10^9*/

    int countDigitOne(int n) {
        int ans = 0;
        for (long digit = 0, tail = 0, magn = 1; n; magn *= 10) {
            tail = digit*magn/10 + tail;
            digit = n % 10;
            n /= 10;
            ans += n * magn;
            if (digit > 1) ans += magn;
            else if (digit == 1) ans += tail + 1;
        }
        return ans;
    }


    /*234. Palindrome Linked List (Easy)
    Given the head of a singly linked list, return true if it is a palindrome.

    Example 1:
    Input: head = [1,2,2,1]
    Output: true

    Example 2:
    Input: head = [1,2]
    Output: false

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5].
    * 0 <= Node.val <= 9

    Follow up: Could you do it in O(n) time and O(1) space?*/

    bool isPalindrome(ListNode* head) {
        // find mid-point
        ListNode *fast = head, *slow = head;

        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }

        // reverse 2nd half
        ListNode *prev = NULL;
        while (slow) {
            ListNode* temp = slow->next;
            slow->next = prev;
            prev = slow;
            slow = temp;
        }

        // check for palindrome
        while (head && prev) {
            if (head->val != prev->val) return false;
            head = head->next;
            prev = prev->next;
        }
        return true;
    }


    /*235. Lowest Common Ancestor of a Binary Search Tree (Easy)
    Given a binary search tree (BST), find the lowest common ancestor (LCA) of
    two given nodes in the BST. According to the definition of LCA on Wikipedia:
    “The lowest common ancestor is defined between two nodes p and q as the
    lowest node in T that has both p and q as descendants (where we allow a
    node to be a descendant of itself).”

    Example 1:
    Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
    Output: 6
    Explanation: The LCA of nodes 2 and 8 is 6.

    Example 2:
    Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
    Output: 2
    Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant
                 of itself according to the LCA definition.

    Example 3:
    Input: root = [2,1], p = 2, q = 1
    Output: 2

    Constraints:
    * The number of nodes in the tree is in the range [2, 10^5].
    * -10^9 <= Node.val <= 10^9
    * All Node.val are unique.
    * p != q
    * p and q will exist in the BST.*/

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (p->val > q->val) swap(p, q);
        TreeNode* node = root;
        while (node) {
            if (node->val < p->val) node = node->right;
            else if (p->val <= node->val && node->val <= q->val) break;
            else node = node->left;
        }
        return node;
    }


    /*236. Lowest Common Ancestor of a Binary Tree (Medium)
    Given a binary tree, find the lowest common ancestor (LCA) of two given
    nodes in the tree. According to the definition of LCA on Wikipedia: “The
    lowest common ancestor is defined between two nodes p and q as the lowest
    node in T that has both p and q as descendants (where we allow a node to
    be a descendant of itself).”

    Example 1:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    Output: 3
    Explanation: The LCA of nodes 5 and 1 is 3.

    Example 2:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    Output: 5
    Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a
                 descendant of itself according to the LCA definition.

    Example 3:
    Input: root = [1,2], p = 1, q = 2
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [2, 10^5].
    * -10^9 <= Node.val <= 10^9
    * All Node.val are unique.
    * p != q
    * p and q will exist in the tree.*/

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q), *right = lowestCommonAncestor(root->right, p, q);
        if (left && right) return root;
        return left ? left : right;
    }


    /*237. Delete Node in a Linked List (Easy)
    Write a function to delete a node in a singly-linked list. You will not be
    given access to the head of the list, instead you will be given access to
    the node to be deleted directly. It is guaranteed that the node to be
    deleted is not a tail node in the list.

    Example 1:
    Input: head = [4,5,1,9], node = 5
    Output: [4,1,9]
    Explanation: You are given the second node with value 5, the linked list
                 should become 4 -> 1 -> 9 after calling your function.

    Example 2:
    Input: head = [4,5,1,9], node = 1
    Output: [4,5,9]
    Explanation: You are given the third node with value 1, the linked list
                 should become 4 -> 5 -> 9 after calling your function.

    Example 3:
    Input: head = [1,2,3,4], node = 3
    Output: [1,2,4]

    Example 4:
    Input: head = [0,1], node = 0
    Output: [1]

    Example 5:
    Input: head = [-3,5,-99], node = -3
    Output: [5,-99]

    Constraints:
    * The number of the nodes in the given list is in the range [2, 1000].
    * -1000 <= Node.val <= 1000
    * The value of each node in the list is unique.
    * The node to be deleted is in the list and is not a tail node*/

    void deleteNode(ListNode* node) {
        ListNode* temp = node->next;
        node->val = node->next->val;
        node->next = node->next->next;
        delete temp;
    }


    /*238. Product of Array Except Self (Medium)
    Given an integer array nums, return an array answer such that answer[i] is
    equal to the product of all the elements of nums except nums[i]. The
    product of any prefix or suffix of nums is guaranteed to fit in a 32-bit
    integer. You must write an algorithm that runs in O(n) time and without
    using the division operation.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: [24,12,8,6]

    Example 2:
    Input: nums = [-1,1,0,-3,3]
    Output: [0,0,9,0,0]

    Constraints:
    * 2 <= nums.length <= 10^5
    * -30 <= nums[i] <= 30
    * The product of any prefix or suffix of nums is guaranteed to fit in a 32-
      bit integer.

    Follow up: Can you solve the problem in O(1) extra space complexity? (The
               output array does not count as extra space for space complexity
               analysis.)*/

    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size(), prefix = 1, suffix = 1;
        vector<int> ans(n, 1);
        for (int i = 0; i < n; ++i) {
            ans[i] *= prefix;
            ans[n-1-i] *= suffix;
            prefix *= nums[i];
            suffix *= nums[n-1-i];
        }
        return ans;
    }


    /*239. Sliding Window Maximum (Hard)
    You are given an array of integers nums, there is a sliding window of size
    k which is moving from the very left of the array to the very right. You
    can only see the k numbers in the window. Each time the sliding window
    moves right by one position. Return the max sliding window.

    Example 1:
    Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
    Output: [3,3,5,5,6,7]
    Explanation: Window position                Max
                 ---------------               -----
                 [1  3  -1] -3  5  3  6  7       3
                  1 [3  -1  -3] 5  3  6  7       3
                  1  3 [-1  -3  5] 3  6  7       5
                  1  3  -1 [-3  5  3] 6  7       5
                  1  3  -1  -3 [5  3  6] 7       6
                  1  3  -1  -3  5 [3  6  7]      7

    Example 2:
    Input: nums = [1], k = 1
    Output: [1]

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^4 <= nums[i] <= 10^4
    * 1 <= k <= nums.length*/

    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q;
        vector<int> ans;
        for (int i = 0; i < nums.size(); ++i) {
            while (q.size() && nums[q.back()] <= nums[i]) q.pop_back();
            q.push_back(i);
            if (q.size() && i-q.front() == k) q.pop_front();
            if (i >= k-1) ans.push_back(nums[q.front()]);
        }
        return ans;
    }


    /*240. Search a 2D Matrix II (Medium)
    Write an efficient algorithm that searches for a target value in an m x n
    integer matrix. The matrix has the following properties:
    * Integers in each row are sorted in ascending from left to right.
    * Integers in each column are sorted in ascending from top to bottom.

    Example 1:
    Input: matrix = [[ 1 ,4, 7,11,15],
                     [ 2, 5, 8,12,19],
                     [ 3, 6, 9,16,22],
                     [10,13,14,17,24],
                     [18,21,23,26,30]], target = 5
    Output: true

    Example 2:
    Input: matrix = [[ 1, 4, 7,11,15],
                     [ 2, 5, 8,12,19],
                     [ 3, 6, 9,16,22],
                     [10,13,14,17,24],
                     [18,21,23,26,30]], target = 20
    Output: false

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= n, m <= 300
    * -10^9 <= matrix[i][j] <= 10^9
    * All the integers in each row are sorted in ascending order.
    * All the integers in each column are sorted in ascending order.
    * -10^9 <= target <= 10^9*/

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        for (int i = 0, j = n-1; i < m && 0 <= j; )
            if (matrix[i][j] < target) ++i;
            else if (matrix[i][j] == target) return true;
            else --j;
        return false;
    }


    /*242. Valid Anagram (Easy)
    Given two strings s and t, return true if t is an anagram of s, and false
    otherwise.

    Example 1:
    Input: s = "anagram", t = "nagaram"
    Output: true

    Example 2:
    Input: s = "rat", t = "car"
    Output: false

    Constraints:
    * 1 <= s.length, t.length <= 5 * 10^4
    * s and t consist of lowercase English letters.

    Follow up: What if the inputs contain Unicode characters? How would you
               adapt your solution to such a case?*/

    bool isAnagram(string s, string t) {
        vector<int> freq(26);
        for (auto& ch : s) ++freq[ch-'a'];
        for (auto& ch : t) --freq[ch-'a'];
        return all_of(freq.begin(), freq.end(), [](int x){return x == 0;});
    }


    /*245. Shortest Word Distance III (Medium)
    Given an array of strings wordsDict and two strings that already exist in
    the array word1 and word2, return the shortest distance between the
    occurrence of these two words in the list. Note that word1 and word2 may be
    the same. It is guaranteed that they represent two individual words in the
    list.

    Example 1:
    Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "coding"
    Output: 1

    Example 2:
    Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "makes"
    Output: 3

    Constraints:
    * 1 <= wordsDict.length <= 10^5
    * 1 <= wordsDict[i].length <= 10
    * wordsDict[i] consists of lowercase English letters.
    * word1 and word2 are in wordsDict.*/

    int shortestWordDistance(vector<string>& wordsDict, string word1, string word2) {
        int n = wordsDict.size(), ans = n, i1 = n, i2 = 2*n;
        for (int i = 0; i < n; ++i) {
            if (wordsDict[i] == word1) i1 = word1 == word2 ? i2 : i;
            if (wordsDict[i] == word2) i2 = i;
            ans = min(ans, abs(i1-i2));
        }
        return ans;
    }


    /*257. Binary Tree Paths (Easy)
    Given the root of a binary tree, return all root-to-leaf paths in any
    order. A leaf is a node with no children.

    Example 1:
    Input: root = [1,2,3,null,5]
    Output: ["1->2->5","1->3"]

    Example 2:
    Input: root = [1]
    Output: ["1"]

    Constraints:
    * The number of nodes in the tree is in the range [1, 100].
    * -100 <= Node.val <= 100*/

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> ans;

        stack<pair<TreeNode*, string>> stk;
        stk.push(make_pair(root, to_string(root->val)));

        while(!stk.empty()) {
            TreeNode* node = stk.top().first;
            string path = stk.top().second;
            stk.pop();

            if (node->left == NULL && node->right == NULL)
                ans.push_back(path);

            if (node->left) {
                stk.push(make_pair(node->left, path+"->"+to_string(node->left->val)));
            }
            if (node->right) {
                stk.push(make_pair(node->right, path+"->"+to_string(node->right->val)));
            }
        }
        return ans;
    }


    /*258. Add Digits (Easy)
    Given an integer num, repeatedly add all its digits until the result has
    only one digit, and return it.

    Example 1:
    Input: num = 38
    Output: 2
    Explanation: The process is
    38 --> 3 + 8 --> 11
    11 --> 1 + 1 --> 2
    Since 2 has only one digit, return it.

    Example 2:
    Input: num = 0
    Output: 0

    Constraints: 0 <= num <= 2^31 - 1

    Follow up: Could you do it without any loop/recursion in O(1) runtime?*/

    int addDigits(int num) {
        return 1 + (num - 1) % 9;
    }


    /*260. Single Number III (Medium)
    Given an integer array nums, in which exactly two elements appear only once
    and all the other elements appear exactly twice. Find the two elements that
    appear only once. You can return the answer in any order. You must write an
    algorithm that runs in linear runtime complexity and uses only constant
    extra space.

    Example 1:
    Input: nums = [1,2,1,3,2,5]
    Output: [3,5]
    Explanation:  [5, 3] is also a valid answer.

    Example 2:
    Input: nums = [-1,0]
    Output: [-1,0]

    Example 3:
    Input: nums = [0,1]
    Output: [1,0]

    Constraints:
    * 2 <= nums.length <= 3 * 10^4
    * -2^31 <= nums[i] <= 2^31 - 1
    * Each integer in nums will appear twice, only two integers will appear
      once.*/

    vector<int> singleNumber(vector<int>& nums) {
        unsigned val = accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());
        val &= -val;
        vector<int> ans(2);
        for (auto& x : nums)
            if (x&val) ans[0] ^= x;
            else ans[1] ^= x;
        return ans;
    }


    /*261. Graph Valid Tree (Medium)
    You have a graph of n nodes labeled from 0 to n - 1. You are given an
    integer n and a list of edges where edges[i] = [ai, bi] indicates that
    there is an undirected edge between nodes ai and bi in the graph. Return
    true if the edges of the given graph make up a valid tree, and false
    otherwise.

    Example 1:
    Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
    Output: true

    Example 2:
    Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
    Output: false

    Constraints:
    * 1 <= 2000 <= n
    * 0 <= edges.length <= 5000
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * There are no self-loops or repeated edges.*/

    bool validTree(int n, vector<vector<int>>& edges) {
        UnionFind *uf = new UnionFind(n);
        for (auto& edge : edges) {
            if (!uf.connect(edge[0], edge[1])) return false;
            --n;
        }
        delete uf;
        return n == 1;
    }


    /*263. Ugly Number (Easy)
    Given an integer n, return true if n is an ugly number. Ugly number is a
    positive number whose prime factors only include 2, 3, and/or 5.

    Example 1:
    Input: n = 6
    Output: true
    Explanation: 6 = 2 × 3

    Example 2:
    Input: n = 8
    Output: true
    Explanation: 8 = 2 × 2 × 2

    Example 3:
    Input: n = 14
    Output: false
    Explanation: 14 is not ugly since it includes another prime factor 7.

    Example 4:
    Input: n = 1
    Output: true
    Explanation: 1 is typically treated as an ugly number.

    Constraints: -2^31 <= n <= 2^31 - 1*/

    bool isUgly(int n) {
        if (n <= 0) return false;

        while (n > 1) {
            if (n % 2 == 0) n /= 2;
            else if (n % 3 == 0) n /= 3;
            else if (n % 5 == 0) n /= 5;
            else return false;
        }
        return true;
    }


    /*264. Ugly Number II (Medium)
    An ugly number is a positive integer whose prime factors are limited to 2,
    3, and 5. Given an integer n, return the nth ugly number.

    Example 1:
    Input: n = 10
    Output: 12
    Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first
                 10 ugly numbers.

    Example 2:
    Input: n = 1
    Output: 1
    Explanation: 1 has no prime factors, therefore all of its prime factors are
                 limited to 2, 3, and 5.

    Constraints: 1 <= n <= 1690*/

    int nthUglyNumber(int n) {
        vector<int> ans = {1};
        for (int i = 0, p2 = 0, p3 = 0, p5 = 0; i < n-1; ++i) {
            int cand = min({2*ans[p2], 3*ans[p3], 5*ans[p5]});
            ans.push_back(cand);
            if (2*ans[p2] == cand) ++p2;
            if (3*ans[p3] == cand) ++p3;
            if (5*ans[p5] == cand) ++p5;
        }
        return ans.back();
    }


    /*265. Paint House II (Hard)
    There are a row of n houses, each house can be painted with one of the k
    colors. The cost of painting each house with a certain color is different.
    You have to paint all the houses such that no two adjacent houses have the
    same color. The cost of painting each house with a certain color is
    represented by an n x k cost matrix costs. For example, costs[0][0] is the
    cost of painting house 0 with color 0; costs[1][2] is the cost of painting
    house 1 with color 2, and so on... Return the minimum cost to paint all
    houses.

    Example 1:
    Input: costs = [[1,5,3],[2,9,4]]
    Output: 5
    Explanation: Paint house 0 into color 0, paint house 1 into color 2.
                 Minimum cost: 1 + 4 = 5; Or paint house 0 into color 2, paint
                 house 1 into color 0. Minimum cost: 3 + 2 = 5.

    Example 2:
    Input: costs = [[1,3],[2,4]]
    Output: 5

    Constraints:
    * costs.length == n
    * costs[i].length == k
    * 1 <= n <= 100
    * 2 <= k <= 20
    * 1 <= costs[i][j] <= 20

    Follow up: Could you solve it in O(nk) runtime?*/

    int minCostII(vector<vector<int>>& costs) {
        int n = costs.size(), k = costs[0].size();
        for (int i = 1; i < n; ++i) {
            int m0 = -1, m1 = -1;
            for (int j = 0; j < k; ++j)
                if (m0 == -1 || costs[i-1][j] <= costs[i-1][m0]) {
                    m1 = m0;
                    m0 = j;
                } else if (m1 == -1 || costs[i-1][j] < costs[i-1][m1])
                    m1 = j;

            for (int j = 0; j < k; ++j)
                if (j != m0) costs[i][j] += costs[i-1][m0];
                else costs[i][j] += costs[i-1][m1];
        }
        return *min_element(costs[n-1].begin(), costs[n-1].end());
    }


    /*268. Missing Number (Easy)
    Given an array nums containing n distinct numbers in the range [0, n],
    return the only number in the range that is missing from the array.

    Follow up: Could you implement a solution using only O(1) extra space
               complexity and O(n) runtime complexity?

    Example 1:
    Input: nums = [3,0,1]
    Output: 2
    Explanation: n = 3 since there are 3 numbers, so all numbers are in the
                 range [0,3]. 2 is the missing number in the range since it
                 does not appear in nums.

    Example 2:
    Input: nums = [0,1]
    Output: 2
    Explanation: n = 2 since there are 2 numbers, so all numbers are in the
                 range [0,2]. 2 is the missing number in the range since it
                 does not appear in nums.

    Example 3:
    Input: nums = [9,6,4,2,3,5,7,0,1]
    Output: 8
    Explanation: n = 9 since there are 9 numbers, so all numbers are in the
                 range [0,9]. 8 is the missing number in the range since it
                 does not appear in nums.

    Example 4:
    Input: nums = [0]
    Output: 1
    Explanation: n = 1 since there is 1 number, so all numbers are in the range
                 [0,1]. 1 is the missing number in the range since it does not
                 appear in nums.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^4
    * 0 <= nums[i] <= n
    * All the numbers of nums are unique.*/

    int missingNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < nums.size(); ++i) {
            ans ^= i+1;
            ans ^= nums[i];
        }
        return ans;
    }


    /*276. Paint Fence (Medium)
    You are painting a fence of n posts with k different colors. You must paint
    the posts following these rules:
    * Every post must be painted exactly one color.
    * There cannot be three or more consecutive posts with the same color.
    Given the two integers n and k, return the number of ways you can paint the
    fence.

    Example 1:
    Input: n = 3, k = 2
    Output: 6
    Explanation: All the possibilities are shown. Note that painting all the
                 posts red or all the posts green is invalid because there
                 cannot be three posts in a row with the same color.

    Example 2:
    Input: n = 1, k = 1
    Output: 1

    Example 3:
    Input: n = 7, k = 2
    Output: 42

    Constraints:
    * 1 <= n <= 50
    * 1 <= k <= 10^5
    * The testcases are generated such that the answer is in the range
      [0, 2^31 - 1] for the given n and k.*/

    int numWays(int n, int k) {
        if (n == 0) return 0;
        if (n == 1) return k;
        int f0 = k, f1 = k*k;
        for (int i = 2; i < n; ++i) {
            int tmp = f1;
            f1 = (f0 + f1) * (k-1);
            f0 = tmp;
        }
        return f1;
    }


    /*278. First Bad Version (Easy)
    You are a product manager and currently leading a team to develop a new
    product. Unfortunately, the latest version of your product fails the
    quality check. Since each version is developed based on the previous
    version, all the versions after a bad version are also bad. Suppose you
    have n versions [1, 2, ..., n] and you want to find out the first bad one,
    which causes all the following ones to be bad. You are given an API bool
    isBadVersion(version) which returns whether version is bad. Implement a
    function to find the first bad version. You should minimize the number of
    calls to the API.

    Example 1:
    Input: n = 5, bad = 4
    Output: 4
    Explanation:
    call isBadVersion(3) -> false
    call isBadVersion(5) -> true
    call isBadVersion(4) -> true
    Then 4 is the first bad version.

    Example 2:
    Input: n = 1, bad = 1
    Output: 1

    Constraints: 1 <= bad <= n <= 2^31 - 1*/

    int firstBadVersion(int n) {
        int lo = 1, hi = n;
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (isBadVersion(mid)) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }


    /*279. Perfect Squares (Medium)
    Given an integer n, return the least number of perfect square numbers that
    sum to n. A perfect square is an integer that is the square of an integer;
    in other words, it is the product of some integer with itself. For example,
    1, 4, 9, and 16 are perfect squares while 3 and 11 are not.

    Example 1:
    Input: n = 12
    Output: 3
    Explanation: 12 = 4 + 4 + 4.

    Example 2:
    Input: n = 13
    Output: 2
    Explanation: 13 = 4 + 9.

    Constraints: 1 <= n <= 10^4*/

    int numSquares(int n) {
        /*Lagrange's four-square theorem which states that every natural
          number can be represented as the sum of four integer (including zero)
          squares; Legendre's three-square theorem which says a positive
          integer can be expressed as the sum of three squares iff it is not
          of the form 4^k(8m+7) for integers k and m.*/

        if (pow(int(sqrt(n)), 2) == n) return 1;
        for (int i = 1; i < sqrt(n); ++i)
            if (pow(int(sqrt(n-i*i)), 2) == n-i*i) return 2;
        for (; n % 4 == 0; n /= 4);
        return n % 8 != 7 ? 3 : 4;
    }


    /*280. Wiggle Sort (Medium)
    Given an integer array nums, reorder it such that
    nums[0] <= nums[1] >= nums[2] <= nums[3].... You may assume the input array
    always has a valid answer.

    Example 1:
    Input: nums = [3,5,2,1,6,4]
    Output: [3,5,1,6,2,4]
    Explanation: [1,6,2,5,3,4] is also accepted.

    Example 2:
    Input: nums = [6,6,5,6,3,8]
    Output: [6,6,5,6,3,8]

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 0 <= nums[i] <= 10^4
    * It is guaranteed that there will be an answer for the given input nums.

    Follow up: Could you solve the problem in O(n) time complexity?*/

    void wiggleSort(vector<int>& nums) {
        for (int i = 0; i < nums.size()-1; ++i)
            if (i&1 && nums[i] < nums[i+1] || !(i&1) && nums[i] > nums[i+1])
                swap(nums[i], nums[i+1]);
    }


    /*282. Expression Add Operators (Hard)
    Given a string num that contains only digits and an integer target, return
    all possibilities to add the binary operators '+', '-', or '*' between the
    digits of num so that the resultant expression evaluates to the target
    value.

    Example 1:
    Input: num = "123", target = 6
    Output: ["1*2*3","1+2+3"]

    Example 2:
    Input: num = "232", target = 8
    Output: ["2*3+2","2+3*2"]

    Example 3:
    Input: num = "105", target = 5
    Output: ["1*0+5","10-5"]

    Example 4:
    Input: num = "00", target = 0
    Output: ["0*0","0+0","0-0"]

    Example 5:
    Input: num = "3456237490", target = 9191
    Output: []

    Constraints:
    * 1 <= num.length <= 10
    * num consists of only digits.
    * -2^31 <= target <= 2^31 - 1*/

    vector<string> addOperators(string num, int target) {
        int n = num.size();
        vector<string> ans;

        function<void(int, string, long, long)> fn = [&](int i, string expr, long total, long last) {
            if (i == n) {
                if (total == target) ans.push_back(expr);
            } else {
                for (int ii = i; ii < (num[i] == '0' ? i+1 : n); ++ii) {
                    string ss = num.substr(i, ii-i+1);
                    long val = stol(ss);
                    if (i == 0) fn(ii+1, ss, val, val);
                    else {
                        fn(ii+1, expr + "*" + ss, total - last + last * val, last * val);
                        fn(ii+1, expr + "+" + ss, total + val, val);
                        fn(ii+1, expr + "-" + ss, total - val, -val);
                    }
                }
            }
        };

        fn(0, "", 0, 0);
        return ans;
    }


    /*283. Move Zeroes (Easy)
    Given an integer array nums, move all 0's to the end of it while
    maintaining the relative order of the non-zero elements. Note that you must
    do this in-place without making a copy of the array.

    Example 1:
    Input: nums = [0,1,0,3,12]
    Output: [1,3,12,0,0]

    Example 2:
    Input: nums = [0]
    Output: [0]

    Constraints:
    * 1 <= nums.length <= 10^4
    * -2^31 <= nums[i] <= 2^31 - 1

    Follow up: Could you minimize the total number of operations done?*/

    void moveZeroes(vector<int>& nums) {
        for (int i = 0, ii = 0; i < nums.size(); ++i) {
            if (nums[i])
                swap(nums[ii++], nums[i]);
        }
    }


    /*290. Word Pattern (Easy)
    Given a pattern and a string s, find if s follows the same pattern. Here
    follow means a full match, such that there is a bijection between a letter
    in pattern and a non-empty word in s.

    Example 1:
    Input: pattern = "abba", s = "dog cat cat dog"
    Output: true

    Example 2:
    Input: pattern = "abba", s = "dog cat cat fish"
    Output: false

    Example 3:
    Input: pattern = "aaaa", s = "dog cat cat dog"
    Output: false

    Example 4:
    Input: pattern = "abba", s = "dog dog dog dog"
    Output: false

    Constraints:
    * 1 <= pattern.length <= 300
    * pattern contains only lower-case English letters.
    * 1 <= s.length <= 3000
    * s contains only lower-case English letters and spaces ' '.
    * s does not contain any leading or trailing spaces.
    * All the words in s are separated by a single space.*/

    bool wordPattern(string pattern, string s) {
        istringstream iss(s);
        string buf;
        vector<string> words;
        while (iss >> buf) words.push_back(buf);

        if (pattern.size() != words.size()) return false;

        unordered_map<char, int> mpp;
        unordered_map<string, int> mpw;

        for (int i = 0; i < pattern.length(); ++i) {
            if (mpp[pattern[i]] != mpw[words[i]]) return false;
            mpp[pattern[i]] = mpw[words[i]] = i+1;
        }
        return true;
    }


    /*292. Nim Game (Easy)
    You are playing the following Nim Game with your friend:
    * Initially, there is a heap of stones on the table.
    * You and your friend will alternate taking turns, and you go first.
    * On each turn, the person whose turn it is will remove 1 to 3 stones from
      the heap.
    * The one who removes the last stone is the winner.
    Given n, the number of stones in the heap, return true if you can win the
    game assuming both you and your friend play optimally, otherwise return
    false.

    Example 1:
    Input: n = 4
    Output: false
    Explanation: These are the possible outcomes:
    1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.
    2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.
    3. You remove 3 stones. Your friend removes the last stone. Your friend wins.
    In all outcomes, your friend wins.

    Example 2:
    Input: n = 1
    Output: true

    Example 3:
    Input: n = 2
    Output: true

    Constraints: 1 <= n <= 2^31 - 1*/

    bool canWinNim(int n) {
        return n % 4;
    }


    /*296. Best Meeting Point (Hard)
    Given an m x n binary grid grid where each 1 marks the home of one friend,
    return the minimal total travel distance. The total travel distance is the
    sum of the distances between the houses of the friends and the meeting
    point. The distance is calculated using Manhattan Distance, where
    distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.

    Example 1:
    Input: grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]
    Output: 6
    Explanation: Given three friends living at (0,0), (0,4), and (2,2). The
                 point (0,2) is an ideal meeting point, as the total travel
                 distance of 2 + 2 + 2 = 6 is minimal. So return 6.

    Example 2:
    Input: grid = [[1,1]]
    Output: 1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 200
    * grid[i][j] is either 0 or 1.
    * There will be at least two friends in the grid.*/

    int minTotalDistance(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> rows, cols;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) {
                    rows.push_back(i);
                    cols.push_back(j);
                }
        sort(cols.begin(), cols.end());

        int ans = 0;
        for (int lo = 0, hi = rows.size()-1; lo < hi; ++lo, --hi)
            ans += rows[hi] - rows[lo] + cols[hi] - cols[lo];
        return ans;
    }


    /*300. Longest Increasing Subsequence (Medium)
    Given an integer array nums, return the length of the longest strictly
    increasing subsequence. A subsequence is a sequence that can be derived
    from an array by deleting some or no elements without changing the order of
    the remaining elements. For example, [3,6,2,7] is a subsequence of the
    array [0,3,1,6,2,2,7].

    Example 1:
    Input: nums = [10,9,2,5,3,7,101,18]
    Output: 4
    Explanation: The longest increasing subsequence is [2,3,7,101], therefore
                 the length is 4.

    Example 2:
    Input: nums = [0,1,0,3,2,3]
    Output: 4

    Example 3:
    Input: nums = [7,7,7,7,7,7,7]
    Output: 1

    Constraints:
    * 1 <= nums.length <= 2500
    * -10^4 <= nums[i] <= 10^4

    Follow up: Can you come up with an algorithm that runs in O(n log(n)) time
               complexity?*/

    int lengthOfLIS(vector<int>& nums) {
        vector<int> ans;
        for (auto& x : nums) {
            auto it = lower_bound(ans.begin(), ans.end(), x);
            if (it == ans.end()) ans.push_back(x);
            else *it = x;
        }
        return ans.size();
    }


    /*305. Number of Islands II (Hard)
    You are given an empty 2D binary grid grid of size m x n. The grid
    represents a map where 0's represent water and 1's represent land.
    Initially, all the cells of grid are water cells (i.e., all the cells are
    0's). We may perform an add land operation which turns the water at
    position into a land. You are given an array positions where
    positions[i] = [ri, ci] is the position (ri, ci) at which we should operate
    the ith operation. Return an array of integers answer where answer[i] is
    the number of islands after turning the cell (ri, ci) into a land. An
    island is surrounded by water and is formed by connecting adjacent lands
    horizontally or vertically. You may assume all four edges of the grid are
    all surrounded by water.

    Example 1:
    Input: m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
    Output: [1,1,2,3]
    Explanation: Initially, the 2d grid is filled with water.
                 - Operation #1: addLand(0, 0) turns the water at grid[0][0]
                                 into a land. We have 1 island.
                 - Operation #2: addLand(0, 1) turns the water at grid[0][1]
                                 into a land. We still have 1 island.
                 - Operation #3: addLand(1, 2) turns the water at grid[1][2]
                                 into a land. We have 2 islands.
                 - Operation #4: addLand(2, 1) turns the water at grid[2][1]
                                 into a land. We have 3 islands.

    Example 2:
    Input: m = 1, n = 1, positions = [[0,0]]
    Output: [1]

    Constraints:
    * 1 <= m, n, positions.length <= 10^4
    * 1 <= m * n <= 10^4
    * positions[i].length == 2
    * 0 <= ri < m
    * 0 <= ci < n

    Follow up: Could you solve it in time complexity O(k log(mn)), where
               k == positions.length?*/

    vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {
        vector<int> parent(m*n);
        iota(parent.begin(), parent.end(), 0);

        function<int(int)> find = [&](int p) {
            if (p != parent[p])
                parent[p] = find(parent[p]);
            return parent[p];
        };

        vector<int> ans;
        vector<vector<bool>> seen(m, vector<bool>(n));
        int prefix = 0, dir[5] = {1, 0, -1, 0, 1};
        for (auto& position : positions) {
            int i = position[0], j = position[1];
            if (not seen[i][j]) {
                ++prefix;
                seen[i][j] = true;
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && seen[ii][jj]) {
                        int p = find(i*n + j), pp = find(ii*n + jj);
                        if (p != pp) {
                            --prefix;
                            parent[p] = pp;
                        }
                    }
                }
            }
            ans.push_back(prefix);
        }
        return ans;
    }


    /*309. Best Time to Buy and Sell Stock with Cooldown (Medium)
    You are given an array prices where prices[i] is the price of a given stock
    on the ith day. Find the maximum profit you can achieve. You may complete
    as many transactions as you like (i.e., buy one and sell one share of the
    stock multiple times) with the following restrictions:
    * After you sell your stock, you cannot buy stock on the next day (i.e.,
      cooldown one day).
    Note: You may not engage in multiple transactions simultaneously (i.e., you
    must sell the stock before you buy again).

    Example 1:
    Input: prices = [1,2,3,0,2]
    Output: 3
    Explanation: transactions = [buy, sell, cooldown, buy, sell]

    Example 2:
    Input: prices = [1]
    Output: 0

    Constraints:
    * 1 <= prices.length <= 5000
    * 0 <= prices[i] <= 1000*/

    int maxProfit(vector<int>& prices) {
        // buy low & sell high
        int buy = INT_MAX, cooldown = 0, sell = 0;
        for (auto& x : prices) {
            buy = min(buy, x - cooldown);
            cooldown = sell;
            sell = max(sell, x - buy);
        }
        return sell;
    }


    /*310. Minimum Height Trees (Medium)
    A tree is an undirected graph in which any two vertices are connected by
    exactly one path. In other words, any connected graph without simple cycles
    is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array
    of n - 1 edges where edges[i] = [ai, bi] indicates that there is an
    undirected edge between the two nodes ai and bi in the tree, you can choose
    any node of the tree as the root. When you select a node x as the root, the
    result tree has height h. Among all possible rooted trees, those with
    minimum height (i.e. min(h))  are called minimum height trees (MHTs).
    Return a list of all MHTs' root labels. You can return the answer in any
    order. The height of a rooted tree is the number of edges on the longest
    downward path between the root and a leaf.

    Example 1:
    Input: n = 4, edges = [[1,0],[1,2],[1,3]]
    Output: [1]
    Explanation: As shown, the height of the tree is 1 when the root is the
                 node with label 1 which is the only MHT.

    Example 2:
    Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
    Output: [3,4]

    Example 3:
    Input: n = 1, edges = []
    Output: [0]

    Example 4:
    Input: n = 2, edges = [[0,1]]
    Output: [0,1]

    Constraints:
    * 1 <= n <= 2 * 10^4
    * edges.length == n - 1
    * 0 <= ai, bi < n
    * ai != bi
    * All the pairs (ai, bi) are distinct.
    * The given input is guaranteed to be a tree and there will be no repeated
      edges.*/

    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        unordered_set<int> graph[n];
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            graph[u].insert(v);
            graph[v].insert(u);
        }
        queue<int> q;
        for (int u = 0; u < n; ++u)
            if (graph[u].size() <= 1) q.push(u);
        while (n > 2) {
            n -= q.size();
            for (int sz = q.size(); sz; --sz) {
                int u = q.front(); q.pop();
                int v = *graph[u].begin();
                graph[v].erase(u);
                if (graph[v].size() == 1) q.push(v);
            }
        }
        vector<int> ans;
        for (; q.size(); q.pop())
            ans.push_back(q.front());
        return ans;
    }


    /*312. Burst Balloons (Hard)
    You are given n balloons, indexed from 0 to n - 1. Each balloon is painted
    with a number on it represented by an array nums. You are asked to burst
    all the balloons. If you burst the ith balloon, you will get
    nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of
    bounds of the array, then treat it as if there is a balloon with a 1
    painted on it. Return the maximum coins you can collect by bursting the
    balloons wisely.

    Example 1:
    Input: nums = [3,1,5,8]
    Output: 167
    Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
                 coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

    Example 2:
    Input: nums = [1,5]
    Output: 10

    Constraints:
    * n == nums.length
    * 1 <= n <= 500
    * 0 <= nums[i] <= 100*/

    int maxCoins(vector<int>& nums) {
        vector<int> vals(2, 1);
        vals.insert(vals.begin()+1, nums.begin(), nums.end());
        int n = vals.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = n-1; i >= 0; --i)
            for (int j = i; j < n; ++j)
                for (int k = i+1; k < j; ++k)
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + vals[i]*vals[k]*vals[j]);
        return dp[0].back();
    }


    /*316. Remove Duplicate Letters (Medium)
    Given a string s, remove duplicate letters so that every letter appears
    once and only once. You must make sure your result is the smallest in
    lexicographical order among all possible results.

    Example 1:
    Input: s = "bcabc"
    Output: "abc"

    Example 2:
    Input: s = "cbacdcbc"
    Output: "acdb"

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of lowercase English letters.

    Note: This question is the same as 1081:
          https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/*/

    string removeDuplicateLetters(string s) {
        vector<int> last(26, -1);
        for (int i = 0; i < s.size(); ++i) last[s[i] - 'a'] = i;
        string ans;
        for (int i = 0; i < s.size(); ++i)
            if (ans.find(s[i]) == string::npos) {
                while (ans.size() && ans.back() > s[i] && last[ans.back() - 'a'] > i) ans.pop_back();
                ans.push_back(s[i]);
            }
        return ans;
    }


    /*318. Maximum Product of Word Lengths (Medium)
    Given a string array words, return the maximum value of
    length(word[i]) * length(word[j]) where the two words do not share common
    letters. If no such two words exist, return 0.

    Example 1:
    Input: words = ["abcw","baz","foo","bar","xtfn","abcdef"]
    Output: 16
    Explanation: The two words can be "abcw", "xtfn".

    Example 2:
    Input: words = ["a","ab","abc","d","cd","bcd","abcd"]
    Output: 4
    Explanation: The two words can be "ab", "cd".

    Example 3:
    Input: words = ["a","aa","aaa","aaaa"]
    Output: 0
    Explanation: No such pair of words.

    Constraints:
    * 2 <= words.length <= 1000
    * 1 <= words[i].length <= 1000
    * words[i] consists only of lowercase English letters.*/

    int maxProduct(vector<string>& words) {
        unordered_map<int, int> mp;
        for (auto& word : words) {
            int mask = 0;
            for (auto& c : word)
                mask |= 1 << (c - 'a');
            mp[mask] = max(mp[mask], (int) size(word));
        }

        int ans = 0;
        for (auto& x : mp) {
            for (auto& y : mp) {
                if ((x.first & y.first) == 0) {
                    ans = max(ans, x.second * y.second);
                }
            }
        }
        return ans;
    }


    /*321. Create Maximum Number (Hard)
    You are given two integer arrays nums1 and nums2 of lengths m and n
    respectively. nums1 and nums2 represent the digits of two numbers. You are
    also given an integer k. Create the maximum number of length k <= m + n
    from digits of the two numbers. The relative order of the digits from the
    same array must be preserved. Return an array of the k digits representing
    the answer.

    Example 1:
    Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5
    Output: [9,8,6,5,3]

    Example 2:
    Input: nums1 = [6,7], nums2 = [6,0,4], k = 5
    Output: [6,7,6,0,4]

    Example 3:
    Input: nums1 = [3,9], nums2 = [8,9], k = 3
    Output: [9,8,9]

    Constraints:
    * m == nums1.length
    * n == nums2.length
    * 1 <= m, n <= 500
    * 0 <= nums1[i], nums2[i] <= 9
    * 1 <= k <= m + n*/

    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        vector<int> ans(k);

        auto fn = [](vector<int>& arr, int k) {
            vector<int> ans(k);
            for (int i = 0, n = 0; i < arr.size(); ++i) {
                while (n && ans[n-1] < arr[i] && n + arr.size() - i > k) --n;
                if (n < k) ans[n++] = arr[i];
            }
            return ans;
        };

        auto cmp = [](vector<int>& val1, int i1, vector<int>& val2, int i2) {
            for (; i1 < val1.size() && i2 < val2.size(); i1++, i2++) {
                if (val1[i1] > val2[i2]) return true;
                if (val1[i1] < val2[i2]) return false;
            }
            return i2 == val2.size();
        };

        for (int i = 0; i <= k; ++i) {
            if (i <= nums1.size() && k-i <= nums2.size()) {
                vector<int> val1 = fn(nums1, i), val2 = fn(nums2, k - i);
                vector<int> cand;
                for (int i1 = 0, i2 = 0; i1 < val1.size() || i2 < val2.size(); )
                    if (cmp(val1, i1, val2, i2)) cand.push_back(val1[i1++]);
                    else cand.push_back(val2[i2++]);
                ans = max(ans, cand);
            }
        }
        return ans;
    }


    /*322. Coin Change (Medium)
    You are given an integer array coins representing coins of different
    denominations and an integer amount representing a total amount of money.
    Return the fewest number of coins that you need to make up that amount. If
    that amount of money cannot be made up by any combination of the coins,
    return -1. You may assume that you have an infinite number of each kind of
    coin.

    Example 1:
    Input: coins = [1,2,5], amount = 11
    Output: 3
    Explanation: 11 = 5 + 5 + 1

    Example 2:
    Input: coins = [2], amount = 3
    Output: -1

    Example 3:
    Input: coins = [1], amount = 0
    Output: 0

    Example 4:
    Input: coins = [1], amount = 1
    Output: 1

    Example 5:
    Input: coins = [1], amount = 2
    Output: 2

    Constraints:
    * 1 <= coins.length <= 12
    * 1 <= coins[i] <= 2^31 - 1
    * 0 <= amount <= 10^4*/

    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1, amount+1);
        dp[0] = 0;
        for (int x = 1; x <= amount; ++x)
            for (auto& coin : coins)
                if (coin <= x)
                    dp[x] = min(dp[x], 1 + dp[x-coin]);
        return dp[amount] <= amount ? dp[amount] : -1;
    }


    /*328. Odd Even Linked List (Medium)
    Given the head of a singly linked list, group all the nodes with odd
    indices together followed by the nodes with even indices, and return the
    reordered list. The first node is considered odd, and the second node is
    even, and so on. Note that the relative order inside both the even and odd
    groups should remain as it was in the input. You must solve the problem in
    O(1) extra space complexity and O(n) time complexity.

    Example 1:
    Input: head = [1,2,3,4,5]
    Output: [1,3,5,2,4]

    Example 2:
    Input: head = [2,1,3,5,6,4,7]
    Output: [2,3,6,7,1,5,4]

    Constraints:
    * n == number of nodes in the linked list
    * 0 <= n <= 10^4
    * -10^6 <= Node.val <= 10^6*/

    ListNode* oddEvenList(ListNode* head) {
        if (head) {
            ListNode *odd = head, *even = head->next, *h0 = even;
            while (even && even->next) {
                odd = odd->next = odd->next->next;
                even = even->next = even->next->next;
            }
            odd->next = h0;
        }
        return head;
    }


    /*329. Longest Increasing Path in a Matrix (Hard)
    Given an m x n integers matrix, return the length of the longest increasing
    path in matrix. From each cell, you can either move in four directions:
    left, right, up, or down. You may not move diagonally or move outside the
    boundary (i.e., wrap-around is not allowed).

    Example 1:
    Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
    Output: 4
    Explanation: The longest increasing path is [1, 2, 6, 9].

    Example 2:
    Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
    Output: 4
    Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.

    Example 3:
    Input: matrix = [[1]]
    Output: 1

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 200
    * 0 <= matrix[i][j] <= 2^31 - 1*/

    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        vector<vector<int>> indeg(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && matrix[i][j] < matrix[ii][jj])
                        ++indeg[ii][jj];
                }

        queue<pair<int, int>> q;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (indeg[i][j] == 0) q.emplace(i, j);

        int ans = 0;
        for (; q.size(); ++ans)
            for (int sz = q.size(); sz; --sz) {
                auto [i, j] = q.front(); q.pop();
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && matrix[i][j] < matrix[ii][jj])
                        if (--indeg[ii][jj] == 0) q.emplace(ii, jj);
                }
            }
        return ans;
    }


    /*330. Patching Array (Hard)
    Given a sorted integer array nums and an integer n, add/patch elements to
    the array such that any number in the range [1, n] inclusive can be formed
    by the sum of some elements in the array. Return the minimum number of
    patches required.

    Example 1:
    Input: nums = [1,3], n = 6
    Output: 1
    Explanation: Combinations of nums are [1], [3], [1,3], which form possible
                 sums of: 1, 3, 4. Now if we add/patch 2 to nums, the
                 combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
                 Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range
                 [1, 6]. So we only need 1 patch.

    Example 2:
    Input: nums = [1,5,10], n = 20
    Output: 2
    Explanation: The two patches can be [2, 4].

    Example 3:
    Input: nums = [1,2,2], n = 5
    Output: 0

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^4
    * nums is sorted in ascending order.
    * 1 <= n <= 2^31 - 1*/

    int minPatches(vector<int>& nums, int n) {
        int ans = 0;
        for (unsigned prefix = 0, k = 0; prefix < n; )
            if (k < nums.size() && nums[k] <= prefix + 1)
                prefix += nums[k++];
            else {
                ++ans;
                prefix += prefix++;
            }
        return ans;
    }


    /*331. Verify Preorder Serialization of a Binary Tree (Medium)
    One way to serialize a binary tree is to use preorder traversal. When we
    encounter a non-null node, we record the node's value. If it is a null node,
    we record using a sentinel value such as '#'. For example, the above binary
    tree can be serialized to the string "9,3,4,#,#,1,#,#,2,#,6,#,#", where '#'
    represents a null node. Given a string of comma-separated values preorder,
    return true if it is a correct preorder traversal serialization of a binary
    tree. It is guaranteed that each comma-separated value in the string must
    be either an integer or a character '#' representing null pointer. You may
    assume that the input format is always valid. For example, it could never
    contain two consecutive commas, such as "1,,3". Note that you are not
    allowed to reconstruct the tree.

    Example 1:
    Input: preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
    Output: true

    Example 2:
    Input: preorder = "1,#"
    Output: false

    Example 3:
    Input: preorder = "9,#,#,1"
    Output: false

    Constraints:
    * 1 <= preorder.length <= 10^4
    * preoder consist of integers in the range [0, 100] and '#' separated by
      commas ','.*/

    bool isValidSerialization(string preorder) {
        int cnt = 1;
        // split string by delimiter
        for (int i = 0, ii = 0; ii != string::npos; i = ii+1) {
            if (cnt == 0) return false;
            ii = preorder.find(',', i);
            string elem = preorder.substr(i, (ii == string::npos ? preorder.size() : ii) - i);
            if (elem == "#") cnt -= 1;
            else cnt += 1;
        }
        return cnt == 0;
    }


    /*334. Increasing Triplet Subsequence (Medium)
    Given an integer array nums, return true if there exists a triple of
    indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If
    no such indices exists, return false.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: true
    Explanation: Any triplet where i < j < k is valid.

    Example 2:
    Input: nums = [5,4,3,2,1]
    Output: false
    Explanation: No triplet exists.

    Example 3:
    Input: nums = [2,1,5,0,4,6]
    Output: true
    Explanation: The triplet (3, 4, 5) is valid because
                 nums[3] == 0 < nums[4] == 4 < nums[5] == 6.

    Constraints:
    * 1 <= nums.length <= 5 * 10^5
    * -2^31 <= nums[i] <= 2^31 - 1

    Follow up: Could you implement a solution that runs in O(n) time complexity
               and O(1) space complexity?*/

    bool increasingTriplet(vector<int>& nums) {
        int x0 = INT_MAX, x1 = INT_MAX;
        for (auto& x : nums)
            if (x <= x0) x0 = x;
            else if (x <= x1) x1 = x;
            else return true;
        return false;
    }


    /*337. House Robber III (Medium)
    The thief has found himself a new place for his thievery again. There is
    only one entrance to this area, called root. Besides the root, each house
    has one and only one parent house. After a tour, the smart thief realized
    that all houses in this place form a binary tree. It will automatically
    contact the police if two directly-linked houses were broken into on the
    same night. Given the root of the binary tree, return the maximum amount of
    money the thief can rob without alerting the police.

    Example 1:
    Input: root = [3,2,3,null,3,null,1]
    Output: 7
    Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.

    Example 2:
    Input: root = [3,4,5,1,3,null,1]
    Output: 9
    Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * 0 <= Node.val <= 10^4*/

    int rob(TreeNode* root) {

        function<pair<int, int>(TreeNode*)> fn = [&](TreeNode* node) -> pair<int, int> {
            if (!node) return {0, 0};
            if (!node->left && !node->right) return {node->val, 0};
            auto [lx, ly] = fn(node->left);
            auto [rx, ry] = fn(node->right);
            return {node->val + ly + ry, max(lx, ly) + max(rx, ry)};
        };

        auto [x, y] = fn(root);
        return max(x, y);
    }


    /*338. Counting Bits (Easy)
    Given an integer n, return an array ans of length n + 1 such that for each
    i (0 <= i <= n), ans[i] is the number of 1's in the binary representation
    of i.

    Example 1:
    Input: n = 2
    Output: [0,1,1]
    Explanation: 0 --> 0
                 1 --> 1
                 2 --> 10

    Example 2:
    Input: n = 5
    Output: [0,1,1,2,1,2]
    Explanation: 0 --> 0
                 1 --> 1
                 2 --> 10
                 3 --> 11
                 4 --> 100
                 5 --> 101

    Constraints: 0 <= n <= 10^5

    Follow up: It is very easy to come up with a solution with a runtime of
               O(n log n). Can you do it in linear time O(n) and possibly in a
               single pass? Can you do it without using any built-in function
               (i.e., like __builtin_popcount in C++)?*/

    vector<int> countBits(int n) {
        vector<int> ans(n+1);
        for (int x = 1; x <= n; ++x)
            ans[x] = ans[x&(x-1)] + 1;
        return ans;
    }


    /*343. Integer Break (Medium)
    Given an integer n, break it into the sum of k positive integers, where
    k >= 2, and maximize the product of those integers. Return the maximum
    product you can get.

    Example 1:
    Input: n = 2
    Output: 1
    Explanation: 2 = 1 + 1, 1 × 1 = 1.

    Example 2:
    Input: n = 10
    Output: 36
    Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.

    Constraints: 2 <= n <= 58*/

    int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n % 3 == 0) return pow(3, n/3);
        if (n % 3 == 1) return 4*pow(3, (n-4)/3);
        return 2*pow(3, (n-2)/3);
    }


    /*344. Reverse String (Easy)
    Write a function that reverses a string. The input string is given as an
    array of characters s.

    Example 1:
    Input: s = ["h","e","l","l","o"]
    Output: ["o","l","l","e","h"]

    Example 2:
    Input: s = ["H","a","n","n","a","h"]
    Output: ["h","a","n","n","a","H"]

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is a printable ascii character.

    Follow up: Do not allocate extra space for another array. You must do this
               by modifying the input array in-place with O(1) extra memory.*/

    void reverseString(vector<char>& s) {
        reverse(s.begin(), s.end());
    }


    /*347. Top K Frequent Elements (Medium)
    Given an integer array nums and an integer k, return the k most frequent
    elements. You may return the answer in any order.

    Example 1:
    Input: nums = [1,1,1,2,2,3], k = 2
    Output: [1,2]

    Example 2:
    Input: nums = [1], k = 1
    Output: [1]

    Constraints:
    * 1 <= nums.length <= 10^5
    * k is in the range [1, the number of unique elements in the array].
    * It is guaranteed that the answer is unique.

    Follow up: Your algorithm's time complexity must be better than O(n log n),
               where n is the array's size.*/

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];

        int n = nums.size();
        vector<vector<int>> bucket(n+1);
        for (auto& [x, v] : freq) bucket[v].push_back(x);

        vector<int> ans;
        for (int x = n; x > 0; --x)
            if (ans.size() < k)
                for (auto& xx : bucket[x])
                    ans.push_back(xx);
            else break;
        return ans;
    }


    /*350. Intersection of Two Arrays II (Easy)
    Given two integer arrays nums1 and nums2, return an array of their
    intersection. Each element in the result must appear as many times as it
    shows in both arrays and you may return the result in any order.

    Example 1:
    Input: nums1 = [1,2,2,1], nums2 = [2,2]
    Output: [2,2]

    Example 2:
    Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
    Output: [4,9]
    Explanation: [9,4] is also accepted.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 1000
    * 0 <= nums1[i], nums2[i] <= 1000

    Follow up:
    * What if the given array is already sorted? How would you optimize your
      algorithm?
    * What if nums1's size is small compared to nums2's size? Which algorithm
      is better?
    * What if elements of nums2 are stored on disk, and the memory is limited
      such that you cannot load all elements into the memory at once?*/

    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> freq;
        for (auto& x : nums1) ++freq[x];
        vector<int> ans;
        for (auto& x : nums2)
            if (freq[x]-- > 0) ans.push_back(x);
        return ans;
    }


    /*351. Android Unlock Patterns (Medium)
    Android devices have a special lock screen with a 3 x 3 grid of dots. Users
    can set an "unlock pattern" by connecting the dots in a specific sequence,
    forming a series of joined line segments where each segment's endpoints are
    two consecutive dots in the sequence. A sequence of k dots is a valid
    unlock pattern if both of the following are true:
    * All the dots in the sequence are distinct.
    * If the line segment connecting two consecutive dots in the sequence
      passes through the center of any other dot, the other dot must have
      previously appeared in the sequence. No jumps through the center non-
      selected dots are allowed.
      + For example, connecting dots 2 and 9 without dots 5 or 6 appearing
        beforehand is valid because the line from dot 2 to dot 9 does not pass
        through the center of either dot 5 or 6.
      + However, connecting dots 1 and 3 without dot 2 appearing beforehand is
        invalid because the line from dot 1 to dot 3 passes through the center
        of dot 2.

    Two unlock patterns are considered unique if there is a dot in one sequence
    that is not in the other, or the order of the dots is different.

    Example 1:
    Input: m = 1, n = 1
    Output: 9

    Example 2:
    Input: m = 1, n = 2
    Output: 65

    Constraints: 1 <= m, n <= 9*/

    int numberOfPatterns(int m, int n) {
        vector<vector<int>> skip(10, vector<int>(10, 0));
        skip[1][3] = skip[3][1] = 2;
        skip[1][7] = skip[7][1] = 4;
        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5;
        skip[3][9] = skip[9][3] = 6;
        skip[7][9] = skip[9][7] = 8;

        map<pair<int, int>, int> memo;
        function<int(int, int)> fn = [&](int x, int mask) {
            int ans = 0, size = __builtin_popcount(mask);
            for (int xx = 1; xx <= 9; ++xx)
                if ((mask & (1 << xx)) == 0 && (skip[x][xx] == 0 || (mask & (1 << skip[x][xx]))))
                    ans += fn(xx, mask^(1 << xx));
            if (m <= size && size <= n) ++ans;
            return ans;
        };

        return fn(0, 0);
    }


    /*358. Rearrange String k Distance Apart (Hard)
    Given a string s and an integer k, rearrange s such that the same
    characters are at least distance k from each other. If it is not possible
    to rearrange the string, return an empty string "".

    Example 1:
    Input: s = "aabbcc", k = 3
    Output: "abcabc"
    Explanation: The same letters are at least a distance of 3 from each other.

    Example 2:
    Input: s = "aaabc", k = 3
    Output: ""
    Explanation: It is not possible to rearrange the string.

    Example 3:
    Input: s = "aaadbbcc", k = 2
    Output: "abacabcd"
    Explanation: The same letters are at least a distance of 2 from each other.

    Constraints:
    * 1 <= s.length <= 3 * 10^5
    * s consists of only lowercase English letters.
    * 0 <= k <= s.length*/

    string rearrangeString(string s, int k) {
        string ans;
        vector<int> freq(26), prev(26, -k);
        for (auto& ch : s) ++freq[ch-'a'];
        for (int i = 0; i < s.size(); ++i) {
            int m = -1;
            for (int c = 0; c < 26; ++c)
                if (freq[c] && (m == -1 || freq[c] > freq[m]) && i - prev[c] >= k) m = c;
            if (m == -1) return "";
            ans.push_back(m+'a');
            --freq[m];
            prev[m] = i;
        }
        return ans;
    }


    /*363. Max Sum of Rectangle No Larger Than K (Hard)
    Given an m x n matrix matrix and an integer k, return the max sum of a
    rectangle in the matrix such that its sum is no larger than k. It is
    guaranteed that there will be a rectangle with a sum no larger than k.

    Example 1:
    Input: matrix = [[1,0,1],[0,-2,3]], k = 2
    Output: 2
    Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2,
                 and 2 is the max number no larger than k (k = 2).

    Example 2:
    Input: matrix = [[2,2,-1]], k = 3
    Output: 3

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 100
    * -100 <= matrix[i][j] <= 100
    * -10^5 <= k <= 10^5

    Follow up: What if the number of rows is much larger than the number of
               columns?*/

    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {
        int m = size(matrix), n = size(matrix[0]);
        vector<vector<int>> rsum(m, vector<int>(n+1));

        int ans = INT_MIN;
        for (int j = 0; j < n; ++j) {
            for (int i = 0; i < m; ++i) rsum[i][j+1] = matrix[i][j] + rsum[i][j];
            for (int jj = 0; jj <= j; ++jj) {
                int prefix = 0;
                set<int> seen;
                for (int i = 0; i < m; ++i) {
                    seen.insert(prefix);
                    prefix += rsum[i][j+1] - rsum[i][jj];
                    auto it = seen.lower_bound(prefix - k);
                    if (it != seen.end()) ans = max(ans, prefix - *it);
                }
            }
        }
        return ans;
    }


    /*368. Largest Divisible Subset (Medium)
    Given a set of distinct positive integers nums, return the largest subset
    answer such that every pair (answer[i], answer[j]) of elements in this
    subset satisfies:
    * answer[i] % answer[j] == 0, or
    * answer[j] % answer[i] == 0
    If there are multiple solutions, return any of them.

    Example 1:
    Input: nums = [1,2,3]
    Output: [1,2]
    Explanation: [1,3] is also accepted.

    Example 2:
    Input: nums = [1,2,4,8]
    Output: [1,2,4,8]

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 2 * 10^9
    * All the integers in nums are unique.*/

    vector<int> largestDivisibleSubset(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<int> dp(n, 1);
        for (int i = 0; i < n; ++i)
            for (int ii = 0; ii < i; ++ii)
                if (nums[i] % nums[ii] == 0)
                    dp[i] = max(dp[i], 1 + dp[ii]);

        auto it = max_element(dp.begin(), dp.end());
        vector<int> ans;
        for (int i = it - dp.begin(), val = *it; i >= 0; --i)
            if (ans.empty() || (ans.back() % nums[i] == 0 && dp[i] == val)) {
                --val;
                ans.push_back(nums[i]);
            }
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*371. Sum of Two Integers (Medium)
    Given two integers a and b, return the sum of the two integers without
    using the operators + and -.

    Example 1:
    Input: a = 1, b = 2
    Output: 3

    Example 2:
    Input: a = 2, b = 3
    Output: 5

    Constraints: -1000 <= a, b <= 1000*/

    int getSum(int a, int b) {
        while (b) {
            int diff = a^b, carry = (unsigned)(a&b) << 1;
            a = diff;
            b = carry;
        }
        return a;
    }


    /*374. Guess Number Higher or Lower (Easy)
    We are playing the Guess Game. The game is as follows:
    * I pick a number from 1 to n. You have to guess which number I picked.
    * Every time you guess wrong, I will tell you whether the number I picked
      is higher or lower than your guess.
    You call a pre-defined API int guess(int num), which returns 3 possible
    results:
    * -1: The number I picked is lower than your guess (i.e. pick < num).
    * 1: The number I picked is higher than your guess (i.e. pick > num).
    * 0: The number I picked is equal to your guess (i.e. pick == num).
    Return the number that I picked.

    Example 1:
    Input: n = 10, pick = 6
    Output: 6

    Example 2:
    Input: n = 1, pick = 1
    Output: 1

    Example 3:
    Input: n = 2, pick = 1
    Output: 1

    Example 4:
    Input: n = 2, pick = 2
    Output: 2

    Constraints:
    * 1 <= n <= 2^31 - 1
    * 1 <= pick <= n*/

    int guessNumber(int n) {
        for (int lo = 1, hi = n; lo <= hi; ) {
            int mid = lo + (hi - lo)/2, val = guess(mid);
            if (val == -1) hi = mid - 1;
            else if (val == 0) return mid;
            else lo = mid + 1;
        }
        return -1;
    }


    /*376. Wiggle Subsequence (Medium)
    A wiggle sequence is a sequence where the differences between successive
    numbers strictly alternate between positive and negative. The first
    difference (if one exists) may be either positive or negative. A sequence
    with one element and a sequence with two non-equal elements are trivially
    wiggle sequences. For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence
    because the differences (6, -3, 5, -7, 3) alternate between positive and
    negative. In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle
    sequences. The first is not because its first two differences are positive,
    and the second is not because its last difference is zero. A subsequence is
    obtained by deleting some elements (possibly zero) from the original
    sequence, leaving the remaining elements in their original order. Given an
    integer array nums, return the length of the longest wiggle subsequence of
    nums.

    Example 1:
    Input: nums = [1,7,4,9,2,5]
    Output: 6
    Explanation: The entire sequence is a wiggle sequence with differences
                 (6, -3, 5, -7, 3).

    Example 2:
    Input: nums = [1,17,5,10,13,15,10,5,16,8]
    Output: 7
    Explanation: There are several subsequences that achieve this length. One
                 is [1, 17, 10, 13, 10, 16, 8] with differences
                 (16, -7, 3, -3, 6, -8).

    Example 3:
    Input: nums = [1,2,3,4,5,6,7,8,9]
    Output: 2

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 1000

    Follow up: Could you solve this in O(n) time?*/

    int wiggleMaxLength(vector<int>& nums) {
        int ans = 1;
        for (int i = 1, prev = 0; i < nums.size(); ++i) {
            int diff = nums[i] - nums[i-1];
            if (diff != 0) {
                if (prev * diff <= 0) ++ans;
                prev = diff;
            }
        }
        return ans;
    }


    /*377. Combination Sum IV (Medium)
    Given an array of distinct integers nums and a target integer target,
    return the number of possible combinations that add up to target. The
    answer is guaranteed to fit in a 32-bit integer.

    Example 1:
    Input: nums = [1,2,3], target = 4
    Output: 7
    Explanation:
    The possible combination ways are:
    (1, 1, 1, 1)
    (1, 1, 2)
    (1, 2, 1)
    (1, 3)
    (2, 1, 1)
    (2, 2)
    (3, 1)
    Note that different sequences are counted as different combinations.

    Example 2:
    Input: nums = [9], target = 3
    Output: 0

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= 1000
    * All the elements of nums are unique.
    * 1 <= target <= 1000

    Follow up: What if negative numbers are allowed in the given array? How
               does it change the problem? What limitation we need to add to
               the question to allow negative numbers?*/

    int combinationSum4(vector<int>& nums, int target) {
        vector<unsigned> dp(target+1);
        dp[0] = 1;
        for (int i = 0; i < target; ++i)
            if (dp[i])
                for (auto& x : nums)
                    if (i + x <= target) dp[i+x] += dp[i];
        return dp[target];
    }


    /*378. Kth Smallest Element in a Sorted Matrix (Medium)
    Given an n x n matrix where each of the rows and columns are sorted in
    ascending order, return the kth smallest element in the matrix. Note that
    it is the kth smallest element in the sorted order, not the kth distinct
    element.

    Example 1:
    Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
    Output: 13
    Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and
                 the 8th smallest number is 13

    Example 2:
    Input: matrix = [[-5]], k = 1
    Output: -5

    Constraints:
    * n == matrix.length
    * n == matrix[i].length
    * 1 <= n <= 300
    * -10^9 <= matrix[i][j] <= 10^9
    * All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order.
    * 1 <= k <= n^2*/

    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int n = matrix.size();
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // min-heap
        for (int i = 0; i < n; ++i)
            pq.emplace(matrix[i][0], i*n);

        while (--k) {
            auto [val, i] = pq.top(); pq.pop();
            int j = i%n;
            if (j+1 < n) pq.emplace(matrix[i/n][j+1], i+1);
        }
        return pq.top().first;
    }


    /*383. Ransom Note (Easy)
    Given two stings ransomNote and magazine, return true if ransomNote can be
    constructed from magazine and false otherwise. Each letter in magazine can
    only be used once in ransomNote.

    Example 1:
    Input: ransomNote = "a", magazine = "b"
    Output: false

    Example 2:
    Input: ransomNote = "aa", magazine = "ab"
    Output: false

    Example 3:
    Input: ransomNote = "aa", magazine = "aab"
    Output: true

    Constraints:
    * 1 <= ransomNote.length, magazine.length <= 10^5
    * ransomNote and magazine consist of lowercase English letters.*/

    bool canConstruct(string ransomNote, string magazine) {
        int freq[26] = {0};
        for (auto& ch : magazine) ++freq[ch-'a'];
        for (auto& ch : ransomNote)
            if (--freq[ch-'a'] < 0) return false; ;
        return true;
    }


    /*387. First Unique Character in a String (Easy)
    Given a string s, find the first non-repeating character in it and return
    its index. If it does not exist, return -1.

    Example 1:
    Input: s = "leetcode"
    Output: 0

    Example 2:
    Input: s = "loveleetcode"
    Output: 2

    Example 3:
    Input: s = "aabb"
    Output: -1

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of only lowercase English letters.*/

    int firstUniqChar(string s) {
        unordered_map<char, int> freq;
        for (auto& ch : s) ++freq[ch];
        for (int i = 0; i < s.size(); ++i)
            if (freq[s[i]] == 1) return i;
        return -1;
    }


    /*389. Find the Difference (Easy)
    You are given two strings s and t. String t is generated by random
    shuffling string s and then add one more letter at a random position.
    Return the letter that was added to t.

    Example 1:
    Input: s = "abcd", t = "abcde"
    Output: "e"
    Explanation: 'e' is the letter that was added.

    Example 2:
    Input: s = "", t = "y"
    Output: "y"

    Constraints:
    * 0 <= s.length <= 1000
    * t.length == s.length + 1
    * s and t consist of lowercase English letters.*/

    char findTheDifference(string s, string t) {
        char ans = 0;
        for (auto& ch : s) ans ^= ch;
        for (auto& ch : t) ans ^= ch;
        return ans;
    }


    /*390. Elimination Game (Medium)
    You have a list arr of all integers in the range [1, n] sorted in a
    strictly increasing order. Apply the following algorithm on arr:
    * Starting from left to right, remove the first number and every other
      number afterward until you reach the end of the list.
    * Repeat the previous step again, but this time from right to left, remove
      the rightmost number and every other number from the remaining numbers.
    * Keep repeating the steps again, alternating left to right and right to
      left, until a single number remains.
    Given the integer n, return the last number that remains in arr.

    Example 1:
    Input: n = 9
    Output: 6
    Explanation: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
                 arr = [2, 4, 6, 8]
                 arr = [2, 6]
                 arr = [6]

    Example 2:
    Input: n = 1
    Output: 1

    Constraints: 1 <= n <= 10^9*/

    int lastRemaining(int n) {
        if (n == 1) return 1;
        if (n&1) --n;
        return n+2-2*lastRemaining(n >> 1);
    }


    /*392. Is Subsequence (Easy)
    Given two strings s and t, return true if s is a subsequence of t, or false
    otherwise. A subsequence of a string is a new string that is formed from
    the original string by deleting some (can be none) of the characters
    without disturbing the relative positions of the remaining characters. (i.e.,
    "ace" is a subsequence of "abcde" while "aec" is not).

    Example 1:
    Input: s = "abc", t = "ahbgdc"
    Output: true

    Example 2:
    Input: s = "axc", t = "ahbgdc"
    Output: false

    Constraints:
    * 0 <= s.length <= 100
    * 0 <= t.length <= 10^4
    * s and t consist only of lowercase English letters.

    Follow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where
               k >= 10^9, and you want to check one by one to see if t has its
               subsequence. In this scenario, how would you change your code?*/

    bool isSubsequence(string s, string t) {
        int i = 0;
        for (int j = 0; i < s.size() && j < t.size(); ++j)
            if (s[i] == t[j]) ++i;
        return i == s.size();
    }


    /*394. Decode String (Medium)
    Given an encoded string, return its decoded string. The encoding rule is:
    k[encoded_string], where the encoded_string inside the square brackets is
    being repeated exactly k times. Note that k is guaranteed to be a positive
    integer. You may assume that the input string is always valid; No extra
    white spaces, square brackets are well-formed, etc. Furthermore, you may
    assume that the original data does not contain any digits and that digits
    are only for those repeat numbers, k. For example, there won't be input
    like 3a or 2[4].

    Example 1:
    Input: s = "3[a]2[bc]"
    Output: "aaabcbc"

    Example 2:
    Input: s = "3[a2[c]]"
    Output: "accaccacc"

    Example 3:
    Input: s = "2[abc]3[cd]ef"
    Output: "abcabccdcdcdef"

    Example 4:
    Input: s = "abc3[cd]xyz"
    Output: "abccdcdcdxyz"

    Constraints:
    * 1 <= s.length <= 30
    * s consists of lowercase English letters, digits, and square brackets '[]'.
    * s is guaranteed to be a valid input.
    * All the integers in s are in the range [1, 300].*/

    string decodeString(string s) {
        string nn, ss;
        stack<string> stk;
        for (auto& ch : s) {
            if (ch == '[') {
                stk.push(ss);
                stk.push(nn);
                nn = ss = "";
            } else if (ch == ']') {
                string tmp;
                for (int k = stoi(stk.top()); k; --k) tmp += ss;
                ss = tmp; stk.pop();
                ss = stk.top() + ss; stk.pop();
            } else if (isdigit(ch)) nn.push_back(ch);
            else ss.push_back(ch);
        }
        return ss;
    }


    /*400. Nth Digit (Medium)
    Given an integer n, return the nth digit of the infinite integer sequence
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].

    Example 1:
    Input: n = 3
    Output: 3

    Example 2:
    Input: n = 11
    Output: 0
    Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                 11, ... is a 0, which is part of the number 10.

    Constraints: 1 <= n <= 2^31 - 1*/

    int findNthDigit(int n) {
        long base = 1, mult = 1;
        for (; n > 9*base*mult; n -= 9*base*mult, base *= 10, ++mult);
        int q = (n-1)/mult, r = (n-1) % mult;
        return to_string(q+base)[r] - '0';
    }


    /*402. Remove K Digits (Medium)
    Given string num representing a non-negative integer num, and an integer k,
    return the smallest possible integer after removing k digits from num.

    Example 1:
    Input: num = "1432219", k = 3
    Output: "1219"
    Explanation: Remove the three digits 4, 3, and 2 to form the new number
                 1219 which is the smallest.

    Example 2:
    Input: num = "10200", k = 1
    Output: "200"
    Explanation: Remove the leading 1 and the number is 200. Note that the
                 output must not contain leading zeroes.

    Example 3:
    Input: num = "10", k = 2
    Output: "0"
    Explanation: Remove all the digits from the number and it is left with
                 nothing which is 0.

    Constraints:
    * 1 <= k <= num.length <= 10^5
    * num consists of only digits.
    * num does not have any leading zeros except for the zero itself.*/

    string removeKdigits(string num, int k) {
        string ans;
        for (auto& ch : num) {
            while (k && ans.size() && ans.back() > ch) {
                --k;
                ans.pop_back();
            }
            if (ans.size() || ch != '0') ans.push_back(ch);
        }
        while (k-- && ans.size()) ans.pop_back();
        return ans.size() ? ans : "0";
    }


    /*403. Frog Jump (Hard)
    A frog is crossing a river. The river is divided into some number of units,
    and at each unit, there may or may not exist a stone. The frog can jump on
    a stone, but it must not jump into the water. Given a list of stones'
    positions (in units) in sorted ascending order, determine if the frog can
    cross the river by landing on the last stone. Initially, the frog is on the
    first stone and assumes the first jump must be 1 unit. If the frog's last
    jump was k units, its next jump must be either k - 1, k, or k + 1 units.
    The frog can only jump in the forward direction.

    Example 1:
    Input: stones = [0,1,3,5,6,8,12,17]
    Output: true
    Explanation: The frog can jump to the last stone by jumping 1 unit to the
                 2nd stone, then 2 units to the 3rd stone, then 2 units to the
                 4th stone, then 3 units to the 6th stone, 4 units to the 7th
                 stone, and 5 units to the 8th stone.

    Example 2:
    Input: stones = [0,1,2,3,4,8,9,11]
    Output: false
    Explanation: There is no way to jump to the last stone as the gap between
                 the 5th and 6th stone is too large.

    Constraints:
    * 2 <= stones.length <= 2000
    * 0 <= stones[i] <= 2^31 - 1
    * stones[0] == 0*/

    bool canCross(vector<int>& stones) {
        int n = size(stones);
        unordered_map<int, int> loc;
        for (int i = 0; i < n; ++i) loc[stones[i]] = i;

        vector<unordered_set<int>> dp(n);
        dp[0].insert(1);

        for (int i = 0; i < n; ++i)
            for (auto& step : dp[i])
                if (0 < step) {
                    int pos = stones[i] + step;
                    if (pos == stones.back()) return true;
                    if (loc.count(pos)) {
                        int ii = loc[pos];
                        dp[ii].insert(step-1);
                        dp[ii].insert(step);
                        dp[ii].insert(step+1);
                    }
                }
        return false;
    }


    /*404. Sum of Left Leaves (Easy)
    Given the root of a binary tree, return the sum of all left leaves.

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
    Output: 24
    Explanation: There are two left leaves in the binary tree, with values 9
                 and 15 respectively.

    Example 2:
    Input: root = [1]
    Output: 0

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * -1000 <= Node.val <= 1000*/

    int sumOfLeftLeaves(TreeNode* root) {
        int ans = 0;
        stack<pair<TreeNode*, bool>> stk;
        stk.emplace(root, false);
        while (stk.size()) {
            auto [node, tf] = stk.top(); stk.pop();
            if (!node->left && !node->right && tf) ans += node->val;
            if (node->left) stk.emplace(node->left, true);
            if (node->right) stk.emplace(node->right, false);
        }
        return ans;
    }


    /*407. Trapping Rain Water II (Hard)
    Given an m x n integer matrix heightMap representing the height of each
    unit cell in a 2D elevation map, return the volume of water it can trap
    after raining.

    Example 1:
    Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
    Output: 4
    Explanation: After the rain, water is trapped between the blocks. We have
                 two small pounds 1 and 3 units trapped. The total volume of
                 water trapped is 4.

    Example 2:
    Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
    Output: 10

    Constraints:
    * m == heightMap.length
    * n == heightMap[i].length
    * 1 <= m, n <= 200
    * 0 <= heightMap[i][j] <= 2 * 10^4*/

    int trapRainWater(vector<vector<int>>& heightMap) {
        int m = heightMap.size(), n = heightMap[0].size();

        priority_queue<array<int,3>, vector<array<int,3>>, greater<>> pq; // min-heap
        for (int i = 0; i < m; ++i) {
            pq.push({heightMap[i][0], i, 0});
            pq.push({heightMap[i][n-1], i, n-1});
        }
        for (int j = 1; j < n-1; ++j) {
            pq.push({heightMap[0][j], 0, j});
            pq.push({heightMap[m-1][j], m-1, j});
        }

        int ans = 0, most = 0, dir[5] = {-1, 0, 1, 0, -1};
        while (pq.size()) {
            auto elem = pq.top(); pq.pop();
            int ht = elem[0], i = elem[1], j = elem[2];
            most = max(most, ht);
            for (int k = 0; k < 4; ++k) {
                int ii = i + dir[k], jj = j + dir[k+1];
                if (0 < ii && ii < m-1 && 0 < jj && jj < n-1 && heightMap[ii][jj] != -1) {
                    ans += max(0, most - heightMap[ii][jj]);
                    pq.push({heightMap[ii][jj], ii, jj});
                    heightMap[ii][jj] = -1;
                }
            }
        }
        return ans;
    }


    /*409. Longest Palindrome (Easy)
    Given a string s which consists of lowercase or uppercase letters, return
    the length of the longest palindrome that can be built with those letters.
    Letters are case sensitive, for example, "Aa" is not considered a
    palindrome here.

    Example 1:
    Input: s = "abccccdd"
    Output: 7
    Explanation: One longest palindrome that can be built is "dccaccd", whose
                 length is 7.

    Example 2:
    Input: s = "a"
    Output: 1

    Example 3:
    Input: s = "bb"
    Output: 2

    Constraints:
    * 1 <= s.length <= 2000
    * s consists of lowercase and/or uppercase English letters only.*/

    int longestPalindrome(string s) {
        unordered_map<char, int> freq;
        for (auto& ch : s) ++freq[ch];
        int ans = 0, odd = 0;
        for (auto& [_, v] : freq) {
            ans += v/2*2;
            if (v&1) odd = 1;
        }
        return ans + odd;
    }


    /*410. Split Array Largest Sum (Hard)
    Given an array nums which consists of non-negative integers and an integer
    m, you can split the array into m non-empty continuous subarrays. Write an
    algorithm to minimize the largest sum among these m subarrays.

    Example 1:
    Input: nums = [7,2,5,10,8], m = 2
    Output: 18
    Explanation: There are four ways to split nums into two subarrays. The best
                 way is to split it into [7,2,5] and [10,8], where the largest
                 sum among the two subarrays is only 18.

    Example 2:
    Input: nums = [1,2,3,4,5], m = 2
    Output: 9

    Example 3:
    Input: nums = [1,4,4], m = 3
    Output: 4

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 10^6
    * 1 <= m <= min(50, nums.length)*/

    int splitArray(vector<int>& nums, int m) {

        auto fn = [&](int val) {
            /* Return True if val is large enough. */
            int cnt = 0, sm = 0;
            for (auto& x : nums) {
                if (sm + x > val) {
                    ++cnt;
                    sm = 0;
                }
                sm += x;
            }
            return 1 + cnt <= m;
        };

        int lo = *max_element(nums.begin(), nums.end()), hi = accumulate(nums.begin(), nums.end(), 0);
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (fn(mid)) hi = mid;
            else lo = mid + 1;
        }
        return lo;
    }


    /*413. Arithmetic Slices (Medium)
    An integer array is called arithmetic if it consists of at least three
    elements and if the difference between any two consecutive elements is the
    same. For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic
    sequences. Given an integer array nums, return the number of arithmetic
    subarrays of nums. A subarray is a contiguous subsequence of the array.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 3
    Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and
                 [1,2,3,4] itself.

    Example 2:
    Input: nums = [1]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 5000
    * -1000 <= nums[i] <= 1000*/

    int numberOfArithmeticSlices(vector<int>& nums) {
        int ans = 0;
        for (int i = 2, cnt = 0; i < nums.size(); ++i) {
            if (nums[i-2] - nums[i-1] == nums[i-1] - nums[i]) ++cnt;
            else cnt = 0;
            ans += cnt;
        }
        return ans;
    }


    /*415. Add Strings (Easy)
    Given two non-negative integers, num1 and num2 represented as string,
    return the sum of num1 and num2 as a string. You must solve the problem
    without using any built-in library for handling large integers (such as
    BigInteger). You must also not convert the inputs to integers directly.

    Example 1:
    Input: num1 = "11", num2 = "123"
    Output: "134"

    Example 2:
    Input: num1 = "456", num2 = "77"
    Output: "533"

    Example 3:
    Input: num1 = "0", num2 = "0"
    Output: "0"

    Constraints:
    * 1 <= num1.length, num2.length <= 10^4
    * num1 and num2 consist of only digits.
    * num1 and num2 don't have any leading zeros except for the zero itself.*/

    string addStrings(string num1, string num2) {
        string ans;
        for (int i = num1.size()-1, j = num2.size()-1, carry = 0; 0 <= i || 0 <= j || carry; --i, --j, carry /= 10) {
            if (0 <= i) carry += num1[i] - '0';
            if (0 <= j) carry += num2[j] - '0';
            ans.push_back(carry % 10 + '0');
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*416. Partition Equal Subset Sum (Medium)
    Given a non-empty array nums containing only positive integers, find if the
    array can be partitioned into two subsets such that the sum of elements in
    both subsets is equal.

    Example 1:
    Input: nums = [1,5,11,5]
    Output: true
    Explanation: The array can be partitioned as [1, 5, 5] and [11].

    Example 2:
    Input: nums = [1,2,3,5]
    Output: false
    Explanation: The array cannot be partitioned into equal sum subsets.

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= 100*/

    bool canPartition(vector<int>& nums) {
        int sm = accumulate(nums.begin(), nums.end(), 0);
        if (sm & 1) return false;
        bitset<20001> bits(1);
        for (auto& x : nums) bits |= bits << x;
        return bits[sm >> 1];
    }


    /*419. Battleships in a Board (Medium)
    Given an m x n matrix board where each cell is a battleship 'X' or empty
    '.', return the number of the battleships on board. Battleships can only be
    placed horizontally or vertically on board. In other words, they can only
    be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column),
    where k can be of any size. At least one horizontal or vertical cell
    separates between two battleships (i.e., there are no adjacent battleships).

    Example 1:
    Input: board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]]
    Output: 2

    Example 2:
    Input: board = [["."]]
    Output: 0

    Constraints:
    * m == board.length
    * n == board[i].length
    * 1 <= m, n <= 200
    * board[i][j] is either '.' or 'X'.

    Follow up: Could you do it in one-pass, using only O(1) extra memory and
               without modifying the values board?*/

    int countBattleships(vector<vector<char>>& board) {
        int ans = 0, m = board.size(), n = board[0].size();
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (board[i][j] == 'X' && (i == 0 || board[i-1][j] == '.') && (j == 0 || board[i][j-1] == '.'))
                    ++ans;
        return ans;
    }


    /*420. Strong Password Checker (Hard)
    A password is considered strong if the below conditions are all met:
    * It has at least 6 characters and at most 20 characters.
    * It contains at least one lowercase letter, at least one uppercase letter,
      and at least one digit.
    * It does not contain three repeating characters in a row (i.e., "...aaa..."
      is weak, but "...aa...a..." is strong, assuming other conditions are met).
    Given a string password, return the minimum number of steps required to
    make password strong. if password is already strong, return 0. In one step,
    you can:
    * Insert one character to password,
    * Delete one character from password, or
    * Replace one character of password with another character.

    Example 1:
    Input: password = "a"
    Output: 5

    Example 2:
    Input: password = "aA1"
    Output: 3

    Example 3:
    Input: password = "1337C0d3"
    Output: 0

    Constraints:
    * 1 <= password.length <= 50
    * password consists of letters, digits, dot '.' or exclamation mark '!'.*/

    int strongPasswordChecker(string password) {
        int digit = 1, lower = 1, upper = 1;
        for (auto& ch : password) {
            if ('0' <= ch && ch <= '9') digit = 0;
            else if ('a' <= ch && ch <= 'z') lower = 0;
            else if ('A' <= ch && ch <= 'Z') upper = 0;
        }
        int missing = digit + lower + upper, reps = 0, one = 0, two = 0;
        for (int i = 2; i < password.size(); ++i)
            if (password[i-2] == password[i-1] && password[i-1] == password[i]) {
                int sz = 3;
                for (; i+1 < password.size() && password[i] == password[i+1]; ++i, ++sz);
                reps += sz/3;
                if (sz % 3 == 0) ++one;
                else if (sz % 3 == 1) ++two;
            }
        if (password.size() < 6) return max(missing, 6 - (int) password.size());
        if (password.size() <= 20) return max(missing, reps);
        int dels = password.size() - 20;
        reps -= min(dels, one);
        reps -= min(max(0, dels-one), 2*two)/2;
        reps -= max(0, dels-one-2*two)/3;
        return dels + max(missing, reps);
    }


    /*421. Maximum XOR of Two Numbers in an Array (Medium)
    Given an integer array nums, return the maximum result of nums[i] XOR
    nums[j], where 0 <= i <= j < n.

    Example 1:
    Input: nums = [3,10,5,25,2,8]
    Output: 28
    Explanation: The maximum result is 5 XOR 25 = 28.

    Example 2:
    Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
    Output: 127

    Constraints:
    * 1 <= nums.length <= 2 * 10^5
    * 0 <= nums[i] <= 2^31 - 1

    class TrieNode {
    public:
        TrieNode *next[2] = {nullptr};
        int val = 0;
        ~TrieNode() {
            delete next[0];
            delete next[1];
        }
    };*/

    int findMaximumXOR(vector<int>& nums) {
        int ans = 0;
        TrieNode *trie = new TrieNode();
        for (auto& x : nums) {
            TrieNode *node = trie, *oppo = trie;
            for (int i = 31; i >= 0; --i) {
                int bit = (x >> i) & 1;
                if (!node->next[bit]) node->next[bit] = new TrieNode();
                node = node->next[bit];
                oppo = oppo->next[1-bit] ? oppo->next[1-bit] : oppo->next[bit];
            }
            node->val = x;
            ans = max(ans, x ^ oppo->val);
        }
        delete trie;
        return ans;
    }


    /*427. Construct Quad Tree (Medium)
    Given a n * n matrix grid of 0's and 1's only. We want to represent the
    grid with a Quad-Tree. Return the root of the Quad-Tree representing the
    grid. Notice that you can assign the value of a node to True or False when
    isLeaf is False, and both are accepted in the answer. A Quad-Tree is a tree
    data structure in which each internal node has exactly four children.
    Besides, each node has two attributes:
    * val: True if the node represents a grid of 1's or False if the node
      represents a grid of 0's.
    * isLeaf: True if the node is leaf node on the tree or False if the node
      has the four children.
    class Node {
        public boolean val;
        public boolean isLeaf;
        public Node topLeft;
        public Node topRight;
        public Node bottomLeft;
        public Node bottomRight;
    }
    We can construct a Quad-Tree from a two-dimensional area using the
    following steps:
    * If the current grid has the same value (i.e all 1's or all 0's) set
      isLeaf True and set val to the value of the grid and set the four
      children to Null and stop.
    * If the current grid has different values, set isLeaf to False and set val
      to any value and divide the current grid into four sub-grids as shown in
      the photo.
    * Recurse for each of the children with the proper sub-grid.
    If you want to know more about the Quad-Tree, you can refer to the wiki.
    Quad-Tree format:
    * The output represents the serialized format of a Quad-Tree using level
      order traversal, where null signifies a path terminator where no node
      exists below.
    * It is very similar to the serialization of the binary tree. The only
      difference is that the node is represented as a list [isLeaf, val].
    * If the value of isLeaf or val is True we represent it as 1 in the list
      [isLeaf, val] and if the value of isLeaf or val is False we represent it
      as 0.

    Example 1:
    Input: grid = [[0,1],[1,0]]
    Output: [[0,1],[1,0],[1,1],[1,1],[1,0]]
    Explanation: The explanation of this example is shown below: Notice that 0
                 represnts False and 1 represents True in the photo
                 representing the Quad-Tree.

    Example 2:
    Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]
    Output: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
    Explanation: All values in the grid are not the same. We divide the grid
                 into four sub-grids. The topLeft, bottomLeft and bottomRight
                 each has the same value. The topRight have different values so
                 we divide it into 4 sub-grids where each has the same value.
                 Explanation is shown in the photo below:

    Constraints:
    * n == grid.length == grid[i].length
    * n == 2x where 0 <= x <= 6*/

    Node* construct(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<int>> prefix(n+1, vector<int>(n+1));
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                prefix[i+1][j+1] = prefix[i][j+1] + prefix[i+1][j] - prefix[i][j] + grid[i][j];

        function<Node*(int, int, int, int)> fn = [&](int i, int ii, int j, int jj) {
            int diff = prefix[ii][jj] - prefix[i][jj] - prefix[ii][j] + prefix[i][j];
            if (diff == 0 || diff == (ii-i)*(jj-j)) return new Node(grid[i][j], true);
            Node* tl = fn(i, (i+ii)/2, j, (j+jj)/2);
            Node* tr = fn(i, (i+ii)/2, (j+jj)/2, jj);
            Node* bl = fn((i+ii)/2, ii, j, (j+jj)/2);
            Node* br = fn((i+ii)/2, ii, (j+jj)/2, jj);
            return new Node(false, false, tl, tr, bl, br);
        };

        return fn(0, n, 0, n);
    }


    /*429. N-ary Tree Level Order Traversal (Medium)
    Given an n-ary tree, return the level order traversal of its nodes' values.
    Nary-Tree input serialization is represented in their level order traversal,
    each group of children is separated by the null value (See examples).

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: [[1],[3,2,4],[5,6]]

    Example 2:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]

    Constraints:
    * The height of the n-ary tree is less than or equal to 1000
    * The total number of nodes is between [0, 10^4]*/

    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> ans;
        if (root) {
            queue<Node*> q;
            q.push(root);
            while (q.size()) {
                vector<int> vals;
                for (int sz = q.size(); sz; --sz) {
                    Node* node = q.front(); q.pop();
                    vals.push_back(node->val);
                    for (auto& child : node->children) q.push(child);
                }
                ans.push_back(vals);
            }
        }
        return ans;
    }


    /*430. Flatten a Multilevel Doubly Linked List (Medium)
    You are given a doubly linked list which in addition to the next and
    previous pointers, it could have a child pointer, which may or may not
    point to a separate doubly linked list. These child lists may have one or
    more children of their own, and so on, to produce a multilevel data
    structure, as shown in the example below. Flatten the list so that all the
    nodes appear in a single-level, doubly linked list. You are given the head
    of the first level of the list.

    Example 1:
    Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
    Output: [1,2,3,7,8,11,12,9,10,4,5,6]

    Example 2:
    Input: head = [1,2,null,3]
    Output: [1,3,2]
    Explanation: The input multilevel linked list is as follows:
                 1---2---NULL
                 |
                 3---NULL

    Example 3:
    Input: head = []
    Output: []

    How multilevel linked list is represented in test case:
    We use the multilevel linked list from Example 1 above:
     1---2---3---4---5---6--NULL
             |
             7---8---9---10--NULL
                 |
                 11--12--NULL
    The serialization of each level is as follows:
    [1,2,3,4,5,6,null]
    [7,8,9,10,null]
    [11,12,null]
    To serialize all levels together we will add nulls in each level to signify
    no node connects to the upper node of the previous level. The serialization
    becomes:
    [1,2,3,4,5,6,null]
    [null,null,7,8,9,10,null]
    [null,11,12,null]
    Merging the serialization of each level and removing trailing nulls we obtain:
    [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]

    Constraints:
    * The number of Nodes will not exceed 1000.
    * 1 <= Node.val <= 10^5*/

    Node* flatten(Node* head) {
        stack<Node*> stk;
        for (Node* node = head; node; node = node->next)
            if (node->child) {
                if (node->next) stk.push(node->next);
                node->next = node->child;
                node->next->prev = node;
                node->child = nullptr;
            } else if (!node->next && stk.size()) {
                node->next = stk.top(); stk.pop();
                node->next->prev = node;
            }
        return head;
    }


    /*435. Non-overlapping Intervals (Medium)
    Given an array of intervals intervals where intervals[i] = [starti, endi],
    return the minimum number of intervals you need to remove to make the rest
    of the intervals non-overlapping.

    Example 1:
    Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
    Output: 1
    Explanation: [1,3] can be removed and the rest of the intervals are non-
                 overlapping.

    Example 2:
    Input: intervals = [[1,2],[1,2],[1,2]]
    Output: 2
    Explanation: You need to remove two [1,2] to make the rest of the intervals
                 non-overlapping.

    Example 3:
    Input: intervals = [[1,2],[2,3]]
    Output: 0
    Explanation: You don't need to remove any of the intervals since they're
                 already non-overlapping.

    Constraints:
    * 1 <= intervals.length <= 10^5
    * intervals[i].length == 2
    * -5 * 10^4 <= starti < endi <= 5 * 10^4*/

    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [&](auto& lhs, auto& rhs) {return lhs[1] < rhs[1];});
        int ans = 0, prev = INT_MIN;
        for (auto& interval : intervals)
            if (interval[0] < prev) ++ans;
            else prev = interval[1];
        return ans;
    }


    /*438. Find All Anagrams in a String (Medium)
    Given two strings s and p, return an array of all the start indices of p's
    anagrams in s. You may return the answer in any order. An Anagram is a word
    or phrase formed by rearranging the letters of a different word or phrase,
    typically using all the original letters exactly once.

    Example 1:
    Input: s = "cbaebabacd", p = "abc"
    Output: [0,6]
    Explanation: The substring with start index = 0 is "cba", which is an
                 anagram of "abc". The substring with start index = 6 is "bac",
                 which is an anagram of "abc".

    Example 2:
    Input: s = "abab", p = "ab"
    Output: [0,1,2]
    Explanation: The substring with start index = 0 is "ab", which is an
                 anagram of "ab". The substring with start index = 1 is "ba",
                 which is an anagram of "ab". The substring with start
                 index = 2 is "ab", which is an anagram of "ab".

    Constraints:
    * 1 <= s.length, p.length <= 3 * 10^4
    * s and p consist of lowercase English letters.*/

    vector<int> findAnagrams(string s, string p) {
        vector<int> ans, freq(26);
        for (auto& ch : p) ++freq[ch-'a'];
        for (int i = 0; i < s.size(); ++i) {
            --freq[s[i]-'a'];
            if (p.size() <= i) ++freq[s[i-p.size()]-'a'];
            if (p.size() <= i+1 && all_of(freq.begin(), freq.end(), [](auto& x) {return x == 0;})) ans.push_back(i-p.size()+1);
        }
        return ans;
    }


    /*439. Ternary Expression Parser (Medium)
    Given a string expression representing arbitrarily nested ternary
    expressions, evaluate the expression, and return the result of it. You can
    always assume that the given expression is valid and only contains digits,
    '?', ':', 'T', and 'F' where 'T' is true and 'F' is false. All the numbers
    in the expression are one-digit numbers (i.e., in the range [0, 9]). The
    conditional expressions group right-to-left (as usual in most languages),
    and the result of the expression will always evaluate to either a digit,
    'T' or 'F'.

    Example 1:
    Input: expression = "T?2:3"
    Output: "2"
    Explanation: If true, then result is 2; otherwise result is 3.

    Example 2:
    Input: expression = "F?1:T?4:5"
    Output: "4"
    Explanation: The conditional expressions group right-to-left. Using
                 parenthesis, it is read/evaluated as:
                 "(F ? 1 : (T ? 4 : 5))" --> "(F ? 1 : 4)" --> "4"
                 or "(F ? 1 : (T ? 4 : 5))" --> "(T ? 4 : 5)" --> "4"

    Example 3:
    Input: expression = "T?T?F:5:3"
    Output: "F"
    Explanation: The conditional expressions group right-to-left. Using
                 parenthesis, it is read/evaluated as:
                 "(T ? (T ? F : 5) : 3)" --> "(T ? F : 3)" --> "F"
                 "(T ? (T ? F : 5) : 3)" --> "(T ? F : 5)" --> "F"

    Constraints:
    * 5 <= expression.length <= 10^4
    * expression consists of digits, 'T', 'F', '?', and ':'.
    * It is guaranteed that expression is a valid ternary expression and that
      each number is a one-digit number.*/

    string parseTernary(string expression) {
        stack<char> stk;
        for (int i = expression.size()-1; i >= 0; --i)
            if (stk.size() && stk.top() == '?') {
                stk.pop();
                char t = stk.top(); stk.pop();
                char f = stk.top(); stk.pop();
                if (expression[i] == 'T') stk.push(t);
                else stk.push(f);
            } else if (expression[i] != ':')
                stk.push(expression[i]);
        return string(1, stk.top());
    }


    /*440. K-th Smallest in Lexicographical Order (Hard)
    Given two integers n and k, return the kth lexicographically smallest
    integer in the range [1, n].

    Example 1:
    Input: n = 13, k = 2
    Output: 10
    Explanation: The lexicographical order is
                 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second
                 smallest number is 10.

    Example 2:
    Input: n = 1, k = 1
    Output: 1

    Constraints: 1 <= k <= n <= 10^9*/

    int findKthNumber(int n, int k) {
        int x = 1;
        while (k > 1) {
            long cnt = 0;
            for (long diff = 1, curr = x; curr <= n; curr *= 10, diff *= 10)
                cnt += min(n - curr + 1, diff);
            if (k > cnt) k -= cnt, ++x;
            else --k, x *= 10;
        }
        return x;
    }


    /*441. Arranging Coins (Easy)
    You have n coins and you want to build a staircase with these coins. The
    staircase consists of k rows where the ith row has exactly i coins. The
    last row of the staircase may be incomplete. Given the integer n, return
    the number of complete rows of the staircase you will build.

    Example 1:
    Input: n = 5
    Output: 2
    Explanation: Because the 3rd row is incomplete, we return 2.

    Example 2:
    Input: n = 8
    Output: 3
    Explanation: Because the 4th row is incomplete, we return 3.

    Constraints: 1 <= n <= 2^31 - 1*/

    int arrangeCoins(int n) {
        return floor((-1 + sqrt(1+8l*n))/2);
    }


    /*442. Find All Duplicates in an Array (Medium)
    Given an integer array nums of length n where all the integers of nums are
    in the range [1, n] and each integer appears once or twice, return an array
    of all the integers that appears twice. You must write an algorithm that
    runs in O(n) time and uses only constant extra space.

    Example 1:
    Input: nums = [4,3,2,7,8,2,3,1]
    Output: [2,3]

    Example 2:
    Input: nums = [1,1,2]
    Output: [1]

    Example 3:
    Input: nums = [1]
    Output: []

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= n
    * Each element in nums appears once or twice.*/

    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans;
        for (auto x : nums) {
            x = abs(x);
            if (nums[x-1] < 0) ans.push_back(x);
            nums[x-1] *= -1;
        }
        return ans;
    }


    /*446. Arithmetic Slices II - Subsequence (Hard)
    Given an integer array nums, return the number of all the arithmetic
    subsequences of nums. A sequence of numbers is called arithmetic if it
    consists of at least three elements and if the difference between any two
    consecutive elements is the same.
    * For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are
      arithmetic sequences.
    * For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.
    A subsequence of an array is a sequence that can be formed by removing some
    elements (possibly none) of the array.
    * For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].
    The answer is guaranteed to fit in 32-bit integer.

    Example 1:
    Input: nums = [2,4,6,8,10]
    Output: 7
    Explanation: All arithmetic subsequence slices are:
                 [2,4,6]
                 [4,6,8]
                 [6,8,10]
                 [2,4,6,8]
                 [4,6,8,10]
                 [2,4,6,8,10]
                 [2,6,10]

    Example 2:
    Input: nums = [7,7,7,7,7]
    Output: 16
    Explanation: Any subsequence of this array is arithmetic.

    Constraints:
    * 1  <= nums.length <= 1000
    * -2^31 <= nums[i] <= 2^31 - 1*/

    int numberOfArithmeticSlices(vector<int>& nums) {
        int ans = 0, n = nums.size();
        unordered_map<int, vector<size_t>> locs;
        for (size_t i = 0; i < nums.size(); ++i)
            locs[nums[i]].push_back(i);

        vector<vector<int>> dp(n, vector<int>(n));

        for (size_t i = 0; i < nums.size(); ++i)
            for (size_t j = 0; j < i; ++j) {
                long prev = (long) 2*nums[j] - nums[i];
                if (INT_MIN <= prev && prev <= INT_MAX) {
                    auto it = locs.find(prev);
                    if (it != locs.end())
                        for (auto& k : it->second) {
                            if (k >= j) break;
                            dp[i][j] += 1 + dp[j][k];
                        }
                    ans += dp[i][j];
                }
            }
        return ans;
    }


    /*448. Find All Numbers Disappeared in an Array (Easy)
    Given an array nums of n integers where nums[i] is in the range [1, n],
    return an array of all the integers in the range [1, n] that do not appear
    in nums.

    Example 1:
    Input: nums = [4,3,2,7,8,2,3,1]
    Output: [5,6]

    Example 2:
    Input: nums = [1,1]
    Output: [2]

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= n

    Follow up: Could you do it without extra space and in O(n) runtime? You may
               assume the returned list does not count as extra space.*/

    vector<int> findDisappearedNumbers(vector<int>& nums) {
        for (auto x : nums) {
            x = abs(x);
            if (nums[x-1] > 0) nums[x-1] *= -1;
        }
        vector<int> ans;
        for (int i = 0; i < nums.size(); ++i)
            if (nums[i] > 0) ans.push_back(i+1);
        return ans;
    }


    /*450. Delete Node in a BST (Medium)
    Given a root node reference of a BST and a key, delete the node with the
    given key in the BST. Return the root node reference (possibly updated) of
    the BST. Basically, the deletion can be divided into two stages:
    * Search for a node to remove.
    * If the node is found, delete the node.

    Example 1:
    Input: root = [5,3,6,2,4,null,7], key = 3
    Output: [5,4,6,2,null,null,7]
    Explanation: Given key to delete is 3. So we find the node with value 3 and
                 delete it. One valid answer is [5,4,6,2,null,null,7], shown in
                 the above BST. Please notice that another valid answer is
                 [5,2,6,null,4,null,7] and it's also accepted.

    Example 2:
    Input: root = [5,3,6,2,4,null,7], key = 0
    Output: [5,3,6,2,4,null,7]
    Explanation: The tree does not contain a node with value = 0.

    Example 3:
    Input: root = [], key = 0
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * -10^5 <= Node.val <= 10^5
    * Each node has a unique value.
    * root is a valid binary search tree.
    * -10^5 <= key <= 10^5

    Follow up: Could you solve it with time complexity O(height of tree)?*/

    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root)
            if (root->val < key) root->right = deleteNode(root->right, key);
            else if (root->val == key) {
                if (!root->left || !root->right) return root->left ? root->left : root->right;
                TreeNode* node = root->left;
                for (; node->right; node = node->right);
                root->val = node->val;
                root->left = deleteNode(root->left, node->val);
            } else root->left = deleteNode(root->left, key);
        return root;
    }


    /*451. Sort Characters By Frequency (Medium)
    Given a string s, sort it in decreasing order based on the frequency of the
    characters. The frequency of a character is the number of times it appears
    in the string. Return the sorted string. If there are multiple answers,
    return any of them.

    Example 1:
    Input: s = "tree"
    Output: "eert"
    Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e'
                 must appear before both 'r' and 't'. Therefore "eetr" is also
                 a valid answer.

    Example 2:
    Input: s = "cccaaa"
    Output: "aaaccc"
    Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and
                 "aaaccc" are valid answers. Note that "cacaca" is incorrect,
                 as the same characters must be together.

    Example 3:
    Input: s = "Aabb"
    Output: "bbAa"
    Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect. Note
                 that 'A' and 'a' are treated as two different characters.

    Constraints:
    * 1 <= s.length <= 5 * 10^5
    * s consists of uppercase and lowercase English letters and digits.*/

    string frequencySort(string s) {
        unordered_map<char, int> freq;
        for (auto& ch : s) ++freq[ch];

        vector<vector<char>> bucket(s.size()+1);
        for (auto& [ch, v] : freq) bucket[v].push_back(ch);

        string ans;
        for (int v = s.size(); v >= 0; --v)
            for (auto& ch : bucket[v])
                ans += string(v, ch);
        return ans;
    }


    /*452. Minimum Number of Arrows to Burst Balloons (Medium)
    There are some spherical balloons taped onto a flat wall that represents
    the XY-plane. The balloons are represented as a 2D integer array points
    where points[i] = [xstart, xend] denotes a balloon whose horizontal
    diameter stretches between xstart and xend. You do not know the exact
    y-coordinates of the balloons. Arrows can be shot up directly vertically
    (in the positive y-direction) from different points along the x-axis. A
    balloon with xstart and xend is burst by an arrow shot at x if
    xstart <= x <= xend. There is no limit to the number of arrows that can be
    shot. A shot arrow keeps traveling up infinitely, bursting any balloons in
    its path. Given the array points, return the minimum number of arrows that
    must be shot to burst all balloons.

    Example 1:
    Input: points = [[10,16],[2,8],[1,6],[7,12]]
    Output: 2
    Explanation: The balloons can be burst by 2 arrows:
                 - Shoot an arrow at x = 6, bursting the balloons [2,8] and
                   [1,6].
                 - Shoot an arrow at x = 11, bursting the balloons [10,16] and
                   [7,12].

    Example 2:
    Input: points = [[1,2],[3,4],[5,6],[7,8]]
    Output: 4
    Explanation: One arrow needs to be shot for each balloon for a total of 4
                 arrows.

    Example 3:
    Input: points = [[1,2],[2,3],[3,4],[4,5]]
    Output: 2
    Explanation: The balloons can be burst by 2 arrows:
                 - Shoot an arrow at x = 2, bursting the balloons [1,2] and
                   [2,3].
                 - Shoot an arrow at x = 4, bursting the balloons [3,4] and
                   [4,5].

    Constraints:
    * 1 <= points.length <= 10^5
    * points[i].length == 2
    * -2^31 <= xstart < xend <= 2^31 - 1*/

    int findMinArrowShots(vector<vector<int>>& points) {
        int ans = 0;
        long prev = LONG_MIN;
        sort(points.begin(), points.end(), [](auto& lhs, auto& rhs) {return lhs[1] < rhs[1];});
        for (auto& p : points)
            if (prev < p[0]) {
                ++ans;
                prev = p[1];
            }
        return ans;
    }


    /*454. 4Sum II (Medium)
    Given four integer arrays nums1, nums2, nums3, and nums4 all of length n,
    return the number of tuples (i, j, k, l) such that:
    * 0 <= i, j, k, l < n
    * nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0

    Example 1:
    Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
    Output: 2
    Explanation: The two tuples are:
                 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
                 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0

    Example 2:
    Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
    Output: 1

    Constraints:
    * n == nums1.length
    * n == nums2.length
    * n == nums3.length
    * n == nums4.length
    * 1 <= n <= 200
    * -2^28 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 2^28*/

    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int, int> freq;
        for (auto& x : nums1)
            for (auto& y : nums2)
                ++freq[x+y];
        int ans = 0;
        for (auto& x : nums3)
            for (auto& y : nums4)
                ans += freq[-x-y];
        return ans;
    }


    /*456. 132 Pattern (Medium)
    Given an array of n integers nums, a 132 pattern is a subsequence of three
    integers nums[i], nums[j] and nums[k] such that i < j < k and
    nums[i] < nums[k] < nums[j]. Return true if there is a 132 pattern in nums,
    otherwise, return false.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: false
    Explanation: There is no 132 pattern in the sequence.

    Example 2:
    Input: nums = [3,1,4,2]
    Output: true
    Explanation: There is a 132 pattern in the sequence: [1, 4, 2].

    Example 3:
    Input: nums = [-1,3,2,0]
    Output: true
    Explanation: There are three 132 patterns in the sequence: [-1, 3, 2],
                 [-1, 3, 0] and [-1, 2, 0].

    Constraints:
    * n == nums.length
    * 1 <= n <= 2 * 10^5
    * -10^9 <= nums[i] <= 10^9*/

    bool find132pattern(vector<int>& nums) {
        int prev = INT_MIN;
        stack<int> stk;
        for (int i = nums.size()-1; i >= 0; --i) {
            if (nums[i] < prev) return true;
            while (stk.size() && stk.top() < nums[i]) {
                prev = max(prev, stk.top());
                stk.pop();
            }
            stk.push(nums[i]);
        }
        return false;
    }


    /*461. Hamming Distance (Easy)
    The Hamming distance between two integers is the number of positions at
    which the corresponding bits are different. Given two integers x and y,
    return the Hamming distance between them.

    Example 1:
    Input: x = 1, y = 4
    Output: 2
    Explanation: 1   (0 0 0 1)
                 4   (0 1 0 0)
                        ↑   ↑
                 The above arrows point to positions where the corresponding
                 bits are different.

    Example 2:
    Input: x = 3, y = 1
    Output: 1

    Constraints: 0 <= x, y <= 2^31 - 1*/

    int hammingDistance(int x, int y) {
        int ans = 0;
        for (int diff = x^y; diff; diff &= diff-1) ++ans;
        return ans;
    }


    /*462. Minimum Moves to Equal Array Elements II (Medium)
    Given an integer array nums of size n, return the minimum number of moves
    required to make all array elements equal. In one move, you can increment
    or decrement an element of the array by 1.

    Example 1:
    Input: nums = [1,2,3]
    Output: 2
    Explanation: Only two moves are needed (remember each move increments or
                 decrements one element): [1,2,3]  =>  [2,2,3]  =>  [2,2,2]

    Example 2:
    Input: nums = [1,10,2,9]
    Output: 16

    Constraints:
    * n == nums.length
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    int minMoves2(vector<int>& nums) {
        nth_element(nums.begin(), nums.begin() + nums.size()/2, nums.end());
        int ans = 0, m = nums[nums.size()/2];
        for (auto& x : nums) {
            ans += abs(x - m);
        }
        return ans;
    }


    /*463. Island Perimeter (Easy)
    You are given row x col grid representing a map where grid[i][j] = 1
    represents land and grid[i][j] = 0 represents water. Grid cells are
    connected horizontally/vertically (not diagonally). The grid is completely
    surrounded by water, and there is exactly one island (i.e., one or more
    connected land cells). The island doesn't have "lakes", meaning the water
    inside isn't connected to the water around the island. One cell is a square
    with side length 1. The grid is rectangular, width and height don't exceed
    100. Determine the perimeter of the island.

    Example 1:
    Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
    Output: 16
    Explanation: The perimeter is the 16 yellow stripes in the image above.

    Example 2:
    Input: grid = [[1]]
    Output: 4

    Example 3:
    Input: grid = [[1,0]]
    Output: 4

    Constraints:
    * row == grid.length
    * col == grid[i].length
    * 1 <= row, col <= 100
    * grid[i][j] is 0 or 1.
    * There is exactly one island in grid.*/

    int islandPerimeter(vector<vector<int>>& grid) {
        int ans = 0;
        for (int i = 0; i < grid.size(); ++i)
            for (int j = 0; j < grid[i].size(); ++j)
                if (grid[i][j]) {
                    ans += 4;
                    if (i && grid[i-1][j]) ans -= 2;
                    if (j && grid[i][j-1]) ans -= 2;
                }
        return ans;
    }


    /*466. Count The Repetitions (Hard)
    We define str = [s, n] as the string str which consists of the string s
    concatenated n times.
    * For example, str == ["abc", 3] =="abcabcabc".
    We define that string s1 can be obtained from string s2 if we can remove
    some characters from s2 such that it becomes s1.
    * For example, s1 = "abc" can be obtained from s2 = "abdbec" based on our
      definition by removing the bolded underlined characters.
    You are given two strings s1 and s2 and two integers n1 and n2. You have
    the two strings str1 = [s1, n1] and str2 = [s2, n2]. Return the maximum
    integer m such that str = [str2, m] can be obtained from str1.

    Example 1:
    Input: s1 = "acb", n1 = 4, s2 = "ab", n2 = 2
    Output: 2

    Example 2:
    Input: s1 = "acb", n1 = 1, s2 = "acb", n2 = 1
    Output: 1

    Constraints:
    * 1 <= s1.length, s2.length <= 100
    * s1 and s2 consist of lowercase English letters.
    * 1 <= n1, n2 <= 10^6*/

    int getMaxRepetitions(string s1, int n1, string s2, int n2) {
        int cnt = 0, idx = 0;
        vector<int> count, index;
        for (int i = 0; i < n1; ++i) {
            for (auto& ch : s1) {
                if (ch == s2[idx])
                    if (++idx == s2.size()) {
                        ++cnt;
                        idx = 0;
                    }
            }
            count.push_back(cnt);
            index.push_back(idx);
            for (int ii = 0; ii < i; ++ii)
                if (index[ii] == idx) {
                    int prev = count[ii], repeat = (cnt - prev) * ((n1-1-ii) / (i-ii)), post = count[ii + (n1-1-ii) % (i-ii)] - count[ii];
                    return (prev + repeat + post) / n2;
                }
        }
        return count.back() / n2;
    }


    /*469. Convex Polygon (Medium)
    You are given an array of points on the X-Y plane points where
    points[i] = [xi, yi]. The points form a polygon when joined sequentially.
    Return true if this polygon is convex and false otherwise. You may assume
    the polygon formed by given points is always a simple polygon. In other
    words, we ensure that exactly two edges intersect at each vertex and that
    edges otherwise don't intersect each other.

    Example 1:
    Input: points = [[0,0],[0,5],[5,5],[5,0]]
    Output: true

    Example 2:
    Input: points = [[0,0],[0,10],[10,10],[10,0],[5,5]]
    Output: false

    Constraints:
    * 3 <= points.length <= 10^4
    * points[i].length == 2
    * -10^4 <= xi, yi <= 10^4
    * All the given points are unique.*/

    bool isConvex(vector<vector<int>>& points) {
        points.push_back(points[0]);
        points.push_back(points[1]);
        long sign = 0;
        for (int i = 2; i < points.size(); ++i) {
            long val = (points[i][0] - points[i-1][0]) * (points[i-1][1] - points[i-2][1]) - (points[i-1][0] - points[i-2][0]) * (points[i][1] - points[i-1][1]);
            if (sign * val < 0) return false;
            if (val) sign = val;
        }
        return true;
    }


    /*472. Concatenated Words (Hard)
    Given an array of strings words (without duplicates), return all the
    concatenated words in the given list of words. A concatenated word is
    defined as a string that is comprised entirely of at least two shorter
    words in the given array.

    Example 1:
    Input: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
    Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]
    Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";
                 "dogcatsdog" can be concatenated by "dog", "cats" and "dog";
                 "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".

    Example 2:
    Input: words = ["cat","dog","catdog"]
    Output: ["catdog"]

    Constraints:
    * 1 <= words.length <= 10^4
    * 0 <= words[i].length <= 1000
    * words[i] consists of only lowercase English letters.
    * 0 <= sum(words[i].length) <= 10^5*/

    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        sort(words.begin(), words.end(), [](auto& lhs, auto& rhs) {
            return lhs.size() < rhs.size();
        });

        vector<string> ans;
        Trie* trie = new Trie();
        for (auto& word : words)
            if (word.size()) {
                vector<bool> dp(1 + word.size());
                dp[0] = true;
                for (int i = 0; i < word.size(); ++i) {
                    TrieNode* node = trie->root;
                    for (int ii = i; ii >= 0; --ii) {
                        if (!node->children[word[ii]-'a']) break;
                        node = node->children[word[ii]-'a'];
                        if (dp[ii] && node->is_word) {
                            dp[i+1] = true;
                            break;
                        }
                    }
                }
                if (dp.back()) ans.push_back(word);
                reverse(word.begin(), word.end());
                trie->insert(word);
            }

        delete trie;
        return ans;
    }


    /*475. Heaters (Medium)
    Winter is coming! During the contest, your first job is to design a
    standard heater with a fixed warm radius to warm all the houses. Every
    house can be warmed, as long as the house is within the heater's warm
    radius range. Given the positions of houses and heaters on a horizontal
    line, return the minimum radius standard of heaters so that those heaters
    could cover all houses. Notice that all the heaters follow your radius
    standard, and the warm radius will the same.

    Example 1:
    Input: houses = [1,2,3], heaters = [2]
    Output: 1
    Explanation: The only heater was placed in the position 2, and if we use
                 the radius 1 standard, then all the houses can be warmed.

    Example 2:
    Input: houses = [1,2,3,4], heaters = [1,4]
    Output: 1
    Explanation: The two heater was placed in the position 1 and 4. We need to
                 use radius 1 standard, then all the houses can be warmed.

    Example 3:
    Input: houses = [1,5], heaters = [2]
    Output: 3

    Constraints:
    * 1 <= houses.length, heaters.length <= 3 * 10^4
    * 1 <= houses[i], heaters[i] <= 10^9*/

    int findRadius(vector<int>& houses, vector<int>& heaters) {
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        int ans = 0;
        auto it = heaters.begin();
        for (auto& x : houses) {
            for (; it != heaters.end() && *it < x; ++it);
            int cand = INT_MAX;
            if (it != heaters.end()) cand = min(cand, *it - x);
            if (it != heaters.begin()) cand = min(cand, x - *prev(it));
            ans = max(ans, cand);
        }
        return ans;
    }


    /*476. Number Complement (Easy)
    The complement of an integer is the integer you get when you flip all the
    0's to 1's and all the 1's to 0's in its binary representation. For example,
    The integer 5 is "101" in binary and its complement is "010" which is the
    integer 2. Given an integer num, return its complement.

    Example 1:
    Input: num = 5
    Output: 2
    Explanation: The binary representation of 5 is 101 (no leading zero bits),
                 and its complement is 010. So you need to output 2.

    Example 2:
    Input: num = 1
    Output: 0
    Explanation: The binary representation of 1 is 1 (no leading zero bits),
                 and its complement is 0. So you need to output 0.

    Constraints: 1 <= num < 2^31

    Note: This question is the same as 1009:
          https://leetcode.com/problems/complement-of-base-10-integer/*/

    int findComplement(int num) {
        int mask = 1;
        while (mask < num) mask = mask << 1 | 1;
        return mask ^ num;
    }


    /*479. Largest Palindrome Product (Hard)
    Given an integer n, return the largest palindromic integer that can be
    represented as the product of two n-digits integers. Since the answer can
    be very large, return it modulo 1337.

    Example 1:
    Input: n = 2
    Output: 987
    Explanation: 99 x 91 = 9009, 9009 % 1337 = 987

    Example 2:
    Input: n = 1
    Output: 9

    Constraints: 1 <= n <= 8*/

    int largestPalindrome(int n) {
        if (n == 1) return 9;
        for (int z = 2; z < pow(10, n); ++z) {
            int left = pow(10, n) - z, right = 0;
            for (int x = left; x; right = 10*right + x%10, x /= 10);
            if ((long) z*z >= 4*right) {
                long term = z*z - 4*right, val = sqrt(term);
                if (val * val == term && (((z+val) & 1) == 0 || ((z-val) & 1) == 0))
                    return ((long)pow(10, n) * left + right) % 1337;
            }
        }
        return 0;
    }


    /*483. Smallest Good Base (Hard)
    Given an integer n represented as a string, return the smallest good base
    of n. We call k >= 2 a good base of n, if all digits of n base k are 1's.

    Example 1:
    Input: n = "13"
    Output: "3"
    Explanation: 13 base 3 is 111.

    Example 2:
    Input: n = "4681"
    Output: "8"
    Explanation: 4681 base 8 is 11111.

    Example 3:
    Input: n = "1000000000000000000"
    Output: "999999999999999999"
    Explanation: 1000000000000000000 base 999999999999999999 is 11.

    Constraints:
    * n is an integer in the range [3, 10^18].
    * n does not contain any leading zeros.*/

    string smallestGoodBase(string n) {
        unsigned long x = stol(n);
        for (int p = log2(x); p > 1; --p) {
            int k = pow(x, 1./p);
            unsigned long sm = 1, val = 1;
            for (int i = 1; i <= p; ++i, val *= k, sm += val);
            if (sm == x) return to_string(int(k));
        }
        return to_string(x-1);
    }


    /*484. Find Permutation (Medium)
    A permutation perm of n integers of all the integers in the range [1, n]
    can be represented as a string s of length n - 1 where:
    * s[i] == 'I' if perm[i] < perm[i + 1], and
    * s[i] == 'D' if perm[i] > perm[i + 1].
    Given a string s, reconstruct the lexicographically smallest permutation
    perm and return it.

    Example 1:
    Input: s = "I"
    Output: [1,2]
    Explanation: [1,2] is the only legal permutation that can represented by s,
                 where the number 1 and 2 construct an increasing relationship.

    Example 2:
    Input: s = "DI"
    Output: [2,1,3]
    Explanation: Both [2,1,3] and [3,1,2] can be represented as "DI", but since
                 we want to find the smallest lexicographical permutation, you
                 should return [2,1,3]

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either 'I' or 'D'.*/

    vector<int> findPermutation(string s) {
        vector<int> ans, stk;
        s.push_back('I');
        for (int i = 0; i < s.size(); ++i)
            if (s[i] == 'D') stk.push_back(i+1);
            else {
                ans.push_back(i+1);
                while (stk.size()) {
                    ans.push_back(stk.back());
                    stk.pop_back();
                }
            }
        return ans;
    }


    /*485. Max Consecutive Ones (Easy)
    Given a binary array nums, return the maximum number of consecutive 1's in
    the array.

    Example 1:
    Input: nums = [1,1,0,1,1,1]
    Output: 3
    Explanation: The first two digits or the last three digits are consecutive
                 1s. The maximum number of consecutive 1s is 3.

    Example 2:
    Input: nums = [1,0,1,1,0,1]
    Output: 2

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1.*/

    int findMaxConsecutiveOnes(vector<int>& nums) {
        int ans = 0, cnt = 0;
        for (auto &x : nums)
            if (x) ans = max(ans, ++cnt);
            else cnt = 0;
        return ans;
    }


    /*488. Zuma Game (Hard)
    You are playing a variation of the game Zuma. In this variation of Zuma,
    there is a single row of colored balls on a board, where each ball can be
    colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also
    have several colored balls in your hand. Your goal is to clear all of the
    balls from the board. On each turn:
    * Pick any ball from your hand and insert it in between two balls in the
      row or on either end of the row.
    * If there is a group of three or more consecutive balls of the same color,
      remove the group of balls from the board.
      + If this removal causes more groups of three or more of the same color
        to form, then continue removing each group until there are none left.
    * If there are no more balls on the board, then you win the game.
    * Repeat this process until you either win or do not have any more balls in
      your hand.
    Given a string board, representing the row of balls on the board, and a
    string hand, representing the balls in your hand, return the minimum number
    of balls you have to insert to clear all the balls from the board. If you
    cannot clear all the balls from the board using the balls in your hand,
    return -1.

    Example 1:
    Input: board = "WRRBBW", hand = "RB"
    Output: -1
    Explanation: It is impossible to clear all the balls. The best you can do
                 is:
                 - Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.
                 - Insert 'B' so the board becomes WBBBW. WBBBW -> WW.
                 There are still balls remaining on the board, and you are out
                 of balls to insert.

    Example 2:
    Input: board = "WWRRBBWW", hand = "WRBRW"
    Output: 2
    Explanation: To make the board empty:
                 - Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW ->
                   WWBBWW.
                 - Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW ->
                   empty.
                 2 balls from your hand were needed to clear the board.

    Example 3:
    Input: board = "G", hand = "GGGGG"
    Output: 2
    Explanation: To make the board empty:
                 - Insert 'G' so the board becomes GG.
                 - Insert 'G' so the board becomes GGG. GGG -> empty.
                 2 balls from your hand were needed to clear the board.

    Constraints:
    * 1 <= board.length <= 16
    * 1 <= hand.length <= 5
    * board and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.
    * The initial row of balls on the board will not have any groups of three
      or more consecutive balls of the same color.*/

    int findMinStep(string board, string hand) {
        sort(hand.begin(), hand.end());
        unordered_set<string> seen = {board + "#" + hand};
        queue<pair<string, string>> q;
        q.emplace(board, hand);
        while (q.size()) {
            auto [b, h] = q.front(); q.pop();
            if (b.empty()) return hand.size() - h.size();
            for (int i = 0; i < h.size(); ++i)
                if (i == 0 || h[i-1] != h[i]) {
                    string hh = h.substr(0, i) + h.substr(i+1);
                    for (int j = 0; j < b.size(); ++j)
                        if ((h[i] == b[j] && (j == 0 || b[j-1] != b[j])) || (j && h[i] != b[j-1] && b[j-1] == b[j])) {
                            string bb = "", nn = b.substr(0, j) + string(1, h[i]) + b.substr(j);
                            while (bb != nn) {
                                bb = nn;
                                nn = "";
                                for (int k = 0, kk = 0; k <= bb.size(); ++k)
                                    if (k == bb.size() || (k && bb[k-1] != bb[k])) {
                                        if (k-kk < 3) nn += bb.substr(kk, k-kk);
                                        kk = k;
                                    }
                            }
                            if (!seen.count(bb + "#" + hh)) {
                                seen.insert(bb + "#" + hh);
                                q.emplace(bb, hh);
                            }
                        }
                }
        }
        return -1;
    }


    /*490. The Maze (Medium)
    There is a ball in a maze with empty spaces (represented as 0) and walls
    (represented as 1). The ball can go through the empty spaces by rolling up,
    down, left or right, but it won't stop rolling until hitting a wall. When
    the ball stops, it could choose the next direction. Given the m x n maze,
    the ball's start position and the destination, where
    start = [startrow, startcol] and
    destination = [destinationrow, destinationcol], return true if the ball can
    stop at the destination, otherwise return false. You may assume that the
    borders of the maze are all walls (see examples).

    Example 1:
    Input: maze = [[0,0,1,0,0],
                   [0,0,0,0,0],
                   [0,0,0,1,0],
                   [1,1,0,1,1],
                   [0,0,0,0,0]], start = [0,4], destination = [4,4]
    Output: true
    Explanation: One possible way is : left -> down -> left -> down -> right ->
                 down -> right.

    Example 2:
    Input: maze = [[0,0,1,0,0],
                   [0,0,0,0,0],
                   [0,0,0,1,0],
                   [1,1,0,1,1],
                   [0,0,0,0,0]], start = [0,4], destination = [3,2]
    Output: false
    Explanation: There is no way for the ball to stop at the destination.
                 Notice that you can pass through the destination but you
                 cannot stop there.

    Example 3:
    Input: maze = [[0,0,0,0,0],
                   [1,1,0,0,1],
                   [0,0,0,0,0],
                   [0,1,0,0,1],
                   [0,1,0,0,0]], start = [4,3], destination = [0,1]
    Output: false

    Constraints:
    * m == maze.length
    * n == maze[i].length
    * 1 <= m, n <= 100
    * maze[i][j] is 0 or 1.
    * start.length == 2
    * destination.length == 2
    * 0 <= startrow, destinationrow <= m
    * 0 <= startcol, destinationcol <= n
    * Both the ball and the destination exist in an empty space, and they will
      not be in the same position initially.
    * The maze contains at least 2 empty spaces.*/

    bool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int m = maze.size(), n = maze[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        stack<pair<int, int>> stk;
        stk.emplace(start[0], start[1]);
        maze[start[0]][start[1]] = 2; // mark as visited
        while (stk.size()) {
            auto [i, j] = stk.top(); stk.pop();
            if (i == destination[0] && j == destination[1]) return true;
            for (int k = 0; k < 4; ++k) {
                int ii = i, jj = j, di = dir[k], dj = dir[k+1];
                for (; 0 <= ii+di && ii+di < m && 0 <= jj+dj && jj+dj < n && maze[ii+di][jj+dj] != 1; ii += di, jj += dj);
                if (maze[ii][jj] == 0) {
                    stk.emplace(ii, jj);
                    maze[ii][jj] = 2;
                }
            }
        }
        return false;
    }


    /*495. Teemo Attacking (Easy)
    Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo
    attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More
    formally, an attack at second t will mean Ashe is poisoned during the
    inclusive time interval [t, t + duration - 1]. If Teemo attacks again
    before the poison effect ends, the timer for it is reset, and the poison
    effect will end duration seconds after the new attack. You are given a
    non-decreasing integer array timeSeries, where timeSeries[i] denotes that
    Teemo attacks Ashe at second timeSeries[i], and an integer duration. Return
    the total number of seconds that Ashe is poisoned.

    Example 1:
    Input: timeSeries = [1,4], duration = 2
    Output: 4
    Explanation: Teemo's attacks on Ashe go as follows:
    - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
    - At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.
    Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.

    Example 2:
    Input: timeSeries = [1,2], duration = 2
    Output: 3
    Explanation: Teemo's attacks on Ashe go as follows:
    - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
    - At second 2 however, Teemo attacks again and resets the poison timer.
      Ashe is poisoned for seconds 2 and 3.
    Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.

    Constraints:
    * 1 <= timeSeries.length <= 10^4
    * 0 <= timeSeries[i], duration <= 10^7
    * timeSeries is sorted in non-decreasing order.*/

    int findPoisonedDuration(vector<int>& timeSeries, int duration) {
        int ans = 0;
        for (int i = 0; i < size(timeSeries)-1; ++i)
            ans += min(duration, timeSeries[i+1] - timeSeries[i]);
        return ans + duration;
    }


    /*496. Next Greater Element I (Easy)
    The next greater element of some element x in an array is the first greater
    element that is to the right of x in the same array. You are given two
    distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset
    of nums2. For each 0 <= i < nums1.length, find the index j such that
    nums1[i] == nums2[j] and determine the next greater element of nums2[j] in
    nums2. If there is no next greater element, then the answer for this query
    is -1. Return an array ans of length nums1.length such that ans[i] is the
    next greater element as described above.

    Example 1:
    Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
    Output: [-1,3,-1]
    Explanation: The next greater element for each value of nums1 is as follows:
                 - 4 is underlined in nums2 = [1,3,4,2]. There is no next
                   greater element, so the answer is -1.
                 - 1 is underlined in nums2 = [1,3,4,2]. The next greater
                   element is 3.
                 - 2 is underlined in nums2 = [1,3,4,2]. There is no next
                   greater element, so the answer is -1.

    Example 2:
    Input: nums1 = [2,4], nums2 = [1,2,3,4]
    Output: [3,-1]
    Explanation: The next greater element for each value of nums1 is as follows:
                 - 2 is underlined in nums2 = [1,2,3,4]. The next greater
                   element is 3.
                 - 4 is underlined in nums2 = [1,2,3,4]. There is no next
                   greater element, so the answer is -1.

    Constraints:
    * 1 <= nums1.length <= nums2.length <= 1000
    * 0 <= nums1[i], nums2[i] <= 10^4
    * All integers in nums1 and nums2 are unique.
    * All the integers of nums1 also appear in nums2.

    Follow up: Could you find an O(nums1.length + nums2.length) solution?*/

    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> mp;
        stack<int> stk;
        for (auto& x : nums2) {
            while (stk.size() && stk.top() < x)
                mp[stk.top()] = x, stk.pop();
            stk.push(x);
        }
        vector<int> ans;
        for (auto& x : nums1)
            ans.push_back(mp.count(x) ? mp[x] : -1);
        return ans;
    }


    /*502. IPO (Hard)
    Suppose LeetCode will start its IPO soon. In order to sell a good price of
    its shares to Venture Capital, LeetCode would like to work on some projects
    to increase its capital before the IPO. Since it has limited resources, it
    can only finish at most k distinct projects before the IPO. Help LeetCode
    design the best way to maximize its total capital after finishing at most k
    distinct projects. You are given n projects where the ith project has a
    pure profit profits[i] and a minimum capital of capital[i] is needed to
    start it. Initially, you have w capital. When you finish a project, you
    will obtain its pure profit and the profit will be added to your total
    capital. Pick a list of at most k distinct projects from given projects to
    maximize your final capital, and return the final maximized capital. The
    answer is guaranteed to fit in a 32-bit signed integer.

    Example 1:
    Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
    Output: 4
    Explanation: Since your initial capital is 0, you can only start the
                 project indexed 0. After finishing it you will obtain profit 1
                 and your capital becomes 1. With capital 1, you can either
                 start the project indexed 1 or the project indexed 2. Since
                 you can choose at most 2 projects, you need to finish the
                 project indexed 2 to get the maximum capital. Therefore,
                 output the final maximized capital, which is 0 + 1 + 3 = 4.

    Example 2:
    Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
    Output: 6

    Constraints:
    * 1 <= k <= 10^5
    * 0 <= w <= 10^9
    * n == profits.length
    * n == capital.length
    * 1 <= n <= 10^5
    * 0 <= profits[i] <= 10^4
    * 0 <= capital[i] <= 10^9*/

    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
        int n = profits.size();
        vector<pair<int, int>> aug;
        for (int i = 0; i < n; ++i) aug.emplace_back(capital[i], profits[i]);
        sort(aug.begin(), aug.end());
        priority_queue<int> pq;
        for (int i = 0; k; --k) {
            for (; i < n && aug[i].first <= w; ++i) pq.push(aug[i].second);
            if (pq.size()) { w += pq.top(); pq.pop(); }
        }
        return w;
    }


    /*504. Base 7 (Easy)
    Given an integer, return its base 7 string representation.

    Example 1:
    Input: 100
    Output: "202"

    Example 2:
    Input: -7
    Output: "-10"

    Note: The input will be in range of [-1e7, 1e7].*/

    string convertToBase7(int num) {
        if (num == 0) return "0"; // edge case

        string ans;
        bool neg = num < 0;
        num = abs(num);
        while (num) {
            ans = to_string(num%7) + ans;
            num /= 7;
        }
        return neg ? "-" + ans : ans;
    }


    /*505. The Maze II (Medium)
    There is a ball in a maze with empty spaces (represented as 0) and walls
    (represented as 1). The ball can go through the empty spaces by rolling up,
    down, left or right, but it won't stop rolling until hitting a wall. When
    the ball stops, it could choose the next direction. Given the m x n maze,
    the ball's start position and the destination, where
    start = [startrow, startcol] and
    destination = [destinationrow, destinationcol], return the shortest
    distance for the ball to stop at the destination. If the ball cannot stop
    at destination, return -1. The distance is the number of empty spaces
    traveled by the ball from the start position (excluded) to the destination
    (included). You may assume that the borders of the maze are all walls (see
    examples).

    Example 1:
    Input: maze = [[0,0,1,0,0],
                   [0,0,0,0,0],
                   [0,0,0,1,0],
                   [1,1,0,1,1],
                   [0,0,0,0,0]], start = [0,4], destination = [4,4]
    Output: 12
    Explanation: One possible way is : left -> down -> left -> down -> right ->
                 down -> right. The length of the path is
                 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.

    Example 2:
    Input: maze = [[0,0,1,0,0],
                   [0,0,0,0,0],
                   [0,0,0,1,0],
                   [1,1,0,1,1],
                   [0,0,0,0,0]], start = [0,4], destination = [3,2]
    Output: -1
    Explanation: There is no way for the ball to stop at the destination.
                 Notice that you can pass through the destination but you
                 cannot stop there.

    Example 3:
    Input: maze = [[0,0,0,0,0],
                   [1,1,0,0,1],
                   [0,0,0,0,0],
                   [0,1,0,0,1],
                   [0,1,0,0,0]], start = [4,3], destination = [0,1]
    Output: -1

    Constraints:
    * m == maze.length
    * n == maze[i].length
    * 1 <= m, n <= 100
    * maze[i][j] is 0 or 1.
    * start.length == 2
    * destination.length == 2
    * 0 <= startrow, destinationrow <= m
    * 0 <= startcol, destinationcol <= n
    * Both the ball and the destination exist in an empty space, and they will
      not be in the same position initially.
    * The maze contains at least 2 empty spaces.*/

    int shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int m = maze.size(), n = maze[0].size();

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // min-heap
        pq.emplace(0, start[0]*n + start[1]);
        vector<int> dist(m*n, INT_MAX);
        dist[start[0]*n + start[1]] = 0;

        while (pq.size()) {
            auto [x, k] = pq.top(); pq.pop();
            int i = k/n, j = k%n;
            if (i == destination[0] && j == destination[1]) return x;
            for (auto& [di, dj] : {make_pair(-1, 0), {0, -1}, {0, 1}, {1, 0}}) {
                int ii = i, jj = j, xx = x;
                for (; 0 <= ii+di && ii+di < m && 0 <= jj+dj && jj+dj < n && maze[ii+di][jj+dj] == 0; ii += di, jj += dj, ++xx);
                if (xx < dist[ii*n+jj]) {
                    pq.emplace(xx, ii*n+jj);
                    dist[ii*n+jj] = xx;
                }
            }
        }
        return -1;
    }


    /*506. Relative Ranks (Easy)
    You are given an integer array score of size n, where score[i] is the score
    of the ith athlete in a competition. All the scores are guaranteed to be
    unique. The athletes are placed based on their scores, where the 1st place
    athlete has the highest score, the 2nd place athlete has the 2nd highest
    score, and so on. The placement of each athlete determines their rank:
    * The 1st place athlete's rank is "Gold Medal".
    * The 2nd place athlete's rank is "Silver Medal".
    * The 3rd place athlete's rank is "Bronze Medal".
    * For the 4th place to the nth place athlete, their rank is their placement
      number (i.e., the xth place athlete's rank is "x").
    Return an array answer of size n where answer[i] is the rank of the ith
    athlete.

    Example 1:
    Input: score = [5,4,3,2,1]
    Output: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
    Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].

    Example 2:
    Input: score = [10,3,8,9,4]
    Output: ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
    Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].

    Constraints:
    * n == score.length
    * 1 <= n <= 10^4
    * 0 <= score[i] <= 10^6
    * All the values in score are unique.*/

    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        vector<int> vals(n);
        iota(vals.begin(), vals.end(), 0);
        sort(vals.begin(), vals.end(), [&](auto& lhs, auto& rhs) { return score[lhs] > score[rhs]; });
        vector<string> ans(n);
        for (int i = 0; i < n; ++i) {
            if (i <= 2) ans[vals[i]] = vector<string>{"Gold Medal", "Silver Medal", "Bronze Medal"}[i];
            else ans[vals[i]] = to_string(i+1);
        }
        return ans;
    }


    /*507. Perfect Number (Easy)
    A perfect number is a positive integer that is equal to the sum of its
    positive divisors, excluding the number itself. A divisor of an integer x
    is an integer that can divide x evenly. Given an integer n, return true if
    n is a perfect number, otherwise return false.

    Example 1:
    Input: num = 28
    Output: true
    Explanation: 28 = 1 + 2 + 4 + 7 + 14
                 1, 2, 4, 7, and 14 are all divisors of 28.

    Example 2:
    Input: num = 7
    Output: false

    Constraints: 1 <= num <= 10^8*/

    bool checkPerfectNumber(int num) {
        // Euclid-Euler theorem
        for (auto& p : {2, 3, 5, 7, 13})
            if ((1<<p-1)*((1<<p)-1) == num) return true;
        return false;
    }


    /*509. Fibonacci Number (Easy)
    The Fibonacci numbers, commonly denoted F(n) form a sequence, called the
    Fibonacci sequence, such that each number is the sum of the two preceding
    ones, starting from 0 and 1. That is,
    * F(0) = 0, F(1) = 1
    * F(n) = F(n - 1) + F(n - 2), for n > 1.
    Given n, calculate F(n).

    Example 1:
    Input: n = 2
    Output: 1
    Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.

    Example 2:
    Input: n = 3
    Output: 2
    Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.

    Example 3:
    Input: n = 4
    Output: 3
    Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.

    Constraints: 0 <= n <= 30*/

    int fib(int n) {

        function<pair<int, int>(int)> fn = [&](int n) -> pair<int, int> {
            // Return nth and (n+1)st Fibonacci numbers via "fast doubling method".
            if (n == 0) return {0, 1};
            auto [x, y] = fn(n >> 1);
            int xx = x*(2*y - x), yy = x*x + y*y;
            if (n&1) return {yy, xx+yy};
            return {xx, yy};
        };

        return fn(n).first;
    }


    /*513. Find Bottom Left Tree Value (Medium)
    Given the root of a binary tree, return the leftmost value in the last row
    of the tree.

    Example 1:
    Input: root = [2,1,3]

          2
         / \
        1   3

    Output: 1

    Example 2:
    Input: root = [1,2,3,4,null,5,6,null,null,7]

            1
           / \
          2   3
         /   / \
        4   5   6
           /
          7

    Output: 7

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -2^31 <= Node.val <= 2^31 - 1*/

    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* node;
        while (q.size())
            for (int sz = q.size(); sz; --sz) {
                node = q.front(); q.pop();
                if (node->right) q.push(node->right);
                if (node->left) q.push(node->left);
            }
        return node->val;
    }


    /*514. Freedom Trail (Hard)
    In the video game Fallout 4, the quest "Road to Freedom" requires players
    to reach a metal dial called the "Freedom Trail Ring" and use the dial to
    spell a specific keyword to open the door. Given a string ring that
    represents the code engraved on the outer ring and another string key that
    represents the keyword that needs to be spelled, return the minimum number
    of steps to spell all the characters in the keyword. Initially, the first
    character of the ring is aligned at the "12:00" direction. You should spell
    all the characters in key one by one by rotating ring clockwise or
    anticlockwise to make each character of the string key aligned at the
    "12:00" direction and then by pressing the center button. At the stage of
    rotating the ring to spell the key character key[i]:
    * You can rotate the ring clockwise or anticlockwise by one place, which
      counts as one step. The final purpose of the rotation is to align one of
      ring's characters at the "12:00" direction, where this character must
      equal key[i].
    * If the character key[i] has been aligned at the "12:00" direction, press
      the center button to spell, which also counts as one step. After the
      pressing, you could begin to spell the next character in the key (next
      stage). Otherwise, you have finished all the spelling.

    Example 1:
    Input: ring = "godding", key = "gd"
    Output: 4
    Explanation: For the first key character 'g', since it is already in place,
                 we just need 1 step to spell this character. For the second
                 key character 'd', we need to rotate the ring "godding"
                 anticlockwise by two steps to make it become "ddinggo". Also,
                 we need 1 more step for spelling. So the final output is 4.

    Example 2:
    Input: ring = "godding", key = "godding"
    Output: 13

    Constraints:
    * 1 <= ring.length, key.length <= 100
    * ring and key consist of only lower case English letters.
    * It is guaranteed that key could always be spelled by rotating ring.*/

    int findRotateSteps(string ring, string key) {
        int m = ring.size(), n = key.size();
        unordered_map<char, vector<int>> locs;
        for (int i = 0; i < m; ++i) locs[ring[i]].push_back(i);

        vector<vector<int>> dp(m, vector<int>(n+1));
        for (int j = n-1; j >= 0; --j) {
            vector<int> loc = locs[key[j]];
            for (int i = 0; i < m; ++i) {
                auto it = lower_bound(loc.begin(), loc.end(), i);
                if (it == loc.end()) it = loc.begin();
                dp[i][j] = min(abs(i-*it), m - abs(i-*it)) + dp[*it][j+1];
                if (it == loc.begin()) it = loc.end();
                it = prev(it);
                dp[i][j] = min(dp[i][j], min(abs(i-*it), m - abs(i-*it)) + dp[*it][j+1]);
            }
        }
        return dp[0][0] + n;
    }


    /*516. Longest Palindromic Subsequence (Medium)
    Given a string s, find the longest palindromic subsequence's length in s. A
    subsequence is a sequence that can be derived from another sequence by
    deleting some or no elements without changing the order of the remaining
    elements.

    Example 1:
    Input: s = "bbbab"
    Output: 4
    Explanation: One possible longest palindromic subsequence is "bbbb".

    Example 2:
    Input: s = "cbbd"
    Output: 2
    Explanation: One possible longest palindromic subsequence is "bb".

    Constraints:
    * 1 <= s.length <= 1000
    * s consists only of lowercase English letters.*/

    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = n-1; i >= 0; --i) {
            dp[i][i] = 1;
            for (int j = i+1; j < n; ++j)
                if (s[i] == s[j]) dp[i][j] = 2 + dp[i+1][j-1];
                else dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
        }
        return dp[0][n-1];
    }


    /*517. Super Washing Machines (Hard)
    You have n super washing machines on a line. Initially, each washing
    machine has some dresses or is empty. For each move, you could choose any m
    (1 <= m <= n) washing machines, and pass one dress of each washing machine
    to one of its adjacent washing machines at the same time. Given an integer
    array machines representing the number of dresses in each washing machine
    from left to right on the line, return the minimum number of moves to make
    all the washing machines have the same number of dresses. If it is not
    possible to do it, return -1.

    Example 1:
    Input: machines = [1,0,5]
    Output: 3
    Explanation: 1st move:    1     0 <-- 5    =>    1     1     4
                 2nd move:    1 <-- 1 <-- 4    =>    2     1     3
                 3rd move:    2     1 <-- 3    =>    2     2     2

    Example 2:
    Input: machines = [0,3,0]
    Output: 2
    Explanation: 1st move:    0 <-- 3     0    =>    1     2     0
                 2nd move:    1     2 --> 0    =>    1     1     1

    Example 3:
    Input: machines = [0,2,0]
    Output: -1
    Explanation: It's impossible to make all three washing machines have the
                 same number of dresses.

    Constraints:
    * n == machines.length
    * 1 <= n <= 10^4
    * 0 <= machines[i] <= 10^5*/

    int findMinMoves(vector<int>& machines) {
        int total = accumulate(machines.begin(), machines.end(), 0);
        if (total % machines.size()) return -1; // impossible

        int avg = total / machines.size(), ans = 0, prefix = 0;
        for (auto& x : machines) {
            ans = max({ans, abs(prefix), x - avg});
            prefix += x - avg;
        }
        return ans;
    }


    /*518. Coin Change 2 (Medium)
    You are given an integer array coins representing coins of different
    denominations and an integer amount representing a total amount of money.
    Return the number of combinations that make up that amount. If that amount
    of money cannot be made up by any combination of the coins, return 0. You
    may assume that you have an infinite number of each kind of coin. The
    answer is guaranteed to fit into a signed 32-bit integer.

    Example 1:
    Input: amount = 5, coins = [1,2,5]
    Output: 4
    Explanation: there are four ways to make up the amount:
                 5=5
                 5=2+2+1
                 5=2+1+1+1
                 5=1+1+1+1+1

    Example 2:
    Input: amount = 3, coins = [2]
    Output: 0
    Explanation: the amount of 3 cannot be made up just with coins of 2.

    Example 3:
    Input: amount = 10, coins = [10]
    Output: 1

    Constraints:
    * 1 <= coins.length <= 300
    * 1 <= coins[i] <= 5000
    * All the values of coins are unique.
    * 0 <= amount <= 5000*/

    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1, 0);
        dp[0] = 1;
        for (auto& coin : coins)
            for (int x = coin; x <= amount; ++x)
                dp[x] += dp[x-coin];
        return dp[amount];
    }


    /*520. Detect Capital (Easy)
    We define the usage of capitals in a word to be right when one of the
    following cases holds:
    * All letters in this word are capitals, like "USA".
    * All letters in this word are not capitals, like "leetcode".
    * Only the first letter in this word is capital, like "Google".
    Given a string word, return true if the usage of capitals in it is right.

    Example 1:
    Input: word = "USA"
    Output: true

    Example 2:
    Input: word = "FlaG"
    Output: false

    Constraints:
    * 1 <= word.length <= 100
    * word consists of lowercase and uppercase English letters.*/

    bool detectCapitalUse(string word) {
        for (int i = 1; i < word.size(); ++i) {
            if (islower(word[0]) && isupper(word[i])) return false;
            if (islower(word[1]) != islower(word[i])) return false;
        }
        return true;
    }


    /*522. Longest Uncommon Subsequence II (Medium)
    Given an array of strings strs, return the length of the longest uncommon
    subsequence between them. If the longest uncommon subsequence does not
    exist, return -1. An uncommon subsequence between an array of strings is a
    string that is a subsequence of one string but not the others. A
    subsequence of a string s is a string that can be obtained after deleting
    any number of characters from s. For example, "abc" is a subsequence of
    "aebdc" because you can delete the underlined characters in "aebdc" to get
    "abc". Other subsequences of "aebdc" include "aebdc", "aeb", and "" (empty
    string).

    Example 1:
    Input: strs = ["aba","cdc","eae"]
    Output: 3

    Example 2:
    Input: strs = ["aaa","aaa","aa"]
    Output: -1

    Constraints:
    * 1 <= strs.length <= 50
    * 1 <= strs[i].length <= 10
    * strs[i] consists of lowercase English letters.*/

    int findLUSlength(vector<string>& strs) {

        auto fn = [] (string p, string s) {
            int i = 0;
            for (auto& ch : s)
                if (i < p.size() && p[i] == ch) ++i;
            return i == p.size();
        };

        int ans = -1;
        for (int i = 0; i < strs.size(); ++i) {
            bool found = false;
            for (int j = 0; j < strs.size(); ++j)
                if (i != j && strs[i].size() <= strs[j].size() && fn(strs[i], strs[j])) {
                    found = true;
                    break;
                }
            if (not found) ans = max(ans, (int) strs[i].size());
        }
        return ans;
    }


    /*523. Continuous Subarray Sum (Medium)
    Given an integer array nums and an integer k, return true if nums has a good
    subarray or false otherwise. A good subarray is a subarray where:
    * its length is at least two, and
    * the sum of the elements of the subarray is a multiple of k.
    Note that:
    * A subarray is a contiguous part of the array.
    * An integer x is a multiple of k if there exists an integer n such that
      x = n * k. 0 is always a multiple of k.

    Example 1:
    Input: nums = [23,2,4,6,7], k = 6
    Output: true
    Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up
                 to 6.

    Example 2:
    Input: nums = [23,2,6,4,7], k = 6
    Output: true
    Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose
                 elements sum up to 42. 42 is a multiple of 6 because 42 = 7 * 6
                 and 7 is an integer.

    Example 3:
    Input: nums = [23,2,6,4,7], k = 13
    Output: false

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 0 <= sum(nums[i]) <= 2^31 - 1
    * 1 <= k <= 2^31 - 1*/

    bool checkSubarraySum(vector<int>& nums, int k) {
        unordered_set<int> seen;
        int prefix = 0, prev = 0;
        for (auto& x : nums) {
            prefix = (prefix+x) % k;
            if (seen.contains(prefix)) return true;
            seen.insert(prev);
            prev = prefix;
        }
        return false;
    }


    /*525. Contiguous Array (Medium)
    Given a binary array nums, return the maximum length of a contiguous
    subarray with an equal number of 0 and 1.

    Example 1:
    Input: nums = [0,1]
    Output: 2
    Explanation: [0, 1] is the longest contiguous subarray with an equal number
                 of 0 and 1.

    Example 2:
    Input: nums = [0,1,0]
    Output: 2
    Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal
                 number of 0 and 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1.*/

    int findMaxLength(vector<int>& nums) {
        int ans = 0;
        unordered_map<int, int> seen = {{0, -1}};
        for (int i = 0, prefix = 0; i < nums.size(); ++i) {
            prefix += 2*nums[i] - 1;
            if (seen.count(prefix)) ans = max(ans, i - seen[prefix]);
            else seen[prefix] = i;
        }
        return ans;
    }


    /*531. Lonely Pixel I (Medium)
    Given an m x n picture consisting of black 'B' and white 'W' pixels, return
    the number of black lonely pixels. A black lonely pixel is a character 'B'
    that located at a specific position where the same row and same column
    don't have any other black pixels.

    Example 1:
    Input: picture = [["W","W","B"],["W","B","W"],["B","W","W"]]
    Output: 3
    Explanation: All the three 'B's are black lonely pixels.

    Example 2:
    Input: picture = [["B","B","B"],["B","B","W"],["B","B","B"]]
    Output: 0

    Constraints:
    * m == picture.length
    * n == picture[i].length
    * 1 <= m, n <= 500
    * picture[i][j] is 'W' or 'B'.*/

    int findLonelyPixel(vector<vector<char>>& picture) {
        int m = picture.size(), n = picture[0].size();
        vector<int> rows(m), cols(n);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (picture[i][j] == 'B') {
                    rows[i]++;
                    cols[j]++;
                }
        int ans = 0;
        for (int i = 0; i < m; ++i)
            if (rows[i] == 1)
                for (int j = 0; j < n; ++j)
                    if (picture[i][j] == 'B' && cols[j] == 1) ++ans;
        return ans;
    }


    /*532. K-diff Pairs in an Array (Medium)
    Given an array of integers nums and an integer k, return the number of
    unique k-diff pairs in the array. A k-diff pair is an integer pair
    (nums[i], nums[j]), where the following are true:
    * 0 <= i < j < nums.length
    * |nums[i] - nums[j]| == k
    Notice that |val| denotes the absolute value of val.

    Example 1:
    Input: nums = [3,1,4,1,5], k = 2
    Output: 2
    Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
                 Although we have two 1s in the input, we should only return
                 the number of unique pairs.

    Example 2:
    Input: nums = [1,2,3,4,5], k = 1
    Output: 4
    Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3),
                 (3, 4) and (4, 5).

    Example 3:
    Input: nums = [1,3,1,5,4], k = 0
    Output: 1
    Explanation: There is one 0-diff pair in the array, (1, 1).

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^7 <= nums[i] <= 10^7
    * 0 <= k <= 10^7*/

    int findPairs(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        int ans = 0;
        for (auto& [x, v] : freq)
            if ((k == 0 && v > 1) || (k && freq.count(x+k))) ++ans;
        return ans;
    }


    /*533. Lonely Pixel II (Medium)
    Given an m x n picture consisting of black 'B' and white 'W' pixels and an
    integer target, return the number of black lonely pixels. A black lonely
    pixel is a character 'B' that located at a specific position (r, c) where:
    * Row r and column c both contain exactly target black pixels.
    * For all rows that have a black pixel at column c, they should be exactly
      the same as row r.

    Example 1:
    Input: picture = [["W","B","W","B","B","W"],
                      ["W","B","W","B","B","W"],
                      ["W","B","W","B","B","W"],
                      ["W","W","B","W","B","W"]], target = 3
    Output: 6
    Explanation: All the green 'B' are the black pixels we need (all 'B's at
                 column 1 and 3). Take 'B' at row r = 0 and column c = 1 as an
                 example:
                 - Rule 1, row r = 0 and column c = 1 both have exactly
                   target = 3 black pixels.
                 - Rule 2, the rows have black pixel at column c = 1 are row 0,
                   row 1 and row 2. They are exactly the same as row r = 0.

    Example 2:
    Input: picture = [["W","W","B"],["W","W","B"],["W","W","B"]], target = 1
    Output: 0

    Constraints:
    * m == picture.length
    * n == picture[i].length
    * 1 <= m, n <= 200
    * picture[i][j] is 'W' or 'B'.
    * 1 <= target <= min(m, n)*/

    int findBlackPixel(vector<vector<char>>& picture, int target) {
        int m = picture.size(), n = picture[0].size();
        vector<string> keys;
        unordered_map<string, int> freq;
        vector<int> rows(m, 0), cols(n, 0);
        for (int i = 0; i < m; ++i) {
            string key;
            for (int j = 0; j < n; ++j) {
                key.push_back(picture[i][j]);
                if (picture[i][j] == 'B') {
                    ++rows[i];
                    ++cols[j];
                }
            }
            keys.push_back(key);
            ++freq[key];
        }

        int ans = 0;
        for (int i = 0; i < m; ++i) {
            string key = keys[i];
            if (freq[key] == target)
                for (int j = 0; j < n; ++j)
                    if (picture[i][j] == 'B' && rows[i] == target && cols[j] == target)
                        ++ans;
        }
        return ans;
    }


    /*536. Construct Binary Tree from String (Medium)
    You need to construct a binary tree from a string consisting of parenthesis
    and integers. The whole input represents a binary tree. It contains an
    integer followed by zero, one or two pairs of parenthesis. The integer
    represents the root's value and a pair of parenthesis contains a child
    binary tree with the same structure. You always start to construct the left
    child node of the parent first if it exists.

    Example 1:
    Input: s = "4(2(3)(1))(6(5))"
    Output: [4,2,6,3,1,5]

    Example 2:
    Input: s = "4(2(3)(1))(6(5)(7))"
    Output: [4,2,6,3,1,5,7]

    Example 3:
    Input: s = "-4(2(3)(1))(6(5)(7))"
    Output: [-4,2,6,3,1,5,7]

    Constraints:
    * 0 <= s.length <= 3 * 10^4
    * s consists of digits, '(', ')', and '-' only.*/

    TreeNode* str2tree(string s) {
        if (s.empty()) return nullptr; // edge case
        stack<TreeNode*> stk;
        string val;
        TreeNode* node = nullptr;
        for (auto& ch : s)
            if (ch == '(') {
                if (val.size()) {
                    node = new TreeNode(stoi(val));
                    val.clear();
                    stk.push(node);
                }
            } else if (ch == ')') {
                if (val.size()) {
                    node = new TreeNode(stoi(val));
                    val.clear();
                } else {
                    node = stk.top(); stk.pop();
                }
                if (!stk.top()->left) stk.top()->left = node;
                else stk.top()->right = node;
            } else val.push_back(ch);
        return stk.size() ? stk.top() : new TreeNode(stoi(val));
    }


    /*537. Complex Number Multiplication (Medium)
    A complex number can be represented as a string on the form "real+imaginaryi"
    where:
    * real is the real part and is an integer in the range [-100, 100].
    * imaginary is the imaginary part and is an integer in the range [-100, 100].
    * i2 == -1.
    Given two complex numbers num1 and num2 as strings, return a string of the
    complex number that represents their multiplications.

    Example 1:
    Input: num1 = "1+1i", num2 = "1+1i"
    Output: "0+2i"
    Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert
                 it to the form of 0+2i.

    Example 2:
    Input: num1 = "1+-1i", num2 = "1+-1i"
    Output: "0+-2i"
    Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert
                 it to the form of 0+-2i.

    Constraints: num1 and num2 are valid complex numbers.*/

    string complexNumberMultiply(string num1, string num2) {
        int r1 = 0, i1 = 0, r2 = 0, i2 = 0;
        char buf;
        stringstream ss1(num1), ss2(num2), ans;
        ss1 >> r1 >> buf >> i1 >> buf;
        ss2 >> r2 >> buf >> i2 >> buf;
        ans << r1*r2 - i1*i2 << "+" << r1*i2 + r2*i1 << "i";
        return ans.str();
    }


    /*540. Single Element in a Sorted Array (Medium)
    You are given a sorted array consisting of only integers where every
    element appears exactly twice, except for one element which appears exactly
    once. Return the single element that appears only once. Your solution must
    run in O(log n) time and O(1) space.

    Example 1:
    Input: nums = [1,1,2,3,3,4,4,8,8]
    Output: 2

    Example 2:
    Input: nums = [3,3,7,7,10,11,11]
    Output: 10

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5*/

    int singleNonDuplicate(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1;
        while (lo < hi) {
            int mid = lo + hi >> 1;
            if (nums[mid] == nums[mid^1]) lo = mid+1;
            else hi = mid;
        }
        return nums[lo];
    }


    /*542. 01 Matrix (Medium)
    Given an m x n binary matrix mat, return the distance of the nearest 0 for
    each cell. The distance between two adjacent cells is 1.

    Example 1:
    Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
    Output: [[0,0,0],[0,1,0],[0,0,0]]

    Example 2:
    Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
    Output: [[0,0,0],[0,1,0],[1,2,1]]

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 10^4
    * 1 <= m * n <= 10^4
    * mat[i][j] is either 0 or 1.
    * There is at least one 0 in mat.*/

    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size();
        vector<vector<int>> ans(m, vector<int>(n, m*n));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (!mat[i][j]) ans[i][j] = 0;
                else {
                    if (i) ans[i][j] = min(ans[i][j], 1 + ans[i-1][j]);
                    if (j) ans[i][j] = min(ans[i][j], 1 + ans[i][j-1]);
                }

        for (int i = m-1; i >= 0; --i)
            for (int j = n-1; j >= 0; --j)
                if (mat[i][j]) {
                    if (i+1 < m) ans[i][j] = min(ans[i][j], 1 + ans[i+1][j]);
                    if (j+1 < n) ans[i][j] = min(ans[i][j], 1 + ans[i][j+1]);
                }
        return ans;
    }


    /*543. Diameter of Binary Tree (Easy)
    Given the root of a binary tree, return the length of the diameter of the
    tree. The diameter of a binary tree is the length of the longest path
    between any two nodes in a tree. This path may or may not pass through the
    root. The length of a path between two nodes is represented by the number
    of edges between them.

    Example 1:
    Input: root = [1,2,3,4,5]
    Output: 3
    Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].

    Example 2:
    Input: root = [1,2]
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -100 <= Node.val <= 100*/

    int diameterOfBinaryTree(TreeNode* root) {
        int ans = 0;

        function<int(TreeNode*)> fn = [&](TreeNode* node) {
            if (!node) return 0;
            int left = fn(node->left), right = fn(node->right);
            ans = max(ans, left + right);
            return 1 + max(left, right);
        };

        fn(root);
        return ans;
    }


    /*544. Output Contest Matches (Medium)
    During the NBA playoffs, we always set the rather strong team to play with
    the rather weak team, like make the rank 1 team play with the rank nth team,
    which is a good strategy to make the contest more interesting. Given n
    teams, return their final contest matches in the form of a string. The n
    teams are labeled from 1 to n, which represents their initial rank (i.e.,
    Rank 1 is the strongest team and Rank n is the weakest team). We will use
    parentheses '(', and ')' and commas ',' to represent the contest team
    pairing. We use the parentheses for pairing and the commas for partition.
    During the pairing process in each round, you always need to follow the
    strategy of making the rather strong one pair with the rather weak one.

    Example 1:
    Input: n = 4
    Output: "((1,4),(2,3))"
    Explanation: In the first round, we pair the team 1 and 4, the teams 2 and
                 3 together, as we need to make the strong team and weak team
                 together. And we got (1, 4),(2, 3). In the second round, the
                 winners of (1, 4) and (2, 3) need to play again to generate
                 the final winner, so you need to add the paratheses outside
                 them. And we got the final answer ((1,4),(2,3)).

    Example 2:
    Input: n = 8
    Output: "(((1,8),(4,5)),((2,7),(3,6)))"
    Explanation: First round: (1, 8),(2, 7),(3, 6),(4, 5)
                 Second round: ((1, 8),(4, 5)),((2, 7),(3, 6))
                 Third round: (((1, 8),(4, 5)),((2, 7),(3, 6)))
                 Since the third round will generate the final winner, you need
                 to output the answer (((1,8),(4,5)),((2,7),(3,6))).

    Constraints: n == 2^x where x in in the range [1, 12].*/

    string findContestMatch(int n) {
        vector<string> ans(n);
        for (int i = 0; i < n; ++i) ans[i] = to_string(i+1);
        for (int n = ans.size(); n > 1; n /= 2)
            for (int i = 0; i < n/2; ++i) {
                ans[i] = "(" + ans[i] + "," + ans[n-i-1] + ")";
                ans.pop_back();
            }
        return ans[0];
    }


    /*545. Boundary of Binary Tree (Medium)
    The boundary of a binary tree is the concatenation of the root, the left
    boundary, the leaves ordered from left-to-right, and the reverse order of
    the right boundary. The left boundary is the set of nodes defined by the
    following:
    * The root node's left child is in the left boundary. If the root does not
      have a left child, then the left boundary is empty.
    * If a node in the left boundary and has a left child, then the left child
      is in the left boundary.
    * If a node is in the left boundary, has no left child, but has a right
      child, then the right child is in the left boundary.
    * The leftmost leaf is not in the left boundary.
    The right boundary is similar to the left boundary, except it is the right
    side of the root's right subtree. Again, the leaf is not part of the right
    boundary, and the right boundary is empty if the root does not have a right
    child. The leaves are nodes that do not have any children. For this problem,
    the root is not a leaf. Given the root of a binary tree, return the values
    of its boundary.

    Example 1:
    Input: root = [1,null,2,3,4]
    Output: [1,3,4,2]
    Explanation: - The left boundary is empty because the root does not have a
                   left child.
                 - The right boundary follows the path starting from the root's
                   right child 2 -> 4. 4 is a leaf, so the right boundary is [2].
                 - The leaves from left to right are [3,4].
                 Concatenating everything results in
                 [1] + [] + [3,4] + [2] = [1,3,4,2].

    Example 2:
    Input: root = [1,2,3,4,5,6,null,null,null,7,8,9,10]
    Output: [1,2,4,7,8,9,10,6,3]
    Explanation: - The left boundary follows the path starting from the root's
                   left child 2 -> 4. 4 is a leaf, so the left boundary is [2].
                 - The right boundary follows the path starting from the root's
                   right child 3 -> 6 -> 10. 10 is a leaf, so the right
                   boundary is [3,6], and in reverse order is [6,3].
                 - The leaves from left to right are [4,7,8,9,10].
                 Concatenating everything results in
                 [1] + [2] + [4,7,8,9,10] + [6,3] = [1,2,4,7,8,9,10,6,3].

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -1000 <= Node.val <= 1000*/

    vector<int> boundaryOfBinaryTree(TreeNode* root) {
        stack<pair<TreeNode*, int>> stk;
        if (root->right) stk.emplace(root->right, 1);
        if (root->left) stk.emplace(root->left, -1);
        vector<int> left, right, leaves;
        while (stk.size()) {
            auto [node, v] = stk.top(); stk.pop();
            if (!node->left && !node->right) leaves.push_back(node->val);
            else if (v == -1) {
                left.push_back(node->val);
                if (node->right) {
                    if (node->left) stk.emplace(node->right, 0);
                    else stk.emplace(node->right, -1);
                }
                if (node->left) stk.emplace(node->left, -1);
            } else if (v == 1) {
                right.push_back(node->val);
                if (node->right) stk.emplace(node->right, 1);
                if (node->left) {
                    if (node->right) stk.emplace(node->left, 0);
                    else stk.emplace(node->left, 1);
                }
            } else {
                if (node->right) stk.emplace(node->right, 0);
                if (node->left) stk.emplace(node->left, 0);
            }
        }
        reverse(right.begin(), right.end());
        vector<int> ans;
        ans.reserve(1 + left.size() + right.size() + leaves.size());
        ans.push_back(root->val);
        ans.insert(ans.end(), left.begin(), left.end());
        ans.insert(ans.end(), leaves.begin(), leaves.end());
        ans.insert(ans.end(), right.begin(), right.end());
        return ans;
    }


    /*546. Remove Boxes (Hard)
    You are given several boxes with different colors represented by different
    positive numbers. You may experience several rounds to remove boxes until
    there is no box left. Each time you can choose some continuous boxes with
    the same color (i.e., composed of k boxes, k >= 1), remove them and get
    k * k points. Return the maximum points you can get.

    Example 1:
    Input: boxes = [1,3,2,2,2,3,4,3,1]
    Output: 23
    Explanation: [1, 3, 2, 2, 2, 3, 4, 3, 1]
                 ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)
                 ----> [1, 3, 3, 3, 1] (1*1=1 points)
                 ----> [1, 1] (3*3=9 points)
                 ----> [] (2*2=4 points)

    Example 2:
    Input: boxes = [1,1,1]
    Output: 9

    Example 3:
    Input: boxes = [1]
    Output: 1

    Constraints:
    * 1 <= boxes.length <= 100
    * 1 <= boxes[i] <= 100*/

    int removeBoxes(vector<int>& boxes) {
        int n = boxes.size(), memo[n+1][n+1][n+1];
        memset(memo, -1, sizeof(memo));

        function<int(int, int, int)> fn = [&](int lo, int hi, int k) {
            if (memo[lo][hi][k] == -1) {
                if (lo == hi) memo[lo][hi][k] = 0;
                else if (lo+1 < hi && boxes[lo] == boxes[lo+1]) memo[lo][hi][k] = fn(lo+1, hi, k+1);
                else {
                    memo[lo][hi][k] = (k+1)*(k+1) + fn(lo+1, hi, 0);
                    for (int mid = lo+2; mid < hi; ++mid) {
                        if (boxes[lo] == boxes[mid])
                            memo[lo][hi][k] = max(memo[lo][hi][k], fn(lo+1, mid, 0) + fn(mid, hi, k+1));
                    }
                }
            }
            return memo[lo][hi][k];
        };

        return fn(0, n, 0);
    }


    /*547. Number of Provinces (Medium)
    There are n cities. Some of them are connected, while some are not. If city
    a is connected directly with city b, and city b is connected directly with
    city c, then city a is connected indirectly with city c. A province is a
    group of directly or indirectly connected cities and no other cities
    outside of the group. You are given an n x n matrix isConnected where
    isConnected[i][j] = 1 if the ith city and the jth city are directly
    connected, and isConnected[i][j] = 0 otherwise. Return the total number of
    provinces.

    Example 1:
    Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
    Output: 2

    Example 2:
    Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
    Output: 3

    Constraints:
    * 1 <= n <= 200
    * n == isConnected.length
    * n == isConnected[i].length
    * isConnected[i][j] is 1 or 0.
    * isConnected[i][i] == 1
    * isConnected[i][j] == isConnected[j][i]*/

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size(), ans = 0;
        vector<bool> visited(n);
        for (int i = 0; i < n; ++i)
            if (!visited[i]) {
                ++ans;
                visited[i] = true;
                stack<int> stk; stk.push(i);
                while (stk.size()) {
                    int i = stk.top(); stk.pop();
                    for (int ii = 0; ii < n; ++ii)
                        if (isConnected[i][ii] && !visited[ii]) {
                            visited[ii] = true;
                            stk.push(ii);
                        }
                }
            }
        return ans;
    }


    /*548. Split Array with Equal Sum (Hard)
    Given an integer array nums of length n, return true if there is a triplet
    (i, j, k) which satisfies the following conditions:
    * 0 < i, i + 1 < j, j + 1 < k < n - 1
    * The sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and
      (k + 1, n - 1) is equal.
    A subarray (l, r) represents a slice of the original array starting from
    the element indexed l to the element indexed r.

    Example 1:
    Input: nums = [1,2,1,2,1,2,1]
    Output: true
    Explanation: i = 1, j = 3, k = 5.
                 sum(0, i - 1) = sum(0, 0) = 1
                 sum(i + 1, j - 1) = sum(2, 2) = 1
                 sum(j + 1, k - 1) = sum(4, 4) = 1
                 sum(k + 1, n - 1) = sum(6, 6) = 1

    Example 2:
    Input: nums = [1,2,1,2,1,2,1,2]
    Output: false

    Constraints:
    * n == nums.length
    * 1 <= n <= 2000
    * -10^6 <= nums[i] <= 10^6*/

    bool splitArray(vector<int>& nums) {
        vector<int> prefix(1);
        for (auto& x : nums) prefix.push_back(prefix.back() + x);
        for (int j = 0, n = nums.size(); j < n; ++j) {
            unordered_set<int> seen;
            for (int i = 1; i+1 < j; ++i)
                if (prefix[i] == prefix[j] - prefix[i+1]) seen.insert(prefix[i]);
            for (int k = j+2; k+1 < n; ++k)
                if (prefix[k] - prefix[j+1] == prefix.back() - prefix[k+1] && seen.count(prefix[k] - prefix[j+1])) return true;
        }
        return false;
    }


    /*549. Binary Tree Longest Consecutive Sequence II (Medium)
    Given the root of a binary tree, return the length of the longest
    consecutive path in the tree. A consecutive path is a path where the values
    of the consecutive nodes in the path differ by one. This path can be either
    increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both
    considered valid, but the path [1,2,4,3] is not valid. On the other hand,
    the path can be in the child-Parent-child order, where not necessarily be
    parent-child order.

    Example 1:
    Input: root = [1,2,3]
    Output: 2
    Explanation: The longest consecutive path is [1, 2] or [2, 1].

    Example 2:
    Input: root = [2,1,3]
    Output: 3
    Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1].

    Constraints:
    * The number of nodes in the tree is in the range [1, 3 * 10^4].
    * -3 * 10^4 <= Node.val <= 3 * 10^4*/

    int longestConsecutive(TreeNode* root) {
        int ans = 0;
        unordered_map<TreeNode*, array<int, 2>> mp;
        stack<TreeNode*> stk;
        TreeNode *node = root, *prev = nullptr;

        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top();
                if (node->right && node->right != prev) node = node->right;
                else {
                    mp[node] = {1, 1};
                    if (node->left) {
                        if (node->left->val + 1 == node->val) mp[node][0] = 1 + mp[node->left][0];
                        if (node->left->val - 1 == node->val) mp[node][1] = 1 + mp[node->left][1];
                    }
                    if (node->right) {
                        if (node->right->val + 1 == node->val) mp[node][0] = max(mp[node][0], 1 + mp[node->right][0]);
                        if (node->right->val - 1 == node->val) mp[node][1] = max(mp[node][1], 1 + mp[node->right][1]);
                    }
                    ans = max(ans, mp[node][0] + mp[node][1] - 1);
                    stk.pop();
                    prev = node;
                    node = nullptr;
                }
            }
        return ans;
    }


    /*552. Student Attendance Record II (Hard)
    An attendance record for a student can be represented as a string where
    each character signifies whether the student was absent, late, or present
    on that day. The record only contains the following three characters:
    * 'A': Absent.
    * 'L': Late.
    * 'P': Present.
    Any student is eligible for an attendance award if they meet both of the
    following criteria:
    * The student was absent ('A') for strictly fewer than 2 days total.
    * The student was never late ('L') for 3 or more consecutive days.
    Given an integer n, return the number of possible attendance records of
    length n that make a student eligible for an attendance award. The answer
    may be very large, so return it modulo 10^9 + 7.

    Example 1:
    Input: n = 2
    Output: 8
    Explanation: There are 8 records with length 2 that are eligible for an
                 award: "PP", "AP", "PA", "LP", "PL", "AL", "LA", "LL". Only
                 "AA" is not eligible because there are 2 absences (there need
                 to be fewer than 2).

    Example 2:
    Input: n = 1
    Output: 3

    Example 3:
    Input: n = 10101
    Output: 183236316

    Constraints: 1 <= n <= 10^5*/

    int checkRecord(int n) {
        vector<long> dp = {1, 2, 4};
        for (int i = 3; i <= n; ++i)
            dp.push_back((dp[i-3] + dp[i-2] + dp[i-1]) % 1'000'000'007);
        int ans = dp[n];
        for (int i = 0; i < n; ++i)
            ans = (ans + dp[i] * dp[n-1-i]) % 1'000'000'007;
        return ans;
    }


    /*553. Optimal Division (Medium)
    You are given an integer array nums. The adjacent integers in nums will
    perform the float division. For example, for nums = [2,3,4], we will
    evaluate the expression "2/3/4". However, you can add any number of
    parenthesis at any position to change the priority of operations. You want
    to add these parentheses such the value of the expression after the
    evaluation is maximum. Return the corresponding expression that has the
    maximum value in string format. Note: your expression should not contain
    redundant parenthesis.

    Example 1:
    Input: nums = [1000,100,10,2]
    Output: "1000/(100/10/2)"
    Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200. However, the bold
                 parenthesis in "1000/((100/10)/2)" are redundant, since they
                 don't influence the operation priority. So you should return
                 "1000/(100/10/2)".
                 Other cases:
                 1000/(100/10)/2 = 50
                 1000/(100/(10/2)) = 50
                 1000/100/10/2 = 0.5
                 1000/100/(10/2) = 2

    Example 2:
    Input: nums = [2,3,4]
    Output: "2/(3/4)"

    Example 3:
    Input: nums = [2]
    Output: "2"

    Constraints:
    * 1 <= nums.length <= 10
    * 2 <= nums[i] <= 1000
    * There is only one optimal division for the given iput.*/

    string optimalDivision(vector<int>& nums) {
        string ans = to_string(nums[0]);
        if (size(nums) == 1) return ans;

        ans += "/";
        if (size(nums) == 2) return ans + to_string(nums[1]);

        ans += "(" + to_string(nums[1]);
        for (int i = 2; i < size(nums); ++i)
            ans += "/" + to_string(nums[i]);
        return ans + ")";
    }


    /*554. Brick Wall (Medium)
    There is a brick wall in front of you. The wall is rectangular and has
    several rows of bricks. The bricks have the same height but different width.
    You want to draw a vertical line from the top to the bottom and cross the
    least bricks. The brick wall is represented by a list of rows. Each row is
    a list of integers representing the width of each brick in this row from
    left to right. If your line go through the edge of a brick, then the brick
    is not considered as crossed. You need to find out how to draw the line to
    cross the least bricks and return the number of crossed bricks. You cannot
    draw a line just along one of the two vertical edges of the wall, in which
    case the line will obviously cross no bricks.

    Example:
    Input: [[1,2,2,1],
            [3,1,2],
            [1,3,2],
            [2,4],
            [3,1,2],
            [1,3,1,1]]

    Output: 2

    Note:
    * The width sum of bricks in different rows are the same and won't exceed
      INT_MAX.
    * The number of bricks in each row is in range [1,10,000]. The height of
      wall is in range [1,10,000]. Total number of bricks of the wall won't
      exceed 20,000.*/

    int leastBricks(vector<vector<int>>& wall) {
        int mx = 0;
        unordered_map<int, int> freq;
        for (auto row : wall) {
            int prefix = 0;
            for (int i = 0; i < row.size()-1; ++i) {
                prefix += row[i];
                mx = max(mx, ++freq[prefix]);
            }
        }
        return wall.size() - mx;
    }


    /*555. Split Concatenated Strings (Medium)
    You are given an array of strings strs. You could concatenate these strings
    together into a loop, where for each string, you could choose to reverse it
    or not. Among all the possible loops, return the lexicographically largest
    string after cutting the loop, which will make the looped string into a
    regular one. Specifically, to find the lexicographically largest string,
    you need to experience two phases:
    * Concatenate all the strings into a loop, where you can reverse some
      strings or not and connect them in the same order as given.
    * Cut and make one breakpoint in any place of the loop, which will make the
      looped string into a regular one starting from the character at the
      cutpoint.
    And your job is to find the lexicographically largest one among all the
    possible regular strings.

    Example 1:
    Input: strs = ["abc","xyz"]
    Output: "zyxcba"
    Explanation: You can get the looped string "-abcxyz-", "-abczyx-",
                 "-cbaxyz-", "-cbazyx-", where '-' represents the looped status.
                 The answer string came from the fourth looped one, where you
                 could cut from the middle character 'a' and get "zyxcba".

    Example 2:
    Input: strs = ["abc"]
    Output: "cba"

    Constraints:
    * 1 <= strs.length <= 1000
    * 1 <= strs[i].length <= 1000
    * 1 <= sum(strs[i].length) <= 1000
    * strs[i] consists of lowercase English letters.*/

    string splitLoopedString(vector<string>& strs) {
        string s;
        for (int i = 0; i < strs.size(); ++i) {
            string rev = strs[i];
            reverse(rev.begin(), rev.end());
            s += max(strs[i], rev);
        }

        string ans;
        for (int i = 0, ii = 0; i < strs.size(); ii += strs[i].size(), ++i) {
            string rest = s.substr(ii + strs[i].size()) + s.substr(0, ii), rev = strs[i];
            reverse(rev.begin(), rev.end());
            for (int k = 0; k < strs[i].size(); ++k) {
                ans = max(ans, strs[i].substr(k) + rest + strs[i].substr(0, k));
                ans = max(ans, rev.substr(k) + rest + rev.substr(0, k));
            }
        }
        return ans;
    }


    /*557. Reverse Words in a String III (Easy)
    Given a string s, reverse the order of characters in each word within a
    sentence while still preserving whitespace and initial word order.

    Example 1:
    Input: s = "Let's take LeetCode contest"
    Output: "s'teL ekat edoCteeL tsetnoc"

    Example 2:
    Input: s = "God Ding"
    Output: "doG gniD"

    Constraints:
    * 1 <= s.length <= 5 * 10^4
    * s contains printable ASCII characters.
    * s does not contain any leading or trailing spaces.
    * There is at least one word in s.
    * All the words in s are separated by a single space.*/

    string reverseWords(string s) {
        for (int i = 0, lo = 0; i < s.size(); ++i)
            if (i+1 == s.size() || s[i+1] == ' ') {
                for (int hi = i; lo < hi; ++lo, --hi)
                    swap(s[lo], s[hi]);
                lo = i+2;
            }
        return s;
    }


    /*559. Maximum Depth of N-ary Tree (Easy)
    Given a n-ary tree, find its maximum depth. The maximum depth is the number
    of nodes along the longest path from the root node down to the farthest
    leaf node. Nary-Tree input serialization is represented in their level
    order traversal, each group of children is separated by the null value (See
    examples).

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: 3

    Example 2:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: 5

    Constraints:
    * The depth of the n-ary tree is less than or equal to 1000.
    * The total number of nodes is between [0, 10^4].*/

    int maxDepth(Node* root) {
        if (!root) return 0; // edge case

        queue<Node*> q;
        q.push(root);
        int ans = 0;
        while (!q.empty()) {
            ++ans;
            for (int i = 0, n = q.size(); i < n; ++i) {
                Node* node = q.front();
                q.pop();
                for (auto &child : node->children) {
                    q.push(child);
                }
            }
        }
        return ans;
    }


    /*560. Subarray Sum Equals K (Medium)
    Given an array of integers nums and an integer k, return the total number
    of continuous subarrays whose sum equals to k.

    Example 1:
    Input: nums = [1,1,1], k = 2
    Output: 2

    Example 2:
    Input: nums = [1,2,3], k = 3
    Output: 2

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * -1000 <= nums[i] <= 1000
    * -10^7 <= k <= 10^7*/

    int subarraySum(vector<int>& nums, int k) {
        int ans = 0, prefix = 0;
        unordered_map<int, int> freq = {{0, 1}};
        for (auto& x : nums) {
            prefix += x;
            ans += freq[prefix - k];
            ++freq[prefix];
        }
        return ans;
    }


    /*561. Array Partition I (Easy)
    Given an integer array nums of 2n integers, group these integers into n
    pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi)
    for all i is maximized. Return the maximized sum.

    Example 1:
    Input: nums = [1,4,3,2]
    Output: 4
    Explanation: All possible pairings (ignoring the ordering of elements) are:
    1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
    2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
    3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
    So the maximum possible sum is 4.

    Example 2:
    Input: nums = [6,2,6,5,1,2]
    Output: 9
    Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.

    Constraints:
    * 1 <= n <= 10^4
    * nums.length == 2 * n
    * -10^4 <= nums[i] <= 10^4*/

    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        for (int i = 0; i < nums.size(); i += 2)
            ans += nums[i];
        return ans;
    }


    /*563. Binary Tree Tilt (Easy)
    Given the root of a binary tree, return the sum of every tree node's tilt.
    The tilt of a tree node is the absolute difference between the sum of all
    left subtree node values and all right subtree node values. If a node does
    not have a left child, then the sum of the left subtree node values is
    treated as 0. The rule is similar if there the node does not have a right
    child.

    Example 1:
    Input: root = [1,2,3]
    Output: 1
    Explanation: Tilt of node 2 : |0-0| = 0 (no children)
                 Tilt of node 3 : |0-0| = 0 (no children)
                 Tilt of node 1 : |2-3| = 1 (left subtree is just left child,
                 so sum is 2; right subtree is just right child, so sum is 3)
                 Sum of every tilt : 0 + 0 + 1 = 1

    Example 2:
    Input: root = [4,2,9,3,5,null,7]
    Output: 15
    Explanation: Tilt of node 3 : |0-0| = 0 (no children)
                 Tilt of node 5 : |0-0| = 0 (no children)
                 Tilt of node 7 : |0-0| = 0 (no children)
                 Tilt of node 2 : |3-5| = 2 (left subtree is just left child,
                 so sum is 3; right subtree is just right child, so sum is 5)
                 Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right
                 subtree is just right child, so sum is 7)
                 Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree
                 values are 3, 5, and 2, which sums to 10; right subtree values
                 are 9 and 7, which sums to 16)
                 Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15

    Example 3:
    Input: root = [21,7,14,1,1,2,2,3,3]
    Output: 9

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * -1000 <= Node.val <= 1000*/

    int findTilt(TreeNode* root) {
        int ans = 0;
        unordered_map<TreeNode*, int> mp = {{nullptr, 0}};
        TreeNode *prev = nullptr, *node = root;
        stack<TreeNode*> stk;
        while (node || stk.size()) {
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top();
                if (node->right && prev != node->right) node = node->right;
                else {
                    ans += abs(mp[node->left] - mp[node->right]);
                    mp[node] = node->val + mp[node->left] + mp[node->right];
                    stk.pop();
                    prev = node;
                    node = nullptr;
                }
            }
        }
        return ans;
    }


    /*564. Find the Closest Palindrome (Hard)
    Given a string n representing an integer, return the closest integer (not
    including itself), which is a palindrome. If there is a tie, return the
    smaller one. The closest is defined as the absolute difference minimized
    between two integers.

    Example 1:
    Input: n = "123"
    Output: "121"

    Example 2:
    Input: n = "1"
    Output: "0"
    Explanation: 0 and 2 are the closest palindromes but we return the smallest
                 which is 0.

    Constraints:
    * 1 <= n.length <= 18
    * n consists of only digits.
    * n does not have leading zeros.
    * n is representing an integer in the range [1, 10^18 - 1].*/

    string nearestPalindromic(string n) {
        int sz = n.size();
        string half = n.substr(0, sz/2), rev = half;
        reverse(rev.begin(), rev.end());
        string cand = half + (sz & 1 ? string(1, n[sz/2]) : "") + rev;

        auto fn = [&](int carry) {
            vector<int> digits;
            for (int i = 0; i < (sz+1)/2; ++i) digits.push_back(n[i] - '0');
            for (int i = (sz-1)/2; i >= 0 && carry; --i) {
                digits[i] += carry;
                carry = digits[i] < 0 ? -1 : digits[i] / 10;
                digits[i] = (10 + digits[i]) % 10;
            }
            string half, rev;
            for (auto& x : digits)
                if (half.size() || x || carry) half.push_back(x + '0');
            if (carry) half = string(1, carry+'0') + half;
            if (half.size() < digits.size()) return sz > 1 ? string(sz-1, '9') : "0";
            if (half.size() > digits.size()) return string(1, '1') + string(sz-1, '0') + string(1, '1');
            if (half.size() == 0) half = "0";
            rev = half;
            if (sz & 1) rev.pop_back();
            reverse(rev.begin(), rev.end());
            return half + rev;
        };

        string large = fn(1), small = fn(-1);
        if (cand == n)
            return abs(stol(small) - stol(n)) <= abs(stol(large) - stol(n)) ? small : large;
        if (cand < n)
            return abs(stol(cand) - stol(n)) <= abs(stol(large) - stol(n)) ? cand : large;
            return abs(stol(small) - stol(n)) <= abs(stol(cand) - stol(n)) ? small : cand;
    }


    /*565. Array Nesting (Medium)
    You are given an integer array nums of length n where nums is a permutation
    of the numbers in the range [0, n - 1]. You should build a set
    s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the
    following rule:
    * The first element in s[k] starts with the selection of the element nums[k]
      of index = k.
    * The next element in s[k] should be nums[nums[k]], and then
      nums[nums[nums[k]]], and so on.
    * We stop adding right before a duplicate element occurs in s[k].
    Return the longest length of a set s[k].

    Example 1:
    Input: nums = [5,4,0,3,1,6,2]
    Output: 4
    Explanation: nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1,
                 nums[5] = 6, nums[6] = 2. One of the longest sets s[k]:
                 s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}

    Example 2:
    Input: nums = [0,1,2]
    Output: 1

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] < nums.length
    * All the values of nums are unique.*/

    int arrayNesting(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < nums.size(); ++i) {
            int cnt = 0;
            for (; nums[i] != -1; ++cnt) {
                int ii = i;
                i = nums[i];
                nums[ii] = -1;
            }
            ans = max(ans, cnt);
        }
        return ans;
    }


    /*566. Reshape the Matrix (Easy)
    In MATLAB, there is a very useful function called 'reshape', which can
    reshape a matrix into a new one with different size but keep its original
    data. You're given a matrix represented by a two-dimensional array, and two
    positive integers r and c representing the row number and column number of
    the wanted reshaped matrix, respectively. The reshaped matrix need to be
    filled with all the elements of the original matrix in the same row-
    traversing order as they were. If the 'reshape' operation with given
    parameters is possible and legal, output the new reshaped matrix; Otherwise,
    output the original matrix.

    Example 1:
    Input: nums = [[1,2], [3,4]], r = 1, c = 4
    Output: [[1,2,3,4]]
    Explanation: The row-traversing of nums is [1,2,3,4]. The new reshaped
                 matrix is a 1 * 4 matrix, fill it row by row by using the
                 previous list.

    Example 2:
    Input: nums = [[1,2], [3,4]], r = 2, c = 4
    Output: [[1,2],  [3,4]]
    Explanation: There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix.
                 So output the original matrix.

    Note:
    * The height and width of the given matrix is in range [1, 100].
    * The given r and c are all positive.*/

    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {
        int m = mat.size(), n = mat[0].size();
        if (m * n != r * c) return mat;
        vector<vector<int>> ans(r, vector<int>(c));
        for (int i = 0; i < m * n; ++i) ans[i/c][i%c] = mat[i/n][i%n];
        return ans;
    }


    /*567. Permutation in String (Medium)
    Given two strings s1 and s2, return true if s2 contains a permutation of s1,
    or false otherwise. In other words, return true if one of s1's permutations
    is the substring of s2.

    Example 1:
    Input: s1 = "ab", s2 = "eidbaooo"
    Output: true
    Explanation: s2 contains one permutation of s1 ("ba").

    Example 2:
    Input: s1 = "ab", s2 = "eidboaoo"
    Output: false

    Constraints:
    * 1 <= s1.length, s2.length <= 10^4
    * s1 and s2 consist of lowercase English letters.*/

    bool checkInclusion(string s1, string s2) {
        vector<int> freq(26);
        for (auto& ch : s1) ++freq[ch-'a'];
        int bal = 26 - count(freq.begin(), freq.end(), 0);
        for (int i = 0, n = s1.size(); i < s2.size(); ++i) {
            if (freq[s2[i]-'a'] == 0) ++bal;
            if (--freq[s2[i]-'a'] == 0) --bal;
            if (i >= n) {
                if (freq[s2[i-n]-'a'] == 0) ++bal;
                if (++freq[s2[i-n]-'a'] == 0) --bal;
            }
            if (bal == 0) return true;
        }
        return false;
    }


    /*572. Subtree of Another Tree (Easy)
    Given two non-empty binary trees s and t, check whether tree t has exactly
    the same structure and node values with a subtree of s. A subtree of s is a
    tree consists of a node in s and all of this node's descendants. The tree s
    could also be considered as a subtree of itself.

    Example 1:
    Given tree s:

         3
        / \
       4   5
      / \
     1   2
    Given tree t:
       4
      / \
     1   2
    Return true, because t has the same structure and node values with a subtree of s.

    Example 2:
    Given tree s:

         3
        / \
       4   5
      / \
     1   2
        /
       0
    Given tree t:
       4
      / \
     1   2
    Return false.*/

    /*
    bool check(TreeNode* ss, TreeNode* tt) {
        if (!ss && !tt) return true;
        if (!ss || !tt) return false;
        return (ss->val == tt->val) && check(ss->left, tt->left) && check(ss->right, tt->right);
    }*/

    bool isSubtree(TreeNode* s, TreeNode* t) {
        stack<TreeNode*> stk;
        stk.push(s);

        while (!stk.empty()) {
            TreeNode* node = stk.top();
            stk.pop();
            if (node) {
                if (check(node, t)) return true;
                stk.push(node->right);
                stk.push(node->left);
            }
        }
        return false;
    }


    /*575. Distribute Candies (Easy)
    Alice has n candies, where the ith candy is of type candyType[i]. Alice
    noticed that she started to gain weight, so she visited a doctor. The
    doctor advised Alice to only eat n / 2 of the candies she has (n is always
    even). Alice likes her candies very much, and she wants to eat the maximum
    number of different types of candies while still following the doctor's
    advice. Given the integer array candyType of length n, return the maximum
    number of different types of candies she can eat if she only eats n / 2 of
    them.

    Example 1:
    Input: candyType = [1,1,2,2,3,3]
    Output: 3
    Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3
                 types, she can eat one of each type.

    Example 2:
    Input: candyType = [1,1,2,3]
    Output: 2
    Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types
                 [1,2], [1,3], or [2,3], she still can only eat 2 different
                 types.

    Example 3:
    Input: candyType = [6,6,6,6]
    Output: 1
    Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat
                 2 candies, she only has 1 type.

    Constraints:
    * n == candyType.length
    * 2 <= n <= 10^4
    * n is even.
    * -10^5 <= candyType[i] <= 10^5*/

    int distributeCandies(vector<int>& candyType) {
        unordered_map<int, int> freq;
        for (auto &x : candyType) {
            ++freq[x];
        }
        return min(candyType.size()/2, freq.size());
    }


    /*576. Out of Boundary Paths (Medium)
    There is an m x n grid with a ball. The ball is initially at the position
    [startRow, startColumn]. You are allowed to move the ball to one of the
    four adjacent four cells in the grid (possibly out of the grid crossing the
    grid boundary). You can apply at most maxMove moves to the ball. Given the
    five integers m, n, maxMove, startRow, startColumn, return the number of
    paths to move the ball out of the grid boundary. Since the answer can be
    very large, return it modulo 10^9 + 7.

    Example 1:
    Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
    Output: 6

    Example 2:
    Input: m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1
    Output: 12

    Constraints:
    * 1 <= m, n <= 50
    * 0 <= maxMove <= 50
    * 0 <= startRow <= m
    * 0 <= startColumn <= n*/

    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        long memo[m][n][maxMove+1];
        memset(memo, -1, sizeof(memo));

        function<long(int, int, int)> fn = [&](int i, int j, int mv) {
            if (i < 0 || i >= m || j < 0 || j >= n) return 1l;
            if (mv == 0) return 0l;
            if (memo[i][j][mv] < 0)
                memo[i][j][mv] = (fn(i-1, j, mv-1) + fn(i, j-1, mv-1) + fn(i, j+1, mv-1) + fn(i+1, j, mv-1)) % 1'000'000'007;
            return memo[i][j][mv];
        };

        return fn(startRow, startColumn, maxMove);
    }


    /*587. Erect the Fence (Hard)
    You are given an array trees where trees[i] = [xi, yi] represents the
    location of a tree in the garden. You are asked to fence the entire garden
    using the minimum length of rope as it is expensive. The garden is well
    fenced only if all the trees are enclosed. Return the coordinates of trees
    that are exactly located on the fence perimeter.

    Example 1:
    Input: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
    Output: [[1,1],[2,0],[3,3],[2,4],[4,2]]

    Example 2:
    Input: points = [[1,2],[2,2],[4,2]]
    Output: [[4,2],[2,2],[1,2]]

    Constraints:
    * 1 <= points.length <= 3000
    * points[i].length == 2
    * 0 <= xi, yi <= 100
    * All the given points are unique.*/

    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
        int xx = INT_MAX, yy = INT_MAX;
        for (auto& p : trees)
            if (p[1] < yy || (p[0] < xx && p[1] == yy)) {
                xx = p[0];
                yy = p[1];
            }

        map<double, vector<vector<int>>> mp;
        for (auto& p : trees) mp[atan2(p[1] - yy, p[0] - xx)].push_back(p);

        vector<vector<int>> vals;
        for (auto& [k, v] : mp) {
            sort(v.begin(), v.end(), [&](auto& lhs, auto& rhs) {
                return abs(lhs[0] - xx) + abs(lhs[1] - yy) < abs(rhs[0] - xx) + abs(rhs[1] - yy);
            });
            if (k == mp.rbegin()->first && vals.size()) reverse(v.begin(), v.end());
            for (auto& x : v) vals.push_back(x);
        }

        vector<vector<int>> ans;
        for (auto& p : vals) {
            while (ans.size() >= 2) {
                auto p0 = ans.back(); ans.pop_back();
                auto p1 = ans.back();
                if ((p0[0] - p1[0]) * (p[1] - p0[1]) - (p[0] - p0[0]) * (p0[1] - p1[1]) >= 0) {
                    ans.push_back(p0);
                    break;
                }
            }
            ans.push_back(p);
        }
        return ans;
    }


    /*583. Delete Operation for Two Strings (Medium)
    Given two strings word1 and word2, return the minimum number of steps
    required to make word1 and word2 the same. In one step, you can delete
    exactly one character in either string.

    Example 1:
    Input: word1 = "sea", word2 = "eat"
    Output: 2
    Explanation: You need one step to make "sea" to "ea" and another step to
                 make "eat" to "ea".

    Example 2:
    Input: word1 = "leetcode", word2 = "etco"
    Output: 4

    Constraints:
    * 1 <= word1.length, word2.length <= 500
    * word1 and word2 consist of only lowercase English letters.*/

    int minDistance(string word1, string word2) {
        // longest common subsequence
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for (int i = m-1; i >= 0; --i)
            for (int j = n-1; j >= 0; --j)
                if (word1[i] == word2[j]) dp[i][j] = 1 + dp[i+1][j+1];
                else dp[i][j] = max(dp[i+1][j], dp[i][j+1]);
        return m + n - dp[0][0]*2;
    }


    /*589. N-ary Tree Preorder Traversal (Easy)
    Given the root of an n-ary tree, return the preorder traversal of its nodes'
    values. Nary-Tree input serialization is represented in their level order
    traversal. Each group of children is separated by the null value (See examples)

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: [1,3,5,6,2,4]

    Example 2:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * 0 <= Node.val <= 10^4
    * The height of the n-ary tree is less than or equal to 1000.

    Follow up: Recursive solution is trivial, could you do it iteratively? */

    vector<int> preorder(Node* root) {
        vector<int> ans;
        if (root) {
            stack<Node*> stk;
            stk.push(root);
            while (stk.size()) {
                Node* node = stk.top();
                stk.pop();
                ans.push_back(node->val);
                for (int i = (node->children).size()-1; i >= 0; --i) {
                    stk.push(node->children[i]);
                }
            }
        }
        return ans;
    }


    /*590. N-ary Tree Postorder Traversal (Easy)
    Given the root of an n-ary tree, return the postorder traversal of its
    nodes' values. Nary-Tree input serialization is represented in their level
    order traversal. Each group of children is separated by the null value (See
    examples)

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: [5,6,3,2,4,1]

    Example 2:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * 0 <= Node.val <= 10^4
    * The height of the n-ary tree is less than or equal to 1000.

    Follow up: Recursive solution is trivial, could you do it iteratively?*/

    vector<int> postorder(Node* root) {
        vector<int> ans;
        if (root) {
            stack<Node*> stk; stk.push(root);
            Node *prev = nullptr;
            while (stk.size()) {
                auto node = stk.top();
                if (node->children.size() && prev != node->children.back())
                    for (int i = node->children.size()-1; i >= 0; --i)
                        stk.push(node->children[i]);
                else {
                    ans.push_back(node->val);
                    stk.pop();
                    prev = node;
                }
            }
        }
        return ans;
    }


    /*591. Tag Validator (Hard)
    Given a string representing a code snippet, implement a tag validator to
    parse the code and return whether it is valid. A code snippet is valid if
    all the following rules hold:
    * The code must be wrapped in a valid closed tag. Otherwise, the code is
      invalid.
    * A closed tag (not necessarily valid) has exactly the following format :
      <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag,
      and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should
      be the same. A closed tag is valid if and only if the TAG_NAME and
      TAG_CONTENT are valid.
    * A valid TAG_NAME only contain upper-case letters, and has length in range
      [1,9]. Otherwise, the TAG_NAME is invalid.
    * A valid TAG_CONTENT may contain other valid closed tags, cdata and any
      characters (see note1) EXCEPT unmatched <, unmatched start and end tag,
      and unmatched or closed tags with invalid TAG_NAME. Otherwise, the
      TAG_CONTENT is invalid.
    * A start tag is unmatched if no end tag exists with the same TAG_NAME, and
      vice versa. However, you also need to consider the issue of unbalanced
      when tags are nested.
    * A < is unmatched if you cannot find a subsequent >. And when you find a <
      or </, all the subsequent characters until the next > should be parsed as
      TAG_NAME (not necessarily valid).
    * The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range
      of CDATA_CONTENT is defined as the characters between <![CDATA[ and the
      first subsequent ]]>.
    * CDATA_CONTENT may contain any characters. The function of cdata is to
      forbid the validator to parse CDATA_CONTENT, so even it has some
      characters that can be parsed as tag (no matter valid or invalid), you
      should treat it as regular characters.

    Example 1:
    Input: code = "<DIV>This is the first line <![CDATA[<div>]]></DIV>"
    Output: true
    Explanation: The code is wrapped in a closed tag : <DIV> and </DIV>. The
                 TAG_NAME is valid, the TAG_CONTENT consists of some characters
                 and cdata. Although CDATA_CONTENT has an unmatched start tag
                 with invalid TAG_NAME, it should be considered as plain text,
                 not parsed as a tag. So TAG_CONTENT is valid, and then the
                 code is valid. Thus return true.

    Example 2:
    Input: code = "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"
    Output: true
    Explanation: We first separate the code into : start_tag|tag_content|
                 end_tag.
                 start_tag -> "<DIV>"
                 end_tag -> "</DIV>"
                 tag_content could also be separated into : text1|cdata|text2.
                 text1 -> ">>  ![cdata[]] "
                 cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is
                          "<div>]>"
                 text2 -> "]]>>]"
                 The reason why start_tag is NOT "<DIV>>>" is because of the
                 rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>"
                 is because of the rule 7.

    Example 3:
    Input: code = "<A>  <B> </A>   </B>"
    Output: false
    Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched,
                 and vice versa.

    Constraints:
    * 1 <= code.length <= 500
    * code consists of English letters, digits, '<', '>', '/', '!', '[', ']',
      '.', and ' '.*/

    bool isValid(string code) {
        bool prefix = false, suffix = false;
        stack<string> stk;
        for (int i = 0, ii = 0; i < code.size(); ++i) {
            if (code.substr(i, 2) == "</") {
                ii = i += 2;
                for (; i < code.size() && code[i] != '>'; ++i);
                if (i == code.size()) return false;
                if (i == code.size()-1) suffix = true;
                string tag = code.substr(ii, i-ii);
                if (stk.empty() || stk.top() != tag) return false;
                stk.pop();
                if (stk.empty() && !suffix) return false;
            } else if (code.substr(i, 3) == "<![") {
                ii = i += 3;
                int buffer = 1;
                for (; i < code.size(); ++i) {
                    if (code[i] == '[') {
                        if (buffer) {
                            buffer = 0;
                            if (code.substr(ii, i-ii) != "CDATA") return false;
                        }
                    } else if (code.substr(i, 3) == "]]>") {
                        if (buffer) return false;
                        break;
                    }
                }
                if (i == code.size()) return false;
            } else if (code[i] == '<') {
                ii = ++i;
                for (; i < code.size() && code[i] != '>'; ++i);
                if (i == code.size()) return false;
                if (ii == 1) prefix = true;
                string tag = code.substr(ii, i-ii);
                if (tag.size() == 0 || tag.size() > 9) return false;
                for (auto& ch : tag)
                    if (!('A' <= ch && ch <= 'Z')) return false;
                stk.push(tag);
            }
        }
        return prefix && suffix && stk.empty();
    }


    /*598. Range Addition II (Easy)
    You are given an m x n matrix M initialized with all 0's and an array of
    operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented
    by one for all 0 <= x < ai and 0 <= y < bi. Count and return the number of
    maximum integers in the matrix after performing all the operations.

    Example 1:
    Input: m = 3, n = 3, ops = [[2,2],[3,3]]
    Output: 4
    Explanation: The maximum integer in M is 2, and there are four of it in M.
                 So return 4.

    Example 2:
    Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],
                                [3,3],[2,2],[3,3],[3,3],[3,3]]
    Output: 4

    Example 3:
    Input: m = 3, n = 3, ops = []
    Output: 9

    Constraints:
    * 1 <= m, n <= 4 * 10^4
    * 1 <= ops.length <= 10^4
    * ops[i].length == 2
    * 1 <= ai <= m
    * 1 <= bi <= n*/

    int maxCount(int m, int n, vector<vector<int>>& ops) {
        for (auto& op : ops) {
            m = min(m, op[0]);
            n = min(n, op[1]);
        }
        return m * n;
    }


    /*600. Non-negative Integers without Consecutive Ones (Hard)
    Given a positive integer n, return the number of the integers in the range
    [0, n] whose binary representations do not contain consecutive ones.

    Example 1:
    Input: n = 5
    Output: 5
    Explanation: Here are the non-negative integers <= 5 with their
                 corresponding binary representations:
                 0 : 0
                 1 : 1
                 2 : 10
                 3 : 11
                 4 : 100
                 5 : 101
                 Among them, only integer 3 disobeys the rule (two consecutive
                 ones) and the other 5 satisfy the rule.

    Example 2:
    Input: n = 1
    Output: 2

    Example 3:
    Input: n = 2
    Output: 3

    Constraints: 1 <= n <= 10^9*/

    int findIntegers(int n) {
        vector<int> fib = {1, 2};
        for (int i = 2; i < 32; ++i) fib.push_back(fib[i-2] + fib[i-1]);

        int ans = 0, prev = 0;
        for (int i = 31; i >= 0; --i) {
            if (n & (1 << i)) {
                ans += fib[i];
                if (prev) return ans;
                else prev = 1;
            } else prev = 0;
        }
        return ans + 1;
    }


    /*605. Can Place Flowers (Easy)
    You have a long flowerbed in which some of the plots are planted, and some
    are not. However, flowers cannot be planted in adjacent plots. Given an
    integer array flowerbed containing 0's and 1's, where 0 means empty and 1
    means not empty, and an integer n, return if n new flowers can be planted
    in the flowerbed without violating the no-adjacent-flowers rule.

    Example 1:
    Input: flowerbed = [1,0,0,0,1], n = 1
    Output: true

    Example 2:
    Input: flowerbed = [1,0,0,0,1], n = 2
    Output: false

    Constraints:
    * 1 <= flowerbed.length <= 2 * 10^4
    * flowerbed[i] is 0 or 1.
    * There are no two adjacent flowers in flowerbed.
    * 0 <= n <= flowerbed.length*/

    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        for (int i = 0; i < flowerbed.size(); ++i)
            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i-1] == 0) && (i+1 == flowerbed.size() || flowerbed[i+1] == 0)) {
                flowerbed[i] = 1;
                --n;
            }
        return n <= 0;
    }


    /*609. Find Duplicate File in System (Medium)
    Given a list paths of directory info, including the directory path, and all
    the files with contents in this directory, return all the duplicate files
    in the file system in terms of their paths. You may return the answer in
    any order. A group of duplicate files consists of at least two files that
    have the same content. A single directory info string in the input list has
    the following format:
    * "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"

    It means there are n files (f1.txt, f2.txt ... fn.txt) with content
    (f1_content, f2_content ... fn_content) respectively in the directory
    "root/d1/d2/.../dm". Note that n >= 1 and m >= 0. If m = 0, it means the
    directory is just the root directory. The output is a list of groups of
    duplicate file paths. For each group, it contains all the file paths of the
    files that have the same content. A file path is a string that has the
    following format:
    *"directory_path/file_name.txt"

    Example 1:
    Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"]
    Output: [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]

    Example 2:
    Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)"]
    Output: [["root/a/2.txt","root/c/d/4.txt"],["root/a/1.txt","root/c/3.txt"]]

    Constraints:
    * 1 <= paths.length <= 2 * 10^4
    * 1 <= paths[i].length <= 3000
    * 1 <= sum(paths[i].length) <= 5 * 10^5
    * paths[i] consist of English letters, digits, '/', '.', '(', ')', and ' '.
    * You may assume no files or directories share the same name in the same directory.
    * You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info.


    Follow up:
    * Imagine you are given a real file system, how will you search files? DFS or BFS?
    * If the file content is very large (GB level), how will you modify your solution?
    * If you can only read the file by 1kb each time, how will you modify your solution?
    * What is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize?
    * How to make sure the duplicated files you find are not false positive?*/

    vector<vector<string>> findDuplicate(vector<string>& paths) {
        unordered_map<string, vector<string>> mp;

        for (auto& path : paths) {
            istringstream iss (path);
            string file;
            vector<string> files;
            while (iss >> file)
                files.push_back(file);

            for (int i = 1; i < files.size(); ++i) {
                int k = files[i].find("(");
                mp[files[i].substr(k)].push_back(files[0] + "/" + files[i].substr(0, k));
            }
        }

        vector<vector<string>> ans;
        for (auto x: mp) {
            if (x.second.size() > 1) {
                ans.push_back(x.second);
            }
        }
        return ans;
    }


    /*611. Valid Triangle Number (Medium)
    Given an integer array nums, return the number of triplets chosen from the
    array that can make triangles if we take them as side lengths of a triangle.

    Example 1:
    Input: nums = [2,2,3,4]
    Output: 3
    Explanation: Valid combinations are:
                 2,3,4 (using the first 2)
                 2,3,4 (using the second 2)
                 2,2,3

    Example 2:
    Input: nums = [4,2,3,4]
    Output: 4

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 1000*/

    int triangleNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        for (int i = 0; i < nums.size(); ++i) {
            int lo = 0, hi = i-1;
            while (lo < hi) {
                if (nums[lo] + nums[hi] > nums[i]) ans += (hi--) - lo;
                else ++lo;
            }
        }
        return ans;
    }


    /*616. Add Bold Tag in String (Medium)
    You are given a string s and an array of strings words. You should add a
    closed pair of bold tag <b> and </b> to wrap the substrings in s that exist
    in words.
    * If two such substrings overlap, you should wrap them together with only
      one pair of closed bold-tag.
    * If two substrings wrapped by bold tags are consecutive, you should
      combine them.
    Return s after adding the bold tags.

    Example 1:
    Input: s = "abcxyz123", words = ["abc","123"]
    Output: "<b>abc</b>xyz<b>123</b>"
    Explanation: The two strings of words are substrings of s as following:
                 "abcxyz123". We add <b> before each substring and </b> after
                 each substring.

    Example 2:
    Input: s = "aaabbb", words = ["aa","b"]
    Output: "<b>aaabbb</b>"
    Explanation: "aa" appears as a substring two times: "aaabbb" and "aaabbb".
                 "b" appears as a substring three times: "aaabbb", "aaabbb",
                 and "aaabbb". We add <b> before each substring and </b> after
                 each substring: "<b>a<b>a</b>a</b><b>b</b><b>b</b><b>b</b>".
                 Since the first two <b>'s overlap, we merge them:
                 "<b>aaa</b><b>b</b><b>b</b><b>b</b>". Since now the four <b>'s
                 are consecuutive, we merge them: "<b>aaabbb</b>".

    Constraints:
    * 1 <= s.length <= 1000
    * 0 <= words.length <= 100
    * 1 <= words[i].length <= 1000
    * s and words[i] consist of English letters and digits.
    * All the values of words are unique.

    Note: This question is the same as 758:
          https://leetcode.com/problems/bold-words-in-string/*/

    string addBoldTag(string s, vector<string>& words) {
        int n = s.size();
        vector<int> line(n+1);
        for (auto& word : words)
            for (int k = -1; true; ) {
                k = s.find(word, ++k);
                if (k == string::npos) break;
                ++line[k];
                --line[k+word.size()];
            }
        string ans;
        for (int i = 0, prefix = 0; i < s.size(); ++i) {
            if (!prefix && prefix+line[i]) ans += "<b>";
            ans += s[i];
            prefix += line[i];
            if (prefix && !(prefix+line[i+1])) ans += "</b>";
        }
        return ans;
    }


    /*617. Merge Two Binary Trees (Easy)
    You are given two binary trees root1 and root2. Imagine that when you put
    one of them to cover the other, some nodes of the two trees are overlapped
    while the others are not. You need to merge the two trees into a new binary
    tree. The merge rule is that if two nodes overlap, then sum node values up
    as the new value of the merged node. Otherwise, the NOT null node will be
    used as the node of the new tree. Return the merged tree. Note: The merging
    process must start from the root nodes of both trees.

    Example 1:
    Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
    Output: [3,4,5,5,4,null,7]

    Example 2:
    Input: root1 = [1], root2 = [1,2]
    Output: [2,2]

    Constraints:
    * The number of nodes in both trees is in the range [0, 2000].
    * -10^4 <= Node.val <= 10^4*/

    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (!root1) return root2;
        if (!root2) return root1;
        return new TreeNode(root1->val+root2->val, mergeTrees(root1->left, root2->left), mergeTrees(root1->right, root2->right));
    }


    /*623. Add One Row to Tree (Medium)
    Given the root of a binary tree and two integers val and depth, add a row of
    nodes with value val at the given depth depth. Note that the root node is at
    depth 1. The adding rule is:
    * Given the integer depth, for each not null tree node cur at the depth
      depth - 1, create two tree nodes with value val as cur's left subtree root
      and right subtree root.
    * cur's original left subtree should be the left subtree of the new left
      subtree root.
    * cur's original right subtree should be the right subtree of the new right
      subtree root.
    * If depth == 1 that means there is no depth depth - 1 at all, then create a
      tree node with value val as the new root of the whole original tree, and
      the original tree is the new root's left subtree.

    Example 1:
    Input: root = [4,2,6,3,1,5], val = 1, depth = 2
    Output: [4,1,1,2,null,null,6,3,1,5]

    Example 2:
    Input: root = [4,2,null,3,1], val = 1, depth = 3
    Output: [4,2,null,1,1,3,null,null,1]

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * The depth of the tree is in the range [1, 10^4].
    * -100 <= Node.val <= 100
    * -10^5 <= val <= 10^5
    * 1 <= depth <= the depth of tree + 1*/

    TreeNode* addOneRow(TreeNode* root, int val, int depth) {
        if (depth == 1) return new TreeNode(val, root, nullptr);
        queue<TreeNode*> q;
        q.push(root);
        for (; q.size() && depth-1 > 1; --depth)
            for (int sz = q.size(); sz; --sz) {
                TreeNode* node = q.front(); q.pop();
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        while (q.size()) {
            TreeNode* node = q.front(); q.pop();
            node->left = new TreeNode(val, node->left, nullptr);
            node->right = new TreeNode(val, nullptr, node->right);
        }
        return root;
    }


    /*624. Maximum Distance in Arrays (Medium)
    You are given m arrays, where each array is sorted in ascending order. You
    can pick up two integers from two different arrays (each array picks one)
    and calculate the distance. We define the distance between two integers a
    and b to be their absolute difference |a - b|. Return the maximum distance.

    Example 1:
    Input: arrays = [[1,2,3],[4,5],[1,2,3]]
    Output: 4
    Explanation: One way to reach the maximum distance 4 is to pick 1 in the
                 first or third array and pick 5 in the second array.

    Example 2:
    Input: arrays = [[1],[1]]
    Output: 0

    Constraints:
    * m == arrays.length
    * 2 <= m <= 10^5
    * 1 <= arrays[i].length <= 500
    * -10^4 <= arrays[i][j] <= 10^4
    * arrays[i] is sorted in ascending order.
    * There will be at most 10^5 integers in all the arrays.*/

    int maxDistance(vector<vector<int>>& arrays) {
        int ans = 0, small = 1e5, large = -1e5;
        for (auto& array : arrays) {
            ans = max({ans, large-array[0], array.back()-small});
            small = min(small, array[0]);
            large = max(large, array.back());
        }
        return ans;
    }


    /*625. Minimum Factorization (Medium)
    Given a positive integer num, return the smallest positive integer x whose
    multiplication of each digit equals num. If there is no answer or the
    answer is not fit in 32-bit signed integer, return 0.

    Example 1:
    Input: num = 48
    Output: 68

    Example 2:
    Input: num = 15
    Output: 35

    Constraints: 1 <= num <= 2^31 - 1*/

    int smallestFactorization(int num) {
        if (num == 1) return 1; // edge case
        long ans = 0;
        for (long x = 9, mult = 1; x > 1; --x)
            for (; num % x == 0; num /= x, mult *= 10) {
                ans += mult * x;
                if (ans > INT_MAX) return 0;
            }
        return num == 1 ? ans : 0;
    }


    /*629. K Inverse Pairs Array (Hard)
    For an integer array nums, an inverse pair is a pair of integers [i, j]
    where 0 <= i < j < nums.length and nums[i] > nums[j]. Given two integers n
    and k, return the number of different arrays consist of numbers from 1 to n
    such that there are exactly k inverse pairs. Since the answer can be huge,
    return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, k = 0
    Output: 1
    Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3
                 has exactly 0 inverse pairs.

    Example 2:
    Input: n = 3, k = 1
    Output: 2
    Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.

    Constraints:
    * 1 <= n <= 1000
    * 0 <= k <= 1000*/

    int kInversePairs(int n, int k) {
        int const MOD = 1'000'000'007;
        vector<vector<int>> dp(n+1, vector<int>(k+1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            dp[i][0] = 1;
            for (int j = 1; j <= k; ++j) {
                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;
                if (i <= j) dp[i][j] = (dp[i][j] - dp[i-1][j-i] + MOD) % MOD;
            }
        }
        return dp.back().back();
    }


    /*630. Course Schedule III (Hard)
    There are n different online courses numbered from 1 to n. You are given an
    array courses where courses[i] = [durationi, lastDayi] indicate that the ith
    course should be taken continuously for durationi days and must be finished
    before or on lastDayi. You will start on the 1st day and you cannot take two
    or more courses simultaneously. Return the maximum number of courses that
    you can take.

    Example 1:
    Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]
    Output: 3
    Explanation: There are totally 4 courses, but you can take 3 courses at most:
                 - First, take the 1st course, it costs 100 days so you will
                   finish it on the 100th day, and ready to take the next course
                   on the 101st day.
                 - Second, take the 3rd course, it costs 1000 days so you will
                   finish it on the 1100th day, and ready to take the next
                   course on the 1101st day.
                 - Third, take the 2nd course, it costs 200 days so you will
                   finish it on the 1300th day.
                 - The 4th course cannot be taken now, since you will finish it
                   on the 3300th day, which exceeds the closed date.

    Example 2:
    Input: courses = [[1,2]]
    Output: 1

    Example 3:
    Input: courses = [[3,2],[4,3]]
    Output: 0

    Constraints:
    * 1 <= courses.length <= 10^4
    * 1 <= durationi, lastDayi <= 10^4*/

    int scheduleCourse(vector<vector<int>>& courses) {
        sort(courses.begin(), courses.end(), [](auto& lhs, auto& rhs) { return lhs[1] < rhs[1]; });

        int prefix = 0;
        priority_queue<int> pq;
        for (auto& course : courses) {
            prefix += course[0];
            pq.push(course[0]);
            if (prefix > course[1]) {
                prefix -= pq.top();
                pq.pop();
            }
        }
        return pq.size();
    }


    /*632. Smallest Range Covering Elements from K Lists (Hard)
    You have k lists of sorted integers in non-decreasing order. Find the
    smallest range that includes at least one number from each of the k lists.
    We define the range [a, b] is smaller than range [c, d] if b - a < d - c or
    a < c if b - a == d - c.

    Example 1:
    Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]
    Output: [20,24]
    Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
                 List 2: [0, 9, 12, 20], 20 is in range [20,24].
                 List 3: [5, 18, 22, 30], 22 is in range [20,24].

    Example 2:
    Input: nums = [[1,2,3],[1,2,3],[1,2,3]]
    Output: [1,1]

    Example 3:
    Input: nums = [[10,10],[11,11]]
    Output: [10,11]

    Example 4:
    Input: nums = [[10],[11]]
    Output: [10,11]

    Example 5:
    Input: nums = [[1],[2],[3],[4],[5],[6],[7]]
    Output: [1,7]

    Constraints:
    * nums.length == k
    * 1 <= k <= 3500
    * 1 <= nums[i].length <= 50
    * -10^5 <= nums[i][j] <= 10^5
    * nums[i] is sorted in non-decreasing order.*/

    vector<int> smallestRange(vector<vector<int>>& nums) {

        struct Compare {
            bool operator() (array<int,3>&lhs, array<int,3>&rhs) { return lhs[0] > rhs[0]; }
        };

        priority_queue<array<int,3>, vector<array<int,3>>, Compare> pq;
        int mx = INT_MIN, lo = -100'000, hi = 100'000;
        for (int i = 0; i < size(nums); ++i) {
            pq.push({nums[i][0], i, 0});
            mx = max(mx, nums[i][0]);
        }

        while (size(pq)) {
            if (mx - pq.top()[0] < hi - lo) {
                lo = pq.top()[0];
                hi = mx;
            }
            auto elem = pq.top(); pq.pop();
            int i = elem[1], j = elem[2];
            if (j+1 == size(nums[i])) break;
            mx = max(mx, nums[i][j+1]);
            pq.push({nums[i][j+1], i, j+1});
        }
        return {lo, hi};
    }


    /*633. Sum of Square Numbers (Medium)
    Given a non-negative integer c, decide whether there're two integers a and
    b such that a^2 + b^2 = c.

    Example 1:
    Input: c = 5
    Output: true
    Explanation: 1 * 1 + 2 * 2 = 5

    Example 2:
    Input: c = 3
    Output: false

    Example 3:
    Input: c = 4
    Output: true

    Example 4:
    Input: c = 2
    Output: true

    Example 5:
    Input: c = 1
    Output: true

    Constraints: 0 <= c <= 2^31 - 1*/

    bool judgeSquareSum(int c) {
        /*Fermat theorem on sum of two squares*/
        for (int x = 2; x*x <= c; ++x)
            if (c % x == 0) {
                int mult = 0;
                for (; c % x == 0; ++mult, c /= x);
                if (x % 4 == 3 && mult & 1) return false;
            }
        return c % 4 != 3;
    }


    /*634. Find the Derangement of An Array (Medium)
    In combinatorial mathematics, a derangement is a permutation of the
    elements of a set, such that no element appears in its original position.
    You are given an integer n. There is originally an array consisting of n
    integers from 1 to n in ascending order, return the number of derangements
    it can generate. Since the answer may be huge, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3
    Output: 2
    Explanation: The original array is [1,2,3]. The two derangements are
                 [2,3,1] and [3,1,2].

    Example 2:
    Input: n = 2
    Output: 1

    Constraints: 1 <= n <= 10^6*/

    int findDerangement(int n) {
        long f0 = 1, f1 = 0;
        for (int i = 2; i <= n; ++i) {
            long f2 = (i-1)*(f0 + f1) % 1'000'000'007;
            f0 = f1;
            f1 = f2;
        }
        return f1;
    }


    /*637. Average of Levels in Binary Tree (Easy)
    Given the root of a binary tree, return the average value of the nodes on
    each level in the form of an array. Answers within 10-5 of the actual
    answer will be accepted.

    Example 1:
    Input: root = [3,9,20,null,15,7]
    Output: [3.00000,14.50000,11.00000]
    Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5,
                 and on level 2 is 11. Hence return [3, 14.5, 11].

    Example 2:
    Input: root = [3,9,20,15,7]
    Output: [3.00000,14.50000,11.00000]

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -2^31 <= Node.val <= 2^31 - 1*/

    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ans;

        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            double sm = 0, cnt = 0;
            for (int i = 0, n = q.size(); i < n; ++i) {
                TreeNode* node = q.front();
                q.pop();
                if (node) {
                    sm += node->val;
                    ++cnt;
                    q.push(node->left);
                    q.push(node->right);
                }
            }
            if (cnt) ans.push_back(sm/cnt);
        }
        return ans;
    }


    /*639. Decode Ways II (Hard)
    A message containing letters from A-Z can be encoded into numbers using the
    following mapping:
    'A' -> "1"
    'B' -> "2"
    ...
    'Z' -> "26"
    To decode an encoded message, all the digits must be grouped then mapped
    back into letters using the reverse of the mapping above (there may be
    multiple ways). For example, "11106" can be mapped into:
    * "AAJF" with the grouping (1 1 10 6)
    * "KJF" with the grouping (11 10 6)
    Note that the grouping (1 11 06) is invalid because "06" cannot be mapped
    into 'F' since "6" is different from "06". In addition to the mapping above,
    an encoded message may contain the '*' character, which can represent any
    digit from '1' to '9' ('0' is excluded). For example, the encoded message
    "1*" may represent any of the encoded messages "11", "12", "13", "14", "15",
    "16", "17", "18", or "19". Decoding "1*" is equivalent to decoding any of
    the encoded messages it can represent. Given a string s consisting of
    digits and '*' characters, return the number of ways to decode it. Since
    the answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: s = "*"
    Output: 9
    Explanation: The encoded message can represent any of the encoded messages
                 "1", "2", "3", "4", "5", "6", "7", "8", or "9". Each of these
                 can be decoded to the strings "A", "B", "C", "D", "E", "F",
                 "G", "H", and "I" respectively. Hence, there are a total of 9
                 ways to decode "*".

    Example 2:
    Input: s = "1*"
    Output: 18
    Explanation: The encoded message can represent any of the encoded messages
                 "11", "12", "13", "14", "15", "16", "17", "18", or "19". Each
                 of these encoded messages have 2 ways to be decoded (e.g. "11"
                 can be decoded to "AA" or "K"). Hence, there are a total of
                 9 * 2 = 18 ways to decode "1*".

    Example 3:
    Input: s = "2*"
    Output: 15
    Explanation: The encoded message can represent any of the encoded messages
                 "21", "22", "23", "24", "25", "26", "27", "28", or "29". "21",
                 "22", "23", "24", "25", and "26" have 2 ways of being decoded,
                 but "27", "28", and "29" only have 1 way. Hence, there are a
                 total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode "2*".

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is a digit or '*'.*/

    int numDecodings(string s) {
        if (s[0] == '0') return 0; // edge case
        int n = s.size();
        vector<long> dp(n+1);
        dp[0] = dp[1] = 1;
        if (s[0] == '*') dp[1] = 9;

        for (int i = 2; i <= n; ++i) {
            if (s[i-1] == '*') {
                dp[i] = 9*dp[i-1];
                if (s[i-2] == '1') dp[i] += 9*dp[i-2];
                else if (s[i-2] == '2') dp[i] += 6*dp[i-2];
                else if (s[i-2] == '*') dp[i] += 15*dp[i-2];
            } else if (s[i-1] == '0') {
                if (s[i-2] == '1' || s[i-2] == '2') dp[i] += dp[i-2];
                else if (s[i-2] == '*') dp[i] += 2*dp[i-2];
            } else {
                dp[i] = dp[i-1];
                if (s[i-2] == '1') dp[i] += dp[i-2];
                else if (s[i-2] == '2' and s[i-1] <= '6') dp[i] += dp[i-2];
                else if (s[i-2] == '*') {
                    dp[i] += dp[i-2];
                    if (s[i-1] <= '6') dp[i] += dp[i-2];
                }
            }
            dp[i] %= 1'000'000'007;
        }
        return dp.back();
    }


    /*643. Maximum Average Subarray I (Easy)
    Given an array consisting of n integers, find the contiguous subarray of
    given length k that has the maximum average value. And you need to output
    the maximum average value.

    Example 1:
    Input: [1,12,-5,-6,50,3], k = 4
    Output: 12.75
    Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75

    Note:
    * 1 <= k <= n <= 30,000.
    * Elements of the given array will be in the range [-10,000, 10,000].*/

    double findMaxAverage(vector<int>& nums, int k) {
        int ans = INT_MIN, sm = 0;
        for (int i = 0; i < nums.size(); ++i) {
            sm += nums[i];
            if (i >= k) sm -= nums[i-k];
            if (i >= k-1) ans = max(ans, sm);
        }
        return (double) ans/k;
    }


    /*644. Maximum Average Subarray II (Hard)
    You are given an integer array nums consisting of n elements, and an
    integer k. Find a contiguous subarray whose length is greater than or equal
    to k that has the maximum average value and return this value. Any answer
    with a calculation error less than 10-5 will be accepted.

    Example 1:
    Input: nums = [1,12,-5,-6,50,3], k = 4
    Output: 12.75000
    Explanation: - When the length is 4, averages are [0.5, 12.75, 10.5] and
                   the maximum average is 12.75
                 - When the length is 5, averages are [10.4, 10.8] and the
                   maximum average is 10.8
                 - When the length is 6, averages are [9.16667] and the maximum
                   average is 9.16667
                 The maximum average is when we choose a subarray of length 4
                 (i.e., the sub array [12, -5, -6, 50]) which has the max
                 average 12.75, so we return 12.75. Note that we do not
                 consider the subarrays of length < 4.

    Example 2:
    Input: nums = [5], k = 1
    Output: 5.00000

    Constraints:
    * n == nums.length
    * 1 <= k <= n <= 10^4
    * -10^4 <= nums[i] <= 10^4*/

    double findMaxAverage(vector<int>& nums, int k) {
        double lo = -1e4, hi = 1e4;
        while (lo + 1e-5 <= hi) {
            double mid = (lo + hi)/2, lag = 0, prefix = 0;
            bool found = false;
            for (int i = 0; i < nums.size(); ++i) {
                prefix += nums[i] - mid;
                if (i >= k) lag += nums[i-k] - mid;
                if (lag < 0) {
                    prefix -= lag;
                    lag = 0;
                }
                if (i >= k-1 && prefix >= 0) {
                    found = true;
                    break;
                }
            }
            if (found) lo = mid;
            else hi = mid;
        }
        return lo;
    }


    /*648. Replace Words (Medium)
    In English, we have a concept called root, which can be followed by some
    other word to form another longer word - let's call this word derivative.
    For example, when the root "help" is followed by the word "ful", we can form
    a derivative "helpful". Given a dictionary consisting of many roots and a
    sentence consisting of words separated by spaces, replace all the
    derivatives in the sentence with the root forming it. If a derivative can be
    replaced by more than one root, replace it with the root that has the
    shortest length. Return the sentence after the replacement.

    Example 1:
    Input: dictionary = ["cat","bat","rat"],
           sentence = "the cattle was rattled by the battery"
    Output: "the cat was rat by the bat"

    Example 2:
    Input: dictionary = ["a","b","c"],
           sentence = "aadsfasf absbs bbab cadsfafs"
    Output: "a a b c"

    Constraints:
    * 1 <= dictionary.length <= 1000
    * 1 <= dictionary[i].length <= 100
    * dictionary[i] consists of only lower-case letters.
    * 1 <= sentence.length <= 106
    * sentence consists of only lower-case letters and spaces.
    * The number of words in sentence is in the range [1, 1000]
    * The length of each word in sentence is in the range [1, 1000]
    * Every two consecutive words in sentence will be separated by exactly one
      space.
    * sentence does not have leading or trailing spaces.

    class TrieNode {
    public:
        TrieNode* next[26] = {nullptr};
        string word = "";
    };*/

    string replaceWords(vector<string>& dictionary, string sentence) {
        TrieNode *trie = new TrieNode();
        for (auto& word : dictionary) {
            TrieNode *node = trie;
            for (auto& ch : word) {
                if (!node->next[ch-'a'])
                    node->next[ch-'a'] = new TrieNode();
                node = node->next[ch-'a'];
            }
            node->word = word;
        }
        string ans;
        istringstream iss(sentence);
        string word;
        while (iss >> word) {
            TrieNode *node = trie;
            for (auto& ch : word) {
                node = node->next[ch-'a'];
                if (!node || node->word.size()) {
                    if (node) word = node->word;
                    break;
                }
            }
            if (ans.size()) ans += " ";
            ans += word;
        }
        return ans;
    }


    /*650. 2 Keys Keyboard (Medium)
    There is only one character 'A' on the screen of a notepad. You can perform
    one of two operations on this notepad for each step:
    * Copy All: You can copy all the characters present on the screen (a partial
      copy is not allowed).
    * Paste: You can paste the characters which are copied last time.
    Given an integer n, return the minimum number of operations to get the
    character 'A' exactly n times on the screen.

    Example 1:
    Input: n = 3
    Output: 3
    Explanation: Initially, we have one character 'A'.
                 - In step 1, we use Copy All operation.
                 - In step 2, we use Paste operation to get 'AA'.
                 - In step 3, we use Paste operation to get 'AAA'.

    Example 2:
    Input: n = 1
    Output: 0

    Constraints: 1 <= n <= 1000*/

    int minSteps(int n) {
        vector<int> dp(n+1);
        iota(dp.begin(), dp.end(), 0);
        dp[1] = 0;
        for (int x = 2; x <= n; ++x)
            for (int p = 2; p <= sqrt(x); ++p)
                if (x % p == 0)
                    dp[x] = min(dp[x], dp[x/p] + p);
        return dp[n];
    }


    /*651. 4 Keys Keyboard (Medium)
    Imagine you have a special keyboard with the following keys:
    * A: Print one 'A' on the screen.
    * Ctrl-A: Select the whole screen.
    * Ctrl-C: Copy selection to buffer.
    * Ctrl-V: Print buffer on screen appending it after what has already been
      printed.
    Given an integer n, return the maximum number of 'A' you can print on the
    screen with at most n presses on the keys.

    Example 1:
    Input: n = 3
    Output: 3
    Explanation: We can at most get 3 A's on screen by pressing the following
                 key sequence: A, A, A

    Example 2:
    Input: n = 7
    Output: 9
    Explanation: We can at most get 9 A's on screen by pressing following key
                 sequence: A, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V

    Constraints: 1 <= n <= 50*/

    int maxA(int n) {
        vector<int> dp = {0, 1};
        for (int i = 2; i <= n; ++i) {
            dp.push_back(dp[i-1] + 1);
            for (int ii = 0; ii < i-1; ++ii)
                dp[i] = max(dp[i], dp[ii]*(i-ii-1));
        }
        return dp[n];
    }


    /*653. Two Sum IV - Input is a BST (Easy)
    Given the root of a Binary Search Tree and a target number k, return true
    if there exist two elements in the BST such that their sum is equal to the
    given target.

    Example 1:
    Input: root = [5,3,6,2,4,null,7], k = 9
    Output: true

    Example 2:
    Input: root = [5,3,6,2,4,null,7], k = 28
    Output: false

    Example 3:
    Input: root = [2,1,3], k = 4
    Output: true

    Example 4:
    Input: root = [2,1,3], k = 1
    Output: false

    Example 5:
    Input: root = [2,1,3], k = 3
    Output: true

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -10^4 <= Node.val <= 10^4
    * root is guaranteed to be a valid binary search tree.
    * -10^5 <= k <= 10^5*/

    bool findTarget(TreeNode* root, int k) {
        stack<TreeNode*> left, right;
        for (TreeNode *lo = root; lo; lo = lo->left) left.push(lo);
        for (TreeNode *hi = root; hi; hi = hi->right) right.push(hi);

        TreeNode *lo = left.top(); left.pop();
        TreeNode *hi = right.top(); right.pop();
        while (lo->val < hi->val)
            if (lo->val + hi->val < k) {
                for (lo = lo->right; lo; lo = lo->left) left.push(lo);
                lo = left.top(); left.pop();
            } else if (lo->val + hi->val == k) return true;
            else {
                for (hi = hi->left; hi; hi = hi->right) right.push(hi);
                hi = right.top(); right.pop();
            }
        return false;
    }


    /*656. Coin Path (Hard)
    You are given an integer array coins (1-indexed) of length n and an integer
    maxJump. You can jump to any index i of the array coins if coins[i] != -1
    and you have to pay coins[i] when you visit index i. In addition to that,
    if you are currently at index i, you can only jump to any index i + k where
    i + k <= n and k is a value in the range [1, maxJump]. You are initially
    positioned at index 1 (coins[1] is not -1). You want to find the path that
    reaches index n with the minimum cost. Return an integer array of the
    indices that you will visit in order so that you can reach index n with the
    minimum cost. If there are multiple paths with the same cost, return the
    lexicographically smallest such path. If it is not possible to reach index
    n, return an empty array. A path p1 = [Pa1, Pa2, ..., Pax] of length x is
    lexicographically smaller than p2 = [Pb1, Pb2, ..., Pbx] of length y, if
    and only if at the first j where Paj and Pbj differ, Paj < Pbj; when no
    such j exists, then x < y.

    Example 1:
    Input: coins = [1,2,4,-1,2], maxJump = 2
    Output: [1,3,5]

    Example 2:
    Input: coins = [1,2,4,-1,2], maxJump = 1
    Output: []

    Constraints:
    * 1 <= coins.length <= 1000
    * -1 <= coins[i] <= 100
    * coins[1] != -1
    * 1 <= maxJump <= 100*/

    vector<int> cheapestJump(vector<int>& coins, int maxJump) {
        int n = coins.size();
        vector<int> dp(n, -1);
        if (coins[n-1] != -1) dp[n-1] = coins[n-1];
        vector<int> jump(n, -1);
        for (int i = n-2; i >= 0; --i)
            if (coins[i] != -1)
                for (int ii = min(n-1, i+maxJump); ii > i; --ii)
                    if (dp[ii] != -1) {
                        int cand = coins[i] + dp[ii];
                        if (dp[i] == -1 || cand <= dp[i]) {
                            dp[i] = cand;
                            jump[i] = ii;
                        }
                    }
        vector<int> ans;
        if (dp[0] != -1)
            for (int i = 0; i >= 0; i = jump[i])
                ans.push_back(i+1);
        return ans;
    }


    /*658. Find K Closest Elements (Medium)
    Given a sorted integer array arr, two integers k and x, return the k
    closest integers to x in the array. The result should also be sorted in
    ascending order. An integer a is closer to x than an integer b if:
    * |a - x| < |b - x|, or
    * |a - x| == |b - x| and a < b

    Example 1:
    Input: arr = [1,2,3,4,5], k = 4, x = 3
    Output: [1,2,3,4]

    Example 2:
    Input: arr = [1,2,3,4,5], k = 4, x = -1
    Output: [1,2,3,4]

    Constraints:
    * 1 <= k <= arr.length
    * 1 <= arr.length <= 10^4
    * arr is sorted in ascending order.
    * -10^4 <= arr[i], x <= 10^4*/

    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        int hi = lower_bound(arr.begin(), arr.end(), x) - arr.begin(), lo = hi - 1;
        deque<int> ans;
        while (k--) {
            if (arr.size() <= hi or 0 <= lo and x - arr[lo] <= arr[hi] - x)
                ans.push_front(arr[lo--]);
            else
                ans.push_back(arr[hi++]);
        }
        return vector<int>(ans.begin(), ans.end());
    }


    /*660. Remove 9 (Hard)
    Start from integer 1, remove any integer that contains 9 such as 9, 19, 29...
    Now, you will have a new integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...].
    Given an integer n, return the nth (1-indexed) integer in the new sequence.

    Example 1:
    Input: n = 9
    Output: 10

    Example 2:
    Input: n = 10
    Output: 11

    Constraints: 1 <= n <= 8 * 10^8*/

    int newInteger(int n) {
        int ans = 0;
        for (long base = 1; n; base *= 10) {
            ans = n%9 * base + ans;
            n /= 9;
        }
        return ans;
    }


    /*662. Maximum Width of Binary Tree (Medium)
    Given the root of a binary tree, return the maximum width of the given
    tree. The maximum width of a tree is the maximum width among all levels.
    The width of one level is defined as the length between the end-nodes (the
    leftmost and rightmost non-null nodes), where the null nodes between the
    end-nodes are also counted into the length calculation. It is guaranteed
    that the answer will in the range of 32-bit signed integer.

    Example 1:
    Input: root = [1,3,2,5,3,null,9]
    Output: 4
    Explanation: The maximum width existing in the third level with the length
                 4 (5,3,null,9).

    Example 2:
    Input: root = [1,3,null,5,3]
    Output: 2
    Explanation: The maximum width existing in the third level with the length
                 2 (5,3).

    Example 3:
    Input: root = [1,3,2,5]
    Output: 2
    Explanation: The maximum width existing in the second level with the length
                 2 (3,2).

    Constraints:
    * The number of nodes in the tree is in the range [1, 3000].
    * -100 <= Node.val <= 100*/

    int widthOfBinaryTree(TreeNode* root) {
        long ans = 0;
        queue<pair<TreeNode*, long>> q; q.emplace(root, 0);
        while (q.size()) {
            ans = max(ans, q.back().second - q.front().second + 1);
            int offset = q.front().second;
            for (int sz = q.size(); sz; --sz) {
                auto [node, x] = q.front(); q.pop();
                x -= offset;
                if (node->left) q.emplace(node->left, 2*x);
                if (node->right) q.emplace(node->right, 2*x+1);
            }
        }
        return ans;
    }


    /*663. Equal Tree Partition (Medium)
    Given the root of a binary tree, return true if you can partition the tree
    into two trees with equal sums of values after removing exactly one edge on
    the original tree.

    Example 1:
    Input: root = [5,10,10,null,null,2,3]
    Output: true

    Example 2:
    Input: root = [1,2,10,null,null,2,20]
    Output: false
    Explanation: You cannot split the tree into two trees with equal sums after
                 removing exactly one edge on the tree.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -10^5 <= Node.val <= 10^5*/

    bool checkEqualTree(TreeNode* root) {
        unordered_map<int, int> freq;

        function<int(TreeNode*)> fn = [&](TreeNode* node) {
            if (!node) return 0;
            int ans = node->val + fn(node->left) + fn(node->right);
            freq[ans]++;
            return ans;
        };

        int total = fn(root);
        return (total == 0 && freq[total]>1) || (total && total % 2 == 0 && freq[total/2]);
    }


    /*664. Strange Printer (Hard)
    There is a strange printer with the following two special properties:
    * The printer can only print a sequence of the same character each time.
    * At each turn, the printer can print new characters starting from and
      ending at any place and will cover the original existing characters.
    Given a string s, return the minimum number of turns the printer needed to
    print it.

    Example 1:
    Input: s = "aaabbb"
    Output: 2
    Explanation: Print "aaa" first and then print "bbb".

    Example 2:
    Input: s = "aba"
    Output: 2
    Explanation: Print "aaa" first and then print "b" from the second place of
                 the string, which will cover the existing character 'a'.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters.*/

    int strangePrinter(string s) {
        int n = s.size();
        vector<vector<int>> dp(n+1, vector<int>(n+1, INT_MAX));
        dp[n] = vector<int>(n+1, 0);
        for (int i = n-1; i >= 0; --i) {
            dp[i][i] = 0;
            for (int j = i+1; j <= n; ++j) {
                dp[i][j] = 1 + dp[i+1][j];
                for (int k = i+1; k < j; ++k)
                    if (s[i] == s[k])
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]);
            }
        }
        return dp[0][n];
    }


    /*665. Non-decreasing Array (Medium)
    Given an array nums with n integers, your task is to check if it could
    become non-decreasing by modifying at most one element. We define an array
    is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based)
    such that (0 <= i <= n - 2).

    Example 1:
    Input: nums = [4,2,3]
    Output: true
    Explanation: You could modify the first 4 to 1 to get a non-decreasing array.

    Example 2:
    Input: nums = [4,2,1]
    Output: false
    Explanation: You can't get a non-decreasing array by modify at most one element.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^4
    * -10^5 <= nums[i] <= 10^5*/

    bool checkPossibility(vector<int>& nums) {
        int cnt = 0;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i-1] > nums[i]) {
                if ((i==1 || nums[i-2] <= nums[i]) || (i+1 == nums.size() || nums[i-1] <= nums[i+1]))
                    ++cnt;
                else
                    return false;
            }
        }
        return cnt <= 1;
    }


    /*666. Path Sum IV (Medium)
    If the depth of a tree is smaller than 5, then this tree can be represented
    by an array of three-digit integers. For each integer in this array:
    * The hundreds digit represents the depth d of this node where 1 <= d <= 4.
    * The tens digit represents the position p of this node in the level it
      belongs to where 1 <= p <= 8. The position is the same as that in a full
      binary tree.
    * The units digit represents the value v of this node where 0 <= v <= 9.
    Given an array of ascending three-digit integers nums representing a binary
    tree with a depth smaller than 5, return the sum of all paths from the root
    towards the leaves. It is guaranteed that the given array represents a
    valid connected binary tree.

    Example 1:
    Input: nums = [113,215,221]
    Output: 12
    Explanation: The tree that the list represents is shown. The path sum is
                 (3 + 5) + (3 + 1) = 12.

    Example 2:
    Input: nums = [113,221]
    Output: 4
    Explanation: The tree that the list represents is shown. The path sum is
                 (3 + 1) = 4.

    Constraints:
    * 1 <= nums.length <= 15
    * 110 <= nums[i] <= 489
    * nums represents a valid binary tree with depth less than 5.*/

    int pathSum(vector<int>& nums) {
        map<int, int> tree;
        for (auto& num : nums) {
            int k = num/10, v = num%10;
            tree[k] = v;
        }

        int ans = 0;
        stack<pair<int, int>> stk;
        stk.emplace(11, 0);
        while (stk.size()) {
            auto [k, v] = stk.top(); stk.pop();
            v += tree[k];
            int ll = (k/10+1)*10 + k%10*2 - 1, rr = ll+1;
            if (!tree.count(ll) && !tree.count(rr)) ans += v;
            if (tree.count(ll)) stk.emplace(ll, v);
            if (tree.count(rr)) stk.emplace(rr, v);
        }
        return ans;
    }


    /*668. Kth Smallest Number in Multiplication Table (Hard)
    Nearly everyone has used the Multiplication Table. The multiplication table
    of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed).
    Given three integers m, n, and k, return the kth smallest element in the
    m x n multiplication table.

    Example 1:
    Input: m = 3, n = 3, k = 5
    Output: 3
    Explanation: The 5th smallest number is 3.

    Example 2:
    Input: m = 2, n = 3, k = 6
    Output: 6
    Explanation: The 6th smallest number is 6.

    Constraints:
    * 1 <= m, n <= 3 * 10^4
    * 1 <= k <= m * n*/

    int findKthNumber(int m, int n, int k) {
        int lo = 1, hi = m*n;
        while (lo < hi) {
            int mid = lo + hi >> 1, cnt = 0;
            for (int i = 0; i < m; ++i) cnt += min(n, mid/(i+1));
            if (cnt < k) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*675. Cut Off Trees for Golf Event (Hard)
    You are asked to cut off all the trees in a forest for a golf event. The
    forest is represented as an m x n matrix. In this matrix:
    * 0 means the cell cannot be walked through.
    * 1 represents an empty cell that can be walked through.
    * A number greater than 1 represents a tree in a cell that can be walked
      through, and this number is the tree's height.
    In one step, you can walk in any of the four directions: north, east, south,
    and west. If you are standing in a cell with a tree, you can choose whether
    to cut it off. You must cut off the trees in order from shortest to tallest.
    When you cut off a tree, the value at its cell becomes 1 (an empty cell).
    Starting from the point (0, 0), return the minimum steps you need to walk
    to cut off all the trees. If you cannot cut off all the trees, return -1.
    You are guaranteed that no two trees have the same height, and there is at
    least one tree needs to be cut off.

    Example 1:
    Input: forest = [[1,2,3],[0,0,4],[7,6,5]]
    Output: 6
    Explanation: Following the path above allows you to cut off the trees from
                 shortest to tallest in 6 steps.

    Example 2:
    Input: forest = [[1,2,3],[0,0,0],[7,6,5]]
    Output: -1
    Explanation: The trees in the bottom row cannot be accessed as the middle
                 row is blocked.

    Example 3:
    Input: forest = [[2,3,4],[0,0,5],[8,7,6]]
    Output: 6
    Explanation: You can follow the same path as Example 1 to cut off all the
                 trees. Note that you can cut off the first tree at (0, 0)
                 before making any steps.

    Constraints:
    * m == forest.length
    * n == forest[i].length
    * 1 <= m, n <= 50
    * 0 <= forest[i][j] <= 10^9*/

    int cutOffTree(vector<vector<int>>& forest) {
        int m = forest.size(), n = forest[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        bool seen[m][n];

        auto fn = [&](pair<int, int>& start, pair<int, int>& end) {
            int ans = 0;
            memset(seen, false, sizeof(seen));
            seen[start.first][start.second] = true;
            queue<pair<int, int>> q; q.push(start);
            for (; q.size(); ++ans)
                for (int sz = q.size(); sz; --sz) {
                    auto [i, j] = q.front(); q.pop();
                    if (i == end.first && j == end.second) return ans;
                    for (int k = 0; k < 4; ++k) {
                        int ii = i + dir[k], jj = j + dir[k+1];
                        if (0 <= ii && ii < m && 0 <= jj && jj < n && forest[ii][jj] != 0 && !seen[ii][jj]) {
                            seen[ii][jj] = true;
                            q.emplace(ii, jj);
                        }
                    }
                }
            return -1;
        };

        vector<tuple<int, int, int>> vals;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (forest[i][j] > 1) vals.emplace_back(forest[i][j], i, j);
        sort(vals.begin(), vals.end());

        int ans = 0;
        pair<int, int> start = {0, 0};
        for (auto& [v, i, j] : vals) {
            pair<int, int> end = {i, j};
            int val = fn(start, end);
            if (val == -1) return -1;
            ans += val;
            start = end;
        }
        return ans;
    }


    /*678. Valid Parenthesis String (Medium)
    Given a string s containing only three types of characters: '(', ')' and
    '*', return true if s is valid. The following rules define a valid string:
    * Any left parenthesis '(' must have a corresponding right parenthesis ')'.
    * Any right parenthesis ')' must have a corresponding left parenthesis '('.
    * Left parenthesis '(' must go before the corresponding right parenthesis
      ')'.
    * '*' could be treated as a single right parenthesis ')' or a single left
      parenthesis '(' or an empty string "".

    Example 1:
    Input: s = "()"
    Output: true

    Example 2:
    Input: s = "(*)"
    Output: true

    Example 3:
    Input: s = "(*))"
    Output: true

    Constraints:
    * 1 <= s.length <= 100
    * s[i] is '(', ')' or '*'.*/

    bool checkValidString(string s) {
        int lower = 0, upper = 0;
        for (auto& ch : s) {
            if (ch == '(') ++lower;
            else if (lower) --lower;
            if (ch == '(' || ch == '*') ++upper;
            else --upper;
            if (upper < 0) return false;
        }
        return lower == 0;
    }


    /*679. 24 Game (Hard)
    You are given an integer array cards of length 4. You have four cards, each
    containing a number in the range [1, 9]. You should arrange the numbers on
    these cards in a mathematical expression using the operators
    ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.
    You are restricted with the following rules:
    * The division operator '/' represents real division, not integer division.
      + For example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.
    * Every operation done is between two numbers. In particular, we cannot use
      '-' as a unary operator.
      + For example, if cards = [1, 1, 1, 1], the expression "-1 - 1 - 1 - 1"
        is not allowed.
    * You cannot concatenate numbers together
      + For example, if cards = [1, 2, 1, 2], the expression "12 + 12" is not
        valid.
    Return true if you can get such expression that evaluates to 24, and false
    otherwise.

    Example 1:
    Input: cards = [4,1,8,7]
    Output: true
    Explanation: (8-4) * (7-1) = 24

    Example 2:
    Input: cards = [1,2,1,2]
    Output: false

    Constraints:
    * cards.length == 4
    * 1 <= cards[i] <= 9*/

    bool judgePoint24(vector<int>& cards) {

        function<bool(vector<double>&)> fn = [&] (vector<double>& nums) {
            if (nums.size() == 1) return abs(nums[0] - 24) < 1e-6;
            for (int i = 0; i < nums.size(); ++i) {
                for (int j = i+1; j < nums.size(); ++j) {
                    vector<double> cand;
                    for (int k = 0; k < nums.size(); ++k)
                        if (k != i && k != j) cand.push_back(nums[k]);
                    vector<double> vals = {nums[i]+nums[j], nums[i]-nums[j], nums[j]-nums[i], nums[i]*nums[j]};
                    if (nums[j]) vals.push_back(nums[i]/nums[j]);
                    if (nums[i]) vals.push_back(nums[j]/nums[i]);
                    for (auto& x : vals) {
                        cand.push_back(x);
                        if (fn(cand)) return true;
                        cand.pop_back();
                    }
                }
            }
            return false;
        };

        vector<double> nums(cards.begin(), cards.end());
        return fn(nums);

    }


    /*680. Valid Palindrome II (Easy)
    Given a non-empty string s, you may delete at most one character. Judge
    whether you can make it a palindrome.

    Example 1:
    Input: "aba"
    Output: True

    Example 2:
    Input: "abca"
    Output: True
    Explanation: You could delete the character 'c'.

    Note: The string will only contain lowercase characters a-z. The maximum
    length of the string is 50000.*/

    bool validPalindrome(string s) {
        for (int i = 0, n = s.size(); i < n/2; ++i)
            if (s[i] != s[n-i-1]) {
                for (int lo = i+1, hi = n-i-1; s[lo] == s[hi]; ++lo, --hi)
                    if (lo >= hi) return true;
                for (int lo = i, hi = n-i-2; s[lo] == s[hi]; ++lo, --hi)
                    if (lo >= hi) return true;
                return false;
            }
        return true;
    }


    /*681. Next Closest Time (Medium)
    Given a time represented in the format "HH:MM", form the next closest time
    by reusing the current digits. There is no limit on how many times a digit
    can be reused. You may assume the given input string is always valid. For
    example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.

    Example 1:
    Input: time = "19:34"
    Output: "19:39"
    Explanation: The next closest time choosing from digits 1, 9, 3, 4, is
                 19:39, which occurs 5 minutes later. It is not 19:33, because
                 this occurs 23 hours and 59 minutes later.

    Example 2:
    Input: time = "23:59"
    Output: "22:22"
    Explanation: The next closest time choosing from digits 2, 3, 5, 9, is
                 22:22. It may be assumed that the returned time is next day's
                 time since it is smaller than the input time numerically.

    Constraints:
    * time.length == 5
    * time is a valid time in the form "HH:MM".
    * 0 <= HH < 24
    * 0 <= MM < 60*/

    string nextClosestTime(string time) {
        vector<char> digit = {time[0], time[1], time[3], time[4]};
        sort(digit.begin(), digit.end());

        vector<char> upper = {'2', '9', '0', '5', '9'};
        if (time[0] == '2') upper[1] = '3';

        string suffix;
        for (int i = 4; i >= 0; --i)
            if (i == 2) suffix = ":" + suffix;
            else {
                auto k = find(digit.begin(), digit.end(), time[i]);
                for (auto it = next(k); it != digit.end(); ++it)
                    if (time[i] < *it && *it <= upper[i]) return time.substr(0, i) + *it + suffix;
                suffix = digit[0] + suffix;
            }
        return suffix;
    }


    /*682. Baseball Game (Easy)
    You are keeping score for a baseball game with strange rules. The game
    consists of several rounds, where the scores of past rounds may affect
    future rounds' scores. At the beginning of the game, you start with an
    empty record. You are given a list of strings ops, where ops[i] is the
    ith operation you must apply to the record and is one of the following:
    * An integer x - Record a new score of x.
    * "+" - Record a new score that is the sum of the previous two scores. It
      is guaranteed there will always be two previous scores.
    * "D" - Record a new score that is double the previous score. It is
      guaranteed there will always be a previous score.
    * "C" - Invalidate the previous score, removing it from the record. It is
      guaranteed there will always be a previous score.
    Return the sum of all the scores on the record.

    Example 1:
    Input: ops = ["5","2","C","D","+"]
    Output: 30
    Explanation:
    "5" - Add 5 to the record, record is now [5].
    "2" - Add 2 to the record, record is now [5, 2].
    "C" - Invalidate and remove the previous score, record is now [5].
    "D" - Add 2 * 5 = 10 to the record, record is now [5, 10].
    "+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].
    The total sum is 5 + 10 + 15 = 30.

    Example 2:
    Input: ops = ["5","-2","4","C","D","9","+","+"]
    Output: 27
    Explanation:
    "5" - Add 5 to the record, record is now [5].
    "-2" - Add -2 to the record, record is now [5, -2].
    "4" - Add 4 to the record, record is now [5, -2, 4].
    "C" - Invalidate and remove the previous score, record is now [5, -2].
    "D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].
    "9" - Add 9 to the record, record is now [5, -2, -4, 9].
    "+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].
    "+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].
    The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.

    Example 3:
    Input: ops = ["1"]
    Output: 1

    Constraints:
    * 1 <= ops.length <= 1000
    * ops[i] is "C", "D", "+", or a string representing an integer in the range [-3 * 10^4, 3 * 10^4].
    * For operation "+", there will always be at least two previous scores on the record.
    * For operations "C" and "D", there will always be at least one previous score on the record.*/

    int calPoints(vector<string>& ops) {
        vector<int> vec;
        for (auto& op : ops) {
            if (op == "+") {
                vec.push_back(vec[vec.size()-2] + vec[vec.size()-1]);
            } else if (op == "D") {
                vec.push_back(vec.back() * 2);
            } else if (op == "C") {
                vec.pop_back();
            } else {
                vec.push_back(stoi(op));
            }
        }
        return accumulate(vec.begin(), vec.end(), 0);
    }


    /*683. K Empty Slots (Hard)
    You have n bulbs in a row numbered from 1 to n. Initially, all the bulbs
    are turned off. We turn on exactly one bulb every day until all bulbs are
    on after n days. You are given an array bulbs of length n where
    bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at
    position x where i is 0-indexed and x is 1-indexed. Given an integer k,
    return the minimum day number such that there exists two turned on bulbs
    that have exactly k bulbs between them that are all turned off. If there
    isn't such day, return -1.

    Example 1:
    Input: bulbs = [1,3,2], k = 1
    Output: 2
    Explanation: - On the first day: bulbs[0] = 1, first bulb is turned on:
                   [1,0,0]
                 - On the second day: bulbs[1] = 3, third bulb is turned on:
                   [1,0,1]
                 - On the third day: bulbs[2] = 2, second bulb is turned on:
                   [1,1,1]
                 We return 2 because on the second day, there were two on
                 bulbs with one off bulb between them.

    Example 2:
    Input: bulbs = [1,2,3], k = 1
    Output: -1

    Constraints:
    * n == bulbs.length
    * 1 <= n <= 2 * 10^4
    * 1 <= bulbs[i] <= n
    * bulbs is a permutation of numbers from 1 to n.
    * 0 <= k <= 2 * 10^4*/

    int kEmptySlots(vector<int>& bulbs, int k) {
        int n = bulbs.size(), ans = INT_MAX;
        vector<int> days(n);
        for (int i = 0; i < n; ++i) days[bulbs[i]-1] = i+1;
        for (int i = 0, lo = 0, hi = k+1; hi < n; ++i)
            if (days[lo] > days[i] || days[i] < days[hi] || i == hi) {
                if (i == hi) ans = min(ans, max(days[lo], days[hi]));
                lo = i;
                hi = i+k+1;
            }
        return ans == INT_MAX ? -1 : ans;
    }


    /*684. Redundant Connection (Medium)
    In this problem, a tree is an undirected graph that is connected and has no
    cycles. You are given a graph that started as a tree with n nodes labeled from
    1 to n, with one additional edge added. The added edge has two different
    vertices chosen from 1 to n, and was not an edge that already existed. The
    graph is represented as an array edges of length n where edges[i] = [ai, bi]
    indicates that there is an edge between nodes ai and bi in the graph. Return an
    edge that can be removed so that the resulting graph is a tree of n nodes. If
    there are multiple answers, return the answer that occurs last in the input.

    Example 1:
    Input: edges = [[1,2],[1,3],[2,3]]
    Output: [2,3]

    Example 2:
    Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
    Output: [1,4]

    Constraints:
    * n == edges.length
    * 3 <= n <= 1000
    * edges[i].length == 2
    * 1 <= ai < bi <= edges.length
    * ai != bi
    * There are no repeated edges.
    * The given graph is connected.*/

    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        UnionFind *uf = new UnionFind(size(edges));
        for (auto& edge : edges)
            if (!uf->connect(edge[0]-1, edge[1]-1)) {
                delete uf;
                return edge;
            }
        delete uf;
        return {};
    }


    /*685. Redundant Connection II (Hard)
    In this problem, a rooted tree is a directed graph such that, there is
    exactly one node (the root) for which all other nodes are descendants of
    this node, plus every node has exactly one parent, except for the root node
    which has no parents. The given input is a directed graph that started as a
    rooted tree with n nodes (with distinct values from 1 to n), with one
    additional directed edge added. The added edge has two different vertices
    chosen from 1 to n, and was not an edge that already existed.  resulting
    graph is given as a 2D-array of edges. Each element of edges is a pair
    [ui, vi] that represents a directed edge connecting nodes ui and vi, where
    ui is a parent of child vi. Return an edge that can be removed so that the
    resulting graph is a rooted tree of n nodes. If there are multiple answers,
    return the answer that occurs last in the given 2D-array.

    Example 1:
    Input: edges = [[1,2],[1,3],[2,3]]
    Output: [2,3]

    Example 2:
    Input: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
    Output: [4,1]

    Constraints:
    * n == edges.length
    * 3 <= n <= 1000
    * edges[i].length == 2
    * 1 <= ui, vi <= n
    * ui != vi*/

    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        vector<int> parent(n, 0), cand0, cand1, cand2;
        bool mult = false, cycle = false;
        UnionFind *uf = new UnionFind(n);

        for (auto& edge : edges) {
            int u = edge[0], v = edge[1];
            if (parent[v-1]) {
                mult = true;
                cand0 = {parent[v-1], v};
                cand1 = {u, v};
            } else {
                parent[v-1] = u;
                if (!uf->connect(u-1, v-1)) {
                    cycle = true;
                    cand2 = {u, v};
                }
            }
        }
        delete uf;
        return mult && cycle ? cand0 : mult ? cand1 : cand2;
    }


    /*689. Maximum Sum of 3 Non-Overlapping Subarrays (Hard)
    Given an integer array nums and an integer k, find three non-overlapping
    subarrays of length k with maximum sum and return them. Return the result
    as a list of indices representing the starting position of each interval
    (0-indexed). If there are multiple answers, return the lexicographically
    smallest one.

    Example 1:
    Input: nums = [1,2,1,2,6,7,5,1], k = 2
    Output: [0,3,5]
    Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting
                 indices [0, 3, 5]. We could have also taken [2, 1], but an
                 answer of [1, 3, 5] would be lexicographically larger.

    Example 2:
    Input: nums = [1,2,1,2,1,2,1,2,1], k = 2
    Output: [0,2,4]

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= nums[i] < 2^16
    * 1 <= k <= floor(nums.length / 3)*/

    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        int rs0 = 0, rs1 = 0, rs2 = 0;
        for (int i = 0; i < k*3; ++i) {
            if (i < k) rs0 += nums[i];
            else if (i < 2*k) rs1 += nums[i];
            else rs2 += nums[i];
        }

        int m0 = rs0, m1 = m0 + rs1, m2 = m1 + rs2;
        vector<int> i0 = {0}, i1 = {0, k}, i2 = {0, k, 2*k};

        for (int i = 0; i < nums.size() - 3*k; ++i) {
            rs0 += nums[i+k] - nums[i];
            rs1 += nums[i+2*k] - nums[i+k];
            rs2 += nums[i+3*k] - nums[i+2*k];
            if (rs0 > m0) { m0 = rs0; i0 = {i+1}; }
            if (m0 + rs1 > m1) { m1 = m0 + rs1; i1 = {i0[0], i+k+1}; }
            if (m1 + rs2 > m2) { m2 = m1 + rs2; i2 = {i1[0], i1[1], i+2*k+1}; }
        }
        return i2;
    }


    /*690. Employee Importance (Easy)
    You are given a data structure of employee information, which includes the
    employee's unique id, their importance value and their direct subordinates'
    id. For example, employee 1 is the leader of employee 2, and employee 2 is
    the leader of employee 3. They have importance value 15, 10 and 5,
    respectively. Then employee 1 has a data structure like [1, 15, [2]], and
    employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that
    although employee 3 is also a subordinate of employee 1, the relationship
    is not direct. Now given the employee information of a company, and an
    employee id, you need to return the total importance value of this employee
    and all their subordinates.

    Example 1:
    Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
    Output: 11
    Explanation: Employee 1 has importance value 5, and he has two direct
                 subordinates: employee 2 and employee 3. They both have
                 importance value 3. So the total importance value of employee
                 1 is 5 + 3 + 3 = 11.

    Note:
    * One employee has at most one direct leader and may have several subordinates.
    * The maximum number of employees won't exceed 2000.*/

    int getImportance(vector<Employee*> employees, int id) {
        unordered_map<int, Employee*> mp;
        for (auto& employee : employees)
            mp.insert({employee->id, employee});

        stack<int> stk;
        stk.push(id);
        int ans = 0;
        while (!stk.empty()) {
            int id = stk.top();
            stk.pop();
            Employee* employee = mp[id];
            ans += employee->importance;
            for (auto& x : employee->subordinates)
                stk.push(x);
        }
        return ans;
    }


    /*691. Stickers to Spell Word (Hard)
    We are given n different types of stickers. Each sticker has a lowercase
    English word on it. You would like to spell out the given string target by
    cutting individual letters from your collection of stickers and rearranging
    them. You can use each sticker more than once if you want, and you have
    infinite quantities of each sticker. Return the minimum number of stickers
    that you need to spell out target. If the task is impossible, return -1.
    Note: In all test cases, all words were chosen randomly from the 1000 most
    common US English words, and target was chosen as a concatenation of two
    random words.

    Example 1:
    Input: stickers = ["with","example","science"], target = "thehat"
    Output: 3
    Explanation: We can use 2 "with" stickers, and 1 "example" sticker. After
                 cutting and rearrange the letters of those stickers, we can
                 form the target "thehat". Also, this is the minimum number of
                 stickers necessary to form the target string.

    Example 2:
    Input: stickers = ["notice","possible"], target = "basicbasic"
    Output: -1
    Explanation: We cannot form the target "basicbasic" from cutting letters
                 from the given stickers.

    Constraints:
    * n == stickers.length
    * 1 <= n <= 50
    * 1 <= stickers[i].length <= 10
    * 1 <= target <= 15
    * stickers[i] and target consist of lowercase English letters.*/

    int minStickers(vector<string>& stickers, string target) {
        int n = target.size();
        vector<uint> dp(1 << n, -1);
        dp[0] = 0;
        for (int mask = 0; mask < (1 << n); ++mask)
            if (dp[mask] != -1)
                for (auto& sticker : stickers) {
                    int mask0 = mask;
                    for (auto& ch : sticker)
                        for (int j = 0; j < n; ++j)
                            if (ch == target[j] && (mask0 & (1<<j)) == 0) {
                                mask0 ^= 1 << j;
                                break;
                            }
                    dp[mask0] = min(dp[mask0], 1 + dp[mask]);
                }
        return dp.back();
    }


    /*693. Binary Number with Alternating Bits (Easy)
    Given a positive integer, check whether it has alternating bits: namely, if
    two adjacent bits will always have different values.

    Example 1:
    Input: n = 5
    Output: true
    Explanation: The binary representation of 5 is: 101

    Example 2:
    Input: n = 7
    Output: false
    Explanation: The binary representation of 7 is: 111.

    Example 3:
    Input: n = 11
    Output: false
    Explanation: The binary representation of 11 is: 1011.

    Example 4:
    Input: n = 10
    Output: true
    Explanation: The binary representation of 10 is: 1010.

    Example 5:
    Input: n = 3
    Output: false

    Constraints: 1 <= n <= 2^31 - 1*/

    bool hasAlternatingBits(int n) {
        long nn = n ^ (n >> 1);
        return (nn & (nn+1)) == 0;
    }


    /*695. Max Area of Island (Medium)
    You are given an m x n binary matrix grid. An island is a group of 1's
    (representing land) connected 4-directionally (horizontal or vertical.) You
    may assume all four edges of the grid are surrounded by water. The area of
    an island is the number of cells with a value 1 in the island. Return the
    maximum area of an island in grid. If there is no island, return 0.

    Example 1:
    Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],
                   [0,0,0,0,0,0,0,1,1,1,0,0,0],
                   [0,1,1,0,1,0,0,0,0,0,0,0,0],
                   [0,1,0,0,1,1,0,0,1,0,1,0,0],
                   [0,1,0,0,1,1,0,0,1,1,1,0,0],
                   [0,0,0,0,0,0,0,0,0,0,1,0,0],
                   [0,0,0,0,0,0,0,1,1,1,0,0,0],
                   [0,0,0,0,0,0,0,1,1,0,0,0,0]]
    Output: 6
    Explanation: The answer is not 11, because the island must be connected
                 4-directionally.

    Example 2:
    Input: grid = [[0,0,0,0,0,0,0,0]]
    Output: 0

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * grid[i][j] is either 0 or 1.*/

    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ans = 0, m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) {
                    int val = 1;
                    grid[i][j] = 0;
                    stack<pair<int, int>> stk; stk.emplace(i, j);
                    while (stk.size()) {
                        auto [i, j] = stk.top(); stk.pop();
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj]) {
                                ++val;
                                grid[ii][jj] = 0;
                                stk.emplace(ii, jj);
                            }
                        }
                    }
                    ans = max(ans, val);
                }
        return ans;
    }


    /*696. Count Binary Substrings (Easy)
    Give a string s, count the number of non-empty (contiguous) substrings that
    have the same number of 0's and 1's, and all the 0's and all the 1's in
    these substrings are grouped consecutively. Substrings that occur multiple
    times are counted the number of times they occur.

    Example 1:
    Input: "00110011"
    Output: 6
    Explanation: There are 6 substrings that have equal number of consecutive
                 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
                 Notice that some of these substrings repeat and are counted
                 the number of times they occur. Also, "00110011" is not a
                 valid substring because all the 0's (and 1's) are not grouped
                 together.

    Example 2:
    Input: "10101"
    Output: 4
    Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal
                 number of consecutive 1's and 0's.

    Note:
    * s.length will be between 1 and 50,000.
    * s will only consist of "0" or "1" characters.*/

    int countBinarySubstrings(string s) {
        int ans = 0, prev = 0, curr = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (i && s[i-1] != s[i]) {
                prev = curr;
                curr = 0;
            }
            if (prev >= ++curr) ans += 1;
        }
        return ans;
    }


    /*697. Degree of an Array (Easy)
    Given a non-empty array of non-negative integers nums, the degree of this
    array is defined as the maximum frequency of any one of its elements. Your
    task is to find the smallest possible length of a (contiguous) subarray of
    nums, that has the same degree as nums.

    Example 1:
    Input: nums = [1,2,2,3,1]
    Output: 2
    Explanation:
    The input array has a degree of 2 because both elements 1 and 2 appear twice.
    Of the subarrays that have the same degree:
    [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
    The shortest length is 2. So return 2.

    Example 2:
    Input: nums = [1,2,2,3,1,4,2]
    Output: 6
    Explanation:
    The degree is 3 because the element 2 is repeated 3 times.
    So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.

    Constraints:
    * nums.length will be between 1 and 50,000.
    * nums[i] will be an integer between 0 and 49,999.*/

    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int, int> freq, seen;
        int ans = INT_MAX, most = 0;
        for (int i = 0; i < nums.size(); ++i) {
            seen.insert({nums[i], i});
            if (most <= ++freq[nums[i]]) {
                if (most < freq[nums[i]]) ans = i - seen[nums[i]] + 1;
                else ans = min(ans, i - seen[nums[i]] + 1);
                most = freq[nums[i]];
            }
        }
        return ans;
    }


    /*698. Partition to K Equal Sum Subsets (Medium)
    Given an integer array nums and an integer k, return true if it is possible
    to divide this array into k non-empty subsets whose sums are all equal.

    Example 1:
    Input: nums = [4,3,2,3,5,2,1], k = 4
    Output: true
    Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3),
                 (2,3) with equal sums.

    Example 2:
    Input: nums = [1,2,3,4], k = 3
    Output: false

    Constraints:
    * 1 <= k <= nums.length <= 16
    * 1 <= nums[i] <= 10^4
    * The frequency of each element is in the range [1, 4].*/

    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int total = accumulate(nums.begin(), nums.end(), 0);
        if (total % k) return false;
        int avg = total / k;

        vector<int> sm(k);
        sort(nums.begin(), nums.end(), [&](auto& lhs, auto& rhs) {return lhs > rhs; });

        function<bool(int)> fn = [&](int i) {
            if (i == nums.size()) return true;
            for (int kk = 0; kk < k; ++kk) {
                if (sm[kk] + nums[i] <= avg) {
                    sm[kk] += nums[i];
                    if (fn(i+1)) return true;
                    sm[kk] -= nums[i];
                }
                if (sm[kk] == 0) break;
            }
            return false;
        };

        return fn(0);
    }


    /*700. Search in a Binary Search Tree (Easy)
    You are given the root of a binary search tree (BST) and an integer val.
    Find the node in the BST that the node's value equals val and return the
    subtree rooted with that node. If such a node does not exist, return null.

    Example 1:
    Input: root = [4,2,7,1,3], val = 2
    Output: [2,1,3]

    Example 2:
    Input: root = [4,2,7,1,3], val = 5
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [1, 5000].
    * 1 <= Node.val <= 10^7
    * root is a binary search tree.
    * 1 <= val <= 10^7*/

    TreeNode* searchBST(TreeNode* root, int val) {
        TreeNode* node = root;
        while (node) {
            if (node->val < val) node = node->right;
            else if (node->val == val) break;
            else node = node->left;
        }
        return node;
    }


    /*701. Insert into a Binary Search Tree (Medium)
    You are given the root node of a binary search tree (BST) and a value to
    insert into the tree. Return the root node of the BST after the insertion.
    It is guaranteed that the new value does not exist in the original BST.
    Notice that there may exist multiple valid ways for the insertion, as long
    as the tree remains a BST after insertion. You can return any of them.

    Example 1:
    Input: root = [4,2,7,1,3], val = 5
    Output: [4,2,7,1,3,5]
    Explanation: Another accepted tree is:

    Example 2:
    Input: root = [40,20,60,10,30,50,70], val = 25
    Output: [40,20,60,10,30,50,70,null,null,25]

    Example 3:
    Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
    Output: [4,2,7,1,3,5]

    Constraints:
    * The number of nodes in the tree will be in the range [0, 10^4].
    * -10^8 <= Node.val <= 10^8
    * All the values Node.val are unique.
    * -10^8 <= val <= 10^8
    * It's guaranteed that val does not exist in the original BST.*/

    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (!root) return new TreeNode(val);
        TreeNode* node = root;
        while (node)
            if (node->val < val)
                if (node->right) node = node->right;
                else {
                    node->right = new TreeNode(val);
                    break;
                }
            else
                if (node->left) node = node->left;
                else {
                    node->left = new TreeNode(val);
                    break;
                }
        return root;
    }


    /*702. Search in a Sorted Array of Unknown Size (Medium)
    This is an interactive problem. You have a sorted array of unique elements
    and an unknown size. You do not have an access to the array but you can use
    the ArrayReader interface to access it. You can call ArrayReader.get(i)
    that:
    * returns the value at the ith index (0-indexed) of the secret array (i.e.,
      secret[i]), or
    * returns 2^31 - 1 if the i is out of the boundary of the array.
    You are also given an integer target. Return the index k of the hidden
    array where secret[k] == target or return -1 otherwise. You must write an
    algorithm with O(log n) runtime complexity.

    Example 1:
    Input: secret = [-1,0,3,5,9,12], target = 9
    Output: 4
    Explanation: 9 exists in secret and its index is 4.

    Example 2:
    Input: secret = [-1,0,3,5,9,12], target = 2
    Output: -1
    Explanation: 2 does not exist in secret so return -1.

    Constraints:
    * 1 <= secret.length <= 10^4
    * -10^4 <= secret[i], target <= 10^4
    * secret is sorted in a strictly increasing order.*/

    int search(const ArrayReader& reader, int target) {
        int lo = 0, hi = 10'000;
        while (lo <= hi) {
            int mid = lo + (hi - lo)/2, val = reader.get(mid);
            if (val < target) lo = mid + 1;
            else if (val == target) return mid;
            else hi = mid - 1;
        }
        return -1;
    }


    /*704. Binary Search (Easy)
    Given an array of integers nums which is sorted in ascending order, and an
    integer target, write a function to search target in nums. If target exists,
    then return its index. Otherwise, return -1. You must write an algorithm
    with O(log n) runtime complexity.

    Example 1:
    Input: nums = [-1,0,3,5,9,12], target = 9
    Output: 4
    Explanation: 9 exists in nums and its index is 4

    Example 2:
    Input: nums = [-1,0,3,5,9,12], target = 2
    Output: -1
    Explanation: 2 does not exist in nums so return -1

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^4 < nums[i], target < 10^4
    * All the integers in nums are unique.
    * nums is sorted in ascending order.*/

    int search(vector<int>& nums, int target) {
        for (int lo = 0, hi = nums.size(); lo < hi; ) {
            int mid = lo + (hi - lo)/2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) lo = mid + 1;
            else hi = mid;
        }
        return -1;
    }


    /*708. Insert into a Sorted Circular Linked List (Medium)
    Given a Circular Linked List node, which is sorted in ascending order,
    write a function to insert a value insertVal into the list such that it
    remains a sorted circular list. The given node can be a reference to any
    single node in the list and may not necessarily be the smallest value in
    the circular list. If there are multiple suitable places for insertion,
    you may choose any place to insert the new value. After the insertion, the
    circular list should remain sorted. If the list is empty (i.e., the given
    node is null), you should create a new single circular list and return the
    reference to that single node. Otherwise, you should return the originally
    given node.

    Example 1:
    Input: head = [3,4,1], insertVal = 2
    Output: [3,4,1,2]
    Explanation: In the figure above, there is a sorted circular list of three
                 elements. You are given a reference to the node with value 3,
                 and we need to insert 2 into the list. The new node should be
                 inserted between node 1 and node 3. After the insertion, the
                 list should look like this, and we should still return node 3.

    Example 2:
    Input: head = [], insertVal = 1
    Output: [1]
    Explanation: The list is empty (given head is null). We create a new single
                 circular list and return the reference to that single node.

    Example 3:
    Input: head = [1], insertVal = 0
    Output: [1,0]

    Constraints:
    * 0 <= Number of Nodes <= 5 * 10^4
    * -10^6 <= Node.val, insertVal <= 10^6*/

    Node* insert(Node* head, int insertVal) {
        Node* temp = new Node(insertVal);
        if (!head) {
            temp->next = temp;
            return temp;
        }

        Node* prev = head, *node = head->next;
        while (true) {
            if (prev->val <= insertVal && insertVal <= node->val) break;
            if (prev->val > node->val && (insertVal < node->val || prev->val < insertVal)) break;
            prev = node;
            node = node->next;
            if (prev == head) break;
        }
        prev->next = temp;
        temp->next = node;
        return head;
    }


    /*709. To Lower Case (Easy)
    Implement function ToLowerCase() that has a string parameter str, and
    returns the same string in lowercase.

    Example 1:
    Input: "Hello"
    Output: "hello"

    Example 2:
    Input: "here"
    Output: "here"

    Example 3:
    Input: "LOVELY"
    Output: "lovely"*/

    string toLowerCase(string s) {
        for (auto& c : s)
            if (isupper(c)) c |= 32;
        return s;
    }


    /*711. Number of Distinct Islands II (Hard)
    You are given an m x n binary matrix grid. An island is a group of 1's
    (representing land) connected 4-directionally (horizontal or vertical.) You
    may assume all four edges of the grid are surrounded by water. An island is
    considered to be the same as another if they have the same shape, or have
    the same shape after rotation (90, 180, or 270 degrees only) or reflection
    (left/right direction or up/down direction). Return the number of distinct
    islands.

    Example 1:
    Input: grid = [[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,1],[0,0,0,1,1]]
    Output: 1
    Explanation: The two islands are considered the same because if we make a
                 180 degrees clockwise rotation on the first island, then two
                 islands will have the same shapes.

    Example 2:
    Input: grid = [[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]
    Output: 1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * grid[i][j] is either 0 or 1.*/

    int numDistinctIslands2(vector<vector<int>>& grid) {
        int ans = 0, m = grid.size(), n = grid[0].size(), dir[] = {-1, 0, 1, 0, -1};
        set<vector<pair<int, int>>> seen;
        for (int r = 0; r < m; ++r) {
            for (int c = 0; c < n; ++c) {
                if (grid[r][c]) {
                    vector<vector<pair<int, int>>> vals(8);
                    grid[r][c] = 0;
                    stack<pair<int, int>> stk; stk.emplace(r, c);
                    while (stk.size()) {
                        auto [i, j] = stk.top(); stk.pop();
                        int k = 0;
                        for (auto& [x, y] : vector<pair<int, int>>{{1, 1}, {1, -1}, {-1, 1}, {-1, -1}}) {
                            vals[k++].emplace_back(i*x, j*y);
                            vals[k++].emplace_back(j*x, i*y);
                        }
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj]) {
                                grid[ii][jj] = 0;
                                stk.emplace(ii, jj);
                            }
                        }
                    }
                    bool found = false;
                    set<vector<pair<int, int>>> temp;
                    for (int k = 0; k < 8; ++k) {
                        int mx = min_element(vals[k].begin(), vals[k].end())->first;
                        int my = min_element(vals[k].begin(), vals[k].end(), [&](auto& lhs, auto& rhs) {return lhs.second < rhs.second;})->second;
                        for (auto& [x, y] : vals[k]) {
                            x -= mx;
                            y -= my;
                        }
                        sort(vals[k].begin(), vals[k].end());
                        if (seen.count(vals[k])) {
                            found = true;
                            break;
                        }
                        temp.insert(vals[k]);
                    }
                    if (!found) {
                        ++ans;
                        for (auto& v : temp) seen.insert(v);
                    }
                }
            }
        }
        return ans;
    }


    /*713. Subarray Product Less Than K (Medium)
    Given an array of integers nums and an integer k, return the number of
    contiguous subarrays where the product of all the elements in the subarray
    is strictly less than k.

    Example 1:
    Input: nums = [10,5,2,6], k = 100
    Output: 8
    Explanation: The 8 subarrays that have product less than 100 are:
                 [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note
                 that [10, 5, 2] is not included as the product of 100 is not
                 strictly less than k.

    Example 2:
    Input: nums = [1,2,3], k = 0
    Output: 0

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * 1 <= nums[i] <= 1000
    * 0 <= k <= 10^6*/

    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int ans = 0;
        for (int i = 0, ii = 0, prod = 1; i < nums.size(); ++i) {
            prod *= nums[i];
            while (ii <= i && k <= prod) prod /= nums[ii++];
            ans += i - ii + 1;
        }
        return ans;
    }


    /*714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)
    You are given an array prices where prices[i] is the price of a given stock
    on the ith day, and an integer fee representing a transaction fee. Find the
    maximum profit you can achieve. You may complete as many transactions as
    you like, but you need to pay the transaction fee for each transaction.
    Note: You may not engage in multiple transactions simultaneously (i.e., you
    must sell the stock before you buy again).

    Example 1:
    Input: prices = [1,3,2,8,4,9], fee = 2
    Output: 8
    Explanation: The maximum profit can be achieved by:
                 - Buying at prices[0] = 1
                 - Selling at prices[3] = 8
                 - Buying at prices[4] = 4
                 - Selling at prices[5] = 9
                 The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

    Example 2:
    Input: prices = [1,3,7,5,10,3], fee = 3
    Output: 6

    Constraints:
    * 1 <= prices.length <= 5 * 10^4
    * 1 <= prices[i] < 5 * 10^4
    * 0 <= fee < 5 * 10^4*/

    int maxProfit(vector<int>& prices, int fee) {
        // buy low & sell high
        int buy = INT_MAX, sell = 0;
        for (auto& x : prices) {
            buy = min(buy, x - sell);
            sell = max(sell, x - buy - fee);
        }
        return sell;
    }


    /*717. 1-bit and 2-bit Characters (Easy)
    We have two special characters. The first character can be represented by
    one bit 0. The second character can be represented by two bits (10 or 11).
    Now given a string represented by several bits. Return whether the last
    character must be a one-bit character or not. The given string will always
    end with a zero.

    Example 1:
    Input: bits = [1, 0, 0]
    Output: True
    Explanation: The only way to decode it is two-bit character and one-bit
                 character. So the last character is one-bit character.

    Example 2:
    Input: bits = [1, 1, 1, 0]
    Output: False
    Explanation: The only way to decode it is two-bit character and two-bit
                 character. So the last character is NOT one-bit character.

    Note:
    * 1 <= len(bits) <= 1000.
    * bits[i] is always 0 or 1.*/

    bool isOneBitCharacter(vector<int>& bits) {
        int i = 0;
        for (; i < bits.size()-1; ++i)
            if (bits[i]) ++i;
        return i == bits.size()-1;
    }


    /*719. Find K-th Smallest Pair Distance (Hard)
    The distance of a pair of integers a and b is defined as the absolute
    difference between a and b. Given an integer array nums and an integer k,
    return the kth smallest distance among all the pairs nums[i] and nums[j]
    where 0 <= i < j < nums.length.

    Example 1:
    Input: nums = [1,3,1], k = 1
    Output: 0
    Explanation: Here are all the pairs: (1,3) -> 2
                                         (1,1) -> 0
                                         (3,1) -> 2
                 Then the 1st smallest distance pair is (1,1), and its distance
                 is 0.

    Example 2:
    Input: nums = [1,1,1], k = 2
    Output: 0

    Example 3:
    Input: nums = [1,6,1], k = 3
    Output: 5

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^4
    * 0 <= nums[i] <= 10^6
    * 1 <= k <= n * (n - 1) / 2*/

    int smallestDistancePair(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());

        auto fn = [&](int x) {
            int ans = 0;
            for (int i = 0, ii = 0; i < nums.size(); ++i) {
                for (; ii < i && nums[i] - nums[ii] > x; ++ii);
                ans += i - ii;
            }
            return ans;
        };

        int lo = 0, hi = nums.back() - nums.front();
        while (lo < hi) {
            int mid = lo + (hi - lo)/2, y = fn(mid);
            if (y < k) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*720. Longest Word in Dictionary (Easy)
    Given an array of strings words representing an English Dictionary, return
    the longest word in words that can be built one character at a time by
    other words in words. If there is more than one possible answer, return the
    longest word with the smallest lexicographical order. If there is no answer,
    return the empty string.

    Example 1:
    Input: words = ["w","wo","wor","worl","world"]
    Output: "world"
    Explanation: The word "world" can be built one character at a time by
                 "w", "wo", "wor", and "worl".

    Example 2:
    Input: words = ["a","banana","app","appl","ap","apply","apple"]
    Output: "apple"
    Explanation: Both "apply" and "apple" can be built from other words in the
                 dictionary. However, "apple" is lexicographically smaller than
                 "apply".

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 30
    * words[i] consists of lowercase English letters.*/

    string longestWord(vector<string>& words) {
        sort(words.begin(), words.end());
        string ans;
        unordered_set<string> seen = {""};
        for (int i = 0; i < words.size(); ++i) {
            int n = words[i].size();
            if (seen.count(words[i].substr(0, n-1))) {
                if (n > ans.size()) ans = words[i];
                seen.insert(words[i]);
            }
        }
        return ans;
    }


    /*721. Accounts Merge (Medium)
    Given a list of accounts where each element accounts[i] is a list of
    strings, where the first element accounts[i][0] is a name, and the rest of
    the elements are emails representing emails of the account. Now, we would
    like to merge these accounts. Two accounts definitely belong to the same
    person if there is some common email to both accounts. Note that even if
    two accounts have the same name, they may belong to different people as
    people could have the same name. A person can have any number of accounts
    initially, but all of their accounts definitely have the same name. After
    merging the accounts, return the accounts in the following format: the
    first element of each account is the name, and the rest of the elements are
    emails in sorted order. The accounts themselves can be returned in any
    order.

    Example 1:
    Input: accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],
                       ["John","johnsmith@mail.com","john00@mail.com"],
                       ["Mary","mary@mail.com"],
                       ["John","johnnybravo@mail.com"]]
    Output: [["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],
             ["Mary","mary@mail.com"],
             ["John","johnnybravo@mail.com"]]
    Explanation: The first and second John's are the same person as they have
                 the common email "johnsmith@mail.com". The third John and Mary
                 are different people as none of their email addresses are used
                 by other accounts. We could return these lists in any order,
                 for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],
                 ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']]
                 would still be accepted.

    Example 2:
    Input: accounts = [["Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"],
                       ["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],
                       ["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],
                       ["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],
                       ["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]
    Output: [["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],
             ["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],
             ["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],
             ["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],
             ["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]

    Constraints:
    * 1 <= accounts.length <= 1000
    * 2 <= accounts[i].length <= 10
    * 1 <= accounts[i][j] <= 30
    * accounts[i][0] consists of English letters.
    * accounts[i][j] (for j > 0) is a valid email.*/

    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        unordered_map<string, string> email;
        UnionFindDict *uf = new UnionFindDict();
        for (auto& account : accounts)
            for (int i = 1; i < account.size(); ++i) {
                email[account[i]] = account[0];
                uf->connect(account[1], account[i]);
            }

        unordered_map<string, vector<string>> group;
        for (auto& [k, v] : email) group[uf->find(k)].push_back(k);

        vector<vector<string>> ans;
        for (auto& [k, v] : group) {
            vector<string> vals = {email[k]};
            sort(v.begin(), v.end());
            vals.insert(vals.end(), v.begin(), v.end());
            ans.push_back(vals);
        }
        delete uf;
        return ans;
    }


 //    /*722. Remove Comments (Medium)
    // Given a C++ program, remove comments from it. The program source is an
    // array of strings source where source[i] is the ith line of the source code.
    // This represents the result of splitting the original source code string by
    // the newline character '\n'. In C++, there are two types of comments, line
    // comments, and block comments.
    // * The string "//" denotes a line comment, which represents that it and the
    //   rest of the characters to the right of it in the same line should be
    //   ignored.
    // * The string "/*" denotes a block comment, which represents that all
    //   characters until the next (non-overlapping) occurrence of "*/" should be
    //   ignored. (Here, occurrences happen in reading order: line by line from
    //   left to right.) To be clear, the string "/*/" does not yet end the block
    //   comment, as the ending would be overlapping the beginning.

    // The first effective comment takes precedence over others.
    // * For example, if the string "//" occurs in a block comment, it is ignored.
    // * Similarly, if the string "/*" occurs in a line or block comment, it is
    //   also ignored.
    // If a certain line of code is empty after removing comments, you must not
    // output that line: each string in the answer list will be non-empty. There
    // will be no control characters, single quote, or double quote characters.
    // * For example, source = "string s = "/* Not a comment. */";" will not be a
    //   test case.
    // Also, nothing else such as defines or macros will interfere with the
    // comments. It is guaranteed that every open block comment will eventually be
    // closed, so "/*" outside of a line or block comment always starts a new
    // comment. Finally, implicit newline characters can be deleted by block
    // comments. Please see the examples below for details. After removing the
    // comments from the source code, return the source code in the same format.

    // Example 1:
    // Input: source = ["/*Test program */",
    //                  "int main()",
    //                  "{ ",
    //                  "  // variable declaration ",
    //                  "int a, b, c;",
    //                  "/* This is a test",
    //                  "   multiline  ",
    //                  "   comment for ",
    //                  "   testing */",
    //                  "a = b + c;", "}"]
    // Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]
    // Explanation: The line by line code is visualized as below:
    //                  /*Test program */
    //                  int main()
    //                  {
    //                    // variable declaration
    //                  int a, b, c;
    //                  /* This is a test
    //                     multiline
    //                     comment for
    //                     testing */
    //                  a = b + c;
    //                  }
    //              The string /* denotes a block comment, including line 1 and
    //              lines 6-9. The string // denotes line 4 as comments. The line
    //              by line output code is visualized as below:
    //                  int main()
    //                  {

    //                  int a, b, c;
    //                  a = b + c;
    //                  }

    // Example 2:
    // Input: source = ["a/*comment",
    //                  "line",
    //                  "more_comment*/b"]
    // Output: ["ab"]
    // Explanation: The original source string is "a/*comment\nline\nmore_comment*/b",
    //              where we have bolded the newline characters.  After deletion,
    //              the implicit newline characters are deleted, leaving the
    //              string "ab", which when delimited by newline characters
    //              becomes ["ab"].

    // Constraints:
    // * 1 <= source.length <= 100
    // * 0 <= source[i].length <= 80
    // * source[i] consists of printable ASCII characters.
    // * Every open block comment is eventually closed.
    // * There are no single-quote or double-quote in the input.*/

    vector<string> removeComments(vector<string>& source) {
        vector<string> ans;
        string val;
        bool comment = false;

        for (auto& line : source) {
            if (!comment) val = "";
            for (int i = 0; i < line.size(); ++i)
                if (comment) {
                    if (line.substr(i, 2) == "*/") {
                        comment = false;
                        ++i;
                    }
                } else
                    if (line.substr(i, 2) == "//") break;
                    else if (line.substr(i, 2) == "/*") {
                        comment = true;
                        ++i;
                    } else val.push_back(line[i]);
            if (!comment && val.size()) ans.push_back(val);
        }
        return ans;
    }


    /*723. Candy Crush (Medium)
    This question is about implementing a basic elimination algorithm for Candy
    Crush. Given an m x n integer array board representing the grid of candy
    where board[i][j] represents the type of candy. A value of board[i][j] == 0
    represents that the cell is empty. The given board represents the state of
    the game following the player's move. Now, you need to restore the board to
    a stable state by crushing candies according to the following rules:
    * If three or more candies of the same type are adjacent vertically or
      horizontally, crush them all at the same time - these positions become
      empty.
    * After crushing all candies simultaneously, if an empty space on the board
      has candies on top of itself, then these candies will drop until they hit
      a candy or bottom at the same time. No new candies will drop outside the
      top boundary.
    * After the above steps, there may exist more candies that can be crushed.
      If so, you need to repeat the above steps.
    * If there does not exist more candies that can be crushed (i.e., the board
      is stable), then return the current board.
    You need to perform the above rules until the board becomes stable, then
    return the stable board.

    Example 1:
    Input: board = [[110,  5,112,113, 114],
                    [210,211,  5,213, 214],
                    [310,311,  3,313, 314],
                    [410,411,412,  5, 414],
                    [  5,  1,512,  3,   3],
                    [610,  4,  1,613, 614],
                    [710,  1,  2,713, 714],
                    [810,  1,  2,  1,   1],
                    [  1,  1,  2,  2,   2],
                    [  4,  1,  4,  4,1014]]
    Output: [[  0,  0,  0,  0,   0],
             [  0,  0,  0,  0,   0],
             [  0,  0,  0,  0,   0],
             [110,  0,  0,  0, 114],
             [210,  0,  0,  0, 214],
             [310,  0,  0,113, 314],
             [410,  0,  0,213, 414],
             [610,211,112,313, 614],
             [710,311,412,613, 714],
             [810,411,512,713,1014]]
    Example 2:

    Input: board = [[1,3,5,5,2],
                    [3,4,3,3,1],
                    [3,2,4,5,2],
                    [2,4,4,5,5],
                    [1,4,4,1,1]]
    Output: [[1,3,0,0,0],
             [3,4,0,5,2],
             [3,2,0,3,1],
             [2,4,0,5,2],
             [1,4,3,1,1]]

    Constraints:
    * m == board.length
    * n == board[i].length
    * 3 <= m, n <= 50
    * 1 <= board[i][j] <= 2000*/

    vector<vector<int>> candyCrush(vector<vector<int>>& board) {
        int m = board.size(), n = board[0].size();

        while (true) {
            vector<pair<int, int>> vals;
            for (int i = 0; i < m; ++i)
                for (int j = 0; j < n; ++j)
                    if (board[i][j])
                        if ((0 <= i-2 && board[i-2][j] == board[i-1][j] && board[i-1][j] == board[i][j])
                            || (0 <= i-1 && i+1 < m && board[i-1][j] == board[i][j] && board[i][j] == board[i+1][j])
                            || (i+2 < m && board[i][j] == board[i+1][j] && board[i+1][j] == board[i+2][j])
                            || (0 <= j-2 && board[i][j-2] == board[i][j-1] && board[i][j-1] == board[i][j])
                            || (0 <= j-1 && j+1 < n && board[i][j-1] == board[i][j] && board[i][j] == board[i][j+1])
                            || (j+2 < n && board[i][j] == board[i][j+1] && board[i][j+1] == board[i][j+2]))
                            vals.emplace_back(i, j);
            if (vals.empty()) break;
            for (auto& [i, j] : vals) board[i][j] = 0;

            for (int j = 0; j < n; ++j) {
                int ii = m-1;
                for (int i = m-1; i >= 0; --i)
                    if (board[i][j]) swap(board[ii--][j], board[i][j]);
            }
        }
        return board;
    }


    /*724. Find Pivot Index (Easy)
    Given an array of integers nums, calculate the pivot index of this array.
    The pivot index is the index where the sum of all the numbers strictly to
    the left of the index is equal to the sum of all the numbers strictly to
    the index's right. If the index is on the left edge of the array, then the
    left sum is 0 because there are no elements to the left. This also applies
    to the right edge of the array. Return the leftmost pivot index. If no such
    index exists, return -1.

    Example 1:
    Input: nums = [1,7,3,6,5,6]
    Output: 3
    Explanation:
    The pivot index is 3.
    Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
    Right sum = nums[4] + nums[5] = 5 + 6 = 11

    Example 2:
    Input: nums = [1,2,3]
    Output: -1
    Explanation:
    There is no index that satisfies the conditions in the problem statement.

    Example 3:
    Input: nums = [2,1,-1]
    Output: 0
    Explanation:
    The pivot index is 0.
    Left sum = 0 (no elements to the left of index 0)
    Right sum = nums[1] + nums[2] = 1 + -1 = 0

    Constraints:
    * 1 <= nums.length <= 10^4
    * -1000 <= nums[i] <= 1000*/

    int pivotIndex(vector<int>& nums) {
        int prefix = 0, suffix = 0;
        for (auto& x : nums)
            suffix += x;

        for (int i = 0; i < nums.size(); ++i) {
            suffix -= nums[i];
            if (prefix == suffix) return i;
            prefix += nums[i];
        }
        return -1;
    }


    /*725. Split Linked List in Parts (Medium)
    Given the head of a singly linked list and an integer k, split the linked
    list into k consecutive linked list parts. The length of each part should
    be as equal as possible: no two parts should have a size differing by more
    than one. This may lead to some parts being null. The parts should be in
    the order of occurrence in the input list, and parts occurring earlier
    should always have a size greater than or equal to parts occurring later.
    Return an array of the k parts.

    Example 1:
    Input: head = [1,2,3], k = 5
    Output: [[1],[2],[3],[],[]]
    Explanation: The first element output[0] has output[0].val = 1,
                 output[0].next = null. The last element output[4] is null, but
                 its string representation as a ListNode is [].

    Example 2:
    Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3
    Output: [[1,2,3,4],[5,6,7],[8,9,10]]
    Explanation: The input has been split into consecutive parts with size
                 difference at most 1, and earlier parts are a larger size than
                 the later parts.

    Constraints:
    * The number of nodes in the list is in the range [0, 1000].
    * 0 <= Node.val <= 1000
    * 1 <= k <= 50*/

    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        int sz = 0;
        for (ListNode *node = head; node; node = node->next, ++sz);
        int q = sz/k, r = sz%k;
        vector<ListNode*> ans;
        ListNode *node = head;
        for (int i = 0; i < k; ++i) {
            ans.push_back(node);
            for (int v = i < r ? q : q-1; v > 0; --v)
                node = node->next;
            if (node)
                tie(node->next, node) = make_pair(nullptr, node->next);
        }
        return ans;
    }


    /*726. Number of Atoms (Hard)
    Given a string formula representing a chemical formula, return the count of
    each atom. The atomic element always starts with an uppercase character,
    then zero or more lowercase letters, representing the name. One or more
    digits representing that element's count may follow if the count is greater
    than 1. If the count is 1, no digits will follow. For example, "H2O" and
    "H2O2" are possible, but "H1O2" is impossible. Two formulas are
    concatenated together to produce another formula. For example, "H2O2He3Mg4"
    is also a formula. A formula placed in parentheses, and a count (optionally
    added) is also a formula. For example, "(H2O2)" and "(H2O2)3" are formulas.
    Return the count of all elements as a string in the following form: the
    first name (in sorted order), followed by its count (if that count is more
    than 1), followed by the second name (in sorted order), followed by its
    count (if that count is more than 1), and so on.

    Example 1:
    Input: formula = "H2O"
    Output: "H2O"
    Explanation: The count of elements are {'H': 2, 'O': 1}.

    Example 2:
    Input: formula = "Mg(OH)2"
    Output: "H2MgO2"
    Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.

    Example 3:
    Input: formula = "K4(ON(SO3)2)2"
    Output: "K4N2O14S4"
    Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.

    Example 4:
    Input: formula = "Be32"
    Output: "Be32"

    Constraints:
    * 1 <= formula.length <= 1000
    * formula consists of English letters, digits, '(', and ')'.
    * formula is always valid.
    * All the values in the output will fit in a 32-bit integer.*/

    string countOfAtoms(string formula) {
        unordered_map<int, int> mp;
        stack<int> stk;
        for (int i = 0; i < formula.size(); ++i) {
            if (formula[i] == '(') stk.push(i);
            else if (formula[i] == ')') { mp[stk.top()] = i; stk.pop(); }
        }

        function<map<string, int>(int, int)> fn = [&](int lo, int hi) {
            map<string, int> ans;
            for (int k = lo; k < hi; ) {
                int cnt = 0;
                if (formula[k] == '(') {
                    map<string, int> freq = fn(k+1, mp[k]);
                    k = mp[k] + 1;
                    for (; k < hi && isdigit(formula[k]); ++k)
                        cnt = 10*cnt + (formula[k] - '0');
                    for (auto& [key, val] : freq)
                        ans[key] += val * max(1, cnt);
                } else {
                    string atom;
                    atom.push_back(formula[k++]);
                    for (; k < hi && formula[k] != '(' && !isupper(formula[k]); ++k) {
                        if (isalpha(formula[k])) atom.push_back(formula[k]);
                        else cnt = 10*cnt + (formula[k] - '0');
                    }
                    ans[atom] += max(1, cnt);
                }
            }
            return ans;
        };

        string ans;
        map<string, int> freq = fn(0, formula.size());
        for (auto& [key, val] : freq) {
            ans += key;
            if (val > 1) ans += to_string(val);
        }
        return ans;
    }


    /*727. Minimum Window Subsequence (Hard)
    Given strings s1 and s2, return the minimum contiguous substring part of s1,
    so that s2 is a subsequence of the part. If there is no such window in s1
    that covers all characters in s2, return the empty string "". If there are
    multiple such minimum-length windows, return the one with the left-most
    starting index.

    Example 1:
    Input: s1 = "abcdebdde", s2 = "bde"
    Output: "bcde"
    Explanation: "bcde" is the answer because it occurs before "bdde" which has
                 the same length. "deb" is not a smaller window because the
                 elements of s2 in the window must occur in order.

    Example 2:
    Input: s1 = "jmeqksfrsdcmsiwvaovztaqenprpvnbstl", s2 = "u"
    Output: ""

    Constraints:
    * 1 <= s1.length <= 2 * 10^4
    * 1 <= s2.length <= 100
    * s1 and s2 consist of lowercase English letters.*/

    string minWindow(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        if (s1[0] == s2[0]) dp[0][0] = 0;
        for (int i = 1; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (s1[i] == s2[j])
                    if (j) dp[i][j] = dp[i-1][j-1];
                    else dp[i][j] = i;
                else dp[i][j] = dp[i-1][j];
        string ans;
        for (int i = 0; i < m; ++i) {
            int k = dp[i][n-1];
            if (k != -1 && (ans == "" || i-k+1 < ans.size())) ans = s1.substr(k, i+1-k);
        }
        return ans;
    }


    /*728. Self Dividing Numbers (Easy)
    A self-dividing number is a number that is divisible by every digit it
    contains. For example, 128 is a self-dividing number because 128 % 1 == 0,
    128 % 2 == 0, and 128 % 8 == 0. Also, a self-dividing number is not allowed
    to contain the digit zero. Given a lower and upper number bound, output a
    list of every possible self dividing number, including the bounds if
    possible.

    Example 1:
    Input:
    left = 1, right = 22
    Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]

    Note: The boundaries of each input argument are 1 <= left <= right <= 10000.*/

    vector<int> selfDividingNumbers(int left, int right) {
        vector<int> ans;
        for (int x = left, n = 0; x <= right; ++x) {
            for (n = x; n; n /= 10) {
                if (n % 10 == 0 || x % (n%10) != 0) break;
            }
            if (n == 0) ans.push_back(x);
        }
        return ans;
    }


    /*733. Flood Fill (Easy)
    An image is represented by a 2-D array of integers, each integer
    representing the pixel value of the image (from 0 to 65535). Given a
    coordinate (sr, sc) representing the starting pixel (row and column) of the
    flood fill, and a pixel value newColor, "flood fill" the image. To perform
    a "flood fill", consider the starting pixel, plus any pixels connected 4-
    directionally to the starting pixel of the same color as the starting pixel,
    plus any pixels connected 4-directionally to those pixels (also with the
    same color as the starting pixel), and so on. Replace the color of all of
    the aforementioned pixels with the newColor. At the end, return the
    modified image.

    Example 1:
    Input: image = [[1,1,1],[1,1,0],[1,0,1]]
           sr = 1, sc = 1, newColor = 2
    Output: [[2,2,2],[2,2,0],[2,0,1]]
    Explanation:
    From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected
    by a path of the same color as the starting pixel are colored with the new color.
    Note the bottom corner is not colored 2, because it is not 4-directionally connected
    to the starting pixel.

    Note:
    * The length of image and image[0] will be in the range [1, 50].
    * The given starting pixel will satisfy 0 <= sr < image.length and 0 <= sc < image[0].length.
    * The value of each color in image[i][j] and newColor will be an integer in [0, 65535].*/

    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int m = image.size(), n = image[0].size(), dir[5] = {-1, 0, 1, 0, -1}, oldColor = image[sr][sc];
        if (oldColor != newColor) {
            stack<pair<int, int>> stk;
            stk.emplace(sr, sc);
            while (stk.size()) {
                auto [i, j] = stk.top(); stk.pop();
                image[i][j] = newColor;
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && image[ii][jj] == oldColor)
                        stk.emplace(ii, jj);
                }
            }
        }
        return image;
    }


    /*734. Sentence Similarity (Easy)
    We can represent a sentence as an array of words, for example, the sentence
    "I am happy with leetcode" can be represented as
    arr = ["I","am",happy","with","leetcode"]. Given two sentences sentence1
    and sentence2 each represented as a string array and given an array of
    string pairs similarPairs where similarPairs[i] = [xi, yi] indicates that
    the two words xi and yi are similar. Return true if sentence1 and sentence2
    are similar, or false if they are not similar. Two sentences are similar if:
    * They have the same length (i.e., the same number of words)
    * sentence1[i] and sentence2[i] are similar.
    Notice that a word is always similar to itself, also notice that the
    similarity relation is not transitive. For example, if the words a and b
    are similar, and the words b and c are similar, a and c are not necessarily
    similar.

    Example 1:
    Input: sentence1 = ["great","acting","skills"],
           sentence2 = ["fine","drama","talent"],
           similarPairs = [["great","fine"],["drama","acting"],["skills","talent"]]
    Output: true
    Explanation: The two sentences have the same length and each word i of
                 sentence1 is also similar to the corresponding word in
                 sentence2.

    Example 2:
    Input: sentence1 = ["great"], sentence2 = ["great"], similarPairs = []
    Output: true
    Explanation: A word is similar to itself.

    Example 3:
    Input: sentence1 = ["great"],
           sentence2 = ["doubleplus","good"],
           similarPairs = [["great","doubleplus"]]
    Output: false
    Explanation: As they don't have the same length, we return false.

    Constraints:
    * 1 <= sentence1.length, sentence2.length <= 1000
    * 1 <= sentence1[i].length, sentence2[i].length <= 20
    * sentence1[i] and sentence2[i] consist of English letters.
    * 0 <= similarPairs.length <= 1000
    * similarPairs[i].length == 2
    * 1 <= xi.length, yi.length <= 20
    * xi and yi consist of lower-case and upper-case English letters.
    * All the pairs (xi, yi) are distinct.*/

    bool areSentencesSimilar(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) {
        if (sentence1.size() != sentence2.size()) return false;
        unordered_map<string, unordered_set<string>> mp;
        for (auto& p : similarPairs) {
            mp[p[0]].insert(p[1]);
            mp[p[1]].insert(p[0]);
        }
        for (int i = 0; i < sentence1.size(); ++i)
            if (sentence1[i] != sentence2[i] && !mp[sentence1[i]].count(sentence2[i])) return false;
        return true;
    }


    /*737. Sentence Similarity II (Medium)
    We can represent a sentence as an array of words, for example, the sentence
    "I am happy with leetcode" can be represented as
    arr = ["I","am",happy","with","leetcode"]. Given two sentences sentence1
    and sentence2 each represented as a string array and given an array of
    string pairs similarPairs where similarPairs[i] = [xi, yi] indicates that
    the two words xi and yi are similar. Return true if sentence1 and sentence2
    are similar, or false if they are not similar. Two sentences are similar if:
    * They have the same length (i.e., the same number of words)
    * sentence1[i] and sentence2[i] are similar.
    Notice that a word is always similar to itself, also notice that the
    similarity relation is transitive. For example, if the words a and b are
    similar, and the words b and c are similar, then a and c are similar.

    Example 1:
    Input: sentence1 = ["great","acting","skills"],
           sentence2 = ["fine","drama","talent"],
           similarPairs = [["great","good"],["fine","good"],["drama","acting"],["skills","talent"]]
    Output: true
    Explanation: The two sentences have the same length and each word i of
                 sentence1 is also similar to the corresponding word in
                 sentence2.

    Example 2:
    Input: sentence1 = ["I","love","leetcode"],
           sentence2 = ["I","love","onepiece"],
           similarPairs = [["manga","onepiece"],["platform","anime"],["leetcode","platform"],["anime","manga"]]
    Output: true
    Explanation: "leetcode" --> "platform" --> "anime" --> "manga" --> "onepiece".
                 Since "leetcode is similar to "onepiece" and the first two
                 words are the same, the two sentences are similar.

    Example 3:
    Input: sentence1 = ["I","love","leetcode"],
           sentence2 = ["I","love","onepiece"],
           similarPairs = [["manga","hunterXhunter"],["platform","anime"],["leetcode","platform"],["anime","manga"]]
    Output: false
    Explanation: "leetcode" is not similar to "onepiece".

    Constraints:
    * 1 <= sentence1.length, sentence2.length <= 1000
    * 1 <= sentence1[i].length, sentence2[i].length <= 20
    * sentence1[i] and sentence2[i] consist of lower-case and upper-case English letters.
    * 0 <= similarPairs.length <= 2000
    * similarPairs[i].length == 2
    * 1 <= xi.length, yi.length <= 20
    * xi and yi consist of English letters.

    class UnionFind {
        unordered_map<string, string> parent;
        unordered_map<string, int> rank;
    public:
        string find(string p) {
            if (!parent.count(p)) {
                parent[p] = p;
                rank[p] = 1;
            }
            if (p != parent[p])
                parent[p] = find(parent[p]);
            return parent[p];
        }

        bool connect(string p, string q) {
            string prt = find(p), qrt = find(q);
            if (prt == qrt) return false;
            if (rank[prt] > rank[qrt]) swap(prt, qrt);
            parent[prt] = qrt;
            rank[qrt] += rank[prt];
            return true;
        }
    };*/

    bool areSentencesSimilarTwo(vector<string>& sentence1, vector<string>& sentence2, vector<vector<string>>& similarPairs) {
        if (sentence1.size() != sentence2.size()) return false;

        UnionFind *uf = new UnionFind();
        for (auto& sp : similarPairs)
            uf->connect(sp[0], sp[1]);

        bool ans = true;
        for (int i = 0; i < sentence1.size(); ++i)
            if (uf->find(sentence1[i]) != uf->find(sentence2[i])) {
                ans = false;
                break;
            }
        delete uf;
        return ans;
    }


    /*739. Daily Temperatures (Medium)
    Given an array of integers temperatures represents the daily temperatures,
    return an array answer such that answer[i] is the number of days you have
    to wait after the ith day to get a warmer temperature. If there is no
    future day for which this is possible, keep answer[i] == 0 instead.

    Example 1:
    Input: temperatures = [73,74,75,71,69,72,76,73]
    Output: [1,1,4,2,1,1,0,0]

    Example 2:
    Input: temperatures = [30,40,50,60]
    Output: [1,1,1,0]

    Example 3:
    Input: temperatures = [30,60,90]
    Output: [1,1,0]

    Constraints:
    * 1 <= temperatures.length <= 10^5
    * 30 <= temperatures[i] <= 100*/

    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> stk;
        for (int i = 0; i < n; ++i) {
            while (stk.size() && temperatures[stk.top()] < temperatures[i]) {
                int ii = stk.top(); stk.pop();
                ans[ii] = i - ii;
            }
            stk.push(i);
        }
        return ans;
    }


    /*740. Delete and Earn (Medium)
    You are given an integer array nums. You want to maximize the number of
    points you get by performing the following operation any number of times:
    * Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you
      must delete every element equal to nums[i] - 1 and every element equal
      to nums[i] + 1.
    Return the maximum number of points you can earn by applying the above
    operation some number of times.

    Example 1:
    Input: nums = [3,4,2]
    Output: 6
    Explanation: You can perform the following operations:
                 - Delete 4 to earn 4 points. Consequently, 3 is also deleted.
                   nums = [2].
                 - Delete 2 to earn 2 points. nums = [].
                 You earn a total of 6 points.

    Example 2:
    Input: nums = [2,2,3,3,3,4]
    Output: 9
    Explanation: You can perform the following operations:
                 - Delete a 3 to earn 3 points. All 2's and 4's are also
                   deleted. nums = [3,3].
                 - Delete a 3 again to earn 3 points. nums = [3].
                 - Delete a 3 once more to earn 3 points. nums = [].
                 You earn a total of 9 points.

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= nums[i] <= 10^4*/

    int deleteAndEarn(vector<int>& nums) {
        map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        int f0 = 0, f1 = 0, prev = -1;
        for (auto& [k, v] : freq) {
            int f2 = prev + 1 == k ? max(f0+k*v, f1) : f1+k*v;
            f0 = f1;
            f1 = f2;
            prev = k;
        }
        return f1;
    }


    /*742. Closest Leaf in a Binary Tree (Medium)
    Given the root of a binary tree where every node has a unique value and a
    target integer k, return the value of the nearest leaf node to the target k
    in the tree. Nearest to a leaf means the least number of edges traveled on
    the binary tree to reach any leaf of the tree. Also, a node is called a
    leaf if it has no children.

    Example 1:
    Input: root = [1,3,2], k = 1
    Output: 2
    Explanation: Either 2 or 3 is the nearest leaf node to the target of 1.

    Example 2:
    Input: root = [1], k = 1
    Output: 1
    Explanation: The nearest leaf node is the root node itself.

    Example 3:
    Input: root = [1,2,3,4,null,null,null,5,null,6], k = 2
    Output: 3
    Explanation: The leaf node with value 3 (and not the leaf node with value 6)
                 is nearest to the node with value 2.

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * 1 <= Node.val <= 1000
    * All the values of the tree are unique.
    * There exist some node in the tree where Node.val == k.*/

    int findClosestLeaf(TreeNode* root, int k) {
        unordered_map<TreeNode*, TreeNode*> mp = {{root, nullptr}};
        stack<TreeNode*> stk; stk.push(root);

        TreeNode* source = nullptr;
        while (stk.size()) {
            TreeNode* node = stk.top(); stk.pop();
            if (node->val == k) source = node;
            if (node->left) {
                mp[node->left] = node;
                stk.push(node->left);
            }
            if (node->right) {
                mp[node->right] = node;
                stk.push(node->right);
            }
        }

        queue<TreeNode*> q; q.push(source);
        unordered_set<TreeNode*> seen;
        while (q.size()) {
            TreeNode* node = q.front(); q.pop();
            if (!node->left && !node->right) return node->val;
            for (auto& x : {node->left, node->right, mp[node]})
                if (x && !seen.count(x)) {
                    seen.insert(x);
                    q.push(x);
                }
        }
        return -1;
    }


    /*744. Find Smallest Letter Greater Than Target (Easy)
    Given a list of sorted characters letters containing only lowercase
    letters, and given a target letter target, find the smallest element in the
    list that is larger than the given target. Letters also wrap around. For
    example, if the target is target = 'z' and letters = ['a', 'b'], the answer
    is 'a'.

    Examples:
    Input: letters = ["c", "f", "j"]
           target = "a"
    Output: "c"

    Input: letters = ["c", "f", "j"]
           target = "c"
    Output: "f"

    Input: letters = ["c", "f", "j"]
           target = "d"
    Output: "f"

    Input: letters = ["c", "f", "j"]
           target = "g"
    Output: "j"

    Input: letters = ["c", "f", "j"]
           target = "j"
    Output: "c"

    Input: letters = ["c", "f", "j"]
           target = "k"
    Output: "c"

    Note:
    * letters has a length in range [2, 10000].
    * letters consists of lowercase letters, and contains at least 2 unique
      letters.
    * target is a lowercase letter.*/

    char nextGreatestLetter(vector<char>& letters, char target) {
        int lo = 0, hi = letters.size();
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (letters[mid] <= target) lo = mid + 1;
            else hi = mid;
        }
        return letters[lo % letters.size()];
    }


    /*746. Min Cost Climbing Stairs (Easy)
    You are given an integer array cost where cost[i] is the cost of ith step
    on a staircase. Once you pay the cost, you can either climb one or two
    steps. You can either start from the step with index 0, or the step with
    index 1. Return the minimum cost to reach the top of the floor.

    Example 1:
    Input: cost = [10,15,20]
    Output: 15
    Explanation: Cheapest is: start on cost[1], pay that cost, and go to the
                 top.

    Example 2:
    Input: cost = [1,100,1,1,1,100,1,1,100,1]
    Output: 6
    Explanation: Cheapest is: start on cost[0], and only step on 1s, skipping
                 cost[3].

    Constraints:
    * 2 <= cost.length <= 1000
    * 0 <= cost[i] <= 999*/

    int minCostClimbingStairs(vector<int>& cost) {
        int f0 = cost[0], f1 = cost[1];
        for (int i = 2; i < cost.size(); ++i) {
            swap(f0, f1);
            f1 = min(f0, f1) + cost[i];
        }
        return min(f0, f1);
    }


    /*748. Shortest Completing Word (Easy)
    Given a string licensePlate and an array of strings words, find the
    shortest completing word in words. A completing word is a word that
    contains all the letters in licensePlate. Ignore numbers and spaces in
    licensePlate, and treat letters as case insensitive. If a letter appears
    more than once in licensePlate, then it must appear in the word the same
    number of times or more. For example, if licensePlate = "aBc 12c", then it
    contains letters 'a', 'b' (ignoring case), and 'c' twice. Possible
    completing words are "abccdef", "caaacab", and "cbca". Return the shortest
    completing word in words. It is guaranteed an answer exists. If there are
    multiple shortest completing words, return the first one that occurs in
    words.

    Example 1:
    Input: licensePlate = "1s3 PSt",
           words = ["step","steps","stripe","stepple"]
    Output: "steps"
    Explanation: licensePlate contains letters 's', 'p', 's' (ignoring case),
                 and 't'. "step" contains 't' and 'p', but only contains 1 's'.
                 "steps" contains 't', 'p', and both 's' characters. "stripe"
                 is missing an 's'. "stepple" is missing an 's'. Since "steps"
                 is the only word containing all the letters, that is the
                 answer.

    Example 2:
    Input: licensePlate = "1s3 456",
           words = ["looks","pest","stew","show"]
    Output: "pest"
    Explanation: licensePlate only contains the letter 's'. All the words
                 contain 's', but among these "pest", "stew", and "show" are
                 shortest. The answer is "pest" because it is the word that
                 appears earliest of the 3.

    Example 3:
    Input: licensePlate = "Ah71752",
           words = ["suggest","letter","of","husband","easy","education","drug","prevent","writer","old"]
    Output: "husband"

    Example 4:
    Input: licensePlate = "OgEu755",
           words = ["enough","these","play","wide","wonder","box","arrive","money","tax","thus"]
    Output: "enough"

    Example 5:
    Input: licensePlate = "iMSlpe4",
           words = ["claim","consumer","student","camera","public","never","wonder","simple","thought","use"]
    Output: "simple"

    Constraints:
    * 1 <= licensePlate.length <= 7
    * licensePlate contains digits, letters (uppercase or lowercase), or space ' '.
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 15
    * words[i] consists of lower case English letters.*/

    string shortestCompletingWord(string licensePlate, vector<string>& words) {
        vector<int> freq(26);
        for (auto& ch : licensePlate)
            if (isalpha(ch)) ++freq[tolower(ch) - 'a'];

        string ans;
        for (auto& word : words) {
            vector<int> temp = freq;
            for (auto& ch : word) --temp[ch - 'a'];
            if ((ans.empty() || word.size() < ans.size()) && all_of(temp.begin(), temp.end(), [&](int x) {return x <= 0;})) ans = word;
        }
        return ans;
    }


    /*749. Contain Virus (Hard)
    A virus is spreading rapidly, and your task is to quarantine the infected
    area by installing walls. The world is modeled as an m x n binary grid
    isInfected, where isInfected[i][j] == 0 represents uninfected cells, and
    isInfected[i][j] == 1 represents cells contaminated with the virus. A wall
    (and only one wall) can be installed between any two 4-directionally
    adjacent cells, on the shared boundary. Every night, the virus spreads to
    all neighboring cells in all four directions unless blocked by a wall.
    Resources are limited. Each day, you can install walls around only one
    region (i.e., the affected area (continuous block of infected cells) that
    threatens the most uninfected cells the following night). There will never
    be a tie. Return the number of walls used to quarantine all the infected
    regions. If the world will become fully infected, return the number of
    walls used.

    Example 1:
    Input: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]
    Output: 10
    Explanation: There are 2 contaminated regions. On the first day, add 5
                 walls to quarantine the viral region on the left. On the
                 second day, add 5 walls to quarantine the viral region on the
                 right. The virus is fully contained.

    Example 2:
    Input: isInfected = [[1,1,1],[1,0,1],[1,1,1]]
    Output: 4
    Explanation: Even though there is only one cell saved, there are 4 walls
                 built. Notice that walls are only built on the shared boundary
                 of two different cells.

    Example 3:
    Input: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]
    Output: 13
    Explanation: The region on the left only builds two new walls.

    Constraints:
    * m == isInfected.length
    * n == isInfected[i].length
    * 1 <= m, n <= 50
    * isInfected[i][j] is either 0 or 1.
    * There is always a contiguous viral region throughout the described
      process that will infect strictly more uncontaminated squares in the next
      round.*/

    int containVirus(vector<vector<int>>& isInfected) {
        int ans = 0, m = isInfected.size(), n = isInfected[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        while (true) {
            vector<vector<pair<int, int>>> regions;
            vector<unordered_set<int>> fronts;
            vector<int> walls;
            unordered_set<int> seen;
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    int k = i*n+j;
                    if (isInfected[i][j] == 1 && !seen.count(k)) {
                        seen.insert(k);
                        stack<pair<int, int>> stk; stk.emplace(i, j);
                        regions.push_back({}); regions.back().emplace_back(i, j);
                        fronts.push_back({});
                        walls.push_back(0);
                        while (stk.size()) {
                            auto [i, j] = stk.top(); stk.pop();
                            for (int d = 0; d < 4; ++d) {
                                int ii = i + dir[d], jj = j + dir[d+1];
                                if (0 <= ii && ii < m && 0 <= jj && jj < n) {
                                    int kk = ii*n + jj;
                                    if (isInfected[ii][jj] == 1 && !seen.count(kk)) {
                                        seen.insert(kk);
                                        stk.emplace(ii, jj);
                                        regions.back().emplace_back(ii, jj);
                                    } else if (isInfected[ii][jj] == 0) {
                                        fronts.back().insert(kk);
                                        ++walls.back();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (regions.empty()) break;
            int idx = max_element(fronts.begin(), fronts.end(), [&](auto& lhs, auto& rhs) { return lhs.size() < rhs.size(); }) - fronts.begin();
            ans += walls[idx];
            for (int i = 0; i < regions.size(); ++i)
                if (i == idx)
                    for (auto& [r, c] : regions[i]) isInfected[r][c] = -1;
                else
                    for (auto& k : fronts[i]) isInfected[k/n][k%n] = 1;
        }
        return ans;
    }


    /*751. IP to CIDR (Medium)
    An IP address is a formatted 32-bit unsigned integer where each group of 8
    bits is printed as a decimal number and the dot character '.' splits the
    groups. For example, the binary number 00001111 10001000 11111111 01101011
    (spaces added for clarity) formatted as an IP address would be
    "15.136.255.107". A CIDR block is a format used to denote a specific set of
    IP addresses. It is a string consisting of a base IP address, followed by a
    slash, followed by a prefix length k. The addresses it covers are all the
    IPs whose first k bits are the same as the base IP address. For example,
    "123.45.67.89/20" is a CIDR block with a prefix length of 20. Any IP
    address whose binary representation matches
    01111011 00101101 0100xxxx xxxxxxxx, where x can be either 0 or 1, is in
    the set covered by the CIDR block. You are given a start IP address ip and
    the number of IP addresses we need to cover n. Your goal is to use as few
    CIDR blocks as possible to cover all the IP addresses in the inclusive
    range [ip, ip + n - 1] exactly. No other IP addresses outside of the range
    should be covered. Return the shortest list of CIDR blocks that covers the
    range of IP addresses. If there are multiple answers, return any of them.

    Example 1:
    Input: ip = "255.0.0.7", n = 10
    Output: ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
    Explanation: The IP addresses that need to be covered are:
                 - 255.0.0.7  -> 11111111 00000000 00000000 00000111
                 - 255.0.0.8  -> 11111111 00000000 00000000 00001000
                 - 255.0.0.9  -> 11111111 00000000 00000000 00001001
                 - 255.0.0.10 -> 11111111 00000000 00000000 00001010
                 - 255.0.0.11 -> 11111111 00000000 00000000 00001011
                 - 255.0.0.12 -> 11111111 00000000 00000000 00001100
                 - 255.0.0.13 -> 11111111 00000000 00000000 00001101
                 - 255.0.0.14 -> 11111111 00000000 00000000 00001110
                 - 255.0.0.15 -> 11111111 00000000 00000000 00001111
                 - 255.0.0.16 -> 11111111 00000000 00000000 00010000
                 The CIDR block "255.0.0.7/32" covers the first address. The
                 CIDR block "255.0.0.8/29" covers the middle 8 addresses
                 (binary format of 11111111 00000000 00000000 00001xxx). The
                 CIDR block "255.0.0.16/32" covers the last address. Note that
                 while the CIDR block "255.0.0.0/28" does cover all the
                 addresses, it also includes addresses outside of the range, so
                 we cannot use it.

    Example 2:
    Input: ip = "117.145.102.62", n = 8
    Output: ["117.145.102.62/31","117.145.102.64/30","117.145.102.68/31"]

    Constraints:
    * 7 <= ip.length <= 15
    * ip is a valid IPv4 on the form "a.b.c.d" where a, b, c, and d are
      integers in the range [0, 255].
    * 1 <= n <= 1000
    * Every implied address ip + x (for x < n) will be a valid IPv4 address.*/

    vector<string> ipToCIDR(string ip, int n) {
        int val = 0;
        istringstream iss(ip);
        string buff;
        while (getline(iss, buff, '.'))
            val = (val << 8) + stoi(buff);
        vector<string> ans;
        for (int i = 0; n; n -= 1<<i, val += 1<<i) {
            for (i = 0; i < 32 && !(val & 1<<i) && (1<<(i+1)) <= n; ++i);
            string elem;
            for (int i = 24; i >= 0; i -= 8) {
                elem += to_string(val >> i & 0xFF);
                if (i) elem.push_back('.');
            }
            ans.push_back(elem + "/" + to_string(32-i));
        }
        return ans;
    }


    /*753. Cracking the Safe (Hard)
    There is a box protected by a password. The password is a sequence of n
    digits where each digit can be in the range [0, k - 1]. While entering a
    password, the last n digits entered will automatically be matched against
    the correct password. For example, assuming the correct password is "345",
    if you type "012345", the box will open because the correct password
    matches the suffix of the entered password. Return any password of minimum
    length that is guaranteed to open the box at some point of entering it.

    Example 1:
    Input: n = 1, k = 2
    Output: "10"
    Explanation: "01" will be accepted too.

    Example 2:
    Input: n = 2, k = 2
    Output: "01100"
    Explanation: "01100", "10011", "11001" will be accepted too.

    Constraints:
    * 1 <= n <= 4
    * 1 <= k <= 10
    * 1 <= kn <= 4096*/

    string crackSafe(int n, int k) {
        string ans; // De Bruijn sequence
        if (n == 1) {
            for (int x = k-1; x >= 0; --x)
                ans.push_back(x + '0');
        } else {
            unordered_map<string, int> mp;

            /* Return Eulerian path via Hierholzer algo */
            function<void(string)> fn = [&](string s) {
                while (mp[s]++ < k)
                    fn(s.substr(1) + to_string(mp[s]-1));
                if (ans.empty()) ans += s;
                else ans.push_back(s[0]);
            };

            fn(string(n-1, '0'));
        }
        return ans;
    }


    /*755. Pour Water (Medium)
    You are given an elevation map represents as an integer array heights where
    heights[i] representing the height of the terrain at index i. The width at
    each index is 1. You are also given two integers volume and k. volume units
    of water will fall at index k. Water first drops at the index k and rests
    on top of the highest terrain or water at that index. Then, it flows
    according to the following rules:
    * If the droplet would eventually fall by moving left, then move left.
    * Otherwise, if the droplet would eventually fall by moving right, then
      move right.
    * Otherwise, rise to its current position.
    Here, "eventually fall" means that the droplet will eventually be at a
    lower level if it moves in that direction. Also, level means the height of
    the terrain plus any water in that column. We can assume there is
    infinitely high terrain on the two sides out of bounds of the array. Also,
    there could not be partial water being spread out evenly on more than one
    grid block, and each unit of water has to be in exactly one block.

    Example 1:
    Input: heights = [2,1,1,2,1,2,2], volume = 4, k = 3
    Output: [2,2,2,3,2,2,2]
    Explanation: The first drop of water lands at index k = 3. When moving left
                 or right, the water can only move to the same level or a lower
                 level. (By level, we mean the total height of the terrain plus
                 any water in that column.) Since moving left will eventually
                 make it fall, it moves left. (A droplet "made to fall" means
                 go to a lower height than it was at previously.) Since moving
                 left will not make it fall, it stays in place. The next
                 droplet falls at index k = 3. Since the new droplet moving
                 left will eventually make it fall, it moves left. Notice that
                 the droplet still preferred to move left, even though it could
                 move right (and moving right makes it fall quicker.) The third
                 droplet falls at index k = 3. Since moving left would not
                 eventually make it fall, it tries to move right. Since moving
                 right would eventually make it fall, it moves right. Finally,
                 the fourth droplet falls at index k = 3. Since moving left
                 would not eventually make it fall, it tries to move right.
                 Since moving right would not eventually make it fall, it stays
                 in place.

    Example 2:
    Input: heights = [1,2,3,4], volume = 2, k = 2
    Output: [2,3,3,4]
    Explanation: The last droplet settles at index 1, since moving further left
                 would not cause it to eventually fall to a lower height.

    Example 3:
    Input: heights = [3,1,3], volume = 5, k = 1
    Output: [4,4,4]

    Constraints:
    * 1 <= heights.length <= 100
    * 0 <= heights[i] <= 99
    * 0 <= volume <= 2000
    * 0 <= k < heights.length*/

    vector<int> pourWater(vector<int>& heights, int volume, int k) {
        stack<int> left, right;
        int lo = k, hi = k, i = 0;

        while (volume--) {

            for (; lo && heights[lo-1] <= heights[lo]; --lo)
                if (heights[lo-1] < heights[lo]) left.push(lo-1);

            for (; hi+1 < heights.size() && heights[hi] >= heights[hi+1]; ++hi)
                if (heights[hi] > heights[hi+1]) right.push(hi+1);

            if (left.size()) {
                i = left.top();
                ++heights[i];
                if (heights[i] == heights[i+1]) left.pop();
                if (lo <= i-1) left.push(i-1);
            } else if (right.size()) {
                i = right.top();
                ++heights[i];
                if (heights[i-1] == heights[i]) right.pop();
                if (i+1 <= hi) right.push(i+1);
            } else {
                ++heights[k];
                if (k && heights[k-1] < heights[k]) left.push(k-1);
                if (k+1 < heights.size() && heights[k] > heights[k+1]) right.push(k+1);
            }
        }
        return heights;
    }


    /*757. Set Intersection Size At Least Two (Hard)
    An integer interval [a, b] (for integers a < b) is a set of all consecutive
    integers from a to b, including a and b. Find the minimum size of a set S
    such that for every integer interval A in intervals, the intersection of S
    with A has a size of at least two.

    Example 1:
    Input: intervals = [[1,3],[1,4],[2,5],[3,5]]
    Output: 3
    Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are
                 at least 2 elements from S in the interval. Also, there isn't
                 a smaller size set that fulfills the above condition. Thus, we
                 output the size of this set, which is 3.

    Example 2:
    Input: intervals = [[1,2],[2,3],[2,4],[4,5]]
    Output: 5
    Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.

    Constraints:
    * 1 <= intervals.length <= 3000
    * intervals[i].length == 2
    * 0 <= ai < bi <= 10^8*/

    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](auto& lhs, auto& rhs) {return lhs[1] < rhs[1] || (lhs[1] == rhs[1] && lhs[0] > rhs[0]);});
        int ans = 0, y0 = -1, y1 = -1;
        for (auto& interval : intervals) {
            int x = interval[0], y = interval[1];
            if (y0 < x && x <= y1) ++ans, y0 = y1, y1 = y;
            else if (y1 < x) ans += 2, y0 = y-1, y1 = y;
        }
        return ans;
    }


    /*758. Bold Words in String (Medium)
    Given an array of keywords words and a string s, make all appearances of
    all keywords words[i] in s bold. Any letters between <b> and </b> tags
    become bold. Return s after adding the bold tags. The returned string
    should use the least number of tags possible, and the tags should form a
    valid combination.

    Example 1:
    Input: words = ["ab","bc"], s = "aabcd"
    Output: "a<b>abc</b>d"
    Explanation: Note that returning "a<b>a<b>b</b>c</b>d" would use more tags,
                 so it is incorrect.

    Example 2:
    Input: words = ["ab","cb"], s = "aabcd"
    Output: "a<b>ab</b>cd"

    Constraints:
    * 1 <= s.length <= 500
    * 0 <= words.length <= 50
    * 1 <= words[i].length <= 10
    * s and words[i] consist of lowercase English letters.

    Note: This question is the same as 616:
          https://leetcode.com/problems/add-bold-tag-in-string/*/

    string boldWords(vector<string>& words, string s) {
        int n = s.size();
        vector<int> line(n+1);
        for (auto& word : words)
            for (int k = -1; true; ) {
                k = s.find(word, ++k);
                if (k == string::npos) break;
                ++line[k];
                --line[k+word.size()];
            }
        string ans;
        for (int i = 0, prefix = 0; i < s.size(); ++i) {
            if (!prefix && prefix+line[i]) ans += "<b>";
            ans += s[i];
            prefix += line[i];
            if (prefix && !(prefix+line[i+1])) ans += "</b>";
        }
        return ans;
    }


    /*759. Employee Free Time (Hard)
    We are given a list schedule of employees, which represents the working
    time for each employee. Each employee has a list of non-overlapping
    Intervals, and these intervals are in sorted order. Return the list of
    finite intervals representing common, positive-length free time for all
    employees, also in sorted order. (Even though we are representing Intervals
    in the form [x, y], the objects inside are Intervals, not lists or arrays.
    For example, schedule[0][0].start = 1, schedule[0][0].end = 2, and
    schedule[0][0][0] is not defined).  Also, we wouldn't include intervals
    like [5, 5] in our answer, as they have zero length.

    Example 1:
    Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
    Output: [[3,4]]
    Explanation: There are a total of three employees, and all common free time
                 intervals would be [-inf, 1], [3, 4], [10, inf]. We discard
                 any intervals that contain inf as they aren't finite.

    Example 2:
    Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
    Output: [[5,6],[7,9]]

    Constraints:
    * 1 <= schedule.length , schedule[i].length <= 50
    * 0 <= schedule[i].start < schedule[i].end <= 10^8*/

    vector<Interval> employeeFreeTime(vector<vector<Interval>> schedule) {
        vector<pair<int, int>> line;
        for (auto& elem : schedule)
            for (auto& x : elem) {
                line.emplace_back(x.start, 1);
                line.emplace_back(x.end, -1);
            }
        sort(line.begin(), line.end());
        vector<Interval> ans;
        int prev = INT_MIN, prefix = 0;
        for (int i = 0; i < line.size(); ) {
            int k = line[i].first;
            if (prefix == 0 && prev > INT_MIN) ans.emplace_back(prev, k);
            for (int ii = i; i < line.size() && line[ii].first == line[i].first; ++i) prefix += line[i].second;
            if (prefix == 0) prev = k;
        }
        return ans;
    }


    /*762. Prime Number of Set Bits in Binary Representation (Easy)
    Given two integers L and R, find the count of numbers in the range [L, R]
    (inclusive) having a prime number of set bits in their binary representation.
    (Recall that the number of set bits an integer has is the number of 1s
    present when written in binary. For example, 21 written in binary is 10101
    which has 3 set bits. Also, 1 is not a prime.)

    Example 1:
    Input: L = 6, R = 10
    Output: 4
    Explanation:
    6 -> 110 (2 set bits, 2 is prime)
    7 -> 111 (3 set bits, 3 is prime)
    9 -> 1001 (2 set bits , 2 is prime)
    10->1010 (2 set bits , 2 is prime)

    Example 2:
    Input: L = 10, R = 15
    Output: 5
    Explanation:
    10 -> 1010 (2 set bits, 2 is prime)
    11 -> 1011 (3 set bits, 3 is prime)
    12 -> 1100 (2 set bits, 2 is prime)
    13 -> 1101 (3 set bits, 3 is prime)
    14 -> 1110 (3 set bits, 3 is prime)
    15 -> 1111 (4 set bits, 4 is not prime)

    Note:
    * L, R will be integers L <= R in the range [1, 10^6].
    * R - L will be at most 10000.*/

    int countPrimeSetBits(int L, int R) {
        int ans = 0;
        for (int x = L; x <= R; ++x) {
            int cnt = __builtin_popcount(x);
            if (cnt > 1) {
                int d = 2;
                for (; d <= sqrt(cnt); ++d) {
                    if (cnt % d == 0) break;
                }
                if (d > sqrt(cnt)) ++ans;
            }
        }
        return ans;
    }


    /*763. Partition Labels (Medium)
    You are given a string s. We want to partition the string into as many
    parts as possible so that each letter appears in at most one part. Return a
    list of integers representing the size of these parts.

    Example 1:
    Input: s = "ababcbacadefegdehijhklij"
    Output: [9,7,8]
    Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a
                 partition so that each letter appears in at most one part. A
                 partition like "ababcbacadefegde", "hijhklij" is incorrect,
                 because it splits s into less parts.

    Example 2:
    Input: s = "eccbbbbdec"
    Output: [10]

    Constraints:
    * 1 <= s.length <= 500
    * s consists of lowercase English letters.*/

    vector<int> partitionLabels(string s) {
        unordered_map<char, int> last;
        for (int i = 0; i < s.size(); ++i) last[s[i]] = i;
        vector<int> ans;
        for (int i = 0, lo = -1, hi = 0; i < s.size(); ++i) {
            hi = max(hi, last[s[i]]);
            if (i == hi) {
                ans.push_back(hi - lo);
                lo = hi;
            }
        }
        return ans;
    }


    /*764. Largest Plus Sign (Medium)
    You are given an integer n. You have an n x n binary grid grid with all
    values initially 1's except for some indices given in the array mines. The
    ith element of the array mines is defined as mines[i] = [xi, yi] where
    grid[xi][yi] == 0. Return the order of the largest axis-aligned plus sign
    of 1's contained in grid. If there is none, return 0. An axis-aligned plus
    sign of 1's of order k has some center grid[r][c] == 1 along with four arms
    of length k - 1 going up, down, left, and right, and made of 1's. Note that
    there could be 0's or 1's beyond the arms of the plus sign, only the
    relevant area of the plus sign is checked for 1's.

    Example 1:
    Input: n = 5, mines = [[4,2]]
    Output: 2
    Explanation: In the above grid, the largest plus sign can only be of order
                 2. One of them is shown.

    Example 2:
    Input: n = 1, mines = [[0,0]]
    Output: 0
    Explanation: There is no plus sign, so return 0.

    Constraints:
    * 1 <= n <= 500
    * 1 <= mines.length <= 5000
    * 0 <= xi, yi < n
    * All the pairs (xi, yi) are unique.*/

    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
        vector<vector<int>> dp(n, vector<int>(n, n));
        for (auto& x : mines) dp[x[0]][x[1]] = 0;

        for (int i = 0; i < n; ++i)
            for (int j = 0, dd = 0, uu = 0, ll = 0, rr = 0; j < n; ++j) {
                dp[i][j] = min(dp[i][j], ll = dp[i][j] == 0 ? 0 : ll+1);
                dp[j][i] = min(dp[j][i], dd = dp[j][i] == 0 ? 0 : dd + 1);
                dp[i][n-1-j] = min(dp[i][n-1-j], rr = dp[i][n-1-j] == 0 ? 0 : rr + 1);
                dp[n-1-j][i] = min(dp[n-1-j][i], uu = dp[n-1-j][i] == 0 ? 0 : uu + 1);
            }

        int ans = 0;
        for (int i = 0; i < n; ++i)
            ans = max(ans, *max_element(dp[i].begin(), dp[i].end()));
        return ans;
    }


    /*766. Toeplitz Matrix (Easy)
    Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise,
    return false. A matrix is Toeplitz if every diagonal from top-left to
    bottom-right has the same elements.

    Example 1:
    Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
    Output: true
    Explanation: In the above grid, the diagonals are:
    "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
    In each diagonal all elements are the same, so the answer is True.

    Example 2:
    Input: matrix = [[1,2],[2,2]]
    Output: false
    Explanation: The diagonal "[1, 2]" has different elements.

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 20
    * 0 <= matrix[i][j] <= 99

    Follow up:
    * What if the matrix is stored on disk, and the memory is limited such that
      you can only load at most one row of the matrix into the memory at once?
    * What if the matrix is so large that you can only load up a partial row
      into the memory at once?*/

    bool isToeplitzMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                if (matrix[i-1][j-1] != matrix[i][j]) return false;
            }
        }
        return true;
    }


    /*768. Max Chunks To Make Sorted II (Hard)
    You are given an integer array arr. We split arr into some number of chunks
    (i.e., partitions), and individually sort each chunk. After concatenating
    them, the result should equal the sorted array. Return the largest number
    of chunks we can make to sort the array.

    Example 1:
    Input: arr = [5,4,3,2,1]
    Output: 1
    Explanation: Splitting into two or more chunks will not return the required
                 result. For example, splitting into [5, 4], [3, 2, 1] will
                 result in [4, 5, 1, 2, 3], which isn't sorted.

    Example 2:
    Input: arr = [2,1,3,4,4]
    Output: 4
    Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4].
                 However, splitting into [2, 1], [3], [4], [4] is the highest
                 number of chunks possible.

    Constraints:
    * 1 <= arr.length <= 2000
    * 0 <= arr[i] <= 10^8*/

    int maxChunksToSorted(vector<int>& arr) {
        stack<int> stk;
        for (auto& x : arr) {
            int most = x;
            while (stk.size() && stk.top() > x) {
                most = max(most, stk.top());
                stk.pop();
            }
            stk.push(most);
        }
        return stk.size();
    }


    /*772. Basic Calculator III (Hard)
    Implement a basic calculator to evaluate a simple expression string. The
    expression string contains only non-negative integers, '+', '-', '*', '/'
    operators, and open '(' and closing parentheses ')'. The integer division
    should truncate toward zero. You may assume that the given expression is
    always valid. All intermediate results will be in the range of
    [-2^31, 2^31 - 1]. Note: You are not allowed to use any built-in function
    which evaluates strings as mathematical expressions, such as eval().

    Example 1:
    Input: s = "1+1"
    Output: 2

    Example 2:
    Input: s = "6-4/2"
    Output: 4

    Example 3:
    Input: s = "2*(5+5*2)/3+(6/2+8)"
    Output: 21

    Constraints:
    * 1 <= s <= 10^4
    * s consists of digits, '+', '-', '*', '/', '(', and ')'.
    * s is a valid expression.*/

    int calculate(string s) {
        s = "(" + s + ")";
        unordered_map<char, int> precedence = {{'(', 0}, {')', 1}, {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
        stack<char> ops;
        vector<string> postfix;
        for (int i = 0, v = 0; i < s.size(); ++i) {
            if ('0' <= s[i] && s[i] <= '9') v = 10*v + s[i] - '0';
            else {
                if (i && '0' <= s[i-1] && s[i-1] <= '9') postfix.push_back(to_string(v));
                v = 0;
                if (s[i] == '(') ops.push(s[i]);
                else {
                    while (ops.size() && precedence[ops.top()] >= precedence[s[i]]) {
                        postfix.push_back(string(1, ops.top())); ops.pop();
                    }
                    if (s[i] == ')') ops.pop();
                    else ops.push(s[i]);
                }
            }
        }
        stack<int> stk;
        for (auto& v : postfix) {
            if (v == "+" || v == "-" || v == "*" || v == "/") {
                int y = stk.top(); stk.pop();
                int x = stk.top(); stk.pop();
                if (v == "+") x += y;
                else if (v == "-") x -= y;
                else if (v == "*") x *= y;
                else x /= y;
                stk.push(x);
            } else stk.push(stoi(v));
        }
        return stk.top();
    }


    /*774. Minimize Max Distance to Gas Station (Hard)
    You are given an integer array stations that represents the positions of
    the gas stations on the x-axis. You are also given an integer k. You should
    add k new gas stations. You can add the stations anywhere on the x-axis,
    and not necessarily on an integer position. Let penalty() be the maximum
    distance between adjacent gas stations after adding the k new stations.
    Return the smallest possible value of penalty(). Answers within 10^-6 of
    the actual answer will be accepted.

    Example 1:
    Input: stations = [1,2,3,4,5,6,7,8,9,10], k = 9
    Output: 0.50000

    Example 2:
    Input: stations = [23,24,36,39,46,56,57,65,84,98], k = 1
    Output: 14.00000

    Constraints:
    * 10 <= stations.length <= 2000
    * 0 <= stations[i] <= 10^8
    * stations is sorted in a strictly increasing order.
    * 1 <= k <= 10^6*/

    double minmaxGasDist(vector<int>& stations, int k) {
        int n = stations.size();
        double lo = 0, hi = stations[n-1] - stations[0];
        while (lo + 1e-6 < hi) {
            double mid = (lo + hi)/2;
            int kk = 0;
            for (int i = 0; i < n-1; ++i)
                kk += int((stations[i+1]-stations[i])/mid);
            if (kk <= k) hi = mid;
            else lo = mid;
        }
        return lo;
    }


    /*776. Split BST (Medium)
    Given the root of a binary search tree (BST) and an integer target, split
    the tree into two subtrees where one subtree has nodes that are all smaller
    or equal to the target value, while the other subtree has all nodes that
    are greater than the target value. It Is not necessarily the case that the
    tree contains a node with the value target. Additionally, most of the
    structure of the original tree should remain. Formally, for any child c
    with parent p in the original tree, if they are both in the same subtree
    after the split, then node c should still have the parent p. Return an
    array of the two roots of the two subtrees.

    Example 1:
    Input: root = [4,2,6,1,3,5,7], target = 2
    Output: [[2,1],[4,3,6,null,null,5,7]]

    Example 2:
    Input: root = [1], target = 1
    Output: [[1],[]]

    Constraints:
    * The number of nodes in the tree is in the range [1, 50].
    * 0 <= Node.val, target <= 1000*/

    vector<TreeNode*> splitBST(TreeNode* root, int target) {
        if (!root) return {nullptr, nullptr};
        if (root->val <= target) {
            auto nodes = splitBST(root->right, target);
            root->right = nodes[0];
            return {root, nodes[1]};
        } else {
            auto nodes = splitBST(root->left, target);
            root->left = nodes[1];
            return {nodes[0], root};
        }
    }


    /*778. Swim in Rising Water (Hard)
    On an N x N grid, each square grid[i][j] represents the elevation at that
    point (i,j). Now rain starts to fall. At time t, the depth of the water
    everywhere is t. You can swim from a square to another 4-directionally
    adjacent square if and only if the elevation of both squares individually
    are at most t. You can swim infinite distance in zero time. Of course, you
    must stay within the boundaries of the grid during your swim. You start at
    the top left square (0, 0). What is the least time until you can reach the
    bottom right square (N-1, N-1)?

    Example 1:
    Input: [[0,2],[1,3]]
    Output: 3
    Explanation: At time 0, you are in grid location (0, 0). You cannot go
                 anywhere else because 4-directionally adjacent neighbors have
                 a higher elevation than t = 0. You cannot reach point (1, 1)
                 until time 3. When the depth of water is 3, we can swim
                 anywhere inside the grid.

    Example 2:
    Input: [[ 0, 1, 2, 3, 4],
            [24,23,22,21, 5],
            [12,13,14,15,16],
            [11,17,18,19,20],
            [10, 9, 8, 7, 6]]
    Output: 16
    Explanation:
     0  1  2  3  4
    24 23 22 21  5
    12 13 14 15 16
    11 17 18 19 20
    10  9  8  7  6

    The final route is marked in bold. We need to wait until time 16 so that
    (0, 0) and (4, 4) are connected.

    Note:
    * 2 <= N <= 50.
    * grid[i][j] is a permutation of [0, ..., N*N - 1].*/

    int swimInWater(vector<vector<int>>& grid) {
        int n = size(grid), dir[5] = {-1, 0, 1, 0, -1};

        struct Compare{
            bool operator()(array<int,3>& lhs, array<int,3>& rhs) { return lhs[0] > rhs[0]; } // greater<>
        };

        priority_queue<array<int,3>, vector<array<int,3>>, Compare> pq; // min-heap
        pq.push({grid[0][0], 0, 0});
        grid[0][0] = -1; // mark as visited

        while (size(pq)) {
            auto [v, i, j] = pq.top(); pq.pop();
            if (i == n-1 && j == n-1) return v;
            for (int k = 0; k < 4; ++k) {
                int ii = i + dir[k], jj = j + dir[k+1];
                if (0 <= ii && ii < n && 0 <= jj && jj < n && grid[ii][jj] >= 0) {
                    pq.push({max(v, grid[ii][jj]), ii, jj});
                    grid[ii][jj] = -1;
                }
            }
        }
        return -1;
    }


    /*780. Reaching Points (Hard)
    Given four integers sx, sy, tx, and ty, return true if it is possible to
    convert the point (sx, sy) to the point (tx, ty) through some operations,
    or false otherwise. The allowed operation on some point (x, y) is to
    convert it to either (x, x + y) or (x + y, y).

    Example 1:
    Input: sx = 1, sy = 1, tx = 3, ty = 5
    Output: true
    Explanation: One series of moves that transforms the starting point to the
                 target is:
                 (1, 1) -> (1, 2)
                 (1, 2) -> (3, 2)
                 (3, 2) -> (3, 5)

    Example 2:
    Input: sx = 1, sy = 1, tx = 2, ty = 2
    Output: false

    Example 3:
    Input: sx = 1, sy = 1, tx = 1, ty = 1
    Output: true

    Constraints: 1 <= sx, sy, tx, ty <= 10^9*/

    bool reachingPoints(int sx, int sy, int tx, int ty) {
        while (sx < tx || sy < ty) {
            if (tx > ty) {
                int k = (tx - sx)/ty;
                if (k == 0) break;
                tx -= k * ty;
            } else {
                int k = (ty - sy)/tx;
                if (k == 0) break;
                ty -= k * tx;
            }
        }
        return sx == tx && sy == ty;
    }


    /*782. Transform to Chessboard (Hard)
    You are given an n x n binary grid board. In each move, you can swap any
    two rows with each other, or any two columns with each other. Return the
    minimum number of moves to transform the board into a chessboard board. If
    the task is impossible, return -1. A chessboard board is a board where no
    0's and no 1's are 4-directionally adjacent.

    Example 1:
    Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
    Output: 2
    Explanation: One potential sequence of moves is shown. The first move swaps
                 the first and second column. The second move swaps the second
                 and third row.

    Example 2:
    Input: board = [[0,1],[1,0]]
    Output: 0
    Explanation: Also note that the board with 0 in the top left corner, is
                 also a valid chessboard.

    Example 3:
    Input: board = [[1,0],[1,0]]
    Output: -1
    Explanation: No matter what sequence of moves you make, you cannot end with
                 a valid chessboard.

    Constraints:
    * n == board.length
    * n == board[i].length
    * 2 <= n <= 30
    * board[i][j] is either 0 or 1.*/

    int movesToChessboard(vector<vector<int>>& board) {
        int n = size(board);

        auto fn = [&](vector<int>& vals) {
            int total = 0, odd = 0;
            for (int i = 0; i < size(vals); ++i) {
                if (vals[0] == vals[i]) {
                    ++total;
                    if (i&1) ++odd;
                } else if ((vals[0] ^ vals[i]) != (1 << n) - 1) return 100;
            }
            int ans = 100;
            if (size(vals) <= 2*total && 2*total <= size(vals)+1) ans = min(ans, odd);
            if (size(vals)-1 <= 2*total && 2*total <= size(vals)) ans = min(ans, total - odd);
            return ans;
        };

        vector<int> rows(n), cols(n);
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (board[i][j]) {
                    rows[i] ^= 1 << j;
                    cols[j] ^= 1 << i;
                }
        int ans = fn(rows) + fn(cols);
        return ans < 100 ? ans : -1;
    }


    /*783. Minimum Distance Between BST Nodes (Easy)
    Given the root of a Binary Search Tree (BST), return the minimum difference
    between the values of any two different nodes in the tree.

    Example 1:
    Input: root = [4,2,6,1,3]
    Output: 1

    Example 2:
    Input: root = [1,0,48,null,null,12,49]
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [2, 100].
    * 0 <= Node.val <= 10^5

    Note: This question is the same as 530:
          https://leetcode.com/problems/minimum-absolute-difference-in-bst/*/

    int minDiffInBST(TreeNode* root) {
        int ans = INT_MAX, prev = -1;
        TreeNode* node = root;
        stack<TreeNode*> stk;
        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top(); stk.pop();
                if (prev >= 0) ans = min(ans, node->val - prev);
                prev = node->val;
                node = node->right;
            }
        return ans;
    }


    /*784. Letter Case Permutation (Medium)
    Given a string s, we can transform every letter individually to be
    lowercase or uppercase to create another string. Return a list of all
    possible strings we could create. You can return the output in any order.

    Example 1:
    Input: s = "a1b2"
    Output: ["a1b2","a1B2","A1b2","A1B2"]

    Example 2:
    Input: s = "3z4"
    Output: ["3z4","3Z4"]

    Example 3:
    Input: s = "12345"
    Output: ["12345"]

    Example 4:
    Input: s = "0"
    Output: ["0"]

    Constraints:
    * s will be a string with length between 1 and 12.
    * s will consist only of letters or digits.*/

    vector<string> letterCasePermutation(string s) {
        vector<string> ans = {""};
        for (auto& ch : s)
            for (int i = 0, n = ans.size(); i < n; ++i) {
                if (isalpha(ch)) ans.push_back(ans[i] + string(1, ch^32));
                ans[i].push_back(ch);
            }
        return ans;
    }


    /*786. K-th Smallest Prime Fraction (Hard)
    You are given a sorted integer array arr containing 1 and prime numbers,
    where all the integers of arr are unique. You are also given an integer k.
    For every i and j where 0 <= i < j < arr.length, we consider the fraction
    arr[i] / arr[j]. Return the kth smallest fraction considered. Return your
    answer as an array of integers of size 2, where answer[0] == arr[i] and
    answer[1] == arr[j].

    Example 1:
    Input: arr = [1,2,3,5], k = 3
    Output: [2,5]
    Explanation: The fractions to be considered in sorted order are:
                 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.
                 The third fraction is 2/5.

    Example 2:
    Input: arr = [1,7], k = 1
    Output: [1,7]

    Constraints:
    * 2 <= arr.length <= 1000
    * 1 <= arr[i] <= 3 * 10^4
    * arr[0] == 1
    * arr[i] is a prime number for i > 0.
    * All the numbers of arr are unique and sorted in strictly increasing order.
    * 1 <= k <= arr.length * (arr.length - 1) / 2*/

    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
        int n = arr.size();
        priority_queue<tuple<double, int, int>, vector<tuple<double, int, int>>, greater<>> pq;
        for (int i = 0; i < n-1; ++i)
            pq.emplace(double(arr[i])/arr[n-1], i, n-1);
        int i = 0, j = 0;
        while (k--) {
            auto elem = pq.top(); pq.pop();
            i = get<1>(elem);
            j = get<2>(elem);
            if (i < j-1) pq.emplace(double(arr[i])/arr[j-1], i, j-1);
        }
        return {arr[i], arr[j]};
    }


    /*787. Cheapest Flights Within K Stops (Medium)
    There are n cities connected by some number of flights. You are given an
    array flights where flights[i] = [fromi, toi, pricei] indicates that there
    is a flight from city fromi to city toi with cost pricei. You are also
    given three integers src, dst, and k, return the cheapest price from src to
    dst with at most k stops. If there is no such route, return -1.

    Example 1:
    Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
    Output: 200
    Explanation: The graph is shown. The cheapest price from city 0 to city 2
                 with at most 1 stop costs 200, as marked red in the picture.

    Example 2:
    Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
    Output: 500
    Explanation: The graph is shown. The cheapest price from city 0 to city 2
                 with at most 0 stop costs 500, as marked blue in the picture.

    Constraints:
    * 1 <= n <= 100
    * 0 <= flights.length <= (n * (n - 1) / 2)
    * flights[i].length == 3
    * 0 <= fromi, toi < n
    * fromi != toi
    * 1 <= pricei <= 10^4
    * There will not be any multiple flights between two cities.
    * 0 <= src, dst, k < n
    * src != dst*/

    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<vector<pair<int, int>>> graph(n);
        for (auto& f : flights) graph[f[0]].emplace_back(f[1], f[2]);
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(0, src, 0);
        vector<pair<int, int>> dist(n, {INT_MAX, INT_MAX});
        dist[src] = {0, 0};
        while (pq.size()) {
            auto [p, u, x] = pq.top(); pq.pop();
            if (u == dst) return p;
            if (x <= k)
                for (auto& [v, pp] : graph[u])
                    if (p + pp < dist[v].first || x+1 < dist[v].second) {
                        pq.emplace(p+pp, v, x+1);
                        dist[v] = min(dist[v], {p+pp, x+1});
                    }
        }
        return -1;
    }


    /*790. Domino and Tromino Tiling (Medium)
    You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You
    may rotate these shapes. Given an integer n, return the number of ways to
    tile an 2 x n board. Since the answer may be very large, return it modulo
    10^9 + 7. In a tiling, every square must be covered by a tile. Two tilings
    are different if and only if there are two 4-directionally adjacent cells
    on the board such that exactly one of the tilings has both squares occupied
    by a tile.

    Example 1:
    Input: n = 3
    Output: 5
    Explanation: The five different ways are show above.

    Example 2:
    Input: n = 1
    Output: 1

    Constraints: 1 <= n <= 1000*/

    int numTilings(int n) {
        long f0 = 0, f1 = 1, f2 = 1;
        for (int i = 2; i <= n; ++i) {
            long temp = (2*f2 + f0) % 1'000'000'007;
            f0 = f1;
            f1 = f2;
            f2 = temp;
        }
        return f2;
    }


    /*791. Custom Sort String (Medium)
    order and str are strings composed of lowercase letters. In order, no
    letter occurs more than once. order was sorted in some custom order
    previously. We want to permute the characters of str so that they match the
    order that order was sorted. More specifically, if x occurs before y in
    order, then x should occur before y in the returned string. Return any
    permutation of str (as a string) that satisfies this property.

    Example:
    Input: order = "cba"
           str = "abcd"
    Output: "cbad"
    Explanation: "a", "b", "c" appear in order, so the order of "a", "b", "c"
                 should be "c", "b", and "a". Since "d" does not appear in
                 order, it can be at any position in the returned string. "dcba",
                 "cdba", "cbda" are also valid outputs.

    Note:
    * order has length at most 26, and no character is repeated in order.
    * str has length at most 200.
    * order and str consist of lowercase letters only.*/

    string customSortString(string order, string str) {
        int freq[26] = {0};
        for (auto& ch : str) ++freq[ch-'a'];

        string ans;
        for (auto& ch : order) {
            if (freq[ch-'a']) {
                ans += string(freq[ch-'a'], ch);
                freq[ch-'a'] = 0;
            }
        }
        for (int i = 0; i < 26; ++i)
            if (freq[i]) ans += string(freq[i], 'a'+i);
        return ans;
    }


    /*792. Number of Matching Subsequences (Medium)
    Given a string s and an array of strings words, return the number of
    words[i] that is a subsequence of s. A subsequence of a string is a new
    string generated from the original string with some characters (can be
    none) deleted without changing the relative order of the remaining
    characters. For example, "ace" is a subsequence of "abcde".

    Example 1:
    Input: s = "abcde", words = ["a","bb","acd","ace"]
    Output: 3
    Explanation: There are three strings in words that are a subsequence of s:
                 "a", "acd", "ace".

    Example 2:
    Input: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]
    Output: 2

    Constraints:
    * 1 <= s.length <= 5 * 10^4
    * 1 <= words.length <= 5000
    * 1 <= words[i].length <= 50
    * s and words[i] consist of only lowercase English letters.*/

    int numMatchingSubseq(string s, vector<string>& words) {
        unordered_map<char, vector<int>> loc;
        for (int i = 0; i < s.size(); ++i) loc[s[i]].push_back(i);

        int ans = 0;
        for (auto& word : words) {
            int x = 0;
            bool found = true;
            for (auto& ch : word) {
                auto it = lower_bound(loc[ch].begin(), loc[ch].end(), x);
                if (it == loc[ch].end()) {
                    found = false;
                    break;
                }
                x = *it + 1;
            }
            if (found) ++ans;
        }
        return ans;
    }


    /*793. Preimage Size of Factorial Zeroes Function (Hard)
    Let f(x) be the number of zeroes at the end of x!. (Recall that
    x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0
    because 3! = 6 has no zeroes at the end, while f(11) = 2 because
    11! = 39916800 has 2 zeroes at the end. Given k, find how many non-negative
    integers x have the property that f(x) = k.

    Example 1:
    Input: k = 0
    Output: 5
    Explanation: 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes.

    Example 2:
    Input: k = 5
    Output: 0
    Explanation: There is no x such that x! ends in k = 5 zeroes.

    Note: k will be an integer in the range [0, 10^9].*/

    int preimageSizeFZF(int k) {

        auto fn = [](int k) {
            long lo = 0, hi = 1l << 32;
            while (lo < hi) {
                long mid = lo + (hi - lo)/2, y = 0;
                for (long x = mid/5; x; x /= 5) y += x;
                if (y < k) lo = mid + 1;
                else hi = mid;
            }
            return lo;
        };

        return fn(k+1) - fn(k);
    }


    /*794. Valid Tic-Tac-Toe State (Medium)
    Given a Tic-Tac-Toe board as a string array board, return true if and only
    if it is possible to reach this board position during the course of a valid
    tic-tac-toe game. The board is a 3 x 3 array that consists of characters
    ' ', 'X', and 'O'. The ' ' character represents an empty square. Here are
    the rules of Tic-Tac-Toe:
    * Players take turns placing characters into empty squares ' '.
    * The first player always places 'X' characters, while the second player
      always places 'O' characters.
    * 'X' and 'O' characters are always placed into empty squares, never filled
      ones.
    * The game ends when there are three of the same (non-empty) character
      filling any row, column, or diagonal.
    * The game also ends if all squares are non-empty.
    * No more moves can be played if the game is over.

    Example 1:
    Input: board = ["O  ","   ","   "]
    Output: false
    Explanation: The first player always plays "X".

    Example 2:
    Input: board = ["XOX"," X ","   "]
    Output: false
    Explanation: Players take turns making moves.

    Example 3:
    Input: board = ["XXX","   ","OOO"]
    Output: false

    Example 4:
    Input: board = ["XOX","O O","XOX"]
    Output: true

    Constraints:
    * board.length == 3
    * board[i].length == 3
    * board[i][j] is either 'X', 'O', or ' '.*/

    bool validTicTacToe(vector<string>& board) {
        int diff = 0;
        vector<int> freq(8);
        unordered_map<char, int> mp = {{'O', -1}, {' ', 0}, {'X', 1}};
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j) {
                int x = mp[board[i][j]];
                diff += x;
                freq[i] += x;
                freq[j+3] += x;
                if (i == j) freq[6] += x;
                if (i+j == 2) freq[7] += x;
            }
        bool xwin = false, owin = false;
        if (find(freq.begin(), freq.end(), 3) != freq.end()) xwin = true;
        if (find(freq.begin(), freq.end(), -3) != freq.end()) owin = true;
        if ((xwin && owin) || (xwin && diff != 1) || (owin && diff != 0))  return false;
        return 0 <= diff && diff <= 1;
    }

    /*795. Number of Subarrays with Bounded Maximum (Medium)
    We are given an array nums of positive integers, and two positive integers
    left and right (left <= right). Return the number of (contiguous, non-empty)
    subarrays such that the value of the maximum array element in that subarray
    is at least left and at most right.

    Example:
    Input: nums = [2, 1, 4, 3]
           left = 2
           right = 3
    Output: 3
    Explanation: There are three subarrays that meet the requirements:
                 [2], [2, 1], [3].

    Note:
    * left, right, and nums[i] will be an integer in the range [0, 10^9].
    * The length of nums will be in the range of [1, 50000].*/

    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
        int ans = 0, inc = 0, cnt = 0;
        for (auto& x : nums) {
            if (x < left) ++cnt;
            else if (left <= x && x <= right) inc = ++cnt;
            else inc = cnt = 0;
            ans += inc;
        }
        return ans;
    }


    /*797. All Paths From Source to Target (Medium)
    Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1,
    find all possible paths from node 0 to node n - 1 and return them in any
    order. The graph is given as follows: graph[i] is a list of all nodes you
    can visit from node i (i.e., there is a directed edge from node i to node
    graph[i][j]).

    Example 1:
    Input: graph = [[1,2],[3],[3],[]]
    Output: [[0,1,3],[0,2,3]]
    Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.

    Example 2:
    Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]
    Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]

    Example 3:
    Input: graph = [[1],[]]
    Output: [[0,1]]

    Example 4:
    Input: graph = [[1,2,3],[2],[3],[]]
    Output: [[0,1,2,3],[0,2,3],[0,3]]

    Example 5:
    Input: graph = [[1,3],[2],[3],[]]
    Output: [[0,1,2,3],[0,3]]

    Constraints:
    * n == graph.length
    * 2 <= n <= 15
    * 0 <= graph[i][j] < n
    * graph[i][j] != i (i.e., there will be no self-loops).
    * All the elements of graph[i] are unique.
    * The input graph is guaranteed to be a DAG.*/

    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        vector<vector<int>> ans;
        vector<int> stk;

        function<void(int)> fn = [&](int n) {
            stk.push_back(n);
            if (n == graph.size()-1) ans.push_back(stk);
            for (auto& nn : graph[n]) fn(nn);
            stk.pop_back();
        };

        fn(0);
        return ans;
    }


    /*798. Smallest Rotation with Highest Score (Hard)
    Given an array nums, we may rotate it by a non-negative integer k so that
    the array becomes nums[k], nums[k+1], nums[k+2], ... nums[nums.length - 1],
    nums[0], nums[1], ..., nums[k-1].  Afterward, any entries that are less
    than or equal to their index are worth 1 point. For example, if we have
    [2, 4, 1, 3, 0], and we rotate by k = 2, it becomes [1, 3, 0, 2, 4]. This
    is worth 3 points because 1 > 0 [no points], 3 > 1 [no points],
    0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point]. Over all
    possible rotations, return the rotation index k that corresponds to the
    highest score we could receive. If there are multiple answers, return the
    smallest such index k.

    Example 1:
    Input: [2, 3, 1, 4, 0]
    Output: 3
    Explanation: Scores for each k are listed below:
                 k = 0,  nums = [2,3,1,4,0],    score 2
                 k = 1,  nums = [3,1,4,0,2],    score 3
                 k = 2,  nums = [1,4,0,2,3],    score 3
                 k = 3,  nums = [4,0,2,3,1],    score 4
                 k = 4,  nums = [0,2,3,1,4],    score 3
                 So we should choose k = 3, which has the highest score.

    Example 2:
    Input: [1, 3, 0, 2, 4]
    Output: 0
    Explanation: nums will always have 3 points no matter how it shifts. So we
                 will choose the smallest k, which is 0.

    Note:
    * nums will have length at most 20000.
    * nums[i] will be in the range [0, nums.length].*/

    int bestRotation(vector<int>& nums) {
        int n = size(nums);

        vector<int> diff(n, 1);
        for (int i = 0; i < n; ++i)
            diff[(i+n-nums[i]+1) % n]--;

        int ans = 0, prefix = 0, mx = INT_MIN;
        for (int i = 0; i < n; ++i) {
            prefix += diff[i];
            if (prefix > mx) {
                mx = prefix;
                ans = i;
            }
        }
        return ans;
    }


    /*803. Bricks Falling When Hit (Hard)
    You are given an m x n binary grid, where each 1 represents a brick and 0
    represents an empty space. A brick is stable if:
    * It is directly connected to the top of the grid, or
    * At least one other brick in its four adjacent cells is stable.
    You are also given an array hits, which is a sequence of erasures we want
    to apply. Each time we want to erase the brick at the location
    hits[i] = (rowi, coli). The brick on that location (if it exists) will
    disappear. Some other bricks may no longer be stable because of that
    erasure and will fall. Once a brick falls, it is immediately erased from
    the grid (i.e., it does not land on other stable bricks). Return an array
    result, where each result[i] is the number of bricks that will fall after
    the ith erasure is applied. Note that an erasure may refer to a location
    with no brick, and if it does, no bricks drop.

    Example 1:
    Input: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
    Output: [2]
    Explanation: Starting with the grid:
                 [[1,0,0,0],
                  [1,1,1,0]]
                 We erase the underlined brick at (1,0), resulting in the grid:
                 [[1,0,0,0],
                  [0,1,1,0]]
                 The two underlined bricks are no longer stable as they are no
                 longer connected to the top nor adjacent to another stable
                 brick, so they will fall. The resulting grid is:
                 [[1,0,0,0],
                  [0,0,0,0]]
                 Hence the result is [2].

    Example 2:
    Input: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
    Output: [0,0]
    Explanation: Starting with the grid:
                 [[1,0,0,0],
                  [1,1,0,0]]
                 We erase the underlined brick at (1,1), resulting in the grid:
                 [[1,0,0,0],
                  [1,0,0,0]]
                 All remaining bricks are still stable, so no bricks fall. The
                 grid remains the same:
                 [[1,0,0,0],
                  [1,0,0,0]]
                 Next, we erase the underlined brick at (1,0), resulting in the
                 grid:
                 [[1,0,0,0],
                  [0,0,0,0]]
                 Once again, all remaining bricks are still stable, so no bricks
                 fall. Hence the result is [0,0].

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 200
    * grid[i][j] is 0 or 1.
    * 1 <= hits.length <= 4 * 10^4
    * hits[i].length == 2
    * 0 <= xi <= m - 1
    * 0 <= yi <= n - 1
    * All (xi, yi) are unique.*/

    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {
        int m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        vector<vector<bool>> on(m, vector<bool>(n));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) on[i][j] = true;

        for (auto& hit : hits)
            grid[hit[0]][hit[1]] = 0;

        UnionFind* uf = new UnionFind(m*n+1);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) {
                    if (i == 0) uf->connect(j, m*n);
                    for (int k = 0; k < 4; ++k) {
                        int ii = i + dir[k], jj = j + dir[k+1];
                        if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj])
                            uf->connect(i*n+j, ii*n+jj);
                    }
                }

        vector<int> ans;
        int prev = uf->top();
        for (int x = hits.size()-1; x >= 0; --x) {
            int i = hits[x][0], j = hits[x][1];
            if (on[i][j]) {
                grid[i][j] = 1;
                if (i == 0) uf->connect(j, m*n);
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj])
                        uf->connect(i*n+j, ii*n+jj);
                }
                int rank = uf->top();
                ans.push_back(max(0, rank - prev - 1));
                prev = rank;
            } else
                ans.push_back(0);
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*810. Chalkboard XOR Game (Hard)
    We are given non-negative integers nums[i] which are written on a
    chalkboard. Alice and Bob take turns erasing exactly one number from the
    chalkboard, with Alice starting first.  If erasing a number causes the
    bitwise XOR of all the elements of the chalkboard to become 0, then that
    player loses.  (Also, we'll say the bitwise XOR of one element is that
    element itself, and the bitwise XOR of no elements is 0.) Also, if any
    player starts their turn with the bitwise XOR of all the elements of the
    chalkboard equal to 0, then that player wins. Return True if and only if
    Alice wins the game, assuming both players play optimally.

    Example:
    Input: nums = [1, 1, 2]
    Output: false
    Explanation: Alice has two choices: erase 1 or erase 2. If she erases 1,
                 the nums array becomes [1, 2]. The bitwise XOR of all the
                 elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove
                 any element he wants, because Alice will be the one to erase
                 the last element and she will lose. If Alice erases 2 first,
                 now nums becomes [1, 1]. The bitwise XOR of all the elements
                 of the chalkboard is 1 XOR 1 = 0. Alice will lose.

    Notes:
    * 1 <= N <= 1000.
    * 0 <= nums[i] <= 2^16.*/

    bool xorGame(vector<int>& nums) {
        int val = 0;
        for (auto& x : nums) val ^= x;
        return val == 0 || size(nums) % 2 == 0;
    }


    /*814. Binary Tree Pruning (Medium)
    Given the root of a binary tree, return the same tree where every subtree
    (of the given tree) not containing a 1 has been removed. A subtree of a
    node node is node plus every node that is a descendant of node.

    Example 1:
    Input: root = [1,null,0,0,1]
    Output: [1,null,0,null,1]
    Explanation: Only the red nodes satisfy the property "every subtree not
                 containing a 1". The diagram on the right represents the
                 answer.

    Example 2:
    Input: root = [1,0,1,0,0,0,1]
    Output: [1,null,1,null,1]

    Example 3:
    Input: root = [1,1,0,1,1,0,1,0]
    Output: [1,1,0,1,1,null,1]

    Constraints:
    * The number of nodes in the tree is in the range [1, 200].
    * Node.val is either 0 or 1.*/

    TreeNode* pruneTree(TreeNode* root) {
        if (root) {
            root->left = pruneTree(root->left);
            root->right = pruneTree(root->right);
            return root->left || root->val || root->right ? root : nullptr;
        }
        return nullptr;
    }


    /*815. Bus Routes (Hard)
    You are given an array routes representing bus routes where routes[i] is a
    bus route that the ith bus repeats forever. For example, if
    routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence
    1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever. You will start at the bus
    stop source (You are not on any bus initially), and you want to go to the
    bus stop target. You can travel between bus stops by buses only. Return the
    least number of buses you must take to travel from source to target. Return
    -1 if it is not possible.

    Example 1:
    Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
    Output: 2
    Explanation: The best strategy is take the first bus to the bus stop 7,
                 then take the second bus to the bus stop 6.

    Example 2:
    Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
    Output: -1

    Constraints:
    * 1 <= routes.length <= 500.
    * 1 <= routes[i].length <= 10^5
    * All the values of routes[i] are unique.
    * sum(routes[i].length) <= 10^5
    * 0 <= routes[i][j] < 10^6
    * 0 <= source, target < 10^6*/

    int numBusesToDestination(vector<vector<int>>& routes, int source, int target) {
        unordered_map<int, vector<int>> mp;
        for (int i = 0; i < size(routes); ++i)
            for (auto& x : routes[i])
                mp[x].push_back(i);

        int ans = 0;
        queue<int> q; q.push(source);
        unordered_set<int> seen = {source};

        while (size(q)) {
            for (int n = size(q); n > 0; --n) {
                int x = q.front(); q.pop();
                if (x == target) return ans;
                for (auto i : mp[x]) {
                    for (auto xx : routes[i])
                        if (seen.find(xx) == seen.end()) {
                            seen.insert(xx);
                            q.push(xx);
                        }
                    routes[i].clear();
                }
            }
            ++ans;
        }
        return -1;
    }


    /*816. Ambiguous Coordinates (Medium)
    We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)". Then,
    we removed all commas, decimal points, and spaces, and ended up with the
    string s. Return a list of strings representing all possibilities for what
    our original coordinates could have been. Our original representation never
    had extraneous zeroes, so we never started with numbers like "00", "0.0",
    "0.00", "1.0", "001", "00.01", or any other number that can be represented
    with less digits.  Also, a decimal point within a number never occurs
    without at least one digit occuring before it, so we never started with
    numbers like ".1". The final answer list can be returned in any order. Also
    note that all coordinates in the final answer have exactly one space
    between them (occurring after the comma.)

    Example 1:
    Input: s = "(123)"
    Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]

    Example 2:
    Input: s = "(00011)"
    Output:  ["(0.001, 1)", "(0, 0.011)"]
    Explanation: 0.0, 00, 0001 or 00.01 are not allowed.

    Example 3:
    Input: s = "(0123)"
    Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]

    Example 4:
    Input: s = "(100)"
    Output: [(10, 0)]
    Explanation: 1.0 is not allowed.

    Note:
    * 4 <= s.length <= 12.
    * s[0] = "(", s[s.length - 1] = ")", and the other elements in s are digits.*/

    vector<string> ambiguousCoordinates(string s) {

        auto fn = [](string&& s) {
            vector<string> ans;
            if (s.size() == 1)
                ans.push_back(s);
            else if (s.front() == '0' and s.back() == '0') ;
            else if (s.front() == '0')
                ans.push_back("0." + s.substr(1));
            else if (s.back() == '0')
                ans.push_back(s);
            else {
                for (int i = 1; i < s.size(); ++i)
                    ans.push_back(s.substr(0, i) + "." + s.substr(i));
                ans.push_back(s);
            }
            return ans;
        };

        vector<string> ans;
        for (int i = 2; i < s.size()-1; ++i)
            for (auto& x : fn(s.substr(1, i-1)))
                for (auto& y : fn(s.substr(i, s.size()-1-i)))
                    ans.push_back("(" + x + ", " + y + ")");
        return ans;
    }


    /*819. Most Common Word (Easy)
    Given a string paragraph and a string array of the banned words banned,
    return the most frequent word that is not banned. It is guaranteed there is
    at least one word that is not banned, and that the answer is unique. The
    words in paragraph are case-insensitive and the answer should be returned
    in lowercase.

    Example 1:
    Input: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]
    Output: "ball"
    Explanation:
    "hit" occurs 3 times, but it is a banned word.
    "ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.
    Note that words in the paragraph are not case sensitive,
    that punctuation is ignored (even if adjacent to words, such as "ball,"),
    and that "hit" isn't the answer even though it occurs more because it is banned.

    Example 2:
    Input: paragraph = "a.", banned = []
    Output: "a"

    Constraints:
    * 1 <= paragraph.length <= 1000
    * paragraph consists of English letters, space ' ', or one of the symbols: "!?',;.".
    * 0 <= banned.length <= 100
    * 1 <= banned[i].length <= 10
    * banned[i] consists of only lowercase English letters.*/

    string mostCommonWord(string paragraph, vector<string>& banned) {
        for (auto& c : paragraph)
            c = isalpha(c) ? tolower(c) : ' ';

        unordered_map<string, int> freq;
        unordered_set<string> ss(banned.begin(), banned.end());

        int cnt = 0;
        istringstream iss(paragraph);
        string ans, word;
        while (iss >> word) {
            if (ss.find(word) == ss.end()) {
                ++freq[word];
                if (cnt < freq[word]) {
                    ans = word;
                    cnt = freq[word];
                }
            }
        }
        return ans;
    }


    /*821. Shortest Distance to a Character (Easy)
    Given a string s and a character c that occurs in s, return an array of
    integers answer where answer.length == s.length and answer[i] is the
    distance from index i to the closest occurrence of character c in s. The
    distance between two indices i and j is abs(i - j), where abs is the
    absolute value function.

    Example 1:
    Input: s = "loveleetcode", c = "e"
    Output: [3,2,1,0,1,0,0,1,2,2,1,0]
    Explanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).
    The closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.
    The closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 3.
    For index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.
    The closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.

    Example 2:
    Input: s = "aaab", c = "b"
    Output: [3,2,1,0]

    Constraints:
    * 1 <= s.length <= 10^4
    * s[i] and c are lowercase English letters.
    * It is guaranteed that c occurs at least once in s.*/

    vector<int> shortestToChar(string s, char c) {
        vector<int> loc;
        for (int i = 0; i < s.size(); ++i)
            if (s[i] == c) loc.push_back(i);

        vector<int> ans;
        int k = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (k+1 < loc.size() && abs(loc[k+1]-i) < abs(loc[k]-i)) ++k;
            ans.push_back(abs(loc[k]-i));
        }
        return ans;
    }


    /*824. Goat Latin (Easy)
    A sentence S is given, composed of words separated by spaces. Each word
    consists of lowercase and uppercase letters only. We would like to convert
    the sentence to "Goat Latin" (a made-up language similar to Pig Latin.)

    The rules of Goat Latin are as follows:
    * If a word begins with a vowel (a, e, i, o, or u), append "ma" to the end
      of the word. For example, the word 'apple' becomes 'applema'.
    * If a word begins with a consonant (i.e. not a vowel), remove the first
      letter and append it to the end, then add "ma". For example, the word
      "goat" becomes "oatgma".
    * Add one letter 'a' to the end of each word per its word index in the
      sentence, starting with 1. For example, the first word gets "a" added to
      the end, the second word gets "aa" added to the end and so on.
    Return the final sentence representing the conversion from S to Goat Latin.

    Example 1:
    Input: "I speak Goat Latin"
    Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"

    Example 2:
    Input: "The quick brown fox jumped over the lazy dog"
    Output: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"

    Notes:
    * S contains only uppercase, lowercase and spaces. Exactly one space between each word.
    * 1 <= S.length <= 150.*/

    string toGoatLatin(string S) {
        string ans, word, vowels = "aeiouAEIOU", suffix;
        istringstream iss(S);
        ostringstream oss;

        while (iss >> word) {
            suffix.push_back('a');
            if (vowels.find(word[0]) == string::npos)
                word = word.substr(1) + word[0];
            oss << " " << word << "ma" << suffix;
        }
        return oss.str().substr(1);
    }


    /*825. Friends Of Appropriate Ages (Medium)
    There are n persons on a social media website. You are given an integer
    array ages where ages[i] is the age of the ith person. A Person x will not
    send a friend request to a person y (x != y) if any of the following
    conditions is true:
    * age[y] <= 0.5 * age[x] + 7
    * age[y] > age[x]
    * age[y] > 100 && age[x] < 100
    Otherwise, x will send a friend request to y. Note that if x sends a
    request to y, y will not necessarily send a request to x. Also, a person
    will not send a friend request to themself. Return the total number of
    friend requests made.

    Example 1:
    Input: ages = [16,16]
    Output: 2
    Explanation: 2 people friend request each other.

    Example 2:
    Input: ages = [16,17,18]
    Output: 2
    Explanation: Friend requests are made 17 -> 16, 18 -> 17.

    Example 3:
    Input: ages = [20,30,100,110,120]
    Output: 3
    Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.

    Constraints:
    * n == ages.length
    * 1 <= n <= 2 * 10^4
    * 1 <= ages[i] <= 120*/

    int numFriendRequests(vector<int>& ages) {
        sort(ages.begin(), ages.end());
        int ans = 0, lo = 0, hi = 0;
        for (auto& x : ages) {
            for (; hi < ages.size() && x == ages[hi]; ++hi);
            for (; lo+1 < hi && ages[lo] <= x/2+7; ++lo);
            ans += hi - lo - 1;
        }
        return ans;
    }


    /*826. Most Profit Assigning Work (Medium)
    You have n jobs and m workers. You are given three arrays: difficulty,
    profit, and worker where:
    * difficulty[i] and profit[i] are the difficulty and the profit of the ith
      job, and
    * worker[j] is the ability of jth worker (i.e., the jth worker can only
      complete a job with difficulty at most worker[j]).
    Every worker can be assigned at most one job, but one job can be completed
    multiple times.
    * For example, if three workers attempt the same job that pays $1, then the
      total profit will be $3. If a worker cannot complete any job, their profit
      is $0.
    Return the maximum profit we can achieve after assigning the workers to the
    jobs.

    Example 1:
    Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
    Output: 100
    Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get
                 a profit of [20,20,30,30] separately.

    Example 2:
    Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
    Output: 0

    Constraints:
    * n == difficulty.length
    * n == profit.length
    * m == worker.length
    * 1 <= n, m <= 10^4
    * 1 <= difficulty[i], profit[i], worker[i] <= 10^5*/

    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {
        int n = difficulty.size();
        vector<pair<int, int>> job;
        for (int i = 0; i < n; ++i)
            job.emplace_back(difficulty[i], profit[i]);
        sort(job.begin(), job.end(), [&](auto& x, auto& y) { return x.first < y.first; });
        sort(worker.begin(), worker.end());
        int ans = 0, k = 0, prefix = 0;
        for (auto& w : worker) {
            for (; k < n && job[k].first <= w; ++k)
                prefix = max(prefix, job[k].second);
            ans += prefix;
        }
        return ans;
    }


    /*827. Making A Large Island (Hard)
    You are given an n x n binary matrix grid. You are allowed to change at
    most one 0 to be 1. Return the size of the largest island in grid after
    applying this operation. An island is a 4-directionally connected group
    of 1s.

    Example 1:
    Input: grid = [[1,0],[0,1]]
    Output: 3
    Explanation: Change one 0 to 1 and connect two 1s, then we get an island
                 with area = 3.

    Example 2:
    Input: grid = [[1,1],[1,0]]
    Output: 4
    Explanation: Change the 0 to 1 and make the island bigger, only one island
                 with area = 4.

    Example 3:
    Input: grid = [[1,1],[1,1]]
    Output: 4
    Explanation: Can't change any 0 to 1, only one island with area = 4.

    Constraints:
    * n == grid.length
    * n == grid[i].length
    * 1 <= n <= 500
    * grid[i][j] is either 0 or 1.*/

    int largestIsland(vector<vector<int>>& grid) {
        int n = grid.size(), v = 2, d[5] = {1, 0, -1, 0, 1};
        unordered_map<int, int> freq;

        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == 1) {
                    stack<pair<int, int>> stk;
                    stk.emplace(i, j);
                    grid[i][j] = v;
                    while (stk.size()) {
                        auto [i, j] = stk.top(); stk.pop();
                        ++freq[v];
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + d[k], jj = j + d[k+1];
                            if (0 <= ii && ii < n && 0 <= jj && jj < n && grid[ii][jj] == 1) {
                                stk.emplace(ii, jj);
                                grid[ii][jj] = v;
                            }
                        }
                    }
                    ++v;
                }

        int ans = 0;
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) ans = max(ans, freq[grid[i][j]]);
                else {
                    int cand = 1;
                    unordered_set<int> seen;
                    for (int k = 0; k < 4; ++k) {
                        int ii = i + d[k], jj = j + d[k+1];
                        if (0 <= ii && ii < n && 0 <= jj && jj < n && grid[ii][jj] && !seen.count(grid[ii][jj])) {
                            seen.insert(grid[ii][jj]);
                            cand += freq[grid[ii][jj]];
                        }
                    }
                    ans = max(ans, cand);
                }
        return ans;
    }


    /*828. Count Unique Characters of All Substrings of a Given String (Hard)
    Let's define a function countUniqueChars(s) that returns the number of
    unique characters on s.
    * For example if s = "LEETCODE" then "L", "T", "C", "O", "D" are the unique
    characters since they appear only once in s, therefore countUniqueChars(s) = 5.
    Given a string s, return the sum of countUniqueChars(t) where t is a
    substring of s. Notice that some substrings can be repeated so in this case
    you have to count the repeated ones too.

    Example 1:
    Input: s = "ABC"
    Output: 10
    Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC".
                 Evey substring is composed with only unique letters. Sum of
                 lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10

    Example 2:
    Input: s = "ABA"
    Output: 8
    Explanation: The same as example 1, except countUniqueChars("ABA") = 1.

    Example 3:
    Input: s = "LEETCODE"
    Output: 92

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of uppercase English letters only.*/

    int uniqueLetterString(string s) {
        vector<vector<int>> locs(26, vector<int>(1, -1));
        for (int i = 0; i < s.size(); ++i) locs[s[i] - 'A'].push_back(i);

        int ans = 0;
        for (int i = 0; i < 26; ++i) {
            locs[i].push_back(s.size());
            for (int k = 1; k < locs[i].size()-1; ++k)
                ans += (locs[i][k] - locs[i][k-1]) * (locs[i][k+1] - locs[i][k]);
        }
        return ans;
    }


    /*829. Consecutive Numbers Sum (Hard)
    Given an integer n, return the number of ways you can write n as the sum of
    consecutive positive integers.

    Example 1:
    Input: n = 5
    Output: 2
    Explanation: 5 = 2 + 3

    Example 2:
    Input: n = 9
    Output: 3
    Explanation: 9 = 4 + 5 = 2 + 3 + 4

    Example 3:
    Input: n = 15
    Output: 4
    Explanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5

    Constraints: 1 <= n <= 10^9*/

    int consecutiveNumbersSum(int n) {
        int ans = 0;
        for (int x = 1; x*x < 2*n; ++x)
            if ((n - x*(x+1)/2) % x == 0) ++ans;
        return ans;
    }


    /*830. Positions of Large Groups (Easy)
    In a string s of lowercase letters, these letters form consecutive groups
    of the same character. For example, a string like s = "abbxxxxzyy" has the
    groups "a", "bb", "xxxx", "z", and "yy". A group is identified by an
    interval [start, end], where start and end denote the start and end indices
    (inclusive) of the group. In the above example, "xxxx" has the interval
    [3,6]. A group is considered large if it has 3 or more characters. Return
    the intervals of every large group sorted in increasing order by start index.

    Example 1:
    Input: s = "abbxxxxzzy"
    Output: [[3,6]]
    Explanation: "xxxx" is the only large group with start index 3 and end index 6.

    Example 2:
    Input: s = "abc"
    Output: []
    Explanation: We have groups "a", "b", and "c", none of which are large groups.

    Example 3:
    Input: s = "abcdddeeeeaabbbcd"
    Output: [[3,5],[6,9],[12,14]]
    Explanation: The large groups are "ddd", "eeee", and "bbb".

    Example 4:
    Input: s = "aba"
    Output: []

    Constraints:
    * 1 <= s.length <= 1000
    * s contains lower-case English letters only.*/

    vector<vector<int>> largeGroupPositions(string s) {
        vector<vector<int>> ans;
        for (int i = 0, ii = 0; i <= s.size(); ++i) {
            if (i == s.size() || (i > 0 && s[i-1] != s[i])) {
                if (i - ii >= 3)
                    ans.push_back({ii, i-1});
                ii = i;
            }
        }
        return ans;
    }


    /*832. Flipping an Image (Easy)
    Given an n x n binary matrix image, flip the image horizontally, then
    invert it, and return the resulting image. To flip an image horizontally
    means that each row of the image is reversed. For example, flipping
    [1,1,0] horizontally results in [0,1,1]. To invert an image means that
    each 0 is replaced by 1, and each 1 is replaced by 0. For example,
    inverting [0,1,1] results in [1,0,0].

    Example 1:
    Input: image = [[1,1,0],[1,0,1],[0,0,0]]
    Output: [[1,0,0],[0,1,0],[1,1,1]]
    Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
    Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]

    Example 2:
    Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
    Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
    Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
    Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]

    Constraints:
    * n == image.length
    * n == image[i].length
    * 1 <= n <= 20
    * images[i][j] is either 0 or 1.*/

    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {
        for (auto& row : image) {
            reverse(row.begin(), row.end());
            for (auto& x : row)
                x ^= 1;
        }
        return image;
    }


    /*834. Sum of Distances in Tree (Hard)
    An undirected, connected tree with n nodes labelled 0...n-1 and n-1 edges
    are given. The ith edge connects nodes edges[i][0] and edges[i][1] together.
    Return a list ans, where ans[i] is the sum of the distances between node i
    and all other nodes.

    Example 1:
    Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
    Output: [8,12,6,10,10,10]
    Explanation: Here is a diagram of the given tree:
      0
     / \
    1   2
       /|\
      3 4 5
    We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
    equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.
    Note: 1 <= n <= 10000*/

    vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
        vector<int> graph[n];
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            graph[u].push_back(v);
            graph[v].push_back(u);
        }

        function<pair<int, int>(int, int)> fn = [&](int u, int p) {
            int cnt = 0, val = 0;
            for (auto& v : graph[u])
                if (v != p) {
                    auto [cc, vv] = fn(v, u);
                    cnt += cc;
                    val += cc + vv;
                }
            size[u] = ++cnt;
            return make_pair(cnt, val);
        };

        vector<int> ans(n), size(n);
        ans[0] = fn(0, -1).second;
        stack<int> stk; stk.push(0);
        while (stk.size()) {
            auto u = stk.top(); stk.pop();
            for (auto& v : graph[u])
                if (ans[v] == 0) {
                    ans[v] = ans[u] + n - 2*size[v];
                    stk.push(v);
                }
        }
        return ans;
    }


    /*836. Rectangle Overlap (Easy)
    An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where
    (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the
    coordinate of its top-right corner. Its top and bottom edges are parallel
    to the X-axis, and its left and right edges are parallel to the Y-axis.
    Two rectangles overlap if the area of their intersection is positive. To be
    clear, two rectangles that only touch at the corner or edges do not overlap.
    Given two axis-aligned rectangles rec1 and rec2, return true if they
    overlap, otherwise return false.

    Example 1:
    Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]
    Output: true

    Example 2:
    Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]
    Output: false

    Example 3:
    Input: rec1 = [0,0,1,1], rec2 = [2,2,3,3]
    Output: false

    Constraints:
    * rect1.length == 4
    * rect2.length == 4
    * -10^9 <= rec1[i], rec2[i] <= 10^9
    * rec1[0] <= rec1[2] and rec1[1] <= rec1[3]
    * rec2[0] <= rec2[2] and rec2[1] <= rec2[3]*/

    bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
        return max(rec1[0], rec2[0]) < min(rec1[2], rec2[2]) && max(rec1[1], rec2[1]) < min(rec1[3], rec2[3]);
    }


    /*838. Push Dominoes (Medium)
    There are n dominoes in a line, and we place each domino vertically upright.
    In the beginning, we simultaneously push some of the dominoes either to the
    left or to the right. After each second, each domino that is falling to the
    left pushes the adjacent domino on the left. Similarly, the dominoes
    falling to the right push their adjacent dominoes standing on the right.
    When a vertical domino has dominoes falling on it from both sides, it stays
    still due to the balance of the forces. For the purposes of this question,
    we will consider that a falling domino expends no additional force to a
    falling or already fallen domino. You are given a string dominoes
    representing the initial state where:
    * dominoes[i] = 'L', if the ith domino has been pushed to the left,
    * dominoes[i] = 'R', if the ith domino has been pushed to the right, and
    * dominoes[i] = '.', if the ith domino has not been pushed.
    Return a string representing the final state.

    Example 1:
    Input: dominoes = "RR.L"
    Output: "RR.L"
    Explanation: The first domino expends no additional force on the second
                 domino.

    Example 2:
    Input: dominoes = ".L.R...LR..L.."
    Output: "LL.RR.LLRRLL.."

    Constraints:
    * n == dominoes.length
    * 1 <= n <= 10^5
    * dominoes[i] is either 'L', 'R', or '.'.*/

    string pushDominoes(string dominoes) {
        int n = dominoes.size();
        vector<int> mp(n);
        for (int i = n-1, ii = n; i >= 0; --i) {
            if (dominoes[i] != '.') ii = i;
            mp[i] = ii;
        }

        string ans;
        for (int i = 0, ii = -1; i < n; ++i) {
            if (dominoes[i] == 'L' || dominoes[i] == 'R') {
                ans.push_back(dominoes[i]);
                ii = i;
            } else {
                char ll = ii == -1 ? 'L' : dominoes[ii], rr = mp[i] == n ? 'R' : dominoes[mp[i]];
                if (ll == rr) ans.push_back(ll);
                else if (ll == 'L') ans.push_back('.');
                else {
                    if (i - ii < mp[i] - i) ans.push_back('R');
                    else if (i - ii > mp[i] - i) ans.push_back('L');
                    else ans.push_back('.');
                }
            }
        }
        return ans;
    }


    /*839. Similar String Groups (Hard)
    Two strings X and Y are similar if we can swap two letters (in different
    positions) of X, so that it equals Y. Also two strings X and Y are similar
    if they are equal. For example, "tars" and "rats" are similar (swapping at
    positions 0 and 2), and "rats" and "arts" are similar, but "star" is not
    similar to "tars", "rats", or "arts". Together, these form two connected
    groups by similarity: {"tars", "rats", "arts"} and {"star"}.  Notice that
    "tars" and "arts" are in the same group even though they are not similar.
    Formally, each group is such that a word is in the group if and only if it
    is similar to at least one other word in the group. We are given a list
    strs of strings where every string in strs is an anagram of every other
    string in strs. How many groups are there?

    Example 1:
    Input: strs = ["tars","rats","arts","star"]
    Output: 2

    Example 2:
    Input: strs = ["omv","ovm"]
    Output: 1

    Constraints:
    * 1 <= strs.length <= 300
    * 1 <= strs[i].length <= 300
    * strs[i] consists of lowercase letters only.
    * All words in strs have the same length and are anagrams of each other.*/

    int numSimilarGroups(vector<string>& strs) {

        auto fn = [](string& x, string& y) {
            int cnt = 0;
            for (int i = 0; i < x.size(); ++i)
                if (x[i] != y[i] && ++cnt > 2) return false;
            return true;
        };

        int n = strs.size();
        UnionFind* uf = new UnionFind(n);
        for (int i = 0; i < strs.size(); ++i)
            for (int ii = 0; ii < i; ++ii)
                if (fn(strs[i], strs[ii]) && uf->connect(i, ii))
                    --n;
        delete uf;
        return n;
    }


    /*841. Keys and Rooms (Medium)
    There are n rooms labeled from 0 to n - 1 and all the rooms are locked
    except for room 0. Your goal is to visit all the rooms. However, you cannot
    enter a locked room without having its key. When you visit a room, you may
    find a set of distinct keys in it. Each key has a number on it, denoting
    which room it unlocks, and you can take all of them with you to unlock the
    other rooms. Given an array rooms where rooms[i] is the set of keys that
    you can obtain if you visited room i, return true if you can visit all the
    rooms, or false otherwise.

    Example 1:
    Input: rooms = [[1],[2],[3],[]]
    Output: true
    Explanation: We visit room 0 and pick up key 1.
                 We then visit room 1 and pick up key 2.
                 We then visit room 2 and pick up key 3.
                 We then visit room 3.
                 Since we were able to visit every room, we return true.

    Example 2:
    Input: rooms = [[1,3],[3,0,1],[2],[0]]
    Output: false
    Explanation: We can not enter room number 2 since the only key that unlocks
                 it is in that room.

    Constraints:
    * n == rooms.length
    * 2 <= n <= 1000
    * 0 <= rooms[i].length <= 1000
    * 1 <= sum(rooms[i].length) <= 3000
    * 0 <= rooms[i][j] < n
    * All the values of rooms[i] are unique.*/

    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n = rooms.size();
        queue<int> q; q.push(0);
        vector<bool> visited(n);
        visited[0] = true;
        while (q.size())
            for (int sz = q.size(); sz; --sz) {
                int i = q.front(); q.pop();
                for (auto& x : rooms[i])
                    if (!visited[x]) {
                        visited[x] = true;
                        q.push(x);
                    }
            }
        return all_of(visited.begin(), visited.end(), [&](bool x){ return x; });
    }


    /*843. Guess the Word (Hard)
    This is an interactive problem. You are given an array of unique strings
    wordlist where wordlist[i] is 6 letters long, and one word in this list is
    chosen as secret. You may call Master.guess(word) to guess a word. The
    guessed word should have type string and must be from the original list
    with 6 lowercase letters. This function returns an integer type,
    representing the number of exact matches (value and position) of your guess
    to the secret word. Also, if your guess is not in the given wordlist, it
    will return -1 instead. For each test case, you have exactly 10 guesses to
    guess the word. At the end of any number of calls, if you have made 10 or
    fewer calls to Master.guess and at least one of these guesses was secret,
    then you pass the test case.

    Example 1:
    Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"], numguesses = 10
    Output: You guessed the secret word correctly.
    Explanation: master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist.
                 master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches.
                 master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches.
                 master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches.
                 master.guess("abcczz") returns 4, because "abcczz" has 4 matches.
                 We made 5 calls to master.guess and one of them was the secret, so we pass the test case.

    Example 2:
    Input: secret = "hamada", wordlist = ["hamada","khaled"], numguesses = 10
    Output: You guessed the secret word correctly.

    Constraints:
    * 1 <= wordlist.length <= 100
    * wordlist[i].length == 6
    * wordlist[i] consist of lowercase English letters.
    * All the strings of wordlist are unique.
    * secret exists in wordlist.
    * numguesses == 10*/

    void findSecretWord(vector<string>& wordlist, Master& master) {
        srand(1);
        random_shuffle(wordlist.begin(), wordlist.end());
        for (int step = 0; step < 10; ++step)
            if (wordlist.size()) {
                string w = wordlist.back();
                wordlist.pop_back();
                int m = master.guess(w);
                vector<string> temp;
                for (auto& ww : wordlist) {
                    int cnt = 0;
                    for (int i = 0; i < w.size(); ++i)
                        if (w[i] == ww[i]) ++cnt;
                    if (cnt == m) temp.push_back(ww);
                }
                wordlist = temp;
            }
    }


    /*844. Backspace String Compare (Easy)
    Given two strings s and t, return true if they are equal when both are
    typed into empty text editors. '#' means a backspace character. Note that
    after backspacing an empty text, the text will continue empty.

    Example 1:
    Input: s = "ab#c", t = "ad#c"
    Output: true
    Explanation: Both s and t become "ac".

    Example 2:
    Input: s = "ab##", t = "c#d#"
    Output: true
    Explanation: Both s and t become "".

    Example 3:
    Input: s = "a##c", t = "#a#c"
    Output: true
    Explanation: Both s and t become "c".

    Example 4:
    Input: s = "a#c", t = "b"
    Output: false
    Explanation: s becomes "c" while t becomes "b".

    Constraints:
    * 1 <= s.length, t.length <= 200
    * s and t only contain lowercase letters and '#' characters.

    Follow up: Can you solve it in O(n) time and O(1) space?*/

    bool backspaceCompare(string s, string t) {
        for (int i = s.size()-1, j = t.size()-1, cs = 0, ct = 0; 0 <= i || 0 <= j; --i, --j) {
            for (; 0 <= i && (s[i] == '#' || cs); --i)
                if (s[i] == '#') ++cs;
                else --cs;
            for (; 0 <= j && (t[j] == '#' || ct); --j)
                if (t[j] == '#') ++ct;
                else --ct;
            if ((i < 0 && 0 <= j) || (0 <= i && j < 0) || (0 <= i && 0 <= j && s[i] != t[j])) return false;
        }
        return true;
    }


    /*846. Hand of Straights (Medium)
    Alice has some number of cards and she wants to rearrange the cards into
    groups so that each group is of size groupSize, and consists of groupSize
    consecutive cards. Given an integer array hand where hand[i] is the value
    written on the ith card and an integer groupSize, return true if she can
    rearrange the cards, or false otherwise.

    Example 1:
    Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
    Output: true
    Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]

    Example 2:
    Input: hand = [1,2,3,4,5], groupSize = 4
    Output: false
    Explanation: Alice's hand can not be rearranged into groups of 4.

    Constraints:
    * 1 <= hand.length <= 10^4
    * 0 <= hand[i] <= 10^9
    * 1 <= groupSize <= hand.length

    Note: This question is the same as 1296:
          https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/*/

    bool isNStraightHand(vector<int>& hand, int groupSize) {
        map<int, int> freq;
        for (auto& x : hand) ++freq[x];
        queue<pair<int, int>> q;
        int need = 0, prev = -1;
        for (auto& [x, v] : freq) {
            if (need > v || (need && x > prev + 1)) return false;
            if (v > need) q.emplace(x, v - need);
            prev = x;
            need = v;
            if (q.size() && x-q.front().first == groupSize-1) need -= q.front().second, q.pop();
        }
        return need == 0;
    }


    /*847. Shortest Path Visiting All Nodes (Hard)
    You have an undirected, connected graph of n nodes labeled from 0 to n - 1.
    You are given an array graph where graph[i] is a list of all the nodes
    connected with node i by an edge. Return the length of the shortest path
    that visits every node. You may start and stop at any node, you may revisit
    nodes multiple times, and you may reuse edges.

    Example 1:
    Input: graph = [[1,2,3],[0],[0],[0]]
    Output: 4
    Explanation: One possible path is [1,0,2,0,3]

    Example 2:
    Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
    Output: 4
    Explanation: One possible path is [0,1,4,2,3]

    Constraints:
    * n == graph.length
    * 1 <= n <= 12
    * 0 <= graph[i].length < n
    * graph[i] does not contain i.
    * If graph[a] contains b, then graph[b] contains a.
    * The input graph is always connected.*/

    int shortestPathLength(vector<vector<int>>& graph) {
        int n = graph.size();
        queue<pair<int, int>> q;
        vector<vector<bool>> seen(n, vector<bool>(1<<n));

        for (int i = 0; i < n; ++i) {
            q.emplace(i, 1<<i);
            seen[i][1<<i] = true;
        }

        for (int ans = 0; q.size(); ++ans)
            for (int sz = q.size(); sz; --sz) {
                auto [u, mask] = q.front(); q.pop();
                if (mask == (1<<n) - 1) return ans;
                for (auto& v : graph[u])
                    if (!seen[v][mask | 1<<v]) {
                        q.emplace(v, mask | 1<<v);
                        seen[v][mask | 1<<v] = true;
                    }
            }
        return -1;
    }


    /*848. Shifting Letters (Medium)
    You are given a string s of lowercase English letters and an integer array
    shifts of the same length. Call the shift() of a letter, the next letter in
    the alphabet, (wrapping around so that 'z' becomes 'a').

    * For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.

    Now for each shifts[i] = x, we want to shift the first i + 1 letters of s,
    x times. Return the final string after all such shifts to s are applied.

    Example 1:
    Input: s = "abc", shifts = [3,5,9]
    Output: "rpl"
    Explanation: We start with "abc".
    After shifting the first 1 letters of s by 3, we have "dbc".
    After shifting the first 2 letters of s by 5, we have "igc".
    After shifting the first 3 letters of s by 9, we have "rpl", the answer.

    Example 2:
    Input: s = "aaa", shifts = [1,2,3]
    Output: "gfd"

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters.
    * shifts.length == s.length
    * 0 <= shifts[i] <= 10^9*/

    string shiftingLetters(string s, vector<int>& shifts) {
        for (int i = s.size()-1; i >= 0; --i) {
            if (i+1 < s.size()) shifts[i] = (shifts[i] + shifts[i+1]) % 26;
            s[i] = (s[i] - 'a' + shifts[i]) % 26 + 'a';
        }
        return s;
    }


    /*849. Maximize Distance to Closest Person (Medium)
    You are given an array representing a row of seats where seats[i] = 1
    represents a person sitting in the ith seat, and seats[i] = 0 represents
    that the ith seat is empty (0-indexed). There is at least one empty seat,
    and at least one person sitting. Alex wants to sit in the seat such that
    the distance between him and the closest person to him is maximized. Return
    that maximum distance to the closest person.

    Example 1:
    Input: seats = [1,0,0,0,1,0,1]
    Output: 2
    Explanation: If Alex sits in the second open seat (i.e. seats[2]), then the
                 closest person has distance 2. If Alex sits in any other open
                 seat, the closest person has distance 1. Thus, the maximum
                 distance to the closest person is 2.

    Example 2:
    Input: seats = [1,0,0,0]
    Output: 3
    Explanation: If Alex sits in the last seat (i.e. seats[3]), the closest
                 person is 3 seats away. This is the maximum distance possible,
                 so the answer is 3.

    Example 3:
    Input: seats = [0,1]
    Output: 1

    Constraints:
    * 2 <= seats.length <= 2 * 10^4
    * seats[i] is 0 or 1.
    * At least one seat is empty.
    * At least one seat is occupied.*/

    int maxDistToClosest(vector<int>& seats) {
        int ans = 0, prev = -1, n = seats.size();
        for (int i = 0; i < n; ++i)
            if (seats[i]) {
                if (prev == -1) ans = max(ans, i);
                else ans = max(ans, (i-prev)/2);
                prev = i;
            }
        return max(ans, n-1-prev);
    }


    /*850. Rectangle Area II (Hard)
    We are given a list of (axis-aligned) rectangles. Each
    rectangle[i] = [xi1, yi1, xi2, yi2], where (xi1, yi1) are the coordinates
    of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-
    right corner of the ith rectangle. Find the total area covered by all
    rectangles in the plane. Since the answer may be too large, return it
    modulo 10^9 + 7.

    Example 1:
    Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
    Output: 6
    Explanation: As illustrated in the picture.

    Example 2:
    Input: rectangles = [[0,0,1000000000,1000000000]]
    Output: 49
    Explanation: The answer is 10^18 modulo (10^9 + 7), which is 49.

    Constraints:
    * 1 <= rectangles.length <= 200
    * rectanges[i].length = 4
    * 0 <= rectangles[i][j] <= 10^9
    * The total area covered by all rectangles will never exceed 2^63 - 1 and
      thus will fit in a 64-bit signed integer.*/

    int rectangleArea(vector<vector<int>>& rectangles) {
        vector<vector<int>> line;
        for (auto& rectangle : rectangles) {
            int x1 = rectangle[0], y1 = rectangle[1], x2 = rectangle[2], y2 = rectangle[3];
            line.push_back({y1, x1, x2, 1});
            line.push_back({y2, x1, x2, 0});
        }

        sort(line.begin(), line.end());

        long ans = 0, val = 0;
        int yy = 0, prev = 0;
        multiset<vector<int>> segments;
        for (auto& elem : line) {
            int y = elem[0], x1 = elem[1], x2 = elem[2], tf = elem[3];
            ans = (ans + val * (y - yy)) % 1'000'000'007;
            yy = y;
            if (tf) segments.insert({x1, x2});
            else segments.erase(segments.find({x1, x2}));
            val = prev = 0;
            for (auto& seg : segments) {
                x1 = seg[0];
                x2 = seg[1];
                val += max(0, x2 - max(x1, prev));
                prev = max(prev, x2);
            }
        }
        return ans;
    }


    /*851. Loud and Rich (Medium)
    There is a group of n people labeled from 0 to n - 1 where each person has
    a different amount of money and a different level of quietness. You are
    given an array richer where richer[i] = [ai, bi] indicates that ai has more
    money than bi and an integer array quiet where quiet[i] is the quietness of
    the ith person. All the given data in richer are logically correct (i.e.,
    the data will not lead you to a situation where x is richer than y and y is
    richer than x at the same time). Return an integer array answer where
    answer[x] = y if y is the least quiet person (that is, the person y with
    the smallest value of quiet[y]) among all people who definitely have equal
    to or more money than the person x.

    Example 1:
    Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
    Output: [5,5,2,5,4,5,6,7]
    Explanation: answer[0] = 5. Person 5 has more money than 3, which has more
                 money than 1, which has more money than 0. The only person who
                 is quieter (has lower quiet[x]) is person 7, but it is not
                 clear if they have more money than person 0. answer[7] = 7.
                 Among all people that definitely have equal to or more money
                 than person 7 (which could be persons 3, 4, 5, 6, or 7), the
                 person who is the quietest (has lower quiet[x]) is person 7.
                 The other answers can be filled out with similar reasoning.

    Example 2:
    Input: richer = [], quiet = [0]
    Output: [0]

    Constraints:
    * n == quiet.length
    * 1 <= n <= 500
    * 0 <= quiet[i] < n
    * All the values of quiet are unique.
    * 0 <= richer.length <= n * (n - 1) / 2
    * 0 <= ai, bi < n
    * ai != bi
    * All the pairs of richer are unique.
    * The observations in richer are all logically consistent.*/

    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        vector<vector<int>> graph(n);
        for (auto& val : richer) graph[val[1]].push_back(val[0]);
        vector<int> ans(n, -1);

        function<int(int)> fn = [&](int x) {
            if (ans[x] == -1) {
                ans[x] = x;
                for (auto& xx : graph[x])
                    if (quiet[fn(xx)] < quiet[ans[x]]) ans[x] = fn(xx);
            }
            return ans[x];
        };

        for (int x = 0; x < n; ++x) fn(x);
        return ans;
    }


    /*852. Peak Index in a Mountain Array (Easy)
    Let's call an array arr a mountain if the following properties hold:
    * arr.length >= 3
    * There exists some i with 0 < i < arr.length - 1 such that:
      + arr[0] < arr[1] < ... arr[i-1] < arr[i]
      + arr[i] > arr[i+1] > ... > arr[arr.length - 1]
    Given an integer array arr that is guaranteed to be a mountain, return any
    i such that arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... >
    arr[arr.length - 1].

    Example 1:
    Input: arr = [0,1,0]
    Output: 1

    Example 2:
    Input: arr = [0,2,1,0]
    Output: 1

    Example 3:
    Input: arr = [0,10,5,2]
    Output: 1

    Example 4:
    Input: arr = [3,4,5,1]
    Output: 2

    Example 5:
    Input: arr = [24,69,100,99,79,78,67,36,26,19]
    Output: 2

    Constraints:
    * 3 <= arr.length <= 10^4
    * 0 <= arr[i] <= 10^6
    * arr is guaranteed to be a mountain array.

    Follow up: Finding the O(n) is straightforward, could you find an O(log(n))
               solution?*/

    int peakIndexInMountainArray(vector<int>& arr) {
        int i = 0;
        for (; arr[i] < arr[i+1]; ++i) {}
        return i;
    }


    /*854. K-Similar Strings (Hard)
    Strings s1 and s2 are k-similar (for some non-negative integer k) if we can
    swap the positions of two letters in s1 exactly k times so that the
    resulting string equals s2. Given two anagrams s1 and s2, return the
    smallest k for which s1 and s2 are k-similar.

    Example 1:
    Input: s1 = "ab", s2 = "ba"
    Output: 1

    Example 2:
    Input: s1 = "abc", s2 = "bca"
    Output: 2

    Example 3:
    Input: s1 = "abac", s2 = "baca"
    Output: 2

    Example 4:
    Input: s1 = "aabc", s2 = "abca"
    Output: 2

    Constraints:
    * 1 <= s1.length <= 20
    * s2.length == s1.length
    * s1 and s2 contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}.
    * s2 is an anagram of s1.*/

    int kSimilarity(string s1, string s2) {
        unordered_set<string> seen;
        queue<string> q; q.push(s1);
        for (int ans = 0; q.size(); ++ans)
            for (int n = q.size(); n; --n) {
                string s = q.front(); q.pop();
                if (s == s2) return ans;
                for (int i = 0; i < s.size(); ++i)
                    if (s[i] != s2[i]) {
                        for (int ii = i+1; ii < s.size(); ++ii)
                            if (s[ii] != s2[ii] && s[ii] == s2[i]) {
                                string ss = s.substr(0, i) + string(1, s[ii]) + s.substr(i+1, ii-i-1) + string(1, s[i]) + s.substr(ii+1);
                                if (!seen.count(ss)) {
                                    seen.insert(ss);
                                    q.push(ss);
                                }
                            }
                        break;
                    }
            }
        return -1;
    }


    /*856. Score of Parentheses (Medium)
    Given a balanced parentheses string s, return the score of the string. The
    score of a balanced parentheses string is based on the following rule:
    * "()" has score 1.
    * AB has score A + B, where A and B are balanced parentheses strings.
    * (A) has score 2 * A, where A is a balanced parentheses string.

    Example 1:
    Input: s = "()"
    Output: 1

    Example 2:
    Input: s = "(())"
    Output: 2

    Example 3:
    Input: s = "()()"
    Output: 2

    Constraints:
    * 2 <= s.length <= 50
    * s consists of only '(' and ')'.
    * s is a balanced parentheses string.*/

    int scoreOfParentheses(string s) {
        int ans = 0;
        stack<int> stk;
        for (auto& ch : s)
            if (ch == '(') {
                stk.push(ans);
                ans = 0;
            } else {
                ans = max(1, 2*ans) + stk.top();
                stk.pop();
            }
        return ans;
    }


    /*857. Minimum Cost to Hire K Workers (Hard)
    There are n workers. The i-th worker has a quality[i] and a minimum wage
    expectation wage[i]. Now we want to hire exactly k workers to form a paid
    group. When hiring a group of k workers, we must pay them according to the
    following rules:
    * Every worker in the paid group should be paid in the ratio of their
      quality compared to other workers in the paid group.
    * Every worker in the paid group must be paid at least their minimum wage
      expectation.
    Return the least amount of money needed to form a paid group satisfying the
    above conditions.

    Example 1:
    Input: quality = [10,20,5], wage = [70,50,30], k = 2
    Output: 105.00000
    Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.

    Example 2:
    Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3
    Output: 30.66667
    Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers
                 seperately.

    Note:
    * 1 <= k <= n <= 10000, where n = quality.length = wage.length
    * 1 <= quality[i] <= 10000
    * 1 <= wage[i] <= 10000
    * Answers within 10-5 of the correct answer will be considered correct.*/

    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {
        vector<pair<int, int>> vals;
        for (int i = 0; i < quality.size(); ++i)
            vals.emplace_back(quality[i], wage[i]);
        sort(vals.begin(), vals.end(), [&](auto& x, auto& y) {
            return x.second*y.first < y.second*x.first;
        });
        double ans = DBL_MAX, prefix = 0;
        priority_queue<int> pq;
        for (auto& [q, w] : vals) {
            prefix += q;
            pq.push(q);
            if (pq.size() > k)
                prefix -= pq.top(), pq.pop();
            if (pq.size() == k)
                ans = min(ans, prefix * w/q);
        }
        return ans;
    }


    /*859. Buddy Strings (Easy)
    Given two strings a and b, return true if you can swap two letters in a so
    the result is equal to b, otherwise, return false. Swapping letters is
    defined as taking two indices i and j (0-indexed) such that i != j and
    swapping the characters at a[i] and a[j]. For example, swapping at indices
    0 and 2 in "abcd" results in "cbad".

    Example 1:
    Input: a = "ab", b = "ba"
    Output: true
    Explanation: You can swap a[0] = 'a' and a[1] = 'b' to get "ba", which is
                 equal to b.

    Example 2:
    Input: a = "ab", b = "ab"
    Output: false
    Explanation: The only letters you can swap are a[0] = 'a' and a[1] = 'b',
                 which results in "ba" != b.

    Example 3:
    Input: a = "aa", b = "aa"
    Output: true
    Explanation: You can swap a[0] = 'a' and a[1] = 'a' to get "aa", which is
                 equal to b.

    Example 4:
    Input: a = "aaaaaaabc", b = "aaaaaaacb"
    Output: true

    Constraints:
    * 1 <= a.length, b.length <= 2 * 10^4
    * a and b consist of lowercase letters.*/

    bool buddyStrings(string a, string b) {
        if (a.size() != b.size()) return false;

        int most = 0;
        vector<int> loc;
        unordered_map<char, int> freq;

        for (int i = 0; i < a.size(); ++i) {
            most = max(most, ++freq[a[i]]);
            if (a[i] != b[i]) loc.push_back(i);
        }
        if (loc.size() == 0) return most > 1;
        if (loc.size() == 2) return a[loc[0]] == b[loc[1]] && a[loc[1]] == b[loc[0]];
        return false;
    }


    /*860. Lemonade Change (Easy)
    At a lemonade stand, each lemonade costs $5. Customers are standing in a
    queue to buy from you, and order one at a time (in the order specified by
    bills). Each customer will only buy one lemonade and pay with either a $5,
    $10, or $20 bill.  You must provide the correct change to each customer,
    so that the net transaction is that the customer pays $5. Note that you
    don't have any change in hand at first. Return true if and only if you can
    provide every customer with correct change.

    Example 1:
    Input: [5,5,5,10,20]
    Output: true
    Explanation:
    From the first 3 customers, we collect three $5 bills in order.
    From the fourth customer, we collect a $10 bill and give back a $5.
    From the fifth customer, we give a $10 bill and a $5 bill.
    Since all customers got correct change, we output true.

    Example 2:
    Input: [5,5,10]
    Output: true

    Example 3:
    Input: [10,10]
    Output: false

    Example 4:
    Input: [5,5,10,10,20]
    Output: false
    Explanation:
    From the first two customers in order, we collect two $5 bills.
    For the next two customers in order, we collect a $10 bill and give back a $5 bill.
    For the last customer, we can't give change of $15 back because we only have two $10 bills.
    Since not every customer received correct change, the answer is false.

    Note:
    * 0 <= bills.length <= 10000
    * bills[i] will be either 5, 10, or 20.*/

    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0;
        for (auto& bill : bills) {
            if (bill == 5) ++five;
            else if (bill == 10) --five, ++ten;
            else if (ten) --five, --ten;
            else five -= 3;
            if (five < 0) return false;
        }
        return true;
    }


    /*861. Score After Flipping Matrix (Medium)
    You are given an m x n binary matrix grid. A move consists of choosing any
    row or column and toggling each value in that row or column (i.e., changing
    all 0's to 1's, and all 1's to 0's). Every row of the matrix is interpreted
    as a binary number, and the score of the matrix is the sum of these numbers.
    Return the highest possible score after making any number of moves
    (including zero moves).

    Example 1:
    Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
    Output: 39
    Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39

    Example 2:
    Input: grid = [[0]]
    Output: 1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 20
    * grid[i][j] is either 0 or 1.*/

    int matrixScore(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), ans = 0;
        for (int j = 0; j < n; ++j) {
            int val = 0;
            for (int i = 0; i < m ; ++i)
                if (grid[i][0] == grid[i][j]) ++val;
            val = max(val, m - val);
            ans += val * (1<<n-1-j);
        }
        return ans;
    }


    /*862. Shortest Subarray with Sum at Least K (Hard)
    Given an integer array nums and an integer k, return the length of the
    shortest non-empty subarray of nums with a sum of at least k. If there is
    no such subarray, return -1. A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1], k = 1
    Output: 1

    Example 2:
    Input: nums = [1,2], k = 4
    Output: -1

    Example 3:
    Input: nums = [2,-1,2], k = 3
    Output: 3

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^5 <= nums[i] <= 10^5
    * 1 <= k <= 10^9*/

    int shortestSubarray(vector<int>& nums, int k) {
        deque<pair<int, int>> dq = {{-1, 0}};
        int prefix = 0, ans = INT_MAX;
        for (int i = 0; i < nums.size(); ++i) {
            prefix += nums[i];
            while (dq.size() && prefix - dq.front().second >= k) {
                ans = min(ans, i - dq.front().first);
                dq.pop_front();
            }
            while (dq.size() && dq.back().second >= prefix) dq.pop_back();
            dq.emplace_back(i, prefix);
        }
        return ans < INT_MAX ? ans : -1;
    }


    /*864. Shortest Path to Get All Keys (Hard)
    You are given an m x n grid grid where:
    * '.' is an empty cell.
    * '#' is a wall.
    * '@' is the starting point.
    * Lowercase letters represent keys.
    * Uppercase letters represent locks.
    You start at the starting point and one move consists of walking one space
    in one of the four cardinal directions. You cannot walk outside the grid,
    or walk into a wall. If you walk over a key, you can pick it up and you
    cannot walk over a lock unless you have its corresponding key. For some
    1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the
    first k letters of the English alphabet in the grid. This means that there
    is exactly one key for each lock, and one lock for each key; and also that
    the letters used to represent the keys and locks were chosen in the same
    order as the English alphabet. Return the lowest number of moves to acquire
    all keys. If it is impossible, return -1.

    Example 1:
    Input: grid = ["@.a.#","###.#","b.A.B"]
    Output: 8
    Explanation: Note that the goal is to obtain all the keys not to open all
                 the locks.

    Example 2:
    Input: grid = ["@..aA","..B#.","....b"]
    Output: 6

    Example 3:
    Input: grid = ["@Aa"]
    Output: -1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 30
    * grid[i][j] is either an English letter, '.', '#', or '@'.
    * The number of keys in the grid is in the range [1, 6].
    * Each key in the grid is unique.
    * Each key in the grid has a matching lock.*/

    int shortestPathAllKeys(vector<string>& grid) {
        int m = grid.size(), n = grid[0].size(), total = 0, dir[5] = {-1, 0, 1, 0, -1};

        deque<array<int,3>> q;
        set<array<int,3>> seen;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == '@') {
                    q.push_back({i, j, 0});
                    seen.insert({i, j, 0});
                }
                else if (islower(grid[i][j])) ++total;

        for (int ans = 0; q.size(); ++ans)
            for (int sz = q.size(); sz; --sz) {
                auto [i, j, keys] = q.front(); q.pop_front();
                if (keys == (1 << total)-1) return ans;
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] != '#') {
                        int kk = keys;
                        if (islower(grid[ii][jj])) kk |= 1 << (grid[ii][jj] - 'a');
                        if (seen.count({ii, jj, kk}) || (isupper(grid[ii][jj]) && (kk & (1 << (grid[ii][jj] - 'A'))) == 0)) continue;
                        q.push_back({ii, jj, kk});
                        seen.insert({ii, jj, kk});
                    }
                }
            }
        return -1;
    }


    /*866. Prime Palindrome (Medium)
    Given an integer n, return the smallest prime palindrome greater than or
    equal to n. An integer is prime if it has exactly two divisors: 1 and
    itself. Note that 1 is not a prime number. For example, 2, 3, 5, 7, 11,
    and 13 are all primes. An integer is a palindrome if it reads the same from
    left to right as it does from right to left. For example, 101 and 12321 are
    palindromes. The test cases are generated so that the answer always exists
    and is in the range [2, 2 * 10^8].

    Example 1:
    Input: n = 6
    Output: 7

    Example 2:
    Input: n = 8
    Output: 11

    Example 3:
    Input: n = 13
    Output: 101

    Constraints: 1 <= n <= 10^8*/

    int primePalindrome(int n) {
        if (8 <= n && n <= 11) return 11; // edge case

        auto fn = [](int x) {
            vector<int> digits;
            for (int xx = x; xx; xx /= 10)
                digits.push_back(xx % 10);
            reverse(digits.begin(), digits.end());
            int n = digits.size();
            bool found = false;
            int i = n/2;
            for (; i >= 0; --i)
                if (digits[i] < 9) {
                    found = true;
                    break;
                }
            if (!found) return 10*x + 11;
            digits[i] = digits[n-1-i] = digits[i] + 1;
            for (int ii = 0; ii < i; ++ii) digits[n-1-ii] = digits[ii];
            for (int ii = i+1; ii <= n/2; ++ii) digits[ii] = digits[n-1-ii] = 0;
            int ans = 0;
            for (auto& digit : digits) ans = 10*ans + digit;
            return ans;
        };

        auto isprime = [&](int x) {
            if (x <= 1) return false;
            if (x % 2 == 0) return x == 2;
            for (int k = 3; k <= sqrt(x); k += 2)
                if (x % k == 0) return false;
            return true;
        };

        auto ispalin = [](int x) {
            vector<int> digits;
            for (; x; x /= 10)
                digits.push_back(x % 10);
            for (int lo = 0, hi = digits.size()-1; lo < hi; ++lo, --hi)
                if (digits[lo] != digits[hi]) return false;
            return true;
        };

        int k = 0;
        for (int nn = n; nn; nn /= 10, ++k);

        if (k % 2 == 0) n = pow(10, k) + 1;
        else if (!ispalin(n)) n = fn(n);

        for (; true; n = fn(n)) {
            if (isprime(n)) return n;
        }
        return -1;
    }


    /*867. Transpose Matrix (Easy)
    Given a 2D integer array matrix, return the transpose of matrix. The
    transpose of a matrix is the matrix flipped over its main diagonal,
    switching the matrix's row and column indices.

    Example 1:
    Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
    Output: [[1,4,7],[2,5,8],[3,6,9]]

    Example 2:
    Input: matrix = [[1,2,3],[4,5,6]]
    Output: [[1,4],[2,5],[3,6]]

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 1000
    * 1 <= m * n <= 10^5
    * -10^9 <= matrix[i][j] <= 10^9*/

    vector<vector<int>> transpose(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> ans(n, vector<int>(m, 0));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                ans[j][i] = matrix[i][j];
            }
        }
        return ans;
    }


    /*868. Binary Gap (Easy)
    Given a positive integer n, find and return the longest distance between
    any two adjacent 1's in the binary representation of n. If there are no two
    adjacent 1's, return 0. Two 1's are adjacent if there are only 0's
    separating them (possibly no 0's). The distance between two 1's is the
    absolute difference between their bit positions. For example, the two 1's
    in "1001" have a distance of 3.

    Example 1:
    Input: n = 22
    Output: 2
    Explanation: 22 in binary is "10110".
                 The first adjacent pair of 1's is "10110" with a distance of 2.
                 The second adjacent pair of 1's is "10110" with a distance of 1.
                 The answer is the largest of these two distances, which is 2.
                 Note that "10110" is not a valid pair since there is a 1
                 separating the two 1's underlined.

    Example 2:
    Input: n = 5
    Output: 2
    Explanation: 5 in binary is "101".

    Example 3:
    Input: n = 6
    Output: 1
    Explanation: 6 in binary is "110".

    Example 4:
    Input: n = 8
    Output: 0
    Explanation: 8 in binary is "1000". There aren't any adjacent pairs of 1's
                 in the binary representation of 8, so we return 0.

    Example 5:
    Input: n = 1
    Output: 0

    Constraints: 1 <= n <= 10^9*/

    int binaryGap(int n) {
        int ans = 0;
        for (int cnt = -1; n; n /= 2) {
            int x = n % 2;
            if (x == 1) {
                ans = max(ans, cnt);
                cnt = 0;
            }
            if (cnt >= 0) ++cnt;
        }
        return ans;
    }


    /*871. Minimum Number of Refueling Stops (Hard)
    A car travels from a starting position to a destination which is target
    miles east of the starting position. Along the way, there are gas stations.
    Each station[i] represents a gas station that is station[i][0] miles east
    of the starting position, and has station[i][1] liters of gas. The car
    starts with an infinite tank of gas, which initially has startFuel liters
    of fuel in it.  It uses 1 liter of gas per 1 mile that it drives. When the
    car reaches a gas station, it may stop and refuel, transferring all the gas
    from the station into the car. What is the least number of refueling stops
    the car must make in order to reach its destination?  If it cannot reach
    the destination, return -1. Note that if the car reaches a gas station with
    0 fuel left, the car can still refuel there.  If the car reaches the
    destination with 0 fuel left, it is still considered to have arrived.

    Example 1:
    Input: target = 1, startFuel = 1, stations = []
    Output: 0
    Explanation: We can reach the target without refueling.

    Example 2:
    Input: target = 100, startFuel = 1, stations = [[10,100]]
    Output: -1
    Explanation: We can't reach the target (or even the first gas station).

    Example 3:
    Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
    Output: 2
    Explanation: We start with 10 liters of fuel. We drive to position 10,
                 expending 10 liters of fuel.  We refuel from 0 liters to 60
                 liters of gas. Then, we drive from position 10 to position 60
                 (expending 50 liters of fuel), and refuel from 10 liters to 50
                 liters of gas.  We then drive to and reach the target. We made
                 2 refueling stops along the way, so we return 2.

    Note:
    * 1 <= target, startFuel, stations[i][1] <= 10^9
    * 0 <= stations.length <= 500
    * 0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target*/

    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        int ans = 0, k = 0, total = startFuel;
        priority_queue<int> pq;
        while (total < target) {
            for(; k < size(stations) && stations[k][0] <= total; ++k)
                pq.push(stations[k][1]);
            if (pq.empty()) return -1;
            total += pq.top(), pq.pop();
            ans += 1;
        }
        return ans;
    }


    /*872. Leaf-Similar Trees (Easy)
    Consider all the leaves of a binary tree, from left to right order, the
    values of those leaves form a leaf value sequence. For example, in the
    given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary
    trees are considered leaf-similar if their leaf value sequence is the same.
    Return true if and only if the two given trees with head nodes root1 and
    root2 are leaf-similar.

    Example 1:
    Input: root1 = [3,5,1,6,2,9,8,null,null,7,4],
           root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
    Output: true

    Example 2:
    Input: root1 = [1], root2 = [1]
    Output: true

    Example 3:
    Input: root1 = [1], root2 = [2]
    Output: false

    Example 4:
    Input: root1 = [1,2], root2 = [2,2]
    Output: true

    Example 5:
    Input: root1 = [1,2,3], root2 = [1,3,2]
    Output: false

    Constraints:
    * The number of nodes in each tree will be in the range [1, 200].
    * Both of the given trees will have values in the range [0, 200].*/

    bool leafSimilar(TreeNode* root1, TreeNode* root2) {

        function<void(TreeNode*, vector<int>&)> dfs = [&dfs](TreeNode* node, vector<int>& vec) {
            if (node->left == NULL && node->right == NULL) vec.push_back(node->val);
            if (node->left) dfs(node->left, vec);
            if (node->right) dfs(node->right, vec);
        };

        vector<int> vec1, vec2;
        dfs(root1, vec1);
        dfs(root2, vec2);
        return vec1 == vec2;
    }


    /*874. Walking Robot Simulation (Easy)
    A robot on an infinite XY-plane starts at point (0, 0) and faces north. The
    robot can receive one of three possible types of commands:
    * -2: turn left 90 degrees,
    * -1: turn right 90 degrees, or
    * 1 <= k <= 9: move forward k units.
    Some of the grid squares are obstacles. The ith obstacle is at grid point
    obstacles[i] = (xi, yi). If the robot would try to move onto them, the robot
    stays on the previous grid square instead (but still continues following the
    rest of the route.) Return the maximum Euclidean distance that the robot
    will be from the origin squared (i.e. if the distance is 5, return 25).

    Note:
    * North means +Y direction.
    * East means +X direction.
    * South means -Y direction.
    * West means -X direction.

    Example 1:
    Input: commands = [4,-1,3], obstacles = []
    Output: 25
    Explanation: The robot starts at (0, 0):
                 1. Move north 4 units to (0, 4).
                 2. Turn right.
                 3. Move east 3 units to (3, 4).
                 The furthest point away from the origin is (3, 4), which is
                 32 + 42 = 25 units away.

    Example 2:
    Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
    Output: 65
    Explanation: The robot starts at (0, 0):
                 1. Move north 4 units to (0, 4).
                 2. Turn right.
                 3. Move east 1 unit and get blocked by the obstacle at (2, 4),
                    robot is at (1, 4).
                 4. Turn left.
                 5. Move north 4 units to (1, 8).
                 The furthest point away from the origin is (1, 8), which is
                 12 + 82 = 65 units away.

    Constraints:
    * 1 <= commands.length <= 10^4
    * commands[i] is one of the values in the list [-2,-1,1,2,3,4,5,6,7,8,9].
    * 0 <= obstacles.length <= 10^4
    * -3 * 10^4 <= xi, yi <= 3 * 10^4
    * The answer is guaranteed to be less than 2^31.*/

    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        int ans = 0, x = 0, y = 0, dx = 0, dy = 1;
        set<vector<int>> tabu;
        for (auto& obstacle : obstacles)
            tabu.insert(obstacle);
        for (auto& command : commands) {
            if (command == -2) { swap(dx, dy); dx *= -1; }
            else if (command == -1) { swap(dx, dy); dy *= -1; }
            else
                while (command--) {
                    if (tabu.contains({x+dx, y+dy})) break;
                    x += dx;
                    y += dy;
                }
            ans = max(ans, x*x + y*y);
        }
        return ans;
    }


    /*875. Koko Eating Bananas (Medium)
    Koko loves to eat bananas. There are n piles of bananas, the ith pile has
    piles[i] bananas. The guards have gone and will come back in h hours. Koko
    can decide her bananas-per-hour eating speed of k. Each hour, she chooses
    some pile of bananas and eats k bananas from that pile. If the pile has
    less than k bananas, she eats all of them instead and will not eat any more
    bananas during this hour. Koko likes to eat slowly but still wants to
    finish eating all the bananas before the guards return. Return the minimum
    integer k such that she can eat all the bananas within h hours.

    Example 1:
    Input: piles = [3,6,7,11], h = 8
    Output: 4

    Example 2:
    Input: piles = [30,11,23,4,20], h = 5
    Output: 30

    Example 3:
    Input: piles = [30,11,23,4,20], h = 6
    Output: 23

    Constraints:
    * 1 <= piles.length <= 10^4
    * piles.length <= h <= 10^9
    * 1 <= piles[i] <= 10^9*/

    int minEatingSpeed(vector<int>& piles, int h) {
        int lo = 1, hi = *max_element(piles.begin(), piles.end());
        while (lo < hi) {
            int mid = lo + (hi - lo)/2, val = 0;
            for (auto& x : piles) val += (x+mid-1)/mid;
            if (val <= h) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }


    /*876. Middle of the Linked List (Easy)
    Given a non-empty, singly linked list with head node head, return a middle
    node of linked list. If there are two middle nodes, return the second
    middle node.

    Example 1:
    Input: [1,2,3,4,5]
    Output: Node 3 from this list (Serialization: [3,4,5])
    The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).
    Note that we returned a ListNode object ans, such that:
    ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.

    Example 2:
    Input: [1,2,3,4,5,6]
    Output: Node 4 from this list (Serialization: [4,5,6])
    Since the list has two middle nodes with values 3 and 4, we return the second one.

    Note: The number of nodes in the given list will be between 1 and 100.*/

    ListNode* middleNode(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }


    /*877. Stone Game (Medium)
    Alex and Lee play a game with piles of stones. There are an even number of
    piles arranged in a row, and each pile has a positive integer number of
    stones piles[i]. The objective of the game is to end with the most stones.
    The total number of stones is odd, so there are no ties. Alex and Lee take
    turns, with Alex starting first. Each turn, a player takes the entire pile
    of stones from either the beginning or the end of the row. This continues
    until there are no more piles left, at which point the person with the most
    stones wins. Assuming Alex and Lee play optimally, return True if and only
    if Alex wins the game.

    Example 1:
    Input: piles = [5,3,4,5]
    Output: true
    Explanation:
    Alex starts first, and can only take the first 5 or the last 5.
    Say he takes the first 5, so that the row becomes [3, 4, 5].
    If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.
    If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.
    This demonstrated that taking the first 5 was a winning move for Alex, so we return true.

    Constraints:
    * 2 <= piles.length <= 500
    * piles.length is even.
    * 1 <= piles[i] <= 500
    * sum(piles) is odd.*/

    bool stoneGame(vector<int>& piles) {
        int n = piles.size();
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = n-1; i >= 0; --i)
            for (int j = i; j < n; ++j)
                if (i == j) dp[i][j] = piles[i];
                else dp[i][j] = max(piles[i] + dp[i+1][j], piles[j] + dp[i][j-1]);
        return dp[0][n-1] > 0;
    }


    /*878. Nth Magical Number (Hard)
    A positive integer is magical if it is divisible by either a or b. Given
    the three integers n, a, and b, return the nth magical number. Since the
    answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 1, a = 2, b = 3
    Output: 2

    Example 2:
    Input: n = 4, a = 2, b = 3
    Output: 6

    Example 3:
    Input: n = 5, a = 2, b = 4
    Output: 10

    Example 4:
    Input: n = 3, a = 6, b = 4
    Output: 8

    Constraints:
    * 1 <= n <= 10^9
    * 2 <= a, b <= 4 * 10^4*/

    int nthMagicalNumber(int n, int a, int b) {
        // inclusion-exclusion principle
        int ab = lcm(a, b);
        long lo = 0, hi = (long) n*min(a,b);
        while (lo < hi) {
            long mid = lo + (hi - lo)/2;
            if (mid/a + mid/b - mid/ab < n) lo = mid + 1;
            else hi = mid;
        }
        return lo % 1'000'000'007;
    }


    /*879. Profitable Schemes (Hard)
    There is a group of n members, and a list of various crimes they could
    commit. The ith crime generates a profit[i] and requires group[i] members
    to participate in it. If a member participates in one crime, that member
    can't participate in another crime. Let's call a profitable scheme any
    subset of these crimes that generates at least minProfit profit, and the
    total number of members participating in that subset of crimes is at most
    n. Return the number of schemes that can be chosen. Since the answer may
    be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3]
    Output: 2
    Explanation: To make a profit of at least 3, the group could either commit
                 crimes 0 and 1, or just crime 1. In total, there are 2 schemes.

    Example 2:
    Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
    Output: 7
    Explanation: To make a profit of at least 5, the group could commit any
                 crimes, as long as they commit one. There are 7 possible
                 schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).

    Constraints:
    * 1 <= n <= 100
    * 0 <= minProfit <= 100
    * 1 <= group.length <= 100
    * 1 <= group[i] <= 100
    * profit.length == group.length
    * 0 <= profit[i] <= 100*/

    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        const int MOD = 1'000'000'007;
        vector<vector<int>> dp(1+minProfit, vector<int>(1+n));
        dp[0][0] = 1;
        for (int k = 0; k < group.size(); ++k)
            for (int i = minProfit; i >= 0; --i)
                for (int j = n-group[k]; j >= 0; --j)
                    dp[min(i+profit[k], minProfit)][j+group[k]] = (dp[min(i+profit[k], minProfit)][j+group[k]] + dp[i][j]) % MOD;
        int ans = 0;
        for (auto& x : dp[minProfit]) ans = (ans + x) % MOD;
        return ans;
    }


    /*881. Boats to Save People (Medium)
    You are given an array people where people[i] is the weight of the ith
    person, and an infinite number of boats where each boat can carry a maximum
    weight of limit. Each boat carries at most two people at the same time,
    provided the sum of the weight of those people is at most limit. Return the
    minimum number of boats to carry every given person.

    Example 1:
    Input: people = [1,2], limit = 3
    Output: 1
    Explanation: 1 boat (1, 2)

    Example 2:
    Input: people = [3,2,2,1], limit = 3
    Output: 3
    Explanation: 3 boats (1, 2), (2) and (3)

    Example 3:
    Input: people = [3,5,3,4], limit = 5
    Output: 4
    Explanation: 4 boats (3), (3), (4), (5)

    Constraints:
    * 1 <= people.length <= 5 * 10^4
    * 1 <= people[i] <= limit <= 3 * 10^4*/

    int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(), people.end());
        int ans = 0;
        for (int lo = 0, hi = people.size()-1; lo <= hi; ++ans, --hi)
            if (lo < hi && people[lo] + people[hi] <= limit) ++lo;
        return ans;
    }


    /*882. Reachable Nodes In Subdivided Graph (Hard)
    You are given an undirected graph (the "original graph") with n nodes
    labeled from 0 to n - 1. You decide to subdivide each edge in the graph
    into a chain of nodes, with the number of new nodes varying between each
    edge. The graph is given as a 2D array of edges where
    edges[i] = [ui, vi, cnti] indicates that there is an edge between nodes ui
    and vi in the original graph, and cnti is the total number of new nodes
    that you will subdivide the edge into. Note that cnti == 0 means you will
    not subdivide the edge. To subdivide the edge [ui, vi], replace it with
    (cnti + 1) new edges and cnti new nodes. The new nodes are x1, x2, ...,
    xcnti, and the new edges are [ui, x1], [x1, x2], [x2, x3], ...,
    [xcnti11, xcnti], [xcnti, vi]. In this new graph, you want to know how many
    nodes are reachable from the node 0, where a node is reachable if the
    distance is maxMoves or less. Given the original graph and maxMoves, return
    the number of nodes that are reachable from node 0 in the new graph.

    Example 1:
    Input: edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
    Output: 13
    Explanation: The edge subdivisions are shown in the image above. The nodes
                 that are reachable are highlighted in yellow.

    Example 2:
    Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
    Output: 23

    Example 3:
    Input: edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
    Output: 1
    Explanation: Node 0 is disconnected from the rest of the graph, so only
                 node 0 is reachable.

    Constraints:
    * 0 <= edges.length <= min(n * (n - 1) / 2, 10^4)
    * edges[i].length == 3
    * 0 <= ui < vi < n
    * There are no multiple edges in the graph.
    * 0 <= cnti <= 10^4
    * 0 <= maxMoves <= 10^9
    * 1 <= n <= 3000*/

    int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
        unordered_map<int, unordered_map<int, int>> graph;
        for (auto& e : edges)
            graph[e[0]][e[1]] = graph[e[1]][e[0]] = e[2];

        int ans = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.emplace(0, 0);

        vector<bool> seen(n);
        vector<vector<int>> used(n, vector<int>(n));

        while (pq.size()) {
            auto [x, u] = pq.top(); pq.pop();
            if (!seen[u]) {
                ++ans;
                seen[u] = true;
                for (auto& [v, w] : graph[u])
                    if (!used[u][v]) {
                        if (used[v][u] < graph[v][u]) {
                            used[u][v] = min(maxMoves - x, graph[v][u] - used[v][u]);
                            ans += used[u][v];
                        }
                        if (x + w + 1 <= maxMoves && !seen[v]) pq.emplace(x + w + 1, v);
                    }
            }
        }
        return ans;
    }


    /*883. Projection Area of 3D Shapes (Easy)
    You are given an n x n grid where we place some 1 x 1 x 1 cubes that are
    axis-aligned with the x, y, and z axes. Each value v = grid[i][j]
    represents a tower of v cubes placed on top of the cell (i, j). We view the
    projection of these cubes onto the xy, yz, and zx planes. A projection is
    like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane.
    We are viewing the "shadow" when looking at the cubes from the top, the
    front, and the side. Return the total area of all three projections.

    Example 1:
    Input: grid = [[1,2],[3,4]]
    Output: 17
    Explanation: Here are the three projections ("shadows") of the shape made
                 with each axis-aligned plane.

    Example 2:
    Input: grid = [[2]]
    Output: 5

    Example 3:
    Input: grid = [[1,0],[0,2]]
    Output: 8

    Example 4:
    Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
    Output: 14

    Example 5:
    Input: grid = [[2,2,2],[2,1,2],[2,2,2]]
    Output: 21

    Constraints:
    * n == grid.length
    * n == grid[i].length
    * 1 <= n <= 50
    * 0 <= grid[i][j] <= 50*/

    int projectionArea(vector<vector<int>>& grid) {
        int n = grid.size(), ans = 0;
        for (int i = 0; i < n; ++i) {
            int cmx = 0, rmx = 0;
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] > 0) ++ans;
                cmx = max(cmx, grid[j][i]);
                rmx = max(rmx, grid[i][j]);
            }
            ans += cmx + rmx;
        }
        return ans;
    }


    /*884. Uncommon Words from Two Sentences (Easy)
    We are given two sentences A and B.  (A sentence is a string of space
    separated words.  Each word consists only of lowercase letters.) A word is
    uncommon if it appears exactly once in one of the sentences, and does not
    appear in the other sentence. Return a list of all uncommon words. You may
    return the list in any order.

    Example 1:
    Input: A = "this apple is sweet", B = "this apple is sour"
    Output: ["sweet","sour"]

    Example 2:
    Input: A = "apple apple", B = "banana"
    Output: ["banana"]

    Note:
    * 0 <= A.length <= 200
    * 0 <= B.length <= 200
    * A and B both contain only spaces and lowercase letters.*/

    vector<string> uncommonFromSentences(string A, string B) {
        istringstream iss(A + " " + B);
        unordered_map<string, int> freq;
        string word;
        while (iss >> word) ++freq[word];

        vector<string> ans;
        for (auto x : freq) {
            if (x.second == 1) ans.push_back(x.first);
        }
        return ans;
    }


    /*887. Super Egg Drop (Hard)
    You are given k identical eggs and you have access to a building with n
    floors labeled from 1 to n. You know that there exists a floor f where
    0 <= f <= n such that any egg dropped at a floor higher than f will break,
    and any egg dropped at or below floor f will not break. Each move, you may
    take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If
    the egg breaks, you can no longer use it. However, if the egg does not
    break, you may reuse it in future moves. Return the minimum number of moves
    that you need to determine with certainty what the value of f is.

    Example 1:
    Input: k = 1, n = 2
    Output: 2
    Explanation: Drop the egg from floor 1. If it breaks, we know that f = 0.
                 Otherwise, drop the egg from floor 2. If it breaks, we know
                 that f = 1. If it does not break, then we know f = 2. Hence,
                 we need at minimum 2 moves to determine with certainty what
                 the value of f is.

    Example 2:
    Input: k = 2, n = 6
    Output: 3

    Example 3:
    Input: k = 3, n = 14
    Output: 4

    Constraints:
    * 1 <= k <= 100
    * 1 <= n <= 10^4*/

    int superEggDrop(int k, int n) {
        vector<int> dp(k+1);
        for (int i = 1; i <= n; ++i)
            for (int j = k; j >= 1; --j) {
                dp[j] += 1 + dp[j-1];
                if (dp[j] >= n) return i;
            }
        return -1;
    }


    /*888. Fair Candy Swap (Easy)
    Alice and Bob have candy bars of different sizes: A[i] is the size of the
    i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of
    candy that Bob has. Since they are friends, they would like to exchange one
    candy bar each so that after the exchange, they both have the same total
    amount of candy.  (The total amount of candy a person has is the sum of the
    sizes of candy bars they have.) Return an integer array ans where ans[0] is
    the size of the candy bar that Alice must exchange, and ans[1] is the size
    of the candy bar that Bob must exchange. If there are multiple answers, you
    may return any one of them.  It is guaranteed an answer exists.

    Example 1:
    Input: A = [1,1], B = [2,2]
    Output: [1,2]

    Example 2:
    Input: A = [1,2], B = [2,3]
    Output: [1,2]

    Example 3:
    Input: A = [2], B = [1,3]
    Output: [2,3]

    Example 4:
    Input: A = [1,2,5], B = [2,4]
    Output: [5,4]

    Note:
    * 1 <= A.length <= 10000
    * 1 <= B.length <= 10000
    * 1 <= A[i] <= 100000
    * 1 <= B[i] <= 100000
    * It is guaranteed that Alice and Bob have different total amounts of candy.
    * It is guaranteed there exists an answer.*/

    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {
        int diff = accumulate(A.begin(), A.end(), 0) - accumulate(B.begin(), B.end(), 0);
        unordered_set<int> seen(A.begin(), A.end());
        for (auto x : B) {
            if (seen.find(x + diff/2) != seen.end()) {
                return {x + diff/2, x};
            }
        }
        return {};
    }


    /*890. Find and Replace Pattern (Medium)
    Given a list of strings words and a string pattern, return a list of words[i]
    that match pattern. You may return the answer in any order. A word matches
    the pattern if there exists a permutation of letters p so that after
    replacing every letter x in the pattern with p(x), we get the desired word.
    Recall that a permutation of letters is a bijection from letters to letters:
    every letter maps to another letter, and no two letters map to the same
    letter.

    Example 1:
    Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
    Output: ["mee","aqq"]
    Explanation: "mee" matches the pattern because there is a permutation
                 {a -> m, b -> e, ...}. "ccc" does not match the pattern
                 because {a -> c, b -> c, ...} is not a permutation, since a
                 and b map to the same letter.

    Example 2:
    Input: words = ["a","b","c"], pattern = "a"
    Output: ["a","b","c"]

    Constraints:
    * 1 <= pattern.length <= 20
    * 1 <= words.length <= 50
    * words[i].length == pattern.length
    * pattern and words[i] are lowercase English letters.*/

    vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
        vector<string> ans;
        for (auto& word : words) {
            bool flag = true;
            unordered_map<char, char> mpw, mpp;
            for (int i = 0; i < size(word); ++i) {
                if (mpw[word[i]] != mpp[pattern[i]]) {
                    flag = false;
                    break;
                }
                mpw[word[i]] = mpp[pattern[i]] = i+1;
            }
            if (flag) ans.push_back(word);
        }
        return ans;
    }


    /*891. Sum of Subsequence Widths (Hard)
    The width of a sequence is the difference between the maximum and minimum
    elements in the sequence. Given an array of integers nums, return the sum
    of the widths of all the non-empty subsequences of nums. Since the answer
    may be very large, return it modulo 10^9 + 7. A subsequence is a sequence
    that can be derived from an array by deleting some or no elements without
    changing the order of the remaining elements. For example, [3,6,2,7] is a
    subsequence of the array [0,3,1,6,2,2,7].

    Example 1:
    Input: nums = [2,1,3]
    Output: 6
    Explanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3],
                 [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2.
                 The sum of these widths is 6.

    Example 2:
    Input: nums = [2]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    int sumSubseqWidths(vector<int>& nums) {
        int n = nums.size(), MOD = 1'000'000'007;
        vector<long> p(n, 1);
        for (int i = 1; i < n; ++i) p[i] = 2*p[i-1]%MOD;

        long ans = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n; ++i)
            ans = (ans + nums[i] * (p[i] - p[n-1-i])) % MOD;
        return ans;
    }


    /*892. Surface Area of 3D Shapes (Easy)
    You are given an n x n grid where you have placed some 1 x 1 x 1 cubes.
    Each value v = grid[i][j] represents a tower of v cubes placed on top of
    cell (i, j). After placing these cubes, you have decided to glue any
    directly adjacent cubes to each other, forming several irregular 3D shapes.
    Return the total surface area of the resulting shapes. Note: The bottom
    face of each shape counts toward its surface area.

    Example 1:
    Input: grid = [[2]]
    Output: 10

    Example 2:
    Input: grid = [[1,2],[3,4]]
    Output: 34

    Example 3:
    Input: grid = [[1,0],[0,2]]
    Output: 16

    Example 4:
    Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
    Output: 32

    Example 5:
    Input: grid = [[2,2,2],[2,1,2],[2,2,2]]
    Output: 46

    Constraints:
    * n == grid.length
    * n == grid[i].length
    * 1 <= n <= 50
    * 0 <= grid[i][j] <= 50*/

    int surfaceArea(vector<vector<int>>& grid) {
        int ans = 0, n = grid.size();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j]) {
                    ans += 4*grid[i][j] + 2;
                    if (i) ans -= 2*min(grid[i][j], grid[i-1][j]);
                    if (j) ans -= 2*min(grid[i][j], grid[i][j-1]);
                }
            }
        }
        return ans;
    }


    /*893. Groups of Special-Equivalent Strings (Easy)
    You are given an array A of strings. A move onto S consists of swapping any
    two even indexed characters of S, or any two odd indexed characters of S.
    Two strings S and T are special-equivalent if after any number of moves
    onto S, S == T. For example, S = "zzxy" and T = "xyzz" are special-
    equivalent because we may make the moves "zzxy" -> "xzzy" -> "xyzz" that
    swap S[0] and S[2], then S[1] and S[3]. Now, a group of special-equivalent
    strings from A is a non-empty subset of A such that:
    1) Every pair of strings in the group are special equivalent, and;
    2) The group is the largest size possible (ie., there isn't a string S not
       in the group such that S is special equivalent to every string in the
       group)
    Return the number of groups of special-equivalent strings from A.

    Example 1:
    Input: ["abcd","cdab","cbad","xyzz","zzxy","zzyx"]
    Output: 3
    Explanation: One group is ["abcd", "cdab", "cbad"], since they are all
                 pairwise special equivalent, and none of the other strings are
                 all pairwise special equivalent to these. The other two groups
                 are ["xyzz", "zzxy"] and ["zzyx"].  Note that in particular,
                 "zzxy" is not special equivalent to "zzyx".

    Example 2:
    Input: ["abc","acb","bac","bca","cab","cba"]
    Output: 3

    Note:
    * 1 <= A.length <= 1000
    * 1 <= A[i].length <= 20
    * All A[i] have the same length.
    * All A[i] consist of only lowercase letters.*/

    int numSpecialEquivGroups(vector<string>& A) {
        unordered_set<string> seen;
        for (auto word : A) {
            string even, odd;
            for (int i = 0; i < word.size(); ++i) {
                if (i&1) odd.push_back(word[i]);
                else even.push_back(word[i]);
            }
            sort(even.begin(), even.end());
            sort(odd.begin(), odd.end());
            seen.insert(even+odd);
        }
        return seen.size();
    }


    /*896. Monotonic Array (Easy)
    An array is monotonic if it is either monotone increasing or monotone
    decreasing. An array A is monotone increasing if for all i <= j, A[i] <= A[j].
    An array A is monotone decreasing if for all i <= j, A[i] >= A[j]. Return
    true if and only if the given array A is monotonic.

    Example 1:
    Input: [1,2,2,3]
    Output: true

    Example 2:
    Input: [6,5,4,4]
    Output: true

    Example 3:
    Input: [1,3,2]
    Output: false

    Example 4:
    Input: [1,2,4,5]
    Output: true

    Example 5:
    Input: [1,1,1]
    Output: true

    Note:
    * 1 <= A.length <= 50000
    * -100000 <= A[i] <= 100000*/

    bool isMonotonic(vector<int>& A) {
        bool increase = true, decrease = true;
        for (int i = 1; i < A.size(); ++i) {
            if (A[i-1] < A[i]) decrease = false;
            if (A[i-1] > A[i]) increase = false;
        }
        return increase || decrease;
    }


    /*897. Increasing Order Search Tree (Easy)
    Given the root of a binary search tree, rearrange the tree in in-order so
    that the leftmost node in the tree is now the root of the tree, and every
    node has no left child and only one right child.

    Example 1:
    Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
    Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

    Example 2:
    Input: root = [5,1,7]
    Output: [1,null,5,null,7]

    Constraints:
    * The number of nodes in the given tree will be in the range [1, 100].
    * 0 <= Node.val <= 1000*/

    TreeNode* increasingBST(TreeNode* root) {
        stack<TreeNode*> stk;
        TreeNode *node = root, *prev = NULL, *head = NULL;

        while (stk.size() || node) {
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top();
                stk.pop();
                if (prev == NULL) {
                    head = prev = node;
                } else {
                    prev = prev->right = node;
                }
                node->left = NULL;
                node = node->right;
            }
        }
        return head;
    }


    /*899. Orderly Queue (Hard)
    A string s of lowercase letters is given. Then, we may make any number of
    moves. In each move, we choose one of the first k letters (starting from
    the left), remove it, and place it at the end of the string. Return the
    lexicographically smallest string we could have after any number of moves.

    Example 1:
    Input: s = "cba", k = 1
    Output: "acb"
    Explanation: In the first move, we move the 1st character ("c") to the end,
                 obtaining the string "bac". In the second move, we move the
                 1st character ("b") to the end, obtaining the final result
                 "acb".

    Example 2:
    Input: s = "baaca", k = 3
    Output: "aaabc"
    Explanation: In the first move, we move the 1st character ("b") to the end,
                 obtaining the string "aacab". In the second move, we move the
                 3rd character ("c") to the end, obtaining the final result
                 "aaabc".

    Note:
    * 1 <= k <= s.length <= 1000
    * s consists of lowercase letters only.*/

    string orderlyQueue(string s, int k) {
        string ans = s;
        if (k == 1)
            for (int i = 1; i < s.size(); ++i)
                ans = min(ans, s.substr(i) + s.substr(0, i));
        else
            sort(ans.begin(), ans.end());
        return ans;
    }


    /*902. Numbers At Most N Given Digit Set (Hard)
    Given an array of digits which is sorted in non-decreasing order. You can
    write numbers using each digits[i] as many times as we want. For example,
    if digits = ['1','3','5'], we may write numbers such as '13', '551', and
    '1351315'. Return the number of positive integers that can be generated
    that are less than or equal to a given integer n.

    Example 1:
    Input: digits = ["1","3","5","7"], n = 100
    Output: 20
    Explanation: The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13,
                 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.

    Example 2:
    Input: digits = ["1","4","9"], n = 1000000000
    Output: 29523
    Explanation: We can write 3 one digit numbers, 9 two digit numbers, 27
                 three digit numbers, 81 four digit numbers, 243 five digit
                 numbers, 729 six digit numbers, 2187 seven digit numbers, 6561
                 eight digit numbers, and 19683 nine digit numbers. In total,
                 this is 29523 integers that can be written using the digits
                 array.

    Example 3:
    Input: digits = ["7"], n = 8
    Output: 1

    Constraints:
    * 1 <= digits.length <= 9
    * digits[i].length == 1
    * digits[i] is a digit from '1' to '9'.
    * All the values in digits are unique.
    * digits is sorted in non-decreasing order.
    * 1 <= n <= 10^9*/

    int atMostNGivenDigitSet(vector<string>& digits, int n) {
        string s = to_string(n);
        int ans = 0, sz = digits.size();
        for (int i = 1, p = sz; i < s.size(); ++i, p *= sz) ans += p;
        for (int i = 0, p = pow(sz, s.size()-1); i < s.size(); ++i, p /= sz) {
            string ch = string(1, s[i]);
            bool found = false;
            for (auto& x : digits) {
                if (x < ch) ans += p;
                if (x == ch) found = true;
            }
            if (!found) return ans;
        }
        return ans + 1;
    }


    /*904. Fruit Into Baskets (Medium)
    You are visiting a farm that has a single row of fruit trees arranged from
    left to right. The trees are represented by an integer array fruits where
    fruits[i] is the type of fruit the ith tree produces. You want to collect
    as much fruit as possible. However, the owner has some strict rules that
    you must follow:
    * You only have two baskets, and each basket can only hold a single type of
      fruit. There is no limit on the amount of fruit each basket can hold.
    * Starting from any tree of your choice, you must pick exactly one fruit
      from every tree (including the start tree) while moving to the right. The
      picked fruits must fit in one of your baskets.
    * Once you reach a tree with fruit that cannot fit in your baskets, you
      must stop.
    Given the integer array fruits, return the maximum number of fruits you can
    pick.

    Example 1:
    Input: fruits = [1,2,1]
    Output: 3
    Explanation: We can pick from all 3 trees.

    Example 2:
    Input: fruits = [0,1,2,2]
    Output: 3
    Explanation: We can pick from trees [1,2,2]. If we had started at the first
                 tree, we would only pick from trees [0,1].

    Example 3:
    Input: fruits = [1,2,3,2,2]
    Output: 4
    Explanation: We can pick from trees [2,3,2,2]. If we had started at the
                 first tree, we would only pick from trees [1,2].

    Constraints:
    * 1 <= fruits.length <= 10^5
    * 0 <= fruits[i] < fruits.length*/

    int totalFruit(vector<int>& fruits) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (int i = 0, ii = 0; i < fruits.size(); ++i) {
            ++freq[fruits[i]];
            while (freq.size() > 2) {
                if (--freq[fruits[ii]] == 0) freq.erase(fruits[ii]);
                ++ii;
            }
            ans = max(ans, i - ii + 1);
        }
        return ans;
    }


    /*905. Sort Array By Parity (Easy)
    Given an array A of non-negative integers, return an array consisting of
    all the even elements of A, followed by all the odd elements of A. You may
    return any answer array that satisfies this condition.

    Example 1:
    Input: [3,1,2,4]
    Output: [2,4,3,1]
    The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.

    Note:
    * 1 <= A.length <= 5000
    * 0 <= A[i] <= 5000*/

    vector<int> sortArrayByParity(vector<int>& A) {
        sort(A.begin(), A.end(), [](int i, int j){return (i&1) < (j&1);});
        return A;
    }


    /*908. Smallest Range I (Easy)
    Given an array A of integers, for each integer A[i] we may choose any x
    with -K <= x <= K, and add x to A[i]. After this process, we have some
    array B. Return the smallest possible difference between the maximum value
    of B and the minimum value of B.

    Example 1:
    Input: A = [1], K = 0
    Output: 0
    Explanation: B = [1]

    Example 2:
    Input: A = [0,10], K = 2
    Output: 6
    Explanation: B = [2,8]

    Example 3:
    Input: A = [1,3,6], K = 3
    Output: 0
    Explanation: B = [3,3,3] or B = [4,4,4]

    Note:
    * 1 <= A.length <= 10000
    * 0 <= A[i] <= 10000
    * 0 <= K <= 10000*/

    int smallestRangeI(vector<int>& A, int K) {
        int mn = *min_element(A.begin(), A.end());
        int mx = *max_element(A.begin(), A.end());
        return max(0, mx - mn - 2*K);
    }


    /*909. Snakes and Ladders (Medium)
    You are given an n x n integer matrix board where the cells are labeled
    from 1 to n2 in a Boustrophedon style starting from the bottom left of the
    board (i.e. board[n - 1][0]) and alternating direction each row. You start
    on square 1 of the board. In each move, starting from square curr, do the
    following:
    * Choose a destination square next with a label in the range
      [curr + 1, min(curr + 6, n2)].
      + This choice simulates the result of a standard 6-sided die roll: i.e.,
        there are always at most 6 destinations, regardless of the size of the
        board.
    * If next has a snake or ladder, you must move to the destination of that
      snake or ladder. Otherwise, you move to next.
    * The game ends when you reach the square n2.
    A board square on row r and column c has a snake or ladder if
    board[r][c] != -1. The destination of that snake or ladder is board[r][c].
    Squares 1 and n2 do not have a snake or ladder. Note that you only take a
    snake or ladder at most once per move. If the destination to a snake or
    ladder is the start of another snake or ladder, you do not follow the
    subsequent snake or ladder.
    * For example, suppose the board is [[-1,4],[-1,3]], and on the first move,
      your destination square is 2. You follow the ladder to square 3, but do
      not follow the subsequent ladder to 4.
    Return the least number of moves required to reach the square n2. If it is
    not possible to reach the square, return -1.

    Example 1:
    Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
    Output: 4
    Explanation: In the beginning, you start at square 1 (at row 5, column 0).
                 You decide to move to square 2 and must take the ladder to
                 square 15. You then decide to move to square 17 and must take
                 the snake to square 13. You then decide to move to square 14
                 and must take the ladder to square 35. You then decide to move
                 to square 36, ending the game. This is the lowest possible
                 number of moves to reach the last square, so return 4.

    Example 2:
    Input: board = [[-1,-1],[-1,3]]
    Output: 1

    Constraints:
    * n == board.length == board[i].length
    * 2 <= n <= 20
    * grid[i][j] is either -1 or in the range [1, n^2].
    * The squares labeled 1 and n2 do not have any ladders or snakes.*/

    int snakesAndLadders(vector<vector<int>>& board) {
        int n = board.size(), ans = 0;
        queue<int> q; q.push(1);
        vector<bool> seen(n*n, false); seen[0] = true;
        while (q.size()) {
            for (int sz = q.size(); sz; --sz) {
                int x = q.front(); q.pop();
                if (x == n*n) return ans;
                for (int xx = x+1; xx <= x+6 && xx <= n*n; ++xx) {
                    int i = (xx-1)/n, j = (xx-1)%n, jj = i&1 ? n-1-j : j, val = xx;
                    if (board[n-1-i][jj] != -1) val = board[n-1-i][jj];
                    if (!seen[val-1]) {
                        q.push(val);
                        seen[val-1] = true;
                    }
                }
            }
            ++ans;
        }
        return -1;
    }


    /*912. Sort an Array (Medium)
    Given an array of integers nums, sort the array in ascending order and
    return it. You must solve the problem without using any built-in functions
    in O(nlog(n)) time complexity and with the smallest space complexity
    possible.

    Example 1:
    Input: nums = [5,2,3,1]
    Output: [1,2,3,5]
    Explanation: After sorting the array, the positions of some numbers are not
                 changed (for example, 2 and 3), while the positions of other
                 numbers are changed (for example, 1 and 5).

    Example 2:
    Input: nums = [5,1,1,2,0,0]
    Output: [0,0,1,1,2,5]
    Explanation: Note that the values of nums are not necessairly unique.

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * -5 * 10^4 <= nums[i] <= 5 * 10^4*/

    vector<int> sortArray(vector<int>& nums) {
        auto rng = default_random_engine {};
        shuffle(nums.begin(), nums.end(), rng);

        function<void(int, int)> sort = [&](int lo, int hi) {
            if (lo+1 >= hi) return;
            int i = lo+1, j = hi-1;
            while (i <= j)
                if (nums[i] < nums[lo]) ++i;
                else if (nums[j] > nums[lo]) --j;
                else swap(nums[i++], nums[j--]);
            swap(nums[lo], nums[j]);
            sort(lo, j);
            sort(j+1, hi);
        };

        sort(0, nums.size());
        return nums;
    }


    /*914. X of a Kind in a Deck of Cards (Easy)
    In a deck of cards, each card has an integer written on it. Return true if
    and only if you can choose X >= 2 such that it is possible to split the
    entire deck into 1 or more groups of cards, where:
    * Each group has exactly X cards.
    * All the cards in each group have the same integer.

    Example 1:
    Input: deck = [1,2,3,4,4,3,2,1]
    Output: true
    Explanation: Possible partition [1,1],[2,2],[3,3],[4,4].

    Example 2:
    Input: deck = [1,1,1,2,2,2,3,3]
    Output: false
    Explanation: No possible partition.

    Example 3:
    Input: deck = [1]
    Output: false
    Explanation: No possible partition.

    Example 4:
    Input: deck = [1,1]
    Output: true
    Explanation: Possible partition [1,1].

    Example 5:
    Input: deck = [1,1,2,2,2,2]
    Output: true
    Explanation: Possible partition [1,1],[2,2],[2,2].

    Constraints:
    * 1 <= deck.length <= 10^4
    * 0 <= deck[i] < 10^4*/

    bool hasGroupsSizeX(vector<int>& deck) {
        unordered_map<int, int> freq;
        for (auto x : deck) ++freq[x];

        int ans = 0;
        for (auto x : freq)
            ans = gcd(ans, x.second);
        return ans >= 2;
    }


    /*915. Partition Array into Disjoint Intervals (Medium)
    Given an array nums, partition it into two (contiguous) subarrays left and
    right so that:
    * Every element in left is less than or equal to every element in right.
    * left and right are non-empty.
    * left has the smallest possible size.
    Return the length of left after such a partitioning.  It is guaranteed that
    such a partitioning exists.

    Example 1:
    Input: nums = [5,0,3,8,6]
    Output: 3
    Explanation: left = [5,0,3], right = [8,6]

    Example 2:
    Input: nums = [1,1,1,0,6,12]
    Output: 4
    Explanation: left = [1,1,1,0], right = [6,12]

    Note:
    * 2 <= nums.length <= 30000
    * 0 <= nums[i] <= 10^6
    * It is guaranteed there is at least one way to partition nums as described.*/

    int partitionDisjoint(vector<int>& nums) {
        int ans = 0, mx = nums[0], threshold = nums[0];
        for (int i = 0; i < nums.size(); ++i) {
            mx = max(mx, nums[i]);
            if (nums[i] < threshold) {
                ans = i;
                threshold = mx;
            }
        }
        return ans + 1;
    }


    /*917. Reverse Only Letters (Easy)
    Given a string S, return the "reversed" string where all characters that
    are not a letter stay in the same place, and all letters reverse their
    positions.

    Example 1:
    Input: "ab-cd"
    Output: "dc-ba"

    Example 2:
    Input: "a-bC-dEf-ghIj"
    Output: "j-Ih-gfE-dCba"

    Example 3:
    Input: "Test1ng-Leet=code-Q!"
    Output: "Qedo1ct-eeLg=ntse-T!"

    Note:
    * S.length <= 100
    * 33 <= S[i].ASCIIcode <= 122
    * S doesn't contain \ or "*/

    string reverseOnlyLetters(string S) {
        for (int lo = 0, hi = S.size() - 1; lo < hi; ) {
            if (!isalpha(S[lo])) ++lo;
            else if (!isalpha(S[hi])) --hi;
            else swap(S[lo++], S[hi--]);
        }
        return S;
    }


    /*918. Maximum Sum Circular Subarray (Medium)
    Given a circular integer array nums of length n, return the maximum
    possible sum of a non-empty subarray of nums. A circular array means the
    end of the array connects to the beginning of the array. Formally, the
    next element of nums[i] is nums[(i + 1) % n] and the previous element of
    nums[i] is nums[(i - 1 + n) % n]. A subarray may only include each element
    of the fixed buffer nums at most once. Formally, for a subarray nums[i],
    nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with
    k1 % n == k2 % n.

    Example 1:
    Input: nums = [1,-2,3,-2]
    Output: 3
    Explanation: Subarray [3] has maximum sum 3.

    Example 2:
    Input: nums = [5,-3,5]
    Output: 10
    Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.

    Example 3:
    Input: nums = [-3,-2,-3]
    Output: -2
    Explanation: Subarray [-2] has maximum sum -2.

    Constraints:
    * n == nums.length
    * 1 <= n <= 3 * 10^4
    * -3 * 10^4 <= nums[i] <= 3 * 10^4*/

    int maxSubarraySumCircular(vector<int>& nums) {
        int large = 0, small = 0, total = 0, most = INT_MIN, least = INT_MIN;
        for (auto& x : nums) {
            total += x;
            large = max(0, large) + x;
            most  = max(most, large);
            small = max(0, small - x);
            least = max(least, small);
        }
        return most >= 0 ? max(most, total + least) : most;
    }


    /*920. Number of Music Playlists (Hard)
    Your music player contains n different songs and she wants to listen to
    goal (not necessarily different) songs during your trip.  You create a
    playlist so that:
    * Every song is played at least once
    * A song can only be played again only if k other songs have been played
    Return the number of possible playlists.  As the answer can be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, goal = 3, k = 1
    Output: 6
    Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2],
                 [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

    Example 2:
    Input: n = 2, goal = 3, k = 0
    Output: 6
    Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1],
                 [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]

    Example 3:
    Input: n = 2, goal = 3, k = 1
    Output: 2
    Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]

    Note: 0 <= k < n <= goal <= 100*/

    int numMusicPlaylists(int n, int goal, int k) {
        const int MOD = 1'000'000'007;
        vector<vector<long>> dp(goal+1, vector<long>(n+1, 0));
        dp[goal][n] = 1l;
        for (int i = goal-1; i >= 0; --i) {
            for (int j = n; j >= 0; --j) {
                if (j < n) dp[i][j] = (dp[i][j] + (n-j) * dp[i+1][j+1]) % MOD;
                if (k < j) dp[i][j] = (dp[i][j] + (j-k) * dp[i+1][j]) % MOD;
            }
        }
        return dp[0][0];
    }


    /*922. Sort Array By Parity II (Easy)
    Given an array of integers nums, half of the integers in nums are odd, and
    the other half are even. Sort the array so that whenever nums[i] is odd, i
    is odd, and whenever nums[i] is even, i is even. Return any answer array
    that satisfies this condition.

    Example 1:
    Input: nums = [4,2,5,7]
    Output: [4,5,2,7]
    Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.

    Example 2:
    Input: nums = [2,3]
    Output: [2,3]

    Constraints:
    * 2 <= nums.length <= 2 * 10^4
    * nums.length is even.
    * Half of the integers in nums are even.
    * 0 <= nums[i] <= 1000

    Follow Up: Could you solve it in-place?*/

    vector<int> sortArrayByParityII(vector<int>& nums) {
        for (int ii = 0, i = 1; ii < nums.size() && i < nums.size(); )
            if (!(nums[ii]&1)) ii += 2;
            else if (nums[i]&1) i += 2;
            else {
                swap(nums[ii], nums[i]);
                ii += 2;
                i += 2;
            }
        return nums;
    }


    /*924. Minimize Malware Spread (Hard)
    You are given a network of n nodes represented as an n x n adjacency matrix
    graph, where the ith node is directly connected to the jth node if
    graph[i][j] == 1. Some nodes initial are initially infected by malware.
    Whenever two nodes are directly connected, and at least one of those two
    nodes is infected by malware, both nodes will be infected by malware. This
    spread of malware will continue until no more nodes can be infected in this
    manner. Suppose M(initial) is the final number of nodes infected with
    malware in the entire network after the spread of malware stops. We will
    remove exactly one node from initial. Return the node that, if removed,
    would minimize M(initial). If multiple nodes could be removed to minimize
    M(initial), return such a node with the smallest index. Note that if a node
    was removed from the initial list of infected nodes, it might still be
    infected later due to the malware spread.

    Example 1:
    Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
    Output: 0

    Example 2:
    Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
    Output: 0

    Example 3:
    Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
    Output: 1

    Constraints:
    * n == graph.length
    * n == graph[i].length
    * 2 <= n <= 300
    * graph[i][j] is 0 or 1.
    * graph[i][j] == graph[j][i]
    * graph[i][i] == 1
    * 1 <= initial.length <= n
    * 0 <= initial[i] <= n - 1
    * All the integers in initial are unique.*/

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        UnionFind *uf = new UnionFind(n);

        for (int i = 0; i < n; ++i)
            for (int j = i+1; j < n; ++j)
                if (graph[i][j]) uf->connect(i, j);

        unordered_map<int, int> freq;
        for (auto& i : initial) ++freq[uf->find(i)];

        int ans = INT_MAX, most = 0;
        for (auto& i : initial) {
            int p = uf->find(i), rank = 0;
            if (freq[p] == 1) rank = uf->rank[p];
            if (rank > most || (rank == most && i < ans)) ans = i, most = rank;
        }

        delete uf;
        return ans;
    }


    /*925. Long Pressed Name (Easy)
    Your friend is typing his name into a keyboard. Sometimes, when typing a
    character c, the key might get long pressed, and the character will be
    typed 1 or more times. You examine the typed characters of the keyboard.
    Return True if it is possible that it was your friends name, with some
    characters (possibly none) being long pressed.

    Example 1:
    Input: name = "alex", typed = "aaleex"
    Output: true
    Explanation: 'a' and 'e' in 'alex' were long pressed.

    Example 2:
    Input: name = "saeed", typed = "ssaaedd"
    Output: false
    Explanation: 'e' must have been pressed twice, but it wasn't in the typed output.

    Example 3:
    Input: name = "leelee", typed = "lleeelee"
    Output: true

    Example 4:
    Input: name = "laiden", typed = "laiden"
    Output: true
    Explanation: It's not necessary to long press any character.

    Constraints:
    * 1 <= name.length <= 1000
    * 1 <= typed.length <= 1000
    * name and typed contain only lowercase English letters.*/

    bool isLongPressedName(string name, string typed) {
        int i = 0;
        for (int j = 0; j < typed.size(); ++j) {
            if (i < name.size() && name[i] == typed[j]) ++i;
            else if (i == 0 || name[i-1] != typed[j]) return false;
        }
        return i == name.size();
    }


    /*926. Flip String to Monotone Increasing (Medium)
    A binary string is monotone increasing if it consists of some number of 0's
    (possibly none), followed by some number of 1's (also possibly none). You
    are given a binary string s. You can flip s[i] changing it from 0 to 1 or
    from 1 to 0. Return the minimum number of flips to make s monotone
    increasing.

    Example 1:
    Input: s = "00110"
    Output: 1
    Explanation: We flip the last digit to get 00111.

    Example 2:
    Input: s = "010110"
    Output: 2
    Explanation: We flip to get 011111, or alternatively 000111.

    Example 3:
    Input: s = "00011000"
    Output: 2
    Explanation: We flip to get 00000000.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'.*/

    int minFlipsMonoIncr(string s) {
        int ones = 0, flip = 0;
        for (auto& ch : s) {
            if (ch == '1') ones += 1;
            else flip = min(ones, flip + 1);
        }
        return flip;
    }


    /*928. Minimize Malware Spread II (Hard)
    You are given a network of n nodes represented as an n x n adjacency matrix
    graph, where the ith node is directly connected to the jth node if
    graph[i][j] == 1. Some nodes initial are initially infected by malware.
    Whenever two nodes are directly connected, and at least one of those two
    nodes is infected by malware, both nodes will be infected by malware. This
    spread of malware will continue until no more nodes can be infected in this
    manner. Suppose M(initial) is the final number of nodes infected with
    malware in the entire network after the spread of malware stops. We will
    remove exactly one node from initial, completely removing it and any
    connections from this node to any other node. Return the node that, if
    removed, would minimize M(initial). If multiple nodes could be removed to
    minimize M(initial), return such a node with the smallest index.

    Example 1:
    Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
    Output: 0

    Example 2:
    Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
    Output: 1

    Example 3:
    Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
    Output: 1

    Constraints:
    * n == graph.length
    * n == graph[i].length
    * 2 <= n <= 300
    * graph[i][j] is 0 or 1.
    * graph[i][j] == graph[j][i]
    * graph[i][i] == 1
    * 1 <= initial.length < n
    * 0 <= initial[i] <= n - 1
    * All the integers in initial are unique.*/

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> infect(n, false);
        for (auto& x : initial) infect[x] = true;

        UnionFind* uf = new UnionFind(n);
        for (int u = 0; u < n; ++u)
            if (!infect[u])
                for (int v = 0; v < n; ++v)
                    if (!infect[v] && graph[u][v])
                        uf->connect(u, v);

        unordered_map<int, unordered_set<int>> mp;
        for (auto& u : initial)
            for (int v = 0; v < n; ++v)
                if (!infect[v] && graph[u][v])
                    mp[u].insert(uf->find(v));

        unordered_map<int, int> freq;
        for (auto& [k, v] : mp)
            for (auto& x : v) ++freq[x];

        int best = -1, ans = -1;
        for (auto& u : initial) {
            int cnt = 0;
            for (auto& v : mp[u])
                if (freq[v] == 1) cnt += uf->rank[v];
            if (cnt > best || (cnt == best && u < ans))
                ans = u, best = cnt;
        }
        return ans;
    }


    /*929. Unique Email Addresses (Easy)
    Every valid email consists of a local name and a domain name, separated by
    the '@' sign. Besides lowercase letters, the email may contain one or more
    '.' or '+'. For example, in "alice@leetcode.com", "alice" is the local name,
    and "leetcode.com" is the domain name. If you add periods '.' between some
    characters in the local name part of an email address, mail sent there will
    be forwarded to the same address without dots in the local name. Note that
    this rule does not apply to domain names.

    For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to
    the same email address. If you add a plus '+' in the local name, everything
    after the first plus sign will be ignored. This allows certain emails to be
    filtered. Note that this rule does not apply to domain names. For example,
    "m.y+name@email.com" will be forwarded to "my@email.com". It is possible to
    use both of these rules at the same time. Given an array of strings emails
    where we send one email to each email[i], return the number of different
    addresses that actually receive mails.

    Example 1:
    Input: emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
    Output: 2
    Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails.

    Example 2:
    Input: emails = ["a@leetcode.com","b@leetcode.com","c@leetcode.com"]
    Output: 3

    Constraints:
    * 1 <= emails.length <= 100
    * 1 <= emails[i].length <= 100
    * email[i] consist of lowercase English letters, '+', '.' and '@'.
    * Each emails[i] contains exactly one '@' character.
    * All local and domain names are non-empty.
    * Local names do not start with a '+' character.*/

    int numUniqueEmails(vector<string>& emails) {
        unordered_set<string> ans;
        for (auto email : emails) {
            string key = "";
            for (auto x : email) {
                if (x == '+' || x == '@') break;
                if (x != '.') key.push_back(x);
            }
            key += email.substr(email.find('@'));
            ans.insert(key);
        }
        return ans.size();
    }


    /*931. Minimum Falling Path Sum (Medium)
    Given an n x n array of integers matrix, return the minimum sum of any
    falling path through matrix. A falling path starts at any element in the
    first row and chooses the element in the next row that is either directly
    below or diagonally left/right. Specifically, the next element from
    position (row, col) will be (row + 1, col - 1), (row + 1, col), or
    (row + 1, col + 1).

    Example 1:
    Input: matrix = [[2,1,3],[6,5,4],[7,8,9]]
    Output: 13
    Explanation: There are two falling paths with a minimum sum underlined
                 below:
                 [[2,1,3],      [[2,1,3],
                  [6,5,4],       [6,5,4],
                  [7,8,9]]       [7,8,9]]

    Example 2:
    Input: matrix = [[-19,57],[-40,-5]]
    Output: -59
    Explanation: The falling path with a minimum sum is underlined below:
                 [[-19,57],
                  [-40,-5]]

    Example 3:
    Input: matrix = [[-48]]
    Output: -48

    Constraints:
    * n == matrix.length
    * n == matrix[i].length
    * 1 <= n <= 100
    * -100 <= matrix[i][j] <= 100*/

    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 1; i < n; ++i)
            for (int j = 0; j < n; ++j) {
                int small = matrix[i-1][j];
                if (j > 0) small = min(small, matrix[i-1][j-1]);
                if (j+1 < n) small = min(small, matrix[i-1][j+1]);
                matrix[i][j] += small;
            }
        return *min_element(matrix[n-1].begin(), matrix[n-1].end());
    }


    /*932. Beautiful Array (Medium)
    For some fixed n, an array nums is beautiful if it is a permutation of the
    integers 1, 2, ..., n, such that for every i < j, there is no k with
    i < k < j such that nums[k] * 2 = nums[i] + nums[j]. Given n, return any
    beautiful array nums. (It is guaranteed that one exists.)

    Example 1:
    Input: n = 4
    Output: [2,1,4,3]

    Example 2:
    Input: n = 5
    Output: [3,1,2,5,4]

    Note: 1 <= n <= 1000*/

    vector<int> beautifulArray(int n) {
        vector<int> ans = {1};
        while (ans.size() < n) {
            vector<int> tmp;
            for (auto& x : ans) if (2*x-1 <= n) tmp.push_back(2*x-1);
            for (auto& x : ans) if (2*x <= n) tmp.push_back(2*x);
            ans = tmp;
        }
        return ans;
    }


    /*937. Reorder Data in Log Files (Easy)
    You are given an array of logs. Each log is a space-delimited string of
    words, where the first word is the identifier. There are two types of logs:
    * Letter-logs: All words (except the identifier) consist of lowercase
      English letters.
    * Digit-logs: All words (except the identifier) consist of digits.

    Reorder these logs so that:
    * The letter-logs come before all digit-logs.
    * The letter-logs are sorted lexicographically by their contents. If their
      contents are the same, then sort them lexicographically by their
      identifiers.
    * The digit-logs maintain their relative ordering.
    Return the final order of the logs.

    Example 1:
    Input: logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
    Output: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]
    Explanation:
    The letter-log contents are all different, so their ordering is "art can", "art zero", "own kit dig".
    The digit-logs have a relative order of "dig1 8 1 5 1", "dig2 3 6".

    Example 2:
    Input: logs = ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
    Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]

    Constraints:
    * 1 <= logs.length <= 100
    * 3 <= logs[i].length <= 100
    * All the tokens of logs[i] are separated by a single space.
    * logs[i] is guaranteed to have an identifier and at least one word after
      the identifier.*/

    vector<string> reorderLogFiles(vector<string>& logs) {
        vector<pair<string, string>> letter_logs;
        vector<string> digit_logs;
        for (auto log : logs) {
            int i = log.find(' ');
            if (isalpha(log[i+1]))
                letter_logs.emplace_back(log.substr(0, i), log.substr(i+1));
            else
                digit_logs.push_back(log);
        }

        sort(letter_logs.begin(), letter_logs.end(), [&](auto& lhs, auto& rhs) {
            return lhs.second < rhs.second || (lhs.second == rhs.second && lhs.first < rhs.first);
        });

        vector<string> ans;
        for (auto x : letter_logs)
            ans.push_back(x.first + " " + x.second);

        ans.insert(ans.end(), digit_logs.begin(), digit_logs.end());
        return ans;
    }


    /*938. Range Sum of BST (Easy)
    Given the root node of a binary search tree, return the sum of values of
    all nodes with a value in the range [low, high].

    Example 1:
    Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
    Output: 32

    Example 2:
    Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
    Output: 23

    Constraints:
    * The number of nodes in the tree is in the range [1, 2 * 10^4].
    * 1 <= Node.val <= 10^5
    * 1 <= low <= high <= 10^5
    * All Node.val are unique.*/

    int rangeSumBST(TreeNode* root, int low, int high) {
        int ans = 0;
        stack<TreeNode*> stk;
        stk.push(root);
        while (stk.size()) {
            TreeNode* node = stk.top();
            stk.pop();
            if (node) {
                if (low <= node->val && node->val <= high) ans += node->val;
                if (node->val < high) stk.push(node->right);
                if (low < node->val) stk.push(node->left);
            }
        }
        return ans;
    }


    /*940. Distinct Subsequences II (Hard)
    Given a string s, return the number of distinct non-empty subsequences of s.
    Since the answer may be very large, return it modulo 10^9 + 7. A
    subsequence of a string is a new string that is formed from the original
    string by deleting some (can be none) of the characters without disturbing
    the relative positions of the remaining characters. (i.e., "ace" is a
    subsequence of "abcde" while "aec" is not.

    Example 1:
    Input: s = "abc"
    Output: 7
    Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac",
                 "bc", and "abc".

    Example 2:
    Input: s = "aba"
    Output: 6
    Explanation: The 6 distinct subsequences are "a", "b", "ab", "aa", "ba",
                 and "aba".

    Example 3:
    Input: s = "aaa"
    Output: 3
    Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".

    Constraints:
    * 1 <= s.length <= 2000
    * s consists of lowercase English letters.*/

    int distinctSubseqII(string s) {
        vector<long> freq(26);
        for (int i = s.size()-1; i >= 0; --i)
            freq[s[i]-'a'] = accumulate(freq.begin(), freq.end(), 1l) % 1'000'000'007;
        return accumulate(freq.begin(), freq.end(), 0l) % 1'000'000'007;
    }


    /*941. Valid Mountain Array (Easy)
    Given an array of integers arr, return true if and only if it is a valid
    mountain array. Recall that arr is a mountain array if and only if:
    * arr.length >= 3
    * There exists some i with 0 < i < arr.length - 1 such that:
      - arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
      - arr[i] > arr[i + 1] > ... > arr[arr.length - 1]

    Example 1:
    Input: arr = [2,1]
    Output: false

    Example 2:
    Input: arr = [3,5,5]
    Output: false

    Example 3:
    Input: arr = [0,3,2,1]
    Output: true

    Constraints:
    * 1 <= arr.length <= 10^4
    * 0 <= arr[i] <= 10^4*/

    bool validMountainArray(vector<int>& arr) {
        int lo = 0, hi = arr.size()-1;
        for (; lo < hi && arr[lo] < arr[lo+1]; ++lo);
        for (; lo < hi && arr[hi-1] > arr[hi]; --hi);
        return 0 < lo && lo == hi && hi < arr.size()-1;
    }


    /*942. DI String Match (Easy)
    A permutation perm of n + 1 integers of all the integers in the range [0, n]
    can be represented as a string s of length n where:
    * s[i] == 'I' if perm[i] < perm[i + 1], and
    * s[i] == 'D' if perm[i] > perm[i + 1].
    Given a string s, reconstruct the permutation perm and return it. If there
    are multiple valid permutations perm, return any of them.

    Example 1:
    Input: s = "IDID"
    Output: [0,4,1,3,2]

    Example 2:
    Input: s = "III"
    Output: [0,1,2,3]

    Example 3:
    Input: s = "DDI"
    Output: [3,2,0,1]

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either 'I' or 'D'.*/

    vector<int> diStringMatch(string s) {
        vector<int> ans;
        for (int i = 0, lo = 0, hi = s.size(); i <= s.size(); i++) {
            if (i == s.size() || s[i] == 'I') ans.push_back(lo++);
            else ans.push_back(hi--);
        }
        return ans;
    }


    /*943. Find the Shortest Superstring (Hard)
    Given an array of strings words, return the smallest string that contains
    each string in words as a substring. If there are multiple valid strings of
    the smallest length, return any of them. You may assume that no string in
    words is a substring of another string in words.

    Example 1:
    Input: words = ["alex","loves","leetcode"]
    Output: "alexlovesleetcode"
    Explanation: All permutations of "alex","loves","leetcode" would also be
                 accepted.

    Example 2:
    Input: words = ["catg","ctaagt","gcta","ttca","atgcatc"]
    Output: "gctaagttcatgcatc"

    Constraints:
    * 1 <= words.length <= 12
    * 1 <= words[i].length <= 20
    * words[i] consists of lowercase English letters.
    * All the strings of words are unique.*/

    string shortestSuperstring(vector<string>& words) {
        int n = size(words);

        vector<vector<int>> ovlp (n, vector<int>(n));
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                for (int k = 0; k < min(size(words[i]), size(words[j])); ++k)
                    if (words[i].substr(size(words[i]) - k) == words[j].substr(0, k)) {
                        ovlp[i][j] = k;
                    }

        vector<vector<int>> dp(1<<n, vector<int>(n)); // min length of mask ending at bit
        vector<vector<int>> parent(1<<n, vector<int>(n, -1));
        for (int mask = 0; mask < (1 << n); ++mask) {
            for (int bit = 0; bit < n; ++bit) {
                if (mask & 1<<bit) {
                    int pmask = mask ^ (1<<bit);
                    if (pmask) {
                        for (int i = 0; i < n; ++i) {
                            if (pmask & 1<<i) {
                                int val = dp[pmask][i] + size(words[bit]) - ovlp[i][bit];
                                if (dp[mask][bit] == 0 || val < dp[mask][bit]) {
                                    dp[mask][bit] = val;
                                    parent[mask][bit] = i;
                                }
                            }
                        }
                    }
                    else dp[mask][bit] = size(words[bit]);
                }
            }
        }

        auto it = min_element(begin(dp.back()), end(dp.back()));
        int mask = (1<<n) - 1, p = it - begin(dp.back());
        string ans;
        while (mask) {
            int pp = parent[mask][p];
            if (pp == -1) ans = words[p] + ans;
            else ans = words[p].substr(ovlp[pp][p]) + ans;
            mask ^= 1 << p;
            p = pp;
        }
        return ans;
    }


    /*944. Delete Columns to Make Sorted (Easy)
    You are given an array of n strings strs, all of the same length. The
    strings can be arranged such that there is one on each line, making a grid.
    For example, strs = ["abc", "bce", "cae"] can be arranged as:
    abc
    bce
    cae
    You want to delete the columns that are not sorted lexicographically. In
    the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2
    ('c', 'e', 'e') are sorted while column 1 ('b', 'c', 'a') is not, so you
    would delete column 1. Return the number of columns that you will delete.

    Example 1:
    Input: strs = ["cba","daf","ghi"]
    Output: 1
    Explanation: The grid looks as follows:
      cba
      daf
      ghi
    Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete
    1 column.

    Example 2:
    Input: strs = ["a","b"]
    Output: 0
    Explanation: The grid looks as follows:
      a
      b
    Column 0 is the only column and is sorted, so you will not delete any columns.

    Example 3:
    Input: strs = ["zyx","wvu","tsr"]
    Output: 3
    Explanation: The grid looks as follows:
      zyx
      wvu
      tsr
    All 3 columns are not sorted, so you will delete all 3.

    Constraints:
    * n == strs.length
    * 1 <= n <= 100
    * 1 <= strs[i].length <= 1000
    * strs[i] consists of lowercase English letters.*/

    int minDeletionSize(vector<string>& strs) {
        int ans = 0;
        for (int j = 0; j < strs[0].size(); ++j) {
            for (int i = 1; i < strs.size(); ++i) {
                if (strs[i-1][j] > strs[i][j]) {
                    ++ans;
                    break;
                }
            }
        }
        return ans;
    }


    /*947. Most Stones Removed with Same Row or Column (Medium)
    On a 2D plane, we place n stones at some integer coordinate points. Each
    coordinate point may have at most one stone. A stone can be removed if it
    shares either the same row or the same column as another stone that has not
    been removed. Given an array stones of length n where stones[i] = [xi, yi]
    represents the location of the ith stone, return the largest possible number
    of stones that can be removed.

    Example 1:
    Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
    Output: 5
    Explanation: One way to remove 5 stones is as follows:
                 1. Remove stone [2,2] because it shares the same row as [2,1].
                 2. Remove stone [2,1] because it shares the same column as
                    [0,1].
                 3. Remove stone [1,2] because it shares the same row as [1,0].
                 4. Remove stone [1,0] because it shares the same column as
                    [0,0].
                 5. Remove stone [0,1] because it shares the same row as [0,0].
                 Stone [0,0] cannot be removed since it does not share a
                 row/column with another stone still on the plane.

    Example 2:
    Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
    Output: 3
    Explanation: One way to make 3 moves is as follows:
                 1. Remove stone [2,2] because it shares the same row as [2,0].
                 2. Remove stone [2,0] because it shares the same column as
                    [0,0].
                 3. Remove stone [0,2] because it shares the same row as [0,0].
                 Stones [0,0] and [1,1] cannot be removed since they do not
                 share a row/column with another stone still on the plane.

    Example 3:
    Input: stones = [[0,0]]
    Output: 0
    Explanation: [0,0] is the only stone on the plane, so you cannot remove it.

    Constraints:
    * 1 <= stones.length <= 1000
    * 0 <= xi, yi <= 10^4
    * No two stones are at the same coordinate point.*/

    int removeStones(vector<vector<int>>& stones) {
        unordered_map<int, int> parent;

        function<int(int)> find = [&](int p) {
            if (!parent.contains(p)) parent[p] = p;
            if (p != parent[p])
                parent[p] = find(parent[p]);
            return parent[p];
        };

        for (auto& s : stones) {
            int x = s[0], y = s[1];
            parent[find(x)] = find(-y-1);
        }
        unordered_set<int> group;
        for (auto& s : stones)
            group.insert(find(s[0]));
        return stones.size() - group.size();
    }


    /*948. Bag of Tokens (Medium)
    You start with an initial power of power, an initial score of 0, and a bag
    of tokens given as an integer array tokens, where each tokens[i] donates the
    value of tokeni. Your goal is to maximize the total score by strategically
    playing these tokens. In one move, you can play an unplayed token in one of
    the two ways (but not both for the same token):
    * Face-up: If your current power is at least tokens[i], you may play tokeni,
      losing tokens[i] power and gaining 1 score.
    * Face-down: If your current score is at least 1, you may play tokeni,
      gaining tokens[i] power and losing 1 score.
    Return the maximum possible score you can achieve after playing any number
    of tokens.

    Example 1:
    Input: tokens = [100], power = 50
    Output: 0
    Explanation: Since your score is 0 initially, you cannot play the token
                 face-down. You also cannot play it face-up since your power
                 (50) is less than tokens[0] (100).

    Example 2:
    Input: tokens = [200,100], power = 150
    Output: 1
    Explanation: Play token1 (100) face-up, reducing your power to 50 and
                 increasing your score to 1. There is no need to play token0,
                 since you cannot play it face-up to add to your score. The
                 maximum score achievable is 1.

    Example 3:
    Input: tokens = [100,200,300,400], power = 200
    Output: 2
    Explanation: Play the tokens in this order to get a score of 2:
                 - Play token0 (100) face-up, reducing power to 100 and
                   increasing score to 1.
                 - Play token3 (400) face-down, increasing power to 500 and
                   reducing score to 0.
                 - Play token1 (200) face-up, reducing power to 300 and
                   increasing score to 1.
                 - Play token2 (300) face-up, reducing power to 0 and increasing
                   score to 2.
                 - The maximum score achievable is 2.

    Constraints:
    * 0 <= tokens.length <= 1000
    * 0 <= tokens[i], power < 10^4*/

    int bagOfTokensScore(vector<int>& tokens, int power) {
        sort(tokens.begin(), tokens.end());
        int ans = 0;
        for (int lo = 0, hi = tokens.size()-1; lo <= hi; )
            if (tokens[lo] <= power) {
                ++ans;
                power -= tokens[lo++];
            } else if (ans && lo < hi) {
                --ans;
                power += tokens[hi--];
            } else break;
        return ans;
    }


    /*950. Reveal Cards In Increasing Order (Medium)
    You are given an integer array deck. There is a deck of cards where every
    card has a unique integer. The integer on the ith card is deck[i]. You can
    order the deck in any order you want. Initially, all the cards start face
    down (unrevealed) in one deck. You will do the following steps repeatedly
    until all cards are revealed:
    * Take the top card of the deck, reveal it, and take it out of the deck.
    * If there are still cards in the deck then put the next top card of the
      deck at the bottom of the deck.
    * If there are still unrevealed cards, go back to step 1. Otherwise, stop.
    Return an ordering of the deck that would reveal the cards in increasing
    order. Note that the first entry in the answer is considered to be the top
    of the deck.

    Example 1:
    Input: deck = [17,13,11,2,3,5,7]
    Output: [2,13,3,11,5,17,7]
    Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order
                 does not matter), and reorder it.
                 After reordering, the deck starts as [2,13,3,11,5,17,7], where
                 2 is the top of the deck.
                 - We reveal 2, and move 13 to the bottom.  The deck is now
                   [3,11,5,17,7,13].
                 - We reveal 3, and move 11 to the bottom.  The deck is now
                   [5,17,7,13,11].
                 - We reveal 5, and move 17 to the bottom.  The deck is now
                   [7,13,11,17].
                 - We reveal 7, and move 13 to the bottom.  The deck is now
                   [11,17,13].
                 - We reveal 11, and move 17 to the bottom.  The deck is now
                   [13,17].
                 - We reveal 13, and move 17 to the bottom.  The deck is now
                   [17].
                 - We reveal 17.
                 Since all the cards revealed are in increasing order, the
                 answer is correct.

    Example 2:
    Input: deck = [1,1000]
    Output: [1,1000]

    Constraints:
    * 1 <= deck.length <= 1000
    * 1 <= deck[i] <= 10^6
    * All the values of deck are unique.*/

    vector<int> deckRevealedIncreasing(vector<int>& deck) {
        deque<int> q;
        sort(deck.rbegin(), deck.rend());
        for (auto& x : deck) {
            if (q.size()) {
                q.push_front(q.back());
                q.pop_back();
            }
            q.push_front(x);
        }
        return vector<int>(q.begin(), q.end());
    }


    /*952. Largest Component Size by Common Factor (Hard)
    You are given an integer array of unique positive integers nums. Consider
    the following graph:
    * There are nums.length nodes, labeled nums[0] to nums[nums.length - 1],
    * There is an undirected edge between nums[i] and nums[j] if nums[i] and
      nums[j] share a common factor greater than 1.
    Return the size of the largest connected component in the graph.

    Example 1:
    Input: nums = [4,6,15,35]
    Output: 4

    Example 2:
    Input: nums = [20,50,9,63]
    Output: 2

    Example 3:
    Input: nums = [2,3,6,7,4,12,21,39]
    Output: 8

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= nums[i] <= 10^5
    * All the values of nums are unique.*/

    int largestComponentSize(vector<int>& nums) {
        int m = *max_element(nums.begin(), nums.end());
        vector<bool> seen(m+1);
        for (auto& x : nums) seen[x] = true;
        UnionFind* uf = new UnionFind(m+1);
        vector<bool> sieve(m+1, true);
        sieve[0] = sieve[1] = false;
        for (int x = 2; x <= m/2; ++x)
            if (sieve[x]) {
                int prev = seen[x] ? x : 0;
                for (int xx = 2*x; xx <= m; xx += x) {
                    sieve[xx] = false;
                    if (seen[xx])
                        if (prev) uf->connect(prev, xx);
                        else prev = xx;
                }
            }
        int ans = *max_element(uf->rank.begin(), uf->rank.end());
        delete uf;
        return ans;
    }


    /*953. Verifying an Alien Dictionary (Easy)
    In an alien language, surprisingly they also use english lowercase letters,
    but possibly in a different order. The order of the alphabet is some
    permutation of lowercase letters. Given a sequence of words written in the
    alien language, and the order of the alphabet, return true if and only if
    the given words are sorted lexicographicaly in this alien language.

    Example 1:
    Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
    Output: true
    Explanation: As 'h' comes before 'l' in this language, then the sequence is
                 sorted.

    Example 2:
    Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
    Output: false
    Explanation: As 'd' comes after 'l' in this language, then
                 words[0] > words[1], hence the sequence is unsorted.

    Example 3:
    Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
    Output: false
    Explanation: The first three characters "app" match, and the second string
                 is shorter (in size.) According to lexicographical rules
                 "apple" > "app", because 'l' > '∅', where '∅' is defined as
                 the blank character which is less than any other character
                 (More info).

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 20
    * order.length == 26
    * All characters in words[i] and order are English lowercase letters.*/

    bool isAlienSorted(vector<string>& words, string order) {
        vector<int> mp(26);
        for (int i = 0; i < 26; ++i)
            mp[order[i] - 'a'] = i;
        string prev;
        for (auto& word : words) {
            string curr;
            for (auto& ch : word) curr.push_back(mp[ch-'a'] + 'a');
            if (prev > curr) return false;
            prev = curr;
        }
        return true;
    }


    /*954. Array of Doubled Pairs (Medium)
    Given an array of integers arr of even length, return true if and only if
    it is possible to reorder it such that arr[2 * i + 1] = 2 * arr[2 * i] for
    every 0 <= i < len(arr) / 2.

    Example 1:
    Input: arr = [3,1,3,6]
    Output: false

    Example 2:
    Input: arr = [2,1,2,6]
    Output: false

    Example 3:
    Input: arr = [4,-2,2,-4]
    Output: true
    Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4]
                 or [2,4,-2,-4].

    Example 4:
    Input: arr = [1,2,4,16,8,4]
    Output: false

    Constraints:
    * 0 <= arr.length <= 3 * 10^4
    * arr.length is even.
    * -10^5 <= arr[i] <= 10^5*/

    bool canReorderDoubled(vector<int>& arr) {
        sort(arr.begin(), arr.end());

        unordered_map<int, int> freq;
        for (auto& x : arr) ++freq[x];

        for (auto& x : arr)
            if (freq[x] && freq[2*x]) { --freq[x]; --freq[2*x]; }
        for (auto& [k, v] : freq)
            if (v) return false;
        return true;
    }


    /*955. Delete Columns to Make Sorted II (Medium)
    You are given an array of n strings strs, all of the same length. We may
    choose any deletion indices, and we delete all the characters in those
    indices for each string. For example, if we have strs = ["abcdef","uvwxyz"]
    and deletion indices {0, 2, 3}, then the final array after deletions is
    ["bef", "vyz"]. Suppose we chose a set of deletion indices answer such that
    after deletions, the final array has its elements in lexicographic order
    (i.e., strs[0] <= strs[1] <= strs[2] <= ... <= strs[n - 1]). Return the
    minimum possible value of answer.length.

    Example 1:
    Input: strs = ["ca","bb","ac"]
    Output: 1
    Explanation: After deleting the first column, strs = ["a", "b", "c"]. Now
                 strs is in lexicographic order (ie. strs[0] <= strs[1] <= strs[2]).
                 We require at least 1 deletion since initially strs was not in
                 lexicographic order, so the answer is 1.

    Example 2:
    Input: strs = ["xc","yb","za"]
    Output: 0
    Explanation: strs is already in lexicographic order, so we do not need to
                 delete anything. Note that the rows of strs are not
                 necessarily in lexicographic order: i.e., it is NOT
                 necessarily true that (strs[0][0] <= strs[0][1] <= ...)

    Example 3:
    Input: strs = ["zyx","wvu","tsr"]
    Output: 3
    Explanation: We have to delete every column.

    Constraints:
    * n == strs.length
    * 1 <= n <= 100
    * 1 <= strs[i].length <= 100
    * strs[i] consists of lowercase English letters.*/

    int minDeletionSize(vector<string>& strs) {
        int ans = 0, m = size(strs), n = size(strs[0]);
        vector<int> grp(m);
        for (int j = 0; j < n; ++j) {
            bool found = false;
            for (int i = 1; i < m; ++i)
                if (grp[i-1] == grp[i] && strs[i-1][j] > strs[i][j]) {
                    ++ans;
                    found = true;
                    break;
                }
            if (!found)
                for (int i = 1; i < m; ++i) {
                    grp[i] = max(grp[i-1], grp[i]);
                    if (grp[i-1] == grp[i] && strs[i-1][j] < strs[i][j]) grp[i] = i;
                }
        }
        return ans;
    }


    /*956. Tallest Billboard (Hard)
    You are installing a billboard and want it to have the largest height. The
    billboard will have two steel supports, one on each side. Each steel
    support must be an equal height. You are given a collection of rods that
    can be welded together. For example, if you have rods of lengths 1, 2, and
    3, you can weld them together to make a support of length 6. Return the
    largest possible height of your billboard installation. If you cannot
    support the billboard, return 0.

    Example 1:
    Input: rods = [1,2,3,6]
    Output: 6
    Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the
                 same sum = 6.

    Example 2:
    Input: rods = [1,2,3,4,5,6]
    Output: 10
    Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the
                 same sum = 10.

    Example 3:
    Input: rods = [1,2]
    Output: 0
    Explanation: The billboard cannot be supported, so we return 0.

    Constraints:
    * 1 <= rods.length <= 20
    * 1 <= rods[i] <= 1000
    * sum(rods[i]) <= 5000*/

    int tallestBillboard(vector<int>& rods) {
        unordered_map<int, int> dp;
        dp[0] = 0;
        for (auto& x : rods) {
            unordered_map<int, int> temp = dp;
            for (auto& [k, v] : temp) {
                dp[k+x] = max(dp[k+x], v);
                if (x <= k) dp[k-x] = max(dp[k-x], v+x);
                else dp[x-k] = max(dp[x-k], v+k);
            }
        }
        return dp[0];
    }


    /*961. N-Repeated Element in Size 2N Array (Easy)
    In a array nums of size 2 * n, there are n + 1 unique elements, and exactly
    one of these elements is repeated n times. Return the element repeated n
    times.

    Example 1:
    Input: nums[1,2,3,3]
    Output: 3

    Example 2:
    Input: nums[2,1,2,5,3,2]
    Output: 2

    Example 3:
    Input: nums[5,1,5,2,5,3,5,4]
    Output: 5

    Note:
    * 4 <= nums.length <= 10000
    * 0 <= nums[i] < 10000
    * nums.length is even*/

    int repeatedNTimes(vector<int>& nums) {
        for (int i = 0; i < size(nums); ++i)
            for (int k = 1; k <= 2; ++k)
                if (i+k < size(nums) && nums[i] == nums[i+k]) return nums[i];
        return nums[0];
    }


    /*964. Least Operators to Express Number (Hard)
    Given a single positive integer x, we will write an expression of the form
    x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either
    addition, subtraction, multiplication, or division (+, -, *, or /). For
    example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3.
    When writing such an expression, we adhere to the following conventions:
    * The division operator (/) returns rational numbers.
    * There are no parentheses placed anywhere.
    * We use the usual order of operations: multiplication and division happen
      before addition and subtraction.
    * It is not allowed to use the unary negation operator (-). For example,
      "x - x" is a valid expression as it only uses subtraction, but "-x + x"
      is not because it uses negation.
    We would like to write an expression with the least number of operators
    such that the expression equals the given target. Return the least number
    of operators used.

    Example 1:
    Input: x = 3, target = 19
    Output: 5
    Explanation: 3 * 3 + 3 * 3 + 3 / 3. The expression contains 5 operations.

    Example 2:
    Input: x = 5, target = 501
    Output: 8
    Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5. The expression contains 8
                 operations.

    Example 3:
    Input: x = 100, target = 100000000
    Output: 3
    Explanation: 100 * 100 * 100 * 100. The expression contains 3 operations.

    Constraints:
    * 2 <= x <= 100
    * 1 <= target <= 2 * 10^8*/

    int leastOpsExpressTarget(int x, int target) {
        unordered_map<int, int> memo;

        function<int(int)> fn = [&](int val) {
            if (val < x) return min(2*val-1, 2*(x-val));
            if (memo.find(val) == memo.end()) {
                int k = log(val)/log(x);
                memo[val] = k + fn(val - pow(x, k));
                if (pow(x, k+1) < 2*val)
                    memo[val] = min(memo[val], k+1+fn(pow(x, k+1) - val));
            }
            return memo[val];
        };

        return fn(target);
    }


    /*965. Univalued Binary Tree (Easy)
    A binary tree is univalued if every node in the tree has the same value.
    Return true if and only if the given tree is univalued.

    Example 1:
    Input: [1,1,1,1,1,null,1]
    Output: true

    Example 2:
    Input: [2,2,2,5,2]
    Output: false

    Note:
    * The number of nodes in the given tree will be in the range [1, 100].
    * Each node's value will be an integer in the range [0, 99].*/

    bool isUnivalTree(TreeNode* root) {

        function<bool(TreeNode*, int)> fn = [&](TreeNode* node, int val) {
            if (!node) return true;
            return node->val == val && fn(node->left, val) && fn(node->right, val);
        };

        return fn(root, root->val);
    }


    /*968. Binary Tree Cameras (Hard)
    Given a binary tree, we install cameras on the nodes of the tree. Each
    camera at a node can monitor its parent, itself, and its immediate children.
    Calculate the minimum number of cameras needed to monitor all nodes of the
    tree.

    Example 1:
    Input: [0,0,null,0,0]
    Output: 1
    Explanation: One camera is enough to monitor all nodes if placed as shown.

    Example 2:
    Input: [0,0,null,0,null,0,null,null,0]
    Output: 2
    Explanation: At least two cameras are needed to monitor all nodes of the
                 tree. The above image shows one of the valid configurations of
                 camera placement.

    Note:
    * The number of nodes in the given tree will be in the range [1, 1000].
    * Every node has value 0.*/

    int minCameraCover(TreeNode* root) {
        int ans = 0;

        function<int(TreeNode*)> fn = [&](TreeNode* node) {
            if (node == NULL) return 1;
            int left = fn(node->left), right = fn(node->right);
            if (left == 0 || right == 0) {
                ++ans;
                return 2;
            }
            if (left == 2 || right == 2) {
                return 1;
            }
            return 0;
        };

        int val = fn(root);
        return (val == 0) + ans;
    }


    /*970. Powerful Integers (Medium)
    Given three integers x, y, and bound, return a list of all the powerful
    integers that have a value less than or equal to bound. An integer is
    powerful if it can be represented as xi + yj for some integers i >= 0 and
    j >= 0. You may return the answer in any order. In your answer, each value
    should occur at most once.

    Example 1:
    Input: x = 2, y = 3, bound = 10
    Output: [2,3,4,5,7,9,10]
    Explanation: 2 = 20 + 30
                 3 = 21 + 30
                 4 = 20 + 31
                 5 = 21 + 31
                 7 = 22 + 31
                 9 = 23 + 30
                 10 = 20 + 32

    Example 2:
    Input: x = 3, y = 5, bound = 15
    Output: [2,4,6,8,10,14]

    Constraints:
    * 1 <= x, y <= 100
    * 0 <= bound <= 10^6*/

    vector<int> powerfulIntegers(int x, int y, int bound) {
        unordered_set<int> ans;
        for (int xx = 1; xx <= bound; xx *= x) {
            for (int yy = 1; xx + yy <= bound; yy *= y) {
                ans.insert(xx + yy);
                if (y == 1) break;
            }
            if (x == 1) break;
        }
        return vector<int>(ans.begin(), ans.end());
    }


    /*972. Equal Rational Numbers (Hard)
    Given two strings s and t, each of which represents a non-negative rational
    number, return true if and only if they represent the same number. The
    strings may use parentheses to denote the repeating part of the rational
    number. A rational number can be represented using up to three parts:
    <IntegerPart>, <NonRepeatingPart>, and a <RepeatingPart>. The number will
    be represented in one of the following three ways:
    * <IntegerPart>
      * For example, 12, 0, and 123.
    * <IntegerPart><.><NonRepeatingPart>
      * For example, 0.5, 1., 2.12, and 123.0001.
    * <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>
      * For example, 0.1(6), 1.(9), 123.00(1212).
    The repeating portion of a decimal expansion is conventionally denoted
    within a pair of round brackets. For example:
    * 1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66).

    Example 1:
    Input: s = "0.(52)", t = "0.5(25)"
    Output: true
    Explanation: Because "0.(52)" represents 0.52525252..., and "0.5(25)"
                 represents 0.52525252525..... , the strings represent the same
                 number.

    Example 2:
    Input: s = "0.1666(6)", t = "0.166(66)"
    Output: true

    Example 3:
    Input: s = "0.9(9)", t = "1."
    Output: true
    Explanation: "0.9(9)" represents 0.999999999... repeated forever, which
                 equals 1.  [See this link for an explanation.] "1." represents
                 the number 1, which is formed correctly: (IntegerPart) = "1"
                 and (NonRepeatingPart) = "".

    Constraints:
    * Each part consists only of digits.
    * The <IntegerPart> does not have leading zeros (except for the zero
      itself).
    * 1 <= <IntegerPart>.length <= 4
    * 0 <= <NonRepeatingPart>.length <= 4
    * 1 <= <RepeatingPart>.length <= 4*/

    bool isRationalEqual(string s, string t) {

        auto fn = [&](string x) {
            auto i = x.find('(');
            if (i != string::npos) {
                string rep = x.substr(i+1, x.size()-i-2);
                x = x.substr(0, i);
                for (int k = 17; k; --k) x += rep;
            }
            return stod(x);
        };

        return fn(s) == fn(t);
    }


    /*973. K Closest Points to Origin (Medium)
    Given an array of points where points[i] = [xi, yi] represents a point on
    the X-Y plane and an integer k, return the k closest points to the origin
    (0, 0). The distance between two points on the X-Y plane is the Euclidean
    distance (i.e., √(x1 - x2)^2 + (y1 - y2)^2). You may return the answer in
    any order. The answer is guaranteed to be unique (except for the order that
    it is in).

    Example 1:
    Input: points = [[1,3],[-2,2]], k = 1
    Output: [[-2,2]]
    Explanation: The distance between (1, 3) and the origin is sqrt(10). The
                 distance between (-2, 2) and the origin is sqrt(8). Since
                 sqrt(8) < sqrt(10), (-2, 2) is closer to the origin. We only
                 want the closest k = 1 points from the origin, so the answer
                 is just [[-2,2]].

    Example 2:
    Input: points = [[3,3],[5,-1],[-2,4]], k = 2
    Output: [[3,3],[-2,4]]
    Explanation: The answer [[-2,4],[3,3]] would also be accepted.

    Constraints:
    * 1 <= k <= points.length <= 10^4
    * -10^4 < xi, yi < 10^4*/

    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        nth_element(points.begin(), points.begin()+k, points.end(), [](auto& lhs, auto&rhs) {
            return lhs[0]*lhs[0]+lhs[1]*lhs[1] < rhs[0]*rhs[0]+rhs[1]*rhs[1];
        });
        return vector<vector<int>>(points.begin(), points.begin()+k);
    }


    /*974. Subarray Sums Divisible by K (Medium)
    Given an integer array nums and an integer k, return the number of non-
    empty subarrays that have a sum divisible by k. A subarray is a contiguous
    part of an array.

    Example 1:
    Input: nums = [4,5,0,-2,-3,1], k = 5
    Output: 7
    Explanation: There are 7 subarrays with a sum divisible by k = 5:
                 [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0],
                 [0, -2, -3], [-2, -3]

    Example 2:
    Input: nums = [5], k = 9
    Output: 0

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * -10^4 <= nums[i] <= 10^4
    * 2 <= k <= 10^4*/

    int subarraysDivByK(vector<int>& nums, int k) {
        int ans = 0, prefix = 0;
        unordered_map<int, int> freq = {{0, 1}};
        for (auto& x : nums) {
            prefix = (prefix + x%k + k) % k;
            ans += freq[prefix]++;
        }
        return ans;
    }


    /*975. Odd Even Jump (Hard)
    You are given an integer array arr. From some starting index, you can make
    a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called
    odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are
    called even-numbered jumps. Note that the jumps are numbered, not the
    indices. You may jump forward from index i to index j (with i < j) in the
    following way:
    * During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the
      index j such that arr[i] <= arr[j] and arr[j] is the smallest possible
      value. If there are multiple such indices j, you can only jump to the
      smallest such index j.
    * During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the
      index j such that arr[i] >= arr[j] and arr[j] is the largest possible
      value. If there are multiple such indices j, you can only jump to the
      smallest such index j.
    * It may be the case that for some index i, there are no legal jumps.
    A starting index is good if, starting from that index, you can reach the
    end of the array (index arr.length - 1) by jumping some number of times
    (possibly 0 or more than once). Return the number of good starting indices.

    Example 1:
    Input: arr = [10,13,12,14,15]
    Output: 2
    Explanation: From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.
                 From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.
                 From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.
                 From starting index i = 4, we have reached the end already.
                 In total, there are 2 different starting indices i = 3 and
                 i = 4, where we can reach the end with some number of jumps.

    Example 2:
    Input: arr = [2,3,1,1,4]
    Output: 3
    Explanation: From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:
                 During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].
                 During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3
                 During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].
                 We can't jump from i = 3 to i = 4, so the starting index i = 0
                 is not good. In a similar manner, we can deduce that:
                 From starting index i = 1, we jump to i = 4, so we reach the end.
                 From starting index i = 2, we jump to i = 3, and then we can't jump anymore.
                 From starting index i = 3, we jump to i = 4, so we reach the end.
                 From starting index i = 4, we are already at the end.
                 In total, there are 3 different starting indices i = 1, i = 3,
                 and i = 4, where we can reach the end with some number of jumps.

    Example 3:
    Input: arr = [5,1,3,4,2]
    Output: 3
    Explanation: We can reach the end from starting indices 1, 2, and 4.

    Constraints:
    * 1 <= arr.length <= 2 * 10^4
    * 0 <= arr[i] < 10^5*/

    int oddEvenJumps(vector<int>& arr) {
        int n = arr.size(), ans = 0;
        vector<int> odd(n, 0), even(n, 0);
        odd[n-1] = even[n-1] = 1;

        set<int> st;
        unordered_map<int, int> mp;
        for (int i = n-1; i >= 0; --i) {
            auto lo = st.lower_bound(arr[i]), hi = st.upper_bound(arr[i]);
            if (lo != st.end()) odd[i] = even[mp[*lo]];
            if (hi != st.begin()) even[i] = odd[mp[*prev(hi)]];
            st.insert(arr[i]);
            mp[arr[i]] = i;
            ans += odd[i];
        }
        return ans;
    }


    /*976. Largest Perimeter Triangle (Easy)
    Given an integer array nums, return the largest perimeter of a triangle
    with a non-zero area, formed from three of these lengths. If it is
    impossible to form any triangle of a non-zero area, return 0.

    Example 1:
    Input: nums = [2,1,2]
    Output: 5

    Example 2:
    Input: nums = [1,2,1]
    Output: 0

    Example 3:
    Input: nums = [3,2,3,4]
    Output: 10

    Example 4:
    Input: nums = [3,6,2,3]
    Output: 8

    Constraints:
    * 3 <= nums.length <= 10^4
    * 1 <= nums[i] <= 10^6*/

    int largestPerimeter(vector<int>& nums) {
        sort(begin(nums), end(nums));
        for (int i = size(nums)-1; i >= 2; --i)
            if (nums[i-2] + nums[i-1] > nums[i])
                return nums[i-2] + nums[i-1] + nums[i];
        return 0;
    }


    /*977. Squares of a Sorted Array (Easy)
    Given an integer array nums sorted in non-decreasing order, return an array
    of the squares of each number sorted in non-decreasing order.

    Example 1:
    Input: nums = [-4,-1,0,3,10]
    Output: [0,1,9,16,100]
    Explanation: After squaring, the array becomes [16,1,0,9,100]. After
                 sorting, it becomes [0,1,9,16,100].

    Example 2:
    Input: nums = [-7,-3,2,3,11]
    Output: [4,9,9,49,121]

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^4 <= nums[i] <= 10^4
    * nums is sorted in non-decreasing order.

    Follow up: Squaring each element and sorting the new array is very trivial,
               could you find an O(n) solution using a different approach?*/

    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = n-1, lo = 0, hi = n-1; i >= 0; --i)
            if (abs(nums[lo]) >= abs(nums[hi])) ans[i] = pow(nums[lo++], 2);
            else ans[i] = pow(nums[hi--], 2);
        return ans;
    }


    /*978. Longest Turbulent Subarray (Medium)
    Given an integer array arr, return the length of a maximum size turbulent
    subarray of arr. A subarray is turbulent if the comparison sign flips
    between each adjacent pair of elements in the subarray. More formally, a
    subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent
    if and only if:
    * For i <= k < j:
      + arr[k] > arr[k + 1] when k is odd, and
      + arr[k] < arr[k + 1] when k is even.
    * Or, for i <= k < j:
      + arr[k] > arr[k + 1] when k is even, and
      + arr[k] < arr[k + 1] when k is odd.

    Example 1:
    Input: arr = [9,4,2,10,7,8,8,1,9]
    Output: 5
    Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]

    Example 2:
    Input: arr = [4,8,12,16]
    Output: 2

    Example 3:
    Input: arr = [100]
    Output: 1

    Constraints:
    * 1 <= arr.length <= 4 * 10^4
    * 0 <= arr[i] <= 10^9*/

    int maxTurbulenceSize(vector<int>& arr) {
        int ans = 1, prev = 0;
        for (int i = 1, ii = 0; i < arr.size(); ++i) {
            int diff = arr[i] - arr[i-1];
            if (diff == 0) ii = i;
            else if ((long)prev * diff > 0) ii = i-1;
            ans = max(ans, i - ii + 1);
            prev = diff;
        }
        return ans;
    }


    /*979. Distribute Coins in Binary Tree (Medium)
    You are given the root of a binary tree with n nodes where each node in the
    tree has node.val coins. There are n coins in total throughout the whole
    tree. In one move, we may choose two adjacent nodes and move one coin from
    one node to another. A move may be from parent to child, or from child to
    parent. Return the minimum number of moves required to make every node have
    exactly one coin.

    Example 1:
    Input: root = [3,0,0]
    Output: 2
    Explanation: From the root of the tree, we move one coin to its left child,
                 and one coin to its right child.

    Example 2:
    Input: root = [0,3,0]
    Output: 3
    Explanation: From the left child of the root, we move two coins to the root
                 [taking two moves]. Then, we move one coin from the root of the
                 tree to the right child.

    Constraints:
    * The number of nodes in the tree is n.
    * 1 <= n <= 100
    * 0 <= Node.val <= n
    * The sum of all Node.val is n.*/

    int distributeCoins(TreeNode* root) {

        function<pair<int, int>(TreeNode*)> fn = [&](TreeNode* node) {
            if (!node) return make_pair(0, 0);
            auto [v0, m0] = fn(node->left);
            auto [v1, m1] = fn(node->right);
            return make_pair(node->val + v0 + v1 - 1, m0 + m1 + abs(v0) + abs(v1));
        };

        return fn(root).second;
    }


    /*980. Unique Paths III (Hard)
    You are given an m x n integer array grid where grid[i][j] could be:
    * 1 representing the starting square. There is exactly one starting square.
    * 2 representing the ending square. There is exactly one ending square.
    * 0 representing empty squares we can walk over.
    * -1 representing obstacles that we cannot walk over.
    Return the number of 4-directional walks from the starting square to the
    ending square, that walk over every non-obstacle square exactly once.

    Example 1:
    Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
    Output: 2
    Explanation: We have the following two paths:
                 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
                 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)

    Example 2:
    Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
    Output: 4
    Explanation: We have the following four paths:
                 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
                 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
                 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
                 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)

    Example 3:
    Input: grid = [[0,1],[2,0]]
    Output: 0
    Explanation: There is no path that walks over every empty square exactly
                 once. Note that the starting and ending square can be anywhere
                 in the grid.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 20
    * 1 <= m * n <= 20
    * -1 <= grid[i][j] <= 2
    * There is exactly one starting cell and one ending cell.*/

    int uniquePathsIII(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), si = 0, sj = 0, empty = 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == 1) si = i, sj = j;
                else if (grid[i][j] == 0) ++empty;

        int ans = 0, dir[5] = {-1, 0, 1, 0, -1};

        function<void(int, int, int)> fn = [&](int i, int j, int empty) {
            if (grid[i][j] == 2) {
                if (empty == -1) ++ans;
            } else {
                grid[i][j] = -1;
                for (int k = 0; k < 4; ++k) {
                    int ii = i+dir[k], jj = j+dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] != -1)
                        fn(ii, jj, empty-1);
                }
                grid[i][j] = 0;
            }
        };

        fn(si, sj, empty);
        return ans;
    }


    /*982. Triples with Bitwise AND Equal To Zero (Hard)
    Given an array of integers nums, find the number of triples of indices
    (i, j, k) such that:
    * 0 <= i < nums.length
    * 0 <= j < nums.length
    * 0 <= k < nums.length
    * nums[i] & nums[j] & nums[k] == 0, where & represents the bitwise-AND
      operator.

    Example 1:
    Input: nums = [2,1,3]
    Output: 12
    Explanation: We could choose the following i, j, k triples:
    (i=0, j=0, k=1) : 2 & 2 & 1
    (i=0, j=1, k=0) : 2 & 1 & 2
    (i=0, j=1, k=1) : 2 & 1 & 1
    (i=0, j=1, k=2) : 2 & 1 & 3
    (i=0, j=2, k=1) : 2 & 3 & 1
    (i=1, j=0, k=0) : 1 & 2 & 2
    (i=1, j=0, k=1) : 1 & 2 & 1
    (i=1, j=0, k=2) : 1 & 2 & 3
    (i=1, j=1, k=0) : 1 & 1 & 2
    (i=1, j=2, k=0) : 1 & 3 & 2
    (i=2, j=0, k=1) : 3 & 2 & 1
    (i=2, j=1, k=0) : 3 & 1 & 2

    Note:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] < 2^16*/

    int countTriplets(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (auto& x : nums)
            for (auto& y : nums)
                ++freq[x&y];

        int ans = 0;
        for (auto& x : nums) {
            x ^= 0xffff;
            for (int mask = x; x; x = mask & (x-1))
                ans += freq[x];
        }
        return ans + size(nums)*freq[0];
    }


    /*985. Sum of Even Numbers After Queries (Easy)
    We have an array nums of integers, and an array queries of queries. For the
    i-th query val = queries[i][0], index = queries[i][1], we add val to
    nums[index].  Then, the answer to the i-th query is the sum of the even
    values of A. (Here, the given index = queries[i][1] is a 0-based index, and
    each query permanently modifies the array nums.) Return the answer to all
    queries.  Your answer array should have answer[i] as the answer to the i-th
    query.

    Example 1:
    Input: nums = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
    Output: [8,6,2,4]
    Explanation:
    At the beginning, the array is [1,2,3,4].
    After adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.
    After adding -3 to nums[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.
    After adding -4 to nums[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.
    After adding 2 to nums[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.

    Note:
    * 1 <= nums.length <= 10000
    * -10000 <= nums[i] <= 10000
    * 1 <= queries.length <= 10000
    * -10000 <= queries[i][0] <= 10000
    * 0 <= queries[i][1] < nums.length*/

    vector<int> sumEvenAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {
        int sm = accumulate(begin(nums), end(nums), 0, [](int s, int x) {return x%2 == 0 ? s + x : s; });

        vector<int> ans;
        for (auto& query : queries) {
            int val = query[0], i = query[1];
            if (nums[i]%2 == 0) sm -= nums[i];
            nums[i] += val;
            if (nums[i]%2 == 0) sm += nums[i];
            ans.push_back(sm);
        }
        return ans;
    }


    /*986. Interval List Intersections (Medium)
    You are given two lists of closed intervals, firstList and secondList,
    where firstList[i] = [starti, endi] and secondList[j] = [startj, endj].
    Each list of intervals is pairwise disjoint and in sorted order. Return the
    intersection of these two interval lists. A closed interval [a, b] (with
    a <= b) denotes the set of real numbers x with a <= x <= b. The
    intersection of two closed intervals is a set of real numbers that are
    either empty or represented as a closed interval. For example, the
    intersection of [1, 3] and [2, 4] is [2, 3].

    Example 1:
    Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
    Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]

    Example 2:
    Input: firstList = [[1,3],[5,9]], secondList = []
    Output: []

    Example 3:
    Input: firstList = [], secondList = [[4,8],[10,12]]
    Output: []

    Example 4:
    Input: firstList = [[1,7]], secondList = [[3,10]]
    Output: [[3,7]]

    Constraints:
    * 0 <= firstList.length, secondList.length <= 1000
    * firstList.length + secondList.length >= 1
    * 0 <= starti < endi <= 10^9
    * endi < starti+1
    * 0 <= startj < endj <= 10^9
    * endj < startj+1*/

    vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {
        vector<vector<int>> ans;
        for (int i = 0, j = 0; i < firstList.size() && j < secondList.size(); ) {
            if (firstList[i][0] <= secondList[j][1] && secondList[j][0] <= firstList[i][1])
                ans.push_back({max(firstList[i][0], secondList[j][0]), min(firstList[i][1], secondList[j][1])});
            if (firstList[i][1] <= secondList[j][1]) ++i;
            else ++j;
        }
        return ans;
    }


    /*988. Smallest String Starting From Leaf (Medium)
    You are given the root of a binary tree where each node has a value in the
    range [0, 25] representing the letters 'a' to 'z'. Return the
    lexicographically smallest string that starts at a leaf of this tree and
    ends at the root. As a reminder, any shorter prefix of a string is
    lexicographically smaller. For example, "ab" is lexicographically smaller
    than "aba". A leaf of a node is a node that has no children.

    Example 1:
    Input: root = [0,1,2,3,4,3,4]
    Output: "dba"

    Example 2:
    Input: root = [25,1,3,1,3,0,2]
    Output: "adz"

    Example 3:
    Input: root = [2,2,1,null,1,0,null,0]
    Output: "abc"

    Constraints:
    * The number of nodes in the tree is in the range [1, 8500].
    * 0 <= Node.val <= 25*/

    string smallestFromLeaf(TreeNode* root) {
        stack<pair<TreeNode*, string>> stk;
        stk.emplace(root, "");
        string ans = "~";
        while (stk.size()) {
            auto [node, val] = stk.top(); stk.pop();
            val = string(1, 'a' + node->val) + val;
            if (node->left == nullptr && node->right == nullptr) ans = min(ans, val);
            else {
                if (node->left) stk.emplace(node->left, val);
                if (node->right) stk.emplace(node->right, val);
            }
        }
        return ans;
    }


    /*989. Add to Array-Form of Integer (Easy)
    The array-form of an integer num is an array representing its digits in
    left to right order.
    * For example, for num = 1321, the array form is [1,3,2,1].
    Given num, the array-form of an integer, and an integer k, return the
    array-form of the integer num + k.

    Example 1:
    Input: num = [1,2,0,0], k = 34
    Output: [1,2,3,4]
    Explanation: 1200 + 34 = 1234

    Example 2:
    Input: num = [2,7,4], k = 181
    Output: [4,5,5]
    Explanation: 274 + 181 = 455

    Example 3:
    Input: num = [2,1,5], k = 806
    Output: [1,0,2,1]
    Explanation: 215 + 806 = 1021

    Example 4:
    Input: num = [9,9,9,9,9,9,9,9,9,9], k = 1
    Output: [1,0,0,0,0,0,0,0,0,0,0]
    Explanation: 9999999999 + 1 = 10000000000

    Constraints:
    * 1 <= num.length <= 10^4
    * 0 <= num[i] <= 9
    * num does not contain any leading zeros except for the zero itself.
    * 1 <= k <= 10^4*/

    vector<int> addToArrayForm(vector<int>& num, int k) {
        reverse(begin(num), end(num));
        for (int i = 0; k; ++i) {
            if (i == size(num)) num.push_back(0);
            k += num[i];
            num[i] = k % 10;
            k /= 10;
        }
        reverse(begin(num), end(num));
        return num;
    }


    /*992. Subarrays with K Different Integers (Hard)
    Given an array nums of positive integers, call a (contiguous, not
    necessarily distinct) subarray of nums good if the number of different
    integers in that subarray is exactly k. (For example, [1,2,3,1,2] has 3
    different integers: 1, 2, and 3.) Return the number of good subarrays of
    nums.

    Example 1:
    Input: nums = [1,2,1,2,3], k = 2
    Output: 7
    Explanation: Subarrays formed with exactly 2 different integers:
                 [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].

    Example 2:
    Input: nums = [1,2,1,3,4], k = 3
    Output: 3
    Explanation: Subarrays formed with exactly 3 different integers:
                 [1,2,1,3], [2,1,3], [1,3,4].

    Note:
    * 1 <= nums.length <= 20000
    * 1 <= nums[i] <= nums.length
    * 1 <= k <= nums.length*/

    int subarraysWithKDistinct(vector<int>& nums, int k) {
        int ans = 0, ii = -1;
        unordered_map<int, int> freq;
        queue<int> q;

        for (int i = 0; i < nums.size(); ++i) {
            freq[nums[i]]++;
            q.push(i);
            if (freq.size() > k) {
                ii = q.front(); q.pop();
                freq.erase(nums[ii]);
            }

            while (freq[nums[q.front()]] > 1) {
                int k = q.front(); q.pop();
                freq[nums[k]]--;
            }

            if (freq.size() == k) ans += q.front() - ii;
        }
        return ans;
    }


    /*993. Cousins in Binary Tree (Easy)
    In a binary tree, the root node is at depth 0, and children of each depth k
    node are at depth k+1. Two nodes of a binary tree are cousins if they have
    the same depth, but have different parents. We are given the root of a
    binary tree with unique values, and the values x and y of two different
    nodes in the tree. Return true if and only if the nodes corresponding to
    the values x and y are cousins.

    Example 1:
    Input: root = [1,2,3,4], x = 4, y = 3
    Output: false

    Example 2:
    Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
    Output: true

    Example 3:
    Input: root = [1,2,3,null,4], x = 2, y = 3
    Output: false

    Constraints:
    * The number of nodes in the tree will be between 2 and 100.
    * Each node has a unique integer value from 1 to 100.*/

    bool isCousins(TreeNode* root, int x, int y) {
        queue<pair<TreeNode*, TreeNode*>> q;
        q.emplace(root, nullptr);
        while (q.size()) {
            TreeNode* seen = nullptr;
            for (int sz = q.size(); sz; --sz) {
                auto [n, p] = q.front(); q.pop();
                if (n->val == x || n->val == y) {
                    if (seen) return seen != p;
                    else seen = p;
                }
                if (n->left) q.emplace(n->left, n);
                if (n->right) q.emplace(n->right, n);
            }
            if (seen) return false;
        }
        return false;
    }


    /*994. Rotting Oranges (Medium)
    You are given an m x n grid where each cell can have one of three values:
    * 0 representing an empty cell,
    * 1 representing a fresh orange, or
    * 2 representing a rotten orange.
    Every minute, any fresh orange that is 4-directionally adjacent to a rotten
    orange becomes rotten. Return the minimum number of minutes that must
    elapse until no cell has a fresh orange. If this is impossible, return -1.

    Example 1:
    Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
    Output: 4

    Example 2:
    Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
    Output: -1
    Explanation: The orange in the bottom left corner (row 2, column 0) is
                 never rotten, because rotting only happens 4-directionally.

    Example 3:
    Input: grid = [[0,2]]
    Output: 0
    Explanation: Since there are already no fresh oranges at minute 0, the
                 answer is just 0.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10
    * grid[i][j] is 0, 1, or 2.*/

    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1};

        int fresh = 0;
        queue<pair<int, int>> q;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == 1) ++fresh;
                else if (grid[i][j] == 2) q.emplace(i, j);

        int ans = 0;
        for (; fresh && q.size(); ++ans)
            for (int sz = q.size(); sz; --sz) {
                auto [i, j] = q.front(); q.pop();
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] == 1) {
                        --fresh;
                        q.emplace(ii, jj);
                        grid[ii][jj] = 2;
                    }
                }
            }
        return fresh == 0 ? ans : -1;
    }


    /*995. Minimum Number of K Consecutive Bit Flips (Hard)
    In an array nums containing only 0s and 1s, a k-bit flip consists of
    choosing a (contiguous) subarray of length k and simultaneously changing
    every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the
    minimum number of k-bit flips required so that there is no 0 in the array.
    If it is not possible, return -1.

    Example 1:
    Input: nums = [0,1,0], k = 1
    Output: 2
    Explanation: Flip nums[0], then flip nums[2].

    Example 2:
    Input: nums = [1,1,0], k = 2
    Output: -1
    Explanation: No matter how we flip subarrays of size 2, we can't make the
                 array become [1,1,1].

    Example 3:
    Input: nums = [0,0,0,1,0,1,1,0], k = 3
    Output: 3
    Explanation:
    Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]
    Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]
    Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]

    Note:
    * 1 <= nums.length <= 30000
    * 1 <= k <= nums.length*/

    int minKBitFlips(vector<int>& nums, int k) {
        int ans = 0, flip = 0, n = nums.size();
        vector<int> line(n);
        for (int i = 0; i < n; ++i) {
            if (nums[i] == flip) {
                if (n <= i+k-1) return -1;
                ++ans;
                flip ^= 1;
                line[i+k-1] = 1;
            }
            if (line[i]) flip ^= 1;
        }
        return ans;
    }


    /*997. Find the Town Judge (Easy)
    In a town, there are n people labelled from 1 to n. There is a rumor that
    one of these people is secretly the town judge. If the town judge exists,
    then:
    * The town judge trusts nobody.
    * Everybody (except for the town judge) trusts the town judge.
    * There is exactly one person that satisfies properties 1 and 2.
    You are given trust, an array of pairs trust[i] = [a, b] representing that
    the person labelled a trusts the person labelled b. If the town judge
    exists and can be identified, return the label of the town judge. Otherwise,
    return -1.

    Example 1:
    Input: n = 2, trust = [[1,2]]
    Output: 2

    Example 2:
    Input: n = 3, trust = [[1,3],[2,3]]
    Output: 3

    Example 3:
    Input: n = 3, trust = [[1,3],[2,3],[3,1]]
    Output: -1

    Example 4:
    Input: n = 3, trust = [[1,2],[2,3]]
    Output: -1

    Example 5:
    Input: n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
    Output: 3

    Constraints:
    * 1 <= n <= 1000
    * 0 <= trust.length <= 10^4
    * trust[i].length == 2
    * trust[i] are all different
    * trust[i][0] != trust[i][1]
    * 1 <= trust[i][0], trust[i][1] <= n*/

    int findJudge(int n, vector<vector<int>>& trust) {
        vector<int> degree(n);
        for (auto& x : trust) {
            --degree[x[0]-1];
            ++degree[x[1]-1];
        }
        for (int i = 0; i < n; ++i)
            if (degree[i] == n-1) return i+1;
        return -1;
    }


    /*999. Available Captures for Rook (Easy)
    On an 8 x 8 chessboard, there is exactly one white rook 'R' and some number
    of white bishops 'B', black pawns 'p', and empty squares '.'. When the rook
    moves, it chooses one of four cardinal directions (north, east, south, or
    west), then moves in that direction until it chooses to stop, reaches the
    edge of the board, captures a black pawn, or is blocked by a white bishop.
    A rook is considered attacking a pawn if the rook can capture the pawn on
    the rook's turn. The number of available captures for the white rook is the
    number of pawns that the rook is attacking. Return the number of available
    captures for the white rook.

    Example 1:
    Input: board = [[".",".",".",".",".",".",".","."],
                    [".",".",".","p",".",".",".","."],
                    [".",".",".","R",".",".",".","p"],
                    [".",".",".",".",".",".",".","."],
                    [".",".",".",".",".",".",".","."],
                    [".",".",".","p",".",".",".","."],
                    [".",".",".",".",".",".",".","."],
                    [".",".",".",".",".",".",".","."]]
    Output: 3
    Explanation: In this example, the rook is attacking all the pawns.

    Example 2:
    Input: board = [[".",".",".",".",".",".",".","."],
                    [".","p","p","p","p","p",".","."],
                    [".","p","p","B","p","p",".","."],
                    [".","p","B","R","B","p",".","."],
                    [".","p","p","B","p","p",".","."],
                    [".","p","p","p","p","p",".","."],
                    [".",".",".",".",".",".",".","."],
                    [".",".",".",".",".",".",".","."]]
    Output: 0
    Explanation: The bishops are blocking the rook from attacking any of the pawns.

    Example 3:
    Input: board = [[".",".",".",".",".",".",".","."],
                    [".",".",".","p",".",".",".","."],
                    [".",".",".","p",".",".",".","."],
                    ["p","p",".","R",".","p","B","."],
                    [".",".",".",".",".",".",".","."],
                    [".",".",".","B",".",".",".","."],
                    [".",".",".","p",".",".",".","."],
                    [".",".",".",".",".",".",".","."]]
    Output: 3
    Explanation: The rook is attacking the pawns at positions b5, d6, and f5.

    Constraints:
    * board.length == 8
    * board[i].length == 8
    * board[i][j] is either 'R', '.', 'B', or 'p'
    * There is exactly one cell with board[i][j] == 'R'*/

    int numRookCaptures(vector<vector<char>>& board) {
        for (int i = 0; i < 8; ++i)
            for (int j = 0; j < 8; ++j)
                if (board[i][j] == 'R') {
                    int ans = 0;
                    vector<pair<int, int>> dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};
                    for (auto& [di, dj] : dir) {
                        for (int ii = i, jj = j; 0 <= ii && ii < 8 && 0 <= jj && jj < 8; ii += di, jj += dj) {
                            if (board[ii][jj] == 'B') break;
                            if (board[ii][jj] == 'p') {
                                ++ans;
                                break;
                            }
                        }
                    }
                    return ans;
                }
        return 0;
    }


    /*1000. Minimum Cost to Merge Stones (Hard)
    There are n piles of stones arranged in a row. The ith pile has stones[i]
    stones. A move consists of merging exactly k consecutive piles into one
    pile, and the cost of this move is equal to the total number of stones in
    these k piles. Return the minimum cost to merge all piles of stones into
    one pile. If it is impossible, return -1.

    Example 1:
    Input: stones = [3,2,4,1], k = 2
    Output: 20
    Explanation: We start with [3, 2, 4, 1].
                 We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].
                 We merge [4, 1] for a cost of 5, and we are left with [5, 5].
                 We merge [5, 5] for a cost of 10, and we are left with [10].
                 The total cost was 20, and this is the minimum possible.

    Example 2:
    Input: stones = [3,2,4,1], k = 3
    Output: -1
    Explanation: After any merge operation, there are 2 piles left, and we
                 can't merge anymore.  So the task is impossible.

    Example 3:
    Input: stones = [3,5,1,2,6], k = 3
    Output: 25
    Explanation: We start with [3, 5, 1, 2, 6].
                 We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].
                 We merge [3, 8, 6] for a cost of 17, and we are left with [17].
                 The total cost was 25, and this is the minimum possible.

    Constraints:
    * n == stones.length
    * 1 <= n <= 30
    * 1 <= stones[i] <= 100
    * 2 <= k <= 30*/

    int mergeStones(vector<int>& stones, int k) {
        int n = stones.size();
        if ((n-1) % (k-1)) return -1; // impossible

        vector<int> prefix(1, 0);
        for (auto& x : stones) prefix.push_back(prefix.back() + x);

        vector<vector<int>> dp(n, vector<int>(n+1)); // dp[lo][hi] min cost merging [lo:hi]
        for (int lo = n-k; lo >= 0; --lo)
            for (int hi = lo+k; hi <= n; ++hi) {
                dp[lo][hi] = INT_MAX;
                for (int mid = lo+1; mid < hi; mid += k-1)
                    dp[lo][hi] = min(dp[lo][hi], dp[lo][mid] + dp[mid][hi]);
                if ((hi-lo-1) % (k-1) == 0) dp[lo][hi] += prefix[hi] - prefix[lo];
            }
        return dp[0].back();
    }


    /*1001. Grid Illumination (Hard)
    There is a 2D grid of size n x n where each cell of this grid has a lamp
    that is initially turned off. You are given a 2D array of lamp positions
    lamps, where lamps[i] = [rowi, coli] indicates that the lamp at
    grid[rowi][coli] is turned on. Even if the same lamp is listed more than
    once, it is turned on. When a lamp is turned on, it illuminates its cell
    and all other cells in the same row, column, or diagonal. You are also
    given another 2D array queries, where queries[j] = [rowj, colj]. For the
    jth query, determine whether grid[rowj][colj] is illuminated or not. After
    answering the jth query, turn off the lamp at grid[rowj][colj] and its 8
    adjacent lamps if they exist. A lamp is adjacent if its cell shares either
    a side or corner with grid[rowj][colj]. Return an array of integers ans,
    where ans[j] should be 1 if the cell in the jth query was illuminated, or 0
    if the lamp was not.

    Example 1:
    Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
    Output: [1,0]
    Explanation: We have the initial grid with all lamps turned off. In the
                 above picture we see the grid after turning on the lamp at
                 grid[0][0] then turning on the lamp at grid[4][4]. The 0th
                 query asks if the lamp at grid[1][1] is illuminated or not
                 (the blue square). It is illuminated, so set ans[0] = 1. Then,
                 we turn off all lamps in the red square. The 1st query asks if
                 the lamp at grid[1][0] is illuminated or not (the blue square).
                 It is not illuminated, so set ans[1] = 0. Then, we turn off
                 all lamps in the red rectangle.

    Example 2:
    Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]
    Output: [1,1]

    Example 3:
    Input: n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]
    Output: [1,1,0]

    Constraints:
    * 1 <= n <= 10^9
    * 0 <= lamps.length <= 20000
    * 0 <= queries.length <= 20000
    * lamps[i].length == 2
    * 0 <= rowi, coli < n
    * queries[j].length == 2
    * 0 <= rowj, colj < n*/

    vector<int> gridIllumination(int n, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
        set<pair<int, int>> ss;
        unordered_map<int, int> rows, cols, anti, diag;

        for (auto& lamp : lamps) {
            int i = lamp[0], j = lamp[1];
            if (ss.insert({i, j}).second) {
                ++rows[i]; ++anti[i+j];
                ++cols[j]; ++diag[i-j];
            }
        }

        vector<int> ans;
        for (auto& query : queries) {
            int i = query[0], j = query[1];
            if (rows[i] || cols[j] || anti[i+j] || diag[i-j]) ans.push_back(1);
            else ans.push_back(0);
            for (int ii = i-1; ii <= i+1; ++ii)
                for (int jj = j-1; jj <= j+1; ++jj)
                    if (ss.erase({ii, jj})) {
                        --rows[ii]; --anti[ii+jj];
                        --cols[jj]; --diag[ii-jj];
                    }
        }
        return ans;
    }


    /*1002. Find Common Characters (Easy)
    Given an array words of strings made only from lowercase letters, return a
    list of all characters that show up in all strings within the list
    (including duplicates).  For example, if a character occurs 3 times in all
    strings but not 4 times, you need to include that character three times in
    the final answer. You may return the answer in any order.

    Example 1:
    Input: ["bella","label","roller"]
    Output: ["e","l","l"]

    Example 2:
    Input: ["cool","lock","cook"]
    Output: ["c","o"]

    Note:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consists of lowercase English letters.*/

    vector<string> commonChars(vector<string>& words) {
        vector<int> freq(26, INT_MAX);
        for (auto& word : words) {
            vector<int> temp(26, 0);
            for (auto& ch : word)
                ++temp[ch - 'a'];
            for (int i = 0; i < 26; ++i)
                freq[i] = min(freq[i], temp[i]);
        }
        vector<string> ans;
        for (int i = 0; i < 26; ++i) {
            while (freq[i]--)
                ans.push_back(string(1, 'a' + i));
        }
        return ans;
    }


    /*1004. Max Consecutive Ones III (Medium)
    Given a binary array nums and an integer k, return the maximum number of
    consecutive 1's in the array if you can flip at most k 0's.

    Example 1:
    Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
    Output: 6
    Explanation: [1,1,1,0,0,1,1,1,1,1,1]
                 Bolded numbers were flipped from 0 to 1. The longest subarray
                 is underlined.

    Example 2:
    Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
    Output: 10
    Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
                 Bolded numbers were flipped from 0 to 1. The longest subarray
                 is underlined.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1.
    * 0 <= k <= nums.length*/

    int longestOnes(vector<int>& nums, int k) {
        int ans = 0;
        for (int i = 0, ii = 0; i < size(nums); ++i) {
            if (nums[i] == 0) --k;
            for (; k < 0; ++ii)
                if (nums[ii] == 0) ++k;
            ans = max(ans, i - ii + 1);
        }
        return ans;
    }


    /*1005. Maximize Sum Of Array After K Negations (Easy)
    Given an array nums of integers, we must modify the array in the following
    way: we choose an i and replace nums[i] with -nums[i], and we repeat this
    process k times in total.  (We may choose the same index i multiple times.)
    Return the largest possible sum of the array after modifying it in this way.

    Example 1:
    Input: nums = [4,2,3], k = 1
    Output: 5
    Explanation: Choose indices (1,) and nums becomes [4,-2,3].

    Example 2:
    Input: nums = [3,-1,0,2], k = 3
    Output: 6
    Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].

    Example 3:
    Input: nums = [2,-3,-1,5,-4], k = 2
    Output: 13
    Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].

    Note:
    * 1 <= nums.length <= 10000
    * 1 <= k <= 10000
    * -100 <= nums[i] <= 100*/

    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(begin(nums), end(nums));
        for (int i = 0; i < size(nums) && k; ++i, --k) {
            if (nums[i] >= 0) break;
            nums[i] *= -1;
        }
        int sm = accumulate(begin(nums), end(nums), 0), mn = *min_element(begin(nums), end(nums));
        return sm - 2 * mn * (k%2);
    }


    /*1007. Minimum Domino Rotations For Equal Row (Medium)
    In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom
    halves of the ith domino. (A domino is a tile with two numbers from 1 to 6
    - one on each half of the tile.) We may rotate the ith domino, so that
    tops[i] and bottoms[i] swap values. Return the minimum number of rotations
    so that all the values in tops are the same, or all the values in bottoms
    are the same. If it cannot be done, return -1.

    Example 1:
    Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]
    Output: 2
    Explanation: The first figure represents the dominoes as given by tops and
                 bottoms: before we do any rotations. If we rotate the second
                 and fourth dominoes, we can make every value in the top row
                 equal to 2, as indicated by the second figure.

    Example 2:
    Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]
    Output: -1
    Explanation: In this case, it is not possible to rotate the dominoes to
                 make one row of values equal.

    Constraints:
    * 2 <= tops.length <= 2 * 10^4
    * bottoms.length == tops.length
    * 1 <= tops[i], bottoms[i] <= 6*/

    int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {
        bool top = true, bottom = true;
        int tt = 0, bt = 0, tb = 0, bb = 0;
        for (int i = 0; i < tops.size(); ++i) {
            if (tops[0] != tops[i] && tops[0] != bottoms[i]) top = false;
            if (bottoms[0] != tops[i] && bottoms[0] != bottoms[i]) bottom = false;
            if (tops[0] != tops[i]) ++tt;
            if (tops[0] != bottoms[i]) ++bt;
            if (bottoms[0] != tops[i]) ++tb;
            if (bottoms[0] != bottoms[i]) ++bb;
        }
        return top || bottom ? min({tt, tb, bt, bb}) : -1;
    }


    /*1008. Construct Binary Search Tree from Preorder Traversal (Medium)
    Given an array of integers preorder, which represents the preorder
    traversal of a BST (i.e., binary search tree), construct the tree and
    return its root. It is guaranteed that there is always possible to find a
    binary search tree with the given requirements for the given test cases.
    A binary search tree is a binary tree where for every node, any descendant
    of Node.left has a value strictly less than Node.val, and any descendant of
    Node.right has a value strictly greater than Node.val. A preorder traversal
    of a binary tree displays the value of the node first, then traverses
    Node.left, then traverses Node.right.

    Example 1:
    Input: preorder = [8,5,1,7,10,12]
    Output: [8,5,10,1,7,null,12]

    Example 2:
    Input: preorder = [1,3]
    Output: [1,null,3]

    Constraints:
    * 1 <= preorder.length <= 100
    * 1 <= preorder[i] <= 10^8
    * All the values of preorder are unique.*/

    TreeNode* bstFromPreorder(vector<int>& preorder) {
        TreeNode *root = nullptr, *node = nullptr;
        stack<TreeNode*> stk;
        for (auto& x : preorder)
            if (!root) root = node = new TreeNode(x);
            else if (x < node->val) {
                stk.push(node);
                node = node->left = new TreeNode(x);
            } else {
                while (stk.size() && stk.top()->val < x) node = stk.top(), stk.pop();
                node = node->right = new TreeNode(x);
            }
        return root;
    }


    /*1009. Complement of Base 10 Integer (Easy)
    The complement of an integer is the integer you get when you flip all the
    0's to 1's and all the 1's to 0's in its binary representation. For example,
    the integer 5 is "101" in binary and its complement is "010" which is the
    integer 2. Given an integer n, return its complement.

    Example 1:
    Input: n = 5
    Output: 2
    Explanation: 5 is "101" in binary, with complement "010" in binary, which
                 is 2 in base-10.

    Example 2:
    Input: n = 7
    Output: 0
    Explanation: 7 is "111" in binary, with complement "000" in binary, which
                 is 0 in base-10.

    Example 3:
    Input: n = 10
    Output: 5
    Explanation: 10 is "1010" in binary, with complement "0101" in binary,
                 which is 5 in base-10.

    Constraints: 0 <= n < 10^9

    Note: This question is the same as 476:
          https://leetcode.com/problems/number-complement/*/

    int bitwiseComplement(int n) {
        int m = 1;
        for (; m < n; m = m<<1 | 1);
        return n ^ m;
    }


    /*1010. Pairs of Songs With Total Durations Divisible by 60 (Medium)
    You are given a list of songs where the ith song has a duration of time[i]
    seconds. Return the number of pairs of songs for which their total duration
    in seconds is divisible by 60. Formally, we want the number of indices i, j
    such that i < j with (time[i] + time[j]) % 60 == 0.

    Example 1:
    Input: time = [30,20,150,100,40]
    Output: 3
    Explanation: Three pairs have a total duration divisible by 60:
                 (time[0] = 30, time[2] = 150): total duration 180
                 (time[1] = 20, time[3] = 100): total duration 120
                 (time[1] = 20, time[4] = 40): total duration 60

    Example 2:
    Input: time = [60,60,60]
    Output: 3
    Explanation: All three pairs have a total duration of 120, which is divisible by 60.

    Constraints:
    * 1 <= time.length <= 6 * 10^4
    * 1 <= time[i] <= 500*/

    int numPairsDivisibleBy60(vector<int>& time) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (auto& x : time) {
            ans += freq[(600-x) % 60];
            ++freq[x % 60];
        }
        return ans;
    }


    /*1011. Capacity To Ship Packages Within D Days (Medium)
    A conveyor belt has packages that must be shipped from one port to another
    within days days. The ith package on the conveyor belt has a weight of
    weights[i]. Each day, we load the ship with packages on the conveyor belt
    (in the order given by weights). We may not load more weight than the
    maximum weight capacity of the ship. Return the least weight capacity of
    the ship that will result in all the packages on the conveyor belt being
    shipped within days days.

    Example 1:
    Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
    Output: 15
    Explanation: A ship capacity of 15 is the minimum to ship all the packages
                 in 5 days like this:
                 1st day: 1, 2, 3, 4, 5
                 2nd day: 6, 7
                 3rd day: 8
                 4th day: 9
                 5th day: 10
                 Note that the cargo must be shipped in the order given, so
                 using a ship of capacity 14 and splitting the packages into
                 parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not
                 allowed.

    Example 2:
    Input: weights = [3,2,2,4,1,4], days = 3
    Output: 6
    Explanation: A ship capacity of 6 is the minimum to ship all the packages
                 in 3 days like this:
                 1st day: 3, 2
                 2nd day: 2, 4
                 3rd day: 1, 4

    Example 3:
    Input: weights = [1,2,3,1,1], days = 4
    Output: 3
    Explanation: 1st day: 1
                 2nd day: 2
                 3rd day: 3
                 4th day: 1, 1

    Constraints:
    * 1 <= days <= weights.length <= 5 * 10^4
    * 1 <= weights[i] <= 500*/

    int shipWithinDays(vector<int>& weights, int days) {
        int lo = *max_element(weights.begin(), weights.end()), hi = accumulate(weights.begin(), weights.end(), 0);
        while (lo < hi) {
            int mid = lo + (hi - lo)/2, cnt = 0, val = hi;
            for (auto& w : weights) {
                if (val + w > mid) {
                    ++cnt;
                    val = 0;
                }
                val += w;
            }
            if (cnt <= days) hi = mid;
            else lo = mid + 1;
        }
        return lo;
    }


    /*1013. Partition Array Into Three Parts With Equal Sum (Easy)
    Given an array of integers arr, return true if we can partition the array
    into three non-empty parts with equal sums. Formally, we can partition the
    array if we can find indexes i + 1 < j with
    (arr[0] + arr[1] + ... + arr[i]
    == arr[i + 1] + arr[i + 2] + ... + arr[j - 1]
    == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])

    Example 1:
    Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]
    Output: true
    Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1

    Example 2:
    Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]
    Output: false

    Example 3:
    Input: arr = [3,3,6,5,-2,2,5,1,-9,4]
    Output: true
    Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4

    Constraints:
    * 3 <= arr.length <= 5 * 10^4
    * -10^4 <= arr[i] <= 10^4*/

    bool canThreePartsEqualSum(vector<int>& arr) {
        int ans = 0, prefix = 0, total = accumulate(arr.begin(), arr.end(), 0);
        if (total % 3) return false;
        for (auto& x : arr) {
            prefix += x;
            if (prefix == total/3) { ++ans; prefix = 0; }
        }
        return ans >= 3;
    }


    /*1014. Best Sightseeing Pair (Medium)
    You are given an integer array values where values[i] represents the value
    of the ith sightseeing spot. Two sightseeing spots i and j have a distance
    j - i between them. The score of a pair (i < j) of sightseeing spots is
    values[i] + values[j] + i - j: the sum of the values of the sightseeing
    spots, minus the distance between them. Return the maximum score of a pair
    of sightseeing spots.

    Example 1:
    Input: values = [8,1,5,2,6]
    Output: 11
    Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11

    Example 2:
    Input: values = [1,2]
    Output: 2

    Constraints:
    * 2 <= values.length <= 5 * 10^4
    * 1 <= values[i] <= 1000*/

    int maxScoreSightseeingPair(vector<int>& values) {
        int ans = 0;
        for (int i = 0, most = 0; i < values.size(); ++i) {
            if (i) ans = max(ans, most + values[i] - i);
            most = max(most, values[i] + i);
        }
        return ans;
    }


    /*1015. Smallest Integer Divisible by K (Medium)
    Given a positive integer k, you need to find the length of the smallest
    positive integer n such that n is divisible by k, and n only contains the
    digit 1. Return the length of n. If there is no such n, return -1. Note:
    n may not fit in a 64-bit signed integer.

    Example 1:
    Input: k = 1
    Output: 1
    Explanation: The smallest answer is n = 1, which has length 1.

    Example 2:
    Input: k = 2
    Output: -1
    Explanation: There is no such positive integer n divisible by 2.

    Example 3:
    Input: k = 3
    Output: 3
    Explanation: The smallest answer is n = 111, which has length 3.

    Constraints: 1 <= k <= 10^5*/

    int smallestRepunitDivByK(int k) {
        int ans = 1;
        vector<bool> seen(k);
        for (int x = 1%k; x; ++ans, x %= k) {
            if (seen[x]) return -1;
            seen[x] = true;
            x = 10*x + 1;
        }
        return ans;
    }


    /*1018. Binary Prefix Divisible By 5 (Easy)
    You are given a binary array nums (0-indexed). We define xi as the number
    whose binary representation is the subarray nums[0..i] (from
    most-significant-bit to least-significant-bit).
    * For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5.
    Return an array of booleans answer where answer[i] is true if xi is
    divisible by 5.

    Example 1:
    Input: nums = [0,1,1]
    Output: [true,false,false]
    Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1,
                 and 3 in base-10. Only the first number is divisible by 5, so
                 answer[0] is true.

    Example 2:
    Input: nums = [1,1,1]
    Output: [false,false,false]

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1.*/

    vector<bool> prefixesDivBy5(vector<int>& nums) {
        vector<bool> ans;
        int prefix = 0;
        for (auto& x : nums) {
            prefix = (2*prefix + x) % 5;
            ans.push_back(!prefix);
        }
        return ans;
    }


    /*1020. Number of Enclaves (Medium)
    You are given an m x n binary matrix grid, where 0 represents a sea cell
    and 1 represents a land cell. A move consists of walking from one land cell
    to another adjacent (4-directionally) land cell or walking off the boundary
    of the grid. Return the number of land cells in grid for which we cannot
    walk off the boundary of the grid in any number of moves.

    Example 1:
    Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
    Output: 3
    Explanation: There are three 1s that are enclosed by 0s, and one 1 that is
                 not enclosed because its on the boundary.

    Example 2:
    Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
    Output: 0
    Explanation: All 1s are either on the boundary or can reach the boundary.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 500
    * grid[i][j] is either 0 or 1.*/

    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        stack<pair<int, int>> stk;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if ((i == 0 || j == 0 || i == m-1 || j == n-1) && grid[i][j]) {
                    stk.emplace(i, j);
                    grid[i][j] = 0;
                }
        while (stk.size()) {
            auto [i, j] = stk.top(); stk.pop();
            for (int k = 0; k < 4; ++k) {
                int ii = i + dir[k], jj = j + dir[k+1];
                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj]) {
                    stk.emplace(ii, jj);
                    grid[ii][jj] = 0;
                }
            }
        }
        int ans = 0;
        for (auto& row : grid)
            ans += accumulate(row.begin(), row.end(), 0);
        return ans;
    }


    /*1021. Remove Outermost Parentheses (Easy)
    A valid parentheses string is either empty "", "(" + A + ")", or A + B,
    where A and B are valid parentheses strings, and + represents string
    concatenation.
    * For example, "", "()", "(())()", and "(()(()))" are all valid parentheses
      strings.
    A valid parentheses string s is primitive if it is nonempty, and there does
    not exist a way to split it into s = A + B, with A and B nonempty valid
    parentheses strings. Given a valid parentheses string s, consider its
    primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive
    valid parentheses strings. Return s after removing the outermost
    parentheses of every primitive string in the primitive decomposition of s.

    Example 1:
    Input: s = "(()())(())"
    Output: "()()()"
    Explanation: The input string is "(()())(())", with primitive decomposition
                 "(()())" + "(())". After removing outer parentheses of each
                 part, this is "()()" + "()" = "()()()".

    Example 2:
    Input: s = "(()())(())(()(()))"
    Output: "()()()()(())"
    Explanation: The input string is "(()())(())(()(()))", with primitive
                 decomposition "(()())" + "(())" + "(()(()))". After removing
                 outer parentheses of each part, this is
                 "()()" + "()" + "()(())" = "()()()()(())".

    Example 3:
    Input: s = "()()"
    Output: ""
    Explanation: The input string is "()()", with primitive decomposition
                 "()" + "()". After removing outer parentheses of each part,
                 this is "" + "" = "".

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '(' or ')'.
    * s is a valid parentheses string.*/

    string removeOuterParentheses(string s) {
        string ans;
        int level = 0;
        for (auto& ch : s)
            if ((ch == '(' && ++level > 1) || (ch == ')' && --level)) ans.push_back(ch);
        return ans;
    }


    /*1022. Sum of Root To Leaf Binary Numbers (Easy)
    You are given the root of a binary tree where each node has a value 0 or 1.
    Each root-to-leaf path represents a binary number starting with the most
    significant bit.
    * For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could
      represent 01101 in binary, which is 13.
    For all leaves in the tree, consider the numbers represented by the path
    from the root to that leaf. Return the sum of these numbers. The test cases
    are generated so that the answer fits in a 32-bits integer.

    Example 1:
    Input: root = [1,0,1,0,1,0,1]
    Output: 22
    Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22

    Example 2:
    Input: root = [0]
    Output: 0

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * Node.val is 0 or 1.*/

    int sumRootToLeaf(TreeNode* root) {
        int ans = 0;
        stack<pair<TreeNode*, int>> stk;
        stk.emplace(root, 0);
        while (stk.size()) {
            auto [node, val] = stk.top(); stk.pop();
            val = val * 2 + node->val;
            if (!node->left && !node->right) ans += val;
            if (node->left) stk.emplace(node->left, val);
            if (node->right) stk.emplace(node->right, val);
        }
        return ans;
    }


    /*1026. Maximum Difference Between Node and Ancestor (Medium)
    Given the root of a binary tree, find the maximum value v for which there
    exist different nodes a and b where v = |a.val - b.val| and a is an
    ancestor of b. A node a is an ancestor of b if either: any child of a is
    equal to b or any child of a is an ancestor of b.

    Example 1:
    Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]
    Output: 7
    Explanation: We have various ancestor-node differences, some of which are
                 given below :
                  |8 - 3| = 5
                  |3 - 7| = 4
                  |8 - 1| = 7
                  |10 - 13| = 3
                 Among all possible differences, the maximum value of 7 is
                 obtained by |8 - 1| = 7.

    Example 2:
    Input: root = [1,null,2,null,0,3]
    Output: 3

    Constraints:
    * The number of nodes in the tree is in the range [2, 5000].
    * 0 <= Node.val <= 10^5*/

    int maxAncestorDiff(TreeNode* root) {
        int ans = 0;
        stack<tuple<TreeNode*, int, int>> stk;
        stk.emplace(root, INT_MAX, INT_MIN);
        while (stk.size()) {
            auto [node, lo, hi] = stk.top(); stk.pop();
            hi = max(hi, node->val);
            lo = min(lo, node->val);
            ans = max({ans, node->val - lo, hi - node->val});
            if (node->left) stk.emplace(node->left, lo, hi);
            if (node->right) stk.emplace(node->right, lo, hi);
        }
        return ans;
    }


    /*1029. Two City Scheduling (Medium)
    A company is planning to interview 2n people. Given the array costs where
    costs[i] = [aCosti, bCosti], the cost of flying the ith person to city a is
    aCosti, and the cost of flying the ith person to city b is bCosti. Return
    the minimum cost to fly every person to a city such that exactly n people
    arrive in each city.

    Example 1:
    Input: costs = [[10,20],[30,200],[400,50],[30,20]]
    Output: 110
    Explanation: The first person goes to city A for a cost of 10.
                 The second person goes to city A for a cost of 30.
                 The third person goes to city B for a cost of 50.
                 The fourth person goes to city B for a cost of 20.
                 The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half
                 the people interviewing in each city.

    Example 2:
    Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]
    Output: 1859

    Example 3:
    Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]
    Output: 3086

    Constraints:
    * 2 * n == costs.length
    * 2 <= costs.length <= 100
    * costs.length is even.
    * 1 <= aCosti, bCosti <= 1000*/

    int twoCitySchedCost(vector<vector<int>>& costs) {
        sort(costs.begin(), costs.end(), [&](auto& lhs, auto& rhs) {
            return lhs[1] - lhs[0] < rhs[1] - rhs[0];
        });
        int ans = 0;
        for (int i = 0, n = costs.size(); i < n; ++i)
            if (i < n/2) ans += costs[i][1];
            else ans += costs[i][0];
        return ans;
    }


    /*1036. Escape a Large Maze (Hard)
    There is a 1 million by 1 million grid on an XY-plane, and the coordinates
    of each grid square are (x, y). We start at the source = [sx, sy] square
    and want to reach the target = [tx, ty] square. There is also an array of
    blocked squares, where each blocked[i] = [xi, yi] represents a blocked
    square with coordinates (xi, yi). Each move, we can walk one square north,
    east, south, or west if the square is not in the array of blocked squares.
    We are also not allowed to walk outside of the grid. Return true if and
    only if it is possible to reach the target square from the source square
    through a sequence of valid moves.

    Example 1:
    Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
    Output: false
    Explanation: The target square is inaccessible starting from the source
                 square because we cannot move. We cannot move north or east
                 because those squares are blocked. We cannot move south or
                 west because we cannot go outside of the grid.

    Example 2:
    Input: blocked = [], source = [0,0], target = [999999,999999]
    Output: true
    Explanation: Because there are no blocked cells, it is possible to reach
                 the target square.

    Constraints:
    * 0 <= blocked.length <= 200
    * blocked[i].length == 2
    * 0 <= xi, yi < 10^6
    * source.length == target.length == 2
    * 0 <= sx, sy, tx, ty < 10^6
    * source != target
    * It is guaranteed that source and target are not blocked.*/

    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        vector<int> dir = {1, 0, -1, 0, 1};

        unordered_set<long long> forbid;
        for (auto blk : blocked) forbid.insert(((long long)blk[0] << 32) + blk[1]);

        function<bool(int, int, int, int)> dfs = [&](int sx, int sy, int tx, int ty) {
            stack<pair<int, int>> stk;
            stk.emplace(sx, sy);
            unordered_set<long long> seen = {((long long)sx << 32) + sy};
            while (stk.size()) {
                auto [x, y] = stk.top(); stk.pop();
                if (abs(x - sx) + abs(y - sy) > 200 || x == tx && y == ty) return true;
                for (int k = 0; k < 4; ++k) {
                    int xx = x + dir[k], yy = y + dir[k+1];
                    if (0 <= xx && xx < 1e6 && 0 <= yy && yy < 1e6) {
                        long long key = ((long long)xx << 32) + yy;
                        if (forbid.find(key) == forbid.end() && seen.find(key) == seen.end()) {
                            stk.emplace(xx, yy);
                            seen.emplace(key);
                        }
                    }
                }
            }
            return false;
        };

        return dfs(source[0], source[1], target[0], target[1]) && dfs(target[0], target[1], source[0], source[1]);
    }


    /*1038. Binary Search Tree to Greater Sum Tree (Medium)
    Given the root of a Binary Search Tree (BST), convert it to a Greater Tree
    such that every key of the original BST is changed to the original key plus
    the sum of all keys greater than the original key in BST. As a reminder, a
    binary search tree is a tree that satisfies these constraints:
    * The left subtree of a node contains only nodes with keys less than the
      node's key.
    * The right subtree of a node contains only nodes with keys greater than the
      node's key.
    * Both the left and right subtrees must also be binary search trees.

    Example 1:
    Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
    Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

    Example 2:
    Input: root = [0,null,1]
    Output: [1,null,1]

    Constraints:
    * The number of nodes in the tree is in the range [1, 100].
    * 0 <= Node.val <= 100
    * All the values in the tree are unique.

    Note: This question is the same as 538:
          https://leetcode.com/problems/convert-bst-to-greater-tree/*/

    TreeNode* bstToGst(TreeNode* root) {
        stack<TreeNode*> stk;
        int prefix = 0;
        TreeNode *node = root;
        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->right;
            } else {
                node = stk.top(); stk.pop();
                node->val = prefix = node->val + prefix;
                node = node->left;
            }
        return root;
    }


    /*1040. Moving Stones Until Consecutive II (Medium)
    On an infinite number line, the position of the i-th stone is given by
    stones[i].  Call a stone an endpoint stone if it has the smallest or
    largest position. Each turn, you pick up an endpoint stone and move it to
    an unoccupied position so that it is no longer an endpoint stone. In
    particular, if the stones are at say, stones = [1,2,5], you cannot move the
    endpoint stone at position 5, since moving it to any position (such as 0,
    or 3) will still keep that stone as an endpoint stone. The game ends when
    you cannot make any more moves, ie. the stones are in consecutive positions.
    When the game ends, what is the minimum and maximum number of moves that
    you could have made?  Return the answer as an length 2 array:
    answer = [minimum_moves, maximum_moves]

    Example 1:
    Input: [7,4,9]
    Output: [1,2]
    Explanation: We can move 4 -> 8 for one move to finish the game. Or, we can
                 move 9 -> 5, 4 -> 6 for two moves to finish the game.

    Example 2:
    Input: [6,5,4,3,10]
    Output: [2,3]
    Explanation: We can move 3 -> 8 then 10 -> 7 to finish the game. Or, we can
                 move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game. Notice we
                 cannot move 10 -> 2 to finish the game, because that would be
                 an illegal move.

    Example 3:
    Input: [100,101,104,102,103]
    Output: [0,0]

    Note:
    * 3 <= stones.length <= 10^4
    * 1 <= stones[i] <= 10^9
    * stones[i] have distinct values.*/

    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(begin(stones), end(stones));
        int n = size(stones), ii = 0, low = INT_MAX, high = max(stones[n-2] - stones[0], stones[n-1] - stones[1]) - (n - 2);

        for (int i = 0; i < n; ++i) {
            while (stones[i] - stones[ii] >= n) ++ii;
            if (i - ii + 1 == n - 1 && stones[i] - stones[ii] == n - 2) low = min(low, 2);
            else low = min(low, n - (i - ii + 1));
        }
        return {low, high};
    }


    /*1041. Robot Bounded In Circle (Medium)
    On an infinite plane, a robot initially stands at (0, 0) and faces north.
    The robot can receive one of three instructions:
    * "G": go straight 1 unit;
    * "L": turn 90 degrees to the left;
    * "R": turn 90 degrees to the right.
    The robot performs the instructions given in order, and repeats them
    forever. Return true if and only if there exists a circle in the plane such
    that the robot never leaves the circle.

    Example 1:
    Input: instructions = "GGLLGG"
    Output: true
    Explanation: The robot moves from (0,0) to (0,2), turns 180 degrees, and
                 then returns to (0,0). When repeating these instructions, the
                 robot remains in the circle of radius 2 centered at the origin.

    Example 2:
    Input: instructions = "GG"
    Output: false
    Explanation: The robot moves north indefinitely.

    Example 3:
    Input: instructions = "GL"
    Output: true
    Explanation: The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0)
                 -> (0, 0) -> ...

    Constraints:
    * 1 <= instructions.length <= 100
    * instructions[i] is 'G', 'L' or, 'R'.*/

    bool isRobotBounded(string instructions) {
        int x = 0, y = 0, dx = 0, dy = 1;
        for (auto& ch : instructions) {
            if (ch == 'G') { x += dx; y += dy; }
            else if (ch == 'L') { swap(dx, dy); dx *= -1; }
            else { swap(dx, dy); dy *= -1; }
        }
        return (x == 0 && y == 0) || dx != 0 || dy != 1;
    }


    /*1046. Last Stone Weight (Easy)
    You are given an array of integers stones where stones[i] is the weight of
    the ith stone. We are playing a game with the stones. On each turn, we
    choose the heaviest two stones and smash them together. Suppose the
    heaviest two stones have weights x and y with x <= y. The result of this
    smash is:
    * If x == y, both stones are destroyed, and
    * If x != y, the stone of weight x is destroyed, and the stone of weight y
      has new weight y - x.
    At the end of the game, there is at most one stone left. Return the weight
    of the last remaining stone. If there are no stones left, return 0.

    Example 1:
    Input: stones = [2,7,4,1,8,1]
    Output: 1
    Explanation: - We combine 7 and 8 to get 1 so the array converts to
                   [2,4,1,1,1] then,
                 - we combine 2 and 4 to get 2 so the array converts to
                   [2,1,1,1] then,
                 - we combine 2 and 1 to get 1 so the array converts to
                   [1,1,1] then,
                 - we combine 1 and 1 to get 0 so the array converts to [1]
                   then that's the value of the last stone.

    Example 2:
    Input: stones = [1]
    Output: 1

    Constraints:
    * 1 <= stones.length <= 30
    * 1 <= stones[i] <= 1000*/

    int lastStoneWeight(vector<int>& stones) {
        priority_queue<int> pq;
        for (auto& x : stones) pq.push(x);
        while (pq.size() > 1) {
            int x = pq.top(); pq.pop();
            int y = pq.top(); pq.pop();
            if (x > y) pq.push(x-y);
        }
        return pq.size() ? pq.top() : 0;
    }


    /*1047. Remove All Adjacent Duplicates In String (Easy)
    You are given a string s consisting of lowercase English letters. A
    duplicate removal consists of choosing two adjacent and equal letters and
    removing them. We repeatedly make duplicate removals on s until we no
    longer can. Return the final string after all such duplicate removals have
    been made. It can be proven that the answer is unique.

    Example 1:
    Input: s = "abbaca"
    Output: "ca"
    Explanation: For example, in "abbaca" we could remove "bb" since the
                 letters are adjacent and equal, and this is the only possible
                 move.  The result of this move is that the string is "aaca",
                 of which only "aa" is possible, so the final string is "ca".

    Example 2:
    Input: s = "azxxzy"
    Output: "ay"

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters.*/

    string removeDuplicates(string s) {
        vector<char> stk;
        for (auto& ch : s) {
            if (size(stk) && stk.back() == ch) stk.pop_back();
            else stk.push_back(ch);
        }
        string ans;
        for (auto& ch : stk) ans.push_back(ch);
        return ans;
    }


    /*1048. Longest String Chain (Medium)
    Given a list of words, each word consists of English lowercase letters.
    Let's say word1 is a predecessor of word2 if and only if we can add exactly
    one letter anywhere in word1 to make it equal to word2. For example, "abc"
    is a predecessor of "abac". A word chain is a sequence of words
    [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of
    word_2, word_2 is a predecessor of word_3, and so on. Return the longest
    possible length of a word chain with words chosen from the given list of
    words.

    Example 1:
    Input: words = ["a","b","ba","bca","bda","bdca"]
    Output: 4
    Explanation: One of the longest word chain is "a","ba","bda","bdca".

    Example 2:
    Input: words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
    Output: 5

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 16
    * words[i] only consists of English lowercase letters.*/

    int longestStrChain(vector<string>& words) {
        sort(words.begin(), words.end(), [](string lhs, string rhs) { return lhs.size() < rhs.size(); });

        unordered_map<string, int> seen;
        int ans = 1;
        for (auto word : words) {
            seen[word] = 1;
            for (int i = 0; i < word.size(); ++i) {
                string key = word.substr(0, i) + word.substr(i+1);
                if (seen.count(key)) {
                    seen[word] = max(seen[word], 1 + seen[key]);
                    ans = max(ans, seen[word]);
                }
            }
        }
        return ans;
    }


    /*1051. Height Checker (Easy)
    A school is trying to take an annual photo of all the students. The students
    are asked to stand in a single file line in non-decreasing order by height.
    Let this ordering be represented by the integer array expected where
    expected[i] is the expected height of the ith student in line. You are given
    an integer array heights representing the current order that the students
    are standing in. Each heights[i] is the height of the ith student in line
    (0-indexed). Return the number of indices where heights[i] != expected[i].

    Example 1:
    Input: heights = [1,1,4,2,1,3]
    Output: 3
    Explanation: heights:  [1,1,4,2,1,3]
                 expected: [1,1,1,2,3,4]
                 Indices 2, 4, and 5 do not match.

    Example 2:
    Input: heights = [5,1,2,3,4]
    Output: 5
    Explanation: heights:  [5,1,2,3,4]
                 expected: [1,2,3,4,5]
                 All indices do not match.

    Example 3:
    Input: heights = [1,2,3,4,5]
    Output: 0
    Explanation: heights:  [1,2,3,4,5]
                 expected: [1,2,3,4,5]
                 All indices match.

    Constraints:
    * 1 <= heights.length <= 100
    * 1 <= heights[i] <= 100*/

    int heightChecker(vector<int>& heights) {
        vector<int> freq(101);
        for (auto& x : heights) ++freq[x];
        int ans = 0, v = 0;
        for (auto& x : heights) {
            while (freq[v] == 0) ++v;
            if (x != v) ++ans;
            --freq[v];
        }
        return ans;
    }


    /*1052. Grumpy Bookstore Owner (Medium)
    There is a bookstore owner that has a store open for n minutes. Every
    minute, some number of customers enter the store. You are given an integer
    array customers of length n where customers[i] is the number of the customer
    that enters the store at the start of the ith minute and all those customers
    leave after the end of that minute. On some minutes, the bookstore owner is
    grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the
    bookstore owner is grumpy during the ith minute, and is 0 otherwise. When
    the bookstore owner is grumpy, the customers of that minute are not
    satisfied, otherwise, they are satisfied. The bookstore owner knows a secret
    technique to keep themselves not grumpy for minutes consecutive minutes, but
    can only use it once. Return the maximum number of customers that can be
    satisfied throughout the day.

    Example 1:
    Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
    Output: 16
    Explanation: The bookstore owner keeps themselves not grumpy for the last 3
                 minutes. The maximum number of customers that can be
                 satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.

    Example 2:
    Input: customers = [1], grumpy = [0], minutes = 1
    Output: 1

    Constraints:
    * n == customers.length == grumpy.length
    * 1 <= minutes <= n <= 2 * 10^4
    * 0 <= customers[i] <= 1000
    * grumpy[i] is either 0 or 1.*/

    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int ans = 0, most = 0;
        for (int i = 0, ii = 0, val = 0; i < customers.size(); ++i) {
            if (grumpy[i]) val += customers[i];
            else ans += customers[i];
            if (ii == i-minutes) {
                if (grumpy[ii]) val -= customers[ii];
                ++ii;
            }
            most = max(most, val);
        }
        return ans + most;
    }


    /*1055. Shortest Way to Form String (Medium)
    A subsequence of a string is a new string that is formed from the original
    string by deleting some (can be none) of the characters without disturbing
    the relative positions of the remaining characters. (i.e., "ace" is a
    subsequence of "abcde" while "aec" is not). Given two strings source and
    target, return the minimum number of subsequences of source such that their
    concatenation equals target. If the task is impossible, return -1.

    Example 1:
    Input: source = "abc", target = "abcbc"
    Output: 2
    Explanation: The target "abcbc" can be formed by "abc" and "bc", which are
                 subsequences of source "abc".

    Example 2:
    Input: source = "abc", target = "acdbc"
    Output: -1
    Explanation: The target string cannot be constructed from the subsequences
                 of source string due to the character "d" in target string.

    Example 3:
    Input: source = "xyz", target = "xzyxz"
    Output: 3
    Explanation: The target string can be constructed as follows
                 "xz" + "y" + "xz".

    Constraints:
    * 1 <= source.length, target.length <= 1000
    * source and target consist of lowercase English letters.*/

    int shortestWay(string source, string target) {
        unordered_map<char, vector<int>> locs;
        for (int i = 0; i < source.size(); ++i)
            locs[source[i]].push_back(i);

        int ans = 1, i = 0;
        for (auto& x : target) {
            if (locs.find(x) == locs.end()) return -1;
            auto it = lower_bound(locs[x].begin(), locs[x].end(), i);
            if (it == locs[x].end()) {
                ++ans;
                it = locs[x].begin();
            }
            i = (*it) + 1;
        }
        return ans;
    }


    /*1057. Campus Bikes (Medium)
    On a campus represented on the X-Y plane, there are n workers and m bikes,
    with n <= m. You are given an array workers of length n where
    workers[i] = [xi, yi] is the position of the ith worker. You are also given
    an array bikes of length m where bikes[j] = [xj, yj] is the position of the
    jth bike. All the given positions are unique. Assign a bike to each worker.
    Among the available bikes and workers, we choose the (workeri, bikej) pair
    with the shortest Manhattan distance between each other and assign the bike
    to that worker. If there are multiple (workeri, bikej) pairs with the same
    shortest Manhattan distance, we choose the pair with the smallest worker
    index. If there are multiple ways to do that, we choose the pair with the
    smallest bike index. Repeat this process until there are no available
    workers. Return an array answer of length n, where answer[i] is the index
    (0-indexed) of the bike that the ith worker is assigned to. The Manhattan
    distance between two points p1 and p2 is
    Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.

    Example 1:
    Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
    Output: [1,0]
    Explanation: Worker 1 grabs Bike 0 as they are closest (without ties), and
                 Worker 0 is assigned Bike 1. So the output is [1, 0].

    Example 2:
    Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
    Output: [0,2,1]
    Explanation: Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share
                 the same distance to Bike 2, thus Worker 1 is assigned to Bike
                 2, and Worker 2 will take Bike 1. So the output is [0,2,1].

    Constraints:
    * n == workers.length
    * m == bikes.length
    * 1 <= n <= m <= 1000
    * workers[i].length == bikes[j].length == 2
    * 0 <= xi, yi < 1000
    * 0 <= xj, yj < 1000
    * All worker and bike locations are unique.*/

    vector<int> assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {
        vector<vector<int>> vals;
        for (int i = 0; i < workers.size(); ++i)
            for (int j = 0; j < bikes.size(); ++j) {
                int dist = abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]);
                vals.push_back({dist, i, j});
            }

        sort(vals.begin(), vals.end());
        vector<int> ans(workers.size(), -1), seen(bikes.size(), 0);
        for (auto& x : vals) {
            int i = x[1], j = x[2];
            if (ans[i] == -1 && !seen[j]) {
                ans[i] = j;
                seen[j] = 1;
            }
        }
        return ans;
    }


    /*1058. Minimize Rounding Error to Meet Target (Medium)
    Given an array of prices [p1,p2...,pn] and a target, round each price pi to
    Roundi(pi) so that the rounded array [Round1(p1),Round2(p2)...,Roundn(pn)]
    sums to the given target. Each operation Roundi(pi) could be either
    Floor(pi) or Ceil(pi). Return the string "-1" if the rounded array is
    impossible to sum to target. Otherwise, return the smallest rounding error,
    which is defined as Σ |Roundi(pi) - (pi)| for i from 1 to n, as a string
    with three places after the decimal.

    Example 1:
    Input: prices = ["0.700","2.800","4.900"], target = 8
    Output: "1.000"
    Explanation: Use Floor, Ceil and Ceil operations to get
                 (0.7 - 0) + (3 - 2.8) + (5 - 4.9) = 0.7 + 0.2 + 0.1 = 1.0 .

    Example 2:
    Input: prices = ["1.500","2.500","3.500"], target = 10
    Output: "-1"
    Explanation: It is impossible to meet the target.

    Example 3:
    Input: prices = ["1.500","2.500","3.500"], target = 9
    Output: "1.500"

    Constraints:
    * 1 <= prices.length <= 500
    * Each string prices[i] represents a real number in the range [0.0, 1000.0]
      and has exactly 3 decimal places.
    * 0 <= target <= 10^6*/

    string minimizeError(vector<string>& prices, int target) {
        vector<double> err;
        double ans = 0, lo = 0, hi = 0;
        for (auto& price : prices) {
            double x = stod(price);
            lo += floor(x);
            hi += ceil(x);
            if (floor(x) < x && x < ceil(x)) err.push_back(x - floor(x));
        }
        if (target < lo || hi < target) return "-1";
        sort(err.begin(), err.end());
        int k = hi - target;
        for (int i = 0; i < err.size(); ++i) {
            if (i < k) ans += err[i];
            else ans -= err[i];
        }
        ans += err.size() - k;
        stringstream stream;
        stream << fixed << setprecision(3) << ans;
        return stream.str();
    }


    /*1059. All Paths from Source Lead to Destination (Medium)
    Given the edges of a directed graph where edges[i] = [ai, bi] indicates
    there is an edge between nodes ai and bi, and two nodes source and
    destination of this graph, determine whether or not all paths starting from
    source eventually, end at destination, that is:
    * At least one path exists from the source node to the destination node
    * If a path exists from the source node to a node with no outgoing edges,
      then that node is equal to destination.
    * The number of possible paths from source to destination is a finite number.
    Return true if and only if all roads from source lead to destination.

    Example 1:
    Input: n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2
    Output: false
    Explanation: It is possible to reach and get stuck on both node 1 and node 2.

    Example 2:
    Input: n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3
    Output: false
    Explanation: We have two possibilities: to end at node 3, or to loop over
                 node 1 and node 2 indefinitely.

    Example 3:
    Input: n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3
    Output: true

    Example 4:
    Input: n = 3, edges = [[0,1],[1,1],[1,2]], source = 0, destination = 2
    Output: false
    Explanation: All paths from the source node end at the destination node,
                 but there are an infinite number of paths, such as 0-1-2,
                 0-1-1-2, 0-1-1-1-2, 0-1-1-1-1-2, and so on.

    Example 5:
    Input: n = 2, edges = [[0,1],[1,1]], source = 0, destination = 1
    Output: false
    Explanation: There is infinite self-loop at destination node.

    Constraints:
    * 1 <= n <= 10^4
    * 0 <= edges.length <= 10^4
    * edges.length == 2
    * 0 <= ai, bi <= n - 1
    * 0 <= source <= n - 1
    * 0 <= destination <= n - 1
    * The given graph may have self-loops and parallel edges.*/

    bool leadsToDestination(int n, vector<vector<int>>& edges, int source, int destination) {
        unordered_map<int, vector<int>> graph;
        for (auto&& edge : edges)
            graph[edge[0]].push_back(edge[1]);

        vector<int> color(n, 0);

        function<bool(int)> fn = [&](int x) {
            if (color[x]) return color[x] == 1;
            if (!graph[x].size()) return x == destination;
            color[x] = -1;
            for (auto&& xx : graph[x])
                if (!fn(xx)) return false;
            color[x] = 1;
            return true;
        };

        return fn(source);
    }


    /*1060. Missing Element in Sorted Array (Medium)
    Given an integer array nums which is sorted in ascending order and all of
    its elements are unique and given also an integer k, return the kth missing
    number starting from the leftmost number of the array.

    Example 1:
    Input: nums = [4,7,9,10], k = 1
    Output: 5
    Explanation: The first missing number is 5.

    Example 2:
    Input: nums = [4,7,9,10], k = 3
    Output: 8
    Explanation: The missing numbers are [5,6,8,...], hence the third missing
                 number is 8.

    Example 3:
    Input: nums = [1,2,4], k = 3
    Output: 6
    Explanation: The missing numbers are [3,5,6,7,...], hence the third missing
                 number is 6.

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 1 <= nums[i] <= 10^7
    * nums is sorted in ascending order, and all the elements are unique.
    * 1 <= k <= 10^8

    Follow up: Can you find a logarithmic time complexity (i.e., O(log(n)))
               solution?*/

    int missingElement(vector<int>& nums, int k) {
        int lo = 0, hi = nums.size();
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (nums[mid] - nums[0] - mid < k) lo = mid + 1;
            else hi = mid;
        }
        return nums[0] + k + lo - 1;
    }


    /*1061. Lexicographically Smallest Equivalent String (Medium)
    You are given two strings of the same length s1 and s2 and a string baseStr.
    We say s1[i] and s2[i] are equivalent characters.
    * For example, if s1 = "abc" and s2 = "cde", then we have 'a' == 'c',
      'b' == 'd', and 'c' == 'e'.
    Equivalent characters follow the usual rules of any equivalence relation:
    * Reflexivity: 'a' == 'a'.
    * Symmetry: 'a' == 'b' implies 'b' == 'a'.
    * Transitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.
    For example, given the equivalency information from s1 = "abc" and
    s2 = "cde", "acd" and "aab" are equivalent strings of baseStr = "eed", and
    "aab" is the lexicographically smallest equivalent string of baseStr.
    Return the lexicographically smallest equivalent string of baseStr by using
    the equivalency information from s1 and s2.

    Example 1:
    Input: s1 = "parker", s2 = "morris", baseStr = "parser"
    Output: "makkek"
    Explanation: Based on the equivalency information in s1 and s2, we can
                 group their characters as [m,p], [a,o], [k,r,s], [e,i]. The
                 characters in each group are equivalent and sorted in
                 lexicographical order. So the answer is "makkek".

    Example 2:
    Input: s1 = "hello", s2 = "world", baseStr = "hold"
    Output: "hdld"
    Explanation: Based on the equivalency information in s1 and s2, we can
                 group their characters as [h,w], [d,e,o], [l,r]. So only the
                 second letter 'o' in baseStr is changed to 'd', the answer is
                 "hdld".

    Example 3:
    Input: s1 = "leetcode", s2 = "programs", baseStr = "sourcecode"
    Output: "aauaaaaada"
    Explanation: We group the equivalent characters in s1 and s2 as
                 [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in
                 baseStr except 'u' and 'd' are transformed to 'a', the answer
                 is "aauaaaaada".

    Constraints:
    * 1 <= s1.length, s2.length, baseStr <= 1000
    * s1.length == s2.length
    * s1, s2, and baseStr consist of lowercase English letters.

class UnionFind {
unordered_map<char, char> parent;
public:
    char find(char p) {
        if (!parent.count(p)) parent[p] = p;
        if (p != parent[p])
            parent[p] = find(parent[p]);
        return parent[p];
    }

    void connect(char p, char q) {
        char prt = find(p), qrt = find(q);
        if (prt < qrt) swap(prt, qrt);
        parent[prt] = qrt;
    }
}; */

    string smallestEquivalentString(string s1, string s2, string baseStr) {
        UnionFind* uf = new UnionFind();
        for (int i = 0; i < s1.size(); ++i)
            uf->connect(s1[i], s2[i]);
        string ans;
        for (auto& ch : baseStr)
            ans.push_back(uf->find(ch));
        delete uf; // release heap memory
        return ans;
    }


    /*1062. Longest Repeating Substring (Medium)
    Given a string s, find out the length of the longest repeating substring(s).
    Return 0 if no repeating substring exists.

    Example 1:
    Input: s = "abcd"
    Output: 0
    Explanation: There is no repeating substring.

    Example 2:
    Input: s = "abbaba"
    Output: 2
    Explanation: The longest repeating substrings are "ab" and "ba", each of
                 which occurs twice.

    Example 3:
    Input: s = "aabcaabdaab"
    Output: 3
    Explanation: The longest repeating substring is "aab", which occurs 3 times.

    Example 4:
    Input: s = "aaaaa"
    Output: 4
    Explanation: The longest repeating substring is "aaaa", which occurs twice.

    Constraints:
    * The string s consists of only lowercase English letters from 'a' - 'z'.
    * 1 <= s.length <= 1500*/

    int longestRepeatingSubstring(string s) {
        const int MOD = 1'000'000'007;
        vector<long> fac(1, 1), prefix(1, 0);
        for (auto& ch : s) {
            fac.push_back(fac.back() * 26 % MOD);
            prefix.push_back((prefix.back() * 26 + (ch - 'a')) % MOD);
        }

        auto fn = [&](int k) {
            unordered_set<int> seen;
            for (int i = 0; i < s.size()-k+1; ++i) {
                int val = (prefix[i+k] - prefix[i]*fac[k]%MOD + MOD) % MOD;
                if (seen.count(val)) return true;
                seen.insert(val);
            }
            return false;
        };

        int lo = -1, hi = s.size()-1;
        while (lo < hi) {
            int mid = lo + (hi - lo + 1)/2;
            if (fn(mid)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }


    /*1063. Number of Valid Subarrays (Hard)
    Given an integer array nums, return the number of non-empty subarrays with
    the leftmost element of the subarray not larger than other elements in the
    subarray. A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1,4,2,5,3]
    Output: 11
    Explanation: There are 11 valid subarrays: [1],[4],[2],[5],[3],[1,4],[2,5],
                 [1,4,2],[2,5,3],[1,4,2,5],[1,4,2,5,3].

    Example 2:
    Input: nums = [3,2,1]
    Output: 3
    Explanation: The 3 valid subarrays are: [3],[2],[1].

    Example 3:
    Input: nums = [2,2,2]
    Output: 6
    Explanation: There are 6 valid subarrays: [2],[2],[2],[2,2],[2,2],[2,2,2].

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 0 <= nums[i] <= 10^5*/

    int validSubarrays(vector<int>& nums) {
        int ans = 0;
        stack<int> stk;
        for (auto& x : nums) {
            while (stk.size() && stk.top() > x) stk.pop();
            stk.push(x);
            ans += stk.size();
        }
        return ans;
    }


    /*1066. Campus Bikes II (Medium)
    On a campus represented as a 2D grid, there are n workers and m bikes, with
    n <= m. Each worker and bike is a 2D coordinate on this grid. We assign one
    unique bike to each worker so that the sum of the Manhattan distances
    between each worker and their assigned bike is minimized. Return the
    minimum possible sum of Manhattan distances between each worker and their
    assigned bike. The Manhattan distance between two points p1 and p2 is
    Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.

    Example 1:
    Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
    Output: 6
    Explanation: We assign bike 0 to worker 0, bike 1 to worker 1. The
                 Manhattan distance of both assignments is 3, so the output is
                 6.

    Example 2:
    Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
    Output: 4
    Explanation: We first assign bike 0 to worker 0, then assign bike 1 to
                 worker 1 or worker 2, bike 2 to worker 2 or worker 1. Both
                 assignments lead to sum of the Manhattan distances as 4.

    Example 3:
    Input: workers = [[0,0],[1,0],[2,0],[3,0],[4,0]],
           bikes = [[0,999],[1,999],[2,999],[3,999],[4,999]]
    Output: 4995

    Constraints:
    * n == workers.length
    * m == bikes.length
    * 1 <= n <= m <= 10
    * workers[i].length == 2
    * bikes[i].length == 2
    * 0 <= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] < 1000
    * All the workers and the bikes locations are unique.*/

    int assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {
        int n = workers.size(), m = bikes.size();
        vector<vector<int>> dp(n+1, vector<int>(1<<m, 0l));
        for (int i = n-1; i >= 0; --i)
            for (int mask = 0; mask < (1 << m); ++mask) {
                dp[i][mask] = 100'000;
                for (int j = 0; j < m; ++j)
                    if ((mask & (1 << j)) == 0)
                        dp[i][mask] = min(dp[i][mask], abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]) + dp[i+1][mask^(1<<j)]);
            }
        return dp[0][0];
    }


    /*1071. Greatest Common Divisor of Strings (Easy)
    For two strings s and t, we say "t divides s" if and only if s = t + ... + t
    (i.e., t is concatenated with itself one or more times). Given two strings
    str1 and str2, return the largest string x such that x divides both str1
    and str2.

    Example 1:
    Input: str1 = "ABCABC", str2 = "ABC"
    Output: "ABC"

    Example 2:
    Input: str1 = "ABABAB", str2 = "ABAB"
    Output: "AB"

    Example 3:
    Input: str1 = "LEET", str2 = "CODE"
    Output: ""

    Constraints:
    * 1 <= str1.length, str2.length <= 1000
    * str1 and str2 consist of English uppercase letters.*/

    string gcdOfStrings(string str1, string str2) {
        if (str1 + str2 != str2 + str1) return "";
        int g = gcd(str1.size(), str2.size());
        return str1.substr(0, g);
    }


    /*1074. Number of Submatrices That Sum to Target (Hard)
    Given a matrix and a target, return the number of non-empty submatrices
    that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells
    matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2. Two submatrices
    (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some
    coordinate that is different: for example, if x1 != x1'.

    Example 1:
    Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
    Output: 4
    Explanation: The four 1x1 submatrices that only contain 0.

    Example 2:
    Input: matrix = [[1,-1],[-1,1]], target = 0
    Output: 5
    Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.

    Example 3:
    Input: matrix = [[904]], target = 0
    Output: 0

    Constraints:
    * 1 <= matrix.length <= 100
    * 1 <= matrix[0].length <= 100
    * -1000 <= matrix[i] <= 1000
    * -10^8 <= target <= 10^8*/

    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
        int ans = 0, m = matrix.size(), n = matrix[0].size(); // dimensions
        vector<vector<int>> prefix(m+1, vector<int>(n+1, 0));

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j)
                prefix[i+1][j+1] = matrix[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j];

            for (int ii = 0; ii <= i; ++ii) {
                unordered_map<int, int> freq;
                freq[0] = 1;
                for (int j = 0; j < n; ++j) {
                    int diff = prefix[i+1][j+1] - prefix[ii][j+1];
                    ans += freq[diff - target];
                    ++freq[diff];
                }
            }
        }
        return ans;
    }


    /*1078. Occurrences After Bigram (Easy)
    Given two strings first and second, consider occurrences in some text of
    the form "first second third", where second comes immediately after first,
    and third comes immediately after second. Return an array of all the words
    third for each occurrence of "first second third".

    Example 1:
    Input: text = "alice is a good girl she is a good student", first = "a", second = "good"
    Output: ["girl","student"]

    Example 2:
    Input: text = "we will we will rock you", first = "we", second = "will"
    Output: ["we","rock"]

    Constraints:
    * 1 <= text.length <= 1000
    * text consists of lowercase English letters and spaces.
    * All the words in text a separated by a single space.
    * 1 <= first.length, second.length <= 10
    * first and second consist of lowercase English letters.*/

    vector<string> findOcurrences(string text, string first, string second) {
        vector<string> ans;
        bool f0 = false, f1 = false;
        istringstream iss(text);
        for (string word; iss >> word; ) {
            if (f1) ans.push_back(word);
            f1 = f0 && word == second;
            f0 = word == first;
        }
        return ans;
    }


    /*1087. Brace Expansion (Medium)
    You are given a string s representing a list of words. Each letter in the
    word has one or more options.
    * If there is one option, the letter is represented as is.
    * If there is more than one option, then curly braces delimit the options.
      For example, "{a,b,c}" represents options ["a", "b", "c"].
    For example, if s = "a{b,c}", the first character is always 'a', but the
    second character can be 'b' or 'c'. The original list is ["ab", "ac"].
    Return all words that can be formed in this manner, sorted in
    lexicographical order.

    Example 1:
    Input: s = "{a,b}c{d,e}f"
    Output: ["acdf","acef","bcdf","bcef"]

    Example 2:
    Input: s = "abcd"
    Output: ["abcd"]

    Constraints:
    * 1 <= s.length <= 50
    * s consists of curly brackets '{}', commas ',', and lowercase English
      letters.
    * s is guaranteed to be a valid input.
    * There are no nested curly brackets.
    * All characters inside a pair of consecutive opening and ending curly
      brackets are different.*/

    vector<string> expand(string s) {
        vector<string> ans = {""};
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '{') {
                int ii = i;
                while (s[++ii] != '}');
                string ss = s.substr(i+1, ii-i-1); // ss == substring
                vector<string> tokens;
                for (int k = 0, kk = 0; k != -1; kk = k+1) {
                    k = ss.find(',', kk);
                    tokens.push_back(ss.substr(kk, (k == -1 ? ss.size() : k)-kk));
                }
                vector<string> tmp;
                for (auto& x : ans)
                    for (auto& xx : tokens)
                        tmp.push_back(x+xx);
                ans = tmp;
                i = ii;
            } else
                for (auto& x : ans) x.push_back(s[i]);
        }
        sort(ans.begin(), ans.end());
        return ans;
    }


    /*1091. Shortest Path in Binary Matrix (Medium)
    Given an n x n binary matrix grid, return the length of the shortest clear
    path in the matrix. If there is no clear path, return -1. A clear path in a
    binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-
    right cell (i.e., (n - 1, n - 1)) such that:
    * All the visited cells of the path are 0.
    * All the adjacent cells of the path are 8-directionally connected (i.e.,
      they are different and they share an edge or a corner).
    The length of a clear path is the number of visited cells of this path.

    Example 1:
    Input: grid = [[0,1],[1,0]]
    Output: 2

    Example 2:
    Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
    Output: 4

    Example 3:
    Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
    Output: -1

    Constraints:
    * n == grid.length
    * n == grid[i].length
    * 1 <= n <= 100
    * grid[i][j] is 0 or 1*/

    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        if (grid[0][0] == 0) {
            int n = grid.size();
            queue<pair<int, int>> q; q.emplace(0, 0);
            grid[0][0] = 1;
            for (int ans = 1; q.size(); ++ans)
                for (int sz = q.size(); sz; --sz) {
                    auto [i, j] = q.front(); q.pop();
                    if (i == n-1 && j == n-1) return ans;
                    for (int ii = i-1; ii <= i+1; ++ii)
                        for (int jj = j-1; jj <= j+1; ++jj)
                            if (0 <= ii && ii < n && 0 <= jj && jj < n && grid[ii][jj] == 0) {
                                q.emplace(ii, jj);
                                grid[ii][jj] = 1;
                            }
                }
        }
        return -1;
    }


    /*1094. Car Pooling (Medium)
    There is a car with capacity empty seats. The vehicle only drives east (i.e.,
    it cannot turn around and drive west). You are given the integer capacity
    and an array trips where trip[i] = [numPassengersi, fromi, toi] indicates
    that the ith trip has numPassengersi passengers and the locations to pick
    them up and drop them off are fromi and toi respectively. The locations are
    given as the number of kilometers due east from the car's initial location.
    Return true if it is possible to pick up and drop off all passengers for
    all the given trips, or false otherwise.

    Example 1:
    Input: trips = [[2,1,5],[3,3,7]], capacity = 4
    Output: false

    Example 2:
    Input: trips = [[2,1,5],[3,3,7]], capacity = 5
    Output: true

    Constraints:
    * 1 <= trips.length <= 1000
    * trips[i].length == 3
    * 1 <= numPassengersi <= 100
    * 0 <= fromi < toi <= 1000
    * 1 <= capacity <= 10^5*/

    bool carPooling(vector<vector<int>>& trips, int capacity) {
        vector<pair<int, int>> vals;
        for (auto& trip : trips) {
            vals.emplace_back(trip[1], trip[0]);
            vals.emplace_back(trip[2], -trip[0]);
        }
        sort(vals.begin(), vals.end());
        for (auto& [k, x] : vals) {
            capacity -= x;
            if (capacity < 0) return false;
        }
        return true;
    }


    /*1095. Find in Mountain Array (Hard)
    (This problem is an interactive problem.)
    You may recall that an array A is a mountain array if and only if:
    * A.length >= 3
    * There exists some i with 0 < i < A.length - 1 such that:
      * A[0] < A[1] < ... A[i-1] < A[i]
      * A[i] > A[i+1] > ... > A[A.length - 1]
    Given a mountain array mountainArr, return the minimum index such that
    mountainArr.get(index) == target.  If such an index doesn't exist, return
    -1. You can't access the mountain array directly.  You may only access the
    array using a MountainArray interface:
    * MountainArray.get(k) returns the element of the array at index k (0-
      indexed).
    * MountainArray.length() returns the length of the array.
    Submissions making more than 100 calls to MountainArray.get will be judged
    Wrong Answer.  Also, any solutions that attempt to circumvent the judge
    will result in disqualification.

    Example 1:
    Input: array = [1,2,3,4,5,3,1], target = 3
    Output: 2
    Explanation: 3 exists in the array, at index=2 and index=5. Return the
                 minimum index, which is 2.

    Example 2:
    Input: array = [0,1,2,4,2,1], target = 3
    Output: -1
    Explanation: 3 does not exist in the array, so we return -1.

    Constraints:
    * 3 <= mountain_arr.length() <= 10000
    * 0 <= target <= 10^9
    * 0 <= mountain_arr.get(index) <= 10^9*/

    int findInMountainArray(int target, MountainArray &mountainArr) {

        function<int(int, int, int)> fn = [&](int lo, int hi, int mult) {
            while (lo < hi) {
                int mid = lo + (hi - lo)/2;
                if (mountainArr.get(mid) == target) return mid;
                else if (mountainArr.get(mid) * mult < target * mult) lo = mid + 1;
                else hi = mid;
            }
            return -1;
        };

        int lo = 0, hi = mountainArr.length();
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (mid && mountainArr.get(mid-1) < mountainArr.get(mid)) lo = mid + 1;
            else hi = mid;
        }
        int ans = 0;
        if ((ans = fn(0, lo, 1)) != -1) return ans;
        if ((ans = fn(lo, mountainArr.length(), -1)) != -1) return ans;
        return -1;
    }


    /*1100. Find K-Length Substrings With No Repeated Characters (Medium)
    Given a string s and an integer k, return the number of substrings in s of
    length k with no repeated characters.

    Example 1:
    Input: s = "havefunonleetcode", k = 5
    Output: 6
    Explanation: There are 6 substrings they are: 'havef','avefu','vefun',
                 'efuno','etcod','tcode'.

    Example 2:
    Input: s = "home", k = 5
    Output: 0
    Explanation: Notice k can be larger than the length of s. In this case, it
                 is not possible to find any substring.

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of lowercase English letters.
    * 1 <= k <= 10^4*/

    int numKLenSubstrNoRepeats(string s, int k) {
        int ans = 0;
        unordered_map<char, int> freq;
        for (int i = 0; i < s.size(); ++i) {
            freq[s[i]]++;
            if (i >= k && --freq[s[i-k]] == 0) freq.erase(s[i-k]);
            if (i+1 >= k && freq.size() == k) ++ans;
        }
        return ans;
    }


    /*1101. The Earliest Moment When Everyone Become Friends (Medium)
    There are n people in a social group labeled from 0 to n - 1. You are given
    an array logs where logs[i] = [timestampi, xi, yi] indicates that xi and yi
    will be friends at the time timestampi. Friendship is symmetric. That means
    if a is friends with b, then b is friends with a. Also, person a is
    acquainted with a person b if a is friends with b, or a is a friend of
    someone acquainted with b. Return the earliest time for which every person
    became acquainted with every other person. If there is no such earliest
    time, return -1.

    Example 1:
    Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],
                   [20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]],
                   n = 6
    Output: 20190301
    Explanation:
    The first event occurs at timestamp = 20190101 and after 0 and 1 become friends we have the following friendship groups [0,1], [2], [3], [4], [5].
    The second event occurs at timestamp = 20190104 and after 3 and 4 become friends we have the following friendship groups [0,1], [2], [3,4], [5].
    The third event occurs at timestamp = 20190107 and after 2 and 3 become friends we have the following friendship groups [0,1], [2,3,4], [5].
    The fourth event occurs at timestamp = 20190211 and after 1 and 5 become friends we have the following friendship groups [0,1,5], [2,3,4].
    The fifth event occurs at timestamp = 20190224 and as 2 and 4 are already friends anything happens.
    The sixth event occurs at timestamp = 20190301 and after 0 and 3 become friends we have that all become friends.

    Example 2:
    Input: logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4
    Output: 3

    Constraints:
    * 2 <= n <= 100
    * 1 <= logs.length <= 10^4
    * logs[i].length == 3
    * 0 <= timestampi <= 10^9
    * 0 <= xi, yi <= n - 1
    * xi != yi
    * All the values timestampi are unique.
    * All the pairs (xi, yi) occur at most one time in the input.*/

    int earliestAcq(vector<vector<int>>& logs, int n) {
        int ans = -1;
        UnionFind* uf = new UnionFind(n);
        sort(logs.begin(), logs.end());
        for (auto& log : logs)
            if (uf->connect(log[1], log[2]) && --n == 1) {
                ans = log[0];
                break;
            }
        delete uf;
        return ans;
    }


    /*1102. Path With Maximum Minimum Value (Medium)
    Given an m x n integer matrix grid, return the maximum score of a path
    starting at (0, 0) and ending at (m - 1, n - 1) moving in the 4 cardinal
    directions. The score of a path is the minimum value in that path. For
    example, the score of the path 8 → 4 → 5 → 9 is 4.

    Example 1:
    Input: grid = [[5,4,5],
                   [1,2,6],
                   [7,4,6]]
    Output: 4
    Explanation: The path with the maximum score is highlighted in yellow.

    Example 2:
    Input: grid = [[2,2,1,2,2,2],
                   [1,2,2,2,1,2]]
    Output: 2

    Example 3:
    Input: grid = [[3,4,6,3,4],
                   [0,2,1,1,7],
                   [8,8,3,2,7],
                   [3,2,4,9,8],
                   [4,1,2,0,0],
                   [4,6,5,4,3]]
    Output: 3

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 100
    * 0 <= grid[i][j] <= 10^9*/

    int maximumMinimumPath(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        priority_queue<pair<int, int>> pq;
        pq.emplace(grid[0][0], 0);
        grid[0][0] = -1; // mark as visited
        while (pq.size()) {
            auto [v, k] = pq.top(); pq.pop();
            int i = k/n, j = k%n;
            if (i == m-1 && j == n-1) return v;
            for (auto& [ii, jj] : {make_pair(i-1, j), {i, j-1}, {i, j+1}, {i+1, j}})
                if (0 <= ii && ii < m && 0 <= jj && jj < n && 0 <= grid[ii][jj]) {
                    pq.emplace(min(v, grid[ii][jj]), ii*n+jj);
                    grid[ii][jj] = -1;
                }
        }
        return -1;
    }


    /*1105. Filling Bookcase Shelves (Medium)
    You are given an array books where books[i] = [thicknessi, heighti]
    indicates the thickness and height of the ith book. You are also given an
    integer shelfWidth. We want to place these books in order onto bookcase
    shelves that have a total width shelfWidth. We choose some of the books to
    place on this shelf such that the sum of their thickness is less than or
    equal to shelfWidth, then build another level of the shelf of the bookcase
    so that the total height of the bookcase has increased by the maximum height
    of the books we just put down. We repeat this process until there are no
    more books to place. Note that at each step of the above process, the order
    of the books we place is the same order as the given sequence of books. For
    example, if we have an ordered list of 5 books, we might place the first and
    second book onto the first shelf, the third book on the second shelf, and
    the fourth and fifth book on the last shelf. Return the minimum possible
    height that the total bookshelf can be after placing shelves in this manner.

    Example 1:
    Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4
    Output: 6
    Explanation: The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.
                 Notice that book number 2 does not have to be on the first
                 shelf.

    Example 2:
    Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6
    Output: 4

    Constraints:
    * 1 <= books.length <= 1000
    * 1 <= thicknessi <= shelfWidth <= 1000
    * 1 <= heighti <= 1000*/

    int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {
        int n = books.size();
        vector<int> dp(n+1, INT_MAX);
        dp[n] = 0;
        for (int i = n-1; i >= 0; --i)
            for (int j = i, h = 0, w = 0; j < n; ++j) {
                w += books[j][0];
                if (w <= shelfWidth) {
                    h = max(h, books[j][1]);
                    dp[i] = min(dp[i], h + dp[j+1]);
                } else break;
            }
        return dp[0];
    }


    /*1110. Delete Nodes And Return Forest (Medium)
    Given the root of a binary tree, each node in the tree has a distinct value.
    After deleting all nodes with a value in to_delete, we are left with a
    forest (a disjoint union of trees). Return the roots of the trees in the
    remaining forest. You may return the result in any order.

    Example 1:
    Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
    Output: [[1,2,null,4],[6],[7]]

    Example 2:
    Input: root = [1,2,4,null,3], to_delete = [3]
    Output: [[1,2,4]]

    Constraints:
    * The number of nodes in the given tree is at most 1000.
    * Each node has a distinct value between 1 and 1000.
    * to_delete.length <= 1000
    * to_delete contains distinct values between 1 and 1000.*/

    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
        unordered_set<int> tabu(to_delete.begin(), to_delete.end());
        vector<TreeNode*> ans;
        stack<pair<TreeNode*, int>> stk;
        stk.emplace(root, -1);
        while (stk.size()) {
            auto [node, p] = stk.top(); stk.pop();
            if (node->left) {
                stk.emplace(node->left, node->val);
                if (tabu.contains(node->left->val)) node->left = nullptr;
            }
            if (node->right) {
                stk.emplace(node->right, node->val);
                if (tabu.contains(node->right->val)) node->right = nullptr;
            }
            if ((p == -1 || tabu.contains(p)) && !tabu.contains(node->val))
                ans.push_back(node);
        }
        return ans;
    }


    /*1120. Maximum Average Subtree (Medium)
    Given the root of a binary tree, return the maximum average value of a
    subtree of that tree. Answers within 10-5 of the actual answer will be
    accepted. A subtree of a tree is any node of that tree plus all its
    descendants. The average value of a tree is the sum of its values, divided
    by the number of nodes.

    Example 1:
    Input: root = [5,6,1]
    Output: 6.00000
    Explanation: For the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4.
                 For the node with value = 6 we have an average of 6 / 1 = 6.
                 For the node with value = 1 we have an average of 1 / 1 = 1.
                 So the answer is 6 which is the maximum.

    Example 2:
    Input: root = [0,null,1]
    Output: 1.00000

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * 0 <= Node.val <= 10^5*/

    double maximumAverageSubtree(TreeNode* root) {
        double ans = 0;
        stack<TreeNode*> stk;
        TreeNode *node = root, *prev = NULL;
        unordered_map<TreeNode*, int> sm, cnt;

        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top();
                if (node->right && node->right != prev) node = node->right;
                else {
                    sm[node] = node->val + sm[node->left] + sm[node->right];
                    cnt[node] = 1 + cnt[node->left] + cnt[node->right];
                    ans = max(ans, (double) sm[node]/cnt[node]);
                    stk.pop();
                    prev = node;
                    node = NULL;
                }
            }
        return ans;
    }


    /*1121. Divide Array Into Increasing Sequences (Hard)
    Given an integer array nums sorted in non-decreasing order and an integer k,
    return true if this array can be divided into one or more disjoint
    increasing subsequences of length at least k, or false otherwise.

    Example 1:
    Input: nums = [1,2,2,3,3,4,4], k = 3
    Output: true
    Explanation: The array can be divided into two subsequences [1,2,3,4] and
                 [2,3,4] with lengths at least 3 each.

    Example 2:
    Input: nums = [5,6,6,7,8], k = 3
    Output: false
    Explanation: There is no way to divide the array using the conditions
                 required.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * nums is sorted in non-decreasing order.*/

    bool canDivideIntoSubsequences(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        int m = 0;
        for (auto& x : nums) m = max(m, ++freq[x]);
        return m * k <= nums.size();
    }


    /*1122. Relative Sort Array (Easy)
    Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all
    elements in arr2 are also in arr1. Sort the elements of arr1 such that the
    relative ordering of items in arr1 are the same as in arr2. Elements that do
    not appear in arr2 should be placed at the end of arr1 in ascending order.

    Example 1:
    Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
    Output: [2,2,2,1,4,3,3,9,6,7,19]

    Example 2:
    Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
    Output: [22,28,8,6,17,44]

    Constraints:
    * 1 <= arr1.length, arr2.length <= 1000
    * 0 <= arr1[i], arr2[i] <= 1000
    * All the elements of arr2 are distinct.
    * Each arr2[i] is in arr1.*/

    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        vector<int> freq(1001);
        for (auto& x : arr1) ++freq[x];
        int i = 0;
        for (auto& x : arr2)
            while (freq[x]-- > 0)
                arr1[i++] = x;
        for (int x = 0; x <= 1000; ++x)
            while (freq[x]-- > 0)
                arr1[i++] = x;
        return arr1;
    }


    /*1129. Shortest Path with Alternating Colors (Medium)
    You are given an integer n, the number of nodes in a directed graph where
    the nodes are labeled from 0 to n - 1. Each edge is red or blue in this
    graph, and there could be self-edges and parallel edges. You are given two
    arrays redEdges and blueEdges where:
    * redEdges[i] = [ai, bi] indicates that there is a directed red edge from
      node ai to node bi in the graph, and
    * blueEdges[j] = [uj, vj] indicates that there is a directed blue edge from
      node uj to node vj in the graph.
    Return an array answer of length n, where each answer[x] is the length of
    the shortest path from node 0 to node x such that the edge colors alternate
    along the path, or -1 if such a path does not exist.

    Example 1:
    Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []
    Output: [0,1,-1]

    Example 2:
    Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]
    Output: [0,1,-1]

    Constraints:
    * 1 <= n <= 100
    * 0 <= redEdges.length, blueEdges.length <= 400
    * redEdges[i].length == blueEdges[j].length == 2
    * 0 <= ai, bi, uj, vj < n*/

    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        vector<vector<pair<int, int>>> graph(n);
        for (auto& e : redEdges) graph[e[0]].emplace_back(e[1], 0);
        for (auto& e : blueEdges) graph[e[0]].emplace_back(e[1], 1);
        queue<pair<int, int>> q;
        q.emplace(0, 0);
        q.emplace(0, 1);
        vector<vector<int>> dist(n, vector<int>(2, INT_MAX));
        for (int k = 0; q.size(); ++k)
            for (int sz = q.size(); sz; --sz) {
                auto [u, c] = q.front(); q.pop();
                if (dist[u][c] > k) {
                    dist[u][c] = k;
                    for (auto& [v, cc] : graph[u])
                        if (cc != c) q.emplace(v, cc);
                }
            }
        vector<int> ans;
        for (auto& d : dist) {
            int v = min(d[0], d[1]);
            ans.push_back(v < INT_MAX ? v : -1);
        }
        return ans;
    }


    /*1135. Connecting Cities With Minimum Cost (Medium)
    There are n cities labeled from 1 to n. You are given the integer n and an
    array connections where connections[i] = [xi, yi, costi] indicates that the
    cost of connecting city xi and city yi (bidirectional connection) is costi.
    Return the minimum cost to connect all the n cities such that there is at
    least one path between each pair of cities. If it is impossible to connect
    all the n cities, return -1, The cost is the sum of the connections' costs
    used.

    Example 1:
    Input: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]
    Output: 6
    Explanation: Choosing any 2 edges will connect all cities so we choose the
                 minimum 2.

    Example 2:
    Input: n = 4, connections = [[1,2,3],[3,4,4]]
    Output: -1
    Explanation: There is no way to connect all cities even if all edges are
                 used.

    Constraints:
    * 1 <= n <= 10^4
    * 1 <= connections.length <= 10^4
    * connections[i].length == 3
    * 1 <= xi, yi <= n
    * xi != yi
    * 0 <= costi <= 10^5*/

    int minimumCost(int n, vector<vector<int>>& connections) {
        sort(connections.begin(), connections.end(), [](auto& lhs, auto& rhs) { return lhs[2] < rhs[2]; });
        int ans = 0;
        UnionFind* uf = new UnionFind(n);
        for (auto& connection : connections) {
            int x = connection[0] - 1, y = connection[1] - 1, cost = connection[2];
            if (uf->connect(x, y)) {
                ans += cost;
                n -= 1;
            }
            if (n == 1) break;
        }
        delete uf;
        return n == 1 ? ans : -1;
    }


    /*1136. Parallel Courses (Medium)
    You are given an integer n, which indicates that there are n courses
    labeled from 1 to n. You are also given an array relations where
    relations[i] = [prevCoursei, nextCoursei], representing a prerequisite
    relationship between course prevCoursei and course nextCoursei: course
    prevCoursei has to be taken before course nextCoursei. In one semester, you
    can take any number of courses as long as you have taken all the
    prerequisites in the previous semester for the courses you are taking.
    Return the minimum number of semesters needed to take all courses. If there
    is no way to take all the courses, return -1.

    Example 1:
    Input: n = 3, relations = [[1,3],[2,3]]
    Output: 2
    Explanation: The figure above represents the given graph. In the first
                 semester, you can take courses 1 and 2. In the second semester,
                 you can take course 3.

    Example 2:
    Input: n = 3, relations = [[1,2],[2,3],[3,1]]
    Output: -1
    Explanation: No course can be studied because they are prerequisites of
                 each other.

    Constraints:
    * 1 <= n <= 5000
    * 1 <= relations.length <= 5000
    * relations[i].length == 2
    * 1 <= prevCoursei, nextCoursei <= n
    * prevCoursei != nextCoursei
    * All the pairs [prevCoursei, nextCoursei] are unique.*/

    int minimumSemesters(int n, vector<vector<int>>& relations) {
        vector<vector<int>> graph(n);
        vector<int> indeg(n, 0);
        for (auto& relation : relations) {
            graph[relation[0]-1].push_back(relation[1]-1);
            indeg[relation[1]-1]++;
        }

        queue<int> q;
        for (int i = 0; i < n; ++i)
            if (indeg[i] == 0) q.push(i);

        int ans = 0;
        for (; q.size(); ++ans)
            for (int n = q.size(); n; --n) {
                int x = q.front(); q.pop();
                for (auto&& xx : graph[x])
                    if (--indeg[xx] == 0) q.push(xx);
            }

        for (auto& x : indeg)
            if (x) return -1;
        return ans;
    }


    /*1137. N-th Tribonacci Number (Easy)
    The Tribonacci sequence Tn is defined as follows:
    * T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.
    Given n, return the value of Tn.

    Example 1:
    Input: n = 4
    Output: 4
    Explanation: T_3 = 0 + 1 + 1 = 2
                 T_4 = 1 + 1 + 2 = 4

    Example 2:
    Input: n = 25
    Output: 1389537

    Constraints:
    * 0 <= n <= 37
    * The answer is guaranteed to fit within a 32-bit integer, ie.
      answer <= 2^31 - 1.*/

    int tribonacci(int n) {
        vector<int> dp{0, 1, 1};
        for (int i = 3; i <= n; ++i)
            dp[i%3] = accumulate(dp.begin(), dp.end(), 0);
        return dp[n%3];
    }


    /*1140. Stone Game II (Medium)
    Alice and Bob continue their games with piles of stones.  There are a number
    of piles arranged in a row, and each pile has a positive integer number of
    stones piles[i].  The objective of the game is to end with the most stones.
    Alice and Bob take turns, with Alice starting first.  Initially, M = 1. On
    each player's turn, that player can take all the stones in the first X
    remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X). The game
    continues until all the stones have been taken. Assuming Alice and Bob play
    optimally, return the maximum number of stones Alice can get.

    Example 1:
    Input: piles = [2,7,9,4,4]
    Output: 10
    Explanation:  If Alice takes one pile at the beginning, Bob takes two piles,
                  then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10
                  piles in total. If Alice takes two piles at the beginning,
                  then Bob can take all three piles left. In this case, Alice
                  get 2 + 7 = 9 piles in total. So we return 10 since it's
                  larger.

    Example 2:
    Input: piles = [1,2,3,4,5,100]
    Output: 104

    Constraints:
    * 1 <= piles.length <= 100
    * 1 <= piles[i] <= 10^4*/

    int stoneGameII(vector<int>& piles) {
        int n = piles.size();
        vector<int> prefix(1);
        for (auto& x : piles)
            prefix.push_back(prefix.back() + x);
        vector<vector<int>> dp(n+1, vector<int>(n+1));
        for (int i = n-1; i >= 0; --i)
            for (int j = 1; j <= n; ++j)
                for (int ii = i; ii < n && ii < i+2*j; ++ii) {
                    int jj = max(j, ii-i+1);
                    int cand = prefix[n] - prefix[i] - dp[ii+1][jj];
                    dp[i][j] = max(dp[i][j], cand);
                }
        return dp[0][1];
    }


    /*1143. Longest Common Subsequence (Medium)
    Given two strings text1 and text2, return the length of their longest
    common subsequence. If there is no common subsequence, return 0. A
    subsequence of a string is a new string generated from the original string
    with some characters (can be none) deleted without changing the relative
    order of the remaining characters. For example, "ace" is a subsequence of
    "abcde". A common subsequence of two strings is a subsequence that is
    common to both strings.

    Example 1:
    Input: text1 = "abcde", text2 = "ace"
    Output: 3
    Explanation: The longest common subsequence is "ace" and its length is 3.

    Example 2:
    Input: text1 = "abc", text2 = "abc"
    Output: 3
    Explanation: The longest common subsequence is "abc" and its length is 3.

    Example 3:
    Input: text1 = "abc", text2 = "def"
    Output: 0
    Explanation: There is no such common subsequence, so the result is 0.

    Constraints:
    * 1 <= text1.length, text2.length <= 1000
    * text1 and text2 consist of only lowercase English characters.*/

    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for (int i = m-1; i >= 0; --i)
            for (int j = n-1; j >= 0; --j)
                if (text1[i] == text2[j]) dp[i][j] = 1 + dp[i+1][j+1];
                else dp[i][j] = max(dp[i+1][j], dp[i][j+1]);
        return dp[0][0];
    }


    /*1151. Minimum Swaps to Group All 1's Together (Medium)
    Given a binary array data, return the minimum number of swaps required to
    group all 1’s present in the array together in any place in the array.

    Example 1:
    Input: data = [1,0,1,0,1]
    Output: 1
    Explanation: There are 3 ways to group all 1's together:
                 [1,1,1,0,0] using 1 swap.
                 [0,1,1,1,0] using 2 swaps.
                 [0,0,1,1,1] using 1 swap.
                 The minimum is 1.

    Example 2:
    Input: data = [0,0,0,1,0]
    Output: 0
    Explanation: Since there is only one 1 in the array, no swaps needed.

    Example 3:
    Input: data = [1,0,1,0,1,0,0,1,1,0,1]
    Output: 3
    Explanation: One possible solution that uses 3 swaps is
                 [0,0,0,0,0,1,1,1,1,1,1].

    Example 4:
    Input: data = [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]
    Output: 8

    Constraints:
    * 1 <= data.length <= 10^5
    * data[i] is 0 or 1.*/

    int minSwaps(vector<int>& data) {
        int ans = 0, val = 0, k = accumulate(data.begin(), data.end(), 0);
        for (int i = 0; i < data.size(); ++i) {
            val += data[i];
            if (i >= k) val -= data[i-k];
            if (i+1 >= k) ans = max(ans, val);
        }
        return k - ans;
    }


    /*1152. Analyze User Website Visit Pattern (Medium)
    You are given two string arrays username and website and an integer array
    timestamp. All the given arrays are of the same length and the tuple
    [username[i], website[i], timestamp[i]] indicates that the user username[i]
    visited the website website[i] at time timestamp[i]. A pattern is a list of
    three websites (not necessarily distinct).

    * For example, ["home", "away", "love"], ["leetcode", "love", "leetcode"],
      and ["luffy", "luffy", "luffy"] are all patterns.
    The score of a pattern is the number of users that visited all the websites
    in the pattern in the same order they appeared in the pattern.
    * For example, if the pattern is ["home", "away", "love"], the score is the
      number of users x such that x visited "home" then visited "away" and
      visited "love" after that.
    * Similarly, if the pattern is ["leetcode", "love", "leetcode"], the score
      is the number of users x such that x visited "leetcode" then visited
      "love" and visited "leetcode" one more time after that.
    * Also, if the pattern is ["luffy", "luffy", "luffy"], the score is the
      number of users x such that x visited "luffy" three different times at
      different timestamps.
    Return the pattern with the largest score. If there is more than one
    pattern with the same largest score, return the lexicographically smallest
    such pattern.

    Example 1:
    Input: username = ["joe","joe","joe","james","james","james","james","mary","mary","mary"],
           timestamp = [1,2,3,4,5,6,7,8,9,10],
           website = ["home","about","career","home","cart","maps","home","home","about","career"]
    Output: ["home","about","career"]
    Explanation: The tuples in this example are:
    ["joe","home",1],["joe","about",2],["joe","career",3],["james","home",4],["james","cart",5],["james","maps",6],["james","home",7],["mary","home",8],["mary","about",9], and ["mary","career",10].
    The pattern ("home", "about", "career") has score 2 (joe and mary).
    The pattern ("home", "cart", "maps") has score 1 (james).
    The pattern ("home", "cart", "home") has score 1 (james).
    The pattern ("home", "maps", "home") has score 1 (james).
    The pattern ("cart", "maps", "home") has score 1 (james).
    The pattern ("home", "home", "home") has score 0 (no user visited home 3 times).

    Example 2:
    Input: username = ["ua","ua","ua","ub","ub","ub"],
           timestamp = [1,2,3,4,5,6],
           website = ["a","b","a","a","b","c"]
    Output: ["a","b","a"]

    Constraints:
    * 3 <= username.length <= 50
    * 1 <= username[i].length <= 10
    * timestamp.length == username.length
    * 1 <= timestamp[i] <= 10^9
    * website.length == username.length
    * 1 <= website[i].length <= 10
    * username[i] and website[i] consist of lowercase English letters.
    * It is guaranteed that there is at least one user who visited at least three websites.
    * All the tuples [username[i], timestamp[i], website[i]] are unique.*/

    vector<string> mostVisitedPattern(vector<string>& username, vector<int>& timestamp, vector<string>& website) {
        unordered_map<string, map<int, string>> mp;
        for (int i = 0; i < username.size(); ++i)
            mp[username[i]][timestamp[i]] = website[i];

        unordered_map<string, int> freq;
        for (auto& [key, v] : mp) {
            unordered_set<string> seen;
            for (auto i = v.begin(); i != v.end(); ++i)
                for (auto j = next(i); j != v.end(); ++j)
                    for (auto k = next(j); k != v.end(); ++k)
                        seen.insert(i->second + "#" + j->second + "#" + k->second);
            for (auto& x : seen) freq[x]++;
        }
        string ans;
        int most = 0;
        for (auto& [k, v] : freq)
            if (v > most || (v == most && k < ans)) {
                ans = k;
                most = v;
            }
        int i = ans.find("#"), j = ans.find("#", i+1);
        return {ans.substr(0, i), ans.substr(i+1, j-i-1), ans.substr(j+1)};
    }


    /*1168. Optimize Water Distribution in a Village (Hard)
    There are n houses in a village. We want to supply water for all the houses
    by building wells and laying pipes. For each house i, we can either build a
    well inside it directly with cost wells[i - 1] (note the -1 due to 0-
    indexing), or pipe in water from another well to it. The costs to lay pipes
    between houses are given by the array pipes, where each
    pipes[j] = [house1j, house2j, costj] represents the cost to connect house1j
    and house2j together using a pipe. Connections are bidirectional. Return
    the minimum total cost to supply water to all houses.

    Example 1:
    Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]
    Output: 3
    Explanation: The image shows the costs of connecting houses using pipes.
                 The best strategy is to build a well in the first house with
                 cost 1 and connect the other houses to it with cost 2 so the
                 total cost is 3.

    Example 2:
    Input: n = 2, wells = [1,1], pipes = [[1,2,1]]
    Output: 2

    Constraints:
    * 2 <= n <= 10^4
    * wells.length == n
    * 0 <= wells[i] <= 10^5
    * 1 <= pipes.length <= 10^4
    * pipes[j].length == 3
    * 1 <= house1j, house2j <= n
    * 0 <= costj <= 10^5
    * house1j != house2j*/

    int minCostToSupplyWater(int n, vector<int>& wells, vector<vector<int>>& pipes) {
        priority_queue<array<int,3>, vector<array<int,3>>, greater<>> pq; // min-heap
        for (auto& pipe : pipes)
            pq.push({pipe[2], pipe[0]-1, pipe[1]-1});

        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);

        function<int(int)> find = [&](int p) {
            if (p != parent[p]) parent[p] = find(parent[p]);
            return parent[p];
        };

        auto connect = [&](int p, int q, int cost) {
            int prt = find(p), qrt = find(q);
            if (wells[prt] < wells[qrt]) swap(prt, qrt);
            if (prt == qrt || wells[prt] <= cost) return false;
            parent[prt] = qrt;
            return true;
        };

        int ans = 0;
        while (pq.size()) {
            auto [cost, p, q] = pq.top(); pq.pop();
            if (connect(p, q, cost)) ans += cost;
        }
        unordered_set<int> seen;
        for (int i = 0; i < n; ++i) {
            int ii = find(i);
            if (!seen.count(ii)) {
                seen.insert(ii);
                ans += wells[ii];
            }
        }
        return ans;
    }


    /*1178. Number of Valid Words for Each Puzzle (Hard)
    With respect to a given puzzle string, a word is valid if both the
    following conditions are satisfied:
    * word contains the first letter of puzzle.
    * For each letter in word, that letter is in puzzle.
      + For example, if the puzzle is "abcdefg", then valid words are "faced",
        "cabbage", and "baggage", while
      + invalid words are "beefed" (does not include 'a') and "based" (includes
        's' which is not in the puzzle).
    Return an array answer, where answer[i] is the number of words in the given
    word list words that is valid with respect to the puzzle puzzles[i].

    Example 1:
    Input: words = ["aaaa","asas","able","ability","actt","actor","access"],
           puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
    Output: [1,1,3,2,4,0]
    Explanation: 1 valid word for "aboveyz" : "aaaa"
                 1 valid word for "abrodyz" : "aaaa"
                 3 valid words for "abslute" : "aaaa", "asas", "able"
                 2 valid words for "absoryz" : "aaaa", "asas"
                 4 valid words for "actresz" : "aaaa", "asas", "actt", "access"
                 There are no valid words for "gaswxyz" cause none of the words
                 in the list contains letter 'g'.

    Example 2:
    Input: words = ["apple","pleas","please"],
           puzzles = ["aelwxyz","aelpxyz","aelpsxy","saelpxy","xaelpsy"]
    Output: [0,1,3,2,0]

    Constraints:
    * 1 <= words.length <= 10^5
    * 4 <= words[i].length <= 50
    * 1 <= puzzles.length <= 10^4
    * puzzles[i].length == 7
    * words[i] and puzzles[i] consist of lowercase English letters.
    * Each puzzles[i] does not contain repeated characters.*/

    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {
        unordered_map<int, int> freq;
        for (auto& word : words) {
            int mask = 0;
            for (auto& ch : word) mask |= 1 << (ch - 'a');
            ++freq[mask];
        }

        vector<int> ans;
        for (auto& puzzle : puzzles) {
            int mask = 0, cnt = 0;
            for (auto& ch : puzzle) mask |= 1 << (ch - 'a');
            for (int m = mask; m; m = mask & (m-1))
                if (m & (1 << (puzzle[0]-'a'))) cnt += freq[m];
            ans.push_back(cnt);
        }
        return ans;
    }


    /*1181. Before and After Puzzle (Medium)
    Given a list of phrases, generate a list of Before and After puzzles. A
    phrase is a string that consists of lowercase English letters and spaces
    only. No space appears in the start or the end of a phrase. There are no
    consecutive spaces in a phrase. Before and After puzzles are phrases that
    are formed by merging two phrases where the last word of the first phrase
    is the same as the first word of the second phrase. Return the Before and
    After puzzles that can be formed by every two phrases phrases[i] and
    phrases[j] where i != j. Note that the order of matching two phrases
    matters, we want to consider both orders. You should return a list of
    distinct strings sorted lexicographically.

    Example 1:
    Input: phrases = ["writing code","code rocks"]
    Output: ["writing code rocks"]

    Example 2:
    Input: phrases = ["mission statement",
                      "a quick bite to eat",
                      "a chip off the old block",
                      "chocolate bar",
                      "mission impossible",
                      "a man on a mission",
                      "block party",
                      "eat my words",
                      "bar of soap"]
    Output: ["a chip off the old block party",
             "a man on a mission impossible",
             "a man on a mission statement",
             "a quick bite to eat my words",
             "chocolate bar of soap"]

    Example 3:
    Input: phrases = ["a","b","a"]
    Output: ["a"]

    Constraints:
    * 1 <= phrases.length <= 100
    * 1 <= phrases[i].length <= 100*/

    vector<string> beforeAndAfterPuzzles(vector<string>& phrases) {
        unordered_set<string> st;
        unordered_map<string, vector<int>> prefix, suffix;

        for (int i = 0; i < phrases.size(); ++i) {
            int k = phrases[i].find(" "), kk = phrases[i].rfind(" ");
            string first = k == string::npos ? phrases[i] : phrases[i].substr(0, k);
            string last = kk == string::npos ? phrases[i] : phrases[i].substr(kk+1);
            for (auto& j : suffix[first])
                st.insert(phrases[j] + phrases[i].substr(first.size()));

            for (auto& j : prefix[last])
                st.insert(phrases[i] + phrases[j].substr(last.size()));

            prefix[first].push_back(i);
            suffix[last].push_back(i);
        }

        vector<string> ans(st.begin(), st.end());
        sort(ans.begin(), ans.end());
        return ans;
    }


    /*1182. Shortest Distance to Target Color (Medium)
    You are given an array colors, in which there are three colors: 1, 2 and 3.
    You are also given some queries. Each query consists of two integers i and
    c, return the shortest distance between the given index i and the target
    color c. If there is no solution return -1.

    Example 1:
    Input: colors = [1,1,2,1,3,2,2,3,3], queries = [[1,3],[2,2],[6,1]]
    Output: [3,0,3]
    Explanation: The nearest 3 from index 1 is at index 4 (3 steps away).
                 The nearest 2 from index 2 is at index 2 itself (0 steps away).
                 The nearest 1 from index 6 is at index 3 (3 steps away).

    Example 2:
    Input: colors = [1,2], queries = [[0,3]]
    Output: [-1]
    Explanation: There is no 3 in the array.

    Constraints:
    * 1 <= colors.length <= 5*10^4
    * 1 <= colors[i] <= 3
    * 1 <= queries.length <= 5*10^4
    * queries[i].length == 2
    * 0 <= queries[i][0] < colors.length
    * 1 <= queries[i][1] <= 3*/

    vector<int> shortestDistanceColor(vector<int>& colors, vector<vector<int>>& queries) {
        unordered_map<int, vector<int>> locs;
        for (int i = 0; i < colors.size(); ++i) locs[colors[i]].push_back(i);

        vector<int> ans;
        for (auto& query : queries) {
            int i = query[0], c = query[1], val = INT_MAX;
            auto it = lower_bound(locs[c].begin(), locs[c].end(), i);
            if (it != locs[c].end()) val = *it - i;
            if (it != locs[c].begin()) val = min(val, i - *prev(it));
            ans.push_back(val < INT_MAX ? val : -1);
        }
        return ans;
    }


    /*1183. Maximum Number of Ones (Hard)
    Consider a matrix M with dimensions width * height, such that every cell
    has value 0 or 1, and any square sub-matrix of M of size
    sideLength * sideLength has at most maxOnes ones. Return the maximum
    possible number of ones that the matrix M can have.

    Example 1:
    Input: width = 3, height = 3, sideLength = 2, maxOnes = 1
    Output: 4
    Explanation: In a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.
                 The best solution that has 4 ones is:
                 [1,0,1]
                 [0,0,0]
                 [1,0,1]

    Example 2:
    Input: width = 3, height = 3, sideLength = 2, maxOnes = 2
    Output: 6
    Explanation: [1,0,1]
                 [1,0,1]
                 [1,0,1]

    Constraints:
    * 1 <= width, height <= 100
    * 1 <= sideLength <= width, height
    * 0 <= maxOnes <= sideLength * sideLength*/

    int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {
        if (width < height) swap(width, height);
        int nw = width/sideLength, rw = width%sideLength, nh = height/sideLength, rh = height%sideLength;
        int ans = nw * nh * maxOnes + (nw + nh + 1) * min(maxOnes, rw * rh);
        maxOnes -= rw * rh;
        if (maxOnes > 0) {
            ans += nw * min(maxOnes, (sideLength - rw) * rh);
            maxOnes -= (sideLength - rw) * rh;
            if (maxOnes > 0) ans += nh * min(maxOnes, rw * (sideLength - rh));
        }
        return ans;
    }


    /*1185. Day of the Week (Easy)
    Given a date, return the corresponding day of the week for that date. The
    input is given as three integers representing the day, month and year
    respectively. Return the answer as one of the following values
    {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.

    Example 1:
    Input: day = 31, month = 8, year = 2019
    Output: "Saturday"

    Example 2:
    Input: day = 18, month = 7, year = 1999
    Output: "Sunday"

    Example 3:
    Input: day = 15, month = 8, year = 1993
    Output: "Sunday"

    Constraints: The given dates are valid dates between the years 1971 and 2100.*/

    string dayOfTheWeek(int day, int month, int year) {

        auto fn = [](int y, int m, int d) {
            if (m < 3) {--y; m += 12; }
            return 365*y + y/4 + y/400 - y/100 + (153*m+8)/5 + d;
        };

        vector<string> day_name = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
        return day_name[(fn(year, month, day)-fn(1971,1,1)+4) % 7];
    }


    /*1189. Maximum Number of Balloons (Easy)
    Given a string text, you want to use the characters of text to form as many
    instances of the word "balloon" as possible. You can use each character in
    text at most once. Return the maximum number of instances that can be formed.

    Example 1:
    Input: text = "nlaebolko"
    Output: 1

    Example 2:
    Input: text = "loonbalxballpoon"
    Output: 2

    Example 3:
    Input: text = "leetcode"
    Output: 0

    Constraints:
    * 1 <= text.length <= 10^4
    * text consists of lower case English letters only.*/

    int maxNumberOfBalloons(string text) {
        int freq[26] = {0};
        for (auto& ch : text) ++freq[ch - 'a'];
        return min({freq[0], freq[1], freq[11]/2, freq[13], freq[14]/2});
    }


    /*1199. Minimum Time to Build Blocks (Hard)
    You are given a list of blocks, where blocks[i] = t means that the i-th
    block needs t units of time to be built. A block can only be built by
    exactly one worker. A worker can either split into two workers (number of
    workers increases by one) or build a block then go home. Both decisions
    cost some time. The time cost of spliting one worker into two workers is
    given as an integer split. Note that if two workers split at the same time,
    they split in parallel so the cost would be split. Output the minimum time
    needed to build all blocks. Initially, there is only one worker.

    Example 1:
    Input: blocks = [1], split = 1
    Output: 1
    Explanation: We use 1 worker to build 1 block in 1 time unit.

    Example 2:
    Input: blocks = [1,2], split = 5
    Output: 7
    Explanation: We split the worker into 2 workers in 5 time units then assign
                 each of them to a block so the cost is 5 + max(1, 2) = 7.

    Example 3:
    Input: blocks = [1,2,3], split = 1
    Output: 4
    Explanation: Split 1 worker into 2, then assign the first worker to the
                 last block and split the second worker into 2. Then, use the
                 two unassigned workers to build the first two blocks. The cost
                 is 1 + max(3, 1 + max(1, 2)) = 4.

    Constraints:
    * 1 <= blocks.length <= 1000
    * 1 <= blocks[i] <= 10^5
    * 1 <= split <= 100*/

    int minBuildTime(vector<int>& blocks, int split) {
        priority_queue<int, vector<int>, greater<>> pq;
        for (auto& x : blocks) pq.push(x);
        while (pq.size() > 1) {
            pq.pop();
            int v = pq.top(); pq.pop();
            pq.push(v+split);
        }
        return pq.top();
    }


    /*1200. Minimum Absolute Difference (Easy)
    Given an array of distinct integers arr, find all pairs of elements with
    the minimum absolute difference of any two elements. Return a list of pairs
    in ascending order(with respect to pairs), each pair [a, b] follows
    * a, b are from arr
    * a < b
    * b - a equals to the minimum absolute difference of any two elements in arr

    Example 1:
    Input: arr = [4,2,1,3]
    Output: [[1,2],[2,3],[3,4]]
    Explanation: The minimum absolute difference is 1. List all pairs with
                 difference equal to 1 in ascending order.

    Example 2:
    Input: arr = [1,3,6,10,15]
    Output: [[1,3]]

    Example 3:
    Input: arr = [3,8,-10,23,19,-4,-14,27]
    Output: [[-14,-10],[19,23],[23,27]]

    Constraints:
    * 2 <= arr.length <= 10^5
    * -10^6 <= arr[i] <= 10^6*/

    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
        sort(arr.begin(), arr.end());
        int diff = INT_MAX;
        vector<vector<int>> ans;
        for (int i = 1; i < arr.size(); ++i)
            if (arr[i] - arr[i-1] <= diff) {
                if (arr[i] - arr[i-1] < diff) {
                    diff = arr[i] - arr[i-1];
                    ans.clear();
                }
                ans.push_back({arr[i-1], arr[i]});
            }
        return ans;
    }


    /*1201. Ugly Number III (Medium)
    An ugly number is a positive integer that is divisible by a, b, or c. Given
    four integers n, a, b, and c, return the nth ugly number.

    Example 1:
    Input: n = 3, a = 2, b = 3, c = 5
    Output: 4
    Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.

    Example 2:
    Input: n = 4, a = 2, b = 3, c = 4
    Output: 6
    Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.

    Example 3:
    Input: n = 5, a = 2, b = 11, c = 13
    Output: 10
    Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.

    Example 4:
    Input: n = 1000000000, a = 2, b = 217983653, c = 336916467
    Output: 1999999984

    Constraints:
    * 1 <= n, a, b, c <= 10^9
    * 1 <= a * b * c <= 10^18
    * It is guaranteed that the result will be in range [1, 2 * 10^9].*/

    int nthUglyNumber(int n, int a, int b, int c) {
        // inclusion-exclusion principle
        long ab = (long) a/gcd(a, b)*b, bc = (long) b/gcd(b, c)*c, ca = (long) c/gcd(c, a)*a, abc = (long) ab/gcd(ab, c)*c;
        int lo = 0, hi = n*min({a, b, c});
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc < n) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*1208. Get Equal Substrings Within Budget (Medium)
    You are given two strings s and t of the same length and an integer maxCost.
    You want to change s to t. Changing the ith character of s to ith character
    of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII
    values of the characters). Return the maximum length of a substring of s
    that can be changed to be the same as the corresponding substring of t with
    a cost less than or equal to maxCost. If there is no substring from s that
    can be changed to its corresponding substring from t, return 0.

    Example 1:
    Input: s = "abcd", t = "bcdf", maxCost = 3
    Output: 3
    Explanation: "abc" of s can change to "bcd".
    That costs 3, so the maximum length is 3.

    Example 2:
    Input: s = "abcd", t = "cdef", maxCost = 3
    Output: 1
    Explanation: Each character in s costs 2 to change to character in t,  so
                 the maximum length is 1.

    Example 3:
    Input: s = "abcd", t = "acde", maxCost = 0
    Output: 1
    Explanation: You cannot make any change, so the maximum length is 1.

    Constraints:
    * 1 <= s.length <= 10^5
    * t.length == s.length
    * 0 <= maxCost <= 10^6
    * s and t consist of only lowercase English letters.*/

    int equalSubstring(string s, string t, int maxCost) {
        int ans = 0;
        for (int i = 0, ii = 0, val = 0; i < s.size(); ++i) {
            val += abs(s[i]-t[i]);
            for (; val > maxCost; ++ii)
                val -= abs(s[ii]-t[ii]);
            ans = max(ans, i-ii+1);
        }
        return ans;
    }


    /*1209. Remove All Adjacent Duplicates in String II (Medium)
    Given a string s, a k duplicate removal consists of choosing k adjacent and
    equal letters from s and removing them causing the left and the right side
    of the deleted substring to concatenate together. We repeatedly make k
    duplicate removals on s until we no longer can. Return the final string
    after all such duplicate removals have been made. It is guaranteed that the
    answer is unique.

    Example 1:
    Input: s = "abcd", k = 2
    Output: "abcd"
    Explanation: There's nothing to delete.

    Example 2:
    Input: s = "deeedbbcccbdaa", k = 3
    Output: "aa"
    Explanation:
    First delete "eee" and "ccc", get "ddbbbdaa"
    Then delete "bbb", get "dddaa"
    Finally delete "ddd", get "aa"

    Example 3:
    Input: s = "pbbcggttciiippooaais", k = 2
    Output: "ps"

    Constraints:
    * 1 <= s.length <= 10^5
    * 2 <= k <= 10^4
    * s only contains lower case English letters.*/

    string removeDuplicates(string s, int k) {
        vector<vector<int>> vec;
        for (auto c : s) {
            if (vec.size() && vec.back()[1] == c) {
                ++vec.back()[0];
            } else {
                vec.push_back({1, c});
            }
            if (vec.back()[0] == k) vec.pop_back();
        }

        string ans;
        for (auto x : vec) {
            ans += string(x[0], x[1]);
        }
        return ans;
    }


    /*1215. Stepping Numbers (Medium)
    A stepping number is an integer such that all of its adjacent digits have
    an absolute difference of exactly 1. For example, 321 is a stepping number
    while 421 is not. Given two integers low and high, return a sorted list of
    all the stepping numbers in the inclusive range [low, high].

    Example 1:
    Input: low = 0, high = 21
    Output: [0,1,2,3,4,5,6,7,8,9,10,12,21]

    Example 2:
    Input: low = 10, high = 15
    Output: [10,12]

    Constraints: 0 <= low <= high <= 2 * 10^9*/

    vector<int> countSteppingNumbers(int low, int high) {
        vector<int> ans;
        if (low == 0) ans.push_back(0);
        queue<long> q;
        for (int x = 1; x <= 9; ++x) q.push(x);

        while (q.size()) {
            long x = q.front(); q.pop();
            if (x <= high) {
                if (low <= x) ans.push_back(x);
                if (0 < x%10) q.push(10*x + x%10 - 1);
                if (x%10 < 9) q.push(10*x + x%10 + 1);
            }
        }
        return ans;
    }


    /*1216. Valid Palindrome III (Hard)
    Given a string s and an integer k, return true if s is a k-palindrome. A
    string is k-palindrome if it can be transformed into a palindrome by
    removing at most k characters from it.

    Example 1:
    Input: s = "abcdeca", k = 2
    Output: true
    Explanation: Remove 'b' and 'e' characters.

    Example 2:
    Input: s = "abbababa", k = 1
    Output: true

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of only lowercase English letters.
    * 1 <= k <= s.length*/

    bool isValidPalindrome(string s, int k) {
        int n = s.size();
        vector<vector<int>> dp(n+1, vector<int>(n));
        for (int i = n-1; i >= 0; --i) {
            dp[i][i] = 1;
            for (int j = i+1; j < n; ++j)
                if (s[i] == s[j]) dp[i][j] = 2 + dp[i+1][j-1];
                else dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
        }
        return dp[0][n-1] >= n-k;
    }


    /*1217. Minimum Cost to Move Chips to The Same Position (Easy)
    We have n chips, where the position of the ith chip is position[i]. We need
    to move all the chips to the same position. In one step, we can change the
    position of the ith chip from position[i] to:
    * position[i] + 2 or position[i] - 2 with cost = 0.
    * position[i] + 1 or position[i] - 1 with cost = 1.
    Return the minimum cost needed to move all the chips to the same position.

    Example 1:
    Input: position = [1,2,3]
    Output: 1
    Explanation: First step: Move the chip at position 3 to position 1 with
                 cost = 0. Second step: Move the chip at position 2 to position
                 1 with cost = 1. Total cost is 1.

    Example 2:
    Input: position = [2,2,2,3,3]
    Output: 2
    Explanation: We can move the two chips at position  3 to position 2. Each
                 move has cost = 1. The total cost = 2.

    Example 3:
    Input: position = [1,1000000000]
    Output: 1

    Constraints:
    * 1 <= position.length <= 100
    * 1 <= position[i] <= 10^9*/

    int minCostToMoveChips(vector<int>& position) {
        int odd = 0, even = 0;
        for (auto& x : position)
            if (x & 1) ++odd;
            else ++even;
        return min(odd, even);
    }


    /*1219. Path with Maximum Gold (Medium)
    In a gold mine grid of size m x n, each cell in this mine has an integer
    representing the amount of gold in that cell, 0 if it is empty. Return the
    maximum amount of gold you can collect under the conditions:
    * Every time you are located in a cell you will collect all the gold in that
      cell.
    * From your position, you can walk one step to the left, right, up, or down.
    * You can't visit the same cell more than once.
    * Never visit a cell with 0 gold.
    * You can start and stop collecting gold from any position in the grid that
      has some gold.

    Example 1:
    Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
    Output: 24
    Explanation: [[0,6,0],
                  [5,8,7],
                  [0,9,0]]
                 Path to get the maximum gold, 9 -> 8 -> 7.

    Example 2:
    Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
    Output: 28
    Explanation: [[1,0,7],
                  [2,0,6],
                  [3,4,5],
                  [0,3,0],
                  [9,0,20]]
                 Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 15
    * 0 <= grid[i][j] <= 100
    * There are at most 25 cells containing gold.*/

    int getMaximumGold(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), dir[] = {-1, 0, 1, 0, -1};

        function<int(int, int)> fn = [&](int i, int j) {
            int ans = 0, v = grid[i][j];
            grid[i][j] = 0;
            for (int k = 0; k < 4; ++k) {
                int ii = i + dir[k], jj = j + dir[k+1];
                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj])
                    ans = max(ans, fn(ii, jj));
            }
            grid[i][j] = v;
            return grid[i][j] + ans;
        };

        int ans = 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j])
                    ans = max(ans, fn(i, j));
        return ans;
    }


    /*1229. Meeting Scheduler (Medium)
    Given the availability time slots arrays slots1 and slots2 of two people
    and a meeting duration duration, return the earliest time slot that works
    for both of them and is of duration duration. If there is no common time
    slot that satisfies the requirements, return an empty array. The format of
    a time slot is an array of two elements [start, end] representing an
    inclusive time range from start to end. It is guaranteed that no two
    availability slots of the same person intersect with each other. That is,
    for any two time slots [start1, end1] and [start2, end2] of the same person,
    either start1 > end2 or start2 > end1.

    Example 1:
    Input: slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8
    Output: [60,68]

    Example 2:
    Input: slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 12
    Output: []

    Constraints:
    * 1 <= slots1.length, slots2.length <= 10^4
    * slots1[i].length, slots2[i].length == 2
    * slots1[i][0] < slots1[i][1]
    * slots2[i][0] < slots2[i][1]
    * 0 <= slots1[i][j], slots2[i][j] <= 10^9
    * 1 <= duration <= 10^6*/

    vector<int> minAvailableDuration(vector<vector<int>>& slots1, vector<vector<int>>& slots2, int duration) {
        sort(slots1.begin(), slots1.end());
        sort(slots2.begin(), slots2.end());
        int i = 0, j = 0;
        for (int i = 0, j = 0; i < slots1.size() && j < slots2.size(); ) {
            int start = max(slots1[i][0], slots2[j][0]), end = min(slots1[i][1], slots2[j][1]);
            if (start + duration <= end) return {start, start + duration};
            if (slots1[i][1] <= slots2[j][1]) ++i;
            else ++j;
        }
        return {};
    }


    /*1230. Toss Strange Coins (Medium)
    You have some coins. The i-th coin has a probability prob[i] of facing
    heads when tossed. Return the probability that the number of coins facing
    heads equals target if you toss every coin exactly once.

    Example 1:
    Input: prob = [0.4], target = 1
    Output: 0.40000

    Example 2:
    Input: prob = [0.5,0.5,0.5,0.5,0.5], target = 0
    Output: 0.03125

    Constraints:
    * 1 <= prob.length <= 1000
    * 0 <= prob[i] <= 1
    * 0 <= target <= prob.length
    * Answers will be accepted as correct if they are within 10^-5 of the
      correct answer.*/

    double probabilityOfHeads(vector<double>& prob, int target) {
        int n = prob.size();
        vector<vector<double>> dp(1+n, vector<double>(1+target));
        dp[n][0] = 1;
        for (int i = n-1; i >= 0; --i)
            for (int j = 0; j <= target; ++j) {
                if (j) dp[i][j] = prob[i]*dp[i+1][j-1];
                dp[i][j] += (1-prob[i])*dp[i+1][j];
            }
        return dp[0][target];
    }


    /*1231. Divide Chocolate (Hard)
    You have one chocolate bar that consists of some chunks. Each chunk has its
    own sweetness given by the array sweetness. You want to share the chocolate
    with your k friends so you start cutting the chocolate bar into k + 1
    pieces using k cuts, each piece consists of some consecutive chunks. Being
    generous, you will eat the piece with the minimum total sweetness and give
    the other pieces to your friends. Find the maximum total sweetness of the
    piece you can get by cutting the chocolate bar optimally.

    Example 1:
    Input: sweetness = [1,2,3,4,5,6,7,8,9], k = 5
    Output: 6
    Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]

    Example 2:
    Input: sweetness = [5,6,7,8,9,1,2,3,4], k = 8
    Output: 1
    Explanation: There is only one way to cut the bar into 9 pieces.

    Example 3:
    Input: sweetness = [1,2,2,1,2,2,1,2,2], k = 2
    Output: 5
    Explanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]

    Constraints:
    * 0 <= k < sweetness.length <= 10^4
    * 1 <= sweetness[i] <= 10^5*/

    int maximizeSweetness(vector<int>& sweetness, int k) {
        int lo = 0, hi = 1'000'000'000;
        while (lo < hi) {
            int mid = lo + (hi-lo+1)/2, cnt = 0, prefix = 0;
            for (auto& x : sweetness) {
                prefix += x;
                if (prefix >= mid) {
                    ++cnt;
                    prefix = 0;
                }
            }
            if (cnt < k+1) hi = mid-1;
            else lo = mid;
        }
        return lo;
    }


    /*1236. Web Crawler (Medium)
    Given a url startUrl and an interface HtmlParser, implement a web crawler
    to crawl all links that are under the same hostname as startUrl. Return all
    urls obtained by your web crawler in any order. Your crawler should:
    * Start from the page: startUrl
    * Call HtmlParser.getUrls(url) to get all urls from a webpage of given url.
    * Do not crawl the same link twice.
    * Explore only the links that are under the same hostname as startUrl.

    As shown in the example url above, the hostname is example.org. For
    simplicity sake, you may assume all urls use http protocol without any port
    specified. For example, the urls http://leetcode.com/problems and
    http://leetcode.com/contest are under the same hostname, while urls
    http://example.org/test and http://example.com/abc are not under the same
    hostname.

    The HtmlParser interface is defined as such:
    interface HtmlParser {
      // Return a list of all urls from a webpage of given url.
      public List<String> getUrls(String url);
    }
    Below are two examples explaining the functionality of the problem, for
    custom testing purposes you'll have three variables urls, edges and
    startUrl. Notice that you will only have access to startUrl in your code,
    while urls and edges are not directly accessible to you in code.

    Example 1:
    Input:
    urls = [
      "http://news.yahoo.com",
      "http://news.yahoo.com/news",
      "http://news.yahoo.com/news/topics/",
      "http://news.google.com",
      "http://news.yahoo.com/us"
    ]
    edges = [[2,0],[2,1],[3,2],[3,1],[0,4]]
    startUrl = "http://news.yahoo.com/news/topics/"
    Output: [
      "http://news.yahoo.com",
      "http://news.yahoo.com/news",
      "http://news.yahoo.com/news/topics/",
      "http://news.yahoo.com/us"
    ]

    Example 2:
    Input:
    urls = [
      "http://news.yahoo.com",
      "http://news.yahoo.com/news",
      "http://news.yahoo.com/news/topics/",
      "http://news.google.com"
    ]
    edges = [[0,2],[2,1],[3,2],[3,1],[3,0]]
    startUrl = "http://news.google.com"
    Output: ["http://news.google.com"]
    Explanation: The startUrl links to all other pages that do not share the
                 same hostname.

    Constraints:
    * 1 <= urls.length <= 1000
    * 1 <= urls[i].length <= 300
    * startUrl is one of the urls.
    * Hostname label must be from 1 to 63 characters long, including the dots,
      may contain only the ASCII letters from 'a' to 'z', digits  from '0' to
      '9' and the hyphen-minus character ('-').
    * The hostname may not start or end with the hyphen-minus character ('-').
    * See: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames
    * You may assume there're no duplicates in url library.*/

    vector<string> crawl(string startUrl, HtmlParser htmlParser) {
        string hostname = startUrl.substr(0, startUrl.find('/', 7));
        vector<string> ans = {startUrl}, stk = {startUrl};
        unordered_set<string> seen = {startUrl};
        while (stk.size()) {
            string url = stk.back(); stk.pop_back();
            for (auto& x : htmlParser.getUrls(url))
                if (!seen.count(x) && x.substr(0, x.find('/', 7)) == hostname) {
                    ans.push_back(x);
                    stk.push_back(x);
                    seen.insert(x);
                }
        }
        return ans;
    }


    /*1239. Maximum Length of a Concatenated String with Unique Characters (Medium)
    Given an array of strings arr. String s is a concatenation of a sub-
    sequence of arr which have unique characters. Return the maximum possible
    length of s.

    Example 1:
    Input: arr = ["un","iq","ue"]
    Output: 4
    Explanation: All possible concatenations are "","un","iq","ue","uniq" and
                 "ique". Maximum length is 4.

    Example 2:
    Input: arr = ["cha","r","act","ers"]
    Output: 6
    Explanation: Possible solutions are "chaers" and "acters".

    Example 3:
    Input: arr = ["abcdefghijklmnopqrstuvwxyz"]
    Output: 26

    Constraints:
    * 1 <= arr.length <= 16
    * 1 <= arr[i].length <= 26
    * arr[i] contains only lower case English letters.*/

    int maxLength(vector<string>& arr) {
        vector<bitset<26>> dp(1);
        for (auto& s : arr) {
            bitset<26> bs;
            for (auto& ch : s) bs.set(ch - 'a');
            if (bs.count() == s.size())
                for (int i = 0, n = dp.size(); i < n; ++i)
                    if ((bs & dp[i]).none()) dp.push_back(bs | dp[i]);
        }
        return max_element(dp.begin(), dp.end(), [](auto& lhs, auto& rhs) {return lhs.count() < rhs.count();})->count();
    }


    /*1246. Palindrome Removal (Hard)
    You are given an integer array arr. In one move, you can select a
    palindromic subarray arr[i], arr[i + 1], ..., arr[j] where i <= j, and
    remove that subarray from the given array. Note that after removing a
    subarray, the elements on the left and on the right of that subarray move
    to fill the gap left by the removal. Return the minimum number of moves
    needed to remove all numbers from the array.

    Example 1:
    Input: arr = [1,2]
    Output: 2

    Example 2:
    Input: arr = [1,3,4,1,5]
    Output: 3
    Explanation: Remove [4] then remove [1,3,1] then remove [5].

    Constraints:
    * 1 <= arr.length <= 100
    * 1 <= arr[i] <= 20*/

    int minimumMoves(vector<int>& arr) {
        int n = arr.size();
        vector<vector<int>> dp(n, vector<int>(n+1, INT_MAX));
        for (int i = n-1; i >= 0; --i)
            for (int j = 0; j <= n; ++j)
                if (i+1 >= j) dp[i][j] = 1;
                else {
                    dp[i][j] = j-i;
                    if (arr[i] == arr[j-1]) dp[i][j] = min(dp[i][j], dp[i+1][j-1]);
                    for (int k = i+1; k < j; ++k)
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
                }
        return dp[0][n];
    }


    /*1249. Minimum Remove to Make Valid Parentheses (Medium)
    Given a string s of '(' , ')' and lowercase English characters. Your task
    is to remove the minimum number of parentheses ( '(' or ')', in any
    positions ) so that the resulting parentheses string is valid and return
    any valid string. Formally, a parentheses string is valid if and only if:
    * It is the empty string, contains only lowercase characters, or
    * It can be written as AB (A concatenated with B), where A and B are valid
      strings, or
    * It can be written as (A), where A is a valid string.

    Example 1:
    Input: s = "lee(t(c)o)de)"
    Output: "lee(t(c)o)de"
    Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.

    Example 2:
    Input: s = "a)b(c)d"
    Output: "ab(c)d"

    Example 3:
    Input: s = "))(("
    Output: ""
    Explanation: An empty string is also valid.

    Example 4:
    Input: s = "(a(b(c)d)"
    Output: "a(b(c)d)"

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either'(' , ')', or lowercase English letter.*/

    string minRemoveToMakeValid(string s) {
        stack<int> stk;
        for (int i = 0; i < s.size(); ++i)
            if (s[i] == '(') stk.push(i);
            else if (s[i] == ')') {
                if (stk.size()) stk.pop();
                else s[i] = '\0';
            }
        while (stk.size()) {
            s[stk.top()] = '\0';
            stk.pop();
        }
        s.erase(remove(s.begin(), s.end(), '\0'), s.end());
        return s;
    }


    /*1255. Maximum Score Words Formed by Letters (Hard)
    Given a list of words, list of  single letters (might be repeating) and
    score of every character. Return the maximum score of any valid set of words
    formed by using the given letters (words[i] cannot be used two or more
    times). It is not necessary to use all characters in letters and each letter
    can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by
    score[0], score[1], ... , score[25] respectively.

    Example 1:
    Input: words = ["dog","cat","dad","good"],
           letters = ["a","a","c","d","d","d","g","o","o"],
           score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
    Output: 23
    Explanation: Score  a=1, c=9, d=5, g=3, o=2
                 Given letters, we can form the words "dad" (5+1+5) and "good"
                 (3+2+2+5) with a score of 23. Words "dad" and "dog" only get a
                 score of 21.

    Example 2:
    Input: words = ["xxxz","ax","bx","cx"],
           letters = ["z","a","b","c","x","x","x"],
           score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
    Output: 27
    Explanation: Score  a=4, b=4, c=4, x=5, z=10
                 Given letters, we can form the words "ax" (4+5), "bx" (4+5) and
                 "cx" (4+5) with a score of 27. Word "xxxz" only get a score of
                 25.

    Example 3:
    Input: words = ["leetcode"],
           letters = ["l","e","t","c","o","d"],
           score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
    Output: 0
    Explanation: Letter "e" can only be used once.

    Constraints:
    * 1 <= words.length <= 14
    * 1 <= words[i].length <= 15
    * 1 <= letters.length <= 100
    * letters[i].length == 1
    * score.length == 26
    * 0 <= score[i] <= 10
    * words[i], letters[i] contains only lower case English letters.*/

    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {
        int n = words.size();
        unordered_map<char, int> freq;
        for (auto& ch : letters) ++freq[ch];

        function<int(int, int)> fn = [&](int i, int v) {
            if (i == n) return v;
            int ans = fn(i+1, v);
            bool valid = true;
            int val = 0;
            for (auto& ch : words[i]) {
                if (--freq[ch] < 0) valid = false;
                val += score[ch-'a'];
            }
            if (valid)
                ans = max(ans, fn(i+1, v+val));
            for (auto& ch : words[i])
                ++freq[ch];
            return ans;
        };

        return fn(0, 0);
    }


    /*1259. Handshakes That Don't Cross (Hard)
    You are given an even number of people numPeople that stand around a circle
    and each person shakes hands with someone else so that there are
    numPeople / 2 handshakes total. Return the number of ways these handshakes
    could occur such that none of the handshakes cross. Since the answer could
    be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: numPeople = 4
    Output: 2
    Explanation: There are two ways to do it, the first way is [(1,2),(3,4)]
                 and the second one is [(2,3),(4,1)].

    Example 2:
    Input: numPeople = 6
    Output: 5

    Constraints:
    * 2 <= numPeople <= 1000
    * numPeople is even.*/

    int numberOfWays(int numPeople) {
        int mod = 1'000'000'007, n = numPeople/2;
        vector<long> fact(2*n+1), ifact(n+2), inv(n+2);
        fact[0] = ifact[0] = inv[0] = inv[1] = 1;
        for (int x = 1; x <= 2*n; ++x) {
            if (2 <= x && x <= n+1) inv[x] = mod - mod/x * inv[mod % x] % mod;
            fact[x] = fact[x-1] * x % mod;
            if (x <= n+1) ifact[x] = ifact[x-1] * inv[x] % mod;
        }
        return (fact[2*n] * ifact[n]) % mod * ifact[n+1] % mod;
    }


    /*1274. Number of Ships in a Rectangle (Hard)
    (This problem is an interactive problem.) Each ship is located at an
    integer point on the sea represented by a cartesian plane, and each integer
    point may contain at most 1 ship. You have a function
    Sea.hasShips(topRight, bottomLeft) which takes two points as arguments and
    returns true If there is at least one ship in the rectangle represented by
    the two points, including on the boundary. Given two points: the top right
    and bottom left corners of a rectangle, return the number of ships present
    in that rectangle. It is guaranteed that there are at most 10 ships in that
    rectangle. Submissions making more than 400 calls to hasShips will be
    judged Wrong Answer. Also, any solutions that attempt to circumvent the
    judge will result in disqualification.

    Example :
    Input: ships = [[1,1],[2,2],[3,3],[5,5]], topRight = [4,4], bottomLeft = [0,0]
    Output: 3
    Explanation: From [0,0] to [4,4] we can count 3 ships within the range.

    Example 2:
    Input: ans = [[1,1],[2,2],[3,3]], topRight = [1000,1000], bottomLeft = [0,0]
    Output: 3

    Constraints:
    * On the input ships is only given to initialize the map internally. You
      must solve this problem "blindfolded". In other words, you must find the
      answer using the given hasShips API, without knowing the ships position.
    * 0 <= bottomLeft[0] <= topRight[0] <= 1000
    * 0 <= bottomLeft[1] <= topRight[1] <= 1000
    * topRight != bottomLeft*/

    int countShips(Sea sea, vector<int> topRight, vector<int> bottomLeft) {
        if (!sea.hasShips(topRight, bottomLeft)) return 0;
        int x0 = bottomLeft[0], y0 = bottomLeft[1], x1 = topRight[0], y1 = topRight[1];
        if (x0 == x1 && y0 == y1) return 1;
        if (x0 < x1) {
            int mid = (x0 + x1)/2;
            return countShips(sea, topRight, {mid+1, y0}) + countShips(sea, {mid, y1}, bottomLeft);
        }
        int mid = (y0 + y1)/2;
        return countShips(sea, topRight, {x0, mid+1}) + countShips(sea, {x1, mid}, bottomLeft);
    }


    /*1275. Find Winner on a Tic Tac Toe Game (Easy)
    Tic-tac-toe is played by two players A and B on a 3 x 3 grid. Here are the
    rules of Tic-Tac-Toe:
    * Players take turns placing characters into empty squares (" ").
    * The first player A always places "X" characters, while the second player
      B always places "O" characters.
    * "X" and "O" characters are always placed into empty squares, never on
      filled ones.
    * The game ends when there are 3 of the same (non-empty) character filling
      any row, column, or diagonal.
    * The game also ends if all squares are non-empty.
    * No more moves can be played if the game is over.
    Given an array moves where each element is another array of size 2
    corresponding to the row and column of the grid where they mark their
    respective character in the order in which A and B play. Return the winner
    of the game if it exists (A or B), in case the game ends in a draw return
    "Draw", if there are still movements to play return "Pending". You can
    assume that moves is valid (It follows the rules of Tic-Tac-Toe), the grid
    is initially empty and A will play first.

    Example 1:
    Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
    Output: "A"
    Explanation: "A" wins, he always plays first.
                 "X  "    "X  "    "X  "    "X  "    "X  "
                 "   " -> "   " -> " X " -> " X " -> " X "
                 "   "    "O  "    "O  "    "OO "    "OOX"

    Example 2:
    Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
    Output: "B"
    Explanation: "B" wins.
                 "X  "    "X  "    "XX "    "XXO"    "XXO"    "XXO"
                 "   " -> " O " -> " O " -> " O " -> "XO " -> "XO "
                 "   "    "   "    "   "    "   "    "   "    "O  "

    Example 3:
    Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
    Output: "Draw"
    Explanation: The game ends in a draw since there are no moves to make.
                 "XXO"
                 "OOX"
                 "XOX"

    Example 4:
    Input: moves = [[0,0],[1,1]]
    Output: "Pending"
    Explanation: The game has not finished yet.
                 "X  "
                 " O "
                 "   "

    Constraints:
    * 1 <= moves.length <= 9
    * moves[i].length == 2
    * 0 <= moves[i][j] <= 2
    * There are no repeated elements on moves.
    * moves follow the rules of tic tac toe.*/

    string tictactoe(vector<vector<int>>& moves) {
        vector<vector<int>> score(2, vector<int>(8));
        for (int i = 0, k = 0; i < moves.size(); ++i, k ^= 1) {
            int x = moves[i][0], y = moves[i][1];
            score[k][x]++;
            score[k][3+y]++;
            if (x == y) score[k][6]++;
            if (x+y == 2) score[k][7]++;
            if (score[k][x] == 3 || score[k][3+y] == 3 || score[k][6] == 3 || score[k][7] == 3) return k == 0 ? "A" : "B";
        }
        return moves.size() == 9 ? "Draw" : "Pending";
    }


    /*1268. Search Suggestions System (Medium)
    Given an array of strings products and a string searchWord. We want to
    design a system that suggests at most three product names from products
    after each character of searchWord is typed. Suggested products should have
    common prefix with the searchWord. If there are more than three products
    with a common prefix return the three lexicographically minimums products.
    Return list of lists of the suggested products after each character of
    searchWord is typed.

    Example 1:
    Input: products = ["mobile","mouse","moneypot","monitor","mousepad"],
           searchWord = "mouse"
    Output: [["mobile","moneypot","monitor"],
             ["mobile","moneypot","monitor"],
             ["mouse","mousepad"],
             ["mouse","mousepad"],
             ["mouse","mousepad"]]
    Explanation: products sorted lexicographically = ["mobile","moneypot","monitor","mouse","mousepad"]
                 After typing m and mo all products match and we show user ["mobile","moneypot","monitor"]
                 After typing mou, mous and mouse the system suggests ["mouse","mousepad"]

    Example 2:
    Input: products = ["havana"],
           searchWord = "havana"
    Output: [["havana"],["havana"],["havana"],["havana"],["havana"],["havana"]]

    Example 3:
    Input: products = ["bags","baggage","banner","box","cloths"],
           searchWord = "bags"
    Output: [["baggage","bags","banner"],
             ["baggage","bags","banner"],
             ["baggage","bags"],
             ["bags"]]

    Example 4:
    Input: products = ["havana"],
           searchWord = "tatiana"
    Output: [[],[],[],[],[],[],[]]

    Constraints:
    * 1 <= products.length <= 1000
    * There are no repeated elements in products.
    * 1 <= Σ products[i].length <= 2 * 10^4
    * All characters of products[i] are lower-case English letters.
    * 1 <= searchWord.length <= 1000
    * All characters of searchWord are lower-case English letters.*/

    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {
        sort(begin(products), end(products));
        vector<vector<string>> ans;
        int lo = 0, hi = size(products)-1;
        for (int i = 0 ; i < size(searchWord); ++i) {
            for (; lo < size(products) && (size(products[lo]) <= i || products[lo][i] < searchWord[i]); ++lo);
            for (; 0 <= hi && (size(products[hi]) <= i || products[hi][i] > searchWord[i]); --hi);
            if (lo <= hi) {
                vector<string> elem;
                for (auto i = lo; i < min(lo+3, hi+1); ++i) elem.push_back(products[i]);
                ans.push_back(elem);
            }
            else ans.push_back({});
        }
        return ans;
    }


    /*1288. Remove Covered Intervals (Medium)
    Given an array intervals where intervals[i] = [li, ri] represent the
    interval [li, ri), remove all intervals that are covered by another
    interval in the list. The interval [a, b) is covered by the interval
    [c, d) if and only if c <= a and b <= d. Return the number of remaining
    intervals.

    Example 1:
    Input: intervals = [[1,4],[3,6],[2,8]]
    Output: 2
    Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.

    Example 2:
    Input: intervals = [[1,4],[2,3]]
    Output: 1

    Constraints:
    * 1 <= intervals.length <= 1000
    * intervals[i].length == 2
    * 0 <= li <= ri <= 10^5
    * All the given intervals are unique.*/

    int removeCoveredIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [&](auto& lhs, auto& rhs) {
            return lhs[0] < rhs[0] || (lhs[0] == rhs[0] && lhs[1] > rhs[1]);
        });
        int ans = 0, prev = INT_MIN;
        for (auto& interval : intervals)
            if (interval[1] > prev) {
                ++ans;
                prev = interval[1];
            }
        return ans;
    }


    /*1289. Minimum Falling Path Sum II (Hard)
    Given an n x n integer matrix grid, return the minimum sum of a falling path
    with non-zero shifts. A falling path with non-zero shifts is a choice of
    exactly one element from each row of grid such that no two elements chosen
    in adjacent rows are in the same column.

    Example 1:
    Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 13
    Explanation: The possible falling paths are:
                 [1,5,9], [1,5,7], [1,6,7], [1,6,8],
                 [2,4,8], [2,4,9], [2,6,7], [2,6,8],
                 [3,4,8], [3,4,9], [3,5,7], [3,5,9]
                 The falling path with the smallest sum is [1,5,7], so the
                 answer is 13.

    Example 2:
    Input: grid = [[7]]
    Output: 7

    Constraints:
    * n == grid.length == grid[i].length
    * 1 <= n <= 200
    * -99 <= grid[i][j] <= 99*/

    int minFallingPathSum(vector<vector<int>>& grid) {
        int n = grid.size(), p0 = 0, p1 = 0;
        for (int i = 0; i < n; ++i) {
            int m0 = 1e7, m1 = 1e7;
            for (int j = 0; j < n; ++j) {
                if (i && grid[i-1][j] != p0) grid[i][j] += p0;
                else grid[i][j] += p1;
                if (grid[i][j] < m0) tie(m0, m1) = make_tuple(grid[i][j], m0);
                else if (grid[i][j] < m1) m1 = grid[i][j];
            }
            p0 = m0, p1 = m1;
        }
        return p0;
    }


    /*1290. Convert Binary Number in a Linked List to Integer (Easy)
    Given head which is a reference node to a singly-linked list. The value of
    each node in the linked list is either 0 or 1. The linked list holds the
    binary representation of a number. Return the decimal value of the number
    in the linked list.

    Example 1:
    Input: head = [1,0,1]
    Output: 5
    Explanation: (101) in base 2 = (5) in base 10

    Example 2:
    Input: head = [0]
    Output: 0

    Example 3:
    Input: head = [1]
    Output: 1

    Example 4:
    Input: head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]
    Output: 18880

    Example 5:
    Input: head = [0,0]
    Output: 0

    Constraints:
    * The Linked List is not empty.
    * Number of nodes will not exceed 30.
    * Each node's value is either 0 or 1.*/

    int getDecimalValue(ListNode* head) {
        int ans = 0;
        for (ListNode *node = head; node; node = node->next)
            ans = 2*ans + node->val;
        return ans;
    }


    /*1291. Sequential Digits (Medium)
    An integer has sequential digits if and only if each digit in the number is
    one more than the previous digit. Return a sorted list of all the integers
    in the range [low, high] inclusive that have sequential digits.

    Example 1:
    Input: low = 100, high = 300
    Output: [123,234]

    Example 2:
    Input: low = 1000, high = 13000
    Output: [1234,2345,3456,4567,5678,6789,12345]

    Constraints: 10 <= low <= high <= 10^9*/

    vector<int> sequentialDigits(int low, int high) {
        vector<int> ans;
        for (int x = 1; x <= 9; ++x) {
            int val = 0;
            for (int d = x; d <= 9; ++d) {
                val = 10*val + d;
                if (low <= val && val <= high) ans.push_back(val);
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }


    /*1305. All Elements in Two Binary Search Trees (Medium)
    Given two binary search trees root1 and root2, return a list containing all
    the integers from both trees sorted in ascending order.

    Example 1:
    Input: root1 = [2,1,4], root2 = [1,0,3]
    Output: [0,1,1,2,3,4]

    Example 2:
    Input: root1 = [1,null,8], root2 = [8,1]
    Output: [1,1,8,8]

    Constraints:
    * The number of nodes in each tree is in the range [0, 5000].
    * -10^5 <= Node.val <= 10^5*/

    vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {

        auto fn = [&](TreeNode* node) {
            vector<int> ans;
            stack<TreeNode*> stk;
            while (node || stk.size())
                if (node) {
                    stk.push(node);
                    node = node->left;
                } else {
                    node = stk.top(); stk.pop();
                    ans.push_back(node->val);
                    node = node->right;
                }
            return ans;
        };

        vector<int> ans, vals1 = fn(root1), vals2 = fn(root2);
        for (int i = 0, j = 0; i < vals1.size() || j < vals2.size(); )
            if (j == vals2.size() || (i < vals1.size() && vals1[i] < vals2[j])) ans.push_back(vals1[i++]);
            else ans.push_back(vals2[j++]);
        return ans;
    }


    /*1306. Jump Game III (Medium)
    Given an array of non-negative integers arr, you are initially positioned
    at start index of the array. When you are at index i, you can jump to
    i + arr[i] or i - arr[i], check if you can reach to any index with value 0.
    Notice that you can not jump outside of the array at any time.

    Example 1:
    Input: arr = [4,2,3,0,3,1,2], start = 5
    Output: true
    Explanation: All possible ways to reach at index 3 with value 0 are:
                 index 5 -> index 4 -> index 1 -> index 3
                 index 5 -> index 6 -> index 4 -> index 1 -> index 3

    Example 2:
    Input: arr = [4,2,3,0,3,1,2], start = 0
    Output: true
    Explanation: One possible way to reach at index 3 with value 0 is:
                 index 0 -> index 4 -> index 1 -> index 3

    Example 3:
    Input: arr = [3,0,2,1,2], start = 2
    Output: false
    Explanation: There is no way to reach at index 1 with value 0.

    Constraints:
    * 1 <= arr.length <= 5 * 10^4
    * 0 <= arr[i] < arr.length
    * 0 <= start < arr.length*/

    bool canReach(vector<int>& arr, int start) {
        stack<int> stk; stk.push(start);
        arr[start] *= -1;
        while (stk.size()) {
            int i = stk.top(); stk.pop();
            if (arr[i] == 0) return true;
            for (auto& ii : {i - arr[i], i + arr[i]})
                if (0 <= ii && ii < arr.size() && arr[ii] >= 0) {
                    stk.push(ii);
                    arr[ii] *= -1;
                }
        }
        return false;
    }


    /*1310. XOR Queries of a Subarray (Medium)
    You are given an array arr of positive integers. You are also given the
    array queries where queries[i] = [lefti, righti]. For each query i compute
    the XOR of elements from lefti to righti (that is, arr[lefti] XOR
    arr[lefti + 1] XOR ... XOR arr[righti] ). Return an array answer where
    answer[i] is the answer to the ith query.

    Example 1:
    Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
    Output: [2,7,14,8]
    Explanation: The binary representation of the elements in the array are:
                 1 = 0001
                 3 = 0011
                 4 = 0100
                 8 = 1000
                 The XOR values for queries are:
                 [0,1] = 1 xor 3 = 2
                 [1,2] = 3 xor 4 = 7
                 [0,3] = 1 xor 3 xor 4 xor 8 = 14
                 [3,3] = 8

    Example 2:
    Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
    Output: [8,0,4,4]

    Constraints:
    * 1 <= arr.length, queries.length <= 3 * 10^4
    * 1 <= arr[i] <= 10^9
    * queries[i].length == 2
    * 0 <= lefti <= righti < arr.length*/

    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        vector<int> prefix(1);
        for (auto& x : arr)
            prefix.push_back(prefix.back() ^ x);
        vector<int> ans;
        for (auto& q : queries) {
            int lo = q[0], hi = q[1];
            ans.push_back(prefix[lo] ^ prefix[hi+1]);
        }
        return ans;
    }


    /*1314. Matrix Block Sum (Medium)
    Given a m x n matrix mat and an integer k, return a matrix answer where
    each answer[i][j] is the sum of all elements mat[r][c] for:
    * i - k <= r <= i + k,
    * j - k <= c <= j + k, and
    * (r, c) is a valid position in the matrix.

    Example 1:
    Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
    Output: [[12,21,16],[27,45,33],[24,39,28]]

    Example 2:
    Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
    Output: [[45,45,45],[45,45,45],[45,45,45]]

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n, k <= 100
    * 1 <= mat[i][j] <= 100*/

    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
        int m= mat.size(), n = mat[0].size();
        vector<vector<int>> prefix(m+1, vector<int>(n+1));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                prefix[i+1][j+1] = mat[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j];

        vector<vector<int>> ans(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                int r0 = max(0, i-k), c0 = max(0, j-k), r1 = min(m-1, i+k), c1 = min(n-1, j+k);
                ans[i][j] = prefix[r1+1][c1+1] - prefix[r0][c1+1] - prefix[r1+1][c0] + prefix[r0][c0];
            }
        return ans;
    }


    /*1325. Delete Leaves With a Given Value (Medium)
    Given a binary tree root and an integer target, delete all the leaf nodes
    with value target. Note that once you delete a leaf node with value target,
    if its parent node becomes a leaf node and has the value target, it should
    also be deleted (you need to continue doing that until you cannot).

    Example 1:
    Input: root = [1,2,3,2,null,2,4], target = 2
    Output: [1,null,3,null,4]
    Explanation: Leaf nodes in green with value (target = 2) are removed
                 (Picture in left). After removing, new nodes become leaf nodes
                 with value (target = 2) (Picture in center).

    Example 2:
    Input: root = [1,3,3,3,2], target = 3
    Output: [1,3,null,null,2]

    Example 3:
    Input: root = [1,2,null,2,null,2], target = 2
    Output: [1]
    Explanation: Leaf nodes in green with value (target = 2) are removed at each
                 step.

    Constraints:
    * The number of nodes in the tree is in the range [1, 3000].
    * 1 <= Node.val, target <= 1000*/

    TreeNode* removeLeafNodes(TreeNode* root, int target) {
        if (root) {
            root->left = removeLeafNodes(root->left, target);
            root->right = removeLeafNodes(root->right, target);
            if (root->left || root->right || root->val != target) return root;
        }
        return nullptr;
    }


    /*1328. Break a Palindrome (Medium)
    Given a palindromic string of lowercase English letters palindrome, replace
    exactly one character with any lowercase English letter so that the
    resulting string is not a palindrome and that it is the lexicographically
    smallest one possible. Return the resulting string. If there is no way to
    replace a character to make it not a palindrome, return an empty string. A
    string a is lexicographically smaller than a string b (of the same length)
    if in the first position where a and b differ, a has a character strictly
    smaller than the corresponding character in b. For example, "abcc" is
    lexicographically smaller than "abcd" because the first position they
    differ is at the fourth character, and 'c' is smaller than 'd'.

    Example 1:
    Input: palindrome = "abccba"
    Output: "aaccba"
    Explanation: There are many ways to make "abccba" not a palindrome, such as
                 "zbccba", "aaccba", and "abacba". Of all the ways, "aaccba" is
                 the lexicographically smallest.

    Example 2:
    Input: palindrome = "a"
    Output: ""
    Explanation: There is no way to replace a single character to make "a" not
                 a palindrome, so return an empty string.

    Example 3:
    Input: palindrome = "aa"
    Output: "ab"

    Example 4:
    Input: palindrome = "aba"
    Output: "abb"

    Constraints:
    * 1 <= palindrome.length <= 1000
    * palindrome consists of only lowercase English letters.*/

    string breakPalindrome(string palindrome) {
        if (palindrome.size() == 1) return "";
        for (int i = 0; i < palindrome.size()/2; ++i)
            if (palindrome[i] != 'a') {
                palindrome[i] = 'a';
                return palindrome;
            }
        palindrome.back() = 'b';
        return palindrome;
    }


    /*1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (Medium)
    There are n cities numbered from 0 to n-1. Given the array edges where
    edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted
    edge between cities fromi and toi, and given the integer distanceThreshold.
    Return the city with the smallest number of cities that are reachable
    through some path and whose distance is at most distanceThreshold, If there
    are multiple such cities, return the city with the greatest number. Notice
    that the distance of a path connecting cities i and j is equal to the sum of
    the edges' weights along that path.

    Example 1:
    Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
    Output: 3
    Explanation: The figure above describes the graph. The neighboring cities at
                 a distanceThreshold = 4 for each city are:
                 City 0 -> [City 1, City 2]
                 City 1 -> [City 0, City 2, City 3]
                 City 2 -> [City 0, City 1, City 3]
                 City 3 -> [City 1, City 2]
                 Cities 0 and 3 have 2 neighboring cities at a
                 distanceThreshold = 4, but we have to return city 3 since it
                 has the greatest number.

    Example 2:
    Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
    Output: 0
    Explanation: The figure above describes the graph. The neighboring cities at
                 a distanceThreshold = 2 for each city are:
                 City 0 -> [City 1]
                 City 1 -> [City 0, City 4]
                 City 2 -> [City 3, City 4]
                 City 3 -> [City 2, City 4]
                 City 4 -> [City 1, City 2, City 3]
                 The city 0 has 1 neighboring city at a distanceThreshold = 2.

    Constraints:
    * 2 <= n <= 100
    * 1 <= edges.length <= n * (n - 1) / 2
    * edges[i].length == 3
    * 0 <= fromi < toi < n
    * 1 <= weighti, distanceThreshold <= 10^4
    * All pairs (fromi, toi) are distinct.*/

    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        vector<vector<int>> dist(n, vector<int>(n, 1e7));
        for (int i = 0; i < n; ++i) dist[i][i] = 0;
        for (auto& e : edges) {
            int i = e[0], j = e[1], w = e[2];
            dist[i][j] = dist[j][i] = w;
        }
        for (int k = 0; k < n; ++k)
            for (int i = 0; i < n; ++i)
                for (int j = 0; j < n; ++j)
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
        int ans = 0, ref = INT_MAX;
        for (int i = 0; i < n; ++i) {
            cout << i << " ";
            for (int j = 0; j < n; ++j)
                cout << dist[i][j] << " ";
            cout << endl;
            int cnt = accumulate(dist[i].begin(), dist[i].end(), 0, [&](int s, int d) { return s + (d <= distanceThreshold); });
            if (cnt <= ref)
                ans = i, ref = cnt;
        }
        return ans;
    }


    /*1337. The K Weakest Rows in a Matrix (Easy)
    You are given an m x n binary matrix mat of 1's (representing soldiers) and
    0's (representing civilians). The soldiers are positioned in front of the
    civilians. That is, all the 1's will appear to the left of all the 0's in
    each row. A row i is weaker than a row j if one of the following is true:
    * The number of soldiers in row i is less than the number of soldiers in
      row j.
    * Both rows have the same number of soldiers and i < j.
    Return the indices of the k weakest rows in the matrix ordered from weakest
    to strongest.

    Example 1:
    Input: mat = [[1,1,0,0,0],
                  [1,1,1,1,0],
                  [1,0,0,0,0],
                  [1,1,0,0,0],
                  [1,1,1,1,1]],
           k = 3
    Output: [2,0,3]
    Explanation: The number of soldiers in each row is:
                 - Row 0: 2
                 - Row 1: 4
                 - Row 2: 1
                 - Row 3: 2
                 - Row 4: 5
                 The rows ordered from weakest to strongest are [2,0,3,1,4].

    Example 2:
    Input: mat = [[1,0,0,0],
                  [1,1,1,1],
                  [1,0,0,0],
                  [1,0,0,0]],
           k = 2
    Output: [0,2]
    Explanation: The number of soldiers in each row is:
                 - Row 0: 1
                 - Row 1: 4
                 - Row 2: 1
                 - Row 3: 1
                 The rows ordered from weakest to strongest are [0,2,3,1].

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 2 <= n, m <= 100
    * 1 <= k <= m
    * matrix[i][j] is either 0 or 1.*/

    vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
        int m = mat.size(), n = mat[0].size();
        vector<int> vals;
        for (int i = 0; i < m; ++i) {
            int lo = 0, hi = n;
            while (lo < hi) {
                int mid = lo + (hi - lo)/2;
                if (mat[i][mid] == 1) lo = mid + 1;
                else hi = mid;
            }
            vals.push_back(lo);
        }
        vector<int> ans(m);
        iota(ans.begin(), ans.end(), 0);
        stable_sort(ans.begin(), ans.end(), [&](auto& lhs, auto& rhs) { return vals[lhs] < vals[rhs]; });
        ans.resize(k);
        return ans;
    }


    /*1338. Reduce Array Size to The Half (Medium)
    Given an array arr.  You can choose a set of integers and remove all the
    occurrences of these integers in the array. Return the minimum size of the
    set so that at least half of the integers of the array are removed.

    Example 1:
    Input: arr = [3,3,3,3,5,5,5,2,2,7]
    Output: 2
    Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has
                 size 5 (i.e equal to half of the size of the old array).
                 Possible sets of size 2 are {3,5},{3,2},{5,2}. Choosing set
                 {2,7} is not possible as it will make the new array
                 [3,3,3,3,5,5,5] which has size greater than half of the size
                 of the old array.

    Example 2:
    Input: arr = [7,7,7,7,7,7]
    Output: 1
    Explanation: The only possible set you can choose is {7}. This will make
                 the new array empty.

    Example 3:
    Input: arr = [1,9]
    Output: 1

    Example 4:
    Input: arr = [1000,1000,3,7]
    Output: 1

    Example 5:
    Input: arr = [1,2,3,4,5,6,7,8,9,10]
    Output: 5

    Constraints:
    * 1 <= arr.length <= 10^5
    * arr.length is even.
    * 1 <= arr[i] <= 10^5*/

    int minSetSize(vector<int>& arr) {
        unordered_map<int, int> freq;
        for (auto& x : arr) freq[x]++;

        vector<int> vals;
        for (auto& [key, val] : freq) vals.push_back(val);

        sort(vals.begin(), vals.end(), greater<int>());
        for (int i = 0, ans = 0; i < vals.size(); ++i) {
            ans += vals[i];
            if (ans >= arr.size()/2) return i + 1;
        }
        return -1;
    }


    /*1339. Maximum Product of Splitted Binary Tree (Medium)
    Given the root of a binary tree, split the binary tree into two subtrees by
    removing one edge such that the product of the sums of the subtrees is
    maximized. Return the maximum product of the sums of the two subtrees.
    Since the answer may be too large, return it modulo 10^9 + 7. Note that you
    need to maximize the answer before taking the mod and not after taking it.

    Example 1:
    Input: root = [1,2,3,4,5,6]
    Output: 110
    Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10.
                 Their product is 110 (11*10)

    Example 2:
    Input: root = [1,null,2,3,4,null,null,5,6]
    Output: 90
    Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.
                 Their product is 90 (15*6)

    Example 3:
    Input: root = [2,3,9,10,7,8,6,5,4,11,1]
    Output: 1025

    Example 4:
    Input: root = [1,1]
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [2, 5 * 10^4].
    * 1 <= Node.val <= 10^4*/

    int maxProduct(TreeNode* root) {
        vector<long> vals;

        function<long(TreeNode*)> fn = [&](TreeNode* node) {
            if (!node) return 0l;
            long ans = node->val + fn(node->left) + fn(node->right);
            vals.push_back(ans);
            return ans;
        };

        long total = fn(root), ans = 0;
        for (auto& x : vals) ans = max(ans, (total-x)*x);
        return ans % 1'000'000'007;
    }


    /*1345. Jump Game IV (Hard)
    Given an array of integers arr, you are initially positioned at the first
    index of the array. In one step you can jump from index i to index:
    * i + 1 where: i + 1 < arr.length.
    * i - 1 where: i - 1 >= 0.
    * j where: arr[i] == arr[j] and i != j.
    Return the minimum number of steps to reach the last index of the array.
    Notice that you can not jump outside of the array at any time.

    Example 1:
    Input: arr = [100,-23,-23,404,100,23,23,23,3,404]
    Output: 3
    Explanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that
                 index 9 is the last index of the array.

    Example 2:
    Input: arr = [7]
    Output: 0
    Explanation: Start index is the last index. You do not need to jump.

    Example 3:
    Input: arr = [7,6,9,6,9,6,9,7]
    Output: 1
    Explanation: You can jump directly from index 0 to index 7 which is last
                 index of the array.

    Constraints:
    * 1 <= arr.length <= 5 * 10^4
    * -10^8 <= arr[i] <= 10^8*/

    int minJumps(vector<int>& arr) {
        unordered_map<int, vector<int>> loc;
        for (int i = 0; i < arr.size(); ++i) loc[arr[i]].push_back(i);

        int ans = 0, n = arr.size();
        deque<int> q; q.push_back(0);
        vector<bool> seen(n);
        seen[0] = true;

        for (; q.size(); ++ans)
            for (int sz = q.size(); sz; --sz) {
                int i = q.front(); q.pop_front();
                if (i+1 == n) return ans;
                vector<int>& cand = loc[arr[i]];
                cand.push_back(i-1);
                cand.push_back(i+1);
                for (auto& ii : cand)
                    if (0 <= ii && ii < arr.size() && !seen[ii]) {
                        seen[ii] = true;
                        q.push_back(ii);
                    }
                cand.clear();
            }
        return -1;
    }


    /*1354. Construct Target Array With Multiple Sums (Hard)
    Given an array of integers target. From a starting array, A consisting of
    all 1's, you may perform the following procedure :
    * let x be the sum of all elements currently in your array.
    * choose index i, such that 0 <= i < target.size and set the value of A at
      index i to x.
    * You may repeat this procedure as many times as needed.
    Return True if it is possible to construct the target array from A
    otherwise return False.

    Example 1:
    Input: target = [9,3,5]
    Output: true
    Explanation: Start with [1, 1, 1]
    [1, 1, 1], sum = 3 choose index 1
    [1, 3, 1], sum = 5 choose index 2
    [1, 3, 5], sum = 9 choose index 0
    [9, 3, 5] Done

    Example 2:
    Input: target = [1,1,1,2]
    Output: false
    Explanation: Impossible to create target array from [1,1,1,1].

    Example 3:
    Input: target = [8,5]
    Output: true

    Constraints:
    * N == target.length
    * 1 <= target.length <= 5 * 10^4
    * 1 <= target[i] <= 10^9*/

    bool isPossible(vector<int>& target) {
        if (target.size() == 1) return target[0] == 1; // edge case

        long total = 0;
        priority_queue<int> pq;
        for (auto x : target) {
            total += x;
            pq.push(x);
        }

        while (pq.top() > 1) {
            int x = pq.top();
            pq.pop();
            total -= x;
            if (x <= total) return false;
            x = (x-1) % total + 1;
            total += x;
            pq.push(x);
        }
        return true;
    }


    /*1359. Count All Valid Pickup and Delivery Options (Hard)
    Given n orders, each order consist in pickup and delivery services. Count
    all valid pickup/delivery possible sequences such that delivery(i) is
    always after of pickup(i). Since the answer may be too large, return it
    modulo 10^9 + 7.

    Example 1:
    Input: n = 1
    Output: 1
    Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.

    Example 2:
    Input: n = 2
    Output: 6
    Explanation: All possible orders: (P1,P2,D1,D2), (P1,P2,D2,D1),
                 (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).
                 This is an invalid order (P1,D2,P2,D1) because Pickup 2 is
                 after of Delivery 2.

    Example 3:
    Input: n = 3
    Output: 90

    Constraints: 1 <= n <= 500*/

    int countOrders(int n) {
        int ans = 1;
        for (int x = 2; x <= n; ++x)
            ans = (long) ans * x * (2*x-1) % 1'000'000'007;
        return ans;
    }


    /*1367. Linked List in Binary Tree (Medium)
    Given a binary tree root and a linked list with head as the first node.
    Return True if all the elements in the linked list starting from the head
    correspond to some downward path connected in the binary tree otherwise
    return False. In this context downward path means a path that starts at some
    node and goes downwards.

    Example 1:
    Input: head = [4,2,8],
           root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    Output: true
    Explanation: Nodes in blue form a subpath in the binary Tree.

    Example 2:
    Input: head = [1,4,2,6],
           root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    Output: true

    Example 3:
    Input: head = [1,4,2,6,8],
           root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    Output: false
    Explanation: There is no path in the binary tree that contains all the
                 elements of the linked list from head.

    Constraints:
    * The number of nodes in the tree will be in the range [1, 2500].
    * The number of nodes in the list will be in the range [1, 100].
    * 1 <= Node.val <= 100 for each node in the linked list and binary tree.*/

    bool isSubPath(ListNode* head, TreeNode* root) {
        vector<int> pattern;
        for (ListNode *node = head; node; node = node->next)
            pattern.push_back(node->val);
        vector<int> lps(1);
        for (int i = 1, k = 0; i < pattern.size(); ++i) {
            while (k && pattern[k] != pattern[i]) k = lps[k-1];
            if (pattern[k] == pattern[i]) ++k;
            lps.push_back(k);
        }

        function<bool(TreeNode*, int)> dfs = [&](TreeNode *node, int k) {
            if (k == pattern.size()) return true;
            if (!node) return false;
            while (k && pattern[k] != node->val) k = lps[k-1];
            if (pattern[k] == node->val) ++k;
            return dfs(node->left, k) || dfs(node->right, k);
        };

        return dfs(root, 0);
    }


    /*1372. Longest ZigZag Path in a Binary Tree (Medium)
    You are given the root of a binary tree. A ZigZag path for a binary tree is
    defined as follow:
    * Choose any node in the binary tree and a direction (right or left).
    * If the current direction is right, move to the right child of the current
      node; otherwise, move to the left child.
    * Change the direction from right to left or from left to right.
    * Repeat the second and third steps until you can't move in the tree.
    Zigzag length is defined as the number of nodes visited - 1. (A single node
    has a length of 0). Return the longest ZigZag path contained in that tree.

    Example 1:
    Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
    Output: 3
    Explanation: Longest ZigZag path in blue nodes (right -> left -> right).

    Example 2:
    Input: root = [1,1,1,null,1,null,null,1,1,null,1]
    Output: 4
    Explanation: Longest ZigZag path in blue nodes (left -> right -> left ->
                 right).

    Example 3:
    Input: root = [1]
    Output: 0

    Constraints:
    * The number of nodes in the tree is in the range [1, 5 * 10^4].
    * 1 <= Node.val <= 100*/

    int longestZigZag(TreeNode* root) {
        int ans = 0;
        stack<tuple<TreeNode*, bool, int>> stk;
        stk.emplace(root, true, 0);
        stk.emplace(root, false, 0);
        while (stk.size()) {
            auto [node, left, val] = stk.top(); stk.pop();
            ans = max(ans, val);
            if (node->left) stk.emplace(node->left, true, left ? 1 : val+1);
            if (node->right) stk.emplace(node->right, false, left ? val+1 : 1);
        }
        return ans;
    }


    /*1380. Lucky Numbers in a Matrix (Easy)
    Given an m x n matrix of distinct numbers, return all lucky numbers in the
    matrix in any order. A lucky number is an element of the matrix such that
    it is the minimum element in its row and maximum in its column.

    Example 1:
    Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
    Output: [15]
    Explanation: 15 is the only lucky number since it is the minimum in its row
                 and the maximum in its column.

    Example 2:
    Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
    Output: [12]
    Explanation: 12 is the only lucky number since it is the minimum in its row
                 and the maximum in its column.

    Example 3:
    Input: matrix = [[7,8],[1,2]]
    Output: [7]
    Explanation: 7 is the only lucky number since it is the minimum in its row
                 and the maximum in its column.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= n, m <= 50
    * 1 <= matrix[i][j] <= 10^5.
    * All elements in the matrix are distinct.*/

    vector<int> luckyNumbers (vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        unordered_set<int> seen;
        for (int i = 0; i < m; ++i)
            seen.insert(*min_element(matrix[i].begin(), matrix[i].end()));
        vector<int> ans;
        for (int j = 0; j < n; ++j) {
            int cand = 0;
            for (int i = 0; i < m; ++i) cand = max(cand, matrix[i][j]);
            if (seen.count(cand)) ans.push_back(cand);
        }
        return ans;
    }


    /*1395. Count Number of Teams (Medium)
    There are n soldiers standing in a line. Each soldier is assigned a unique
    rating value. You have to form a team of 3 soldiers amongst them under the
    following rules:
    * Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j],
      rating[k]).
    * A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] >
      rating[j] > rating[k]) where (0 <= i < j < k < n).
    Return the number of teams you can form given the conditions. (soldiers can
    be part of multiple teams).

    Example 1:
    Input: rating = [2,5,3,4,1]
    Output: 3
    Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1),
                 (5,3,1).

    Example 2:
    Input: rating = [2,1,3]
    Output: 0
    Explanation: We can't form any team given the conditions.

    Example 3:
    Input: rating = [1,2,3,4]
    Output: 4

    Constraints:
    * n == rating.length
    * 3 <= n <= 1000
    * 1 <= rating[i] <= 10^5
    * All the integers in rating are unique.*/

    int numTeams(vector<int>& rating) {
        int n = rating.size();
        vector<int> copy(rating.begin(), rating.end());
        sort(copy.begin(), copy.end());
        unordered_map<int, int> mp;
        for (int i = 0; i < n; ++i)
            mp[copy[i]] = i;
        vector<int> vals;
        for (auto& x : rating)
            vals.push_back(mp[x]);

        auto fn = [&](vector<int> vals) {
            int ans = 0;
            Fenwick mark(n), pair(n);
            for (auto& x : vals) {
                ans += pair.query(x-1);
                mark.add(x, 1);
                pair.add(x, mark.query(x-1));
            }
            return ans;
        };

        int ans = fn(vals);
        reverse(vals.begin(), vals.end());
        ans += fn(vals);
        return ans;
    }


    /*1404. Number of Steps to Reduce a Number in Binary Representation to One (Medium)
    Given the binary representation of an integer as a string s, return the
    number of steps to reduce it to 1 under the following rules:
    * If the current number is even, you have to divide it by 2.
    * If the current number is odd, you have to add 1 to it.
    It is guaranteed that you can always reach one for all test cases.

    Example 1:
    Input: s = "1101"
    Output: 6
    Explanation: "1101" corressponds to number 13 in their decimal representation.
                 Step 1) 13 is odd, add 1 and obtain 14.
                 Step 2) 14 is even, divide by 2 and obtain 7.
                 Step 3) 7 is odd, add 1 and obtain 8.
                 Step 4) 8 is even, divide by 2 and obtain 4.
                 Step 5) 4 is even, divide by 2 and obtain 2.
                 Step 6) 2 is even, divide by 2 and obtain 1.

    Example 2:
    Input: s = "10"
    Output: 1
    Explanation: "10" corressponds to number 2 in their decimal representation.
                 Step 1) 2 is even, divide by 2 and obtain 1.

    Example 3:
    Input: s = "1"
    Output: 0

    Constraints:
    * 1 <= s.length <= 500
    * s consists of characters '0' or '1'
    * s[0] == '1'*/

    int numSteps(string s) {
        int ans = 0, one = 0;
        for (int i = s.size()-1; i > 0; --i)
            if (s[i] == '1') {
                ans += 2-one;
                one = 1;
            } else ans += 1+one;
        return ans + one;
    }


    /*1405. Longest Happy String (Medium)
    A string s is called happy if it satisfies the following conditions:
    * s only contains the letters 'a', 'b', and 'c'.
    * s does not contain any of "aaa", "bbb", or "ccc" as a substring.
    * s contains at most a occurrences of the letter 'a'.
    * s contains at most b occurrences of the letter 'b'.
    * s contains at most c occurrences of the letter 'c'.
    Given three integers a, b, and c, return the longest possible happy string.
    If there are multiple longest happy strings, return any of them. If there
    is no such string, return the empty string "". A substring is a contiguous
    sequence of characters within a string.

    Example 1:
    Input: a = 1, b = 1, c = 7
    Output: "ccaccbcc"
    Explanation: "ccbccacc" would also be a correct answer.

    Example 2:
    Input: a = 7, b = 1, c = 0
    Output: "aabaa"
    Explanation: It is the only correct answer in this case.

    Constraints:
    * 0 <= a, b, c <= 100
    * a + b + c > 0*/

    string longestDiverseString(int a, int b, int c) {
        priority_queue<pair<int, char>> pq;
        if (a) pq.emplace(a, 'a');
        if (b) pq.emplace(b, 'b');
        if (c) pq.emplace(c, 'c');
        string ans;
        while (pq.size()) {
            auto [x, c] = pq.top(); pq.pop();
            if (ans.size() >= 2 && ans.back() == c && *(ans.rbegin()+1) == c)
                if (pq.size()) {
                    auto [xx, cc] = pq.top(); pq.pop();
                    ans.push_back(cc);
                    if (xx-1) pq.emplace(xx-1, cc);
                    pq.emplace(x, c);
                } else break;
            else {
                ans.push_back(c);
                if (x-1) pq.emplace(x-1, c);
            }
        }
        return ans;
    }


    /*1413. Minimum Value to Get Positive Step by Step Sum (Easy)
    Given an array of integers nums, you start with an initial positive value
    startValue. In each iteration, you calculate the step by step sum of
    startValue plus elements in nums (from left to right). Return the minimum
    positive value of startValue such that the step by step sum is never less
    than 1.

    Example 1:
    Input: nums = [-3,2,-3,4,2]
    Output: 5
    Explanation: If you choose startValue = 4, in the third iteration your step
                 by step sum is less than 1.
                 startValue = 4 | startValue = 5 | nums
                   (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
                   (1 +2 ) = 3  | (2 +2 ) = 4    |   2
                   (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
                   (0 +4 ) = 4  | (1 +4 ) = 5    |   4
                   (4 +2 ) = 6  | (5 +2 ) = 7    |   2

    Example 2:
    Input: nums = [1,2]
    Output: 1
    Explanation: Minimum start value should be positive.

    Example 3:
    Input: nums = [1,-2,-3]
    Output: 5

    Constraints:
    * 1 <= nums.length <= 100
    * -100 <= nums[i] <= 100*/

    int minStartValue(vector<int>& nums) {
        int ans = 0, prefix = 0;
        for (auto& x : nums) {
            prefix += x;
            ans = min(ans, prefix);
        }
        return 1 - ans;
    }


    /*1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (Medium)
    Given an integer k, return the minimum number of Fibonacci numbers whose
    sum is equal to k. The same Fibonacci number can be used multiple times.
    The Fibonacci numbers are defined as:
    * F1 = 1
    * F2 = 1
    * Fn = Fn-1 + Fn-2 for n > 2.
    It is guaranteed that for the given constraints we can always find such
    Fibonacci numbers that sum up to k.

    Example 1:
    Input: k = 7
    Output: 2
    Explanation: The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... For k = 7
                 we can use 2 + 5 = 7.

    Example 2:
    Input: k = 10
    Output: 2
    Explanation: For k = 10 we can use 2 + 8 = 10.

    Example 3:
    Input: k = 19
    Output: 3
    Explanation: For k = 19 we can use 1 + 5 + 13 = 19.

    Constraints: 1 <= k <= 10^9*/

    int findMinFibonacciNumbers(int k) {
        vector<int> vals;
        for (int f0 = 1, f1 = 1; f1 <= k; swap(f0, f1), f1 += f0)
            vals.push_back(f1);
        int ans = 0;
        for (; k; ++ans) {
            auto it = upper_bound(vals.begin(), vals.end(), k);
            k -= *prev(it);
        }
        return ans;
    }


    /*1423. Maximum Points You Can Obtain from Cards (Medium)
    There are several cards arranged in a row, and each card has an associated
    number of points The points are given in the integer array cardPoints. In
    one step, you can take one card from the beginning or from the end of the
    row. You have to take exactly k cards. Your score is the sum of the points
    of the cards you have taken. Given the integer array cardPoints and the
    integer k, return the maximum score you can obtain.

    Example 1:
    Input: cardPoints = [1,2,3,4,5,6,1], k = 3
    Output: 12
    Explanation: After the first step, your score will always be 1. However,
                 choosing the rightmost card first will maximize your total
                 score. The optimal strategy is to take the three cards on the
                 right, giving a final score of 1 + 6 + 5 = 12.

    Example 2:
    Input: cardPoints = [2,2,2], k = 2
    Output: 4
    Explanation: Regardless of which two cards you take, your score will always
                 be 4.

    Example 3:
    Input: cardPoints = [9,7,7,9,7,7,9], k = 7
    Output: 55
    Explanation: You have to take all the cards. Your score is the sum of
                 points of all cards.

    Example 4:
    Input: cardPoints = [1,1000,1], k = 1
    Output: 1
    Explanation: You cannot take the card in the middle. Your best score is 1.

    Example 5:
    Input: cardPoints = [1,79,80,1,1,1,200,1], k = 3
    Output: 202

    Constraints:
    * 1 <= cardPoints.length <= 10^5
    * 1 <= cardPoints[i] <= 10^4
    * 1 <= k <= cardPoints.length*/

    int maxScore(vector<int>& cardPoints, int k) {
        int ans = 0, n = cardPoints.size();
        for (int i = 0; i < k; ++i) {
            ans += cardPoints[i];
        }

        for (int i = 0, val = ans; i < k; ++i) {
            val += cardPoints[n-1-i] - cardPoints[k-1-i];
            ans = max(ans, val);
        }
        return ans;
    }


    /*1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)
    Given an array of integers arr. We want to select three indices i, j and k
    where (0 <= i < j <= k < arr.length). Let's define a and b as follows:
    * a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
    * b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
    Note that ^ denotes the bitwise-xor operation. Return the number of triplets
    (i, j and k) Where a == b.

    Example 1:
    Input: arr = [2,3,1,6,7]
    Output: 4
    Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)

    Example 2:
    Input: arr = [1,1,1,1,1]
    Output: 10

    Constraints:
    * 1 <= arr.length <= 300
    * 1 <= arr[i] <= 10^8*/

    int countTriplets(vector<int>& arr) {
        int ans =- 0, prefix = 0;
        unordered_map<int, pair<int, int>> mp;
        mp[0] = make_pair(0, 1);
        for (int i = 0; i < arr.size(); ++i) {
            prefix ^= arr[i];
            auto [s, c] = mp[prefix];
            ans += c*i - s;
            mp[prefix] = make_pair(s+i+1, c+1);
        }
        return ans;
    }


    /*1443. Minimum Time to Collect All Apples in a Tree (Medium)
    Given an undirected tree consisting of n vertices numbered from 0 to n-1,
    which has some apples in their vertices. You spend 1 second to walk over
    one edge of the tree. Return the minimum time in seconds you have to spend
    to collect all apples in the tree, starting at vertex 0 and coming back to
    this vertex. The edges of the undirected tree are given in the array edges,
    where edges[i] = [ai, bi] means that exists an edge connecting the vertices
    ai and bi. Additionally, there is a boolean array hasApple, where
    hasApple[i] = true means that vertex i has an apple; otherwise, it does not
    have any apple.

    Example 1:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]],
           hasApple = [false,false,true,false,true,true,false]
    Output: 8
    Explanation: The figure above represents the given tree where red vertices
                 have an apple. One optimal path to collect all apples is shown
                 by the green arrows.

    Example 2:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]],
           hasApple = [false,false,true,false,false,true,false]
    Output: 6
    Explanation: The figure above represents the given tree where red vertices
                 have an apple. One optimal path to collect all apples is shown
                 by the green arrows.

    Example 3:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]],
           hasApple = [false,false,false,false,false,false,false]
    Output: 0

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai < bi <= n - 1
    * fromi < toi
    * hasApple.length == n*/

    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        vector<int> ans(n);
        vector<bool> seen(n);
        stack<pair<int, int>> stk; stk.emplace(0, -1);
        while (stk.size()) {
            auto [u, p] = stk.top();
            if (seen[u]) {
                for (auto& v : tree[u])
                    if (v != p) ans[u] += ans[v];
                if (u && (ans[u] || hasApple[u])) ++ans[u];
                stk.pop();
            } else {
                for (auto& v : tree[u])
                    if (v != p) stk.emplace(v, u);
                seen[u] = true;
            }
        }
        return ans[0]*2;
    }


    /*1446. Consecutive Characters (Easy)
    The power of the string is the maximum length of a non-empty substring that
    contains only one unique character. Given a string s, return the power of s.

    Example 1:
    Input: s = "leetcode"
    Output: 2
    Explanation: The substring "ee" is of length 2 with the character 'e' only.

    Example 2:
    Input: s = "abbcccddddeeeeedcba"
    Output: 5
    Explanation: The substring "eeeee" is of length 5 with the character 'e' only.

    Example 3:
    Input: s = "triplepillooooow"
    Output: 5

    Example 4:
    Input: s = "hooraaaaaaaaaaay"
    Output: 11

    Example 5:
    Input: s = "tourist"
    Output: 1

    Constraints:
    * 1 <= s.length <= 500
    * s consists of only lowercase English letters.*/

    int maxPower(string s) {
        int ans = 0;
        for (int i = 0, cnt = 0; i < s.size(); ++i) {
            if (i && s[i-1] != s[i]) cnt = 0;
            ++cnt;
            ans = max(ans, cnt);
        }
        return ans;
    }


    /*1447. Simplified Fractions (Medium)
    Given an integer n, return a list of all simplified fractions between 0 and
    1 (exclusive) such that the denominator is less-than-or-equal-to n. You can
    return the answer in any order.

    Example 1:
    Input: n = 2
    Output: ["1/2"]
    Explanation: "1/2" is the only unique fraction with a denominator less-than-
                 or-equal-to 2.

    Example 2:
    Input: n = 3
    Output: ["1/2","1/3","2/3"]

    Example 3:
    Input: n = 4
    Output: ["1/2","1/3","1/4","2/3","3/4"]
    Explanation: "2/4" is not a simplified fraction because it can be
                 simplified to "1/2".

    Constraints: 1 <= n <= 100*/

    vector<string> simplifiedFractions(int n) {
        vector<string> ans;
        stack<tuple<int, int, int, int>> stk; // Stern-Brocot tree
        stk.emplace(0, 1, 1, 1);
        while (stk.size()) {
            auto [px, pd, x, d] = stk.top(); stk.pop();
            int cx = px + x, cd = pd + d; // mediant
            if (cd <= n) {
                stk.emplace(px, pd, cx, cd);
                stk.emplace(cx, cd, x, d);
                ans.push_back(to_string(cx) + "/" + to_string(cd));
            }
        }
        return ans;
    }


    /*1448. Count Good Nodes in Binary Tree (Medium)
    Given a binary tree root, a node X in the tree is named good if in the path
    from root to X there are no nodes with a value greater than X. Return the
    number of good nodes in the binary tree.

    Example 1:
    Input: root = [3,1,4,3,null,1,5]
    Output: 4
    Explanation: Nodes in blue are good. Root Node (3) is always a good node.
    Node 4 -> (3,4) is the maximum value in the path starting from the root.
    Node 5 -> (3,4,5) is the maximum value in the path
    Node 3 -> (3,1,3) is the maximum value in the path.

    Example 2:
    Input: root = [3,3,null,4,2]
    Output: 3
    Explanation: Node 2 -> (3, 3, 2) is not good, because "3" is higher than it.

    Example 3:
    Input: root = [1]
    Output: 1
    Explanation: Root is considered as good.

    Constraints:
    * The number of nodes in the binary tree is in the range [1, 10^5].
    * Each node's value is between [-10^4, 10^4].*/

    int goodNodes(TreeNode* root) {
        int ans = 0;
        if (root) {
            stack<pair<TreeNode*, int>> stk;
            stk.emplace(root, root->val);
            while (stk.size()) {
                auto [node, val] = stk.top();
                stk.pop();
                if (node->val >= val) {
                    ++ans;
                    val = node->val;
                }
                if (node->left) stk.emplace(node->left, val);
                if (node->right) stk.emplace(node->right, val);
            }
        }
        return ans;
    }


    /*1460. Make Two Arrays Equal by Reversing Subarrays (Easy)
    You are given two integer arrays of equal length target and arr. In one
    step, you can select any non-empty subarray of arr and reverse it. You are
    allowed to make any number of steps. Return true if you can make arr equal
    to target or false otherwise.

    Example 1:
    Input: target = [1,2,3,4], arr = [2,4,1,3]
    Output: true
    Explanation: You can follow the next steps to convert arr to target:
                 1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]
                 2- Reverse subarray [4,2], arr becomes [1,2,4,3]
                 3- Reverse subarray [4,3], arr becomes [1,2,3,4]
                 There are multiple ways to convert arr to target, this is not
                 the only way to do so.

    Example 2:
    Input: target = [7], arr = [7]
    Output: true
    Explanation: arr is equal to target without any reverses.

    Example 3:
    Input: target = [3,7,9], arr = [3,7,11]
    Output: false
    Explanation: arr does not have value 9 and it can never be converted to
                 target.

    Constraints:
    * target.length == arr.length
    * 1 <= target.length <= 1000
    * 1 <= target[i] <= 1000
    * 1 <= arr[i] <= 1000*/

    bool canBeEqual(vector<int>& target, vector<int>& arr) {
        unordered_map<int, int> freq;
        for (auto& x : target) ++freq[x];
        for (auto& x : arr) --freq[x];
        return all_of(freq.begin(), freq.end(), [&](auto& elem) { return elem.second == 0; });
    }


    /*1463. Cherry Pickup II (Hard)
    You are given a rows x cols matrix grid representing a field of cherries
    where grid[i][j] represents the number of cherries that you can collect
    from the (i, j) cell. You have two robots that can collect cherries for you:
    * Robot #1 is located at the top-left corner (0, 0), and
    * Robot #2 is located at the top-right corner (0, cols - 1).
    Return the maximum number of cherries collection using both robots by
    following the rules below:
    * From a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j),
      or (i + 1, j + 1).
    * When any robot passes through a cell, It picks up all cherries, and the
      cell becomes an empty cell.
    * When both robots stay in the same cell, only one takes the cherries.
    * Both robots cannot move outside of the grid at any moment.
    * Both robots should reach the bottom row in grid.

    Example 1:
    Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
    Output: 24
    Explanation: Path of robot #1 and #2 are described in color green and blue
                 respectively. Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.
                 Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12. Total of
                 cherries: 12 + 12 = 24.

    Example 2:
    Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
    Output: 28
    Explanation: Path of robot #1 and #2 are described in color green and blue
                 respectively. Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.
                 Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11. Total of
                 cherries: 17 + 11 = 28.

    Constraints:
    * rows == grid.length
    * cols == grid[i].length
    * 2 <= rows, cols <= 70
    * 0 <= grid[i][j] <= 100*/

    int cherryPickup(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<vector<int>>> memo(m, vector<vector<int>>(n, vector<int>(n, -1)));

        function<int(int, int, int)> fn = [&](int i, int j, int k) {
            if (i == m) return 0;
            if (memo[i][j][k] == -1) {
                memo[i][j][k] = grid[i][j];
                if (j != k) memo[i][j][k] += grid[i][k];
                int val = 0;
                for (int jj = j-1; jj <= j+1; ++jj)
                    for (int kk = k-1; kk <= k+1; ++kk)
                        if (0 <= jj && jj < n && 0 <= kk && kk < n)
                            val = max(val, fn(i+1, jj, kk));
                memo[i][j][k] += val;
            }
            return memo[i][j][k];
        };

        return fn(0, 0, n-1);
    }


    /*1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts (Medium)
    Given a rectangular cake with height h and width w, and two arrays of
    integers horizontalCuts and verticalCuts where horizontalCuts[i] is the
    distance from the top of the rectangular cake to the ith horizontal cut and
    similarly, verticalCuts[j] is the distance from the left of the rectangular
    cake to the jth vertical cut. Return the maximum area of a piece of cake
    after you cut at each horizontal and vertical position provided in the
    arrays horizontalCuts and verticalCuts. Since the answer can be a huge
    number, return this modulo 10^9 + 7.

    Example 1:
    Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]
    Output: 4
    Explanation: The figure above represents the given rectangular cake. Red
                 lines are the horizontal and vertical cuts. After you cut the
                 cake, the green piece of cake has the maximum area.

    Example 2:
    Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]
    Output: 6
    Explanation: The figure above represents the given rectangular cake. Red
                 lines are the horizontal and vertical cuts. After you cut the
                 cake, the green and yellow pieces of cake have the maximum
                 area.

    Example 3:
    Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]
    Output: 9

    Constraints:
    * 2 <= h, w <= 10^9
    * 1 <= horizontalCuts.length < min(h, 10^5)
    * 1 <= verticalCuts.length < min(w, 10^5)
    * 1 <= horizontalCuts[i] < h
    * 1 <= verticalCuts[i] < w
    * It is guaranteed that all elements in horizontalCuts are distinct.
    * It is guaranteed that all elements in verticalCuts are distinct.*/

    int maxArea(int h, int w, vector<int>& horizontalCuts, vector<int>& verticalCuts) {
        sort(begin(horizontalCuts), end(horizontalCuts));
        sort(begin(verticalCuts), end(verticalCuts));
        int hmx = max(horizontalCuts.front(), h - horizontalCuts.back());
        for (int i = 1; i < size(horizontalCuts); ++i)
            hmx = max(hmx, horizontalCuts[i] - horizontalCuts[i-1]);
        int vmx = max(verticalCuts.front(), w - verticalCuts.back());
        for (int i = 1; i < size(verticalCuts); ++i)
            vmx = max(vmx, verticalCuts[i] - verticalCuts[i-1]);
        return (long) hmx * vmx % 1'000'000'007;
    }


    /*1470. Shuffle the Array (Easy)
    Given the array nums consisting of 2n elements in the form
    [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form
    [x1,y1,x2,y2,...,xn,yn].

    Example 1:
    Input: nums = [2,5,1,3,4,7], n = 3
    Output: [2,3,5,4,1,7]
    Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is
                 [2,3,5,4,1,7].

    Example 2:
    Input: nums = [1,2,3,4,4,3,2,1], n = 4
    Output: [1,4,2,3,3,2,4,1]

    Example 3:
    Input: nums = [1,1,2,2], n = 2
    Output: [1,2,1,2]

    Constraints:
    * 1 <= n <= 500
    * nums.length == 2n
    * 1 <= nums[i] <= 10^3*/

    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> ans;
        for (int i = 0; i < n; ++i) {
            ans.push_back(nums[i]);
            ans.push_back(nums[i+n]);
        }
        return ans;
    }


    /*1482. Minimum Number of Days to Make m Bouquets (Medium)
    You are given an integer array bloomDay, an integer m and an integer k. You
    want to make m bouquets. To make a bouquet, you need to use k adjacent
    flowers from the garden. The garden consists of n flowers, the ith flower
    will bloom in the bloomDay[i] and then can be used in exactly one bouquet.
    Return the minimum number of days you need to wait to be able to make m
    bouquets from the garden. If it is impossible to make m bouquets return -1.

    Example 1:
    Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
    Output: 3
    Explanation: Let us see what happened in the first three days. x means
                 flower bloomed and _ means flower did not bloom in the garden.
                 We need 3 bouquets each should contain 1 flower.
                 After day 1: [x, _, _, _, _]   // we can only make one bouquet.
                 After day 2: [x, _, _, _, x]   // we can only make two bouquets.
                 After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The
                                                // answer is 3.

    Example 2:
    Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
    Output: -1
    Explanation: We need 3 bouquets each has 2 flowers, that means we need 6
                 flowers. We only have 5 flowers so it is impossible to get the
                 needed bouquets and we return -1.

    Example 3:
    Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
    Output: 12
    Explanation: We need 2 bouquets each should have 3 flowers. Here is the
                 garden after the 7 and 12 days:
                 After day 7: [x, x, x, x, _, x, x]
                 We can make one bouquet of the first three flowers that
                 bloomed. We cannot make another bouquet from the last three
                 flowers that bloomed because they are not adjacent.
                 After day 12: [x, x, x, x, x, x, x]
                 It is obvious that we can make two bouquets in different ways.

    Constraints:
    * bloomDay.length == n
    * 1 <= n <= 10^5
    * 1 <= bloomDay[i] <= 10^9
    * 1 <= m <= 10^6
    * 1 <= k <= n*/

    int minDays(vector<int>& bloomDay, int m, int k) {
        if (bloomDay.size() < (long) m*k) return -1;
        int lo = 0, hi = *max_element(bloomDay.begin(), bloomDay.end());
        while (lo < hi) {
            int mid = lo + (hi-lo)/2;
            int bouquet = 0, flower = 0;
            for (auto& x : bloomDay) {
                if (x <= mid) ++flower;
                else flower = 0;
                if (flower == k) {
                    flower = 0;
                    ++bouquet;
                }
            }
            if (bouquet >= m) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }


    /*1485. Clone Binary Tree With Random Pointer (Medium)
    A binary tree is given such that each node contains an additional random
    pointer which could point to any node in the tree or null. Return a deep
    copy of the tree. The tree is represented in the same input/output way as
    normal binary trees where each node is represented as a pair of
    [val, random_index] where:
    * val: an integer representing Node.val
    * random_index: the index of the node (in the input) where the random
      pointer points to, or null if it does not point to any node.
    You will be given the tree in class Node and you should return the cloned
    tree in class NodeCopy. NodeCopy class is just a clone of Node class with
    the same attributes and constructors.

    Example 1:
    Input: root = [[1,null],null,[4,3],[7,0]]
    Output: [[1,null],null,[4,3],[7,0]]
    Explanation: The original binary tree is [1,null,4,7]. The random pointer
                 of node one is null, so it is represented as [1, null]. The
                 random pointer of node 4 is node 7, so it is represented as
                 [4, 3] where 3 is the index of node 7 in the array
                 representing the tree. The random pointer of node 7 is node 1,
                 so it is represented as [7, 0] where 0 is the index of node 1
                 in the array representing the tree.

    Example 2:
    Input: root = [[1,4],null,[1,0],null,[1,5],[1,5]]
    Output: [[1,4],null,[1,0],null,[1,5],[1,5]]
    Explanation: The random pointer of a node can be the node itself.

    Example 3:
    Input: root = [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]
    Output: [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]

    Example 4:
    Input: root = []
    Output: []

    Example 5:
    Input: root = [[1,null],null,[2,null],null,[1,null]]
    Output: [[1,null],null,[2,null],null,[1,null]]

    Constraints:
    * The number of nodes in the tree is in the range [0, 1000].
    * Each node's value is between [1, 10^6].*/

    NodeCopy* copyRandomBinaryTree(Node* root) {
        if (!root) return nullptr;
        unordered_map<Node*, NodeCopy*> mp;
        stack<Node*> stk;
        stk.push(root);

        while (stk.size()) {
            Node* node = stk.top(); stk.pop();
            if (!mp[node]) mp[node] = new NodeCopy();
            mp[node]->val = node->val;
            if (node->left) {
                if (!mp[node->left]) mp[node->left] = new NodeCopy();
                mp[node]->left = mp[node->left];
                stk.push(node->left);
            }
            if (node->right) {
                if (!mp[node->right]) mp[node->right] = new NodeCopy();
                mp[node]->right = mp[node->right];
                stk.push(node->right);
            }
            if (node->random) {
                if (!mp[node->random]) mp[node->random] = new NodeCopy();
                mp[node]->random = mp[node->random];
            }
        }
        return mp[root];
    }


    /*1490. Clone N-ary Tree (Medium)
    Given a root of an N-ary tree, return a deep copy (clone) of the tree. Each
    node in the n-ary tree contains a val (int) and a list (List[Node]) of its
    children.

    class Node {
        public int val;
        public List<Node> children;
    }

    Nary-Tree input serialization is represented in their level order traversal,
    each group of children is separated by the null value (See examples).

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: [1,null,3,2,4,null,5,6]

    Example 2:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]

    Constraints:
    * The depth of the n-ary tree is less than or equal to 1000.
    * The total number of nodes is between [0, 10^4].

    Follow up: Can your solution work for the graph problem?*/

    Node* cloneTree(Node* root) {
        if (!root) return nullptr;
        Node* ans = new Node(root->val);
        for (auto& child : root->children)
            ans->children.push_back(cloneTree(child));
        return ans;
    }


    /*1506. Find Root of N-Ary Tree (Medium)
    You are given all the nodes of an N-ary tree as an array of Node objects,
    where each node has a unique value. Return the root of the N-ary tree.

    Custom testing: An N-ary tree can be serialized as represented in its level
    order traversal where each group of children is separated by the null value
    (see examples). For example, the above tree is serialized as
    [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].

    The testing will be done in the following way:
    * The input data should be provided as a serialization of the tree.
    * The driver code will construct the tree from the serialized input data
      and put each Node object into an array in an arbitrary order.
    * The driver code will pass the array to findRoot, and your function should
      find and return the root Node object in the array.
    * The driver code will take the returned Node object and serialize it. If
      the serialized value and the input data are the same, the test passes.

    Example 1:
    Input: tree = [1,null,3,2,4,null,5,6]
    Output: [1,null,3,2,4,null,5,6]
    Explanation: The tree from the input data is shown above. The driver code
                 creates the tree and gives findRoot the Node objects in an
                 arbitrary order. For example, the passed array could be
                 [Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)] or
                 [Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)]. The
                 findRoot function should return the root Node(1), and the
                 driver code will serialize it and compare with the input data.
                 The input data and serialized Node(1) are the same, so the
                 test passes.

    Example 2:
    Input: tree = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]

    Constraints:
    * The total number of nodes is between [1, 5 * 10^4].
    * Each node has a unique value.

    Follow up: Could you solve this problem in constant space complexity with a
               linear time algorithm?*/

    Node* findRoot(vector<Node*> tree) {
        int val = 0;
        for (auto& node : tree) {
            val ^= node->val;
            for (auto& child : node->children)
                val ^= child->val;
        }
        for (auto& node : tree)
            if (node->val == val) return node;
        return nullptr;
    }


    /*1508. Range Sum of Sorted Subarray Sums (Medium)
    You are given the array nums consisting of n positive integers. You computed
    the sum of all non-empty continuous subarrays from the array and then sorted
    them in non-decreasing order, creating a new array of n * (n + 1) / 2
    numbers. Return the sum of the numbers from index left to index right
    (indexed from 1), inclusive, in the new array. Since the answer can be a
    huge number return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
    Output: 13
    Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After
                 sorting them in non-decreasing order we have the new array
                 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from
                 index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13.

    Example 2:
    Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
    Output: 6
    Explanation: The given array is the same as example 1. We have the new array
                 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from
                 index le = 3 to ri = 4 is 3 + 3 = 6.

    Example 3:
    Input: nums = [1,2,3,4], n = 4, left = 1, right = 10
    Output: 50

    Constraints:
    * n == nums.length
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 100
    * 1 <= left <= right <= n * (n + 1) / 2*/

    int rangeSum(vector<int>& nums, int n, int left, int right) {
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        for (int i = 0; i < n; ++i)
            pq.emplace(nums[i], i);
        long ans = 0;
        for (int k = 1; k <= right; ++k) {
            auto [x, i] = pq.top(); pq.pop();
            if (k >= left) ans = (ans + x) % 1'000'000'007;
            if (i+1 < n)
                pq.emplace(x + nums[i+1], i+1);
        }
        return ans;
    }


    /*1509. Minimum Difference Between Largest and Smallest Value in Three Moves (Medium)
    You are given an integer array nums. In one move, you can choose one element
    of nums and change it to any value. Return the minimum difference between
    the largest and smallest value of nums after performing at most three moves.

    Example 1:
    Input: nums = [5,3,2,4]
    Output: 0
    Explanation: We can make at most 3 moves.
                 In the first move, change 2 to 3. nums becomes [5,3,3,4].
                 In the second move, change 4 to 3. nums becomes [5,3,3,3].
                 In the third move, change 5 to 3. nums becomes [3,3,3,3].
                 After performing 3 moves, the difference between the minimum
                 and maximum is 3 - 3 = 0.

    Example 2:
    Input: nums = [1,5,0,10,14]
    Output: 1
    Explanation: We can make at most 3 moves.
                 In the first move, change 5 to 0. nums becomes [1,0,0,10,14].
                 In the second move, change 10 to 0. nums becomes [1,0,0,0,14].
                 In the third move, change 14 to 1. nums becomes [1,0,0,0,1].
                 After performing 3 moves, the difference between the minimum
                 and maximum is 1 - 0 = 1. It can be shown that there is no way
                 to make the difference 0 in 3 moves.

    Example 3:
    Input: nums = [3,100,20]
    Output: 0
    Explanation: We can make at most 3 moves.
                 In the first move, change 100 to 7. nums becomes [3,7,20].
                 In the second move, change 20 to 7. nums becomes [3,7,7].
                 In the third move, change 3 to 7. nums becomes [7,7,7].
                 After performing 3 moves, the difference between the minimum
                 and maximum is 7 - 7 = 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    int minDifference(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int ans = INT_MAX;
        for (int i = 0, n = nums.size(); i < 4 && i < n; ++i) {
            int j = max(i, n-4+i);
            ans = min(ans, nums[j]-nums[i]);
        }
        return ans;
    }


    /*1510. Stone Game IV (Hard)
    Alice and Bob take turns playing a game, with Alice starting first.
    Initially, there are n stones in a pile. On each player's turn, that player
    makes a move consisting of removing any non-zero square number of stones in
    the pile. Also, if a player cannot make a move, he/she loses the game.
    Given a positive integer n, return true if and only if Alice wins the game
    otherwise return false, assuming both players play optimally.

    Example 1:
    Input: n = 1
    Output: true
    Explanation: Alice can remove 1 stone winning the game because Bob doesn't
                 have any moves.

    Example 2:
    Input: n = 2
    Output: false
    Explanation: Alice can only remove 1 stone, after that Bob removes the last
                 one winning the game (2 -> 1 -> 0).

    Example 3:
    Input: n = 4
    Output: true
    Explanation: n is already a perfect square, Alice can win with one move,
                 removing 4 stones (4 -> 0).

    Constraints: 1 <= n <= 10^5*/

    bool winnerSquareGame(int n) {
        vector<bool> dp(n+1);
        for (int x = 1; x <= n; ++x)
            for (int k = 1; k*k <= x; ++k)
                if (!dp[x-k*k]) {
                    dp[x] = true;
                    break;
                }
        return dp.back();
    }


    /*1514. Path with Maximum Probability (Medium)
    You are given an undirected weighted graph of n nodes (0-indexed),
    represented by an edge list where edges[i] = [a, b] is an undirected edge
    connecting the nodes a and b with a probability of success of traversing
    that edge succProb[i]. Given two nodes start and end, find the path with the
    maximum probability of success to go from start to end and return its
    success probability. If there is no path from start to end, return 0. Your
    answer will be accepted if it differs from the correct answer by at most
    1e-5.

    Example 1:
    Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
    Output: 0.25000
    Explanation: There are two paths from start to end, one having a probability
                 of success = 0.2 and the other has 0.5 * 0.5 = 0.25.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
    Output: 0.30000

    Example 3:
    Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
    Output: 0.00000
    Explanation: There is no path between 0 and 2.

    Constraints:
    * 2 <= n <= 10^4
    * 0 <= start, end < n
    * start != end
    * 0 <= a, b < n
    * a != b
    * 0 <= succProb.length == edges.length <= 2*10^4
    * 0 <= succProb[i] <= 1
    * There is at most one edge between every two nodes.*/

    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {
        vector<vector<pair<int, double>>> graph(n);
        for (int i = 0; i < edges.size(); ++i) {
            int u = edges[i][0], v = edges[i][1];
            graph[u].emplace_back(v, succProb[i]);
            graph[v].emplace_back(u, succProb[i]);
        }
        priority_queue<pair<double, int>> pq;
        pq.emplace(1, start_node);
        vector<double> dist(n);
        dist[start_node] = 1;
        while (pq.size()) {
            auto [p, u] = pq.top(); pq.pop();
            if (u == end_node) return p;
            for (auto& [v, x] : graph[u])
                if (dist[v] < p*x) {
                    dist[v] = p*x;
                    pq.emplace(p*x, v);
                }
        }
        return 0;
    }


    /*1516. Move Sub-Tree of N-Ary Tree (Hard)
    Given the root of an N-ary tree of unique values, and two nodes of the tree
    p and q. You should move the subtree of the node p to become a direct child
    of node q. If p is already a direct child of q, do not change anything.
    Node p must be the last child in the children list of node q. Return the
    root of the tree after adjusting it. There are 3 cases for nodes p and q:
    * Node q is in the sub-tree of node p.
    * Node p is in the sub-tree of node q.
    * Neither node p is in the sub-tree of node q nor node q is in the sub-tree
      of node p.
    In cases 2 and 3, you just need to move p (with its sub-tree) to be a child
    of q, but in case 1 the tree may be disconnected, thus you need to
    reconnect the tree again. Please read the examples carefully before solving
    this problem. Nary-Tree input serialization is represented in their level
    order traversal, each group of children is separated by the null value (See
    examples). For example, the above tree is serialized as
    [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].

    Example 1:
    Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 4, q = 1
    Output: [1,null,2,3,4,null,5,null,6,null,7,8]
    Explanation: This example follows the second case as node p is in the sub-
                 tree of node q. We move node p with its sub-tree to be a
                 direct child of node q. Notice that node 4 is the last child
                 of node 1.

    Example 2:
    Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 7, q = 4
    Output: [1,null,2,3,null,4,5,null,6,null,7,8]
    Explanation: Node 7 is already a direct child of node 4. We don't change
                 anything.

    Example 3:
    Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 3, q = 8
    Output: [1,null,2,null,4,5,null,7,8,null,null,null,3,null,6]
    Explanation: This example follows case 3 because node p is not in the sub-
                 tree of node q and vice-versa. We can move node 3 with its
                 sub-tree and make it as node 8's child.

    Constraints:
    * The total number of nodes is between [2, 1000].
    * Each node has a unique value.
    * p != null
    * q != null
    * p and q are two different nodes (i.e. p != q).*/

    Node* moveSubTree(Node* root, Node* p, Node* q) {
        if (find(q->children.begin(), q->children.end(), p) == q->children.end()) {
            unordered_map<Node*, Node*> parent = {{root, nullptr}};
            stack<Node*> stk; stk.push(root);
            while (stk.size()) {
                auto u = stk.top(); stk.pop();
                for (auto& v : u->children) {
                    parent[v] = u;
                    stk.push(v);
                }
            }
            unordered_set<Node*> anc;
            for (Node* n = q; n; n = parent[n]) anc.insert(n);
            if (anc.count(p)) {
                parent[q]->children.erase(remove(parent[q]->children.begin(), parent[q]->children.end(), q), parent[q]->children.end());
                if (p == root) root = q;
                else {
                    auto ptr = find(parent[p]->children.begin(), parent[p]->children.end(), p);
                    *ptr = q;
                }
            } else parent[p]->children.erase(remove(parent[p]->children.begin(), parent[p]->children.end(), p), parent[p]->children.end());
            q->children.push_back(p);
        }
        return root;
    }


    /*1518. Water Bottles (Easy)
    Given numBottles full water bottles, you can exchange numExchange empty
    water bottles for one full water bottle. The operation of drinking a full
    water bottle turns it into an empty bottle. Return the maximum number of
    water bottles you can drink.

    Example 1:
    Input: numBottles = 9, numExchange = 3
    Output: 13
    Explanation: You can exchange 3 empty bottles to get 1 full water bottle.
                 Number of water bottles you can drink: 9 + 3 + 1 = 13.

    Example 2:
    Input: numBottles = 15, numExchange = 4
    Output: 19
    Explanation: You can exchange 4 empty bottles to get 1 full water bottle.
                 Number of water bottles you can drink: 15 + 3 + 1 = 19.

    Example 3:
    Input: numBottles = 5, numExchange = 5
    Output: 6

    Example 4:
    Input: numBottles = 2, numExchange = 3
    Output: 2

    Constraints:
    * 1 <= numBottles <= 100
    * 2 <= numExchange <= 100*/

    int numWaterBottles(int numBottles, int numExchange) {
        int ans = 0, empty = 0;
        while (numBottles) {
            ans += numBottles;
            numBottles += empty;
            empty = numBottles % numExchange;
            numBottles = numBottles / numExchange;
        }
        return ans;
    }


    /*1519. Number of Nodes in the Sub-Tree With the Same Label (Medium)
    You are given a tree (i.e. a connected, undirected graph that has no cycles)
    consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The
    root of the tree is the node 0, and each node of the tree has a label which
    is a lower-case character given in the string labels (i.e. The node with
    the number i has the label labels[i]). The edges array is given on the form
    edges[i] = [ai, bi], which means there is an edge between nodes ai and bi
    in the tree. Return an array of size n where ans[i] is the number of nodes
    in the subtree of the ith node which have the same label as node i. A
    subtree of a tree T is the tree consisting of a node in T and all of its
    descendant nodes.

    Example 1:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = "abaedcd"
    Output: [2,1,1,1,1,1,1]
    Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label
                 'a' as well, thus the answer is 2. Notice that any node is
                 part of its sub-tree. Node 1 has a label 'b'. The sub-tree of
                 node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have
                 different labels than node 1, the answer is just 1 (the node
                 itself).

    Example 2:
    Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = "bbbb"
    Output: [4,2,1,1]
    Explanation: The sub-tree of node 2 contains only node 2, so the answer is
                 1. The sub-tree of node 3 contains only node 3, so the answer
                 is 1. The sub-tree of node 1 contains nodes 1 and 2, both have
                 label 'b', thus the answer is 2. The sub-tree of node 0
                 contains nodes 0, 1, 2 and 3, all with label 'b', thus the
                 answer is 4.

    Example 3:
    Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = "aabab"
    Output: [3,2,1,1,1]

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * labels.length == n
    * labels is consisting of only of lowercase English letters.*/

    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        vector<int> ans(n);
        vector<vector<int>> freq(n, vector<int>(26));
        vector<bool> seen(n);
        stack<pair<int, int>> stk; stk.emplace(0, -1);
        while (stk.size()) {
            auto [u, p] = stk.top();
            if (seen[u]) {
                ++freq[u][labels[u] - 'a'];
                for (auto& v : tree[u])
                    if (v != p)
                        for (int i = 0; i < 26; ++i)
                            freq[u][i] += freq[v][i];
                ans[u] = freq[u][labels[u] - 'a'];
                stk.pop();
            } else {
                for (auto& v : tree[u])
                    if (v != p) stk.emplace(v, u);
                seen[u] = true;
            }
        }
        return ans;
    }


    /*1522. Diameter of N-Ary Tree (Medium)
    Given a root of an N-ary tree, you need to compute the length of the
    diameter of the tree. The diameter of an N-ary tree is the length of the
    longest path between any two nodes in the tree. This path may or may not
    pass through the root. (Nary-Tree input serialization is represented in
    their level order traversal, each group of children is separated by the
    null value.)

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: 3
    Explanation: Diameter is shown in red color.

    Example 2:
    Input: root = [1,null,2,null,3,4,null,5,null,6]
    Output: 4

    Example 3:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,
                   null,12,null,13,null,null,14]
    Output: 7

    Constraints:
    * The depth of the n-ary tree is less than or equal to 1000.
    * The total number of nodes is between [1, 10^4].*/

    int diameter(Node* root) {
        int ans = 0;

        function<int(Node*)> fn = [&](Node* node) {
            if (!node) return 0;
            int mx0 = 0, mx1 = 0;
            for (auto& child : node->children) {
                int val = fn(child);
                if (val >= mx0) {
                    mx1 = mx0;
                    mx0 = val;
                } else if (val > mx1)
                    mx1 = val;
            }
            ans = max(ans, mx0 + mx1);
            return 1 + mx0;
        };

        fn(root);
        return ans;
    }


    /*1523. Count Odd Numbers in an Interval Range (Easy)
    Given two non-negative integers low and high. Return the count of odd
    numbers between low and high (inclusive).

    Example 1:
    Input: low = 3, high = 7
    Output: 3
    Explanation: The odd numbers between 3 and 7 are [3,5,7].

    Example 2:
    Input: low = 8, high = 10
    Output: 1
    Explanation: The odd numbers between 8 and 10 are [9].

    Constraints: 0 <= low <= high <= 10^9*/

    int countOdds(int low, int high) {
        return (high+1)/2 - low/2;
    }


    /*1530. Number of Good Leaf Nodes Pairs (Medium)
    You are given the root of a binary tree and an integer distance. A pair of
    two different leaf nodes of a binary tree is said to be good if the length
    of the shortest path between them is less than or equal to distance. Return
    the number of good leaf node pairs in the tree.

    Example 1:
    Input: root = [1,2,3,null,4], distance = 3
    Output: 1
    Explanation: The leaf nodes of the tree are 3 and 4 and the length of the
                 shortest path between them is 3. This is the only good pair.

    Example 2:
    Input: root = [1,2,3,4,5,6,7], distance = 3
    Output: 2
    Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The
                 pair [4,6] is not good because the length of ther shortest path
                 between them is 4.

    Example 3:
    Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
    Output: 1
    Explanation: The only good pair is [2,5].

    Constraints:
    * The number of nodes in the tree is in the range [1, 2^10].
    * 1 <= Node.val <= 100
    * 1 <= distance <= 10*/

    int countPairs(TreeNode* root, int distance) {
        int ans = 0;

        function<vector<int>(TreeNode*)> fn = [&](TreeNode* node) {
            if (!node) return vector<int>();
            if (!node->left && !node->right) return vector<int>{0};
            vector<int> left = fn(node->left), right = fn(node->right);
            int j = right.size()-1;
            for (auto& x : left) {
                for (; 0 <= j && x+right[j]+2 > distance; --j);
                ans += j+1;
            }
            vector<int> out;
            for (int i = 0, j = 0, ni = left.size(), nj = right.size(); i < ni || j < nj; )
                if (j == nj || i < ni && left[i] < right[j])
                    out.push_back(left[i++]+1);
                else
                    out.push_back(right[j++]+1);
            return out;
        };

        fn(root);
        return ans;
    }


    /*1533. Find the Index of the Large Integer (Medium)
    We have an integer array arr, where all the integers in arr are equal
    except for one integer which is larger than the rest of the integers. You
    will not be given direct access to the array, instead, you will have an API
    ArrayReader which have the following functions:
    * int compareSub(int l, int r, int x, int y): where
      0 <= l, r, x, y < ArrayReader.length(), l <= r and x <= y. The function
      compares the sum of sub-array arr[l..r] with the sum of the sub-array
      arr[x..y] and returns:
      - 1 if arr[l]+arr[l+1]+...+arr[r] > arr[x]+arr[x+1]+...+arr[y].
      - 0 if arr[l]+arr[l+1]+...+arr[r] == arr[x]+arr[x+1]+...+arr[y].
      - -1 if arr[l]+arr[l+1]+...+arr[r] < arr[x]+arr[x+1]+...+arr[y].
    * int length(): Returns the size of the array.
    You are allowed to call compareSub() 20 times at most. You can assume both
    functions work in O(1) time. Return the index of the array arr which has
    the largest integer.

    Follow-up:
    * What if there are two numbers in arr that are bigger than all other
      numbers?
    * What if there is one number that is bigger than other numbers and one
      number that is smaller than other numbers?

    Example 1:
    Input: arr = [7,7,7,7,10,7,7,7]
    Output: 4
    Explanation: The following calls to the API
    reader.compareSub(0, 0, 1, 1) // returns 0 this is a query comparing the
                                  // sub-array (0, 0) with the sub array (1, 1),
                                  // (i.e. compares arr[0] with arr[1]).
    Thus we know that arr[0] and arr[1] doesn't contain the largest element.
    reader.compareSub(2, 2, 3, 3) // returns 0, we can exclude arr[2] and arr[3].
    reader.compareSub(4, 4, 5, 5) // returns 1, thus for sure arr[4] is the
                                  // largest element in the array.
    Notice that we made only 3 calls, so the answer is valid.

    Example 2:
    Input: nums = [6,6,12]
    Output: 2

    Constraints:
    * 2 <= arr.length <= 5 * 10^5
    * 1 <= arr[i] <= 100
    * All elements of arr are equal except for one element which is larger than
      all other elements.*/

    int getIndex(ArrayReader &reader) {
        int lo = 0, hi = reader.length()-1;
        while (lo <= hi) {
            int mid = lo + (hi - lo)/2;
            if ((hi-lo) & 1) {
                int res = reader.compareSub(lo, mid, mid+1, hi);
                if (res == 1) hi = mid;
                else lo = mid + 1;
            } else {
                int res = reader.compareSub(lo, mid, mid, hi);
                if (res == 1) hi = mid-1;
                else if (res == 0) return mid;
                else lo = mid+1;
            }
        }
        return -1;
    }


    /*1538. Guess the Majority in a Hidden Array (Medium)
    We have an integer array nums, where all the integers in nums are 0 or 1.
    You will not be given direct access to the array, instead, you will have an
    API ArrayReader which have the following functions:
    * int query(int a, int b, int c, int d): where
      0 <= a < b < c < d < ArrayReader.length(). The function returns the
      distribution of the value of the 4 elements and returns:
      + 4 : if the values of the 4 elements are the same (0 or 1).
      + 2 : if three elements have a value equal to 0 and one element has value
            equal to 1 or vice versa.
      + 0 : if two element have a value equal to 0 and two elements have a
            value equal to 1.
    * int length(): Returns the size of the array.
    You are allowed to call query() 2 * n times at most where n is equal to
    ArrayReader.length(). Return any index of the most frequent value in nums,
    in case of tie, return -1.

    Example 1:
    Input: nums = [0,0,1,0,1,1,1,1]
    Output: 5
    Explanation: The following calls to the API
                 reader.length() // returns 8 because there are 8 elements in
                                 // the hidden array.
                 reader.query(0,1,2,3) // returns 2 this is a query that
                                       // compares the elements nums[0],
                                       // nums[1], nums[2], nums[3]
                                       // Three elements have a value equal to 0
                                       // and one element has value equal to 1
                                       // or viceversa.
                 reader.query(4,5,6,7) // returns 4 because nums[4], nums[5],
                                       // nums[6], nums[7] have the same value.
                 we can infer that the most frequent value is found in the last
                 4 elements. Index 2, 4, 6, 7 is also a correct answer.

    Example 2:
    Input: nums = [0,0,1,1,0]
    Output: 0

    Example 3:
    Input: nums = [1,0,1,0,1,0,1,0]
    Output: -1

    Constraints:
    * 5 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1

    Follow up: What is the minimum number of calls needed to find the majority
               element?*/

    int guessMajority(ArrayReader &reader) {
        vector<int> freq(2), idx(2, -1);
        for (int i = 3; i < reader.length(); ++i) {
            int k = reader.query(0, 1, 2, i) == reader.query(0, 1, 2, 3);
            ++freq[k];
            idx[k] = i;
        }
        vector<int> args = {0, 1, 2, 3, 4};
        for (int i = 0; i < 3; ++i) {
            vector<int> copy = args;
            copy.erase(next(copy.begin(), i));
            int k = reader.query(copy[0], copy[1], copy[2], copy[3]) == reader.query(0, 1, 2, 4);
            ++freq[k];
            idx[k] = i;
        }
        return freq[0] > freq[1] ? idx[0] : (freq[0] < freq[1] ? idx[1] : -1);
    }


    /*1539. Kth Missing Positive Number (Easy)
    Given an array arr of positive integers sorted in a strictly increasing
    order, and an integer k. Return the kth positive integer that is missing
    from this array.

    Example 1:
    Input: arr = [2,3,4,7,11], k = 5
    Output: 9
    Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...].
                 The 5th missing positive integer is 9.

    Example 2:
    Input: arr = [1,2,3,4], k = 2
    Output: 6
    Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing
                 positive integer is 6.

    Constraints:
    * 1 <= arr.length <= 1000
    * 1 <= arr[i] <= 1000
    * 1 <= k <= 1000
    * arr[i] < arr[j] for 1 <= i < j <= arr.length

    Follow up: Could you solve this problem in less than O(n) complexity?*/

    int findKthPositive(vector<int>& arr, int k) {
        int lo = 0, hi = arr.size();
        while (lo < hi) {
            int mid = lo + (hi-lo)/2;
            if (arr[mid] - (mid+1) < k) lo = mid+1;
            else hi = mid;
        }
        return lo+k;
    }


    /*1544. Make The String Great (Easy)
    Given a string s of lower and upper case English letters. A good string is a
    string which doesn't have two adjacent characters s[i] and s[i + 1] where:
    * 0 <= i <= s.length - 2
    * s[i] is a lower-case letter and s[i + 1] is the same letter but in
      upper-case or vice-versa.
    To make the string good, you can choose two adjacent characters that make
    the string bad and remove them. You can keep doing this until the string
    becomes good. Return the string after making it good. The answer is
    guaranteed to be unique under the given constraints. Notice that an empty
    string is also good.

    Example 1:
    Input: s = "leEeetcode"
    Output: "leetcode"
    Explanation: In the first step, either you choose i = 1 or i = 2, both will
                 result "leEeetcode" to be reduced to "leetcode".

    Example 2:
    Input: s = "abBAcC"
    Output: ""
    Explanation: We have many possible scenarios, and all lead to the same
                 answer. For example:
                 "abBAcC" --> "aAcC" --> "cC" --> ""
                 "abBAcC" --> "abBA" --> "aA" --> ""

    Example 3:
    Input: s = "s"
    Output: "s"

    Constraints:
    * 1 <= s.length <= 100
    * s contains only lower and upper case English letters.*/

    string makeGood(string s) {
        string ans;
        for (auto& ch : s)
            if (ans.size() && (ans.back() ^ 32) == ch) ans.pop_back();
            else ans.push_back(ch);
        return ans;
    }


    /*1548. The Most Similar Path in a Graph (Hard)
    We have n cities and m bi-directional roads where roads[i] = [ai, bi]
    connects city ai with city bi. Each city has a name consisting of exactly
    three upper-case English letters given in the string array names. Starting
    at any city x, you can reach any city y where y != x (i.e., the cities and
    the roads are forming an undirected connected graph). You will be given a
    string array targetPath. You should find a path in the graph of the same
    length and with the minimum edit distance to targetPath. You need to return
    the order of the nodes in the path with the minimum edit distance. The path
    should be of the same length of targetPath and should be valid (i.e., there
    should be a direct road between ans[i] and ans[i + 1]). If there are
    multiple answers return any one of them.

    Example 1:
    Input: n = 5, roads = [[0,2],[0,3],[1,2],[1,3],[1,4],[2,4]], names = ["ATL","PEK","LAX","DXB","HND"], targetPath = ["ATL","DXB","HND","LAX"]
    Output: [0,2,4,2]
    Explanation: [0,2,4,2], [0,3,0,2] and [0,3,1,2] are accepted answers.
                 [0,2,4,2] is equivalent to ["ATL","LAX","HND","LAX"] which has
                           edit distance = 1 with targetPath.
                 [0,3,0,2] is equivalent to ["ATL","DXB","ATL","LAX"] which has
                           edit distance = 1 with targetPath.
                 [0,3,1,2] is equivalent to ["ATL","DXB","PEK","LAX"] which has
                           edit distance = 1 with targetPath.

    Example 2:
    Input: n = 4, roads = [[1,0],[2,0],[3,0],[2,1],[3,1],[3,2]], names = ["ATL","PEK","LAX","DXB"], targetPath = ["ABC","DEF","GHI","JKL","MNO","PQR","STU","VWX"]
    Output: [0,1,0,1,0,1,0,1]
    Explanation: Any path in this graph has edit distance = 8 with targetPath.

    Example 3:
    Input: n = 6, roads = [[0,1],[1,2],[2,3],[3,4],[4,5]], names = ["ATL","PEK","LAX","ATL","DXB","HND"], targetPath = ["ATL","DXB","HND","DXB","ATL","LAX","PEK"]
    Output: [3,4,5,4,3,2,1]
    Explanation: [3,4,5,4,3,2,1] is the only path with edit distance = 0 with
                 targetPath. It's equivalent to
                 ["ATL","DXB","HND","DXB","ATL","LAX","PEK"]

    Constraints:
    * 2 <= n <= 100
    * m == roads.length
    * n - 1 <= m <= (n * (n - 1) / 2)
    * 0 <= ai, bi <= n - 1
    * ai != bi
    * The graph is guaranteed to be connected and each pair of nodes may have
      at most one direct road.
    * names.length == n
    * names[i].length == 3
    * names[i] consists of upper-case English letters.
    * There can be two cities with the same name.
    * 1 <= targetPath.length <= 100
    * targetPath[i].length == 3
    * targetPath[i] consists of upper-case English letters.

    Follow up: If each node can be visited only once in the path, What should
               you change in your solution?*/

    vector<int> mostSimilar(int n, vector<vector<int>>& roads, vector<string>& names, vector<string>& targetPath) {
        vector<vector<int>> graph(n);
        for (auto& r : roads) {
            graph[r[0]].push_back(r[1]);
            graph[r[1]].push_back(r[0]);
        }
        int m = targetPath.size();
        vector<vector<int>> mp(m, vector<int>(n)), dp(m+1, vector<int>(n, INT_MAX));
        for (int j = 0; j < n; ++j) dp[m][j] = 0;
        for (int i = m-1; i >= 0; --i)
            for (int j = 0; j < n; ++j) {
                for (auto& k : graph[j])
                    if (dp[i+1][k] < dp[i][j]) {
                        dp[i][j] = dp[i+1][k];
                        mp[i][j] = k;
                    }
                if (targetPath[i] != names[j]) ++dp[i][j];
            }
        int jj = 0;
        for (int j = 0, v = INT_MAX; j < n; ++j)
            if (dp[0][j] < v) {
                jj = j;
                v = dp[0][j];
            }
        vector<int> ans;
        for (int i = 0; i < m; ++i) {
            ans.push_back(jj);
            jj = mp[i][jj];
        }
        return ans;
    }


    /*1550. Three Consecutive Odds (Easy)
    Given an integer array arr, return true if there are three consecutive odd
    numbers in the array. Otherwise, return false.

    Example 1:
    Input: arr = [2,6,4,1]
    Output: false
    Explanation: There are no three consecutive odds.

    Example 2:
    Input: arr = [1,2,34,3,4,5,7,23,12]
    Output: true
    Explanation: [5,7,23] are three consecutive odds.

    Constraints:
    * 1 <= arr.length <= 1000
    * 1 <= arr[i] <= 1000*/

    bool threeConsecutiveOdds(vector<int>& arr) {
        int cnt = 0;
        for (auto& x : arr) {
            if (x & 1) ++cnt;
            else cnt = 0;
            if (cnt == 3) return true;
        }
        return false;
    }


    /*1552. Magnetic Force Between Two Balls (Medium)
    In the universe Earth C-137, Rick discovered a special form of magnetic
    force between two balls if they are put in his new invented basket. Rick has
    n empty baskets, the ith basket is at position[i], Morty has m balls and
    needs to distribute the balls into the baskets such that the minimum
    magnetic force between any two balls is maximum. Rick stated that magnetic
    force between two different balls at positions x and y is |x - y|. Given the
    integer array position and the integer m. Return the required force.

    Example 1:
    Input: position = [1,2,3,4,7], m = 3
    Output: 3
    Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the
                 magnetic force between ball pairs [3, 3, 6]. The minimum
                 magnetic force is 3. We cannot achieve a larger minimum
                 magnetic force than 3.

    Example 2:
    Input: position = [5,4,3,2,1,1000000000], m = 2
    Output: 999999999
    Explanation: We can use baskets 1 and 1000000000.

    Constraints:
    * n == position.length
    * 2 <= n <= 10^5
    * 1 <= position[i] <= 10^9
    * All integers in position are distinct.
    * 2 <= m <= position.length*/

    int maxDistance(vector<int>& position, int m) {
        sort(position.begin(), position.end());
        int lo = 1, hi = position.back() - position[0];
        while (lo < hi) {
            int mid = lo + hi + 1 >> 1, cnt = 0, prev = -1'000'000'000;
            for (auto& x : position)
                if (x - prev >= mid) {
                    ++cnt;
                    prev = x;
                }
            if (cnt >= m) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*1554. Strings Differ by One Character (Medium)
    Given a list of strings dict where all the strings are of the same length.
    Return True if there are 2 strings that only differ by 1 character in the
    same index, otherwise return False.

    Follow up: Could you solve this problem in O(n*m) where n is the length of
               dict and m is the length of each string.

    Example 1:
    Input: dict = ["abcd","acbd", "aacd"]
    Output: true
    Explanation: Strings "abcd" and "aacd" differ only by one character in the
                 index 1.

    Example 2:
    Input: dict = ["ab","cd","yz"]
    Output: false

    Example 3:
    Input: dict = ["abcd","cccc","abyd","abab"]
    Output: true

    Constraints:
    * Number of characters in dict <= 10^5
    * dict[i].length == dict[j].length
    * dict[i] should be unique.
    * dict[i] contains only lowercase English letters.*/

    bool differByOne(vector<string>& dict) {
        const int MOD = 1'000'000'007;
        vector<int> hs;
        for (auto& word : dict) {
            long val = 0;
            for (auto& ch : word) val = (26*val + ch - 'a') % MOD;
            hs.push_back(val);
        }

        int m = dict.size(), n = dict[0].size();
        long mult = 1l;
        for (int j = n-1; j >= 0; --j) {
            unordered_map<int, vector<int>> seen;
            for (int i = 0; i < m; ++i) {
                int val = (hs[i] - (dict[i][j] - 'a')*mult + 26l*MOD) % MOD;
                if (seen.count(val))
                    for (auto& ii : seen[val])
                        if (dict[ii].substr(0, j) == dict[i].substr(0, j) && dict[ii].substr(j+1, n-j-1) == dict[i].substr(j+1, n-j-1)) return true;
                seen[val].push_back(i);
            }
            mult = (26 * mult) % MOD;
        }
        return false;
    }


    /*1557. Minimum Number of Vertices to Reach All Nodes (Medium)
    Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and
    an array edges where edges[i] = [fromi, toi] represents a directed edge
    from node fromi to node toi. Find the smallest set of vertices from which
    all nodes in the graph are reachable. It's guaranteed that a unique
    solution exists. Notice that you can return the vertices in any order.

    Example 1:
    Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
    Output: [0,3]
    Explanation: It's not possible to reach all the nodes from a single vertex.
                 From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5].
                 So we output [0,3].

    Example 2:
    Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]
    Output: [0,2,3]
    Explanation: Notice that vertices 0, 3 and 2 are not reachable from any
                 other node, so we must include them. Also any of these
                 vertices can reach nodes 1 and 4.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= edges.length <= min(10^5, n * (n - 1) / 2)
    * edges[i].length == 2
    * 0 <= fromi, toi < n
    * All pairs (fromi, toi) are distinct.*/

    vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {
        vector<int> indeg(n);
        for (auto& edge : edges) ++indeg[edge[1]];
        vector<int> ans;
        for (int u = 0; u < n; ++u)
            if (indeg[u] == 0) ans.push_back(u);
        return ans;
    }


    /*1567. Maximum Length of Subarray With Positive Product (Medium)
    Given an array of integers nums, find the maximum length of a subarray
    where the product of all its elements is positive. A subarray of an array
    is a consecutive sequence of zero or more values taken out of that array.
    Return the maximum length of a subarray with positive product.

    Example 1:
    Input: nums = [1,-2,-3,4]
    Output: 4
    Explanation: The array nums already has a positive product of 24.

    Example 2:
    Input: nums = [0,1,-2,-3,-4]
    Output: 3
    Explanation: The longest subarray with positive product is [1,-2,-3] which
                 has a product of 6. Notice that we cannot include 0 in the
                 subarray since that'll make the product 0 which is not
                 positive.

    Example 3:
    Input: nums = [-1,-2,-3,0,1]
    Output: 2
    Explanation: The longest subarray with positive product is [-1,-2] or
                 [-2,-3].

    Example 4:
    Input: nums = [-1,2]
    Output: 1

    Example 5:
    Input: nums = [1,2,3,5,-6,4,0,10]
    Output: 4

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    int getMaxLen(vector<int>& nums) {
        int ans = 0, pos = 0, neg = 0;
        for (auto& x : nums) {
            if (x == 0) pos = neg = 0;
            else if (x < 0) {
                swap(pos, neg);
                ++neg;
                pos = pos ? pos + 1 : 0;
            } else {
                ++pos;
                neg = neg ? neg + 1 : 0;
            }
            ans = max(ans, pos);
        }
        return ans;
    }


    /*1568. Minimum Number of Days to Disconnect Island (Hard)
    You are given an m x n binary grid grid where 1 represents land and 0
    represents water. An island is a maximal 4-directionally (horizontal or
    vertical) connected group of 1's. The grid is said to be connected if we
    have exactly one island, otherwise is said disconnected. In one day, we are
    allowed to change any single land cell (1) into a water cell (0). Return the
    minimum number of days to disconnect the grid.

    Example 1:
    Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
    Output: 2
    Explanation: We need at least 2 days to get a disconnected grid. Change land
                 grid[1][1] and grid[0][2] to water and get 2 disconnected
                 island.

    Example 2:
    Input: grid = [[1,1]]
    Output: 2
    Explanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0
                 islands.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 30
    * grid[i][j] is either 0 or 1.*/

    int minDays(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), dir[] = {-1, 0, 1, 0, -1};

        auto fn = [&](vector<vector<int>>& grid) {
            int ans = 0;
            vector<vector<bool>> seen(m, vector<bool>(n));
            for (int x = 0; x < m; ++x)
                for (int y = 0; y < n; ++y)
                    if (grid[x][y] && !seen[x][y]) {
                        ++ans;
                        seen[x][y] = true;
                        stack<pair<int, int>> stk; stk.emplace(x, y);
                        while (stk.size()) {
                            auto [i, j] = stk.top(); stk.pop();
                            for (int k = 0; k < 4; ++k) {
                                int ii = i + dir[k], jj = j + dir[k+1];
                                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] && !seen[ii][jj]) {
                                    seen[ii][jj] = true;
                                    stk.emplace(ii, jj);
                                }
                            }
                        }
                    }
            return ans;
        };

        if (fn(grid) != 1) return 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) {
                    grid[i][j] = 0;
                    if (fn(grid) != 1) return 1;
                    grid[i][j] = 1;
                }
        return 2;
    }


    /*1597. Build Binary Expression Tree From Infix Expression (Hard)
    A binary expression tree is a kind of binary tree used to represent
    arithmetic expressions. Each node of a binary expression tree has either
    zero or two children. Leaf nodes (nodes with 0 children) correspond to
    operands (numbers), and internal nodes (nodes with 2 children) correspond
    to the operators '+' (addition), '-' (subtraction), '*' (multiplication),
    and '/' (division). For each internal node with operator o, the infix
    expression it represents is (A o B), where A is the expression the left
    subtree represents and B is the expression the right subtree represents.
    You are given a string s, an infix expression containing operands, the
    operators described above, and parentheses '(' and ')'. Return any valid
    binary expression tree, whose in-order traversal reproduces s after
    omitting the parenthesis from it. Please note that order of operations
    applies in s. That is, expressions in parentheses are evaluated first, and
    multiplication and division happen before addition and subtraction.
    Operands must also appear in the same order in both s and the in-order
    traversal of the tree.

    Example 1:
    Input: s = "3*4-2*5"
    Output: [-,*,*,3,4,2,5]
    Explanation: The tree above is the only valid tree whose inorder traversal
                 produces s.

    Example 2:
    Input: s = "2-3/(5*2)+1"
    Output: [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2]
    Explanation: The inorder traversal of the tree above is 2-3/5*2+1 which is
                 the same as s without the parenthesis. The tree also produces
                 the correct result and its operands are in the same order as
                 they appear in s. The tree below is also a valid binary
                 expression tree with the same inorder traversal as s, but it
                 not a valid answer because it does not evaluate to the same
                 value. The third tree below is also not valid. Although it
                 produces the same result and is equivalent to the above trees,
                 its inorder traversal does not produce s and its operands are
                 not in the same order as s.

    Example 3:
    Input: s = "1+2+3+4+5"
    Output: [+,+,5,+,4,null,null,+,3,null,null,1,2]
    Explanation: The tree [+,+,5,+,+,null,null,1,2,3,4] is also one of many
                 other valid trees.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of digits and the characters '+', '-', '*', and '/'.
    * Operands in s are exactly 1 digit.
    * It is guaranteed that s is a valid expression.*/

    Node* expTree(string s) {
        s = "(" + s + ")";
        unordered_map<char, int> precedence = {{'(', 0}, {')', 1}, {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
        stack<char> ops;
        vector<char> postfix;
        for (auto& ch : s)
            if ('0' <= ch && ch <= '9') postfix.push_back(ch);
            else if (ch == '(') ops.push(ch);
            else {
                while (ops.size() && precedence[ops.top()] >= precedence[ch]) postfix.push_back(ops.top()), ops.pop();
                if (ch == ')') ops.pop();
                else ops.push(ch);
            }
        stack<Node*> stack;
        for (auto& ch : postfix) {
            Node* node = new Node(ch);
            if (ch < '0' || ch > '9') {
                node->right = stack.top(); stack.pop();
                node->left = stack.top(); stack.pop();
            }
            stack.push(node);
        }
        return stack.top();
    }


    /*1598. Crawler Log Folder (Easy)
    The Leetcode file system keeps a log each time some user performs a change
    folder operation. The operations are described below:
    * "../" : Move to the parent folder of the current folder. (If you are
      already in the main folder, remain in the same folder).
    * "./" : Remain in the same folder.
    * "x/" : Move to the child folder named x (This folder is guaranteed to
      always exist).
    You are given a list of strings logs where logs[i] is the operation
    performed by the user at the ith step. The file system starts in the main
    folder, then the operations in logs are performed. Return the minimum number
    of operations needed to go back to the main folder after the change folder
    operations.

    Example 1:
    Input: logs = ["d1/","d2/","../","d21/","./"]
    Output: 2
    Explanation: Use this change folder operation "../" 2 times and go back to
                 the main folder.

    Example 2:
    Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
    Output: 3

    Example 3:
    Input: logs = ["d1/","../","../","../"]
    Output: 0

    Constraints:
    * 1 <= logs.length <= 10^3
    * 2 <= logs[i].length <= 10
    * logs[i] contains lowercase English letters, digits, '.', and '/'.
    * logs[i] follows the format described in the statement.
    * Folder names consist of lowercase English letters and digits.*/

    int minOperations(vector<string>& logs) {
        int ans = 0;
        for (auto& log : logs)
            if (log == "./") continue;
            else if (log == "../") ans = max(0, --ans);
            else ++ans;
        return ans;
    }


    /*1609. Even Odd Tree (Medium)
    A binary tree is named Even-Odd if it meets the following conditions:
    * The root of the binary tree is at level index 0, its children are at
      level index 1, their children are at level index 2, etc.
    * For every even-indexed level, all nodes at the level have odd integer
      values in strictly increasing order (from left to right).
    * For every odd-indexed level, all nodes at the level have even integer
      values in strictly decreasing order (from left to right).
    Given the root of a binary tree, return true if the binary tree is Even-Odd,
    otherwise return false.

    Example 1:
    Input: root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
    Output: true
    Explanation: The node values on each level are:
                 Level 0: [1]
                 Level 1: [10,4]
                 Level 2: [3,7,9]
                 Level 3: [12,8,6,2]
                 Since levels 0 and 2 are all odd and increasing and levels 1
                 and 3 are all even and decreasing, the tree is Even-Odd.

    Example 2:
    Input: root = [5,4,2,3,3,7]
    Output: false
    Explanation: The node values on each level are:
                 Level 0: [5]
                 Level 1: [4,2]
                 Level 2: [3,3,7]
                 Node values in level 2 must be in strictly increasing order,
                 so the tree is not Even-Odd.

    Example 3:
    Input: root = [5,9,1,3,5,7]
    Output: false
    Explanation: Node values in the level 1 should be even integers.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 10^6*/

    bool isEvenOddTree(TreeNode* root) {
        queue<TreeNode*> q; q.push(root);
        for (int level = 0; q.size(); level ^= 1) {
            int prev = level ? INT_MAX : INT_MIN;
            for (int sz = q.size(); sz; --sz) {
                TreeNode* node = q.front(); q.pop();
                if ((node->val & 1) == level || !level && prev >= node->val || level && prev <= node->val) return false;
                prev = node->val;
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        return true;
    }


    /*1612. Check If Two Expression Trees are Equivalent (Medium)
    A binary expression tree is a kind of binary tree used to represent
    arithmetic expressions. Each node of a binary expression tree has either
    zero or two children. Leaf nodes (nodes with 0 children) correspond to
    operands (variables), and internal nodes (nodes with two children)
    correspond to the operators. In this problem, we only consider the '+'
    operator (i.e. addition). You are given the roots of two binary expression
    trees, root1 and root2. Return true if the two binary expression trees are
    equivalent. Otherwise, return false. Two binary expression trees are
    equivalent if they evaluate to the same value regardless of what the
    variables are set to.

    Follow up: What will you change in your solution if the tree also supports
               the '-' operator (i.e. subtraction)?

    Example 1:
    Input: root1 = [x], root2 = [x]
    Output: true

    Example 2:
    Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c]
    Output: true
    Explaination: a + (b + c) == (b + c) + a

    Example 3:
    Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d]
    Output: false
    Explaination: a + (b + c) != (b + d) + a

    Constraints:
    * The number of nodes in both trees are equal, odd and, in the range [1, 4999].
    * Node.val is '+' or a lower-case English letter.
    * It's guaranteed that the tree given is a valid binary expression tree.*/

    bool checkEquivalence(Node* root1, Node* root2) {
        unordered_map<char, int> freq;

        function<void(Node*, int)> fn = [&] (Node* x, int k) {
            if (x) {
                freq[x->val] += k;
                if (freq[x->val] == 0) freq.erase(x->val);
                fn(x->left, k);
                fn(x->right, k);
            }
        };

        fn(root1, 1);
        fn(root2, -1);
        return freq.empty();
    }


    /*1614. Maximum Nesting Depth of the Parentheses (Easy)
    A string is a valid parentheses string (denoted VPS) if it meets one of the
    following:
    * It is an empty string "", or a single character not equal to "(" or ")",
    * It can be written as AB (A concatenated with B), where A and B are VPS's,
      or
    * It can be written as (A), where A is a VPS.
    We can similarly define the nesting depth depth(S) of any VPS S as follows:
    * depth("") = 0
    * depth(C) = 0, where C is a string with a single character not equal to "("
      or ")".
    * depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
    * depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
    For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1,
    and 2), and ")(" and "(()" are not VPS's. Given a VPS represented as string
    s, return the nesting depth of s.

    Example 1:
    Input: s = "(1+(2*3)+((8)/4))+1"
    Output: 3
    Explanation: Digit 8 is inside of 3 nested parentheses in the string.

    Example 2:
    Input: s = "(1)+((2))+(((3)))"
    Output: 3

    Constraints:
    * 1 <= s.length <= 100
    * s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
    * It is guaranteed that parentheses expression s is a VPS.*/

    int maxDepth(string s) {
        int ans = 0, val = 0;
        for (auto& ch : s)
            if (ch == '(') ans = max(ans, ++val);
            else if (ch == ')') --val;
        return ans;
    }


    /*1629. Slowest Key (Easy)
    A newly designed keypad was tested, where a tester pressed a sequence of n
    keys, one at a time. You are given a string keysPressed of length n, where
    keysPressed[i] was the ith key pressed in the testing sequence, and a
    sorted list releaseTimes, where releaseTimes[i] was the time the ith key
    was released. Both arrays are 0-indexed. The 0th key was pressed at the
    time 0, and every subsequent key was pressed at the exact time the previous
    key was released. The tester wants to know the key of the keypress that had
    the longest duration. The ith keypress had a duration of
    releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration
    of releaseTimes[0]. Note that the same key could have been pressed multiple
    times during the test, and these multiple presses of the same key may not
    have had the same duration. Return the key of the keypress that had the
    longest duration. If there are multiple such keypresses, return the
    lexicographically largest key of the keypresses.

    Example 1:
    Input: releaseTimes = [9,29,49,50], keysPressed = "cbcd"
    Output: "c"
    Explanation: The keypresses were as follows:
                 Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).
                 Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).
                 Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).
                 Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).
                 The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.
                 'c' is lexicographically larger than 'b', so the answer is 'c'.

    Example 2:
    Input: releaseTimes = [12,23,36,46,62], keysPressed = "spuda"
    Output: "a"
    Explanation: The keypresses were as follows:
                 Keypress for 's' had a duration of 12.
                 Keypress for 'p' had a duration of 23 - 12 = 11.
                 Keypress for 'u' had a duration of 36 - 23 = 13.
                 Keypress for 'd' had a duration of 46 - 36 = 10.
                 Keypress for 'a' had a duration of 62 - 46 = 16.
                 The longest of these was the keypress for 'a' with duration 16.

    Constraints:
    * releaseTimes.length == n
    * keysPressed.length == n
    * 2 <= n <= 1000
    * 1 <= releaseTimes[i] <= 10^9
    * releaseTimes[i] < releaseTimes[i+1]
    * keysPressed contains only lowercase English letters.*/

    char slowestKey(vector<int>& releaseTimes, string keysPressed) {
        char ans = 'a';
        int most = 0;
        for (int i = 0; i < releaseTimes.size(); ++i) {
            int dur = i == 0 ? releaseTimes[i] : releaseTimes[i] - releaseTimes[i-1];
            if (dur > most || (dur == most && keysPressed[i] > ans)) {
                ans = keysPressed[i];
                most = dur;
            }
        }
        return ans;
    }


    /*1636. Sort Array by Increasing Frequency (Easy)
    Given an array of integers nums, sort the array in increasing order based on
    the frequency of the values. If multiple values have the same frequency,
    sort them in decreasing order. Return the sorted array.

    Example 1:
    Input: nums = [1,1,2,2,2,3]
    Output: [3,1,1,2,2,2]
    Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has
                 a frequency of 3.

    Example 2:
    Input: nums = [2,3,1,3,2]
    Output: [1,3,3,2,2]
    Explanation: '2' and '3' both have a frequency of 2, so they are sorted in
                 decreasing order.

    Example 3:
    Input: nums = [-1,1,-6,4,5,-6,1,4,1]
    Output: [5,-1,4,4,-6,-6,1,1,1]

    Constraints:
    * 1 <= nums.length <= 100
    * -100 <= nums[i] <= 100*/

    vector<int> frequencySort(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        sort(nums.begin(), nums.end(), [&](auto& x, auto& y) {
            return freq[x] != freq[y] ? freq[x] < freq[y] : x > y;
        });
        return nums;
    }


    /*1642. Furthest Building You Can Reach (Medium)
    You are given an integer array heights representing the heights of
    buildings, some bricks, and some ladders. You start your journey from
    building 0 and move to the next building by possibly using bricks or
    ladders. While moving from building i to building i+1 (0-indexed),
    * If the current building's height is greater than or equal to the next
      building's height, you do not need a ladder or bricks.
    * If the current building's height is less than the next building's height,
      you can either use one ladder or (h[i+1] - h[i]) bricks.
    Return the furthest building index (0-indexed) you can reach if you use the
    given ladders and bricks optimally.

    Example 1:
    Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
    Output: 4
    Explanation: Starting at building 0, you can follow these steps:
    - Go to building 1 without using ladders nor bricks since 4 >= 2.
    - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.
    - Go to building 3 without using ladders nor bricks since 7 >= 6.
    - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.
    It is impossible to go beyond building 4 because you do not have any more bricks or ladders.

    Example 2:
    Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2
    Output: 7

    Example 3:
    Input: heights = [14,3,19,3], bricks = 17, ladders = 0
    Output: 3

    Constraints:
    * 1 <= heights.length <= 10^5
    * 1 <= heights[i] <= 10^6
    * 0 <= bricks <= 10^9
    * 0 <= ladders <= heights.length*/

    int furthestBuilding(vector<int>& heights, int bricks, int ladders) {
        priority_queue<int> pq; // max heap

        for (int i = 1; i < heights.size(); ++i) {
            int diff = heights[i] - heights[i-1];
            if (diff > 0) {
                pq.push(diff);
                bricks -= diff;
                if (bricks < 0) {
                    if (ladders) {
                        bricks += pq.top();
                        pq.pop();
                        ladders -= 1;
                    } else return i-1;
                }
            }
        }
        return heights.size() - 1;
    }


    /*1653. Minimum Deletions to Make String Balanced (Medium)
    You are given a string s consisting only of characters 'a' and 'b'. You can
    delete any number of characters in s to make s balanced. s is balanced if
    there is no pair of indices (i,j) such that i < j and s[i] = 'b' and
    s[j]= 'a'. Return the minimum number of deletions needed to make s balanced.

    Example 1:
    Input: s = "aababbab"
    Output: 2
    Explanation: You can either:
                 - Delete the characters at 0-indexed positions 2 and 6
                   ("aababbab" -> "aaabbb"), or
                 - Delete the characters at 0-indexed positions 3 and 6
                   ("aababbab" -> "aabbbb").

    Example 2:
    Input: s = "bbaaaaabb"
    Output: 2
    Explanation: The only solution is to delete the first two characters.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is 'a' or 'b'.*/

    int minimumDeletions(string s) {
        int ans = 0, prefix = 0;
        for (auto& ch : s)
            if (ch == 'b') ++prefix;
            else ans = min(ans+1, prefix);
        return ans;
    }


    /*1672. Richest Customer Wealth (Easy)
    You are given an m x n integer grid accounts where accounts[i][j] is the
    amount of money the ith customer has in the jth bank. Return the wealth
    that the richest customer has. A customer's wealth is the amount of money
    they have in all their bank accounts. The richest customer is the customer
    that has the maximum wealth.

    Example 1:
    Input: accounts = [[1,2,3],[3,2,1]]
    Output: 6
    Explanation: 1st customer has wealth = 1 + 2 + 3 = 6
                 2nd customer has wealth = 3 + 2 + 1 = 6
                 Both customers are considered the richest with a wealth of 6
                 each, so return 6.

    Example 2:
    Input: accounts = [[1,5],[7,3],[3,5]]
    Output: 10
    Explanation: 1st customer has wealth = 6
                 2nd customer has wealth = 10
                 3rd customer has wealth = 8
                 The 2nd customer is the richest with a wealth of 10.

    Example 3:
    Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]
    Output: 17

    Constraints:
    * m == accounts.length
    * n == accounts[i].length
    * 1 <= m, n <= 50
    * 1 <= accounts[i][j] <= 100*/

    int maximumWealth(vector<vector<int>>& accounts) {
        int ans = 0;
        for (int i = 0; i < accounts.size(); ++i)
            ans = max(ans, accumulate(accounts[i].begin(), accounts[i].end(), 0));
        return ans;
    }


    /*1675. Minimize Deviation in Array (Hard)
    You are given an array nums of n positive integers. You can perform two
    types of operations on any element of the array any number of times:
    * If the element is even, divide it by 2.
      + For example, if the array is [1,2,3,4], then you can do this operation
        on the last element, and the array will be [1,2,3,2].
    * If the element is odd, multiply it by 2.
      + For example, if the array is [1,2,3,4], then you can do this operation
        on the first element, and the array will be [2,2,3,4].
    The deviation of the array is the maximum difference between any two
    elements in the array. Return the minimum deviation the array can have
    after performing some number of operations.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 1
    Explanation: You can transform the array to [1,2,3,2], then to [2,2,3,2],
                 then the deviation will be 3 - 2 = 1.

    Example 2:
    Input: nums = [4,1,5,20,3]
    Output: 3
    Explanation: You can transform the array after two operations to [4,2,5,5,3],
                 then the deviation will be 5 - 2 = 3.

    Example 3:
    Input: nums = [2,10,8]
    Output: 3

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int minimumDeviation(vector<int>& nums) {
        priority_queue<int> pq;
        int ans = INT_MAX, least = INT_MAX;
        for (auto& x : nums) {
            if (x&1) x *= 2;
            least = min(least, x);
            pq.push(x);
        }
        while ((pq.top()&1) == 0) {
            auto x = pq.top()/2; pq.pop();
            pq.push(x);
            least = min(least, x);
            ans = min(ans, pq.top() - least);
        }
        return ans;
    }


    /*1684. Count the Number of Consistent Strings (Easy)
    You are given a string allowed consisting of distinct characters and an
    array of strings words. A string is consistent if all characters in the
    string appear in the string allowed. Return the number of consistent strings
    in the array words.

    Example 1:
    Input: allowed = "ab", words = ["ad","bd","aaab","baa","badab"]
    Output: 2
    Explanation: Strings "aaab" and "baa" are consistent since they only contain
                 characters 'a' and 'b'.

    Example 2:
    Input: allowed = "abc", words = ["a","b","c","ab","ac","bc","abc"]
    Output: 7
    Explanation: All strings are consistent.

    Example 3:
    Input: allowed = "cad", words = ["cc","acd","b","ba","bac","bad","ac","d"]
    Output: 4
    Explanation: Strings "cc", "acd", "ac", and "d" are consistent.

    Constraints:
    * 1 <= words.length <= 10^4
    * 1 <= allowed.length <= 26
    * 1 <= words[i].length <= 10
    * The characters in allowed are distinct.
    * words[i] and allowed contain only lowercase English letters.*/

    int countConsistentStrings(string allowed, vector<string>& words) {
        int ans = 0;
        for (auto& word : words)
            if (all_of(word.begin(), word.end(), [&](auto ch) {
                return allowed.find(ch) != string::npos;
            })) ++ans;
        return ans;
    }


    /*1687. Delivering Boxes from Storage to Ports (Hard)
    You have the task of delivering some boxes from storage to their ports
    using only one ship. However, this ship has a limit on the number of boxes
    and the total weight that it can carry. You are given an array boxes, where
    boxes[i] = [portsi, weighti], and three integers portsCount, maxBoxes, and
    maxWeight.
    * portsi is the port where you need to deliver the ith box and weightsi is
      the weight of the ith box.
    * portsCount is the number of ports.
    * maxBoxes and maxWeight are the respective box and weight limits of the
      ship.
    The boxes need to be delivered in the order they are given. The ship will
    follow these steps:
    * The ship will take some number of boxes from the boxes queue, not
      violating the maxBoxes and maxWeight constraints.
    * For each loaded box in order, the ship will make a trip to the port the
      box needs to be delivered to and deliver it. If the ship is already at
      the correct port, no trip is needed, and the box can immediately be
      delivered.
    * The ship then makes a return trip to storage to take more boxes from the
      queue.
    The ship must end at storage after all the boxes have been delivered.
    Return the minimum number of trips the ship needs to make to deliver all
    boxes to their respective ports.

    Example 1:
    Input: boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
    Output: 4
    Explanation: The optimal strategy is as follows:
                 - The ship takes all the boxes in the queue, goes to port 1,
                   then port 2, then port 1 again, then returns to storage. 4
                   trips.
                 So the total number of trips is 4. Note that the first and
                 third boxes cannot be delivered together because the boxes
                 need to be delivered in order (i.e. the second box needs to be
                 delivered at port 2 before the third box).

    Example 2:
    Input: boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
    Output: 6
    Explanation: The optimal strategy is as follows:
                 - The ship takes the first box, goes to port 1, then returns
                   to storage. 2 trips.
                 - The ship takes the second, third and fourth boxes, goes to
                   port 3, then returns to storage. 2 trips.
                 - The ship takes the fifth box, goes to port 3, then returns
                   to storage. 2 trips.
                 So the total number of trips is 2 + 2 + 2 = 6.

    Example 3:
    Input: boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
    Output: 6
    Explanation: The optimal strategy is as follows:
                 - The ship takes the first and second boxes, goes to port 1,
                   then returns to storage. 2 trips.
                 - The ship takes the third and fourth boxes, goes to port 2,
                   then returns to storage. 2 trips.
                 - The ship takes the fifth and sixth boxes, goes to port 3,
                   then returns to storage. 2 trips.
                 So the total number of trips is 2 + 2 + 2 = 6.

    Example 4:
    Input: boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7
    Output: 14
    Explanation: The optimal strategy is as follows:
                 - The ship takes the first box, goes to port 2, then storage.
                   2 trips.
                 - The ship takes the second box, goes to port 2, then storage.
                   2 trips.
                 - The ship takes the third and fourth boxes, goes to port 3,
                   then storage. 2 trips.
                 - The ship takes the fifth box, goes to port 3, then storage.
                   2 trips.
                 - The ship takes the sixth and seventh boxes, goes to port 3,
                   then port 4, then storage. 3 trips.
                 - The ship takes the eighth and ninth boxes, goes to port 1,
                   then port 5, then storage. 3 trips.
                 So the total number of trips is 2 + 2 + 2 + 2 + 3 + 3 = 14.

    Constraints:
    * 1 <= boxes.length <= 10^5
    * 1 <= portsCount, maxBoxes, maxWeight <= 10^5
    * 1 <= portsi <= portsCount
    * 1 <= weightsi <= maxWeight*/

    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {
        int n = boxes.size();
        vector<int> dp(n+1, INT_MAX);
        dp[0] = 0;

        int trips = 2;
        for (int i = 0, ii = 0; i < n; ++i) {
            maxWeight -= boxes[i][1];
            if (i && boxes[i-1][0] != boxes[i][0]) ++trips;
            for (; maxBoxes < i - ii + 1 || maxWeight < 0 || (ii < i && dp[ii] == dp[ii+1]); ++ii) {
                maxWeight += boxes[ii][1];
                if (boxes[ii][0] != boxes[ii+1][0]) --trips;
            }
            dp[i+1] = dp[ii] + trips;
        }
        return dp.back();
    }


    /*1688. Count of Matches in Tournament (Easy)
    You are given an integer n, the number of teams in a tournament that has
    strange rules:
    * If the current number of teams is even, each team gets paired with
      another team. A total of n / 2 matches are played, and n / 2 teams
      advance to the next round.
    * If the current number of teams is odd, one team randomly advances in the
      tournament, and the rest gets paired. A total of (n - 1) / 2 matches are
      played, and (n - 1) / 2 + 1 teams advance to the next round.
    Return the number of matches played in the tournament until a winner is
    decided.

    Example 1:
    Input: n = 7
    Output: 6
    Explanation: Details of the tournament:
                 - 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
                 - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
                 - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared
                   the winner.
                 Total number of matches = 3 + 2 + 1 = 6.

    Example 2:
    Input: n = 14
    Output: 13
    Explanation: Details of the tournament:
                 - 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
                 - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
                 - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
                 - 4th Round: Teams = 2, Matches = 1, and 1 team is declared
                   the winner.
                 Total number of matches = 7 + 3 + 2 + 1 = 13.

    Constraints: 1 <= n <= 200*/

    int numberOfMatches(int n) {
        return n-1;
    }


    /*1689. Partitioning Into Minimum Number Of Deci-Binary Numbers (Medium)
    A decimal number is called deci-binary if each of its digits is either 0 or
    1 without any leading zeros. For example, 101 and 1100 are deci-binary,
    while 112 and 3001 are not. Given a string n that represents a positive
    decimal integer, return the minimum number of positive deci-binary numbers
    needed so that they sum up to n.

    Example 1:
    Input: n = "32"
    Output: 3
    Explanation: 10 + 11 + 11 = 32

    Example 2:
    Input: n = "82734"
    Output: 8

    Example 3:
    Input: n = "27346209830709182346"
    Output: 9

    Constraints:
    * 1 <= n.length <= 10^5
    * n consists of only digits.
    * n does not contain any leading zeros and represents a positive integer.*/

    int minPartitions(string n) {
        return *max_element(begin(n), end(n)) - '0';
    }


    /*1690. Stone Game VII (Medium)
    Alice and Bob take turns playing a game, with Alice starting first. There
    are n stones arranged in a row. On each player's turn, they can remove
    either the leftmost stone or the rightmost stone from the row and receive
    points equal to the sum of the remaining stones' values in the row. The
    winner is the one with the higher score when there are no stones left to
    remove. Bob found that he will always lose this game (poor Bob, he always
    loses), so he decided to minimize the score's difference. Alice's goal is
    to maximize the difference in the score. Given an array of integers stones
    where stones[i] represents the value of the ith stone from the left, return
    the difference in Alice and Bob's score if they both play optimally.

    Example 1:
    Input: stones = [5,3,1,4,2]
    Output: 6
    Explanation:
    - Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = [5,3,1,4].
    - Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = [3,1,4].
    - Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = [1,4].
    - Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = [4].
    - Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = [].
    The score difference is 18 - 12 = 6.

    Example 2:
    Input: stones = [7,90,5,1,100,10,10,2]
    Output: 122

    Constraints:
    * n == stones.length
    * 2 <= n <= 1000
    * 1 <= stones[i] <= 1000*/

    int stoneGameVII(vector<int>& stones) {
        vector<int> prefix = {0};
        for (auto& x : stones) prefix.push_back(prefix.back() + x);

        int n = size(stones);
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = n-1; i >= 0; --i) {
            for (int j = i+1; j < n; ++j) {
                dp[i][j] = max(prefix[j+1] - prefix[i+1] - dp[i+1][j], prefix[j] - prefix[i] - dp[i][j-1]);
            }
        }
        return dp[0][n-1];
    }


    /*1692. Count Ways to Distribute Candies (Hard)
    There are n unique candies (labeled 1 through n) and k bags. You are asked
    to distribute all the candies into the bags such that every bag has at
    least one candy. There can be multiple ways to distribute the candies. Two
    ways are considered different if the candies in one bag in the first way
    are not all in the same bag in the second way. The order of the bags and
    the order of the candies within each bag do not matter. For example, (1),
    (2,3) and (2), (1,3) are considered different because candies 2 and 3 in
    the bag (2,3) in the first way are not in the same bag in the second way
    (they are split between the bags (2) and (1,3)). However, (1), (2,3) and
    (3,2), (1) are considered the same because the candies in each bag are all
    in the same bags in both ways. Given two integers, n and k, return the
    number of different ways to distribute the candies. As the answer may be
    too large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, k = 2
    Output: 3
    Explanation: You can distribute 3 candies into 2 bags in 3 ways:
                 (1), (2,3)
                 (1,2), (3)
                 (1,3), (2)

    Example 2:
    Input: n = 4, k = 2
    Output: 7
    Explanation: You can distribute 4 candies into 2 bags in 7 ways:
                 (1), (2,3,4)
                 (1,2), (3,4)
                 (1,3), (2,4)
                 (1,4), (2,3)
                 (1,2,3), (4)
                 (1,2,4), (3)
                 (1,3,4), (2)

    Example 3:
    Input: n = 20, k = 5
    Output: 206085257
    Explanation: You can distribute 20 candies into 5 bags in 1881780996 ways.
                 1881780996 modulo 10^9 + 7 = 206085257.

    Constraints: 1 <= k <= n <= 1000*/

    int waysToDistribute(int n, int k) {
        vector<vector<long>> dp(n+1, vector<long>(k+2));
        dp[n][k] = 1;
        for (int i = n-1; i >= 0; --i)
            for (int j = k; j >= 0 && j >= k-n+i; --j)
                dp[i][j] = (j * dp[i+1][j] + dp[i+1][j+1]) % 1'000'000'007;
        return dp[0][0];
    }


    /*1695. Maximum Erasure Value (Medium)
    You are given an array of positive integers nums and want to erase a
    subarray containing unique elements. The score you get by erasing the
    subarray is equal to the sum of its elements. Return the maximum score you
    can get by erasing exactly one subarray. An array b is called to be a
    subarray of a if it forms a contiguous subsequence of a, that is, if it is
    equal to a[l],a[l+1],...,a[r] for some (l,r).

    Example 1:
    Input: nums = [4,2,4,5,6]
    Output: 17
    Explanation: The optimal subarray here is [2,4,5,6].

    Example 2:
    Input: nums = [5,2,1,2,5,2,1,2,5]
    Output: 8
    Explanation: The optimal subarray here is [5,2,1] or [1,2,5].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^4*/

    int maximumUniqueSubarray(vector<int>& nums) {
        unordered_map<int, int> freq;
        int ans = 0, val = 0, ii = 0;
        for (auto& x : nums) {
            val += x;
            ++freq[x];
            for (; freq[x] > 1; ++ii) {
                val -= nums[ii];
                --freq[nums[ii]];
            }
            ans = max(ans, val);
        }
        return ans;
    }


    /*1696. Jump Game VI (Medium)
    You are given a 0-indexed integer array nums and an integer k. You are
    initially standing at index 0. In one move, you can jump at most k steps
    forward without going outside the boundaries of the array. That is, you can
    jump from index i to any index in the range [i + 1, min(n - 1, i + k)]
    inclusive. You want to reach the last index of the array (index n - 1).
    Your score is the sum of all nums[j] for each index j you visited in the
    array. Return the maximum score you can get.

    Example 1:
    Input: nums = [1,-1,-2,4,-7,3], k = 2
    Output: 7
    Explanation: You can choose your jumps forming the subsequence [1,-1,4,3]
                 (underlined above). The sum is 7.

    Example 2:
    Input: nums = [10,-5,-2,4,0,3], k = 3
    Output: 17
    Explanation: You can choose your jumps forming the subsequence [10,4,3]
                 (underlined above). The sum is 17.

    Example 3:
    Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2
    Output: 0

    Constraints:
    * 1 <= nums.length, k <= 10^5
    * -10^4 <= nums[i] <= 10^4*/

    int maxResult(vector<int>& nums, int k) {
        deque<pair<int, int>> dq;
        int ans = 0;
        for (int i = size(nums)-1; i >= 0; --i) {
            while (size(dq) && dq.front().second - i > k) dq.pop_front();
            ans = nums[i];
            if (size(dq)) ans += dq.front().first;
            while (size(dq) && dq.back().first <= ans) dq.pop_back();
            dq.emplace_back(ans, i);
        }
        return ans;
    }


    /*1697. Checking Existence of Edge Length Limited Paths (Hard)
    An undirected graph of n nodes is defined by edgeList, where
    edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with
    distance disi. Note that there may be multiple edges between two nodes.
    Given an array queries, where queries[j] = [pj, qj, limitj], your task is
    to determine for each queries[j] whether there is a path between pj and qj
    such that each edge on the path has a distance strictly less than limitj .
    Return a boolean array answer, where answer.length == queries.length and
    the jth value of answer is true if there is a path for queries[j] is true,
    and false otherwise.

    Example 1:
    Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
    Output: [false,true]
    Explanation: The above figure shows the given graph. Note that there are
                 two overlapping edges between 0 and 1 with distances 2 and 16.
                 For the first query, between 0 and 1 there is no path where
                 each distance is less than 2, thus we return false for this
                 query. For the second query, there is a path (0 -> 1 -> 2) of
                 two edges with distances less than 5, thus we return true for
                 this query.

    Example 2:
    Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
    Output: [true,false]
    Exaplanation: The above figure shows the given graph.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= edgeList.length, queries.length <= 10^5
    * edgeList[i].length == 3
    * queries[j].length == 3
    * 0 <= ui, vi, pj, qj <= n - 1
    * ui != vi
    * pj != qj
    * 1 <= disi, limitj <= 10^9
    * There may be multiple edges between two nodes.*/

    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {
        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);

        function<int(int)> find = [&](int p) {
            if (p != parent[p])
                parent[p] = find(parent[p]);
            return parent[p];
        };

        vector<bool> ans(queries.size());
        sort(edgeList.begin(), edgeList.end(), [&](auto& lhs, auto& rhs) { return lhs[2] < rhs[2]; });
        for (int i = 0; i < queries.size(); ++i) queries[i].push_back(i);
        sort(queries.begin(), queries.end(), [&](auto& lhs, auto& rhs) { return lhs[2] < rhs[2]; });
        int ii = 0;
        for (auto& query : queries) {
            int p = query[0], q = query[1], w = query[2], i = query[3];
            for (; ii < edgeList.size() && edgeList[ii][2] < w; ++ii) {
                int uu = find(edgeList[ii][0]), vv = find(edgeList[ii][1]);
                if (uu != vv) parent[uu] = vv;
            }
            if (find(p) == find(q)) ans[i] = true;
        }
        return ans;
    }


    /*1700. Number of Students Unable to Eat Lunch (Easy)
    The school cafeteria offers circular and square sandwiches at lunch break,
    referred to by numbers 0 and 1 respectively. All students stand in a queue.
    Each student either prefers square or circular sandwiches. The number of
    sandwiches in the cafeteria is equal to the number of students. The
    sandwiches are placed in a stack. At each step:
    * If the student at the front of the queue prefers the sandwich on the top
      of the stack, they will take it and leave the queue.
    * Otherwise, they will leave it and go to the queue's end.
    This continues until none of the queue students want to take the top
    sandwich and are thus unable to eat. You are given two integer arrays
    students and sandwiches where sandwiches[i] is the type of the ith sandwich
    in the stack (i = 0 is the top of the stack) and students[j] is the
    preference of the jth student in the initial queue (j = 0 is the front of
    the queue). Return the number of students that are unable to eat.

    Example 1:
    Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
    Output: 0
    Explanation: - Front student leaves the top sandwich and returns to the end
                   of the line making students = [1,0,0,1].
                 - Front student leaves the top sandwich and returns to the end
                   of the line making students = [0,0,1,1].
                 - Front student takes the top sandwich and leaves the line
                   making students = [0,1,1] and sandwiches = [1,0,1].
                 - Front student leaves the top sandwich and returns to the end
                   of the line making students = [1,1,0].
                 - Front student takes the top sandwich and leaves the line
                   making students = [1,0] and sandwiches = [0,1].
                 - Front student leaves the top sandwich and returns to the end
                   of the line making students = [0,1].
                 - Front student takes the top sandwich and leaves the line
                   making students = [1] and sandwiches = [1].
                 - Front student takes the top sandwich and leaves the line
                   making students = [] and sandwiches = [].
                 Hence all students are able to eat.

    Example 2:
    Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
    Output: 3

    Constraints:
    * 1 <= students.length, sandwiches.length <= 100
    * students.length == sandwiches.length
    * sandwiches[i] is 0 or 1.
    * students[i] is 0 or 1.*/

    int countStudents(vector<int>& students, vector<int>& sandwiches) {
        int prefix = accumulate(students.begin(), students.end(), 0);
        for (int i = 0, n = sandwiches.size(); i < n; ++i) {
            if (sandwiches[i] && prefix == 0 || sandwiches[i] == 0 && prefix == n-i) return n-i;
            prefix -= sandwiches[i];
        }
        return 0;
    }


    /*1701. Average Waiting Time (Medium)
    There is a restaurant with a single chef. You are given an array customers,
    where customers[i] = [arrivali, timei]:
    * arrivali is the arrival time of the ith customer. The arrival times are
      sorted in non-decreasing order.
    * timei is the time needed to prepare the order of the ith customer.
    When a customer arrives, he gives the chef his order, and the chef starts
    preparing it once he is idle. The customer waits till the chef finishes
    preparing his order. The chef does not prepare food for more than one
    customer at a time. The chef prepares food for customers in the order they
    were given in the input. Return the average waiting time of all customers.
    Solutions within 10-5 from the actual answer are considered accepted.

    Example 1:
    Input: customers = [[1,2],[2,5],[4,3]]
    Output: 5.00000
    Explanation: 1) The first customer arrives at time 1, the chef takes his
                    order and starts preparing it immediately at time 1, and
                    finishes at time 3, so the waiting time of the first
                    customer is 3 - 1 = 2.
                 2) The second customer arrives at time 2, the chef takes his
                    order and starts preparing it at time 3, and finishes at
                    time 8, so the waiting time of the second customer is
                    8 - 2 = 6.
                 3) The third customer arrives at time 4, the chef takes his
                    order and starts preparing it at time 8, and finishes at
                    time 11, so the waiting time of the third customer is
                    11 - 4 = 7.
                 So the average waiting time = (2 + 6 + 7) / 3 = 5.

    Example 2:
    Input: customers = [[5,2],[5,4],[10,3],[20,1]]
    Output: 3.25000
    Explanation: 1) The first customer arrives at time 5, the chef takes his
                    order and starts preparing it immediately at time 5, and
                    finishes at time 7, so the waiting time of the first
                    customer is 7 - 5 = 2.
                 2) The second customer arrives at time 5, the chef takes his
                    order and starts preparing it at time 7, and finishes at
                    time 11, so the waiting time of the second customer is
                    11 - 5 = 6.
                 3) The third customer arrives at time 10, the chef takes his
                    order and starts preparing it at time 11, and finishes at
                    time 14, so the waiting time of the third customer is
                    14 - 10 = 4.
                 4) The fourth customer arrives at time 20, the chef takes his
                    order and starts preparing it immediately at time 20, and
                    finishes at time 21, so the waiting time of the fourth
                    customer is 21 - 20 = 1.
                 So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.

    Constraints:
    * 1 <= customers.length <= 10^5
    * 1 <= arrivali, timei <= 10^4
    * arrivali <= arrivali+1*/

    double averageWaitingTime(vector<vector<int>>& customers) {
        double ans = 0;
        int t = 0;
        for (auto& c : customers) {
            int arrival = c[0], time = c[1];
            t = max(t, arrival) + time;
            ans += t - arrival;
        }
        return ans/customers.size();
    }


    /*1706. Where Will the Ball Fall (Medium)
    You have a 2-D grid of size m x n representing a box, and you have n balls.
    The box is open on the top and bottom sides. Each cell in the box has a
    diagonal board spanning two corners of the cell that can redirect a ball to
    the right or to the left.
    * A board that redirects the ball to the right spans the top-left corner to
      the bottom-right corner and is represented in the grid as 1.
    * A board that redirects the ball to the left spans the top-right corner to
      the bottom-left corner and is represented in the grid as -1.
    We drop one ball at the top of each column of the box. Each ball can get
    stuck in the box or fall out of the bottom. A ball gets stuck if it hits a
    "V" shaped pattern between two boards or if a board redirects the ball into
    either wall of the box. Return an array answer of size n where answer[i] is
    the column that the ball falls out of at the bottom after dropping the ball
    from the ith column at the top, or -1 if the ball gets stuck in the box.

    Example 1:
    Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
    Output: [1,-1,-1,-1,-1]
    Explanation: This example is shown in the photo. Ball b0 is dropped at
                 column 0 and falls out of the box at column 1. Ball b1 is
                 dropped at column 1 and will get stuck in the box between
                 column 2 and 3 and row 1. Ball b2 is dropped at column 2 and
                 will get stuck on the box between column 2 and 3 and row 0.
                 Ball b3 is dropped at column 3 and will get stuck on the box
                 between column 2 and 3 and row 0. Ball b4 is dropped at column
                 4 and will get stuck on the box between column 2 and 3 and row
                 1.

    Example 2:
    Input: grid = [[-1]]
    Output: [-1]
    Explanation: The ball gets stuck against the left wall.

    Example 3:
    Input: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
    Output: [0,1,2,3,4,-1]

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 100
    * grid[i][j] is 1 or -1.*/

    vector<int> findBall(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> ans;
        for (int j = 0; j < n; ++j) {
            int k = j;
            for (int i = 0, kk = 0; i < m; ++i, k = kk) {
                kk = k + grid[i][k];
                if (kk < 0 || kk >= n || grid[i][kk] != grid[i][k]) { k = -1; break; }
            }
            ans.push_back(k);
        }
        return ans;
    }


    /*1710. Maximum Units on a Truck (Easy)
    You are assigned to put some amount of boxes onto one truck. You are given
    a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:
    * numberOfBoxesi is the number of boxes of type i.
    * numberOfUnitsPerBoxi is the number of units in each box of the type i.
    You are also given an integer truckSize, which is the maximum number of
    boxes that can be put on the truck. You can choose any boxes to put on the
    truck as long as the number of boxes does not exceed truckSize. Return the
    maximum total number of units that can be put on the truck.

    Example 1:
    Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
    Output: 8
    Explanation: There are:
                 - 1 box of the first type that contains 3 units.
                 - 2 boxes of the second type that contain 2 units each.
                 - 3 boxes of the third type that contain 1 unit each.
                 You can take all the boxes of the first and second types, and
                 one box of the third type. The total number of units will be
                 = (1 * 3) + (2 * 2) + (1 * 1) = 8.

    Example 2:
    Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
    Output: 91

    Constraints:
    * 1 <= boxTypes.length <= 1000
    * 1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000
    * 1 <= truckSize <= 10^6*/

    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {
        sort(begin(boxTypes), end(boxTypes), [](auto& lhs, auto& rhs) { return lhs[1] > rhs[1]; });
        int ans = 0;
        for (auto& boxType : boxTypes) {
            auto boxes = boxType[0], units = boxType[1];
            boxes = min(boxes, truckSize);
            ans += boxes * units;
            truckSize -= boxes;
        }
        return ans;
    }


    /*1714. Sum Of Special Evenly-Spaced Elements In Array (Hard)
    You are given a 0-indexed integer array nums consisting of n non-negative
    integers. You are also given an array queries, where queries[i] = [xi, yi].
    The answer to the ith query is the sum of all nums[j] where xi <= j < n
    and (j - xi) is divisible by yi. Return an array answer where
    answer.length == queries.length and answer[i] is the answer to the ith
    query modulo 10^9 + 7.

    Example 1:
    Input: nums = [0,1,2,3,4,5,6,7], queries = [[0,3],[5,1],[4,2]]
    Output: [9,18,10]
    Explanation: The answers of the queries are as follows:
                 1) The j indices that satisfy this query are 0, 3, and 6.
                    nums[0] + nums[3] + nums[6] = 9
                 2) The j indices that satisfy this query are 5, 6, and 7.
                    nums[5] + nums[6] + nums[7] = 18
                 3) The j indices that satisfy this query are 4 and 6.
                    nums[4] + nums[6] = 10

    Example 2:
    Input: nums = [100,200,101,201,102,202,103,203], queries = [[0,7]]
    Output: [303]

    Constraints:
    * n == nums.length
    * 1 <= n <= 5 * 10^4
    * 0 <= nums[i] <= 10^9
    * 1 <= queries.length <= 1.5 * 10^5
    * 0 <= xi < n
    * 1 <= yi <= 5 * 10^4*/

    vector<int> solve(vector<int>& nums, vector<vector<int>>& queries) {
        const int mod = 1'000'000'007;
        int n = nums.size(), r = sqrt(n);
        vector<vector<long>> dp(n, vector<long>(r));
        for (int i = n-1; i >= 0; --i)
            for (int j = 0; j < r; ++j) {
                dp[i][j] = nums[i];
                if (i+j < n) dp[i][j] = (dp[i][j] + dp[i+j][j]) % mod;
            }
        vector<int> ans;
        for (auto& q : queries) {
            int x = q[0], y = q[1];
            if (y < r) ans.push_back(dp[x][y]);
            else {
                long val = 0;
                for (int j = x; j < n; j += y) val = (val + nums[j]) % mod;
                ans.push_back(val);
            }
        }
        return ans;
    }


    /*1717. Maximum Score From Removing Substrings (Medium）
    You are given a string s and two integers x and y. You can perform two types
    of operations any number of times.
    * Remove substring "ab" and gain x points.
      + For example, when removing "ab" from "cabxbae" it becomes "cxbae".
    * Remove substring "ba" and gain y points.
      + For example, when removing "ba" from "cabxbae" it becomes "cabxe".
    Return the maximum points you can gain after applying the above operations
    on s.

    Example 1:
    Input: s = "cdbcbbaaabab", x = 4, y = 5
    Output: 19
    Explanation: - Remove the "ba" underlined in "cdbcbbaaabab". Now, s =
                   "cdbcbbaaab" and 5 points are added to the score.
                 - Remove the "ab" underlined in "cdbcbbaaab". Now, s =
                   "cdbcbbaa" and 4 points are added to the score.
                 - Remove the "ba" underlined in "cdbcbbaa". Now, s = "cdbcba"
                   and 5 points are added to the score.
                 - Remove the "ba" underlined in "cdbcba". Now, s = "cdbc" and 5
                   points are added to the score.
                 Total score = 5 + 4 + 5 + 5 = 19.

    Example 2:
    Input: s = "aabbaaxybbaabb", x = 5, y = 4
    Output: 20

    Constraints:
    * 1 <= s.length <= 10^5
    * 1 <= x, y <= 10^4
    * s consists of lowercase English letters.*/

    int maximumGain(string s, int x, int y) {
        char a = 'a', b = 'b';
        if (x < y) {
            swap(x, y);
            swap(a, b);
        }
        int ans = 0, ca = 0, cb = 0;
        for (auto& ch : s)
            if (ch != 'a' && ch != 'b') {
                ans += min(ca, cb)*y;
                ca = cb = 0;
            } else if (ch == b) {
                if (ca) {
                    --ca;
                    ans += x;
                } else ++cb;
            } else ++ca;
        return ans + min(ca, cb)*y;
    }


    /*1735. Count Ways to Make Array With Product (Hard)
    You are given a 2D integer array, queries. For each queries[i], where
    queries[i] = [ni, ki], find the number of different ways you can place
    positive integers into an array of size ni such that the product of the
    integers is ki. As the number of ways may be too large, the answer to the
    ith query is the number of ways modulo 10^9 + 7. Return an integer array
    answer where answer.length == queries.length, and answer[i] is the answer
    to the ith query.

    Example 1:
    Input: queries = [[2,6],[5,1],[73,660]]
    Output: [4,1,50734910]
    Explanation: Each query is independent.
                 [2,6]: There are 4 ways to fill an array of size 2 that
                        multiply to 6: [1,6], [2,3], [3,2], [6,1].
                 [5,1]: There is 1 way to fill an array of size 5 that multiply
                        to 1: [1,1,1,1,1].
                 [73,660]: There are 1050734917 ways to fill an array of size
                           73 that multiply to 660.
                           1050734917 modulo 10^9 + 7 = 50734910.

    Example 2:
    Input: queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]
    Output: [1,2,3,10,5]

    Constraints:
    1 <= queries.length <= 10^4
    1 <= ni, ki <= 10^4*/

    vector<int> waysToFillArray(vector<vector<int>>& queries) {
        const int MOD = 1'000'000'007;
        vector<int> spf(10001);
        iota(spf.begin(), spf.end(), 0);
        for (int x = 4; x <= 10000; x += 2) spf[x] = 2;
        for (int x = 3; x <= sqrt(10000); x += 2)
            if (spf[x] == x)
                for (int xx = x*x; xx <= 10000; xx += x)
                    spf[xx] = min(spf[xx], x);
        vector<long> fact(20000), ifact(20000), inv(20000);
        inv[1] = 1;
        fact[0] = ifact[0] = 1;
        for (int x = 1; x < 20000; ++x) {
            if (x >= 2) inv[x] = MOD - MOD/x * inv[MOD % x] % MOD;
            fact[x] = fact[x-1] * x % MOD;
            ifact[x] = ifact[x-1] * inv[x] % MOD;
        }
        vector<int> ans;
        for (auto& q : queries) {
            unordered_map<int, int> freq;
            for (int k = q[1]; k > 1; k /= spf[k]) ++freq[spf[k]];
            long val = 1;
            for (auto& [_, v] : freq) {
                val = val * fact[q[0]+v-1] % MOD;
                val = val * ifact[q[0]-1] % MOD;
                val = val * ifact[v] % MOD;
            }
            ans.push_back(val);
        }
        return ans;
    }


    /*1748. Sum of Unique Elements (Easy)
    You are given an integer array nums. The unique elements of an array are
    the elements that appear exactly once in the array. Return the sum of all
    the unique elements of nums.

    Example 1:
    Input: nums = [1,2,3,2]
    Output: 4
    Explanation: The unique elements are [1,3], and the sum is 4.

    Example 2:
    Input: nums = [1,1,1,1,1]
    Output: 0
    Explanation: There are no unique elements, and the sum is 0.

    Example 3:
    Input: nums = [1,2,3,4,5]
    Output: 15
    Explanation: The unique elements are [1,2,3,4,5], and the sum is 15.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100*/

    int sumOfUnique(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        int ans = 0;
        for (auto& [k, v] : freq)
            if (v == 1) ans += k;
        return ans;
    }


    /*1750. Minimum Length of String After Deleting Similar Ends (Medium)
    Given a string s consisting only of characters 'a', 'b', and 'c'. You are
    asked to apply the following algorithm on the string any number of times:
    * Pick a non-empty prefix from the string s where all the characters in the
      prefix are equal.
    * Pick a non-empty suffix from the string s where all the characters in this
      suffix are equal.
    * The prefix and the suffix should not intersect at any index.
    * The characters from the prefix and suffix must be the same.
    Delete both the prefix and the suffix. Return the minimum length of s after
    performing the above operation any number of times (possibly zero times).

    Example 1:
    Input: s = "ca"
    Output: 2
    Explanation: You can't remove any characters, so the string stays as is.

    Example 2:
    Input: s = "cabaabac"
    Output: 0
    Explanation: An optimal sequence of operations is:
                 - Take prefix = "c" and suffix = "c" and remove them,
                   s = "abaaba".
                 - Take prefix = "a" and suffix = "a" and remove them,
                   s = "baab".
                 - Take prefix = "b" and suffix = "b" and remove them, s = "aa".
                 - Take prefix = "a" and suffix = "a" and remove them, s = "".

    Example 3:
    Input: s = "aabccabba"
    Output: 3
    Explanation: An optimal sequence of operations is:
                 - Take prefix = "aa" and suffix = "a" and remove them,
                   s = "bccabb".
                 - Take prefix = "b" and suffix = "bb" and remove them,
                   s = "cca".

    Constraints:
    * 1 <= s.length <= 10^5
    * s only consists of characters 'a', 'b', and 'c'.*/

    int minimumLength(string s) {
        int lo = 0, hi = s.size()-1;
        while (lo < hi && s[lo] == s[hi]) {
            char ch = s[lo];
            for (; lo <= hi && s[lo] == ch; ++lo);
            for (; lo <= hi && s[hi] == ch; --hi);
        }
        return hi - lo + 1;
    }


    /*1763. Longest Nice Substring (Easy)
    A string s is nice if, for every letter of the alphabet that s contains, it
    appears both in uppercase and lowercase. For example, "abABB" is nice
    because 'A' and 'a' appear, and 'B' and 'b' appear. However, "abA" is not
    because 'b' appears, but 'B' does not. Given a string s, return the longest
    substring of s that is nice. If there are multiple, return the substring of
    the earliest occurrence. If there are none, return an empty string.

    Example 1:
    Input: s = "YazaAay"
    Output: "aAa"
    Explanation: "aAa" is a nice string because 'A/a' is the only letter of the
                 alphabet in s, and both 'A' and 'a' appear. "aAa" is the
                 longest nice substring.

    Example 2:
    Input: s = "Bb"
    Output: "Bb"
    Explanation: "Bb" is a nice string because both 'B' and 'b' appear. The
                 whole string is a substring.

    Example 3:
    Input: s = "c"
    Output: ""
    Explanation: There are no nice substrings.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of uppercase and lowercase English letters.*/

    string longestNiceSubstring(string s) {
        if (s.size()) {
            unordered_set<char> ss(s.begin(), s.end());
            for (int i = 0; i < s.size(); ++i)
                if (!ss.count(s[i]^32)) {
                    string cand0 = longestNiceSubstring(s.substr(0, i)), cand1 = longestNiceSubstring(s.substr(i+1));
                    return cand0.size() >= cand1.size() ? cand0 : cand1;
                }
        }
        return s;
    }


    /*1770. Maximum Score from Performing Multiplication Operations (Medium)
    You are given two integer arrays nums and multipliers of size n and m
    respectively, where n >= m. The arrays are 1-indexed. You begin with a
    score of 0. You want to perform exactly m operations. On the ith operation
    (1-indexed), you will:
    * Choose one integer x from either the start or the end of the array nums.
    * Add multipliers[i] * x to your score.
    * Remove x from the array nums.
    Return the maximum score after performing m operations.

    Example 1:
    Input: nums = [1,2,3], multipliers = [3,2,1]
    Output: 14
    Explanation: An optimal solution is as follows:
                 - Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.
                 - Choose from the end, [1,2], adding 2 * 2 = 4 to the score.
                 - Choose from the end, [1], adding 1 * 1 = 1 to the score.
                 The total score is 9 + 4 + 1 = 14.

    Example 2:
    Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
    Output: 102
    Explanation: An optimal solution is as follows:
                 - Choose from the start, [-5,-3,-3,-2,7,1], adding
                   -5 * -10 = 50 to the score.
                 - Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15
                   to the score.
                 - Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to
                   the score.
                 - Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.
                 - Choose from the end, [-2,7], adding 7 * 6 = 42 to the score.
                 The total score is 50 + 15 - 9 + 4 + 42 = 102.

    Constraints:
    * n == nums.length
    * m == multipliers.length
    * 1 <= m <= 10^3
    * m <= n <= 10^5
    * -1000 <= nums[i], multipliers[i] <= 1000*/

    int maximumScore(vector<int>& nums, vector<int>& multipliers) {
        int m = multipliers.size(), n = nums.size();
        vector<vector<long>> dp(m+1, vector<long>(m));
        for (int i = m-1; i >= 0; --i)
            for (int j = i; j < m; ++j) {
                int k = i+m-j-1;
                dp[i][j] = (long) nums[i]*multipliers[k] + dp[i+1][j];
                if (j) dp[i][j] = max(dp[i][j], (long) nums[j-m+n]*multipliers[k]+dp[i][j-1]);
            }
        return dp[0].back();
    }


    /*1772. Sort Features by Popularity (Medium)
    You are given a string array features where features[i] is a single word
    that represents the name of a feature of the latest product you are working
    on. You have made a survey where users have reported which features they
    like. You are given a string array responses, where each responses[i] is a
    string containing space-separated words. The popularity of a feature is the
    number of responses[i] that contain the feature. You want to sort the
    features in non-increasing order by their popularity. If two features have
    the same popularity, order them by their original index in features. Notice
    that one response could contain the same feature multiple times; this
    feature is only counted once in its popularity. Return the features in
    sorted order.

    Example 1:
    Input: features = ["cooler","lock","touch"],
           responses = ["i like cooler cooler","lock touch cool","locker like touch"]
    Output: ["touch","cooler","lock"]
    Explanation: appearances("cooler") = 1, appearances("lock") = 1,
                 appearances("touch") = 2. Since "cooler" and "lock" both had 1
                 appearance, "cooler" comes first because "cooler" came first
                 in the features array.

    Example 2:
    Input: features = ["a","aa","b","c"], responses = ["a","a aa","a a a a a","b a"]
    Output: ["a","aa","b","c"]

    Constraints:
    * 1 <= features.length <= 10^4
    * 1 <= features[i].length <= 10
    * features contains no duplicates.
    * features[i] consists of lowercase letters.
    * 1 <= responses.length <= 10^2
    * 1 <= responses[i].length <= 10^3
    * responses[i] consists of lowercase letters and spaces.
    * responses[i] contains no two consecutive spaces.
    * responses[i] has no leading or trailing spaces.*/

    vector<string> sortFeatures(vector<string>& features, vector<string>& responses) {
        unordered_map<string, int> freq;

        for (auto& response : responses) {
            istringstream iss(response);
            string buf;
            unordered_set<string> words;
            while (iss >> buf) words.insert(buf);

            for (auto& feature : features)
                if (words.count(feature)) freq[feature]++;
        }

        stable_sort(features.begin(), features.end(), [&](auto& lhs, auto& rhs) { return freq[lhs] > freq[rhs]; } );
        return features;
    }


    /*1778. Shortest Path in a Hidden Grid (Medium)
    This is an interactive problem. There is a robot in a hidden grid, and you
    are trying to get it from its starting cell to the target cell in this grid.
    The grid is of size m x n, and each cell in the grid is either empty or
    blocked. It is guaranteed that the starting cell and the target cell are
    different, and neither of them is blocked. You want to find the minimum
    distance to the target cell. However, you do not know the grid's dimensions,
    the starting cell, nor the target cell. You are only allowed to ask queries
    to the GridMaster object. Thr GridMaster class has the following functions:
    * boolean canMove(char direction) Returns true if the robot can move in
      that direction. Otherwise, it returns false.
    * void move(char direction) Moves the robot in that direction. If this move
      would move the robot to a blocked cell or off the grid, the move will be
      ignored, and the robot will remain in the same position.
    * boolean isTarget() Returns true if the robot is currently on the target
      cell. Otherwise, it returns false.
    Note that direction in the above functions should be a character from
    {'U','D','L','R'}, representing the directions up, down, left, and right,
    respectively. Return the minimum distance between the robot's initial
    starting cell and the target cell. If there is no valid path between the
    cells, return -1.

    Custom testing:
    The test input is read as a 2D matrix grid of size m x n where:
    * grid[i][j] == -1 indicates that the robot is in cell (i, j) (the starting
      cell).
    * grid[i][j] == 0 indicates that the cell (i, j) is blocked.
    * grid[i][j] == 1 indicates that the cell (i, j) is empty.
    * grid[i][j] == 2 indicates that the cell (i, j) is the target cell.
    There is exactly one -1 and 2 in grid. Remember that you will not have this
    information in your code.

    Example 1:
    Input: grid = [[1,2],[-1,0]]
    Output: 2
    Explanation: One possible interaction is described below:
                 The robot is initially standing on cell (1, 0), denoted by the
                 -1.
                 - master.canMove('U') returns true.
                 - master.canMove('D') returns false.
                 - master.canMove('L') returns false.
                 - master.canMove('R') returns false.
                 - master.move('U') moves the robot to the cell (0, 0).
                 - master.isTarget() returns false.
                 - master.canMove('U') returns false.
                 - master.canMove('D') returns true.
                 - master.canMove('L') returns false.
                 - master.canMove('R') returns true.
                 - master.move('R') moves the robot to the cell (0, 1).
                 - master.isTarget() returns true.
                 We now know that the target is the cell (0, 1), and the
                 shortest path to the target cell is 2.

    Example 2:
    Input: grid = [[0,0,-1],[1,1,1],[2,0,0]]
    Output: 4
    Explanation: The minimum distance between the robot and the target cell is
                 4.

    Example 3:
    Input: grid = [[-1,0],[0,2]]
    Output: -1
    Explanation: There is no path from the robot to the target cell.

    Constraints:
    * 1 <= n, m <= 500
    * m == grid.length
    * n == grid[i].length
    * grid[i][j] is either -1, 0, 1, or 2.
    * There is exactly one -1 in grid.
    * There is exactly one 2 in grid.*/

    int findShortestPath(GridMaster &master) {
        int sz = 1002, i0 = sz/2, j0 = sz/2, dir[5] = {-1, 0, 1, 0, -1};
        string s = "LURD";
        vector<vector<int>> grid(sz, vector<int>(sz, 0));

        function<void(int, int)> dfs = [&](int i, int j) {
            grid[i][j] = 1;
            if (master.isTarget()) grid[i][j] = 2;
            for (int k = 0; k < 4; ++k) {
                if (master.canMove(s[k])) {
                    int di = dir[k], dj = dir[k+1], ii = i + di, jj = j + dj;
                    if (!grid[ii][jj]) {
                        master.move(s[k]);
                        dfs(ii, jj);
                        master.move(s[(k+2) % 4]);
                    }
                }
            }
        };

        dfs(i0, j0);
        int ans = 0;
        vector<vector<bool>> seen(sz, vector<bool>(sz));
        queue<pair<int, int>> q; q.emplace(i0, j0);
        while (q.size()) {
            for (int sz = q.size(); sz; --sz) {
                auto [i, j] = q.front(); q.pop();
                if (grid[i][j] == 2) return ans;
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (grid[ii][jj] && !seen[ii][jj]) {
                        seen[ii][jj] = true;
                        q.emplace(ii, jj);
                    }
                }
            }
            ++ans;
        }
        return -1;
    }


    /*1788. Maximize the Beauty of the Garden (Hard)
    There is a garden of n flowers, and each flower has an integer beauty value.
    The flowers are arranged in a line. You are given an integer array flowers
    of size n and each flowers[i] represents the beauty of the ith flower. A
    garden is valid if it meets these conditions:
    * The garden has at least two flowers.
    * The first and the last flower of the garden have the same beauty value.
    As the appointed gardener, you have the ability to remove any (possibly
    none) flowers from the garden. You want to remove flowers in a way that
    makes the remaining garden valid. The beauty of the garden is the sum of
    the beauty of all the remaining flowers. Return the maximum possible beauty
    of some valid garden after you have removed any (possibly none) flowers.

    Example 1:
    Input: flowers = [1,2,3,1,2]
    Output: 8
    Explanation: You can produce the valid garden [2,3,1,2] to have a total
                 beauty of 2 + 3 + 1 + 2 = 8.

    Example 2:
    Input: flowers = [100,1,1,-3,1]
    Output: 3
    Explanation: You can produce the valid garden [1,1,1] to have a total
                 beauty of 1 + 1 + 1 = 3.

    Example 3:
    Input: flowers = [-1,-2,0,-1]
    Output: -2
    Explanation: You can produce the valid garden [-1,-1] to have a total
                 beauty of -1 + -1 = -2.

    Constraints:
    * 2 <= flowers.length <= 10^5
    * -10^4 <= flowers[i] <= 10^4
    * It is possible to create a valid garden by removing some (possibly none)
      flowers.*/

    int maximumBeauty(vector<int>& flowers) {
        int ans = INT_MIN, prefix = 0;
        unordered_map<int, int> seen;
        for (auto& x : flowers) {
            prefix += max(0, x);
            if (seen.count(x)) {
                int cand = prefix - seen[x];
                if (x < 0) cand += 2*x;
                ans = max(ans, cand);
            } else seen[x] = prefix - max(0, x);
        }
        return ans;
    }


    /*1790. Check if One String Swap Can Make Strings Equal (Easy)
    You are given two strings s1 and s2 of equal length. A string swap is an
    operation where you choose two indices in a string (not necessarily
    different) and swap the characters at these indices. Return true if it is
    possible to make both strings equal by performing at most one string swap
    on exactly one of the strings. Otherwise, return false.

    Example 1:
    Input: s1 = "bank", s2 = "kanb"
    Output: true
    Explanation: For example, swap the first character with the last character
                 of s2 to make "bank".

    Example 2:
    Input: s1 = "attack", s2 = "defend"
    Output: false
    Explanation: It is impossible to make them equal with one string swap.

    Example 3:
    Input: s1 = "kelb", s2 = "kelb"
    Output: true
    Explanation: The two strings are already equal, so no string swap operation is required.

    Example 4:
    Input: s1 = "abcd", s2 = "dcba"
    Output: false

    Constraints:
    * 1 <= s1.length, s2.length <= 100
    * s1.length == s2.length
    * s1 and s2 consist of only lowercase English letters.*/

    bool areAlmostEqual(string s1, string s2) {
        vector<int> diff;
        for (int i = 0; i < size(s1); ++i)
            if (s1[i] != s2[i]) diff.push_back(i);
        return size(diff) == 0 || (size(diff) == 2 && s1[diff[0]] == s2[diff[1]] && s1[diff[1]] == s2[diff[0]]);
    }


    /*1791. Find Center of Star Graph (Medium)
    There is an undirected star graph consisting of n nodes labeled from 1 to n.
    A star graph is a graph where there is one center node and exactly n - 1
    edges that connect the center node with every other node. You are given a
    2D integer array edges where each edges[i] = [ui, vi] indicates that there
    is an edge between the nodes ui and vi. Return the center of the given star
    graph.

    Example 1:
    Input: edges = [[1,2],[2,3],[4,2]]
    Output: 2
    Explanation: As shown in the figure above, node 2 is connected to every
                 other node, so 2 is the center.

    Example 2:
    Input: edges = [[1,2],[5,1],[1,3],[1,4]]
    Output: 1

    Constraints:
    * 3 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 1 <= ui, vi <= n
    * ui != vi
    * The given edges represent a valid star graph.*/

    int findCenter(vector<vector<int>>& edges) {
        return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] ? edges[0][0] : edges[0][1];
    }


    /*1792. Maximum Average Pass Ratio (Medium)
    There is a school that has classes of students and each class will be
    having a final exam. You are given a 2D integer array classes, where
    classes[i] = [passi, totali]. You know beforehand that in the ith class,
    there are totali total students, but only passi number of students will
    pass the exam. You are also given an integer extraStudents. There are
    another extraStudents brilliant students that are guaranteed to pass the
    exam of any class they are assigned to. You want to assign each of the
    extraStudents students to a class in a way that maximizes the average pass
    ratio across all the classes. The pass ratio of a class is equal to the
    number of students of the class that will pass the exam divided by the
    total number of students of the class. The average pass ratio is the sum of
    pass ratios of all the classes divided by the number of the classes. Return
    the maximum possible average pass ratio after assigning the extraStudents
    students. Answers within 10-5 of the actual answer will be accepted.

    Example 1:
    Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2
    Output: 0.78333
    Explanation: You can assign the two extra students to the first class. The
                 average pass ratio will be equal to
                 (3/4 + 3/5 + 2/2) / 3 = 0.78333.

    Example 2:
    Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4
    Output: 0.53485

    Constraints:
    * 1 <= classes.length <= 10^5
    * classes[i].length == 2
    * 1 <= passi <= totali <= 10^5
    * 1 <= extraStudents <= 10^5*/

    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
        auto diff = [](int pass, int total) { return (double)(pass+1)/(total+1) - (double)pass/total; };

        double ans = 0;
        priority_queue<pair<double, array<int,2>>> pq;
        for (auto& cls : classes) {
            ans += (double) cls[0]/cls[1];
            pq.push({diff(cls[0], cls[1]), {cls[0], cls[1]}});
        }

        while (extraStudents--) {
            auto [chg, elem] = pq.top(); pq.pop();
            ans += chg;
            pq.push({diff(elem[0]+1, elem[1]+1), {elem[0]+1, elem[1]+1}});
        }

        return ans/size(classes);
    }


    /*1793. Maximum Score of a Good Subarray (Hard)
    You are given an array of integers nums (0-indexed) and an integer k. The
    score of a subarray (i, j) is defined as

    min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1).

    A good subarray is a subarray where i <= k <= j. Return the maximum
    possible score of a good subarray.

    Example 1:
    Input: nums = [1,4,3,7,4,5], k = 3
    Output: 15
    Explanation: The optimal subarray is (1, 5) with a score of
                 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15.

    Example 2:
    Input: nums = [5,5,4,5,4,1,1,1], k = 0
    Output: 20
    Explanation: The optimal subarray is (0, 4) with a score of
                 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 2 * 10^4
    * 0 <= k < nums.length*/

    int maximumScore(vector<int>& nums, int k) {
        int i = k, j = k, ans = nums[k], val = nums[k]; ;
        while (0 <= i-1 || j+1 < size(nums)) {
            if (j+1 == size(nums) || (0 < i && nums[i-1] > nums[j+1]))
                val = min(val, nums[--i]);
            else
                val = min(val, nums[++j]);
            ans = max(ans, val * (j-i+1));
        }
        return ans;
    }


    /*1794. Count Pairs of Equal Substrings With Minimum Difference (Medium)
    You are given two strings firstString and secondString that are 0-indexed
    and consist only of lowercase English letters. Count the number of index
    quadruples (i,j,a,b) that satisfy the following conditions:
    * 0 <= i <= j < firstString.length
    * 0 <= a <= b < secondString.length
    * The substring of firstString that starts at the ith character and ends at
      the jth character (inclusive) is equal to the substring of secondString
      that starts at the ath character and ends at the bth character (inclusive).
    * j - a is the minimum possible value among all quadruples that satisfy the
      previous conditions.
    Return the number of such quadruples.

    Example 1:
    Input: firstString = "abcd", secondString = "bccda"
    Output: 1
    Explanation: The quadruple (0,0,4,4) is the only one that satisfies all the
                 conditions and minimizes j - a.

    Example 2:
    Input: firstString = "ab", secondString = "cd"
    Output: 0
    Explanation: There are no quadruples satisfying all the conditions.

    Constraints:
    * 1 <= firstString.length, secondString.length <= 2 * 10^5
    * Both strings consist only of lowercase English letters.*/

    int countQuadruples(string firstString, string secondString) {
        unordered_map<char, int> prefix, suffix;
        for (int i = firstString.size()-1; i >= 0; --i) prefix[firstString[i]] = i;
        for (int i = 0; i < secondString.size(); ++i) suffix[secondString[i]] = i;

        int most = INT_MIN, ans = 0;
        for (auto&& ch : "abcdefghijklmnopqrstuvwxyz")
            if (prefix.count(ch) && suffix.count(ch)) {
                int val = suffix[ch] - prefix[ch];
                if (val > most) {
                    most = val;
                    ans = 1;
                } else if (val == most) ++ans;
            }
        return ans;
    }


    /*1796. Second Largest Digit in a String (Easy)
    Given an alphanumeric string s, return the second largest numerical digit
    that appears in s, or -1 if it does not exist. An alphanumeric string is a
    string consisting of lowercase English letters and digits.

    Example 1:
    Input: s = "dfa12321afd"
    Output: 2
    Explanation: The digits that appear in s are [1, 2, 3]. The second largest
                 digit is 2.

    Example 2:
    Input: s = "abc1111"
    Output: -1
    Explanation: The digits that appear in s are [1]. There is no second
                 largest digit.

    Constraints:
    * 1 <= s.length <= 500
    * s consists of only lowercase English letters and/or digits.*/

    int secondHighest(string s) {
        set<char> ss;
        for (auto& ch : s)
            if ('0' <= ch && ch <= '9') ss.insert(ch);
        return size(ss) > 1 ? *next(rbegin(ss)) - '0' : -1;
    }


    /*1798. Maximum Number of Consecutive Values You Can Make (Medium)
    You are given an integer array coins of length n which represents the n
    coins that you own. The value of the ith coin is coins[i]. You can make
    some value x if you can choose some of your n coins such that their values
    sum up to x. Return the maximum number of consecutive integer values that
    you can make with your coins starting from and including 0. Note that you
    may have multiple coins of the same value.

    Example 1:
    Input: coins = [1,3]
    Output: 2
    Explanation: You can make the following values:
                 - 0: take []
                 - 1: take [1]
                 You can make 2 consecutive integer values starting from 0.

    Example 2:
    Input: coins = [1,1,1,4]
    Output: 8
    Explanation: You can make the following values:
                 - 0: take []
                 - 1: take [1]
                 - 2: take [1,1]
                 - 3: take [1,1,1]
                 - 4: take [4]
                 - 5: take [4,1]
                 - 6: take [4,1,1]
                 - 7: take [4,1,1,1]
                 You can make 8 consecutive integer values starting from 0.

    Example 3:
    Input: nums = [1,4,10,3,1]
    Output: 20

    Constraints:
    * coins.length == n
    * 1 <= n <= 4 * 10^4
    * 1 <= coins[i] <= 4 * 10^4*/

    int getMaximumConsecutive(vector<int>& coins) {
        sort(begin(coins), end(coins));
        int ans = 1;
        for (auto& x : coins) {
            if (ans < x) break;
            ans += x;
        }
        return ans;
    }


    /*1799. Maximize Score After N Operations (Hard)
    You are given nums, an array of positive integers of size 2 * n. You must
    perform n operations on this array. In the ith operation (1-indexed), you
    will:
    * Choose two elements, x and y.
    * Receive a score of i * gcd(x, y).
    * Remove x and y from nums.
    Return the maximum score you can receive after performing n operations. The
    function gcd(x, y) is the greatest common divisor of x and y.

    Example 1:
    Input: nums = [1,2]
    Output: 1
    Explanation: The optimal choice of operations is: (1 * gcd(1, 2)) = 1

    Example 2:
    Input: nums = [3,4,6,8]
    Output: 11
    Explanation: The optimal choice of operations is:
                 (1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11

    Example 3:
    Input: nums = [1,2,3,4,5,6]
    Output: 14
    Explanation: The optimal choice of operations is:
                 (1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14

    Constraints:
    * 1 <= n <= 7
    * nums.length == 2 * n
    * 1 <= nums[i] <= 10^6*/

    int maxScore(vector<int>& nums) {
        int n = size(nums);
        map<pair<int, int>, int> memo;

        function<int(int, int)> fn = [&](int k, int mask) {
            pair<int, int> key = make_pair(k, mask);
            if (!memo.count(key))
                for (int i = 0; i < n; ++i)
                    if (mask & (1 << i))
                        for (int j = i+1; j < n; ++j)
                            if (mask & (1 << j))
                                memo[key] = max(memo[key], k*gcd(nums[i], nums[j]) + fn(k+1, mask^(1<<i)^(1<<j)));
            return memo[key];
        };

        return fn(1, (1 << n)-1);
    }


    /*1800. Maximum Ascending Subarray Sum (Easy)
    Given an array of positive integers nums, return the maximum possible sum
    of an ascending subarray in nums. A subarray is defined as a contiguous
    sequence of numbers in an array. A subarray [numsl, numsl+1, ..., numsr-1, numsr]
    is ascending if for all i where l <= i < r, numsi < numsi+1. Note that a
    subarray of size 1 is ascending.

    Example 1:
    Input: nums = [10,20,30,5,10,50]
    Output: 65
    Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.

    Example 2:
    Input: nums = [10,20,30,40,50]
    Output: 150
    Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.

    Example 3:
    Input: nums = [12,17,15,13,10,11,12]
    Output: 33
    Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.

    Example 4:
    Input: nums = [100,10,1]
    Output: 100

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100*/

    int maxAscendingSum(vector<int>& nums) {
        int ans = 0, val = 0;
        for (int i = 0; i < size(nums); ++i) {
            if (i == 0 || nums[i-1] >= nums[i]) val = 0;
            val += nums[i];
            ans = max(ans, val);
        }
        return ans;
    }


    /*1801. Number of Orders in the Backlog (Medium)
    You are given a 2D integer array orders, where each
    orders[i] = [pricei, amounti, orderTypei] denotes that amounti orders have
    been placed of type orderTypei at the price pricei. The orderTypei is:
    * 0 if it is a batch of buy orders, or
    * 1 if it is a batch of sell orders.
    Note that orders[i] represents a batch of amounti independent orders with
    the same price and order type. All orders represented by orders[i] will be
    placed before all orders represented by orders[i+1] for all valid i. There
    is a backlog that consists of orders that have not been executed. The
    backlog is initially empty. When an order is placed, the following happens:
    * If the order is a buy order, you look at the sell order with the smallest
      price in the backlog. If that sell order's price is smaller than or equal
      to the current buy order's price, they will match and be executed, and
      that sell order will be removed from the backlog. Else, the buy order is
      added to the backlog.
    * Vice versa, if the order is a sell order, you look at the buy order with
      the largest price in the backlog. If that buy order's price is larger
      than or equal to the current sell order's price, they will match and be
      executed, and that buy order will be removed from the backlog. Else, the
      sell order is added to the backlog.
    Return the total amount of orders in the backlog after placing all the
    orders from the input. Since this number can be large, return it modulo
    10^9 + 7.

    Example 1:
    Input: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]
    Output: 6
    Explanation: Here is what happens with the orders:
    - 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.
    - 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.
    - 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.
    - 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.
    Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.

    Example 2:
    Input: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]
    Output: 999999984
    Explanation: Here is what happens with the orders:
    - 10^9 orders of type sell with price 7 are placed. There are no buy orders, so the 10^9 orders are added to the backlog.
    - 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.
    - 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.
    - 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.
    Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (10^9 + 7).

    Constraints:
    * 1 <= orders.length <= 10^5
    * orders[i].length == 3
    * 1 <= pricei, amounti <= 10^9
    * orderTypei is either 0 or 1.*/

    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
        priority_queue<pair<int, int>> buy; // max-heap
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> sell; // min-heap

        for (auto& order : orders) {
            auto price = order[0], qty = order[1], type = order[2];
            if (type == 0) buy.emplace(price, qty);
            else sell.emplace(price, qty);

            while (size(buy) && size(sell) && buy.top().first >= sell.top().first) {
                auto [bp, bq] = buy.top(); buy.pop();
                auto [sp, sq] = sell.top(); sell.pop();
                if (bq > sq) {
                    bq -= sq;
                    buy.emplace(bp, bq);
                } else if (bq < sq) {
                    sq -= bq;
                    sell.emplace(sp, sq);
                }
            }
        }

        int ans = 0;
        while (size(buy)) { ans = (ans + buy.top().second) % 1'000'000'007; buy.pop(); }
        while (size(sell)) { ans = (ans + sell.top().second) % 1'000'000'007; sell.pop(); }
        return ans;
    }


    /*1802. Maximum Value at a Given Index in a Bounded Array (Medium)
    You are given three positive integers: n, index, and maxSum. You want to
    construct an array nums (0-indexed) that satisfies the following conditions:
    * nums.length == n
    * nums[i] is a positive integer where 0 <= i < n.
    * abs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.
    * The sum of all the elements of nums does not exceed maxSum.
    * nums[index] is maximized.
    Return nums[index] of the constructed array. Note that abs(x) equals x if
    x >= 0, and -x otherwise.

    Example 1:
    Input: n = 4, index = 2,  maxSum = 6
    Output: 2
    Explanation: nums = [1,2,2,1] is one array that satisfies all the conditions.
                 There are no arrays that satisfy all the conditions and have
                 nums[2] == 3, so 2 is the maximum nums[2].

    Example 2:
    Input: n = 6, index = 1,  maxSum = 10
    Output: 3

    Constraints:
    * 1 <= n <= maxSum <= 10^9
    * 0 <= index < n*/

    int maxValue(int n, int index, int maxSum) {
        auto fn = [](int n, long x) { return n <= x ? n*(2*x - n + 1)/2 : x*(1+x)/2 + n - x; };

        long lo = 0, hi = maxSum;
        while (lo < hi) {
            long mid = lo + (hi - lo + 1)/2;
            if (fn(index, mid-1) + fn(n - index, mid) > maxSum) hi = mid-1;
            else lo = mid;
        }
        return lo;
    }


    /*1803. Count Pairs With XOR in a Range (Hard)
    Given a (0-indexed) integer array nums and two integers low and high,
    return the number of nice pairs. A nice pair is a pair (i, j) where
    0 <= i < j < nums.length and low <= (nums[i] XOR nums[j]) <= high.

    Example 1:
    Input: nums = [1,4,2,7], low = 2, high = 6
    Output: 6
    Explanation: All nice pairs (i, j) are as follows:
        - (0, 1): nums[0] XOR nums[1] = 5
        - (0, 2): nums[0] XOR nums[2] = 3
        - (0, 3): nums[0] XOR nums[3] = 6
        - (1, 2): nums[1] XOR nums[2] = 6
        - (1, 3): nums[1] XOR nums[3] = 3
        - (2, 3): nums[2] XOR nums[3] = 5

    Example 2:
    Input: nums = [9,8,4,2,1], low = 5, high = 14
    Output: 8
    Explanation: All nice pairs (i, j) are as follows:
        - (0, 2): nums[0] XOR nums[2] = 13
        - (0, 3): nums[0] XOR nums[3] = 11
        - (0, 4): nums[0] XOR nums[4] = 8
        - (1, 2): nums[1] XOR nums[2] = 12
        - (1, 3): nums[1] XOR nums[3] = 10
        - (1, 4): nums[1] XOR nums[4] = 9
        - (2, 3): nums[2] XOR nums[3] = 6
        - (2, 4): nums[2] XOR nums[4] = 5

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= nums[i] <= 2 * 10^4
    * 1 <= low <= high <= 2 * 10^4

    class TrieNode {
        TrieNode* child[2] = {nullptr};
        int cnt = 0;
        friend class Trie;
    };


    class Trie {
        TrieNode* root;
    public:
        Trie() {root = new TrieNode(); }

        void insert(int val) {
            TrieNode* node = root;
            for (int i = 14; i >= 0; --i) {
                int bit = (val >> i) & 1;
                if (!node->child[bit]) node->child[bit] = new TrieNode();
                node = node->child[bit];
                ++node->cnt;
            }
        }

        int count(int val, int high) {
            int ans = 0;
            TrieNode* node = root;
            for (int i = 14; i >= 0; --i) {
                if (!node) break;
                int bit = (val >> i) & 1, cmp = (high >> i) & 1;
                if (cmp) {
                    if (node->child[bit]) ans += node->child[bit]->cnt;
                    node = node->child[1^bit];
                } else {
                    node = node->child[bit];
                }
            }
            return ans;
        }
    };*/

    int countPairs(vector<int>& nums, int low, int high) {
        Trie* trie = new Trie();
        int ans = 0;
        for (auto& x : nums) {
            ans += trie->count(x, high+1) - trie->count(x, low);
            trie->insert(x);
        }
        return ans;
    }


    /*1805. Number of Different Integers in a String (Easy)
    You are given a string word that consists of digits and lowercase English
    letters. You will replace every non-digit character with a space. For
    example, "a123bc34d8ef34" will become " 123  34 8  34". Notice that you are
    left with some integers that are separated by at least one space: "123",
    "34", "8", and "34". Return the number of different integers after
    performing the replacement operations on word. Two integers are considered
    different if their decimal representations without any leading zeros are
    different.

    Example 1:
    Input: word = "a123bc34d8ef34"
    Output: 3
    Explanation: The three different integers are "123", "34", and "8". Notice
                 that "34" is only counted once.

    Example 2:
    Input: word = "leet1234code234"
    Output: 2

    Example 3:
    Input: word = "a1b01c001"
    Output: 1
    Explanation: The three integers "1", "01", and "001" all represent the same
                 integer because the leading zeros are ignored when comparing
                 their decimal values.

    Constraints:
    * 1 <= word.length <= 1000
    * word consists of digits and lowercase English letters.*/

    int numDifferentIntegers(string word) {
        unordered_set<string> seen;
        for (int i = 0, j = 0; i < size(word); i = ++j) {
            for (; isdigit(word[j]); ++j);
            for (; word[i] == '0' && i+1 < j; ++i); // remove leading "0"
            if (i < j) {
                string s = word.substr(i, j-i);
                seen.insert(s);
            }
        }
        return size(seen);
    }


    /*1806. Minimum Number of Operations to Reinitialize a Permutation (Medium)
    You are given an even integer n. You initially have a permutation perm of
    size n where perm[i] == i (0-indexed). In one operation, you will create a
    new array arr, and for each i:
    * If i % 2 == 0, then arr[i] = perm[i / 2].
    * If i % 2 == 1, then arr[i] = perm[n / 2 + (i - 1) / 2].
    You will then assign arr to perm. Return the minimum non-zero number of
    operations you need to perform on perm to return the permutation to its
    initial value.

    Example 1:
    Input: n = 2
    Output: 1
    Explanation: perm = [0,1] initially.
                 After the 1st operation, perm = [0,1].
                 So it takes only 1 operation.

    Example 2:
    Input: n = 4
    Output: 2
    Explanation: perm = [0,1,2,3] initially.
                 After the 1st operation, perm = [0,2,1,3]
                 After the 2nd operation, perm = [0,1,2,3]
                 So it takes only 2 operations.

    Example 3:
    Input: n = 6
    Output: 4

    Constraints:
    * 2 <= n <= 1000
    * n is even.*/

    int reinitializePermutation(int n) {
        vector<int> perm(n), arr(n);
        for (int i = 0; i < n; ++i) perm[i] = arr[i] = i;

        for (int k = 1; ; ++k) {
            vector<int> tmp = arr;
            bool flag = true;
            for (int i = 0; i < n; ++i) {
                if (i&1) arr[i] = tmp[n/2 + (i-1)/2];
                else arr[i] = tmp[i/2];
                if (perm[i] != arr[i]) flag = false;
            }
            if (flag) return k;
        }
        return 0;
    }


    /*1807. Evaluate the Bracket Pairs of a String (Medium)
    You are given a string s that contains some bracket pairs, with each pair
    containing a non-empty key.
    * For example, in the string "(name)is(age)yearsold", there are two bracket
      pairs that contain the keys "name" and "age".
    You know the values of a wide range of keys. This is represented by a 2D
    string array knowledge where each knowledge[i] = [keyi, valuei] indicates
    that key keyi has a value of valuei. You are tasked to evaluate all of the
    bracket pairs. When you evaluate a bracket pair that contains some key keyi,
    you will:
    * Replace keyi and the bracket pair with the key's corresponding valuei.
    * If you do not know the value of the key, you will replace keyi and the
      bracket pair with a question mark "?" (without the quotation marks).
    Each key will appear at most once in your knowledge. There will not be any
    nested brackets in s. Return the resulting string after evaluating all of
    the bracket pairs.

    Example 1:
    Input: s = "(name)is(age)yearsold", knowledge = [["name","bob"],["age","two"]]
    Output: "bobistwoyearsold"
    Explanation: The key "name" has a value of "bob", so replace "(name)" with "bob".
                 The key "age" has a value of "two", so replace "(age)" with "two".

    Example 2:
    Input: s = "hi(name)", knowledge = [["a","b"]]
    Output: "hi?"
    Explanation: As you do not know the value of the key "name", replace "(name)"
                 with "?".

    Example 3:
    Input: s = "(a)(a)(a)aaa", knowledge = [["a","yes"]]
    Output: "yesyesyesaaa"
    Explanation: The same key can appear multiple times. The key "a" has a
                 value of "yes", so replace all occurrences of "(a)" with "yes".
                 Notice that the "a"s not in a bracket pair are not evaluated.

    Example 4:
    Input: s = "(a)(b)", knowledge = [["a","b"],["b","a"]]
    Output: "ba"

    Constraints:
    * 1 <= s.length <= 10^5
    * 0 <= knowledge.length <= 10^5
    * knowledge[i].length == 2
    * 1 <= keyi.length, valuei.length <= 10
    * s consists of lowercase English letters and round brackets '(' and ')'.
    * Every open bracket '(' in s will have a corresponding close bracket ')'.
    * The key in each bracket pair of s will be non-empty.
    * There will not be any nested bracket pairs in s.
    * keyi and valuei consist of lowercase English letters.
    * Each keyi in knowledge is unique.*/

    string evaluate(string s, vector<vector<string>>& knowledge) {
        unordered_map<string, string> mp;
        for (auto& x : knowledge) mp[x[0]] = x[1];

        stringstream ans;
        for (int i = 0, j = 0; i < size(s); ) {
            if (s[i] == '(') {
                for (j = 0; s[i+1+j] != ')'; ++j);
                string key = s.substr(i+1, j);
                ans << (mp.count(key) ? mp[key] : "?");
                i += j+2;
            } else {
                ans << s[i++];
            }
        }
        return ans.str();
    }


    /*1808. Maximize Number of Nice Divisors (Hard)
    You are given a positive integer primeFactors. You are asked to construct a
    positive integer n that satisfies the following conditions:
    * The number of prime factors of n (not necessarily distinct) is at most
      primeFactors.
    * The number of nice divisors of n is maximized. Note that a divisor of n
      is nice if it is divisible by every prime factor of n. For example, if
      n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice
      divisors, while 3 and 4 are not.
    Return the number of nice divisors of n. Since that number can be too large,
    return it modulo 10^9 + 7. Note that a prime number is a natural number
    greater than 1 that is not a product of two smaller natural numbers. The
    prime factors of a number n is a list of prime numbers such that their
    product equals n.

    Example 1:
    Input: primeFactors = 5
    Output: 6
    Explanation: 200 is a valid value of n. It has 5 prime factors: [2,2,2,5,5],
                 and it has 6 nice divisors: [10,20,40,50,100,200]. There is
                 not other value of n that has at most 5 prime factors and more
                 nice divisors.

    Example 2:
    Input: primeFactors = 8
    Output: 18

    Constraints: 1 <= primeFactors <= 10^9*/

    int maxNiceDivisors(int primeFactors) {
        if (primeFactors <= 3) return primeFactors;
        int q = primeFactors/3, r = primeFactors%3, mod = 1'000'000'007;

        auto mpow = [&](long x, int k) {
            long ans = 1;
            for (; k; k /= 2) {
                if (k&1) ans = (ans * x) % mod;
                x = (x * x) % mod;
            }
            return ans;
        };

        if (r == 0) return mpow(3, q);
        if (r == 1) return mpow(3, q-1) * 4 % mod;
        return mpow(3, q) * 2 % mod;
    }


    /*1810. Minimum Path Cost in a Hidden Grid (Medium)
    This is an interactive problem. There is a robot in a hidden grid, and you
    are trying to get it from its starting cell to the target cell in this grid.
    The grid is of size m x n, and each cell in the grid is either empty or
    blocked. It is guaranteed that the starting cell and the target cell are
    different, and neither of them is blocked. Each cell has a cost that you
    need to pay each time you move to the cell. The starting cell's cost is not
    applied before the robot moves. You want to find the minimum total cost to
    move the robot to the target cell. However, you do not know the grid's
    dimensions, the starting cell, nor the target cell. You are only allowed to
    ask queries to the GridMaster object. The GridMaster class has the
    following functions:
    * boolean canMove(char direction) Returns true if the robot can move in
      that direction. Otherwise, it returns false.
    * int move(char direction) Moves the robot in that direction and returns
      the cost of moving to that cell. If this move would move the robot to a
      blocked cell or off the grid, the move will be ignored, the robot will
      remain in the same position, and the function will return -1.
    * boolean isTarget() Returns true if the robot is currently on the target
      cell. Otherwise, it returns false.
    Note that direction in the above functions should be a character from
    {'U','D','L','R'}, representing the directions up, down, left, and right,
    respectively. Return the minimum total cost to get the robot from its
    initial starting cell to the target cell. If there is no valid path between
    the cells, return -1.

    Custom testing:
    The test input is read as a 2D matrix grid of size m x n and four integers
    r1, c1, r2, and c2 where:
    * grid[i][j] == 0 indicates that the cell (i, j) is blocked.
    * grid[i][j] >= 1 indicates that the cell (i, j) is empty and grid[i][j] is
      the cost to move to that cell.
    * (r1, c1) is the starting cell of the robot.
    * (r2, c2) is the target cell of the robot.
    Remember that you will not have this information in your code.

    Example 1:
    Input: grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0
    Output: 2
    Explanation: One possible interaction is described below:
                 The robot is initially standing on cell (0, 1), denoted by the
                 3.
                 - master.canMove('U') returns false.
                 - master.canMove('D') returns true.
                 - master.canMove('L') returns true.
                 - master.canMove('R') returns false.
                 - master.move('L') moves the robot to the cell (0, 0) and
                   returns 2.
                 - master.isTarget() returns false.
                 - master.canMove('U') returns false.
                 - master.canMove('D') returns true.
                 - master.canMove('L') returns false.
                 - master.canMove('R') returns true.
                 - master.move('D') moves the robot to the cell (1, 0) and
                   returns 1.
                 - master.isTarget() returns true.
                 - master.move('L') doesn't move the robot and returns -1.
                 - master.move('R') moves the robot to the cell (1, 1) and
                   returns 1.
                 We now know that the target is the cell (1, 0), and the
                 minimum total cost to reach it is 2.

    Example 2:
    Input: grid = [[0,3,1],[3,4,2],[1,2,0]], r1 = 2, c1 = 0, r2 = 0, c2 = 2
    Output: 9
    Explanation: The minimum cost path is (2,0) -> (2,1) -> (1,1) -> (1,2) ->
                 (0,2).

    Example 3:
    Input: grid = [[1,0],[0,1]], r1 = 0, c1 = 0, r2 = 1, c2 = 1
    Output: -1
    Explanation: There is no path from the robot to the target cell.

    Constraints:
    * 1 <= n, m <= 100
    * m == grid.length
    * n == grid[i].length
    * 0 <= grid[i][j] <= 100*/

    int findShortestPath(GridMaster &master) {
        int sz = 202, i0 = sz/2, j0 = sz/2, dir[5] = {-1, 0, 1, 0, -1};
        vector<vector<int>> cost(sz, vector<int>(sz, -1));
        string s = "LURD";
        vector<int> target = {-100, -100};

        function<void(int, int)> dfs = [&](int i, int j) {
            if (master.isTarget()) target = {i, j};
            for (int k = 0; k < 4; ++k) {
                if (master.canMove(s[k])) {
                    int di = dir[k], dj = dir[k+1], ii = i+di, jj = j+dj;
                    if (cost[ii][jj] == -1) {
                        cost[ii][jj] = master.move(s[k]);
                        dfs(ii, jj);
                        master.move(s[(k+2) % 4]);
                    }
                }
            }
        };

        dfs(i0, j0);

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq; pq.emplace(0, i0, j0);
        vector<vector<int>> dist(sz, vector<int>(sz, -1));
        while (pq.size()) {
            auto [v, i, j] = pq.top(); pq.pop();
            if (target[0] == i && target[1] == j) return v;
            for (int k = 0; k < 4; ++k) {
                int ii = i+dir[k], jj = j+dir[k+1];
                if (cost[ii][jj] != -1) {
                    int vv = v + cost[ii][jj];
                    if (dist[ii][jj] == -1 || vv < dist[ii][jj]) {
                        dist[ii][jj] = vv;
                        pq.emplace(vv, ii, jj);
                    }
                }
            }
        }
        return -1;
    }


    /*1812. Determine Color of a Chessboard Square (Easy)
    You are given coordinates, a string that represents the coordinates of a
    square of the chessboard. Below is a chessboard for your reference. Return
    true if the square is white, and false if the square is black. The
    coordinate will always represent a valid chessboard square. The coordinate
    will always have the letter first, and the number second.

    Example 1:
    Input: coordinates = "a1"
    Output: false
    Explanation: From the chessboard above, the square with coordinates "a1" is
                 black, so return false.

    Example 2:
    Input: coordinates = "h3"
    Output: true
    Explanation: From the chessboard above, the square with coordinates "h3" is
                 white, so return true.

    Example 3:
    Input: coordinates = "c7"
    Output: false

    Constraints:
    * coordinates.length == 2
    * 'a' <= coordinates[0] <= 'h'
    * '1' <= coordinates[1] <= '8'*/

    bool squareIsWhite(string coordinates) {
        return (coordinates[0] & 1) != (coordinates[1] & 1);
    }



    /*1814. Count Nice Pairs in an Array (Medium)
    You are given an array nums that consists of non-negative integers. Let us
    define rev(x) as the reverse of the non-negative integer x. For example,
    rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it
    satisfies all of the following conditions:
    * 0 <= i < j < nums.length
    * nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
    Return the number of nice pairs of indices. Since that number can be too
    large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [42,11,1,97]
    Output: 2
    Explanation: The two pairs are:
     - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
     - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.

    Example 2:
    Input: nums = [13,10,35,24,76]
    Output: 4

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9*/

    int countNicePairs(vector<int>& nums) {
        long ans = 0;
        unordered_map<int, int> freq;
        for (auto& x : nums) {
            int rev = 0;
            for (int xx = x; xx; xx /= 10) rev = 10*rev + xx % 10;
            x -= rev;
            ans = (ans + freq[x]) % 1'000'000'007;
            ++freq[x];
        }
        return ans;
    }


    /*1813. Sentence Similarity III (Medium)
    A sentence is a list of words that are separated by a single space with no
    leading or trailing spaces. For example, "Hello World", "HELLO", "hello
    world hello world" are all sentences. Words consist of only uppercase and
    lowercase English letters. Two sentences sentence1 and sentence2 are
    similar if it is possible to insert an arbitrary sentence (possibly empty)
    inside one of these sentences such that the two sentences become equal. For
    example, sentence1 = "Hello my name is Jane" and sentence2 = "Hello Jane"
    can be made equal by inserting "my name is" between "Hello" and "Jane" in
    sentence2. Given two sentences sentence1 and sentence2, return true if
    sentence1 and sentence2 are similar. Otherwise, return false.

    Example 1:
    Input: sentence1 = "My name is Haley", sentence2 = "My Haley"
    Output: true
    Explanation: sentence2 can be turned to sentence1 by inserting "name is"
                 between "My" and "Haley".

    Example 2:
    Input: sentence1 = "of", sentence2 = "A lot of words"
    Output: false
    Explanation: No single sentence can be inserted inside one of the sentences
                 to make it equal to the other.

    Example 3:
    Input: sentence1 = "Eating right now", sentence2 = "Eating"
    Output: true
    Explanation: sentence2 can be turned to sentence1 by inserting "right now"
                 at the end of the sentence.

    Example 4:
    Input: sentence1 = "Luky", sentence2 = "Lucccky"
    Output: false

    Constraints:
    * 1 <= sentence1.length, sentence2.length <= 100
    * sentence1 and sentence2 consist of lowercase and uppercase English
      letters and spaces.
    * The words in sentence1 and sentence2 are separated by a single space.*/

    bool areSentencesSimilar(string sentence1, string sentence2) {
        if (size(sentence1) < size(sentence2)) swap(sentence1, sentence2);

        vector<string> words1, words2;

        string word;
        istringstream iss1(sentence1);
        while (iss1 >> word) words1.push_back(word);

        istringstream iss2(sentence2);
        while (iss2 >> word) words2.push_back(word);

        int i = 0;
        for (; i < size(words2) && words1[i] == words2[i]; ++i);
        int j = size(words2)-1;
        for (; 0 <= j && words1[size(words1)-size(words2)+j] == words2[j]; --j);
        return j < i;
    }


    /*1815. Maximum Number of Groups Getting Fresh Donuts (Hard)
    There is a donuts shop that bakes donuts in batches of batchSize. They have
    a rule where they must serve all of the donuts of a batch before serving
    any donuts of the next batch. You are given an integer batchSize and an
    integer array groups, where groups[i] denotes that there is a group of
    groups[i] customers that will visit the shop. Each customer will get
    exactly one donut. When a group visits the shop, all customers of the group
    must be served before serving any of the following groups. A group will be
    happy if they all get fresh donuts. That is, the first customer of the
    group does not receive a donut that was left over from the previous group.
    You can freely rearrange the ordering of the groups. Return the maximum
    possible number of happy groups after rearranging the groups.

    Example 1:
    Input: batchSize = 3, groups = [1,2,3,4,5,6]
    Output: 4
    Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd,
                 4th, and 6th groups will be happy.

    Example 2:
    Input: batchSize = 4, groups = [1,3,2,5,2,2,1,6]
    Output: 4

    Constraints:
    * 1 <= batchSize <= 9
    * 1 <= groups.length <= 30
    * 1 <= groups[i] <= 10^9*/

    int maxHappyGroups(int batchSize, vector<int>& groups) {
        vector<int> freq(batchSize, 0);
        int ans = 0;
        for (auto group : groups) {
            group %= batchSize;
            if (group == 0) ++ans;
            else if (freq[batchSize - group]) {
                ++ans;
                --freq[batchSize - group];
            }
            else ++freq[group];
        }

        map<vector<int>, int> memo;

        function<int(int)> fn = [&](int left) {
            if (memo.find(freq) == memo.end()) {
                int ans = 0, more = 0;
                for (int i = 0; i < batchSize; ++i) {
                    if (freq[i]) {
                        --freq[i];
                        ans = max(ans, fn((left + i) % batchSize));
                        ++freq[i];
                        more = 1;
                    }
                }
                if (left == 0 && more) ans += 1;
                memo[freq] = ans;
            }
            return memo[freq];
        };

        return ans + fn(0);
    }


    /*1816. Truncate Sentence (Easy)
    A sentence is a list of words that are separated by a single space with no
    leading or trailing spaces. Each of the words consists of only uppercase
    and lowercase English letters (no punctuation). For example, "Hello World",
    "HELLO", and "hello world hello world" are all sentences. You are given a
    sentence s and an integer k. You want to truncate s such that it contains
    only the first k words. Return s after truncating it.

    Example 1:
    Input: s = "Hello how are you Contestant", k = 4
    Output: "Hello how are you"
    Explanation:
    The words in s are ["Hello", "how" "are", "you", "Contestant"].
    The first 4 words are ["Hello", "how", "are", "you"].
    Hence, you should return "Hello how are you".

    Example 2:
    Input: s = "What is the solution to this problem", k = 4
    Output: "What is the solution"
    Explanation:
    The words in s are ["What", "is" "the", "solution", "to", "this", "problem"].
    The first 4 words are ["What", "is", "the", "solution"].
    Hence, you should return "What is the solution".

    Example 3:
    Input: s = "chopper is not a tanuki", k = 5
    Output: "chopper is not a tanuki"

    Constraints:
    * 1 <= s.length <= 500
    * k is in the range [1, the number of words in s].
    * s consist of only lowercase and uppercase English letters and spaces.
    * The words in s are separated by a single space.
    * There are no leading or trailing spaces.*/

    string truncateSentence(string s, int k) {
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == ' ') {
                if (--k == 0) return s.substr(0, i);
            }
        }
        return s;
    }


    /*1817. Finding the Users Active Minutes (Medium)
    You are given the logs for users' actions on LeetCode, and an integer k.
    The logs are represented by a 2D integer array logs where each
    logs[i] = [IDi, timei] indicates that the user with IDi performed an action
    at the minute timei. Multiple users can perform actions simultaneously,
    and a single user can perform multiple actions in the same minute. The
    user active minutes (UAM) for a given user is defined as the number of
    unique minutes in which the user performed an action on LeetCode. A minute
    can only be counted once, even if multiple actions occur during it. You
    are to calculate a 1-indexed array answer of size k such that, for each j
    (1 <= j <= k), answer[j] is the number of users whose UAM equals j. Return
    the array answer as described above.

    Example 1:
    Input: logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5
    Output: [0,2,0,0,0]
    Explanation:
    The user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once).
    The user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.
    Since both users have a UAM of 2, answer[2] is 2, and the remaining answer[j] values are 0.

    Example 2:
    Input: logs = [[1,1],[2,2],[2,3]], k = 4
    Output: [1,1,0,0]
    Explanation:
    The user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1.
    The user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.
    There is one user with a UAM of 1 and one with a UAM of 2.
    Hence, answer[1] = 1, answer[2] = 1, and the remaining values are 0.

    Constraints:
    * 1 <= logs.length <= 10^4
    * 0 <= IDi <= 10^9
    * 1 <= timei <= 10^5
    * k is in the range [The maximum UAM for a user, 10^5].*/

    vector<int> findingUsersActiveMinutes(vector<vector<int>>& logs, int k) {
        unordered_map<int, unordered_set<int>> mp;
        for (auto &log : logs) {
            mp[log[0]].insert(log[1]);
        }

        vector<int> ans(k, 0);
        for (auto &x : mp) {
            if (x.second.size() <= k)
                ++ans[x.second.size() - 1];
        }
        return ans;
    }


    /*1818. Minimum Absolute Sum Difference (Medium)
    You are given two positive integer arrays nums1 and nums2, both of length n.
    The absolute sum difference of arrays nums1 and nums2 is defined as the sum
    of |nums1[i] - nums2[i]| for each 0 <= i < n (0-indexed). You can replace
    at most one element of nums1 with any other element in nums1 to minimize
    the absolute sum difference. Return the minimum absolute sum difference
    after replacing at most one element in the array nums1. Since the answer
    may be large, return it modulo 10^9 + 7. |x| is defined as:
    * x if x >= 0, or
    * -x if x < 0.

    Example 1:
    Input: nums1 = [1,7,5], nums2 = [2,3,5]
    Output: 3
    Explanation: There are two possible optimal solutions:
    - Replace the second element with the first: [1,7,5] => [1,1,5], or
    - Replace the second element with the third: [1,7,5] => [1,5,5].
    Both will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3.

    Example 2:
    Input: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
    Output: 0
    Explanation: nums1 is equal to nums2 so no replacement is needed. This will result in an
    absolute sum difference of 0.

    Example 3:
    Input: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
    Output: 20
    Explanation: Replace the first element with the second: [1,10,4,4,2,7] => [10,10,4,4,2,7].
    This yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20

    Constraints:
    * n == nums1.length
    * n == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^5*/

    int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {
        vector<int> s1 = nums1;
        sort(s1.begin(), s1.end());

        long ans = 0, bnft = 0;
        for (int i = 0; i < nums1.size(); ++i) {
            long term = abs(nums1[i] - nums2[i]);
            ans += term;
            auto it = lower_bound(s1.begin(), s1.end(), nums2[i]);
            if (it < s1.end())
                bnft = max(bnft, term - (*it - nums2[i]));
            if (s1.begin() < it)
                bnft = max(bnft, term - (nums2[i] - *prev(it)));
        }
        return (ans - bnft) % 1'000'000'007;
    }


    /*1819. Number of Different Subsequences GCDs (Hard)
    You are given an array nums that consists of positive integers. The GCD of
    a sequence of numbers is defined as the greatest integer that divides all
    the numbers in the sequence evenly. For example, the GCD of the sequence
    [4,6,16] is 2. A subsequence of an array is a sequence that can be formed
    by removing some elements (possibly none) of the array. For example,
    [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10]. Return the number of
    different GCDs among all non-empty subsequences of nums.

    Example 1:
    Input: nums = [6,10,3]
    Output: 5
    Explanation: The figure shows all the non-empty subsequences and their GCDs.
    The different GCDs are 6, 10, 3, 2, and 1.

    Example 2:
    Input: nums = [5,15,40,5,6]
    Output: 7

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 2 * 10^5*/

    int countDifferentSubsequenceGCDs(vector<int>& nums) {
        auto mx = *max_element(nums.begin(), nums.end());
        vector<bool> seen (mx+1, false);
        for (auto& x : nums)
            seen[x] = true;

        int ans = 0;
        for (int x = 1; x <= mx; ++x) {
            int g = 0;
            for (int xx = x; xx <= mx; xx += x) {
                if (seen[xx]) g = __gcd(g, xx);
            }
            if (g == x) ++ans;
        }
        return ans;
    }


    /*1820. Maximum Number of Accepted Invitations (Medium)
    There are m boys and n girls in a class attending an upcoming party. You
    are given an m x n integer matrix grid, where grid[i][j] equals 0 or 1. If
    grid[i][j] == 1, then that means the ith boy can invite the jth girl to the
    party. A boy can invite at most one girl, and a girl can accept at most one
    invitation from a boy. Return the maximum possible number of accepted
    invitations.

    Example 1:
    Input: grid = [[1,1,1],
                   [1,0,1],
                   [0,0,1]]
    Output: 3
    Explanation: The invitations are sent as follows:
                 - The 1st boy invites the 2nd girl.
                 - The 2nd boy invites the 1st girl.
                 - The 3rd boy invites the 3rd girl.

    Example 2:
    Input: grid = [[1,0,1,0],
                   [1,0,0,0],
                   [0,0,1,0],
                   [1,1,1,0]]
    Output: 3
    Explanation: The invitations are sent as follows:
                 -The 1st boy invites the 3rd girl.
                 -The 2nd boy invites the 1st girl.
                 -The 3rd boy invites no one.
                 -The 4th boy invites the 2nd girl.

    Constraints:
    * grid.length == m
    * grid[i].length == n
    * 1 <= m, n <= 200
    * grid[i][j] is either 0 or 1.*/

    int maximumInvitations(vector<vector<int>>& grid) {
        /*maximum bipartite matching*/
        int m = grid.size(), n = grid[0].size(), ans = 0;
        vector<int> match(n, -1);

        function<bool(int, vector<bool>&)> fn = [&](int i, vector<bool>& seen) {
            for (int j = 0; j < n; ++j)
                if (grid[i][j] && not seen[j]) {
                    seen[j] = true;
                    if (match[j] == -1 || fn(match[j], seen)) {
                        match[j] = i;
                        return true;
                    }
                }
            return false;
        };

        for (int i = 0; i < m; ++i) {
            vector<bool> seen(n, false);
            if (fn(i, seen)) ++ans;
        }
        return ans;
    }


    /*1823. Find the Winner of the Circular Game (Medium)
    There are n friends that are playing a game. The friends are sitting in a
    circle and are numbered from 1 to n in clockwise order. More formally,
    moving clockwise from the ith friend brings you to the (i+1)th friend for
    1 <= i < n, and moving clockwise from the nth friend brings you to the 1st
    friend. The rules of the game are as follows:
    * Start at the 1st friend.
    * Count the next k friends in the clockwise direction including the friend
      you started at. The counting wraps around the circle and may count some
      friends more than once.
    * The last friend you counted leaves the circle and loses the game.
    * If there is still more than one friend in the circle, go back to step 2
      starting from the friend immediately clockwise of the friend who just
      lost and repeat.
    * Else, the last friend in the circle wins the game.
    Given the number of friends, n, and an integer k, return the winner of the
    game.

    Example 1:
    Input: n = 5, k = 2
    Output: 3
    Explanation: Here are the steps of the game:
                 1) Start at friend 1.
                 2) Count 2 friends clockwise, which are friends 1 and 2.
                 3) Friend 2 leaves the circle. Next start is friend 3.
                 4) Count 2 friends clockwise, which are friends 3 and 4.
                 5) Friend 4 leaves the circle. Next start is friend 5.
                 6) Count 2 friends clockwise, which are friends 5 and 1.
                 7) Friend 1 leaves the circle. Next start is friend 3.
                 8) Count 2 friends clockwise, which are friends 3 and 5.
                 9) Friend 5 leaves the circle. Only friend 3 is left, so they
                 are the winner.

    Example 2:
    Input: n = 6, k = 5
    Output: 1
    Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is
                 friend 1.

    Constraints: 1 <= k <= n <= 500*/

    int findTheWinner(int n, int k) {
        /*Josephus Problem*/
        int ans = 0;
        for (int x = 2; x <= n; ++x)
            ans = (ans + k) % x;
        return ans + 1;
    }


    /*1827. Minimum Operations to Make the Array Increasing (Easy)
    You are given an integer array nums (0-indexed). In one operation, you can
    choose an element of the array and increment it by 1. For example, if
    nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].
    Return the minimum number of operations needed to make nums strictly
    increasing. An array nums is strictly increasing if nums[i] < nums[i+1] for
    all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly
    increasing.

    Example 1:
    Input: nums = [1,1,1]
    Output: 3
    Explanation: You can do the following operations:
                 1) Increment nums[2], so nums becomes [1,1,2].
                 2) Increment nums[1], so nums becomes [1,2,2].
                 3) Increment nums[2], so nums becomes [1,2,3].

    Example 2:
    Input: nums = [1,5,2,4,1]
    Output: 14

    Example 3:
    Input: nums = [8]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 5000
    * 1 <= nums[i] <= 10^4*/

    int minOperations(vector<int>& nums) {
        int ans = 0, prev = 0;
        for (auto& x : nums) {
            ans += max(0, 1 + prev - x);
            prev = max(1 + prev, x);
        }
        return ans;
    }


    /*1828. Queries on Number of Points Inside a Circle (Medium)
    You are given an array points where points[i] = [xi, yi] is the coordinates
    of the ith point on a 2D plane. Multiple points can have the same coordinates.
    You are also given an array queries where queries[j] = [xj, yj, rj] describes
    a circle centered at (xj, yj) with a radius of rj. For each query queries[j],
    compute the number of points inside the jth circle. Points on the border of
    the circle are considered inside. Return an array answer, where answer[j]
    is the answer to the jth query.

    Example 1:
    Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]
    Output: [3,2,2]
    Explanation: The points and circles are shown above. queries[0] is the green
                 circle, queries[1] is the red circle, and queries[2] is the blue
                 circle.

    Example 2:
    Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]
    Output: [2,3,2,4]
    Explanation: The points and circles are shown above. queries[0] is green,
                 queries[1] is red, queries[2] is blue, and queries[3] is purple.

    Constraints:
    * 1 <= points.length <= 500
    * points[i].length == 2
    * 0 <= xi, yi <= 500
    * 1 <= queries.length <= 500
    * queries[j].length == 3
    * 0 <= xj, yj <= 500
    * 1 <= rj <= 500
    * All coordinates are integers.

    Follow up: Could you find the answer for each query in better complexity than O(n)?*/

    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {
        vector<int> ans;
        for (auto& query : queries) {
            int cnt = 0, r = query[2];
            for (auto& point : points) {
                if (pow(query[0]-point[0], 2) + pow(query[1]-point[1], 2) <= r*r) ++cnt;
            }
            ans.push_back(cnt);
        }
        return ans;
    }


    /*1829. Maximum XOR for Each Query (Medium)
    You are given a sorted array nums of n non-negative integers and an integer
    maximumBit. You want to perform the following query n times:
    * Find a non-negative integer k < 2maximumBit such that nums[0] XOR nums[1]
      XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the answer to
      the ith query.
    * Remove the last element from the current array nums.
    Return an array answer, where answer[i] is the answer to the ith query.

    Example 1:
    Input: nums = [0,1,1,3], maximumBit = 2
    Output: [0,3,2,3]
    Explanation: The queries are answered as follows:
                 1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.
                 2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.
                 3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.
                 4th query: nums = [0], k = 3 since 0 XOR 3 = 3.

    Example 2:
    Input: nums = [2,3,4,7], maximumBit = 3
    Output: [5,2,6,5]
    Explanation: The queries are answered as follows:
                 1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.
                 2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.
                 3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.
                 4th query: nums = [2], k = 5 since 2 XOR 5 = 7.

    Example 3:
    Input: nums = [0,1,2,2,5,7], maximumBit = 3
    Output: [4,3,6,4,6,7]

    Constraints:
    * nums.length == n
    * 1 <= n <= 10^5
    * 1 <= maximumBit <= 20
    * 0 <= nums[i] < 2maximumBit
    * nums​​​ is sorted in ascending order.*/

    vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {
        int prefix = 0;
        vector<int> ans(size(nums), 0);
        for (int i = 0; i < size(nums); ++i) {
            prefix ^= nums[i];
            ans[size(nums)-i-1] = prefix ^ ((1 << maximumBit) - 1);
        }
        return ans;
    }


    /*1830. Minimum Number of Operations to Make String Sorted (Hard)
    You are given a string s (0-indexed). You are asked to perform the
    following operation on s until you get a sorted string:
    * Find the largest index i such that 1 <= i < s.length and s[i] < s[i - 1].
    * Find the largest index j such that i <= j < s.length and s[k] < s[i - 1]
      for all the possible values of k in the range [i, j] inclusive.
    * Swap the two characters at indices i - 1 and j.
    * Reverse the suffix starting at index i.
    Return the number of operations needed to make the string sorted. Since the
    answer can be too large, return it modulo 10^9 + 7.

    Example 1:
    Input: s = "cba"
    Output: 5
    Explanation: The simulation goes as follows:
    Operation 1: i=2, j=2. Swap s[1] and s[2] to get s="cab", then reverse the suffix starting at 2. Now, s="cab".
    Operation 2: i=1, j=2. Swap s[0] and s[2] to get s="bac", then reverse the suffix starting at 1. Now, s="bca".
    Operation 3: i=2, j=2. Swap s[1] and s[2] to get s="bac", then reverse the suffix starting at 2. Now, s="bac".
    Operation 4: i=1, j=1. Swap s[0] and s[1] to get s="abc", then reverse the suffix starting at 1. Now, s="acb".
    Operation 5: i=2, j=2. Swap s[1] and s[2] to get s="abc", then reverse the suffix starting at 2. Now, s="abc".

    Example 2:
    Input: s = "aabaa"
    Output: 2
    Explanation: The simulation goes as follows:
    Operation 1: i=3, j=4. Swap s[2] and s[4] to get s="aaaab", then reverse the substring starting at 3. Now, s="aaaba".
    Operation 2: i=4, j=4. Swap s[3] and s[4] to get s="aaaab", then reverse the substring starting at 4. Now, s="aaaab".

    Example 3:
    Input: s = "cdbea"
    Output: 63

    Example 4:
    Input: s = "leetcodeleetcodeleetcode"
    Output: 982157772

    Constraints:
    * 1 <= s.length <= 3000
    * s consists only of lowercase English letters.*/

    int makeStringSorted(string s) {
        int freq[26] = {}, n = size(s), MOD = 1'000'000'007;
        for (auto& c : s) ++freq[c - 'a'];

        auto power = [](long x, int p, int m) {
            long ans = 1;
            while (p) {
                if (p & 1) {
                    ans = ans * x % m;
                    --p;
                } else {
                    x = x * x % m;
                    p /= 2;
                }
            }
            return ans;
        };

        long ans = 0, fac = 1;
        vector<long> ifac(n+1, 1); // +1 buffer

        for (int i = 1; i < n; ++i) {
            fac = fac * i % MOD;
            ifac[i] = power(fac, MOD-2, MOD); // Fermat's little theorem
        }

        for (auto& x : freq) fac = fac * ifac[x] % MOD;

        for (int i = 0; i < n; ++i) {
            for (int k = 0; k < s[i] - 'a'; ++k)
                ans = (ans + fac * freq[k]) % MOD;
            fac = fac * power(n-i-1, MOD-2, MOD) % MOD;
            fac = fac * freq[s[i] - 'a'] % MOD;
            --freq[s[i] - 'a'];
        }
        return ans;
    }


    /*1832. Check if the Sentence Is Pangram (Easy)
    A pangram is a sentence where every letter of the English alphabet appears
    at least once. Given a string sentence containing only lowercase English
    letters, return true if sentence is a pangram, or false otherwise.

    Example 1:
    Input: sentence = "thequickbrownfoxjumpsoverthelazydog"
    Output: true
    Explanation: sentence contains at least one of every letter of the English alphabet.

    Example 2:
    Input: sentence = "leetcode"
    Output: false

    Constraints:
    * 1 <= sentence.length <= 1000
    * sentence consists of lowercase English letters.*/

    bool checkIfPangram(string sentence) {
        unordered_set<char> seen;
        for (auto x : sentence) {
            seen.insert(x);
        }
        return seen.size() == 26;
    }


    /*1833. Maximum Ice Cream Bars (Medium)
    It is a sweltering summer day, and a boy wants to buy some ice cream bars.
    At the store, there are n ice cream bars. You are given an array costs of
    length n, where costs[i] is the price of the ith ice cream bar in coins.
    The boy initially has coins coins to spend, and he wants to buy as many ice
    cream bars as possible. Return the maximum number of ice cream bars the boy
    can buy with coins coins. Note: The boy can buy the ice cream bars in any
    order.

    Example 1:
    Input: costs = [1,3,2,4,1], coins = 7
    Output: 4
    Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total
                 price of 1 + 3 + 2 + 1 = 7.

    Example 2:
    Input: costs = [10,6,8,7,7,8], coins = 5
    Output: 0
    Explanation: The boy cannot afford any of the ice cream bars.

    Example 3:
    Input: costs = [1,6,3,1,2,5], coins = 20
    Output: 6
    Explanation: The boy can buy all the ice cream bars for a total price of
                 1 + 6 + 3 + 1 + 2 + 5 = 18.

    Constraints:
    * costs.length == n
    * 1 <= n <= 10^5
    * 1 <= costs[i] <= 10^5
    * 1 <= coins <= 10^8*/

    int maxIceCream(vector<int>& costs, int coins) {
        int ans = 0;
        sort(costs.begin(), costs.end());
        for (int i = 0; i < costs.size(); ++i) {
            if (costs[i] <= coins) {
                ++ans;
                coins -= costs[i];
            } else break;
        }
        return ans;
    }


    /*1834. Single-Threaded CPU (Medium)
    You are given n tasks labeled from 0 to n - 1 represented by a 2D
    integer array tasks, where tasks[i] = [enqueueTimei, processingTimei]
    means that the ith task will be available to process at enqueueTimei
    and will take processingTimei to finish processing. You have a single-
    threaded CPU that can process at most one task at a time and will act in
    the following way:
    * If the CPU is idle and there are no available tasks to process, the CPU
      remains idle.
    * If the CPU is idle and there are available tasks, the CPU will choose the
      one with the shortest processing time. If multiple tasks have the same
      shortest processing time, it will choose the task with the smallest index.
    * Once a task is started, the CPU will process the entire task without stopping.
    * The CPU can finish a task then start a new one instantly.
    Return the order in which the CPU will process the tasks.

    Example 1:
    Input: tasks = [[1,2],[2,4],[3,2],[4,1]]
    Output: [0,2,3,1]
    Explanation: The events go as follows:
    - At time = 1, task 0 is available to process. Available tasks = {0}.
    - Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.
    - At time = 2, task 1 is available to process. Available tasks = {1}.
    - At time = 3, task 2 is available to process. Available tasks = {1, 2}.
    - Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.
    - At time = 4, task 3 is available to process. Available tasks = {1, 3}.
    - At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.
    - At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.
    - At time = 10, the CPU finishes task 1 and becomes idle.

    Example 2:
    Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
    Output: [4,3,2,0,1]
    Explanation: The events go as follows:
    - At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.
    - Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.
    - At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.
    - At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.
    - At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.
    - At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.
    - At time = 40, the CPU finishes task 1 and becomes idle.

    Constraints:
    * tasks.length == n
    * 1 <= n <= 10^5
    * 1 <= enqueueTimei, processingTimei <= 10^9*/

    vector<int> getOrder(vector<vector<int>>& tasks) {
        for (int i = 0; i < tasks.size(); ++i) tasks[i].push_back(i);
        sort(tasks.begin(), tasks.end()); // ascending order

        vector<int> ans;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // min-heap

        for (long i = 0, time = 0; pq.size() || i < tasks.size(); ) {
            for ( ; i < tasks.size() && tasks[i][0] <= time; ++i) {
                pq.emplace(tasks[i][1], tasks[i][2]);
            }

            if (pq.size()) {
                auto [prc, index] = pq.top();
                pq.pop();
                ans.push_back(index);
                time += prc;
            } else {
                time = tasks[i][0];
            }
        }
        return ans;
    }


    /*1835. Find XOR Sum of All Pairs Bitwise AND (Hard)
    The XOR sum of a list is the bitwise XOR of all its elements. If the list
    only contains one element, then its XOR sum will be equal to this element.
    For example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 4 = 4,
    and the XOR sum of [3] is equal to 3. You are given two 0-indexed arrays
    arr1 and arr2 that consist only of non-negative integers. Consider the list
    containing the result of arr1[i] AND arr2[j] (bitwise AND) for every (i, j)
    pair where 0 <= i < arr1.length and 0 <= j < arr2.length. Return the XOR
    sum of the aforementioned list.

    Example 1:
    Input: arr1 = [1,2,3], arr2 = [6,5]
    Output: 0
    Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1].
    The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.

    Example 2:
    Input: arr1 = [12], arr2 = [4]
    Output: 4
    Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4.

    Constraints:
    * 1 <= arr1.length, arr2.length <= 10^5
    * 0 <= arr1[i], arr2[j] <= 10^9*/

    int getXORSum(vector<int>& arr1, vector<int>& arr2) {
        return accumulate(arr1.begin(), arr1.end(), 0, bit_xor()) & accumulate(arr2.begin(), arr2.end(), 0, bit_xor());
    }


    /*1836. Remove Duplicates From an Unsorted Linked List (Medium)
    Given the head of a linked list, find all the values that appear more than
    once in the list and delete the nodes that have any of those values. Return
    the linked list after the deletions.

    Example 1:
    Input: head = [1,2,3,2]
    Output: [1,3]
    Explanation: 2 appears twice in the linked list, so all 2's should be
                 deleted. After deleting all 2's, we are left with [1,3].

    Example 2:
    Input: head = [2,1,1,2]
    Output: []
    Explanation: 2 and 1 both appear twice. All the elements should be deleted.

    Example 3:
    Input: head = [3,2,2,1,3,2,4]
    Output: [1,4]
    Explanation: 3 appears twice and 2 appears three times. After deleting all
                 3's and 2's, we are left with [1,4].

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5]
    * 1 <= Node.val <= 10^5*/

    ListNode* deleteDuplicatesUnsorted(ListNode* head) {
        unordered_map<int, int> freq;
        for (ListNode* node = head; node; node = node->next) freq[node->val]++;

        ListNode* dummy = new ListNode(0, head);
        for (ListNode* node = dummy; node->next; ) {
            if (freq[node->next->val] > 1) node->next = node->next->next;
            else node = node->next;
        }
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;
    }


    /*1837. Sum of Digits in Base K (Easy)
    Given an integer n (in base 10) and a base k, return the sum of the digits
    of n after converting n from base 10 to base k. After converting, each
    digit should be interpreted as a base 10 number, and the sum should be
    returned in base 10.

    Example 1:
    Input: n = 34, k = 6
    Output: 9
    Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.

    Example 2:
    Input: n = 10, k = 10
    Output: 1
    Explanation: n is already in base 10. 1 + 0 = 1.

    Constraints:
    * 1 <= n <= 100
    * 2 <= k <= 10*/

    int sumBase(int n, int k) {
        int ans = 0;
        while (n) {
            ans += n % k;
            n /= k;
        }
        return ans;
    }


    /*1838. Frequency of the Most Frequent Element (Medium)
    The frequency of an element is the number of times it occurs in an array.
    You are given an integer array nums and an integer k. In one operation, you
    can choose an index of nums and increment the element at that index by 1.
    Return the maximum possible frequency of an element after performing at
    most k operations.

    Example 1:
    Input: nums = [1,2,4], k = 5
    Output: 3
    Explanation: Increment the first element three times and the second element
                 two times to make nums = [4,4,4]. 4 has a frequency of 3.

    Example 2:
    Input: nums = [1,4,8,13], k = 5
    Output: 2
    Explanation: There are multiple optimal solutions:
    - Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
    - Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
    - Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.

    Example 3:
    Input: nums = [3,9,6], k = 2
    Output: 1

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= 10^5*/

    int maxFrequency(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());

        int ans = 0, ii = 0;
        long sm = 0;
        for (int i = 0; i < nums.size(); ++i) {
            sm += nums[i];
            while (sm + k < (long) nums[i]*(i-ii+1)) {
                sm -= nums[ii];
                ii += 1;
            }
            ans = max(ans, i - ii + 1);
        }
        return ans;
    }


    /*1839. Longest Substring Of All Vowels in Order (Medium)
    A string is considered beautiful if it satisfies the following conditions:
    * Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at
      least once in it.
    * The letters must be sorted in alphabetical order (i.e. all 'a's before
      'e's, all 'e's before 'i's, etc.).
    For example, strings "aeiou" and "aaaaaaeiiiioou" are considered beautiful,
    but "uaeio", "aeoiu", and "aaaeeeooo" are not beautiful. Given a string
    word consisting of English vowels, return the length of the longest
    beautiful substring of word. If no such substring exists, return 0. A
    substring is a contiguous sequence of characters in a string.

    Example 1:
    Input: word = "aeiaaioaaaaeiiiiouuuooaauuaeiu"
    Output: 13
    Explanation: The longest beautiful substring in word is "aaaaeiiiiouuu" of
                 length 13.

    Example 2:
    Input: word = "aeeeiiiioooauuuaeiou"
    Output: 5
    Explanation: The longest beautiful substring in word is "aeiou" of length 5.

    Example 3:
    Input: word = "a"
    Output: 0
    Explanation: There is no beautiful substring, so return 0.

    Constraints:
    * 1 <= word.length <= 5 * 10^5
    * word consists of characters 'a', 'e', 'i', 'o', and 'u'.*/

    int longestBeautifulSubstring(string word) {
        int ans = 0, cnt = 1, unique = 1;
        for (int i = 1; i < word.size(); ++i) {
            if (word[i-1] <= word[i]) {
                ++cnt;
                if (word[i-1] < word[i]) ++unique;
            } else {
                cnt = unique = 1;
            }
            if (unique == 5) ans = max(ans, cnt);
        }
        return ans;
    }


    /*1840. Maximum Building Height (Hard)
    You want to build n new buildings in a city. The new buildings will be
    built in a line and are labeled from 1 to n. However, there are city
    restrictions on the heights of the new buildings:
    * The height of each building must be a non-negative integer.
    * The height of the first building must be 0.
    * The height difference between any two adjacent buildings cannot exceed 1.
    Additionally, there are city restrictions on the maximum height of specific
    buildings. These restrictions are given as a 2D integer array restrictions
    where restrictions[i] = [idi, maxHeighti] indicates that building idi must
    have a height less than or equal to maxHeighti. It is guaranteed that each
    building will appear at most once in restrictions, and building 1 will not
    be in restrictions. Return the maximum possible height of the tallest
    building.

    Example 1:
    Input: n = 5, restrictions = [[2,1],[4,1]]
    Output: 2
    Explanation: The green area in the image indicates the maximum allowed
                 height for each building. We can build the buildings with
                 heights [0,1,2,1,2], and the tallest building has a height of
                 2.

    Example 2:
    Input: n = 6, restrictions = []
    Output: 5
    Explanation: The green area in the image indicates the maximum allowed
                 height for each building. We can build the buildings with
                 heights [0,1,2,3,4,5], and the tallest building has a height
                 of 5.

    Example 3:
    Input: n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]
    Output: 5
    Explanation: The green area in the image indicates the maximum allowed
                 height for each building. We can build the buildings with
                 heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a
                 height of 5.

    Constraints:
    * 2 <= n <= 10^9
    * 0 <= restrictions.length <= min(n - 1, 10^5)
    * 2 <= idi <= n
    * idi is unique.
    * 0 <= maxHeighti <= 10^9*/

    int maxBuilding(int n, vector<vector<int>>& restrictions) {
        restrictions.push_back({1, 0});
        restrictions.push_back({n, n-1});
        sort(restrictions.begin(), restrictions.end());
        for (int i = restrictions.size()-2; i >= 0; --i) {
            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1] + restrictions[i+1][0] - restrictions[i][0]);
        }

        int ans = 0;
        for (int i = 1; i < restrictions.size(); ++i) {
            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0]);
            ans = max(ans, (restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0] + restrictions[i][1])/2);
        }
        return ans;
    }


    /*1842. Next Palindrome Using Same Digits (Hard)
    You are given a numeric string num, representing a very large palindrome.
    Return the smallest palindrome larger than num that can be created by
    rearranging its digits. If no such palindrome exists, return an empty
    string "". A palindrome is a number that reads the same backward as
    forward.

    Example 1:
    Input: num = "1221"
    Output: "2112"
    Explanation: The next palindrome larger than "1221" is "2112".

    Example 2:
    Input: num = "32123"
    Output: ""
    Explanation: No palindromes larger than "32123" can be made by rearranging the digits.

    Example 3:
    Input: num = "45544554"
    Output: "54455445"
    Explanation: The next palindrome larger than "45544554" is "54455445".

    Constraints:
    * 1 <= num.length <= 10^5
    * num is a palindrome.*/

    string nextPalindrome(string num) {
        for (int n = num.size(), i = n/2-2; i >= 0; --i)
            if (num[i] < num[i+1]) {
                int ii = i+1;
                for (int j = i+1; j < n/2; ++j)
                    if (num[i] < num[j]) ii = j;
                swap(num[i], num[ii]);
                reverse(num.begin()+i+1, num.begin()+n/2);
                for (int i = (n+1)/2; i < n; ++i) num[i] = num[n-1-i];
                return num;
            }
        return "";
    }


    /*1844. Replace All Digits with Characters (Easy)
    You are given a 0-indexed string s that has lowercase English letters in
    its even indices and digits in its odd indices. There is a function
    shift(c, x), where c is a character and x is a digit, that returns the xth
    character after c.
    * For example, shift('a', 5) = 'f' and shift('x', 0) = 'x'.
    For every odd index i, you want to replace the digit s[i] with
    shift(s[i-1], s[i]). Return s after replacing all digits. It is guaranteed
    that shift(s[i-1], s[i]) will never exceed 'z'.

    Example 1:
    Input: s = "a1c1e1"
    Output: "abcdef"
    Explanation: The digits are replaced as follows:
                 - s[1] -> shift('a',1) = 'b'
                 - s[3] -> shift('c',1) = 'd'
                 - s[5] -> shift('e',1) = 'f'

    Example 2:
    Input: s = "a1b2c3d4e"
    Output: "abbdcfdhe"
    Explanation: The digits are replaced as follows:
                 - s[1] -> shift('a',1) = 'b'
                 - s[3] -> shift('b',2) = 'd'
                 - s[5] -> shift('c',3) = 'f'
                 - s[7] -> shift('d',4) = 'h'

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of lowercase English letters and digits.
    * shift(s[i-1], s[i]) <= 'z' for all odd indices i.*/

    string replaceDigits(string s) {
        for (int i = 1; i < s.size(); i += 2)
            s[i] += s[i-1] - '0';
        return s;
    }


    /*1846. Maximum Element After Decreasing and Rearranging (Medium)
    You are given an array of positive integers arr. Perform some operations
    (possibly none) on arr so that it satisfies these conditions:
    * The value of the first element in arr must be 1.
    * The absolute difference between any 2 adjacent elements must be less than
      or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i
      where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
    There are 2 types of operations that you can perform any number of times:
    * Decrease the value of any element of arr to a smaller positive integer.
    * Rearrange the elements of arr to be in any order.
    Return the maximum possible value of an element in arr after performing the
    operations to satisfy the conditions.

    Example 1:
    Input: arr = [2,2,1,2,1]
    Output: 2
    Explanation: We can satisfy the conditions by rearranging arr so it becomes
                 [1,2,2,2,1]. The largest element in arr is 2.

    Example 2:
    Input: arr = [100,1,1000]
    Output: 3
    Explanation: One possible way to satisfy the conditions is by doing the
                 following:
                 1. Rearrange arr so it becomes [1,100,1000].
                 2. Decrease the value of the second element to 2.
                 3. Decrease the value of the third element to 3.
                 Now arr = [1,2,3], which satisfies the conditions. The largest
                 element in arr is 3.

    Example 3:
    Input: arr = [1,2,3,4,5]
    Output: 5
    Explanation: The array already satisfies the conditions, and the largest
                 element is 5.

    Constraints:
    * 1 <= arr.length <= 10^5
    * 1 <= arr[i] <= 10^9*/

    int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {
        sort(arr.begin(), arr.end());
        int ans = 0;
        for (auto& x : arr) ans = min(1 + ans, x);
        return ans;
    }


    /*1847. Closest Room (Hard)
    There is a hotel with n rooms. The rooms are represented by a 2D integer
    array rooms where rooms[i] = [roomIdi, sizei] denotes that there is a room
    with room number roomIdi and size equal to sizei. Each roomIdi is
    guaranteed to be unique. You are also given k queries in a 2D array queries
    where queries[j] = [preferredj, minSizej]. The answer to the jth query is
    the room number id of a room such that:
    * The room has a size of at least minSizej, and
    * abs(id - preferredj) is minimized, where abs(x) is the absolute value of
      x.
    If there is a tie in the absolute difference, then use the room with the
    smallest such id. If there is no such room, the answer is -1. Return an
    array answer of length k where answer[j] contains the answer to the jth
    query.

    Example 1:
    Input: rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]
    Output: [3,-1,3]
    Explanation: The answers to the queries are as follows:
    Query = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.
    Query = [3,3]: There are no rooms with a size of at least 3, so the answer is -1.
    Query = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3.

    Example 2:
    Input: rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]
    Output: [2,1,3]
    Explanation: The answers to the queries are as follows:
    Query = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.
    Query = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.
    Query = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3.

    Constraints:
    * n == rooms.length
    * 1 <= n <= 10^5
    * k == queries.length
    * 1 <= k <= 10^4
    * 1 <= roomIdi, preferredj <= 10^7
    * 1 <= sizei, minSizej <= 10^7*/

    vector<int> closestRoom(vector<vector<int>>& rooms, vector<vector<int>>& queries) {
        for (int i = 0; i < queries.size(); ++i) queries[i].push_back(i);

        sort(rooms.begin(), rooms.end(), [](auto& lhs, auto& rhs){ return lhs[1] > rhs[1]; });
        sort(queries.begin(), queries.end(), [](auto& lhs, auto& rhs){ return lhs[1] > rhs[1]; });

        set<int> st; // symbol table
        vector<int> ans(queries.size(), -1);
        for (int i = 0, k = 0; i < queries.size(); ++i) {
            while (k < rooms.size() && rooms[k][1] >= queries[i][1])
                st.insert(rooms[k++][0]);
            if (st.size()) {
                auto it = st.upper_bound(queries[i][0]);
                int diff = INT_MAX;
                if (it != st.end()) diff = *it - queries[i][0];
                if (it != st.begin() && queries[i][0] - *prev(it) <= diff) --it;
                ans[queries[i][2]] = *it;
            }
        }
        return ans;
    }


    /*1848. Minimum Distance to the Target Element (Easy)
    Given an integer array nums (0-indexed) and two integers target and start,
    find an index i such that nums[i] == target and abs(i - start) is minimized.
    Note that abs(x) is the absolute value of x. Return abs(i - start). It is
    guaranteed that target exists in nums.

    Example 1:
    Input: nums = [1,2,3,4,5], target = 5, start = 3
    Output: 1
    Explanation: nums[4] = 5 is the only value equal to target, so the answer
                 is abs(4 - 3) = 1.

    Example 2:
    Input: nums = [1], target = 1, start = 0
    Output: 0
    Explanation: nums[0] = 1 is the only value equal to target, so the answer
                 is abs(0 - 0) = 0.

    Example 3:
    Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
    Output: 0
    Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start),
                 which is abs(0 - 0) = 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^4
    * 0 <= start < nums.length
    * target is in nums.*/

    int getMinDistance(vector<int>& nums, int target, int start) {
        int ans = INT_MAX;
        for (int i = 0; i < nums.size() && ans > abs(start - i); ++i)
            if (nums[i] == target)
                ans = abs(start - i);
        return ans;
    }


    /*1849. Splitting a String Into Descending Consecutive Values (Medium)
    You are given a string s that consists of only digits. Check if we can
    split s into two or more non-empty substrings such that the numerical
    values of the substrings are in descending order and the difference between
    numerical values of every two adjacent substrings is equal to 1. For
    example, the string s = "0090089" can be split into ["0090", "089"] with
    numerical values [90,89]. The values are in descending order and adjacent
    values differ by 1, so this way is valid. Another example, the string
    s = "001" can be split into ["0", "01"], ["00", "1"], or ["0", "0", "1"].
    However all the ways are invalid because they have numerical values [0,1],
    [0,1], and [0,0,1] respectively, all of which are not in descending order.
    Return true if it is possible to split s​​​​​​ as described above, or false
    otherwise. A substring is a contiguous sequence of characters in a string.

    Example 1:
    Input: s = "1234"
    Output: false
    Explanation: There is no valid way to split s.

    Example 2:
    Input: s = "050043"
    Output: true
    Explanation: s can be split into ["05", "004", "3"] with numerical values
                 [5,4,3]. The values are in descending order with adjacent
                 values differing by 1.

    Example 3:
    Input: s = "9080701"
    Output: false
    Explanation: There is no valid way to split s.

    Example 4:
    Input: s = "10009998"
    Output: true
    Explanation: s can be split into ["100", "099", "98"] with numerical values
                 [100,99,98]. The values are in descending order with adjacent
                 values differing by 1.

    Constraints:
    * 1 <= s.length <= 20
    * s only consists of digits.*/

    bool splitString(string s) {

        function<bool(int, double)> fn = [&](int i, long prev) {
            if (i == s.size()) return true;
            long curr = 0;
            for (int ii = i; ii < s.size() - (prev < 0) && curr < 10'000'000'000; ++ii) {
                curr = curr*10 + (s[ii] - '0');
                if ((prev < 0 || prev - 1 == curr) && fn(ii+1, curr)) return true;
            }
            return false;
        };

        return fn(0, -1);
    }


    /*1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number (Medium)
    You are given a string num, representing a large integer, and an integer k.
    We call some integer wonderful if it is a permutation of the digits in num
    and is greater in value than num. There can be many wonderful integers.
    However, we only care about the smallest-valued ones.

    For example, when num = "5489355142":
    * The 1st smallest wonderful integer is "5489355214".
    * The 2nd smallest wonderful integer is "5489355241".
    * The 3rd smallest wonderful integer is "5489355412".
    * The 4th smallest wonderful integer is "5489355421".
    Return the minimum number of adjacent digit swaps that needs to be applied
    to num to reach the kth smallest wonderful integer. The tests are generated
    in such a way that kth smallest wonderful integer exists.

    Example 1:
    Input: num = "5489355142", k = 4
    Output: 2
    Explanation: The 4th smallest wonderful number is "5489355421". To get this
                 number:
                 - Swap index 7 with index 8: "5489355142" -> "5489355412"
                 - Swap index 8 with index 9: "5489355412" -> "5489355421"

    Example 2:
    Input: num = "11112", k = 4
    Output: 4
    Explanation: The 4th smallest wonderful number is "21111". To get this number:
                 - Swap index 3 with index 4: "11112" -> "11121"
                 - Swap index 2 with index 3: "11121" -> "11211"
                 - Swap index 1 with index 2: "11211" -> "12111"
                 - Swap index 0 with index 1: "12111" -> "21111"

    Example 3:
    Input: num = "00123", k = 1
    Output: 1
    Explanation: The 1st smallest wonderful number is "00132". To get this number:
                 - Swap index 3 with index 4: "00123" -> "00132"

    Constraints:
    * 2 <= num.length <= 1000
    * 1 <= k <= 1000
    * num only consists of digits.*/

    int getMinSwaps(string num, int k) {
        string perm = num;
        while (k--)
            next_permutation(perm.begin(), perm.end());

        int ans = 0;
        for (int i = 0; i < num.size(); ++i) {
            int ii = i;
            while (num[i] != perm[i]) {
                ++ans;
                swap(perm[i], perm[++ii]);
            }
        }
        return ans;
    }


    /*1851. Minimum Interval to Include Each Query (Hard)
    You are given a 2D integer array intervals, where
    intervals[i] = [lefti, righti] describes the ith interval starting at lefti
    and ending at righti (inclusive). The size of an interval is defined as the
    number of integers it contains, or more formally righti - lefti + 1. You
    are also given an integer array queries. The answer to the jth query is the
    size of the smallest interval i such that lefti <= queries[j] <= righti. If
    no such interval exists, the answer is -1. Return an array containing the
    answers to the queries.

    Example 1:
    Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
    Output: [3,3,1,4]
    Explanation: The queries are processed as follows:
    - Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.
    - Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.
    - Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.
    - Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.

    Example 2:
    Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
    Output: [2,-1,4,6]
    Explanation: The queries are processed as follows:
    - Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.
    - Query = 19: None of the intervals contain 19. The answer is -1.
    - Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.
    - Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.

    Constraints:
    * 1 <= intervals.length <= 10^5
    * 1 <= queries.length <= 10^5
    * intervals[i].length == 2
    * 1 <= lefti <= righti <= 10^7
    * 1 <= queries[j] <= 10^7*/

    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        sort(intervals.begin(), intervals.end());

        vector<pair<int, int>> aug; // augmented array to queries
        for (int i = 0; i < queries.size(); ++i)
            aug.emplace_back(queries[i], i);
        sort(aug.begin(), aug.end());

        int k = 0;
        vector<int> ans(queries.size(), -1);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // min-heap
        for (auto& [query, i] : aug) {
            for (; k < intervals.size() && intervals[k][0] <= query; ++k)
                pq.emplace(intervals[k][1] - intervals[k][0], intervals[k][1]);
            while (pq.size() && pq.top().second < query)
                pq.pop();
            if (pq.size())
                ans[i] = 1 + pq.top().first;
        }
        return ans;
    }


    /*1852. Distinct Numbers in Each Subarray (Medium)
    Given an integer array nums and an integer k, you are asked to construct
    the array ans of size n-k+1 where ans[i] is the number of distinct numbers
    in the subarray nums[i:i+k-1] = [nums[i], nums[i+1], ..., nums[i+k-1]].
    Return the array ans.

    Example 1:
    Input: nums = [1,2,3,2,2,1,3], k = 3
    Output: [3,2,2,2,3]
    Explanation: The number of distinct elements in each subarray goes as follows:
                 - nums[0:2] = [1,2,3] so ans[0] = 3
                 - nums[1:3] = [2,3,2] so ans[1] = 2
                 - nums[2:4] = [3,2,2] so ans[2] = 2
                 - nums[3:5] = [2,2,1] so ans[3] = 2
                 - nums[4:6] = [2,1,3] so ans[4] = 3

    Example 2:
    Input: nums = [1,1,1,1,2,3,4], k = 4
    Output: [1,2,3,4]
    Explanation: The number of distinct elements in each subarray goes as follows:
                 - nums[0:3] = [1,1,1,1] so ans[0] = 1
                 - nums[1:4] = [1,1,1,2] so ans[1] = 2
                 - nums[2:5] = [1,1,2,3] so ans[2] = 3
                 - nums[3:6] = [1,2,3,4] so ans[3] = 4

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    vector<int> distinctNumbers(vector<int>& nums, int k) {
        vector<int> ans;
        unordered_map<int, int> freq;
        for (int i = 0; i < nums.size(); ++i) {
            freq[nums[i]]++;
            if (i >= k && --freq[nums[i-k]] == 0) freq.erase(nums[i-k]);
            if (i+1 >= k) ans.push_back(freq.size());
        }
        return ans;
    }


    /*1854. Maximum Population Year (Easy)
    You are given a 2D integer array logs where each logs[i] = [birthi, deathi]
    indicates the birth and death years of the ith person. The population of
    some year x is the number of people alive during that year. The ith person
    is counted in year x's population if x is in the inclusive range
    [birthi, deathi - 1]. Note that the person is not counted in the year that
    they die. Return the earliest year with the maximum population.

    Example 1:
    Input: logs = [[1993,1999],[2000,2010]]
    Output: 1993
    Explanation: The maximum population is 1, and 1993 is the earliest year
                 with this population.

    Example 2:
    Input: logs = [[1950,1961],[1960,1971],[1970,1981]]
    Output: 1960
    Explanation: The maximum population is 2, and it had happened in years 1960
                 and 1970. The earlier year between them is 1960.

    Constraints:
    * 1 <= logs.length <= 100
    * 1950 <= birthi < deathi <= 2050*/

    int maximumPopulation(vector<vector<int>>& logs) {
        vector<pair<int, int>> vals;
        for (auto log : logs) {
            vals.push_back(make_pair(log[0], 1));
            vals.push_back(make_pair(log[1], -1));
        }
        sort(vals.begin(), vals.end());

        int ans = 0, prefix = 0, most = 0;
        for (auto val : vals) {
            prefix += val.second;
            if (prefix > most) {
                most = prefix;
                ans = val.first;
            }
        }
        return ans;
    }


    /*1855. Maximum Distance Between a Pair of Values (Medium)
    You are given two non-increasing 0-indexed integer arrays nums1 and
    nums2. A pair of indices (i, j), where 0 <= i < nums1.length and
    0 <= j < nums2.length, is valid if both i <= j and nums1[i] <= nums2[j].
    The distance of the pair is j - i. Return the maximum distance of any
    valid pair (i, j). If there are no valid pairs, return 0. An array arr
    is non-increasing if arr[i-1] >= arr[i] for every 1 <= i < arr.length.

    Example 1:
    Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
    Output: 2
    Explanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4),
                 and (4,4). The maximum distance is 2 with pair (2,4).

    Example 2:
    Input: nums1 = [2,2,2], nums2 = [10,10,1]
    Output: 1
    Explanation: The valid pairs are (0,0), (0,1), and (1,1). The maximum
                 distance is 1 with pair (0,1).

    Example 3:
    Input: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
    Output: 2
    Explanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).
                 The maximum distance is 2 with pair (2,4).

    Example 4:
    Input: nums1 = [5,4], nums2 = [3,2]
    Output: 0
    Explanation: There are no valid pairs, so return 0.

    Constraints:
    * 1 <= nums1.length <= 10^5
    * 1 <= nums2.length <= 10^5
    * 1 <= nums1[i], nums2[j] <= 10^5
    * Both nums1 and nums2 are non-increasing.*/

    int maxDistance(vector<int>& nums1, vector<int>& nums2) {
        int ans = 0, i = 0;
        for (int j = 0; j < nums2.size(); ++j) {
            while (i < nums1.size() && nums1[i] > nums2[j]) ++i;
            if (i < nums1.size())
                ans = max(ans, j - i);
        }
        return ans;
    }


    /*1856. Maximum Subarray Min-Product (Medium)
    The min-product of an array is equal to the minimum value in the array
    multiplied by the array's sum. For example, the array [3,2,5] (minimum
    value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20. Given an array
    of integers nums, return the maximum min-product of any non-empty subarray
    of nums. Since the answer may be large, return it modulo 10^9 + 7. Note
    that the min-product should be maximized before performing the modulo
    operation. Testcases are generated such that the maximum min-product
    without modulo will fit in a 64-bit signed integer. A subarray is a
    contiguous part of an array.

    Example 1:
    Input: nums = [1,2,3,2]
    Output: 14
    Explanation: The maximum min-product is achieved with the subarray [2,3,2]
                 (minimum value is 2). 2 * (2+3+2) = 2 * 7 = 14.

    Example 2:
    Input: nums = [2,3,3,1,2]
    Output: 18
    Explanation: The maximum min-product is achieved with the subarray [3,3]
                 (minimum value is 3). 3 * (3+3) = 3 * 6 = 18.

    Example 3:
    Input: nums = [3,1,5,6,4,2]
    Output: 60
    Explanation: The maximum min-product is achieved with the subarray [5,6,4]
                 (minimum value is 4). 4 * (5+6+4) = 4 * 15 = 60.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^7*/

    int maxSumMinProduct(vector<int>& nums) {
        vector<long> prefix = {0};
        for (auto x : nums)
            prefix.push_back(prefix.back() + x);

        long ans = 0;
        stack<pair<int, int>> stk;
        nums.push_back(0);

        for (int i = 0; i < nums.size(); ++i) {
            int ii = i;
            while (stk.size() && stk.top().second >= nums[i]) {
                ii = stk.top().first;
                int val = stk.top().second;
                ans = max(ans, val * (prefix[i] - prefix[ii]));
                stk.pop();
            }
            stk.push(make_pair(ii, nums[i]));
        }
        return ans % 1'000'000'007;
    }


    /*1857. Largest Color Value in a Directed Graph (Hard)
    There is a directed graph of n colored nodes and m edges. The nodes are
    numbered from 0 to n - 1. You are given a string colors where colors[i] is
    a lowercase English letter representing the color of the ith node in this
    graph (0-indexed). You are also given a 2D array edges where
    edges[j] = [aj, bj] indicates that there is a directed edge from node aj to
    node bj. A valid path in the graph is a sequence of nodes
    x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to
    xi+1 for every 1 <= i < k. The color value of the path is the number of
    nodes that are colored the most frequently occurring color along that path.
    Return the largest color value of any valid path in the given graph, or -1
    if the graph contains a cycle.

    Example 1:
    Input: colors = "abaca", edges = [[0,1],[0,2],[2,3],[3,4]]
    Output: 3
    Explanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored "a"
                 (red in the above image).

    Example 2:
    Input: colors = "a", edges = [[0,0]]
    Output: -1
    Explanation: There is a cycle from 0 to 0.

    Constraints:
    * n == colors.length
    * m == edges.length
    * 1 <= n <= 10^5
    * 0 <= m <= 10^5
    * colors consists of lowercase English letters.
    * 0 <= aj, bj < n*/

    int largestPathValue(string colors, vector<vector<int>>& edges) {
        int n = colors.size();

        unordered_map<int, vector<int>> graph;
        vector<int> indeg(n);
        for (auto edge : edges) {
            ++indeg[edge[1]];
            graph[edge[0]].push_back(edge[1]);
        }

        stack<int> stk;
        for (int i = 0; i < n; ++i) {
            if (indeg[i] == 0) stk.push(i);
        }

        // topological sort via Kahn's algo
        int ans = 0, cnt = 0;
        vector<vector<int>> dp(n, vector<int>(26, 0));
        while (stk.size()) {
            int node = stk.top();
            stk.pop();
            ++cnt;
            ans = max(ans, ++dp[node][colors[node] - 'a']);

            for (auto child : graph[node]) {
                if (--indeg[child] == 0) stk.push(child);
                for (int i = 0; i < 26; ++i) {
                    dp[child][i] = max(dp[node][i], dp[child][i]);
                    ans = max(ans, dp[child][i]);
                }
            }
        }
        return cnt == n ? ans : -1;
    }


    /*1858. Longest Word With All Prefixes (Medium)
    Given an array of strings words, find the longest string in words such that
    every prefix of it is also in words. For example, let
    words = ["a", "app", "ap"]. The string "app" has prefixes "ap" and "a", all
    of which are in words. Return the string described above. If there is more
    than one string with the same length, return the lexicographically smallest
    one, and if no string exists, return "".

    Example 1:
    Input: words = ["k","ki","kir","kira", "kiran"]
    Output: "kiran"
    Explanation: "kiran" has prefixes "kira", "kir", "ki", and "k", and all of
                 them appear in words.

    Example 2:
    Input: words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
    Output: "apple"
    Explanation: Both "apple" and "apply" have all their prefixes in words.
                 However, "apple" is lexicographically smaller, so we return
                 that.

    Example 3:
    Input: words = ["abc", "bc", "ab", "qwe"]
    Output: ""

    Constraints:
    * 1 <= words.length <= 10^5
    * 1 <= words[i].length <= 10^5
    * 1 <= sum(words[i].length) <= 10^5*/

    string longestWord(vector<string>& words) {
        sort(words.begin(), words.end(), [](auto& lhs, auto& rhs) {
            return lhs.size() < rhs.size() || (lhs.size() == rhs.size() && lhs < rhs);
        });

        string ans = "";
        unordered_set<string> seen = {""};
        for (auto& word : words)
            if (seen.count(word.substr(0, word.size()-1))) {
                if (word.size() > ans.size()) ans = word;
                seen.insert(word);
            }
        return ans;
    }


    /*1859. Sorting the Sentence (Easy)
    A sentence is a list of words that are separated by a single space with no
    leading or trailing spaces. Each word consists of lowercase and uppercase
    English letters. A sentence can be shuffled by appending the 1-indexed word
    position to each word then rearranging the words in the sentence. For
    example, the sentence "This is a sentence" can be shuffled as
    "sentence4 a3 is2 This1" or "is2 sentence4 This1 a3". Given a shuffled
    sentence s containing no more than 9 words, reconstruct and return the
    original sentence.

    Example 1:
    Input: s = "is2 sentence4 This1 a3"
    Output: "This is a sentence"
    Explanation: Sort the words in s to their original positions
                 "This1 is2 a3 sentence4", then remove the numbers.

    Example 2:
    Input: s = "Myself2 Me1 I4 and3"
    Output: "Me Myself and I"
    Explanation: Sort the words in s to their original positions
                 "Me1 Myself2 and3 I4", then remove the numbers.

    Constraints:
    * 2 <= s.length <= 200
    * s consists of lowercase and uppercase English letters, spaces, and digits from 1 to 9.
    * The number of words in s is between 1 and 9.
    * The words in s are separated by a single space.
    * s contains no leading or trailing spaces.*/

    string sortSentence(string s) {
        vector<string> vals(9);

        istringstream iss(s);
        string word;
        while (iss >> word) {
            vals[word.back()-'1'] = word.substr(0, word.size()-1);
        }

        string ans;
        for (int i = 0; i < vals.size() && vals[i].size(); ++i) {
            if (i) ans += " ";
            ans += vals[i];
        }
        return ans;
    }


    /*1860. Incremental Memory Leak (Medium)
    You are given two integers memory1 and memory2 representing the available
    memory in bits on two memory sticks. There is currently a faulty program
    running that consumes an increasing amount of memory every second. At the
    ith second (starting from 1), i bits of memory are allocated to the stick
    with more available memory (or from the first memory stick if both have the
    same available memory). If neither stick has at least i bits of available
    memory, the program crashes. Return an array containing
    [crashTime, memory1crash, memory2crash], where crashTime is the time (in
    seconds) when the program crashed and memory1crash and memory2crash are the
    available bits of memory in the first and second sticks respectively.

    Example 1:
    Input: memory1 = 2, memory2 = 2
    Output: [3,1,0]
    Explanation: The memory is allocated as follows:
    - At the 1st second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory.
    - At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory.
    - At the 3rd second, the program crashes. The sticks have 1 and 0 bits available respectively.

    Example 2:
    Input: memory1 = 8, memory2 = 11
    Output: [6,0,4]
    Explanation: The memory is allocated as follows:
    - At the 1st second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory.
    - At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory.
    - At the 3rd second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory.
    - At the 4th second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory.
    - At the 5th second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory.
    - At the 6th second, the program crashes. The sticks have 0 and 4 bits available respectively.

    Constraints: 0 <= memory1, memory2 <= 2^31 - 1*/

    vector<int> memLeak(int memory1, int memory2) {
        int ans = 1;
        while (ans <= memory1 || ans <= memory2) {
            if (memory1 < memory2)
                memory2 -= ans;
            else
                memory1 -= ans;
            ans += 1;
        }
        return {ans, memory1, memory2};
    }


    /*1861. Rotating the Box (Medium)
    You are given an m x n matrix of characters box representing a side-view of
    a box. Each cell of the box is one of the following:
    * A stone '#'
    * A stationary obstacle '*'
    * Empty '.'
    The box is rotated 90 degrees clockwise, causing some of the stones to fall
    due to gravity. Each stone falls down until it lands on an obstacle, another
    stone, or the bottom of the box. Gravity does not affect the obstacles'
    positions, and the inertia from the box's rotation does not affect the
    stones' horizontal positions. It is guaranteed that each stone in box rests
    on an obstacle, another stone, or the bottom of the box. Return an n x m
    matrix representing the box after the rotation described above.

    Example 1:
    Input: box = [["#",".","#"]]
    Output: [["."],
             ["#"],
             ["#"]]

    Example 2:
    Input: box = [["#",".","*","."],
                  ["#","#","*","."]]
    Output: [["#","."],
             ["#","#"],
             ["*","*"],
             [".","."]]

    Example 3:
    Input: box = [["#","#","*",".","*","."],
                  ["#","#","#","*",".","."],
                  ["#","#","#",".","#","."]]
    Output: [[".","#","#"],
             [".","#","#"],
             ["#","#","*"],
             ["#","*","."],
             ["#",".","*"],
             ["#",".","."]]

    Constraints:
    * m == box.length
    * n == box[i].length
    * 1 <= m, n <= 500
    * box[i][j] is either '#', '*', or '.'.*/

    vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {
        int m = box.size(), n = box[0].size(); // dimensions
        vector<vector<char>> ans(n, vector<char>(m));

        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                ans[j][i] = box[m-1-i][j];

        for (int j = 0; j < m; ++j) {
            int k = 0;
            for (int i = 0; i < n; ++i) {
                if (ans[i][j] == '#') {
                    ans[i][j] = '.';
                    ++k;
                }
                if (i+1 == n || ans[i+1][j] == '*') {
                    while (k) {
                        ans[i+1-k][j] = '#';
                        --k;
                    }
                }
            }
        }
        return ans;
    }


    /*1862. Sum of Floored Pairs (Hard)
    Given an integer array nums, return the sum of floor(nums[i] / nums[j]) for
    all pairs of indices 0 <= i, j < nums.length in the array. Since the answer
    may be too large, return it modulo 10^9 + 7. The floor() function returns
    the integer part of the division.

    Example 1:
    Input: nums = [2,5,9]
    Output: 10
    Explanation:
    floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0
    floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1
    floor(5 / 2) = 2
    floor(9 / 2) = 4
    floor(9 / 5) = 1
    We calculate the floor of the division for every pair of indices in the
    array then sum them up.

    Example 2:
    Input: nums = [7,7,7,7,7,7,7]
    Output: 49

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    int sumOfFlooredPairs(vector<int>& nums) {
        int m = *max_element(nums.begin(), nums.end());
        vector<int> vals(m+1);
        for (auto x : nums)
            ++vals[x];

        for (int x = m; x > 0; --x)
            for (int xx = 2*x; xx <= m; xx += x)
                vals[xx] += vals[x];

        for (int i = 1; i < vals.size(); ++i)
            vals[i] += vals[i-1];

        int ans = 0;
        for (auto x : nums)
            ans = (ans + vals[x]) % 1'000'000'007;
        return ans;
    }


    /*1863. Sum of All Subset XOR Totals (Easy)
    The XOR total of an array is defined as the bitwise XOR of all its elements,
    or 0 if the array is empty.
    * For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
    Given an array nums, return the sum of all XOR totals for every subset of
    nums. Note that subsets with the same elements should be counted multiple
    times. An array a is a subset of an array b if a can be obtained from b by
    deleting some (possibly zero) elements of b.

    Example 1:
    Input: nums = [1,3]
    Output: 6
    Explanation: The 4 subsets of [1,3] are:
    - The empty subset has an XOR total of 0.
    - [1] has an XOR total of 1.
    - [3] has an XOR total of 3.
    - [1,3] has an XOR total of 1 XOR 3 = 2.
    0 + 1 + 3 + 2 = 6

    Example 2:
    Input: nums = [5,1,6]
    Output: 28
    Explanation: The 8 subsets of [5,1,6] are:
    - The empty subset has an XOR total of 0.
    - [5] has an XOR total of 5.
    - [1] has an XOR total of 1.
    - [6] has an XOR total of 6.
    - [5,1] has an XOR total of 5 XOR 1 = 4.
    - [5,6] has an XOR total of 5 XOR 6 = 3.
    - [1,6] has an XOR total of 1 XOR 6 = 7.
    - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
    0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

    Example 3:
    Input: nums = [3,4,5,6,7,8]
    Output: 480
    Explanation: The sum of all XOR totals for every subset is 480.

    Constraints:
    * 1 <= nums.length <= 12
    * 1 <= nums[i] <= 20*/

    int subsetXORSum(vector<int>& nums) {
        return accumulate(nums.begin(), nums.end(), 0, bit_or<int>()) << nums.size()-1;
    }


    /*1864. Minimum Number of Swaps to Make the Binary String Alternating (Medium)
    Given a binary string s, return the minimum number of character swaps to
    make it alternating, or -1 if it is impossible. The string is called
    alternating if no two adjacent characters are equal. For example, the
    strings "010" and "1010" are alternating, while the string "0100" is not.
    Any two characters may be swapped, even if they are not adjacent.

    Example 1:
    Input: s = "111000"
    Output: 1
    Explanation: Swap positions 1 and 4: "111000" -> "101010". The string is
                 now alternating.

    Example 2:
    Input: s = "010"
    Output: 0
    Explanation: The string is already alternating, no swaps are needed.

    Example 3:
    Input: s = "1110"
    Output: -1

    Constraints:
    * 1 <= s.length <= 1000
    * s[i] is either '0' or '1'.*/

    int minSwaps(string s) {
        int ones = 0;
        for (auto c : s) {
            if (c == '1') ++ones;
        }
        int zeros = s.size() - ones;

        if (abs(ones - zeros) > 1) return -1; // impossible

        auto fn = [&s](char x){
            int cnt = 0;
            for (auto c : s) {
                if (x != c) ++cnt;
                x = x == '0' ? '1' : '0';
            }
            return cnt/2;
        };

        if (ones > zeros) return fn('1');
        else if (ones < zeros) return fn('0');
        else return min(fn('1'), fn('0'));
    }


    /*1866. Number of Ways to Rearrange Sticks With K Sticks Visible (Hard)
    There are n uniquely-sized sticks whose lengths are integers from 1 to n.
    You want to arrange the sticks such that exactly k sticks are visible from
    the left. A stick is visible from the left if there are no longer sticks to
    the left of it. For example, if the sticks are arranged [1,3,2,5,4], then
    the sticks with lengths 1, 3, and 5 are visible from the left. Given n and
    k, return the number of such arrangements. Since the answer may be large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, k = 2
    Output: 3
    Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such
                 that exactly 2 sticks are visible. The visible sticks are
                 underlined.

    Example 2:
    Input: n = 5, k = 5
    Output: 1
    Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are
                 visible. The visible sticks are underlined.

    Example 3:
    Input: n = 20, k = 11
    Output: 647427950
    Explanation: There are 647427950 (mod 10^9 + 7) ways to rearrange the sticks
                 such that exactly 11 sticks are visible.

    Constraints:
    * 1 <= n <= 1000
    * 1 <= k <= n*/

    int rearrangeSticks(int n, int k) {
        vector<vector<long>> dp(n+1, vector<long>(k+1, 0));

        for (int i = 0; i <= k; ++i) dp[i][i] = 1;

        for (int j = 1; j <= k; ++j) {
            for (int i = j+1; i <= n; ++i) {
                dp[i][j] = ((i-1)*dp[i-1][j] + dp[i-1][j-1]) % 1'000'000'007;
            }
        }
        return dp[n][k];
    }


    /*1868. Product of Two Run-Length Encoded Arrays (Medium)
    Run-length encoding is a compression algorithm that allows for an integer
    array nums with many segments of consecutive repeated numbers to be
    represented by a (generally smaller) 2D array encoded. Each
    encoded[i] = [vali, freqi] describes the ith segment of repeated numbers in
    nums where vali is the value that is repeated freqi times. For example,
    nums = [1,1,1,2,2,2,2,2] is represented by the run-length encoded array
    encoded = [[1,3],[2,5]]. Another way to read this is "three 1's followed by
    five 2's". The product of two run-length encoded arrays encoded1 and
    encoded2 can be calculated using the following steps:
    * Expand both encoded1 and encoded2 into the full arrays nums1 and nums2
      respectively.
    * Create a new array prodNums of length nums1.length and set
      prodNums[i] = nums1[i] * nums2[i].
    * Compress prodNums into a run-length encoded array and return it.
    You are given two run-length encoded arrays encoded1 and encoded2
    representing full arrays nums1 and nums2 respectively. Both nums1 and nums2
    have the same length. Each encoded1[i] = [vali, freqi] describes the ith
    segment of nums1, and each encoded2[j] = [valj, freqj] describes the jth
    segment of nums2. Return the product of encoded1 and encoded2.

    Note: Compression should be done such that the run-length encoded array has
          the minimum possible length.

    Example 1:
    Input: encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]]
    Output: [[6,6]]
    Explanation: encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to
                 [6,6,6,3,3,3]. prodNums = [6,6,6,6,6,6], which is compressed
                 into the run-length encoded array [[6,6]].

    Example 2:
    Input: encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]]
    Output: [[2,3],[6,1],[9,2]]
    Explanation: encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to
                 [2,2,2,3,3,3]. prodNums = [2,2,2,6,9,9], which is compressed
                 into the run-length encoded array [[2,3],[6,1],[9,2]].

    Constraints:
    * 1 <= encoded1.length, encoded2.length <= 10^5
    * encoded1[i].length == 2
    * encoded2[j].length == 2
    * 1 <= vali, freqi <= 10^4 for each encoded1[i].
    * 1 <= valj, freqj <= 10^4 for each encoded2[j].
    * The full arrays that encoded1 and encoded2 represent are the same length.*/

    vector<vector<int>> findRLEArray(vector<vector<int>>& encoded1, vector<vector<int>>& encoded2) {
        vector<vector<int>> ans;
        for (int i = 0, j = 0; i < encoded1.size() && j < encoded2.size(); ) {
            int val = encoded1[i][0] * encoded2[j][0], freq = min(encoded1[i][1], encoded2[j][1]);
            if (ans.size() && ans.back()[0] == val) ans.back()[1] += freq;
            else ans.push_back({val, freq});
            if ((encoded1[i][1] -= freq) == 0) ++i;
            if ((encoded2[j][1] -= freq) == 0) ++j;
        }
        return ans;
    }


    /*1869. Longer Contiguous Segments of Ones than Zeros (Easy)
    Given a binary string s, return true if the longest contiguous segment of
    1s is strictly longer than the longest contiguous segment of 0s in s.
    Return false otherwise. For example, in s = "110100010" the longest
    contiguous segment of 1s has length 2, and the longest contiguous segment
    of 0s has length 3. Note that if there are no 0s, then the longest
    contiguous segment of 0s is considered to have length 0. The same applies
    if there are no 1s.

    Example 1:
    Input: s = "1101"
    Output: true
    Explanation:
    The longest contiguous segment of 1s has length 2: "1101"
    The longest contiguous segment of 0s has length 1: "1101"
    The segment of 1s is longer, so return true.

    Example 2:
    Input: s = "111000"
    Output: false
    Explanation:
    The longest contiguous segment of 1s has length 3: "111000"
    The longest contiguous segment of 0s has length 3: "111000"
    The segment of 1s is not longer, so return false.

    Example 3:
    Input: s = "110100010"
    Output: false
    Explanation:
    The longest contiguous segment of 1s has length 2: "110100010"
    The longest contiguous segment of 0s has length 3: "110100010"
    The segment of 1s is not longer, so return false.

    Constraints:
    * 1 <= s.length <= 100
    * s[i] is either '0' or '1'.*/

    bool checkZeroOnes(string s) {
        int ones = 0, zeros = 0, cnt = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (i == 0 || s[i-1] != s[i]) cnt = 0;
            ++cnt;
            if (s[i] == '0') zeros = max(zeros, cnt);
            else ones = max(ones, cnt);
        }
        return ones > zeros;
    }


    /*1870. Minimum Speed to Arrive on Time (Medium)
    You are given a floating-point number hour, representing the amount of time
    you have to reach the office. To commute to the office, you must take n
    trains in sequential order. You are also given an integer array dist of
    length n, where dist[i] describes the distance (in kilometers) of the ith
    train ride. Each train can only depart at an integer hour, so you may need
    to wait in between each train ride. For example, if the 1st train ride
    takes 1.5 hours, you must wait for an additional 0.5 hours before you can
    depart on the 2nd train ride at the 2 hour mark. Return the minimum
    positive integer speed (in kilometers per hour) that all the trains must
    travel at for you to reach the office on time, or -1 if it is impossible to
    be on time. Tests are generated such that the answer will not exceed 10^7
    and hour will have at most two digits after the decimal point.

    Example 1:
    Input: dist = [1,3,2], hour = 6
    Output: 1
    Explanation: At speed 1:
    - The first train ride takes 1/1 = 1 hour.
    - Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
    - Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
    - You will arrive at exactly the 6 hour mark.

    Example 2:
    Input: dist = [1,3,2], hour = 2.7
    Output: 3
    Explanation: At speed 3:
    - The first train ride takes 1/3 = 0.33333 hours.
    - Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
    - Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
    - You will arrive at the 2.66667 hour mark.

    Example 3:
    Input: dist = [1,3,2], hour = 1.9
    Output: -1
    Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.

    Constraints:
    * n == dist.length
    * 1 <= n <= 10^5
    * 1 <= dist[i] <= 10^5
    * 1 <= hour <= 10^9
    * There will be at most two digits after the decimal point in hour.*/

    int minSpeedOnTime(vector<int>& dist, double hour) {
        int lo = 1, hi = 10'000'001;
        while (lo < hi) {
            double mid = lo + (hi - lo)/2, tm = dist.back()/mid;
            for (int i = 0; i < dist.size()-1; ++i)
                tm += ceil(dist[i]/mid);
            if (tm <= hour) hi = mid;
            else lo = mid + 1;
        }
        return lo < 10'000'001 ? lo : -1;
    }


    /*1871. Jump Game VII (Medium)
    You are given a 0-indexed binary string s and two integers minJump and
    maxJump. In the beginning, you are standing at index 0, which is equal to
    '0'. You can move from index i to index j if the following conditions are
    fulfilled:
    * i + minJump <= j <= min(i + maxJump, s.length - 1), and
    * s[j] == '0'.
    Return true if you can reach index s.length - 1 in s, or false otherwise.

    Example 1:
    Input: s = "011010", minJump = 2, maxJump = 3
    Output: true
    Explanation: In the first step, move from index 0 to index 3.
                 In the second step, move from index 3 to index 5.

    Example 2:
    Input: s = "01101110", minJump = 2, maxJump = 3
    Output: false

    Constraints:
    * 2 <= s.length <= 10^5
    * s[i] is either '0' or '1'.
    * s[0] == '0'
    * 1 <= minJump <= maxJump < s.length*/

    bool canReach(string s, int minJump, int maxJump) {
        queue<int> q;
        q.push(0);
        int lo = 0;
        while (q.size()) {
            int i = q.front();
            q.pop();
            if (i+1 == size(s)) return true;
            for (int ii = max(lo+1, i+minJump); ii < min(i+maxJump+1, (int) size(s)); ++ii) {
                if (s[ii] == '0') q.push(ii);
            }
            lo = max(lo, i+maxJump);
        }
        return false;
    }


    /*1872. Stone Game VIII (Hard)
    Alice and Bob take turns playing a game, with Alice starting first. There
    are n stones arranged in a row. On each player's turn, while the number of
    stones is more than one, they will do the following:
    * Choose an integer x > 1, and remove the leftmost x stones from the row.
    * Add the sum of the removed stones' values to the player's score.
    * Place a new stone, whose value is equal to that sum, on the left side of
      the row.
    The game stops when only one stone is left in the row. The score difference
    between Alice and Bob is (Alice's score - Bob's score). Alice's goal is to
    maximize the score difference, and Bob's goal is the minimize the score
    difference. Given an integer array stones of length n where stones[i]
    represents the value of the ith stone from the left, return the score
    difference between Alice and Bob if they both play optimally.

    Example 1:
    Input: stones = [-1,2,-3,4,-5]
    Output: 5
    Explanation:
    - Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her
      score, and places a stone of value 2 on the left. stones = [2,-5].
    - Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and
      places a stone of value -3 on the left. stones = [-3].
    The difference between their scores is 2 - (-3) = 5.

    Example 2:
    Input: stones = [7,-6,5,10,5,-2,-6]
    Output: 13
    Explanation:
    - Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13
      to her score, and places a stone of value 13 on the left. stones = [13].
    The difference between their scores is 13 - 0 = 13.

    Example 3:
    Input: stones = [-10,-12]
    Output: -22
    Explanation:
    - Alice can only make one move, which is to remove both stones. She adds
      (-10) + (-12) = -22 to her score and places a stone of value -22 on the
      left. stones = [-22].
    The difference between their scores is (-22) - 0 = -22.

    Constraints:
    * n == stones.length
    * 2 <= n <= 10^5
    * -10^4 <= stones[i] <= 10^4*/

    int stoneGameVIII(vector<int>& stones) {
        int prefix = 0;
        for (auto& x : stones) prefix += x;

        int ans = prefix;
        for (int i = size(stones)-2; i >= 1; --i) {
            prefix -= stones[i+1];
            ans = max(ans, prefix - ans);
        }
        return ans;
    }


    /*1874. Minimize Product Sum of Two Arrays (Medium)
    The product sum of two equal-length arrays a and b is equal to the sum of
    a[i] * b[i] for all 0 <= i < a.length (0-indexed). For example, if
    a = [1,2,3,4] and b = [5,2,3,1], the product sum would be
    1*5 + 2*2 + 3*3 + 4*1 = 22. Given two arrays nums1 and nums2 of length n,
    return the minimum product sum if you are allowed to rearrange the order
    of the elements in nums1.

    Example 1:
    Input: nums1 = [5,3,4,2], nums2 = [4,2,2,5]
    Output: 40
    Explanation: We can rearrange nums1 to become [3,5,4,2]. The product sum of
                 [3,5,4,2] and [4,2,2,5] is 3*4 + 5*2 + 4*2 + 2*5 = 40.

    Example 2:
    Input: nums1 = [2,1,4,5,7], nums2 = [3,2,4,8,6]
    Output: 65
    Explanation: We can rearrange nums1 to become [5,7,4,1,2]. The product sum
                 of [5,7,4,1,2] and [3,2,4,8,6] is
                 5*3 + 7*2 + 4*4 + 1*8 + 2*6 = 65.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 100*/

    int minProductSum(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end(), greater<int>());
        int ans = 0;
        for (int i = 0; i < nums1.size(); ++i)
            ans += nums1[i] * nums2[i];
        return ans;
    }


    /*1876. Substrings of Size Three with Distinct Characters (Easy)
    A string is good if there are no repeated characters. Given a string s,
    return the number of good substrings of length three in s. Note that if
    there are multiple occurrences of the same substring, every occurrence
    should be counted. A substring is a contiguous sequence of characters in a
    string.

    Example 1:
    Input: s = "xyzzaz"
    Output: 1
    Explanation: There are 4 substrings of size 3: "xyz", "yzz", "zza", and
                 "zaz". The only good substring of length 3 is "xyz".

    Example 2:
    Input: s = "aababcabc"
    Output: 4
    Explanation: There are 7 substrings of size 3: "aab", "aba", "bab", "abc",
                 "bca", "cab", and "abc". The good substrings are "abc", "bca",
                 "cab", and "abc".

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters.*/

    int countGoodSubstrings(string s) {
        int ans = 0;
        for (int i = 2; i < size(s); ++i) {
            if (s[i-2] != s[i-1] && s[i-1] != s[i] && s[i-2] != s[i])
                ++ans;
        }
        return ans;
    }


    /*1877. Minimize Maximum Pair Sum in Array (Medium)
    The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the
    largest pair sum in a list of pairs.
    * For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair
      sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
    Given an array nums of even length n, pair up the elements of nums into
    n / 2 pairs such that:
    * Each element of nums is in exactly one pair, and
    * The maximum pair sum is minimized.
    Return the minimized maximum pair sum after optimally pairing up the elements.

    Example 1:
    Input: nums = [3,5,2,3]
    Output: 7
    Explanation: The elements can be paired up into pairs (3,3) and (5,2). The
                 maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.

    Example 2:
    Input: nums = [3,5,4,2,4,6]
    Output: 8
    Explanation: The elements can be paired up into pairs (3,5), (4,4), and
                 (6,2). The maximum pair sum is
                 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^5
    * n is even.
    * 1 <= nums[i] <= 10^5*/

    int minPairSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        for (int i = 0; i < size(nums)/2; ++i) {
            ans = max(ans, nums[i] + nums[size(nums)-1-i]);
        }
        return ans;
    }


    /*1878. Get Biggest Three Rhombus Sums in a Grid (Medium)
    You are given an m x n integer matrix grid. A rhombus sum is the sum of the
    elements that form the border of a regular rhombus shape in grid. The
    rhombus must have the shape of a square rotated 45 degrees with each of the
    corners centered in a grid cell. Below is an image of four valid rhombus
    shapes with the corresponding colored cells that should be included in each
    rhombus sum. Note that the rhombus can have an area of 0, which is depicted
    by the purple rhombus in the bottom right corner. Return the biggest three
    distinct rhombus sums in the grid in descending order. If there are less
    than three distinct values, return all of them.

    Example 1:
    Input: grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]
    Output: [228,216,211]
    Explanation: The rhombus shapes for the three biggest distinct rhombus sums
                 are depicted above.
                 - Blue: 20 + 3 + 200 + 5 = 228
                 - Red: 200 + 2 + 10 + 4 = 216
                 - Green: 5 + 200 + 4 + 2 = 211

    Example 2:
    Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
    Output: [20,9,8]
    Explanation: The rhombus shapes for the three biggest distinct rhombus sums
                 are depicted above.
                 - Blue: 4 + 2 + 6 + 8 = 20
                 - Red: 9 (area 0 rhombus in the bottom right corner)
                 - Green: 8 (area 0 rhombus in the bottom middle)

    Example 3:
    Input: grid = [[7,7,7]]
    Output: [7]
    Explanation: All three possible rhombus sums are the same, so return [7].

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * 1 <= grid[i][j] <= 10^5*/

    vector<int> getBiggestThree(vector<vector<int>>& grid) {
        int m = size(grid), n = size(grid[0]); // dimensions
        set<int> s;

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                for (int k = 0; 0 <= i-k && i+k < m && 0 <= j-k && j+k < n; ++k) {
                    int sm = 0, x = i-k, y = j, dx = 1, dy = 1;
                    if (k == 0) sm = grid[i][j];
                    else {
                        for (int d = 0; d < 4; ++d) {
                            for (int step = 0; step < k; ++step) {
                                sm += grid[x][y];
                                x += dx;
                                y += dy;
                            }
                            swap(dx, dy);
                            dy *= -1;
                        }
                    }
                    s.insert(sm);
                    if (size(s) > 3) s.erase(begin(s));
                }
            }
        }
        return vector<int>(rbegin(s), rend(s));
    }


    /*1879. Minimum XOR Sum of Two Arrays (Hard)
    You are given two integer arrays nums1 and nums2 of length n. The XOR sum
    of the two integer arrays is
    (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) (0-indexed).
    * For example, the XOR sum of [1,2,3] and [3,2,1] is equal to
      (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4.
    Rearrange the elements of nums2 such that the resulting XOR sum is
    minimized. Return the XOR sum after the rearrangement.

    Example 1:
    Input: nums1 = [1,2], nums2 = [2,3]
    Output: 2
    Explanation: Rearrange nums2 so that it becomes [3,2]. The XOR sum is
                 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.

    Example 2:
    Input: nums1 = [1,0,3], nums2 = [5,3,4]
    Output: 8
    Explanation: Rearrange nums2 so that it becomes [5,4,3]. The XOR sum is
                 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.

    Constraints:
    * n == nums1.length
    * n == nums2.length
    * 1 <= n <= 14
    * 0 <= nums1[i], nums2[i] <= 10^7*/

    int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {
        int n = size(nums1);
        vector<int> dp(1<<n, INT_MAX);
        dp[0] = 0;

        for (int mask = 0; mask < (1<<n); ++mask) {
            int k = __builtin_popcount(mask); // count set bits
            for (int bit = 0; bit < n; ++bit) {
                if (mask & (1<<bit)) {
                    dp[mask] = min(dp[mask], (nums1[bit] ^ nums2[k-1]) + dp[mask ^ (1<<bit)]);
                }
            }
        }
        return dp.back();
    }


    /*1880. Check if Word Equals Summation of Two Words (Easy)
    The letter value of a letter is its position in the alphabet starting from
    0 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, etc.). The numerical value of some
    string of lowercase English letters s is the concatenation of the letter
    values of each letter in s, which is then converted into an integer.
    * For example, if s = "acb", we concatenate each letter's letter value,
      resulting in "021". After converting it, we get 21.

    You are given three strings firstWord, secondWord, and targetWord, each
    consisting of lowercase English letters 'a' through 'j' inclusive. Return
    true if the summation of the numerical values of firstWord and secondWord
    equals the numerical value of targetWord, or false otherwise.

    Example 1:
    Input: firstWord = "acb", secondWord = "cba", targetWord = "cdb"
    Output: true
    Explanation:
    The numerical value of firstWord is "acb" -> "021" -> 21.
    The numerical value of secondWord is "cba" -> "210" -> 210.
    The numerical value of targetWord is "cdb" -> "231" -> 231.
    We return true because 21 + 210 == 231.

    Example 2:
    Input: firstWord = "aaa", secondWord = "a", targetWord = "aab"
    Output: false
    Explanation:
    The numerical value of firstWord is "aaa" -> "000" -> 0.
    The numerical value of secondWord is "a" -> "0" -> 0.
    The numerical value of targetWord is "aab" -> "001" -> 1.
    We return false because 0 + 0 != 1.

    Example 3:
    Input: firstWord = "aaa", secondWord = "a", targetWord = "aaaa"
    Output: true
    Explanation:
    The numerical value of firstWord is "aaa" -> "000" -> 0.
    The numerical value of secondWord is "a" -> "0" -> 0.
    The numerical value of targetWord is "aaaa" -> "0000" -> 0.
    We return true because 0 + 0 == 0.

    Constraints:
    * 1 <= firstWord.length, secondWord.length, targetWord.length <= 8
    * firstWord, secondWord, and targetWord consist of lowercase English
      letters from 'a' to 'j' inclusive.*/

    bool isSumEqual(string firstWord, string secondWord, string targetWord) {

        auto fn = [](string s) {
            int ans = 0;
            for (auto& c : s) ans = 10*ans + (c - 'a');
            return ans;
        };

        return fn(firstWord) + fn(secondWord) == fn(targetWord);
    }


    /*1881. Maximum Value after Insertion (Medium)
    You are given a very large integer n, represented as a string, and an
    integer digit x. The digits in n and the digit x are in the inclusive range
    [1, 9], and n may represent a negative number. You want to maximize n's
    numerical value by inserting x anywhere in the decimal representation of n.
    You cannot insert x to the left of the negative sign.
    * For example, if n = 73 and x = 6, it would be best to insert it between 7
      and 3, making n = 763.
    * If n = -55 and x = 2, it would be best to insert it before the first 5,
      making n = -255.
    Return a string representing the maximum value of n after the insertion.

    Example 1:
    Input: n = "99", x = 9
    Output: "999"
    Explanation: The result is the same regardless of where you insert 9.

    Example 2:
    Input: n = "-13", x = 2
    Output: "-123"
    Explanation: You can make n one of {-213, -123, -132}, and the largest of
                 those three is -123.

    Constraints:
    * 1 <= n.length <= 10^5
    * 1 <= x <= 9
    * The digits in n are in the range [1, 9].
    * n is a valid representation of an integer.
    * In the case of a negative n, it will begin with '-'.*/

    string maxValue(string n, int x) {
        for (int i = 0; i < size(n); ++i) {
            if ((n[0] == '-' && x < n[i] - '0') || (n[0] != '-' && x > n[i] - '0'))
                return n.substr(0, i) + to_string(x) + n.substr(i);
        }
        return n + to_string(x);
    }


    /*1882. Process Tasks Using Servers (Medium)
    You are given two 0-indexed integer arrays servers and tasks of lengths n
    and m respectively. servers[i] is the weight of the ith server, and
    tasks[j] is the time needed to process the jth task in seconds. You are
    running a simulation system that will shut down after all tasks are
    processed. Each server can only process one task at a time. You will be
    able to process the jth task starting from the jth second beginning with
    the 0th task at second 0. To process task j, you assign it to the server
    with the smallest weight that is free, and in case of a tie, choose the
    server with the smallest index. If a free server gets assigned task j at
    second t, it will be free again at the second t + tasks[j]. If there are
    no free servers, you must wait until one is free and execute the free tasks
    as soon as possible. If multiple tasks need to be assigned, assign them in
    order of increasing index. You may assign multiple tasks at the same second
    if there are multiple free servers. Build an array ans of length m, where
    ans[j] is the index of the server the jth task will be assigned to. Return
    the array ans.

    Example 1:
    Input: servers = [3,3,2], tasks = [1,2,3,2,1,2]
    Output: [2,2,0,2,1,2]
    Explanation: Events in chronological order go as follows:
    - At second 0, task 0 is added and processed using server 2 until second 1.
    - At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.
    - At second 2, task 2 is added and processed using server 0 until second 5.
    - At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.
    - At second 4, task 4 is added and processed using server 1 until second 5.
    - At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.

    Example 2:
    Input: servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]
    Output: [1,4,1,4,1,3,2]
    Explanation: Events in chronological order go as follows:
    - At second 0, task 0 is added and processed using server 1 until second 2.
    - At second 1, task 1 is added and processed using server 4 until second 2.
    - At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4.
    - At second 3, task 3 is added and processed using server 4 until second 7.
    - At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9.
    - At second 5, task 5 is added and processed using server 3 until second 7.
    - At second 6, task 6 is added and processed using server 2 until second 7.

    Constraints:
    * servers.length == n
    * tasks.length == m
    * 1 <= n, m <= 2 * 10^5
    * 1 <= servers[i], tasks[j] <= 2 * 10^5*/

    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {
        priority_queue<array<int, 2>, vector<array<int, 2>>, greater<>> free;
        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> busy;

        for (int i = 0; i < size(servers); ++i)
            free.push({servers[i], i});

        vector<int> ans;
        for (int t = 0; t < size(tasks); ++t) {
            while (size(busy) && busy.top()[0] <= t) {
                auto [tm, wt, i] = busy.top(); busy.pop();
                free.push({wt, i});
            }

            if (size(free)) {
                auto [wt, i] = free.top(); free.pop();
                ans.push_back(i);
                busy.push({t + tasks[t], wt, i});
            } else {
                auto [tm, wt, i] = busy.top(); busy.pop();
                ans.push_back(i);
                busy.push({tm + tasks[t], wt, i});
            }
        }
        return ans;
    }


    /*1883. Minimum Skips to Arrive at Meeting On Time (Hard)
    You are given an integer hoursBefore, the number of hours you have to
    travel to your meeting. To arrive at your meeting, you have to travel
    through n roads. The road lengths are given as an integer array dist of
    length n, where dist[i] describes the length of the ith road in kilometers.
    In addition, you are given an integer speed, which is the speed (in km/h)
    you will travel at. After you travel road i, you must rest and wait for the
    next integer hour before you can begin traveling on the next road. Note
    that you do not have to rest after traveling the last road because you are
    already at the meeting.
    * For example, if traveling a road takes 1.4 hours, you must wait until the
      2 hour mark before traveling the next road. If traveling a road takes
      exactly 2 hours, you do not need to wait.
    However, you are allowed to skip some rests to be able to arrive on time,
    meaning you do not need to wait for the next integer hour. Note that this
    means you may finish traveling future roads at different hour marks.
    * For example, suppose traveling the first road takes 1.4 hours and
      traveling the second road takes 0.6 hours. Skipping the rest after the
      first road will mean you finish traveling the second road right at the 2
      hour mark, letting you start traveling the third road immediately.
    Return the minimum number of skips required to arrive at the meeting on
    time, or -1 if it is impossible.

    Example 1:
    Input: dist = [1,3,2], speed = 4, hoursBefore = 2
    Output: 1
    Explanation: Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.
                 You can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.
                 Note that the second rest is shortened because you finish
                 traveling the second road at an integer hour due to skipping
                 the first rest.

    Example 2:
    Input: dist = [7,3,5,5], speed = 2, hoursBefore = 10
    Output: 2
    Explanation: Without skipping any rests, you will arrive in
                 (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.
                 You can skip the first and third rest to arrive in
                 ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.

    Example 3:
    Input: dist = [7,3,5,5], speed = 1, hoursBefore = 10
    Output: -1
    Explanation: It is impossible to arrive at the meeting on time even if you
                 skip all the rests.

    Constraints:
    * n == dist.length
    * 1 <= n <= 1000
    * 1 <= dist[i] <= 10^5
    * 1 <= speed <= 10^6
    * 1 <= hoursBefore <= 10^7*/

    int minSkips(vector<int>& dist, int speed, int hoursBefore) {
        int n = size(dist);
        vector<vector<long>> dp(n, vector<long>(n, 0));

        for (int i = 1; i < n; ++i)
            for (int j = 0; j < n; ++j) {
                dp[i][j] = (dp[i-1][j] + dist[i-1] + speed - 1)/speed*speed;
                if (j) dp[i][j] = min(dp[i][j], dp[i-1][j-1] + dist[i-1]);
            }

        for (int j = 0; j < n; ++j) {
            if (dp.back()[j] + dist.back() <= (long) speed * hoursBefore) return j;
        }
        return -1;
    }


    /*1884. Egg Drop With 2 Eggs and N Floors (Medium)
    You are given two identical eggs and you have access to a building with n
    floors labeled from 1 to n. You know that there exists a floor f where
    0 <= f <= n such that any egg dropped at a floor higher than f will break,
    and any egg dropped at or below floor f will not break. In each move, you
    may take an unbroken egg and drop it from any floor x (where 1 <= x <= n).
    If the egg breaks, you can no longer use it. However, if the egg does not
    break, you may reuse it in future moves. Return the minimum number of moves
    that you need to determine with certainty what the value of f is.

    Example 1:
    Input: n = 2
    Output: 2
    Explanation: We can drop the first egg from floor 1 and the second egg from floor 2.
                 If the first egg breaks, we know that f = 0.
                 If the second egg breaks but the first egg didn't, we know that f = 1.
                 Otherwise, if both eggs survive, we know that f = 2.

    Example 2:
    Input: n = 100
    Output: 14
    Explanation: One optimal strategy is:
    - Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8.
      Drop the 2nd egg starting from floor 1 and going up one at a time to find
      f within 7 more drops. Total drops is 1 + 7 = 8.
    - If the 1st egg does not break, drop the 1st egg again at floor 22. If it
      breaks, we know f is between 9 and 21. Drop the 2nd egg starting from
      floor 10 and going up one at a time to find f within 12 more drops. Total
      drops is 2 + 12 = 14.
    - If the 1st egg does not break again, follow a similar process dropping
      the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and
      100.
    Regardless of the outcome, it takes at most 14 drops to determine f.

    Constraints: 1 <= n <= 1000*/

    int twoEggDrop(int n) {
        vector<vector<int>> dp(n+1, vector<int>(2, INT_MAX));
        for (int i = 0; i <= n; ++i) dp[i][0] = i;
        dp[0][0] = dp[0][1] = 0;

        for (int i = 1; i <= n; ++i)
            for (int ii = 1; ii <= i; ++ii)
                dp[i][1] = min(dp[i][1], 1 + max(dp[ii-1][0], dp[i-ii][1]));
        return dp[n][1];
    }


    /*1885. Count Pairs in Two Arrays (Medium)
    Given two integer arrays nums1 and nums2 of length n, count the pairs of
    indices (i, j) such that i < j and nums1[i] + nums1[j] > nums2[i] + nums2[j].
    Return the number of pairs satisfying the condition.

    Example 1:
    Input: nums1 = [2,1,2,1], nums2 = [1,2,1,2]
    Output: 1
    Explanation: The pairs satisfying the condition are:
                 - (0, 2) where 2 + 2 > 1 + 1.

    Example 2:
    Input: nums1 = [1,10,6,2], nums2 = [1,4,1,5]
    Output: 5
    Explanation: The pairs satisfying the condition are:
                 - (0, 1) where 1 + 10 > 1 + 4.
                 - (0, 2) where 1 + 6 > 1 + 1.
                 - (1, 2) where 10 + 6 > 4 + 1.
                 - (1, 3) where 10 + 2 > 4 + 5.
                 - (2, 3) where 6 + 2 > 1 + 5.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^5*/

    long long countPairs(vector<int>& nums1, vector<int>& nums2) {
        vector<int> diff;
        for (int i = 0; i < nums1.size(); ++i) diff.push_back(nums1[i] - nums2[i]);
        sort(diff.begin(), diff.end());

        long long ans = 0;
        for (int i = 0; i < diff.size(); ++i)
            ans += diff.end() - upper_bound(diff.begin()+i+1, diff.end(), -diff[i]);
        return ans;
    }


    /*1886. Determine Whether Matrix Can Be Obtained By Rotation (Easy)
    Given two n x n binary matrices mat and target, return true if it is
    possible to make mat equal to target by rotating mat in 90-degree
    increments, or false otherwise.

    Example 1:
    Input: mat = [[0,1],[1,0]], target = [[1,0],[0,1]]
    Output: true
    Explanation: We can rotate mat 90 degrees clockwise to make mat equal target.

    Example 2:
    Input: mat = [[0,1],[1,1]], target = [[1,0],[0,1]]
    Output: false
    Explanation: It is impossible to make mat equal to target by rotating mat.

    Example 3:
    Input: mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]
    Output: true
    Explanation: We can rotate mat 90 degrees clockwise two times to make mat equal target.

    Constraints:
    * n == mat.length == target.length
    * n == mat[i].length == target[i].length
    * 1 <= n <= 10
    * mat[i][j] and target[i][j] are either 0 or 1.*/

    bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {
        int n = size(target);
        vector<bool> can(4, true);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (target[i][j] != mat[i][j]) can[0] = false;
                if (target[i][j] != mat[n-1-j][i]) can[1] = false;
                if (target[i][j] != mat[n-1-i][n-1-j]) can[2] = false;
                if (target[i][j] != mat[j][n-1-i]) can[3] = false;
            }
        }
        return can[0] || can[1] || can[2] || can[3];
    }


    /*1887. Reduction Operations to Make the Array Elements Equal (Medium)
    Given an integer array nums, your goal is to make all elements in nums
    equal. To complete one operation, follow these steps:
    * Find the largest value in nums. Let its index be i (0-indexed) and its
      value be largest. If there are multiple elements with the largest value,
      pick the smallest i.
    * Find the next largest value in nums strictly smaller than largest. Let
      its value be nextLargest.
    Reduce nums[i] to nextLargest. Return the number of operations to make all
    elements in nums equal.

    Example 1:
    Input: nums = [5,1,3]
    Output: 3
    Explanation: It takes 3 operations to make all elements in nums equal:
    1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
    2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
    3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].

    Example 2:
    Input: nums = [1,1,1]
    Output: 0
    Explanation: All elements in nums are already equal.

    Example 3:
    Input: nums = [1,1,2,2,3]
    Output: 4
    Explanation: It takes 4 operations to make all elements in nums equal:
    1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].
    2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].
    3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].
    4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 1 <= nums[i] <= 5 * 10^4*/

    int reductionOperations(vector<int>& nums) {
        sort(begin(nums), end(nums));
        int ans = 0, chg = 0;
        for (int i = 1; i < size(nums); ++i) {
            if (nums[i-1] < nums[i]) ++chg;
            ans += chg;
        }
        return ans;
    }


    /*1888. Minimum Number of Flips to Make the Binary String Alternating (Medium)
    You are given a binary string s. You are allowed to perform two types of
    operations on the string in any sequence:
    * Type-1: Remove the character at the start of the string s and append it
      to the end of the string.
    * Type-2: Pick any character in s and flip its value, i.e., if its value is
      '0' it becomes '1' and vice-versa.
    Return the minimum number of type-2 operations you need to perform such
    that s becomes alternating. The string is called alternating if no two
    adjacent characters are equal. For example, the strings "010" and "1010"
    are alternating, while the string "0100" is not.

    Example 1:
    Input: s = "111000"
    Output: 2
    Explanation: Use the first operation two times to make s = "100011". Then,
                 use the second operation on the third and sixth elements to
                 make s = "101010".

    Example 2:
    Input: s = "010"
    Output: 0
    Explanation: The string is already alternating.

    Example 3:
    Input: s = "1110"
    Output: 1
    Explanation: Use the second operation on the second element to make s = "1010".

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'.*/

    int minFlips(string s) {
        int ans = INT_MAX, x01 = 0, x10 = 0;
        for (int i = 0; i < 2*size(s); ++i) {
            x01 += (s[i%size(s)]^i)&1;
            x10 += (s[i%size(s)]^(i+1))&1;
            if (i+1 >= size(s)) {
                if (i >= size(s)) {
                    x01 -= (s[i-size(s)]^(i-size(s)))&1;
                    x10 -= (s[i-size(s)]^(i-size(s)+1))&1;
                }
                ans = min(ans, min(x01, x10));
            }
        }
        return ans;
    }


    /*1889. Minimum Space Wasted From Packaging (Hard)
    You have n packages that you are trying to place in boxes, one package in
    each box. There are m suppliers that each produce boxes of different sizes
    (with infinite supply). A package can be placed in a box if the size of the
    package is less than or equal to the size of the box. The package sizes are
    given as an integer array packages, where packages[i] is the size of the
    ith package. The suppliers are given as a 2D integer array boxes, where
    boxes[j] is an array of box sizes that the jth supplier produces. You want
    to choose a single supplier and use boxes from them such that the total
    wasted space is minimized. For each package in a box, we define the space
    wasted to be size of the box - size of the package. The total wasted space
    is the sum of the space wasted in all the boxes. For example, if you have
    to fit packages with sizes [2,3,5] and the supplier offers boxes of sizes
    [4,8], you can fit the packages of size-2 and size-3 into two boxes of
    size-4 and the package with size-5 into a box of size-8. This would result
    in a waste of (4-2) + (4-3) + (8-5) = 6. Return the minimum total wasted
    space by choosing the box supplier optimally, or -1 if it is impossible to
    fit all the packages inside boxes. Since the answer may be large, return it
    modulo 10^9 + 7.

    Example 1:
    Input: packages = [2,3,5], boxes = [[4,8],[2,8]]
    Output: 6
    Explanation: It is optimal to choose the first supplier, using two size-4
                 boxes and one size-8 box. The total waste is
                 (4-2) + (4-3) + (8-5) = 6.

    Example 2:
    Input: packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]
    Output: -1
    Explanation: There is no box that the package of size 5 can fit in.

    Example 3:
    Input: packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]
    Output: 9
    Explanation: It is optimal to choose the third supplier, using two size-5
                 boxes, two size-10 boxes, and two size-14 boxes. The total
                 waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.

    Constraints:
    * n == packages.length
    * m == boxes.length
    * 1 <= n <= 10^5
    * 1 <= m <= 10^5
    * 1 <= packages[i] <= 10^5
    * 1 <= boxes[j].length <= 10^5
    * 1 <= boxes[j][k] <= 10^5
    * sum(boxes[j].length) <= 10^5
    * The elements in boxes[j] are distinct.*/

    int minWastedSpace(vector<int>& packages, vector<vector<int>>& boxes) {
        sort(begin(packages), end(packages));
        long ans = LONG_MAX;
        for (auto& box : boxes) {
            sort(begin(box), end(box));
            if (packages.back() <= box.back()) {
                int kk = 0;
                long val = 0;
                for (auto& x : box) {
                    long k = upper_bound(begin(packages), end(packages), x) - begin(packages);
                    val += (long) x * (k - kk);
                    kk = k;
                }
                ans = min(ans, val);
            }
        }
        return ans < LONG_MAX ? (ans - accumulate(begin(packages), end(packages), (long) 0)) % 1'000'000'007 : -1;
    }


    /*1891. Cutting Ribbons (Medium)
    You are given an integer array ribbons, where ribbons[i] represents the
    length of the ith ribbon, and an integer k. You may cut any of the ribbons
    into any number of segments of positive integer lengths, or perform no cuts
    at all. For example, if you have a ribbon of length 4, you can:
    * Keep the ribbon of length 4,
    * Cut it into one ribbon of length 3 and one ribbon of length 1,
    * Cut it into two ribbons of length 2,
    * Cut it into one ribbon of length 2 and two ribbons of length 1, or
    * Cut it into four ribbons of length 1.
    Your goal is to obtain k ribbons of all the same positive integer length.
    You are allowed to throw away any excess ribbon as a result of cutting.
    Return the maximum possible positive integer length that you can obtain k
    ribbons of, or 0 if you cannot obtain k ribbons of the same length.

    Example 1:
    Input: ribbons = [9,7,5], k = 3
    Output: 5
    Explanation:
    - Cut the first ribbon to two ribbons, one of length 5 and one of length 4.
    - Cut the second ribbon to two ribbons, one of length 5 and one of length 2.
    - Keep the third ribbon as it is.
    Now you have 3 ribbons of length 5.

    Example 2:
    Input: ribbons = [7,5,9], k = 4
    Output: 4
    Explanation:
    - Cut the first ribbon to two ribbons, one of length 4 and one of length 3.
    - Cut the second ribbon to two ribbons, one of length 4 and one of length 1.
    - Cut the third ribbon to three ribbons, two of length 4 and one of length 1.
    Now you have 4 ribbons of length 4.

    Example 3:
    Input: ribbons = [5,7,9], k = 22
    Output: 0
    Explanation: You cannot obtain k ribbons of the same positive integer length.

    Constraints:
    * 1 <= ribbons.length <= 10^5
    * 1 <= ribbons[i] <= 10^5
    * 1 <= k <= 10^9*/

    int maxLength(vector<int>& ribbons, int k) {
        int lo = 0, hi = 100'000;
        while (lo < hi) {
            int mid = lo + (hi - lo + 1)/2, sm = 0;
            for (auto& ribbon : ribbons) sm += ribbon/mid;
            if (sm < k) hi = mid - 1;
            else lo = mid;
        }
        return lo;
    }


    /*1893. Check if All the Integers in a Range Are Covered (Easy)
    You are given a 2D integer array ranges and two integers left and right.
    Each ranges[i] = [starti, endi] represents an inclusive interval between
    starti and endi. Return true if each integer in the inclusive range
    [left, right] is covered by at least one interval in ranges. Return false
    otherwise. An integer x is covered by an interval ranges[i] = [starti, endi]
    if starti <= x <= endi.

    Example 1:
    Input: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
    Output: true
    Explanation: Every integer between 2 and 5 is covered:
                 - 2 is covered by the first range.
                 - 3 and 4 are covered by the second range.
                 - 5 is covered by the third range.

    Example 2:
    Input: ranges = [[1,10],[10,20]], left = 21, right = 21
    Output: false
    Explanation: 21 is not covered by any range.

    Constraints:
    * 1 <= ranges.length <= 50
    * 1 <= starti <= endi <= 50
    * 1 <= left <= right <= 50*/

    bool isCovered(vector<vector<int>>& ranges, int left, int right) {
        vector<int> vals(52);
        for (auto& rng : ranges)
            ++vals[rng[0]], --vals[rng[1]+1];
        for (int i = 0, prefix = 0; i < size(vals); ++i) {
            prefix += vals[i];
            if (left <= i && i <= right && prefix == 0) return false;
        }
        return true;
    }


    /*1894. Find the Student that Will Replace the Chalk (Medium)
    There are n students in a class numbered from 0 to n - 1. The teacher will
    give each student a problem starting with the student number 0, then the
    student number 1, and so on until the teacher reaches the student number
    n - 1. After that, the teacher will restart the process, starting with the
    student number 0 again. You are given a 0-indexed integer array chalk and
    an integer k. There are initially k pieces of chalk. When the student
    number i is given a problem to solve, they will use chalk[i] pieces of
    chalk to solve that problem. However, if the current number of chalk pieces
    is strictly less than chalk[i], then the student number i will be asked to
    replace the chalk. Return the index of the student that will replace the
    chalk.

    Example 1:
    Input: chalk = [5,1,5], k = 22
    Output: 0
    Explanation: The students go in turns as follows:
                 - Student number 0 uses 5 chalk, so k = 17.
                 - Student number 1 uses 1 chalk, so k = 16.
                 - Student number 2 uses 5 chalk, so k = 11.
                 - Student number 0 uses 5 chalk, so k = 6.
                 - Student number 1 uses 1 chalk, so k = 5.
                 - Student number 2 uses 5 chalk, so k = 0.
                 Student number 0 does not have enough chalk, so they will have
                 to replace it.

    Example 2:
    Input: chalk = [3,4,1,2], k = 25
    Output: 1
    Explanation: The students go in turns as follows:
                 - Student number 0 uses 3 chalk so k = 22.
                 - Student number 1 uses 4 chalk so k = 18.
                 - Student number 2 uses 1 chalk so k = 17.
                 - Student number 3 uses 2 chalk so k = 15.
                 - Student number 0 uses 3 chalk so k = 12.
                 - Student number 1 uses 4 chalk so k = 8.
                 - Student number 2 uses 1 chalk so k = 7.
                 - Student number 3 uses 2 chalk so k = 5.
                 - Student number 0 uses 3 chalk so k = 2.
                 Student number 1 does not have enough chalk, so they will have
                 to replace it.

    Constraints:
    * chalk.length == n
    * 1 <= n <= 10^5
    * 1 <= chalk[i] <= 10^5
    * 1 <= k <= 10^9*/

    int chalkReplacer(vector<int>& chalk, int k) {
        long total = accumulate(chalk.begin(), chalk.end(), 0l);
        k %= total;
        for (int i = 0; i < chalk.size(); ++i)
            if ((k -= chalk[i]) < 0) return i;
        return -1;
    }


    /*1895. Largest Magic Square (Medium)
    A k x k magic square is a k x k grid filled with integers such that every
    row sum, every column sum, and both diagonal sums are all equal. The
    integers in the magic square do not have to be distinct. Every 1 x 1 grid
    is trivially a magic square. Given an m x n integer grid, return the size
    (i.e., the side length k) of the largest magic square that can be found
    within this grid.

    Example 1:
    Input: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]
    Output: 3
    Explanation: The largest magic square has a size of 3. Every row sum,
                 column sum, and diagonal sum of this magic square is equal to
                 12.
                 - Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
                 - Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
                 - Diagonal sums: 5+4+3 = 6+4+2 = 12

    Example 2:
    Input: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]
    Output: 2

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * 1 <= grid[i][j] <= 10^6*/

    int largestMagicSquare(vector<vector<int>>& grid) {
        int m = size(grid), n = size(grid[0]); // dimensions

        vector<vector<int>> rows(m, vector<int>(n+1)), cols(m+1, vector<int>(n)), diag(m+1, vector<int>(n+1)), anti(m+1, vector<int>(n+1));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                rows[i][j+1] = grid[i][j] + rows[i][j];
                cols[i+1][j] = grid[i][j] + cols[i][j];
                diag[i+1][j+1] = grid[i][j] + diag[i][j];
                anti[i+1][j] = grid[i][j] + anti[i][j+1];
            }
        }

        int ans = 1;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                for (int k = 1; k <= min(i, j); ++k) {
                    int ii = i-k, jj = j-k;
                    if (k >= ans) {
                        int val = diag[i+1][j+1] - diag[ii][jj];
                        bool match = val == anti[i+1][jj] - anti[ii][j+1];
                        for (int r = ii; r <= i; ++r) match &= val == rows[r][j+1] - rows[r][jj];
                        for (int c = jj; c <= j; ++c) match &= val == cols[i+1][c] - cols[ii][c];
                        if (match) ans = max(ans, k+1);
                    }
                }
            }
        }
        return ans;
    }


    /*1896. Minimum Cost to Change the Final Value of Expression (Hard)
    You are given a valid boolean expression as a string expression consisting
    of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR
    operator),'(', and ')'. For example, "()1|1" and "(1)&()" are not valid
    while "1", "(((1))|(0))", and "1|(0&(1))" are valid expressions. Return the
    minimum cost to change the final value of the expression. For example, if
    expression = "1|1|(0&0)&1", its value is 1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1.
    We want to apply operations so that the new expression evaluates to 0. The
    cost of changing the final value of an expression is the number of
    operations performed on the expression. The types of operations are
    described as follows:
    * Turn a '1' into a '0'.
    * Turn a '0' into a '1'.
    * Turn a '&' into a '|'.
    * Turn a '|' into a '&'.
    Note: '&' does not take precedence over '|' in the order of calculation.
    Evaluate parentheses first, then in left-to-right order.

    Example 1:
    Input: expression = "1&(0|1)"
    Output: 1
    Explanation: We can turn "1&(0|1)" into "1&(0&1)" by changing the '|' to a
                 '&' using 1 operation. The new expression evaluates to 0.

    Example 2:
    Input: expression = "(0&0)&(0&0&0)"
    Output: 3
    Explanation: We can turn "(0&0)&(0&0&0)" into "(0|1)|(0&0&0)" using 3
                 operations. The new expression evaluates to 1.

    Example 3:
    Input: expression = "(0|(1|0&1))"
    Output: 1
    Explanation: We can turn "(0|(1|0&1))" into "(0|(0|0&1))" using 1 operation.
                 The new expression evaluates to 0.

    Constraints:
    * 1 <= expression.length <= 10^5
    * expression only contains '1','0','&','|','(', and ')'
    * All parentheses are properly matched.
    * There will be no empty parentheses (i.e: "()" is not a substring of expression).*/

    int minOperationsToFlip(string expression) {
        unordered_map<int, int> mp;
        stack<int> stk;
        for (int i = size(expression)-1; i >= 0; --i) {
            if (expression[i] == ')') stk.push(i);
            else if (expression[i] == '(') mp[stk.top()] = i, stk.pop();
        }

        function<pair<int, int>(int, int)> fn = [&](int lo, int hi) {
            if (lo == hi) return make_pair(expression[lo]-'0', 1); // single number
            if (expression[hi] == ')' && lo == mp[hi]) return fn(lo+1, hi-1); // single parenthesis
            int mid = (mp.count(hi) ? mp[hi] : hi) - 1;
            auto [v, c] = fn(mid+1, hi);
            auto [vv, cc] = fn(lo, mid-1);
            int val = 0, chg = 0;
            if (expression[mid] == '|') {
                val = v | vv;
                if (v == 1 && vv == 1) chg = 1 + min(c, cc);
                else if (v == 0 && vv == 0) chg = min(c, cc);
                else chg = 1;
            } else {
                val = v & vv;
                if (v == 1 && vv == 1) chg = min(c, cc);
                else if (v == 0 && vv == 0) chg = 1 + min(c, cc);
                else chg = 1;
            }
            return make_pair(val, chg);
        };

        return fn(0, size(expression)-1).second;
    }


    /*1897. Redistribute Characters to Make All Strings Equal (Easy)
    You are given an array of strings words (0-indexed). In one operation, pick
    two distinct indices i and j, where words[i] is a non-empty string, and
    move any character from words[i] to any position in words[j]. Return true
    if you can make every string in words equal using any number of operations,
    and false otherwise.

    Example 1:
    Input: words = ["abc","aabc","bc"]
    Output: true
    Explanation: Move the first 'a' in words[1] to the front of words[2], to
                 make words[1] = "abc" and words[2] = "abc". All the strings
                 are now equal to "abc", so return true.

    Example 2:
    Input: words = ["ab","a"]
    Output: false
    Explanation: It is impossible to make all the strings equal using the
                 operation.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consists of lowercase English letters.*/

    bool makeEqual(vector<string>& words) {
        vector<int> freq(26);
        for (auto& word : words)
            for (auto& ch : word) ++freq[ch-'a'];
        for (int i = 0; i < 26; ++i)
            if (freq[i] % size(words)) return false;
        return true;
    }


    /*1898. Maximum Number of Removable Characters (Medium)
    You are given two strings s and p where p is a subsequence of s. You are
    also given a distinct 0-indexed integer array removable containing a subset
    of indices of s (s is also 0-indexed). You want to choose an integer k
    (0 <= k <= removable.length) such that, after removing k characters from s
    using the first k indices in removable, p is still a subsequence of s. More
    formally, you will mark the character at s[removable[i]] for each 0 <= i < k,
    then remove all marked characters and check if p is still a subsequence.
    Return the maximum k you can choose such that p is still a subsequence of s
    after the removals. A subsequence of a string is a new string generated from
    the original string with some characters (can be none) deleted without
    changing the relative order of the remaining characters.

    Example 1:
    Input: s = "abcacb", p = "ab", removable = [3,1,0]
    Output: 2
    Explanation: After removing the characters at indices 3 and 1, "abcacb"
                 becomes "accb". "ab" is a subsequence of "accb". If we remove
                 the characters at indices 3, 1, and 0, "abcacb" becomes "ccb",
                 and "ab" is no longer a subsequence. Hence, the maximum k is 2.

    Example 2:
    Input: s = "abcbddddd", p = "abcd", removable = [3,2,1,4,5,6]
    Output: 1
    Explanation: After removing the character at index 3, "abcbddddd" becomes
                 "abcddddd". "abcd" is a subsequence of "abcddddd".

    Example 3:
    Input: s = "abcab", p = "abc", removable = [0,1,2,3,4]
    Output: 0
    Explanation: If you remove the first index in the array removable, "abc" is no longer a subsequence.

    Constraints:
    * 1 <= p.length <= s.length <= 10^5
    * 0 <= removable.length < s.length
    * 0 <= removable[i] < s.length
    * p is a subsequence of s.
    * s and p both consist of lowercase English letters.
    * The elements in removable are distinct.*/

    int maximumRemovals(string s, string p, vector<int>& removable) {
        unordered_map<int, int> mp;
        for (int i = 0; i < size(removable); ++i) mp[removable[i]] = i;

        auto fn = [&](int x) {
            int k = 0;
            for (int i = 0; i < size(s); ++i) {
                if (mp.count(i) && mp[i] < x) continue;
                if (k < size(p) && s[i] == p[k]) ++k;
            }
            return k == size(p);
        };

        int lo = -1, hi = size(removable);
        while (lo < hi) {
            int mid = lo + (hi - lo + 1)/2;
            if (fn(mid)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }


    /*1899. Merge Triplets to Form Target Triplet (Medium)
    A triplet is an array of three integers. You are given a 2D integer array
    triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You
    are also given an integer array target = [x, y, z] that describes the
    triplet you want to obtain. To obtain target, you may apply the following
    operation on triplets any number of times (possibly zero):
    * Choose two indices (0-indexed) i and j (i != j) and update triplets[j]
      to become [max(ai, aj), max(bi, bj), max(ci, cj)].
    For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5],
    triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5].
    Return true if it is possible to obtain the target triplet [x, y, z] as an
    element of triplets, or false otherwise.

    Example 1:
    Input: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]
    Output: true
    Explanation: Perform the following operations:
                 - Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]].
                 Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5].
                 triplets = [[2,5,3],[1,8,4],[2,7,5]]. The target triplet [2,7,5]
                 is now an element of triplets.

    Example 2:
    Input: triplets = [[1,3,4],[2,5,8]], target = [2,5,8]
    Output: true
    Explanation: The target triplet [2,5,8] is already an element of triplets.

    Example 3:
    Input: triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]
    Output: true
    Explanation: Perform the following operations:
                 - Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]].
                   Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5].
                   triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]].
                 - Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]].
                   Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5].
                   triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]].
                 The target triplet [5,5,5] is now an element of triplets.

    Example 4:
    Input: triplets = [[3,4,5],[4,5,6]], target = [3,2,5]
    Output: false
    Explanation: It is impossible to have [3,2,5] as an element because there
                 is no 2 in any of the triplets.

    Constraints:
    * 1 <= triplets.length <= 10^5
    * triplets[i].length == target.length == 3
    * 1 <= ai, bi, ci, x, y, z <= 1000*/

    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
        vector<int> ans(3);
        for (auto& triplet : triplets) {
            if (triplet[0] <= target[0] && triplet[1] <= target[1] && triplet[2] <= target[2]) {
                ans[0] = max(ans[0], triplet[0]);
                ans[1] = max(ans[1], triplet[1]);
                ans[2] = max(ans[2], triplet[2]);
            }
        }
        return ans == target;
    }


    /*1900. The Earliest and Latest Rounds Where Players Compete (Hard)
    There is a tournament where n players are participating. The players are
    standing in a single row and are numbered from 1 to n based on their
    initial standing position (player 1 is the first player in the row, player
    2 is the second player in the row, etc.). The tournament consists of
    multiple rounds (starting from round number 1). In each round, the ith
    player from the front of the row competes against the ith player from the
    end of the row, and the winner advances to the next round. When the number
    of players is odd for the current round, the player in the middle
    automatically advances to the next round.

    * For example, if the row consists of players 1, 2, 4, 6, 7
      - Player 1 competes against player 7.
      - Player 2 competes against player 6.
      - Player 4 automatically advances to the next round.
    After each round is over, the winners are lined back up in the row based on
    the original ordering assigned to them initially (ascending order). The
    players numbered firstPlayer and secondPlayer are the best in the tournament.
    They can win against any other player before they compete against each other.
    If any two other players compete against each other, either of them might
    win, and thus you may choose the outcome of this round. Given the integers n,
    firstPlayer, and secondPlayer, return an integer array containing two values,
    the earliest possible round number and the latest possible round number in
    which these two players will compete against each other, respectively.

    Example 1:
    Input: n = 11, firstPlayer = 2, secondPlayer = 4
    Output: [3,4]
    Explanation: One possible scenario which leads to the earliest round number:
                 First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
                 Second round: 2, 3, 4, 5, 6, 11
                 Third round: 2, 3, 4
                 One possible scenario which leads to the latest round number:
                 First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
                 Second round: 1, 2, 3, 4, 5, 6
                 Third round: 1, 2, 4
                 Fourth round: 2, 4

    Example 2:
    Input: n = 5, firstPlayer = 1, secondPlayer = 5
    Output: [1,1]
    Explanation: The players numbered 1 and 5 compete in the first round. There
                 is no way to make them compete in any other round.

    Constraints:
    * 2 <= n <= 28
    * 1 <= firstPlayer < secondPlayer <= n*/

    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {
        firstPlayer -= 1;
        secondPlayer -= 1;

        map<int, vector<int>> memo;

        function<vector<int>(int, int, int, int)> fn = [&](int r, int mask, int i, int j) {
            if (memo.find(mask) == memo.end()) {
                if (i >= j) return fn(r+1, mask, 0, n-1);
                if (!(mask & (1 << i))) return fn(r, mask, i+1, j);
                if (!(mask & (1 << j))) return fn(r, mask, i, j-1);
                if ((i == firstPlayer && j == secondPlayer) || (i == secondPlayer && j == firstPlayer)) return vector<int>(2, r);
                if (i == firstPlayer || i == secondPlayer) return fn(r, mask^(1<<j), i+1, j-1);
                if (j == firstPlayer || j == secondPlayer) return fn(r, mask^(1<<i), i+1, j-1);
                else {
                    vector<int> x = fn(r, mask^(1<<j), i+1, j-1);
                    vector<int> y = fn(r, mask^(1<<i), i+1, j-1);
                    memo[mask] = {min(x[0], y[0]), max(x[1], y[1])};
                }
            }
            return memo[mask];
        };

        return fn(1, (1<<n)-1, 0, n-1);
    }


    /*1901. Find a Peak Element II (Medium)
    A peak element in a 2D grid is an element that is strictly greater than all
    of its adjacent neighbors to the left, right, top, and bottom. Given a
    0-indexed m x n matrix mat where no two adjacent cells are equal, find any
    peak element mat[i][j] and return the length 2 array [i,j]. You may assume
    that the entire matrix is surrounded by an outer perimeter with the value
    -1 in each cell. You must write an algorithm that runs in O(m log(n)) or
    O(n log(m)) time.

    Example 1:
    Input: mat = [[1,4],[3,2]]
    Output: [0,1]
    Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both
                 acceptable answers.

    Example 2:
    Input: mat = [[10,20,15],[21,30,14],[7,16,32]]
    Output: [1,1]
    Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both
                 acceptable answers.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 500
    * 1 <= mat[i][j] <= 10^5
    * No two adjacent cells are equal.*/

    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int m = size(mat), n = size(mat[0]);

        function<vector<int>(int, int)> fn = [&](int lo, int hi) {
            if (lo == hi) return vector<int>{};
            int mid = (lo + hi)/2;
            vector<int> left = fn(lo, mid), right = fn(mid+1, hi);
            if (size(left)) return left;
            if (size(right)) return right;
            for (int i = 0; i < m; ++i) {
                if ((i == 0 || mat[i-1][mid] < mat[i][mid]) && (i+1 == m || mat[i][mid] > mat[i+1][mid]) && (mid == 0 || mat[i][mid-1] < mat[i][mid]) && (mid+1 == n || mat[i][mid] > mat[i][mid+1]))
                    return vector<int>{i, mid};
            }
            return vector<int>{};
        };

        return fn(0, n);
    }


    /*1902. Depth of BST Given Insertion Order (Medium)
    You are given a 0-indexed integer array order of length n, a permutation of
    integers from 1 to n representing the order of insertion into a binary
    search tree. A binary search tree is defined as follows:
    * The left subtree of a node contains only nodes with keys less than the
      node's key.
    * The right subtree of a node contains only nodes with keys greater than
      the node's key.
    * Both the left and right subtrees must also be binary search trees.
    The binary search tree is constructed as follows:
    * order[0] will be the root of the binary search tree.
    * All subsequent elements are inserted as the child of any existing node
      such that the binary search tree properties hold.
    Return the depth of the binary search tree. A binary tree's depth is the
    number of nodes along the longest path from the root node down to the
    farthest leaf node.

    Example 1:
    Input: order = [2,1,4,3]
    Output: 3
    Explanation: The binary search tree has a depth of 3 with path 2->3->4.

    Example 2:
    Input: order = [2,1,3,4]
    Output: 3
    Explanation: The binary search tree has a depth of 3 with path 2->3->4.

    Example 3:
    Input: order = [1,2,3,4]
    Output: 4
    Explanation: The binary search tree has a depth of 4 with path 1->2->3->4.

    Constraints:
    * n == order.length
    * 1 <= n <= 10^5
    * order is a permutation of integers between 1 and n.*/

    int maxDepthBST(vector<int>& order) {
        int ans = 0;
        map<int, int> mp = {{0, 0}, {100001, 0}};
        for (auto& x : order) {
            auto it = mp.lower_bound(x);
            mp[x] = 1 + max(prev(it)->second, it->second);
            ans = max(ans, mp[x]);
        }
        return ans;
    }


    /*1903. Largest Odd Number in String (Easy)
    You are given a string num, representing a large integer. Return the
    largest-valued odd integer (as a string) that is a non-empty substring of
    num, or an empty string "" if no odd integer exists. A substring is a
    contiguous sequence of characters within a string.

    Example 1:
    Input: num = "52"
    Output: "5"
    Explanation: The only non-empty substrings are "5", "2", and "52". "5" is
                 the only odd number.

    Example 2:
    Input: num = "4206"
    Output: ""
    Explanation: There are no odd numbers in "4206".

    Example 3:
    Input: num = "35427"
    Output: "35427"
    Explanation: "35427" is already an odd number.

    Constraints:
    * 1 <= num.length <= 10^5
    * num only consists of digits and does not contain any leading zeros.*/

    string largestOddNumber(string num) {
        for (int i = num.size()-1; i >= 0; --i)
            if ((num[i]-'0') & 1) return num.substr(0, i+1);
        return "";
    }


    /*1904. The Number of Full Rounds You Have Played (Medium)
    A new online video game has been released, and in this video game, there
    are 15-minute rounds scheduled every quarter-hour period. This means that
    at HH:00, HH:15, HH:30 and HH:45, a new round starts, where HH represents
    an integer number from 00 to 23. A 24-hour clock is used, so the earliest
    time in the day is 00:00 and the latest is 23:59. Given two strings
    startTime and finishTime in the format "HH:MM" representing the exact time
    you started and finished playing the game, respectively, calculate the
    number of full rounds that you played during your game session. For example,
    if startTime = "05:20" and finishTime = "05:59" this means you played only
    one full round from 05:30 to 05:45. You did not play the full round from
    05:15 to 05:30 because you started after the round began, and you did not
    play the full round from 05:45 to 06:00 because you stopped before the
    round ended. If finishTime is earlier than startTime, this means you have
    played overnight (from startTime to the midnight and from midnight to
    finishTime). Return the number of full rounds that you have played if you
    had started playing at startTime and finished at finishTime.

    Example 1:
    Input: startTime = "12:01", finishTime = "12:44"
    Output: 1
    Explanation: You played one full round from 12:15 to 12:30. You did not
                 play the full round from 12:00 to 12:15 because you started
                 playing at 12:01 after it began. You did not play the full
                 round from 12:30 to 12:45 because you stopped playing at
                 12:44 before it ended.

    Example 2:
    Input: startTime = "20:00", finishTime = "06:00"
    Output: 40
    Explanation: You played 16 full rounds from 20:00 to 00:00 and 24 full
                 rounds from 00:00 to 06:00. 16 + 24 = 40.

    Example 3:
    Input: startTime = "00:00", finishTime = "23:59"
    Output: 95
    Explanation: You played 4 full rounds each hour except for the last hour
                 where you played 3 full rounds.

    Constraints:
    * startTime and finishTime are in the format HH:MM.
    * 00 <= HH <= 23
    * 00 <= MM <= 59
    * startTime and finishTime are not equal.*/

    int numberOfRounds(string startTime, string finishTime) {
        int ts = 60 * stoi(startTime.substr(0, 2)) + stoi(startTime.substr(3, 2));
        int tf = 60 * stoi(finishTime.substr(0, 2)) + stoi(finishTime.substr(3, 2));
        if (0 <= tf - ts && tf - ts < 15) return 0;
        return tf/15 - (ts + 14)/15 + (ts > tf)*96;
    }


    /*1905. Count Sub Islands (Medium)
    You are given two m x n binary matrices grid1 and grid2 containing only 0's
    (representing water) and 1's (representing land). An island is a group of
    1's connected 4-directionally (horizontal or vertical). Any cells outside
    of the grid are considered water cells. An island in grid2 is considered a
    sub-island if there is an island in grid1 that contains all the cells that
    make up this island in grid2. Return the number of islands in grid2 that
    are considered sub-islands.

    Example 1:
    Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]],
           grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
    Output: 3
    Explanation: In the picture above, the grid on the left is grid1 and the
                 grid on the right is grid2. The 1s colored red in grid2 are
                 those considered to be part of a sub-island. There are three
                 sub-islands.

    Example 2:
    Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]],
           grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
    Output: 2
    Explanation: In the picture above, the grid on the left is grid1 and the
                 grid on the right is grid2. The 1s colored red in grid2 are
                 those considered to be part of a sub-island. There are two
                 sub-islands.

    Constraints:
    * m == grid1.length == grid2.length
    * n == grid1[i].length == grid2[i].length
    * 1 <= m, n <= 500
    * grid1[i][j] and grid2[i][j] are either 0 or 1.*/

    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
        int ans = 0, m = grid1.size(), n = grid1[0].size(), dir[] = {-1, 0, 1, 0, -1};
        for (int x = 0; x < m; ++x)
            for (int y = 0; y < n; ++y)
                if (grid2[x][y]) {
                    int val = 1;
                    grid2[x][y] = 0;
                    stack<pair<int, int>> stk; stk.emplace(x, y);
                    while (stk.size()) {
                        auto [i, j] = stk.top(); stk.pop();
                        val &= grid1[i][j];
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid2[ii][jj]) {
                                grid2[ii][jj] = 0;
                                stk.emplace(ii, jj);
                            }
                        }
                    }
                    ans += val;
                }
        return ans;
    }


    /*1906. Minimum Absolute Difference Queries (Medium)
    The minimum absolute difference of an array a is defined as the minimum
    value of |a[i] - a[j]|, where 0 <= i < j < a.length and a[i] != a[j]. If
    all elements of a are the same, the minimum absolute difference is -1.
    For example, the minimum absolute difference of the array [5,2,3,7,2] is
    |2 - 3| = 1. Note that it is not 0 because a[i] and a[j] must be different.
    You are given an integer array nums and the array queries where
    queries[i] = [li, ri]. For each query i, compute the minimum absolute
    difference of the subarray nums[li...ri] containing the elements of nums
    between the 0-based indices li and ri (inclusive). Return an array ans
    where ans[i] is the answer to the ith query. A subarray is a contiguous
    sequence of elements in an array. The value of |x| is defined as:
    * x if x >= 0.
    * -x if x < 0.

    Example 1:
    Input: nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]
    Output: [2,1,4,1]
    Explanation: The queries are processed as follows:
                 - queries[0] = [0,1]: The subarray is [1,3] and the minimum absolute difference is |1-3| = 2.
                 - queries[1] = [1,2]: The subarray is [3,4] and the minimum absolute difference is |3-4| = 1.
                 - queries[2] = [2,3]: The subarray is [4,8] and the minimum absolute difference is |4-8| = 4.
                 - queries[3] = [0,3]: The subarray is [1,3,4,8] and the minimum absolute difference is |3-4| = 1.
    Example 2:
    Input: nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]
    Output: [-1,1,1,3]
    Explanation: The queries are processed as follows:
                 - queries[0] = [2,3]: The subarray is [2,2] and the minimum absolute difference is -1 because all the elements are the same.
                 - queries[1] = [0,2]: The subarray is [4,5,2] and the minimum absolute difference is |4-5| = 1.
                 - queries[2] = [0,5]: The subarray is [4,5,2,2,7,10] and the minimum absolute difference is |4-5| = 1.
                 - queries[3] = [3,5]: The subarray is [2,7,10] and the minimum absolute difference is |7-10| = 3.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 100
    * 1 <= queries.length <= 2 * 10^4
    * 0 <= li < ri < nums.length*/

    vector<int> minDifference(vector<int>& nums, vector<vector<int>>& queries) {
        vector<vector<int>> loc(101);
        for (int i = 0; i < size(nums); ++i)
            loc[nums[i]].push_back(i);

        vector<int> ans;
        for (auto& query : queries) {
            int prev = 0, val = INT_MAX;
            for (int x = 1; x <= 100; ++x) {
                auto it = lower_bound(loc[x].begin(), loc[x].end(), query[0]);
                if (it != loc[x].end() && *it <= query[1]) {
                    if (prev) val = min(val, x - prev);
                    prev = x;
                }
            }
            ans.push_back(val < INT_MAX ? val : -1);
        }
        return ans;
    }


    /*1908. Game of Nim (Medium)
    Alice and Bob take turns playing a game with Alice starting first. In this
    game, there are n piles of stones. On each player's turn, the player should
    remove any positive number of stones from a non-empty pile of his or her
    choice. The first player who cannot make a move loses, and the other player
    wins. Given an integer array piles, where piles[i] is the number of stones
    in the ith pile, return true if Alice wins, or false if Bob wins. Both
    Alice and Bob play optimally.

    Example 1:
    Input: piles = [1]
    Output: true
    Explanation: There is only one possible scenario:
    - On the first turn, Alice removes one stone from the first pile. piles = [0].
    - On the second turn, there are no stones left for Bob to remove. Alice wins.

    Example 2:
    Input: piles = [1,1]
    Output: false
    Explanation: It can be proven that Bob will always win. One possible scenario is:
    - On the first turn, Alice removes one stone from the first pile. piles = [0,1].
    - On the second turn, Bob removes one stone from the second pile. piles = [0,0].
    - On the third turn, there are no stones left for Alice to remove. Bob wins.

    Example 3:
    Input: piles = [1,2,3]
    Output: false
    Explanation: It can be proven that Bob will always win. One possible scenario is:
    - On the first turn, Alice removes three stones from the third pile. piles = [1,2,0].
    - On the second turn, Bob removes one stone from the second pile. piles = [1,1,0].
    - On the third turn, Alice removes one stone from the first pile. piles = [0,1,0].
    - On the fourth turn, Bob removes one stone from the second pile. piles = [0,0,0].
    - On the fifth turn, there are no stones left for Alice to remove. Bob wins.

    Constraints:
    * n == piles.length
    * 1 <= n <= 7
    * 1 <= piles[i] <= 7


    Follow-up: Could you find a linear time solution? Although the linear time
               solution may be beyond the scope of an interview, it could be
               interesting to know.*/

    bool nimGame(vector<int>& piles) {
        unordered_map<int, bool> memo;

        function<bool(int)> fn = [&](int mask) {
            if (!memo.count(mask)) {
                memo[mask] = false;
                for (int i = 0; i < piles.size(); ++i) {
                    int val = (mask >> 3*i) & 7;
                    for (int x = 1; x <= val; ++x) {
                        int mask0 = mask - (x << 3*i);
                        if (!fn(mask0)) return memo[mask] = true;
                    }
                }
            }
            return memo[mask];
        };

        int mask = 0;
        for (int i = 0; i < piles.size(); ++i) mask |= piles[i] << 3*i;
        return fn(mask);
    }


    /*1909. Remove One Element to Make the Array Strictly Increasing (Easy)
    Given a 0-indexed integer array nums, return true if it can be made
    strictly increasing after removing exactly one element, or false otherwise.
    If the array is already strictly increasing, return true. The array nums is
    strictly increasing if nums[i - 1] < nums[i] for each index
    (1 <= i < nums.length).

    Example 1:
    Input: nums = [1,2,10,5,7]
    Output: true
    Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].
                 [1,2,5,7] is strictly increasing, so return true.

    Example 2:
    Input: nums = [2,3,1,2]
    Output: false
    Explanation: [3,1,2] is the result of removing the element at index 0.
                 [2,1,2] is the result of removing the element at index 1.
                 [2,3,2] is the result of removing the element at index 2.
                 [2,3,1] is the result of removing the element at index 3.
                 No resulting array is strictly increasing, so return false.

    Example 3:
    Input: nums = [1,1,1]
    Output: false
    Explanation: The result of removing any element is [1,1]. [1,1] is not
                 strictly increasing, so return false.

    Example 4:
    Input: nums = [1,2,3]
    Output: true
    Explanation: [1,2,3] is already strictly increasing, so return true.

    Constraints:
    * 2 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000*/

    bool canBeIncreasing(vector<int>& nums) {
        int prev = INT_MIN;
        bool seen = false;
        for (int i = 0; i < size(nums); ++i) {
            if (prev < nums[i]) prev = nums[i];
            else {
                if (seen) return false;
                seen = true;
                if (i == 1 || nums[i-2] < nums[i]) prev = nums[i];
            }
        }
        return true;
    }


    /*1910. Remove All Occurrences of a Substring (Medium)
    Given two strings s and part, perform the following operation on s until
    all occurrences of the substring part are removed:
    * Find the leftmost occurrence of the substring part and remove it from s.
    Return s after removing all occurrences of part. A substring is a
    contiguous sequence of characters in a string.

    Example 1:
    Input: s = "daabcbaabcbc", part = "abc"
    Output: "dab"
    Explanation: The following operations are done:
                 - s = "daabcbaabcbc", remove "abc" starting at index 2, so s = "dabaabcbc".
                 - s = "dabaabcbc", remove "abc" starting at index 4, so s = "dababc".
                 - s = "dababc", remove "abc" starting at index 3, so s = "dab".
                 Now s has no occurrences of "abc".

    Example 2:
    Input: s = "axxxxyyyyb", part = "xy"
    Output: "ab"
    Explanation: The following operations are done:
                 - s = "axxxxyyyyb", remove "xy" starting at index 4 so s = "axxxyyyb".
                 - s = "axxxyyyb", remove "xy" starting at index 3 so s = "axxyyb".
                 - s = "axxyyb", remove "xy" starting at index 2 so s = "axyb".
                 - s = "axyb", remove "xy" starting at index 1 so s = "ab".
                 Now s has no occurrences of "xy".

    Constraints:
    * 1 <= s.length <= 1000
    * 1 <= part.length <= 1000
    * s and part consists of lowercase English letters.*/

    string removeOccurrences(string s, string part) {
        vector<int> lps = {0};
        int k = 0;
        for (int i = 1; i < size(part); ++i) {
            while (k && part[k] != part[i]) k = lps[k-1];
            if (part[k] == part[i]) ++k;
            lps.push_back(k);
        }

        vector<pair<char, int>> stk;
        for (auto& ch : s) {
            int k = size(stk) ? stk.back().second : 0;
            while (k && part[k] != ch) k = lps[k-1];
            if (part[k] == ch) ++k;
            stk.emplace_back(ch, k);
            if (k == size(part))
                while (k--) stk.pop_back();
        }

        string ans;
        for (auto& [ch, k] : stk) ans.push_back(ch);
        return ans;
    }


    /*1911. Maximum Alternating Subsequence Sum (Medium)
    The alternating sum of a 0-indexed array is defined as the sum of the
    elements at even indices minus the sum of the elements at odd indices.
    * For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4.
    Given an array nums, return the maximum alternating sum of any subsequence
    of nums (after reindexing the elements of the subsequence). A subsequence
    of an array is a new array generated from the original array by deleting
    some elements (possibly none) without changing the remaining elements'
    relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4]
    (the underlined elements), while [2,4,2] is not.

    Example 1:
    Input: nums = [4,2,5,3]
    Output: 7
    Explanation: It is optimal to choose the subsequence [4,2,5] with
                 alternating sum (4 + 5) - 2 = 7.

    Example 2:
    Input: nums = [5,6,7,8]
    Output: 8
    Explanation: It is optimal to choose the subsequence [8] with alternating
                 sum 8.

    Example 3:
    Input: nums = [6,2,1,2,4,5]
    Output: 10
    Explanation: It is optimal to choose the subsequence [6,1,5] with
                 alternating sum (6 + 5) - 1 = 10.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    long long maxAlternatingSum(vector<int>& nums) {
        long long ans = 0;
        for (int i = 1; i < size(nums); ++i) {
            if (nums[i-1] > nums[i])
                ans += nums[i-1] - nums[i];
        }
        return ans + nums.back();
    }


    /*1913. Maximum Product Difference Between Two Pairs (Easy)
    The product difference between two pairs (a, b) and (c, d) is defined as
    (a * b) - (c * d). For example, the product difference between (5, 6) and
    (2, 7) is (5 * 6) - (2 * 7) = 16. Given an integer array nums, choose four
    distinct indices w, x, y, and z such that the product difference between
    pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized. Return the
    maximum such product difference.

    Example 1:
    Input: nums = [5,6,2,7,4]
    Output: 34
    Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and
                 indices 2 and 4 for the second pair (2, 4). The product
                 difference is (6 * 7) - (2 * 4) = 34.

    Example 2:
    Input: nums = [4,2,5,9,7,4,8]
    Output: 64
    Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and
                 indices 1 and 5 for the second pair (2, 4). The product
                 difference is (9 * 8) - (2 * 4) = 64.

    Constraints:
    * 4 <= nums.length <= 10^4
    * 1 <= nums[i] <= 10^4*/

    int maxProductDifference(vector<int>& nums) {
        sort(begin(nums), end(nums));
        int n = size(nums);
        return nums[n-1] * nums[n-2] - nums[1] * nums[0];
    }


    /*1914. Cyclically Rotating a Grid (Medium)
    You are given an m x n integer matrix grid, where m and n are both even
    integers, and an integer k. The matrix is composed of several layers, which
    is shown in the below image, where each color is its own layer.
    A cyclic rotation of the matrix is done by cyclically rotating each layer
    in the matrix. To cyclically rotate a layer once, each element in the layer
    will take the place of the adjacent element in the counter-clockwise
    direction. Return the matrix after applying k cyclic rotations to it.

    Example 1:
    Input: grid = [[40,10],[30,20]], k = 1
    Output: [[10,20],[40,30]]
    Explanation: The figures above represent the grid at every state.

    Example 2:
    Input: grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2
    Output: [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]
    Explanation: The figures above represent the grid at every state.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 50
    * Both m and n are even integers.
    * 1 <= grid[i][j] <= 5000
    * 1 <= k <= 10^9*/

    vector<vector<int>> rotateGrid(vector<vector<int>>& grid, int k) {
        int m = size(grid), n = size(grid[0]);
        vector<vector<int>> ans(m, vector<int>(n));

        for (int r = 0; r < min(m, n)/2; ++r) {
            int i = r, j = r;
            vector<int> vals;
            for (int jj = j; jj < n-1-j; ++jj) vals.push_back(grid[i][jj]);
            for (int ii = i; ii < m-1-i; ++ii) vals.push_back(grid[ii][n-1-j]);
            for (int jj = n-1-j; jj > j; --jj) vals.push_back(grid[m-1-j][jj]);
            for (int ii = m-1-i; ii > i; --ii) vals.push_back(grid[ii][j]);

            int kk = k % size(vals);
            for (int jj = j; jj < n-1-j; ++jj) ans[i][jj]     = vals[kk++ % size(vals)];
            for (int ii = i; ii < m-1-i; ++ii) ans[ii][n-1-j] = vals[kk++ % size(vals)];
            for (int jj = n-1-j; jj > j; --jj) ans[m-1-j][jj] = vals[kk++ % size(vals)];
            for (int ii = m-1-i; ii > i; --ii) ans[ii][j]     = vals[kk++ % size(vals)];
        }
        return ans;
    }


    /*1915. Number of Wonderful Substrings (Medium)
    A wonderful string is a string where at most one letter appears an odd
    number of times. For example, "ccjjc" and "abab" are wonderful, but "ab" is
    not. Given a string word that consists of the first ten lowercase English
    letters ('a' through 'j'), return the number of wonderful non-empty
    substrings in word. If the same substring appears multiple times in word,
    then count each occurrence separately. A substring is a contiguous sequence
    of characters in a string.

    Example 1:
    Input: word = "aba"
    Output: 4
    Explanation: The four wonderful substrings are underlined below:
                 - "aba" -> "a"
                 - "aba" -> "b"
                 - "aba" -> "a"
                 - "aba" -> "aba"

    Example 2:
    Input: word = "aabb"
    Output: 9
    Explanation: The nine wonderful substrings are underlined below:
                 - "aabb" -> "a"
                 - "aabb" -> "aa"
                 - "aabb" -> "aab"
                 - "aabb" -> "aabb"
                 - "aabb" -> "a"
                 - "aabb" -> "abb"
                 - "aabb" -> "b"
                 - "aabb" -> "bb"
                 - "aabb" -> "b"

    Example 3:
    Input: word = "he"
    Output: 2
    Explanation: The two wonderful substrings are underlined below:
                 - "he" -> "h"
                 - "he" -> "e"

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists of lowercase English letters from 'a' to 'j'.*/

    long long wonderfulSubstrings(string word) {
        long long ans = 0;
        unordered_map<int, int> freq = {{0, 1}};
        int mask = 0;
        for (auto& ch : word) {
            mask ^= 1 << ch-'a';
            ans += freq[mask];
            for (int i = 0; i < 10; ++i)
                ans += freq[mask ^ 1<<i];
            ++freq[mask];
        }
        return ans;
    }


    /*1916. Count Ways to Build Rooms in an Ant Colony (Hard)
    You are an ant tasked with adding n new rooms numbered 0 to n-1 to your
    colony. You are given the expansion plan as a 0-indexed integer array of
    length n, prevRoom, where prevRoom[i] indicates that you must build room
    prevRoom[i] before building room i, and these two rooms must be connected
    directly. Room 0 is already built, so prevRoom[0] = -1. The expansion plan
    is given such that once all the rooms are built, every room will be
    reachable from room 0. You can only build one room at a time, and you can
    travel freely between rooms you have already built only if they are
    connected. You can choose to build any room as long as its previous room is
    already built. Return the number of different orders you can build all the
    rooms in. Since the answer may be large, return it modulo 10^9 + 7.

    Example 1:
    Input: prevRoom = [-1,0,1]
    Output: 1
    Explanation: There is only one way to build the additional rooms: 0 → 1 → 2

    Example 2:
    Input: prevRoom = [-1,0,0,1,2]
    Output: 6
    Explanation: The 6 ways are:
                 0 → 1 → 3 → 2 → 4
                 0 → 2 → 4 → 1 → 3
                 0 → 1 → 2 → 3 → 4
                 0 → 1 → 2 → 4 → 3
                 0 → 2 → 1 → 3 → 4
                 0 → 2 → 1 → 4 → 3

    Constraints:
    * n == prevRoom.length
    * 2 <= n <= 10^5
    * prevRoom[0] == -1
    * 0 <= prevRoom[i] < n for all 1 <= i < n
    * Every room is reachable from room 0 once all the rooms are built.*/

    int waysToBuildRooms(vector<int>& prevRoom) {
        int n = size(prevRoom);
        vector<vector<int>> tree(n);
        for (int i = 0; i < size(prevRoom); ++i)
            if (prevRoom[i] >= 0) tree[prevRoom[i]].push_back(i);

        const int MOD = 1'000'000'007, N = 100'001;
        long inv[N], fact[N], ifact[N];
        inv[1] = 1;
        fact[0] = ifact[0] = 1;

        for (int x = 1; x < N; ++x) {
            if (x >= 2) inv[x] = MOD - MOD/x * inv[MOD % x] % MOD; // modular inverse
            fact[x] = fact[x-1] * x % MOD;
            ifact[x] = ifact[x-1] * inv[x] % MOD;
        }

        function<pair<int, long>(int)> fn = [&](int x) {
            if (size(tree[x]) == 0) return make_pair(1, 1l);
            int c = 0;
            long m = 1;
            for (auto& xx : tree[x]) {
                auto [cc, mm] = fn(xx);
                c += cc;
                m = m * mm % MOD * ifact[cc] % MOD;
            }
            m = m * fact[c] % MOD;
            return make_pair(c+1, m);
        };

        return fn(0).second;
    }


    /*1918. Kth Smallest Subarray Sum (Medium)
    Given an integer array nums of length n and an integer k, return the kth
    smallest subarray sum. A subarray is defined as a non-empty contiguous
    sequence of elements in an array. A subarray sum is the sum of all elements
    in the subarray.

    Example 1:
    Input: nums = [2,1,3], k = 4
    Output: 3
    Explanation: The subarrays of [2,1,3] are:
                 - [2] with sum 2
                 - [1] with sum 1
                 - [3] with sum 3
                 - [2,1] with sum 3
                 - [1,3] with sum 4
                 - [2,1,3] with sum 6
                 Ordering the sums from smallest to largest gives 1, 2, 3, 3,
                 4, 6. The 4th smallest is 3.

    Example 2:
    Input: nums = [3,3,5,5], k = 7
    Output: 10
    Explanation: The subarrays of [3,3,5,5] are:
                 - [3] with sum 3
                 - [3] with sum 3
                 - [5] with sum 5
                 - [5] with sum 5
                 - [3,3] with sum 6
                 - [3,5] with sum 8
                 - [5,5] with sum 10
                 - [3,3,5], with sum 11
                 - [3,5,5] with sum 13
                 - [3,3,5,5] with sum 16
                 Ordering the sums from smallest to largest gives 3, 3, 5, 5,
                 6, 8, 10, 11, 13, 16. The 7th smallest is 10.

    Constraints:
    * n == nums.length
    * 1 <= n <= 2 * 10^4
    * 1 <= nums[i] <= 5 * 10^4
    * 1 <= k <= n * (n + 1) / 2*/

    int kthSmallestSubarraySum(vector<int>& nums, int k) {
        int lo = 0, hi = accumulate(nums.begin(), nums.end(), 0);
        while (lo < hi) {
            int mid = lo + (hi - lo)/2, cnt = 0;
            for (int i = 0, ii = 0, rsm = 0; i < nums.size(); ++i) {
                rsm += nums[i];
                while (rsm > mid) rsm -= nums[ii++];
                cnt += i - ii + 1;
            }
            if (cnt < k) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*1925. Count Square Sum Triples (Easy)
    A square triple (a,b,c) is a triple where a, b, and c are integers and
    a^2 + b^2 = c^2. Given an integer n, return the number of square triples
    such that 1 <= a, b, c <= n.

    Example 1:
    Input: n = 5
    Output: 2
    Explanation: The square triples are (3,4,5) and (4,3,5).

    Example 2:
    Input: n = 10
    Output: 4
    Explanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).

    Constraints: 1 <= n <= 250*/

    int countTriples(int n) {
        int ans = 0;
        for (int a = 1; a < n; ++a) {
            for (int b = a+1; b < n; ++b) {
                int cc = a*a + b*b, c = sqrt(cc);
                if (c*c == cc && c <= n) ans += 2;
            }
        }
        return ans;
    }


    /*1926. Nearest Exit from Entrance in Maze (Medium)
    You are given an m x n matrix maze (0-indexed) with empty cells
    (represented as '.') and walls (represented as '+'). You are also given the
    entrance of the maze, where entrance = [entrancerow, entrancecol] denotes
    the row and column of the cell you are initially standing at. In one step,
    you can move one cell up, down, left, or right. You cannot step into a cell
    with a wall, and you cannot step outside the maze. Your goal is to find the
    nearest exit from the entrance. An exit is defined as an empty cell that is
    at the border of the maze. The entrance does not count as an exit. Return
    the number of steps in the shortest path from the entrance to the nearest
    exit, or -1 if no such path exists.

    Example 1:
    Input: maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
    Output: 1
    Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].
                 Initially, you are at the entrance cell [1,2].
                 - You can reach [1,0] by moving 2 steps left.
                 - You can reach [0,2] by moving 1 step up.
                 It is impossible to reach [2,3] from the entrance.
                 Thus, the nearest exit is [0,2], which is 1 step away.

    Example 2:
    Input: maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
    Output: 2
    Explanation: There is 1 exit in this maze at [1,2].
                 [1,0] does not count as an exit since it is the entrance cell.
                 Initially, you are at the entrance cell [1,0].
                 - You can reach [1,2] by moving 2 steps right.
                 Thus, the nearest exit is [1,2], which is 2 steps away.

    Example 3:
    Input: maze = [[".","+"]], entrance = [0,0]
    Output: -1
    Explanation: There are no exits in this maze.

    Constraints:
    * maze.length == m
    * maze[i].length == n
    * 1 <= m, n <= 100
    * maze[i][j] is either '.' or '+'.
    * entrance.length == 2
    * 0 <= entrancerow < m
    * 0 <= entrancecol < n
    * entrance will always be an empty cell.*/

    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int ans = 0, m = maze.size(), n = maze[0].size(), d[5] = {1, 0, -1, 0, 1};
        queue<int> q;
        q.push(entrance[0]*n + entrance[1]);
        while (q.size()) {
            for (int k = q.size(); k; --k) {
                int x = q.front()/n, y = q.front()%n;
                q.pop();
                if ((x == 0 || x == m-1 || y == 0 || y == n-1) && (x != entrance[0] || y != entrance[1])) return ans;
                for (int i = 0; i < 4; ++i) {
                    int xx = x + d[i], yy = y + d[i+1];
                    if (0 <= xx && xx < m && 0 <= yy && yy < n && maze[xx][yy] == '.') {
                        maze[xx][yy] = '+';
                        q.push(xx*n + yy);
                    }
                }
            }
            ++ans;
        }
        return -1;
    }


    /*1927. Sum Game (Medium)
    Alice and Bob take turns playing a game, with Alice starting first. You are
    given a string num of even length consisting of digits and '?' characters.
    On each turn, a player will do the following if there is still at least one
    '?' in num:
    * Choose an index i where num[i] == '?'.
    * Replace num[i] with any digit between '0' and '9'.
    The game ends when there are no more '?' characters in num. For Bob to win,
    the sum of the digits in the first half of num must be equal to the sum of
    the digits in the second half. For Alice to win, the sums must not be equal.
    * For example, if the game ended with num = "243801", then Bob wins because
      2+4+3 = 8+0+1. If the game ended with num = "243803", then Alice wins
      because 2+4+3 != 8+0+3.
    Assuming Alice and Bob play optimally, return true if Alice will win and
    false if Bob will win.

    Example 1:
    Input: num = "5023"
    Output: false
    Explanation: There are no moves to be made. The sum of the first half is
                 equal to the sum of the second half: 5 + 0 = 2 + 3.

    Example 2:
    Input: num = "25??"
    Output: true
    Explanation: Alice can replace one of the '?'s with '9' and it will be
                 impossible for Bob to make the sums equal.

    Example 3:
    Input: num = "?3295???"
    Output: false
    Explanation: It can be proven that Bob will always win. One possible outcome is:
                 - Alice replaces the first '?' with '9'. num = "93295???".
                 - Bob replaces one of the '?' in the right half with '9'. num = "932959??".
                 - Alice replaces one of the '?' in the right half with '2'. num = "9329592?".
                 - Bob replaces the last '?' in the right half with '7'. num = "93295927".
                 Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.

    Constraints:
    * 2 <= num.length <= 10^5
    * num.length is even.
    * num consists of only digits and '?'.*/

    bool sumGame(string num) {
        int diff = 0, qm = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (num[i] == '?') qm += i < num.size()/2 ? 1 : -1;
            else diff += i < num.size()/2 ? num[i] - '0' : '0' - num[i];
        }
        return diff * 2 + qm * 9 != 0;
    }


    /*1928. Minimum Cost to Reach Destination in Time (Hard)
    There is a country of n cities numbered from 0 to n - 1 where all the
    cities are connected by bi-directional roads. The roads are represented as
    a 2D integer array edges where edges[i] = [xi, yi, timei] denotes a road
    between cities xi and yi that takes timei minutes to travel. There may be
    multiple roads of differing travel times connecting the same two cities,
    but no road connects a city to itself. Each time you pass through a city,
    you must pay a passing fee. This is represented as a 0-indexed integer
    array passingFees of length n where passingFees[j] is the amount of dollars
    you must pay when you pass through city j. In the beginning, you are at
    city 0 and want to reach city n - 1 in maxTime minutes or less. The cost of
    your journey is the summation of passing fees for each city that you passed
    through at some moment of your journey (including the source and
    destination cities). Given maxTime, edges, and passingFees, return the
    minimum cost to complete your journey, or -1 if you cannot complete it
    within maxTime minutes.

    Example 1:
    Input: maxTime = 30,
           edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]],
           passingFees = [5,1,2,20,20,3]
    Output: 11
    Explanation: The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes
                 and has $11 worth of passing fees.

    Example 2:
    Input: maxTime = 29,
           edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]],
           passingFees = [5,1,2,20,20,3]
    Output: 48
    Explanation: The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes
                 and has $48 worth of passing fees. You cannot take path
                 0 -> 1 -> 2 -> 5 since it would take too long.

    Example 3:
    Input: maxTime = 25,
           edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]],
           passingFees = [5,1,2,20,20,3]
    Output: -1
    Explanation: There is no way to reach city 5 from city 0 within 25 minutes.

    Constraints:
    * 1 <= maxTime <= 1000
    * n == passingFees.length
    * 2 <= n <= 1000
    * n - 1 <= edges.length <= 1000
    * 0 <= xi, yi <= n - 1
    * 1 <= timei <= 1000
    * 1 <= passingFees[j] <= 1000
    * The graph may contain multiple edges between two nodes.
    * The graph does not contain self loops.*/

    int minCost(int maxTime, vector<vector<int>>& edges, vector<int>& passingFees) {
        unordered_map<int, vector<pair<int, int>>> graph;
        for (auto& edge : edges) {
            graph[edge[0]].emplace_back(edge[1], edge[2]);
            graph[edge[1]].emplace_back(edge[0], edge[2]);
        }

        // Dijkstra's algo
        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> pq; // min-heap
        pq.push({passingFees[0], 0, 0});
        unordered_map<int, int> dist = {{0, passingFees[0]}};
        while (pq.size()) {
            auto [cost, k, t] = pq.top(); pq.pop();
            if (k == passingFees.size()-1) return cost;
            for (auto& [kk, tt] : graph[k]) {
                if (t + tt <= maxTime && (!dist.count(kk) || t + tt < dist[kk])) {
                    dist[kk] = t + tt;
                    pq.push({cost + passingFees[kk], kk, t + tt});
                }
            }
        }
        return -1;
    }


    /*1929. Concatenation of Array (Easy)
    Given an integer array nums of length n, you want to create an array ans of
    length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n
    (0-indexed). Specifically, ans is the concatenation of two nums arrays.
    Return the array ans.

    Example 1:
    Input: nums = [1,2,1]
    Output: [1,2,1,1,2,1]
    Explanation: The array ans is formed as follows:
                 - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
                 - ans = [1,2,1,1,2,1]

    Example 2:
    Input: nums = [1,3,2,1]
    Output: [1,3,2,1,1,3,2,1]
    Explanation: The array ans is formed as follows:
                 - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
                 - ans = [1,3,2,1,1,3,2,1]

    Constraints:
    * n == nums.length
    * 1 <= n <= 1000
    * 1 <= nums[i] <= 1000*/

    vector<int> getConcatenation(vector<int>& nums) {
        vector<int> ans;
        for (int i = 0; i < 2*nums.size(); ++i)
            ans.push_back(nums[i % nums.size()]);
        return ans;
    }


    /*1930. Unique Length-3 Palindromic Subsequences (Medium)
    Given a string s, return the number of unique palindromes of length three
    that are a subsequence of s. Note that even if there are multiple ways to
    obtain the same subsequence, it is still only counted once. A palindrome is
    a string that reads the same forwards and backwards. A subsequence of a
    string is a new string generated from the original string with some
    characters (can be none) deleted without changing the relative order of the
    remaining characters. For example, "ace" is a subsequence of "abcde".

    Example 1:
    Input: s = "aabca"
    Output: 3
    Explanation: The 3 palindromic subsequences of length 3 are:
                 - "aba" (subsequence of "aabca")
                 - "aaa" (subsequence of "aabca")
                 - "aca" (subsequence of "aabca")

    Example 2:
    Input: s = "adc"
    Output: 0
    Explanation: There are no palindromic subsequences of length 3 in "adc".

    Example 3:
    Input: s = "bbcbaba"
    Output: 4
    Explanation: The 4 palindromic subsequences of length 3 are:
                 - "bbb" (subsequence of "bbcbaba")
                 - "bcb" (subsequence of "bbcbaba")
                 - "bab" (subsequence of "bbcbaba")
                 - "aba" (subsequence of "bbcbaba")

    Constraints:
    * 3 <= s.length <= 10^5
    * s consists of only lowercase English letters.*/

    int countPalindromicSubsequence(string s) {
        unordered_map<char, vector<int>> locs;
        for (int i = 0; i < s.size(); ++i) locs[s[i]].push_back(i);

        int ans = 0;
        string ascii_lowercase = "abcdefghijklmnopqrstuvwxyz";
        for (auto& c : ascii_lowercase)
            if (locs[c].size() > 1) {
                if (locs[c].size() > 2) ++ans;
                for (auto& cc : ascii_lowercase)
                    if (c != cc) {
                        auto lo = lower_bound(locs[cc].begin(), locs[cc].end(), locs[c].front());
                        auto hi = lower_bound(locs[cc].begin(), locs[cc].end(), locs[c].back());
                        if (lo != hi) ++ans;
                    }
            }
        return ans;
    }


    /*1931. Painting a Grid With Three Different Colors (Hard)
    You are given two integers m and n. Consider an m x n grid where each cell
    is initially white. You can paint each cell red, green, or blue. All cells
    must be painted. Return the number of ways to color the grid with no two
    adjacent cells having the same color. Since the answer can be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: m = 1, n = 1
    Output: 3
    Explanation: The three possible colorings are shown in the image above.

    Example 2:
    Input: m = 1, n = 2
    Output: 6
    Explanation: The six possible colorings are shown in the image above.

    Example 3:
    Input: m = 5, n = 5
    Output: 580986

    Constraints:
    * 1 <= m <= 5
    * 1 <= n <= 1000*/

    int colorTheGrid(int m, int n) {
        long memo[m][n][1<<2*m];
        memset(memo, 0, sizeof(memo));

        function<long(int, int, int)> fn = [&](int i, int j, int mask) {
            if (j == n) return 1l;
            if (i == m) return fn(0, j+1, mask);
            if (!memo[i][j][mask])
                for (const int& x : {1<<(2*i), 1<<(2*i+1), 3<<(2*i)}) {
                    int mask0 = mask ^ x;
                    if ((mask0 & 3<<2*i) != 0 && (i == 0 || (mask0>>2*i & 3) != (mask0>>2*i-2 & 3))) {
                        memo[i][j][mask] = (memo[i][j][mask] + fn(i+1, j, mask0)) % 1'000'000'007;
                    }
                }
            return memo[i][j][mask];
        };

        return fn(0, 0, 0);
    }


    /*1932. Merge BSTs to Create Single BST (Hard)
    You are given n BST (binary search tree) root nodes for n separate BSTs
    stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes,
    and no two roots have the same value. In one operation, you can:
    * Select two distinct indices i and j such that the value stored at one of
      the leaves of trees[i] is equal to the root value of trees[j].
    * Replace the leaf node in trees[i] with trees[j].
    * Remove trees[j] from trees.
    Return the root of the resulting BST if it is possible to form a valid BST
    after performing n - 1 operations, or null if it is impossible to create a
    valid BST. A BST (binary search tree) is a binary tree where each node
    satisfies the following property:
    * Every node in the node's left subtree has a value strictly less than the
      node's value.
    * Every node in the node's right subtree has a value strictly greater than
      the node's value.
    A leaf is a node that has no children.

    Example 1:
    Input: trees = [[2,1],[3,2,5],[5,4]]
    Output: [3,2,5,1,null,4]
    Explanation: In the first operation, pick i=1 and j=0, and merge trees[0]
                 into trees[1]. Delete trees[0], so trees = [[3,2,5,1],[5,4]].
                 In the second operation, pick i=0 and j=1, and merge trees[1]
                 into trees[0]. Delete trees[1], so trees = [[3,2,5,1,null,4]].
                 The resulting tree, shown above, is a valid BST, so return its
                 root.

    Example 2:
    Input: trees = [[5,3,8],[3,2,6]]
    Output: []
    Explanation: Pick i=0 and j=1 and merge trees[1] into trees[0]. Delete
                 trees[1], so trees = [[5,3,8,2,6]]. The resulting tree is
                 shown above. This is the only valid operation that can be
                 performed, but the resulting tree is not a valid BST, so
                 return null.

    Example 3:
    Input: trees = [[5,4],[3]]
    Output: []
    Explanation: It is impossible to perform any operations.

    Example 4:
    Input: trees = [[2,1,3]]
    Output: [2,1,3]
    Explanation: There is only one tree, and it is already a valid BST, so
                 return its root.

    Constraints:
    * n == trees.length
    * 1 <= n <= 5 * 10^4
    * The number of nodes in each tree is in the range [1, 3].
    * Each node in the input may have children but no grandchildren.
    * No two roots of trees have the same value.
    * All the trees in the input are valid BSTs.
    * 1 <= TreeNode.val <= 5 * 10^4.*/

    TreeNode* canMerge(vector<TreeNode*>& trees) {
        unordered_map<int, int> freq;
        stack<TreeNode*> stk;

        for (auto& tree : trees) {
            stk.push(tree);
            while (stk.size()) {
                TreeNode* node = stk.top(); stk.pop();
                if (node) {
                    ++freq[node->val];
                    stk.push(node->left);
                    stk.push(node->right);
                }
            }
        }

        int cnt = 0;
        TreeNode* root = NULL;
        unordered_map<int, TreeNode*> mp;

        for (auto& tree : trees) {
            mp[tree->val] = tree;
            if (freq[tree->val] & 1) {
                ++cnt;
                root = tree;
            }
        }

        if (cnt != 1) return NULL;

        stk.push(root);
        int total = trees.size();
        while (stk.size()) {
            TreeNode* node = stk.top(); stk.pop();
            if (node->left && !node->left->left && !node->left->right && mp.count(node->left->val)) {
                node->left = mp[node->left->val];
                --total;
            }
            if (node->right && !node->right->left && !node->right->right && mp.count(node->right->val)) {
                node->right = mp[node->right->val];
                --total;
            }
            if (node->left) stk.push(node->left);
            if (node->right) stk.push(node->right);
        }

        if (total != 1) return NULL;

        int prev = INT_MIN;
        TreeNode* node = root;
        while (stk.size() || node) {
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top(); stk.pop();
                if (prev >= node->val) return NULL;
                prev = node->val;
                node = node->right;
            }
        }
        return root;
    }


    /*1933. Check if String Is Decomposable Into Value-Equal Substrings (Easy)
    A value-equal string is a string where all characters are the same.
    * For example, "1111" and "33" are value-equal strings.
    * In contrast, "123" is not a value-equal string.
    Given a digit string s, decompose the string into some number of
    consecutive value-equal substrings where exactly one substring has a length
    of 2 and the remaining substrings have a length of 3. Return true if you
    can decompose s according to the above rules. Otherwise, return false. A
    substring is a contiguous sequence of characters in a string.

    Example 1:
    Input: s = "000111000"
    Output: false
    Explanation: s cannot be decomposed according to the rules because
                 ["000", "111", "000"] does not have a substring of length 2.

    Example 2:
    Input: s = "00011111222"
    Output: true
    Explanation: s can be decomposed into ["000", "111", "11", "222"].

    Example 3:
    Input: s = "011100022233"
    Output: false
    Explanation: s cannot be decomposed according to the rules because of the
                 first '0'.

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of only digits '0' through '9'.*/

    bool isDecomposable(string s) {
        int ii = 0, found = 0;
        for (int i = 0; i <= s.size(); ++i)
            if (i == s.size() || (i and s[i-1] != s[i])) {
                int r = (i - ii) % 3;
                ii = i;
                if (r == 2 && not found) found = 1;
                else if (r) return false;
            }
        return found;
    }


    /*1935. Maximum Number of Words You Can Type (Easy)
    There is a malfunctioning keyboard where some letter keys do not work. All
    other keys on the keyboard work properly. Given a string text of words
    separated by a single space (no leading or trailing spaces) and a string
    brokenLetters of all distinct letter keys that are broken, return the
    number of words in text you can fully type using this keyboard.

    Example 1:
    Input: text = "hello world", brokenLetters = "ad"
    Output: 1
    Explanation: We cannot type "world" because the 'd' key is broken.

    Example 2:
    Input: text = "leet code", brokenLetters = "lt"
    Output: 1
    Explanation: We cannot type "leet" because the 'l' and 't' keys are broken.

    Example 3:
    Input: text = "leet code", brokenLetters = "e"
    Output: 0
    Explanation: We cannot type either word because the 'e' key is broken.

    Constraints:
    * 1 <= text.length <= 10^4
    * 0 <= brokenLetters.length <= 26
    * text consists of words separated by a single space without any leading or
      trailing spaces.
    * Each word only consists of lowercase English letters.
    * brokenLetters consists of distinct lowercase English letters.*/

    int canBeTypedWords(string text, string brokenLetters) {
        unordered_set<char> broken(brokenLetters.begin(), brokenLetters.end());
        int ans = 0;
        string word;
        istringstream iss(text);
        while (iss >> word) {
            bool found = false;
            for (auto& ch : word)
                if (broken.count(ch)) found = true;
            if (!found) ++ans;
        }
        return ans;
    }


    /*1936. Add Minimum Number of Rungs (Medium)
    You are given a strictly increasing integer array rungs that represents the
    height of rungs on a ladder. You are currently on the floor at height 0,
    and you want to reach the last rung. You are also given an integer dist.
    You can only climb to the next highest rung if the distance between where
    you are currently at (the floor or on a rung) and the next rung is at most
    dist. You are able to insert rungs at any positive integer height if a rung
    is not already there. Return the minimum number of rungs that must be added
    to the ladder in order for you to climb to the last rung.

    Example 1:
    Input: rungs = [1,3,5,10], dist = 2
    Output: 2
    Explanation: You currently cannot reach the last rung. Add rungs at heights
                 7 and 8 to climb this ladder. The ladder will now have rungs
                 at [1,3,5,7,8,10].

    Example 2:
    Input: rungs = [3,6,8,10], dist = 3
    Output: 0
    Explanation: This ladder can be climbed without adding additional rungs.

    Example 3:
    Input: rungs = [3,4,6,7], dist = 2
    Output: 1
    Explanation: You currently cannot reach the first rung from the ground. Add
                 a rung at height 1 to climb this ladder. The ladder will now
                 have rungs at [1,3,4,6,7].

    Example 4:
    Input: rungs = [5], dist = 10
    Output: 0
    Explanation: This ladder can be climbed without adding additional rungs.

    Constraints:
    * 1 <= rungs.length <= 10^5
    * 1 <= rungs[i] <= 10^9
    * 1 <= dist <= 10^9
    * rungs is strictly increasing.*/

    int addRungs(vector<int>& rungs, int dist) {
        int ans = 0, prev = 0;
        for (auto& x : rungs) {
            ans += (x - prev - 1)/dist;
            prev = x;
        }
        return ans;
    }


    /*1937. Maximum Number of Points with Cost (Medium)
    You are given an m x n integer matrix points (0-indexed). Starting with 0
    points, you want to maximize the number of points you can get from the
    matrix. To gain points, you must pick one cell in each row. Picking the
    cell at coordinates (r, c) will add points[r][c] to your score. However,
    you will lose points if you pick a cell too far from the cell that you
    picked in the previous row. For every two adjacent rows r and r + 1 (where
    0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will
    subtract abs(c1 - c2) from your score. Return the maximum number of points
    you can achieve. abs(x) is defined as:
    * x for x >= 0.
    * -x for x < 0.

    Example 1:
    Input: points = [[1,2,3],[1,5,1],[3,1,1]]
    Output: 9
    Explanation: The blue cells denote the optimal cells to pick, which have
                 coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11
                 to your score. However, you must subtract
                 abs(2 - 1) + abs(1 - 0) = 2 from your score. Your final score
                 is 11 - 2 = 9.

    Example 2:
    Input: points = [[1,5],[2,3],[4,2]]
    Output: 11
    Explanation: The blue cells denote the optimal cells to pick, which have
                 coordinates (0, 1), (1, 1), and (2, 0). You add 5 + 3 + 4 = 12
                 to your score. However, you must subtract
                 abs(1 - 1) + abs(1 - 0) = 1 from your score. Your final score
                 is 12 - 1 = 11.

    Constraints:
    * m == points.length
    * n == points[r].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 0 <= points[r][c] <= 10^5*/

    long long maxPoints(vector<vector<int>>& points) {
        int m = points.size(), n = points[0].size();
        vector<vector<long long>> dp(m, vector<long long>(n));
        dp[0] = vector<long long>(points[0].begin(), points[0].end());
        for (int i = 1; i < m; ++i){
            for (int j = n-2; j >= 0; --j)
                dp[i-1][j] = max(dp[i-1][j], dp[i-1][j+1]-1);
            long long prefix = 0;
            for (int j = 0; j < n; ++j) {
                dp[i][j] = points[i][j] + max(prefix, dp[i-1][j]);
                prefix = max(prefix, dp[i-1][j])-1;
            }
        }
        return *max_element(dp.back().begin(), dp.back().end());
    }


    /*1938. Maximum Genetic Difference Query (Hard)
    There is a rooted tree consisting of n nodes numbered 0 to n - 1. Each
    node's number denotes its unique genetic value (i.e. the genetic value of
    node x is x). The genetic difference between two genetic values is defined
    as the bitwise-XOR of their values. You are given the integer array parents,
    where parents[i] is the parent for node i. If node x is the root of the
    tree, then parents[x] == -1. You are also given the array queries where
    queries[i] = [nodei, vali]. For each query i, find the maximum genetic
    difference between vali and pi, where pi is the genetic value of any node
    that is on the path between nodei and the root (including nodei and the
    root). More formally, you want to maximize vali XOR pi. Return an array ans
    where ans[i] is the answer to the ith query.

    Example 1:
    Input: parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
    Output: [2,3,7]
    Explanation: The queries are processed as follows:
    - [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.
    - [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.
    - [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.

    Example 2:
    Input: parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
    Output: [6,14,7]
    Explanation: The queries are processed as follows:
    - [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.
    - [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.
    - [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.

    Constraints:
    * 2 <= parents.length <= 10^5
    * 0 <= parents[i] <= parents.length - 1 for every node i that is not the root.
    * parents[root] == -1
    * 1 <= queries.length <= 3 * 10^4
    * 0 <= nodei <= parents.length - 1
    * 0 <= vali <= 2 * 10^5

class TrieNode {
    TrieNode* child[2] = {};
    int mult = 0;
    int val = -1;
friend class Trie;
};

class Trie {
    TrieNode* root;
public:
    Trie() { root = new TrieNode(); }
    void insert(int val) {
        TrieNode* node = root;
        for (int i = 18; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (!node->child[bit]) node->child[bit] = new TrieNode();
            node = node->child[bit];
            node->mult += 1;
        }
        node->val = val;
    }

    int search(int val) {
        TrieNode* node = root;
        for (int i = 18; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node->child[1^bit]) node = node->child[1^bit];
            else node = node->child[bit];
        }
        return val ^ node->val;
    }

    void remove(int val) {
        TrieNode* node = root;
        for (int i = 18; i >= 0; --i) {
            int bit = (val >> i) & 1;
            --node->child[bit]->mult;
            if (node->child[bit]->mult == 0) {
                delete node->child[bit];
                node->child[bit] = nullptr;
                break;
            }
            node = node->child[bit];
        }
    }
};*/

    vector<int> maxGeneticDifference(vector<int>& parents, vector<vector<int>>& queries) {
        int root = -1;
        unordered_map<int, vector<int>> tree;

        for (int i = 0; i < parents.size(); ++i) {
            if (parents[i] == -1) root = i;
            else tree[parents[i]].push_back(i);
        }

        unordered_map<int, vector<pair<int, int>>> mp;
        for (int i = 0; i < queries.size(); ++i) {
            int node = queries[i][0], val = queries[i][1];
            mp[node].emplace_back(val, i);
        }

        vector<int> ans(queries.size(), 0);
        Trie* trie = new Trie();

        function<void(int)> fn = [&](int x) {
            trie->insert(x);
            for (auto& [v, i] : mp[x]) ans[i] = trie->search(v);
            for (auto& xx : tree[x]) fn(xx);
            trie->remove(x);
        };

        fn(root);
        return ans;
    }


    /*1940. Longest Common Subsequence Between Sorted Arrays (Medium)
    Given an array of integer arrays arrays where each arrays[i] is sorted in
    strictly increasing order, return an integer array representing the longest
    common subsequence between all the arrays. A subsequence is a sequence that
    can be derived from another sequence by deleting some elements (possibly
    none) without changing the order of the remaining elements.

    Example 1:
    Input: arrays = [[1,3,4],
                     [1,4,7,9]]
    Output: [1,4]
    Explanation: The longest common subsequence in the two arrays is [1,4].

    Example 2:
    Input: arrays = [[2,3,6,8],
                     [1,2,3,5,6,7,10],
                     [2,3,4,6,9]]
    Output: [2,3,6]
    Explanation: The longest common subsequence in all three arrays is [2,3,6].

    Example 3:
    Input: arrays = [[1,2,3,4,5],
                     [6,7,8]]
    Output: []
    Explanation: There is no common subsequence between the two arrays.

    Constraints:
    * 2 <= arrays.length <= 100
    * 1 <= arrays[i].length <= 100
    * 1 <= arrays[i][j] <= 100
    * arrays[i] is sorted in strictly increasing order.*/

    vector<int> longestCommomSubsequence(vector<vector<int>>& arrays) {
        vector<int> ans;
        unordered_map<int, int> freq;
        for (auto& array : arrays)
            for (auto& x : array)
                if (++freq[x] == arrays.size()) ans.push_back(x);
        return ans;
    }


    /*1941. Check if All Characters Have Equal Number of Occurrences (Easy)
    Given a string s, return true if s is a good string, or false otherwise. A
    string s is good if all the characters that appear in s have the same
    number of occurrences (i.e., the same frequency).

    Example 1:
    Input: s = "abacbc"
    Output: true
    Explanation: The characters that appear in s are 'a', 'b', and 'c'. All
                 characters occur 2 times in s.

    Example 2:
    Input: s = "aaabb"
    Output: false
    Explanation: The characters that appear in s are 'a' and 'b'. 'a' occurs 3
                 times while 'b' occurs 2 times, which is not the same number
                 of times.

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of lowercase English letters.*/

    bool areOccurrencesEqual(string s) {
        unordered_map<char, int> freq;
        for (auto& ch : s) ++freq[ch];

        int prev = 0;
        for (auto& [k, v] : freq) {
            if (!prev) prev = v;
            else if (prev != v) return false;
        }
        return true;
    }


    /*1942. The Number of the Smallest Unoccupied Chair (Medium)
    There is a party where n friends numbered from 0 to n - 1 are attending.
    There is an infinite number of chairs in this party that are numbered from
    0 to infinity. When a friend arrives at the party, they sit on the
    unoccupied chair with the smallest number. For example, if chairs 0, 1, and
    5 are occupied when a friend comes, they will sit on chair number 2. When a
    friend leaves the party, their chair becomes unoccupied at the moment they
    leave. If another friend arrives at that same moment, they can sit in that
    chair. You are given a 0-indexed 2D integer array times where
    times[i] = [arrivali, leavingi], indicating the arrival and leaving times
    of the ith friend respectively, and an integer targetFriend. All arrival
    times are distinct. Return the chair number that the friend numbered
    targetFriend will sit on.

    Example 1:
    Input: times = [[1,4],[2,3],[4,6]], targetFriend = 1
    Output: 1
    Explanation: - Friend 0 arrives at time 1 and sits on chair 0.
                 - Friend 1 arrives at time 2 and sits on chair 1.
                 - Friend 1 leaves at time 3 and chair 1 becomes empty.
                 - Friend 0 leaves at time 4 and chair 0 becomes empty.
                 - Friend 2 arrives at time 4 and sits on chair 0.
                 Since friend 1 sat on chair 1, we return 1.

    Example 2:
    Input: times = [[3,10],[1,5],[2,6]], targetFriend = 0
    Output: 2
    Explanation: - Friend 1 arrives at time 1 and sits on chair 0.
                 - Friend 2 arrives at time 2 and sits on chair 1.
                 - Friend 0 arrives at time 3 and sits on chair 2.
                 - Friend 1 leaves at time 5 and chair 0 becomes empty.
                 - Friend 2 leaves at time 6 and chair 1 becomes empty.
                 - Friend 0 leaves at time 10 and chair 2 becomes empty.
                 Since friend 0 sat on chair 2, we return 2.

    Constraints:
    * n == times.length
    * 2 <= n <= 10^4
    * times[i].length == 2
    * 1 <= arrivali < leavingi <= 10^5
    * 0 <= targetFriend <= n - 1
    * Each arrivali time is distinct.*/

    int smallestChair(vector<vector<int>>& times, int targetFriend) {
        vector<vector<int>> vals;
        for (int i = 0; i < times.size(); ++i) {
            vals.push_back({times[i][0], 1, i});
            vals.push_back({times[i][1], 0, i});
        }
        sort(vals.begin(), vals.end());

        int k = 0;
        priority_queue<int, vector<int>, greater<>> pq;
        unordered_map<int, int> mp;

        for (auto& val : vals) {
            int i = val[2], s = 0;
            if (val[1]) {
                if (pq.size()) {
                    s = pq.top(); pq.pop();
                } else
                    s = k++;
                if (i == targetFriend) return s;
                mp[i] = s;
            } else
                pq.push(mp[i]);
        }
        return -1;
    }


    /*1943. Describe the Painting (Medium)
    There is a long and thin painting that can be represented by a number line.
    The painting was painted with multiple overlapping segments where each
    segment was painted with a unique color. You are given a 2D integer array
    segments, where segments[i] = [starti, endi, colori] represents the half-
    closed segment [starti, endi) with colori as the color. The colors in the
    overlapping segments of the painting were mixed when it was painted. When
    two or more colors mix, they form a new color that can be represented as a
    set of mixed colors.

    * For example, if colors 2, 4, and 6 are mixed, then the resulting mixed
      color is {2,4,6}.
    For the sake of simplicity, you should only output the sum of the elements
    in the set rather than the full set. You want to describe the painting with
    the minimum number of non-overlapping half-closed segments of these mixed
    colors. These segments can be represented by the 2D array painting where
    painting[j] = [leftj, rightj, mixj] describes a half-closed segment
    [leftj, rightj) with the mixed color sum of mixj.

    * For example, the painting created with segments = [[1,4,5],[1,7,7]] can
      be described by painting = [[1,4,12],[4,7,7]] because:
      + [1,4) is colored {5,7} (with a sum of 12) from both the first and
        second segments.
      + [4,7) is colored {7} from only the second segment.
    Return the 2D array painting describing the finished painting (excluding
    any parts that are not painted). You may return the segments in any order.
    A half-closed segment [a, b) is the section of the number line between
    points a and b including point a and not including point b.

    Example 1:
    Input: segments = [[1,4,5],[4,7,7],[1,7,9]]
    Output: [[1,4,14],[4,7,16]]
    Explanation: The painting can be described as follows:
                 - [1,4) is colored {5,9} (with a sum of 14) from the first and third segments.
                 - [4,7) is colored {7,9} (with a sum of 16) from the second and third segments.

    Example 2:
    Input: segments = [[1,7,9],[6,8,15],[8,10,7]]
    Output: [[1,6,9],[6,7,24],[7,8,15],[8,10,7]]
    Explanation: The painting can be described as follows:
                 - [1,6) is colored 9 from the first segment.
                 - [6,7) is colored {9,15} (with a sum of 24) from the first and second segments.
                 - [7,8) is colored 15 from the second segment.
                 - [8,10) is colored 7 from the third segment.

    Example 3:
    Input: segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]
    Output: [[1,4,12],[4,7,12]]
    Explanation: The painting can be described as follows:
                 - [1,4) is colored {5,7} (with a sum of 12) from the first and second segments.
                 - [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.
                 Note that returning a single segment [1,7) is incorrect
                 because the mixed color sets are different.

    Constraints:
    * 1 <= segments.length <= 2 * 10^4
    * segments[i].length == 3
    * 1 <= starti < endi <= 10^5
    * 1 <= colori <= 10^9
    * Each colori is distinct.*/

    vector<vector<long long>> splitPainting(vector<vector<int>>& segments) {
        vector<vector<int>> vals;
        for (auto& segment : segments) {
            vals.push_back({segment[0],  segment[2]});
            vals.push_back({segment[1], -segment[2]});
        }
        sort(vals.begin(), vals.end());

        int prev = 0;
        long long prefix = 0;
        vector<vector<long long>> ans;

        for (auto& val : vals) {
            if (prev < val[0] && prefix) ans.push_back({prev, val[0], prefix});
            prev = val[0];
            prefix += val[1];
        }
        return ans;
    }


    /*1944. Number of Visible People in a Queue (Hard)
    There are n people standing in a queue, and they numbered from 0 to n - 1
    in left to right order. You are given an array heights of distinct integers
    where heights[i] represents the height of the ith person. A person can see
    another person to their right in the queue if everybody in between is
    shorter than both of them. More formally, the ith person can see the jth
    person if
    * i < j and
    * min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]).
    Return an array answer of length n where answer[i] is the number of people
    the ith person can see to their right in the queue.

    Example 1:
    Input: heights = [10,6,8,5,11,9]
    Output: [3,1,2,1,1,0]
    Explanation: Person 0 can see person 1, 2, and 4.
                 Person 1 can see person 2.
                 Person 2 can see person 3 and 4.
                 Person 3 can see person 4.
                 Person 4 can see person 5.
                 Person 5 can see no one since nobody is to the right of them.

    Example 2:
    Input: heights = [5,1,2,3,10]
    Output: [4,1,1,1,0]

    Constraints:
    * n == heights.length
    * 1 <= n <= 10^5
    * 1 <= heights[i] <= 10^5
    * All the values of heights are unique.*/

    vector<int> canSeePersonsCount(vector<int>& heights) {
        int n = heights.size();
        vector<int> ans(n);
        stack<int> stk;
        for (int i = n-1; i >= 0; --i) {
            while (stk.size() && stk.top() <= heights[i]) {
                ++ans[i];
                stk.pop();
            }
            if (stk.size()) ++ans[i];
            stk.push(heights[i]);
        }
        return ans;
    }


    /*1945. Sum of Digits of String After Convert (Easy)
    You are given a string s consisting of lowercase English letters, and an
    integer k. First, convert s into an integer by replacing each letter with
    its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ...,
    'z' with 26). Then, transform the integer by replacing it with the sum of
    its digits. Repeat the transform operation k times in total. For example,
    if s = "zbax" and k = 2, then the resulting integer would be 8 by the
    following operations:
    * Convert: "zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124
    * Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
    * Transform #2: 17 ➝ 1 + 7 ➝ 8
    Return the resulting integer after performing the operations described
    above.

    Example 1:
    Input: s = "iiii", k = 1
    Output: 36
    Explanation: The operations are as follows:
                 - Convert: "iiii" ➝ "(9)(9)(9)(9)" ➝ "9999" ➝ 9999
                 - Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36
                 Thus the resulting integer is 36.

    Example 2:
    Input: s = "leetcode", k = 2
    Output: 6
    Explanation: The operations are as follows:
                 - Convert: "leetcode" ➝ "(12)(5)(5)(20)(3)(15)(4)(5)" ➝ "12552031545" ➝ 12552031545
                 - Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33
                 - Transform #2: 33 ➝ 3 + 3 ➝ 6
                 Thus the resulting integer is 6.

    Example 3:
    Input: s = "zbax", k = 2
    Output: 8

    Constraints:
    * 1 <= s.length <= 100
    * 1 <= k <= 10
    * s consists of lowercase English letters.*/

    int getLucky(string s, int k) {
        int ans = 0;
        for (auto& ch : s) {
            int x = ch - 'a' + 1;
            ans += x/10 + x%10;
        }
        for (int v = 0; --k; ans = v)
            for (v = 0; ans; ans /= 10)
                v += ans % 10;
        return ans;
    }


    /*1946. Largest Number After Mutating Substring (Medium)
    You are given a string num, which represents a large integer. You are also
    given a 0-indexed integer array change of length 10 that maps each digit
    0-9 to another digit. More formally, digit d maps to digit change[d]. You
    may choose to mutate any substring of num. To mutate a substring, replace
    each digit num[i] with the digit it maps to in change (i.e. replace num[i]
    with change[num[i]]). Return a string representing the largest possible
    integer after mutating (or choosing not to) any substring of num. A
    substring is a contiguous sequence of characters within the string.

    Example 1:
    Input: num = "132", change = [9,8,5,0,3,6,4,2,6,8]
    Output: "832"
    Explanation: Replace the substring "1":
                 - 1 maps to change[1] = 8.
                 Thus, "132" becomes "832". "832" is the largest number that
                 can be created, so return it.

    Example 2:
    Input: num = "021", change = [9,4,3,5,7,2,1,9,0,6]
    Output: "934"
    Explanation: Replace the substring "021":
                 - 0 maps to change[0] = 9.
                 - 2 maps to change[2] = 3.
                 - 1 maps to change[1] = 4.
                 Thus, "021" becomes "934". "934" is the largest number that
                 can be created, so return it.

    Example 3:
    Input: num = "5", change = [1,4,7,5,3,2,5,6,9,4]
    Output: "5"
    Explanation: "5" is already the largest number that can be created, so
                 return it.

    Constraints:
    * 1 <= num.length <= 10^5
    * num consists of only digits 0-9.
    * change.length == 10
    * 0 <= change[d] <= 9*/

    string maximumNumber(string num, vector<int>& change) {
        bool on = false;
        for (int i = 0; i < num.size(); ++i) {
            int x = num[i] - '0';
            if (x < change[x]) {
                on = true;
                num[i] = change[x] + '0';
            } else if (x > change[x] && on) break;
        }
        return num;
    }


    /*1947. Maximum Compatibility Score Sum (Medium)
    There is a survey that consists of n questions where each question's answer
    is either 0 (no) or 1 (yes). The survey was given to m students numbered
    from 0 to m - 1 and m mentors numbered from 0 to m - 1. The answers of the
    students are represented by a 2D integer array students where students[i]
    is an integer array that contains the answers of the ith student (0-indexed).
    The answers of the mentors are represented by a 2D integer array mentors
    where mentors[j] is an integer array that contains the answers of the jth
    mentor (0-indexed). Each student will be assigned to one mentor, and each
    mentor will have one student assigned to them. The compatibility score of a
    student-mentor pair is the number of answers that are the same for both the
    student and the mentor.

    * For example, if the student's answers were [1, 0, 1] and the mentor's
      answers were [0, 0, 1], then their compatibility score is 2 because only
      the second and the third answers are the same.
    You are tasked with finding the optimal student-mentor pairings to maximize
    the sum of the compatibility scores. Given students and mentors, return the
    maximum compatibility score sum that can be achieved.

    Example 1:
    Input: students = [[1,1,0],[1,0,1],[0,0,1]],
           mentors = [[1,0,0],[0,0,1],[1,1,0]]
    Output: 8
    Explanation: We assign students to mentors in the following way:
                 - student 0 to mentor 2 with a compatibility score of 3.
                 - student 1 to mentor 0 with a compatibility score of 2.
                 - student 2 to mentor 1 with a compatibility score of 3.
                 The compatibility score sum is 3 + 2 + 3 = 8.

    Example 2:
    Input: students = [[0,0],[0,0],[0,0]],
           mentors = [[1,1],[1,1],[1,1]]
    Output: 0
    Explanation: The compatibility score of any student-mentor pair is 0.

    Constraints:
    * m == students.length == mentors.length
    * n == students[i].length == mentors[j].length
    * 1 <= m, n <= 8
    * students[i][k] is either 0 or 1.
    * mentors[j][k] is either 0 or 1.*/

    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {
        int m = students.size(), n = students[0].size();
        vector<vector<int>> score(m, vector<int>(m));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < m; ++j)
                for (int k = 0; k < n; ++k)
                    if (students[i][k] == mentors[j][k]) ++score[i][j];

        vector<int> dp(1 << m);
        for (int mask = 0; mask < (1 << m); ++mask) {
            int i = __builtin_popcount(mask);
            for (int j = 0; j < m; ++j)
                if (!(mask & (1 << j)))
                    dp[mask^(1 << j)] = max(dp[mask^(1 << j)], dp[mask] + score[i][j]);
        }
        return dp.back();
    }


    /*1948. Delete Duplicate Folders in System (Hard)
    Due to a bug, there are many duplicate folders in a file system. You are
    given a 2D array paths, where paths[i] is an array representing an absolute
    path to the ith folder in the file system.

    * For example, ["one", "two", "three"] represents the path "/one/two/three".
    Two folders (not necessarily on the same level) are identical if they
    contain the same non-empty set of identical subfolders and underlying
    subfolder structure. The folders do not need to be at the root level to be
    identical. If two or more folders are identical, then mark the folders as
    well as all their subfolders.

    * For example, folders "/a" and "/b" in the file structure below are
      identical. They (as well as their subfolders) should all be marked:
      - /a
      - /a/x
      - /a/x/y
      - /a/z
      - /b
      - /b/x
      - /b/x/y
      - /b/z
    * However, if the file structure also included the path "/b/w", then the
      folders "/a" and "/b" would not be identical. Note that "/a/x" and "/b/x"
      would still be considered identical even with the added folder.
    Once all the identical folders and their subfolders have been marked, the
    file system will delete all of them. The file system only runs the deletion
    once, so any folders that become identical after the initial deletion are
    not deleted. Return the 2D array ans containing the paths of the remaining
    folders after deleting all the marked folders. The paths may be returned in
    any order.

    Example 1:
    Input: paths = [["a"],["c"],["d"],["a","b"],["c","b"],["d","a"]]
    Output: [["d"],["d","a"]]
    Explanation: Folders "/a" and "/c" (and their subfolders) are marked for
                 deletion because they both contain an empty folder named "b".

    Example 2:
    Input: paths = [["a"],["c"],["a","b"],["c","b"],["a","b","x"],["a","b","x","y"],["w"],["w","y"]]
    Output: [["c"],["c","b"],["a"],["a","b"]]
    Explanation: Folders "/a/b/x" and "/w" (and their subfolders) are marked
                 for deletion because they both contain an empty folder named
                 "y". Note that folders "/a" and "/c" are identical after the
                 deletion, but they are not deleted because they were not
                 marked beforehand.

    Example 3:
    Input: paths = [["a","b"],["c","d"],["c"],["a"]]
    Output: [["c"],["c","d"],["a"],["a","b"]]
    Explanation: All folders are unique in the file system. Note that the
                 returned array can be in a different order as the order does
                 not matter.

    Example 4:
    Input: paths = [["a"],["a","x"],["a","x","y"],["a","z"],["b"],["b","x"],["b","x","y"],["b","z"]]
    Output: []
    Explanation: Folders "/a/x" and "/b/x" (and their subfolders) are marked
                 for deletion because they both contain an empty folder named
                 "y". Folders "/a" and "/b" (and their subfolders) are marked
                 for deletion because they both contain an empty folder "z" and
                 the folder "x" described above.

    Example 5:
    Input: paths = [["a"],["a","x"],["a","x","y"],["a","z"],["b"],["b","x"],["b","x","y"],["b","z"],["b","w"]]
    Output: [["b"],["b","w"],["b","z"],["a"],["a","z"]]
    Explanation: This has the same structure as the previous example, except
                 with the added "/b/w". Folders "/a/x" and "/b/x" are still
                 marked, but "/a" and "/b" are no longer marked because "/b"
                 has the empty folder named "w" and "/a" does not. Note that
                 "/a/z" and "/b/z" are not marked because the set of identical
                 subfolders must be non-empty, but these folders are empty.

    Constraints:
    * 1 <= paths.length <= 2 * 10^4
    * 1 <= paths[i].length <= 500
    * 1 <= paths[i][j].length <= 10
    * 1 <= sum(paths[i][j].length) <= 2 * 10^5
    * path[i][j] consists of lowercase English letters.
    * No two paths lead to the same folder.
    * For any folder not at the root level, its parent folder will also be in the input.

class Node {
public:
    bool mark = false;
    int index = -1;
    unordered_map<string, Node*> next;
};*/

    vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {
        sort(paths.begin(), paths.end());

        Node* tree = new Node();
        for (int i = 0; i < paths.size(); ++i) {
            Node* node = tree;
            for (auto& x : paths[i]) {
                if (node->next.count(x) == 0) node->next[x] = new Node();
                node = node->next[x];
            }
            node->index = i;
        }

        unordered_map<string, vector<int>> mp;

        function<string(Node*)> fn = [&](Node* node) -> string {
            if (node->next.size() == 0) return "$";
            string ans;
            for (auto& [k, nn] : node->next)
                ans += "$" + k + "$" + fn(nn);
            mp[ans].push_back(node->index);
            return ans;
        };

        fn(tree);

        unordered_set<int> mark;
        for (auto& [k, v] : mp)
            if (v.size() > 1)
                for (auto& vv : v) mark.insert(vv);

        vector<vector<string>> ans;
        stack<Node*> stk;
        stk.push(tree);

        while(stk.size()) {
            Node* node = stk.top(); stk.pop();
            if (node->index >= 0) ans.push_back(paths[node->index]);
            for (auto& [k, nn] : node->next) {
                if (mark.find(nn->index) == mark.end())
                    stk.push(nn);
            }
        }
        return ans;
    }


    /*1950. Maximum of Minimum Values in All Subarrays (Medium)
    You are given an integer array nums of size n. You are asked to solve n
    queries for each integer i in the range 0 <= i < n. To solve the ith query:
    * Find the minimum value in each possible subarray of size i + 1 of the
      array nums.
    * Find the maximum of those minimum values. This maximum is the answer to
      the query.
    Return a 0-indexed integer array ans of size n such that ans[i] is the
    answer to the ith query. A subarray is a contiguous sequence of elements in
    an array.

    Example 1:
    Input: nums = [0,1,2,4]
    Output: [4,2,1,0]
    Explanation: i=0:
                 - The subarrays of size 1 are [0], [1], [2], [4]. The minimum values are 0, 1, 2, 4.
                 - The maximum of the minimum values is 4.
                 i=1:
                 - The subarrays of size 2 are [0,1], [1,2], [2,4]. The minimum values are 0, 1, 2.
                 - The maximum of the minimum values is 2.
                 i=2:
                 - The subarrays of size 3 are [0,1,2], [1,2,4]. The minimum values are 0, 1.
                 - The maximum of the minimum values is 1.
                 i=3:
                 - There is one subarray of size 4, which is [0,1,2,4]. The minimum value is 0.
                 - There is only one value, so the maximum is 0.

    Example 2:
    Input: nums = [10,20,50,10]
    Output: [50,20,10,10]
    Explanation: i=0:
                 - The subarrays of size 1 are [10], [20], [50], [10]. The minimum values are 10, 20, 50, 10.
                 - The maximum of the minimum values is 50.
                 i=1:
                 - The subarrays of size 2 are [10,20], [20,50], [50,10]. The minimum values are 10, 20, 10.
                 - The maximum of the minimum values is 20.
                 i=2:
                 - The subarrays of size 3 are [10,20,50], [20,50,10]. The minimum values are 10, 10.
                 - The maximum of the minimum values is 10.
                 i=3:
                 - There is one subarray of size 4, which is [10,20,50,10]. The minimum value is 10.
                 - There is only one value, so the maximum is 10.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 0 <= nums[i] <= 10^9*/

    vector<int> findMaximums(vector<int>& nums) {
        vector<int> ans(nums.size()), stk;

        nums.push_back(0);
        for (int i = 0; i < nums.size(); ++i) {
            while (stk.size() && nums[stk.back()] >= nums[i]) {
                int val = nums[stk.back()], k = i-1;
                stk.pop_back();
                if (stk.size()) k = i-stk.back()-2;
                ans[k] = max(ans[k], val);
            }
            stk.push_back(i);
        }
        for (int i = ans.size()-1; i; --i) ans[i-1] = max(ans[i-1], ans[i]);
        return ans;
    }


    /*1952. Three Divisors (Easy)
    Given an integer n, return true if n has exactly three positive divisors.
    Otherwise, return false. An integer m is a divisor of n if there exists an
    integer k such that n = k * m.

    Example 1:
    Input: n = 2
    Output: false
    Explantion: 2 has only two divisors: 1 and 2.

    Example 2:
    Input: n = 4
    Output: true
    Explantion: 4 has three divisors: 1, 2, and 4.

    Constraints: 1 <= n <= 10^4*/


    bool isThree(int n) {
        if (n == 1) return false;
        int x = sqrt(n);
        if (x*x != n) return false;

        for (int i = 2; i <= sqrt(x); ++i)
            if (x % i == 0) return false;
        return true;
    }


    /*1953. Maximum Number of Weeks for Which You Can Work (Medium)
    There are n projects numbered from 0 to n - 1. You are given an integer
    array milestones where each milestones[i] denotes the number of milestones
    the ith project has. You can work on the projects following these two rules:
    * Every week, you will finish exactly one milestone of one project. You
      must work every week.
    * You cannot work on two milestones from the same project for two
      consecutive weeks.
    Once all the milestones of all the projects are finished, or if the only
    milestones that you can work on will cause you to violate the above rules,
    you will stop working. Note that you may not be able to finish every
    project's milestones due to these constraints. Return the maximum number of
    weeks you would be able to work on the projects without violating the rules
    mentioned above.

    Example 1:
    Input: milestones = [1,2,3]
    Output: 6
    Explanation: One possible scenario is:
                 - During the 1st week, you will work on a milestone of project 0.
                 - During the 2nd week, you will work on a milestone of project 2.
                 - During the 3rd week, you will work on a milestone of project 1.
                 - During the 4th week, you will work on a milestone of project 2.
                 - During the 5th week, you will work on a milestone of project 1.
                 - During the 6th week, you will work on a milestone of project 2.
                 The total number of weeks is 6.

    Example 2:
    Input: milestones = [5,2,1]
    Output: 7
    Explanation: One possible scenario is:
                 - During the 1st week, you will work on a milestone of project 0.
                 - During the 2nd week, you will work on a milestone of project 1.
                 - During the 3rd week, you will work on a milestone of project 0.
                 - During the 4th week, you will work on a milestone of project 1.
                 - During the 5th week, you will work on a milestone of project 0.
                 - During the 6th week, you will work on a milestone of project 2.
                 - During the 7th week, you will work on a milestone of project 0.
                 The total number of weeks is 7. Note that you cannot work on
                 the last milestone of project 0 on 8th week because it would
                 violate the rules. Thus, one milestone in project 0 will
                 remain unfinished.

    Constraints:
    * n == milestones.length
    * 1 <= n <= 10^5
    * 1 <= milestones[i] <= 10^9*/

    long long numberOfWeeks(vector<int>& milestones) {
        long long m = *max_element(milestones.begin(), milestones.end()), s = accumulate(milestones.begin(), milestones.end(), 0ll);
        return s - max(0ll, 2*m - s - 1);
    }


    /*1954. Minimum Garden Perimeter to Collect Enough Apples (Medium)
    In a garden represented as an infinite 2D grid, there is an apple tree
    planted at every integer coordinate. The apple tree planted at an integer
    coordinate (i, j) has |i| + |j| apples growing on it. You will buy an axis-
    aligned square plot of land that is centered at (0, 0). Given an integer
    neededApples, return the minimum perimeter of a plot such that at least
    neededApples apples are inside or on the perimeter of that plot.

    The value of |x| is defined as:
    * x if x >= 0
    * -x if x < 0

    Example 1:
    Input: neededApples = 1
    Output: 8
    Explanation: A square plot of side length 1 does not contain any apples.
                 However, a square plot of side length 2 has 12 apples inside
                 (as depicted in the image above). The perimeter is 2 * 4 = 8.

    Example 2:
    Input: neededApples = 13
    Output: 16

    Example 3:
    Input: neededApples = 1000000000
    Output: 5040

    Constraints: 1 <= neededApples <= 10^15*/

    long long minimumPerimeter(long long neededApples) {
        long long lo = 0, hi = 100000;
        while (lo < hi) {
            long long mid = lo + (hi - lo)/2;
            if (2*mid*(mid+1)*(2*mid+1) < neededApples) lo = mid+1;
            else hi = mid;
        }
        return lo*8;
    }


    /*1955. Count Number of Special Subsequences (Hard)
    A sequence is special if it consists of a positive number of 0s, followed
    by a positive number of 1s, then a positive number of 2s.
    * For example, [0,1,2] and [0,0,1,1,1,2] are special.
    * In contrast, [2,1,0], [1], and [0,1,2,0] are not special.
    Given an array nums (consisting of only integers 0, 1, and 2), return the
    number of different subsequences that are special. Since the answer may be
    very large, return it modulo 10^9 + 7. A subsequence of an array is a
    sequence that can be derived from the array by deleting some or no elements
    without changing the order of the remaining elements. Two subsequences are
    different if the set of indices chosen are different.

    Example 1:
    Input: nums = [0,1,2,2]
    Output: 3
    Explanation: The special subsequences are [0,1,2,2], [0,1,2,2], and
                 [0,1,2,2].

    Example 2:
    Input: nums = [2,2,0,0]
    Output: 0
    Explanation: There are no special subsequences in [2,2,0,0].

    Example 3:
    Input: nums = [0,1,2,0,1,2]
    Output: 7
    Explanation: The special subsequences are:
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 2*/

    int countSpecialSubsequences(vector<int>& nums) {
        const int MOD = 1'000'000'007;
        long s0 = 0, s1 = 0, s2 = 0;
        for (auto& x : nums) {
            if (x == 0) s0 = (1 + 2*s0) % MOD;
            else if (x == 1) s1 = (s0 + 2*s1) % MOD;
            else s2 = (s1 + 2*s2) % MOD;
        }
        return s2;
    }


    /*1956. Minimum Time For K Virus Variants to Spread (Hard)
    There are n unique virus variants in an infinite 2D grid. You are given a
    2D array points, where points[i] = [xi, yi] represents a virus originating
    at (xi, yi) on day 0. Note that it is possible for multiple virus variants
    to originate at the same point. Every day, each cell infected with a virus
    variant will spread the virus to all neighboring points in the four
    cardinal directions (i.e. up, down, left, and right). If a cell has
    multiple variants, all the variants will spread without interfering with
    each other. Given an integer k, return the minimum integer number of days
    for any point to contain at least k of the unique virus variants.

    Example 1:
    Input: points = [[1,1],[6,1]], k = 2
    Output: 3
    Explanation: On day 3, points (3,1) and (4,1) will contain both virus
                 variants. Note that these are not the only points that will
                 contain both virus variants.

    Example 2:
    Input: points = [[3,3],[1,2],[9,2]], k = 2
    Output: 2
    Explanation: On day 2, points (1,3), (2,3), (2,2), and (3,2) will contain
                 the first two viruses. Note that these are not the only points
                 that will contain both virus variants.

    Example 3:
    Input: points = [[3,3],[1,2],[9,2]], k = 3
    Output: 4
    Explanation: On day 4, the point (5,2) will contain all 3 viruses. Note
                 that this is not the only point that will contain all 3 virus
                 variants.

    Constraints:
    * n == points.length
    * 2 <= n <= 50
    * points[i].length == 2
    * 1 <= xi, yi <= 100
    * 2 <= k <= n*/

    int minDayskVariants(vector<vector<int>>& points, int k) {

        auto fn = [&](int day) {
            unordered_map<int, unordered_map<int, int>> lines;
            for (auto& p : points) {
                int x = p[0], y = p[1];
                lines[x+y-day][y-x+day];
                lines[x+y+day][y-x-day];
                lines[x+y+day][y-x+day];
                ++lines[x+y-day][y-x-day];
                --lines[x+y-day][y-x+day+1];
                --lines[x+y+day+1][y-x-day];
                ++lines[x+y+day+1][y-x+day+1];
            }
            vector<int> rows;
            for (auto& [k, _] : lines) rows.push_back(k);
            sort(rows.begin(), rows.end());
            unordered_map<int, int> line;
            for (auto& xx : rows) {
                for (auto& [yy, vv] : lines[xx]) line[yy] += vv;
                int prefix = 0;
                vector<int> keys;
                for (auto& [k, v] : line) keys.push_back(k);
                sort(keys.begin(), keys.end());
                for (auto& yy : keys) {
                    prefix += line[yy];
                    if (prefix >= k && ((xx-yy)%2 == 0 || !lines.count(xx+1) || prefix+line[yy+1] >= k)) return true;
                }
            }
            return false;
        };

        int lo = 0, hi = 1'000'000'000;
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (fn(mid)) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }


    /*1957. Delete Characters to Make Fancy String (Easy)
    A fancy string is a string where no three consecutive characters are equal.
    Given a string s, delete the minimum possible number of characters from s
    to make it fancy. Return the final string after the deletion. It can be
    shown that the answer will always be unique.

    Example 1:
    Input: s = "leeetcode"
    Output: "leetcode"
    Explanation: Remove an 'e' from the first group of 'e's to create
                 "leetcode". No three consecutive characters are equal, so
                 return "leetcode".

    Example 2:
    Input: s = "aaabaaaa"
    Output: "aabaa"
    Explanation: Remove an 'a' from the first group of 'a's to create "aabaaaa".
                 Remove two 'a's from the second group of 'a's to create "aabaa".
                 No three consecutive characters are equal, so return "aabaa".

    Example 3:
    Input: s = "aab"
    Output: "aab"
    Explanation: No three consecutive characters are equal, so return "aab".

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters.*/

    string makeFancyString(string s) {
        int ii = 1;
        for (int i = 2; i < s.size(); ++i) {
            if (s[ii-1] == s[ii] && s[ii] == s[i]) continue;
            s[++ii] = s[i];
        }
        return s.substr(0, ++ii);
    }


    /*1958. Check if Move is Legal (Medium)
    You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents
    the cell (r, c) on a game board. On the board, free cells are represented
    by '.', white cells are represented by 'W', and black cells are represented
    by 'B'. Each move in this game consists of choosing a free cell and
    changing it to the color you are playing as (either white or black).
    However, a move is only legal if, after changing it, the cell becomes the
    endpoint of a good line (horizontal, vertical, or diagonal). A good line is
    a line of three or more cells (including the endpoints) where the endpoints
    of the line are one color, and the remaining cells in the middle are the
    opposite color (no cells in the line are free). Given two integers rMove
    and cMove and a character color representing the color you are playing as
    (white or black), return true if changing cell (rMove, cMove) to color
    color is a legal move, or false if it is not legal.

    Example 1:
    Input: board = [[".",".",".","B",".",".",".","."],
                    [".",".",".","W",".",".",".","."],
                    [".",".",".","W",".",".",".","."],
                    [".",".",".","W",".",".",".","."],
                    ["W","B","B",".","W","W","W","B"],
                    [".",".",".","B",".",".",".","."],
                    [".",".",".","B",".",".",".","."],
                    [".",".",".","W",".",".",".","."]],
           rMove = 4, cMove = 3, color = "B"
    Output: true
    Explanation: '.', 'W', and 'B' are represented by the colors blue, white,
                 and black respectively, and cell (rMove, cMove) is marked with
                 an 'X'. The two good lines with the chosen cell as an endpoint
                 are annotated above with the red rectangles.

    Example 2:
    Input: board = [[".",".",".",".",".",".",".","."],
                    [".","B",".",".","W",".",".","."],
                    [".",".","W",".",".",".",".","."],
                    [".",".",".","W","B",".",".","."],
                    [".",".",".",".",".",".",".","."],
                    [".",".",".",".","B","W",".","."],
                    [".",".",".",".",".",".","W","."],
                    [".",".",".",".",".",".",".","B"]],
           rMove = 4, cMove = 4, color = "W"
    Output: false
    Explanation: While there are good lines with the chosen cell as a middle
                 cell, there are no good lines with the chosen cell as an
                 endpoint.

    Constraints:
    * board.length == board[r].length == 8
    * 0 <= rMove, cMove < 8
    * board[rMove][cMove] == '.'
    * color is either 'B' or 'W'.*/

    bool checkMove(vector<vector<char>>& board, int rMove, int cMove, char color) {
        int dir[9] = {1, 0, -1, 0, 1, 1, -1, -1, 1};
        for (int k = 0; k < 8; ++k) {
            for (int i = rMove, j = cMove, step = 0; 0 <= i && i < 8 && 0 <= j && j < 8; i += dir[k], j += dir[k+1], ++step) {
                if (board[i][j] == color && step > 1) return true;
                if ((board[i][j] == '.' && step > 0) || (board[i][j] == color && step == 1)) break;
            }
        }
        return false;
    }


    /*1959. Minimum Total Space Wasted With K Resizing Operations (Medium)
    You are currently designing a dynamic array. You are given a 0-indexed
    integer array nums, where nums[i] is the number of elements that will be in
    the array at time i. In addition, you are given an integer k, the maximum
    number of times you can resize the array (to any size). The size of the
    array at time t, sizet, must be at least nums[t] because there needs to be
    enough space in the array to hold all the elements. The space wasted at
    time t is defined as sizet - nums[t], and the total space wasted is the sum
    of the space wasted across every time t where 0 <= t < nums.length. Return
    the minimum total space wasted if you can resize the array at most k times.
    Note: The array can have any size at the start and does not count towards
    the number of resizing operations.

    Example 1:
    Input: nums = [10,20], k = 0
    Output: 10
    Explanation: size = [20,20]. We can set the initial size to be 20. The
                 total wasted space is (20 - 10) + (20 - 20) = 10.

    Example 2:
    Input: nums = [10,20,30], k = 1
    Output: 10
    Explanation: size = [20,20,30]. We can set the initial size to be 20 and
                 resize to 30 at time 2. The total wasted space is
                 (20 - 10) + (20 - 20) + (30 - 30) = 10.

    Example 3:
    Input: nums = [10,20,15,30,20], k = 2
    Output: 15
    Explanation: size = [10,20,20,30,30]. We can set the initial size to 10,
                 resize to 20 at time 1, and resize to 30 at time 3. The total
                 wasted space is
                 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15.

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= 10^6
    * 0 <= k <= nums.length - 1*/

    int minSpaceWastedKResizing(vector<int>& nums, int k) {
        int n = nums.size();
        vector<vector<int>> dp(n+1, vector<int>(k+1, INT_MAX));

        for (int j = 0; j <= k; ++j) dp[n][j] = 0;
        int total = 0, most = 0;
        for (int i = n-1; i >= 0; --i) {
            most = max(most, nums[i]);
            total += nums[i];
            dp[i][0] = most * (n - i) - total;
        }

        for (int i = n-1; i >= 0; --i)
            for (int j = 1; j <= k; ++j) {
                total = most = 0;
                for (int ii = i; ii < n; ++ii) {
                    total += nums[ii];
                    most = max(most, nums[ii]);
                    dp[i][j] = min(dp[i][j], most * (ii - i + 1) - total + dp[ii+1][j-1]);
                }
            }
        return dp[0][k];
    }


    /*1960. Maximum Product of the Length of Two Palindromic Substrings (Hard)
    You are given a 0-indexed string s and are tasked with finding two non-
    intersecting palindromic substrings of odd length such that the product of
    their lengths is maximized. More formally, you want to choose four integers
    i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the
    substrings s[i...j] and s[k...l] are palindromes and have odd lengths.
    s[i...j] denotes a substring from index i to index j inclusive. Return the
    maximum possible product of the lengths of the two non-intersecting
    palindromic substrings. A palindrome is a string that is the same forward
    and backward. A substring is a contiguous sequence of characters in a
    string.

    Example 1:
    Input: s = "ababbb"
    Output: 9
    Explanation: Substrings "aba" and "bbb" are palindromes with odd length.
                 product = 3 * 3 = 9.

    Example 2:
    Input: s = "zaaaxbbby"
    Output: 9
    Explanation: Substrings "aaa" and "bbb" are palindromes with odd length.
                 product = 3 * 3 = 9.

    Constraints:
    * 2 <= s.length <= 10^5
    * s consists of lowercase English letters.*/

    long long maxProduct(string s) {
        int n = s.size(), center = 0, right = 0;
        vector<int> hlen(n, 0), prefix(n, 0), suffix(n, 0);
        for (int i = 0; i < n; ++i) {
            if (i < right) hlen[i] = min(right - i, hlen[2*center - i]);
            while (0 <= i-1-hlen[i] && i+1+hlen[i] < n && s[i-1-hlen[i]] == s[i+1+hlen[i]]) ++hlen[i];
            if (right < i + hlen[i]) {
                center = i;
                right = i + hlen[i];
            }
        }

        for (int i = 0; i < n; ++i) {
            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i] + 1);
            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i] + 1);
        }

        for (int i = 1; i < n; ++i) {
            prefix[n-1-i] = max(prefix[n-1-i], prefix[n-i]-2);
            suffix[i] = max(suffix[i], suffix[i-1]-2);
        }

        for (int i = 1; i < n; ++i) {
            prefix[i] = max(prefix[i-1], prefix[i]);
            suffix[n-1-i] = max(suffix[n-1-i], suffix[n-i]);
        }

        long long ans = 0ll;
        for (int i = 1; i < n; ++i) ans = max(ans, (long long) prefix[i-1] * suffix[i]);
        return ans;
    }


    /*1961. Check If String Is a Prefix of Array (Easy)
    Given a string s and an array of strings words, determine whether s is a
    prefix string of words. A string s is a prefix string of words if s can be
    made by concatenating the first k strings in words for some positive k no
    larger than words.length. Return true if s is a prefix string of words, or
    false otherwise.

    Example 1:
    Input: s = "iloveleetcode", words = ["i","love","leetcode","apples"]
    Output: true
    Explanation: s can be made by concatenating "i", "love", and "leetcode"
                 together.

    Example 2:
    Input: s = "iloveleetcode", words = ["apples","i","love","leetcode"]
    Output: false
    Explanation: It is impossible to make s using a prefix of arr.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 20
    * 1 <= s.length <= 1000
    * words[i] and s consist of only lowercase English letters.*/

    bool isPrefixString(string s, vector<string>& words) {
        int i = 0;
        for (auto& word : words) {
            if (s.substr(i, word.size()) != word) return false;
            i += word.size();
            if (i == s.size()) return true;
        }
        return false;
    }


    /*1962. Remove Stones to Minimize the Total (Medium)
    You are given a 0-indexed integer array piles, where piles[i] represents
    the number of stones in the ith pile, and an integer k. You should apply
    the following operation exactly k times:
    * Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
    Notice that you can apply the operation on the same pile more than once.
    Return the minimum possible total number of stones remaining after applying
    the k operations. floor(x) is the greatest integer that is smaller than or
    equal to x (i.e., rounds x down).

    Example 1:
    Input: piles = [5,4,9], k = 2
    Output: 12
    Explanation: Steps of a possible scenario are:
                 - Apply the operation on pile 2. The resulting piles are [5,4,5].
                 - Apply the operation on pile 0. The resulting piles are [3,4,5].
                 The total number of stones in [3,4,5] is 12.

    Example 2:
    Input: piles = [4,3,6,7], k = 3
    Output: 12
    Explanation: Steps of a possible scenario are:
                 - Apply the operation on pile 3. The resulting piles are [4,3,3,7].
                 - Apply the operation on pile 4. The resulting piles are [4,3,3,4].
                 - Apply the operation on pile 0. The resulting piles are [2,3,3,4].
                 The total number of stones in [2,3,3,4] is 12.

    Constraints:
    * 1 <= piles.length <= 10^5
    * 1 <= piles[i] <= 10^4
    * 1 <= k <= 10^5*/

    int minStoneSum(vector<int>& piles, int k) {
        priority_queue<int> pq;
        for (auto& x : piles) pq.push(x);
        while (k--) {
            int x = pq.top(); pq.pop();
            x -= x/2;
            pq.push(x);
        }
        int ans = 0;
        while (pq.size()) {
            ans += pq.top(); pq.pop();
        }
        return ans;
    }


    /*1963. Minimum Number of Swaps to Make the String Balanced (Medium)
    You are given a 0-indexed string s of even length n. The string consists of
    exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'. A string
    is called balanced if and only if:
    * It is the empty string, or
    * It can be written as AB, where both A and B are balanced strings, or
    * It can be written as [C], where C is a balanced string.
    You may swap the brackets at any two indices any number of times. Return
    the minimum number of swaps to make s balanced.

    Example 1:
    Input: s = "][]["
    Output: 1
    Explanation: You can make the string balanced by swapping index 0 with
                 index 3. The resulting string is "[[]]".

    Example 2:
    Input: s = "]]][[["
    Output: 2
    Explanation: You can do the following to make the string balanced:
                 - Swap index 0 with index 4. s = "[]][[]".
                 - Swap index 1 with index 5. s = "[[][]]".
                 The resulting string is "[[][]]".

    Example 3:
    Input: s = "[]"
    Output: 0
    Explanation: The string is already balanced.

    Constraints:
    * n == s.length
    * 2 <= n <= 10^6
    * n is even.
    * s[i] is either '[' or ']'.
    * The number of opening brackets '[' equals n / 2, and the number of
      closing brackets ']' equals n / 2.*/

    int minSwaps(string s) {
        int ans = 0, prefix = 0;
        for (auto& ch : s) {
            if (ch == '[') prefix += 1;
            else prefix -= 1;
            if (prefix == -1) {
                ++ans;
                prefix = 1;
            }
        }
        return ans;
    }


    /*1964. Find the Longest Valid Obstacle Course at Each Position (Hard)
    You want to build some obstacle courses. You are given a 0-indexed integer
    array obstacles of length n, where obstacles[i] describes the height of the
    ith obstacle. For every index i between 0 and n - 1 (inclusive), find the
    length of the longest obstacle course in obstacles such that:
    * You choose any number of obstacles between 0 and i inclusive.
    * You must include the ith obstacle in the course.
    * You must put the chosen obstacles in the same order as they appear in
      obstacles.
    * Every obstacle (except the first) is taller than or the same height as
      the obstacle immediately before it.
    Return an array ans of length n, where ans[i] is the length of the longest
    obstacle course for index i as described above.

    Example 1:
    Input: obstacles = [1,2,3,2]
    Output: [1,2,3,3]
    Explanation: The longest valid obstacle course at each position is:
                 - i = 0: [1], [1] has length 1.
                 - i = 1: [1,2], [1,2] has length 2.
                 - i = 2: [1,2,3], [1,2,3] has length 3.
                 - i = 3: [1,2,3,2], [1,2,2] has length 3.

    Example 2:
    Input: obstacles = [2,2,1]
    Output: [1,2,1]
    Explanation: The longest valid obstacle course at each position is:
                 - i = 0: [2], [2] has length 1.
                 - i = 1: [2,2], [2,2] has length 2.
                 - i = 2: [2,2,1], [1] has length 1.

    Example 3:
    Input: obstacles = [3,1,5,6,4,2]
    Output: [1,1,2,3,2,2]
    Explanation: The longest valid obstacle course at each position is:
                 - i = 0: [3], [3] has length 1.
                 - i = 1: [3,1], [1] has length 1.
                 - i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.
                 - i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.
                 - i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.
                 - i = 5: [3,1,5,6,4,2], [1,2] has length 2.

    Constraints:
    * n == obstacles.length
    * 1 <= n <= 10^5
    * 1 <= obstacles[i] <= 10^7*/

    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
        vector<int> vals, ans;
        for (auto& x : obstacles) {
            auto it = upper_bound(vals.begin(), vals.end(), x);
            ans.push_back(it-vals.begin()+1);
            if (it == vals.end()) vals.push_back(x);
            else *it = x;
        }
        return ans;
    }


    /*1966. Binary Searchable Numbers in an Unsorted Array (Medium)
    Consider a function that implements an algorithm similar to Binary Search.
    The function has two input parameters: sequence is a sequence of integers,
    and target is an integer value. The purpose of the function is to find if
    the target exists in the sequence. The pseudocode of the function is as
    follows:

    func(sequence, target)
      while sequence is not empty
        randomly choose an element from sequence as the pivot
        if pivot = target, return true
        else if pivot < target, remove pivot and all elements to its left from the sequence
        else, remove pivot and all elements to its right from the sequence
      end while
      return false

    When the sequence is sorted, the function works correctly for all values.
    When the sequence is not sorted, the function does not work for all values,
    but may still work for some values. Given an integer array nums,
    representing the sequence, that contains unique numbers and may or may not
    be sorted, return the number of values that are guaranteed to be found
    using the function, for every possible pivot selection.

    Example 1:
    Input: nums = [7]
    Output: 1
    Explanation: Searching for value 7 is guaranteed to be found. Since the
                 sequence has only one element, 7 will be chosen as the pivot.
                 Because the pivot equals the target, the function will return
                 true.

    Example 2:
    Input: nums = [-1,5,2]
    Output: 1
    Explanation: Searching for value -1 is guaranteed to be found. If -1 was
                 chosen as the pivot, the function would return true. If 5 was
                 chosen as the pivot, 5 and 2 would be removed. In the next
                 loop, the sequence would have only -1 and the function would
                 return true. If 2 was chosen as the pivot, 2 would be removed.
                 In the next loop, the sequence would have -1 and 5. No matter
                 which number was chosen as the next pivot, the function would
                 find -1 and return true. Searching for value 5 is NOT
                 guaranteed to be found. If 2 was chosen as the pivot, -1, 5
                 and 2 would be removed. The sequence would be empty and the
                 function would return false. Searching for value 2 is NOT
                 guaranteed to be found. If 5 was chosen as the pivot, 5 and 2
                 would be removed. In the next loop, the sequence would have
                 only -1 and the function would return false. Because only -1
                 is guaranteed to be found, you should return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^5 <= nums[i] <= 10^5
    * All the values of nums are unique.

    Follow-up: If nums has duplicates, would you modify your algorithm? If so,
               how?*/

    int binarySearchableNumbers(vector<int>& nums) {
        vector<int> suffix = {INT_MAX};
        for (int i = nums.size()-1; i >= 0; --i)
            suffix.push_back(min(suffix.back(), nums[i]));
        reverse(suffix.begin(), suffix.end());

        int prefix = INT_MIN, ans = 0;
        for (int i = 0; i < nums.size(); ++i) {
            prefix = max(prefix, nums[i]);
            if (prefix == nums[i] && nums[i] == suffix[i]) ++ans;
        }
        return ans;
    }


    /*1967. Number of Strings That Appear as Substrings in Word (Easy)
    Given an array of strings patterns and a string word, return the number of
    strings in patterns that exist as a substring in word. A substring is a
    contiguous sequence of characters within a string.

    Example 1:
    Input: patterns = ["a","abc","bc","d"], word = "abc"
    Output: 3
    Explanation: - "a" appears as a substring in "abc".
                 - "abc" appears as a substring in "abc".
                 - "bc" appears as a substring in "abc".
                 - "d" does not appear as a substring in "abc".
                 3 of the strings in patterns appear as a substring in word.

    Example 2:
    Input: patterns = ["a","b","c"], word = "aaaaabbbbb"
    Output: 2
    Explanation: - "a" appears as a substring in "aaaaabbbbb".
                 - "b" appears as a substring in "aaaaabbbbb".
                 - "c" does not appear as a substring in "aaaaabbbbb".
                 2 of the strings in patterns appear as a substring in word.

    Example 3:
    Input: patterns = ["a","a","a"], word = "ab"
    Output: 3
    Explanation: Each of the patterns appears as a substring in word "ab".

    Constraints:
    * 1 <= patterns.length <= 100
    * 1 <= patterns[i].length <= 100
    * 1 <= word.length <= 100
    * patterns[i] and word consist of lowercase English letters.*/

    int numOfStrings(vector<string>& patterns, string word) {
        int ans = 0;
        for (auto& x : patterns)
            if (word.find(x) != string::npos) ++ans;
        return ans;
    }


    /*1968. Array With Elements Not Equal to Average of Neighbors (Medium)
    You are given a 0-indexed array nums of distinct integers. You want to
    rearrange the elements in the array such that every element in the
    rearranged array is not equal to the average of its neighbors. More
    formally, the rearranged array should have the property such that for every
    i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not
    equal to nums[i]. Return any rearrangement of nums that meets the
    requirements.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: [1,2,4,5,3]
    Explanation:
    When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.
    When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.
    When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.

    Example 2:
    Input: nums = [6,2,0,9,7]
    Output: [9,7,6,2,0]
    Explanation:
    When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.
    When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.
    When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5*/

    vector<int> rearrangeArray(vector<int>& nums) {
        for (int i = 1; i < nums.size()-1; ++i)
            if ((nums[i-1] < nums[i] && nums[i] < nums[i+1]) || (nums[i-1] > nums[i] && nums[i] > nums[i+1]))
                swap(nums[i], nums[i+1]);
        return nums;
    }


    /*1969. Minimum Non-Zero Product of the Array Elements (Medium)
    You are given a positive integer p. Consider an array nums (1-indexed) that
    consists of the integers in the inclusive range [1, 2p - 1] in their binary
    representations. You are allowed to do the following operation any number
    of times:
    * Choose two elements x and y from nums.
    * Choose a bit in x and swap it with its corresponding bit in y.
      Corresponding bit refers to the bit that is in the same position in the
      other integer.
    For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the
    right, we have x = 1111 and y = 0001. Find the minimum non-zero product of
    nums after performing the above operation any number of times. Return this
    product modulo 10^9 + 7. Note: The answer should be the minimum product
    before the modulo operation is done.

    Example 1:
    Input: p = 1
    Output: 1
    Explanation: nums = [1]. There is only one element, so the product equals
                 that element.

    Example 2:
    Input: p = 2
    Output: 6
    Explanation: nums = [01, 10, 11]. Any swap would either make the product 0
                 or stay the same. Thus, the array product of 1 * 2 * 3 = 6 is
                 already minimized.

    Example 3:
    Input: p = 3
    Output: 1512
    Explanation: nums = [001, 010, 011, 100, 101, 110, 111]
                 - In the first operation we can swap the leftmost bit of the second and fifth elements.
                     - The resulting array is [001, 110, 011, 100, 001, 110, 111].
                 - In the second operation we can swap the middle bit of the third and fourth elements.
                     - The resulting array is [001, 110, 001, 110, 001, 110, 111].
                 The array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512, which is the minimum possible product.

    Constraints: 1 <= p <= 60*/

    int minNonZeroProduct(int p) {
        const int MOD = 1'000'000'007;
        long x =  (1l << p) - 1;

        auto power = [](long n, long k, int m) {
            long ans = 1;
            while (k) {
                if (k & 1) {
                    ans = (ans * n) % MOD;
                    k--;
                } else {
                    n = (n * n) % MOD;
                    k /= 2;
                }
            }
            return ans;
        };

        return power((x-1) % MOD, (x-1)/2, MOD) * (x % MOD) % MOD;
    }


    /*1970. Last Day Where You Can Still Cross (Hard)
    There is a 1-based binary matrix where 0 represents land and 1 represents
    water. You are given integers row and col representing the number of rows
    and columns in the matrix, respectively. Initially on day 0, the entire
    matrix is land. However, each day a new cell becomes flooded with water.
    You are given a 1-based 2D array cells, where cells[i] = [ri, ci]
    represents that on the ith day, the cell on the rith row and cith column
    (1-based coordinates) will be covered with water (i.e., changed to 1).You
    want to find the last day that it is possible to walk from the top to the
    bottom by only walking on land cells. You can start from any cell in the
    top row and end at any cell in the bottom row. You can only travel in the
    four cardinal directions (left, right, up, and down). Return the last day
    where it is possible to walk from the top to the bottom by only walking on
    land cells.

    Example 1:
    Input: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
    Output: 2
    Explanation: The above image depicts how the matrix changes each day
                 starting from day 0. The last day where it is possible to
                 cross from top to bottom is on day 2.

    Example 2:
    Input: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
    Output: 1
    Explanation: The above image depicts how the matrix changes each day
                 starting from day 0. The last day where it is possible to
                 cross from top to bottom is on day 1.

    Example 3:
    Input: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
    Output: 3
    Explanation: The above image depicts how the matrix changes each day
                 starting from day 0. The last day where it is possible to
                 cross from top to bottom is on day 3.

    Constraints:
    * 2 <= row, col <= 2 * 10^4
    * 4 <= row * col <= 2 * 10^4
    * cells.length == row * col
    * 1 <= ri <= row
    * 1 <= ci <= col
    * All the values of cells are unique.*/

    int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
        int n = row * col;
        vector<vector<int>> grid(row, vector<int>(col, 0)), span(n, {n, 0});
        UnionFind* uf = new UnionFind(n);

        for (int step = 0; step < cells.size(); ++step) {
            int i = cells[step][0]-1, j = cells[step][1]-1, x = i*col + j;
            grid[i][j] = 1;
            for (auto&& di : {-1, 0, 1})
                for (auto&& dj : {-1, 0, 1})
                    if (di || dj) {
                        int ii = i + di, jj = j + dj;
                        if (0 <= ii && ii < row && 0 <= jj && jj < col && grid[ii][jj]) {
                            int xx = ii*col+jj, r = uf->find(x), rr = uf->find(xx);
                            span[r][0] = span[rr][0] = min(span[r][0], min(span[rr][0], min(j, jj)));
                            span[r][1] = span[rr][1] = max(span[r][1], max(span[rr][1], max(j, jj)));
                            if (span[r][0] == 0 && span[r][1] == col - 1) {
                                delete uf;
                                return step;
                            }
                            uf->connect(x, xx);
                        }
                    }
        }
        delete uf;
        return -1;
    }


    /*1971. Find if Path Exists in Graph (Easy)
    There is a bi-directional graph with n vertices, where each vertex is
    labeled from 0 to n - 1 (inclusive). The edges in the graph are represented
    as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a
    bi-directional edge between vertex ui and vertex vi. Every vertex pair is
    connected by at most one edge, and no vertex has an edge to itself. You
    want to determine if there is a valid path that exists from vertex start to
    vertex end. Given edges and the integers n, start, and end, return true if
    there is a valid path from start to end, or false otherwise.

    Example 1:
    Input: n = 3, edges = [[0,1],[1,2],[2,0]], start = 0, end = 2
    Output: true
    Explanation: There are two paths from vertex 0 to vertex 2:
                 - 0 → 1 → 2
                 - 0 → 2

    Example 2:
    Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], start = 0, end = 5
    Output: false
    Explanation: There is no path from vertex 0 to vertex 5.

    Constraints:
    * 1 <= n <= 2 * 10^5
    * 0 <= edges.length <= 2 * 10^5
    * edges[i].length == 2
    * 1 <= ui, vi <= n - 1
    * ui != vi
    * 1 <= start, end <= n - 1
    * There are no duplicate edges.
    * There are no self edges.*/

    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        vector<vector<int>> graph(n);
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            graph[u].push_back(v);
            graph[v].push_back(u);
        }
        vector<bool> seen(n, false);
        seen[source] = true;
        stack<int> stk; stk.push(source);
        while (stk.size()) {
            int u = stk.top(); stk.pop();
            if (u == destination) return true;
            for (auto& v : graph[u])
                if (!seen[v]) {
                    seen[v] = true;
                    stk.push(v);
                }
        }
        return false;
    }


    /*1973. Count Nodes Equal to Sum of Descendants (Medium)
    Given the root of a binary tree, return the number of nodes where the value
    of the node is equal to the sum of the values of its descendants. A
    descendant of a node x is any node that is on the path from node x to some
    leaf node. The sum is considered to be 0 if the node has no descendants.

    Example 1:
    Input: root = [10,3,4,2,1]
    Output: 2
    Explanation: For the node with value 10: The sum of its descendants is
                 3+4+2+1 = 10. For the node with value 3: The sum of its
                 descendants is 2+1 = 3.

    Example 2:
    Input: root = [2,3,null,2,null]
    Output: 0
    Explanation: No node has a value that is equal to the sum of its descendants.

    Example 3:
    Input: root = [0]
    Output: 1
    Explanation: For the node with value 0: The sum of its descendants is 0
                 since it has no descendants.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 0 <= Node.val <= 10^5*/

    int equalToDescendants(TreeNode* root) {
        int ans = 0;

        function<long(TreeNode*)> fn = [&](TreeNode* node) {
            if (!node) return 0l;
            long sm = fn(node->left) + fn(node->right);
            if (sm == node->val) ++ans;
            return sm + node->val;
        };

        fn(root);
        return ans;
    }


    /*1974. Minimum Time to Type Word Using Special Typewriter (Easy)
    There is a special typewriter with lowercase English letters 'a' to 'z'
    arranged in a circle with a pointer. A character can only be typed if the
    pointer is pointing to that character. The pointer is initially pointing to
    the character 'a'. Each second, you may perform one of the following
    operations:
    * Move the pointer one character counterclockwise or clockwise.
    * Type the character the pointer is currently on.
    Given a string word, return the minimum number of seconds to type out the
    characters in word.

    Example 1:
    Input: word = "abc"
    Output: 5
    Explanation: The characters are printed as follows:
                 - Type the character 'a' in 1 second since the pointer is
                   initially on 'a'.
                 - Move the pointer clockwise to 'b' in 1 second.
                 - Type the character 'b' in 1 second.
                 - Move the pointer clockwise to 'c' in 1 second.
                 - Type the character 'c' in 1 second.

    Example 2:
    Input: word = "bza"
    Output: 7
    Explanation: The characters are printed as follows:
                 - Move the pointer clockwise to 'b' in 1 second.
                 - Type the character 'b' in 1 second.
                 - Move the pointer counterclockwise to 'z' in 2 seconds.
                 - Type the character 'z' in 1 second.
                 - Move the pointer clockwise to 'a' in 1 second.
                 - Type the character 'a' in 1 second.

    Example 3:
    Input: word = "zjpc"
    Output: 34
    Explanation: The characters are printed as follows:
                 - Move the pointer counterclockwise to 'z' in 1 second.
                 - Type the character 'z' in 1 second.
                 - Move the pointer clockwise to 'j' in 10 seconds.
                 - Type the character 'j' in 1 second.
                 - Move the pointer clockwise to 'p' in 6 seconds.
                 - Type the character 'p' in 1 second.
                 - Move the pointer counterclockwise to 'c' in 13 seconds.
                 - Type the character 'c' in 1 second.

    Constraints:
    * 1 <= word.length <= 100
    * word consists of lowercase English letters.*/

    int minTimeToType(string word) {
        int ans = word.size();
        char prev = 'a';
        for (auto& ch : word) {
            int val = abs(ch - prev);
            ans += min(val, 26 - val);
            prev = ch;
        }
        return ans;
    }


    /*1975. Maximum Matrix Sum (Medium)
    You are given an n x n integer matrix. You can do the following operation
    any number of times:
    * Choose any two adjacent elements of matrix and multiply each of them by
      -1.
    Two elements are considered adjacent if and only if they share a border.
    Your goal is to maximize the summation of the matrix's elements. Return the
    maximum sum of the matrix's elements using the operation mentioned above.

    Example 1:
    Input: matrix = [[1,-1],[-1,1]]
    Output: 4
    Explanation: We can follow the following steps to reach sum equals 4:
                 - Multiply the 2 elements in the first row by -1.
                 - Multiply the 2 elements in the first column by -1.

    Example 2:
    Input: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
    Output: 16
    Explanation: We can follow the following step to reach sum equals 16:
                 - Multiply the 2 last elements in the second row by -1.

    Constraints:
    * n == matrix.length == matrix[i].length
    * 2 <= n <= 250
    * -10^5 <= matrix[i][j] <= 10^5*/

    long long maxMatrixSum(vector<vector<int>>& matrix) {
        long long ans = 0;
        int mult = 0, small = INT_MAX;
        for (auto& row : matrix) {
            for (auto& x : row) {
                ans += abs(x);
                small = min(small, abs(x));
                if (x < 0) mult ^= 1;
            }
        }
        return ans - 2*mult*small;
    }


    /*1976. Number of Ways to Arrive at Destination (Medium)
    You are in a city that consists of n intersections numbered from 0 to n - 1
    with bi-directional roads between some intersections. The inputs are
    generated such that you can reach any intersection from any other
    intersection and that there is at most one road between any two
    intersections. You are given an integer n and a 2D integer array roads
    where roads[i] = [ui, vi, timei] means that there is a road between
    intersections ui and vi that takes timei minutes to travel. You want to
    know in how many ways you can travel from intersection 0 to intersection
    n - 1 in the shortest amount of time. Return the number of ways you can
    arrive at your destination in the shortest amount of time. Since the answer
    may be large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
    Output: 4
    Explanation: The shortest amount of time it takes to go from intersection 0
                 to intersection 6 is 7 minutes. The four ways to get there in
                 7 minutes are:
                 - 0 ➝ 6
                 - 0 ➝ 4 ➝ 6
                 - 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
                 - 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6

    Example 2:
    Input: n = 2, roads = [[1,0,10]]
    Output: 1
    Explanation: There is only one way to go from intersection 0 to
                 intersection 1, and it takes 10 minutes.

    Constraints:
    * 1 <= n <= 200
    * n - 1 <= roads.length <= n * (n - 1) / 2
    * roads[i].length == 3
    * 0 <= ui, vi <= n - 1
    * 1 <= timei <= 10^9
    * ui != vi
    * There is at most one road connecting any two intersections.
    * You can reach any intersection from any other intersection.*/

    int countPaths(int n, vector<vector<int>>& roads) {
        vector<vector<pair<int, int>>> graph(n);
        for (auto& elem : roads) {
            graph[elem[0]].emplace_back(elem[1], elem[2]);
            graph[elem[1]].emplace_back(elem[0], elem[2]);
        }

        vector<long> dist(n, LONG_MAX), ways(n, 0);
        dist[0] = 0;
        ways[0] = 1;

        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<>> pq; // min-heap
        pq.emplace(0, 0);
        while (pq.size()) {
            auto [d, u] = pq.top(); pq.pop();
            if (d > dist.back()) break;
            if (d == dist[u])
                for (auto& [v, time] : graph[u]) {
                    if (dist[u] + time < dist[v]) {
                        dist[v] = dist[u] + time;
                        ways[v] = ways[u];
                        pq.emplace(dist[v], v);
                    } else if (dist[u] + time == dist[v])
                        ways[v] = (ways[v] + ways[u]) % 1'000'000'007;
                }
        }

        return ways.back();
    }


    /*1977. Number of Ways to Separate Numbers (Hard)
    You wrote down many positive integers in a string called num. However, you
    realized that you forgot to add commas to seperate the different numbers.
    You remember that the list of integers was non-decreasing and that no
    integer had leading zeros. Return the number of possible lists of integers
    that you could have written down to get the string num. Since the answer
    may be large, return it modulo 10^9 + 7.

    Example 1:
    Input: num = "327"
    Output: 2
    Explanation: You could have written down the numbers:
                 3, 27
                 327

    Example 2:
    Input: num = "094"
    Output: 0
    Explanation: No numbers can have leading zeros and all numbers must be
                 positive.

    Example 3:
    Input: num = "0"
    Output: 0
    Explanation: No numbers can have leading zeros and all numbers must be
                 positive.

    Example 4:
    Input: num = "9999999999999"
    Output: 101

    Constraints:
    * 1 <= num.length <= 3500
    * num consists of digits '0' through '9'.*/

    int numberOfCombinations(string num) {
        const int MOD = 1'000'000'007;
        int n = num.size();
        vector<vector<int>> lcs(n, vector<int>(n+1));
        for (int i = n-1; i >= 0; --i) {
            for (int j = n-1; j > i; --j) {
                if (num[i] == num[j]) lcs[i][j] = 1 + lcs[i+1][j+1];
            }
        }

        vector<vector<long>> memo(n, vector<long>(n+1, -1));

        function<long(int, int)> fn = [&](int lo, int hi) {
            if (lo >= hi) return 0l;
            if (num[lo] == '0') return 0l;
            if (lo == 0) return 1l;
            if (memo[lo][hi] == -1) {
                long ans = fn(lo, hi-1);
                if (0 <= 2*lo - hi) {
                    int m = lcs[2*lo-hi][lo];
                    if (m >= hi - lo || num[2*lo-hi+m] <= num[lo+m])
                        ans = (ans + fn(2*lo-hi, lo)) % MOD;
                }
                if (0 <= 2*lo - hi + 1) {
                    int m = lcs[2*lo-hi+1][lo];
                    if (m < hi - lo - 1 && num[2*lo-hi+1+m] > num[lo+m])
                        ans = (ans + fn(2*lo-hi+1, lo)) % MOD;
                }
                memo[lo][hi] = ans;
            }
            return memo[lo][hi];
        };

        long ans = 0;
        for (int i = 0; i < n; ++i)
            ans = (ans + fn(i, n)) % MOD;
        return ans;

    }


    /*1979. Find Greatest Common Divisor of Array (Easy)
    Given an integer array nums, return the greatest common divisor of the
    smallest number and largest number in nums. The greatest common divisor of
    two numbers is the largest positive integer that evenly divides both
    numbers.

    Example 1:
    Input: nums = [2,5,6,9,10]
    Output: 2
    Explanation: The smallest number in nums is 2. The largest number in nums
                 is 10. The greatest common divisor of 2 and 10 is 2.

    Example 2:
    Input: nums = [7,5,6,8,3]
    Output: 1
    Explanation: The smallest number in nums is 3. The largest number in nums
                 is 8. The greatest common divisor of 3 and 8 is 1.

    Example 3:
    Input: nums = [3,3]
    Output: 3
    Explanation: The smallest number in nums is 3. The largest number in nums
                 is 3. The greatest common divisor of 3 and 3 is 3.

    Constraints:
    * 2 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000*/

    int findGCD(vector<int>& nums) {
        return gcd(*max_element(nums.begin(), nums.end()), *min_element(nums.begin(), nums.end()));
    }


    /*1980. Find Unique Binary String (Medium)
    Given an array of strings nums containing n unique binary strings each of
    length n, return a binary string of length n that does not appear in nums.
    If there are multiple answers, you may return any of them.

    Example 1:
    Input: nums = ["01","10"]
    Output: "11"
    Explanation: "11" does not appear in nums. "00" would also be correct.

    Example 2:
    Input: nums = ["00","01"]
    Output: "11"
    Explanation: "11" does not appear in nums. "10" would also be correct.

    Example 3:
    Input: nums = ["111","011","001"]
    Output: "101"
    Explanation: "101" does not appear in nums. "000", "010", "100", and "110"
                 would also be correct.

    Constraints:
    * n == nums.length
    * 1 <= n <= 16
    * nums[i].length == n
    * nums[i] is either '0' or '1'.
    * All the strings of nums are unique.*/

    string findDifferentBinaryString(vector<string>& nums) {
        string ans;
        for (int i = 0; i < nums.size(); ++i)
            ans += nums[i][i] == '0' ? "1" : "0";
        return ans;
    }


    /*1981. Minimize the Difference Between Target and Chosen Elements (Medium)
    You are given an m x n integer matrix mat and an integer target. Choose one
    integer from each row in the matrix such that the absolute difference
    between target and the sum of the chosen elements is minimized. Return the
    minimum absolute difference. The absolute difference between two numbers a
    and b is the absolute value of a - b.

    Example 1:
    Input: mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13
    Output: 0
    Explanation: One possible choice is to:
                 - Choose 1 from the first row.
                 - Choose 5 from the second row.
                 - Choose 7 from the third row.
                 The sum of the chosen elements is 13, which equals the target,
                 so the absolute difference is 0.

    Example 2:
    Input: mat = [[1],[2],[3]], target = 100
    Output: 94
    Explanation: The best possible choice is to:
                 - Choose 1 from the first row.
                 - Choose 2 from the second row.
                 - Choose 3 from the third row.
                 The sum of the chosen elements is 6, and the absolute
                 difference is 94.

    Example 3:
    Input: mat = [[1,2,9,8,7]], target = 6
    Output: 1
    Explanation: The best choice is to choose 7 from the first row. The
                 absolute difference is 1.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 70
    * 1 <= mat[i][j] <= 70
    * 1 <= target <= 800*/

    int minimizeTheDifference(vector<vector<int>>& mat, int target) {
        bitset<5000> bits(1);
        for (auto& row : mat) {
            bitset<5000> temp;
            for (auto& x : row) temp |= (bits << x);
            bits = temp;
        }

        for (int x = 0; ; ++x)
            if (bits[target+x] || (x <= target && bits[target-x])) return x;
        return -1;
    }


    /*1982. Find Array Given Subset Sums (Hard)
    You are given an integer n representing the length of an unknown array that
    you are trying to recover. You are also given an array sums containing the
    values of all 2n subset sums of the unknown array (in no particular order).
    Return the array ans of length n representing the unknown array. If
    multiple answers exist, return any of them. An array sub is a subset of an
    array arr if sub can be obtained from arr by deleting some (possibly zero
    or all) elements of arr. The sum of the elements in sub is one possible
    subset sum of arr. The sum of an empty array is considered to be 0. Note
    that test cases are generated such that there will always be at least one
    correct answer.

    Example 1:
    Input: n = 3, sums = [-3,-2,-1,0,0,1,2,3]
    Output: [1,2,-3]
    Explanation: [1,2,-3] is able to achieve the given subset sums:
                 - []: sum is 0
                 - [1]: sum is 1
                 - [2]: sum is 2
                 - [1,2]: sum is 3
                 - [-3]: sum is -3
                 - [1,-3]: sum is -2
                 - [2,-3]: sum is -1
                 - [1,2,-3]: sum is 0
                 Note that any permutation of [1,2,-3] and also any permutation
                 of [-1,-2,3] will also be accepted.

    Example 2:
    Input: n = 2, sums = [0,0,0,0]
    Output: [0,0]
    Explanation: The only correct answer is [0,0].

    Example 3:
    Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]
    Output: [0,-1,4,5]
    Explanation: [0,-1,4,5] is able to achieve the given subset sums.

    Constraints:
    * 1 <= n <= 15
    * sums.length == 2n
    * -10^4 <= sums[i] <= 10^4*/

    vector<int> recoverArray(int n, vector<int>& sums) {
        sort(sums.begin(), sums.end());

        vector<int> ans;
        while (n--) {
            int diff = sums[1] - sums[0];
            unordered_map<int, int> freq;
            vector<int> ss0, ss1;
            bool on = false;
            for (auto& x : sums)
                if (!freq[x]) {
                    ss0.push_back(x);
                    freq[x+diff]++;
                    if (x == 0) on = true;
                } else {
                    ss1.push_back(x);
                    freq[x]--;
                }
            if (on) {
                ans.push_back(diff);
                sums = ss0;
            } else {
                ans.push_back(-diff);
                sums = ss1;
            }
        }
        return ans;
    }


    /*1983. Widest Pair of Indices With Equal Range Sum (Medium)
    You are given two 0-indexed binary arrays nums1 and nums2. Find the widest
    pair of indices (i, j) such that i <= j and
    nums1[i] + nums1[i+1] + ... + nums1[j] == nums2[i] + nums2[i+1] + ... + nums2[j].
    The widest pair of indices is the pair with the largest distance between i
    and j. The distance between a pair of indices is defined as j - i + 1.
    Return the distance of the widest pair of indices. If no pair of indices
    meets the conditions, return 0.

    Example 1:
    Input: nums1 = [1,1,0,1], nums2 = [0,1,1,0]
    Output: 3
    Explanation: If i = 1 and j = 3:
                 nums1[1] + nums1[2] + nums1[3] = 1 + 0 + 1 = 2.
                 nums2[1] + nums2[2] + nums2[3] = 1 + 1 + 0 = 2.
                 The distance between i and j is j - i + 1 = 3 - 1 + 1 = 3.

    Example 2:
    Input: nums1 = [0,1], nums2 = [1,1]
    Output: 1
    Explanation: If i = 1 and j = 1:
                 nums1[1] = 1.
                 nums2[1] = 1.
                 The distance between i and j is j - i + 1 = 1 - 1 + 1 = 1.

    Example 3:
    Input: nums1 = [0], nums2 = [1]
    Output: 0
    Explanation: There are no pairs of indices that meet the requirements.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * nums1[i] is either 0 or 1.
    * nums2[i] is either 0 or 1.*/

    int widestPairOfIndices(vector<int>& nums1, vector<int>& nums2) {
        int ans = 0, prefix = 0;
        unordered_map<int, int> seen = {{0, -1}};
        for (int i = 0; i < nums1.size(); ++i) {
            prefix += nums1[i] - nums2[i];
            if (seen.count(prefix)) ans = max(ans, i - seen[prefix]);
            else seen[prefix] = i;
        }
        return ans;
    }


    /*1984. Minimum Difference Between Highest and Lowest of K Scores (Easy)
    You are given a 0-indexed integer array nums, where nums[i] represents the
    score of the ith student. You are also given an integer k. Pick the scores
    of any k students from the array so that the difference between the highest
    and the lowest of the k scores is minimized. Return the minimum possible
    difference.

    Example 1:
    Input: nums = [90], k = 1
    Output: 0
    Explanation: There is one way to pick score(s) of one student:
                 - [90]. The difference between the highest and lowest score is 90 - 90 = 0.
                 The minimum possible difference is 0.

    Example 2:
    Input: nums = [9,4,1,7], k = 2
    Output: 2
    Explanation: There are six ways to pick score(s) of two students:
                 - [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.
                 - [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.
                 - [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.
                 - [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.
                 - [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.
                 - [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.
                 The minimum possible difference is 2.

    Constraints:
    * 1 <= k <= nums.length <= 1000
    * 0 <= nums[i] <= 10^5*/

    int minimumDifference(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int ans = INT_MAX;
        for (int i = k-1; i < nums.size(); ++i)
            ans = min(ans, nums[i] - nums[i-k+1]);
        return ans;
    }


    /*1985. Find the Kth Largest Integer in the Array (Medium)
    You are given an array of strings nums and an integer k. Each string in
    nums represents an integer without leading zeros. Return the string that
    represents the kth largest integer in nums. Note: Duplicate numbers should
    be counted distinctly. For example, if nums is ["1","2","2"], "2" is the
    first largest integer, "2" is the second-largest integer, and "1" is the
    third-largest integer.

    Example 1:
    Input: nums = ["3","6","7","10"], k = 4
    Output: "3"
    Explanation: The numbers in nums sorted in non-decreasing order are
                 ["3","6","7","10"]. The 4th largest integer in nums is "3".

    Example 2:
    Input: nums = ["2","21","12","1"], k = 3
    Output: "2"
    Explanation: The numbers in nums sorted in non-decreasing order are
                 ["1","2","12","21"]. The 3rd largest integer in nums is "2".

    Example 3:
    Input: nums = ["0","0"], k = 2
    Output: "0"
    Explanation: The numbers in nums sorted in non-decreasing order are
                 ["0","0"]. The 2nd largest integer in nums is "0".

    Constraints:
    * 1 <= k <= nums.length <= 10^4
    * 1 <= nums[i].length <= 100
    * nums[i] consists of only digits.
    * nums[i] will not have any leading zeros.*/

    string kthLargestNumber(vector<string>& nums, int k) {
        nth_element(nums.begin(), nums.end()-k, nums.end(), [](auto& lhs, auto& rhs) {
            return lhs.size() < rhs.size() || (lhs.size() == rhs.size() && lhs < rhs);
        });
        return *(nums.end()-k);
    }


    /*1986. Minimum Number of Work Sessions to Finish the Tasks (Medium)
    There are n tasks assigned to you. The task times are represented as an
    integer array tasks of length n, where the ith task takes tasks[i] hours to
    finish. A work session is when you work for at most sessionTime consecutive
    hours and then take a break. You should finish the given tasks in a way
    that satisfies the following conditions:
    * If you start a task in a work session, you must complete it in the same
      work session.
    * You can start a new task immediately after finishing the previous one.
    * You may complete the tasks in any order.
    Given tasks and sessionTime, return the minimum number of work sessions
    needed to finish all the tasks following the conditions above. The tests
    are generated such that sessionTime is greater than or equal to the maximum
    element in tasks[i].

    Example 1:
    Input: tasks = [1,2,3], sessionTime = 3
    Output: 2
    Explanation: You can finish the tasks in two work sessions.
                 - First work session: finish the first and the second tasks in
                   1 + 2 = 3 hours.
                 - Second work session: finish the third task in 3 hours.

    Example 2:
    Input: tasks = [3,1,3,1,1], sessionTime = 8
    Output: 2
    Explanation: You can finish the tasks in two work sessions.
                 - First work session: finish all the tasks except the last one
                   in 3 + 1 + 3 + 1 = 8 hours.
                 - Second work session: finish the last task in 1 hour.

    Example 3:
    Input: tasks = [1,2,3,4,5], sessionTime = 15
    Output: 1
    Explanation: You can finish all the tasks in one work session.

    Constraints:
    * n == tasks.length
    * 1 <= n <= 14
    * 1 <= tasks[i] <= 10
    * max(tasks[i]) <= sessionTime <= 15*/

    int minSessions(vector<int>& tasks, int sessionTime) {
        int n = tasks.size();
        vector<vector<int>> dp(1<<n, vector<int>(sessionTime, 15));

        for (int mask = 0; mask < (1 << n); ++mask)
            for (int t = 0; t < sessionTime; ++t)
                if (mask == 0) dp[mask][t] = 0;
                else
                    for (int i = 0; i < n; ++i)
                        if (mask & (1<<i))
                            if (tasks[i] <= t)
                                dp[mask][t] = min(dp[mask][t], dp[mask^(1<<i)][t-tasks[i]]);
                            else
                                dp[mask][t] = min(dp[mask][t], 1 + dp[mask^(1<<i)][sessionTime-tasks[i]]);
        return dp[(1<<n)-1][0];
    }


    /*1987. Number of Unique Good Subsequences (Hard)
    You are given a binary string binary. A subsequence of binary is considered
    good if it is not empty and has no leading zeros (with the exception of "0").
    Find the number of unique good subsequences of binary. For example, if
    binary = "001", then all the good subsequences are ["0", "0", "1"], so the
    unique good subsequences are "0" and "1". Note that subsequences "00", "01",
    and "001" are not good because they have leading zeros. Return the number
    of unique good subsequences of binary. Since the answer may be very large,
    return it modulo 10^9 + 7. A subsequence is a sequence that can be derived
    from another sequence by deleting some or no elements without changing the
    order of the remaining elements.

    Example 1:
    Input: binary = "001"
    Output: 2
    Explanation: The good subsequences of binary are ["0", "0", "1"]. The
                 unique good subsequences are "0" and "1".

    Example 2:
    Input: binary = "11"
    Output: 2
    Explanation: The good subsequences of binary are ["1", "1", "11"]. The
                 unique good subsequences are "1" and "11".

    Example 3:
    Input: binary = "101"
    Output: 5
    Explanation: The good subsequences of binary are ["1", "0", "1", "10", "11",
                 "101"]. The unique good subsequences are "0", "1", "10", "11",
                 and "101".

    Constraints:
    * 1 <= binary.length <= 10^5
    * binary consists of only '0's and '1's.*/

    int numberOfUniqueGoodSubsequences(string binary) {
        const int MOD = 1'000'000'007;
        long f0 = 0, f1 = 0;
        for (auto& ch : binary) {
            if (ch == '0') f0 = (f0 + f1) % MOD;
            else f1 = (f0 + f1 + 1) % MOD;
        }
        return (f0 + f1 + (f0 || binary[0] == '0')) % MOD;
    }


    /*1989. Maximum Number of People That Can Be Caught in Tag (Medium)
    You are playing a game of tag with your friends. In tag, people are divided
    into two teams: people who are "it", and people who are not "it". The
    people who are "it" want to catch as many people as possible who are not
    "it". You are given a 0-indexed integer array team containing only zeros
    (denoting people who are not "it") and ones (denoting people who are "it"),
    and an integer dist. A person who is "it" at index i can catch any one
    person whose index is in the range [i - dist, i + dist] (inclusive) and is
    not "it". Return the maximum number of people that the people who are "it"
    can catch.

    Example 1:
    Input: team = [0,1,0,1,0], dist = 3
    Output: 2
    Explanation: The person who is "it" at index 1 can catch people in the
                 range [i-dist, i+dist] = [1-3, 1+3] = [-2, 4]. They can catch
                 the person who is not "it" at index 2. The person who is "it"
                 at index 3 can catch people in the range [i-dist, i+dist] =
                 [3-3, 3+3] = [0, 6]. They can catch the person who is not "it"
                 at index 0. The person who is not "it" at index 4 will not be
                 caught because the people at indices 1 and 3 are already
                 catching one person.

    Example 2:
    Input: team = [1], dist = 1
    Output: 0
    Explanation: There are no people who are not "it" to catch.

    Example 3:
    Input: team = [0], dist = 1
    Output: 0
    Explanation: There are no people who are "it" to catch people.

    Constraints:
    * 1 <= team.length <= 10^5
    * 0 <= team[i] <= 1
    * 1 <= dist <= team.length*/

    int catchMaximumAmountofPeople(vector<int>& team, int dist) {
        int ans = 0;
        queue<int> q0, q1;
        for (int i = 0; i < team.size(); ++i) {
            if (q0.size() && q0.front() < i-dist) q0.pop();
            if (q1.size() && q1.front() < i-dist) q1.pop();
            if (team[i])
                if (q0.size()) {
                    ++ans;
                    q0.pop();
                } else q1.push(i);
            else
                if (q1.size()) {
                    ++ans;
                    q1.pop();
                } else q0.push(i);
        }
        return ans;
    }


    /*1991. Find the Middle Index in Array (Easy)
    Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e.,
    the smallest amongst all the possible ones). A middleIndex is an index
    where
    nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].
    If middleIndex == 0, the left side sum is considered to be 0. Similarly, if
    middleIndex == nums.length - 1, the right side sum is considered to be 0.
    Return the leftmost middleIndex that satisfies the condition, or -1 if
    there is no such index.

    Example 1:
    Input: nums = [2,3,-1,8,4]
    Output: 3
    Explanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4
                 The sum of the numbers after index 3 is: 4 = 4

    Example 2:
    Input: nums = [1,-1,4]
    Output: 2
    Explanation: The sum of the numbers before index 2 is: 1 + -1 = 0
                 The sum of the numbers after index 2 is: 0

    Example 3:
    Input: nums = [2,5]
    Output: -1
    Explanation: There is no valid middleIndex.

    Example 4:
    Input: nums = [1]
    Output: 0
    Explantion: The sum of the numbers before index 0 is: 0
                The sum of the numbers after index 0 is: 0

    Constraints:
    * 1 <= nums.length <= 100
    * -1000 <= nums[i] <= 1000*/

    int findMiddleIndex(vector<int>& nums) {
        int total = accumulate(nums.begin(), nums.end(), 0), prefix = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (2*prefix == total - nums[i]) return i;
            prefix += nums[i];
        }
        return -1;
    }


    /*1992. Find All Groups of Farmland (Medium)
    You are given a 0-indexed m x n binary matrix land where a 0 represents a
    hectare of forested land and a 1 represents a hectare of farmland. To keep
    the land organized, there are designated rectangular areas of hectares that
    consist entirely of farmland. These rectangular areas are called groups. No
    two groups are adjacent, meaning farmland in one group is not four-
    directionally adjacent to another farmland in a different group. land can
    be represented by a coordinate system where the top left corner of land is
    (0, 0) and the bottom right corner of land is (m-1, n-1). Find the
    coordinates of the top left and bottom right corner of each group of
    farmland. A group of farmland with a top left corner at (r1, c1) and a
    bottom right corner at (r2, c2) is represented by the 4-length array
    [r1, c1, r2, c2]. Return a 2D array containing the 4-length arrays
    described above for each group of farmland in land. If there are no groups
    of farmland, return an empty array. You may return the answer in any order.

    Example 1:
    Input: land = [[1,0,0],[0,1,1],[0,1,1]]
    Output: [[0,0,0,0],[1,1,2,2]]
    Explanation: The first group has a top left corner at land[0][0] and a
                 bottom right corner at land[0][0]. The second group has a top
                 left corner at land[1][1] and a bottom right corner at
                 land[2][2].

    Example 2:
    Input: land = [[1,1],[1,1]]
    Output: [[0,0,1,1]]
    Explanation: The first group has a top left corner at land[0][0] and a
                 bottom right corner at land[1][1].

    Example 3:
    Input: land = [[0]]
    Output: []
    Explanation: There are no groups of farmland.

    Constraints:
    * m == land.length
    * n == land[i].length
    * 1 <= m, n <= 300
    * land consists of only 0's and 1's.
    * Groups of farmland are rectangular in shape.*/

    vector<vector<int>> findFarmland(vector<vector<int>>& land) {
        int m = land.size(), n = land[0].size();
        vector<vector<int>> ans;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                if (land[i][j] == 1) {
                    int ii = i, jj = j;
                    for (; jj < n && land[i][jj]; ++jj);
                    for (; ii < m && land[ii][j]; ++ii) {
                        land[ii][j] = -jj;
                    }
                    ans.push_back({i, j, ii-1, jj-1});
                }
                if (land[i][j] < 0) j = -land[i][j];
            }
        return ans;
    }


    /*1994. The Number of Good Subsets (Hard)
    You are given an integer array nums. We call a subset of nums good if its
    product can be represented as a product of one or more distinct prime
    numbers.
    * For example, if nums = [1, 2, 3, 4]:
      + [2, 3], [1, 2, 3], and [1, 3] are good subsets with products 6 = 2*3,
        6 = 2*3, and 3 = 3 respectively.
      + [1, 4] and [4] are not good subsets with products 4 = 2*2 and 4 = 2*2
        respectively.
    Return the number of different good subsets in nums modulo 10^9 + 7. A
    subset of nums is any array that can be obtained by deleting some (possibly
    none or all) elements from nums. Two subsets are different if and only if
    the chosen indices to delete are different.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 6
    Explanation: The good subsets are:
                 - [1,2]: product is 2, which is the product of distinct prime 2.
                 - [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.
                 - [1,3]: product is 3, which is the product of distinct prime 3.
                 - [2]: product is 2, which is the product of distinct prime 2.
                 - [2,3]: product is 6, which is the product of distinct primes 2 and 3.
                 - [3]: product is 3, which is the product of distinct prime 3.

    Example 2:
    Input: nums = [4,2,3,15]
    Output: 5
    Explanation: The good subsets are:
                 - [2]: product is 2, which is the product of distinct prime 2.
                 - [2,3]: product is 6, which is the product of distinct primes 2 and 3.
                 - [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.
                 - [3]: product is 3, which is the product of distinct prime 3.
                 - [15]: product is 15, which is the product of distinct primes 3 and 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 30*/

    int numberOfGoodSubsets(vector<int>& nums) {
        const int MOD = 1'000'000'007;

        int primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
        unordered_map<int, int> mp;
        for (int i = 0; i < 10; ++i) mp[primes[i]] = i+1;

        vector<int> freq(31);
        for (auto& x : nums) ++freq[x];

        vector<int> masks(31);
        masks[1] = 1;
        for (int x = 2; x < 31; ++x) {
            int bits = 0, xx = x;
            bool dup = false;
            for (auto& k : primes)
                while (xx % k == 0) {
                    if ((bits >> mp[k]) & 1) {
                        dup = true;
                        break;
                    }
                    bits |= 1 << mp[k];
                    xx /= k;
                }
            if (not dup) masks[x] = bits;
        }

        auto power = [](long x, int p, int m) {
            long ans = 1;
            while (p) {
                if (p & 1) {
                    ans = ans * x % m;
                    --p;
                } else {
                    x = x * x % m;
                    p /= 2;
                }
            }
            return ans;
        };

        int M = 1 << 11;
        vector<vector<long>> dp(32, vector<long>(M));
        for (int m = 2; m < M; ++m) dp[31][m] = 1;

        for (int x = 30; x >= 1; --x)
            for (int m = 0; m < M; ++m) {
                dp[x][m] = dp[x+1][m];
                if (freq[x] && masks[x]) {
                    if (x == 1) dp[x][m] = power(2, freq[1], MOD) * dp[x][m] % MOD;
                    else if ((m & masks[x]) == 0) dp[x][m] = (dp[x][m] + freq[x] * dp[x+1][m | masks[x]]) % MOD;
                }
            }
        return dp[1][0];
    }


    /*1995. Count Special Quadruplets (Easy)
    Given a 0-indexed integer array nums, return the number of distinct
    quadruplets (a, b, c, d) such that:
    * nums[a] + nums[b] + nums[c] == nums[d], and
    * a < b < c < d

    Example 1:
    Input: nums = [1,2,3,6]
    Output: 1
    Explanation: The only quadruplet that satisfies the requirement is
                 (0, 1, 2, 3) because 1 + 2 + 3 == 6.

    Example 2:
    Input: nums = [3,3,6,4,5]
    Output: 0
    Explanation: There are no such quadruplets in [3,3,6,4,5].

    Example 3:
    Input: nums = [1,1,1,3,5]
    Output: 4
    Explanation: The 4 quadruplets that satisfy the requirement are:
                 - (0, 1, 2, 3): 1 + 1 + 1 == 3
                 - (0, 1, 3, 4): 1 + 1 + 3 == 5
                 - (0, 2, 3, 4): 1 + 1 + 3 == 5
                 - (1, 2, 3, 4): 1 + 1 + 3 == 5

    Constraints:
    * 4 <= nums.length <= 50
    * 1 <= nums[i] <= 100*/

    int countQuadruplets(vector<int>& nums) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = i+1; j < nums.size(); ++j) ans += freq[nums[j] - nums[i]];
            for (int ii = 0; ii < i; ++ii) ++freq[nums[ii] + nums[i]];
        }
        return ans;
    }


    /*1996. The Number of Weak Characters in the Game (Medium)
    You are playing a game that contains multiple characters, and each of the
    characters has two main properties: attack and defense. You are given a 2D
    integer array properties where properties[i] = [attacki, defensei]
    represents the properties of the ith character in the game. A character is
    said to be weak if any other character has both attack and defense levels
    strictly greater than this character's attack and defense levels. More
    formally, a character i is said to be weak if there exists another
    character j where attackj > attacki and defensej > defensei. Return the
    number of weak characters.

    Example 1:
    Input: properties = [[5,5],[6,3],[3,6]]
    Output: 0
    Explanation: No character has strictly greater attack and defense than the
                 other.

    Example 2:
    Input: properties = [[2,2],[3,3]]
    Output: 1
    Explanation: The first character is weak because the second character has a
                 strictly greater attack and defense.

    Example 3:
    Input: properties = [[1,5],[10,4],[4,3]]
    Output: 1
    Explanation: The third character is weak because the second character has a
                 strictly greater attack and defense.

    Constraints:
    * 2 <= properties.length <= 10^5
    * properties[i].length == 2
    * 1 <= attacki, defensei <= 10^5*/

    int numberOfWeakCharacters(vector<vector<int>>& properties) {
        sort(properties.begin(), properties.end(), [](auto& lhs, auto& rhs) {
            return lhs[0] > rhs[0] || (lhs[0] == rhs[0] && lhs[1] < rhs[1]);
        });

        int ans = 0, prefix = 0;
        for (auto& x : properties) {
            if (x[1] < prefix) ++ans;
            prefix = max(prefix, x[1]);
        }
        return ans;
    }


    /*1997. First Day Where You Have Been in All the Rooms (Medium)
    There are n rooms you need to visit, labeled from 0 to n - 1. Each day is
    labeled, starting from 0. You will go in and visit one room a day.
    Initially on day 0, you visit room 0. The order you visit the rooms for the
    coming days is determined by the following rules and a given 0-indexed
    array nextVisit of length n:
    * Assuming that on a day, you visit room i,
    * if you have been in room i an odd number of times (including the current
      visit), on the next day you will visit the room specified by nextVisit[i]
      where 0 <= nextVisit[i] <= i;
    * if you have been in room i an even number of times (including the current
      visit), on the next day you will visit room (i + 1) mod n.
    Return the label of the first day where you have been in all the rooms. It
    can be shown that such a day exists. Since the answer may be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: nextVisit = [0,0]
    Output: 2
    Explanation:
    - On day 0, you visit room 0. The total times you have been in room 0 is 1,
      which is odd. On the next day you will visit room nextVisit[0] = 0
    - On day 1, you visit room 0, The total times you have been in room 0 is 2,
      which is even. On the next day you will visit room (0 + 1) mod 2 = 1
    - On day 2, you visit room 1. This is the first day where you have been in
      all the rooms.

    Example 2:
    Input: nextVisit = [0,0,2]
    Output: 6
    Explanation: Your room visiting order for each day is: [0,0,1,0,0,1,2,...].
                 Day 6 is the first day where you have been in all the rooms.

    Example 3:
    Input: nextVisit = [0,1,2,0]
    Output: 6
    Explanation: Your room visiting order for each day is: [0,0,1,1,2,2,3,...].
                 Day 6 is the first day where you have been in all the rooms.

    Constraints:
    * n == nextVisit.length
    * 2 <= n <= 10^5
    * 0 <= nextVisit[i] <= i*/

    int firstDayBeenInAllRooms(vector<int>& nextVisit) {
        const int MOD = 1'000'000'007;
        int n = nextVisit.size();
        vector<long> odd(n), even(n);
        even[0] = 1;
        for (int i = 1; i < n; ++i) {
            odd[i] = (even[i-1] + 1) % MOD;
            even[i] = (2*odd[i] - odd[nextVisit[i]] + 1 + MOD) % MOD;
        }
        return odd.back();
    }


    /*1998. GCD Sort of an Array (Hard)
    You are given an integer array nums, and you can perform the following
    operation any number of times on nums:
    * Swap the positions of two elements nums[i] and nums[j] if
      gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest
      common divisor of nums[i] and nums[j].
    Return true if it is possible to sort nums in non-decreasing order using
    the above swap method, or false otherwise.

    Example 1:
    Input: nums = [7,21,3]
    Output: true
    Explanation: We can sort [7,21,3] by performing the following operations:
                 - Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3]
                 - Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21]

    Example 2:
    Input: nums = [5,2,6,2]
    Output: false
    Explanation: It is impossible to sort the array because 5 cannot be swapped
                 with any other element.

    Example 3:
    Input: nums = [10,5,9,3,15]
    Output: true
    We can sort [10,5,9,3,15] by performing the following operations:
    - Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10]
    - Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10]
    - Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15]

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * 2 <= nums[i] <= 10^5*/

    bool gcdSort(vector<int>& nums) {
        int m = *max_element(nums.begin(), nums.end());
        UnionFind* uf = new UnionFind(1+m);

        unordered_set<int> seen(nums.begin(), nums.end());

        vector<bool> sieve(1+m, true);
        sieve[0] = sieve[1] = false;
        for (int i = 2; i <= m/2; ++i)
            if (sieve[i])
                for (int ii = i*2; ii <= m; ii += i) {
                    sieve[ii] = false;
                    if (seen.count(ii)) uf->connect(i, ii);
                }

        bool ans = true;
        vector<int> copy(nums);
        sort(copy.begin(), copy.end());
        for (int i = 0; i < nums.size(); ++i)
            if (uf->find(nums[i]) != uf->find(copy[i])) {
                ans = false;
                break;
            }
        delete uf;
        return ans;
    }


    /*1999. Smallest Greater Multiple Made of Two Digits (Medium)
    Given three integers, k, digit1, and digit2, you want to find the smallest
    integer that is:
    * Larger than k,
    * A multiple of k, and
    * Comprised of only the digits digit1 and/or digit2.
    Return the smallest such integer. If no such integer exists or the integer
    exceeds the limit of a signed 32-bit integer (2^31 - 1), return -1.

    Example 1:
    Input: k = 2, digit1 = 0, digit2 = 2
    Output: 20
    Explanation: 20 is the first integer larger than 2, a multiple of 2, and
                 comprised of only the digits 0 and/or 2.

    Example 2:
    Input: k = 3, digit1 = 4, digit2 = 2
    Output: 24
    Explanation: 24 is the first integer larger than 3, a multiple of 3, and
                 comprised of only the digits 4 and/or 2.

    Example 3:
    Input: k = 2, digit1 = 0, digit2 = 0
    Output: -1
    Explanation: No integer meets the requirements so return -1.

    Constraints:
    * 1 <= k <= 1000
    * 0 <= digit1 <= 9
    * 0 <= digit2 <= 9*/

    int findInteger(int k, int digit1, int digit2) {
        if (digit1 > digit2) swap(digit1, digit2);
        queue<long> q; q.push(0);
        while (q.size()) {
            long val = q.front(); q.pop();
            if (k < val && val % k == 0) return val;
            if (val+digit1 && 10*val+digit1 < INT_MAX) q.push(10*val+digit1);
            if (digit1 < digit2 && 10*val+digit2 < INT_MAX) q.push(10*val+digit2);
        }
        return -1;
    }


    /*2000. Reverse Prefix of Word (Easy)
    Given a 0-indexed string word and a character ch, reverse the segment of
    word that starts at index 0 and ends at the index of the first occurrence
    of ch (inclusive). If the character ch does not exist in word, do nothing.
    For example, if word = "abcdefd" and ch = "d", then you should reverse the
    segment that starts at 0 and ends at 3 (inclusive). The resulting string
    will be "dcbaefd". Return the resulting string.

    Example 1:
    Input: word = "abcdefd", ch = "d"
    Output: "dcbaefd"
    Explanation: The first occurrence of "d" is at index 3. Reverse the part of
                 word from 0 to 3 (inclusive), the resulting string is "dcbaefd".

    Example 2:
    Input: word = "xyxzxe", ch = "z"
    Output: "zxyxxe"
    Explanation: The first and only occurrence of "z" is at index 3. Reverse
                 the part of word from 0 to 3 (inclusive), the resulting string
                 is "zxyxxe".

    Example 3:
    Input: word = "abcd", ch = "z"
    Output: "abcd"
    Explanation: "z" does not exist in word. You should not do any reverse
                 operation, the resulting string is "abcd".

    Constraints:
    * 1 <= word.length <= 250
    * word consists of lowercase English letters.
    * ch is a lowercase English letter.*/

    string reversePrefix(string word, char ch) {
        int k = word.find(ch);
        reverse(word.begin(), word.begin()+k+1);
        return word;
    }


    /*2001. Number of Pairs of Interchangeable Rectangles (Medium)
    You are given n rectangles represented by a 0-indexed 2D integer array
    rectangles, where rectangles[i] = [widthi, heighti] denotes the width and
    height of the ith rectangle. Two rectangles i and j (i < j) are considered
    interchangeable if they have the same width-to-height ratio. More formally,
    two rectangles are interchangeable if widthi/heighti == widthj/heightj
    (using decimal division, not integer division). Return the number of pairs
    of interchangeable rectangles in rectangles.

    Example 1:
    Input: rectangles = [[4,8],[3,6],[10,20],[15,30]]
    Output: 6
    Explanation: The following are the interchangeable pairs of rectangles by
                 index (0-indexed):
                 - Rectangle 0 with rectangle 1: 4/8 == 3/6.
                 - Rectangle 0 with rectangle 2: 4/8 == 10/20.
                 - Rectangle 0 with rectangle 3: 4/8 == 15/30.
                 - Rectangle 1 with rectangle 2: 3/6 == 10/20.
                 - Rectangle 1 with rectangle 3: 3/6 == 15/30.
                 - Rectangle 2 with rectangle 3: 10/20 == 15/30.
    Example 2:
    Input: rectangles = [[4,5],[7,8]]
    Output: 0
    Explanation: There are no interchangeable pairs of rectangles.

    Constraints:
    * n == rectangles.length
    * 1 <= n <= 10^5
    * rectangles[i].length == 2
    * 1 <= widthi, heighti <= 10^5*/

    long long interchangeableRectangles(vector<vector<int>>& rectangles) {
        long long ans = 0;
        unordered_map<double, int> freq;
        for (auto& rec : rectangles) {
            double ratio = (double) rec[0]/rec[1];
            ans += freq[ratio];
            freq[ratio]++;
        }
        return ans;
    }


    /*2002. Maximum Product of the Length of Two Palindromic Subsequences (Medium)
    Given a string s, find two disjoint palindromic subsequences of s such that
    the product of their lengths is maximized. The two subsequences are
    disjoint if they do not both pick a character at the same index. Return the
    maximum possible product of the lengths of the two palindromic subsequences.
    A subsequence is a string that can be derived from another string by
    deleting some or no characters without changing the order of the remaining
    characters. A string is palindromic if it reads the same forward and
    backward.

    Example 1:
    example-1
    Input: s = "leetcodecom"
    Output: 9
    Explanation: An optimal solution is to choose "ete" for the 1st subsequence
                 and "cdc" for the 2nd subsequence. The product of their
                 lengths is: 3 * 3 = 9.

    Example 2:
    Input: s = "bb"
    Output: 1
    Explanation: An optimal solution is to choose "b" (the first character) for
                 the 1st subsequence and "b" (the second character) for the 2nd
                 subsequence. The product of their lengths is: 1 * 1 = 1.

    Example 3:
    Input: s = "accbcaxxcxx"
    Output: 25
    Explanation: An optimal solution is to choose "accca" for the 1st
                 subsequence and "xxcxx" for the 2nd subsequence. The product
                 of their lengths is: 5 * 5 = 25.

    Constraints:
    * 2 <= s.length <= 12
    * s consists of lowercase English letters only.*/

    int maxProduct(string s) {
        int n = s.size();
        vector<int> dp(1 << n);
        for (int mask = 1; mask < (1 << n); ++mask)
            if ((mask & mask-1) == 0) dp[mask] = 1;
            else {
                int lo = log2(mask & ~(mask-1)), hi = log2(mask);
                if (s[lo] == s[hi]) dp[mask] = 2 + dp[mask^(1<<lo)^(1<<hi)];
                else dp[mask] = max(dp[mask^(1<<lo)], dp[mask^(1<<hi)]);
            }

        int ans = 0;
        for (int mask = 0; mask < (1 << n); ++mask) {
            int comp = (1 << n) - 1 ^ mask;
            ans = max(ans, dp[mask] * dp[comp]);
        }
        return ans;
    }


    /*2003. Smallest Missing Genetic Value in Each Subtree (Hard)
    There is a family tree rooted at 0 consisting of n nodes numbered 0 to
    n - 1. You are given a 0-indexed integer array parents, where parents[i] is
    the parent for node i. Since node 0 is the root, parents[0] == -1. There
    are 10^5 genetic values, each represented by an integer in the inclusive
    range [1, 10^5]. You are given a 0-indexed integer array nums, where nums[i]
    is a distinct genetic value for node i. Return an array ans of length n
    where ans[i] is the smallest genetic value that is missing from the subtree
    rooted at node i. The subtree rooted at a node x contains node x and all of
    its descendant nodes.

    Example 1:
    Input: parents = [-1,0,0,2], nums = [1,2,3,4]
    Output: [5,1,1,1]
    Explanation: The answer for each subtree is calculated as follows:
                 - 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value.
                 - 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.
                 - 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value.
                 - 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value.

    Example 2:
    Input: parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]
    Output: [7,1,1,4,2,1]
    Explanation: The answer for each subtree is calculated as follows:
                 - 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value.
                 - 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value.
                 - 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.
                 - 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value.
                 - 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.
                 - 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value.

    Example 3:
    Input: parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]
    Output: [1,1,1,1,1,1,1]
    Explanation: The value 1 is missing from all the subtrees.

    Constraints:
    * n == parents.length == nums.length
    * 2 <= n <= 10^5
    * 0 <= parents[i] <= n - 1 for i != 0
    * parents[0] == -1
    * parents represents a valid tree.
    * 1 <= nums[i] <= 10^5
    * Each nums[i] is distinct.*/

    vector<int> smallestMissingValueSubtree(vector<int>& parents, vector<int>& nums) {
        int n = parents.size();
        vector<int> ans(n, 1);

        auto it = find(nums.begin(), nums.end(), 1);
        if (it != nums.end()) {
            vector<vector<int>> tree(n);
            for (int i = 0; i < n; ++i)
                if (parents[i] != -1) tree[parents[i]].push_back(i);

            int miss = 1;
            unordered_set<int> seen;
            for (int k = it - nums.begin(); k != -1; k = parents[k]) {
                stack<int> stk; stk.push(k);
                seen.insert(nums[k]);
                while (stk.size()) {
                    int x = stk.top(); stk.pop();
                    for (auto& xx : tree[x])
                        if (!seen.count(nums[xx])) {
                            seen.insert(nums[xx]);
                            stk.push(xx);
                        }
                }
                for (; seen.count(miss); ++miss);
                ans[k] = miss;
            }
        }
        return ans;
    }


    /*2005. Subtree Removal Game with Fibonacci Tree (Hard)
    A Fibonacci tree is a binary tree created using the order function order(n):
    * order(0) is the empty tree.
    * order(1) is a binary tree with only one node.
    * order(n) is a binary tree that consists of a root node with the left
      subtree as order(n - 2) and the right subtree as order(n - 1).
    Alice and Bob are playing a game with a Fibonacci tree with Alice staring
    first. On each turn, a player selects a node and removes that node and its
    subtree. The player that is forced to delete root loses. Given the integer
    n, return true if Alice wins the game or false if Bob wins, assuming both
    players play optimally. A subtree of a binary tree tree is a tree that
    consists of a node in tree and all of this node's descendants. The tree
    tree could also be considered as a subtree of itself.

    Example 1:
    Input: n = 3
    Output: true
    Explanation: Alice takes the node 1 in the right subtree. Bob takes either
                 the 1 in the left subtree or the 2 in the right subtree. Alice
                 takes whichever node Bob doesn't take. Bob is forced to take
                 the root node 3, so Bob will lose. Return true because Alice
                 wins.

    Example 2:
    Input: n = 1
    Output: false
    Explanation: Alice is forced to take the root node 1, so Alice will lose.
                 Return false because Alice loses.

    Example 3:
    Input: n = 2
    Output: true
    Explanation: Alice takes the node 1. Bob is forced to take the root node 2,
                 so Bob will lose. Return true because Alice wins.

    Constraints: 1 <= n <= 100*/

    bool findGameWinner(int n) {
        return (n-1) % 6;
    }


    /*2006. Count Number of Pairs With Absolute Difference K (Easy)
    Given an integer array nums and an integer k, return the number of pairs
    (i, j) where i < j such that |nums[i] - nums[j]| == k. The value of |x| is
    defined as:
    * x if x >= 0.
    * -x if x < 0.

    Example 1:
    Input: nums = [1,2,2,1], k = 1
    Output: 4
    Explanation: The pairs with an absolute difference of 1 are:
                 - [1,2,2,1]
                 - [1,2,2,1]
                 - [1,2,2,1]
                 - [1,2,2,1]

    Example 2:
    Input: nums = [1,3], k = 3
    Output: 0
    Explanation: There are no pairs with an absolute difference of 3.

    Example 3:
    Input: nums = [3,2,1,5,4], k = 2
    Output: 3
    Explanation: The pairs with an absolute difference of 2 are:
                 - [3,2,1,5,4]
                 - [3,2,1,5,4]
                 - [3,2,1,5,4]

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= 100
    * 1 <= k <= 99*/

    int countKDifference(vector<int>& nums, int k) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (auto& x : nums) {
            ans += freq[x - k] + freq[x + k];
            freq[x]++;
        }
        return ans;
    }


    /*2007. Find Original Array From Doubled Array (Medium)
    An integer array original is transformed into a doubled array changed by
    appending twice the value of every element in original, and then randomly
    shuffling the resulting array. Given an array changed, return original if
    changed is a doubled array. If changed is not a doubled array, return an
    empty array. The elements in original may be returned in any order.

    Example 1:
    Input: changed = [1,3,4,2,6,8]
    Output: [1,3,4]
    Explanation: One possible original array could be [1,3,4]:
                 - Twice the value of 1 is 1 * 2 = 2.
                 - Twice the value of 3 is 3 * 2 = 6.
                 - Twice the value of 4 is 4 * 2 = 8.
                 Other original arrays could be [4,3,1] or [3,1,4].

    Example 2:
    Input: changed = [6,3,0,1]
    Output: []
    Explanation: changed is not a doubled array.

    Example 3:
    Input: changed = [1]
    Output: []
    Explanation: changed is not a doubled array.

    Constraints:
    * 1 <= changed.length <= 10^5
    * 0 <= changed[i] <= 10^5*/

    vector<int> findOriginalArray(vector<int>& changed) {
        map<int, int> freq;
        for (auto& x : changed) freq[x]++;

        sort(changed.begin(), changed.end());

        vector<int> ans;
        for (auto& [k, v] : freq)
            if (v) {
                if (k && v <= freq[2*k]) {
                    freq[2*k] -= v;
                    for (; v; --v) ans.push_back(k);
                } else if (k == 0 && v % 2 == 0)
                    for (v /= 2; v; --v) ans.push_back(k);
                else return {};
            }
        return ans;
    }


    /*2008. Maximum Earnings From Taxi (Medium)
    There are n points on a road you are driving your taxi on. The n points on
    the road are labeled from 1 to n in the direction you are going, and you
    want to drive from point 1 to point n to make money by picking up
    passengers. You cannot change the direction of the taxi. The passengers are
    represented by a 0-indexed 2D integer array rides, where
    rides[i] = [starti, endi, tipi] denotes the ith passenger requesting a ride
    from point starti to point endi who is willing to give a tipi dollar tip.
    For each passenger i you pick up, you earn endi - starti + tipi dollars.
    You may only drive at most one passenger at a time. Given n and rides,
    return the maximum number of dollars you can earn by picking up the
    passengers optimally. Note: You may drop off a passenger and pick up a
    different passenger at the same point.

    Example 1:
    Input: n = 5, rides = [[2,5,4],[1,5,1]]
    Output: 7
    Explanation: We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.

    Example 2:
    Input: n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]
    Output: 20
    Explanation: We will pick up the following passengers:
                 - Drive passenger 1 from point 3 to point 10 for a profit of
                   10 - 3 + 2 = 9 dollars.
                 - Drive passenger 2 from point 10 to point 12 for a profit of
                   12 - 10 + 3 = 5 dollars.
                 - Drive passenger 5 from point 13 to point 18 for a profit of
                   18 - 13 + 1 = 6 dollars.
                 We earn 9 + 5 + 6 = 20 dollars in total.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= rides.length <= 3 * 10^4
    * rides[i].length == 3
    * 1 <= starti < endi <= n
    * 1 <= tipi <= 10^5*/

    long long maxTaxiEarnings(int n, vector<vector<int>>& rides) {
        unordered_map<int, vector<pair<int, int>>> mp;
        for (auto& x : rides)
            mp[x[0]].emplace_back(x[1], x[2]);

        vector<long long> dp(n+1);
        for (int x = n-1; x >= 1; --x) {
            dp[x] = dp[x+1];
            for (auto& [xx, tip] : mp[x])
                dp[x] = max(dp[x], xx - x + tip + dp[xx]);
        }
        return dp[1];
    }


    /*2009. Minimum Number of Operations to Make Array Continuous (Hard)
    You are given an integer array nums. In one operation, you can replace any
    element in nums with any integer. nums is considered continuous if both of
    the following conditions are fulfilled:
    * All elements in nums are unique.
    * The difference between the maximum element and the minimum element in
      nums equals nums.length - 1.
    For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6]
    is not continuous. Return the minimum number of operations to make nums
    continuous.

    Example 1:
    Input: nums = [4,2,5,3]
    Output: 0
    Explanation: nums is already continuous.

    Example 2:
    Input: nums = [1,2,3,5,6]
    Output: 1
    Explanation: One possible solution is to change the last element to 4. The
                 resulting array is [1,2,3,5,4], which is continuous.

    Example 3:
    Input: nums = [1,10,100,1000]
    Output: 3
    Explanation: One possible solution is to:
                 - Change the second element to 2.
                 - Change the third element to 3.
                 - Change the fourth element to 4.
                 The resulting array is [1,2,3,4], which is continuous.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int minOperations(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end()); // remove duplicates

        for (int i = 0, ii = 0; i < nums.size(); ++i) {
            if (nums[i] - nums[ii] >= n) ++ii;
            ans = max(ans, i - ii + 1);
        }
        return n - ans;
    }


    /*2011. Final Value of Variable After Performing Operations (Easy)
    There is a programming language with only four operations and one variable
    X:
    * ++X and X++ increments the value of the variable X by 1.
    * --X and X-- decrements the value of the variable X by 1.
    Initially, the value of X is 0. Given an array of strings operations
    containing a list of operations, return the final value of X after
    performing all the operations.

    Example 1:
    Input: operations = ["--X","X++","X++"]
    Output: 1
    Explanation: The operations are performed as follows:
                 Initially, X = 0.
                 --X: X is decremented by 1, X =  0 - 1 = -1.
                 X++: X is incremented by 1, X = -1 + 1 =  0.
                 X++: X is incremented by 1, X =  0 + 1 =  1.

    Example 2:
    Input: operations = ["++X","++X","X++"]
    Output: 3
    Explanation: The operations are performed as follows:
                 Initially, X = 0.
                 ++X: X is incremented by 1, X = 0 + 1 = 1.
                 ++X: X is incremented by 1, X = 1 + 1 = 2.
                 X++: X is incremented by 1, X = 2 + 1 = 3.

    Example 3:
    Input: operations = ["X++","++X","--X","X--"]
    Output: 0
    Explanation: The operations are performed as follows:
                 Initially, X = 0.
                 X++: X is incremented by 1, X = 0 + 1 = 1.
                 ++X: X is incremented by 1, X = 1 + 1 = 2.
                 --X: X is decremented by 1, X = 2 - 1 = 1.
                 X--: X is decremented by 1, X = 1 - 1 = 0.

    Constraints:
    * 1 <= operations.length <= 100
    * operations[i] will be either "++X", "X++", "--X", or "X--".*/

    int finalValueAfterOperations(vector<string>& operations) {
        int ans = 0;
        for (auto& op : operations)
            if (op == "++X" || op == "X++") ++ans;
            else --ans;
        return ans;
    }


    /*2012. Sum of Beauty in the Array (Medium)
    You are given a 0-indexed integer array nums. For each index i
    (1 <= i <= nums.length - 2) the beauty of nums[i] equals:
    * 2, if nums[j] < nums[i] < nums[k], for all 0 <= j < i and for all
      i < k <= nums.length - 1.
    * 1, if nums[i - 1] < nums[i] < nums[i + 1], and the previous condition is
      not satisfied.
    * 0, if none of the previous conditions holds.
    Return the sum of beauty of all nums[i] where 1 <= i <= nums.length - 2.

    Example 1:
    Input: nums = [1,2,3]
    Output: 2
    Explanation: For each index i in the range 1 <= i <= 1:
                 - The beauty of nums[1] equals 2.

    Example 2:
    Input: nums = [2,4,6,4]
    Output: 1
    Explanation: For each index i in the range 1 <= i <= 2:
                 - The beauty of nums[1] equals 1.
                 - The beauty of nums[2] equals 0.

    Example 3:
    Input: nums = [3,2,1]
    Output: 0
    Explanation: For each index i in the range 1 <= i <= 1:
                 - The beauty of nums[1] equals 0.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    int sumOfBeauties(vector<int>& nums) {
        int n = nums.size();
        vector<int> suffix(n, INT_MAX);
        for (int i = n-2; i >= 1; --i)
            suffix[i] = min(suffix[i+1], nums[i+1]);

        int prefix = 0, ans = 0;
        for (int i = 1; i < n-1; ++i) {
            prefix = max(prefix, nums[i-1]);
            if (prefix < nums[i] && nums[i] < suffix[i]) ans += 2;
            else if (nums[i-1] < nums[i] && nums[i] < nums[i+1]) ans += 1;
        }
        return ans;
    }


    /*2014. Longest Subsequence Repeated k Times (Hard)
    You are given a string s of length n, and an integer k. You are tasked to
    find the longest subsequence repeated k times in string s. A subsequence is
    a string that can be derived from another string by deleting some or no
    characters without changing the order of the remaining characters. A
    subsequence seq is repeated k times in the string s if seq * k is a
    subsequence of s, where seq * k represents a string constructed by
    concatenating seq k times. For example, "bba" is repeated 2 times in the
    string "bababcba", because the string "bbabba", constructed by
    concatenating "bba" 2 times, is a subsequence of the string "bababcba".
    Return the longest subsequence repeated k times in string s. If multiple
    such subsequences are found, return the lexicographically largest one. If
    there is no such subsequence, return an empty string.

    Example 1:
    example 1
    Input: s = "letsleetcode", k = 2
    Output: "let"
    Explanation: There are two longest subsequences repeated 2 times: "let" and
                 "ete". "let" is the lexicographically largest one.

    Example 2:
    Input: s = "bb", k = 2
    Output: "b"
    Explanation: The longest subsequence repeated 2 times is "b".

    Example 3:
    Input: s = "ab", k = 2
    Output: ""
    Explanation: There is no subsequence repeated 2 times. Empty string is
                 returned.

    Example 4:
    Input: s = "bbabbabbbbabaababab", k = 3
    Output: "bbbb"
    Explanation: The longest subsequence "bbbb" is repeated 3 times in
                 "bbabbabbbbabaababab".

    Constraints:
    * n == s.length
    * 2 <= n, k <= 2000
    * 2 <= n < k * 8
    * s consists of lowercase English letters.*/

    string longestSubsequenceRepeatedK(string s, int k) {
        vector<int> freq(26);
        for (auto& ch : s) ++freq[ch - 'a'];

        vector<char> cand;
        for (int i = 0; i < 26; ++i)
            if (freq[i] >= k) cand.push_back(i + 'a');

        auto fn = [&](string ss) {
            // return True if ss is a k-repeated sub-sequence of s.
            int i = 0, cnt = 0;
            for (auto& ch : s)
                if (ss[i] == ch)
                    if (++i == ss.size()) {
                        if (++cnt == k) return true;
                        i = 0;
                    }
            return false;
        };

        string ans;
        queue<string> q;
        q.push("");
        while (q.size()) {
            string x = q.front(); q.pop();
            ans = x;
            for (auto& ch : cand) {
                string xx = x + ch;
                if (fn(xx)) {
                    ans = xx;
                    q.push(xx);
                }
            }
        }
        return ans;
    }


    /*2015. Average Height of Buildings in Each Segment (Medium)
    A perfectly straight street is represented by a number line. The street has
    building(s) on it and is represented by a 2D integer array buildings, where
    buildings[i] = [starti, endi, heighti]. This means that there is a building
    with heighti in the half-closed segment [starti, endi). You want to
    describe the heights of the buildings on the street with the minimum number
    of non-overlapping segments. The street can be represented by the 2D
    integer array street where street[j] = [leftj, rightj, averagej] describes
    a half-closed segment [leftj, rightj) of the road where the average heights
    of the buildings in the segment is averagej.
    * For example, if buildings = [[1,5,2],[3,10,4]], the street could be
      represented by street = [[1,3,2],[3,5,3],[5,10,4]] because:
      + From 1 to 3, there is only the first building with an average height of
        2 / 1 = 2.
      + From 3 to 5, both the first and the second building are there with an
        average height of (2+4) / 2 = 3.
      + From 5 to 10, there is only the second building with an average height
        of 4 / 1 = 4.
    Given buildings, return the 2D integer array street as described above
    (excluding any areas of the street where there are no buldings). You may
    return the array in any order. The average of n elements is the sum of the
    n elements divided (integer division) by n. A half-closed segment [a, b) is
    the section of the number line between points a and b including point a and
    not including point b.

    Example 1:
    Input: buildings = [[1,4,2],[3,9,4]]
    Output: [[1,3,2],[3,4,3],[4,9,4]]
    Explanation: From 1 to 3, there is only the first building with an average
                 height of 2 / 1 = 2. From 3 to 4, both the first and the
                 second building are there with an average height of
                 (2+4) / 2 = 3. From 4 to 9, there is only the second building
                 with an average height of 4 / 1 = 4.

    Example 2:
    Input: buildings = [[1,3,2],[2,5,3],[2,8,3]]
    Output: [[1,3,2],[3,8,3]]
    Explanation: From 1 to 2, there is only the first building with an average
                 height of 2 / 1 = 2. From 2 to 3, all three buildings are
                 there with an average height of (2+3+3) / 3 = 2. From 3 to 5,
                 both the second and the third building are there with an
                 average height of (3+3) / 2 = 3. From 5 to 8, there is only
                 the last building with an average height of 3 / 1 = 3. The
                 average height from 1 to 3 is the same so we can group them
                 into one segment. The average height from 3 to 8 is the same
                 so we can group them into one segment.

    Example 3:
    Input: buildings = [[1,2,1],[5,6,1]]
    Output: [[1,2,1],[5,6,1]]
    Explanation: From 1 to 2, there is only the first building with an average
                 height of 1 / 1 = 1. From 2 to 5, there are no buildings, so
                 it is not included in the output. From 5 to 6, there is only
                 the second building with an average height of 1 / 1 = 1. We
                 cannot group the segments together because an empty space with
                 no buildings seperates the segments.

    Constraints:
    * 1 <= buildings.length <= 10^5
    * buildings[i].length == 3
    * 0 <= starti < endi <= 10^8
    * 1 <= heighti <= 10^5*/

    vector<vector<int>> averageHeightOfBuildings(vector<vector<int>>& buildings) {
        map<int, vector<pair<int, int>>> street;
        for (auto& building : buildings) {
            street[building[0]].emplace_back(building[2], 1);
            street[building[1]].emplace_back(-building[2], -1);
        }
        vector<vector<int>> ans;
        int prev = INT_MIN, count = 0, value = 0;
        for (auto& [k, v] : street) {
            if (prev > INT_MIN && count) {
                int avg = value/count;
                if (ans.size() && ans.back()[1] == prev && ans.back()[2] == avg) ans.back()[1] = k;
                else ans.push_back({prev, k, value/count});
            }
            for (auto& [h, c] : v) {
                count += c;
                value += h;
            }
            prev = k;
        }
        return ans;
    }


    /*2016. Maximum Difference Between Increasing Elements (Easy)
    Given a 0-indexed integer array nums of size n, find the maximum difference
    between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that
    0 <= i < j < n and nums[i] < nums[j]. Return the maximum difference. If no
    such i and j exists, return -1.

    Example 1:
    Input: nums = [7,1,5,4]
    Output: 4
    Explanation: The maximum difference occurs with i = 1 and j = 2,
                 nums[j] - nums[i] = 5 - 1 = 4. Note that with i = 1 and j = 0,
                 the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it
                 is not valid.

    Example 2:
    Input: nums = [9,4,3,2]
    Output: -1
    Explanation: There is no i and j such that i < j and nums[i] < nums[j].

    Example 3:
    Input: nums = [1,5,2,10]
    Output: 9
    Explanation: The maximum difference occurs with i = 0 and j = 3,
                 nums[j] - nums[i] = 10 - 1 = 9.

    Constraints:
    * n == nums.length
    * 2 <= n <= 1000
    * 1 <= nums[i] <= 10^9*/

    int maximumDifference(vector<int>& nums) {
        int ans = -1, prefix = INT_MAX;
        for (auto& x : nums) {
            if (prefix < x) ans = max(ans, x - prefix);
            prefix = min(prefix, x);
        }
        return ans;
    }


    /*2017. Grid Game (Medium)
    You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c]
    represents the number of points at position (r, c) on the matrix. Two
    robots are playing a game on this matrix. Both robots initially start at
    (0, 0) and want to reach (1, n-1). Each robot may only move to the right
    ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)). At the start of the
    game, the first robot moves from (0, 0) to (1, n-1), collecting all the
    points from the cells on its path. For all cells (r, c) traversed on the
    path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to
    (1, n-1), collecting the points on its path. Note that their paths may
    intersect with one another. The first robot wants to minimize the number of
    points collected by the second robot. In contrast, the second robot wants
    to maximize the number of points it collects. If both robots play optimally,
    return the number of points collected by the second robot.

    Example 1:
    Input: grid = [[2,5,4],[1,5,1]]
    Output: 4
    Explanation: The optimal path taken by the first robot is shown in red, and
                 the optimal path taken by the second robot is shown in blue.
                 The cells visited by the first robot are set to 0. The second
                 robot will collect 0 + 0 + 4 + 0 = 4 points.

    Example 2:
    Input: grid = [[3,3,1],[8,5,2]]
    Output: 4
    Explanation: The optimal path taken by the first robot is shown in red, and
                 the optimal path taken by the second robot is shown in blue.
                 The cells visited by the first robot are set to 0. The second
                 robot will collect 0 + 3 + 1 + 0 = 4 points.

    Example 3:
    Input: grid = [[1,3,1,15],[1,3,3,1]]
    Output: 7
    Explanation: The optimal path taken by the first robot is shown in red, and
                 the optimal path taken by the second robot is shown in blue.
                 The cells visited by the first robot are set to 0. The second
                 robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.

    Constraints:
    * grid.length == 2
    * n == grid[r].length
    * 1 <= n <= 5 * 10^4
    * 1 <= grid[r][c] <= 10^5*/

    long long gridGame(vector<vector<int>>& grid) {
        long long ans = LONG_MAX, prefix = 0, suffix = accumulate(grid[0].begin(), grid[0].end(), 0l);
        for (int i = 0; i < grid[0].size(); ++i) {
            suffix -= grid[0][i];
            ans = min(ans, max(prefix, suffix));
            prefix += grid[1][i];
        }
        return ans;
    }


    /*2018. Check if Word Can Be Placed In Crossword (Medium)
    You are given an m x n matrix board, representing the current state of a
    crossword puzzle. The crossword contains lowercase English letters (from
    solved words), ' ' to represent any empty cells, and '#' to represent any
    blocked cells. A word can be placed horizontally (left to right or right to
    left) or vertically (top to bottom or bottom to top) in the board if:
    * It does not occupy a cell containing the character '#'.
    * The cell each letter is placed in must either be ' ' (empty) or match the
      letter already on the board.
    * There must not be any empty cells ' ' or other lowercase letters directly
      left or right of the word if the word was placed horizontally.
    * There must not be any empty cells ' ' or other lowercase letters directly
      above or below the word if the word was placed vertically.
    Given a string word, return true if word can be placed in board, or false
    otherwise.

    Example 1:
    Input: board = [["#", " ", "#"], [" ", " ", "#"], ["#", "c", " "]], word = "abc"
    Output: true
    Explanation: The word "abc" can be placed as shown above (top to bottom).

    Example 2:
    Input: board = [[" ", "#", "a"], [" ", "#", "c"], [" ", "#", "a"]], word = "ac"
    Output: false
    Explanation: It is impossible to place the word because there will always
                 be a space/letter above or below it.

    Example 3:
    Input: board = [["#", " ", "#"], [" ", " ", "#"], ["#", " ", "c"]], word = "ca"
    Output: true
    Explanation: The word "ca" can be placed as shown above (right to left).

    Constraints:
    * m == board.length
    * n == board[i].length
    * 1 <= m * n <= 2 * 10^5
    * board[i][j] will be ' ', '#', or a lowercase English letter.
    * 1 <= word.length <= max(m, n)
    * word will contain only lowercase English letters.*/

    bool placeWordInCrossword(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size(), w = word.size();
        vector<vector<char>> trans(n, vector<char>(m));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                trans[j][i] = board[i][j];

        auto fn = [&](vector<vector<char>>& x) {
            int m = x.size(), n = x[0].size();
            for (int i = 0; i < m; ++i) {
                int lo = 0, hi = w-1;
                for (int j = 0; j < n; ++j) {
                    if (x[i][j] == '#') {
                        lo = 0; hi = w-1;
                    } else if (x[i][j] == ' ') {
                        ++lo; --hi;
                    } else {
                        lo = x[i][j] == word[lo] ? lo+1 : 0;
                        hi = x[i][j] == word[hi] ? hi-1 : w-1;
                    }
                    if (lo == w || hi == -1)
                        if ((j == n-1 || x[i][j+1] == '#') and (j == w-1 || x[i][j-w] == '#')) return true;
                        else { lo = 0; hi = w-1; }
                }
            }
            return false;
        };

        return fn(board) || fn(trans);
    }


    /*2019. The Score of Students Solving Math Expression (Hard)
    You are given a string s that contains digits 0-9, addition symbols '+',
    and multiplication symbols '*' only, representing a valid math expression
    of single digit numbers (e.g., 3+5*2). This expression was given to n
    elementary school students. The students were instructed to get the answer
    of the expression by following this order of operations:
    * Compute multiplication, reading from left to right; Then,
    * Compute addition, reading from left to right.
    You are given an integer array answers of length n, which are the submitted
    answers of the students in no particular order. You are asked to grade the
    answers, by following these rules:
    * If an answer equals the correct answer of the expression, this student
      will be rewarded 5 points;
    * Otherwise, if the answer could be interpreted as if the student used the
      incorrect order of operations, once or multiple times, this student will
      be rewarded 2 points;
    * Otherwise, this student will be rewarded 0 points.
    Return the sum of the points of the students.

    Example 1:
    Input: s = "7+3*1*2", answers = [20,13,42]
    Output: 7
    Explanation: As illustrated above, the correct answer of the expression is
                 13, therefore one student is rewarded 5 points: [20,13,42]. A
                 student might have used this incorrect order of operations:
                 7+3=10, 10*1=10, 10*2=20. Therefore one student is rewarded 2
                 points: [20,13,42]. The points for the students are: [2,5,0].
                 The sum of the points is 2+5+0=7.

    Example 2:
    Input: s = "3+5*2", answers = [13,0,10,13,13,16,16]
    Output: 19
    Explanation: The correct answer of the expression is 13, therefore three
                 students are rewarded 5 points each: [13,0,10,13,13,16,16].
                 A student might have used this incorrect order of operations:
                 3+5=8, 8*2=16. Therefore two students are rewarded 2 points:
                 [13,0,10,13,13,16,16]. The points for the students are:
                 [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19.

    Example 3:
    Input: s = "6+0*1", answers = [12,9,6,4,8,6]
    Output: 10
    Explanation: The correct answer of the expression is 6. If a student had
                 used some incorrect order of operations, the answer would also
                 be 6. By the rules of grading, the students will still be
                 rewarded 5 points (as they got the correct answer), not 2
                 points. The points for the students are: [0,0,5,0,0,5]. The
                 sum of the points is 10.

    Constraints:
    * 3 <= s.length <= 31
    * s represents a valid expression that contains only digits 0-9, '+', and '*' only.
    * All the integer operands in the expression are in the inclusive range [0, 9].
    * 1 <= The count of all operators ('+' and '*') in the math expression <= 15
    * Test data are generated such that the correct answer of the expression is in the range of [0, 1000].
    * n == answers.length
    * 1 <= n <= 10^4
    * 0 <= answers[i] <= 1000*/

    int scoreOfStudents(string s, vector<int>& answers) {
        int n = s.size();
        vector<int> stk;
        for (int i = 0; i < n; i += 2) {
            int x = s[i] - '0';
            if (i && s[i-1] == '*') stk.back() *= x;
            else stk.push_back(x);
        }
        int target = accumulate(stk.begin(), stk.end(), 0);

        vector<vector<unordered_set<int>>> dp(n, vector<unordered_set<int>>(n));
        for (int lo = n-1; lo >= 0; lo -= 2)
            for (int hi = lo; hi < n; hi += 2)
                if (lo == hi) dp[lo][hi] = {s[lo] - '0'};
                else
                    for (int mid = lo+1; mid < hi; mid += 2)
                        for (auto& x : dp[lo][mid-1])
                            for (auto& y : dp[mid+1][hi])
                                if (s[mid] == '+' && x + y <= 1000) dp[lo][hi].insert(x+y);
                                else if (s[mid] == '*' && x * y <= 1000) dp[lo][hi].insert(x*y);

        int ans = 0;
        for (auto& x : answers) {
            if (x == target) ans += 5;
            else if (dp[0][n-1].count(x)) ans += 2;
        }
        return ans;
    }


    /*2021. Brightest Position on Street (Medium)
    A perfectly straight street is represented by a number line. The street has
    street lamp(s) on it and is represented by a 2D integer array lights. Each
    lights[i] = [positioni, rangei] indicates that there is a street lamp at
    position positioni that lights up the area from
    [positioni - rangei, positioni + rangei] (inclusive). The brightness of a
    position p is defined as the number of street lamp that light up the
    position p. Given lights, return the brightest position on the street. If
    there are multiple brightest positions, return the smallest one.

    Example 1:
    Input: lights = [[-3,2],[1,2],[3,3]]
    Output: -1
    Explanation: The first street lamp lights up the area from
                 [(-3) - 2, (-3) + 2] = [-5, -1]. The second street lamp lights
                 up the area from [1 - 2, 1 + 2] = [-1, 3]. The third street
                 lamp lights up the area from [3 - 3, 3 + 3] = [0, 6]. Position
                 -1 has a brightness of 2, illuminated by the first and second
                 street light. Positions 0, 1, 2, and 3 have a brightness of 2,
                 illuminated by the second and third street light. Out of all
                 these positions, -1 is the smallest, so return it.

    Example 2:
    Input: lights = [[1,0],[0,1]]
    Output: 1
    Explanation: The first street lamp lights up the area from [1 - 0, 1 + 0] =
                 [1, 1]. The second street lamp lights up the area from
                 [0 - 1, 0 + 1] = [-1, 1]. Position 1 has a brightness of 2,
                 illuminated by the first and second street light. Return 1
                 because it is the brightest position on the street.

    Example 3:
    Input: lights = [[1,2]]
    Output: -1
    Explanation: The first street lamp lights up the area from [1 - 2, 1 + 2] =
                 [-1, 3]. Positions -1, 0, 1, 2, and 3 have a brightness of 1,
                 illuminated by the first street light. Out of all these
                 positions, -1 is the smallest, so return it.

    Constraints:
    * 1 <= lights.length <= 10^5
    * lights[i].length == 2
    * -10^8 <= positioni <= 10^8
    * 0 <= rangei <= 10^8*/

    int brightestPosition(vector<vector<int>>& lights) {
        vector<pair<int, int>> line;
        for (auto& light : lights) {
            line.emplace_back(light[0] - light[1], 1);
            line.emplace_back(light[0] + light[1] + 1, -1);
        }
        sort(line.begin(), line.end());
        int ans = 0, most = 0, prefix = 0;
        for (auto& [x, v] : line) {
            prefix += v;
            if (prefix > most) tie(ans, most) = make_pair(x, prefix);
        }
        return ans;
    }


    /*2022. Convert 1D Array Into 2D Array (Easy)
    You are given a 0-indexed 1-dimensional (1D) integer array original, and
    two integers, m and n. You are tasked with creating a 2-dimensional (2D)
    array with m rows and n columns using all the elements from original. The
    elements from indices 0 to n - 1 (inclusive) of original should form the
    first row of the constructed 2D array, the elements from indices n to
    2 * n - 1 (inclusive) should form the second row of the constructed 2D
    array, and so on. Return an m x n 2D array constructed according to the
    above procedure, or an empty 2D array if it is impossible.

    Example 1:
    Input: original = [1,2,3,4], m = 2, n = 2
    Output: [[1,2],[3,4]]
    Explanation: The constructed 2D array should contain 2 rows and 2 columns.
                 The first group of n=2 elements in original, [1,2], becomes
                 the first row in the constructed 2D array. The second group of
                 n=2 elements in original, [3,4], becomes the second row in the
                 constructed 2D array.

    Example 2:
    Input: original = [1,2,3], m = 1, n = 3
    Output: [[1,2,3]]
    Explanation: The constructed 2D array should contain 1 row and 3 columns.
                 Put all three elements in original into the first row of the
                 constructed 2D array.

    Example 3:
    Input: original = [1,2], m = 1, n = 1
    Output: []
    Explanation: There are 2 elements in original. It is impossible to fit 2
                 elements in a 1x1 2D array, so return an empty 2D array.

    Example 4:
    Input: original = [3], m = 1, n = 2
    Output: []
    Explanation: There is 1 element in original. It is impossible to make 1
                 element fill all the spots in a 1x2 2D array, so return an
                 empty 2D array.

    Constraints:
    * 1 <= original.length <= 5 * 10^4
    * 1 <= original[i] <= 10^5
    * 1 <= m, n <= 4 * 10^4*/

    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
        if (original.size() != m * n) return {};
        vector<vector<int>> ans(m, vector<int>(n));
        for (int i = 0, k = 0; i < m; i++)
            for (int j = 0; j < n; ++j, ++k)
                ans[i][j] = original[k];
        return ans;
    }


    /*2023. Number of Pairs of Strings With Concatenation Equal to Target (Medium)
    Given an array of digit strings nums and a digit string target, return the
    number of pairs of indices (i, j) (where i != j) such that the
    concatenation of nums[i] + nums[j] equals target.

    Example 1:
    Input: nums = ["777","7","77","77"], target = "7777"
    Output: 4
    Explanation: Valid pairs are:
                 - (0, 1): "777" + "7"
                 - (1, 0): "7" + "777"
                 - (2, 3): "77" + "77"
                 - (3, 2): "77" + "77"

    Example 2:
    Input: nums = ["123","4","12","34"], target = "1234"
    Output: 2
    Explanation: Valid pairs are:
                 - (0, 1): "123" + "4"
                 - (2, 3): "12" + "34"

    Example 3:
    Input: nums = ["1","1","1"], target = "11"
    Output: 6
    Explanation: Valid pairs are:
                 - (0, 1): "1" + "1"
                 - (1, 0): "1" + "1"
                 - (0, 2): "1" + "1"
                 - (2, 0): "1" + "1"
                 - (1, 2): "1" + "1"
                 - (2, 1): "1" + "1"

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i].length <= 100
    * 2 <= target.length <= 100
    * nums[i] and target consist of digits.
    * nums[i] and target do not have leading zeros.*/

    int numOfPairs(vector<string>& nums, string target) {
        unordered_map<string, int> freq;
        for (auto& x : nums) freq[x]++;

        int ans = 0;
        for (auto& [k, v] : freq) {
            if (target.substr(0, k.size()) == k) {
                string suffix = target.substr(k.size());
                ans += v * freq[suffix];
                if (k == suffix) ans -= freq[suffix];
            }
        }
        return ans;
    }


    /*2024. Maximize the Confusion of an Exam (Medium)
    A teacher is writing a test with n true/false questions, with 'T' denoting
    true and 'F' denoting false. He wants to confuse the students by maximizing
    the number of consecutive questions with the same answer (multiple trues or
    multiple falses in a row). You are given a string answerKey, where
    answerKey[i] is the original answer to the ith question. In addition, you
    are given an integer k, the maximum number of times you may perform the
    following operation:
    * Change the answer key for any question to 'T' or 'F' (i.e., set
      answerKey[i] to 'T' or 'F').
    Return the maximum number of consecutive 'T's or 'F's in the answer key
    after performing the operation at most k times.

    Example 1:
    Input: answerKey = "TTFF", k = 2
    Output: 4
    Explanation: We can replace both the 'F's with 'T's to make
                 answerKey = "TTTT". There are four consecutive 'T's.

    Example 2:
    Input: answerKey = "TFFT", k = 1
    Output: 3
    Explanation: We can replace the first 'T' with an 'F' to make
                 answerKey = "FFFT". Alternatively, we can replace the second
                 'T' with an 'F' to make answerKey = "TFFF". In both cases,
                 there are three consecutive 'F's.

    Example 3:
    Input: answerKey = "TTFTTFTT", k = 1
    Output: 5
    Explanation: We can replace the first 'F' to make answerKey = "TTTTTFTT"
                 Alternatively, we can replace the second 'F' to make
                 answerKey = "TTFTTTTT". In both cases, there are five
                 consecutive 'T's.

    Constraints:
    * n == answerKey.length
    * 1 <= n <= 5 * 10^4
    * answerKey[i] is either 'T' or 'F'
    * 1 <= k <= n*/

    int maxConsecutiveAnswers(string answerKey, int k) {

        auto fn = [&](char target) {
            int ans = 0;
            for (int i = 0, ii = 0, cnt = 0; i < answerKey.size(); ++i) {
                if (answerKey[i] == target) ++cnt;
                for (; cnt > k; ++ii)
                    if (answerKey[ii] == target) --cnt;
                ans = max(ans, i - ii + 1);
            }
            return ans;
        };

        return max(fn('T'), fn('F'));
    }


    /*2025. Maximum Number of Ways to Partition an Array (Hard)
    You are given a 0-indexed integer array nums of length n. The number of
    ways to partition nums is the number of pivot indices that satisfy both
    conditions:
    * 1 <= pivot < n
    * nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]
    You are also given an integer k. You can choose to change the value of one
    element of nums to k, or to leave the array unchanged. Return the maximum
    possible number of ways to partition nums to satisfy both conditions after
    changing at most one element.

    Example 1:
    Input: nums = [2,-1,2], k = 3
    Output: 1
    Explanation: One optimal approach is to change nums[0] to k. The array
                 becomes [3,-1,2]. There is one way to partition the array:
                 - For pivot = 2, we have the partition [3,-1 | 2]:
                   3 + -1 == 2.

    Example 2:
    Input: nums = [0,0,0], k = 1
    Output: 2
    Explanation: The optimal approach is to leave the array unchanged. There
                 are two ways to partition the array:
                 - For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.
                 - For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.

    Example 3:
    Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33
    Output: 4
    Explanation: One optimal approach is to change nums[2] to k. The array
                 becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14]. There
                 are four ways to partition the array.

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^5
    * -10^5 <= k, nums[i] <= 10^5*/

    int waysToPartition(vector<int>& nums, int k) {
        vector<long> prefix(1);
        unordered_map<long, vector<int>> mp;
        for (int i = 0; i < nums.size(); ++i) {
            prefix.push_back(prefix[i] + nums[i]);
            if (i < nums.size()-1) mp[prefix[i+1]].push_back(i);
        }

        int ans = 0;
        long total = prefix.back();
        if (total % 2 == 0) ans = mp[total/2].size();

        for (int i = 0; i < nums.size(); ++i) {
            int diff = k - nums[i], val = 0;
            long target = total + diff;
            if (target % 2 == 0) {
                target /= 2;
                val += lower_bound(mp[target].begin(), mp[target].end(), i) - mp[target].begin();
                val += mp[target-diff].size() - (lower_bound(mp[target-diff].begin(), mp[target-diff].end(), i) - mp[target-diff].begin());
            }
            ans = max(ans, val);
        }
        return ans;
    }


    /*2027. Minimum Moves to Convert String (Easy)
    You are given a string s consisting of n characters which are either 'X' or
    'O'. A move is defined as selecting three consecutive characters of s and
    converting them to 'O'. Note that if a move is applied to the character 'O',
    it will stay the same. Return the minimum number of moves required so that
    all the characters of s are converted to 'O'.

    Example 1:
    Input: s = "XXX"
    Output: 1
    Explanation: XXX -> OOO. We select all the 3 characters and convert them in
                 one move.

    Example 2:
    Input: s = "XXOX"
    Output: 2
    Explanation: XXOX -> OOOX -> OOOO. We select the first 3 characters in the
                 first move, and convert them to 'O'. Then we select the last 3
                 characters and convert them so that the final string contains
                 all 'O's.

    Example 3:
    Input: s = "OOOO"
    Output: 0
    Explanation: There are no 'X's in s to convert.

    Constraints:
    * 3 <= s.length <= 1000
    * s[i] is either 'X' or 'O'.*/

    int minimumMoves(string s) {
        int ans = 0;
        for (int i = 0; i < s.size(); ++i)
            if (s[i] == 'X')
                ++ans, i += 2;
        return ans;
    }


    /*2028. Find Missing Observations (Medium)
    You have observations of n + m 6-sided dice rolls with each face numbered
    from 1 to 6. n of the observations went missing, and you only have the
    observations of m rolls. Fortunately, you have also calculated the average
    value of the n + m rolls. You are given an integer array rolls of length m
    where rolls[i] is the value of the ith observation. You are also given the
    two integers mean and n. Return an array of length n containing the missing
    observations such that the average value of the n + m rolls is exactly mean.
    If there are multiple valid answers, return any of them. If no such array
    exists, return an empty array. The average value of a set of k numbers is
    the sum of the numbers divided by k. Note that mean is an integer, so the
    sum of the n + m rolls should be divisible by n + m.

    Example 1:
    Input: rolls = [3,2,4,3], mean = 4, n = 2
    Output: [6,6]
    Explanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.

    Example 2:
    Input: rolls = [1,5,6], mean = 3, n = 4
    Output: [2,3,2,2]
    Explanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.

    Example 3:
    Input: rolls = [1,2,3,4], mean = 6, n = 4
    Output: []
    Explanation: It is impossible for the mean to be 6 no matter what the 4
                 missing rolls are.

    Example 4:
    Input: rolls = [1], mean = 3, n = 1
    Output: [5]
    Explanation: The mean of all n + m rolls is (1 + 5) / 2 = 3.

    Constraints:
    * m == rolls.length
    * 1 <= n, m <= 10^5
    * 1 <= rolls[i], mean <= 6*/

    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {
        int m = rolls.size();
        int total = mean*(m+n) - accumulate(rolls.begin(), rolls.end(), 0);
        if (n <= total && total <= 6*n) {
            int q = total/n, r = total % n;
            vector<int> ans(n, q);
            fill(ans.begin(), ans.begin()+r, q+1);
            return ans;
        }
        return {};
    }


    /*2029. Stone Game IX (Medium)
    Alice and Bob continue their games with stones. There is a row of n stones,
    and each stone has an associated value. You are given an integer array
    stones, where stones[i] is the value of the ith stone. Alice and Bob take
    turns, with Alice starting first. On each turn, the player may remove any
    stone from stones. The player who removes a stone loses if the sum of the
    values of all removed stones is divisible by 3. Bob will win automatically
    if there are no remaining stones (even if it is Alice's turn). Assuming
    both players play optimally, return true if Alice wins and false if Bob
    wins.

    Example 1:
    Input: stones = [2,1]
    Output: true
    Explanation: The game will be played as follows:
                 - Turn 1: Alice can remove either stone.
                 - Turn 2: Bob removes the remaining stone.
                 The sum of the removed stones is 1 + 2 = 3 and is divisible by
                 3. Therefore, Bob loses and Alice wins the game.

    Example 2:
    Input: stones = [2]
    Output: false
    Explanation: Alice will remove the only stone, and the sum of the values on
                 the removed stones is 2. Since all the stones are removed and
                 the sum of values is not divisible by 3, Bob wins the game.

    Example 3:
    Input: stones = [5,1,2,4,3]
    Output: false
    Explanation: Bob will always win. One possible way for Bob to win is shown
                 below:
                 - Turn 1: Alice can remove the second stone with value 1. Sum
                   of removed stones = 1.
                 - Turn 2: Bob removes the fifth stone with value 3. Sum of
                   removed stones = 1 + 3 = 4.
                 - Turn 3: Alices removes the fourth stone with value 4. Sum of
                   removed stones = 1 + 3 + 4 = 8.
                 - Turn 4: Bob removes the third stone with value 2. Sum of
                   removed stones = 1 + 3 + 4 + 2 = 10.
                 - Turn 5: Alice removes the first stone with value 5. Sum of
                   removed stones = 1 + 3 + 4 + 2 + 5 = 15.
                 Alice loses the game because the sum of the removed stones (15)
                 is divisible by 3. Bob wins the game.

    Constraints:
    * 1 <= stones.length <= 10^5
    * 1 <= stones[i] <= 10^4*/

    bool stoneGameIX(vector<int>& stones) {
        unordered_map<int, int> freq;
        for (auto& x : stones) freq[x % 3]++;
        if (freq[0] & 1) return abs(freq[1] - freq[2]) >= 3;
        return freq[1] && freq[2];
    }


    /*2030. Smallest K-Length Subsequence With Occurrences of a Letter (Hard)
    You are given a string s, an integer k, a letter letter, and an integer
    repetition. Return the lexicographically smallest subsequence of s of
    length k that has the letter letter appear at least repetition times. The
    test cases are generated so that the letter appears in s at least
    repetition times. A subsequence is a string that can be derived from
    another string by deleting some or no characters without changing the order
    of the remaining characters. A string a is lexicographically smaller than a
    string b if in the first position where a and b differ, string a has a
    letter that appears earlier in the alphabet than the corresponding letter
    in b.

    Example 1:
    Input: s = "leet", k = 3, letter = "e", repetition = 1
    Output: "eet"
    Explanation: There are four subsequences of length 3 that have the letter
                 'e' appear at least 1 time:
                 - "lee" (from "leet")
                 - "let" (from "leet")
                 - "let" (from "leet")
                 - "eet" (from "leet")
                 The lexicographically smallest subsequence among them is "eet".

    Example 2:
    example-2
    Input: s = "leetcode", k = 4, letter = "e", repetition = 2
    Output: "ecde"
    Explanation: "ecde" is the lexicographically smallest subsequence of length
                 4 that has the letter "e" appear at least 2 times.

    Example 3:
    Input: s = "bb", k = 2, letter = "b", repetition = 2
    Output: "bb"
    Explanation: "bb" is the only subsequence of length 2 that has the letter
                 "b" appear at least 2 times.

    Constraints:
    * 1 <= repetition <= k <= s.length <= 5 * 10^4
    * s consists of lowercase English letters.
    * letter is a lowercase English letter, and appears in s at least
      repetition times.*/

    string smallestSubsequence(string s, int k, char letter, int repetition) {
        int rest = count(s.begin(), s.end(), letter);
        string ans;
        for (int i = 0, n = s.size(); i < n; ++i) {
            while (ans.size() && ans.back() > s[i] && ans.size() + n - i > k && (ans.back() != letter || repetition < rest)) {
                if (ans.back() == letter) repetition += 1;
                ans.pop_back();
            }
            if (ans.size() < k && (s[i] == letter || ans.size() + repetition < k)) {
                ans.push_back(s[i]);
                if (s[i] == letter) repetition -= 1;
            }
            if (s[i] == letter) --rest;
        }

        return ans;
    }


    /*2031. Count Subarrays With More Ones Than Zeros (Medium)
    You are given a binary array nums containing only the integers 0 and 1.
    Return the number of subarrays in nums that have more 1's than 0's. Since
    the answer may be very large, return it modulo 10^9 + 7. A subarray is a
    contiguous sequence of elements within an array.

    Example 1:
    Input: nums = [0,1,1,0,1]
    Output: 9
    Explanation: The subarrays of size 1 that have more ones than zeros are:
                 [1], [1], [1]. The subarrays of size 2 that have more ones
                 than zeros are: [1,1]. The subarrays of size 3 that have more
                 ones than zeros are: [0,1,1], [1,1,0], [1,0,1]. The subarrays
                 of size 4 that have more ones than zeros are: [1,1,0,1]. The
                 subarrays of size 5 that have more ones than zeros are:
                 [0,1,1,0,1].

    Example 2:
    Input: nums = [0]
    Output: 0
    Explanation: No subarrays have more ones than zeros.

    Example 3:
    Input: nums = [1]
    Output: 1
    Explanation: The subarrays of size 1 that have more ones than zeros are: [1].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1*/

    int subarraysWithMoreZerosThanOnes(vector<int>& nums) {
        unordered_map<int, int> freq = {{0, 1}};
        long ans = 0, dp = 0, prefix = 0;
        for (auto& x : nums) {
            if (x) dp += freq[prefix];
            else dp -= freq[prefix-1];
            ans = (ans + dp) % 1'000'000'007;
            prefix += 2*x-1;
            ++freq[prefix];
        }
        return ans;
    }


    /*2032. Two Out of Three (Easy)
    Given three integer arrays nums1, nums2, and nums3, return a distinct array
    containing all the values that are present in at least two out of the three
    arrays. You may return the values in any order.

    Example 1:
    Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]
    Output: [3,2]
    Explanation: The values that are present in at least two arrays are:
                 - 3, in all three arrays.
                 - 2, in nums1 and nums2.

    Example 2:
    Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]
    Output: [2,3,1]
    Explanation: The values that are present in at least two arrays are:
                 - 2, in nums2 and nums3.
                 - 3, in nums1 and nums2.
                 - 1, in nums1 and nums3.

    Example 3:
    Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]
    Output: []
    Explanation: No value is present in at least two arrays.

    Constraints:
    * 1 <= nums1.length, nums2.length, nums3.length <= 100
    * 1 <= nums1[i], nums2[j], nums3[k] <= 100*/

    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {
        unordered_map<int, int> freq;
        for (auto& nums : {nums1, nums2, nums3}) {
            unordered_set<int> st(nums.begin(), nums.end());
            for (auto& x : st) ++freq[x];
        }
        vector<int> ans;
        for (auto& [k, v] : freq)
            if (v >= 2) ans.push_back(k);
        return ans;
    }


    /*2033. Minimum Operations to Make a Uni-Value Grid (Medium)
    You are given a 2D integer grid of size m x n and an integer x. In one
    operation, you can add x to or subtract x from any element in the grid. A
    uni-value grid is a grid where all the elements of it are equal. Return the
    minimum number of operations to make the grid uni-value. If it is not
    possible, return -1.

    Example 1:
    Input: grid = [[2,4],[6,8]], x = 2
    Output: 4
    Explanation: We can make every element equal to 4 by doing the following:
                 - Add x to 2 once.
                 - Subtract x from 6 once.
                 - Subtract x from 8 twice.
                 A total of 4 operations were used.

    Example 2:
    Input: grid = [[1,5],[2,3]], x = 1
    Output: 5
    Explanation: We can make every element equal to 3.

    Example 3:
    Input: grid = [[1,2],[3,4]], x = 2
    Output: -1
    Explanation: It is impossible to make every element equal.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 1 <= x, grid[i][j] <= 10^4*/

    int minOperations(vector<vector<int>>& grid, int x) {
        vector<int> vals;
        for (auto& row : grid)
            for (auto& x : row)
                vals.push_back(x);

        for (auto& v : vals)
            if ((v - vals[0]) % x) return -1;

        sort(vals.begin(), vals.end());
        int ans = 0, median = vals[vals.size()/2];
        for (auto& v : vals) ans += abs(v - median)/x;
        return ans;
    }


    /*2035. Partition Array Into Two Arrays to Minimize Sum Difference (Hard)
    You are given an integer array nums of 2 * n integers. You need to
    partition nums into two arrays of length n to minimize the absolute
    difference of the sums of the arrays. To partition nums, put each element
    of nums into one of the two arrays. Return the minimum possible absolute
    difference.

    Example 1:
    Input: nums = [3,9,7,3]
    Output: 2
    Explanation: One optimal partition is: [3,9] and [7,3]. The absolute
                 difference between the sums of the arrays is
                 abs((3 + 9) - (7 + 3)) = 2.

    Example 2:
    Input: nums = [-36,36]
    Output: 72
    Explanation: One optimal partition is: [-36] and [36]. The absolute
                 difference between the sums of the arrays is
                 abs((-36) - (36)) = 72.

    Example 3:
    Input: nums = [2,-1,0,4,-2,-9]
    Output: 0
    Explanation: One optimal partition is: [2,4,-9] and [-1,0,-2]. The absolute
                 difference between the sums of the arrays is
                 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.

    Constraints:
    * 1 <= n <= 15
    * nums.length == 2 * n
    * -10^7 <= nums[i] <= 10^7*/

    int minimumDifference(vector<int>& nums) {
        int n = nums.size()/2;
        vector<int> left(nums.begin(), nums.begin()+n), right(nums.begin()+n, nums.begin()+2*n);

        vector<vector<int>> vals(n+1);
        for (int mask = 0; mask < (1<<n); ++mask) {
            int diff = 0, key = __builtin_popcount(mask);
            for (int i = 0; i < n; ++i)
                diff += (mask & (1 << i)) ? left[i] : -left[i];
            vals[key].push_back(diff);
        }

        for (auto& v : vals) sort(v.begin(), v.end());

        int ans = INT_MAX;
        for (int mask = 0; mask < (1<<n); ++mask) {
            int diff = 0, key = n - __builtin_popcount(mask);
            for (int i = 0; i < n; ++i)
                diff += (mask & (1 << i)) ? right[i] : -right[i];
            auto it = lower_bound(vals[key].begin(), vals[key].end(), -diff);
            if (it != vals[key].begin()) ans = min(ans, abs(diff + *prev(it)));
            if (it != vals[key].end()) ans = min(ans, abs(diff + *it));
        }
        return ans;
    }


    /*2036. Maximum Alternating Subarray Sum (Medium)
    A subarray of a 0-indexed integer array is a contiguous non-empty sequence
    of elements within an array. The alternating subarray sum of a subarray
    that ranges from index i to j (inclusive, 0 <= i <= j < nums.length) is
    nums[i] - nums[i+1] + nums[i+2] - ... +/- nums[j]. Given a 0-indexed
    integer array nums, return the maximum alternating subarray sum of any
    subarray of nums.

    Example 1:
    Input: nums = [3,-1,1,2]
    Output: 5
    Explanation: The subarray [3,-1,1] has the largest alternating subarray
                 sum. The alternating subarray sum is 3 - (-1) + 1 = 5.

    Example 2:
    Input: nums = [2,2,2,2,2]
    Output: 2
    Explanation: The subarrays [2], [2,2,2], and [2,2,2,2,2] have the largest
                 alternating subarray sum. The alternating subarray sum of [2]
                 is 2. The alternating subarray sum of [2,2,2] is 2 - 2 + 2 = 2.
                 The alternating subarray sum of [2,2,2,2,2] is
                 2 - 2 + 2 - 2 + 2 = 2.

    Example 3:
    Input: nums = [1]
    Output: 1
    Explanation: There is only one non-empty subarray, which is [1]. The
                 alternating subarray sum is 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^5 <= nums[i] <= 10^5*/

    long long maximumAlternatingSubarraySum(vector<int>& nums) {
        long long ans = LONG_MIN, pos = INT_MIN, neg = INT_MIN;
        for (auto& x : nums) {
            neg = max((long long) x, neg+x);
            pos -= x;
            swap(pos, neg);
            ans = max(ans, max(pos, neg));
        }
        return ans;
    }


    /*2037. Minimum Number of Moves to Seat Everyone (Easy)
    There are n seats and n students in a room. You are given an array seats of
    length n, where seats[i] is the position of the ith seat. You are also
    given the array students of length n, where students[j] is the position of
    the jth student. You may perform the following move any number of times:
    * Increase or decrease the position of the ith student by 1 (i.e., moving
      the ith student from position x to x + 1 or x - 1)
    * Return the minimum number of moves required to move each student to a
      seat such that no two students are in the same seat.
    Note that there may be multiple seats or students in the same position at
    the beginning.

    Example 1:
    Input: seats = [3,1,5], students = [2,7,4]
    Output: 4
    Explanation: The students are moved as follows:
                 - The first student is moved from from position 2 to position 1 using 1 move.
                 - The second student is moved from from position 7 to position 5 using 2 moves.
                 - The third student is moved from from position 4 to position 3 using 1 move.
                 In total, 1 + 2 + 1 = 4 moves were used.

    Example 2:
    Input: seats = [4,1,5,9], students = [1,3,2,6]
    Output: 7
    Explanation: The students are moved as follows:
                 - The first student is not moved.
                 - The second student is moved from from position 3 to position 4 using 1 move.
                 - The third student is moved from from position 2 to position 5 using 3 moves.
                 - The fourth student is moved from from position 6 to position 9 using 3 moves.
                 In total, 0 + 1 + 3 + 3 = 7 moves were used.

    Example 3:
    Input: seats = [2,2,6,6], students = [1,3,2,6]
    Output: 4
    Explanation: The students are moved as follows:
                 - The first student is moved from from position 1 to position 2 using 1 move.
                 - The second student is moved from from position 3 to position 6 using 3 moves.
                 - The third student is not moved.
                 - The fourth student is not moved.
                 In total, 1 + 3 + 0 + 0 = 4 moves were used.

    Constraints:
    * n == seats.length == students.length
    * 1 <= n <= 100
    * 1 <= seats[i], students[j] <= 100*/

    int minMovesToSeat(vector<int>& seats, vector<int>& students) {
        sort(seats.begin(), seats.end());
        sort(students.begin(), students.end());
        int ans = 0;
        for (int i = 0; i < seats.size(); ++i)
            ans += abs(seats[i] - students[i]);
        return ans;
    }


    /*2038. Remove Colored Pieces if Both Neighbors are the Same Color (Medium)
    There are n pieces arranged in a line, and each piece is colored either by
    'A' or by 'B'. You are given a string colors of length n where colors[i] is
    the color of the ith piece. Alice and Bob are playing a game where they
    take alternating turns removing pieces from the line. In this game, Alice
    moves first.
    * Alice is only allowed to remove a piece colored 'A' if both its neighbors
      are also colored 'A'. She is not allowed to remove pieces that are
      colored 'B'.
    * Bob is only allowed to remove a piece colored 'B' if both its neighbors
      are also colored 'B'. He is not allowed to remove pieces that are colored
      'A'.
    * Alice and Bob cannot remove pieces from the edge of the line.
    * If a player cannot make a move on their turn, that player loses and the
      other player wins.
    Assuming Alice and Bob play optimally, return true if Alice wins, or return
    false if Bob wins.

    Example 1:
    Input: colors = "AAABABB"
    Output: true
    Explanation: AAABABB -> AABABB
                 Alice moves first. She removes the second 'A' from the left
                 since that is the only 'A' whose neighbors are both 'A'. Now
                 it's Bob's turn. Bob cannot make a move on his turn since
                 there are no 'B's whose neighbors are both 'B'. Thus, Alice
                 wins, so return true.

    Example 2:
    Input: colors = "AA"
    Output: false
    Explanation: Alice has her turn first. There are only two 'A's and both are
                 on the edge of the line, so she cannot move on her turn. Thus,
                 Bob wins, so return false.

    Example 3:
    Input: colors = "ABBBBBBBAAA"
    Output: false
    Explanation: ABBBBBBBAAA -> ABBBBBBBAA
                 Alice moves first. Her only option is to remove the second to
                 last 'A' from the right.
                 ABBBBBBBAA -> ABBBBBBAA
                 Next is Bob's turn. He has many options for which 'B' piece to
                 remove. He can pick any. On Alice's second turn, she has no
                 more pieces that she can remove. Thus, Bob wins, so return
                 false.

    Constraints:
    * 1 <= colors.length <= 10^5
    * colors consists of only the letters 'A' and 'B'*/

    bool winnerOfGame(string colors) {
        int diff = 0;
        for (int i = 0; i < colors.size(); ++i)
            if (colors.substr(i, 3) == "AAA") ++diff;
            else if (colors.substr(i, 3) == "BBB") --diff;
        return diff > 0;
    }


    /*2039. The Time When the Network Becomes Idle (Medium)
    There is a network of n servers, labeled from 0 to n - 1. You are given a
    2D integer array edges, where edges[i] = [ui, vi] indicates there is a
    message channel between servers ui and vi, and they can pass any number of
    messages to each other directly in one second. You are also given a
    0-indexed integer array patience of length n. All servers are connected,
    i.e., a message can be passed from one server to any other server(s)
    directly or indirectly through the message channels. The server labeled 0
    is the master server. The rest are data servers. Each data server needs to
    send its message to the master server for processing and wait for a reply.
    Messages move between servers optimally, so every message takes the least
    amount of time to arrive at the master server. The master server will
    process all newly arrived messages instantly and send a reply to the
    originating server via the reversed path the message had gone through. At
    the beginning of second 0, each data server sends its message to be
    processed. Starting from second 1, at the beginning of every second, each
    data server will check if it has received a reply to the message it sent
    (including any newly arrived replies) from the master server:
    * If it has not, it will resend the message periodically. The data server
      i will resend the message every patience[i] second(s), i.e., the data
      server i will resend the message if patience[i] second(s) have elapsed
      since the last time the message was sent from this server.
    * Otherwise, no more resending will occur from this server.
    The network becomes idle when there are no messages passing between servers
    or arriving at servers. Return the earliest second starting from which the
    network becomes idle.

    Example 1:
    Input: edges = [[0,1],[1,2]], patience = [0,2,1]
    Output: 8
    Explanation: At (the beginning of) second 0,
                 - Data server 1 sends its message (denoted 1A) to the master server.
                 - Data server 2 sends its message (denoted 2A) to the master server.
                 At second 1,
                 - Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.
                 - Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.
                 - Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).
                 At second 2,
                 - The reply 1A arrives at server 1. No more resending will occur from server 1.
                 - Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.
                 - Server 2 resends the message (denoted 2C).
                 ...
                 At second 4,
                 - The reply 2A arrives at server 2. No more resending will occur from server 2.
                 ...
                 At second 7, reply 2D arrives at server 2.
                 Starting from the beginning of the second 8, there are no
                 messages passing between servers or arriving at servers. This
                 is the time when the network becomes idle.

    Example 2:
    Input: edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]
    Output: 3
    Explanation: Data servers 1 and 2 receive a reply back at the beginning of
                 second 2. From the beginning of the second 3, the network
                 becomes idle.

    Constraints:
    * n == patience.length
    * 2 <= n <= 10^5
    * patience[0] == 0
    * 1 <= patience[i] <= 10^5 for 1 <= i < n
    * 1 <= edges.length <= min(10^5, n * (n - 1) / 2)
    * edges[i].length == 2
    * 0 <= ui, vi < n
    * ui != vi
    * There are no duplicate edges.
    * Each server can directly or indirectly reach another server.*/

    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {
        int n = patience.size();
        vector<vector<int>> graph(n);
        for (auto& edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }

        vector<int> dist(n, -1);
        dist[0] = 0;
        queue<int> q; q.push(0);
        for (int val = 2; q.size(); val += 2)
            for (int sz = q.size(); sz; --sz) {
                int u = q.front(); q.pop();
                for (auto& v : graph[u])
                    if (dist[v] == -1) {
                        dist[v] = val;
                        q.push(v);
                    }
            }

        int ans = 0;
        for (int i = 0; i < n; ++i)
            if (patience[i]) {
                int k = dist[i]/patience[i];
                if (dist[i] % patience[i] == 0) k -= 1;
                ans = max(ans, dist[i] + k*patience[i]);
            }
        return ans + 1;
    }


    /*2040. Kth Smallest Product of Two Sorted Arrays (Hard)
    Given two sorted 0-indexed integer arrays nums1 and nums2 as well as an
    integer k, return the kth (1-based) smallest product of nums1[i] * nums2[j]
    where 0 <= i < nums1.length and 0 <= j < nums2.length.

    Example 1:
    Input: nums1 = [2,5], nums2 = [3,4], k = 2
    Output: 8
    Explanation: The 2 smallest products are:
                 - nums1[0] * nums2[0] = 2 * 3 = 6
                 - nums1[0] * nums2[1] = 2 * 4 = 8
                 The 2nd smallest product is 8.

    Example 2:
    Input: nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6
    Output: 0
    Explanation: The 6 smallest products are:
                 - nums1[0] * nums2[1] = (-4) * 4 = -16
                 - nums1[0] * nums2[0] = (-4) * 2 = -8
                 - nums1[1] * nums2[1] = (-2) * 4 = -8
                 - nums1[1] * nums2[0] = (-2) * 2 = -4
                 - nums1[2] * nums2[0] = 0 * 2 = 0
                 - nums1[2] * nums2[1] = 0 * 4 = 0
                 The 6th smallest product is 0.

    Example 3:
    Input: nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3
    Output: -6
    Explanation: The 3 smallest products are:
                 - nums1[0] * nums2[4] = (-2) * 5 = -10
                 - nums1[0] * nums2[3] = (-2) * 4 = -8
                 - nums1[4] * nums2[0] = 2 * (-3) = -6
                 The 3rd smallest product is -6.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 5 * 10^4
    * -10^5 <= nums1[i], nums2[j] <= 10^5
    * 1 <= k <= nums1.length * nums2.length
    * nums1 and nums2 are sorted.*/

    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {

        auto fn = [&](double val) {
            long long ans = 0;
            for (auto& x : nums1) {
                if (x < 0) ans += nums2.end() - lower_bound(nums2.begin(), nums2.end(), ceil(val/x));
                else if (x == 0) {
                    if (0 <= val) ans += nums2.size();
                } else ans += upper_bound(nums2.begin(), nums2.end(), floor(val/x)) - nums2.begin();
            }
            return ans;
        };

        long long lo = -pow(10, 10), hi = pow(10, 10)+1;
        while (lo < hi) {
            long long mid = lo + (hi - lo)/2;
            if (fn(mid) < k) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*2042. Check if Numbers Are Ascending in a Sentence (Easy)
    A sentence is a list of tokens separated by a single space with no leading
    or trailing spaces. Every token is either a positive number consisting of
    digits 0-9 with no leading zeros, or a word consisting of lowercase English
    letters. For example, "a puppy has 2 eyes 4 legs" is a sentence with seven
    tokens: "2" and "4" are numbers and the other tokens such as "puppy" are
    words. Given a string s representing a sentence, you need to check if all
    the numbers in s are strictly increasing from left to right (i.e., other
    than the last number, each number is strictly smaller than the number on
    its right in s). Return true if so, or false otherwise.

    Example 1:
    Input: s = "1 box has 3 blue 4 red 6 green and 12 yellow marbles"
    Output: true
    Explanation: The numbers in s are: 1, 3, 4, 6, 12. They are strictly
                 increasing from left to right: 1 < 3 < 4 < 6 < 12.

    Example 2:
    Input: s = "hello world 5 x 5"
    Output: false
    Explanation: The numbers in s are: 5, 5. They are not strictly increasing.

    Example 3:
    Input: s = "sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s"
    Output: false
    Explanation: The numbers in s are: 7, 51, 50, 60. They are not strictly increasing.

    Example 4:
    Input: s = "4 5 11 26"
    Output: true
    Explanation: The numbers in s are: 4, 5, 11, 26. They are strictly
                 increasing from left to right: 4 < 5 < 11 < 26.

    Constraints:
    * 3 <= s.length <= 200
    * s consists of lowercase English letters, spaces, and digits from 0 to 9,
      inclusive.
    * The number of tokens in s is between 2 and 100, inclusive.
    * The tokens in s are separated by a single space.
    * There are at least two numbers in s.
    * Each number in s is a positive number less than 100, with no leading
      zeros.
    * s contains no leading or trailing spaces.*/

    bool areNumbersAscending(string s) {
        istringstream iss(s);
        string buf;
        int prev = INT_MIN;
        while (iss >> buf)
            if(all_of(buf.begin(), buf.end(), [](auto& ch) {return isdigit(ch);})) {
                int curr = stoi(buf);
                if (prev >= curr) return false;
                prev = curr;
            }
        return true;
    }


    /*2044. Count Number of Maximum Bitwise-OR Subsets (Medium)
    Given an integer array nums, find the maximum possible bitwise OR of a
    subset of nums and return the number of different non-empty subsets with
    the maximum bitwise OR. An array a is a subset of an array b if a can be
    obtained from b by deleting some (possibly zero) elements of b. Two subsets
    are considered different if the indices of the elements chosen are
    different. The bitwise OR of an array a is equal to
    a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).

    Example 1:
    Input: nums = [3,1]
    Output: 2
    Explanation: The maximum possible bitwise OR of a subset is 3. There are 2
                 subsets with a bitwise OR of 3:
                 - [3]
                 - [3,1]

    Example 2:
    Input: nums = [2,2,2]
    Output: 7
    Explanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There
                 are 2^3 - 1 = 7 total subsets.

    Example 3:
    Input: nums = [3,2,1,5]
    Output: 6
    Explanation: The maximum possible bitwise OR of a subset is 7. There are 6
                 subsets with a bitwise OR of 7:
                 - [3,5]
                 - [3,1,5]
                 - [3,2,5]
                 - [3,2,1,5]
                 - [2,5]
                 - [2,1,5]

    Constraints:
    * 1 <= nums.length <= 16
    * 1 <= nums[i] <= 10^5*/

    int countMaxOrSubsets(vector<int>& nums) {
        int most = 0;
        unordered_map<int, int> mp = {{0, 1}};
        for (int x : nums) {
            most |= x;
            unordered_map<int, int> tmp = mp;
            for (auto& [k, v] : tmp) mp[x | k] += v;
        }
        return mp[most];
    }


    /*2045. Second Minimum Time to Reach Destination (Hard)
    A city is represented as a bi-directional connected graph with n vertices
    where each vertex is labeled from 1 to n (inclusive). The edges in the
    graph are represented as a 2D integer array edges, where each
    edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and
    vertex vi. Every vertex pair is connected by at most one edge, and no
    vertex has an edge to itself. The time taken to traverse any edge is time
    minutes. Each vertex has a traffic signal which changes its color from
    green to red and vice versa every change minutes. All signals change at the
    same time. You can enter a vertex at any time, but can leave a vertex only
    when the signal is green. You cannot wait at a vertex if the signal is
    green. The second minimum value is defined as the smallest value strictly
    larger than the minimum value. For example the second minimum value of
    [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4. Given n,
    edges, time, and change, return the second minimum time it will take to go
    from vertex 1 to vertex n.

    Notes:
    * You can go through any vertex any number of times, including 1 and n.
    * You can assume that when the journey starts, all signals have just turned
      green.

    Example 1:
    Input: n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
    Output: 13
    Explanation: The figure on the left shows the given graph. The blue path in
                 the figure on the right is the minimum time path. The time
                 taken is:
                 - Start at 1, time elapsed=0
                 - 1 -> 4: 3 minutes, time elapsed=3
                 - 4 -> 5: 3 minutes, time elapsed=6
                 Hence the minimum time needed is 6 minutes. The red path shows
                 the path to get the second minimum time.
                 - Start at 1, time elapsed=0
                 - 1 -> 3: 3 minutes, time elapsed=3
                 - 3 -> 4: 3 minutes, time elapsed=6
                 - Wait at 4 for 4 minutes, time elapsed=10
                 - 4 -> 5: 3 minutes, time elapsed=13
                 Hence the second minimum time is 13 minutes.

    Example 2:
    Input: n = 2, edges = [[1,2]], time = 3, change = 2
    Output: 11
    Explanation: The minimum time path is 1 -> 2 with time = 3 minutes. The
                 second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11
                 minutes.

    Constraints:
    * 2 <= n <= 10^4
    * n - 1 <= edges.length <= min(2 * 10^4, n * (n - 1) / 2)
    * edges[i].length == 2
    * 1 <= ui, vi <= n
    * ui != vi
    * There are no duplicate edges.
    * Each vertex can be reached directly or indirectly from every other vertex.
    * 1 <= time, change <= 10^3*/

    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        vector<vector<int>> graph(n);
        for (auto& edge : edges) {
            graph[edge[0]-1].push_back(edge[1]-1);
            graph[edge[1]-1].push_back(edge[0]-1);
        }

        int least = -1;
        queue<pair<int, int>> pq;
        pq.emplace(0, 0);
        vector<vector<int>> seen(n);

        while (pq.size()) {
            auto [t, u] = pq.front(); pq.pop();
            if (u == n-1) {
                if (least == -1) least = t;
                else if (least < t) return t;
            }
            if (t/change & 1) t = (t/change+1)*change;
            t += time;
            for (auto& v : graph[u])
                if (seen[v].empty() or (seen[v].size() == 1 and seen[v][0] != t)) {
                    seen[v].push_back(t);
                    pq.emplace(t, v);
                }
        }
        return -1;
    }


    /*2046. Sort Linked List Already Sorted Using Absolute Values (Medium)
    Given the head of a singly linked list that is sorted in non-decreasing
    order using the absolute values of its nodes, return the list sorted in
    non-decreasing order using the actual values of its nodes.

    Example 1:
    Input: head = [0,2,-5,5,10,-10]
    Output: [-10,-5,0,2,5,10]
    Explanation: The list sorted in non-descending order using the absolute
                 values of the nodes is [0,2,-5,5,10,-10]. The list sorted in
                 non-descending order using the actual values is
                 [-10,-5,0,2,5,10].

    Example 2:
    Input: head = [0,1,2]
    Output: [0,1,2]
    Explanation: The linked list is already sorted in non-decreasing order.

    Example 3:
    Input: head = [1]
    Output: [1]
    Explanation: The linked list is already sorted in non-decreasing order.

    Constraints:
    * The number of nodes in the list is the range [1, 10^5].
    * -5000 <= Node.val <= 5000
    * head is sorted in non-decreasing order using the absolute value of its
      nodes.

    Follow up: Can you think of a solution with O(n) time complexity?*/

    ListNode* sortLinkedList(ListNode* head) {
        ListNode *prev = head, *node = head->next;
        while (node)
            if (node->val < 0) {
                prev->next = node->next;
                node->next = head;
                head = node;
                node = prev->next;
            } else {
                prev = node;
                node = node->next;
            }
        return head;
    }


    /*2047. Number of Valid Words in a Sentence (Easy)
    A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'),
    hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only.
    Each sentence can be broken down into one or more tokens separated by one
    or more spaces ' '. A token is a valid word if:
    * It only contains lowercase letters, hyphens, and/or punctuation (no
      digits).
    * There is at most one hyphen '-'. If present, it should be surrounded by
      lowercase characters ("a-b" is valid, but "-ab" and "ab-" are not valid).
    * There is at most one punctuation mark. If present, it should be at the
      end of the token.
    Examples of valid words include "a-b.", "afad", "ba-c", "a!", and "!".
    Given a string sentence, return the number of valid words in sentence.

    Example 1:
    Input: sentence = "cat and  dog"
    Output: 3
    Explanation: The valid words in the sentence are "cat", "and", and "dog".

    Example 2:
    Input: sentence = "!this  1-s b8d!"
    Output: 0
    Explanation: There are no valid words in the sentence. "!this" is invalid
                 because it starts with a punctuation mark. "1-s" and "b8d" are
                 invalid because they contain digits.

    Example 3:
    Input: sentence = "alice and  bob are playing stone-game10"
    Output: 5
    Explanation: The valid words in the sentence are "alice", "and", "bob",
                 "are", and "playing". "stone-game10" is invalid because it
                 contains digits.

    Example 4:
    Input: sentence = "he bought 2 pencils, 3 erasers, and 1  pencil-sharpener."
    Output: 6
    Explanation: The valid words in the sentence are "he", "bought", "pencils,",
                 "erasers,", "and", and "pencil-sharpener.".

    Constraints:
    * 1 <= sentence.length <= 1000
    * sentence only contains lowercase English letters, digits, ' ', '-', '!',
      '.', and ','.
    * There will be at least 1 token.*/

    int countValidWords(string sentence) {
        regex pattern("(^[a-z]+(-[a-z]+)?)?[!,.]?$");

        int ans = 0;
        istringstream iss(sentence);
        string buf;
        while (iss >> buf)
            if (regex_match(buf, pattern)) ++ans;
        return ans;
    }


    /*2048. Next Greater Numerically Balanced Number (Medium)
    An integer x is numerically balanced if for every digit d in the number x,
    there are exactly d occurrences of that digit in x. Given an integer n,
    return the smallest numerically balanced number strictly greater than n.

    Example 1:
    Input: n = 1
    Output: 22
    Explanation: 22 is numerically balanced since:
                 - The digit 2 occurs 2 times.
                 It is also the smallest numerically balanced number strictly
                 greater than 1.

    Example 2:
    Input: n = 1000
    Output: 1333
    Explanation: 1333 is numerically balanced since:
                 - The digit 1 occurs 1 time.
                 - The digit 3 occurs 3 times.
                 It is also the smallest numerically balanced number strictly
                 greater than 1000. Note that 1022 cannot be the answer because
                 0 appeared more than 0 times.

    Example 3:
    Input: n = 3000
    Output: 3133
    Explanation: 3133 is numerically balanced since:
                 - The digit 1 occurs 1 time.
                 - The digit 3 occurs 3 times.
                 It is also the smallest numerically balanced number strictly
                 greater than 3000.

    Constraints: 0 <= n <= 10^6*/

    int nextBeautifulNumber(int n) {
        for (bool found = false; !found; ) {
            ++n;
            vector<int> freq(10);
            for (int x = n; x; x /= 10) ++freq[x % 10];
            found = true;
            for (int i = 0; i < 10; ++i)
                if (freq[i] && i != freq[i]) found = false;
        }
        return n;
    }


    /*2049. Count Nodes With the Highest Score (Medium)
    There is a binary tree rooted at 0 consisting of n nodes. The nodes are
    labeled from 0 to n - 1. You are given a 0-indexed integer array parents
    representing the tree, where parents[i] is the parent of node i. Since node
    0 is the root, parents[0] == -1. Each node has a score. To find the score
    of a node, consider if the node and the edges connected to it were removed.
    The tree would become one or more non-empty subtrees. The size of a subtree
    is the number of the nodes in it. The score of the node is the product of
    the sizes of all those subtrees. Return the number of nodes that have the
    highest score.

    Example 1:
    Input: parents = [-1,2,0,2,0]
    Output: 3
    Explanation: - The score of node 0 is: 3 * 1 = 3
                 - The score of node 1 is: 4 = 4
                 - The score of node 2 is: 1 * 1 * 2 = 2
                 - The score of node 3 is: 4 = 4
                 - The score of node 4 is: 4 = 4
                 The highest score is 4, and three nodes (node 1, node 3, and
                 ode 4) have the highest score.

    Example 2:
    Input: parents = [-1,2,0]
    Output: 2
    Explanation: - The score of node 0 is: 2 = 2
                 - The score of node 1 is: 2 = 2
                 - The score of node 2 is: 1 * 1 = 1
                 The highest score is 2, and two nodes (node 0 and node 1) have
                 the highest score.

    Constraints:
    * n == parents.length
    * 2 <= n <= 10^5
    * parents[0] == -1
    * 0 <= parents[i] <= n - 1 for i != 0
    * parents represents a valid binary tree.*/

    int countHighestScoreNodes(vector<int>& parents) {
        int n = parents.size();
        vector<vector<int>> tree(n);
        for (int i = 0; i < n; ++i)
            if (parents[i] >= 0) tree[parents[i]].push_back(i);

        map<long, int> freq;

        function<int(int)> fn = [&](int x) {
            long count = 1, score = 1;
            for (auto& xx : tree[x]) {
                int cc = fn(xx);
                count += cc;
                score *= cc;
            }
            score *= max(1l, n - count);
            ++freq[score];
            return count;
        };

        fn(0);
        return freq.rbegin()->second;
    }


    /*2050. Parallel Courses III (Hard)
    You are given an integer n, which indicates that there are n courses
    labeled from 1 to n. You are also given a 2D integer array relations where
    relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej
    has to be completed before course nextCoursej (prerequisite relationship).
    Furthermore, you are given a 0-indexed integer array time where time[i]
    denotes how many months it takes to complete the (i+1)th course. You must
    find the minimum number of months needed to complete all the courses
    following these rules:
    * You may start taking a course at any time if the prerequisites are met.
    * Any number of courses can be taken at the same time.
    Return the minimum number of months needed to complete all the courses.
    Note: The test cases are generated such that it is possible to complete
    every course (i.e., the graph is a directed acyclic graph).

    Example 1:
    Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]
    Output: 8
    Explanation: The figure above represents the given graph and the time
                 required to complete each course. We start course 1 and course
                 2 simultaneously at month 0. Course 1 takes 3 months and
                 course 2 takes 2 months to complete respectively. Thus, the
                 earliest time we can start course 3 is at month 3, and the
                 total time required is 3 + 5 = 8 months.

    Example 2:
    Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]
    Output: 12
    Explanation: The figure above represents the given graph and the time
                 required to complete each course. You can start courses 1, 2,
                 and 3 at month 0. You can complete them after 1, 2, and 3
                 months respectively. Course 4 can be taken only after course 3
                 is completed, i.e., after 3 months. It is completed after
                 3 + 4 = 7 months. Course 5 can be taken only after courses 1,
                 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7
                 months. Thus, the minimum time needed to complete all the
                 courses is 7 + 5 = 12 months.

    Constraints:
    * 1 <= n <= 5 * 10^4
    * 0 <= relations.length <= min(n * (n - 1) / 2, 5 * 10^4)
    * relations[j].length == 2
    * 1 <= prevCoursej, nextCoursej <= n
    * prevCoursej != nextCoursej
    * All the pairs [prevCoursej, nextCoursej] are unique.
    * time.length == n
    * 1 <= time[i] <= 10^4
    * The given graph is a directed acyclic graph.*/

    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {
        vector<vector<int>> graph(n);
        vector<int> indeg(n);

        for (auto& edge : relations) {
            graph[edge[0]-1].push_back(edge[1]-1);
            ++indeg[edge[1]-1];
        }

        queue<pair<int, int>> q;
        vector<int> start(n);
        for (int i = 0; i < n; ++i)
            if (indeg[i] == 0) q.emplace(time[i], i);

        int ans = 0;
        while (q.size()) {
            auto [t, u] = q.front(); q.pop();
            ans = max(ans, t);
            for (auto& v : graph[u]) {
                start[v] = max(start[v], t);
                if (--indeg[v] == 0) q.emplace(start[v] + time[v], v);
            }
        }
        return ans;
    }


    /*2052. Minimum Cost to Separate Sentence Into Rows (Medium)
    You are given a string sentence containing words separated by spaces, and
    an integer k. Your task is to separate sentence into rows where the number
    of characters in each row is at most k. You may assume that sentence does
    not begin or end with a space, and the words in sentence are separated by a
    single space. You can split sentence into rows by inserting line breaks
    between words in sentence. A word cannot be split between two rows. Each
    word must be used exactly once, and the word order cannot be rearranged.
    Adjacent words in a row should be separated by a single space, and rows
    should not begin or end with spaces. The cost of a row with length n is
    (k - n)2, and the total cost is the sum of the costs for all rows except
    the last one.
    * For example if sentence = "i love leetcode" and k = 12:
      + Separating sentence into "i", "love", and "leetcode" has a cost of
        (12 - 1)2 + (12 - 4)2 = 185.
      + Separating sentence into "i love", and "leetcode" has a cost of
        (12 - 6)2 = 36.
      + Separating sentence into "i", and "love leetcode" is not possible
        because the length of "love leetcode" is greater than k.
    Return the minimum possible total cost of separating sentence into rows.

    Example 1:
    Input: sentence = "i love leetcode", k = 12
    Output: 36
    Explanation: Separating sentence into "i", "love", and "leetcode" has a
                 cost of (12 - 1)^2 + (12 - 4)^2 = 185. Separating sentence
                 into "i love", and "leetcode" has a cost of (12 - 6)^2 = 36.
                 Separating sentence into "i", "love leetcode" is not possible
                 because "love leetcode" has length 13. 36 is the minimum
                 possible total cost so return it.

    Example 2:
    Input: sentence = "apples and bananas taste great", k = 7
    Output: 21
    Explanation: Separating sentence into "apples", "and", "bananas", "taste",
                 and "great" has a cost of
                 (7 - 6)^2 + (7 - 3)^2 + (7 - 7)^2 + (7 - 5)^2 = 21. 21 is the
                 minimum possible total cost so return it.

    Example 3:
    Input: sentence = "a", k = 5
    Output: 0
    Explanation: The cost of the last row is not included in the total cost,
                 and since there is only one row, return 0.

    Constraints:
    * 1 <= sentence.length <= 5000
    * 1 <= k <= 5000
    * The length of each word in sentence is at most k.
    * sentence consists of only lowercase English letters and spaces.
    * sentence does not begin or end with a space.
    * Words in sentence are separated by a single space.*/

    int minimumCost(string sentence, int k) {
        if (sentence.size() <= k) return 0;
        string buff;
        vector<string> words;
        istringstream iss(sentence);
        while (iss >> buff) words.push_back(buff);
        int n = words.size();
        vector<int> dp(n, INT_MAX);
        dp.back() = 0;
        for (int i = n-2; i >= 0; --i) {
            int prefix = -1;
            for (int j = i; j < n; ++j) {
                prefix += 1 + words[j].size();
                if (prefix <= k) dp[i] = j == n-1 ? 0 : min(dp[i], (k-prefix)*(k-prefix)+ dp[j+1]);
                else break;
            }
        }
        return dp[0];
    }


    /*2053. Kth Distinct String in an Array (Easy)
    A distinct string is a string that is present only once in an array. Given
    an array of strings arr, and an integer k, return the kth distinct string
    present in arr. If there are fewer than k distinct strings, return an empty
    string "". Note that the strings are considered in the order in which they
    appear in the array.

    Example 1:
    Input: arr = ["d","b","c","b","c","a"], k = 2
    Output: "a"
    Explanation: The only distinct strings in arr are "d" and "a".
                 "d" appears 1st, so it is the 1st distinct string.
                 "a" appears 2nd, so it is the 2nd distinct string.
                 Since k == 2, "a" is returned.

    Example 2:
    Input: arr = ["aaa","aa","a"], k = 1
    Output: "aaa"
    Explanation: All strings in arr are distinct, so the 1st string "aaa" is
                 returned.

    Example 3:
    Input: arr = ["a","b","a"], k = 3
    Output: ""
    Explanation: The only distinct string is "b". Since there are fewer than 3
                 distinct strings, we return an empty string "".

    Constraints:
    * 1 <= k <= arr.length <= 1000
    * 1 <= arr[i].length <= 5
    * arr[i] consists of lowercase English letters.*/

    string kthDistinct(vector<string>& arr, int k) {
        unordered_map<string, int> freq;
        for (auto& s : arr) ++freq[s];
        for (auto& s : arr)
            if (freq[s] == 1 && --k == 0)
                return s;
        return "";
    }


    /*2057. Smallest Index With Equal Value (Easy)
    Given a 0-indexed integer array nums, return the smallest index i of nums
    such that i mod 10 == nums[i], or -1 if such index does not exist. x mod y
    denotes the remainder when x is divided by y.

    Example 1:
    Input: nums = [0,1,2]
    Output: 0
    Explanation: i=0: 0 mod 10 = 0 == nums[0].
                 i=1: 1 mod 10 = 1 == nums[1].
                 i=2: 2 mod 10 = 2 == nums[2].
                 All indices have i mod 10 == nums[i], so we return the
                 smallest index 0.

    Example 2:
    Input: nums = [4,3,2,1]
    Output: 2
    Explanation: i=0: 0 mod 10 = 0 != nums[0].
                 i=1: 1 mod 10 = 1 != nums[1].
                 i=2: 2 mod 10 = 2 == nums[2].
                 i=3: 3 mod 10 = 3 != nums[3].
                 2 is the only index which has i mod 10 == nums[i].

    Example 3:
    Input: nums = [1,2,3,4,5,6,7,8,9,0]
    Output: -1
    Explanation: No index satisfies i mod 10 == nums[i].

    Example 4:
    Input: nums = [2,1,3,5,2]
    Output: 1
    Explanation: 1 is the only index with i mod 10 == nums[i].

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 9*/

    int smallestEqual(vector<int>& nums) {
        for (int i = 0; i < nums.size(); ++i)
            if (i % 10 == nums[i]) return i;
        return -1;
    }


    /*2058. Find the Minimum and Maximum Number of Nodes Between Critical Points (Medium)
    A critical point in a linked list is defined as either a local maxima or a
    local minima. A node is a local maxima if the current node has a value
    strictly greater than the previous node and the next node. A node is a
    local minima if the current node has a value strictly smaller than the
    previous node and the next node. Note that a node can only be a local
    maxima/minima if there exists both a previous node and a next node. Given a
    linked list head, return an array of length 2 containing
    [minDistance, maxDistance] where minDistance is the minimum distance
    between any two distinct critical points and maxDistance is the maximum
    distance between any two distinct critical points. If there are fewer than
    two critical points, return [-1, -1].

    Example 1:
    Input: head = [3,1]
    Output: [-1,-1]
    Explanation: There are no critical points in [3,1].

    Example 2:
    Input: head = [5,3,1,2,5,1,2]
    Output: [1,3]
    Explanation: There are three critical points:
                 - [5,3,1,2,5,1,2]: The third node is a local minima because 1
                   is less than 3 and 2.
                 - [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5
                   is greater than 2 and 1.
                 - [5,3,1,2,5,1,2]: The sixth node is a local minima because 1
                   is less than 5 and 2.
                 The minimum distance is between the fifth and the sixth node.
                 minDistance = 6 - 5 = 1. The maximum distance is between the
                 third and the sixth node. maxDistance = 6 - 3 = 3.

    Example 3:
    Input: head = [1,3,2,2,3,2,2,2,7]
    Output: [3,3]
    Explanation: There are two critical points:
                 - [1,3,2,2,3,2,2,2,7]: The second node is a local maxima
                   because 3 is greater than 1 and 2.
                 - [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima
                   because 3 is greater than 2 and 2.
                 Both the minimum and maximum distances are between the second
                 and the fifth node. Thus, minDistance and maxDistance is
                 5 - 2 = 3. Note that the last node is not considered a local
                 maxima because it does not have a next node.

    Example 4:
    Input: head = [2,3,3,2]
    Output: [-1,-1]
    Explanation: There are no critical points in [2,3,3,2].

    Constraints:
    * The number of nodes in the list is in the range [2, 10^5].
    * 1 <= Node.val <= 10^5*/

    vector<int> nodesBetweenCriticalPoints(ListNode* head) {
        int dmin = INT_MAX, last = 0, first = 0, prev = head->val, i = 1;
        for (ListNode* node = head->next; node && node->next; prev = node->val, node = node->next, ++i)
            if ((prev < node->val && node->val > node->next->val) || (prev > node->val && node->val < node->next->val)) {
                if (last) dmin = min(dmin, i - last);
                if (!first) first = i;
                last = i;
            }
        if (dmin < INT_MAX) return {dmin, last - first};
        return {-1, -1};
    }


    /*2059. Minimum Operations to Convert Number (Medium)
    You are given a 0-indexed integer array nums containing distinct numbers,
    an integer start, and an integer goal. There is an integer x that is
    initially set to start, and you want to perform operations on x such that
    it is converted to goal. You can perform the following operation repeatedly
    on the number x:

    If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length),
    you can set x to any of the following:
    * x + nums[i]
    * x - nums[i]
    * x ^ nums[i] (bitwise-XOR)
    Note that you can use each nums[i] any number of times in any order.
    Operations that set x to be out of the range 0 <= x <= 1000 are valid, but
    no more operations can be done afterward. Return the minimum number of
    operations needed to convert x = start into goal, and -1 if it is not
    possible.

    Example 1:
    Input: nums = [1,3], start = 6, goal = 4
    Output: 2
    Explanation: We can go from 6 → 7 → 4 with the following 2 operations.
                 - 6 ^ 1 = 7
                 - 7 ^ 3 = 4

    Example 2:
    Input: nums = [2,4,12], start = 2, goal = 12
    Output: 2
    Explanation: We can go from 2 → 14 → 12 with the following 2 operations.
                 - 2 + 12 = 14
                 - 14 - 2 = 12

    Example 3:
    Input: nums = [3,5,7], start = 0, goal = -4
    Output: 2
    Explanation: We can go from 0 → 3 → -4 with the following 2 operations.
                 - 0 + 3 = 3
                 - 3 - 7 = -4
                 Note that the last operation sets x out of the range
                 0 <= x <= 1000, which is valid.

    Example 4:
    Input: nums = [2,8,16], start = 0, goal = 1
    Output: -1
    Explanation: There is no way to convert 0 into 1.

    Example 5:
    Input: nums = [1], start = 0, goal = 3
    Output: 3
    Explanation: We can go from 0 → 1 → 2 → 3 with the following 3 operations.
                 - 0 + 1 = 1
                 - 1 + 1 = 2
                 - 2 + 1 = 3

    Constraints:
    * 1 <= nums.length <= 1000
    * -10^9 <= nums[i], goal <= 10^9
    * 0 <= start <= 1000
    * start != goal
    * All the integers in nums are distinct.*/

    int minimumOperations(vector<int>& nums, int start, int goal) {
        queue<int> q; q.push(start);
        bool visited[1001] = {false};
        for (int ans = 0; q.size(); ++ans)
            for (int sz = q.size(); sz; --sz) {
                int val = q.front(); q.pop();
                if (val == goal) return ans;
                if (0 <= val && val <= 1000 && !visited[val]) {
                    visited[val] = true;
                    for (auto& x : nums)
                        for (auto& cand : {val+x, val-x, val^x})
                            q.push(cand);
                }
            }
        return -1;
    }


    /*2060. Check if an Original String Exists Given Two Encoded Strings (Hard)
    An original string, consisting of lowercase English letters, can be encoded
    by the following steps:
    * Arbitrarily split it into a sequence of some number of non-empty substrings.
    * Arbitrarily choose some elements (possibly none) of the sequence, and
      replace each with its length (as a numeric string).
    * Concatenate the sequence as the encoded string.
    For example, one way to encode an original string "abcdefghijklmnop" might
    be:
    * Split it as a sequence: ["ab", "cdefghijklmn", "o", "p"].
    * Choose the second and third elements to be replaced by their lengths,
      respectively. The sequence becomes ["ab", "12", "1", "p"].
    * Concatenate the elements of the sequence to get the encoded string:
      "ab121p".
    Given two encoded strings s1 and s2, consisting of lowercase English
    letters and digits 1-9 (inclusive), return true if there exists an original
    string that could be encoded as both s1 and s2. Otherwise, return false.
    Note: The test cases are generated such that the number of consecutive
    digits in s1 and s2 does not exceed 3.

    Example 1:
    Input: s1 = "internationalization", s2 = "i18n"
    Output: true
    Explanation: It is possible that "internationalization" was the original
                 string.
                 - "internationalization"
                   -> Split:       ["internationalization"]
                   -> Do not replace any element
                   -> Concatenate:  "internationalization", which is s1.
                 - "internationalization"
                   -> Split:       ["i", "nternationalizatio", "n"]
                   -> Replace:     ["i", "18",                 "n"]
                   -> Concatenate:  "i18n", which is s2

    Example 2:
    Input: s1 = "l123e", s2 = "44"
    Output: true
    Explanation: It is possible that "leetcode" was the original string.
                 - "leetcode"
                   -> Split:      ["l", "e", "et", "cod", "e"]
                   -> Replace:    ["l", "1", "2",  "3",   "e"]
                   -> Concatenate: "l123e", which is s1.
                 - "leetcode"
                   -> Split:      ["leet", "code"]
                   -> Replace:    ["4",    "4"]
                   -> Concatenate: "44", which is s2.

    Example 3:
    Input: s1 = "a5b", s2 = "c5b"
    Output: false
    Explanation: It is impossible.
                 - The original string encoded as s1 must start with the letter 'a'.
                 - The original string encoded as s2 must start with the letter 'c'.

    Example 4:
    Input: s1 = "112s", s2 = "g841"
    Output: true
    Explanation: It is possible that "gaaaaaaaaaaaas" was the original string
                 - "gaaaaaaaaaaaas"
                   -> Split:      ["g", "aaaaaaaaaaaa", "s"]
                   -> Replace:    ["1", "12",           "s"]
                   -> Concatenate: "112s", which is s1.
                 - "gaaaaaaaaaaaas"
                   -> Split:      ["g", "aaaaaaaa", "aaaa", "s"]
                   -> Replace:    ["g", "8",        "4",    "1"]
                   -> Concatenate: "g841", which is s2.

    Example 5:
    Input: s1 = "ab", s2 = "a2"
    Output: false
    Explanation: It is impossible.
                 - The original string encoded as s1 has two letters.
                 - The original string encoded as s2 has three letters.

    Constraints:
    * 1 <= s1.length, s2.length <= 40
    * s1 and s2 consist of digits 1-9 (inclusive), and lowercase English
     l etters only.
    * The number of consecutive digits in s1 and s2 does not exceed 3.*/

    bool possiblyEquals(string s1, string s2) {
        int m = s1.size(), n = s2.size();

        auto gg = [](string s) {
            vector<int> ans = {stoi(s)};
            if (s.size() >= 2) ans.push_back(stoi(s.substr(0, 1)) + stoi(s.substr(1)));
            if (s.size() == 3) {
                ans.push_back(stoi(s.substr(0, 2)) + s[2] - '0');
                ans.push_back(s[0] - '0' + s[1] - '0' + s[2] - '0');
            }
            return ans;
        };

        int memo[41][41][2000] = {0};

        function<int(int, int, int)> fn = [&](int i, int j, int diff) {
            if (!memo[i][j][1000+diff]) {
                memo[i][j][1000+diff] = 1;
                if (i == m && j == n) {
                    if (diff == 0) memo[i][j][1000+diff] = 2;
                } else if (i < m && isdigit(s1[i])) {
                    int ii = i;
                    for (; ii < m && isdigit(s1[ii]); ++ii);
                    for (auto& x : gg(s1.substr(i, ii-i)))
                        if (fn(ii, j, diff-x) == 2) {
                            memo[i][j][1000+diff] = 2;
                            break;
                        }
                } else if (j < n && isdigit(s2[j])) {
                    int jj = j;
                    for (; jj < n && isdigit(s2[jj]); ++jj);
                    for (auto& x : gg(s2.substr(j, jj-j)))
                        if (fn(i, jj, diff+x) == 2) {
                            memo[i][j][1000+diff] = 2;
                            break;
                        }
                } else if (diff == 0) {
                    if (i < m && j < n && s1[i] == s2[j]) memo[i][j][1000+diff] = fn(i+1, j+1, 0);
                } else if (diff > 0) {
                    if (i < m) memo[i][j][1000+diff] = fn(i+1, j, diff-1);
                } else {
                    if (j < n) memo[i][j][1000+diff] = fn(i, j+1, diff+1);
                }
            }
            return memo[i][j][1000+diff];
        };

        return fn(0, 0, 0) == 2;
    }


    /*2061. Number of Spaces Cleaning Robot Cleaned (Medium)
    A room is represented by a 0-indexed 2D binary matrix room where a 0
    represents an empty space and a 1 represents a space with an object. The
    top left corner of the room will be empty in all test cases. A cleaning
    robot starts at the top left corner of the room and is facing right. The
    robot will continue heading straight until it reaches the edge of the room
    or it hits an object, after which it will turn 90 degrees clockwise and
    repeat this process. The starting space and all spaces that the robot
    visits are cleaned by it. Return the number of clean spaces in the room if
    the robot runs indefinetely.

    Example 1:
    Input: room = [[0,0,0],[1,1,0],[0,0,0]]
    Output: 7
    Explanation: The robot cleans the spaces at (0, 0), (0, 1), and (0, 2). The
                 robot is at the edge of the room, so it turns 90 degrees
                 clockwise and now faces down. The robot cleans the spaces at
                 (1, 2), and (2, 2). The robot is at the edge of the room, so
                 it turns 90 degrees clockwise and now faces left. The robot
                 cleans the spaces at (2, 1), and (2, 0). The robot has cleaned
                 all 7 empty spaces, so return 7.

    Example 2:
    Input: room = [[0,1,0],[1,0,0],[0,0,0]]
    Output: 1
    Explanation: The robot cleans the space at (0, 0). The robot hits an object,
                 so it turns 90 degrees clockwise and now faces down. The robot
                 hits an object, so it turns 90 degrees clockwise and now faces
                 left. The robot is at the edge of the room, so it turns 90
                 degrees clockwise and now faces up. The robot is at the edge
                 of the room, so it turns 90 degrees clockwise and now faces
                 right. The robot is back at its starting position. The robot
                 has cleaned 1 space, so return 1.

    Constraints:
    * m == room.length
    * n == room[r].length
    * 1 <= m, n <= 300
    * room[r][c] is either 0 or 1.
    * room[0][0] == 0*/

    int numberOfCleanRooms(vector<vector<int>>& room) {
        int m = room.size(), n = room[0].size(), ans = 0, dir[5] = {0, 1, 0, -1, 0};
        vector<vector<int>> seen(m, vector<int>(n));
        for (int i = 0, j = 0, k = 0; !(seen[i][j] & 1<<k); ) {
            if (room[i][j] == 0) {
                ++ans;
                room[i][j] = -1;
            }
            seen[i][j] |= 1<<k;
            int ii = i + dir[k], jj = j + dir[k+1];
            if (0 <= ii && ii < m && 0 <= jj && jj < n && room[ii][jj] != 1) tie(i, j) = make_pair(ii, jj);
            else k = (k+1) % 4;
        }
        return ans;
    }


    /*2062. Count Vowel Substrings of a String (Easy)
    A substring is a contiguous (non-empty) sequence of characters within a
    string. A vowel substring is a substring that only consists of vowels
    ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it. Given
    a string word, return the number of vowel substrings in word.

    Example 1:
    Input: word = "aeiouu"
    Output: 2
    Explanation: The vowel substrings of word are as follows (underlined):
                 - "aeiouu"
                 - "aeiouu"

    Example 2:
    Input: word = "unicornarihan"
    Output: 0
    Explanation: Not all 5 vowels are present, so there are no vowel substrings.

    Example 3:
    Input: word = "cuaieuouac"
    Output: 7
    Explanation: The vowel substrings of word are as follows (underlined):
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"

    Example 4:
    Input: word = "bbaeixoubb"
    Output: 0
    Explanation: The only substrings that contain all five vowels also contain
                 consonants, so there are no vowel substrings.

    Constraints:
    * 1 <= word.length <= 100
    * word consists of lowercase English letters only.*/

    int countVowelSubstrings(string word) {
        int ans = 0;
        vector<int> freq(5);
        unordered_map<char, int> mp = {{'a', 0}, {'e', 1}, {'i', 2}, {'o', 3}, {'u', 4}};
        for (int i = 0, jj = 0, j = 0; i < word.size(); ++i)
            if (mp.count(word[i])) {
                if (i == 0 || !mp.count(word[i-1])) {
                    jj = j = i;
                    fill(freq.begin(), freq.end(), 0);
                }
                ++freq[mp[word[i]]];
                while (all_of(freq.begin(), freq.end(), [](int x) {return x;})) --freq[mp[word[j++]]];
                ans += j - jj;
            }
        return ans;
    }


    /*2063. Vowels of All Substrings (Medium)
    Given a string word, return the sum of the number of vowels ('a', 'e', 'i',
    'o', and 'u') in every substring of word. A substring is a contiguous (non-
    empty) sequence of characters within a string. Note: Due to the large
    constraints, the answer may not fit in a signed 32-bit integer. Please be
    careful during the calculations.

    Example 1:
    Input: word = "aba"
    Output: 6
    Explanation: All possible substrings are: "a", "ab", "aba", "b", "ba", and
                 "a".
                 - "b" has 0 vowels in it
                 - "a", "ab", "ba", and "a" have 1 vowel each
                 - "aba" has 2 vowels in it
                 Hence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6.

    Example 2:
    Input: word = "abc"
    Output: 3
    Explanation: All possible substrings are: "a", "ab", "abc", "b", "bc", and
                 "c".
                 - "a", "ab", and "abc" have 1 vowel each
                 - "b", "bc", and "c" have 0 vowels each
                 Hence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3.

    Example 3:
    Input: word = "ltcd"
    Output: 0
    Explanation: There are no vowels in any substring of "ltcd".

    Example 4:
    Input: word = "noosabasboosa"
    Output: 237
    Explanation: There are a total of 237 vowels in all the substrings.

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists of lowercase English letters.*/

    long long countVowels(string word) {
        long ans = 0;
        string vowel = "aeiou";
        for (long i = 0; i < word.size(); ++i)
            if (vowel.find(word[i]) != string::npos)
                ans += (i+1)*(word.size()-i);
        return ans;
    }


    /*2064. Minimized Maximum of Products Distributed to Any Store (Medium)
    You are given an integer n indicating there are n specialty retail stores.
    There are m product types of varying amounts, which are given as a 0-
    indexed integer array quantities, where quantities[i] represents the number
    of products of the ith product type. You need to distribute all products to
    the retail stores following these rules:
    * A store can only be given at most one product type but can be given any
      amount of it.
    * After distribution, each store will be given some number of products
      (possibly 0). Let x represent the maximum number of products given to any
      store. You want x to be as small as possible, i.e., you want to minimize
      the maximum number of products that are given to any store.
    Return the minimum possible x.

    Example 1:
    Input: n = 6, quantities = [11,6]
    Output: 3
    Explanation: One optimal way is:
                 - The 11 products of type 0 are distributed to the first four
                   stores in these amounts: 2, 3, 3, 3
                 - The 6 products of type 1 are distributed to the other two
                   stores in these amounts: 3, 3
                 The maximum number of products given to any store is
                 max(2, 3, 3, 3, 3, 3) = 3.

    Example 2:
    Input: n = 7, quantities = [15,10,10]
    Output: 5
    Explanation: One optimal way is:
                 - The 15 products of type 0 are distributed to the first three
                   stores in these amounts: 5, 5, 5
                 - The 10 products of type 1 are distributed to the next two
                   stores in these amounts: 5, 5
                 - The 10 products of type 2 are distributed to the last two
                   stores in these amounts: 5, 5
                 The maximum number of products given to any store is
                 max(5, 5, 5, 5, 5, 5, 5) = 5.

    Example 3:
    Input: n = 1, quantities = [100000]
    Output: 100000
    Explanation: The only optimal way is:
                 - The 100000 products of type 0 are distributed to the only
                   store.
                 The maximum number of products given to any store is
                 max(100000) = 100000.

    Constraints:
    * m == quantities.length
    * 1 <= m <= n <= 10^5
    * 1 <= quantities[i] <= 10^5*/

    int minimizedMaximum(int n, vector<int>& quantities) {
        int lo = 1, hi = *max_element(quantities.begin(), quantities.end());
        while (lo < hi) {
            int mid = lo + (hi - lo)/2, cnt = 0;
            for (auto& qty : quantities) cnt += ceil((double) qty / mid);
            if (cnt <= n) hi = mid;
            else lo = mid + 1;
        }
        return lo;
    }


    /*2065. Maximum Path Quality of a Graph (Hard)
    There is an undirected graph with n nodes numbered from 0 to n - 1
    (inclusive). You are given a 0-indexed integer array values where values[i]
    is the value of the ith node. You are also given a 0-indexed 2D integer
    array edges, where each edges[j] = [uj, vj, timej] indicates that there is
    an undirected edge between the nodes uj and vj, and it takes timej seconds
    to travel between the two nodes. Finally, you are given an integer maxTime.
    A valid path in the graph is any path that starts at node 0, ends at node 0,
    and takes at most maxTime seconds to complete. You may visit the same node
    multiple times. The quality of a valid path is the sum of the values of the
    unique nodes visited in the path (each node's value is added at most once
    to the sum). Return the maximum quality of a valid path. Note: There are at
    most four edges connected to each node.

    Example 1:
    Input: values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49
    Output: 75
    Explanation: One possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time
                 taken is 10 + 10 + 10 + 10 = 40 <= 49. The nodes visited are
                 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.

    Example 2:
    Input: values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30
    Output: 25
    Explanation: One possible path is 0 -> 3 -> 0. The total time taken is
                 10 + 10 = 20 <= 30. The nodes visited are 0 and 3, giving a
                 maximal path quality of 5 + 20 = 25.

    Example 3:
    Input: values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50
    Output: 7
    Explanation: One possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time
                 taken is 10 + 13 + 13 + 10 = 46 <= 50. The nodes visited are
                 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.

    Example 4:
    Input: values = [0,1,2], edges = [[1,2,10]], maxTime = 10
    Output: 0
    Explanation: The only path is 0. The total time taken is 0. The only node
                 visited is 0, giving a maximal path quality of 0.

    Constraints:
    * n == values.length
    * 1 <= n <= 1000
    * 0 <= values[i] <= 10^8
    * 0 <= edges.length <= 2000
    * edges[j].length == 3
    * 0 <= uj < vj <= n - 1
    * 10 <= timej, maxTime <= 100
    * All the pairs [uj, vj] are unique.
    * There are at most four edges connected to each node.
    * The graph may not be connected.*/

    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {
        int n = values.size();
        vector<vector<pair<int, int>>> graph(n);
        for (auto& x : edges) {
            graph[x[0]].emplace_back(x[1], x[2]);
            graph[x[1]].emplace_back(x[0], x[2]);
        }

        int ans = 0;
        vector<int> freq(n); freq[0] = 1;

        function<void(int, int, int)> fn = [&](int u, int time, int val) {
            if (u == 0) ans = max(ans, val);
            for (auto& [v, t] : graph[u])
                if (time + t <= maxTime) {
                    if (++freq[v] == 1) fn(v, time+t, val + values[v]);
                    else fn(v, time+t, val);
                    --freq[v];
                }
        };

        fn(0, 0, values[0]);
        return ans;
    }


    /*2067. Number of Equal Count Substrings (Medium)
    You are given a 0-indexed string s consisting of only lowercase English
    letters, and an integer count. A substring of s is said to be an equal
    count substring if, for each unique letter in the substring, it appears
    exactly count times in the substring. Return the number of equal count
    substrings in s. A substring is a contiguous non-empty sequence of
    characters within a string.

    Example 1:
    Input: s = "aaabcbbcc", count = 3
    Output: 3
    Explanation: The substring that starts at index 0 and ends at index 2 is
                 "aaa". The letter 'a' in the substring appears exactly 3
                 times. The substring that starts at index 3 and ends at index
                 8 is "bcbbcc". The letters 'b' and 'c' in the substring appear
                 exactly 3 times. The substring that starts at index 0 and ends
                 at index 8 is "aaabcbbcc". The letters 'a', 'b', and 'c' in
                 the substring appear exactly 3 times.

    Example 2:
    Input: s = "abcd", count = 2
    Output: 0
    Explanation: The number of times each letter appears in s is less than
                 count. Therefore, no substrings in s are equal count
                 substrings, so return 0.

    Example 3:
    Input: s = "a", count = 5
    Output: 0
    Explanation: The number of times each letter appears in s is less than
                 count. Therefore, no substrings in s are equal count
                 substrings, so return 0

    Constraints:
    * 1 <= s.length <= 3 * 10^4
    * 1 <= count <= 3 * 10^4
    * s consists only of lowercase English letters.*/

    int equalCountSubstrings(string s, int count) {
        int ans = 0;
        for (int k = 1; k <= 26; ++k) {
            vector<int> freq(26);
            int uniq = 0;
            for (int i = 0; i < s.size(); ++i) {
                if (++freq[s[i]-'a'] == count) ++uniq;
                if (i >= k*count && freq[s[i-k*count]-'a']-- == count) --uniq;
                if (uniq == k) ++ans;
            }
        }
        return ans;
    }


    /*2068. Check Whether Two Strings are Almost Equivalent (Easy)
    Two strings word1 and word2 are considered almost equivalent if the
    differences between the frequencies of each letter from 'a' to 'z' between
    word1 and word2 is at most 3. Given two strings word1 and word2, each of
    length n, return true if word1 and word2 are almost equivalent, or false
    otherwise. The frequency of a letter x is the number of times it occurs in
    the string.

    Example 1:
    Input: word1 = "aaaa", word2 = "bccb"
    Output: false
    Explanation: There are 4 'a's in "aaaa" but 0 'a's in "bccb". The
                 difference is 4, which is more than the allowed 3.

    Example 2:
    Input: word1 = "abcdeef", word2 = "abaaacc"
    Output: true
    Explanation: The differences between the frequencies of each letter in
                 word1 and word2 are at most 3:
                 - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.
                 - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.
                 - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.
                 - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.
                 - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.
                 - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.

    Example 3:
    Input: word1 = "cccddabba", word2 = "babababab"
    Output: true
    Explanation: The differences between the frequencies of each letter in
                 word1 and word2 are at most 3:
                 - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.
                 - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.
                 - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.
                 - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.

    Constraints:
    * n == word1.length == word2.length
    * 1 <= n <= 100
    * word1 and word2 consist only of lowercase English letters.*/

    bool checkAlmostEquivalent(string word1, string word2) {
        vector<int> freq(26);
        for (auto& ch : word1) ++freq[ch-'a'];
        for (auto& ch : word2) --freq[ch-'a'];
        return all_of(freq.begin(), freq.end(), [](auto& x) {return abs(x) <= 3;});
    }


    /*2070. Most Beautiful Item for Each Query (Medium)
    You are given a 2D integer array items where items[i] = [pricei, beautyi]
    denotes the price and beauty of an item respectively. You are also given a
    0-indexed integer array queries. For each queries[j], you want to determine
    the maximum beauty of an item whose price is less than or equal to
    queries[j]. If no such item exists, then the answer to this query is 0.
    Return an array answer of the same length as queries where answer[j] is the
    answer to the jth query.

    Example 1:
    Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]
    Output: [2,4,5,5,6,6]
    Explanation: - For queries[0]=1, [1,2] is the only item which has price <= 1.
                   Hence, the answer for this query is 2.
                 - For queries[1]=2, the items which can be considered are [1,2]
                   and [2,4]. The maximum beauty among them is 4.
                 - For queries[2]=3 and queries[3]=4, the items which can be
                   considered are [1,2], [3,2], [2,4], and [3,5]. The maximum
                   beauty among them is 5.
                 - For queries[4]=5 and queries[5]=6, all items can be considered.
                   Hence, the answer for them is the maximum beauty of all items,
                   i.e., 6.

    Example 2:
    Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]
    Output: [4]
    Explanation: The price of every item is equal to 1, so we choose the item
                 with the maximum beauty 4. Note that multiple items can have
                 the same price and/or beauty.

    Example 3:
    Input: items = [[10,1000]], queries = [5]
    Output: [0]
    Explanation: No item has a price less than or equal to 5, so no item can be
                 chosen. Hence, the answer to the query is 0.

    Constraints:
    * 1 <= items.length, queries.length <= 10^5
    * items[i].length == 2
    * 1 <= pricei, beautyi, queries[j] <= 10^9*/

    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(items.begin(), items.end());
        vector<pair<int, int>> aug;
        for (int i = 0; i < queries.size(); ++i) aug.emplace_back(queries[i], i);
        sort(aug.begin(), aug.end());

        vector<int> ans(queries.size());
        int prefix = 0, ii = 0;
        for (auto& [x, i] : aug) {
            for (; ii < items.size() && items[ii][0] <= x; ++ii)
                prefix = max(prefix, items[ii][1]);
            ans[i] = prefix;
        }
        return ans;
    }


    /*2071. Maximum Number of Tasks You Can Assign (Hard)
    You have n tasks and m workers. Each task has a strength requirement stored
    in a 0-indexed integer array tasks, with the ith task requiring tasks[i]
    strength to complete. The strength of each worker is stored in a 0-indexed
    integer array workers, with the jth worker having workers[j] strength. Each
    worker can only be assigned to a single task and must have a strength
    greater than or equal to the task's strength requirement (i.e.,
    workers[j] >= tasks[i]). Additionally, you have pills magical pills that
    will increase a worker's strength by strength. You can decide which workers
    receive the magical pills, however, you may only give each worker at most
    one magical pill. Given the 0-indexed integer arrays tasks and workers and
    the integers pills and strength, return the maximum number of tasks that
    can be completed.

    Example 1:
    Input: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1
    Output: 3
    Explanation: We can assign the magical pill and tasks as follows:
                 - Give the magical pill to worker 0.
                 - Assign worker 0 to task 2 (0 + 1 >= 1)
                 - Assign worker 1 to task 1 (3 >= 2)
                 - Assign worker 2 to task 0 (3 >= 3)

    Example 2:
    Input: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5
    Output: 1
    Explanation: We can assign the magical pill and tasks as follows:
                 - Give the magical pill to worker 0.
                 - Assign worker 0 to task 0 (0 + 5 >= 5)

    Example 3:
    Input: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10
    Output: 2
    Explanation: We can assign the magical pills and tasks as follows:
                 - Give the magical pill to worker 0 and worker 1.
                 - Assign worker 0 to task 0 (0 + 10 >= 10)
                 - Assign worker 1 to task 1 (10 + 10 >= 15)

    Example 4:
    Input: tasks = [5,9,8,5,9], workers = [1,6,4,2,6], pills = 1, strength = 5
    Output: 3
    Explanation: We can assign the magical pill and tasks as follows:
                 - Give the magical pill to worker 2.
                 - Assign worker 1 to task 0 (6 >= 5)
                 - Assign worker 2 to task 2 (4 + 5 >= 8)
                 - Assign worker 4 to task 3 (6 >= 5)

    Constraints:
    * n == tasks.length
    * m == workers.length
    * 1 <= n, m <= 5 * 10^4
    * 0 <= pills <= m
    * 0 <= tasks[i], workers[j], strength <= 10^9*/

    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {
        sort(tasks.begin(), tasks.end());
        sort(workers.begin(), workers.end());

        auto fn = [&](int k) {
            int p = pills;
            multiset<int> st(workers.end()-k, workers.end());
            for (int i = k-1; i >= 0; --i) {
                int task = tasks[i];
                if (task <= *(st.rbegin())) st.erase(prev(st.end()));
                else if (task <= *st.rbegin() + strength && p) {
                    --p;
                    auto it = st.lower_bound(task - strength);
                    st.erase(it);
                }
                else return false;
            }
            return true;
        };

        int lo = 0, hi = min((int)tasks.size(), (int)workers.size());
        while (lo < hi) {
            int mid = lo + (hi - lo + 1)/2;
            if (fn(mid)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }


    /*2073. Time Needed to Buy Tickets (Easy)
    There are n people in a line queuing to buy tickets, where the 0th person
    is at the front of the line and the (n - 1)th person is at the back of the
    line. You are given a 0-indexed integer array tickets of length n where the
    number of tickets that the ith person would like to buy is tickets[i]. Each
    person takes exactly 1 second to buy a ticket. A person can only buy 1
    ticket at a time and has to go back to the end of the line (which happens
    instantaneously) in order to buy more tickets. If a person does not have
    any tickets left to buy, the person will leave the line. Return the time
    taken for the person at position k (0-indexed) to finish buying tickets.

    Example 1:
    Input: tickets = [2,3,2], k = 2
    Output: 6
    Explanation: - In the first pass, everyone in the line buys a ticket and
                   the line becomes [1, 2, 1].
                 - In the second pass, everyone in the line buys a ticket and
                   the line becomes [0, 1, 0].
                 The person at position 2 has successfully bought 2 tickets and
                 it took 3 + 3 = 6 seconds.

    Example 2:
    Input: tickets = [5,1,1,1], k = 0
    Output: 8
    Explanation: - In the first pass, everyone in the line buys a ticket and
                   the line becomes [4, 0, 0, 0].
                 - In the next 4 passes, only the person in position 0 is
                   buying tickets.
                 The person at position 0 has successfully bought 5 tickets and
                 it took 4 + 1 + 1 + 1 + 1 = 8 seconds.

    Constraints:
    * n == tickets.length
    * 1 <= n <= 100
    * 1 <= tickets[i] <= 100
    * 0 <= k < n*/

    int timeRequiredToBuy(vector<int>& tickets, int k) {
        int ans = 0, behind = 0;
        for (int i = 0; i < tickets.size(); ++i) {
            if (i > k) behind = 1;
            if (tickets[i] < tickets[k] - behind) ans += tickets[i];
            else ans += tickets[k] - behind;
        }
        return ans;
    }


    /*2074. Reverse Nodes in Even Length Groups (Medium)
    You are given the head of a linked list. The nodes in the linked list are
    sequentially assigned to non-empty groups whose lengths form the sequence
    of the natural numbers (1, 2, 3, 4, ...). The length of a group is the
    number of nodes assigned to it. In other words,
    * The 1st node is assigned to the first group.
    * The 2nd and the 3rd nodes are assigned to the second group.
    * The 4th, 5th, and 6th nodes are assigned to the third group, and so on.
    Note that the length of the last group may be less than or equal to
    1 + the length of the second to last group. Reverse the nodes in each group
    with an even length, and return the head of the modified linked list.

    Example 1:
    Input: head = [5,2,6,3,9,1,7,3,8,4]
    Output: [5,6,2,3,9,1,4,8,3,7]
    Explanation:
    - The length of the first group is 1, which is odd, hence no reversal occurrs.
    - The length of the second group is 2, which is even, hence the nodes are reversed.
    - The length of the third group is 3, which is odd, hence no reversal occurrs.
    - The length of the last group is 4, which is even, hence the nodes are reversed.

    Example 2:
    Input: head = [1,1,0,6]
    Output: [1,0,1,6]
    Explanation:
    - The length of the first group is 1. No reversal occurrs.
    - The length of the second group is 2. The nodes are reversed.
    - The length of the last group is 1. No reversal occurrs.

    Example 3:
    Input: head = [2,1]
    Output: [2,1]
    Explanation:
    - The length of the first group is 1. No reversal occurrs.
    - The length of the last group is 1. No reversal occurrs.

    Example 4:
    Input: head = [8]
    Output: [8]
    Explanation: There is only one group whose length is 1. No reversal occurrs.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5].
    * 0 <= Node.val <= 10^5*/

    ListNode* reverseEvenLengthGroups(ListNode* head) {
        int n = 0;
        for (ListNode* node = head; node; node = node->next, ++n);

        ListNode* node = head;
        for (int k = 1; n; ++k) {
            int size = min(k, n);
            stack<int> stk;
            if (size % 2 == 0) {
                ListNode* temp = node;
                for (int i = 0; i < size; ++i) {
                    stk.push(temp->val);
                    temp = temp->next;
                }
            }
            for (int i = 0; i < size; ++i) {
                if (stk.size()) node->val = stk.top(), stk.pop();
                node = node->next;
            }
            n -= size;
        }


        return head;
    }


    /*2075. Decode the Slanted Ciphertext (Medium)
    A string originalText is encoded using a slanted transposition cipher to a
    string encodedText with the help of a matrix having a fixed number of rows
    rows. originalText is placed first in a top-left to bottom-right manner.
    The blue cells are filled first, followed by the red cells, then the yellow
    cells, and so on, until we reach the end of originalText. The arrow
    indicates the order in which the cells are filled. All empty cells are
    filled with ' '. The number of columns is chosen such that the rightmost
    column will not be empty after filling in originalText. encodedText is then
    formed by appending all characters of the matrix in a row-wise fashion. The
    characters in the blue cells are appended first to encodedText, then the
    red cells, and so on, and finally the yellow cells. The arrow indicates the
    order in which the cells are accessed. For example, if
    originalText = "cipher" and rows = 3, then we encode it in the following
    manner:
    The blue arrows depict how originalText is placed in the matrix, and the
    red arrows denote the order in which encodedText is formed. In the above
    example, encodedText = "ch ie pr". Given the encoded string encodedText and
    number of rows rows, return the original string originalText. Note:
    originalText does not have any trailing spaces ' '. The test cases are
    generated such that there is only one possible originalText.

    Example 1:
    Input: encodedText = "ch   ie   pr", rows = 3
    Output: "cipher"
    Explanation: This is the same example described in the problem description.

    Example 2:
    Input: encodedText = "iveo    eed   l te   olc", rows = 4
    Output: "i love leetcode"
    Explanation: The figure above denotes the matrix that was used to encode
                 originalText. The blue arrows show how we can find
                 originalText from encodedText.

    Example 3:
    Input: encodedText = "coding", rows = 1
    Output: "coding"
    Explanation: Since there is only 1 row, both originalText and encodedText
                 are the same.

    Example 4:
    Input: encodedText = " b  ac", rows = 2
    Output: " abc"
    Explanation: originalText cannot have trailing spaces, but it may be
                 preceded by one or more spaces.

    Constraints:
    * 0 <= encodedText.length <= 10^6
    * encodedText consists of lowercase English letters and ' ' only.
    * encodedText is a valid encoding of some originalText that does not have
      trailing spaces.
    * 1 <= rows <= 1000
    * The testcases are generated such that there is only one possible
      originalText.*/

    string decodeCiphertext(string encodedText, int rows) {
        int cols = encodedText.size() / rows;
        vector<vector<char>> mat(rows, vector<char>(cols));
        for (int i = 0, k = 0; i < rows; ++i)
            for (int j = 0; j < cols; ++j, ++k)
                if (k < encodedText.size())
                    mat[i][j] = encodedText[k];
        string ans;
        for (int offset = 0; offset < cols; ++offset)
            for (int i = 0, j = offset;  i < rows && j < cols; ++i, ++j)
                ans.push_back(mat[i][j]);
        return ans.substr(0, 1+ans.find_last_not_of(' '));
    }


    /*2076. Process Restricted Friend Requests (Hard)
    You are given an integer n indicating the number of people in a network.
    Each person is labeled from 0 to n - 1. You are also given a 0-indexed 2D
    integer array restrictions, where restrictions[i] = [xi, yi] means that
    person xi and person yi cannot become friends, either directly or
    indirectly through other people. Initially, no one is friends with each
    other. You are given a list of friend requests as a 0-indexed 2D integer
    array requests, where requests[j] = [uj, vj] is a friend request between
    person uj and person vj. A friend request is successful if uj and vj can be
    friends. Each friend request is processed in the given order (i.e.,
    requests[j] occurs before requests[j + 1]), and upon a successful request,
    uj and vj become direct friends for all future friend requests. Return a
    boolean array result, where each result[j] is true if the jth friend
    request is successful or false if it is not. Note: If uj and vj are already
    direct friends, the request is still successful.

    Example 1:
    Input: n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]
    Output: [true,false]
    Explanation: Request 0: Person 0 and person 2 can be friends, so they
                 become direct friends. Request 1: Person 2 and person 1 cannot
                 be friends since person 0 and person 1 would be indirect
                 friends (1--2--0).

    Example 2:
    Input: n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]
    Output: [true,false]
    Explanation: Request 0: Person 1 and person 2 can be friends, so they
                 become direct friends. Request 1: Person 0 and person 2 cannot
                 be friends since person 0 and person 1 would be indirect
                 friends (0--2--1).

    Example 3:
    Input: n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]
    Output: [true,false,true,false]
    Explanation: Request 0: Person 0 and person 4 can be friends, so they
                 become direct friends. Request 1: Person 1 and person 2 cannot
                 be friends since they are directly restricted. Request 2:
                 Person 3 and person 1 can be friends, so they become direct
                 friends. Request 3: Person 3 and person 4 cannot be friends
                 since person 0 and person 1 would be indirect friends
                 (0--4--3--1).

    Constraints:
    * 2 <= n <= 1000
    * 0 <= restrictions.length <= 1000
    * restrictions[i].length == 2
    * 0 <= xi, yi <= n - 1
    * xi != yi
    * 1 <= requests.length <= 1000
    * requests[j].length == 2
    * 0 <= uj, vj <= n - 1
    * uj != vj*/

    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {
        vector<bool> ans;
        UnionFind *uf = new UnionFind(n);
        for (auto& request : requests) {
            int u = uf->find(request[0]), v = uf->find(request[1]);
            bool found = false;
            for (auto& restriction : restrictions) {
                int x = uf->find(restriction[0]), y = uf->find(restriction[1]);
                if ((u == x && v == y) || (u == y && v == x)) {
                    found = true;
                    break;
                }
            }
            ans.push_back(!found);
            if (!found) uf->connect(u, v);
        }
        delete uf;
        return ans;
    }


    /*2077. Paths in Maze That Lead to Same Room (Medium)
    A maze consists of n rooms numbered from 1 to n, and some rooms are
    connected by corridors. You are given a 2D integer array corridors where
    corridors[i] = [room1i, room2i] indicates that there is a corridor
    connecting room1i and room2i, allowing a person in the maze to go from
    room1i to room2i and vice versa. The designer of the maze wants to know how
    confusing the maze is. The confusion score of the maze is the number of
    different cycles of length 3.
    * For example, 1 → 2 → 3 → 1 is a cycle of length 3, but 1 → 2 → 3 → 4 and
      1 → 2 → 3 → 2 → 1 are not.
    Two cycles are considered to be different if one or more of the rooms
    visited in the first cycle is not in the second cycle. Return the confusion
    score of the maze.

    Example 1:
    Input: n = 5, corridors = [[1,2],[5,2],[4,1],[2,4],[3,1],[3,4]]
    Output: 2
    Explanation: One cycle of length 3 is 4 → 1 → 3 → 4, denoted in red. Note
                 that this is the same cycle as 3 → 4 → 1 → 3 or 1 → 3 → 4 → 1
                 because the rooms are the same. Another cycle of length 3 is
                 1 → 2 → 4 → 1, denoted in blue. Thus, there are two different
                 cycles of length 3.

    Example 2:
    Input: n = 4, corridors = [[1,2],[3,4]]
    Output: 0
    Explanation: There are no cycles of length 3.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= corridors.length <= 5 * 10^4
    * corridors[i].length == 2
    * 1 <= room1i, room2i <= n
    * room1i != room2i
    * There are no duplicate corridors.*/

    int numberOfPaths(int n, vector<vector<int>>& corridors) {
        vector<unordered_set<int>> graph(n);
        for (auto& c : corridors) {
            graph[c[0]-1].insert(c[1]-1);
            graph[c[1]-1].insert(c[0]-1);
        }
        int ans = 0;
        for (auto& c : corridors)
            for (auto& u : graph[c[0]-1])
                if (graph[c[1]-1].count(u)) ++ans;
        return ans/3;
    }


    /*2078. Two Furthest Houses With Different Colors (Easy)
    There are n houses evenly lined up on the street, and each house is
    beautifully painted. You are given a 0-indexed integer array colors of
    length n, where colors[i] represents the color of the ith house. Return the
    maximum distance between two houses with different colors. The distance
    between the ith and jth houses is abs(i - j), where abs(x) is the absolute
    value of x.

    Example 1:
    Input: colors = [1,1,1,6,1,1,1]
    Output: 3
    Explanation: In the above image, color 1 is blue, and color 6 is red. The
                 furthest two houses with different colors are house 0 and
                 house 3. House 0 has color 1, and house 3 has color 6. The
                 distance between them is abs(0 - 3) = 3. Note that houses 3
                 and 6 can also produce the optimal answer.

    Example 2:
    Input: colors = [1,8,3,8,3]
    Output: 4
    Explanation: In the above image, color 1 is blue, color 8 is yellow, and
                 color 3 is green. The furthest two houses with different
                 colors are house 0 and house 4. House 0 has color 1, and house
                 4 has color 3. The distance between them is abs(0 - 4) = 4.

    Example 3:
    Input: colors = [0,1]
    Output: 1
    Explanation: The furthest two houses with different colors are house 0 and
                 house 1. House 0 has color 0, and house 1 has color 1. The
                 distance between them is abs(0 - 1) = 1.

    Constraints:
    * n == colors.length
    * 2 <= n <= 100
    * 0 <= colors[i] <= 100
    * Test data are generated such that at least two houses have different
      colors.*/

    int maxDistance(vector<int>& colors) {
        int ans = 0, n = colors.size();
        for (int i = 0; i < n; ++i) {
            if (colors.front() != colors[i]) ans = max(ans, i);
            if (colors[i] != colors.back()) ans = max(ans, n-1-i);
        }
        return ans;
    }


    /*2079. Watering Plants (Medium)
    You want to water n plants in your garden with a watering can. The plants
    are arranged in a row and are labeled from 0 to n - 1 from left to right
    where the ith plant is located at x = i. There is a river at x = -1 that
    you can refill your watering can at. Each plant needs a specific amount of
    water. You will water the plants in the following way:
    * Water the plants in order from left to right.
    * After watering the current plant, if you do not have enough water to
      completely water the next plant, return to the river to fully refill the
      watering can.
    * You cannot refill the watering can early.
    You are initially at the river (i.e., x = -1). It takes one step to move
    one unit on the x-axis. Given a 0-indexed integer array plants of n
    integers, where plants[i] is the amount of water the ith plant needs, and
    an integer capacity representing the watering can capacity, return the
    number of steps needed to water all the plants.

    Example 1:
    Input: plants = [2,2,3,3], capacity = 5
    Output: 14
    Explanation: Start at the river with a full watering can:
    - Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.
    - Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.
    - Since you cannot completely water plant 2, walk back to the river to refill (2 steps).
    - Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.
    - Since you cannot completely water plant 3, walk back to the river to refill (3 steps).
    - Walk to plant 3 (4 steps) and water it.
    Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.

    Example 2:
    Input: plants = [1,1,1,4,2,3], capacity = 4
    Output: 30
    Explanation: Start at the river with a full watering can:
    - Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).
    - Water plant 3 (4 steps). Return to river (4 steps).
    - Water plant 4 (5 steps). Return to river (5 steps).
    - Water plant 5 (6 steps).
    Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.

    Example 3:
    Input: plants = [7,7,7,7,7,7,7], capacity = 8
    Output: 49
    Explanation: You have to refill before watering each plant. Steps needed
                 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.

    Constraints:
    * n == plants.length
    * 1 <= n <= 1000
    * 1 <= plants[i] <= 10^6
    * max(plants[i]) <= capacity <= 10^9*/

    int wateringPlants(vector<int>& plants, int capacity) {
        int ans = 0, can = capacity;
        for (int i = 0; i < plants.size(); ++i, ++ans) {
            if (can < plants[i]) ans += 2*i, can = capacity;
            can -= plants[i];
        }
        return ans;
    }


    /*2081. Sum of k-Mirror Numbers (Hard)
    A k-mirror number is a positive integer without leading zeros that reads
    the same both forward and backward in base-10 as well as in base-k. For
    example, 9 is a 2-mirror number. The representation of 9 in base-10 and
    base-2 are 9 and 1001 respectively, which read the same both forward and
    backward. On the contrary, 4 is not a 2-mirror number. The representation
    of 4 in base-2 is 100, which does not read the same both forward and
    backward. Given the base k and the number n, return the sum of the n
    smallest k-mirror numbers.

    Example 1:
    Input: k = 2, n = 5
    Output: 25
    Explanation: The 5 smallest 2-mirror numbers and their representations in
                 base-2 are listed as follows:
                   base-10    base-2
                     1          1
                     3          11
                     5          101
                     7          111
                     9          1001
                 Their sum = 1 + 3 + 5 + 7 + 9 = 25.

    Example 2:
    Input: k = 3, n = 7
    Output: 499
    Explanation: The 7 smallest 3-mirror numbers are and their representations
                 in base-3 are listed as follows:
                   base-10    base-3
                     1          1
                     2          2
                     4          11
                     8          22
                     121        11111
                     151        12121
                     212        21212
                 Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.

    Example 3:
    Input: k = 7, n = 17
    Output: 20379000
    Explanation: The 17 smallest 7-mirror numbers are: 1, 2, 3, 4, 5, 6, 8, 121,
                 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596

    Constraints:
    * 2 <= k <= 9
    * 1 <= n <= 30*/

    long long kMirror(int k, int n) {

        auto palin = [](int n, bool odd) {
            long long ans = n;
            if (odd) n /= 10;
            for (; n; n /= 10) ans = 10*ans + n % 10;
            return ans;
        };

        auto is_mirror = [&](long long x) {
            long long rev = 0;
            for (auto tmp = x; tmp; tmp /= k) rev = k*rev + tmp % k;
            return x == rev;
        };

        long long ans = 0, palin0 = 0, palin1 = 0;
        int odd = 1, even = 1;
        while (n--) {
            for (; true; ++odd) {
                palin1 = palin(odd, true);
                if (is_mirror(palin1)) break;
            }
            for (; palin0 < palin1; ++even) {
                palin0 = palin(even, false);
                if (is_mirror(palin0)) break;
            }
            if (palin0 < palin1) {
                ans += palin0;
                ++even;
            } else {
                ans += palin1;
                ++odd;
            }
        }
        return ans;
    }


    /*2083. Substrings That Begin and End With the Same Letter (Medium)
    You are given a 0-indexed string s consisting of only lowercase English
    letters. Return the number of substrings in s that begin and end with the
    same character. A substring is a contiguous non-empty sequence of
    characters within a string.

    Example 1:
    Input: s = "abcba"
    Output: 7
    Explanation: The substrings of length 1 that start and end with the same
                 letter are: "a", "b", "c", "b", and "a". The substring of
                 length 3 that starts and ends with the same letter is: "bcb".
                 The substring of length 5 that starts and ends with the same
                 letter is: "abcba".

    Example 2:
    Input: s = "abacad"
    Output: 9
    Explanation: The substrings of length 1 that start and end with the same
                 letter are: "a", "b", "a", "c", "a", and "d". The substrings
                 of length 3 that start and end with the same letter are: "aba"
                 and "aca". The substring of length 5 that starts and ends with
                 the same letter is: "abaca".

    Example 3:
    Input: s = "a"
    Output: 1
    Explanation: The substring of length 1 that starts and ends with the same
                 letter is: "a".

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters.*/

    long long numberOfSubstrings(string s) {
        long long ans = 0;
        vector<int> freq(26);
        for (auto& ch : s) ans += ++freq[ch-'a'];
        return ans;
    }


    /*2085. Count Common Words With One Occurrence (Easy)
    Given two string arrays words1 and words2, return the number of strings
    that appear exactly once in each of the two arrays.

    Example 1:
    Input: words1 = ["leetcode","is","amazing","as","is"], words2 = ["amazing","leetcode","is"]
    Output: 2
    Explanation:
    - "leetcode" appears exactly once in each of the two arrays. We count this
      string.
    - "amazing" appears exactly once in each of the two arrays. We count this
      string.
    - "is" appears in each of the two arrays, but there are 2 occurrences of it
      in words1. We do not count this string.
    - "as" appears once in words1, but does not appear in words2. We do not
      count this string.
    Thus, there are 2 strings that appear exactly once in each of the two
    arrays.

    Example 2:
    Input: words1 = ["b","bb","bbb"], words2 = ["a","aa","aaa"]
    Output: 0
    Explanation: There are no strings that appear in each of the two arrays.

    Example 3:
    Input: words1 = ["a","ab"], words2 = ["a","a","a","ab"]
    Output: 1
    Explanation: The only string that appears exactly once in each of the two arrays is "ab".

    Constraints:
    * 1 <= words1.length, words2.length <= 1000
    * 1 <= words1[i].length, words2[j].length <= 30
    * words1[i] and words2[j] consists only of lowercase English letters.*/

    int countWords(vector<string>& words1, vector<string>& words2) {
        unordered_map<string, int> freq1, freq2;
        for (auto& s : words1) ++freq1[s];
        for (auto& s : words2) ++freq2[s];
        int ans = 0;
        for (auto& [s, v] : freq1)
            if (v == 1 && freq2[s] == 1) ++ans;
        return ans;
    }


    /*2086. Minimum Number of Buckets Required to Collect Rainwater from Houses (Medium)
    You are given a 0-indexed string street. Each character in street is either
    'H' representing a house or '.' representing an empty space. You can place
    buckets on the empty spaces to collect rainwater that falls from the
    adjacent houses. The rainwater from a house at index i is collected if a
    bucket is placed at index i - 1 and/or index i + 1. A single bucket, if
    placed adjacent to two houses, can collect the rainwater from both houses.
    Return the minimum number of buckets needed so that for every house, there
    is at least one bucket collecting rainwater from it, or -1 if it is
    impossible.

    Example 1:
    Input: street = "H..H"
    Output: 2
    Explanation: We can put buckets at index 1 and index 2. "H..H" -> "HBBH"
                 ('B' denotes where a bucket is placed). The house at index 0
                 has a bucket to its right, and the house at index 3 has a
                 bucket to its left. Thus, for every house, there is at least
                 one bucket collecting rainwater from it.

    Example 2:
    Input: street = ".H.H."
    Output: 1
    Explanation: We can put a bucket at index 2. ".H.H." -> ".HBH." ('B'
                 denotes where a bucket is placed). The house at index 1 has a
                 bucket to its right, and the house at index 3 has a bucket to
                 its left. Thus, for every house, there is at least one bucket
                 collecting rainwater from it.

    Example 3:
    Input: street = ".HHH."
    Output: -1
    Explanation: There is no empty space to place a bucket to collect the
                 rainwater from the house at index 2. Thus, it is impossible to
                 collect the rainwater from all the houses.

    Example 4:
    Input: street = "H"
    Output: -1
    Explanation: There is no empty space to place a bucket. Thus, it is
                 impossible to collect the rainwater from the house.

    Example 5:
    Input: street = "."
    Output: 0
    Explanation: There is no house to collect water from. Thus, 0 buckets are
                 needed.

    Constraints:
    * 1 <= street.length <= 10^5
    * street[i] is either'H' or '.'.*/

    int minimumBuckets(string street) {
        int ans = 0 ;
        for (int i = 0; i < street.size(); ++i) {
            if (street[i] == 'H' && (i == 0 || street[i-1] != '#')) {
                if (i+1 < street.size() && street[i+1] == '.') street[i+1] = '#';
                else if (i > 0 && street[i-1] == '.') street[i-1] = '#';
                else return -1;
                ++ans;
            }
        }
        return ans;
    }


    /*2087. Minimum Cost Homecoming of a Robot in a Grid (Medium)
    There is an m x n grid, where (0, 0) is the top-left cell and (m - 1, n - 1)
    is the bottom-right cell. You are given an integer array startPos where
    startPos = [startrow, startcol] indicates that initially, a robot is at the
    cell (startrow, startcol). You are also given an integer array homePos
    where homePos = [homerow, homecol] indicates that its home is at the cell
    (homerow, homecol). The robot needs to go to its home. It can move one cell
    in four directions: left, right, up, or down, and it can not move outside
    the boundary. Every move incurs some cost. You are further given two 0-
    indexed integer arrays: rowCosts of length m and colCosts of length n.
    * If the robot moves up or down into a cell whose row is r, then this move
      costs rowCosts[r].
    * If the robot moves left or right into a cell whose column is c, then this
      move costs colCosts[c].
    Return the minimum total cost for this robot to return home.

    Example 1:
    Input: startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]
    Output: 18
    Explanation: One optimal path is that: Starting from (1, 0)
    -> It goes down to (2, 0). This move costs rowCosts[2] = 3.
    -> It goes right to (2, 1). This move costs colCosts[1] = 2.
    -> It goes right to (2, 2). This move costs colCosts[2] = 6.
    -> It goes right to (2, 3). This move costs colCosts[3] = 7.
    The total cost is 3 + 2 + 6 + 7 = 18

    Example 2:
    Input: startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]
    Output: 0
    Explanation: The robot is already at its home. Since no moves occur, the
                 total cost is 0.

    Constraints:
    * m == rowCosts.length
    * n == colCosts.length
    * 1 <= m, n <= 10^5
    * 0 <= rowCosts[r], colCosts[c] <= 10^4
    * startPos.length == 2
    * homePos.length == 2
    * 0 <= startrow, homerow < m
    * 0 <= startcol, homecol < n*/

    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {
        int ans = 0, si = startPos[0], sj = startPos[1], hi = homePos[0], hj = homePos[1], begin = 0, end = 0;
        if (si != hi) {
            if (si < hi) begin = si+1, end = hi;
            else if (si > hi) begin = hi, end = si-1;
            for (int i = begin; i <= end; ++i) ans += rowCosts[i];
        }
        if (sj != hj) {
            if (sj < hj) begin = sj+1, end = hj;
            else if (sj > hj) begin = hj, end = sj-1;
            for (int j = begin; j <= end; ++j) ans += colCosts[j];
        }
        return ans;
    }


    /*2088. Count Fertile Pyramids in a Land (Hard)
    A farmer has a rectangular grid of land with m rows and n columns that can
    be divided into unit cells. Each cell is either fertile (represented by a 1)
    or barren (represented by a 0). All cells outside the grid are considered
    barren. A pyramidal plot of land can be defined as a set of cells with the
    following criteria:
    * The number of cells in the set has to be greater than 1 and all cells
      must be fertile.
    * The apex of a pyramid is the topmost cell of the pyramid. The height of a
      pyramid is the number of rows it covers. Let (r, c) be the apex of the
      pyramid, and its height be h. Then, the plot comprises of cells (i, j)
      where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).
    An inverse pyramidal plot of land can be defined as a set of cells with
    similar criteria:
    * The number of cells in the set has to be greater than 1 and all cells
      must be fertile.
    * The apex of an inverse pyramid is the bottommost cell of the inverse
      pyramid. The height of an inverse pyramid is the number of rows it covers.
      Let (r, c) be the apex of the pyramid, and its height be h. Then, the
      plot comprises of cells (i, j) where r - h + 1 <= i <= r and
      c - (r - i) <= j <= c + (r - i).
    Some examples of valid and invalid pyramidal (and inverse pyramidal) plots
    are shown below. Black cells indicate fertile cells. Given a 0-indexed
    m x n binary matrix grid representing the farmland, return the total number
    of pyramidal and inverse pyramidal plots that can be found in grid.

    Example 1:
    Input: grid = [[0,1,1,0],[1,1,1,1]]
    Output: 2
    Explanation: The 2 possible pyramidal plots are shown in blue and red
                 respectively. There are no inverse pyramidal plots in this
                 grid. Hence total number of pyramidal and inverse pyramidal
                 plots is 2 + 0 = 2.

    Example 2:
    Input: grid = [[1,1,1],[1,1,1]]
    Output: 2
    Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal
                 plot is shown in red. Hence the total number of plots is
                 1 + 1 = 2.

    Example 3:
    Input: grid = [[1,0,1],[0,0,0],[1,0,1]]
    Output: 0
    Explanation: There are no pyramidal or inverse pyramidal plots in the grid.

    Example 4:
    Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]
    Output: 13
    Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd
                 and 3rd figures. There are 6 inverse pyramidal plots, 2 of
                 which are shown in the last figure. The total number of plots
                 is 7 + 6 = 13.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 1000
    * 1 <= m * n <= 10^5
    * grid[i][j] is either 0 or 1.*/

    int countPyramids(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> vals(m, vector<int>(n, INT_MAX));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 0) vals[i][j] = 0;
                else if (j == 0) vals[i][j] = 1;
                else vals[i][j] = min(vals[i][j], 1 + vals[i][j-1]);

                if (grid[i][n-1-j] == 0) vals[i][n-1-j] = 0;
                else if (j == 0) vals[i][n-1-j] = 1;
                else vals[i][n-1-j] = min(vals[i][n-1-j], 1 + vals[i][n-j]);
            }

        auto fn = [&](vector<vector<int>>& vals) {
            int ans = 0;
            for (int j = 0; j < n; ++j) {
                int width = 0;
                for (int i = 0; i < m; ++i) {
                    if (vals[i][j]) width = min(1+width, vals[i][j]);
                    else width = 0;
                    ans += max(0, width-1);
                }
            }
            return ans;
        };

        int ans = fn(vals);
        reverse(vals.begin(), vals.end());
        ans += fn(vals);
        return ans;
    }


    /*2089. Find Target Indices After Sorting Array (Easy)
    You are given a 0-indexed integer array nums and a target element target.
    A target index is an index i such that nums[i] == target. Return a list of
    the target indices of nums after sorting nums in non-decreasing order. If
    there are no target indices, return an empty list. The returned list must
    be sorted in increasing order.

    Example 1:
    Input: nums = [1,2,5,2,3], target = 2
    Output: [1,2]
    Explanation: After sorting, nums is [1,2,2,3,5]. The indices where
                 nums[i] == 2 are 1 and 2.

    Example 2:
    Input: nums = [1,2,5,2,3], target = 3
    Output: [3]
    Explanation: After sorting, nums is [1,2,2,3,5]. The index where
                 nums[i] == 3 is 3.

    Example 3:
    Input: nums = [1,2,5,2,3], target = 5
    Output: [4]
    Explanation: After sorting, nums is [1,2,2,3,5]. The index where
                 nums[i] == 5 is 4.

    Example 4:
    Input: nums = [1,2,5,2,3], target = 4
    Output: []
    Explanation: There are no elements in nums with value 4.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i], target <= 100*/

    vector<int> targetIndices(vector<int>& nums, int target) {
        int lo = 0, mid = 0, hi = nums.size()-1;
        while (mid <= hi) {
            if (nums[mid] < target) swap(nums[lo++], nums[mid++]);
            else if (nums[mid] == target) ++mid;
            else swap(nums[mid], nums[hi--]);
        }
        vector<int> ans(mid-lo);
        iota(ans.begin(), ans.end(), lo);
        return ans;
    }


    /*2090. K Radius Subarray Averages (Medium)
    You are given a 0-indexed array nums of n integers, and an integer k. The
    k-radius average for a subarray of nums centered at some index i with the
    radius k is the average of all elements in nums between the indices i - k
    and i + k (inclusive). If there are less than k elements before or after
    the index i, then the k-radius average is -1. Build and return an array
    avgs of length n where avgs[i] is the k-radius average for the subarray
    centered at index i. The average of x elements is the sum of the x elements
    divided by x, using integer division. The integer division truncates toward
    zero, which means losing its fractional part. For example, the average of
    four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which
    truncates to 2.

    Example 1:
    Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
    Output: [-1,-1,-1,5,4,4,-1,-1,-1]
    Explanation:
    - avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.
    - The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.
      Using integer division, avg[3] = 37 / 7 = 5.
    - For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.
    - For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.
    - avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.

    Example 2:
    Input: nums = [100000], k = 0
    Output: [100000]
    Explanation:
    - The sum of the subarray centered at index 0 with radius 0 is: 100000.
      avg[0] = 100000 / 1 = 100000.

    Example 3:
    Input: nums = [8], k = 100000
    Output: [-1]
    Explanation:
    - avg[0] is -1 because there are less than k elements before and after index 0.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 0 <= nums[i], k <= 10^5*/

    vector<int> getAverages(vector<int>& nums, int k) {
        vector<int> ans(nums.size(), -1);
        long rsm = 0;
        for (int i = 0; i < nums.size(); ++i) {
            rsm += nums[i];
            if (i >= 2*k+1) rsm -= nums[i-(2*k+1)];
            if (i+1 >= 2*k+1) ans[i-k] = rsm/(2*k+1);
        }
        return ans;
    }


    /*2091. Removing Minimum and Maximum From Array (Medium)
    You are given a 0-indexed array of distinct integers nums. There is an
    element in nums that has the lowest value and an element that has the
    highest value. We call them the minimum and maximum respectively. Your goal
    is to remove both these elements from the array. A deletion is defined as
    either removing an element from the front of the array or removing an
    element from the back of the array. Return the minimum number of deletions
    it would take to remove both the minimum and maximum element from the array.

    Example 1:
    Input: nums = [2,10,7,5,4,1,8,6]
    Output: 5
    Explanation: The minimum element in the array is nums[5], which is 1. The
                 maximum element in the array is nums[1], which is 10. We can
                 remove both the minimum and maximum by removing 2 elements
                 from the front and 3 elements from the back. This results in
                 2 + 3 = 5 deletions, which is the minimum number possible.

    Example 2:
    Input: nums = [0,-4,19,1,8,-2,-3,5]
    Output: 3
    Explanation: The minimum element in the array is nums[1], which is -4. The
                 maximum element in the array is nums[2], which is 19. We can
                 remove both the minimum and maximum by removing 3 elements
                 from the front. This results in only 3 deletions, which is the
                 minimum number possible.

    Example 3:
    Input: nums = [101]
    Output: 1
    Explanation: There is only one element in the array, which makes it both
                 the minimum and maximum element. We can remove it with 1
                 deletion.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^5 <= nums[i] <= 10^5
    * The integers in nums are distinct.*/

    int minimumDeletions(vector<int>& nums) {
        int imax = max_element(nums.begin(), nums.end()) - nums.begin(), imin = min_element(nums.begin(), nums.end()) - nums.begin();
        int k = min(imin, imax), kk = max(imin, imax), n = nums.size();
        return min({1+kk, n-k, n+1+k-kk});
    }


    /*2092. Find All People With Secret (Hard)
    You are given an integer n indicating there are n people numbered from 0 to
    n - 1. You are also given a 0-indexed 2D integer array meetings where
    meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a
    meeting at timei. A person may attend multiple meetings at the same time.
    Finally, you are given an integer firstPerson. Person 0 has a secret and
    initially shares the secret with a person firstPerson at time 0. This
    secret is then shared every time a meeting takes place with a person that
    has the secret. More formally, for every meeting, if a person xi has the
    secret at timei, then they will share the secret with person yi, and vice
    versa. The secrets are shared instantaneously. That is, a person may
    receive the secret and share it with people in other meetings within the
    same time frame. Return a list of all the people that have the secret after
    all the meetings have taken place. You may return the answer in any order.

    Example 1:
    Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
    Output: [0,1,2,3,5]
    Explanation: At time 0, person 0 shares the secret with person 1.
                 At time 5, person 1 shares the secret with person 2.
                 At time 8, person 2 shares the secret with person 3.
                 At time 10, person 1 shares the secret with person 5.
                 Thus, people 0, 1, 2, 3, and 5 know the secret after all the
                 meetings.

    Example 2:
    Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
    Output: [0,1,3]
    Explanation: At time 0, person 0 shares the secret with person 3.
                 At time 2, neither person 1 nor person 2 know the secret.
                 At time 3, person 3 shares the secret with person 0 and person 1.
                 Thus, people 0, 1, and 3 know the secret after all the meetings.

    Example 3:
    Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
    Output: [0,1,2,3,4]
    Explanation: At time 0, person 0 shares the secret with person 1.
                 At time 1, person 1 shares the secret with person 2, and
                 person 2 shares the secret with person 3. Note that person 2
                 can share the secret at the same time as receiving it.
                 At time 2, person 3 shares the secret with person 4.
                 Thus, people 0, 1, 2, 3, and 4 know the secret after all the
                 meetings.

    Example 4:
    Input: n = 6, meetings = [[0,2,1],[1,3,1],[4,5,1]], firstPerson = 1
    Output: [0,1,2,3]
    Explanation: At time 0, person 0 shares the secret with person 1.
                 At time 1, person 0 shares the secret with person 2, and person 1 shares the secret with person 3.
                 Thus, people 0, 1, 2, and 3 know the secret after all the meetings.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= meetings.length <= 10^5
    * meetings[i].length == 3
    * 0 <= xi, yi <= n - 1
    * xi != yi
    * 1 <= timei <= 10^5
    * 1 <= firstPerson <= n - 1*/

    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {
        vector<bool> can(n);
        can[0] = can[firstPerson] = true;

        map<int, vector<pair<int, int>>> mp;
        for (auto& meeting : meetings)
            mp[meeting[2]].emplace_back(meeting[0], meeting[1]);

        for (auto& [k, v] : mp) {
            unordered_map<int, vector<int>> graph;
            unordered_set<int> st;
            for (auto& [x, y] : v) {
                graph[x].push_back(y);
                graph[y].push_back(x);
                if (can[x]) st.insert(x);
                if (can[y]) st.insert(y);
            }

            queue<int> q;
            for (auto& x : st) q.push(x);

            while (q.size()) {
                auto x = q.front(); q.pop();
                for (auto& y : graph[x])
                    if (!can[y]) {
                        can[y] = true;
                        q.push(y);
                    }
            }
        }

        vector<int> ans;
        for (int i = 0; i < n; ++i)
            if (can[i]) ans.push_back(i);
        return ans;
    }


    /*2093. Minimum Cost to Reach City With Discounts (Medium)
    A series of highways connect n cities numbered from 0 to n - 1. You are
    given a 2D integer array highways where highways[i] = [city1i, city2i, tolli]
    indicates that there is a highway that connects city1i and city2i, allowing
    a car to go from city1i to city2i and vice versa for a cost of tolli. You
    are also given an integer discounts which represents the number of
    discounts you have. You can use a discount to travel across the ith highway
    for a cost of tolli / 2 (integer division). Each discount may only be used
    once, and you can only use at most one discount per highway. Return the
    minimum total cost to go from city 0 to city n - 1, or -1 if it is not
    possible to go from city 0 to city n - 1.

    Example 1:
    Input: n = 5, highways = [[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]], discounts = 1
    Output: 9
    Explanation: Go from 0 to 1 for a cost of 4. Go from 1 to 4 and use a
                 discount for a cost of 11 / 2 = 5. The minimum cost to go from
                 0 to 4 is 4 + 5 = 9.

    Example 2:
    Input: n = 4, highways = [[1,3,17],[1,2,7],[3,2,5],[0,1,6],[3,0,20]], discounts = 20
    Output: 8
    Explanation: Go from 0 to 1 and use a discount for a cost of 6 / 2 = 3.
                 Go from 1 to 2 and use a discount for a cost of 7 / 2 = 3.
                 Go from 2 to 3 and use a discount for a cost of 5 / 2 = 2.
                 The minimum cost to go from 0 to 3 is 3 + 3 + 2 = 8.

    Example 3:
    Input: n = 4, highways = [[0,1,3],[2,3,2]], discounts = 0
    Output: -1
    Explanation: It is impossible to go from 0 to 3 so return -1.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= highways.length <= 1000
    * highways[i].length == 3
    * 0 <= city1i, city2i <= n - 1
    * city1i != city2i
    * 0 <= tolli <= 10^5
    * 0 <= discounts <= 500
    * There are no duplicate highways.*/

    int minimumCost(int n, vector<vector<int>>& highways, int discounts) {
        vector<vector<pair<int, int>>> graph(n);
        for (auto& h : highways) {
            graph[h[0]].emplace_back(h[1], h[2]);
            graph[h[1]].emplace_back(h[0], h[2]);
        }
        vector<vector<int>> dist(n, vector<int>(discounts+1, INT_MAX));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(0, discounts, 0);
        while (pq.size()) {
            auto [x, d, u] = pq.top(); pq.pop();
            if (u == n-1) return x;
            for (auto& [v, cost] : graph[u]) {
                if (x+cost < dist[v][d]) {
                    pq.emplace(x+cost, d, v);
                    dist[v][d] = x + cost;
                }
                if (d && x+cost/2 < dist[v][d-1]) {
                    pq.emplace(x+cost/2, d-1, v);
                    dist[v][d-1] = x + cost/2;
                }
            }
        }
        return -1;
    }


    /*2094. Finding 3-Digit Even Numbers (Easy)
    You are given an integer array digits, where each element is a digit. The
    array may contain duplicates. You need to find all the unique integers that
    follow the given requirements:
    * The integer consists of the concatenation of three elements from digits
      in any arbitrary order.
    * The integer does not have leading zeros.
    * The integer is even.
    For example, if the given digits were [1, 2, 3], integers 132 and 312
    follow the requirements. Return a sorted array of the unique integers.

    Example 1:
    Input: digits = [2,1,3,0]
    Output: [102,120,130,132,210,230,302,310,312,320]
    Explanation: All the possible integers that follow the requirements are in
                 the output array. Notice that there are no odd integers or
                 integers with leading zeros.

    Example 2:
    Input: digits = [2,2,8,8,2]
    Output: [222,228,282,288,822,828,882]
    Explanation: The same digit can be used as many times as it appears in
                 digits. In this example, the digit 8 is used twice each time
                 in 288, 828, and 882.

    Example 3:
    Input: digits = [3,7,5]
    Output: []
    Explanation: No even integers can be formed using the given digits.

    Example 4:
    Input: digits = [0,2,0,0]
    Output: [200]
    Explanation: The only valid integer that can be formed with three digits
                 and no leading zeros is 200.

    Example 5:
    Input: digits = [0,0,0]
    Output: []
    Explanation: All the integers that can be formed have leading zeros. Thus,
                 there are no valid integers.

    Constraints:
    * 3 <= digits.length <= 100
    * 0 <= digits[i] <= 9*/

    vector<int> findEvenNumbers(vector<int>& digits) {
        vector<int> freq(10), ans;
        for (auto& x : digits) ++freq[x];
        for (int val = 100; val < 1000; val += 2) {
            vector<int> f = freq;
            for (int x = val; x; x /= 10) --f[x % 10];
            if (all_of(f.begin(), f.end(), [&](int x) { return x >= 0; })) ans.push_back(val);
        }
        return ans;
    }


    /*2095. Delete the Middle Node of a Linked List (Medium)
    You are given the head of a linked list. Delete the middle node, and return
    the head of the modified linked list. The middle node of a linked list of
    size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where
    ⌊x⌋ denotes the largest integer less than or equal to x. For n = 1, 2, 3, 4,
    and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.

    Example 1:
    Input: head = [1,3,4,7,1,2,6]
    Output: [1,3,4,1,2,6]
    Explanation: The above figure represents the given linked list. The indices
                 of the nodes are written below. Since n = 7, node 3 with value
                 7 is the middle node, which is marked in red. We return the
                 new list after removing this node.

    Example 2:
    Input: head = [1,2,3,4]
    Output: [1,2,4]
    Explanation: The above figure represents the given linked list. For n = 4,
                 node 2 with value 3 is the middle node, which is marked in red.

    Example 3:
    Input: head = [2,1]
    Output: [2]
    Explanation: The above figure represents the given linked list. For n = 2,
                 node 1 with value 1 is the middle node, which is marked in red.
                 Node 0 with value 2 is the only node remaining after removing
                 node 1.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5*/

    ListNode* deleteMiddle(ListNode* head) {
        ListNode dummy(0, head), *fast = &dummy, *slow = &dummy;
        while (fast->next && fast->next->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummy.next;
    }


    /*2096. Step-By-Step Directions From a Binary Tree Node to Another (Medium)
    You are given the root of a binary tree with n nodes. Each node is uniquely
    assigned a value from 1 to n. You are also given an integer startValue
    representing the value of the start node s, and a different integer
    destValue representing the value of the destination node t. Find the
    shortest path starting from node s and ending at node t. Generate step-by-
    step directions of such path as a string consisting of only the uppercase
    letters 'L', 'R', and 'U'. Each letter indicates a specific direction:
    * 'L' means to go from a node to its left child node.
    * 'R' means to go from a node to its right child node.
    * 'U' means to go from a node to its parent node.
    Return the step-by-step directions of the shortest path from node s to node
    t.

    Example 1:
    Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
    Output: "UURL"
    Explanation: The shortest path is: 3 → 1 → 5 → 2 → 6.

    Example 2:
    Input: root = [2,1], startValue = 2, destValue = 1
    Output: "L"
    Explanation: The shortest path is: 2 → 1.

    Constraints:
    * The number of nodes in the tree is n.
    * 2 <= n <= 10^5
    * 1 <= Node.val <= n
    * All the values in the tree are unique.
    * 1 <= startValue, destValue <= n
    * startValue != destValue*/

    string getDirections(TreeNode* root, int startValue, int destValue) {

        function<TreeNode*(TreeNode*)> lca = [&](TreeNode* node) {
            if (!node || node->val == startValue || node->val == destValue) return node;
            TreeNode *left = lca(node->left), *right = lca(node->right);
            if (left && right) return node;
            return left ? left : right;
        };

        root = lca(root);
        string ps, pd, path;

        function<void(TreeNode*)> fn = [&] (TreeNode* node) {
            if (node->val == startValue) ps = path;
            if (node->val == destValue) pd = path;
            if (node->left) {
                path.push_back('L');
                fn(node->left);
                path.pop_back();
            }
            if (node->right) {
                path.push_back('R');
                fn(node->right);
                path.pop_back();
            }
        };

        fn(root);
        return string(ps.size(), 'U') + pd;
    }


    /*2097. Valid Arrangement of Pairs (Hard)
    You are given a 0-indexed 2D integer array pairs where
    pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every
    index i where 1 <= i < pairs.length, we have endi-1 == starti. Return any
    valid arrangement of pairs. Note: The inputs will be generated such that
    there exists a valid arrangement of pairs.

    Example 1:
    Input: pairs = [[5,1],[4,5],[11,9],[9,4]]
    Output: [[11,9],[9,4],[4,5],[5,1]]
    Explanation: This is a valid arrangement since endi-1 always equals starti.
                 end0 = 9 == 9 = start1
                 end1 = 4 == 4 = start2
                 end2 = 5 == 5 = start3

    Example 2:
    Input: pairs = [[1,3],[3,2],[2,1]]
    Output: [[1,3],[3,2],[2,1]]
    Explanation: This is a valid arrangement since endi-1 always equals starti.
                 end0 = 3 == 3 = start1
                 end1 = 2 == 2 = start2
                 The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]]
                 are also valid.

    Example 3:
    Input: pairs = [[1,2],[1,3],[2,1]]
    Output: [[1,2],[2,1],[1,3]]
    Explanation: This is a valid arrangement since endi-1 always equals starti.
                 end0 = 2 == 2 = start1
                 end1 = 1 == 1 = start2

    Constraints:
    * 1 <= pairs.length <= 10^5
    * pairs[i].length == 2
    * 0 <= starti, endi <= 10^9
    * starti != endi
    * No two pairs are exactly the same.
    * There exists a valid arrangement of pairs.*/

    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        unordered_map<int, vector<int>> graph;
        unordered_map<int, int> degree;

        int start = 0;
        for (auto& edge : pairs) {
            graph[edge[0]].push_back(edge[1]);
            ++degree[edge[0]];
            --degree[edge[1]];
            start = edge[0];
        }

        for (auto& [k, v] : degree)
            if (v == 1) start = k;

        // iterative implementation of Hierholzer's algo
        vector<int> path;
        stack<int> stk; stk.push(start);
        while (stk.size()) {
            while (graph[stk.top()].size()) {
                int x = stk.top();
                stk.push(graph[x].back());
                graph[x].pop_back();
            }
            path.push_back(stk.top()); stk.pop();
        }
        reverse(path.begin(), path.end());
        vector<vector<int>> ans;
        for (int i = 0; i < path.size()-1; ++i) ans.push_back({path[i], path[i+1]});
        return ans;
    }


    /*2098. Subsequence of Size K With the Largest Even Sum (Medium)
    You are given an integer array nums and an integer k. Find the largest even
    sum of any subsequence of nums that has a length of k. Return this sum, or
    -1 if such a sum does not exist. A subsequence is an array that can be
    derived from another array by deleting some or no elements without changing
    the order of the remaining elements.

    Example 1:
    Input: nums = [4,1,5,3,1], k = 3
    Output: 12
    Explanation: The subsequence with the largest possible even sum is [4,5,3].
                 It has a sum of 4 + 5 + 3 = 12.

    Example 2:
    Input: nums = [4,6,2], k = 3
    Output: 12
    Explanation: The subsequence with the largest possible even sum is [4,6,2].
                 It has a sum of 4 + 6 + 2 = 12.

    Example 3:
    Input: nums = [1,3,5], k = 1
    Output: -1
    Explanation: No subsequence of nums with length 1 has an even sum.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5
    * 1 <= k <= nums.length*/

    long long largestEvenSum(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), greater<>());
        long long ans = -1, prefix = 0;
        vector<int> least(2, INT_MAX);
        for (int i = 0; i < nums.size(); ++i)
            if (i < k) {
                prefix += nums[i];
                least[nums[i]&1] = min(least[nums[i]&1], nums[i]);
                if (i == k-1 && !(prefix&1)) return prefix;
            } else ans = max(ans, prefix - least[!(nums[i]&1)] + nums[i]);
        return ans;
    }


    /*2099. Find Subsequence of Length K With the Largest Sum (Easy)
    You are given an integer array nums and an integer k. You want to find a
    subsequence of nums of length k that has the largest sum. Return any such
    subsequence as an integer array of length k. A subsequence is an array that
    can be derived from another array by deleting some or no elements without
    changing the order of the remaining elements.

    Example 1:
    Input: nums = [2,1,3,3], k = 2
    Output: [3,3]
    Explanation: The subsequence has the largest sum of 3 + 3 = 6.

    Example 2:
    Input: nums = [-1,-2,3,4], k = 3
    Output: [-1,3,4]
    Explanation: The subsequence has the largest sum of -1 + 3 + 4 = 6.

    Example 3:
    Input: nums = [3,4,3,3], k = 2
    Output: [3,4]
    Explanation: The subsequence has the largest sum of 3 + 4 = 7. Another
                 possible subsequence is [4, 3].

    Constraints:
    * 1 <= nums.length <= 1000
    * -10^5 <= nums[i] <= 10^5
    * 1 <= k <= nums.length*/

    vector<int> maxSubsequence(vector<int>& nums, int k) {
        vector<int> tmp = nums;
        nth_element(tmp.begin(), tmp.end()-k, tmp.end());

        int n = nums.size(), threshold = tmp[n-k], larger = 0;
        for (auto& x : nums)
            if (x > threshold) ++larger;
        int equal = k - larger;
        vector<int> ans;
        for (auto& x : nums)
            if (x > threshold || (x == threshold && equal-- > 0)) ans.push_back(x);
        return ans;
    }


    /*2100. Find Good Days to Rob the Bank (Medium)
    You and a gang of thieves are planning on robbing a bank. You are given a
    0-indexed integer array security, where security[i] is the number of guards
    on duty on the ith day. The days are numbered starting from 0. You are also
    given an integer time. The ith day is a good day to rob the bank if:
    * There are at least time days before and after the ith day,
    * The number of guards at the bank for the time days before i are non-
      increasing, and
    * The number of guards at the bank for the time days after i are non-
      decreasing.
    More formally, this means day i is a good day to rob the bank if and only
    if security[i - time] >= security[i - time + 1] >= ... >= security[i]
    <= ... <= security[i + time - 1] <= security[i + time]. Return a list of
    all days (0-indexed) that are good days to rob the bank. The order that the
    days are returned in does not matter.

    Example 1:
    Input: security = [5,3,3,3,5,6,2], time = 2
    Output: [2,3]
    Explanation: On day 2, we have security[0] >= security[1] >= security[2]
                 <= security[3] <= security[4]. On day 3, we have security[1]
                 >= security[2] >= security[3] <= security[4] <= security[5].
                 No other days satisfy this condition, so days 2 and 3 are the
                 only good days to rob the bank.

    Example 2:
    Input: security = [1,1,1,1,1], time = 0
    Output: [0,1,2,3,4]
    Explanation: Since time equals 0, every day is a good day to rob the bank,
                 so return every day.

    Example 3:
    Input: security = [1,2,3,4,5,6], time = 2
    Output: []
    Explanation: No day has 2 days before it that have a non-increasing number
                 of guards. Thus, no day is a good day to rob the bank, so
                 return an empty list.

    Example 4:
    Input: security = [1], time = 5
    Output: []
    Explanation: No day has 5 days before and after it. Thus, no day is a good
                 day to rob the bank, so return an empty list.

    Constraints:
    * 1 <= security.length <= 10^5
    * 0 <= security[i], time <= 10^5*/

    vector<int> goodDaysToRobBank(vector<int>& security, int time) {
        int n = security.size();
        vector<int> suffix(n);
        for (int i = n-2; i >= 0; --i)
            if (security[i] <= security[i+1]) suffix[i] = suffix[i+1] + 1;

        vector<int> ans;
        int prefix = 0;
        for (int i = 0; i < n-time; ++i) {
            if (i && security[i-1] >= security[i]) ++prefix;
            else prefix = 0;
            if (prefix >= time && suffix[i] >= time) ans.push_back(i);
        }
        return ans;
    }


    /*2101. Detonate the Maximum Bombs (Medium)
    You are given a list of bombs. The range of a bomb is defined as the area
    where its effect can be felt. This area is in the shape of a circle with
    the center as the location of the bomb. The bombs are represented by a 0-
    indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi
    denote the X-coordinate and Y-coordinate of the location of the ith bomb,
    whereas ri denotes the radius of its range. You may choose to detonate a
    single bomb. When a bomb is detonated, it will detonate all bombs that lie
    in its range. These bombs will further detonate the bombs that lie in their
    ranges. Given the list of bombs, return the maximum number of bombs that
    can be detonated if you are allowed to detonate only one bomb.

    Example 1:
    Input: bombs = [[2,1,3],[6,1,4]]
    Output: 2
    Explanation: The above figure shows the positions and ranges of the 2 bombs.
                 If we detonate the left bomb, the right bomb will not be
                 affected. But if we detonate the right bomb, both bombs will
                 be detonated. So the maximum bombs that can be detonated is
                 max(1, 2) = 2.

    Example 2:
    Input: bombs = [[1,1,5],[10,10,5]]
    Output: 1
    Explanation: Detonating either bomb will not detonate the other bomb, so
                 the maximum number of bombs that can be detonated is 1.

    Example 3:
    Input: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
    Output: 5
    Explanation: The best bomb to detonate is bomb 0 because:
                 - Bomb 0 detonates bombs 1 and 2. The red circle denotes the
                   range of bomb 0.
                 - Bomb 2 detonates bomb 3. The blue circle denotes the range
                   of bomb 2.
                 - Bomb 3 detonates bomb 4. The green circle denotes the range
                   of bomb 3.
                 Thus all 5 bombs are detonated.

    Constraints:
    * 1 <= bombs.length <= 100
    * bombs[i].length == 3
    * 1 <= xi, yi, ri <= 10^5*/

    int maximumDetonation(vector<vector<int>>& bombs) {
        int n = bombs.size();
        vector<vector<int>> graph(n);
        for (int i = 0; i < n; ++i)
            for (int j = i+1; j < n; ++j) {
                long dist2 = pow(bombs[i][0] - bombs[j][0], 2) + pow(bombs[i][1] - bombs[j][1], 2);
                if (dist2 <= pow(bombs[i][2], 2)) graph[i].push_back(j);
                if (dist2 <= pow(bombs[j][2], 2)) graph[j].push_back(i);
            }

        auto fn = [&](int x) {
            int ans = 1;
            stack<int> stk; stk.push(x);
            vector<bool> seen(n); seen[x] = true;
            while (stk.size()) {
                auto u = stk.top(); stk.pop();
                for (auto& v : graph[u])
                    if (!seen[v]) {
                        ++ans;
                        seen[v] = true;
                        stk.push(v);
                    }
            }
            return ans;
        };

        int most = 0;
        for (int x = 0; x < n; ++x) most = max(most, fn(x));
        return most;
    }


    /*2103. Rings and Rods (Easy)
    There are n rings and each ring is either red, green, or blue. The rings
    are distributed across ten rods labeled from 0 to 9. You are given a string
    rings of length 2n that describes the n rings that are placed onto the rods.
    Every two characters in rings forms a color-position pair that is used to
    describe each ring where:
    * The first character of the ith pair denotes the ith ring's color
      ('R', 'G', 'B').
    * The second character of the ith pair denotes the rod that the ith ring is
      placed on ('0' to '9').
    For example, "R3G2B1" describes n == 3 rings: a red ring placed onto the
    rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring
    placed onto the rod labeled 1. Return the number of rods that have all
    three colors of rings on them.

    Example 1:
    Input: rings = "B0B6G0R6R0R6G9"
    Output: 1
    Explanation:
    - The rod labeled 0 holds 3 rings with all colors: red, green, and blue.
    - The rod labeled 6 holds 3 rings, but it only has red and blue.
    - The rod labeled 9 holds only a green ring.
    Thus, the number of rods with all three colors is 1.

    Example 2:
    Input: rings = "B0R0G0R9R0B0G0"
    Output: 1
    Explanation:
    - The rod labeled 0 holds 6 rings with all colors: red, green, and blue.
    - The rod labeled 9 holds only a red ring.
    Thus, the number of rods with all three colors is 1.

    Example 3:
    Input: rings = "G4"
    Output: 0
    Explanation: Only one ring is given. Thus, no rods have all three colors.

    Constraints:
    * rings.length == 2 * n
    * 1 <= n <= 100
    * rings[i] where i is even is either 'R', 'G', or 'B' (0-indexed).
    * rings[i] where i is odd is a digit from '0' to '9' (0-indexed).*/

    int countPoints(string rings) {
        vector<int> mask(10);
        unordered_map<char, int> mp = {{'R', 0}, {'G', 1}, {'B', 2}};
        for (int i = 0; i < rings.size(); i += 2)
            mask[rings[i+1] - '0'] |= 1 << mp[rings[i]];
        return count(mask.begin(), mask.end(), 7);
    }


    /*2104. Sum of Subarray Ranges (Medium)
    You are given an integer array nums. The range of a subarray of nums is the
    difference between the largest and smallest element in the subarray. Return
    the sum of all subarray ranges of nums. A subarray is a contiguous non-
    empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,3]
    Output: 4
    Explanation: The 6 subarrays of nums are the following:
                 [1], range = largest - smallest = 1 - 1 = 0
                 [2], range = 2 - 2 = 0
                 [3], range = 3 - 3 = 0
                 [1,2], range = 2 - 1 = 1
                 [2,3], range = 3 - 2 = 1
                 [1,2,3], range = 3 - 1 = 2
                 So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.

    Example 2:
    Input: nums = [1,3,3]
    Output: 4
    Explanation: The 6 subarrays of nums are the following:
                 [1], range = largest - smallest = 1 - 1 = 0
                 [3], range = 3 - 3 = 0
                 [3], range = 3 - 3 = 0
                 [1,3], range = 3 - 1 = 2
                 [3,3], range = 3 - 3 = 0
                 [1,3,3], range = 3 - 1 = 2
                 So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.

    Example 3:
    Input: nums = [4,-2,-3,4,1]
    Output: 59
    Explanation: The sum of all subarray ranges of nums is 59.

    Constraints:
    * 1 <= nums.length <= 1000
    * -10^9 <= nums[i] <= 10^9*/

    long long subArrayRanges(vector<int>& nums) {

        auto fn = [&](function<bool(int, int)> op) {
            long long ans = 0;
            stack<int> stk;
            for (int i = 0; i <= nums.size(); ++i) {
                while (stk.size() && (i == nums.size() || op(nums[stk.top()], nums[i]))) {
                    int mid = stk.top(); stk.pop();
                    int ii = stk.size() ? stk.top() : -1;
                    ans += (long) nums[mid] * (i - mid) * (mid - ii);
                }
                stk.push(i);
            }
            return ans;
        };

        return fn(less<int>()) - fn(greater<int>());
    }


    /*2105. Watering Plants II (Medium)
    Alice and Bob want to water n plants in their garden. The plants are
    arranged in a row and are labeled from 0 to n - 1 from left to right where
    the ith plant is located at x = i. Each plant needs a specific amount of
    water. Alice and Bob have a watering can each, initially full. They water
    the plants in the following way:
    * Alice waters the plants in order from left to right, starting from the
      0th plant. Bob waters the plants in order from right to left, starting
      from the (n - 1)th plant. They begin watering the plants simultaneously.
    * If one does not have enough water to completely water the current plant,
      he/she refills the watering can instantaneously.
    * It takes the same amount of time to water each plant regardless of how
      much water it needs.
    * One cannot refill the watering can early.
    * Each plant can be watered either by Alice or by Bob.
    * In case both Alice and Bob reach the same plant, the one with more water
      currently in his/her watering can should water this plant. If they have
      the same amount of water, then Alice should water this plant.
    Given a 0-indexed integer array plants of n integers, where plants[i] is
    the amount of water the ith plant needs, and two integers capacityA and
    capacityB representing the capacities of Alice's and Bob's watering cans
    respectively, return the number of times they have to refill to water all
    the plants.

    Example 1:
    Input: plants = [2,2,3,3], capacityA = 5, capacityB = 5
    Output: 1
    Explanation:
    - Initially, Alice and Bob have 5 units of water each in their watering
      cans.
    - Alice waters plant 0, Bob waters plant 3.
    - Alice and Bob now have 3 units and 2 units of water respectively.
    - Alice has enough water for plant 1, so she waters it. Bob does not have
      enough water for plant 2, so he refills his can then waters it.
    So, the total number of times they have to refill to water all the plants
    is 0 + 0 + 1 + 0 = 1.

    Example 2:
    Input: plants = [2,2,3,3], capacityA = 3, capacityB = 4
    Output: 2
    Explanation:
    - Initially, Alice and Bob have 3 units and 4 units of water in their
      watering cans respectively.
    - Alice waters plant 0, Bob waters plant 3.
    - Alice and Bob now have 1 unit of water each, and need to water plants 1
      and 2 respectively.
    - Since neither of them have enough water for their current plants, they
      refill their cans and then water the plants.
    So, the total number of times they have to refill to water all the plants
    is 0 + 1 + 1 + 0 = 2.

    Example 3:
    Input: plants = [5], capacityA = 10, capacityB = 8
    Output: 0
    Explanation:
    - There is only one plant.
    - Alice's watering can has 10 units of water, whereas Bob's can has 8 units.
      Since Alice has more water in her can, she waters this plant.
    So, the total number of times they have to refill is 0.

    Example 4:
    Input: plants = [1,2,4,4,5], capacityA = 6, capacityB = 5
    Output: 2
    Explanation:
    - Initially, Alice and Bob have 6 units and 5 units of water in their
      watering cans respectively.
    - Alice waters plant 0, Bob waters plant 4.
    - Alice and Bob now have 5 units and 0 units of water respectively.
    - Alice has enough water for plant 1, so she waters it. Bob does not have
      enough water for plant 3, so he refills his can then waters it.
    - Alice and Bob now have 3 units and 1 unit of water respectively.
    - Since Alice has more water, she waters plant 2. However, she does not
      have enough water to completely water this plant. Hence she refills her
      can then waters it.
    So, the total number of times they have to refill to water all the plants
    is 0 + 0 + 1 + 1 + 0 = 2.

    Example 5:
    Input: plants = [2,2,5,2,2], capacityA = 5, capacityB = 5
    Output: 1
    Explanation: Both Alice and Bob will reach the middle plant with the same
                 amount of water, so Alice will water it. She will have 1 unit
                 of water when she reaches it, so she will refill her can. This
                 is the only refill needed.

    Constraints:
    * n == plants.length
    * 1 <= n <= 10^5
    * 1 <= plants[i] <= 10^6
    * max(plants[i]) <= capacityA, capacityB <= 10^9*/

    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {
        int ans = 0, lo = 0, hi = plants.size()-1, canA = capacityA, canB = capacityB;
        for (; lo < hi; ++lo, --hi) {
            if (canA < plants[lo]) ++ans, canA = capacityA;
            canA -= plants[lo];
            if (canB < plants[hi]) ++ans, canB = capacityB;
            canB -= plants[hi];
        }
        if (lo == hi && max(canA, canB) < plants[lo]) ++ans;
        return ans;
    }


    /*2106. Maximum Fruits Harvested After at Most K Steps (Hard)
    Fruits are available at some positions on an infinite x-axis. You are given
    a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts
    amounti fruits at the position positioni. fruits is already sorted by
    positioni in ascending order, and each positioni is unique. You are also
    given an integer startPos and an integer k. Initially, you are at the
    position startPos. From any position, you can either walk to the left or
    right. It takes one step to move one unit on the x-axis, and you can walk
    at most k steps in total. For every position you reach, you harvest all the
    fruits at that position, and the fruits will disappear from that position.
    Return the maximum total number of fruits you can harvest.

    Example 1:
    Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
    Output: 9
    Explanation: The optimal way is to:
                 - Move right to position 6 and harvest 3 fruits
                 - Move right to position 8 and harvest 6 fruits
                 You moved 3 steps and harvested 3 + 6 = 9 fruits in total.

    Example 2:
    Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4
    Output: 14
    Explanation: You can move at most k = 4 steps, so you cannot reach position
                 0 nor 10. The optimal way is to:
                 - Harvest the 7 fruits at the starting position 5
                 - Move left to position 4 and harvest 1 fruit
                 - Move right to position 6 and harvest 2 fruits
                 - Move right to position 7 and harvest 4 fruits
                 You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14
                 fruits in total.

    Example 3:
    Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2
    Output: 0
    Explanation: You can move at most k = 2 steps and cannot reach any position
                 with fruits.

    Constraints:
    * 1 <= fruits.length <= 10^5
    * fruits[i].length == 2
    * 0 <= startPos, positioni <= 2 * 10^5
    * positioni-1 < positioni for any i > 0 (0-indexed)
    * 1 <= amounti <= 10^4
    * 0 <= k <= 2 * 10^5*/

    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        int ans = 0;
        for (int i = 0, ii = 0, rsm = 0; i < fruits.size(); ++i) {
            int p = fruits[i][0], x = fruits[i][1];
            if (p > startPos + k) break;
            rsm += x;
            if (p <= startPos)
                while (ii <= i && startPos - fruits[ii][0] > k)
                    rsm -= fruits[ii++][1];
            else
                while (ii <= i && 2*(p-startPos)+(startPos-fruits[ii][0]) > k && (p-startPos)+2*(startPos-fruits[ii][0]) > k)
                    rsm -= fruits[ii++][1];
            ans = max(ans, rsm);
        }
        return ans;
    }


    /*2107. Number of Unique Flavors After Sharing K Candies (Medium)
    You are given a 0-indexed integer array candies, where candies[i]
    represents the flavor of the ith candy. Your mom wants you to share these
    candies with your little sister by giving her k consecutive candies, but
    you want to keep as many flavors of candies as possible. Return the maximum
    number of unique flavors of candy you can keep after sharing with your
    sister.

    Example 1:
    Input: candies = [1,2,2,3,4,3], k = 3
    Output: 3
    Explanation: Give the candies in the range [1, 3] (inclusive) with flavors
                 [2,2,3]. You can eat candies with flavors [1,4,3]. There are 3
                 unique flavors, so return 3.

    Example 2:
    Input: candies = [2,2,2,2,3,3], k = 2
    Output: 2
    Explanation: Give the candies in the range [3, 4] (inclusive) with flavors
                 [2,3]. You can eat candies with flavors [2,2,2,3]. There are 2
                 unique flavors, so return 2. Note that you can also share the
                 candies with flavors [2,2] and eat the candies with flavors
                 [2,2,3,3].

    Example 3:
    Input: candies = [2,4,5], k = 0
    Output: 3
    Explanation: You do not have to give any candies. You can eat the candies
                 with flavors [2,4,5]. There are 3 unique flavors, so return 3.

    Constraints:
    * 1 <= candies.length <= 10^5
    * 1 <= candies[i] <= 10^5
    * 0 <= k <= candies.length*/

    int shareCandies(vector<int>& candies, int k) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (auto& x : candies) ++freq[x];
        for (int i = 0; i < candies.size(); ++i) {
            if (--freq[candies[i]] == 0) freq.erase(candies[i]);
            if (i >= k) ++freq[candies[i-k]];
            if (i >= k-1) ans = max(ans, (int) freq.size());
        }
        return ans;
    }


    /*2108. Find First Palindromic String in the Array (Easy)
    Given an array of strings words, return the first palindromic string in the
    array. If there is no such string, return an empty string "". A string is
    palindromic if it reads the same forward and backward.

    Example 1:
    Input: words = ["abc","car","ada","racecar","cool"]
    Output: "ada"
    Explanation: The first string that is palindromic is "ada". Note that
                 "racecar" is also palindromic, but it is not the first.

    Example 2:
    Input: words = ["notapalindrome","racecar"]
    Output: "racecar"
    Explanation: The first and only string that is palindromic is "racecar".

    Example 3:
    Input: words = ["def","ghi"]
    Output: ""
    Explanation: There are no palindromic strings, so the empty string is returned.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consists only of lowercase English letters.*/

    string firstPalindrome(vector<string>& words) {
        for (auto& word : words)
            if (word == string(word.rbegin(), word.rend())) return word;
        return "";
    }


    /*2109. Adding Spaces to a String (Medium)
    You are given a 0-indexed string s and a 0-indexed integer array spaces
    that describes the indices in the original string where spaces will be
    added. Each space should be inserted before the character at the given
    index. For example, given s = "EnjoyYourCoffee" and spaces = [5, 9], we
    place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively.
    Thus, we obtain "Enjoy Your Coffee". Return the modified string after the
    spaces have been added.

    Example 1:
    Input: s = "LeetcodeHelpsMeLearn", spaces = [8,13,15]
    Output: "Leetcode Helps Me Learn"
    Explanation: The indices 8, 13, and 15 correspond to the underlined
                 characters in "LeetcodeHelpsMeLearn". We then place spaces
                 before those characters.

    Example 2:
    Input: s = "icodeinpython", spaces = [1,5,7,9]
    Output: "i code in py thon"
    Explanation: The indices 1, 5, 7, and 9 correspond to the underlined
                 characters in "icodeinpython". We then place spaces before
                 those characters.

    Example 3:
    Input: s = "spacing", spaces = [0,1,2,3,4,5,6]
    Output: " s p a c i n g"
    Explanation: We are also able to place spaces before the first character
                 of the string.

    Constraints:
    * 1 <= s.length <= 3 * 10^5
    * s consists only of lowercase and uppercase English letters.
    * 1 <= spaces.length <= 3 * 10^5
    * 0 <= spaces[i] <= s.length - 1
    * All the values of spaces are strictly increasing.*/

    string addSpaces(string s, vector<int>& spaces) {
        string ans;
        for (int i = 0, j = 0; i < s.size(); ++i) {
            if (j < spaces.size() && i == spaces[j]) {
                ans.push_back(' ');
                ++j;
            }
            ans.push_back(s[i]);
        }
        return ans;
    }


    /*2110. Number of Smooth Descent Periods of a Stock (Medium)
    You are given an integer array prices representing the daily price history
    of a stock, where prices[i] is the stock price on the ith day. A smooth
    descent period of a stock consists of one or more contiguous days such that
    the price on each day is lower than the price on the preceding day by
    exactly 1. The first day of the period is exempted from this rule. Return
    the number of smooth descent periods.

    Example 1:
    Input: prices = [3,2,1,4]
    Output: 7
    Explanation: There are 7 smooth descent periods: [3], [2], [1], [4], [3,2],
                 [2,1], and [3,2,1]. Note that a period with one day is a
                 smooth descent period by the definition.

    Example 2:
    Input: prices = [8,6,7,7]
    Output: 4
    Explanation: There are 4 smooth descent periods: [8], [6], [7], and [7].
                 Note that [8,6] is not a smooth descent period as 8 - 6 ≠ 1.

    Example 3:
    Input: prices = [1]
    Output: 1
    Explanation: There is 1 smooth descent period: [1]

    Constraints:
    * 1 <= prices.length <= 10^5
    * 1 <= prices[i] <= 10^5*/

    long long getDescentPeriods(vector<int>& prices) {
        long long ans = 0;
        for (int i = 0, cnt = 0; i < prices.size(); ++i) {
            if (i && prices[i-1] != prices[i]+1) cnt = 0;
            ans += ++cnt;
        }
        return ans;
    }


    /*2111. Minimum Operations to Make the Array K-Increasing (Hard)
    You are given a 0-indexed array arr consisting of n positive integers, and
    a positive integer k. The array arr is called K-increasing if
    arr[i-k] <= arr[i] holds for every index i, where k <= i <= n-1.
    * For example, arr = [4, 1, 5, 2, 6, 2] is K-increasing for k = 2 because:
      o arr[0] <= arr[2] (4 <= 5)
      o arr[1] <= arr[3] (1 <= 2)
      o arr[2] <= arr[4] (5 <= 6)
      o arr[3] <= arr[5] (2 <= 2)
    * However, the same arr is not K-increasing for k = 1 (because
      arr[0] > arr[1]) or k = 3 (because arr[0] > arr[3]).
    In one operation, you can choose an index i and change arr[i] into any
    positive integer. Return the minimum number of operations required to make
    the array K-increasing for the given k.

    Example 1:
    Input: arr = [5,4,3,2,1], k = 1
    Output: 4
    Explanation: For k = 1, the resultant array has to be non-decreasing. Some
                 of the K-increasing arrays that can be formed are [5,6,7,8,9],
                 [1,1,1,1,1], [2,2,3,4,4]. All of them require 4 operations. It
                 is suboptimal to change the array to, for example, [6,7,8,9,10]
                 because it would take 5 operations. It can be shown that we
                 cannot make the array K-increasing in less than 4 operations.

    Example 2:
    Input: arr = [4,1,5,2,6,2], k = 2
    Output: 0
    Explanation: This is the same example as the one in the problem description.
                 Here, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i].
                 Since the given array is already K-increasing, we do not need
                 to perform any operations.

    Example 3:
    Input: arr = [4,1,5,2,6,2], k = 3
    Output: 2
    Explanation: Indices 3 and 5 are the only ones not satisfying
                 arr[i-3] <= arr[i] for 3 <= i <= 5. One of the ways we can
                 make the array K-increasing is by changing arr[3] to 4 and
                 arr[5] to 5. The array will now be [4,1,5,4,6,5]. Note that
                 there can be other ways to make the array K-increasing, but
                 none of them require less than 2 operations.

    Constraints:
    * 1 <= arr.length <= 10^5
    * 1 <= arr[i], k <= arr.length*/

    int kIncreasing(vector<int>& arr, int k) {
        int ans = 0;
        for (int i = 0; i < k; ++i) {
            vector<int> vals;
            for (int ii = i; ii < arr.size(); ii += k) {
                if (vals.empty() || vals.back() <= arr[ii]) vals.push_back(arr[ii]);
                else *upper_bound(vals.begin(), vals.end(), arr[ii]) = arr[ii];
            }
            ans += vals.size();
        }
        return arr.size() - ans;
    }


    /*2113. Elements in Array After Removing and Replacing Elements (Medium)
    You are given a 0-indexed integer array nums. Initially on minute 0, the
    array is unchanged. Every minute, the leftmost element in nums is removed
    until no elements remain. Then, every minute, one element is appended to
    the end of nums, in the order they were removed in, until the original
    array is restored. This process repeats indefinitely.
    * For example, the array [0,1,2] would change as follows:
      [0,1,2] → [1,2] → [2] → [] → [0] → [0,1] → [0,1,2] → [1,2] → [2] → [] →
      [0] → [0,1] → [0,1,2] → ...
    You are also given a 2D integer array queries of size n where
    queries[j] = [timej, indexj]. The answer to the jth query is:
    * nums[indexj] if indexj < nums.length at minute timej
    * -1 if indexj >= nums.length at minute timej
    Return an integer array ans of size n where ans[j] is the answer to the jth
    query.

    Example 1:
    Input: nums = [0,1,2], queries = [[0,2],[2,0],[3,2],[5,0]]
    Output: [2,2,-1,0]
    Explanation: Minute 0: [0,1,2] - All elements are in the nums.
                 Minute 1: [1,2]   - The leftmost element, 0, is removed.
                 Minute 2: [2]     - The leftmost element, 1, is removed.
                 Minute 3: []      - The leftmost element, 2, is removed.
                 Minute 4: [0]     - 0 is added to the end of nums.
                 Minute 5: [0,1]   - 1 is added to the end of nums.
                 At minute 0, nums[2] is 2.
                 At minute 2, nums[0] is 2.
                 At minute 3, nums[2] does not exist.
                 At minute 5, nums[0] is 0.

    Example 2:
    Input: nums = [2], queries = [[0,0],[1,0],[2,0],[3,0]]
    Output: [2,-1,2,-1]
    Explanation: Minute 0: [2] - All elements are in the nums.
                 Minute 1: []  - The leftmost element, 2, is removed.
                 Minute 2: [2] - 2 is added to the end of nums.
                 Minute 3: []  - The leftmost element, 2, is removed.
                 At minute 0, nums[0] is 2.
                 At minute 1, nums[0] does not exist.
                 At minute 2, nums[0] is 2.
                 At minute 3, nums[0] does not exist.

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 100
    * n == queries.length
    * 1 <= n <= 10^5
    * queries[j].length == 2
    * 0 <= timej <= 10^5
    * 0 <= indexj < nums.length*/

    vector<int> elementInNums(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> ans;
        for (auto& q : queries) {
            int t = q[0] % (2*n), i = q[1];
            if (t < n - i) ans.push_back(nums[i+t]);
            else if (t <= n+i) ans.push_back(-1);
            else ans.push_back(nums[i]);
        }
        return ans;
    }


    /*2114. Maximum Number of Words Found in Sentences (Easy)
    A sentence is a list of words that are separated by a single space with no
    leading or trailing spaces. You are given an array of strings sentences,
    where each sentences[i] represents a single sentence. Return the maximum
    number of words that appear in a single sentence.

    Example 1:
    Input: sentences = ["alice and bob love leetcode", "i think so too", "this is great thanks very much"]
    Output: 6
    Explanation:
    - The first sentence, "alice and bob love leetcode", has 5 words in total.
    - The second sentence, "i think so too", has 4 words in total.
    - The third sentence, "this is great thanks very much", has 6 words in total.
    Thus, the maximum number of words in a single sentence comes from the third
    sentence, which has 6 words.

    Example 2:
    Input: sentences = ["please wait", "continue to fight", "continue to win"]
    Output: 3
    Explanation: It is possible that multiple sentences contain the same number
                 of words. In this example, the second and third sentences
                 (underlined) have the same number of words.

    Constraints:
    * 1 <= sentences.length <= 100
    * 1 <= sentences[i].length <= 100
    * sentences[i] consists only of lowercase English letters and ' ' only.
    * sentences[i] does not have leading or trailing spaces.
    * All the words in sentences[i] are separated by a single space.*/

    int mostWordsFound(vector<string>& sentences) {
        int ans = 0;
        for (auto& s : sentences) {
            int cnt = 0;
            istringstream iss(s);
            for (string buf; iss >> buf; ++cnt);
            ans = max(ans, cnt);
        }
        return ans;
    }


    /*2115. Find All Possible Recipes from Given Supplies (Medium)
    You have information about n different recipes. You are given a string
    array recipes and a 2D string array ingredients. The ith recipe has the
    name recipes[i], and you can create it if you have all the needed
    ingredients from ingredients[i]. Ingredients to a recipe may need to be
    created from other recipes, i.e., ingredients[i] may contain a string that
    is in recipes. You are also given a string array supplies containing all
    the ingredients that you initially have, and you have an infinite supply of
    all of them. Return a list of all the recipes that you can create. You may
    return the answer in any order. Note that two recipes may contain each
    other in their ingredients.

    Example 1:
    Input: recipes = ["bread"], ingredients = [["yeast","flour"]], supplies = ["yeast","flour","corn"]
    Output: ["bread"]
    Explanation: We can create "bread" since we have the ingredients "yeast"
                 and "flour".

    Example 2:
    Input: recipes = ["bread","sandwich"], ingredients = [["yeast","flour"],["bread","meat"]], supplies = ["yeast","flour","meat"]
    Output: ["bread","sandwich"]
    Explanation: We can create "bread" since we have the ingredients "yeast"
                 and "flour". We can create "sandwich" since we have the
                 ingredient "meat" and can create the ingredient "bread".

    Example 3:
    Input: recipes = ["bread","sandwich","burger"], ingredients = [["yeast","flour"],["bread","meat"],["sandwich","meat","bread"]], supplies = ["yeast","flour","meat"]
    Output: ["bread","sandwich","burger"]
    Explanation: We can create "bread" since we have the ingredients "yeast"
                 and "flour". We can create "sandwich" since we have the
                 ingredient "meat" and can create the ingredient "bread". We
                 can create "burger" since we have the ingredient "meat" and
                 can create the ingredients "bread" and "sandwich".

    Constraints:
    * n == recipes.length == ingredients.length
    * 1 <= n <= 100
    * 1 <= ingredients[i].length, supplies.length <= 100
    * 1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10
    * recipes[i], ingredients[i][j], and supplies[k] consist only of lowercase
      English letters.
    * All the values of recipes and supplies combined are unique.
    * Each ingredients[i] does not contain any duplicate values.*/

    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {
        unordered_map<string, int> indeg;
        unordered_map<string, vector<string>> graph;
        for (int i = 0; i < recipes.size(); ++i) {
            indeg[recipes[i]] = ingredients[i].size();
            for (auto& ing : ingredients[i]) graph[ing].push_back(recipes[i]);
        }

        vector<string> ans;
        unordered_set<string> st(recipes.begin(), recipes.end());
        deque<string> q(supplies.begin(), supplies.end());
        while (q.size()) {
            string x = q.front(); q.pop_front();
            if (st.count(x)) ans.push_back(x);
            for (auto& xx : graph[x])
                if(--indeg[xx] == 0) q.push_back(xx);
        }
        return ans;
    }


    /*2116. Check if a Parentheses String Can Be Valid (Medium)
    A parentheses string is a non-empty string consisting only of '(' and ')'.
    It is valid if any of the following conditions is true:
    * It is ().
    * It can be written as AB (A concatenated with B), where A and B are valid
      parentheses strings.
    * It can be written as (A), where A is a valid parentheses string.
    You are given a parentheses string s and a string locked, both of length n.
    locked is a binary string consisting only of '0's and '1's. For each index
    i of locked,
    * If locked[i] is '1', you cannot change s[i].
    * But if locked[i] is '0', you can change s[i] to either '(' or ')'.
    Return true if you can make s a valid parentheses string. Otherwise, return
    false.

    Example 1:
    Input: s = "))()))", locked = "010100"
    Output: true
    Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1]
                 or s[3]. We change s[0] and s[4] to '(' while leaving s[2] and
                 s[5] unchanged to make s valid.

    Example 2:
    Input: s = "()()", locked = "0000"
    Output: true
    Explanation: We do not need to make any changes because s is already valid.

    Example 3:
    Input: s = ")", locked = "0"
    Output: false
    Explanation: locked permits us to change s[0]. Changing s[0] to either '('
                 or ')' will not make s valid.

    Constraints:
    * n == s.length == locked.length
    * 1 <= n <= 10^5
    * s[i] is either '(' or ')'.
    * locked[i] is either '0' or '1'.*/

    bool canBeValid(string s, string locked) {
        if (s.size() & 1) return false;
        for (int i = 0, bal = 0; i < s.size(); ++i) {
            if (locked[i] == '0' || s[i] == '(') bal += 1;
            else bal -= 1;
            if (bal < 0) return false;
        }
        for (int i = s.size()-1, bal = 0; 0 <= i; --i) {
            if (locked[i] == '0' || s[i] == ')') bal += 1;
            else bal -= 1;
            if (bal < 0) return false;
        }
        return true;
    }


    /*2117. Abbreviating the Product of a Range (Hard)
    You are given two positive integers left and right with left <= right.
    Calculate the product of all integers in the inclusive range [left, right].
    Since the product may be very large, you will abbreviate it following these
    steps:
    * Count all trailing zeros in the product and remove them. Let us denote
      this count as C.
      For example, there are 3 trailing zeros in 1000, and there are 0 trailing
      zeros in 546.
    * Denote the remaining number of digits in the product as d. If d > 10,
      then express the product as <pre>...<suf> where <pre> denotes the first 5
      digits of the product, and <suf> denotes the last 5 digits of the product
      after removing all trailing zeros. If d <= 10, we keep it unchanged.
      For example, we express 1234567654321 as 12345...54321, but 1234567 is
      represented as 1234567.
    * Finally, represent the product as a string "<pre>...<suf>eC".
      For example, 12345678987600000 will be represented as "12345...89876e5".
    Return a string denoting the abbreviated product of all integers in the
    inclusive range [left, right].

    Example 1:
    Input: left = 1, right = 4
    Output: "24e0"
    Explanation: The product is 1 × 2 × 3 × 4 = 24. There are no trailing zeros,
                 so 24 remains the same. The abbreviation will end with "e0".
                 Since the number of digits is 2, which is less than 10, we do
                 not have to abbreviate it further. Thus, the final
                 representation is "24e0".

    Example 2:
    Input: left = 2, right = 11
    Output: "399168e2"
    Explanation: The product is 39916800. There are 2 trailing zeros, which we
                 remove to get 399168. The abbreviation will end with "e2". The
                 number of digits after removing the trailing zeros is 6, so we
                 do not abbreviate it further. Hence, the abbreviated product
                 is "399168e2".

    Example 3:
    Input: left = 999998, right = 1000000
    Output: "99999...00002e6"
    Explanation: The above diagram shows how we abbreviate the product to
                 "99999...00002e6".
                 - It has 6 trailing zeros. The abbreviation will end with "e6".
                 - The first 5 digits are 99999.
                 - The last 5 digits after removing trailing zeros is 00002.

    Constraints: 1 <= left <= right <= 10^6*/

    string abbreviateProduct(int left, int right) {
        int highest = 0, trailing = 0;
        long prefix = 1, suffix = 1;

        for (int x = left; x <= right; ++x) {
            prefix *= x;
            suffix *= x;
            for (; prefix >= 1e12; ++highest, prefix /= 10);
            for (; suffix % 10 == 0; ++trailing, suffix /= 10);
            if (suffix >= 1e10) suffix %= 10'000'000'000;
        }

        for (; prefix >= 1e5; ++highest, prefix /= 10);
        highest += log10(prefix);
        if (highest - trailing < 10) return to_string(suffix) + "e" + to_string(trailing);
        suffix %= 100'000;
        return to_string(prefix) + "..." + string(5-to_string(suffix).size(), '0') + to_string(suffix) + "e" + to_string(trailing);
    }


    /*2119. A Number After a Double Reversal (Easy)
    Reversing an integer means to reverse all its digits. For example,
    reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros
    are not retained. Given an integer num, reverse num to get reversed1, then
    reverse reversed1 to get reversed2. Return true if reversed2 equals num.
    Otherwise return false.

    Example 1:
    Input: num = 526
    Output: true
    Explanation: Reverse num to get 625, then reverse 625 to get 526, which
                 equals num.

    Example 2:
    Input: num = 1800
    Output: false
    Explanation: Reverse num to get 81, then reverse 81 to get 18, which does
                 not equal num.

    Example 3:
    Input: num = 0
    Output: true
    Explanation: Reverse num to get 0, then reverse 0 to get 0, which equals
                 num.

    Constraints: 0 <= num <= 10^6*/

    bool isSameAfterReversals(int num) {
        return num == 0 || num % 10;
    }


    /*2120. Execution of All Suffix Instructions Staying in a Grid (Medium)
    There is an n x n grid, with the top-left cell at (0, 0) and the bottom-
    right cell at (n - 1, n - 1). You are given the integer n and an integer
    array startPos where startPos = [startrow, startcol] indicates that a robot
    is initially at cell (startrow, startcol). You are also given a 0-indexed
    string s of length m where s[i] is the ith instruction for the robot:
    'L' (move left), 'R' (move right), 'U' (move up), and 'D' (move down).
    The robot can begin executing from any ith instruction in s. It executes
    the instructions one by one towards the end of s but it stops if either of
    these conditions is met:
    * The next instruction will move the robot off the grid.
    * There are no more instructions left to execute.
    Return an array answer of length m where answer[i] is the number of
    instructions the robot can execute if the robot begins executing from the
    ith instruction in s.

    Example 1:
    Input: n = 3, startPos = [0,1], s = "RRDDLU"
    Output: [1,5,4,3,1,0]
    Explanation: Starting from startPos and beginning execution from the ith instruction:
    - 0th: "RRDDLU". Only one instruction "R" can be executed before it moves off the grid.
    - 1st:  "RDDLU". All five instructions can be executed while it stays in the grid and ends at (1, 1).
    - 2nd:   "DDLU". All four instructions can be executed while it stays in the grid and ends at (1, 0).
    - 3rd:    "DLU". All three instructions can be executed while it stays in the grid and ends at (0, 0).
    - 4th:     "LU". Only one instruction "L" can be executed before it moves off the grid.
    - 5th:      "U". If moving up, it would move off the grid.

    Example 2:
    Input: n = 2, startPos = [1,1], s = "LURD"
    Output: [4,1,0,0]
    Explanation: - 0th: "LURD".
                 - 1st:  "URD".
                 - 2nd:   "RD".
                 - 3rd:    "D".

    Example 3:
    Input: n = 1, startPos = [0,0], s = "LRUD"
    Output: [0,0,0,0]
    Explanation: No matter which instruction the robot begins execution from,
                 it would move off the grid.

    Constraints:
    * m == s.length
    * 1 <= n, m <= 500
    * startPos.length == 2
    * 0 <= startrow, startcol < n
    * s consists of 'L', 'R', 'U', and 'D'.*/

    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {
        vector<int> ans;
        for (int i = 0; i < s.size(); ++i) {
            int x = startPos[0], y = startPos[1], val = 0;
            for (int ii = i; ii < s.size(); ++ii) {
                if (s[ii] == 'L') y -= 1;
                else if (s[ii] == 'R') y += 1;
                else if (s[ii] == 'U') x -= 1;
                else x += 1;
                if (0 <= x && x < n && 0 <= y && y < n) ++val;
                else break;
            }
            ans.push_back(val);
        }
        return ans;
    }


    /*2121. Intervals Between Identical Elements (Medium)
    You are given a 0-indexed array of n integers arr. The interval between two
    elements in arr is defined as the absolute difference between their indices.
    More formally, the interval between arr[i] and arr[j] is |i - j|. Return an
    array intervals of length n where intervals[i] is the sum of intervals
    between arr[i] and each element in arr with the same value as arr[i]. Note:
    |x| is the absolute value of x.

    Example 1:
    Input: arr = [2,1,3,1,2,3,3]
    Output: [4,2,7,2,4,4,5]
    Explanation:
    - Index 0: Another 2 is found at index 4. |0 - 4| = 4
    - Index 1: Another 1 is found at index 3. |1 - 3| = 2
    - Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7
    - Index 3: Another 1 is found at index 1. |3 - 1| = 2
    - Index 4: Another 2 is found at index 0. |4 - 0| = 4
    - Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4
    - Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5

    Example 2:
    Input: arr = [10,5,10,10]
    Output: [5,0,3,4]
    Explanation:
    - Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5
    - Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.
    - Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3
    - Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4

    Constraints:
    * n == arr.length
    * 1 <= n <= 10^5
    * 1 <= arr[i] <= 10^5*/

    vector<long long> getDistances(vector<int>& arr) {
        unordered_map<int, vector<int>> loc;
        for (int i = 0; i < arr.size(); ++i) loc[arr[i]].push_back(i);

        unordered_map<int, deque<long long>> mp;
        for (auto& [k, v] : loc) {
            vector<long long> prefix(1ll);
            for (auto& x : v) prefix.push_back(prefix.back() + x);
            deque<long long> vals;
            for (int i = 0; i < v.size(); ++i)
                vals.push_back(prefix.back() - prefix[i] - prefix[i+1] - (long long) (v.size()-2*i-1)*v[i]);
            mp[k] = vals;
        }

        vector<long long> ans;
        for (auto& x : arr) {
            ans.push_back(mp[x].front());
            mp[x].pop_front();
        }
        return ans;
    }


    /*2122. Recover the Original Array (Hard)
    Alice had a 0-indexed array arr consisting of n positive integers. She
    chose an arbitrary positive integer k and created two new 0-indexed integer
    arrays lower and higher in the following manner:
    * lower[i] = arr[i] - k, for every index i where 0 <= i < n
    * higher[i] = arr[i] + k, for every index i where 0 <= i < n
    Unfortunately, Alice lost all three arrays. However, she remembers the
    integers that were present in the arrays lower and higher, but not the
    array each integer belonged to. Help Alice and recover the original array.
    Given an array nums consisting of 2n integers, where exactly n of the
    integers were present in lower and the remaining in higher, return the
    original array arr. In case the answer is not unique, return any valid
    array. Note: The test cases are generated such that there exists at least
    one valid array arr.

    Example 1:
    Input: nums = [2,10,6,4,8,12]
    Output: [3,7,11]
    Explanation: If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and
                 higher = [4,8,12]. Combining lower and higher gives us
                 [2,6,10,4,8,12], which is a permutation of nums. Another valid
                 possibility is that arr = [5,7,9] and k = 3. In that case,
                 lower = [2,4,6] and higher = [8,10,12].

    Example 2:
    Input: nums = [1,1,3,3]
    Output: [2,2]
    Explanation: If arr = [2,2] and k = 1, we get lower = [1,1] and
                 higher = [3,3]. Combining lower and higher gives us [1,1,3,3],
                 which is equal to nums. Note that arr cannot be [1,3] because
                 in that case, the only possible way to obtain [1,1,3,3] is
                 with k = 0. This is invalid since k must be positive.

    Example 3:
    Input: nums = [5,435]
    Output: [220]
    Explanation: The only possible combination is arr = [220] and k = 215.
                 Using them, we get lower = [5] and higher = [435].

    Constraints:
    * 2 * n == nums.length
    * 1 <= n <= 1000
    * 1 <= nums[i] <= 10^9
    * The test cases are generated such that there exists at least one valid
      array arr.*/

    vector<int> recoverArray(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        map<int, int> cnt;
        for (auto& x : nums) ++cnt[x];

        vector<int> ans;
        for (int i = 1; i < nums.size(); ++i) {
            int diff = nums[i] - nums[0];
            if (diff && diff % 2 == 0) {
                ans.clear();
                bool found = true;
                map<int, int> freq = cnt;
                for (auto& [k, v] : freq) {
                    if (v) {
                        if (freq[k + diff] < v) {found = false; break;}
                        freq[k+diff] -= v;
                        for (; v; --v) ans.push_back(k+diff/2);
                    }
                }
                if (found) break;
            }
        }
        return ans;
    }


    /*2123. Minimum Operations to Remove Adjacent Ones in Matrix (Hard)
    You are given a 0-indexed binary matrix grid. In one operation, you can
    flip any 1 in grid to be 0. A binary matrix is well-isolated if there is no
    1 in the matrix that is 4-directionally connected (i.e., horizontal and
    vertical) to another 1. Return the minimum number of operations to make
    grid well-isolated.

    Example 1:
    Input: grid = [[1,1,0],[0,1,1],[1,1,1]]
    Output: 3
    Explanation: Use 3 operations to change grid[0][1], grid[1][2], and
                 grid[2][1] to 0. After, no more 1's are 4-directionally
                 connected and grid is well-isolated.

    Example 2:
    Input: grid = [[0,0,0],[0,0,0],[0,0,0]]
    Output: 0
    Explanation: There are no 1's in grid and it is well-isolated. No
                 operations were done so return 0.

    Example 3:
    Input: grid = [[0,1],[1,0]]
    Output: 0
    Explanation: None of the 1's are 4-directionally connected and grid is
                 well-isolated. No operations were done so return 0.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 300
    * grid[i][j] is either 0 or 1.*/

    int minimumOperations(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), dir[] = {-1, 0, 1, 0, -1};
        vector<vector<int>> match(m, vector<int>(n, -1));
        vector<vector<int>> seen(m, vector<int>(n, -1));

        function<bool(int, int, int)> dfs = [&](int i, int j, int x) {
            /* Return true if an augmenting path is found via Hungarian algo. */
            for (int k = 0; k < 4; ++k) {
                int ii = i + dir[k], jj = j + dir[k+1];
                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] && seen[ii][jj] != x) {
                    seen[ii][jj] = x;
                    if (match[ii][jj] == -1 || dfs(match[ii][jj]/n, match[ii][jj]%n, x)) {
                        match[ii][jj] = i*n + j;
                        match[i][j] = ii*n + jj;
                        return true;
                    }
                }
            }
            return false;
        };

        int ans = 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] && (i+j)&1 && match[i][j] == -1 && dfs(i, j, seen[i][j] = i*n+j))
                    ++ans;
        return ans;
    }


    /*2124. Check if All A's Appears Before All B's (Easy)
    Given a string s consisting of only the characters 'a' and 'b', return true
    if every 'a' appears before every 'b' in the string. Otherwise, return
    false.

    Example 1:
    Input: s = "aaabbb"
    Output: true
    Explanation: The 'a's are at indices 0, 1, and 2, while the 'b's are at
                 indices 3, 4, and 5. Hence, every 'a' appears before every 'b'
                 and we return true.

    Example 2:
    Input: s = "abab"
    Output: false
    Explanation: There is an 'a' at index 2 and a 'b' at index 1. Hence, not
                 every 'a' appears before every 'b' and we return false.

    Example 3:
    Input: s = "bbb"
    Output: true
    Explanation: There are no 'a's, hence, every 'a' appears before every 'b'
                 and we return true.

    Constraints:
    * 1 <= s.length <= 100
    * s[i] is either 'a' or 'b'.*/

    bool checkString(string s) {
        return s.find("ba") == string::npos;
    }


    /*2125. Number of Laser Beams in a Bank (Medium)
    Anti-theft security devices are activated inside a bank. You are given a 0-
    indexed binary string array bank representing the floor plan of the bank,
    which is an m x n 2D matrix. bank[i] represents the ith row, consisting of
    '0's and '1's. '0' means the cell is empty, while'1' means the cell has a
    security device. There is one laser beam between any two security devices
    if both conditions are met:
    * The two devices are located on two different rows: r1 and r2, where
      r1 < r2.
    * For each row i where r1 < i < r2, there are no security devices in the
      ith row.
    Laser beams are independent, i.e., one beam does not interfere nor join
    with another. Return the total number of laser beams in the bank.

    Example 1:
    Input: bank = ["011001","000000","010100","001000"]
    Output: 8
    Explanation: Between each of the following device pairs, there is one beam.
                 In total, there are 8 beams:
                  * bank[0][1] -- bank[2][1]
                  * bank[0][1] -- bank[2][3]
                  * bank[0][2] -- bank[2][1]
                  * bank[0][2] -- bank[2][3]
                  * bank[0][5] -- bank[2][1]
                  * bank[0][5] -- bank[2][3]
                  * bank[2][1] -- bank[3][2]
                  * bank[2][3] -- bank[3][2]
                 Note that there is no beam between any device on the 0th row
                 with any on the 3rd row. This is because the 2nd row contains
                 security devices, which breaks the second condition.

    Example 2:
    Input: bank = ["000","111","000"]
    Output: 0
    Explanation: There does not exist two devices located on two different rows.

    Constraints:
    * m == bank.length
    * n == bank[i].length
    * 1 <= m, n <= 500
    * bank[i][j] is either '0' or '1'.*/

    int numberOfBeams(vector<string>& bank) {
        int ans = 0, prev = 0;
        for (auto& row : bank) {
            int curr = count(row.begin(), row.end(), '1');
            if (curr) {
                ans += prev * curr;
                prev = curr;
            }
        }
        return ans;
    }


    /*2126. Destroying Asteroids (Medium)
    You are given an integer mass, which represents the original mass of a
    planet. You are further given an integer array asteroids, where asteroids[i]
    is the mass of the ith asteroid. You can arrange for the planet to collide
    with the asteroids in any arbitrary order. If the mass of the planet is
    greater than or equal to the mass of the asteroid, the asteroid is
    destroyed and the planet gains the mass of the asteroid. Otherwise, the
    planet is destroyed. Return true if all asteroids can be destroyed.
    Otherwise, return false.

    Example 1:
    Input: mass = 10, asteroids = [3,9,19,5,21]
    Output: true
    Explanation: One way to order the asteroids is [9,19,5,3,21]:
    - The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19
    - The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38
    - The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43
    - The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46
    - The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67
    All asteroids are destroyed.

    Example 2:
    Input: mass = 5, asteroids = [4,9,23,4]
    Output: false
    Explanation: The planet cannot ever gain enough mass to destroy the
                 asteroid with a mass of 23. After the planet destroys the
                 other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22.
                 This is less than 23, so a collision would not destroy the
                 last asteroid.

    Constraints:
    * 1 <= mass <= 10^5
    * 1 <= asteroids.length <= 10^5
    * 1 <= asteroids[i] <= 10^5*/

    bool asteroidsDestroyed(int mass, vector<int>& asteroids) {
        sort(asteroids.begin(), asteroids.end());
        long m = mass;
        for (auto& x : asteroids) {
            if (m < x) return false;
            m += x;
        }
        return true;
    }


    /*2127. Maximum Employees to Be Invited to a Meeting (Hard)
    A company is organizing a meeting and has a list of n employees, waiting
    to be invited. They have arranged for a large circular table, capable of
    seating any number of employees. The employees are numbered from 0 to n - 1.
    Each employee has a favorite person and they will attend the meeting only
    if they can sit next to their favorite person at the table. The favorite
    person of an employee is not themself. Given a 0-indexed integer array
    favorite, where favorite[i] denotes the favorite person of the ith employee,
    return the maximum number of employees that can be invited to the meeting.

    Example 1:
    Input: favorite = [2,2,1,2]
    Output: 3
    Explanation: The above figure shows how the company can invite employees 0,
                 1, and 2, and seat them at the round table. All employees
                 cannot be invited because employee 2 cannot sit beside
                 employees 0, 1, and 3, simultaneously. Note that the company
                 can also invite employees 1, 2, and 3, and give them their
                 desired seats. The maximum number of employees that can be
                 invited to the meeting is 3.

    Example 2:
    Input: favorite = [1,2,0]
    Output: 3
    Explanation: Each employee is the favorite person of at least one other
                 employee, and the only way the company can invite them is if
                 they invite every employee. The seating arrangement will be
                 the same as that in the figure given in example 1:
                 - Employee 0 will sit between employees 2 and 1.
                 - Employee 1 will sit between employees 0 and 2.
                 - Employee 2 will sit between employees 1 and 0.
                 The maximum number of employees that can be invited to the
                 meeting is 3.

    Example 3:
    Input: favorite = [3,0,1,4,1]
    Output: 4
    Explanation: The above figure shows how the company will invite employees
                 0, 1, 3, and 4, and seat them at the round table. Employee 2
                 cannot be invited because the two spots next to their favorite
                 employee 0 are taken. So the company leaves them out of the
                 meeting. The maximum number of employees that can be invited
                 to the meeting is 4.

    Constraints:
    * n == favorite.length
    * 2 <= n <= 10^5
    * 0 <= favorite[i] <= n - 1
    * favorite[i] != i*/

    int maximumInvitations(vector<int>& favorite) {
        int n = favorite.size();
        vector<vector<int>> graph(n);
        for (int i = 0; i < n; ++i) graph[favorite[i]].push_back(i);

        auto fn = [&](int x, unordered_set<int> seen) {
            int ans = 0;
            deque<int> q; q.push_back(x);
            for (; q.size(); ++ans)
                for (int sz = q.size(); sz; --sz) {
                    int u = q.front(); q.pop_front();
                    for (auto& v : graph[u])
                        if (!seen.count(v)) {
                            seen.insert(v);
                            q.push_back(v);
                        }
                }
            return ans;
        };

        int ans = 0;
        vector<bool> seen(n);
        for (int i = 0; i < n; ++i)
            if (favorite[favorite[i]] == i && !seen[i]) {
                seen[i] = seen[favorite[i]] = true;
                ans += fn(i, {i, favorite[i]}) + fn(favorite[i], {i, favorite[i]});
            }

        vector<int> dp(n);
        for (int i = 0; i < n; ++i)
            if (dp[i] == 0) {
                bool found = false;
                int ii = i, val = 0, cycle = 0;
                unordered_map<int, int> memo;
                for (; !memo.count(ii); ++val, ii = favorite[ii]) {
                    if (dp[ii]) {cycle = dp[ii]; found = true; break; }
                    memo[ii] = val;
                }
                if (!found) cycle = val - memo[ii];
                for (auto& [k, v] : memo) dp[k] = cycle;
            }
        return max(ans, *max_element(dp.begin(), dp.end()));
    }


    /*2128. Remove All Ones With Row and Column Flips (Medium)
    You are given an m x n binary matrix grid. In one operation, you can choose
    any row or column and flip each value in that row or column (i.e., changing
    all 0's to 1's, and all 1's to 0's). Return true if it is possible to
    remove all 1's from grid using any number of operations or false otherwise.

    Example 1:
    Input: grid = [[0,1,0],[1,0,1],[0,1,0]]
    Output: true
    Explanation: One possible way to remove all 1's from grid is to:
                 - Flip the middle row
                 - Flip the middle column

    Example 2:
    Input: grid = [[1,1,0],[0,0,0],[0,0,0]]
    Output: false
    Explanation: It is impossible to remove all 1's from grid.

    Example 3:
    Input: grid = [[0]]
    Output: true
    Explanation: There are no 1's in grid.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 300
    * grid[i][j] is either 0 or 1.*/

    bool removeOnes(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> flip(n);
        for (int j = 0; j < n; ++j) flip[j] = 1^grid[0][j];
        for (int i = 1; i < m; ++i)
            if (grid[i] != grid[0] && grid[i] != flip) return false;
        return true;
    }


    /*2133. Check if Every Row and Column Contains All Numbers (Easy)
    An n x n matrix is valid if every row and every column contains all the
    integers from 1 to n (inclusive). Given an n x n integer matrix matrix,
    return true if the matrix is valid. Otherwise, return false.

    Example 1:
    Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]
    Output: true
    Explanation: In this case, n = 3, and every row and column contains the
                 numbers 1, 2, and 3. Hence, we return true.

    Example 2:
    Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]
    Output: false
    Explanation: In this case, n = 3, but the first row and the first column do
                 not contain the numbers 2 or 3. Hence, we return false.

    Constraints:
    * n == matrix.length == matrix[i].length
    * 1 <= n <= 100
    * 1 <= matrix[i][j] <= n*/

    bool checkValid(vector<vector<int>>& matrix) {
        for (int i = 0, n = matrix.size(); i < n; ++i) {
            bitset<100> row, col;
            for (int j = 0; j < n; ++j)
                row[matrix[i][j]-1] = col[matrix[j][i]-1] = true;
            if (row.count() < n || col.count() < n) return false;
        }
        return true;
    }


    /*2134. Minimum Swaps to Group All 1's Together II (Medium)
    A swap is defined as taking two distinct positions in an array and swapping
    the values in them. A circular array is defined as an array where we
    consider the first element and the last element to be adjacent. Given a
    binary circular array nums, return the minimum number of swaps required to
    group all 1's present in the array together at any location.

    Example 1:
    Input: nums = [0,1,0,1,1,0,0]
    Output: 1
    Explanation: Here are a few of the ways to group all the 1's together:
                 [0,0,1,1,1,0,0] using 1 swap. [0,1,1,1,0,0,0] using 1 swap.
                 [1,1,0,0,0,0,1] using 2 swaps (using the circular property of
                 the array). There is no way to group all 1's together with 0
                 swaps. Thus, the minimum number of swaps required is 1.

    Example 2:
    Input: nums = [0,1,1,1,0,0,1,1,0]
    Output: 2
    Explanation: Here are a few of the ways to group all the 1's together:
                 [1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property
                 of the array). [1,1,1,1,1,0,0,0,0] using 2 swaps. There is no
                 way to group all 1's together with 0 or 1 swaps. Thus, the
                 minimum number of swaps required is 2.

    Example 3:
    Input: nums = [1,1,0,0,1]
    Output: 0
    Explanation: All the 1's are already grouped together due to the circular
                 property of the array. Thus, the minimum number of swaps
                 required is 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1.*/

    int minSwaps(vector<int>& nums) {
        int ans = INT_MAX, ones = count(nums.begin(), nums.end(), 1);
        for (int i = 0, n = nums.size(), prefix = 0; i < n + ones; ++i) {
            prefix += nums[i % n];
            if (i >= ones) prefix -= nums[(i-ones) % n];
            ans = min(ans, ones - prefix);
        }
        return ans;
    }


    /*2135. Count Words Obtained After Adding a Letter (Medium)
    You are given two 0-indexed arrays of strings startWords and targetWords.
    Each string consists of lowercase English letters only. For each string in
    targetWords, check if it is possible to choose a string from startWords and
    perform a conversion operation on it to be equal to that from targetWords.

    The conversion operation is described in the following two steps:
    * Append any lowercase letter that is not present in the string to its end.
      + For example, if the string is "abc", the letters 'd', 'e', or 'y' can
        be added to it, but not 'a'. If 'd' is added, the resulting string will
        be "abcd".
    * Rearrange the letters of the new string in any arbitrary order.
      + For example, "abcd" can be rearranged to "acbd", "bacd", "cbda", and so
        on. Note that it can also be rearranged to "abcd" itself.
    Return the number of strings in targetWords that can be obtained by
    performing the operations on any string of startWords. Note that you will
    only be verifying if the string in targetWords can be obtained from a
    string in startWords by performing the operations. The strings in
    startWords do not actually change during this process.

    Example 1:
    Input: startWords = ["ant","act","tack"], targetWords = ["tack","act","acti"]
    Output: 2
    Explanation: - In order to form targetWords[0] = "tack", we use
                   startWords[1] = "act", append 'k' to it, and rearrange "actk"
                   to "tack".
                 - There is no string in startWords that can be used to obtain
                   targetWords[1] = "act". Note that "act" does exist in
                   startWords, but we must append one letter to the string
                   before rearranging it.
                 - In order to form targetWords[2] = "acti", we use
                   startWords[1] = "act", append 'i' to it, and rearrange "acti"
                   to "acti" itself.

    Example 2:
    Input: startWords = ["ab","a"], targetWords = ["abc","abcd"]
    Output: 1
    Explanation: - In order to form targetWords[0] = "abc", we use
                   startWords[0] = "ab", add 'c' to it, and rearrange it to
                   "abc".
                 - There is no string in startWords that can be used to obtain
                   targetWords[1] = "abcd".

    Constraints:
    * 1 <= startWords.length, targetWords.length <= 5 * 10^4
    * 1 <= startWords[i].length, targetWords[j].length <= 26
    * Each string of startWords and targetWords consists of lowercase English
      letters only.
    * No letter occurs more than once in any string of startWords or
      targetWords.*/

    int wordCount(vector<string>& startWords, vector<string>& targetWords) {
        unordered_set<int> st;
        for (auto& word : startWords) {
            int m = 0;
            for (auto& ch : word) m ^= 1 << ch-'a';
            st.insert(m);
        }

        int ans = 0;
        for (auto& word : targetWords) {
            int m = 0;
            for (auto& ch : word) m ^= 1 << ch-'a';
            for (auto& ch : word)
                if (st.count(m ^ (1 << ch-'a'))) { ++ans; break; }
        }
        return ans;
    }


    /*2136. Earliest Possible Day of Full Bloom (Hard)
    You have n flower seeds. Every seed must be planted first before it can
    begin to grow, then bloom. Planting a seed takes time and so does the
    growth of a seed. You are given two 0-indexed integer arrays plantTime and
    growTime, of length n each:
    * plantTime[i] is the number of full days it takes you to plant the ith
      seed. Every day, you can work on planting exactly one seed. You do not
      have to work on planting the same seed on consecutive days, but the
      planting of a seed is not complete until you have worked plantTime[i]
      days on planting it in total.
    * growTime[i] is the number of full days it takes the ith seed to grow
      after being completely planted. After the last day of its growth, the
      flower blooms and stays bloomed forever.
    From the beginning of day 0, you can plant the seeds in any order. Return
    the earliest possible day where all seeds are blooming.

    Example 1:
    Input: plantTime = [1,4,3], growTime = [2,3,1]
    Output: 9
    Explanation: The grayed out pots represent planting days, colored pots
                 represent growing days, and the flower represents the day it
                 blooms.
                 One optimal way is:
                 - On day 0, plant the 0th seed. The seed grows for 2 full days
                   and blooms on day 3.
                 - On days 1, 2, 3, and 4, plant the 1st seed. The seed grows
                   for 3 full days and blooms on day 8.
                 - On days 5, 6, and 7, plant the 2nd seed. The seed grows for
                   1 full day and blooms on day 9.
                 Thus, on day 9, all the seeds are blooming.

    Example 2:
    Input: plantTime = [1,2,3,2], growTime = [2,1,2,1]
    Output: 9
    Explanation: The grayed out pots represent planting days, colored pots
                 represent growing days, and the flower represents the day it
                 blooms.
                 One optimal way is:
                 - On day 1, plant the 0th seed. The seed grows for 2 full days
                   and blooms on day 4.
                 - On days 0 and 3, plant the 1st seed. The seed grows for 1
                   full day and blooms on day 5.
                 - On days 2, 4, and 5, plant the 2nd seed. The seed grows for
                   2 full days and blooms on day 8.
                 - On days 6 and 7, plant the 3rd seed. The seed grows for 1
                   full day and blooms on day 9.
                 Thus, on day 9, all the seeds are blooming.

    Example 3:
    Input: plantTime = [1], growTime = [1]
    Output: 2
    Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day
                 and blooms on day 2. Thus, on day 2, all the seeds are
                 blooming.

    Constraints:
    * n == plantTime.length == growTime.length
    * 1 <= n <= 10^5
    * 1 <= plantTime[i], growTime[i] <= 10^4*/

    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {
        vector<pair<int, int>> aug;
        for (int i = 0; i < plantTime.size(); ++i)
            aug.emplace_back(plantTime[i], growTime[i]);

        sort(aug.begin(), aug.end(), [&](auto& lhs, auto& rhs) {return lhs.second > rhs.second;});

        int ans = 0;
        for (int i = 0, prefix = 0; i < aug.size(); ++i) {
            prefix += aug[i].first;
            ans = max(ans, prefix + aug[i].second);
        }
        return ans;
    }


    /*2137. Pour Water Between Buckets to Make Water Levels Equal (Medium)
    You have n buckets each containing some gallons of water in it, represented
    by a 0-indexed integer array buckets, where the ith bucket contains
    buckets[i] gallons of water. You are also given an integer loss. You want
    to make the amount of water in each bucket equal. You can pour any amount
    of water from one bucket to another bucket (not necessarily an integer).
    However, every time you pour k gallons of water, you spill loss percent of
    k. Return the maximum amount of water in each bucket after making the
    amount of water equal. Answers within 10-5 of the actual answer will be
    accepted.

    Example 1:
    Input: buckets = [1,2,7], loss = 80
    Output: 2.00000
    Explanation: Pour 5 gallons of water from buckets[2] to buckets[0].
                 5 * 80% = 4 gallons are spilled and buckets[0] only receives
                 5 - 4 = 1 gallon of water. All buckets have 2 gallons of water
                 in them so return 2.

    Example 2:
    Input: buckets = [2,4,6], loss = 50
    Output: 3.50000
    Explanation: Pour 0.5 gallons of water from buckets[1] to buckets[0].
                 0.5 * 50% = 0.25 gallons are spilled and buckets[0] only
                 receives 0.5 - 0.25 = 0.25 gallons of water. Now,
                 buckets = [2.25, 3.5, 6]. Pour 2.5 gallons of water from
                 buckets[2] to buckets[0]. 2.5 * 50% = 1.25 gallons are spilled
                 and buckets[0] only receives 2.5 - 1.25 = 1.25 gallons of
                 water. All buckets have 3.5 gallons of water in them so return
                 3.5.

    Example 3:
    Input: buckets = [3,3,3,3], loss = 40
    Output: 3.00000
    Explanation: All buckets already have the same amount of water in them.

    Constraints:
    * 1 <= buckets.length <= 10^5
    * 0 <= buckets[i] <= 10^5
    * 0 <= loss <= 99*/

    double equalizeWater(vector<int>& buckets, int loss) {
        sort(buckets.begin(), buckets.end());
        double ans = 0, prefix = 0, total = accumulate(buckets.begin(), buckets.end(), 0.);
        for (int i = 0, n = buckets.size(); i < n; prefix += buckets[i++]) {
            double cand = (prefix + (1-loss/100.)*(total-prefix))/(i + (1-loss/100.)*(n-i));
            if ((i == 0 || buckets[i-1] <= cand) && cand <= buckets[i]) ans = max(ans, cand);
        }
        return ans;
    }


    /*2138. Divide a String Into Groups of Size k (Easy)
    A string s can be partitioned into groups of size k using the following
    procedure:
    * The first group consists of the first k characters of the string, the
      second group consists of the next k characters of the string, and so on.
      Each character can be a part of exactly one group.
    * For the last group, if the string does not have k characters remaining, a
      character fill is used to complete the group.
    Note that the partition is done so that after removing the fill character
    from the last group (if it exists) and concatenating all the groups in
    order, the resultant string should be s. Given the string s, the size of
    each group k and the character fill, return a string array denoting the
    composition of every group s has been divided into, using the above
    procedure.

    Example 1:
    Input: s = "abcdefghi", k = 3, fill = "x"
    Output: ["abc","def","ghi"]
    Explanation: The first 3 characters "abc" form the first group. The next 3
                 characters "def" form the second group. The last 3 characters
                 "ghi" form the third group. Since all groups can be completely
                 filled by characters from the string, we do not need to use
                 fill. Thus, the groups formed are "abc", "def", and "ghi".

    Example 2:
    Input: s = "abcdefghij", k = 3, fill = "x"
    Output: ["abc","def","ghi","jxx"]
    Explanation: Similar to the previous example, we are forming the first
                 three groups "abc", "def", and "ghi". For the last group, we
                 can only use the character 'j' from the string. To complete
                 this group, we add 'x' twice. Thus, the 4 groups formed are
                 "abc", "def", "ghi", and "jxx".

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters only.
    * 1 <= k <= 100
    * fill is a lowercase English letter.*/

    vector<string> divideString(string s, int k, char fill) {
        vector<string> ans;
        for (int i = 0; i < s.size(); i += k) {
            string ss = s.substr(i, k);
            ans.push_back(ss + string(k - ss.size(), fill));
        }
        return ans;
    }


    /*2139. Minimum Moves to Reach Target Score (Medium)
    You are playing a game with integers. You start with the integer 1 and you
    want to reach the integer target. In one move, you can either:
    * Increment the current integer by one (i.e., x = x + 1).
    * Double the current integer (i.e., x = 2 * x).
    You can use the increment operation any number of times, however, you can
    only use the double operation at most maxDoubles times. Given the two
    integers target and maxDoubles, return the minimum number of moves needed
    to reach target starting with 1.

    Example 1:
    Input: target = 5, maxDoubles = 0
    Output: 4
    Explanation: Keep incrementing by 1 until you reach target.

    Example 2:
    Input: target = 19, maxDoubles = 2
    Output: 7
    Explanation: Initially, x = 1
                 Increment 3 times so x = 4
                 Double once so x = 8
                 Increment once so x = 9
                 Double again so x = 18
                 Increment once so x = 19

    Example 3:
    Input: target = 10, maxDoubles = 4
    Output: 4
    Explanation: Initially, x = 1
                 Increment once so x = 2
                 Double once so x = 4
                 Increment once so x = 5
                 Double again so x = 10

    Constraints:
    * 1 <= target <= 10^9
    * 0 <= maxDoubles <= 100*/

    int minMoves(int target, int maxDoubles) {
        int ans = 0;
        for (; target > 1 && maxDoubles; ++ans)
            if (target&1) --target;
            else if (maxDoubles) {
                --maxDoubles;
                target >>= 1;
            }
        return ans + target - 1;
    }


    /*2140. Solving Questions With Brainpower (Medium)
    You are given a 0-indexed 2D integer array questions where
    questions[i] = [pointsi, brainpoweri]. The array describes the questions of
    an exam, where you have to process the questions in order (i.e., starting
    from question 0) and make a decision whether to solve or skip each question.
    Solving question i will earn you pointsi points but you will be unable to
    solve each of the next brainpoweri questions. If you skip question i, you
    get to make the decision on the next question.
    * For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:
      + If question 0 is solved, you will earn 3 points but you will be unable
        to solve questions 1 and 2.
      + If instead, question 0 is skipped and question 1 is solved, you will
        earn 4 points but you will be unable to solve questions 2 and 3.
    Return the maximum points you can earn for the exam.

    Example 1:
    Input: questions = [[3,2],[4,3],[4,4],[2,5]]
    Output: 5
    Explanation: The maximum points can be earned by solving questions 0 and 3.
                 - Solve question 0: Earn 3 points, will be unable to solve the
                   next 2 questions
                 - Unable to solve questions 1 and 2
                 - Solve question 3: Earn 2 points
                 Total points earned: 3 + 2 = 5. There is no other way to earn
                 5 or more points.

    Example 2:
    Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
    Output: 7
    Explanation: The maximum points can be earned by solving questions 1 and 4.
                 - Skip question 0
                 - Solve question 1: Earn 2 points, will be unable to solve the
                   next 2 questions
                 - Unable to solve questions 2 and 3
                 - Solve question 4: Earn 5 points
                 Total points earned: 2 + 5 = 7. There is no other way to earn
                 7 or more points.

    Constraints:
    * 1 <= questions.length <= 10^5
    * questions[i].length == 2
    * 1 <= pointsi, brainpoweri <= 10^5*/

    long long mostPoints(vector<vector<int>>& questions) {
        int n = questions.size();
        vector<long long> dp(n+1);
        for (int i = n-1; i >= 0; --i) {
            dp[i] = dp[i+1];
            long long cand = questions[i][0];
            if (i + questions[i][1] + 1 <= n) cand += dp[i+questions[i][1]+1];
            dp[i] = max(dp[i], cand);
        }
        return dp[0];
    }


    /*2141. Maximum Running Time of N Computers (Hard)
    You have n computers. You are given the integer n and a 0-indexed integer
    array batteries where the ith battery can run a computer for batteries[i]
    minutes. You are interested in running all n computers simultaneously using
    the given batteries. Initially, you can insert at most one battery into
    each computer. After that and at any integer time moment, you can remove a
    battery from a computer and insert another battery any number of times. The
    inserted battery can be a totally new battery or a battery from another
    computer. You may assume that the removing and inserting processes take no
    time. Note that the batteries cannot be recharged. Return the maximum
    number of minutes you can run all the n computers simultaneously.

    Example 1:
    Input: n = 2, batteries = [3,3,3]
    Output: 4
    Explanation: Initially, insert battery 0 into the first computer and
                 battery 1 into the second computer. After two minutes, remove
                 battery 1 from the second computer and insert battery 2
                 instead. Note that battery 1 can still run for one minute. At
                 the end of the third minute, battery 0 is drained, and you
                 need to remove it from the first computer and insert battery 1
                 instead. By the end of the fourth minute, battery 1 is also
                 drained, and the first computer is no longer running. We can
                 run the two computers simultaneously for at most 4 minutes, so
                 we return 4.

    Example 2:
    Input: n = 2, batteries = [1,1,1,1]
    Output: 2
    Explanation: Initially, insert battery 0 into the first computer and
                 battery 2 into the second computer. After one minute, battery
                 0 and battery 2 are drained so you need to remove them and
                 insert battery 1 into the first computer and battery 3 into
                 the second computer. After another minute, battery 1 and
                 battery 3 are also drained so the first and second computers
                 are no longer running. We can run the two computers
                 simultaneously for at most 2 minutes, so we return 2.

    Constraints:
    * 1 <= n <= batteries.length <= 10^5
    * 1 <= batteries[i] <= 10^9*/

    long long maxRunTime(int n, vector<int>& batteries) {
        sort(batteries.begin(), batteries.end());
        long long extra = 0;
        for (int i = 0; i < batteries.size()-n; ++i) extra += batteries[i];

        long long ans = 0, prefix = 0;
        for (int i = batteries.size()-n, k = 1; i < batteries.size(); ++i, ++k) {
            prefix += batteries[i];
            if (i+1 < batteries.size() && (long long) batteries[i+1]*k - prefix > extra) return (prefix+extra)/k;
        }
        return (prefix+extra)/n;
    }


    /*2143. Choose Numbers From Two Arrays in Range (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2 of length n. A
    range [l, r] (inclusive) where 0 <= l <= r < n is balanced if:
    * For every i in the range [l, r], you pick either nums1[i] or nums2[i].
    * The sum of the numbers you pick from nums1 equals to the sum of the
      numbers you pick from nums2 (the sum is considered to be 0 if you pick no
      numbers from an array).
    Two balanced ranges from [l1, r1] and [l2, r2] are considered to be
    different if at least one of the following is true:
    * l1 != l2
    * r1 != r2
    * nums1[i] is picked in the first range, and nums2[i] is picked in the
      second range or vice versa for at least one i.
    Return the number of different ranges that are balanced. Since the answer
    may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums1 = [1,2,5], nums2 = [2,6,3]
    Output: 3
    Explanation: The balanced ranges are:
                 - [0, 1] where we choose nums2[0], and nums1[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 2 = 2.
                 - [0, 2] where we choose nums1[0], nums2[1], and nums1[2].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 1 + 5 = 6.
                 - [0, 2] where we choose nums1[0], nums1[1], and nums2[2].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 1 + 2 = 3.
                 Note that the second and third balanced ranges are different.
                 In the second balanced range, we choose nums2[1] and in the
                 third balanced range, we choose nums1[1].

    Example 2:
    Input: nums1 = [0,1], nums2 = [1,0]
    Output: 4
    Explanation: The balanced ranges are:
                 - [0, 0] where we choose nums1[0].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 0 = 0.
                 - [1, 1] where we choose nums2[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 0 = 0.
                 - [0, 1] where we choose nums1[0] and nums2[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 0 = 0.
                 - [0, 1] where we choose nums2[0] and nums1[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 1 = 1.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 100
    * 0 <= nums1[i], nums2[i] <= 100*/

    int countSubranges(vector<int>& nums1, vector<int>& nums2) {
        const int mod = 1'000'000'007;
        long ans = 0;
        unordered_map<int, long> freq;
        for (int i = 0; i < nums1.size(); ++i) {
            unordered_map<int, long> ff;
            ++ff[nums1[i]];
            ++ff[-nums2[i]];
            for (auto& [k, v] : freq) {
                ff[k+nums1[i]] = (ff[k+nums1[i]] + v) % mod;
                ff[k-nums2[i]] = (ff[k-nums2[i]] + v) % mod;
            }
            freq = ff;
            ans = (ans + freq[0]) % mod;
        }
        return ans;
    }


    /*2144. Minimum Cost of Buying Candies With Discount (Easy)
    A shop is selling candies at a discount. For every two candies sold, the
    shop gives a third candy for free. The customer can choose any candy to
    take away for free as long as the cost of the chosen candy is less than or
    equal to the minimum cost of the two candies bought. For example, if there
    are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with
    costs 2 and 3, they can take the candy with cost 1 for free, but not the
    candy with cost 4. Given a 0-indexed integer array cost, where cost[i]
    denotes the cost of the ith candy, return the minimum cost of buying all
    the candies.

    Example 1:
    Input: cost = [1,2,3]
    Output: 5
    Explanation: We buy the candies with costs 2 and 3, and take the candy with
                 cost 1 for free. The total cost of buying all candies is
                 2 + 3 = 5. This is the only way we can buy the candies. Note
                 that we cannot buy candies with costs 1 and 3, and then take
                 the candy with cost 2 for free. The cost of the free candy has
                 to be less than or equal to the minimum cost of the purchased
                 candies.

    Example 2:
    Input: cost = [6,5,7,9,2,2]
    Output: 23
    Explanation: The way in which we can get the minimum cost is described below:
                 - Buy candies with costs 9 and 7
                 - Take the candy with cost 6 for free
                 - We buy candies with costs 5 and 2
                 - Take the last remaining candy with cost 2 for free
                 Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.

    Example 3:
    Input: cost = [5,5]
    Output: 10
    Explanation: Since there are only 2 candies, we buy both of them. There is
                 not a third candy we can take for free. Hence, the minimum
                 cost to buy all candies is 5 + 5 = 10.

    Constraints:
    * 1 <= cost.length <= 100
    * 1 <= cost[i] <= 100*/

    int minimumCost(vector<int>& cost) {
        sort(cost.begin(), cost.end(), greater<int>());
        int ans = 0;
        for (int i = 0; i < cost.size(); ++i)
            if ((i+1)%3) ans += cost[i];
        return ans;
    }


    /*2145. Count the Hidden Sequences (Medium)
    You are given a 0-indexed array of n integers differences, which describes
    the differences between each pair of consecutive integers of a hidden
    sequence of length (n + 1). More formally, call the hidden sequence hidden,
    then we have that differences[i] = hidden[i + 1] - hidden[i]. You are
    further given two integers lower and upper that describe the inclusive
    range of values [lower, upper] that the hidden sequence can contain.
    * For example, given differences = [1, -3, 4], lower = 1, upper = 6, the
      hidden sequence is a sequence of length 4 whose elements are in between 1
      and 6 (inclusive).
      [3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences.
      [5, 6, 3, 7] is not possible since it contains an element greater than 6.
      [1, 2, 3, 4] is not possible since the differences are not correct.
    Return the number of possible hidden sequences there are. If there are no
    possible sequences, return 0.

    Example 1:
    Input: differences = [1,-3,4], lower = 1, upper = 6
    Output: 2
    Explanation: The possible hidden sequences are:
                 - [3, 4, 1, 5]
                 - [4, 5, 2, 6]
                 Thus, we return 2.

    Example 2:
    Input: differences = [3,-4,5,1,-2], lower = -4, upper = 5
    Output: 4
    Explanation: The possible hidden sequences are:
                 - [-3, 0, -4, 1, 2, 0]
                 - [-2, 1, -3, 2, 3, 1]
                 - [-1, 2, -2, 3, 4, 2]
                 - [0, 3, -1, 4, 5, 3]
                 Thus, we return 4.

    Example 3:
    Input: differences = [4,-7,2], lower = 3, upper = 6
    Output: 0
    Explanation: There are no possible hidden sequences. Thus, we return 0.

    Constraints:
    * n == differences.length
    * 1 <= n <= 10^5
    * -10^5 <= differences[i] <= 10^5
    * -10^5 <= lower <= upper <= 10^5*/

    int numberOfArrays(vector<int>& differences, int lower, int upper) {
        long prefix = 0, mn = 0, mx = 0;
        for (auto& x : differences) {
            prefix += x;
            mn = min(mn, prefix);
            mx = max(mx, prefix);
        }
        return max(0L, (upper - lower) - (mx - mn) + 1);
    }


    /*2146. K Highest Ranked Items Within a Price Range (Medium)
    You are given a 0-indexed 2D integer array grid of size m x n that
    represents a map of the items in a shop. The integers in the grid represent
    the following:
    * 0 represents a wall that you cannot pass through.
    * 1 represents an empty cell that you can freely move to and from.
    * All other positive integers represent the price of an item in that cell.
      You may also freely move to and from these item cells.
    It takes 1 step to travel between adjacent grid cells. You are also given
    integer arrays pricing and start where pricing = [low, high] and
    start = [row, col] indicates that you start at the position (row, col) and
    are interested only in items with a price in the range of [low, high]
    (inclusive). You are further given an integer k. You are interested in the
    positions of the k highest-ranked items whose prices are within the given
    price range. The rank is determined by the first of these criteria that is
    different:
    * Distance, defined as the length of the shortest path from the start
      (shorter distance has a higher rank).
    * Price (lower price has a higher rank, but it must be in the price range).
    * The row number (smaller row number has a higher rank).
    * The column number (smaller column number has a higher rank).
    Return the k highest-ranked items within the price range sorted by their
    rank (highest to lowest). If there are fewer than k reachable items within
    the price range, return all of them.

    Example 1:
    Input: grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3
    Output: [[0,1],[1,1],[2,1]]
    Explanation: You start at (0,0). With a price range of [2,5], we can take
                 items from (0,1), (1,1), (2,1) and (2,2). The ranks of these
                 items are:
                 - (0,1) with distance 1
                 - (1,1) with distance 2
                 - (2,1) with distance 3
                 - (2,2) with distance 4
                 Thus, the 3 highest ranked items in the price range are (0,1),
                 (1,1), and (2,1).

    Example 2:
    Input: grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2
    Output: [[2,1],[1,2]]
    Explanation: You start at (2,3). With a price range of [2,3], we can take
                 items from (0,1), (1,1), (1,2) and (2,1). The ranks of these
                 items are:
                 - (2,1) with distance 2, price 2
                 - (1,2) with distance 2, price 3
                 - (1,1) with distance 3
                 - (0,1) with distance 4
                 Thus, the 2 highest ranked items in the price range are (2,1)
                 and (1,2).

    Example 3:
    Input: grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3
    Output: [[2,1],[2,0]]
    Explanation: You start at (0,0). With a price range of [2,3], we can take
                 items from (2,0) and (2,1). The ranks of these items are:
                 - (2,1) with distance 5
                 - (2,0) with distance 6
                 Thus, the 2 highest ranked items in the price range are (2,1)
                 and (2,0). Note that k = 3 but there are only 2 reachable
                 items within the price range.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 0 <= grid[i][j] <= 10^5
    * pricing.length == 2
    * 2 <= low <= high <= 10^5
    * start.length == 2
    * 0 <= row <= m - 1
    * 0 <= col <= n - 1
    * grid[row][col] > 0
    * 1 <= k <= m * n*/

    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {
        int m = grid.size(), n = grid[0].size(), i = start[0], j = start[1], dir[5] = {-1, 0, 1, 0, -1};
        vector<vector<int>> vals;
        deque<pair<int, int>> q; q.emplace_back(i, j);
        grid[i][j] *= -1;
        for (int x = 0; q.size(); ++x)
            for (int sz = q.size(); sz; --sz) {
                auto [i, j] = q.front(); q.pop_front();
                if (pricing[0] <= -grid[i][j] && -grid[i][j] <= pricing[1]) vals.push_back({x, -grid[i][j], i, j});
                for (int idx = 0; idx < 4; ++idx) {
                    int ii = i + dir[idx], jj = j + dir[idx+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] > 0) {
                        grid[ii][jj] *= -1;
                        q.emplace_back(ii, jj);
                    }
                }
            }
        sort(vals.begin(), vals.end());
        vector<vector<int>> ans;
        for (int i = 0; i < min(k, (int) vals.size()); ++i) ans.push_back({vals[i][2], vals[i][3]});
        return ans;
    }


    /*2147. Number of Ways to Divide a Long Corridor (Hard)
    Along a long library corridor, there is a line of seats and decorative
    plants. You are given a 0-indexed string corridor of length n consisting of
    letters 'S' and 'P' where each 'S' represents a seat and each 'P'
    represents a plant. One room divider has already been installed to the left
    of index 0, and another to the right of index n - 1. Additional room
    dividers can be installed. For each position between indices i - 1 and i
    (1 <= i <= n - 1), at most one divider can be installed. Divide the
    corridor into non-overlapping sections, where each section has exactly two
    seats with any number of plants. There may be multiple ways to perform the
    division. Two ways are different if there is a position with a room divider
    installed in the first way but not in the second way. Return the number of
    ways to divide the corridor. Since the answer may be very large, return it
    modulo 10^9 + 7. If there is no way, return 0.

    Example 1:
    Input: corridor = "SSPPSPS"
    Output: 3
    Explanation: There are 3 different ways to divide the corridor. The black
                 bars in the above image indicate the two room dividers already
                 installed. Note that in each of the ways, each section has
                 exactly two seats.

    Example 2:
    Input: corridor = "PPSPSP"
    Output: 1
    Explanation: There is only 1 way to divide the corridor, by not installing
                 any additional dividers. Installing any would create some
                 section that does not have exactly two seats.

    Example 3:
    Input: corridor = "S"
    Output: 0
    Explanation: There is no way to divide the corridor because there will
                 always be a section that does not have exactly two seats.

    Constraints:
    * n == corridor.length
    * 1 <= n <= 10^5
    * corridor[i] is either 'S' or 'P'.*/

    int numberOfWays(string corridor) {
        long ans = 1, seats = 0;
        for (int i = 0, ii = 0; i < corridor.size(); ++i)
            if (corridor[i] == 'S') {
                if (seats && seats % 2 == 0) ans = ans * (i - ii) % 1'000'000'007;
                ++seats;
                ii = i;
            }
        return seats && seats % 2 == 0 ? ans : 0;
    }


    /*2148. Count Elements With Strictly Smaller and Greater Elements (Easy)
    Given an integer array nums, return the number of elements that have both a
    strictly smaller and a strictly greater element appear in nums.

    Example 1:
    Input: nums = [11,7,2,15]
    Output: 2
    Explanation: The element 7 has the element 2 strictly smaller than it and
                 the element 11 strictly greater than it. Element 11 has
                 element 7 strictly smaller than it and element 15 strictly
                 greater than it. In total there are 2 elements having both a
                 strictly smaller and a strictly greater element appear in nums.

    Example 2:
    Input: nums = [-3,3,3,90]
    Output: 2
    Explanation: The element 3 has the element -3 strictly smaller than it and
                 the element 90 strictly greater than it. Since there are two
                 elements with the value 3, in total there are 2 elements
                 having both a strictly smaller and a strictly greater element
                 appear in nums.

    Constraints:
    * 1 <= nums.length <= 100
    * -10^5 <= nums[i] <= 10^5*/

    int countElements(vector<int>& nums) {
        int ans = 0, mx = *max_element(nums.begin(), nums.end()), mn = *min_element(nums.begin(), nums.end());
        for (auto& x : nums)
            if (mn < x && x < mx) ++ans;
        return ans;
    }


    /*2149. Rearrange Array Elements by Sign (Medium)
    You are given a 0-indexed integer array nums of even length consisting of
    an equal number of positive and negative integers. You should rearrange the
    elements of nums such that the modified array follows the given conditions:
    * Every consecutive pair of integers have opposite signs.
    * For all integers with the same sign, the order in which they were present
      in nums is preserved.
    * The rearranged array begins with a positive integer.
    Return the modified array after rearranging the elements to satisfy the
    aforementioned conditions.

    Example 1:
    Input: nums = [3,1,-2,-5,2,-4]
    Output: [3,-2,1,-5,2,-4]
    Explanation: The positive integers in nums are [3,1,2]. The negative
                 integers are [-2,-5,-4]. The only possible way to rearrange
                 them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
                 Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4],
                 [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one
                 or more conditions.

    Example 2:
    Input: nums = [-1,1]
    Output: [1,-1]
    Explanation: 1 is the only positive integer and -1 the only negative
                 integer in nums. So nums is rearranged to [1,-1].

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * nums.length is even
    * 1 <= |nums[i]| <= 10^5
    * nums consists of equal number of positive and negative integers.*/

    vector<int> rearrangeArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        int p = 0, n = 1;
        for (auto& x : nums)
            if (x > 0) {
                ans[p] = x;
                p += 2;
            } else {
                ans[n] = x;
                n += 2;
            }
        return ans;
    }


    /*2150. Find All Lonely Numbers in the Array (Medium)
    You are given an integer array nums. A number x is lonely when it appears
    only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the
    array. Return all lonely numbers in nums. You may return the answer in any
    order.

    Example 1:
    Input: nums = [10,6,5,8]
    Output: [10,8]
    Explanation: - 10 is a lonely number since it appears exactly once and 9
                   and 11 does not appear in nums.
                 - 8 is a lonely number since it appears exactly once and 7 and
                   9 does not appear in nums.
                 - 5 is not a lonely number since 6 appears in nums and vice
                   versa.
                 Hence, the lonely numbers in nums are [10, 8]. Note that
                 [8, 10] may also be returned.

    Example 2:
    Input: nums = [1,3,5,3]
    Output: [1,5]
    Explanation: - 1 is a lonely number since it appears exactly once and 0 and
                   2 does not appear in nums.
                 - 5 is a lonely number since it appears exactly once and 4 and
                   6 does not appear in nums.
                 - 3 is not a lonely number since it appears twice.
                 Hence, the lonely numbers in nums are [1, 5]. Note that [5, 1]
                 may also be returned.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6*/

    vector<int> findLonely(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        vector<int> ans;
        for (auto& [k, v] : freq)
            if (v == 1 && !freq.count(k-1) && !freq.count(k+1)) ans.push_back(k);
        return ans;
    }


    /*2151. Maximum Good People Based on Statements (Hard)
    There are two types of persons:
    * The good person: The person who always tells the truth.
    * The bad person: The person who might tell the truth and might lie.
    You are given a 0-indexed 2D integer array statements of size n x n that
    represents the statements made by n people about each other. More
    specifically, statements[i][j] could be one of the following:
    * 0 which represents a statement made by person i that person j is a bad
      person.
    * 1 which represents a statement made by person i that person j is a good
      person.
    * 2 represents that no statement is made by person i about person j.
    Additionally, no person ever makes a statement about themselves. Formally,
    we have that statements[i][i] = 2 for all 0 <= i < n. Return the maximum
    number of people who can be good based on the statements made by the n people.

    Example 1:
    Input: statements = [[2,1,2],[1,2,2],[2,0,2]]
    Output: 2
    Explanation: Each person makes a single statement.
                 - Person 0 states that person 1 is good.
                 - Person 1 states that person 0 is good.
                 - Person 2 states that person 1 is bad.
                 Let's take person 2 as the key.
                 - Assuming that person 2 is a good person:
                     - Based on the statement made by person 2, person 1 is a bad person.
                     - Now we know for sure that person 1 is bad and person 2 is good.
                     - Based on the statement made by person 1, and since person 1 is bad, they could be:
                         - telling the truth. There will be a contradiction in this case and this assumption is invalid.
                         - lying. In this case, person 0 is also a bad person and lied in their statement.
                     - Following that person 2 is a good person, there will be only one good person in the group.
                 - Assuming that person 2 is a bad person:
                     - Based on the statement made by person 2, and since person 2 is bad, they could be:
                         - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.
                             - Following that person 2 is bad but told the truth, there will be no good persons in the group.
                         - lying. In this case person 1 is a good person.
                             - Since person 1 is a good person, person 0 is also a good person.
                             - Following that person 2 is bad and lied, there will be two good persons in the group.
                 We can see that at most 2 persons are good in the best case, so we return 2.
                 Note that there is more than one way to arrive at this conclusion.

    Example 2:
    Input: statements = [[2,0],[0,2]]
    Output: 1
    Explanation: Each person makes a single statement.
                 - Person 0 states that person 1 is bad.
                 - Person 1 states that person 0 is bad.
                 Let's take person 0 as the key.
                 - Assuming that person 0 is a good person:
                     - Based on the statement made by person 0, person 1 is a bad person and was lying.
                     - Following that person 0 is a good person, there will be only one good person in the group.
                 - Assuming that person 0 is a bad person:
                     - Based on the statement made by person 0, and since person 0 is bad, they could be:
                         - telling the truth. Following this scenario, person 0 and 1 are both bad.
                             - Following that person 0 is bad but told the truth, there will be no good persons in the group.
                         - lying. In this case person 1 is a good person.
                             - Following that person 0 is bad and lied, there will be only one good person in the group.
                 We can see that at most, one person is good in the best case, so we return 1.
                 Note that there is more than one way to arrive at this conclusion.

    Constraints:
    * n == statements.length == statements[i].length
    * 2 <= n <= 15
    * statements[i][j] is either 0, 1, or 2.
    * statements[i][i] == 2*/

    int maximumGood(vector<vector<int>>& statements) {
        int ans = 0, n = statements.size();
        for (int m = (1<<n)-1; m >= 0; --m) {
            bool cand = true;
            for (int i = 0; i < n; ++i)
                if ((m & (1<<i)) && cand)
                    for (int j = 0; j < n; ++j)
                        if ((statements[i][j]==1 && !(m & 1<<j)) || (statements[i][j]==0 && (m & 1<<j))) {
                            cand = false;
                            break;
                        }
            if (cand) ans = max(ans, __builtin_popcount(m));
        }
        return ans;
    }


    /*2152. Minimum Number of Lines to Cover Points (Medium)
    You are given an array points where points[i] = [xi, yi] represents a point
    on an X-Y plane. Straight lines are going to be added to the X-Y plane,
    such that every point is covered by at least one line. Return the minimum
    number of straight lines needed to cover all the points.

    Example 1:
    Input: points = [[0,1],[2,3],[4,5],[4,3]]
    Output: 2
    Explanation: The minimum number of straight lines needed is two. One
                 possible solution is to add:
                 - One line connecting the point at (0, 1) to the point at
                   (4, 5).
                 - Another line connecting the point at (2, 3) to the point at
                   (4, 3).

    Example 2:
    Input: points = [[0,2],[-2,-2],[1,4]]
    Output: 1
    Explanation: The minimum number of straight lines needed is one. The only
                 solution is to add:
                 - One line connecting the point at (-2, -2) to the point at
                   (1, 4).

    Constraints:
    * 1 <= points.length <= 10
    * points[i].length == 2
    * -100 <= xi, yi <= 100
    * All the points are unique.*/

    int minimumLines(vector<vector<int>>& points) {
        int n = points.size();
        vector<vector<int>> mask(n, vector<int>(n));
        for (int i = 0; i < n; ++i)
            for (int j = i+1; j < n; ++j) {
                mask[i][j] ^= (1<<i) ^ (1<<j);
                for (int k = j+1; k < n; ++k)
                    if ((points[i][0]-points[j][0])*(points[i][1]-points[k][1]) == (points[i][1]-points[j][1])*(points[i][0]-points[k][0])) mask[i][j] ^= 1<<k;
            }
        vector<int> dp(1<<n, n/2+1);
        dp[0] = 0;
        for (int m = 1; m < 1<<n; ++m)
            if (__builtin_popcount(m) <= 2) dp[m] = 1;
            else {
                int i = 0;
                for (; i < n; ++i)
                    if (m & (1<<i)) break;
                for (int j = i+1; j < n; ++j)
                    if (m & (1<<j)) dp[m] = min(dp[m], 1+dp[m ^ mask[i][j]]);
            }
        return dp.back();
    }


    /*2158. Amount of New Area Painted Each Day (Hard)
    There is a long and thin painting that can be represented by a number line.
    You are given a 0-indexed 2D integer array paint of length n, where
    paint[i] = [starti, endi]. This means that on the ith day you need to paint
    the area between starti and endi. Painting the same area multiple times
    will create an uneven painting so you only want to paint each area of the
    painting at most once. Return an integer array worklog of length n, where
    worklog[i] is the amount of new area that you painted on the ith day.

    Example 1:
    Input: paint = [[1,4],[4,7],[5,8]]
    Output: [3,3,1]
    Explanation: On day 0, paint everything between 1 and 4. The amount of new
                 area painted on day 0 is 4 - 1 = 3. On day 1, paint everything
                 between 4 and 7. The amount of new area painted on day 1 is
                 7 - 4 = 3. On day 2, paint everything between 7 and 8.
                 Everything between 5 and 7 was already painted on day 1. The
                 amount of new area painted on day 2 is 8 - 7 = 1.

    Example 2:
    Input: paint = [[1,4],[5,8],[4,7]]
    Output: [3,3,1]
    Explanation: On day 0, paint everything between 1 and 4. The amount of new
                 area painted on day 0 is 4 - 1 = 3. On day 1, paint everything
                 between 5 and 8. The amount of new area painted on day 1 is
                 8 - 5 = 3. On day 2, paint everything between 4 and 5.
                 Everything between 5 and 7 was already painted on day 1. The
                 amount of new area painted on day 2 is 5 - 4 = 1.

    Example 3:
    Input: paint = [[1,5],[2,4]]
    Output: [4,0]
    Explanation: On day 0, paint everything between 1 and 5. The amount of new
                 area painted on day 0 is 5 - 1 = 4. On day 1, paint nothing
                 because everything between 2 and 4 was already painted on day
                 0. The amount of new area painted on day 1 is 0.

    Constraints:
    * 1 <= paint.length <= 10^5
    * paint[i].length == 2
    * 0 <= starti < endi <= 5 * 10^4*/

    vector<int> amountPainted(vector<vector<int>>& paint) {
        vector<int> ans;
        map<int, int> intervals;
        for (auto& p : paint) {
            int x = p[0], y = p[1], diff = 0;
            auto ptr = intervals.lower_bound(x);
            if (intervals.begin() != ptr && x < prev(ptr)->second) {
                auto [xx, yy] = *prev(ptr);
                x = min(x, xx);
                y = max(y, yy);
                diff -= yy - xx;
                intervals.erase(prev(ptr));
            }
            while (ptr != intervals.end() && ptr->first < y) {
                auto [xx, yy] = *ptr;
                y = max(y, yy);
                diff -= yy - xx;
                ptr = next(ptr);
                intervals.erase(prev(ptr));
            }
            ans.push_back(y-x+diff);
            intervals[x] = y;
        }
        return ans;
    }


    /*2160. Minimum Sum of Four Digit Number After Splitting Digits (Easy)
    You are given a positive integer num consisting of exactly four digits.
    Split num into two new integers new1 and new2 by using the digits found in
    num. Leading zeros are allowed in new1 and new2, and all the digits found
    in num must be used. For example, given num = 2932, you have the following
    digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2]
    are [22, 93], [23, 92], [223, 9] and [2, 329]. Return the minimum possible
    sum of new1 and new2.

    Example 1:
    Input: num = 2932
    Output: 52
    Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.
                 The minimum sum can be obtained by the pair [29, 23]:
                 29 + 23 = 52.

    Example 2:
    Input: num = 4009
    Output: 13
    Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc.
                 The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.

    Constraints: 1000 <= num <= 9999*/

    int minimumSum(int num) {
        string s = to_string(num);
        sort(s.begin(), s.end());
        return (s[0] - '0' + s[1] - '0') * 10 + (s[2] - '0' + s[3] - '0');
    }


    /*2161. Partition Array According to Given Pivot (Medium)
    You are given a 0-indexed integer array nums and an integer pivot.
    Rearrange nums such that the following conditions are satisfied:
    * Every element less than pivot appears before every element greater than
      pivot.
    * Every element equal to pivot appears in between the elements less than
      and greater than pivot.
    * The relative order of the elements less than pivot and the elements
      greater than pivot is maintained.
    More formally, consider every pi, pj where pi is the new position of the
    ith element and pj is the new position of the jth element. For elements
    less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then
    pi < pj. Similarly for elements greater than pivot, if i < j and
    nums[i] > pivot and nums[j] > pivot, then pi < pj. Return nums after the
    rearrangement.

    Example 1:
    Input: nums = [9,12,5,10,14,3,10], pivot = 10
    Output: [9,5,3,10,10,12,14]
    Explanation: The elements 9, 5, and 3 are less than the pivot so they are
                 on the left side of the array. The elements 12 and 14 are
                 greater than the pivot so they are on the right side of the
                 array. The relative ordering of the elements less than and
                 greater than pivot is also maintained. [9, 5, 3] and [12, 14]
                 are the respective orderings.

    Example 2:
    Input: nums = [-3,4,3,2], pivot = 2
    Output: [-3,2,4,3]
    Explanation: The element -3 is less than the pivot so it is on the left
                 side of the array. The elements 4 and 3 are greater than the
                 pivot so they are on the right side of the array. The relative
                 ordering of the elements less than and greater than pivot is
                 also maintained. [-3] and [4, 3] are the respective orderings.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^6 <= nums[i] <= 10^6
    * pivot equals to an element of nums.*/

    vector<int> pivotArray(vector<int>& nums, int pivot) {
        vector<int> small, equal, large;
        for (auto& x : nums)
            if (x < pivot) small.push_back(x);
            else if (x == pivot) equal.push_back(x);
            else large.push_back(x);
        vector<int> ans = small;
        ans.insert(ans.end(), equal.begin(), equal.end());
        ans.insert(ans.end(), large.begin(), large.end());
        return ans;
    }


    /*2162. Minimum Cost to Set Cooking Time (Medium)
    A generic microwave supports cooking times for:
    * at least 1 second.
    * at most 99 minutes and 99 seconds.
    To set the cooking time, you push at most four digits. The microwave
    normalizes what you push as four digits by prepending zeroes. It interprets
    the first two digits as the minutes and the last two digits as the seconds.
    It then adds them up as the cooking time. For example,
    * You push 9 5 4 (three digits). It is normalized as 0954 and interpreted
      as 9 minutes and 54 seconds.
    * You push 0 0 0 8 (four digits). It is interpreted as 0 minutes and 8
      seconds.
    * You push 8 0 9 0. It is interpreted as 80 minutes and 90 seconds.
    * You push 8 1 3 0. It is interpreted as 81 minutes and 30 seconds.
    You are given integers startAt, moveCost, pushCost, and targetSeconds.
    Initially, your finger is on the digit startAt. Moving the finger above any
    specific digit costs moveCost units of fatigue. Pushing the digit below the
    finger once costs pushCost units of fatigue. There can be multiple ways to
    set the microwave to cook for targetSeconds seconds but you are interested
    in the way with the minimum cost. Return the minimum cost to set
    targetSeconds seconds of cooking time. Remember that one minute consists of
    60 seconds.

    Example 1:
    Input: startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600
    Output: 6
    Explanation: The following are the possible ways to set the cooking time.
                 - 1 0 0 0, interpreted as 10 minutes and 0 seconds. The finger
                   is already on digit 1, pushes 1 (with cost 1), moves to 0
                   (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost
                   1), and pushes 0 (with cost 1). The cost is:
                   1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.
                 - 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is
                   also 600 seconds. The finger moves to 0 (with cost 2),
                   pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9
                   (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost
                   1), moves to 0 (with cost 2), and pushes 0 (with cost 1).
                   The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.
                 - 9 6 0, normalized as 0960 and interpreted as 9 minutes and
                   60 seconds. The finger moves to 9 (with cost 2), pushes 9
                   (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost
                   1), moves to 0 (with cost 2), and pushes 0 (with cost 1).
                   The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.

    Example 2:
    Input: startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76
    Output: 6
    Explanation: The optimal way is to push two digits: 7 6, interpreted as 76
                 seconds. The finger moves to 7 (with cost 1), pushes 7 (with
                 cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2).
                 The total cost is: 1 + 2 + 1 + 2 = 6. Note other possible ways
                 are 0076, 076, 0116, and 116, but none of them produces the
                 minimum cost.

    Constraints:
    * 0 <= startAt <= 9
    * 1 <= moveCost, pushCost <= 10^5
    * 1 <= targetSeconds <= 6039*/

    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {
        int minute = targetSeconds/60, second = targetSeconds%60;
        int ans = INT_MAX;
        for (auto& [m, s] : vector<pair<int, int>>{{minute, second}, {minute-1, second+60}}) {
            if (0 <= m && m < 100 && s < 100) {
                int cost = 0, prev = startAt;
                bool found = false;
                for (auto& x : {m/10, m%10, s/10, s%10})
                    if (x || found) {
                        if (x != prev) {cost += moveCost; prev = x;}
                        cost += pushCost;
                        found = true;
                    }
                ans = min(ans, cost);
            }
        }
        return ans;
    }


    /*2163. Minimum Difference in Sums After Removal of Elements (Hard)
    You are given a 0-indexed integer array nums consisting of 3 * n elements.
    You are allowed to remove any subsequence of elements of size exactly n
    from nums. The remaining 2 * n elements will be divided into two equal
    parts:
    * The first n elements belonging to the first part and their sum is
      sumfirst.
    * The next n elements belonging to the second part and their sum is
      sumsecond.
    The difference in sums of the two parts is denoted as sumfirst - sumsecond.
    * For example, if sumfirst = 3 and sumsecond = 2, their difference is 1.
    * Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.
    Return the minimum difference possible between the sums of the two parts
    after the removal of n elements.

    Example 1:
    Input: nums = [3,1,2]
    Output: -1
    Explanation: Here, nums has 3 elements, so n = 1. Thus we have to remove 1
                 element from nums and divide the array into two equal parts.
                 - If we remove nums[0] = 3, the array will be [1,2]. The
                   difference in sums of the two parts will be 1 - 2 = -1.
                 - If we remove nums[1] = 1, the array will be [3,2]. The
                   difference in sums of the two parts will be 3 - 2 = 1.
                 - If we remove nums[2] = 2, the array will be [3,1]. The
                   difference in sums of the two parts will be 3 - 1 = 2.
                 The minimum difference between sums of the two parts is
                 min(-1,1,2) = -1.

    Example 2:
    Input: nums = [7,9,5,8,1,3]
    Output: 1
    Explanation: Here n = 2. So we must remove 2 elements and divide the
                 remaining array into two parts containing two elements each.
                 If we remove nums[2] = 5 and nums[3] = 8, the resultant array
                 will be [7,9,1,3]. The difference in sums will be
                 (7+9) - (1+3) = 12. To obtain the minimum difference, we
                 should remove nums[1] = 9 and nums[4] = 1. The resultant array
                 becomes [7,5,8,3]. The difference in sums of the two parts is
                 (7+5) - (8+3) = 1. It can be shown that it is not possible to
                 obtain a difference smaller than 1.

    Constraints:
    * nums.length == 3 * n
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= 10^5*/

    long long minimumDifference(vector<int>& nums) {
        int n = nums.size()/3;
        long ans = 0;
        priority_queue<int> left;
        for (int i = 0; i < n; ++i) {
            left.push(nums[i]);
            ans += nums[i];
        }
        priority_queue<int, vector<int>, greater<>> right;
        for (int i = 2*n; i < 3*n; ++i) {
            right.push(nums[i]);
            ans -= nums[i];
        }
        vector<long> prefix = {0};
        for (int i = n; i < 2*n; ++i)
            if (nums[i] < left.top()) {
                prefix.push_back(prefix.back() + nums[i] - left.top());
                left.pop();
                left.push(nums[i]);
            } else prefix.push_back(prefix.back());
        long extra = prefix.back(), suffix = 0;
        for (int i = 2*n-1; i >= n; --i) {
            if (nums[i] > right.top()) {
                suffix += right.top() - nums[i];
                right.pop();
                right.push(nums[i]);
            }
            extra = min(extra, prefix[i-n] + suffix);
        }
        return ans + extra;
    }


    /*2167. Minimum Time to Remove All Cars Containing Illegal Goods (Hard)
    You are given a 0-indexed binary string s which represents a sequence of
    train cars. s[i] = '0' denotes that the ith car does not contain illegal
    goods and s[i] = '1' denotes that the ith car does contain illegal goods.
    As the train conductor, you would like to get rid of all the cars
    containing illegal goods. You can do any of the following three operations
    any number of times:
    * Remove a train car from the left end (i.e., remove s[0]) which takes 1
      unit of time.
    * Remove a train car from the right end (i.e., remove s[s.length - 1])
      which takes 1 unit of time.
    * Remove a train car from anywhere in the sequence which takes 2 units of
      time.
    Return the minimum time to remove all the cars containing illegal goods.
    Note that an empty sequence of cars is considered to have no cars
    containing illegal goods.

    Example 1:
    Input: s = "1100101"
    Output: 5
    Explanation: One way to remove all the cars containing illegal goods from
                 the sequence is to
                 - remove a car from the left end 2 times. Time taken is
                   2 * 1 = 2.
                 - remove a car from the right end. Time taken is 1.
                 - remove the car containing illegal goods found in the middle.
                   Time taken is 2.
                 This obtains a total time of 2 + 1 + 2 = 5. An alternative way
                 is to
                 - remove a car from the left end 2 times. Time taken is
                   2 * 1 = 2.
                 - remove a car from the right end 3 times. Time taken is
                   3 * 1 = 3.
                 This also obtains a total time of 2 + 3 = 5. 5 is the minimum
                 time taken to remove all the cars containing illegal goods.
                 There are no other ways to remove them with less time.

    Example 2:
    Input: s = "0010"
    Output: 2
    Explanation: One way to remove all the cars containing illegal goods from
                 the sequence is to
                 - remove a car from the left end 3 times. Time taken is
                   3 * 1 = 3.
                 This obtains a total time of 3. Another way to remove all the
                 cars containing illegal goods from the sequence is to
                 - remove the car containing illegal goods found in the middle.
                   Time taken is 2.
                 This obtains a total time of 2. Another way to remove all the
                 cars containing illegal goods from the sequence is to
                 - remove a car from the right end 2 times. Time taken is
                   2 * 1 = 2.
                 This obtains a total time of 2. 2 is the minimum time taken to
                 remove all the cars containing illegal goods. There are no
                 other ways to remove them with less time.

    Constraints:
    * 1 <= s.length <= 2 * 10^5
    * s[i] is either '0' or '1'.*/

    int minimumTime(string s) {
        int ans = INT_MAX;
        for (int i = 0, prefix = 0, n = s.size(); i < n; ++i) {
            if (s[i] == '1') prefix = min(2+prefix, i+1);
            ans = min(ans, prefix + n - 1 - i);
        }
        return ans;
    }


    /*2168. Unique Substrings With Equal Digit Frequency (Medium)
    Given a digit string s, return the number of unique substrings of s where
    every digit appears the same number of times.

    Example 1:
    Input: s = "1212"
    Output: 5
    Explanation: The substrings that meet the requirements are "1", "2", "12",
                 "21", "1212". Note that although the substring "12" appears
                 twice, it is only counted once.

    Example 2:
    Input: s = "12321"
    Output: 9
    Explanation: The substrings that meet the requirements are "1", "2", "3",
                 "12", "23", "32", "21", "123", "321".

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of digits.*/

    int equalDigitFrequency(string s) {
        unordered_set<int> seen;
        for (int i = 0, n = s.size(); i < n; ++i) {
            unordered_map<char, int> freq;
            long hs = 0;
            for (int j = i, most = 0; j < n; ++j) {
                most = max(most, ++freq[s[j]]);
                hs = (11*hs + s[j] - '0' + 1) % 1'000'000'007;
                if (most * freq.size() == j-i+1) seen.insert(hs);
            }
        }
        return seen.size();
    }


    /*2169. Count Operations to Obtain Zero (Easy)
    You are given two non-negative integers num1 and num2. In one operation, if
    num1 >= num2, you must subtract num2 from num1, otherwise subtract num1
    from num2.
    * For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus
      obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after
      one operation, num1 = 4 and num2 = 1.
    Return the number of operations required to make either num1 = 0 or
    num2 = 0.

    Example 1:
    Input: num1 = 2, num2 = 3
    Output: 3
    Explanation: - Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we
                   subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.
                 - Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we
                   subtract num2 from num1.
                 - Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we
                   subtract num2 from num1.
                 Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to
                 perform any further operations. So the total number of
                 operations required is 3.

    Example 2:
    Input: num1 = 10, num2 = 10
    Output: 1
    Explanation: - Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we
                   subtract num2 from num1 and get num1 = 10 - 10 = 0.
                 Now num1 = 0 and num2 = 10. Since num1 == 0, we are done. So
                 the total number of operations required is 1.

    Constraints: 0 <= num1, num2 <= 10^5*/

    int countOperations(int num1, int num2) {
        int ans = 0;
        while (num1 && num2) {
            ans += num1/num2;
            num1 %= num2;
            swap(num1, num2);
        }
        return ans;
    }


    /*2170. Minimum Operations to Make the Array Alternating (Medium)
    You are given a 0-indexed array nums consisting of n positive integers. The
    array nums is called alternating if:
    * nums[i - 2] == nums[i], where 2 <= i <= n - 1.
    * nums[i - 1] != nums[i], where 1 <= i <= n - 1.
    In one operation, you can choose an index i and change nums[i] into any
    positive integer. Return the minimum number of operations required to make
    the array alternating.

    Example 1:
    Input: nums = [3,1,3,2,4,3]
    Output: 3
    Explanation: One way to make the array alternating is by converting it to
                 [3,1,3,1,3,1]. The number of operations required in this case
                 is 3. It can be proven that it is not possible to make the
                 array alternating in less than 3 operations.

    Example 2:
    Input: nums = [1,2,2,2,2]
    Output: 2
    Explanation: One way to make the array alternating is by converting it to
                 [1,2,1,2,1]. The number of operations required in this case is
                 2. Note that the array cannot be converted to [2,2,2,2,2]
                 because in this case nums[0] == nums[1] which violates the
                 conditions of an alternating array.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    int minimumOperations(vector<int>& nums) {
        unordered_map<int, int> even, odd;
        for (int i = 0; i < nums.size(); ++i)
            if (i&1) ++odd[nums[i]];
            else ++even[nums[i]];

        auto fn = [&](unordered_map<int, int> freq) {
            int key = 0, m0 = 0, m1 = 0;
            for (auto& [k, v] : freq)
                if (v > m0) tie(key, m1, m0) = make_tuple(k, m0, v);
                else m1 = v;
            return make_tuple(key, m0, m1);
        };

        auto [k0, m00, m01] = fn(even);
        auto [k1, m10, m11] = fn(odd);
        return k0 == k1 ? nums.size() - max(m00 + m11, m01 + m10) : nums.size() - m00 - m10;
    }


    /*2171. Removing Minimum Number of Magic Beans (Medium)
    You are given an array of positive integers beans, where each integer
    represents the number of magic beans found in a particular magic bag.
    Remove any number of beans (possibly none) from each bag such that the
    number of beans in each remaining non-empty bag (still containing at least
    one bean) is equal. Once a bean has been removed from a bag, you are not
    allowed to return it to any of the bags. Return the minimum number of magic
    beans that you have to remove.

    Example 1:
    Input: beans = [4,1,6,5]
    Output: 4
    Explanation: - We remove 1 bean from the bag with only 1 bean. This results
                   in the remaining bags: [4,0,6,5]
                 - Then we remove 2 beans from the bag with 6 beans. This
                   results in the remaining bags: [4,0,4,5]
                 - Then we remove 1 bean from the bag with 5 beans. This
                   results in the remaining bags: [4,0,4,4]
                 We removed a total of 1 + 2 + 1 = 4 beans to make the
                 remaining non-empty bags have an equal number of beans. There
                 are no other solutions that remove 4 beans or fewer.

    Example 2:
    Input: beans = [2,10,3,2]
    Output: 7
    Explanation: - We remove 2 beans from one of the bags with 2 beans. This
                   results in the remaining bags: [0,10,3,2]
                 - Then we remove 2 beans from the other bag with 2 beans. This
                   results in the remaining bags: [0,10,3,0]
                 - Then we remove 3 beans from the bag with 3 beans. This
                   results in the remaining bags: [0,10,0,0]
                 We removed a total of 2 + 2 + 3 = 7 beans to make the
                 remaining non-empty bags have an equal number of beans. There
                 are no other solutions that removes 7 beans or fewer.

    Constraints:
    * 1 <= beans.length <= 10^5
    * 1 <= beans[i] <= 10^5*/

    long long minimumRemoval(vector<int>& beans) {
        sort(beans.begin(), beans.end());
        long most = 0;
        for (int i = 0, n = beans.size(); i < n; ++i) most = max(most, (long)(n-i)*beans[i]);
        return accumulate(beans.begin(), beans.end(), 0l) - most;
    }


    /*2172. Maximum AND Sum of Array (Hard)
    You are given an integer array nums of length n and an integer numSlots
    such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to
    numSlots. You have to place all n integers into the slots such that each
    slot contains at most two numbers. The AND sum of a given placement is the
    sum of the bitwise AND of every number with its respective slot number.
    * For example, the AND sum of placing the numbers [1, 3] into slot 1 and
      [4, 6] into slot 2 is equal to
      (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4.
    Return the maximum possible AND sum of nums given numSlots slots.

    Example 1:
    Input: nums = [1,2,3,4,5,6], numSlots = 3
    Output: 9
    Explanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot
                 2, and [3, 5] into slot 3. This gives the maximum AND sum of
                 (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) +
                 (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.

    Example 2:
    Input: nums = [1,3,10,4,7,1], numSlots = 9
    Output: 24
    Explanation: One possible placement is [1, 1] into slot 1, [3] into slot 3,
                 [4] into slot 4, [7] into slot 7, and [10] into slot 9. This
                 gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3)
                 + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.
                 Note that slots 2, 5, 6, and 8 are empty which is permitted.

    Constraints:
    * n == nums.length
    * 1 <= numSlots <= 9
    * 1 <= n <= 2 * numSlots
    * 1 <= nums[i] <= 15*/

    int maximumANDSum(vector<int>& nums, int numSlots) {
        vector<vector<int>> memo(nums.size(), vector<int>(1<<2*numSlots, -1));

        function<int(int, int)> fn = [&](int k, int m) {
            if (k == nums.size()) return 0;
            if (memo[k][m] == -1)
                for (int i = 0; i < numSlots; ++i)
                    if ((m & 1<<2*i) == 0 || (m & 1<<2*i+1) == 0) {
                        int mm = m;
                        if ((m & 1<<2*i) == 0) mm ^= 1<<2*i;
                        else mm ^= 1<<2*i+1;
                        memo[k][m] = max(memo[k][m], (nums[k] & i+1) + fn(k+1, mm));
                    }
            return memo[k][m];
        };

        return fn(0, 0);
    }


    /*2174. Remove All Ones With Row and Column Flips II (Medium)
    You are given a 0-indexed m x n binary matrix grid. In one operation, you
    can choose any i and j that meet the following conditions:
    * 0 <= i < m
    * 0 <= j < n
    * grid[i][j] == 1
    and change the values of all cells in row i and column j to zero. Return
    the minimum number of operations needed to remove all 1's from grid.

    Example 1:
    Input: grid = [[1,1,1],[1,1,1],[0,1,0]]
    Output: 2
    Explanation: In the first operation, change all cell values of row 1 and
                 column 1 to zero. In the second operation, change all cell
                 values of row 0 and column 0 to zero.

    Example 2:
    Input: grid = [[0,1,0],[1,0,1],[0,1,0]]
    Output: 2
    Explanation: In the first operation, change all cell values of row 1 and
                 column 0 to zero. In the second operation, change all cell
                 values of row 2 and column 1 to zero. Note that we cannot
                 perform an operation using row 1 and column 1 because
                 grid[1][1] != 1.

    Example 3:
    Input: grid = [[0,0],[0,0]]
    Output: 0
    Explanation: There are no 1's to remove so return 0.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 15
    * 1 <= m * n <= 15
    * grid[i][j] is either 0 or 1.*/

    int removeOnes(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> mask(m, vector<int>(n, (1<<m*n)-1));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                for (int ii = 0; ii < m; ++ii)
                    if (mask[i][j] & (1<<ii*n+j)) mask[i][j] ^= 1<<ii*n+j;
                for (int jj = 0; jj < n; ++jj)
                    if (mask[i][j] & (1<<i*n+jj)) mask[i][j] ^= 1<<i*n+jj;
            }
        int v = 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) v ^= 1<<i*n+j;

        int ans = 0;
        vector<bool> seen(v+1); seen[v] = true;
        queue<int> q; q.push(v);
        while (q.size()) {
            for (int sz = q.size(); sz; --sz) {
                auto v = q.front(); q.pop();
                if (v == 0) return ans;
                for (int i = 0; i < m; ++i)
                    for (int j = 0; j < n; ++j)
                        if (v & (1<<i*n+j)) {
                            int vv = v & mask[i][j];
                            if (!seen[vv]) {
                                seen[vv] = true;
                                q.push(vv);
                            }
                        }
            }
            ++ans;
        }
        return -1;
    }


    /*2176. Count Equal and Divisible Pairs in an Array (Easy)
    Given a 0-indexed integer array nums of length n and an integer k, return
    the number of pairs (i, j) where 0 <= i < j < n, such that
    nums[i] == nums[j] and (i * j) is divisible by k.

    Example 1:
    Input: nums = [3,1,2,2,2,1,3], k = 2
    Output: 4
    Explanation: There are 4 pairs that meet all the requirements:
                 - nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
                 - nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
                 - nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
                 - nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.

    Example 2:
    Input: nums = [1,2,3,4], k = 1
    Output: 0
    Explanation: Since no value in nums is repeated, there are no pairs (i,j)
                 that meet all the requirements.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i], k <= 100*/

    int countPairs(vector<int>& nums, int k) {
        int ans = 0;
        for (int i = 0; i < nums.size(); ++i)
            for (int j = i+1; j < nums.size(); ++j)
                if (nums[i] == nums[j] && i*j%k == 0)
                    ++ans;
        return ans;
    }


    /*2177. Find Three Consecutive Integers That Sum to a Given Number (Medium)
    Given an integer num, return three consecutive integers (as a sorted array)
    that sum to num. If num cannot be expressed as the sum of three consecutive
    integers, return an empty array.

    Example 1:
    Input: num = 33
    Output: [10,11,12]
    Explanation: 33 can be expressed as 10 + 11 + 12 = 33. 10, 11, 12 are 3
                 consecutive integers, so we return [10, 11, 12].

    Example 2:
    Input: num = 4
    Output: []
    Explanation: There is no way to express 4 as the sum of 3 consecutive
                 integers.

    Constraints: 0 <= num <= 10^15*/

    vector<long long> sumOfThree(long long num) {
        if (num % 3) return {};
        return {num/3-1, num/3, num/3+1};
    }


    /*2178. Maximum Split of Positive Even Integers (Medium)
    You are given an integer finalSum. Split it into a sum of a maximum number
    of unique positive even integers.
    * For example, given finalSum = 12, the following splits are valid (unique
      positive even integers summing up to finalSum): (2 + 10), (2 + 4 + 6),
      and (4 + 8). Among them, (2 + 4 + 6) contains the maximum number of
      integers. Note that finalSum cannot be split into (2 + 2 + 4 + 4) as all
      the numbers should be unique.
    Return a list of integers that represent a valid split containing a maximum
    number of integers. If no valid split exists for finalSum, return an empty
    list. You may return the integers in any order.

    Example 1:
    Input: finalSum = 12
    Output: [2,4,6]
    Explanation: The following are some valid splits: (2 + 10), (2 + 4 + 6),
                 and (4 + 8). (2 + 4 + 6) has the maximum number of integers,
                 which is 3. Thus, we return [2,4,6]. Note that [2,6,4], [6,2,4],
                 etc. are also accepted.

    Example 2:
    Input: finalSum = 7
    Output: []
    Explanation: There are no valid splits for the given finalSum. Thus, we
                 return an empty array.

    Example 3:
    Input: finalSum = 28
    Output: [6,8,2,12]
    Explanation: The following are some valid splits: (2 + 26), (6 + 8 + 2 + 12),
                 and (4 + 24). (6 + 8 + 2 + 12) has the maximum number of
                 integers, which is 4. Thus, we return [6,8,2,12]. Note that
                 [10,2,4,12], [6,2,4,16], etc. are also accepted.

    Constraints: 1 <= finalSum <= 10^10*/

    vector<long long> maximumEvenSplit(long long finalSum) {
        if (finalSum & 1) return {};
        vector<long long> ans;
        for (long long x = 2; x <= finalSum; finalSum -= x, x += 2)
            ans.push_back(x);
        ans.back() += finalSum;
        return ans;
    }


    /*2179. Count Good Triplets in an Array (Hard)
    You are given two 0-indexed arrays nums1 and nums2 of length n, both of
    which are permutations of [0, 1, ..., n - 1]. A good triplet is a set of 3
    distinct values which are present in increasing order by position both in
    nums1 and nums2. In other words, if we consider pos1v as the index of the
    value v in nums1 and pos2v as the index of the value v in nums2, then a
    good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that
    pos1x < pos1y < pos1z and pos2x < pos2y < pos2z. Return the total number of
    good triplets.

    Example 1:
    Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3]
    Output: 1
    Explanation: There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z.
                 They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). Out of those
                 triplets, only the triplet (0,1,3) satisfies
                 pos2x < pos2y < pos2z. Hence, there is only 1 good triplet.

    Example 2:
    Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
    Output: 4
    Explanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2).

    Constraints:
    * n == nums1.length == nums2.length
    * 3 <= n <= 10^5
    * 0 <= nums1[i], nums2[i] <= n - 1
    * nums1 and nums2 are permutations of [0, 1, ..., n - 1].*/

    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        unordered_map<int, int> mp;
        for (int i = 0; i < n; ++i) mp[nums1[i]] = i;
        long long ans = 0;
        Fenwick<int> *fw = new Fenwick<int>(n);
        for (auto& x : nums2) {
            x = mp[x];
            int left = fw->query(x), right = (n-1-x) - (fw->query(n-1)-fw->query(x));
            ans += (long long) left * right;
            fw->update(x, 1);
        }
        delete fw;
        return ans;
    }


    /*2180. Count Integers With Even Digit Sum (Easy)
    Given a positive integer num, return the number of positive integers less
    than or equal to num whose digit sums are even. The digit sum of a positive
    integer is the sum of all its digits.

    Example 1:
    Input: num = 4
    Output: 2
    Explanation: The only integers less than or equal to 4 whose digit sums are
                 even are 2 and 4.

    Example 2:
    Input: num = 30
    Output: 14
    Explanation: The 14 integers less than or equal to 30 whose digit sums are
                 even are 2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and
                 28.

    Constraints: 1 <= num <= 1000*/

    int countEven(int num) {
        int ans = 0;
        for (int x = 1; x <= num; ++x) {
            int sm = 0;
            for (int xx = x; xx; xx /= 10)
                sm += xx % 10;
            if ((sm&1) == 0) ++ans;
        }
        return ans;
    }


    /*2181. Merge Nodes in Between Zeros (Medium)
    You are given the head of a linked list, which contains a series of
    integers separated by 0's. The beginning and end of the linked list will
    have Node.val == 0. For every two consecutive 0's, merge all the nodes
    lying in between them into a single node whose value is the sum of all the
    merged nodes. The modified list should not contain any 0's. Return the head
    of the modified linked list.

    Example 1:
    Input: head = [0,3,1,0,4,5,2,0]
    Output: [4,11]
    Explanation: The above figure represents the given linked list. The
                 modified list contains
                 - The sum of the nodes marked in green: 3 + 1 = 4.
                 - The sum of the nodes marked in red: 4 + 5 + 2 = 11.

    Example 2:
    Input: head = [0,1,0,3,0,2,2,0]
    Output: [1,3,4]
    Explanation: The above figure represents the given linked list. The
                 modified list contains
                 - The sum of the nodes marked in green: 1 = 1.
                 - The sum of the nodes marked in red: 3 = 3.
                 - The sum of the nodes marked in yellow: 2 + 2 = 4.

    Constraints:
    * The number of nodes in the list is in the range [3, 2 * 10^5].
    * 0 <= Node.val <= 1000
    * There are no two consecutive nodes with Node.val == 0.
    * The beginning and end of the linked list have Node.val == 0.*/

    ListNode* mergeNodes(ListNode* head) {
        ListNode dummy, *node = &dummy;
        while (head) {
            int sm = 0;
            for (head = head->next; head && head->val; head = head->next)
                sm += head->val;
            if (sm) node = node->next = new ListNode(sm);
        }
        return dummy.next;
    }


    /*2182. Construct String With Repeat Limit (Medium)
    You are given a string s and an integer repeatLimit. Construct a new string
    repeatLimitedString using the characters of s such that no letter appears
    more than repeatLimit times in a row. You do not have to use all characters
    from s. Return the lexicographically largest repeatLimitedString possible.
    A string a is lexicographically larger than a string b if in the first
    position where a and b differ, string a has a letter that appears later in
    the alphabet than the corresponding letter in b. If the first
    min(a.length, b.length) characters do not differ, then the longer string is
    the lexicographically larger one.

    Example 1:
    Input: s = "cczazcc", repeatLimit = 3
    Output: "zzcccac"
    Explanation: We use all of the characters from s to construct the
                 repeatLimitedString "zzcccac". The letter 'a' appears at most
                 1 time in a row. The letter 'c' appears at most 3 times in a
                 row. The letter 'z' appears at most 2 times in a row. Hence,
                 no letter appears more than repeatLimit times in a row and the
                 string is a valid repeatLimitedString. The string is the
                 lexicographically largest repeatLimitedString possible so we
                 return "zzcccac". Note that the string "zzcccca" is
                 lexicographically larger but the letter 'c' appears more than
                 3 times in a row, so it is not a valid repeatLimitedString.

    Example 2:
    Input: s = "aababab", repeatLimit = 2
    Output: "bbabaa"
    Explanation: We use only some of the characters from s to construct the
                 repeatLimitedString "bbabaa". The letter 'a' appears at most 2
                 times in a row. The letter 'b' appears at most 2 times in a
                 row. Hence, no letter appears more than repeatLimit times in a
                 row and the string is a valid repeatLimitedString. The string
                 is the lexicographically largest repeatLimitedString possible
                 so we return "bbabaa". Note that the string "bbabaaa" is
                 lexicographically larger but the letter 'a' appears more than
                 2 times in a row, so it is not a valid repeatLimitedString.

    Constraints:
    * 1 <= repeatLimit <= s.length <= 10^5
    * s consists of lowercase English letters.*/

    string repeatLimitedString(string s, int repeatLimit) {
        unordered_map<char, int> freq;
        for (auto& ch : s) freq[ch] += 1;
        priority_queue<pair<char, int>> pq;
        for (auto& [ch, v] : freq) pq.emplace(ch, v);
        string ans;
        while (pq.size()) {
            auto [c, v] = pq.top(); pq.pop();
            if (ans.size() && ans.back() == c) {
                if (pq.empty()) break;
                auto [cc, vv] = pq.top(); pq.pop();
                ans.push_back(cc);
                if (vv - 1) pq.emplace(cc, vv-1);
                pq.emplace(c, v);
            } else {
                int m = min(v, repeatLimit);
                ans += string(m, c);
                if (v - m) pq.emplace(c, v-m);
            }
        }
        return ans;
    }


    /*2183. Count Array Pairs Divisible by K (Hard)
    Given a 0-indexed integer array nums of length n and an integer k, return
    the number of pairs (i, j) such that:
    * 0 <= i < j <= n - 1 and
    * nums[i] * nums[j] is divisible by k.

    Example 1:
    Input: nums = [1,2,3,4,5], k = 2
    Output: 7
    Explanation: The 7 pairs of indices whose corresponding products are
                 divisible by 2 are (0, 1), (0, 3), (1, 2), (1, 3), (1, 4),
                 (2, 3), and (3, 4). Their products are 2, 4, 6, 8, 10, 12, and
                 20 respectively. Other pairs such as (0, 2) and (2, 4) have
                 products 3 and 15 respectively, which are not divisible by 2.

    Example 2:
    Input: nums = [1,2,3,4], k = 5
    Output: 0
    Explanation: There does not exist any pair of indices whose corresponding
                 product is divisible by 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= 10^5*/

    long long countPairs(vector<int>& nums, int k) {
        vector<int> factors;
        for (int x = 1; x <= sqrt(k); ++x)
            if (k % x == 0) factors.push_back(x);
        long long ans = 0;
        unordered_map<int, int> freq;
        for (auto& x : nums) {
            x = gcd(x, k);
            ans += freq[k/x];
            for (auto& f : factors)
                if (x % f == 0 && f <= x/f) {
                    ++freq[f];
                    if (f < x/f) ++freq[x/f];
                }
        }
        return ans;
    }


    /*2185. Counting Words With a Given Prefix (Easy)
    You are given an array of strings words and a string pref. Return the
    number of strings in words that contain pref as a prefix. A prefix of a
    string s is any leading contiguous substring of s.

    Example 1:
    Input: words = ["pay","attention","practice","attend"], pref = "at"
    Output: 2
    Explanation: The 2 strings that contain "at" as a prefix are: "attention"
                 and "attend".

    Example 2:
    Input: words = ["leetcode","win","loops","success"], pref = "code"
    Output: 0
    Explanation: There are no strings that contain "code" as a prefix.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length, pref.length <= 100
    * words[i] and pref consist of lowercase English letters.*/

    int prefixCount(vector<string>& words, string pref) {
        return count_if(words.begin(), words.end(), [&](auto& word) {
            return word.rfind(pref, 0) == 0;
        });
    }


    /*2186. Minimum Number of Steps to Make Two Strings Anagram II (Medium)
    You are given two strings s and t. In one step, you can append any
    character to either s or t. Return the minimum number of steps to make s
    and t anagrams of each other. An anagram of a string is a string that
    contains the same characters with a different (or the same) ordering.

    Example 1:
    Input: s = "leetcode", t = "coats"
    Output: 7
    Explanation: - In 2 steps, we can append the letters in "as" onto
                   s = "leetcode", forming s = "leetcodeas".
                 - In 5 steps, we can append the letters in "leede" onto
                   t = "coats", forming t = "coatsleede".
                 "leetcodeas" and "coatsleede" are now anagrams of each other.
                 We used a total of 2 + 5 = 7 steps. It can be shown that there
                 is no way to make them anagrams of each other with less than 7
                 steps.

    Example 2:
    Input: s = "night", t = "thing"
    Output: 0
    Explanation: The given strings are already anagrams of each other. Thus, we
                 do not need any further steps.

    Constraints:
    * 1 <= s.length, t.length <= 2 * 10^5
    * s and t consist of lowercase English letters.*/

    int minSteps(string s, string t) {
        vector<int> freq(26);
        for (auto& ch : s) ++freq[ch-'a'];
        for (auto& ch : t) --freq[ch-'a'];
        return transform_reduce(freq.begin(), freq.end(), 0, plus<>{}, static_cast<int(*)(int)>(abs));
    }


    /*2187. Minimum Time to Complete Trips (Medium)
    You are given an array time where time[i] denotes the time taken by the ith
    bus to complete one trip. Each bus can make multiple trips successively;
    that is, the next trip can start immediately after completing the current
    trip. Also, each bus operates independently; that is, the trips of one bus
    do not influence the trips of any other bus. You are also given an integer
    totalTrips, which denotes the number of trips all buses should make in
    total. Return the minimum time required for all buses to complete at least
    totalTrips trips.

    Example 1:
    Input: time = [1,2,3], totalTrips = 5
    Output: 3
    Explanation: - At time t = 1, the number of trips completed by each bus are
                   [1,0,0]. The total number of trips completed is 1 + 0 + 0 = 1.
                 - At time t = 2, the number of trips completed by each bus are
                   [2,1,0]. The total number of trips completed is 2 + 1 + 0 = 3.
                 - At time t = 3, the number of trips completed by each bus are
                   [3,1,1]. The total number of trips completed is 3 + 1 + 1 = 5.
                 So the minimum time needed for all buses to complete at least
                 5 trips is 3.

    Example 2:
    Input: time = [2], totalTrips = 1
    Output: 2
    Explanation: There is only one bus, and it will complete its first trip at
                 t = 2. So the minimum time needed to complete 1 trip is 2.

    Constraints:
    1 <= time.length <= 10^5
    1 <= time[i], totalTrips <= 10^7*/

    long long minimumTime(vector<int>& time, int totalTrips) {
        long long lo = 0, hi = (long long) *max_element(time.begin(), time.end()) * totalTrips;
        while (lo < hi) {
            long long mid = lo + (hi - lo)/2, cnt = 0;
            for (auto& t : time) cnt += mid/t;
            if (cnt < totalTrips) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*2188. Minimum Time to Finish the Race (Hard)
    You are given a 0-indexed 2D integer array tires where tires[i] = [fi, ri]
    indicates that the ith tire can finish its xth successive lap in
    fi * ri^(x-1) seconds. For example, if fi = 3 and ri = 2, then the tire
    would finish its 1st lap in 3 seconds, its 2nd lap in 3 * 2 = 6 seconds,
    its 3rd lap in 3 * 22 = 12 seconds, etc. You are also given an integer
    changeTime and an integer numLaps. The race consists of numLaps laps and
    you may start the race with any tire. You have an unlimited supply of each
    tire and after every lap, you may change to any given tire (including the
    current tire type) if you wait changeTime seconds. Return the minimum time
    to finish the race.

    Example 1:
    Input: tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4
    Output: 21
    Explanation: Lap 1: Start with tire 0 and finish the lap in 2 seconds.
                 Lap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6
                        seconds.
                 Lap 3: Change tires to a new tire 0 for 5 seconds and then
                        finish the lap in another 2 seconds.
                 Lap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6
                        seconds.
                 Total time = 2 + 6 + 5 + 2 + 6 = 21 seconds. The minimum time
                 to complete the race is 21 seconds.

    Example 2:
    Input: tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5
    Output: 25
    Explanation: Lap 1: Start with tire 1 and finish the lap in 2 seconds.
                 Lap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4
                        seconds.
                 Lap 3: Change tires to a new tire 1 for 6 seconds and then
                        finish the lap in another 2 seconds.
                 Lap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4
                        seconds.
                 Lap 5: Change tires to tire 0 for 6 seconds then finish the
                        lap in another 1 second.
                 Total time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds. The
                 minimum time to complete the race is 25 seconds.

    Constraints:
    * 1 <= tires.length <= 10^5
    * tires[i].length == 2
    * 1 <= fi, changeTime <= 10^5
    * 2 <= ri <= 10^5
    * 1 <= numLaps <= 1000*/

    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) {
        vector<long> nonstop(20, INT_MAX);
        for (auto& tire : tires) {
            long prefix = tire[0], term = tire[0];
            for (int i = 1; i < 20; ++i) {
                nonstop[i] = min(nonstop[i], prefix);
                term *= tire[1];
                if (term >= tire[0] + changeTime) break;
                prefix += term;
            }
        }
        vector<int> dp(numLaps+1, INT_MAX);
        dp[1] = nonstop[1];
        for (int x = 2; x <= numLaps; ++x) {
            if (x < 20) dp[x] = nonstop[x];
            for (int xx = 1; xx < min(20, x/2+1); ++xx)
                dp[x] = min(dp[x], dp[xx] + dp[x-xx] + changeTime);
        }
        return dp.back();
    }


    /*2189. Number of Ways to Build House of Cards (Medium)
    You are given an integer n representing the number of playing cards you
    have. A house of cards meets the following conditions:
    * A house of cards consists of one or more rows of triangles and horizontal
      cards.
    * Triangles are created by leaning two cards against each other.
    * One card must be placed horizontally between all adjacent triangles in a
      row.
    * Any triangle on a row higher than the first must be placed on a
      horizontal card from the previous row.
    * Each triangle is placed in the leftmost available spot in the row.
    Return the number of distinct house of cards you can build using all n
    cards. Two houses of cards are considered distinct if there exists a row
    where the two houses contain a different number of cards.

    Example 1:
    Input: n = 16
    Output: 2
    Explanation: The two valid houses of cards are shown. The third house of
                 cards in the diagram is not valid because the rightmost
                 triangle on the top row is not placed on top of a horizontal
                 card.

    Example 2:
    Input: n = 2
    Output: 1
    Explanation: The one valid house of cards is shown.

    Example 3:
    Input: n = 4
    Output: 0
    Explanation: The three houses of cards in the diagram are not valid. The
                 first house of cards needs a horizontal card placed between
                 the two triangles. The second house of cards uses 5 cards. The
                 third house of cards uses 2 cards.

    Constraints: 1 <= n <= 500*/

    int houseOfCards(int n) {
        vector<int> dp(n+1);
        dp[0] = 1;
        for (int x = 2; x <= n; x += 3)
            for (int i = n; i >= x; --i)
                dp[i] += dp[i-x];
        return dp.back();
    }


    /*2194. Cells in a Range on an Excel Sheet (Easy)
    A cell (r, c) of an excel sheet is represented as a string "<col><row>"
    where:
    * <col> denotes the column number c of the cell. It is represented by
      alphabetical letters.
      + For example, the 1st column is denoted by 'A', the 2nd by 'B', the 3rd
        by 'C', and so on.
    * <row> is the row number r of the cell. The rth row is represented by the
      integer r.
    You are given a string s in the format "<col1><row1>:<col2><row2>", where
    <col1> represents the column c1, <row1> represents the row r1, <col2>
    represents the column c2, and <row2> represents the row r2, such that
    r1 <= r2 and c1 <= c2. Return the list of cells (x, y) such that
    r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as strings
    in the format mentioned above and be sorted in non-decreasing order first
    by columns and then by rows.

    Example 1:
    Input: s = "K1:L2"
    Output: ["K1","K2","L1","L2"]
    Explanation: The above diagram shows the cells which should be present in
                 the list. The red arrows denote the order in which the cells
                 should be presented.

    Example 2:
    Input: s = "A1:F1"
    Output: ["A1","B1","C1","D1","E1","F1"]
    Explanation: The above diagram shows the cells which should be present in
                 the list. The red arrow denotes the order in which the cells
                 should be presented.

    Constraints:
    * s.length == 5
    * 'A' <= s[0] <= s[3] <= 'Z'
    * '1' <= s[1] <= s[4] <= '9'
    * s consists of uppercase English letters, digits and ':'.*/

    vector<string> cellsInRange(string s) {
        vector<string> ans;
        for (char c = s[0]; c <= s[3]; ++c)
            for (char r = s[1]; r <= s[4]; ++r)
                ans.push_back(string(1, c) + string(1, r));
        return ans;
    }


    /*2195. Append K Integers With Minimal Sum (Medium)
    You are given an integer array nums and an integer k. Append k unique
    positive integers that do not appear in nums to nums such that the
    resulting total sum is minimum. Return the sum of the k integers appended
    to nums.

    Example 1:
    Input: nums = [1,4,25,10,25], k = 2
    Output: 5
    Explanation: The two unique positive integers that do not appear in nums
                 which we append are 2 and 3. The resulting sum of nums is
                 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum. The
                 sum of the two integers appended is 2 + 3 = 5, so we return 5.

    Example 2:
    Input: nums = [5,6], k = 6
    Output: 25
    Explanation: The six unique positive integers that do not appear in nums
                 which we append are 1, 2, 3, 4, 7, and 8. The resulting sum of
                 nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the
                 minimum. The sum of the six integers appended is
                 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= 10^9*/

    long long minimalKSum(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        long long ans = (long) k*(k+1)/2;
        for (int i = 0, prev = INT_MIN; i < nums.size(); prev = nums[i], ++i)
            if (prev < nums[i])
                if (nums[i] <= k) ans += (++k) - nums[i];
                else break;
        return ans;
    }


    /*2196. Create Binary Tree From Descriptions (Medium)
    You are given a 2D integer array descriptions where
    descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the
    parent of childi in a binary tree of unique values. Furthermore,
    * If isLefti == 1, then childi is the left child of parenti.
    * If isLefti == 0, then childi is the right child of parenti.
    Construct the binary tree described by descriptions and return its root.
    The test cases will be generated such that the binary tree is valid.

    Example 1:
    Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]
    Output: [50,20,80,15,17,19]
    Explanation: The root node is the node with value 50 since it has no parent.
                 The resulting binary tree is shown in the diagram.

    Example 2:
    Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]]
    Output: [1,2,null,null,3,4]
    Explanation: The root node is the node with value 1 since it has no parent.
                 The resulting binary tree is shown in the diagram.

    Constraints:
    * 1 <= descriptions.length <= 10^4
    * descriptions[i].length == 3
    * 1 <= parenti, childi <= 10^5
    * 0 <= isLefti <= 1
    * The binary tree described by descriptions is valid.*/

    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {
        unordered_map<int, TreeNode*> mp;
        unordered_set<int> child;
        for (auto& d : descriptions) {
            int p = d[0], c = d[1], left = d[2];
            if (!mp.contains(p)) mp[p] = new TreeNode(p);
            if (!mp.contains(c)) mp[c] = new TreeNode(c);
            if (left) mp[p]->left = mp[c];
            else mp[p]->right = mp[c];
            child.insert(c);
        }
        for (auto& d : descriptions)
            if (!child.contains(d[0])) return mp[d[0]];
        return nullptr;
    }


    /*2197. Replace Non-Coprime Numbers in Array (Hard)
    You are given an array of integers nums. Perform the following steps:
    * Find any two adjacent numbers in nums that are non-coprime.
    * If no such numbers are found, stop the process.
    * Otherwise, delete the two numbers and replace them with their LCM (Least
      Common Multiple).
    * Repeat this process as long as you keep finding two adjacent non-coprime
      numbers.
    Return the final modified array. It can be shown that replacing adjacent
    non-coprime numbers in any arbitrary order will lead to the same result.
    The test cases are generated such that the values in the final array are
    less than or equal to 10^8. Two values x and y are non-coprime if
    GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.

    Example 1:
    Input: nums = [6,4,3,2,7,6,2]
    Output: [12,7,6]
    Explanation: - (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [12,3,2,7,6,2].
                 - (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [12,2,7,6,2].
                 - (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [12,7,6,2].
                 - (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,6].
                 There are no more adjacent non-coprime numbers in nums. Thus,
                 the final modified array is [12,7,6]. Note that there are
                 other ways to obtain the same resultant array.

    Example 2:
    Input: nums = [2,2,1,1,3,3,3]
    Output: [2,1,1,3]
    Explanation: - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3,3].
                 - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3].
                 - (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [2,1,1,3].
                 There are no more adjacent non-coprime numbers in nums. Thus,
                 the final modified array is [2,1,1,3]. Note that there are
                 other ways to obtain the same resultant array.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * The test cases are generated such that the values in the final array are
      less than or equal to 10^8.*/

    vector<int> replaceNonCoprimes(vector<int>& nums) {
        vector<int> stk;
        for (auto& x : nums) {
            while (stk.size() && gcd(stk.back(), x) > 1) {
                x = lcm(x, stk.back());
                stk.pop_back();
            }
            stk.push_back(x);
        }
        return stk;
    }


    /*2198. Number of Single Divisor Triplets (Medium)
    You are given a 0-indexed array of positive integers nums. A triplet of
    three distinct indices (i, j, k) is called a single divisor triplet of nums
    if nums[i] + nums[j] + nums[k] is divisible by exactly one of nums[i],
    nums[j], or nums[k]. Return the number of single divisor triplets of nums.

    Example 1:
    Input: nums = [4,6,7,3,2]
    Output: 12
    Explanation: The triplets (0, 3, 4), (0, 4, 3), (3, 0, 4), (3, 4, 0),
                 (4, 0, 3), and (4, 3, 0) have the values of [4, 3, 2] (or a
                 permutation of [4, 3, 2]). 4 + 3 + 2 = 9 which is only
                 divisible by 3, so all such triplets are single divisor
                 triplets. The triplets (0, 2, 3), (0, 3, 2), (2, 0, 3),
                 (2, 3, 0), (3, 0, 2), and (3, 2, 0) have the values of
                 [4, 7, 3] (or a permutation of [4, 7, 3]). 4 + 7 + 3 = 14
                 which is only divisible by 7, so all such triplets are single
                 divisor triplets. There are 12 single divisor triplets in
                 total.

    Example 2:
    Input: nums = [1,2,2]
    Output: 6
    Explanation: The triplets (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0),
                 (2, 0, 1), and (2, 1, 0) have the values of [1, 2, 2] (or a
                 permutation of [1, 2, 2]). 1 + 2 + 2 = 5 which is only
                 divisible by 1, so all such triplets are single divisor
                 triplets. There are 6 single divisor triplets in total.

    Example 3:
    Input: nums = [1,1,1]
    Output: 0
    Explanation: There are no single divisor triplets. Note that (0, 1, 2) is
                 not a single divisor triplet because
                 nums[0] + nums[1] + nums[2] = 3 and 3 is divisible by nums[0],
                 nums[1], and nums[2].

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 100*/

    long long singleDivisorTriplet(vector<int>& nums) {
        vector<int> freq(101);
        for (auto& x : nums) ++freq[x];
        long long ans = 0;
        for (int i = 1; i <= 100; ++i)
            for (int j = i; freq[i] && j <= 100; ++j)
                for (int k = j; freq[j] && k <= 100; ++k)
                    if (freq[k]) {
                        int sm = i+j+k;
                        if (bool(sm%i) + bool(sm%j) + bool(sm%k) == 2)
                            if (i == j) ans += (long long) freq[i]*(freq[j]-1)/2*freq[k];
                            else if (j == k) ans += (long long) freq[i]*freq[j]*(freq[k]-1)/2;
                            else ans += (long long) freq[i]*freq[j]*freq[k];
                    }
        return ans*6;
    }


    /*2204. Distance to a Cycle in Undirected Graph (Hard)
    You are given a positive integer n representing the number of nodes in a
    connected undirected graph containing exactly one cycle. The nodes are
    numbered from 0 to n - 1 (inclusive). You are also given a 2D integer array
    edges, where edges[i] = [node1i, node2i] denotes that there is a
    bidirectional edge connecting node1i and node2i in the graph. The distance
    between two nodes a and b is defined to be the minimum number of edges that
    are needed to go from a to b. Return an integer array answer of size n,
    where answer[i] is the minimum distance between the ith node and any node
    in the cycle.

    Example 1:
    Input: n = 7, edges = [[1,2],[2,4],[4,3],[3,1],[0,1],[5,2],[6,5]]
    Output: [1,0,0,0,0,1,2]
    Explanation: The nodes 1, 2, 3, and 4 form the cycle.
                 The distance from 0 to 1 is 1.
                 The distance from 1 to 1 is 0.
                 The distance from 2 to 2 is 0.
                 The distance from 3 to 3 is 0.
                 The distance from 4 to 4 is 0.
                 The distance from 5 to 2 is 1.
                 The distance from 6 to 2 is 2.

    Example 2:
    Input: n = 9, edges = [[0,1],[1,2],[0,2],[2,6],[6,7],[6,8],[0,3],[3,4],[3,5]]
    Output: [0,0,0,1,2,2,1,2,2]
    Explanation: The nodes 0, 1, and 2 form the cycle.
                 The distance from 0 to 0 is 0.
                 The distance from 1 to 1 is 0.
                 The distance from 2 to 2 is 0.
                 The distance from 3 to 1 is 1.
                 The distance from 4 to 1 is 2.
                 The distance from 5 to 1 is 2.
                 The distance from 6 to 2 is 1.
                 The distance from 7 to 2 is 2.
                 The distance from 8 to 2 is 2.

    Constraints:
    * 3 <= n <= 10^5
    * edges.length == n
    * edges[i].length == 2
    * 0 <= node1i, node2i <= n - 1
    * node1i != node2i
    * The graph is connected.
    * The graph has exactly one cycle.
    * There is at most one edge between any pair of vertices.*/

    vector<int> distanceToCycle(int n, vector<vector<int>>& edges) {
        vector<vector<int>> graph(n);
        for (auto& e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }
        stack<int> stk;
        vector<int> degree(n);
        for (int u = 0; u < n; ++u) {
            degree[u] = graph[u].size();
            if (degree[u] == 1) stk.push(u);
        }
        while (stk.size()) {
            auto u = stk.top(); stk.pop();
            for (auto& v : graph[u])
                if (degree[v] > 1 && --degree[v] == 1) stk.push(v);
        }
        vector<int> ans(n, -1);
        queue<int> q;
        for (int u = 0; u < n; ++u)
            if (degree[u] > 1) {
                q.push(u);
                ans[u] = 0;
            }
        for (int val = 1; q.size(); ++val)
            for (int sz = q.size(); sz; --sz) {
                auto u = q.front(); q.pop();
                for (auto& v : graph[u])
                    if (ans[v] == -1) {
                        q.push(v);
                        ans[v] = val;
                    }
            }
        return ans;
    }


    /*2214. Minimum Health to Beat Game (Medium)
    You are playing a game that has n levels numbered from 0 to n - 1. You are
    given a 0-indexed integer array damage where damage[i] is the amount of
    health you will lose to complete the ith level. You are also given an
    integer armor. You may use your armor ability at most once during the game
    on any level which will protect you from at most armor damage. You must
    complete the levels in order and your health must be greater than 0 at all
    times to beat the game. Return the minimum health you need to start with to
    beat the game.

    Example 1:
    Input: damage = [2,7,4,3], armor = 4
    Output: 13
    Explanation: One optimal way to beat the game starting at 13 health is:
                 On round 1, take 2 damage. You have 13 - 2 = 11 health.
                 On round 2, take 7 damage. You have 11 - 7 = 4 health.
                 On round 3, use your armor to protect you from 4 damage. You
                             have 4 - 0 = 4 health.
                 On round 4, take 3 damage. You have 4 - 3 = 1 health.
                 Note that 13 is the minimum health you need to start with to
                 beat the game.

    Example 2:
    Input: damage = [2,5,3,4], armor = 7
    Output: 10
    Explanation: One optimal way to beat the game starting at 10 health is:
                 On round 1, take 2 damage. You have 10 - 2 = 8 health.
                 On round 2, use your armor to protect you from 5 damage. You
                             have 8 - 0 = 8 health.
                 On round 3, take 3 damage. You have 8 - 3 = 5 health.
                 On round 4, take 4 damage. You have 5 - 4 = 1 health.
                 Note that 10 is the minimum health you need to start with to
                 beat the game.

    Example 3:
    Input: damage = [3,3,3], armor = 0
    Output: 10
    Explanation: One optimal way to beat the game starting at 10 health is:
                 On round 1, take 3 damage. You have 10 - 3 = 7 health.
                 On round 2, take 3 damage. You have 7 - 3 = 4 health.
                 On round 3, take 3 damage. You have 4 - 3 = 1 health.
                 Note that you did not use your armor ability.

    Constraints:
    * n == damage.length
    * 1 <= n <= 10^5
    * 0 <= damage[i] <= 10^5
    * 0 <= armor <= 10^5*/

    long long minimumHealth(vector<int>& damage, int armor) {
        return accumulate(damage.begin(), damage.end(), 1ll) - min(*max_element(damage.begin(), damage.end()), armor);
    }


    /*2219. Maximum Sum Score of Array (Medium)
    You are given a 0-indexed integer array nums of length n. The sum score of
    nums at an index i where 0 <= i < n is the maximum of:
    * The sum of the first i + 1 elements of nums.
    * The sum of the last n - i elements of nums.
    Return the maximum sum score of nums at any index.

    Example 1:
    Input: nums = [4,3,-2,5]
    Output: 10
    Explanation: The sum score at index 0 is max(4, 4 + 3 + -2 + 5) = max(4, 10) = 10.
                 The sum score at index 1 is max(4 + 3, 3 + -2 + 5) = max(7, 6) = 7.
                 The sum score at index 2 is max(4 + 3 + -2, -2 + 5) = max(5, 3) = 5.
                 The sum score at index 3 is max(4 + 3 + -2 + 5, 5) = max(10, 5) = 10.
                 The maximum sum score of nums is 10.

    Example 2:
    Input: nums = [-3,-5]
    Output: -3
    Explanation: The sum score at index 0 is max(-3, -3 + -5) = max(-3, -8) = -3.
                 The sum score at index 1 is max(-3 + -5, -5) = max(-8, -5) = -5.
                 The maximum sum score of nums is -3.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * -10^5 <= nums[i] <= 10^5*/

    long long maximumSumScore(vector<int>& nums) {
        long long ans = LONG_MIN, prefix = 0, suffix = accumulate(nums.begin(), nums.end(), 0ll);
        for (auto& x : nums) {
            prefix += x;
            ans = max({ans, prefix, suffix});
            suffix -= x;
        }
        return ans;
    }


    /*2220. Minimum Bit Flips to Convert Number (Easy)
    A bit flip of a number x is choosing a bit in the binary representation of x
    and flipping it from either 0 to 1 or 1 to 0.
    * For example, for x = 7, the binary representation is 111 and we may choose
      any bit (including any leading zeros not shown) and flip it. We can flip
      the first bit from the right to get 110, flip the second bit from the
      right to get 101, flip the fifth bit from the right (a leading zero) to
      get 10111, etc.
    Given two integers start and goal, return the minimum number of bit flips to
    convert start to goal.

    Example 1:
    Input: start = 10, goal = 7
    Output: 3
    Explanation: The binary representation of 10 and 7 are 1010 and 0111
                 respectively. We can convert 10 to 7 in 3 steps:
                 - Flip the first bit from the right: 1010 -> 1011.
                 - Flip the third bit from the right: 1011 -> 1111.
                 - Flip the fourth bit from the right: 1111 -> 0111.
                 It can be shown we cannot convert 10 to 7 in less than 3 steps.
                 Hence, we return 3.

    Example 2:
    Input: start = 3, goal = 4
    Output: 3
    Explanation: The binary representation of 3 and 4 are 011 and 100
                 respectively. We can convert 3 to 4 in 3 steps:
                 - Flip the first bit from the right: 011 -> 010.
                 - Flip the second bit from the right: 010 -> 000.
                 - Flip the third bit from the right: 000 -> 100.
                 It can be shown we cannot convert 3 to 4 in less than 3 steps.
                 Hence, we return 3.

    Constraints: 0 <= start, goal <= 10^9*/

    int minBitFlips(int start, int goal) {
        return __popcount(start ^ goal);
    }


    /*2229. Check if an Array Is Consecutive (Easy)
    Given an integer array nums, return true if nums is consecutive, otherwise
    return false. An array is consecutive if it contains every number in the
    range [x, x + n - 1] (inclusive), where x is the minimum number in the
    array and n is the length of the array.

    Example 1:
    Input: nums = [1,3,4,2]
    Output: true
    Explanation: The minimum value is 1 and the length of nums is 4. All of the
                 values in the range [x, x + n - 1] = [1, 1 + 4 - 1] = [1, 4]
                 = (1, 2, 3, 4) occur in nums. Therefore, nums is consecutive.

    Example 2:
    Input: nums = [1,3]
    Output: false
    Explanation: The minimum value is 1 and the length of nums is 2. The value
                 2 in the range [x, x + n - 1] = [1, 1 + 2 - 1], = [1, 2]
                 = (1, 2) does not occur in nums. Therefore, nums is not
                 consecutive.

    Example 3:
    Input: nums = [3,5,4]
    Output: true
    Explanation: The minimum value is 3 and the length of nums is 3. All of the
                 values in the range [x, x + n - 1] = [3, 3 + 3 - 1] = [3, 5]
                 = (3, 4, 5) occur in nums. Therefore, nums is consecutive.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5*/

    bool isConsecutive(vector<int>& nums) {
        int m = *min_element(nums.begin(), nums.end()), n = nums.size();
        vector<bool> seen(n);
        for (auto& x : nums) {
            if (x >= m + n || seen[x-m]) return false;
            seen[x-m] = true;
        }
        return true;
    }


    /*2235. Add Two Integers (Easy)
    Given two integers num1 and num2, return the sum of the two integers.

    Example 1:
    Input: num1 = 12, num2 = 5
    Output: 17
    Explanation: num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is
                 returned.

    Example 2:
    Input: num1 = -10, num2 = 4
    Output: -6
    Explanation: num1 + num2 = -6, so -6 is returned.

    Constraints:
    * -100 <= num1, num2 <= 100*/

    int sum(int num1, int num2) {
        return num1 + num2;
    }


    /*2236. Root Equals Sum of Children (Easy)
    You are given the root of a binary tree that consists of exactly 3 nodes:
    the root, its left child, and its right child. Return true if the value of
    the root is equal to the sum of the values of its two children, or false
    otherwise.

    Example 1:
    Input: root = [10,4,6]
    Output: true
    Explanation: The values of the root, its left child, and its right child
                 are 10, 4, and 6, respectively. 10 is equal to 4 + 6, so we
                 return true.

    Example 2:
    Input: root = [5,3,1]
    Output: false
    Explanation: The values of the root, its left child, and its right child
                 are 5, 3, and 1, respectively. 5 is not equal to 3 + 1, so we
                 return false.

    Constraints:
    * The tree consists only of the root, its left child, and its right child.
    * -100 <= Node.val <= 100*/

    bool checkTree(TreeNode* root) {
        return root->val == root->left->val + root->right->val;
    }


    /*2237. Count Positions on Street With Required Brightness (Medium)
    You are given an integer n. A perfectly straight street is represented by a
    number line ranging from 0 to n - 1. You are given a 2D integer array
    lights representing the street lamp(s) on the street. Each
    lights[i] = [positioni, rangei] indicates that there is a street lamp at
    position positioni that lights up the area from
    [max(0, positioni - rangei), min(n - 1, positioni + rangei)] (inclusive).
    The brightness of a position p is defined as the number of street lamps
    that light up the position p. You are given a 0-indexed integer array
    requirement of size n where requirement[i] is the minimum brightness of the
    ith position on the street. Return the number of positions i on the street
    between 0 and n - 1 that have a brightness of at least requirement[i].

    Example 1:
    Input: n = 5, lights = [[0,1],[2,1],[3,2]], requirement = [0,2,1,4,1]
    Output: 4
    Explanation: - The first street lamp lights up the area from
                   [max(0, 0 - 1), min(n - 1, 0 + 1)] = [0, 1] (inclusive).
                 - The second street lamp lights up the area from
                   [max(0, 2 - 1), min(n - 1, 2 + 1)] = [1, 3] (inclusive).
                 - The third street lamp lights up the area from
                   [max(0, 3 - 2), min(n - 1, 3 + 2)] = [1, 4] (inclusive).
                 - Position 0 is covered by the first street lamp. It is
                   covered by 1 street lamp which is greater than requirement[0].
                 - Position 1 is covered by the first, second, and third street
                   lamps. It is covered by 3 street lamps which is greater than
                   requirement[1].
                 - Position 2 is covered by the second and third street lamps.
                   It is covered by 2 street lamps which is greater than
                   requirement[2].
                 - Position 3 is covered by the second and third street lamps.
                   It is covered by 2 street lamps which is less than
                   requirement[3].
                 - Position 4 is covered by the third street lamp. It is
                   covered by 1 street lamp which is equal to requirement[4].
                 Positions 0, 1, 2, and 4 meet the requirement so we return 4.

    Example 2:
    Input: n = 1, lights = [[0,1]], requirement = [2]
    Output: 0
    Explanation: - The first street lamp lights up the area from
                   [max(0, 0 - 1), min(n - 1, 0 + 1)] = [0, 0] (inclusive).
                 - Position 0 is covered by the first street lamp. It is
                   covered by 1 street lamp which is less than requirement[0].
                 - We return 0 because no position meets their brightness
                   requirement.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= lights.length <= 10^5
    * 0 <= positioni < n
    * 0 <= rangei <= 10^5
    * requirement.length == n
    * 0 <= requirement[i] <= 10^5*/

    int meetRequirement(int n, vector<vector<int>>& lights, vector<int>& requirement) {
        vector<int> line(n+1);
        for (auto& x : lights) {
            int lo = max(0, x[0]-x[1]), hi = min(n, x[0]+x[1]+1);
            ++line[max(0, x[0]-x[1])];
            --line[min(n, x[0]+x[1]+1)];
        }
        int ans = 0;
        for (int i = 0, prefix = 0; i < n; ++i) {
            prefix += line[i];
            if (prefix >= requirement[i]) ++ans;
        }
        return ans;
    }


    /*2247. Maximum Cost of Trip With K Highways (Hard)
    A series of highways connect n cities numbered from 0 to n - 1. You are
    given a 2D integer array highways where highways[i] = [city1i, city2i, tolli]
    indicates that there is a highway that connects city1i and city2i, allowing
    a car to go from city1i to city2i and vice versa for a cost of tolli. You
    are also given an integer k. You are going on a trip that crosses exactly k
    highways. You may start at any city, but you may only visit each city at
    most once during your trip. Return the maximum cost of your trip. If there
    is no trip that meets the requirements, return -1.

    Example 1:
    Input: n = 5, highways = [[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]], k = 3
    Output: 17
    Explanation: One possible trip is to go from 0 -> 1 -> 4 -> 3. The cost of
                 this trip is 4 + 11 + 2 = 17. Another possible trip is to go
                 from 4 -> 1 -> 2 -> 3. The cost of this trip is
                 11 + 3 + 3 = 17. It can be proven that 17 is the maximum
                 possible cost of any valid trip. Note that the trip
                 4 -> 1 -> 0 -> 1 is not allowed because you visit the city 1
                 twice.

    Example 2:
    Input: n = 4, highways = [[0,1,3],[2,3,2]], k = 2
    Output: -1
    Explanation: There are no valid trips of length 2, so return -1.

    Constraints:
    * 2 <= n <= 15
    * 1 <= highways.length <= 50
    * highways[i].length == 3
    * 0 <= city1i, city2i <= n - 1
    * city1i != city2i
    * 0 <= tolli <= 100
    * 1 <= k <= 50
    * There are no duplicate highways.*/

    int maximumCost(int n, vector<vector<int>>& highways, int k) {
        vector<vector<pair<int, int>>> graph(n);
        for (auto& h : highways) {
            graph[h[0]].emplace_back(h[1], h[2]);
            graph[h[1]].emplace_back(h[0], h[2]);
        }
        vector<vector<int>> dp(n, vector<int>(1<<n, INT_MIN));
        for (int m = (1<<n)-1; m >= 0; --m)
            for (int u = 0; u < n; ++u)
                if (m & 1<<u) {
                    int cnt = __builtin_popcount(m);
                    if (cnt == k+1) dp[u][m] = 0;
                    else if (cnt < k+1)
                        for (auto& [v, w] : graph[u])
                            if (!(m & 1<<v)) dp[u][m] = max(dp[u][m], w + dp[v][m ^ 1<<v]);
                }
        int ans = -1;
        for (int u = 0; u < n; ++u) ans = max(ans, dp[u][1<<u]);
        return ans;
    }


    /*2263. Make Array Non-decreasing or Non-increasing (Hard)
    You are given a 0-indexed integer array nums. In one operation, you can:
    * Choose an index i in the range 0 <= i < nums.length
    * Set nums[i] to nums[i] + 1 or nums[i] - 1
    Return the minimum number of operations to make nums non-decreasing or non-
    increasing.

    Example 1:
    Input: nums = [3,2,4,5,0]
    Output: 4
    Explanation: One possible way to turn nums into non-increasing order is to:
                 - Add 1 to nums[1] once so that it becomes 3.
                 - Subtract 1 from nums[2] once so it becomes 3.
                 - Subtract 1 from nums[3] twice so it becomes 3.
                 After doing the 4 operations, nums becomes [3,3,3,3,0] which
                 is in non-increasing order. Note that it is also possible to
                 turn nums into [4,4,4,4,0] in 4 operations. It can be proven
                 that 4 is the minimum number of operations needed.

    Example 2:
    Input: nums = [2,2,3,4]
    Output: 0
    Explanation: nums is already in non-decreasing order, so no operations are
                 needed and we return 0.

    Example 3:
    Input: nums = [0]
    Output: 0
    Explanation: nums is already in non-decreasing order, so no operations are
                 needed and we return 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 1000

    Follow up: Can you solve it in O(n*log(n)) time complexity?*/

    int convertArray(vector<int>& nums) {

        auto fn = [&](vector<int>& nums) {
            priority_queue<int> pq;
            int ans = 0;
            for (auto& x : nums) {
                if (pq.size() && x < pq.top()) {
                    ans += pq.top() - x;
                    pq.pop();
                    pq.push(x);
                }
                pq.push(x);
            }
            return ans;
        };

        int ans = fn(nums);
        reverse(nums.begin(), nums.end());
        return min(ans, fn(nums));
    }


    /*2268. Minimum Number of Keypresses (Medium)
    You have a keypad with 9 buttons, numbered from 1 to 9, each mapped to
    lowercase English letters. You can choose which characters each button is
    matched to as long as:
    * All 26 lowercase English letters are mapped to.
    * Each character is mapped to by exactly 1 button.
    * Each button maps to at most 3 characters.
    To type the first character matched to a button, you press the button once.
    To type the second character, you press the button twice, and so on. Given
    a string s, return the minimum number of keypresses needed to type s using
    your keypad. Note that the characters mapped to by each button, and the
    order they are mapped in cannot be changed.

    Example 1:
    Input: s = "apple"
    Output: 5
    Explanation: One optimal way to setup your keypad is shown above.
                 Type 'a' by pressing button 1 once.
                 Type 'p' by pressing button 6 once.
                 Type 'p' by pressing button 6 once.
                 Type 'l' by pressing button 5 once.
                 Type 'e' by pressing button 3 once.
                 A total of 5 button presses are needed, so return 5.

    Example 2:
    Input: s = "abcdefghijkl"
    Output: 15
    Explanation: One optimal way to setup your keypad is shown above.
                 The letters 'a' to 'i' can each be typed by pressing a button
                 once.
                 Type 'j' by pressing button 1 twice.
                 Type 'k' by pressing button 2 twice.
                 Type 'l' by pressing button 3 twice.
                 A total of 15 button presses are needed, so return 15.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters.*/

    int minimumKeypresses(string s) {
        vector<int> freq(26);
        for (auto& ch : s) ++freq[ch - 'a'];
        sort(freq.begin(), freq.end(), greater<>());
        int ans = 0;
        for (int i = 0, press = 0; i < 26; ++i) {
            if (i % 9 == 0) ++press;
            ans += press * freq[i];
        }
        return ans;
    }


    /*2277. Closest Node to Path in Tree (Hard)
    You are given a positive integer n representing the number of nodes in a
    tree, numbered from 0 to n - 1 (inclusive). You are also given a 2D integer
    array edges of length n - 1, where edges[i] = [node1i, node2i] denotes that
    there is a bidirectional edge connecting node1i and node2i in the tree. You
    are given a 0-indexed integer array query of length m where
    query[i] = [starti, endi, nodei] means that for the ith query, you are
    tasked with finding the node on the path from starti to endi that is
    closest to nodei. Return an integer array answer of length m, where
    answer[i] is the answer to the ith query.

    Example 1:
    Input: n = 7, edges = [[0,1],[0,2],[0,3],[1,4],[2,5],[2,6]], query = [[5,3,4],[5,3,6]]
    Output: [0,2]
    Explanation: The path from node 5 to node 3 consists of the nodes 5, 2, 0,
                 and 3. The distance between node 4 and node 0 is 2. Node 0 is
                 the node on the path closest to node 4, so the answer to the
                 first query is 0. The distance between node 6 and node 2 is 1.
                 Node 2 is the node on the path closest to node 6, so the
                 answer to the second query is 2.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2]], query = [[0,1,2]]
    Output: [1]
    Explanation: The path from node 0 to node 1 consists of the nodes 0, 1. The
                 distance between node 2 and node 1 is 1. Node 1 is the node on
                 the path closest to node 2, so the answer to the first query
                 is 1.

    Example 3:
    Input: n = 3, edges = [[0,1],[1,2]], query = [[0,0,0]]
    Output: [0]
    Explanation: The path from node 0 to node 0 consists of the node 0. Since 0
                 is the only node on the path, the answer to the first query is
                 0.

    Constraints:
    * 1 <= n <= 1000
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= node1i, node2i <= n - 1
    * node1i != node2i
    * 1 <= query.length <= 1000
    * query[i].length == 3
    * 0 <= starti, endi, nodei <= n - 1
    * The graph is a tree.*/

    vector<int> closestNode(int n, vector<vector<int>>& edges, vector<vector<int>>& query) {
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        int m = int(log2(n)) + 1;
        vector<vector<int>> lift(n, vector<int>(m, -1)); // binary lifting
        vector<int> depth(n, -1);
        stack<tuple<int, int, int>> stk; stk.emplace(0, -1, 0);
        while (stk.size()) {
            auto [u, p, d] = stk.top(); stk.pop();
            depth[u] = d;
            for (auto& v : tree[u])
                if (v != p) {
                    lift[v][0] = u;
                    for (int j = 1; j < m; ++j) {
                        if (lift[v][j-1] == -1) break;
                        lift[v][j] = lift[lift[v][j-1]][j-1];
                    }
                    stk.emplace(v, u, d+1);
                }
        }

        auto lca = [&](int u, int v) {
            /*Return lowest common ancestor via binary lifting.*/
            if (depth[u] > depth[v]) swap(u, v);
            for (int i = 0; i < m; ++i)
                if (depth[v]-depth[u] & 1<<i) v = lift[v][i];
            if (u == v) return u;
            for (int i = m-1; i >= 0; --i)
                if (lift[u][i] != lift[v][i]) {
                    u = lift[u][i];
                    v = lift[v][i];
                }
            return lift[u][0];
        };

        vector<int> ans;
        for (auto& q : query) {
            int x = lca(q[0], q[1]), y = lca(q[1], q[2]), z = lca(q[2], q[0]);
            if (depth[x] < depth[y]) swap(x, y);
            if (depth[x] < depth[z]) swap(x, z);
            ans.push_back(x);
        }
        return ans;
    }


    /*2279. Maximum Bags With Full Capacity of Rocks (Medium)
    You have n bags numbered from 0 to n - 1. You are given two 0-indexed
    integer arrays capacity and rocks. The ith bag can hold a maximum of
    capacity[i] rocks and currently contains rocks[i] rocks. You are also given
    an integer additionalRocks, the number of additional rocks you can place in
    any of the bags. Return the maximum number of bags that could have full
    capacity after placing the additional rocks in some bags.

    Example 1:
    Input: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2
    Output: 3
    Explanation: Place 1 rock in bag 0 and 1 rock in bag 1. The number of rocks
                 in each bag are now [2,3,4,4]. Bags 0, 1, and 2 have full
                 capacity. There are 3 bags at full capacity, so we return 3.
                 It can be shown that it is not possible to have more than 3
                 bags at full capacity. Note that there may be other ways of
                 placing the rocks that result in an answer of 3.

    Example 2:
    Input: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100
    Output: 3
    Explanation: Place 8 rocks in bag 0 and 2 rocks in bag 2. The number of
                 rocks in each bag are now [10,2,2]. Bags 0, 1, and 2 have full
                 capacity. There are 3 bags at full capacity, so we return 3.
                 It can be shown that it is not possible to have more than 3
                 bags at full capacity. Note that we did not use all of the
                 additional rocks.

    Constraints:
    * n == capacity.length == rocks.length
    * 1 <= n <= 5 * 10^4
    * 1 <= capacity[i] <= 10^9
    * 0 <= rocks[i] <= capacity[i]
    * 1 <= additionalRocks <= 10^9*/

    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {
        vector<int> diff;
        for (int i = 0; i < capacity.size(); ++i) diff.push_back(capacity[i] - rocks[i]);
        sort(diff.begin(), diff.end());
        int ans = 0;
        for (auto& x : diff)
            if (x <= additionalRocks) ++ans, additionalRocks -= x;
        return ans;
    }


    /*2282. Number of People That Can Be Seen in a Grid (Medium)
    You are given an m x n 0-indexed 2D array of positive integers heights
    where heights[i][j] is the height of the person standing at position (i, j).
    A person standing at position (row1, col1) can see a person standing at
    position (row2, col2) if:
    * The person at (row2, col2) is to the right or below the person at
      (row1, col1). More formally, this means that either row1 == row2 and
      col1 < col2 or row1 < row2 and col1 == col2.
    * Everyone in between them is shorter than both of them.
    Return an m x n 2D array of integers answer where answer[i][j] is the
    number of people that the person at position (i, j) can see.

    Example 1:
    Input: heights = [[3,1,4,2,5]]
    Output: [[2,1,2,1,0]]
    Explanation: - The person at (0, 0) can see the people at (0, 1) and (0, 2).
                   Note that he cannot see the person at (0, 4) because the
                   person at (0, 2) is taller than him.
                 - The person at (0, 1) can see the person at (0, 2).
                 - The person at (0, 2) can see the people at (0, 3) and (0, 4).
                 - The person at (0, 3) can see the person at (0, 4).
                 - The person at (0, 4) cannot see anybody.

    Example 2:
    Input: heights = [[5,1],[3,1],[4,1]]
    Output: [[3,1],[2,1],[1,0]]
    Explanation: - The person at (0, 0) can see the people at (0, 1), (1, 0)
                   and (2, 0).
                 - The person at (0, 1) can see the person at (1, 1).
                 - The person at (1, 0) can see the people at (1, 1) and (2, 0).
                 - The person at (1, 1) can see the person at (2, 1).
                 - The person at (2, 0) can see the person at (2, 1).
                 - The person at (2, 1) cannot see anybody.

    Constraints:
    * 1 <= heights.length <= 400
    * 1 <= heights[i].length <= 400
    * 1 <= heights[i][j] <= 10^5*/

    vector<vector<int>> seePeople(vector<vector<int>>& heights) {
        int m = heights.size(), n = heights[0].size();
        vector<vector<int>> ans(m, vector<int>(n));
        for (int i = 0; i < m; ++i) {
            stack<int> stk;
            for (int j = 0; j < n; ++j) {
                int prev = INT_MIN;
                while (stk.size() && heights[i][stk.top()] < heights[i][j]) {
                    if (prev < heights[i][stk.top()]) ++ans[i][stk.top()];
                    prev = heights[i][stk.top()];
                    stk.pop();
                }
                if (stk.size() && prev < heights[i][stk.top()]) ++ans[i][stk.top()];
                stk.push(j);
            }
        }
        for (int j = 0; j < n; ++j) {
            stack<int> stk;
            for (int i = 0; i < m; ++i) {
                int prev = INT_MIN;
                while (stk.size() && heights[stk.top()][j] < heights[i][j]) {
                    if (prev < heights[stk.top()][j]) ++ans[stk.top()][j];
                    prev = heights[stk.top()][j];
                    stk.pop();
                }
                if (stk.size() && prev < heights[stk.top()][j]) ++ans[stk.top()][j];
                stk.push(i);
            }
        }
        return ans;
    }


    /*2291. Maximum Profit From Trading Stocks (Medium)
    You are given two 0-indexed integer arrays of the same length present and
    future where present[i] is the current price of the ith stock and future[i]
    is the price of the ith stock a year in the future. You may buy each stock
    at most once. You are also given an integer budget representing the amount
    of money you currently have. Return the maximum amount of profit you can
    make.

    Example 1:
    Input: present = [5,4,6,2,3], future = [8,5,4,3,5], budget = 10
    Output: 6
    Explanation: One possible way to maximize your profit is to:
                 Buy the 0th, 3rd, and 4th stocks for a total of 5 + 2 + 3 = 10.
                 Next year, sell all three stocks for a total of 8 + 3 + 5 = 16.
                 The profit you made is 16 - 10 = 6. It can be shown that the
                 maximum profit you can make is 6.

    Example 2:
    Input: present = [2,2,5], future = [3,4,10], budget = 6
    Output: 5
    Explanation: The only possible way to maximize your profit is to:
                 Buy the 2nd stock, and make a profit of 10 - 5 = 5.
                 It can be shown that the maximum profit you can make is 5.

    Example 3:
    Input: present = [3,3,12], future = [0,3,15], budget = 10
    Output: 0
    Explanation: One possible way to maximize your profit is to:
                 Buy the 1st stock, and make a profit of 3 - 3 = 0.
                 It can be shown that the maximum profit you can make is 0.

    Constraints:
    * n == present.length == future.length
    * 1 <= n <= 1000
    * 0 <= present[i], future[i] <= 100
    * 0 <= budget <= 1000*/

    int maximumProfit(vector<int>& present, vector<int>& future, int budget) {
        vector<int> dp(budget+1);
        for (int i = 0; i < present.size(); ++i)
            for (int j = budget; j >= present[i]; --j) {
                dp[j] = max(dp[j], dp[j-present[i]] + future[i] - present[i]);
            }
        return dp.back();
    }


    /*2297. Jump Game VIII (Medium)
    You are given a 0-indexed integer array nums of length n. You are initially
    standing at index 0. You can jump from index i to index j where i < j if:
    * nums[i] <= nums[j] and nums[k] < nums[i] for all indexes k in the range
      i < k < j, or
    * nums[i] > nums[j] and nums[k] >= nums[i] for all indexes k in the range
      i < k < j.
    You are also given an integer array costs of length n where costs[i]
    denotes the cost of jumping to index i. Return the minimum cost to jump to
    the index n - 1.

    Example 1:
    Input: nums = [3,2,4,4,1], costs = [3,7,6,4,2]
    Output: 8
    Explanation: You start at index 0.
                 - Jump to index 2 with a cost of costs[2] = 6.
                 - Jump to index 4 with a cost of costs[4] = 2.
                 The total cost is 8. It can be proven that 8 is the minimum
                 cost needed. Two other possible paths are from index 0 -> 1 ->
                 4 and index 0 -> 2 -> 3 -> 4. These have a total cost of 9 and
                 12, respectively.

    Example 2:
    Input: nums = [0,1,2], costs = [1,1,1]
    Output: 2
    Explanation: Start at index 0.
                 - Jump to index 1 with a cost of costs[1] = 1.
                 - Jump to index 2 with a cost of costs[2] = 1.
                 The total cost is 2. Note that you cannot jump directly from
                 index 0 to index 2 because nums[0] <= nums[1].

    Constraints:
    * n == nums.length == costs.length
    * 1 <= n <= 10^5
    * 0 <= nums[i], costs[i] <= 10^5*/

    long long minCost(vector<int>& nums, vector<int>& costs) {
        vector<vector<int>> jump(nums.size());
        stack<int> s0, s1;
        for (int i = 0; i < nums.size(); ++i) {
            while (s0.size() && nums[s0.top()] <= nums[i]) jump[i].push_back(s0.top()), s0.pop();
            while (s1.size() && nums[s1.top()] > nums[i]) jump[i].push_back(s1.top()), s1.pop();
            s0.push(i);
            s1.push(i);
        }
        vector<long long> dp(nums.size(), LONG_MAX);
        dp[0] = 0;
        for (int i = 0; i < costs.size(); ++i)
            for (auto& k : jump[i]) dp[i] = min(dp[i], dp[k] + costs[i]);
        return dp.back();
    }


    /*2307. Check for Contradictions in Equations (Hard)
    You are given a 2D array of strings equations and an array of real numbers
    values, where equations[i] = [Ai, Bi] and values[i] means that
    Ai / Bi = values[i]. Determine if there exists a contradiction in the
    equations. Return true if there is a contradiction, or false otherwise.

    Note:
    * When checking if two numbers are equal, check that their absolute
      difference is less than 10-5.
    * The testcases are generated such that there are no cases targeting
      precision, i.e. using double is enough to solve the problem.

    Example 1:
    Input: equations = [["a","b"],["b","c"],["a","c"]], values = [3,0.5,1.5]
    Output: false
    Explanation: The given equations are: a / b = 3, b / c = 0.5, a / c = 1.5
                 There are no contradictions in the equations. One possible
                 assignment to satisfy all equations is: a = 3, b = 1 and c = 2.

    Example 2:
    Input: equations = [["le","et"],["le","code"],["code","et"]], values = [2,5,0.5]
    Output: true
    Explanation: The given equations are: le / et = 2, le / code = 5,
                 code / et = 0.5 Based on the first two equations, we get
                 code / et = 0.4. Since the third equation is
                 code / et = 0.5, we get a contradiction.

    Constraints:
    * 1 <= equations.length <= 100
    * equations[i].length == 2
    * 1 <= Ai.length, Bi.length <= 5
    * Ai, Bi consist of lowercase English letters.
    * equations.length == values.length
    * 0.0 < values[i] <= 10.0
    * values[i] has a maximum of 2 decimal places.*/

    bool checkContradictions(vector<vector<string>>& equations, vector<double>& values) {
        unordered_set<string> node;
        unordered_map<string, vector<pair<string, double>>> graph;
        for (int i = 0; i < equations.size(); ++i) {
            string u = equations[i][0], v = equations[i][1];
            node.insert(u);
            node.insert(v);
            graph[u].emplace_back(v, values[i]);
            graph[v].emplace_back(u, 1/values[i]);
        }
        unordered_map<string, double> vals;
        for (auto& u : node)
            if (!vals.count(u)) {
                stack<string> stk; stk.push(u);
                vals[u] = 1;
                while (stk.size()) {
                    auto u = stk.top(); stk.pop();
                    for (auto [v, w] : graph[u])
                        if (vals.count(v)) {
                            if (abs(vals[v] - vals[u]/w) > 1e-5*vals[v]) return true;
                        } else {
                            stk.push(v);
                            vals[v] = vals[u]/w;
                        }
                }
            }
        return false;
    }


    /*2313. Minimum Flips in Binary Tree to Get Result (Hard)
    You are given the root of a binary tree with the following properties:
    * Leaf nodes have either the value 0 or 1, representing false and true
      respectively.
    * Non-leaf nodes have either the value 2, 3, 4, or 5, representing the
      boolean operations OR, AND, XOR, and NOT, respectively.
    You are also given a boolean result, which is the desired result of the
    evaluation of the root node. The evaluation of a node is as follows:
    * If the node is a leaf node, the evaluation is the value of the node, i.e.
      true or false.
    * Otherwise, evaluate the node's children and apply the boolean operation
      of its value with the children's evaluations.
    In one operation, you can flip a leaf node, which causes a false node to
    become true, and a true node to become false. Return the minimum number of
    operations that need to be performed such that the evaluation of root
    yields result. It can be shown that there is always a way to achieve result.
    A leaf node is a node that has zero children.

    Note: NOT nodes have either a left child or a right child, but other non-
          leaf nodes have both a left child and a right child.

    Example 1:
    Input: root = [3,5,4,2,null,1,1,1,0], result = true
    Output: 2
    Explanation: It can be shown that a minimum of 2 nodes have to be flipped
                 to make the root of the tree evaluate to true. One way to
                 achieve this is shown in the diagram above.

    Example 2:
    Input: root = [0], result = false
    Output: 0
    Explanation: The root of the tree already evaluates to false, so 0 nodes
                 have to be flipped.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 0 <= Node.val <= 5
    * OR, AND, and XOR nodes have 2 children.
    * NOT nodes have 1 child.
    * Leaf nodes have a value of 0 or 1.
    * Non-leaf nodes have a value of 2, 3, 4, or 5.

    int minimumFlips(TreeNode* root, bool result) {

        function<pair<int, int>(TreeNode*)> fn = [&](TreeNode* node) {
            if (node->val == 0) return make_pair(0, 1);
            if (node->val == 1) return make_pair(1, 0);
            int lt = -1, lf = -1, rt = -1, rf = -1;
            if (node->left) tie(lf, lt) = fn(node->left);
            if (node->right) tie(rf, rt) = fn(node->right);
            switch (node->val) {
                case 2: return make_pair(lf+rf, min(lt, rt));
                case 3: return make_pair(min(lf, rf), lt+rt);
                case 4: return make_pair(min(lf+rf, lt+rt), min(lf+rt, lt+rf));
                default: return node->left ? make_pair(lt, lf) : make_pair(rt, rf);
            }
        };

        return result ? fn(root).second : fn(root).first;
    }


    /*2323. Find Minimum Time to Finish All Jobs II (Medium)
    You are given two 0-indexed integer arrays jobs and workers of equal length,
    where jobs[i] is the amount of time needed to complete the ith job, and
    workers[j] is the amount of time the jth worker can work each day. Each job
    should be assigned to exactly one worker, such that each worker completes
    exactly one job. Return the minimum number of days needed to complete all
    the jobs after assignment.

    Example 1:
    Input: jobs = [5,2,4], workers = [1,7,5]
    Output: 2
    Explanation: - Assign the 2nd worker to the 0th job. It takes them 1 day to
                   finish the job.
                 - Assign the 0th worker to the 1st job. It takes them 2 days
                   to finish the job.
                 - Assign the 1st worker to the 2nd job. It takes them 1 day to
                   finish the job.
                 It takes 2 days for all the jobs to be completed, so return 2.
                 It can be proven that 2 days is the minimum number of days needed.

    Example 2:
    Input: jobs = [3,18,15,9], workers = [6,5,1,3]
    Output: 3
    Explanation: - Assign the 2nd worker to the 0th job. It takes them 3 days
                   to finish the job.
                 - Assign the 0th worker to the 1st job. It takes them 3 days
                   to finish the job.
                 - Assign the 1st worker to the 2nd job. It takes them 3 days
                   to finish the job.
                 - Assign the 3rd worker to the 3rd job. It takes them 3 days
                   to finish the job.
                 It takes 3 days for all the jobs to be completed, so return 3.
                 It can be proven that 3 days is the minimum number of days
                 needed.

    Constraints:
    * n == jobs.length == workers.length
    * 1 <= n <= 10^5
    * 1 <= jobs[i], workers[i] <= 10^5*/

    int minimumTime(vector<int>& jobs, vector<int>& workers) {
        sort(jobs.begin(), jobs.end());
        sort(workers.begin(), workers.end());
        int ans = 0;
        for (int i = 0; i < jobs.size(); ++i)
            ans = max(ans, (jobs[i] + workers[i] - 1)/workers[i]);
        return ans;
    }


    /*2326. Spiral Matrix IV (Medium)
    You are given two integers m and n, which represent the dimensions of a
    matrix. You are also given the head of a linked list of integers. Generate
    an m x n matrix that contains the integers in the linked list presented in
    spiral order (clockwise), starting from the top-left of the matrix. If there
    are remaining empty spaces, fill them with -1. Return the generated matrix.

    Example 1:
    Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
    Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
    Explanation: The diagram above shows how the values are printed in the
                 matrix. Note that the remaining spaces in the matrix are filled
                 with -1.

    Example 2:
    Input: m = 1, n = 4, head = [0,1,2]
    Output: [[0,1,2,-1]]
    Explanation: The diagram above shows how the values are printed from left to
                 right in the matrix. The last space in the matrix is set to -1.

    Constraints:
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * The number of nodes in the list is in the range [1, m * n].
    * 0 <= Node.val <= 1000*/

    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {
        vector<vector<int>> ans(m, vector<int>(n, -1));
        ListNode *node = head;
        for (int i = 0, j = 0, di = 0, dj = 1; node; i += di, j += dj, node = node->next) {
            ans[i][j] = node->val;
            if (!(0 <= i+di && i+di < m && 0 <= j+dj && j+dj < n && ans[i+di][j+dj] == -1)) {
                swap(di, dj);
                dj *= -1;
            }
        }
        return ans;
    }


    /*2330. Valid Palindrome IV (Medium)
    You are given a 0-indexed string s consisting of only lowercase English
    letters. In one operation, you can change any character of s to any other
    character. Return true if you can make s a palindrome after performing
    exactly one or two operations, or return false otherwise.

    Example 1:
    Input: s = "abcdba"
    Output: true
    Explanation: One way to make s a palindrome using 1 operation is:
                 - Change s[2] to 'd'. Now, s = "abddba".
                 One operation could be performed to make s a palindrome so
                 return true.

    Example 2:
    Input: s = "aa"
    Output: true
    Explanation: One way to make s a palindrome using 2 operations is:
                 - Change s[0] to 'b'. Now, s = "ba".
                 - Change s[1] to 'b'. Now, s = "bb".
                 Two operations could be performed to make s a palindrome so
                 return true.

    Example 3:
    Input: s = "abcdef"
    Output: false
    Explanation: It is not possible to make s a palindrome using one or two
                 operations so return false.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters.*/

    bool makePalindrome(string s) {
        int count = 0;
        for (int i = 0, n = s.size(); i < n/2; ++i)
            if (s[i] != s[n-1-i]) ++count;
        return count <= 2;
    }


    /*2331. Evaluate Boolean Binary Tree (Easy)
    You are given the root of a full binary tree with the following properties:
    * Leaf nodes have either the value 0 or 1, where 0 represents False and 1
      represents True.
    * Non-leaf nodes have either the value 2 or 3, where 2 represents the
      boolean OR and 3 represents the boolean AND.
    The evaluation of a node is as follows:
    * If the node is a leaf node, the evaluation is the value of the node, i.e.
      True or False.
    * Otherwise, evaluate the node's two children and apply the boolean
      operation of its value with the children's evaluations.
    Return the boolean result of evaluating the root node. A full binary tree is
    a binary tree where each node has either 0 or 2 children. A leaf node is a
    node that has zero children.

    Example 1:
    Input: root = [2,1,3,null,null,0,1]
    Output: true
    Explanation: The above diagram illustrates the evaluation process.
                 The AND node evaluates to False AND True = False.
                 The OR node evaluates to True OR False = True.
                 The root node evaluates to True, so we return true.

    Example 2:
    Input: root = [0]
    Output: false
    Explanation: The root node is a leaf node and it evaluates to false, so we
                 return false.

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * 0 <= Node.val <= 3
    * Every node has either 0 or 2 children.
    * Leaf nodes have a value of 0 or 1.
    * Non-leaf nodes have a value of 2 or 3.*/

    bool evaluateTree(TreeNode* root) {
        unordered_map<TreeNode*, bool> mp;
        stack<TreeNode*> stk;
        TreeNode *prev = nullptr, *node = root;
        while (node || stk.size()) {
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top();
                if (node->right && node->right != prev) node = node->right;
                else {
                    if (!node->left && !node->right) mp[node] = node->val != 0;
                    else if (node->val == 2) mp[node] = mp[node->left] || mp[node->right];
                    else mp[node] = mp[node->left] && mp[node->right];
                    stk.pop();
                    prev = node;
                    node = nullptr;
                }
            }
        }
        return mp[root];
    }


    /*2340. Minimum Adjacent Swaps to Make a Valid Array (Medium)
    You are given a 0-indexed integer array nums. Swaps of adjacent elements
    are able to be performed on nums. A valid array meets the following
    conditions:
    * The largest element (any of the largest elements if there are multiple)
      is at the rightmost position in the array.
    * The smallest element (any of the smallest elements if there are multiple)
      is at the leftmost position in the array.
    Return the minimum swaps required to make nums a valid array.

    Example 1:
    Input: nums = [3,4,5,5,3,1]
    Output: 6
    Explanation: Perform the following swaps:
                 - Swap 1: Swap the 3rd and 4th elements, nums is then
                   [3,4,5,3,5,1].
                 - Swap 2: Swap the 4th and 5th elements, nums is then
                   [3,4,5,3,1,5].
                 - Swap 3: Swap the 3rd and 4th elements, nums is then
                   [3,4,5,1,3,5].
                 - Swap 4: Swap the 2nd and 3rd elements, nums is then
                   [3,4,1,5,3,5].
                 - Swap 5: Swap the 1st and 2nd elements, nums is then
                   [3,1,4,5,3,5].
                 - Swap 6: Swap the 0th and 1st elements, nums is then
                   [1,3,4,5,3,5].
                 It can be shown that 6 swaps is the minimum swaps required to
                 make a valid array.

    Example 2:
    Input: nums = [9]
    Output: 0
    Explanation: The array is already valid, so we return 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    int minimumSwaps(vector<int>& nums) {
        int imin = 0, imax = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] < nums[imin]) imin = i;
            if (nums[i] >= nums[imax]) imax = i;
        }
        return imin + nums.size() - imax - 1 - (imax < imin);
    }


    /*2345. Finding the Number of Visible Mountains (Medium)
    You are given a 0-indexed 2D integer array peaks where peaks[i] = [xi, yi]
    states that mountain i has a peak at coordinates (xi, yi). A mountain can
    be described as a right-angled isosceles triangle, with its base along the
    x-axis and a right angle at its peak. More formally, the gradients of
    ascending and descending the mountain are 1 and -1 respectively. A mountain
    is considered visible if its peak does not lie within another mountain
    (including the border of other mountains). Return the number of visible
    mountains.

    Example 1:
    Input: peaks = [[2,2],[6,3],[5,4]]
    Output: 2
    Explanation: The diagram above shows the mountains.
                 - Mountain 0 is visible since its peak does not lie within
                   another mountain or its sides.
                 - Mountain 1 is not visible since its peak lies within the
                   side of mountain 2.
                 - Mountain 2 is visible since its peak does not lie within
                   another mountain or its sides.
                 There are 2 mountains that are visible.

    Example 2:
    Input: peaks = [[1,3],[1,3]]
    Output: 0
    Explanation: The diagram above shows the mountains (they completely overlap).
                 Both mountains are not visible since their peaks lie within
                 each other.

    Constraints:
    * 1 <= peaks.length <= 10^5
    * peaks[i].length == 2
    * 1 <= xi, yi <= 10^5*/

    int visibleMountains(vector<vector<int>>& peaks) {
        sort(peaks.begin(), peaks.end(), [&](auto& lhs, auto& rhs) {
            return lhs[0]-lhs[1] < rhs[0]-rhs[1] || (lhs[0]-lhs[1] == rhs[0]-rhs[1] && lhs[0]+lhs[1] > rhs[0]+rhs[1]);
        });
        int ans = 0, right = INT_MIN;
        for (int i = 0, n = peaks.size(); i < n; ++i) {
            int hi = peaks[i][0] + peaks[i][1];
            if (right < hi && (i+1 == n || peaks[i] != peaks[i+1])) ++ans;
            right = max(right, hi);
        }
        return ans;
    }


    /*2347. Best Poker Hand (Easy)
    You are given an integer array ranks and a character array suits. You have
    5 cards where the ith card has a rank of ranks[i] and a suit of suits[i].
    The following are the types of poker hands you can make from best to worst:
    * "Flush": Five cards of the same suit.
    * "Three of a Kind": Three cards of the same rank.
    * "Pair": Two cards of the same rank.
    * "High Card": Any single card.
    Return a string representing the best type of poker hand you can make with
    the given cards. Note that the return values are case-sensitive.

    Example 1:
    Input: ranks = [13,2,3,1,9], suits = ["a","a","a","a","a"]
    Output: "Flush"
    Explanation: The hand with all the cards consists of 5 cards with the same
                 suit, so we have a "Flush".

    Example 2:
    Input: ranks = [4,4,2,4,4], suits = ["d","a","a","b","c"]
    Output: "Three of a Kind"
    Explanation: The hand with the first, second, and fourth card consists of 3
                 cards with the same rank, so we have a "Three of a Kind". Note
                 that we could also make a "Pair" hand but "Three of a Kind" is
                 a better hand. Also note that other cards could be used to
                 make the "Three of a Kind" hand.

    Example 3:
    Input: ranks = [10,10,2,12,9], suits = ["a","b","c","a","d"]
    Output: "Pair"
    Explanation: The hand with the first and second card consists of 2 cards
                 with the same rank, so we have a "Pair". Note that we cannot
                 make a "Flush" or a "Three of a Kind".

    Constraints:
    * ranks.length == suits.length == 5
    * 1 <= ranks[i] <= 13
    * 'a' <= suits[i] <= 'd'
    * No two cards have the same rank and suit.*/

    string bestHand(vector<int>& ranks, vector<char>& suits) {
        if (*max_element(suits.begin(), suits.end()) == *min_element(suits.begin(), suits.end())) return "Flush";
        unordered_map<int, int> freq;
        for (auto& x : ranks) ++freq[x];
        auto p = max_element(freq.begin(), freq.end(), [](const auto& lhs, const auto& rhs) {return lhs.second < rhs.second;});
        if (p->second >= 3) return "Three of a Kind";
        else if (p->second == 2) return "Pair";
        return "High Card";
    }


    /*2348. Number of Zero-Filled Subarrays (Medium)
    Given an integer array nums, return the number of subarrays filled with 0.
    A subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,3,0,0,2,0,0,4]
    Output: 6
    Explanation: There are 4 occurrences of [0] as a subarray. There are 2
                 occurrences of [0,0] as a subarray. There is no occurrence of
                 a subarray with a size more than 2 filled with 0. Therefore,
                 we return 6.

    Example 2:
    Input: nums = [0,0,0,2,0,0]
    Output: 9
    Explanation: There are 5 occurrences of [0] as a subarray. There are 3
                 occurrences of [0,0] as a subarray. There is 1 occurrence of
                 [0,0,0] as a subarray. There is no occurrence of a subarray
                 with a size more than 3 filled with 0. Therefore, we return 9.

    Example 3:
    Input: nums = [2,10,2019]
    Output: 0
    Explanation: There is no subarray filled with 0. Therefore, we return 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    long long zeroFilledSubarray(vector<int>& nums) {
        long long ans = 0, cnt = 0;
        for (auto& x : nums) {
            if (x) cnt = 0;
            else ++cnt;
            ans += cnt;
        }
        return ans;
    }


    /*2355. Maximum Number of Books You Can Take (Hard)
    You are given a 0-indexed integer array books of length n where books[i]
    denotes the number of books on the ith shelf of a bookshelf. You are going
    to take books from a contiguous section of the bookshelf spanning from l to
    r where 0 <= l <= r < n. For each index i in the range l <= i < r, you must
    take strictly fewer books from shelf i than shelf i + 1. Return the maximum
    number of books you can take from the bookshelf.

    Example 1:
    Input: books = [8,5,2,7,9]
    Output: 19
    Explanation: - Take 1 book from shelf 1.
                 - Take 2 books from shelf 2.
                 - Take 7 books from shelf 3.
                 - Take 9 books from shelf 4.
                 You have taken 19 books, so return 19. It can be proven that
                 19 is the maximum number of books you can take.

    Example 2:
    Input: books = [7,0,3,4,5]
    Output: 12
    Explanation: - Take 3 books from shelf 2.
                 - Take 4 books from shelf 3.
                 - Take 5 books from shelf 4.
                 You have taken 12 books so return 12. It can be proven that 12
                 is the maximum number of books you can take.

    Example 3:
    Input: books = [8,2,3,7,3,4,0,1,4,3]
    Output: 13
    Explanation: - Take 1 book from shelf 0.
                 - Take 2 books from shelf 1.
                 - Take 3 books from shelf 2.
                 - Take 7 books from shelf 3.
                 You have taken 13 books so return 13. It can be proven that 13
                 is the maximum number of books you can take.

    Constraints:
    * 1 <= books.length <= 10^5
    * 0 <= books[i] <= 10^5*/

    long long maximumBooks(vector<int>& books) {
        int n = books.size();
        vector<long long> dp(n);
        stack<int> stk;
        for (int i = 0; i < n; ++i) {
            while (stk.size() && stk.top()-books[stk.top()] <= i - books[i]) stk.pop();
            int ii = max(i-books[i], stk.size() ? stk.top() : -1);
            dp[i] = (i-ii)*(2*(long long)books[i]-i+ii+1)/2;
            if (stk.size() && ii == stk.top()) dp[i] += dp[ii];
            stk.push(i);
        }
        return *max_element(dp.begin(), dp.end());
    }


    /*2359. Find Closest Node to Given Two Nodes (Medium)
    You are given a directed graph of n nodes numbered from 0 to n - 1, where
    each node has at most one outgoing edge. The graph is represented with a
    given 0-indexed array edges of size n, indicating that there is a directed
    edge from node i to node edges[i]. If there is no outgoing edge from i,
    then edges[i] == -1. You are also given two integers node1 and node2.
    Return the index of the node that can be reached from both node1 and node2,
    such that the maximum between the distance from node1 to that node, and
    from node2 to that node is minimized. If there are multiple answers, return
    the node with the smallest index, and if no possible answer exists, return
    -1. Note that edges may contain cycles.

    Example 1:
    Input: edges = [2,2,3,-1], node1 = 0, node2 = 1
    Output: 2
    Explanation: The distance from node 0 to node 2 is 1, and the distance from
                 node 1 to node 2 is 1. The maximum of those two distances is 1.
                 It can be proven that we cannot get a node with a smaller
                 maximum distance than 1, so we return node 2.

    Example 2:
    Input: edges = [1,2,-1], node1 = 0, node2 = 2
    Output: 2
    Explanation: The distance from node 0 to node 2 is 2, and the distance from
                 node 2 to itself is 0. The maximum of those two distances is 2.
                 It can be proven that we cannot get a node with a smaller
                 maximum distance than 2, so we return node 2.

    Constraints:
    * n == edges.length
    * 2 <= n <= 10^5
    * -1 <= edges[i] < n
    * edges[i] != i
    * 0 <= node1, node2 < n*/

    int closestMeetingNode(vector<int>& edges, int node1, int node2) {
        int n = edges.size();

        auto bfs = [&](int u) {
            vector<int> dist(n, INT_MAX);
            for (int k = 0; u != -1 && dist[u] == INT_MAX; ++k, u = edges[u])
                dist[u] = k;
            return dist;
        };

        int ans = -1, small = INT_MAX;
        vector<int> dist1 = bfs(node1), dist2 = bfs(node2);
        for (int i = 0; i < n; ++i) {
            int cand = max(dist1[i], dist2[i]);
            if (cand < small) {
                ans = i;
                small = cand;
            }
        }
        return ans;
    }


    /*2361. Minimum Costs Using the Train Line (Hard)
    A train line going through a city has two routes, the regular route and the
    express route. Both routes go through the same n + 1 stops labeled from 0
    to n. Initially, you start on the regular route at stop 0. You are given
    two 1-indexed integer arrays regular and express, both of length n.
    regular[i] describes the cost it takes to go from stop i - 1 to stop i
    using the regular route, and express[i] describes the cost it takes to go
    from stop i - 1 to stop i using the express route. You are also given an
    integer expressCost which represents the cost to transfer from the regular
    route to the express route.

    Note that:
    * There is no cost to transfer from the express route back to the regular
      route.
    * You pay expressCost every time you transfer from the regular route to the
      express route.
    * There is no extra cost to stay on the express route.
    Return a 1-indexed array costs of length n, where costs[i] is the minimum
    cost to reach stop i from stop 0. Note that a stop can be counted as
    reached from either route.

    Example 1:
    Input: regular = [1,6,9,5], express = [5,2,3,10], expressCost = 8
    Output: [1,7,14,19]
    Explanation: The diagram above shows how to reach stop 4 from stop 0 with
                 minimum cost.
                 - Take the regular route from stop 0 to stop 1, costing 1.
                 - Take the express route from stop 1 to stop 2, costing 8 + 2 = 10.
                 - Take the express route from stop 2 to stop 3, costing 3.
                 - Take the regular route from stop 3 to stop 4, costing 5.
                 The total cost is 1 + 10 + 3 + 5 = 19. Note that a different
                 route could be taken to reach the other stops with minimum
                 cost.

    Example 2:
    Input: regular = [11,5,13], express = [7,10,6], expressCost = 3
    Output: [10,15,24]
    Explanation: The diagram above shows how to reach stop 3 from stop 0 with
                 minimum cost.
                 - Take the express route from stop 0 to stop 1, costing 3 + 7 = 10.
                 - Take the regular route from stop 1 to stop 2, costing 5.
                 - Take the express route from stop 2 to stop 3, costing 3 + 6 = 9.
                 The total cost is 10 + 5 + 9 = 24. Note that the expressCost
                 is paid again to transfer back to the express route.

    Constraints:
    * n == regular.length == express.length
    * 1 <= n <= 10^5
    * 1 <= regular[i], express[i], expressCost <= 10^5*/

    vector<long long> minimumCosts(vector<int>& regular, vector<int>& express, int expressCost) {
        vector<long long> ans;
        long long cr = 0, ce = expressCost;
        for (int i = 0; i < regular.size(); ++i) {
            tie(cr, ce) = make_tuple(min(cr+regular[i], ce+express[i]), min(cr+regular[i]+expressCost, ce+express[i]));
            ans.push_back(min(cr, ce));
        }
        return ans;
    }


    /*2370. Longest Ideal Subsequence (Medium)
    You are given a string s consisting of lowercase letters and an integer k.
    We call a string t ideal if the following conditions are satisfied:
    * t is a subsequence of the string s.
    * The absolute difference in the alphabet order of every two adjacent
      letters in t is less than or equal to k.
    Return the length of the longest ideal string. A subsequence is a string
    that can be derived from another string by deleting some or no characters
    without changing the order of the remaining characters. Note that the
    alphabet order is not cyclic. For example, the absolute difference in the
    alphabet order of 'a' and 'z' is 25, not 1.

    Example 1:
    Input: s = "acfgbd", k = 2
    Output: 4
    Explanation: The longest ideal string is "acbd". The length of this string
                 is 4, so 4 is returned. Note that "acfgbd" is not ideal because
                 'c' and 'f' have a difference of 3 in alphabet order.

    Example 2:
    Input: s = "abcd", k = 3
    Output: 4
    Explanation: The longest ideal string is "abcd". The length of this string
                 is 4, so 4 is returned.

    Constraints:
    * 1 <= s.length <= 10^5
    * 0 <= k <= 25
    * s consists of lowercase English letters.*/

    int longestIdealString(string s, int k) {
        vector<int> dp(26);
        for (auto& ch : s) {
            int x = ch - 'a', lo = max(0, x-k), hi = min(26, x+k+1);
            dp[x] = 1 + *max_element(dp.begin()+lo, dp.begin()+hi);
        }
        return *max_element(dp.begin(), dp.end());
    }


    /*2371. Minimize Maximum Value in a Grid (Hard)
    You are given an m x n integer matrix grid containing distinct positive
    integers. You have to replace each integer in the matrix with a positive
    integer satisfying the following conditions:
    * The relative order of every two elements that are in the same row or
      column should stay the same after the replacements.
    * The maximum number in the matrix after the replacements should be as
      small as possible.
    The relative order stays the same if for all pairs of elements in the
    original matrix such that grid[r1][c1] > grid[r2][c2] where either r1 == r2
    or c1 == c2, then it must be true that grid[r1][c1] > grid[r2][c2] after
    the replacements. For example, if grid = [[2, 4, 5], [7, 3, 9]] then a good
    replacement could be either grid = [[1, 2, 3], [2, 1, 4]] or
    grid = [[1, 2, 3], [3, 1, 4]]. Return the resulting matrix. If there are
    multiple answers, return any of them.

    Example 1:
    Input: grid = [[3,1],[2,5]]
    Output: [[2,1],[1,2]]
    Explanation: The above diagram shows a valid replacement. The maximum
                 number in the matrix is 2. It can be shown that no smaller
                 value can be obtained.

    Example 2:
    Input: grid = [[10]]
    Output: [[1]]
    Explanation: We replace the only number in the matrix with 1.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 1000
    * 1 <= m * n <= 10^5
    * 1 <= grid[i][j] <= 10^9
    * grid consists of distinct integers.*/

    vector<vector<int>> minScore(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<tuple<int, int, int>> vals;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                vals.emplace_back(grid[i][j], i, j);
        sort(vals.begin(), vals.end());
        vector<int> row(m), col(n);
        vector<vector<int>> ans(m, vector<int>(n));
        for (auto& [_, i, j] : vals)
            ans[i][j] = row[i] = col[j] = max(row[i], col[j]) + 1;
        return ans;
    }


    /*2378. Choose Edges to Maximize Score in a Tree (Medium)
    You are given a weighted tree consisting of n nodes numbered from 0 to
    n - 1. The tree is rooted at node 0 and represented with a 2D array edges
    of size n where edges[i] = [pari, weighti] indicates that node pari is the
    parent of node i, and the edge between them has a weight equal to weighti.
    Since the root does not have a parent, you have edges[0] = [-1, -1]. Choose
    some edges from the tree such that no two chosen edges are adjacent and the
    sum of the weights of the chosen edges is maximized. Return the maximum sum
    of the chosen edges.

    Note:
    * You are allowed to not choose any edges in the tree, the sum of weights
      in this case will be 0.
    * Two edges Edge1 and Edge2 in the tree are adjacent if they have a common
      node.
      + In other words, they are adjacent if Edge1 connects nodes a and b and
        Edge2 connects nodes b and c.

    Example 1:
    Input: edges = [[-1,-1],[0,5],[0,10],[2,6],[2,4]]
    Output: 11
    Explanation: The above diagram shows the edges that we have to choose
                 colored in red. The total score is 5 + 6 = 11. It can be shown
                 that no better score can be obtained.

    Example 2:
    Input: edges = [[-1,-1],[0,5],[0,-6],[0,7]]
    Output: 7
    Explanation: We choose the edge with weight 7. Note that we cannot choose
                 more than one edge because all edges are adjacent to each
                 other.

    Constraints:
    * n == edges.length
    * 1 <= n <= 10^5
    * edges[i].length == 2
    * par0 == weight0 == -1
    * 0 <= pari <= n - 1 for all i >= 1.
    * pari != i
    * -10^6 <= weighti <= 10^6 for all i >= 1.
    * edges represents a valid tree.*/

    long long maxScore(vector<vector<int>>& edges) {
        int n = edges.size();
        vector<vector<pair<int, int>>> tree(n);
        for (int i = 1; i < n; ++i)
            tree[edges[i][0]].emplace_back(i, edges[i][1]);

        function<pair<long long, long long>(int)> dfs = [&](int u) {
            long long sm = 0, delta = 0;
            for (auto& [v, w] : tree[u]) {
                auto [ss, dd] = dfs(v);
                sm += ss + dd;
                delta = max(delta, w - dd);
            }
            return make_pair(sm, delta);
        };

        auto [s, d] = dfs(0);
        return s + d;
    }


    /*2387. Median of a Row Wise Sorted Matrix (Medium)
    Given an m x n matrix grid containing an odd number of integers where each
    row is sorted in non-decreasing order, return the median of the matrix.
    You must solve the problem in less than O(m * n) time complexity.

    Example 1:
    Input: grid = [[1,1,2],[2,3,3],[1,3,4]]
    Output: 2
    Explanation: The elements of the matrix in sorted order are
                 1,1,1,2,2,3,3,3,4. The median is 2.

    Example 2:
    Input: grid = [[1,1,3,3,4]]
    Output: 3
    Explanation: The elements of the matrix in sorted order are 1,1,3,3,4. The
                 median is 3.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 500
    * m and n are both odd.
    * 1 <= grid[i][j] <= 10^6
    * grid[i] is sorted in non-decreasing order.*/

    int matrixMedian(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(), lo = INT_MAX, hi = INT_MIN;
        for (auto& row : grid) {
            lo = min(lo, row[0]);
            hi = max(hi, row[n-1]);
        }
        while (lo < hi) {
            int mid = lo + (hi-lo)/2, more = 0;
            for (auto& row : grid)
                more += row.end() - upper_bound(row.begin(), row.end(), mid);
            if (more > m*n/2) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*2392. Build a Matrix With Conditions (Hard)
    You are given a positive integer k. You are also given:
    * a 2D integer array rowConditions of size n where
      rowConditions[i] = [abovei, belowi], and
    * a 2D integer array colConditions of size m where
      colConditions[i] = [lefti, righti].
    The two arrays contain integers from 1 to k. You have to build a k x k
    matrix that contains each of the numbers from 1 to k exactly once. The
    remaining cells should have the value 0. The matrix should also satisfy the
    following conditions:
    * The number abovei should appear in a row that is strictly above the row at
      which the number belowi appears for all i from 0 to n - 1.
    * The number lefti should appear in a column that is strictly left of the
      column at which the number righti appears for all i from 0 to m - 1.
    Return any matrix that satisfies the conditions. If no answer exists, return
    an empty matrix.

    Example 1:
    Input: k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]
    Output: [[3,0,0],[0,0,1],[0,2,0]]
    Explanation: The diagram above shows a valid example of a matrix that
                 satisfies all the conditions.
                 The row conditions are the following:
                 - Number 1 is in row 1, and number 2 is in row 2, so 1 is above
                   2 in the matrix.
                 - Number 3 is in row 0, and number 2 is in row 2, so 3 is above
                   2 in the matrix.
                 The column conditions are the following:
                 - Number 2 is in column 1, and number 1 is in column 2, so 2 is
                   left of 1 in the matrix.
                 - Number 3 is in column 0, and number 2 is in column 1, so 3 is
                   left of 2 in the matrix.
                 Note that there may be multiple correct answers.

    Example 2:
    Input: k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]
    Output: []
    Explanation: From the first two conditions, 3 has to be below 1 but the
                 third conditions needs 3 to be above 1 to be satisfied. No
                 matrix can satisfy all the conditions, so we return the empty
                 matrix.

    Constraints:
    * 2 <= k <= 400
    * 1 <= rowConditions.length, colConditions.length <= 10^4
    * rowConditions[i].length == colConditions[i].length == 2
    * 1 <= abovei, belowi, lefti, righti <= k
    * abovei != belowi
    * lefti != righti*/

    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& aboveConditions, vector<vector<int>>& leftConditions) {

        auto fn = [&](vector<vector<int>>& edges) {
            vector<vector<int>> graph(k);
            vector<int> degree(k);
            for (auto& e : edges) {
                graph[e[0]-1].push_back(e[1]-1);
                ++degree[e[1]-1];
            }
            queue<int> q;
            vector<int> ans;
            for (int u = 0; u < k; ++u)
                if (degree[u] == 0) q.push(u);
            while (q.size()) {
                int u = q.front(); q.pop();
                ans.push_back(u);
                for (auto& v : graph[u])
                    if (--degree[v] == 0) q.push(v);
            }
            return ans;
        };

        vector<int> row = fn(aboveConditions), col = fn(leftConditions);
        if (row.size() < k || col.size() < k) return vector<vector<int>>();
        vector<int> rmap(k), cmap(k);
        for (int i = 0; i < k; ++i)
            rmap[row[i]] = cmap[col[i]] = i;
        vector<vector<int>> ans(k, vector<int>(k));
        for (int x = 0; x < k; ++x)
            ans[rmap[x]][cmap[x]] = x+1;
        return ans;
    }


    /*2393. Count Strictly Increasing Subarrays (Medium)
    You are given an array nums consisting of positive integers. Return the
    number of subarrays of nums that are in strictly increasing order. A
    subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1,3,5,4,4,6]
    Output: 10
    Explanation: The strictly increasing subarrays are the following:
                 - Subarrays of length 1: [1], [3], [5], [4], [4], [6].
                 - Subarrays of length 2: [1,3], [3,5], [4,6].
                 - Subarrays of length 3: [1,3,5].
                 The total number of subarrays is 6 + 3 + 1 = 10.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: 15
    Explanation: Every subarray is strictly increasing. There are 15 possible
                 subarrays that we can take.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    long long countSubarrays(vector<int>& nums) {
        long long ans = 0;
        for (int i = 0, cnt = 0; i < nums.size(); ++i) {
            if (i && nums[i-1] >= nums[i]) cnt = 0;
            ans += ++cnt;
        }
        return ans;
    }


    /*2403. Minimum Time to Kill All Monsters (Hard)
    You are given an integer array power where power[i] is the power of the ith
    monster. You start with 0 mana points, and each day you increase your mana
    points by gain where gain initially is equal to 1. Each day, after gaining
    gain mana, you can defeat a monster if your mana points are greater than or
    equal to the power of that monster. When you defeat a monster:
    * your mana points will be reset to 0, and
    * the value of gain increases by 1.
    Return the minimum number of days needed to defeat all the monsters.

    Example 1:
    Input: power = [3,1,4]
    Output: 4
    Explanation: The optimal way to beat all the monsters is to:
                 - Day 1: Gain 1 mana point to get a total of 1 mana point.
                   Spend all mana points to kill the 2nd monster.
                 - Day 2: Gain 2 mana points to get a total of 2 mana points.
                 - Day 3: Gain 2 mana points to get a total of 4 mana points.
                   Spend all mana points to kill the 3rd monster.
                 - Day 4: Gain 3 mana points to get a total of 3 mana points.
                   Spend all mana points to kill the 1st monster.
                 It can be proven that 4 is the minimum number of days needed.

    Example 2:
    Input: power = [1,1,4]
    Output: 4
    Explanation: The optimal way to beat all the monsters is to:
                 - Day 1: Gain 1 mana point to get a total of 1 mana point.
                   Spend all mana points to kill the 1st monster.
                 - Day 2: Gain 2 mana points to get a total of 2 mana points.
                   Spend all mana points to kill the 2nd monster.
                 - Day 3: Gain 3 mana points to get a total of 3 mana points.
                 - Day 4: Gain 3 mana points to get a total of 6 mana points.
                   Spend all mana points to kill the 3rd monster.
                 It can be proven that 4 is the minimum number of days needed.

    Example 3:
    Input: power = [1,2,4,9]
    Output: 6
    Explanation: The optimal way to beat all the monsters is to:
                 - Day 1: Gain 1 mana point to get a total of 1 mana point.
                   Spend all mana points to kill the 1st monster.
                 - Day 2: Gain 2 mana points to get a total of 2 mana points.
                   Spend all mana points to kill the 2nd monster.
                 - Day 3: Gain 3 mana points to get a total of 3 mana points.
                 - Day 4: Gain 3 mana points to get a total of 6 mana points.
                 - Day 5: Gain 3 mana points to get a total of 9 mana points.
                   Spend all mana points to kill the 4th monster.
                 - Day 6: Gain 4 mana points to get a total of 4 mana points.
                   Spend all mana points to kill the 3rd monster.
                 It can be proven that 6 is the minimum number of days needed.

    Constraints:
    * 1 <= power.length <= 17
    * 1 <= power[i] <= 10^9*/

    long long minimumTime(vector<int>& power) {
        int n = power.size();
        vector<long long> dp(1<<n, LONG_MAX);
        dp[0] = 0;
        for (int m = 1; m < 1<<n; ++m) {
            int gain = 1;
            for (int i = 0; i < n; ++i)
                if (!(m & 1<<i)) ++gain;
            for (int i = 0; i < n; ++i)
                if (m & 1<<i)
                    dp[m] = min(dp[m], (power[i] + gain - 1)/gain + dp[m ^ 1<<i]);
        }
        return dp.back();
    }


    /*2417. Closest Fair Integer (Medium)
    You are given a positive integer n. We call an integer k fair if the number
    of even digits in k is equal to the number of odd digits in it. Return the
    smallest fair integer that is greater than or equal to n.

    Example 1:
    Input: n = 2
    Output: 10
    Explanation: The smallest fair integer that is greater than or equal to 2
                 is 10. 10 is fair because it has an equal number of even and
                 odd digits (one odd digit and one even digit).

    Example 2:
    Input: n = 403
    Output: 1001
    Explanation: The smallest fair integer that is greater than or equal to 403
                 is 1001. 1001 is fair because it has an equal number of even
                 and odd digits (two odd digits and two even digits).

    Constraints: 1 <= n <= 10^9*/

    int closestFair(int n) {
        vector<int> freq(2);
        for (int x = n; x; x /= 10) ++freq[(x%10) & 1];
        int sz = freq[0] + freq[1];
        if (sz & 1) return stoi("1" + string((sz+1)/2, '0') + string((sz-1)/2, '1'));
        return freq[0] == freq[1]  ? n : closestFair(n+1);
    }


    /*2418. Sort the People (Easy)
    You are given an array of strings names, and an array heights that consists
    of distinct positive integers. Both arrays are of length n. For each index
    i, names[i] and heights[i] denote the name and height of the ith person.
    Return names sorted in descending order by the people's heights.

    Example 1:
    Input: names = ["Mary","John","Emma"], heights = [180,165,170]
    Output: ["Mary","Emma","John"]
    Explanation: Mary is the tallest, followed by Emma and John.

    Example 2:
    Input: names = ["Alice","Bob","Bob"], heights = [155,185,150]
    Output: ["Bob","Alice","Bob"]
    Explanation: The first Bob is the tallest, followed by Alice and the second
                 Bob.

    Constraints:
    * n == names.length == heights.length
    * 1 <= n <= 10^3
    * 1 <= names[i].length <= 20
    * 1 <= heights[i] <= 10^5
    * names[i] consists of lower and upper case English letters.
    * All the values of heights are distinct.*/

    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {
        vector<pair<int, string>> hn;
        for (int i = 0; i < names.size(); ++i)
            hn.emplace_back(heights[i], names[i]);
        sort(hn.begin(), hn.end(), greater<>());
        vector<string> ans;
        for (auto& [h, n] : hn) ans.push_back(n);
        return ans;
    }


    /*2419. Longest Subarray With Maximum Bitwise AND (Medium)
    You are given an integer array nums of size n. Consider a non-empty
    subarray from nums that has the maximum possible bitwise AND. In other
    words, let k be the maximum value of the bitwise AND of any subarray of
    nums. Then, only subarrays with a bitwise AND equal to k should be
    considered. Return the length of the longest such subarray. The bitwise AND
    of an array is the bitwise AND of all the numbers in it. A subarray is a
    contiguous sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,3,3,2,2]
    Output: 2
    Explanation: The maximum possible bitwise AND of a subarray is 3. The
                 longest subarray with that value is [3,3], so we return 2.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 1
    Explanation: The maximum possible bitwise AND of a subarray is 4. The
                 longest subarray with that value is [4], so we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    int longestSubarray(vector<int>& nums) {
        int ans = 0;
        for (int i = 0, ii = 0, most = 0; i < nums.size(); ++i) {
            for (; nums[ii] != nums[i]; ++ii);
            if (most < nums[i]) tie(most, ans) = make_tuple(nums[i], i-ii+1);
            else if (most == nums[i]) ans = max(ans, i-ii+1);
        }
        return ans;
    }


    /*2420. Find All Good Indices (Medium)
    You are given a 0-indexed integer array nums of size n and a positive
    integer k. We call an index i in the range k <= i < n - k good if the
    following conditions are satisfied:
    * The k elements that are just before the index i are in non-increasing
      order.
    * The k elements that are just after the index i are in non-decreasing
      order.
    Return an array of all good indices sorted in increasing order.

    Example 1:
    Input: nums = [2,1,1,1,3,4,1], k = 2
    Output: [2,3]
    Explanation: There are two good indices in the array:
                 - Index 2. The subarray [2,1] is in non-increasing order, and
                   the subarray [1,3] is in non-decreasing order.
                 - Index 3. The subarray [1,1] is in non-increasing order, and
                   the subarray [3,4] is in non-decreasing order.
                 Note that the index 4 is not good because [4,1] is not non-
                 decreasing.

    Example 2:
    Input: nums = [2,1,1,2], k = 2
    Output: []
    Explanation: There are no good indices in this array.

    Constraints:
    * n == nums.length
    * 3 <= n <= 10^5
    * 1 <= nums[i] <= 10^6
    * 1 <= k <= n / 2*/

    vector<int> goodIndices(vector<int>& nums, int k) {
        vector<int> prefix;
        for (int i = 0, val = 0; i < nums.size(); ++i) {
            if (i && nums[i-1] < nums[i]) val = 0;
            prefix.push_back(++val);
        }
        vector<int> ans;
        for (int n = nums.size(), i = n-1, suffix = 0; i >= k; --i, ++suffix) {
            if (prefix[i-1] >= k && suffix >= k) ans.push_back(i);
            if (i < n-1 && nums[i] > nums[i+1]) suffix = 0;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*2421. Number of Good Paths (Hard)
    There is a tree (i.e. a connected, undirected graph with no cycles)
    consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. You
    are given a 0-indexed integer array vals of length n where vals[i] denotes
    the value of the ith node. You are also given a 2D integer array edges
    where edges[i] = [ai, bi] denotes that there exists an undirected edge
    connecting nodes ai and bi. A good path is a simple path that satisfies the
    following conditions:
    * The starting node and the ending node have the same value.
    * All nodes between the starting node and the ending node have values less
      than or equal to the starting node (i.e. the starting node's value should
      be the maximum value along the path).
    Return the number of distinct good paths. Note that a path and its reverse
    are counted as the same path. For example, 0 -> 1 is considered to be the
    same as 1 -> 0. A single node is also considered as a valid path.

    Example 1:
    Input: vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
    Output: 6
    Explanation: There are 5 good paths consisting of a single node. There is 1
                 additional good path: 1 -> 0 -> 2 -> 4. (The reverse path
                 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)
                 Note that 0 -> 2 -> 3 is not a good path because
                 vals[2] > vals[0].

    Example 2:
    Input: vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
    Output: 7
    Explanation: There are 5 good paths consisting of a single node. There are
                 2 additional good paths: 0 -> 1 and 2 -> 3.

    Example 3:
    Input: vals = [1], edges = []
    Output: 1
    Explanation: The tree consists of only one node, so there is one good path.

    Constraints:
    * n == vals.length
    * 1 <= n <= 3 * 10^4
    * 0 <= vals[i] <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * edges represents a valid tree.*/

    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {
        int ans = 0, n = vals.size();
        vector<vector<int>> graph(n);
        for (auto& e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }

        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);

        function<int(int)> find = [&](int p) {
            if (parent[p] != p) parent[p] = find(parent[p]);
            return parent[p];
        };

        map<int, vector<int>> mp;
        for (int i = 0; i < n; ++i) mp[vals[i]].push_back(i);

        vector<bool> seen(n);
        for (auto& [_, idx] : mp) {
            for (auto& u : idx) {
                seen[u] = true;
                for (auto& v : graph[u])
                    if (seen[v]) parent[find(u)] = find(v);
            }
            unordered_map<int, int> freq;
            for (auto& u : idx) ++freq[find(u)];
            for (auto& [_, v] : freq) ans += v*(v-1)/2;
        }
        return ans + n;
    }


    /*2422. Merge Operations to Turn Array Into a Palindrome (Medium)
    You are given an array nums consisting of positive integers. You can
    perform the following operation on the array any number of times:
    * Choose any two adjacent elements and replace them with their sum.
      + For example, if nums = [1,2,3,1], you can apply one operation to make
        it [1,5,1].
    Return the minimum number of operations needed to turn the array into a
    palindrome.

    Example 1:
    Input: nums = [4,3,2,1,2,3,1]
    Output: 2
    Explanation: We can turn the array into a palindrome in 2 operations as
                 follows:
                 - Apply the operation on the fourth and fifth element of the
                   array, nums becomes equal to [4,3,2,3,3,1].
                 - Apply the operation on the fifth and sixth element of the
                   array, nums becomes equal to [4,3,2,3,4].
                 The array [4,3,2,3,4] is a palindrome. It can be shown that 2
                 is the minimum number of operations needed.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 3
    Explanation: We do the operation 3 times in any position, we obtain the
                 array [10] at the end which is a palindrome.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    int minimumOperations(vector<int>& nums) {
        int ans = 0;
        for (int lo = -1, hi = nums.size(), diff = 0; lo < hi; )
            if (diff > 0) {
                ++ans;
                diff -= nums[--hi];
            } else if (diff < 0) {
                ++ans;
                diff += nums[++lo];
            } else diff = nums[++lo] - nums[--hi];
        return ans;
    }


    /*2423. Remove Letter To Equalize Frequency (Easy)
    You are given a 0-indexed string word, consisting of lowercase English
    letters. You need to select one index and remove the letter at that index
    from word so that the frequency of every letter present in word is equal.
    Return true if it is possible to remove one letter so that the frequency of
    all letters in word are equal, and false otherwise.

    Note:
    * The frequency of a letter x is the number of times it occurs in the
      string.
    * You must remove exactly one letter and cannot chose to do nothing.

    Example 1:
    Input: word = "abcc"
    Output: true
    Explanation: Select index 3 and delete it: word becomes "abc" and each
                 character has a frequency of 1.

    Example 2:
    Input: word = "aazz"
    Output: false
    Explanation: We must delete a character, so either the frequency of "a" is
                 1 and the frequency of "z" is 2, or vice versa. It is
                 impossible to make all present letters have equal frequency.

    Constraints:
    * 2 <= word.length <= 100
    * word consists of lowercase English letters only.*/

    bool equalFrequency(string word) {
        unordered_map<char, int> freq;
        for (auto& ch : word) ++freq[ch];
        vector<int> vals;
        for (auto& [k, v] : freq) vals.push_back(v);
        sort(vals.begin(), vals.end());
        int n = vals.size();
        return n == 1 || (vals[0] == 1 && vals[1] == vals[n-1]) || (vals[0] == vals[n-2] && vals[0]+1 == vals[n-1]);
    }


    /*2425. Bitwise XOR of All Pairings (Medium)
    You are given two 0-indexed arrays, nums1 and nums2, consisting of non-
    negative integers. There exists another array, nums3, which contains the
    bitwise XOR of all pairings of integers between nums1 and nums2 (every
    integer in nums1 is paired with every integer in nums2 exactly once).
    Return the bitwise XOR of all integers in nums3.

    Example 1:
    Input: nums1 = [2,1,3], nums2 = [10,2,5,0]
    Output: 13
    Explanation: A possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3]. The
                 bitwise XOR of all these numbers is 13, so we return 13.

    Example 2:
    Input: nums1 = [1,2], nums2 = [3,4]
    Output: 0
    Explanation: All possible pairs of bitwise XORs are nums1[0] ^ nums2[0],
                 nums1[0] ^ nums2[1], nums1[1] ^ nums2[0], and
                 nums1[1] ^ nums2[1]. Thus, one possible nums3 array is
                 [2,5,1,6]. 2 ^ 5 ^ 1 ^ 6 = 0, so we return 0.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 10^5
    * 0 <= nums1[i], nums2[j] <= 10^9*/

    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {
        int ans = 0;
        if (nums1.size() & 1)
            for (auto& x : nums2) ans ^= x;
        if (nums2.size() & 1)
            for (auto& x : nums1) ans ^= x;
        return ans;
    }


    /*2426. Number of Pairs Satisfying Inequality (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2, each of size n,
    and an integer diff. Find the number of pairs (i, j) such that:
    * 0 <= i < j <= n - 1 and
    * nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.
    Return the number of pairs that satisfy the conditions.

    Example 1:
    Input: nums1 = [3,2,5], nums2 = [2,2,1], diff = 1
    Output: 3
    Explanation: There are 3 pairs that satisfy the conditions:
                 1. i = 0, j = 1: 3 - 2 <= 2 - 2 + 1. Since i < j and 1 <= 1,
                    this pair satisfies the conditions.
                 2. i = 0, j = 2: 3 - 5 <= 2 - 1 + 1. Since i < j and -2 <= 2,
                    this pair satisfies the conditions.
                 3. i = 1, j = 2: 2 - 5 <= 2 - 1 + 1. Since i < j and -3 <= 2,
                    this pair satisfies the conditions.
                 Therefore, we return 3.

    Example 2:
    Input: nums1 = [3,-1], nums2 = [-2,2], diff = -1
    Output: 0
    Explanation: Since there does not exist any pair that satisfies the
                 conditions, we return 0.

    Constraints:
    * n == nums1.length == nums2.length
    * 2 <= n <= 10^5
    * -10^4 <= nums1[i], nums2[i] <= 10^4
    * -10^4 <= diff <= 10^4*/

    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {
        for (int i = 0; i < nums1.size(); ++i) nums1[i] -= nums2[i];
        vector<int> copy = nums1;

        function<long long(vector<int>&, vector<int>&, int, int)> fn = [&](vector<int>& nums, vector<int>& copy, int lo, int hi) {
            long long ans = 0;
            if (lo+1 < hi) {
                int mid = lo + (hi-lo)/2;
                ans += fn(copy, nums, lo, mid);
                ans += fn(copy, nums, mid, hi);
                for (int i = lo, j = mid, jj = mid; i < mid || j < hi; ++lo)
                    if (j == hi || (i < mid && copy[i] <= copy[j])) {
                        while (jj < hi && copy[i] > copy[jj]+diff) ++jj;
                        ans += hi - jj;
                        nums[lo] = copy[i++];
                    } else nums[lo] = copy[j++];
            }
            return ans;
        };

        return fn(nums1, copy, 0, nums1.size());
    }


    /*2431. Maximize Total Tastiness of Purchased Fruits (Medium)
    You are given two non-negative integer arrays price and tastiness, both
    arrays have the same length n. You are also given two non-negative integers
    maxAmount and maxCoupons.

    For every integer i in range [0, n - 1]:
    * price[i] describes the price of ith fruit.
    * tastiness[i] describes the tastiness of ith fruit.
    You want to purchase some fruits such that total tastiness is maximized and
    the total price does not exceed maxAmount. Additionally, you can use a
    coupon to purchase fruit for half of its price (rounded down to the closest
    integer). You can use at most maxCoupons of such coupons. Return the
    maximum total tastiness that can be purchased.

    Note that:
    * You can purchase each fruit at most once.
    * You can use coupons on some fruit at most once.

    Example 1:
    Input: price = [10,20,20], tastiness = [5,8,8], maxAmount = 20, maxCoupons = 1
    Output: 13
    Explanation: It is possible to make total tastiness 13 in following way:
                 - Buy first fruit without coupon, so that total price = 0 + 10
                   and total tastiness = 0 + 5.
                 - Buy second fruit with coupon, so that total price = 10 + 10
                   and total tastiness = 5 + 8.
                 - Do not buy third fruit, so that total price = 20 and total
                   tastiness = 13.
                 It can be proven that 13 is the maximum total tastiness that
                 can be obtained.

    Example 2:
    Input: price = [10,15,7], tastiness = [5,8,20], maxAmount = 10, maxCoupons = 2
    Output: 28
    Explanation: It is possible to make total tastiness 20 in following way:
                 - Do not buy first fruit, so that total price = 0 and total
                   tastiness = 0.
                 - Buy second fruit with coupon, so that total price = 0 + 7
                   and total tastiness = 0 + 8.
                 - Buy third fruit with coupon, so that total price = 7 + 3 and
                   total tastiness = 8 + 20.
                 It can be proven that 28 is the maximum total tastiness that
                 can be obtained.

    Constraints:
    * n == price.length == tastiness.length
    * 1 <= n <= 100
    * 0 <= price[i], tastiness[i], maxAmount <= 1000
    * 0 <= maxCoupons <= 5*/

    int maxTastiness(vector<int>& price, vector<int>& tastiness, int maxAmount, int maxCoupons) {
        vector<vector<int>> dp(maxAmount+1, vector<int>(maxCoupons+1));
        for (int i = 0; i < price.size(); ++i)
            for (int j = maxAmount; j >= price[i]/2; --j)
                for (int k = maxCoupons; k >= 0; --k) {
                    if (price[i] <= j) dp[j][k] = max(dp[j][k], tastiness[i] + dp[j-price[i]][k]);
                    if (k) dp[j][k] = max(dp[j][k], tastiness[i] + dp[j-price[i]/2][k-1]);
                }
        return dp.back().back();
    }


    /*2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium)
    You are given an array nums consisting of positive integers. Split the
    array into one or more disjoint subarrays such that:
    * Each element of the array belongs to exactly one subarray, and
    * The GCD of the elements of each subarray is strictly greater than 1.
    Return the minimum number of subarrays that can be obtained after the split.

    Note that:
    * The GCD of a subarray is the largest positive integer that evenly divides
      all the elements of the subarray.
    * A subarray is a contiguous part of the array.

    Example 1:
    Input: nums = [12,6,3,14,8]
    Output: 2
    Explanation: We can split the array into the subarrays: [12,6,3] and [14,8].
                 - The GCD of 12, 6 and 3 is 3, which is strictly greater than
                   1.
                 - The GCD of 14 and 8 is 2, which is strictly greater than 1.
                 It can be shown that splitting the array into one subarray
                 will make the GCD = 1.

    Example 2:
    Input: nums = [4,12,6,14]
    Output: 1
    Explanation: We can split the array into only one subarray, which is the
                 whole array.

    Constraints:
    * 1 <= nums.length <= 2000
    * 2 <= nums[i] <= 10^9*/

    int minimumSplits(vector<int>& nums) {
        int ans = 0, g = 1;
        for (auto& x : nums) {
            g = gcd(g, x);
            if (g == 1) {
                ++ans;
                g = x;
            }
        }
        return ans;
    }


    /*2437. Number of Valid Clock Times (Easy)
    You are given a string of length 5 called time, representing the current
    time on a digital clock in the format "hh:mm". The earliest possible time
    is "00:00" and the latest possible time is "23:59". In the string time, the
    digits represented by the ? symbol are unknown, and must be replaced with a
    digit from 0 to 9. Return an integer answer, the number of valid clock
    times that can be created by replacing every ? with a digit from 0 to 9.

    Example 1:
    Input: time = "?5:00"
    Output: 2
    Explanation: We can replace the ? with either a 0 or 1, producing "05:00"
                 or "15:00". Note that we cannot replace it with a 2, since the
                 time "25:00" is invalid. In total, we have two choices.

    Example 2:
    Input: time = "0?:0?"
    Output: 100
    Explanation: Each ? can be replaced by any digit from 0 to 9, so we have
                 100 total choices.

    Example 3:
    Input: time = "??:??"
    Output: 1440
    Explanation: There are 24 possible choices for the hours, and 60 possible
                 choices for the minutes. In total, we have 24 * 60 = 1440
                 choices.

    Constraints:
    * time is a valid string of length 5 in the format "hh:mm".
    * "00" <= hh <= "23"
    * "00" <= mm <= "59"
    * Some of the digits might be replaced with '?' and need to be replaced
      with digits from 0 to 9.*/

    int countTime(string time) {
        int ans = 1;
        if (time[0] == '?' && time[1] == '?') ans *= 24;
        else if (time[0] == '?') ans *= time[1] >= '4' ? 2 : 3;
        else if (time[1] == '?') ans *= time[0] == '2' ? 4 : 10;
        if (time[3] == '?') ans *= 6;
        if (time[4] == '?') ans *= 10;
        return ans;
    }


    /*2438. Range Product Queries of Powers (Medium)
    Given a positive integer n, there exists a 0-indexed array called powers,
    composed of the minimum number of powers of 2 that sum to n. The array is
    sorted in non-decreasing order, and there is only one way to form the array.
    You are also given a 0-indexed 2D integer array queries, where
    queries[i] = [lefti, righti]. Each queries[i] represents a query where you
    have to find the product of all powers[j] with lefti <= j <= righti. Return
    an array answers, equal in length to queries, where answers[i] is the
    answer to the ith query. Since the answer to the ith query may be too large,
    each answers[i] should be returned modulo 10^9 + 7.

    Example 1:
    Input: n = 15, queries = [[0,1],[2,2],[0,3]]
    Output: [2,4,64]
    Explanation: For n = 15, powers = [1,2,4,8]. It can be shown that powers
                 cannot be a smaller size.
                 Answer to 1st query: powers[0] * powers[1] = 1 * 2 = 2.
                 Answer to 2nd query: powers[2] = 4.
                 Answer to 3rd query: powers[0] * powers[1] * powers[2] *
                 powers[3] = 1 * 2 * 4 * 8 = 64.
                 Each answer modulo 10^9 + 7 yields the same answer, so [2,4,64]
                 is returned.

    Example 2:
    Input: n = 2, queries = [[0,0]]
    Output: [2]
    Explanation: For n = 2, powers = [2]. The answer to the only query is
                 powers[0] = 2. The answer modulo 10^9 + 7 is the same, so
                 [2] is returned.

    Constraints:
    * 1 <= n <= 10^9
    * 1 <= queries.length <= 10^5
    * 0 <= starti <= endi < powers.length*/

    vector<int> productQueries(int n, vector<vector<int>>& queries) {
        vector<int> powers;
        for (int i = 0; i < 30; ++i)
            if (n & 1<<i) powers.push_back(1<<i);
        vector<int> ans;
        for (auto& q : queries) {
            long val = 1;
            for (int i = q[0]; i <= q[1]; ++i)
                val = val * powers[i] % 1'000'000'007;
            ans.push_back(val);
        }
        return ans;
    }


    /*2439. Minimize Maximum of Array (Medium)
    You are given a 0-indexed array nums comprising of n non-negative integers.
    In one operation, you must:
    * Choose an integer i such that 1 <= i < n and nums[i] > 0.
    * Decrease nums[i] by 1.
    * Increase nums[i - 1] by 1.
    Return the minimum possible value of the maximum integer of nums after
    performing any number of operations.

    Example 1:
    Input: nums = [3,7,1,6]
    Output: 5
    Explanation: One set of optimal operations is as follows:
                 1. Choose i = 1, and nums becomes [4,6,1,6].
                 2. Choose i = 3, and nums becomes [4,6,2,5].
                 3. Choose i = 1, and nums becomes [5,5,2,5].
                 The maximum integer of nums is 5. It can be shown that the
                 maximum number cannot be less than 5. Therefore, we return 5.

    Example 2:
    Input: nums = [10,1]
    Output: 10
    Explanation: It is optimal to leave nums as is, and since 10 is the maximum
                 value, we return 10.

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^5
    * 0 <= nums[i] <= 10^9*/

    int minimizeArrayValue(vector<int>& nums) {
        long ans = 0, prefix = 0;
        for (int i = 0; i < nums.size(); ++i) {
            prefix += nums[i];
            ans = max(ans, (prefix + i)/(i+1));
        }
        return ans;
    }


    /*2440. Create Components With Same Value (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given a 0-indexed integer array nums of length n where nums[i] represents
    the value of the ith node. You are also given a 2D integer array edges of
    length n - 1 where edges[i] = [ai, bi] indicates that there is an edge
    between nodes ai and bi in the tree. You are allowed to delete some edges,
    splitting the tree into multiple connected components. Let the value of a
    component be the sum of all nums[i] for which node i is in the component.
    Return the maximum number of edges you can delete, such that every
    connected component in the tree has the same value.

    Example 1:
    Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]]
    Output: 2
    Explanation: The above figure shows how we can delete the edges [0,1] and
                 [3,4]. The created components are nodes [0], [1,2,3] and [4].
                 The sum of the values in each component equals 6. It can be
                 proven that no better deletion exists, so the answer is 2.

    Example 2:
    Input: nums = [2], edges = []
    Output: 0
    Explanation: There are no edges to be deleted.

    Constraints:
    * 1 <= n <= 2 * 10^4
    * nums.length == n
    * 1 <= nums[i] <= 50
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * edges represents a valid tree.*/

    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {
        int n = nums.size();
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }

        function<int(int, int, int)> fn = [&](int u, int p, int cand) {
            int ans = nums[u];
            for (auto& v : tree[u])
                if (v != p) ans += fn(v, u, cand);
            return ans == cand ? 0 : ans;
        };

        int total = accumulate(nums.begin(), nums.end(), 0);
        for (int cand = 1; cand <= total/2; ++cand)
            if (total % cand == 0 and fn(0, -1, cand) == 0) return total/cand-1;
        return 0;
    }


    /*2441. Largest Positive Integer That Exists With Its Negative (Easy)
    Given an integer array nums that does not contain any zeros, find the
    largest positive integer k such that -k also exists in the array. Return
    the positive integer k. If there is no such integer, return -1.

    Example 1:
    Input: nums = [-1,2,-3,3]
    Output: 3
    Explanation: 3 is the only valid k we can find in the array.

    Example 2:
    Input: nums = [-1,10,6,7,-7,1]
    Output: 7
    Explanation: Both 1 and 7 have their corresponding negative values in the
                 array. 7 has a larger value.

    Example 3:
    Input: nums = [-10,8,6,7,-2,-3]
    Output: -1
    Explanation: There is no a single valid k, we return -1.

    Constraints:
    * 1 <= nums.length <= 1000
    * -1000 <= nums[i] <= 1000
    * nums[i] != 0*/

    int findMaxK(vector<int>& nums) {
        int ans = -1;
        unordered_set<int> seen;
        for (auto& x : nums) {
            if (seen.count(-x)) ans = max(ans, abs(x));
            seen.insert(x);
        }
        return ans;
    }


    /*2442. Count Number of Distinct Integers After Reverse Operations (Medium)
    You are given an array nums consisting of positive integers. You have to
    take each integer in the array, reverse its digits, and add it to the end
    of the array. You should apply this operation to the original integers in
    nums. Return the number of distinct integers in the final array.

    Example 1:
    Input: nums = [1,13,10,12,31]
    Output: 6
    Explanation: After including the reverse of each number, the resulting
                 array is [1,13,10,12,31,1,31,1,21,13]. The reversed integers
                 that were added to the end of the array are underlined. Note
                 that for the integer 10, after reversing it, it becomes 01
                 which is just 1. The number of distinct integers in this array
                 is 6 (The numbers 1, 10, 12, 13, 21, and 31).

    Example 2:
    Input: nums = [2,2,2]
    Output: 1
    Explanation: After including the reverse of each number, the resulting
                 array is [2,2,2,2,2,2]. The number of distinct integers in
                 this array is 1 (The number 2).

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    int countDistinctIntegers(vector<int>& nums) {
        unordered_set<int> seen(nums.begin(), nums.end());
        for (auto& x : nums) {
            int r = 0;
            for (; x; r = 10*r + x%10, x /= 10);
            seen.insert(r);
        }
        return seen.size();
    }


    /*2443. Sum of Number and Its Reverse (Medium)
    Given a non-negative integer num, return true if num can be expressed as
    the sum of any non-negative integer and its reverse, or false otherwise.

    Example 1:
    Input: num = 443
    Output: true
    Explanation: 172 + 271 = 443 so we return true.

    Example 2:
    Input: num = 63
    Output: false
    Explanation: 63 cannot be expressed as the sum of a non-negative integer
                 and its reverse so we return false.

    Example 3:
    Input: num = 181
    Output: true
    Explanation: 140 + 041 = 181 so we return true. Note that when a number is
                 reversed, there may be leading zeros.

    Constraints: 0 <= num <= 10^5*/

    bool sumOfNumberAndReverse(int num) {
        for (int x = 0; x <= num; ++x) {
            int r = 0;
            for (int xx = x; xx; r = 10*r + xx % 10, xx /= 10);
            if (x + r == num) return true;
        }
        return false;
    }


    /*2444. Count Subarrays With Fixed Bounds (Hard)
    You are given an integer array nums and two integers minK and maxK. A
    fixed-bound subarray of nums is a subarray that satisfies the following
    conditions:
    * The minimum value in the subarray is equal to minK.
    * The maximum value in the subarray is equal to maxK.
    Return the number of fixed-bound subarrays. A subarray is a contiguous
    part of an array.

    Example 1:
    Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5
    Output: 2
    Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].

    Example 2:
    Input: nums = [1,1,1,1], minK = 1, maxK = 1
    Output: 10
    Explanation: Every subarray of nums is a fixed-bound subarray. There are 10
                 possible subarrays.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i], minK, maxK <= 10^6*/

    long long countSubarrays(vector<int>& nums, int minK, int maxK) {
        long long ans = 0;
        for (int i = 0, ii = -1, imin = -1, imax = -1; i < nums.size(); ++i)
            if (minK <= nums[i] && nums[i] <= maxK) {
                if (minK == nums[i]) imin = i;
                if (maxK == nums[i]) imax = i;
                ans += max(0, min(imin, imax) - ii);
            } else ii = i;
        return ans;
    }


    /*2445. Number of Nodes With Value One (Medium)
    There is an undirected connected tree with n nodes labeled from 1 to n and
    n - 1 edges. You are given the integer n. The parent node of a node with a
    label v is the node with the label floor (v / 2). The root of the tree is
    the node with the label 1.
    * For example, if n = 7, then the node with the label 3 has the node with
      the label floor(3 / 2) = 1 as its parent, and the node with the label 7
      has the node with the label floor(7 / 2) = 3 as its parent.
    You are also given an integer array queries. Initially, every node has a
    value 0 on it. For each query queries[i], you should flip all values in the
    subtree of the node with the label queries[i]. Return the total number of
    nodes with the value 1 after processing all the queries.

    Note that:
    * Flipping the value of a node means that the node with the value 0 becomes
      1 and vice versa.
    * floor(x) is equivalent to rounding x down to the nearest integer.

    Example 1:
    Input: n = 5 , queries = [1,2,5]
    Output: 3
    Explanation: The diagram above shows the tree structure and its status
                 after performing the queries. The blue node represents the
                 value 0, and the red node represents the value 1. After
                 processing the queries, there are three red nodes (nodes with
                 value 1): 1, 3, and 5.

    Example 2:
    Input: n = 3, queries = [2,3,3]
    Output: 1
    Explanation: The diagram above shows the tree structure and its status
                 after performing the queries. The blue node represents the
                 value 0, and the red node represents the value 1. After
                 processing the queries, there are one red node (node with
                 value 1): 2.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= queries.length <= 10^5
    * 1 <= queries[i] <= n*/

    int numberOfNodes(int n, vector<int>& queries) {
        vector<int> flip(n+1);
        for (auto& q : queries) flip[q] ^= 1;
        int ans = 0;
        stack<pair<int, int>> stk; stk.emplace(1, flip[1]);
        while (stk.size()) {
            auto [x, f] = stk.top(); stk.pop();
            if (f & 1) ++ans;
            if (2*x <= n) stk.emplace(2*x, f^flip[2*x]);
            if (2*x+1 <= n) stk.emplace(2*x+1, f^flip[2*x+1]);
        }
        return ans;
    }


    /*2446. Determine if Two Events Have Conflict (Easy)
    You are given two arrays of strings that represent two inclusive events
    that happened on the same day, event1 and event2, where:
    * event1 = [startTime1, endTime1] and
    * event2 = [startTime2, endTime2].
    Event times are valid 24 hours format in the form of HH:MM. A conflict
    happens when two events have some non-empty intersection (i.e., some moment
    is common to both events). Return true if there is a conflict between two
    events. Otherwise, return false.

    Example 1:
    Input: event1 = ["01:15","02:00"], event2 = ["02:00","03:00"]
    Output: true
    Explanation: The two events intersect at time 2:00.

    Example 2:
    Input: event1 = ["01:00","02:00"], event2 = ["01:20","03:00"]
    Output: true
    Explanation: The two events intersect starting from 01:20 to 02:00.

    Example 3:
    Input: event1 = ["10:00","11:00"], event2 = ["14:00","15:00"]
    Output: false
    Explanation: The two events do not intersect.

    Constraints:
    * evnet1.length == event2.length == 2.
    * event1[i].length == event2[i].length == 5
    * startTime1 <= endTime1
    * startTime2 <= endTime2
    * All the event times follow the HH:MM format.*/

    bool haveConflict(vector<string>& event1, vector<string>& event2) {
        return !(event1[1] < event2[0] || event2[1] < event1[0]);
    }


    /*2447. Number of Subarrays With GCD Equal to K (Medium)
    Given an integer array nums and an integer k, return the number of
    subarrays of nums where the greatest common divisor of the subarray's
    elements is k. A subarray is a contiguous non-empty sequence of elements
    within an array. The greatest common divisor of an array is the largest
    integer that evenly divides all the array elements.

    Example 1:
    Input: nums = [9,3,1,2,6,3], k = 3
    Output: 4
    Explanation: The subarrays of nums where 3 is the greatest common divisor
                 of all the subarray's elements are:
                 - [9,3,1,2,6,3]
                 - [9,3,1,2,6,3]
                 - [9,3,1,2,6,3]
                 - [9,3,1,2,6,3]

    Example 2:
    Input: nums = [4], k = 7
    Output: 0
    Explanation: There are no subarrays of nums where 7 is the greatest common
                 divisor of all the subarray's elements.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i], k <= 10^9*/

    int subarrayGCD(vector<int>& nums, int k) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (auto& x : nums) {
            unordered_map<int, int> temp = {{x, 1}};
            for (auto& [key, v] : freq)
                temp[gcd(key, x)] += v;
            freq = temp;
            ans += freq[k];
        }
        return ans;
    }


    /*2448. Minimum Cost to Make Array Equal (Hard)
    You are given two 0-indexed arrays nums and cost consisting each of n
    positive integers. You can do the following operation any number of times:
    * Increase or decrease any element of the array nums by 1.
    The cost of doing one operation on the ith element is cost[i]. Return the
    minimum total cost such that all the elements of the array nums become
    equal.

    Example 1:
    Input: nums = [1,3,5,2], cost = [2,3,1,14]
    Output: 8
    Explanation: We can make all the elements equal to 2 in the following way:
                 - Increase the 0th element one time. The cost is 2.
                 - Decrease the 1st element one time. The cost is 3.
                 - Decrease the 2nd element three times. The cost is
                   1 + 1 + 1 = 3.
                 The total cost is 2 + 3 + 3 = 8. It can be shown that we
                 cannot make the array equal with a smaller cost.

    Example 2:
    Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3]
    Output: 0
    Explanation: All the elements are already equal, so no operations are
                 needed.

    Constraints:
    * n == nums.length == cost.length
    * 1 <= n <= 10^5
    * 1 <= nums[i], cost[i] <= 10^6*/

    long long minCost(vector<int>& nums, vector<int>& cost) {
        vector<pair<int, int>> aug;
        for (int i = 0; i < nums.size(); ++i) aug.emplace_back(nums[i], cost[i]);
        sort(aug.begin(), aug.end());
        long long ans = 0, median = 0, prefix = 0, total = accumulate(cost.begin(), cost.end(), 0ll);
        for (auto& [x, c] : aug) {
            prefix += c;
            if (prefix > total/2) { median = x; break; }
        }
        for (auto& [x, c] : aug) ans += c * abs(x - median);
        return ans;
    }


    /*2449. Minimum Number of Operations to Make Arrays Similar (Hard)
    You are given two positive integer arrays nums and target, of the same
    length. In one operation, you can choose any two distinct indices i and j
    where 0 <= i, j < nums.length and:
    * set nums[i] = nums[i] + 2 and
    * set nums[j] = nums[j] - 2.
    Two arrays are considered to be similar if the frequency of each element is
    the same. Return the minimum number of operations required to make nums
    similar to target. The test cases are generated such that nums can always
    be similar to target.

    Example 1:
    Input: nums = [8,12,6], target = [2,14,10]
    Output: 2
    Explanation: It is possible to make nums similar to target in two
                 operations:
                 - Choose i = 0 and j = 2, nums = [10,12,4].
                 - Choose i = 1 and j = 2, nums = [10,14,2].
                 It can be shown that 2 is the minimum number of operations
                 needed.

    Example 2:
    Input: nums = [1,2,5], target = [4,1,3]
    Output: 1
    Explanation: We can make nums similar to target in one operation:
                 - Choose i = 1 and j = 2, nums = [1,4,3].

    Example 3:
    Input: nums = [1,1,1,1,1], target = [1,1,1,1,1]
    Output: 0
    Explanation: The array nums is already similiar to target.

    Constraints:
    * n == nums.length == target.length
    * 1 <= n <= 10^5
    * 1 <= nums[i], target[i] <= 10^6
    * It is possible to make nums similar to target.*/

    long long makeSimilar(vector<int>& nums, vector<int>& target) {
        auto cmp = [&](auto& lhs, auto& rhs) {
            return (lhs & 1) < (rhs & 1) || ((lhs & 1) == (rhs & 1) && lhs < rhs);
        };
        sort(nums.begin(), nums.end(), cmp);
        sort(target.begin(), target.end(), cmp);
        long long ans = 0;
        for (int i = 0; i < nums.size(); ++i)
            ans += abs(nums[i] - target[i]);
        return ans/4;
    }


    /*2450. Number of Distinct Binary Strings After Applying Operations (Medium)
    You are given a binary string s and a positive integer k. You can apply the
    following operation on the string any number of times:
    * Choose any substring of size k from s and flip all its characters, that
      is, turn all 1's into 0's, and all 0's into 1's.
    Return the number of distinct strings you can obtain. Since the answer may
    be too large, return it modulo 10^9 + 7.

    Note that:
    * A binary string is a string that consists only of the characters 0 and 1.
    * A substring is a contiguous part of a string.

    Example 1:
    Input: s = "1001", k = 3
    Output: 4
    Explanation: We can obtain the following strings:
                 - Applying no operation on the string gives s = "1001".
                 - Applying one operation on the substring starting at index 0
                   gives s = "0111".
                 - Applying one operation on the substring starting at index 1
                   gives s = "1110".
                 - Applying one operation on both the substrings starting at
                   indices 0 and 1 gives s = "0000".
                 It can be shown that we cannot obtain any other string, so the
                 answer is 4.

    Example 2:
    Input: s = "10110", k = 5
    Output: 2
    Explanation: We can obtain the following strings:
                 - Applying no operation on the string gives s = "10110".
                 - Applying one operation on the whole string gives s = "01001".
                 It can be shown that we cannot obtain any other string, so the
                 answer is 2.

    Constraints:
    * 1 <= k <= s.length <= 10^5
    * s[i] is either 0 or 1.*/

    int countDistinctStrings(string s, int k) {
        long ans = 1;
        for (int i = 0; i <= s.size() - k; ++i)
            ans = ans * 2 % 1'000'000'007;
        return ans;
    }


    /*2451. Odd String Difference (Easy)
    You are given an array of equal-length strings words. Assume that the
    length of each string is n. Each string words[i] can be converted into a
    difference integer array difference[i] of length n - 1 where
    difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note
    that the difference between two letters is the difference between their
    positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z'
    is 25. For example, for the string "acb", the difference integer array is
    [2 - 0, 1 - 2] = [2, -1]. All the strings in words have the same difference
    integer array, except one. You should find that string. Return the string
    in words that has different difference integer array.

    Example 1:
    Input: words = ["adc","wzy","abc"]
    Output: "abc"
    Explanation: - The difference integer array of "adc" is
                   [3 - 0, 2 - 3] = [3, -1].
                 - The difference integer array of "wzy" is
                   [25 - 22, 24 - 25]= [3, -1].
                 - The difference integer array of "abc" is
                   [1 - 0, 2 - 1] = [1, 1].
                 The odd array out is [1, 1], so we return the corresponding
                 string, "abc".

    Example 2:
    Input: words = ["aaa","bob","ccc","ddd"]
    Output: "bob"
    Explanation: All the integer arrays are [0, 0] except for "bob", which
                 corresponds to [13, -13].

    Constraints:
    * 3 <= words.length <= 100
    * n == words[i].length
    * 2 <= n <= 20
    * words[i] consists of lowercase English letters.*/

    string oddString(vector<string>& words) {
        map<vector<int>, vector<string>> mp;
        for (auto& word : words) {
            vector<int> diff;
            for (int i = 1; i < word.size(); ++i)
                diff.push_back(word[i] - word[i-1]);
            mp[diff].push_back(word);
        }
        for (auto& [_, v] : mp)
            if (v.size() == 1) return v[0];
        return "";
    }


    /*2452. Words Within Two Edits of Dictionary (Medium)
    You are given two string arrays, queries and dictionary. All words in each
    array comprise of lowercase English letters and have the same length. In
    one edit you can take a word from queries, and change any letter in it to
    any other letter. Find all words from queries that, after a maximum of two
    edits, equal some word from dictionary. Return a list of all words from
    queries, that match with some word from dictionary after a maximum of two
    edits. Return the words in the same order they appear in queries.

    Example 1:
    Input: queries = ["word","note","ants","wood"], dictionary = ["wood","joke","moat"]
    Output: ["word","note","wood"]
    Explanation: - Changing the 'r' in "word" to 'o' allows it to equal the
                   dictionary word "wood".
                 - Changing the 'n' to 'j' and the 't' to 'k' in "note" changes
                   it to "joke".
                 - It would take more than 2 edits for "ants" to equal a
                   dictionary word.
                 - "wood" can remain unchanged (0 edits) and match the
                   corresponding dictionary word.
                 Thus, we return ["word","note","wood"].

    Example 2:
    Input: queries = ["yes"], dictionary = ["not"]
    Output: []
    Explanation: Applying any two edits to "yes" cannot make it equal to "not".
                 Thus, we return an empty array.

    Constraints:
    * 1 <= queries.length, dictionary.length <= 100
    * n == queries[i].length == dictionary[j].length
    * 1 <= n <= 100
    * All queries[i] and dictionary[j] are composed of lowercase English
      letters.*/

    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {
        unordered_set<string> seen;
        for (auto& word : dictionary)
            for (int i = 0; i < word.size(); ++i) {
                char ch = word[i];
                for (auto& ch : string("abcdefghijklmnopqrstuvwxyz")) {
                    word[i] = ch;
                    seen.insert(word);
                }
                word[i] = ch;
            }
        vector<string> ans;
        for (auto& word : queries)
            for (int i = 0; i < word.size(); ++i) {
                char ch = word[i];
                bool found = false;
                for (auto& ch : string("abcdefghijklmnopqrstuvwxyz")) {
                    word[i] = ch;
                    if (seen.count(word)) {found = true; break;}
                }
                word[i] = ch;
                if (found) {
                    ans.push_back(word);
                    break;
                }
            }
        return ans;
    }


    /*2453. Destroy Sequential Targets (Medium)
    You are given a 0-indexed array nums consisting of positive integers,
    representing targets on a number line. You are also given an integer space.
    You have a machine which can destroy targets. Seeding the machine with some
    nums[i] allows it to destroy all targets with values that can be
    represented as nums[i] + c * space, where c is any non-negative integer.
    You want to destroy the maximum number of targets in nums. Return the
    minimum value of nums[i] you can seed the machine with to destroy the
    maximum number of targets.

    Example 1:
    Input: nums = [3,7,8,1,1,5], space = 2
    Output: 1
    Explanation: If we seed the machine with nums[3], then we destroy all
                 targets equal to 1,3,5,7,9,... In this case, we would destroy
                 5 total targets (all except for nums[2]). It is impossible to
                 destroy more than 5 targets, so we return nums[3].

    Example 2:
    Input: nums = [1,3,5,2,4,6], space = 2
    Output: 1
    Explanation: Seeding the machine with nums[0], or nums[3] destroys 3
                 targets. It is not possible to destroy more than 3 targets.
                 Since nums[0] is the minimal integer that can destroy 3
                 targets, we return 1.

    Example 3:
    Input: nums = [6,2,5], space = 100
    Output: 2
    Explanation: Whatever initial seed we select, we can only destroy 1 target.
                 The minimal seed is nums[1].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= space <= 10^9*/

    int destroyTargets(vector<int>& nums, int space) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x % space];
        return *max_element(nums.begin(), nums.end(), [&](auto& lhs, auto& rhs) {
            int ll = freq[lhs % space], rr = freq[rhs % space];
            return ll < rr || (ll == rr && lhs > rhs);
        });
    }


    /*2454. Next Greater Element IV (Hard)
    You are given a 0-indexed array of non-negative integers nums. For each
    integer in nums, you must find its respective second greater integer.
    The second greater integer of nums[i] is nums[j] such that:
    * j > i
    * nums[j] > nums[i]
    * There exists exactly one index k such that nums[k] > nums[i] and
      i < k < j.
    If there is no such nums[j], the second greater integer is considered to be
    -1. For example, in the array [1, 2, 4, 3], the second greater integer of 1
    is 4, 2 is 3, and that of 3 and 4 is -1. Return an integer array answer,
    where answer[i] is the second greater integer of nums[i].

    Example 1:
    Input: nums = [2,4,0,9,6]
    Output: [9,6,6,-1,-1]
    Explanation: 0th index: 4 is the first integer greater than 2, and 9 is the
                            second integer greater than 2, to the right of 2.
                 1st index: 9 is the first, and 6 is the second integer greater
                            than 4, to the right of 4.
                 2nd index: 9 is the first, and 6 is the second integer greater
                            than 0, to the right of 0.
                 3rd index: There is no integer greater than 9 to its right, so
                            the second greater integer is considered to be -1.
                 4th index: There is no integer greater than 6 to its right, so
                            the second greater integer is considered to be -1.
                 Thus, we return [9,6,6,-1,-1].

    Example 2:
    Input: nums = [3,3]
    Output: [-1,-1]
    Explanation: We return [-1,-1] since neither integer has any integer
                 greater than it.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9*/

    vector<int> secondGreaterElement(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        stack<int> s, ss, buff;
        for (int i = 0; i < nums.size(); ++i) {
            while (ss.size() && nums[ss.top()] < nums[i])
                ans[ss.top()] = nums[i], ss.pop();
            while (s.size() && nums[s.top()] < nums[i])
                buff.push(s.top()), s.pop();
            while (buff.size())
                ss.push(buff.top()), buff.pop();
            s.push(i);
        }
        return ans;
    }


    /*2455. Average Value of Even Numbers That Are Divisible by Three (Easy)
    Given an integer array nums of positive integers, return the average value
    of all even integers that are divisible by 3. Note that the average of n
    elements is the sum of the n elements divided by n and rounded down to the
    nearest integer.

    Example 1:
    Input: nums = [1,3,6,10,12,15]
    Output: 9
    Explanation: 6 and 12 are even numbers that are divisible by 3.
                 (6 + 12) / 2 = 9.

    Example 2:
    Input: nums = [1,2,4,7,10]
    Output: 0
    Explanation: There is no single number that satisfies the requirement, so
                 return 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000*/

    int averageValue(vector<int>& nums) {
        int total = 0, count = 0;
        for (auto& x : nums)
            if (x % 6 == 0) total += x, ++count;
        return count ? total/count : 0;
    }


    /*2456. Most Popular Video Creator (Medium)
    You are given two string arrays creators and ids, and an integer array
    views, all of length n. The ith video on a platform was created by
    creator[i], has an id of ids[i], and has views[i] views. The popularity of
    a creator is the sum of the number of views on all of the creator's videos.
    Find the creator with the highest popularity and the id of their most
    viewed video.
    * If multiple creators have the highest popularity, find all of them.
    * If multiple videos have the highest view count for a creator, find the
      lexicographically smallest id.
    Return a 2D array of strings answer where answer[i] = [creatori, idi] means
    that creatori has the highest popularity and idi is the id of their most
    popular video. The answer can be returned in any order.

    Example 1:
    Input: creators = ["alice","bob","alice","chris"], ids = ["one","two","three","four"], views = [5,10,5,4]
    Output: [["alice","one"],["bob","two"]]
    Explanation: The popularity of alice is 5 + 5 = 10. The popularity of bob
                 is 10. The popularity of chris is 4. alice and bob are the
                 most popular creators. For bob, the video with the highest
                 view count is "two". For alice, the videos with the highest
                 view count are "one" and "three". Since "one" is
                 lexicographically smaller than "three", it is included in the
                 answer.

    Example 2:
    Input: creators = ["alice","alice","alice"], ids = ["a","b","c"], views = [1,2,2]
    Output: [["alice","b"]]
    Explanation: The videos with id "b" and "c" have the highest view count.
                 Since "b" is lexicographically smaller than "c", it is
                 included in the answer.

    Constraints:
    * n == creators.length == ids.length == views.length
    * 1 <= n <= 10^5
    * 1 <= creators[i].length, ids[i].length <= 5
    * creators[i] and ids[i] consist only of lowercase English letters.
    * 0 <= views[i] <= 10^5*/

    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {
        unordered_map<string, long> total;
        unordered_map<string, vector<pair<string, int>>> mp;
        for (int i = 0; i < creators.size(); ++i) {
            total[creators[i]] += views[i];
            mp[creators[i]].emplace_back(ids[i], views[i]);
        }
        auto [_, most] = *max_element(total.begin(), total.end(), [](auto& lhs, auto& rhs) {return lhs.second < rhs.second;});
        vector<vector<string>> ans;
        for (auto& [k, v] : total)
            if (v == most)
                ans.push_back({k, max_element(mp[k].begin(), mp[k].end(), [](auto& lhs, auto&rhs) {
                    return lhs.second < rhs.second || (lhs.second == rhs.second && lhs.first > rhs.first);
                })->first});
        return ans;
    }


    /*2457. Minimum Addition to Make Integer Beautiful (Medium)
    You are given two positive integers n and target. An integer is considered
    beautiful if the sum of its digits is less than or equal to target. Return
    the minimum non-negative integer x such that n + x is beautiful. The input
    will be generated such that it is always possible to make n beautiful.

    Example 1:
    Input: n = 16, target = 6
    Output: 4
    Explanation: Initially n is 16 and its digit sum is 1 + 6 = 7. After adding
                 4, n becomes 20 and digit sum becomes 2 + 0 = 2. It can be
                 shown that we can not make n beautiful with adding non-
                 negative integer less than 4.

    Example 2:
    Input: n = 467, target = 6
    Output: 33
    Explanation: Initially n is 467 and its digit sum is 4 + 6 + 7 = 17. After
                 adding 33, n becomes 500 and digit sum becomes 5 + 0 + 0 = 5.
                 It can be shown that we can not make n beautiful with adding
                 non-negative integer less than 33.

    Example 3:
    Input: n = 1, target = 1
    Output: 0
    Explanation: Initially n is 1 and its digit sum is 1, which is already
                 smaller than or equal to target.

    Constraints:
    * 1 <= n <= 10^12
    * 1 <= target <= 150
    * The input will be generated such that it is always possible to make n
      beautiful.*/

    long long makeIntegerBeautiful(long long n, int target) {

        auto fn = [](long long n) {
            int ans = 0;
            for (; n; ans += n%10, n /= 10);
            return ans;
        };

        long long diff = 0;
        for (int i = 1; fn(n+diff) > target; ++i)
            diff = pow(10, i) - n % (long long) pow(10, i);
        return diff;
    }


    /*2458. Height of Binary Tree After Subtree Removal Queries (Hard)
    You are given the root of a binary tree with n nodes. Each node is assigned
    a unique value from 1 to n. You are also given an array queries of size m.
    You have to perform m independent queries on the tree where in the ith
    query you do the following:
    * Remove the subtree rooted at the node with the value queries[i] from the
      tree. It is guaranteed that queries[i] will not be equal to the value of
      the root.
    Return an array answer of size m where answer[i] is the height of the tree
    after performing the ith query.

    Note:
    * The queries are independent, so the tree returns to its initial state
      after each query.
    * The height of a tree is the number of edges in the longest simple path
      from the root to some node in the tree.

    Example 1:
    Input: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]
    Output: [2]
    Explanation: The diagram above shows the tree after removing the subtree
                 rooted at node with value 4. The height of the tree is 2 (The
                 path 1 -> 3 -> 2).

    Example 2:
    Input: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]
    Output: [3,2,3,2]
    Explanation: We have the following queries:
                 - Removing the subtree rooted at node with value 3. The height
                   of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).
                 - Removing the subtree rooted at node with value 2. The height
                   of the tree becomes 2 (The path 5 -> 8 -> 1).
                 - Removing the subtree rooted at node with value 4. The height
                   of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).
                 - Removing the subtree rooted at node with value 8. The height
                   of the tree becomes 2 (The path 5 -> 9 -> 3).

    Constraints:
    * The number of nodes in the tree is n.
    * 2 <= n <= 10^5
    * 1 <= Node.val <= n
    * All the values in the tree are unique.
    * m == queries.length
    * 1 <= m <= min(n, 10^4)
    * 1 <= queries[i] <= n
    * queries[i] != root.val*/

    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {
        unordered_map<int, int> depth, height;

        function<int(TreeNode*, int d)> fn = [&](TreeNode* node, int d) {
            if (!node) return 0;
            depth[node->val] = d;
            height[node->val] = 1 + max(fn(node->left, d+1), fn(node->right, d+1));
            return height[node->val];
        };
        int h = fn(root, 0);
        vector<vector<int>> level(h, vector<int>(2));

        for (auto& [k, v] : depth) {
            if (height[k] >= height[level[v][0]]) level[v] = {k, level[v][0]};
            else if (height[k] > height[level[v][1]]) level[v][1] = k;
        }
        vector<int> ans;
        for (auto& q : queries) {
            int d = depth[q];
            if (q == level[d][0]) ans.push_back(h-1-height[q]+height[level[d][1]]);
            else ans.push_back(h-1);
        }
        return ans;
    }


    /*2460. Apply Operations to an Array (Easy)
    You are given a 0-indexed array nums of size n consisting of non-negative
    integers. You need to apply n - 1 operations to this array where, in the
    ith operation (0-indexed), you will apply the following on the ith element
    of nums:
    * If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1]
      to 0. Otherwise, you skip this operation.
    After performing all the operations, shift all the 0's to the end of the
    array.
    * For example, the array [1,0,2,0,0,1] after shifting all its 0's to the
      end, is [1,2,1,0,0,0].
    Return the resulting array. Note that the operations are applied
    sequentially, not all at once.

    Example 1:
    Input: nums = [1,2,2,1,1,0]
    Output: [1,4,2,0,0,0]
    Explanation: We do the following operations:
                 - i = 0: nums[0] and nums[1] are not equal, so we skip this
                          operation.
                 - i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by
                          2 and change nums[2] to 0. The array becomes
                          [1,4,0,1,1,0].
                 - i = 2: nums[2] and nums[3] are not equal, so we skip this
                          operation.
                 - i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by
                          2 and change nums[4] to 0. The array becomes
                          [1,4,0,2,0,0].
                 - i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by
                          2 and change nums[5] to 0. The array becomes
                          [1,4,0,2,0,0].
                 After that, we shift the 0's to the end, which gives the array
                 [1,4,2,0,0,0].

    Example 2:
    Input: nums = [0,1]
    Output: [1,0]
    Explanation: No operation can be applied, we just shift the 0 to the end.

    Constraints:
    * 2 <= nums.length <= 2000
    * 0 <= nums[i] <= 1000*/

    vector<int> applyOperations(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for (int i = 0; i < n; ++i) {
            if (i+1 < n && nums[i] == nums[i+1]) {
                nums[i] *= 2;
                nums[i+1] = 0;
            }
            if (nums[i]) ans.push_back(nums[i]);
        }
        ans.resize(n);
        return ans;
    }


    /*2461. Maximum Sum of Distinct Subarrays With Length K (Medium)
    You are given an integer array nums and an integer k. Find the maximum
    subarray sum of all the subarrays of nums that meet the following
    conditions:
    * The length of the subarray is k, and
    * All the elements of the subarray are distinct.
    Return the maximum subarray sum of all the subarrays that meet the
    conditions. If no subarray meets the conditions, return 0. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,5,4,2,9,9,9], k = 3
    Output: 15
    Explanation: The subarrays of nums with length 3 are:
                 - [1,5,4] which meets the requirements and has a sum of 10.
                 - [5,4,2] which meets the requirements and has a sum of 11.
                 - [4,2,9] which meets the requirements and has a sum of 15.
                 - [2,9,9] which does not meet the requirements because the
                   element 9 is repeated.
                 - [9,9,9] which does not meet the requirements because the
                   element 9 is repeated.
                 We return 15 because it is the maximum subarray sum of all the
                 subarrays that meet the conditions

    Example 2:
    Input: nums = [4,4,4], k = 3
    Output: 0
    Explanation: The subarrays of nums with length 3 are:
                 - [4,4,4] which does not meet the requirements because the
                   element 4 is repeated.
                 We return 0 because no subarrays meet the conditions.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    long long maximumSubarraySum(vector<int>& nums, int k) {
        unordered_set<int> seen;
        long long ans = 0, rsm = 0;
        for (int i = 0, ii = 0; i < nums.size(); ++i) {
            while (seen.count(nums[i]) || i-ii == k) {
                seen.erase(nums[ii]);
                rsm -= nums[ii++];
            }
            seen.insert(nums[i]);
            rsm += nums[i];
            if (i-ii == k-1) ans = max(ans, rsm);
        }
        return ans;
    }


    /*2462. Total Cost to Hire K Workers (Medium)
    You are given a 0-indexed integer array costs where costs[i] is the cost of
    hiring the ith worker. You are also given two integers k and candidates. We
    want to hire exactly k workers according to the following rules:
    * You will run k sessions and hire exactly one worker in each session.
    * In each hiring session, choose the worker with the lowest cost from
      either the first candidates workers or the last candidates workers. Break
      the tie by the smallest index.
      + For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the
        first hiring session, we will choose the 4th worker because they have
        the lowest cost [3,2,7,7,1,2].
      + In the second hiring session, we will choose 1st worker because they
        have the same lowest cost as 4th worker but they have the smallest
        index [3,2,7,7,2]. Please note that the indexing may be changed in the
        process.
    * If there are fewer than candidates workers remaining, choose the worker
      with the lowest cost among them. Break the tie by the smallest index.
    * A worker can only be chosen once.
    Return the total cost to hire exactly k workers.

    Example 1:
    Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4
    Output: 11
    Explanation: We hire 3 workers in total. The total cost is initially 0.
                 - In the first hiring round we choose the worker from
                   [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break
                   the tie by the smallest index, which is 3. The total cost =
                   0 + 2 = 2.
                 - In the second hiring round we choose the worker from
                   [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The
                   total cost = 2 + 2 = 4.
                 - In the third hiring round we choose the worker from
                   [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The
                   total cost = 4 + 7 = 11. Notice that the worker with index 3
                   was common in the first and last four workers.
                 The total hiring cost is 11.

    Example 2:
    Input: costs = [1,2,4,1], k = 3, candidates = 3
    Output: 4
    Explanation: We hire 3 workers in total. The total cost is initially 0.
                 - In the first hiring round we choose the worker from [1,2,4,1].
                   The lowest cost is 1, and we break the tie by the smallest
                   index, which is 0. The total cost = 0 + 1 = 1. Notice that
                   workers with index 1 and 2 are common in the first and last
                   3 workers.
                 - In the second hiring round we choose the worker from [2,4,1].
                   The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.
                 - In the third hiring round there are less than three
                   candidates. We choose the worker from the remaining workers
                   [2,4]. The lowest cost is 2 (index 0). The total cost =
                   2 + 2 = 4.
                 The total hiring cost is 4.

    Constraints:
    * 1 <= costs.length <= 10^5
    * 1 <= costs[i] <= 10^5
    * 1 <= k, candidates <= costs.length*/

    long long totalCost(vector<int>& costs, int k, int candidates) {
        long long ans = 0;
        priority_queue<int, vector<int>, greater<>> q, qq;
        int n = costs.size(), i = candidates, ii = n-candidates-1;
        for (int i = 0; i < candidates; ++i) q.push(costs[i]);
        for (int i = max(candidates, n-candidates); i < n; ++i) qq.push(costs[i]);
        for (; k; --k)
            if (qq.empty() || (q.size() && q.top() <= qq.top())) {
                ans += q.top(); q.pop();
                if (i <= ii) q.push(costs[i++]);
            } else {
                ans += qq.top(); qq.pop();
                if (i <= ii) qq.push(costs[ii--]);
            }
        return ans;
    }


    /*2463. Minimum Total Distance Traveled (Hard)
    There are some robots and factories on the X-axis. You are given an integer
    array robot where robot[i] is the position of the ith robot. You are also
    given a 2D integer array factory where factory[j] = [positionj, limitj]
    indicates that positionj is the position of the jth factory and that the
    jth factory can repair at most limitj robots. The positions of each robot
    are unique. The positions of each factory are also unique. Note that a
    robot can be in the same position as a factory initially. All the robots
    are initially broken; they keep moving in one direction. The direction
    could be the negative or the positive direction of the X-axis. When a robot
    reaches a factory that did not reach its limit, the factory repairs the
    robot, and it stops moving. At any moment, you can set the initial
    direction of moving for some robot. Your target is to minimize the total
    distance traveled by all the robots. Return the minimum total distance
    traveled by all the robots. The test cases are generated such that all the
    robots can be repaired.

    Note that
    * All robots move at the same speed.
    * If two robots move in the same direction, they will never collide.
    * If two robots move in opposite directions and they meet at some point,
      they do not collide. They cross each other.
    * If a robot passes by a factory that reached its limits, it crosses it as
      if it does not exist.
    * If the robot moved from a position x to a position y, the distance it
      moved is |y - x|.

    Example 1:
    Input: robot = [0,4,6], factory = [[2,2],[6,2]]
    Output: 4
    Explanation: As shown in the figure:
                 - The first robot at position 0 moves in the positive
                   direction. It will be repaired at the first factory.
                 - The second robot at position 4 moves in the negative
                   direction. It will be repaired at the first factory.
                 - The third robot at position 6 will be repaired at the second
                   factory. It does not need to move.
                 The limit of the first factory is 2, and it fixed 2 robots.
                 The limit of the second factory is 2, and it fixed 1 robot.
                 The total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can
                 be shown that we cannot achieve a better total distance than 4.

    Example 2:
    Input: robot = [1,-1], factory = [[-2,1],[2,1]]
    Output: 2
    Explanation: As shown in the figure:
                 - The first robot at position 1 moves in the positive
                   direction. It will be repaired at the second factory.
                 - The second robot at position -1 moves in the negative
                   direction. It will be repaired at the first factory.
                 The limit of the first factory is 1, and it fixed 1 robot.
                 The limit of the second factory is 1, and it fixed 1 robot.
                 The total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be
                 shown that we cannot achieve a better total distance than 2.

    Constraints:
    * 1 <= robot.length, factory.length <= 100
    * factory[j].length == 2
    * -10^9 <= robot[i], positionj <= 10^9
    * 0 <= limitj <= robot.length
    * The input will be generated such that it is always possible to repair
      every robot.*/

    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {
        sort(robot.begin(), robot.end());
        sort(factory.begin(), factory.end());
        int m = robot.size(), n = factory.size();
        vector<vector<long long>> dp(m+1, vector<long long>(n+1));
        for (int i = 0; i < m; ++i) dp[i][n] = LONG_MAX;
        for (int j = n-1; j >= 0; --j) {
            long long prefix = 0;
            deque<pair<int, long long>> qq; qq.emplace_back(m, 0);
            for (int i = m-1; i >= 0; --i) {
                prefix += abs(robot[i] - factory[j][0]);
                if (qq.front().first > i+factory[j][1]) qq.pop_front();
                while (qq.size() && qq.back().second >= dp[i][j+1] - prefix) qq.pop_back();
                qq.emplace_back(i, dp[i][j+1] - prefix);
                dp[i][j] = qq.front().second + prefix;
            }
        }
        return dp[0][0];
    }


    /*2464. Minimum Subarrays in a Valid Split (Medium)
    You are given an integer array nums. Splitting of an integer array nums
    into subarrays is valid if:
    * the greatest common divisor of the first and last elements of each
      subarray is greater than 1, and
    * each element of nums belongs to exactly one subarray.
    Return the minimum number of subarrays in a valid subarray splitting of
    nums. If a valid subarray splitting is not possible, return -1.

    Note that:
    * The greatest common divisor of two numbers is the largest positive
      integer that evenly divides both numbers.
    * A subarray is a contiguous non-empty part of an array.

    Example 1:
    Input: nums = [2,6,3,4,3]
    Output: 2
    Explanation: We can create a valid split in the following way:
                 [2,6] | [3,4,3].
                 - The starting element of the 1st subarray is 2 and the ending
                   is 6. Their greatest common divisor is 2, which is greater
                   than 1.
                 - The starting element of the 2nd subarray is 3 and the ending
                   is 3. Their greatest common divisor is 3, which is greater
                   than 1.
                 It can be proved that 2 is the minimum number of subarrays
                 that we can obtain in a valid split.

    Example 2:
    Input: nums = [3,5]
    Output: 2
    Explanation: We can create a valid split in the following way: [3] | [5].
                 - The starting element of the 1st subarray is 3 and the ending
                   is 3. Their greatest common divisor is 3, which is greater
                   than 1.
                 - The starting element of the 2nd subarray is 5 and the ending
                   is 5. Their greatest common divisor is 5, which is greater
                   than 1.
                 It can be proved that 2 is the minimum number of subarrays
                 that we can obtain in a valid split.

    Example 3:
    Input: nums = [1,2,1]
    Output: -1
    Explanation: It is impossible to create valid split.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5*/

    int validSubarraySplit(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n+1, INT_MAX-1);
        dp.back() = 0;
        for (int i = n-1; i >= 0; --i)
            for (int j = i; j < n; ++j)
                if (gcd(nums[i], nums[j]) > 1) dp[i] = min(dp[i], 1+dp[j+1]);
        return dp[0] == INT_MAX-1 ? -1 : dp[0];
    }


    /*2465. Number of Distinct Averages (Easy)
    You are given a 0-indexed integer array nums of even length. As long as
    nums is not empty, you must repetitively:
    * Find the minimum number in nums and remove it.
    * Find the maximum number in nums and remove it.
    * Calculate the average of the two removed numbers.
    The average of two numbers a and b is (a + b) / 2. For example, the average
    of 2 and 3 is (2 + 3) / 2 = 2.5. Return the number of distinct averages
    calculated using the above process. Note that when there is a tie for a
    minimum or maximum number, any can be removed.

    Example 1:
    Input: nums = [4,1,4,0,3,5]
    Output: 2
    Explanation: 1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now,
                    nums = [4,1,4,3].
                 2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and
                    nums = [4,3].
                 3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.
                 Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we
                 return 2.

    Example 2:
    Input: nums = [1,100]
    Output: 1
    Explanation: There is only one average to be calculated after removing 1
                 and 100, so we return 1.

    Constraints:
    * 2 <= nums.length <= 100
    * nums.length is even.
    * 0 <= nums[i] <= 100*/

    int distinctAverages(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        unordered_set<float> seen;
        for (int i = 0, n = nums.size(); i < n/2; ++i)
            seen.insert((nums[i] + nums[n-1-i])/2.);
        return seen.size();
    }


    /*2466. Count Ways To Build Good Strings (Medium)
    Given the integers zero, one, low, and high, we can construct a string by
    starting with an empty string, and then at each step perform either of the
    following:
    * Append the character '0' zero times.
    * Append the character '1' one times.
    This can be performed any number of times. A good string is a string
    constructed by the above process having a length between low and high
    (inclusive). Return the number of different good strings that can be
    constructed satisfying these properties. Since the answer can be large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: low = 3, high = 3, zero = 1, one = 1
    Output: 8
    Explanation: One possible valid good string is "011". It can be constructed
                 as follows: "" -> "0" -> "01" -> "011". All binary strings
                 from "000" to "111" are good strings in this example.

    Example 2:
    Input: low = 2, high = 3, zero = 1, one = 2
    Output: 5
    Explanation: The good strings are "00", "11", "000", "110", and "011".

    Constraints:
    * 1 <= low <= high <= 10^5
    * 1 <= zero, one <= low*/

    int countGoodStrings(int low, int high, int zero, int one) {
        int MOD = 1'000'000'007;
        vector<long> dp(high+1);
        for (int i = high; i >= 0; --i) {
            if (low <= i) dp[i] = 1;
            if (i+zero <= high) dp[i] = (dp[i] + dp[i+zero]) % MOD;
            if (i+one <= high) dp[i] = (dp[i] + dp[i+one]) % MOD;
        }
        return dp[0];
    }


    /*2467. Most Profitable Path in a Tree (Medium)
    There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at
    node 0. You are given a 2D integer array edges of length n - 1 where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. At every node i, there is a gate. You are also given an array
    of even integers amount, where amount[i] represents:
    * the price needed to open the gate at node i, if amount[i] is negative, or,
    * the cash reward obtained on opening the gate at node i, otherwise.
    The game goes on as follows:
    * Initially, Alice is at node 0 and Bob is at node bob.
    * At every second, Alice and Bob each move to an adjacent node. Alice moves
      towards some leaf node, while Bob moves towards node 0.
    * For every node along their path, Alice and Bob either spend money to open
      the gate at that node, or accept the reward. Note that:
      + If the gate is already open, no price will be required, nor will there
        be any cash reward.
      + If Alice and Bob reach the node simultaneously, they share the
        price/reward for opening the gate there. In other words, if the price
        to open the gate is c, then both Alice and Bob pay c / 2 each.
        Similarly, if the reward at the gate is c, both of them receive c / 2
        each.
    * If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches
      node 0, he stops moving. Note that these events are independent of each
      other.
    Return the maximum net income Alice can have if she travels towards the
    optimal leaf node.

    Example 1:
    Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
    Output: 6
    Explanation: The above diagram represents the given tree. The game goes as
                 follows:
                 - Alice is initially on node 0, Bob on node 3. They open the
                   gates of their respective nodes. Alice's net income is now
                   -2.
                 - Both Alice and Bob move to node 1. Since they reach here
                   simultaneously, they open the gate together and share the
                   reward. Alice's net income becomes -2 + (4 / 2) = 0.
                 - Alice moves on to node 3. Since Bob already opened its gate,
                   Alice's income remains unchanged. Bob moves on to node 0,
                   and stops moving.
                 - Alice moves on to node 4 and opens the gate there. Her net
                   income becomes 0 + 6 = 6.
                 Now, neither Alice nor Bob can make any further moves, and the
                 game ends. It is not possible for Alice to get a higher net
                 income.

    Example 2:
    Input: edges = [[0,1]], bob = 1, amount = [-7280,2350]
    Output: -7280
    Explanation: Alice follows the path 0->1 whereas Bob follows the path 1->0.
                 Thus, Alice opens the gate at node 0 only. Hence, her net
                 income is -7280.

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * edges represents a valid tree.
    * 1 <= bob < n
    * amount.length == n
    * amount[i] is an even integer in the range [-10^4, 10^4].*/

    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {
        int n = 1 + edges.size();
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        vector<bool> seen(n);

        function<pair<int, int>(int, int)> dfs = [&](int u, int d) {
            seen[u] = true;
            int ans = INT_MIN;
            int dd = u == bob ? 0 : n;
            for (auto& v : tree[u])
                if (!seen[v]) {
                    auto [x, y] = dfs(v, d+1);
                    ans = max(ans, x);
                    dd = min(dd, y);
                }
            if (ans == INT_MIN) ans = 0;
            if (d == dd) ans += amount[u]/2;
            if (d < dd) ans += amount[u];
            return make_pair(ans, dd+1);
        };

        return dfs(0, 0).first;
    }


    /*2468. Split Message Based on Limit (Hard)
    You are given a string, message, and a positive integer, limit. You must
    split message into one or more parts based on limit. Each resulting part
    should have the suffix "<a/b>", where "b" is to be replaced with the total
    number of parts and "a" is to be replaced with the index of the part,
    starting from 1 and going up to b. Additionally, the length of each
    resulting part (including its suffix) should be equal to limit, except for
    the last part whose length can be at most limit. The resulting parts should
    be formed such that when their suffixes are removed and they are all
    concatenated in order, they should be equal to message. Also, the result
    should contain as few parts as possible. Return the parts message would be
    split into as an array of strings. If it is impossible to split message as
    required, return an empty array.

    Example 1:
    Input: message = "this is really a very awesome message", limit = 9
    Output: ["thi<1/14>","s i<2/14>","s r<3/14>","eal<4/14>","ly <5/14>","a v<6/14>","ery<7/14>"," aw<8/14>","eso<9/14>","me<10/14>"," m<11/14>","es<12/14>","sa<13/14>","ge<14/14>"]
    Explanation: The first 9 parts take 3 characters each from the beginning of
                 message. The next 5 parts take 2 characters each to finish
                 splitting message. In this example, each part, including the
                 last, has length 9. It can be shown it is not possible to
                 split message into less than 14 parts.

    Example 2:
    Input: message = "short message", limit = 15
    Output: ["short mess<1/2>","age<2/2>"]
    Explanation: Under the given constraints, the string can be split into two
                 parts:
                 - The first part comprises of the first 10 characters, and has
                   a length 15.
                 - The next part comprises of the last 3 characters, and has a
                   length 8.

    Constraints:
    * 1 <= message.length <= 10^4
    * message consists only of lowercase English letters and ' '.
    * 1 <= limit <= 10^4*/

    vector<string> splitMessage(string message, int limit) {
        int b = 0, cnt = 0;
        for (int prefix = 0; 3 + cnt*2 < limit && message.size() + prefix + (3+cnt)*b > limit * b; prefix += cnt)
            cnt = int(log10(++b)) + 1;
        vector<string> ans;
        if (3 + cnt*2 < limit)
            for (int i = 0, a = 1, step = 0; a <= b; ++a, i += step) {
                step = limit - (int(log10(a)) + int(log10(b)) + 5);
                ans.push_back(message.substr(i, step) + "<" + to_string(a) + "/" + to_string(b) + ">");
            }
        return ans;
    }


    /*2469. Convert the Temperature (Easy)
    You are given a non-negative floating point number rounded to two decimal
    places celsius, that denotes the temperature in Celsius. You should convert
    Celsius into Kelvin and Fahrenheit and return it as an array
    ans = [kelvin, fahrenheit]. Return the array ans. Answers within 10-5 of
    the actual answer will be accepted.

    Note that:
    * Kelvin = Celsius + 273.15
    * Fahrenheit = Celsius * 1.80 + 32.00

    Example 1:
    Input: celsius = 36.50
    Output: [309.65000,97.70000]
    Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and
                 converted in Fahrenheit is 97.70.

    Example 2:
    Input: celsius = 122.11
    Output: [395.26000,251.79800]
    Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26
                 and converted in Fahrenheit is 251.798.

    Constraints: 0 <= celsius <= 1000*/

    vector<double> convertTemperature(double celsius) {
        return {celsius+273.15, 1.8*celsius+32};
    }


    /*2470. Number of Subarrays With LCM Equal to K (Medium)
    Given an integer array nums and an integer k, return the number of
    subarrays of nums where the least common multiple of the subarray's
    elements is k. A subarray is a contiguous non-empty sequence of elements
    within an array. The least common multiple of an array is the smallest
    positive integer that is divisible by all the array elements.

    Example 1:
    Input: nums = [3,6,2,7,1], k = 6
    Output: 4
    Explanation: The subarrays of nums where 6 is the least common multiple of
                 all the subarray's elements are:
                 - [3,6,2,7,1]
                 - [3,6,2,7,1]
                 - [3,6,2,7,1]
                 - [3,6,2,7,1]

    Example 2:
    Input: nums = [3], k = 2
    Output: 0
    Explanation: There are no subarrays of nums where 2 is the least common
                 multiple of all the subarray's elements.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i], k <= 1000*/

    int subarrayLCM(vector<int>& nums, int k) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (auto& x : nums) {
            unordered_map<int, int> temp;
            if (k % x == 0) {
                for (auto& [kk, v] : freq)
                    temp[lcm(kk, x)] += v;
                ++temp[x];
                ans += temp[k];
            }
            freq = temp;
        }
        return ans;
    }


    /*2471. Minimum Number of Operations to Sort a Binary Tree by Level (Medium)
    You are given the root of a binary tree with unique values. In one
    operation, you can choose any two nodes at the same level and swap their
    values. Return the minimum number of operations needed to make the values
    at each level sorted in a strictly increasing order. The level of a node is
    the number of edges along the path between it and the root node.

    Example 1:
    Input: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]
    Output: 3
    Explanation: - Swap 4 and 3. The 2nd level becomes [3,4].
                 - Swap 7 and 5. The 3rd level becomes [5,6,8,7].
                 - Swap 8 and 7. The 3rd level becomes [5,6,7,8].
                 We used 3 operations so return 3. It can be proven that 3 is
                 the minimum number of operations needed.

    Example 2:
    Input: root = [1,3,2,7,6,5,4]
    Output: 3
    Explanation: - Swap 3 and 2. The 2nd level becomes [2,3].
                 - Swap 7 and 4. The 3rd level becomes [4,6,5,7].
                 - Swap 6 and 5. The 3rd level becomes [4,5,6,7].
                 We used 3 operations so return 3. It can be proven that 3 is
                 the minimum number of operations needed.

    Example 3:
    Input: root = [1,2,3,4,5,6]
    Output: 0
    Explanation: Each level is already sorted in increasing order so return 0.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5
    * All the values of the tree are unique.*/

    int minimumOperations(TreeNode* root) {
        int ans = 0;
        queue<TreeNode*> q; q.push(root);
        while (q.size()) {
            vector<int> vals;
            for (int sz = q.size(); sz; --sz) {
                TreeNode* node = q.front(); q.pop();
                vals.push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            vector<int> perm(vals.size());
            iota(perm.begin(), perm.end(), 0);
            sort(perm.begin(), perm.end(), [&](auto& lhs, auto& rhs) {return vals[lhs] < vals[rhs];});
            for (int i = 0; i < perm.size(); ++i)
                for (; i != perm[i]; ++ans)
                    swap(perm[i], perm[perm[i]]);
        }
        return ans;
    }


    /*2472. Maximum Number of Non-overlapping Palindrome Substrings (Hard)
    You are given a string s and a positive integer k. Select a set of non-
    overlapping substrings from the string s that satisfy the following
    conditions:
    * The length of each substring is at least k.
    * Each substring is a palindrome.
    Return the maximum number of substrings in an optimal selection. A
    substring is a contiguous sequence of characters within a string.

    Example 1:
    Input: s = "abaccdbbd", k = 3
    Output: 2
    Explanation: We can select the substrings underlined in s = "abaccdbbd".
                 Both "aba" and "dbbd" are palindromes and have a length of at
                 least k = 3. It can be shown that we cannot find a selection
                 with more than two valid substrings.

    Example 2:
    Input: s = "adbcda", k = 2
    Output: 0
    Explanation: There is no palindrome substring of length at least 2 in the
                 string.

    Constraints:
    * 1 <= k <= s.length <= 2000
    * s consists of lowercase English letters.*/

    int maxPalindromes(string s, int k) {
        vector<pair<int, int>> intervals;
        for (int i = 0, n = s.size(); i < 2*n-1; ++i)
            for (int lo = i/2, hi = (i+1)/2; 0 <= lo && hi < n && s[lo] == s[hi]; --lo, ++hi)
                if (hi-lo+1 >= k) {
                    intervals.emplace_back(lo, hi+1);
                    break;
                }
        int ans = 0, hi = 0;
        for (auto& [x, y] : intervals)
            if (x >= hi) {
                ++ans;
                hi = y;
            }
        return ans;
    }


    /*2473. Minimum Cost to Buy Apples (Medium)
    You are given a positive integer n representing n cities numbered from 1 to
    n. You are also given a 2D array roads, where roads[i] = [ai, bi, costi]
    indicates that there is a bidirectional road between cities ai and bi with
    a cost of traveling equal to costi. You can buy apples in any city you want,
    but some cities have different costs to buy apples. You are given the array
    appleCost where appleCost[i] is the cost of buying one apple from city i.
    You start at some city, traverse through various roads, and eventually buy
    exactly one apple from any city. After you buy that apple, you have to
    return back to the city you started at, but now the cost of all the roads
    will be multiplied by a given factor k. Given the integer k, return an
    array answer of size n where answer[i] is the minimum total cost to buy an
    apple if you start at city i.

    Example 1:
    Input: n = 4, roads = [[1,2,4],[2,3,2],[2,4,5],[3,4,1],[1,3,4]],
           appleCost = [56,42,102,301], k = 2
    Output: [54,42,48,51]
    Explanation: The minimum cost for each starting city is the following:
                 - Starting at city 1: You take the path 1 -> 2, buy an apple
                   at city 2, and finally take the path 2 -> 1. The total
                   cost is 4 + 42 + 4 * 2 = 54.
                 - Starting at city 2: You directly buy an apple at city 2.
                   The total cost is 42.
                 - Starting at city 3: You take the path 3 -> 2, buy an apple
                   at city 2, and finally take the path 2 -> 3. The total cost
                   is 2 + 42 + 2 * 2 = 48.
                 - Starting at city 4: You take the path 4 -> 3 -> 2 then you
                   buy at city 2, and finally take the path 2 -> 3 -> 4. The
                   total cost is 1 + 2 + 42 + 1 * 2 + 2 * 2 = 51.

    Example 2:
    Input: n = 3, roads = [[1,2,5],[2,3,1],[3,1,2]], appleCost = [2,3,1], k = 3
    Output: [2,3,1]
    Explanation: It is always optimal to buy the apple in the starting city.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= roads.length <= 1000
    * 1 <= ai, bi <= n
    * ai != bi
    * 1 <= costi <= 10^5
    * appleCost.length == n
    * 1 <= appleCost[i] <= 10^5
    * 1 <= k <= 100
    * There are no repeated edges.*/

    vector<long long> minCost(int n, vector<vector<int>>& roads, vector<int>& appleCost, int k) {
        vector<vector<pair<int, int>>> graph(n);
        for (auto& r : roads) {
            graph[r[0]-1].emplace_back(r[1]-1, r[2]);
            graph[r[1]-1].emplace_back(r[0]-1, r[2]);
        }
        vector<long long> ans(n, LONG_MAX);
        for (int i = 0; i < n; ++i) {
            vector<long long> dist(n, LONG_MAX);
            dist[i] = 0;
            priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> pq;
            pq.emplace(0, i);
            while (pq.size()) {
                auto [x, u] = pq.top(); pq.pop();
                ans[i] = min(ans[i], appleCost[u] + (1+k)*x);
                for (auto& [v, w] : graph[u]) {
                    long long xx = x + w;
                    if (xx < dist[v]) {
                        dist[v] = xx;
                        pq.emplace(xx, v);
                    }
                }
            }
        }
        return ans;
    }


    /*2475. Number of Unequal Triplets in Array (Easy)
    You are given a 0-indexed array of positive integers nums. Find the number
    of triplets (i, j, k) that meet the following conditions:
    * 0 <= i < j < k < nums.length
    * nums[i], nums[j], and nums[k] are pairwise distinct.
      + In other words, nums[i] != nums[j], nums[i] != nums[k], and
        nums[j] != nums[k].
    Return the number of triplets that meet the conditions.

    Example 1:
    Input: nums = [4,4,2,4,3]
    Output: 3
    Explanation: The following triplets meet the conditions:
                 - (0, 2, 4) because 4 != 2 != 3
                 - (1, 2, 4) because 4 != 2 != 3
                 - (2, 3, 4) because 2 != 4 != 3
                 Since there are 3 triplets, we return 3. Note that (2, 0, 4)
                 is not a valid triplet because 2 > 0.

    Example 2:
    Input: nums = [1,1,1,1,1]
    Output: 0
    Explanation: No triplets meet the conditions so we return 0.

    Constraints:
    * 3 <= nums.length <= 100
    * 1 <= nums[i] <= 1000*/

    int unequalTriplets(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        int ans = 0, prefix = 0, suffix = nums.size();
        for (auto& [k, v] : freq) {
            suffix -= v;
            ans += prefix * v * suffix;
            prefix += v;
        }
        return ans;
    }


    /*2476. Closest Nodes Queries in a Binary Search Tree (Medium)
    You are given the root of a binary search tree and an array queries of size
    n consisting of positive integers. Find a 2D array answer of size n where
    answer[i] = [mini, maxi]:
    * mini is the largest value in the tree that is smaller than or equal to
      queries[i]. If a such value does not exist, add -1 instead.
    * maxi is the smallest value in the tree that is greater than or equal to
      queries[i]. If a such value does not exist, add -1 instead.
    Return the array answer.

    Example 1:
    Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]
    Output: [[2,2],[4,6],[15,-1]]
    Explanation: We answer the queries in the following way:
                 - The largest number that is smaller or equal than 2 in the
                   tree is 2, and the smallest number that is greater or equal
                   than 2 is still 2. So the answer for the first query is
                   [2,2].
                 - The largest number that is smaller or equal than 5 in the
                   tree is 4, and the smallest number that is greater or equal
                   than 5 is 6. So the answer for the second query is [4,6].
                 - The largest number that is smaller or equal than 16 in the
                   tree is 15, and the smallest number that is greater or equal
                   than 16 does not exist. So the answer for the third query is
                   [15,-1].

    Example 2:
    Input: root = [4,null,9], queries = [3]
    Output: [[-1,4]]
    Explanation: The largest number that is smaller or equal to 3 in the tree
                 does not exist, and the smallest number that is greater or
                 equal to 3 is 4. So the answer for the query is [-1,4].

    Constraints:
    * The number of nodes in the tree is in the range [2, 10^5].
    * 1 <= Node.val <= 10^6
    * n == queries.length
    * 1 <= n <= 10^5
    * 1 <= queries[i] <= 10^6*/

    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> vals;
        stack<TreeNode*> stk;
        TreeNode* node = root;
        while (node || stk.size())
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top(); stk.pop();
                vals.push_back(node->val);
                node = node->right;
            }
        vector<vector<int>> ans;
        for (auto& q : queries) {
            ans.push_back({-1, -1});
            auto lo = upper_bound(vals.begin(), vals.end(), q);
            if (vals.begin() != lo) ans.back()[0] = *prev(lo);
            auto hi = lower_bound(vals.begin(), vals.end(), q);
            if (hi != vals.end()) ans.back()[1] = *hi;
        }
        return ans;
    }


    /*2477. Minimum Fuel Cost to Report to the Capital (Medium)
    There is a tree (i.e., a connected, undirected graph with no cycles)
    structure country network consisting of n cities numbered from 0 to n - 1
    and exactly n - 1 roads. The capital city is city 0. You are given a 2D
    integer array roads where roads[i] = [ai, bi] denotes that there exists a
    bidirectional road connecting cities ai and bi. There is a meeting for the
    representatives of each city. The meeting is in the capital city. There is
    a car in each city. You are given an integer seats that indicates the
    number of seats in each car. A representative can use the car in their city
    to travel or change the car and ride with another representative. The cost
    of traveling between two cities is one liter of fuel. Return the minimum
    number of liters of fuel to reach the capital city.

    Example 1:
    Input: roads = [[0,1],[0,2],[0,3]], seats = 5
    Output: 3
    Explanation: - Representative1 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative2 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative3 goes directly to the capital with 1 liter of
                   fuel.
                 It costs 3 liters of fuel at minimum. It can be proven that 3
                 is the minimum number of liters of fuel needed.

    Example 2:
    Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
    Output: 7
    Explanation: - Representative2 goes directly to city 3 with 1 liter of fuel.
                 - Representative2 and representative3 go together to city 1
                   with 1 liter of fuel.
                 - Representative2 and representative3 go together to the
                   capital with 1 liter of fuel.
                 - Representative1 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative5 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative6 goes directly to city 4 with 1 liter of fuel.
                 - Representative4 and representative6 go together to the
                   capital with 1 liter of fuel.
                 It costs 7 liters of fuel at minimum. It can be proven that 7
                 is the minimum number of liters of fuel needed.

    Example 3:
    Input: roads = [], seats = 1
    Output: 0
    Explanation: No representatives need to travel to the capital city.

    Constraints:
    * 1 <= n <= 10^5
    * roads.length == n - 1
    * roads[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * roads represents a valid tree
    * 1 <= seats <= 10^5*/

    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {
        vector<vector<int>> graph(roads.size()+1);
        for (auto& r : roads) {
            graph[r[0]].push_back(r[1]);
            graph[r[1]].push_back(r[0]);
        }

        function<pair<long long, long long>(int, int)> dfs = [&](int u, int p) {
            long long ans = 0, ppl = 1;
            for (auto& v : graph[u])
                if (v != p) {
                    auto [x, y] = dfs(v, u);
                    ppl += x;
                    ans += y;
                }
            if (u) ans += (ppl + seats - 1)/seats;
            return make_pair(ppl, ans);
        };

        return dfs(0, -1).second;
    }


    /*2478. Number of Beautiful Partitions (Hard)
    You are given a string s that consists of the digits '1' to '9' and two
    integers k and minLength. A partition of s is called beautiful if:
    * s is partitioned into k non-intersecting substrings.
    * Each substring has a length of at least minLength.
    * Each substring starts with a prime digit and ends with a non-prime digit.
      Prime digits are '2', '3', '5', and '7', and the rest of the digits are
      non-prime.
    Return the number of beautiful partitions of s. Since the answer may be
    very large, return it modulo 10^9 + 7. A substring is a contiguous sequence
    of characters within a string.

    Example 1:
    Input: s = "23542185131", k = 3, minLength = 2
    Output: 3
    Explanation: There exists three ways to create a beautiful partition:
                 "2354 | 218 | 5131"
                 "2354 | 21851 | 31"
                 "2354218 | 51 | 31"

    Example 2:
    Input: s = "23542185131", k = 3, minLength = 3
    Output: 1
    Explanation: There exists one way to create a beautiful partition:
                 "2354 | 218 | 5131".

    Example 3:
    Input: s = "3312958", k = 3, minLength = 1
    Output: 1
    Explanation: There exists one way to create a beautiful partition:
                 "331 | 29 | 58".

    Constraints:
    * 1 <= k, minLength <= s.length <= 1000
    * s consists of the digits '1' to '9'.*/

    int beautifulPartitions(string s, int k, int minLength) {
        string prime = "2357";
        vector<vector<long>> dp(k, vector<long>(s.size()+1));
        if (prime.find(s[0]) != string::npos && prime.find(s.back()) == string::npos) {
            for (int j = 0; j <= s.size(); ++j) dp[0][j] = 1;
            for (int i = 1; i < k; ++i)
                for (int j = s.size()-1; j >= 0; --j) {
                    dp[i][j] = dp[i][j+1];
                    if (minLength <= j && j <= s.size()-minLength && prime.find(s[j-1]) == string::npos && prime.find(s[j]) != string::npos)
                        dp[i][j] = (dp[i][j] + dp[i-1][j+minLength]) % 1'000'000'007;
                }
        }
        return dp.back()[0];
    }


    /*2479. Maximum XOR of Two Non-Overlapping Subtrees (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. The root of the tree is the node labeled 0. Each node has an
    associated value. You are given an array values of length n, where values[i]
    is the value of the ith node. Select any two non-overlapping subtrees. Your
    score is the bitwise XOR of the sum of the values within those subtrees.
    Return the maximum possible score you can achieve. If it is impossible to
    find two nonoverlapping subtrees, return 0.

    Note that:
    * The subtree of a node is the tree consisting of that node and all of its
      descendants.
    * Two subtrees are non-overlapping if they do not share any common node.

    Example 1:
    Input: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5]
    Output: 24
    Explanation: Node 1's subtree has sum of values 16, while node 2's subtree
                 has sum of values 8, so choosing these nodes will yield a
                 score of 16 XOR 8 = 24. It can be proved that is the maximum
                 possible score we can obtain.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2]], values = [4,6,1]
    Output: 0
    Explanation: There is no possible way to select two non-overlapping
                 subtrees, so we just return 0.

    Constraints:
    * 2 <= n <= 5 * 10^4
    * edges.length == n - 1
    * 0 <= ai, bi < n
    * values.length == n
    * 1 <= values[i] <= 10^9
    * It is guaranteed that edges represents a valid tree.*/

    long long maxXor(int n, vector<vector<int>>& edges, vector<int>& values) {
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        vector<long> sum(n);

        function<long(int, int)> dfs = [&](int u, int p) {
            sum[u] = values[u];
            for (auto& v : tree[u])
                if (v != p) sum[u] += dfs(v, u);
            return sum[u];
        };

        dfs(0, -1);

        struct TrieNode {
            TrieNode* child[2] = {nullptr};
            long val = 0;
        };

        TrieNode* trie = new TrieNode();

        function<long(int, int)> calc = [&](int u, int p) {
            long ans = 0;
            if (trie->child[0] || trie->child[1]) {
                TrieNode* node = trie;
                for (int i = 45; i >= 0; --i) {
                    int b = (sum[u] >> i) & 1;
                    if (node->child[1-b]) node = node->child[1-b];
                    else node = node->child[b];
                }
                ans = node->val ^ sum[u];
            }
            for (auto& v : tree[u])
                if (v != p) ans = max(ans, calc(v, u));
            TrieNode* node = trie;
            for (int i = 45; i >= 0; --i) {
                int b = (sum[u] >> i) & 1;
                if (!node->child[b]) node->child[b] = new TrieNode();
                node = node->child[b];
            }
            node->val = sum[u];
            return ans;
        };

        return calc(0, -1);
    }


    /*2481. Minimum Cuts to Divide a Circle (Easy)
    A valid cut in a circle can be:
    * A cut that is represented by a straight line that touches two points on
      the edge of the circle and passes through its center, or
    * A cut that is represented by a straight line that touches one point on
      the edge of the circle and its center.
    Some valid and invalid cuts are shown in the figures below. Given the
    integer n, return the minimum number of cuts needed to divide a circle into
    n equal slices.

    Example 1:
    Input: n = 4
    Output: 2
    Explanation: The above figure shows how cutting the circle twice through
                 the middle divides it into 4 equal slices.

    Example 2:
    Input: n = 3
    Output: 3
    Explanation: At least 3 cuts are needed to divide the circle into 3 equal
                 slices. It can be shown that less than 3 cuts cannot result in
                 3 slices of equal size and shape. Also note that the first cut
                 will not divide the circle into distinct parts.

    Constraints: 1 <= n <= 100*/

    int numberOfCuts(int n) {
        if (n == 1) return 0;
        return n&1 ? n : n >> 1;
    }


    /*2482. Difference Between Ones and Zeros in Row and Column (Medium)
    You are given a 0-indexed m x n binary matrix grid. A 0-indexed m x n
    difference matrix diff is created with the following procedure:
    * Let the number of ones in the ith row be onesRowi.
    * Let the number of ones in the jth column be onesColj.
    * Let the number of zeros in the ith row be zerosRowi.
    * Let the number of zeros in the jth column be zerosColj.
    * diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
    Return the difference matrix diff.

    Example 1:
    Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
    Output: [[0,0,4],[0,0,4],[-2,-2,2]]
    Explanation: - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0
                   = 2 + 1 - 1 - 2 = 0
                 - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1
                   = 2 + 1 - 1 - 2 = 0
                 - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2
                   = 2 + 3 - 1 - 0 = 4
                 - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0
                   = 2 + 1 - 1 - 2 = 0
                 - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1
                   = 2 + 1 - 1 - 2 = 0
                 - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2
                   = 2 + 3 - 1 - 0 = 4
                 - diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0
                   = 1 + 1 - 2 - 2 = -2
                 - diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1
                   = 1 + 1 - 2 - 2 = -2
                 - diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2
                   = 1 + 3 - 2 - 0 = 2

    Example 2:
    Input: grid = [[1,1,1],[1,1,1]]
    Output: [[5,5,5],[5,5,5]]
    Explanation: - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0
                   = 3 + 2 - 0 - 0 = 5
                 - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1
                   = 3 + 2 - 0 - 0 = 5
                 - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2
                   = 3 + 2 - 0 - 0 = 5
                 - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0
                   = 3 + 2 - 0 - 0 = 5
                 - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1
                   = 3 + 2 - 0 - 0 = 5
                 - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2
                   = 3 + 2 - 0 - 0 = 5

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * grid[i][j] is either 0 or 1.*/

    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> row(m), col(n);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                row[i] += grid[i][j];
                col[j] += grid[i][j];
            }
        vector<vector<int>> ans(m, vector<int>(n));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                ans[i][j] = 2*row[i] + 2*col[j] - m - n;
        return ans;
    }


    /*2483. Minimum Penalty for a Shop (Medium)
    You are given the customer visit log of a shop represented by a 0-indexed
    string customers consisting only of characters 'N' and 'Y':
    * if the ith character is 'Y', it means that customers come at the ith hour
    * whereas 'N' indicates that no customers come at the ith hour.
    If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated
    as follows:
    * For every hour when the shop is open and no customers come, the penalty
      increases by 1.
    * For every hour when the shop is closed and customers come, the penalty
      increases by 1.
    Return the earliest hour at which the shop must be closed to incur a
    minimum penalty. Note that if a shop closes at the jth hour, it means the
    shop is closed at the hour j.

    Example 1:
    Input: customers = "YYNY"
    Output: 2
    Explanation: - Closing the shop at the 0th hour incurs in 1+1+0+1 = 3
                   penalty.
                 - Closing the shop at the 1st hour incurs in 0+1+0+1 = 2
                   penalty.
                 - Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1
                   penalty.
                 - Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2
                   penalty.
                 - Closing the shop at the 4th hour incurs in 0+0+1+0 = 1
                   penalty.
                 Closing the shop at 2nd or 4th hour gives a minimum penalty.
                 Since 2 is earlier, the optimal closing time is 2.

    Example 2:
    Input: customers = "NNNNN"
    Output: 0
    Explanation: It is best to close the shop at the 0th hour as no customers
                 arrive.

    Example 3:
    Input: customers = "YYYY"
    Output: 4
    Explanation: It is best to close the shop at the 4th hour as customers
                 arrive at each hour.

    Constraints:
    * 1 <= customers.length <= 10^5
    * customers consists only of characters 'Y' and 'N'.*/

    int bestClosingTime(string customers) {
        int ans = 0, prefix = count(customers.begin(), customers.end(), 'Y'), least = prefix;
        for (int i = 0; i < customers.size(); ++i) {
            if (customers[i] == 'N') ++prefix;
            else --prefix;
            if (prefix < least) ans = i+1, least = prefix;
        }
        return ans;
    }


    /*2484. Count Palindromic Subsequences (Hard)
    Given a string of digits s, return the number of palindromic subsequences
    of s having length 5. Since the answer may be very large, return it modulo
    10^9 + 7.

    Note:
    * A string is palindromic if it reads the same forward and backward.
    * A subsequence is a string that can be derived from another string by
      deleting some or no characters without changing the order of the
      remaining characters.

    Example 1:
    Input: s = "103301"
    Output: 2
    Explanation: There are 6 possible subsequences of length 5: "10330","10331",
                 "10301","10301","13301","03301". Two of them (both equal to
                 "10301") are palindromic.

    Example 2:
    Input: s = "0000000"
    Output: 21
    Explanation: All 21 subsequences are "00000", which is palindromic.

    Example 3:
    Input: s = "9999900000"
    Output: 2
    Explanation: The only two palindromic subsequences are "99999" and "00000".

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of digits.*/

    int countPalindromes(string s) {
        const int mod = 1'000'000'007;
        int n = s.size();
        long ans = 0;
        for (int x = 0; x <= 9; ++x)
            for (int y = 0; y <= 9; ++y) {
                vector<int> pattern = {x, y, 0, y, x};
                vector<long> dp(6);
                dp[5] = 1;
                for (int i = 0; i < n; ++i)
                    for (int j = 0; j < 5; ++j)
                        if (s[i] == pattern[j] + '0' || j == 2) dp[j] = (dp[j] + dp[j+1]) % mod;
                ans = (ans + dp[0]) % mod;
            }
        return ans;
    }


    /*2485. Find the Pivot Integer (Easy)
    Given a positive integer n, find the pivot integer x such that:
    * The sum of all elements between 1 and x inclusively equals the sum of all
      elements between x and n inclusively.
    Return the pivot integer x. If no such integer exists, return -1. It is
    guaranteed that there will be at most one pivot index for the given input.

    Example 1:
    Input: n = 8
    Output: 6
    Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.

    Example 2:
    Input: n = 1
    Output: 1
    Explanation: 1 is the pivot integer since: 1 = 1.

    Example 3:
    Input: n = 4
    Output: -1
    Explanation: It can be proved that no such integer exist.

    Constraints: 1 <= n <= 1000*/

    int pivotInteger(int n) {
        int total = n*(n+1)/2, val = sqrt(total);
        return pow(val, 2) == total ? val : -1;
    }


    /*2486. Append Characters to String to Make Subsequence (Medium)
    You are given two strings s and t consisting of only lowercase English
    letters. Return the minimum number of characters that need to be appended
    to the end of s so that t becomes a subsequence of s. A subsequence is a
    string that can be derived from another string by deleting some or no
    characters without changing the order of the remaining characters.

    Example 1:
    Input: s = "coaching", t = "coding"
    Output: 4
    Explanation: Append the characters "ding" to the end of s so that
                 s = "coachingding". Now, t is a subsequence of s
                 ("coachingding"). It can be shown that appending any 3
                 characters to the end of s will never make t a subsequence.

    Example 2:
    Input: s = "abcde", t = "a"
    Output: 0
    Explanation: t is already a subsequence of s ("abcde").

    Example 3:
    Input: s = "z", t = "abcde"
    Output: 5
    Explanation: Append the characters "abcde" to the end of s so that
                 s = "zabcde". Now, t is a subsequence of s ("zabcde"). It can
                 be shown that appending any 4 characters to the end of s will
                 never make t a subsequence.

    Constraints:
    * 1 <= s.length, t.length <= 10^5
    * s and t consist only of lowercase English letters.*/

    int appendCharacters(string s, string t) {
        int i = 0;
        for (auto& ch : s)
            if (i < t.size() && ch == t[i]) ++i;
        return t.size() - i;
    }


    /*2487. Remove Nodes From Linked List (Medium)
    You are given the head of a linked list. Remove every node which has a node
    with a strictly greater value anywhere to the right side of it. Return the
    head of the modified linked list.

    Example 1:
    Input: head = [5,2,13,3,8]
    Output: [13,8]
    Explanation: The nodes that should be removed are 5, 2 and 3.
                 - Node 13 is to the right of node 5.
                 - Node 13 is to the right of node 2.
                 - Node 8 is to the right of node 3.

    Example 2:
    Input: head = [1,1,1,1]
    Output: [1,1,1,1]
    Explanation: Every node has value 1, so no nodes are removed.

    Constraints:
    * The number of the nodes in the given list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5*/

    ListNode* removeNodes(ListNode* head) {
        deque<ListNode*> stk;
        for (ListNode* node = head; node; node = node->next) {
            while (stk.size() && stk.back()->val < node->val) stk.pop_back();
            if (stk.size()) stk.back()->next = node;
            stk.push_back(node);
        }
        return stk.front();
    }


    /*2488. Count Subarrays With Median K (Hard)
    You are given an array nums of size n consisting of distinct integers from
    1 to n and a positive integer k. Return the number of non-empty subarrays
    in nums that have a median equal to k.

    Note:
    * The median of an array is the middle element after sorting the array in
      ascending order. If the array is of even length, the median is the left
      middle element.
      + For example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1]
        is 4.
    * A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [3,2,1,4,5], k = 4
    Output: 3
    Explanation: The subarrays that have a median equal to 4 are: [4], [4,5]
                 and [1,4,5].

    Example 2:
    Input: nums = [2,3,1], k = 3
    Output: 1
    Explanation: [3] is the only subarray that has a median equal to 3.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 1 <= nums[i], k <= n
    * The integers in nums are distinct.*/

    int countSubarrays(vector<int>& nums, int k) {
        unordered_map<int, int> freq = {{0, 1}};
        int ans = 0, diff = 0;
        bool found = false;
        for (auto& x : nums) {
            if (x < k) --diff;
            else if (x > k) ++diff;
            else found = true;
            if (found) ans += freq[diff] + freq[diff-1];
            else ++freq[diff];
        }
        return ans;
    }


    /*2489. Number of Substrings With Fixed Ratio (Medium)
    You are given a binary string s, and two integers num1 and num2. num1 and
    num2 are coprime numbers. A ratio substring is a substring of s where the
    ratio between the number of 0's and the number of 1's in the substring is
    exactly num1 : num2.
    * For example, if num1 = 2 and num2 = 3, then "01011" and "1110000111" are
      ratio substrings, while "11000" is not.
    Return the number of non-empty ratio substrings of s.

    Note that:
    * A substring is a contiguous sequence of characters within a string.
    * Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the
      greatest common divisor of x and y.

    Example 1:
    Input: s = "0110011", num1 = 1, num2 = 2
    Output: 4
    Explanation: There exist 4 non-empty ratio substrings.
                 - The substring s[0..2]: "0110011". It contains one 0 and two
                   1's. The ratio is 1 : 2.
                 - The substring s[1..4]: "0110011". It contains one 0 and two
                   1's. The ratio is 1 : 2.
                 - The substring s[4..6]: "0110011". It contains one 0 and two
                   1's. The ratio is 1 : 2.
                 - The substring s[1..6]: "0110011". It contains two 0's and
                   four 1's. The ratio is 2 : 4 == 1 : 2.
                 It can be shown that there are no more ratio substrings.

    Example 2:
    Input: s = "10101", num1 = 3, num2 = 1
    Output: 0
    Explanation: There is no ratio substrings of s. We return 0.

    Constraints:
    * 1 <= s.length <= 10^5
    * 1 <= num1, num2 <= s.length
    * num1 and num2 are coprime integers.*/

    long long fixedRatio(string s, int num1, int num2) {
        unordered_map<long long, int> freq = {{0, 1}};
        long long ans = 0, prefix = 0;
        for (auto& ch : s) {
            if (ch == '0') prefix += num2;
            else prefix -= num1;
            ans += freq[prefix];
            ++freq[prefix];
        }
        return ans;
    }


    /*2492. Minimum Score of a Path Between Two Cities (Medium)
    You are given a positive integer n representing n cities numbered from 1 to
    n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei]
    indicates that there is a bidirectional road between cities ai and bi with
    a distance equal to distancei. The cities graph is not necessarily
    connected. The score of a path between two cities is defined as the minimum
    distance of a road in this path. Return the minimum possible score of a
    path between cities 1 and n.

    Note:
    * A path is a sequence of roads between two cities.
    * It is allowed for a path to contain the same road multiple times, and you
      can visit cities 1 and n multiple times along the path.
    * The test cases are generated such that there is at least one path between
      1 and n.

    Example 1:
    Input: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]
    Output: 5
    Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 ->
                 4. The score of this path is min(9,5) = 5. It can be shown
                 that no other path has less score.

    Example 2:
    Input: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]
    Output: 2
    Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 ->
                 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= roads.length <= 10^5
    * roads[i].length == 3
    * 1 <= ai, bi <= n
    * ai != bi
    * 1 <= distancei <= 10^4
    * There are no repeated edges.
    * There is at least one path between 1 and n.*/

    int minScore(int n, vector<vector<int>>& roads) {
        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);

        function<int(int)> find = [&](int p) {
            if (p != parent[p]) parent[p] = find(parent[p]);
            return parent[p];
        };

        vector<int> mp(n, INT_MAX);
        for (auto& r : roads) {
            int uu = find(r[0]-1), vv = find(r[1]-1);
            parent[uu] = vv;
            mp[uu] = mp[vv] = min({mp[uu], mp[vv], r[2]});
        }
        return find(0) == find(n-1) ? mp[find(0)] : -1;
    }


    /*2495. Number of Subarrays Having Even Product (Medium)
    Given a 0-indexed integer array nums, return the number of subarrays of
    nums having an even product.

    Example 1:
    Input: nums = [9,6,7,13]
    Output: 6
    Explanation: There are 6 subarrays with an even product:
                 - nums[0..1] = 9 * 6 = 54.
                 - nums[0..2] = 9 * 6 * 7 = 378.
                 - nums[0..3] = 9 * 6 * 7 * 13 = 4914.
                 - nums[1..1] = 6.
                 - nums[1..2] = 6 * 7 = 42.
                 - nums[1..3] = 6 * 7 * 13 = 546.

    Example 2:
    Input: nums = [7,3,5]
    Output: 0
    Explanation: There are no subarrays with an even product.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    long long evenProduct(vector<int>& nums) {
        long long ans = 0;
        for (int i = 0, val = 0; i < nums.size(); ++i) {
            if (nums[i] % 2 == 0) val = i+1;
            ans += val;
        }
        return ans;
    }


    /*2496. Maximum Value of a String in an Array (Easy)
    The value of an alphanumeric string can be defined as:
    * The numeric representation of the string in base 10, if it comprises of
      digits only.
    * The length of the string, otherwise.
    Given an array strs of alphanumeric strings, return the maximum value of
    any string in strs.

    Example 1:
    Input: strs = ["alic3","bob","3","4","00000"]
    Output: 5
    Explanation: - "alic3" consists of both letters and digits, so its value is
                   its length, i.e. 5.
                 - "bob" consists only of letters, so its value is also its
                   length, i.e. 3.
                 - "3" consists only of digits, so its value is its numeric
                   equivalent, i.e. 3.
                 - "4" also consists only of digits, so its value is 4.
                 - "00000" consists only of digits, so its value is 0.
                 Hence, the maximum value is 5, of "alic3".

    Example 2:
    Input: strs = ["1","01","001","0001"]
    Output: 1
    Explanation: Each string in the array has value 1. Hence, we return 1.

    Constraints:
    * 1 <= strs.length <= 100
    * 1 <= strs[i].length <= 9
    * strs[i] consists of only lowercase English letters and digits.*/

    int maximumValue(vector<string>& strs) {
        int ans = 0;
        for (auto& word : strs) {
            bool digit = true;
            for (auto& ch : word)
                if ('a' <= ch && ch <= 'z') {
                    digit = false;
                    break;
                }
            if (digit) ans = max(ans, stoi(word));
            else ans = max(ans, (int) word.size());
        }
        return ans;
    }


    /*2497. Maximum Star Sum of a Graph (Medium)
    There is an undirected graph consisting of n nodes numbered from 0 to n - 1.
    You are given a 0-indexed integer array vals of length n where vals[i]
    denotes the value of the ith node. You are also given a 2D integer array
    edges where edges[i] = [ai, bi] denotes that there exists an undirected
    edge connecting nodes ai and bi. A star graph is a subgraph of the given
    graph having a center node containing 0 or more neighbors. In other words,
    it is a subset of edges of the given graph such that there exists a common
    node for all edges. The image below shows star graphs with 3 and 4
    neighbors respectively, centered at the blue node. The star sum is the sum
    of the values of all the nodes present in the star graph. Given an integer
    k, return the maximum star sum of a star graph containing at most k edges.

    Example 1:
    Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2
    Output: 16
    Explanation: The above diagram represents the input graph. The star graph
                 with the maximum star sum is denoted by blue. It is centered
                 at 3 and includes its neighbors 1 and 4. It can be shown it is
                 not possible to get a star graph with a sum greater than 16.

    Example 2:
    Input: vals = [-5], edges = [], k = 0
    Output: -5
    Explanation: There is only one possible star graph, which is node 0 itself.
                 Hence, we return -5.

    Constraints:
    * n == vals.length
    * 1 <= n <= 10^5
    * -10^4 <= vals[i] <= 10^4
    * 0 <= edges.length <= min(n * (n - 1) / 2, 10^5)
    * edges[i].length == 2
    * 0 <= ai, bi <= n - 1
    * ai != bi
    * 0 <= k <= n - 1*/

    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) {
        int n = vals.size();
        vector<vector<int>> graph(n);
        for (auto& e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }
        int ans = INT_MIN;
        for (int u = 0; u < n; ++u) {
            int cand = vals[u];
            if (graph[u].size() > k)
                nth_element(graph[u].begin(), graph[u].begin()+k, graph[u].end(), [&](auto& lhs, auto& rhs) {
                    return vals[lhs] > vals[rhs];
                });
            for (int i = 0; i < k && i < graph[u].size(); ++i)
                cand += max(0, vals[graph[u][i]]);
            ans = max(ans, cand);
        }
        return ans;
    }


    /*2498. Frog Jump II (Medium)
    You are given a 0-indexed integer array stones sorted in strictly
    increasing order representing the positions of stones in a river. A frog,
    initially on the first stone, wants to travel to the last stone and then
    return to the first stone. However, it can jump to any stone at most once.
    The length of a jump is the absolute difference between the position of the
    stone the frog is currently on and the position of the stone to which the
    frog jumps. More formally, if the frog is at stones[i] and is jumping to
    stones[j], the length of the jump is |stones[i] - stones[j]|. The cost of a
    path is the maximum length of a jump among all jumps in the path. Return
    the minimum cost of a path for the frog.

    Example 1:
    Input: stones = [0,2,5,6,7]
    Output: 5
    Explanation: The above figure represents one of the optimal paths the frog
                 can take. The cost of this path is 5, which is the maximum
                 length of a jump. Since it is not possible to achieve a cost
                 of less than 5, we return it.

    Example 2:
    Input: stones = [0,3,9]
    Output: 9
    Explanation: The frog can jump directly to the last stone and come back to
                 the first stone. In this case, the length of each jump will be
                 9. The cost for the path will be max(9, 9) = 9. It can be
                 shown that this is the minimum achievable cost.

    Constraints:
    * 2 <= stones.length <= 10^5
    * 0 <= stones[i] <= 10^9
    * stones[0] == 0
    * stones is sorted in a strictly increasing order.*/

    int maxJump(vector<int>& stones) {
        int ans = stones[1];
        for (int i = 2; i < stones.size(); ++i)
            ans = max(ans, stones[i] - stones[i-2]);
        return ans;
    }


    /*2499. Minimum Total Cost to Make Arrays Unequal (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2, of equal length
    n. In one operation, you can swap the values of any two indices of nums1.
    The cost of this operation is the sum of the indices. Find the minimum
    total cost of performing the given operation any number of times such that
    nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the
    operations. Return the minimum total cost such that nums1 and nums2 satisfy
    the above condition. In case it is not possible, return -1.

    Example 1:
    Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]
    Output: 10
    Explanation: One of the ways we can perform the operations is:
                 - Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3.
                   Now, nums1 = [4,2,3,1,5]
                 - Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3.
                   Now, nums1 = [4,3,2,1,5].
                 - Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4.
                   Now, nums1 =[5,3,2,1,4].
                 We can see that for each index i, nums1[i] != nums2[i]. The
                 cost required here is 10. Note that there are other ways to
                 swap values, but it can be proven that it is not possible to
                 obtain a cost less than 10.

    Example 2:
    Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]
    Output: 10
    Explanation: One of the ways we can perform the operations is:
                 - Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5.
                   Now, nums1 = [2,2,1,2,3].
                 - Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5.
                   Now, nums1 = [2,3,1,2,2].
                 The total cost needed here is 10, which is the minimum
                 possible.

    Example 3:
    Input: nums1 = [1,2,2], nums2 = [1,2,2]
    Output: -1
    Explanation: It can be shown that it is not possible to satisfy the given
                 conditions irrespective of the number of operations we
                 perform. Hence, we return -1.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= n*/

    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), total = 0;
        long long ans = 0;
        unordered_map<int, int> freq;
        for (int i = 0; i < n; ++i)
            if(nums1[i] == nums2[i]) {
                ++freq[nums1[i]];
                ++total;
                ans += i;
            }
        if (!total) return 0;
        auto [key, most] = *max_element(freq.begin(), freq.end(), [&](auto& lhs, auto& rhs) {return lhs.second < rhs.second;});
        for (int i = 0; i < n && 2*most > total; ++i)
            if (nums1[i] != nums2[i] && key != nums1[i] && key != nums2[i]) {
                ++total;
                ans += i;
            }
        return 2*most > total ? -1 : ans;
    }


    /*2500. Delete Greatest Value in Each Row (Easy)
    You are given an m x n matrix grid consisting of positive integers. Perform
    the following operation until grid becomes empty:
    * Delete the element with the greatest value from each row. If multiple
      such elements exist, delete any of them.
    * Add the maximum of deleted elements to the answer.
    Note that the number of columns decreases by one after each operation.
    Return the answer after performing the operations described above.

    Example 1:
    Input: grid = [[1,2,4],[3,3,1]]
    Output: 8
    Explanation: The diagram above shows the removed values in each step.
                 - In the first operation, we remove 4 from the first row and 3
                   from the second row (notice that, there are two cells with
                   value 3 and we can remove any of them). We add 4 to the
                   answer.
                 - In the second operation, we remove 2 from the first row and
                   3 from the second row. We add 3 to the answer.
                 - In the third operation, we remove 1 from the first row and 1
                   from the second row. We add 1 to the answer.
                 The final answer = 4 + 3 + 1 = 8.

    Example 2:
    Input: grid = [[10]]
    Output: 10
    Explanation: The diagram above shows the removed values in each step.
                 - In the first operation, we remove 10 from the first row. We
                   add 10 to the answer.
                 The final answer = 10.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * 1 <= grid[i][j] <= 100*/

    int deleteGreatestValue(vector<vector<int>>& grid) {
        for (auto& row : grid)
            sort(row.begin(), row.end());
        int ans = 0;
        for (int j = 0, n = grid[0].size(); j < n; ++j) {
            int val = 0;
            for (int i = 0, m = grid.size(); i < m; ++i)
                val = max(val, grid[i][j]);
            ans += val;
        }
        return ans;
    }


    /*2501. Longest Square Streak in an Array (Medium)
    You are given an integer array nums. A subsequence of nums is called a
    square streak if:
    * The length of the subsequence is at least 2, and
    * after sorting the subsequence, each element (except the first element) is
      the square of the previous number.
    Return the length of the longest square streak in nums, or return -1 if
    there is no square streak. A subsequence is an array that can be derived
    from another array by deleting some or no elements without changing the
    order of the remaining elements.

    Example 1:
    Input: nums = [4,3,6,16,8,2]
    Output: 3
    Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes
                 [2,4,16].
                 - 4 = 2 * 2.
                 - 16 = 4 * 4.
                 Therefore, [4,16,2] is a square streak. It can be shown that
                 every subsequence of length 4 is not a square streak.

    Example 2:
    Input: nums = [2,3,5,6,7]
    Output: -1
    Explanation: There is no square streak in nums so return -1.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 2 <= nums[i] <= 10^5*/

    int longestSquareStreak(vector<int>& nums) {
        vector<int> dp(100'001);
        sort(nums.begin(), nums.end());
        for (auto& x : nums) {
            dp[x] = max(1, dp[x]);
            int v = sqrt(x);
            if (v * v == x) dp[x] = 1 + dp[v];
        }
        int ans = *max_element(dp.begin(), dp.end());
        return ans > 1 ? ans : -1;
    }


    /*2503. Maximum Number of Points From Grid Queries (Hard)
    You are given an m x n integer matrix grid and an array queries of size k.
    Find an array answer of size k such that for each integer queres[i] you
    start in the top left cell of the matrix and repeat the following process:
    * If queries[i] is strictly greater than the value of the current cell that
      you are in, then you get one point if it is your first time visiting this
      cell, and you can move to any adjacent cell in all 4 directions: up, down,
      left, and right.
    * Otherwise, you do not get any points, and you end this process.
    After the process, answer[i] is the maximum number of points you can get.
    Note that for each query you are allowed to visit the same cell multiple
    times. Return the resulting array answer.

    Example 1:
    Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]
    Output: [5,8,1]
    Explanation: The diagrams above show which cells we visit to get points for
                 each query.

    Example 2:
    Input: grid = [[5,2,1],[1,1,2]], queries = [3]
    Output: [0]
    Explanation: We can not get any points because the value of the top left
                 cell is already greater than or equal to 3.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 1000
    * 4 <= m * n <= 10^5
    * k == queries.length
    * 1 <= k <= 10^4
    * 1 <= grid[i][j], queries[i] <= 10^6*/

    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {
        int m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1}, prefix = 0, prev = INT_MIN;
        vector<pair<int, int>> point;
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(grid[0][0], 0, 0);
        grid[0][0] = 0;
        while (pq.size()) {
            auto [v, i, j] = pq.top(); pq.pop();
            if (prev != v) point.emplace_back(prev, prefix);
            ++prefix;
            prev = v;
            for (int k = 0; k < 4; ++k) {
                int ii = i + dir[k], jj = j + dir[k+1];
                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj]) {
                    int vv = max(v, grid[ii][jj]);
                    pq.emplace(vv, ii, jj);
                    grid[ii][jj] = 0;
                }
            }
        }
        point.emplace_back(prev, prefix);
        vector<int> ans;
        for (auto& q : queries) {
            auto it = lower_bound(point.begin(), point.end(), make_pair(q, 0));
            ans.push_back((--it)->second);
        }
        return ans;
    }


    /*2505. Bitwise OR of All Subsequence Sums (Medium)
    Given an integer array nums, return the value of the bitwise OR of the sum
    of all possible subsequences in the array. A subsequence is a sequence that
    can be derived from another sequence by removing zero or more elements
    without changing the order of the remaining elements.

    Example 1:
    Input: nums = [2,1,0,3]
    Output: 7
    Explanation: All possible subsequence sums that we can have are:
                 0, 1, 2, 3, 4, 5, 6. And we have
                 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 = 7, so we return 7.

    Example 2:
    Input: nums = [0,0,0]
    Output: 0
    Explanation: 0 is the only possible subsequence sum we can have, so we
                 return 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9*/

    long long subsequenceSumOr(vector<int>& nums) {
        long long ans = 0, prefix = 0;
        for (auto& x : nums) {
            prefix += x;
            ans |= x | prefix;
        }
        return ans;
    }


    /*2506. Count Pairs Of Similar Strings (Easy)
    You are given a 0-indexed string array words. Two strings are similar if
    they consist of the same characters.
    * For example, "abca" and "cba" are similar since both consist of
      characters 'a', 'b', and 'c'.
    * However, "abacba" and "bcfd" are not similar since they do not consist of
      the same characters.
    Return the number of pairs (i, j) such that 0 <= i < j <= word.length - 1
    and the two strings words[i] and words[j] are similar.

    Example 1:
    Input: words = ["aba","aabb","abcd","bac","aabc"]
    Output: 2
    Explanation: There are 2 pairs that satisfy the conditions:
                 - i = 0 and j = 1 : both words[0] and words[1] only consist of
                   characters 'a' and 'b'.
                 - i = 3 and j = 4 : both words[3] and words[4] only consist of
                   characters 'a', 'b', and 'c'.

    Example 2:
    Input: words = ["aabb","ab","ba"]
    Output: 3
    Explanation: There are 3 pairs that satisfy the conditions:
                 - i = 0 and j = 1 : both words[0] and words[1] only consist of
                   characters 'a' and 'b'.
                 - i = 0 and j = 2 : both words[0] and words[2] only consist of
                   characters 'a' and 'b'.
                 - i = 1 and j = 2 : both words[1] and words[2] only consist of
                   characters 'a' and 'b'.

    Example 3:
    Input: words = ["nba","cba","dba"]
    Output: 0
    Explanation: Since there does not exist any pair that satisfies the
                 conditions, we return 0.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consist of only lowercase English letters.*/

    int similarPairs(vector<string>& words) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (auto& word : words) {
            int mask = 0;
            for (auto& c : word) mask |= 1 << (c-'a');
            ans += freq[mask]++;
        }
        return ans;
    }


    /*2507. Smallest Value After Replacing With Sum of Prime Factors (Medium)
    You are given a positive integer n. Continuously replace n with the sum of
    its prime factors.
    * Note that if a prime factor divides n multiple times, it should be
      included in the sum as many times as it divides n.
    Return the smallest value n will take on.

    Example 1:
    Input: n = 15
    Output: 5
    Explanation: Initially, n = 15.
                 15 = 3 * 5, so replace n with 3 + 5 = 8.
                 8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.
                 6 = 2 * 3, so replace n with 2 + 3 = 5.
                 5 is the smallest value n will take on.

    Example 2:
    Input: n = 3
    Output: 3
    Explanation: Initially, n = 3. 3 is the smallest value n will take on.

    Constraints: 2 <= n <= 10^5*/

    int smallestValue(int n) {
        while (true) {
            int sm = 0;
            for (int f = 2, nn = n; f <= nn; ++f)
                for (; nn % f == 0; nn /= f, sm += f);
            if (sm == n) break;
            n = sm;
        }
        return n;
    }


    /*2508. Add Edges to Make Degrees of All Nodes Even (Hard)
    There is an undirected graph consisting of n nodes numbered from 1 to n.
    You are given the integer n and a 2D array edges where edges[i] = [ai, bi]
    indicates that there is an edge between nodes ai and bi. The graph can be
    disconnected. You can add at most two additional edges (possibly none) to
    this graph so that there are no repeated edges and no self-loops. Return
    true if it is possible to make the degree of each node in the graph even,
    otherwise return false. The degree of a node is the number of edges
    connected to it.

    Example 1:
    Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]
    Output: true
    Explanation: The above diagram shows a valid way of adding an edge. Every
                 node in the resulting graph is connected to an even number of
                 edges.

    Example 2:
    Input: n = 4, edges = [[1,2],[3,4]]
    Output: true
    Explanation: The above diagram shows a valid way of adding two edges.

    Example 3:
    Input: n = 4, edges = [[1,2],[1,3],[1,4]]
    Output: false
    Explanation: It is not possible to obtain a valid graph with adding at most
                 2 edges.

    Constraints:
    * 3 <= n <= 10^5
    * 2 <= edges.length <= 10^5
    * edges[i].length == 2
    * 1 <= ai, bi <= n
    * ai != bi
    * There are no repeated edges.*/

    bool isPossible(int n, vector<vector<int>>& edges) {
        vector<unordered_set<int>> graph(n);
        for (auto& e : edges) {
            graph[e[0]-1].insert(e[1]-1);
            graph[e[1]-1].insert(e[0]-1);
        }
        vector<long> odd;
        for (int i = 0; i < n; ++i)
            if (graph[i].size() & 1) odd.push_back(i);
        return odd.size() == 0
            || odd.size() == 2 && any_of(graph.begin(), graph.end(), [&](auto& g) { return !g.count(odd[0]) && !g.count(odd[1]); })
            || odd.size() == 4 && (!graph[odd[0]].count(odd[1]) && !graph[odd[2]].count(odd[3]) || !graph[odd[0]].count(odd[2]) && !graph[odd[1]].count(odd[3]) || !graph[odd[0]].count(odd[3]) && !graph[odd[1]].count(odd[2]));
    }


    /*2509. Cycle Length Queries in a Tree (Hard)
    You are given an integer n. There is a complete binary tree with 2n - 1
    nodes. The root of that tree is the node with the value 1, and every node
    with a value val in the range [1, 2n - 1 - 1] has two children where:
    * The left node has the value 2 * val, and
    * The right node has the value 2 * val + 1.
    You are also given a 2D integer array queries of length m, where
    queries[i] = [ai, bi]. For each query, solve the following problem:
    * Add an edge between the nodes with values ai and bi.
    * Find the length of the cycle in the graph.
    * Remove the added edge between nodes with values ai and bi.
    Note that:
    * A cycle is a path that starts and ends at the same node, and each edge in
      the path is visited only once.
    * The length of a cycle is the number of edges visited in the cycle.
    * There could be multiple edges between two nodes in the tree after adding
      the edge of the query.
    Return an array answer of length m where answer[i] is the answer to the ith
    query.

    Example 1:
    Input: n = 3, queries = [[5,3],[4,7],[2,3]]
    Output: [4,5,3]
    Explanation: The diagrams above show the tree of 23 - 1 nodes. Nodes
                 colored in red describe the nodes in the cycle after adding
                 the edge.
                 - After adding the edge between nodes 3 and 5, the graph
                   contains a cycle of nodes [5,2,1,3]. Thus answer to the
                   first query is 4. We delete the added edge and process the
                   next query.
                 - After adding the edge between nodes 4 and 7, the graph
                   contains a cycle of nodes [4,2,1,3,7]. Thus answer to the
                   second query is 5. We delete the added edge and process the
                   next query.
                 - After adding the edge between nodes 2 and 3, the graph
                   contains a cycle of nodes [2,1,3]. Thus answer to the third
                   query is 3. We delete the added edge.

    Example 2:
    Input: n = 2, queries = [[1,2]]
    Output: [2]
    Explanation: The diagram above shows the tree of 22 - 1 nodes. Nodes
                 colored in red describe the nodes in the cycle after adding
                 the edge.
                 - After adding the edge between nodes 1 and 2, the graph
                   contains a cycle of nodes [2,1]. Thus answer for the first
                   query is 2. We delete the added edge.

    Constraints:
    * 2 <= n <= 30
    * m == queries.length
    * 1 <= m <= 10^5
    * queries[i].length == 2
    * 1 <= ai, bi <= 2n - 1
    * ai != bi*/

    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {
        vector<int> ans;
        for (auto& q : queries) {
            int dist = 1;
            for (int u = q[0], v = q[1]; u != v; u /= 2, ++dist)
                if (u < v) swap(u, v);
            ans.push_back(dist);
        }
        return ans;
    }


    /*2510. Check if There is a Path With Equal Number of 0's And 1's (Medium)
    You are given a 0-indexed m x n binary matrix grid. You can move from a
    cell (row, col) to any of the cells (row + 1, col) or (row, col + 1).
    Return true if there is a path from (0, 0) to (m - 1, n - 1) that visits an
    equal number of 0's and 1's. Otherwise return false.

    Example 1:
    Input: grid = [[0,1,0,0],[0,1,0,0],[1,0,1,0]]
    Output: true
    Explanation: The path colored in blue in the above diagram is a valid path
                 because we have 3 cells with a value of 1 and 3 with a value
                 of 0. Since there is a valid path, we return true.

    Example 2:
    Input: grid = [[1,1,0],[0,0,1],[1,0,0]]
    Output: false
    Explanation: There is no path in this grid with an equal number of 0's and
                 1's.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 100
    * grid[i][j] is either 0 or 1.*/

    bool isThereAPath(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        if ((m+n) & 1) {
            vector<vector<int>> lo(m, vector<int>(n, INT_MAX)), hi(m, vector<int>(n, INT_MIN));
            lo[0][0] = hi[0][0] = 2*grid[0][0]-1;
            for (int i = 0; i < m; ++i)
                for (int j = 0; j < n; ++j) {
                    if (i) {
                        lo[i][j] = min(lo[i][j], lo[i-1][j] + 2*grid[i][j]-1);
                        hi[i][j] = max(hi[i][j], hi[i-1][j] + 2*grid[i][j]-1);
                    }
                    if (j) {
                        lo[i][j] = min(lo[i][j], lo[i][j-1] + 2*grid[i][j]-1);
                        hi[i][j] = max(hi[i][j], hi[i][j-1] + 2*grid[i][j]-1);
                    }
                }
            return lo[m-1][n-1] <= 0 && 0 <= hi[m-1][n-1];
        }
        return false;
    }


    /*2511. Maximum Enemy Forts That Can Be Captured (Easy)
    You are given a 0-indexed integer array forts of length n representing the
    positions of several forts. forts[i] can be -1, 0, or 1 where:
    * -1 represents there is no fort at the ith position.
    * 0 indicates there is an enemy fort at the ith position.
    * 1 indicates the fort at the ith the position is under your command.
    Now you have decided to move your army from one of your forts at position i
    to an empty position j such that:
    * 0 <= i, j <= n - 1
    * The army travels over enemy forts only. Formally, for all k where
      min(i,j) < k < max(i,j), forts[k] == 0.
    While moving the army, all the enemy forts that come in the way are
    captured. Return the maximum number of enemy forts that can be captured. In
    case it is impossible to move your army, or you do not have any fort under
    your command, return 0.

    Example 1:
    Input: forts = [1,0,0,-1,0,0,0,0,1]
    Output: 4
    Explanation: - Moving the army from position 0 to position 3 captures 2
                   enemy forts, at 1 and 2.
                 - Moving the army from position 8 to position 3 captures 4
                   enemy forts.
                 Since 4 is the maximum number of enemy forts that can be
                 captured, we return 4.

    Example 2:
    Input: forts = [0,0,1,-1]
    Output: 0
    Explanation: Since no enemy fort can be captured, 0 is returned.

    Constraints:
    * 1 <= forts.length <= 1000
    * -1 <= forts[i] <= 1*/

    int captureForts(vector<int>& forts) {
        int ans = 0;
        for (int i = 0, ii = 0; i < forts.size(); ++i)
            if (forts[i]) {
                if (forts[ii] == -forts[i]) ans = max(ans, i-ii-1);
                ii = i;
            }
        return ans;
    }


    /*2512. Reward Top K Students (Medium)
    You are given two string arrays positive_feedback and negative_feedback,
    containing the words denoting positive and negative feedback, respectively.
    Note that no word is both positive and negative. Initially every student
    has 0 points. Each positive word in a feedback report increases the points
    of a student by 3, whereas each negative word decreases the points by 1.
    You are given n feedback reports, represented by a 0-indexed string array
    report and a 0-indexed integer array student_id, where student_id[i]
    represents the ID of the student who has received the feedback report
    report[i]. The ID of each student is unique. Given an integer k, return
    the top k students after ranking them in non-increasing order by their
    points. In case more than one student has the same points, the one with the
    lower ID ranks higher.

    Example 1:
    Input: positive_feedback = ["smart","brilliant","studious"],
           negative_feedback = ["not"],
           report = ["this student is studious","the student is smart"],
           student_id = [1,2], k = 2
    Output: [1,2]
    Explanation: Both the students have 1 positive feedback and 3 points but
                 since student 1 has a lower ID he ranks higher.

    Example 2:
    Input: positive_feedback = ["smart","brilliant","studious"],
           negative_feedback = ["not"],
           report = ["this student is not studious","the student is smart"],
           student_id = [1,2], k = 2
    Output: [2,1]
    Explanation: - The student with ID 1 has 1 positive feedback and 1 negative
                   feedback, so he has 3-1=2 points.
                 - The student with ID 2 has 1 positive feedback, so he has 3
                   points.
                 Since student 2 has more points, [2,1] is returned.

    Constraints:
    * 1 <= positive_feedback.length, negative_feedback.length <= 10^4
    * 1 <= positive_feedback[i].length, negative_feedback[j].length <= 100
    * Both positive_feedback[i] and negative_feedback[j] consists of lowercase
      English letters.
    * No word is present in both positive_feedback and negative_feedback.
    * n == report.length == student_id.length
    * 1 <= n <= 10^4
    * report[i] consists of lowercase English letters and spaces ' '.
    * There is a single space between consecutive words of report[i].
    * 1 <= report[i].length <= 100
    * 1 <= student_id[i] <= 10^9
    * All the values of student_id[i] are unique.
    * 1 <= k <= n*/

    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {
        unordered_set<string> positive(positive_feedback.begin(), positive_feedback.end()), negative(negative_feedback.begin(), negative_feedback.end());
        unordered_map<int, int> mp;
        for (int i = 0; i < report.size(); ++i) {
            istringstream iss(report[i]);
            string word;
            int point = 0;
            while (iss >> word)
                if (positive.count(word)) point += 3;
                else if (negative.count(word)) --point;
            mp[student_id[i]] = point;
        }
        vector<int> ans;
        for (auto& [x, v] : mp) ans.push_back(x);
        sort(ans.begin(), ans.end(), [&](auto& lhs, auto& rhs) { return mp[lhs] > mp[rhs] || (mp[lhs] == mp[rhs] && lhs < rhs); });
        ans.resize(k);
        return ans;
    }


    /*2513. Minimize the Maximum of Two Arrays (Medium)
    We have two arrays arr1 and arr2 which are initially empty. You need to add
    positive integers to them such that they satisfy all the following
    conditions:
    * arr1 contains uniqueCnt1 distinct positive integers, each of which is not
      divisible by divisor1.
    * arr2 contains uniqueCnt2 distinct positive integers, each of which is not
      divisible by divisor2.
    * No integer is present in both arr1 and arr2.
    Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum
    possible maximum integer that can be present in either array.

    Example 1:
    Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3
    Output: 4
    Explanation: We can distribute the first 4 natural numbers into arr1 and
                 arr2. arr1 = [1] and arr2 = [2,3,4]. We can see that both
                 arrays satisfy all the conditions. Since the maximum value is
                 4, we return it.

    Example 2:
    Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1
    Output: 3
    Explanation: Here arr1 = [1,2], and arr2 = [3] satisfy all conditions.
                 Since the maximum value is 3, we return it.

    Example 3:
    Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2
    Output: 15
    Explanation: Here, the final possible arrays can be
                 arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6]. It can be shown
                 that it is not possible to obtain a lower maximum satisfying
                 all conditions.

    Constraints:
    * 2 <= divisor1, divisor2 <= 10^5
    * 1 <= uniqueCnt1, uniqueCnt2 < 10^9
    * 2 <= uniqueCnt1 + uniqueCnt2 <= 10^9*/

    int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {
        long lo = 0, hi = INT_MAX, mult = lcm((long) divisor1, divisor2);
        while (lo < hi) {
            int mid = lo + (hi-lo)/2;
            if (uniqueCnt1 <= mid-mid/divisor1 && uniqueCnt2 <= mid-mid/divisor2 && uniqueCnt1+uniqueCnt2 <= mid-mid/mult) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }


    /*2514. Count Anagrams (Hard)
    You are given a string s containing one or more words. Every consecutive
    pair of words is separated by a single space ' '. A string t is an anagram
    of string s if the ith word of t is a permutation of the ith word of s.
    * For example, "acb dfe" is an anagram of "abc def", but "def cab" and
      "adc bef" are not.
    Return the number of distinct anagrams of s. Since the answer may be very
    large, return it modulo 10^9 + 7.

    Example 1:
    Input: s = "too hot"
    Output: 18
    Explanation: Some of the anagrams of the given string are "too hot",
                 "oot hot", "oto toh", "too toh", and "too oht".

    Example 2:
    Input: s = "aa"
    Output: 1
    Explanation: There is only one anagram possible for the given string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters and spaces ' '.
    * There is single space between consecutive words.*/

    int countAnagrams(string s) {
        const int mod = 1'000'000'007;
        int n = s.size();
        vector<long> fact(n+1, 1), ifact(n+1, 1), inv(n+1, 1);
        for (int x = 1; x <= n; ++x) {
            if (x >= 2) inv[x] = mod - mod/x * inv[mod%x] % mod;
            fact[x] = fact[x-1] * x % mod;
            ifact[x] = ifact[x-1] * inv[x] % mod;
        }
        long ans = 1;
        istringstream iss(s);
        string word;
        while (iss >> word) {
            ans = ans * fact[word.size()] % mod;
            vector<int> freq(26);
            for (auto& ch : word) ++freq[ch-'a'];
            for (auto& x : freq) ans = ans * ifact[x] % mod;
        }
        return ans;
    }


    /*2515. Shortest Distance to Target String in a Circular Array (Easy)
    You are given a 0-indexed circular string array words and a string target.
    A circular array means that the array's end connects to the array's
    beginning.
    * Formally, the next element of words[i] is words[(i + 1) % n] and the
      previous element of words[i] is words[(i - 1 + n) % n], where n is the
      length of words.
    Starting from startIndex, you can move to either the next word or the
    previous word with 1 step at a time. Return the shortest distance needed to
    reach the string target. If the string target does not exist in words,
    return -1.

    Example 1:
    Input: words = ["hello","i","am","leetcode","hello"], target = "hello", startIndex = 1
    Output: 1
    Explanation: We start from index 1 and can reach "hello" by
                 - moving 3 units to the right to reach index 4.
                 - moving 2 units to the left to reach index 4.
                 - moving 4 units to the right to reach index 0.
                 - moving 1 unit to the left to reach index 0.
                 The shortest distance to reach "hello" is 1.

    Example 2:
    Input: words = ["a","b","leetcode"], target = "leetcode", startIndex = 0
    Output: 1
    Explanation: We start from index 0 and can reach "leetcode" by
                 - moving 2 units to the right to reach index 3.
                 - moving 1 unit to the left to reach index 3.
                 The shortest distance to reach "leetcode" is 1.

    Example 3:
    Input: words = ["i","eat","leetcode"], target = "ate", startIndex = 0
    Output: -1
    Explanation: Since "ate" does not exist in words, we return -1.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] and target consist of only lowercase English letters.
    * 0 <= startIndex < words.length*/

    int closetTarget(vector<string>& words, string target, int startIndex) {
        int ans = INT_MAX ;
        for (int i = 0, n = words.size(); i < n; ++i)
            if (words[i] == target) {
                int dist = abs(i - startIndex);
                ans = min({ans, dist, n - dist});
            }
        return ans < INT_MAX ? ans : -1;
    }


    /*2516. Take K of Each Character From Left and Right (Medium)
    You are given a string s consisting of the characters 'a', 'b', and 'c' and
    a non-negative integer k. Each minute, you may take either the leftmost
    character of s, or the rightmost character of s. Return the minimum number
    of minutes needed for you to take at least k of each character, or return
    -1 if it is not possible to take k of each character.

    Example 1:
    Input: s = "aabaaaacaabc", k = 2
    Output: 8
    Explanation: Take three characters from the left of s. You now have two 'a'
                 characters, and one 'b' character. Take five characters from
                 the right of s. You now have four 'a' characters, two 'b'
                 characters, and two 'c' characters. A total of 3 + 5 = 8
                 minutes is needed. It can be proven that 8 is the minimum
                 number of minutes needed.

    Example 2:
    Input: s = "a", k = 1
    Output: -1
    Explanation: It is not possible to take one 'b' or 'c' so return -1.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of only the letters 'a', 'b', and 'c'.
    * 0 <= k <= s.length*/

    int takeCharacters(string s, int k) {
        int ans = INT_MAX;
        vector<int> freq(3);
        for (int i = 0, ii = 0, n = s.size(); i < 2*n; ++i) {
            ++freq[s[i%n] - 'a'];
            while (ii < n && i >= n-1 && freq[s[ii]-'a'] > k && *min_element(freq.begin(), freq.end()) >= k) {
                ans = min(ans, i-ii);
                --freq[s[ii++] - 'a'];
            }
        }
        return ans <= s.size() ? ans : -1;
    }


    /*2517. Maximum Tastiness of Candy Basket (Medium)
    You are given an array of positive integers price where price[i] denotes
    the price of the ith candy and a positive integer k. The store sells
    baskets of k distinct candies. The tastiness of a candy basket is the
    smallest absolute difference of the prices of any two candies in the basket.
    Return the maximum tastiness of a candy basket.

    Example 1:
    Input: price = [13,5,1,8,21,2], k = 3
    Output: 8
    Explanation: Choose the candies with the prices [13,5,21]. The tastiness of
                 the candy basket is:
                 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8. It can
                 be proven that 8 is the maximum tastiness that can be achieved.

    Example 2:
    Input: price = [1,3,1], k = 2
    Output: 2
    Explanation: Choose the candies with the prices [1,3]. The tastiness of the
                 candy basket is: min(|1 - 3|) = min(2) = 2. It can be proven
                 that 2 is the maximum tastiness that can be achieved.

    Example 3:
    Input: price = [7,7,7,7], k = 2
    Output: 0
    Explanation: Choosing any two distinct candies from the candies we have
                 will result in a tastiness of 0.

    Constraints:
    * 1 <= price.length <= 10^5
    * 1 <= price[i] <= 10^9
    * 2 <= k <= price.length*/

    int maximumTastiness(vector<int>& price, int k) {
        sort(price.begin(), price.end());
        int lo = 0, hi = price.back() - price[0];
        while (lo < hi) {
            int mid = lo+(hi-lo+1)/2, val = price[0], cnt = 0;
            for (auto& x : price)
                if (x >= val + mid) ++cnt, val = x;
            if (cnt >= k-1) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }


    /*2518. Number of Great Partitions (Hard)
    You are given an array nums consisting of positive integers and an integer
    k. Partition the array into two ordered groups such that each element is in
    exactly one group. A partition is called great if the sum of elements of
    each group is greater than or equal to k. Return the number of distinct
    great partitions. Since the answer may be too large, return it modulo
    10^9 + 7. Two partitions are considered distinct if some element nums[i] is
    in different groups in the two partitions.

    Example 1:
    Input: nums = [1,2,3,4], k = 4
    Output: 6
    Explanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]),
                 ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and
                 ([4], [1,2,3]).

    Example 2:
    Input: nums = [3,3,3], k = 4
    Output: 0
    Explanation: There are no great partitions for this array.

    Example 3:
    Input: nums = [6,6], k = 2
    Output: 2
    Explanation: We can either put nums[0] in the first partition or in the
                 second partition. The great partitions will be ([6], [6]) and
                 ([6], [6]).

    Constraints:
    * 1 <= nums.length, k <= 1000
    * 1 <= nums[i] <= 10^9*/

    int countPartitions(vector<int>& nums, int k) {
        const int mod = 1'000'000'007;
        long ans = 1, total = 0;
        vector<long> dp(k);
        dp[0] = 1;
        for (auto& x : nums) {
            ans = 2*ans % mod;
            total += x;
            for (int i = k-1-x; i >= 0; --i)
                dp[i+x] = (dp[i] + dp[i+x]) % mod;
        }
        ans -= 2*accumulate(dp.begin(), dp.end(), 0l);
        return total >= 2*k ? (ans % mod + mod) % mod : 0;
    }


    /*2519. Count the Number of K-Big Indices (Hard)
    You are given a 0-indexed integer array nums and a positive integer k. We
    call an index i k-big if the following conditions are satisfied:
    * There exist at least k different indices idx1 such that idx1 < i and
      nums[idx1] < nums[i].
    * There exist at least k different indices idx2 such that idx2 > i and
      nums[idx2] < nums[i].
    Return the number of k-big indices.

    Example 1:
    Input: nums = [2,3,6,5,2,3], k = 2
    Output: 2
    Explanation: There are only two 2-big indices in nums:
                 - i = 2 --> There are two valid idx1: 0 and 1. There are three
                             valid idx2: 2, 3, and 4.
                 - i = 3 --> There are two valid idx1: 0 and 1. There are two
                             valid idx2: 3 and 4.

    Example 2:
    Input: nums = [1,1,1], k = 3
    Output: 0
    Explanation: There are no 3-big indices in nums.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= nums.length*/

    int kBigIndices(vector<int>& nums, int k) {
        int n = nums.size();
        vector<bool> prefix(n);
        priority_queue<int> pq;
        for (int i = 0; i < n; ++i) {
            if (pq.size() == k && pq.top() < nums[i]) prefix[i] = true;
            pq.push(nums[i]);
            if (pq.size() > k) pq.pop();
        }
        int ans = 0;
        pq = priority_queue<int>();
        for (int i = n-1; i >= 0; --i) {
            if (pq.size() == k && pq.top() < nums[i] && prefix[i]) ++ans;
            pq.push(nums[i]);
            if (pq.size() > k) pq.pop();
        }
        return ans;
    }


    /*2520. Count the Digits That Divide a Number (Easy)
    Given an integer num, return the number of digits in num that divide num.
    An integer val divides nums if nums % val == 0.

    Example 1:
    Input: num = 7
    Output: 1
    Explanation: 7 divides itself, hence the answer is 1.

    Example 2:
    Input: num = 121
    Output: 2
    Explanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a
                 digit, we return 2.

    Example 3:
    Input: num = 1248
    Output: 4
    Explanation: 1248 is divisible by all of its digits, hence the answer is 4.

    Constraints:
    * 1 <= num <= 10^9
    * num does not contain 0 as one of its digits.*/

    int countDigits(int num) {
        int ans = 0;
        for (int n = num; n; n /= 10)
            if (num % (n % 10) == 0) ++ans;
        return ans;
    }


    /*2521. Distinct Prime Factors of Product of Array (Medium)
    Given an array of positive integers nums, return the number of distinct
    prime factors in the product of the elements of nums. Note that:
    * A number greater than 1 is called prime if it is divisible by only 1 and
      itself.
    * An integer val1 is a factor of another integer val2 if val2 / val1 is an
      integer.

    Example 1:
    Input: nums = [2,4,3,7,10,6]
    Output: 4
    Explanation: The product of all the elements in nums is:
                 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2^5 * 3^2 * 5 * 7.
                 There are 4 distinct prime factors so we return 4.

    Example 2:
    Input: nums = [2,4,8,16]
    Output: 1
    Explanation: The product of all the elements in nums is:
                 2 * 4 * 8 * 16 = 1024 = 2^10.
                 There is 1 distinct prime factor so we return 1.

    Constraints:
    * 1 <= nums.length <= 10^4
    * 2 <= nums[i] <= 1000*/

    int distinctPrimeFactors(vector<int>& nums) {
        unordered_set<int> seen;
        for (auto& x : nums) {
            for (int f = 2; f <= sqrt(x); ++f)
                for (; x % f == 0; x /= f)
                    seen.insert(f);
            if (1 < x) seen.insert(x);
        }
        return seen.size();
    }


    /*2522. Partition String Into Substrings With Values at Most K (Medium)
    You are given a string s consisting of digits from 1 to 9 and an integer k.
    A partition of a string s is called good if:
    * Each digit of s is part of exactly one substring.
    * The value of each substring is less than or equal to k.
    Return the minimum number of substrings in a good partition of s. If no
    good partition of s exists, return -1. Note that:
    * The value of a string is its result when interpreted as an integer. For
      example, the value of "123" is 123 and the value of "1" is 1.
    * A substring is a contiguous sequence of characters within a string.

    Example 1:
    Input: s = "165462", k = 60
    Output: 4
    Explanation: We can partition the string into substrings "16", "54", "6",
                 and "2". Each substring has a value less than or equal to
                 k = 60. It can be shown that we cannot partition the string
                 into less than 4 substrings.

    Example 2:
    Input: s = "238182", k = 5
    Output: -1
    Explanation: There is no good partition for this string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is a digit from '1' to '9'.
    * 1 <= k <= 10^9*/

    int minimumPartition(string s, int k) {
        int ans = 1;
        long val = 0;
        for (auto& ch : s) {
            if (10*val + (ch - '0') > k) {
                ++ans;
                val = 0;
            };
            val = 10*val + (ch - '0');
            if (val > k) return -1;
        }
        return ans;
    }


    /*2523. Closest Prime Numbers in Range (Medium)
    Given two positive integers left and right, find the two integers num1 and
    num2 such that:
    * left <= nums1 < nums2 <= right .
    * nums1 and nums2 are both prime numbers.
    * nums2 - nums1 is the minimum amongst all other pairs satisfying the above
      conditions.
    Return the positive integer array ans = [nums1, nums2]. If there are
    multiple pairs satisfying these conditions, return the one with the minimum
    nums1 value or [-1, -1] if such numbers do not exist. A number greater than
    1 is called prime if it is only divisible by 1 and itself.

    Example 1:
    Input: left = 10, right = 19
    Output: [11,13]
    Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.
                 The closest gap between any pair is 2, which can be achieved
                 by [11,13] or [17,19]. Since 11 is smaller than 17, we return
                 the first pair.

    Example 2:
    Input: left = 4, right = 6
    Output: [-1,-1]
    Explanation: There exists only one prime number in the given range, so the
                 conditions cannot be satisfied.

    Constraints: 1 <= left <= right <= 10^6*/

    vector<int> closestPrimes(int left, int right) {
        vector<bool> sieve(right+1, true);
        sieve[0] = sieve[1] = false;
        for (int x = 2; x <= sqrt(right); ++x)
            if (sieve[x])
                for (int xx = x*x; xx <= right; xx += x)
                    sieve[xx] = false;
        vector<int> ans = {-1, -1};
        int prev = 0, least = INT_MAX;
        for (int x = left; x <= right; ++x)
            if (sieve[x]) {
                if (prev && x - prev < least) {
                    ans = {prev, x};
                    least = x - prev;
                }
                prev = x;
            }
        return ans;
    }


    /*2524. Maximum Frequency Score of a Subarray (Hard)
    You are given an integer array nums and a positive integer k. The frequency
    score of an array is the sum of the distinct values in the array raised to
    the power of their frequencies, taking the sum modulo 10^9 + 7. For example,
    the frequency score of the array [5,4,5,7,4,4] is
    (4^3 + 5^2 + 7^1) modulo (10^9 + 7) = 96. Return the maximum frequency
    score of a subarray of size k in nums. You should maximize the value under
    the modulo and not the actual value. A subarray is a contiguous part of an
    array.

    Example 1:
    Input: nums = [1,1,1,2,1,2], k = 3
    Output: 5
    Explanation: The subarray [2,1,2] has a frequency score equal to 5. It can
                 be shown that it is the maximum frequency score we can have.

    Example 2:
    Input: nums = [1,1,1,1,1,1], k = 4
    Output: 1
    Explanation: All the subarrays of length 4 have a frequency score equal to
                 1.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    int maxFrequencyScore(vector<int>& nums, int k) {
        const int mod = 1'000'000'007;

        auto pow = [&](long x, int p) {
            long ans = 1;
            for (; p; p >>= 1) {
                if (p&1) ans = ans * x % mod;
                x = x * x % mod;
            }
            return ans;
        };

        long ans = 0, val = 0;
        unordered_map<int, int> freq;
        for (int i = 0; i < nums.size(); ++i) {
            if (freq[nums[i]]) val = (val - pow(nums[i], freq[nums[i]])) % mod;
            val = (val + pow(nums[i], ++freq[nums[i]])) % mod;
            if (i >= k) {
                val = (val - pow(nums[i-k], freq[nums[i-k]])) % mod;
                if (--freq[nums[i-k]]) val = (val + pow(nums[i-k], freq[nums[i-k]])) % mod;
            }
            val = (val + mod) % mod;
            if (i >= k-1) ans = max(ans, val);
        }
        return ans;
    }


    /*2525. Categorize Box According to Criteria (Easy)
    Given four integers length, width, height, and mass, representing the
    dimensions and mass of a box, respectively, return a string representing
    the category of the box.
    * The box is "Bulky" if:
      + Any of the dimensions of the box is greater or equal to 10^4.
      + Or, the volume of the box is greater or equal to 10^9.
    * If the mass of the box is greater or equal to 100, it is "Heavy".
    * If the box is both "Bulky" and "Heavy", then its category is "Both".
    * If the box is neither "Bulky" nor "Heavy", then its category is "Neither".
    * If the box is "Bulky" but not "Heavy", then its category is "Bulky".
    * If the box is "Heavy" but not "Bulky", then its category is "Heavy".
    Note that the volume of the box is the product of its length, width and
    height.

    Example 1:
    Input: length = 1000, width = 35, height = 700, mass = 300
    Output: "Heavy"
    Explanation: None of the dimensions of the box is greater or equal to 10^4.
                 Its volume = 24500000 <= 10^9. So it cannot be categorized as
                 "Bulky". However mass >= 100, so the box is "Heavy". Since the
                 box is not "Bulky" but "Heavy", we return "Heavy".

    Example 2:
    Input: length = 200, width = 50, height = 800, mass = 50
    Output: "Neither"
    Explanation: None of the dimensions of the box is greater or equal to 10^4.
                 Its volume = 8 * 10^6 <= 10^9. So it cannot be categorized as
                 "Bulky". Its mass is also less than 100, so it cannot be
                 categorized as "Heavy" either.  Since its neither of the two
                 above categories, we return "Neither".

    Constraints:
    * 1 <= length, width, height <= 10^5
    * 1 <= mass <= 10^3*/

    string categorizeBox(int length, int width, int height, int mass) {
        bool bulky = max({length, width, height}) >= 1e4 || (long long) length*width*height >= 1e9, heavy = mass >= 100;
        if (bulky && heavy) return "Both";
        if (bulky) return "Bulky";
        if (heavy) return "Heavy";
        return "Neither";
    }


    /*2527. Find Xor-Beauty of Array (Medium)
    You are given a 0-indexed integer array nums. The effective value of three
    indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]). The xor-
    beauty of the array is the XORing of the effective values of all the
    possible triplets of indices (i, j, k) where 0 <= i, j, k < n. Return the
    xor-beauty of nums. Note that:
    * val1 | val2 is bitwise OR of val1 and val2.
    * val1 & val2 is bitwise AND of val1 and val2.

    Example 1:
    Input: nums = [1,4]
    Output: 5
    Explanation: The triplets and their corresponding effective values are
                 listed below:
                 - (0,0,0) with effective value ((1 | 1) & 1) = 1
                 - (0,0,1) with effective value ((1 | 1) & 4) = 0
                 - (0,1,0) with effective value ((1 | 4) & 1) = 1
                 - (0,1,1) with effective value ((1 | 4) & 4) = 4
                 - (1,0,0) with effective value ((4 | 1) & 1) = 1
                 - (1,0,1) with effective value ((4 | 1) & 4) = 4
                 - (1,1,0) with effective value ((4 | 4) & 1) = 0
                 - (1,1,1) with effective value ((4 | 4) & 4) = 4
                 Xor-beauty of array will be bitwise XOR of all beauties =
                 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.

    Example 2:
    Input: nums = [15,45,20,2,34,35,5,44,32,30]
    Output: 34
    Explanation: The xor-beauty of the given array is 34.

    Constraints:
    1 <= nums.length <= 10^5
    1 <= nums[i] <= 10^9*/

    int xorBeauty(vector<int>& nums) {
        int val = 0;
        for (auto& x : nums) val ^= x;
        return (val | val) & val;
    }


    /*2528. Maximize the Minimum Powered City (Hard)
    You are given a 0-indexed integer array stations of length n, where
    stations[i] represents the number of power stations in the ith city. Each
    power station can provide power to every city in a fixed range. In other
    words, if the range is denoted by r, then a power station at city i can
    provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.
    * Note that |x| denotes absolute value. For example, |7 - 5| = 2 and
      |3 - 10| = 7.
    The power of a city is the total number of power stations it is being
    provided power from. The government has sanctioned building k more power
    stations, each of which can be built in any city, and have the same range
    as the pre-existing ones. Given the two integers r and k, return the
    maximum possible minimum power of a city, if the additional power stations
    are built optimally. Note that you can build the k power stations in
    multiple cities.

    Example 1:
    Input: stations = [1,2,4,5,0], r = 1, k = 2
    Output: 5
    Explanation: One of the optimal ways is to install both the power stations
                 at city 1. So stations will become [1,4,4,5,0].
                 - City 0 is provided by 1 + 4 = 5 power stations.
                 - City 1 is provided by 1 + 4 + 4 = 9 power stations.
                 - City 2 is provided by 4 + 4 + 5 = 13 power stations.
                 - City 3 is provided by 5 + 4 = 9 power stations.
                 - City 4 is provided by 5 + 0 = 5 power stations.
                 So the minimum power of a city is 5. Since it is not possible
                 to obtain a larger power, we return 5.

    Example 2:
    Input: stations = [4,4,4,4], r = 0, k = 3
    Output: 4
    Explanation: It can be proved that we cannot make the minimum power of a
                 city greater than 4.

    Constraints:
    * n == stations.length
    * 1 <= n <= 10^5
    * 0 <= stations[i] <= 10^5
    * 0 <= r <= n - 1
    * 0 <= k <= 10^9*/

    long long maxPower(vector<int>& stations, int r, int k) {
        int n = stations.size();
        long long lo = 0, hi = 2e10;
        while (lo < hi) {
            long long mid = lo + (hi-lo+1)/2, prefix = 0;
            int kk = k;
            bool ok = true;
            vector<int> ss = stations;
            for (int i = 0; i < n+r; ++i) {
                if (i < n) prefix += ss[i];
                if (i >= 2*r+1) prefix -= ss[i-2*r-1];
                if (i >= r && prefix < mid) {
                    if (kk < mid - prefix) {
                        ok = false;
                        break;
                    }
                    kk -= mid - prefix;
                    if (i < n) ss[i] += mid - prefix;
                    prefix = mid;
                }
            }
            if (ok) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*2529. Maximum Count of Positive Integer and Negative Integer (Easy)
    Given an array nums sorted in non-decreasing order, return the maximum
    between the number of positive integers and the number of negative integers.
    In other words, if the number of positive integers in nums is pos and the
    number of negative integers is neg, then return the maximum of pos and neg.
    Note that 0 is neither positive nor negative.

    Example 1:
    Input: nums = [-2,-1,-1,1,2,3]
    Output: 3
    Explanation: There are 3 positive integers and 3 negative integers. The
                 maximum count among them is 3.

    Example 2:
    Input: nums = [-3,-2,-1,0,0,1,2]
    Output: 3
    Explanation: There are 2 positive integers and 3 negative integers. The
                 maximum count among them is 3.

    Example 3:
    Input: nums = [5,20,66,1314]
    Output: 4
    Explanation: There are 4 positive integers and 0 negative integers. The
                 maximum count among them is 4.

    Constraints:
    * 1 <= nums.length <= 2000
    * -2000 <= nums[i] <= 2000
    * nums is sorted in a non-decreasing order.*/

    int maximumCount(vector<int>& nums) {
        int neg = lower_bound(nums.begin(), nums.end(), 0) - nums.begin(), pos = nums.end() - upper_bound(nums.begin(), nums.end(), 0);
        return max(neg, pos);
    }


    /*2530. Maximal Score After Applying K Operations (Medium)
    You are given a 0-indexed integer array nums and an integer k. You have a
    starting score of 0. In one operation:
    * choose an index i such that 0 <= i < nums.length,
    * increase your score by nums[i], and
    * replace nums[i] with ceil(nums[i] / 3).
    Return the maximum possible score you can attain after applying exactly k
    operations. The ceiling function ceil(val) is the least integer greater
    than or equal to val.

    Example 1:
    Input: nums = [10,10,10,10,10], k = 5
    Output: 50
    Explanation: Apply the operation to each array element exactly once. The
                 final score is 10 + 10 + 10 + 10 + 10 = 50.

    Example 2:
    Input: nums = [1,10,3,3,3], k = 3
    Output: 17
    Explanation: You can do the following operations:
                 Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your
                              score increases by 10.
                 Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your
                              score increases by 4.
                 Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your
                              score increases by 3.
                 The final score is 10 + 4 + 3 = 17.

    Constraints:
    * 1 <= nums.length, k <= 10^5
    * 1 <= nums[i] <= 10^9*/

    long long maxKelements(vector<int>& nums, int k) {
        long long ans = 0;
        priority_queue<int> pq(nums.begin(), nums.end());
        while (k--) {
            int val = pq.top(); pq.pop();
            ans += val;
            pq.push((val+2)/3);
        }
        return ans;
    }


    /*2531. Make Number of Distinct Characters Equal (Medium)
    You are given two 0-indexed strings word1 and word2. A move consists of
    choosing two indices i and j such that 0 <= i < word1.length and
    0 <= j < word2.length and swapping word1[i] with word2[j]. Return true if
    it is possible to get the number of distinct characters in word1 and word2
    to be equal with exactly one move. Return false otherwise.

    Example 1:
    Input: word1 = "ac", word2 = "b"
    Output: false
    Explanation: Any pair of swaps would yield two distinct characters in the
                 first string, and one in the second string.

    Example 2:
    Input: word1 = "abcc", word2 = "aab"
    Output: true
    Explanation: We swap index 2 of the first string with index 0 of the second
                 string. The resulting strings are word1 = "abac" and
                 word2 = "cab", which both have 3 distinct characters.

    Example 3:
    Input: word1 = "abcde", word2 = "fghij"
    Output: true
    Explanation: Both resulting strings will have 5 distinct characters,
                 regardless of which indices we swap.

    Constraints:
    * 1 <= word1.length, word2.length <= 10^5
    * word1 and word2 consist of only lowercase English letters.*/

    bool isItPossible(string word1, string word2) {
        unordered_map<int, int> freq1, freq2;
        for (auto& ch : word1) ++freq1[ch];
        for (auto& ch : word2) ++freq2[ch];
        int sz1 = freq1.size(), sz2 = freq2.size();
        for (char c1 = 'a'; c1 <= 'z'; ++c1)
            for (char c2 = 'a'; c2 <= 'z'; ++c2)
                if (freq1[c1] && freq2[c2])
                    if (c1 == c2) {
                        if (sz1 == sz2) return true;
                    } else {
                        int cnt1 = sz1, cnt2 = sz2;
                        if (freq1[c1] == 1) --cnt1;
                        if (freq1[c2] == 0) ++cnt1;
                        if (freq2[c1] == 0) ++cnt2;
                        if (freq2[c2] == 1) --cnt2;
                        if (cnt1 == cnt2) return true;
                    }
        return false;
    }


    /*2532. Time to Cross a Bridge (Hard)
    There are k workers who want to move n boxes from an old warehouse to a new
    one. You are given the two integers n and k, and a 2D integer array time of
    size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].
    The warehouses are separated by a river and connected by a bridge. The old
    warehouse is on the right bank of the river, and the new warehouse is on
    the left bank of the river. Initially, all k workers are waiting on the
    left side of the bridge. To move the boxes, the ith worker (0-indexed) can :
    * Cross the bridge from the left bank (new warehouse) to the right bank
      (old warehouse) in leftToRighti minutes.
    * Pick a box from the old warehouse and return to the bridge in pickOldi
      minutes. Different workers can pick up their boxes simultaneously.
    * Cross the bridge from the right bank (old warehouse) to the left bank
      (new warehouse) in rightToLefti minutes.
    * Put the box in the new warehouse and return to the bridge in putNewi
      minutes. Different workers can put their boxes simultaneously.
    A worker i is less efficient than a worker j if either condition is met:
    * leftToRighti + rightToLefti > leftToRightj + rightToLeftj
    * leftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j
    The following rules regulate the movement of the workers through the bridge :
    * If a worker x reaches the bridge while another worker y is crossing the
      bridge, x waits at their side of the bridge.
    * If the bridge is free, the worker waiting on the right side of the bridge
      gets to cross the bridge. If more than one worker is waiting on the right
      side, the one with the lowest efficiency crosses first.
    * If the bridge is free and no worker is waiting on the right side, and at
      least one box remains at the old warehouse, the worker on the left side
      of the river gets to cross the bridge. If more than one worker is waiting
      on the left side, the one with the lowest efficiency crosses first.
    Return the instance of time at which the last worker reaches the left bank
    of the river after all n boxes have been put in the new warehouse.

    Example 1:
    Input: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]
    Output: 6
    Explanation: From 0 to 1: worker 2 crosses the bridge from the left bank to
                              the right bank.
                 From 1 to 2: worker 2 picks up a box from the old warehouse.
                 From 2 to 6: worker 2 crosses the bridge from the right bank
                              to the left bank.
                 From 6 to 7: worker 2 puts a box at the new warehouse.
                 The whole process ends after 7 minutes. We return 6 because
                 the problem asks for the instance of time at which the last
                 worker reaches the left bank.

    Example 2:
    Input: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]
    Output: 50
    Explanation: From 0  to 10: worker 1 crosses the bridge from the left bank
                                to the right bank.
                 From 10 to 20: worker 1 picks up a box from the old warehouse.
                 From 10 to 11: worker 0 crosses the bridge from the left bank
                                to the right bank.
                 From 11 to 20: worker 0 picks up a box from the old warehouse.
                 From 20 to 30: worker 1 crosses the bridge from the right bank
                                to the left bank.
                 From 30 to 40: worker 1 puts a box at the new warehouse.
                 From 30 to 31: worker 0 crosses the bridge from the right bank
                                to the left bank.
                 From 31 to 39: worker 0 puts a box at the new warehouse.
                 From 39 to 40: worker 0 crosses the bridge from the left bank
                                to the right bank.
                 From 40 to 49: worker 0 picks up a box from the old warehouse.
                 From 49 to 50: worker 0 crosses the bridge from the right bank
                                to the left bank.
                 From 50 to 58: worker 0 puts a box at the new warehouse.
                 The whole process ends after 58 minutes. We return 50 because
                 the problem asks for the instance of time at which the last
                 worker reaches the left bank.

    Constraints:
    * 1 <= n, k <= 10^4
    * time.length == k
    * time[i].length == 4
    * 1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000*/

    int findCrossingTime(int n, int k, vector<vector<int>>& time) {
        int ans = 0, free = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> l, r;
        priority_queue<pair<int, int>> ll, rr;
        for (int i = 0; i < time.size(); ++i)
            ll.emplace(time[i][0]+time[i][2], i);
        while (n || r.size() || rr.size()) {
            if (rr.empty() && (r.empty() || r.top().first>free) && (!n || ll.empty() && (l.empty() || l.top().first>free))) {
                int cand = INT_MAX;
                if (n && l.size()) cand = min(cand, l.top().first);
                if (r.size()) cand = min(cand, r.top().first);
                free = cand;
            }
            while (l.size() && l.top().first <= free) {
                auto [_, i] = l.top(); l.pop();
                ll.emplace(time[i][0]+time[i][2], i);
            }
            while (r.size() && r.top().first <= free) {
                auto [_, i] = r.top(); r.pop();
                rr.emplace(time[i][0]+time[i][2], i);
            }
            if (rr.size()) {
                auto [_, i] = rr.top(); rr.pop();
                free += time[i][2];
                if (n) l.emplace(free+time[i][3], i);
                else ans = max(ans, free);
            } else {
                auto [_, i] = ll.top(); ll.pop();
                free += time[i][0];
                r.emplace(free+time[i][1], i);
                --n;
            }
        }
        return ans;
    }


    /*2533. Number of Good Binary Strings (Medium)
    You are given four integers minLenght, maxLength, oneGroup and zeroGroup. A
    binary string is good if it satisfies the following conditions:
    * The length of the string is in the range [minLength, maxLength].
    * The size of each block of consecutive 1's is a multiple of oneGroup.
      + For example in a binary string 00110111100 sizes of each block of
        consecutive ones are [2,4].
    * The size of each block of consecutive 0's is a multiple of zeroGroup.
      + For example, in a binary string 00110111100 sizes of each block of
        consecutive ones are [2,1,2].
    Return the number of good binary strings. Since the answer may be too large,
    return it modulo 10^9 + 7. Note that 0 is considered a multiple of all the
    numbers.

    Example 1:
    Input: minLength = 2, maxLength = 3, oneGroup = 1, zeroGroup = 2
    Output: 5
    Explanation: There are 5 good binary strings in this example: "00", "11",
                 "001", "100", and "111". It can be proven that there are only
                 5 good strings satisfying all conditions.

    Example 2:
    Input: minLength = 4, maxLength = 4, oneGroup = 4, zeroGroup = 3
    Output: 1
    Explanation: There is only 1 good binary string in this example: "1111". It
                 can be proven that there is only 1 good string satisfying all
                 conditions.

    Constraints:
    * 1 <= minLength <= maxLength <= 10^5
    * 1 <= oneGroup, zeroGroup <= maxLength*/

    int goodBinaryStrings(int minLength, int maxLength, int oneGroup, int zeroGroup) {
        vector<long> dp(maxLength+1);
        for (int i = maxLength; i >= 0; --i) {
            if (minLength <= i) ++dp[i];
            if (i+oneGroup <= maxLength) dp[i] = (dp[i] + dp[i+oneGroup]) % 1'000'000'007;
            if (i+zeroGroup <= maxLength) dp[i] = (dp[i] + dp[i+zeroGroup]) % 1'000'000'007;
        }
        return dp[0];
    }


    /*2534. Time Taken to Cross the Door (Hard)
    There are n persons numbered from 0 to n - 1 and a door. Each person can
    enter or exit through the door once, taking one second. You are given a
    non-decreasing integer array arrival of size n, where arrival[i] is the
    arrival time of the ith person at the door. You are also given an array
    state of size n, where state[i] is 0 if person i wants to enter through the
    door or 1 if they want to exit through the door. If two or more persons
    want to use the door at the same time, they follow the following rules:
    * If the door was not used in the previous second, then the person who
      wants to exit goes first.
    * If the door was used in the previous second for entering, the person who
      wants to enter goes first.
    * If the door was used in the previous second for exiting, the person who
      wants to exit goes first.
    * If multiple persons want to go in the same direction, the person with the
      smallest index goes first.
    Return an array answer of size n where answer[i] is the second at which the
    ith person crosses the door.

    Note that:
    * Only one person can cross the door at each second.
    * A person may arrive at the door and wait without entering or exiting to
      follow the mentioned rules.

    Example 1:
    Input: arrival = [0,1,1,2,4], state = [0,1,0,0,1]
    Output: [0,3,1,2,4]
    Explanation: At each second we have the following:
                 - At t = 0: Person 0 is the only one who wants to enter, so
                             they just enter through the door.
                 - At t = 1: Person 1 wants to exit, and person 2 wants to
                             enter. Since the door was used the previous second
                             for entering, person 2 enters.
                 - At t = 2: Person 1 still wants to exit, and person 3 wants
                             to enter. Since the door was used the previous
                             second for entering, person 3 enters.
                 - At t = 3: Person 1 is the only one who wants to exit, so
                             they just exit through the door.
                 - At t = 4: Person 4 is the only one who wants to exit, so
                             they just exit through the door.

    Example 2:
    Input: arrival = [0,0,0], state = [1,0,1]
    Output: [0,2,1]
    Explanation: At each second we have the following:
                 - At t = 0: Person 1 wants to enter while persons 0 and 2 want
                             to exit. Since the door was not used in the
                             previous second, the persons who want to exit get
                             to go first. Since person 0 has a smaller index,
                             they exit first.
                 - At t = 1: Person 1 wants to enter, and person 2 wants to
                             exit. Since the door was used in the previous
                             second for exiting, person 2 exits.
                 - At t = 2: Person 1 is the only one who wants to enter, so
                             they just enter through the door.

    Constraints:
    * n == arrival.length == state.length
    * 1 <= n <= 10^5
    * 0 <= arrival[i] <= n
    * arrival is sorted in non-decreasing order.
    * state[i] is either 0 or 1.*/

    vector<int> timeTaken(vector<int>& arrival, vector<int>& state) {
        int n = arrival.size();
        vector<int> ans(n, -1);
        deque<int> qin, qout;
        bool enter = false;
        for (int i = 0, time = 0; i < n || qin.size() || qout.size(); ) {
            if (i == n || time < arrival[i])
                if (qin.size() || qout.size()) {
                    if (qin.size() && (qout.empty() || enter)) {
                        ans[qin.front()] = time++;
                        qin.pop_front();
                        enter = true;
                    } else {
                        ans[qout.front()] = time++;
                        qout.pop_front();
                        enter = false;
                    }
                } else {
                    if (time+1 <= arrival[i]) enter = false;
                    time = arrival[i];
                }
            for (; i < n && time == arrival[i]; ++i)
                if (state[i]) qout.push_back(i);
                else qin.push_back(i);
        }
        return ans;
    }


    /*2535. Difference Between Element Sum and Digit Sum of an Array (Easy)
    You are given a positive integer array nums.
    * The element sum is the sum of all the elements in nums.
    * The digit sum is the sum of all the digits (not necessarily distinct)
      that appear in nums.
    Return the absolute difference between the element sum and digit sum of
    nums. Note that the absolute difference between two integers x and y is
    defined as |x - y|.

    Example 1:
    Input: nums = [1,15,6,3]
    Output: 9
    Explanation: The element sum of nums is 1 + 15 + 6 + 3 = 25. The digit sum
                 of nums is 1 + 1 + 5 + 6 + 3 = 16. The absolute difference
                 between the element sum and digit sum is |25 - 16| = 9.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: The element sum of nums is 1 + 2 + 3 + 4 = 10. The digit sum
                 of nums is 1 + 2 + 3 + 4 = 10. The absolute difference between
                 the element sum and digit sum is |10 - 10| = 0.

    Constraints:
    * 1 <= nums.length <= 2000
    * 1 <= nums[i] <= 2000*/

    int differenceOfSum(vector<int>& nums) {
        int ans = 0;
        for (auto x : nums) {
            ans += x;
            for (; x; x /= 10)
                ans -= x % 10;
        }
        return ans;
    }


    /*2536. Increment Submatrices by One (Medium)
    You are given a positive integer n, indicating that we initially have an
    n x n 0-indexed integer matrix mat filled with zeroes. You are also given a
    2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i],
    you should do the following operation:
    * Add 1 to every element in the submatrix with the top left corner
      (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1
      to mat[x][y] for for all row1i <= x <= row2i and col1i <= y <= col2i.
    Return the matrix mat after performing every query.

    Example 1:
    Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]
    Output: [[1,1,0],[1,2,1],[0,1,1]]
    Explanation: The diagram above shows the initial matrix, the matrix after
                 the first query, and the matrix after the second query.
                 - In the first query, we add 1 to every element in the
                   submatrix with the top left corner (1, 1) and bottom right
                   corner (2, 2).
                 - In the second query, we add 1 to every element in the
                   submatrix with the top left corner (0, 0) and bottom right
                   corner (1, 1).

    Example 2:
    Input: n = 2, queries = [[0,0,1,1]]
    Output: [[1,1],[1,1]]
    Explanation: The diagram above shows the initial matrix and the matrix
                 after the first query.
                 - In the first query we add 1 to every element in the matrix.

    Constraints:
    * 1 <= n <= 500
    * 1 <= queries.length <= 10^4
    * 0 <= row1i <= row2i < n
    * 0 <= col1i <= col2i < n*/

    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {
        vector<vector<int>> ans(n, vector<int>(n));
        for (auto& q : queries) {
            int i = q[0], j = q[1], ii = q[2], jj = q[3];
            ++ans[i][j];
            if (ii+1 < n) --ans[ii+1][j];
            if (jj+1 < n) --ans[i][jj+1];
            if (ii+1 < n && jj+1 < n) ++ans[ii+1][jj+1];
        }
        for (int i = 0; i < n; ++i) {
            int prefix = 0;
            for (int j = 0; j < n; ++j) {
                prefix += ans[i][j];
                ans[i][j] = prefix;
                if (i) ans[i][j] += ans[i-1][j];
            }
        }
        return ans;
    }


    /*2537. Count the Number of Good Subarrays (Medium)
    Given an integer array nums and an integer k, return the number of good
    subarrays of nums. A subarray arr is good if it there are at least k pairs
    of indices (i, j) such that i < j and arr[i] == arr[j]. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,1,1,1,1], k = 10
    Output: 1
    Explanation: The only good subarray is the array nums itself.

    Example 2:
    Input: nums = [3,1,4,3,2,2,4], k = 2
    Output: 4
    Explanation: There are 4 different good subarrays:
                 - [3,1,4,3,2,2] that has 2 pairs.
                 - [3,1,4,3,2,2,4] that has 3 pairs.
                 - [1,4,3,2,2,4] that has 2 pairs.
                 - [4,3,2,2,4] that has 2 pairs.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= 10^9*/

    long long countGood(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        long long ans = 0;
        for (int i = 0, ii = 0; i < nums.size(); ++i) {
            k -= freq[nums[i]]++;
            for (; k <= 0; ++ii)
                k += --freq[nums[ii]];
            ans += ii;
        }
        return ans;
    }


    /*2538. Difference Between Maximum and Minimum Price Sum (Hard)
    There exists an undirected and initially unrooted tree with n nodes indexed
    from 0 to n - 1. You are given the integer n and a 2D integer array edges
    of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge
    between nodes ai and bi in the tree. Each node has an associated price. You
    are given an integer array price, where price[i] is the price of the ith
    node. The price sum of a given path is the sum of the prices of all nodes
    lying on that path. The tree can be rooted at any node root of your choice.
    The incurred cost after choosing root is the difference between the maximum
    and minimum price sum amongst all paths starting at root. Return the
    maximum possible cost amongst all possible root choices.

    Example 1:
    Input: n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]
    Output: 24
    Explanation: The diagram above denotes the tree after rooting it at node 2.
                 The first part (colored in red) shows the path with the
                 maximum price sum. The second part (colored in blue) shows the
                 path with the minimum price sum.
                 - The first path contains nodes [2,1,3,4]: the prices are
                   [7,8,6,10], and the sum of the prices is 31.
                 - The second path contains the node [2] with the price [7].
                 The difference between the maximum and minimum price sum is 24.
                 It can be proved that 24 is the maximum cost.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2]], price = [1,1,1]
    Output: 2
    Explanation: The diagram above denotes the tree after rooting it at node 0.
                 The first part (colored in red) shows the path with the
                 maximum price sum. The second part (colored in blue) shows the
                 path with the minimum price sum.
                 - The first path contains nodes [0,1,2]: the prices are
                   [1,1,1], and the sum of the prices is 3.
                 - The second path contains node [0] with a price [1].
                 The difference between the maximum and minimum price sum is 2.
                 It can be proved that 2 is the maximum cost.

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * 0 <= ai, bi <= n - 1
    * edges represents a valid tree.
    * price.length == n
    * 1 <= price[i] <= 10^5*/

    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        long long ans = 0;

        function<pair<long long, long long>(int, int)> dfs = [&](int u, int p) {
            long long x = price[u], y = 0;
            for (auto& v : tree[u]) {
                if (v != p) {
                    auto [xx, yy] = dfs(v, u);
                    ans = max({ans, x + yy, xx + y});
                    x = max(x, xx + price[u]);
                    y = max(y, yy + price[u]);
                }
            }
            return make_pair(x, y);
        };

        dfs(0, -1);
        return ans;
    }


    /*2539. Count the Number of Good Subsequences (Medium)
    A subsequence of a string is good if it is not empty and the frequency of
    each one of its characters is the same. Given a string s, return the number
    of good subsequences of s. Since the answer may be too large, return it
    modulo 10^9 + 7. A subsequence is a string that can be derived from another
    string by deleting some or no characters without changing the order of the
    remaining characters.

    Example 1:
    Input: s = "aabb"
    Output: 11
    Explanation: The total number of subsequences is 24. There are five
                 subsequences which are not good: "aabb", "aabb", "aabb",
                 "aabb", and the empty subsequence. Hence, the number of good
                 subsequences is 24-5 = 11.

    Example 2:
    Input: s = "leet"
    Output: 12
    Explanation: There are four subsequences which are not good: "leet", "leet",
                 "leet", and the empty subsequence. Hence, the number of good
                 subsequences is 24-4 = 12.

    Example 3:
    Input: s = "abcd"
    Output: 15
    Explanation: All of the non-empty subsequences are good subsequences.
                 Hence, the number of good subsequences is 24-1 = 15.

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of only lowercase English letters.*/

    int countGoodSubsequences(string s) {
        const int mod = 1'000'000'007;
        vector<int> freq(26);
        for (auto& ch : s) ++freq[ch-'a'];
        long ans = 0;
        vector<long> coef(26, 1), inv(s.size()+1);
        inv[0] = inv[1] = 1;
        for (int x = 1; x <= s.size(); ++x) {
            long val = 1;
            if (x >= 2) inv[x] = mod - mod/x * inv[mod%x] % mod;
            for (int i = 0; i < 26; ++i) {
                coef[i] = coef[i] * (freq[i]-x+1) % mod;
                coef[i] = coef[i] * inv[x] % mod;
                val = val * (1+coef[i]) % mod;
            }
            ans = (ans + val - 1) % mod;
        }
        return ans;
    }


    /*2540. Minimum Common Value (Easy)
    Given two integer arrays nums1 and nums2, sorted in non-decreasing order,
    return the minimum integer common to both arrays. If there is no common
    integer amongst nums1 and nums2, return -1. Note that an integer is said
    to be common to nums1 and nums2 if both arrays have at least one
    occurrence of that integer.

    Example 1:
    Input: nums1 = [1,2,3], nums2 = [2,4]
    Output: 2
    Explanation: The smallest element common to both arrays is 2, so we return
                 2.

    Example 2:
    Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
    Output: 2
    Explanation: There are two common elements in the array 2 and 3 out of
                 which 2 is the smallest, so 2 is returned.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 10^5
    * 1 <= nums1[i], nums2[j] <= 10^9
    * Both nums1 and nums2 are sorted in non-decreasing order.*/

    int getCommon(vector<int>& nums1, vector<int>& nums2) {
        for (int i = 0, ii = 0; i < nums1.size() && ii < nums2.size(); ) {
            if (nums1[i] < nums2[ii]) ++i;
            else if (nums1[i] == nums2[ii]) return nums1[i];
            else ++ii;
        }
        return -1;
    }


    /*2541. Minimum Operations to Make Array Equal II (Medium)
    You are given two integer arrays nums1 and nums2 of equal length n and an
    integer k. You can perform the following operation on nums1:
    * Choose two indexes i and j and increment nums1[i] by k and decrement
      nums1[j] by k. In other words, nums1[i] = nums1[i] + k and
      nums1[j] = nums1[j] - k.
    nums1 is said to be equal to nums2 if for all indices i such that
    0 <= i < n, nums1[i] == nums2[i]. Return the minimum number of operations
    required to make nums1 equal to nums2. If it is impossible to make them
    equal, return -1.

    Example 1:
    Input: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3
    Output: 2
    Explanation: In 2 operations, we can transform nums1 to nums2. 1st
                 operation: i = 2, j = 0. After applying the operation,
                 nums1 = [1,3,4,4]. 2nd operation: i = 2, j = 3. After applying
                 the operation, nums1 = [1,3,7,1]. One can prove that it is
                 impossible to make arrays equal in fewer operations.

    Example 2:
    Input: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1
    Output: -1
    Explanation: It can be proved that it is impossible to make the two arrays
                 equal.

    Constraints:
    * n == nums1.length == nums2.length
    * 2 <= n <= 10^5
    * 0 <= nums1[i], nums2[j] <= 10^9
    * 0 <= k <= 10^5*/

    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {
        long long ans = 0, total = 0;
        for (int i = 0; i < nums1.size(); ++i) {
            int diff = nums1[i] - nums2[i];
            if (k == 0 && diff || k && diff % k) return -1;
            if (k) ans += abs(diff) / k;
            total += diff;
        }
        return total == 0 ? ans/2 : -1;
    }


    /*2542. Maximum Subsequence Score (Medium)
    You are given two 0-indexed integer arrays nums1 and nums2 of equal length
    n and a positive integer k. You must choose a subsequence of indices from
    nums1 of length k. For chosen indices i0, i1, ..., ik - 1, your score is
    defined as:
    * The sum of the selected elements from nums1 multiplied with the minimum
      of the selected elements from nums2.
    * It can defined simply as:
      (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).
    Return the maximum possible score. A subsequence of indices of an array is
    a set that can be derived from the set {0, 1, ..., n-1} by deleting some or
    no elements.

    Example 1:
    Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
    Output: 12
    Explanation: The four possible subsequence scores are:
                 - We choose the indices 0, 1, and 2 with
                   score = (1+3+3) * min(2,1,3) = 7.
                 - We choose the indices 0, 1, and 3 with
                   score = (1+3+2) * min(2,1,4) = 6.
                 - We choose the indices 0, 2, and 3 with
                   score = (1+3+2) * min(2,3,4) = 12.
                 - We choose the indices 1, 2, and 3 with
                   score = (3+3+2) * min(1,3,4) = 8.
                 Therefore, we return the max score, which is 12.

    Example 2:
    Input: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1
    Output: 30
    Explanation: Choosing index 2 is optimal:
                 nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible
                 score.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 0 <= nums1[i], nums2[j] <= 10^5
    * 1 <= k <= n*/

    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {
        vector<vector<int>> aug;
        for (int i = 0; i < nums1.size(); ++i)
            aug.push_back({nums2[i], nums1[i]});
        sort(aug.begin(), aug.end(), greater<>());
        priority_queue<int, vector<int>, greater<>> pq;
        long long ans = 0, total = 0;
        for (int i = 0; i < aug.size(); ++i) {
            total += aug[i][1];
            pq.push(aug[i][1]);
            if (i >= k) { total -= pq.top(); pq.pop(); }
            if (i >= k-1) ans = max(ans, total * aug[i][0]);
        }
        return ans;
    }


    /*2543. Check if Point Is Reachable (Hard)
    There exists an infinitely large grid. You are currently at point (1, 1),
    and you need to reach the point (targetX, targetY) using a finite number of
    steps. In one step, you can move from point (x, y) to any one of the
    following points: (x, y - x)
                      (x - y, y)
                      (2 * x, y)
                      (x, 2 * y)
    Given two integers targetX and targetY representing the X-coordinate and Y-
    coordinate of your final position, return true if you can reach the point
    from (1, 1) using some number of steps, and false otherwise.

    Example 1:
    Input: targetX = 6, targetY = 9
    Output: false
    Explanation: It is impossible to reach (6,9) from (1,1) using any sequence
                 of moves, so false is returned.

    Example 2:
    Input: targetX = 4, targetY = 7
    Output: true
    Explanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) ->
                 (1,7) -> (2,7) -> (4,7).

    Constraints: 1 <= targetX, targetY <= 10^9*/

    bool isReachable(int targetX, int targetY) {
        int g = gcd(targetX, targetY);
        return (g & (g-1)) == 0;
    }


    /*2544. Alternating Digit Sum (Easy)
    You are given a positive integer n. Each digit of n has a sign according to
    the following rules:
    * The most significant digit is assigned a positive sign.
    * Each other digit has an opposite sign to its adjacent digits.
    Return the sum of all digits with their corresponding sign.

    Example 1:
    Input: n = 521
    Output: 4
    Explanation: (+5) + (-2) + (+1) = 4.

    Example 2:
    Input: n = 111
    Output: 1
    Explanation: (+1) + (-1) + (+1) = 1.

    Example 3:
    Input: n = 886996
    Output: 0
    Explanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.

    Constraints: 1 <= n <= 10^9*/

    int alternateDigitSum(int n) {
        int ans = 0, sign = 1;
        for (; n; n /= 10) {
            sign *= -1;
            ans += n % 10 * sign;
        }
        return ans * sign;
    }


    /*2545. Sort the Students by Their Kth Score (Medium)
    There is a class with m students and n exams. You are given a 0-indexed
    m x n integer matrix score, where each row represents one student and
    score[i][j] denotes the score the ith student got in the jth exam. The
    matrix score contains distinct integers only. You are also given an integer
    k. Sort the students (i.e., the rows of the matrix) by their scores in the
    kth (0-indexed) exam from the highest to the lowest. Return the matrix
    after sorting it.

    Example 1:
    Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
    Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
    Explanation: In the above diagram, S denotes the student, while E denotes
                 the exam.
                 - The student with index 1 scored 11 in exam 2, which is the
                   highest score, so they got first place.
                 - The student with index 0 scored 9 in exam 2, which is the
                   second highest score, so they got second place.
                 - The student with index 2 scored 3 in exam 2, which is the
                   lowest score, so they got third place.

    Example 2:
    Input: score = [[3,4],[5,6]], k = 0
    Output: [[5,6],[3,4]]
    Explanation: In the above diagram, S denotes the student, while E denotes
                 the exam.
                 - The student with index 1 scored 5 in exam 0, which is the
                   highest score, so they got first place.
                 - The student with index 0 scored 3 in exam 0, which is the
                   lowest score, so they got second place.

    Constraints:
    * m == score.length
    * n == score[i].length
    * 1 <= m, n <= 250
    * 1 <= score[i][j] <= 10^5
    * score consists of distinct integers.
    * 0 <= k < n*/

    vector<vector<int>> sortTheStudents(vector<vector<int>>& score, int k) {
        sort(score.begin(), score.end(), [&](auto& lhs, auto& rhs) { return lhs[k] > rhs[k]; });
        return score;
    }


    /*2546. Apply Bitwise Operations to Make Strings Equal (Medium)
    You are given two 0-indexed binary strings s and target of the same length
    n. You can do the following operation on s any number of times:
    * Choose two different indices i and j where 0 <= i, j < n.
    * Simultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR
      s[j]).
    For example, if s = "0110", you can choose i = 0 and j = 2, then
    simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with
    (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = "1110". Return true if
    you can make the string s equal to target, or false otherwise.

    Example 1:
    Input: s = "1010", target = "0110"
    Output: true
    Explanation: We can do the following operations:
                 - Choose i = 2 and j = 0. We have now s = "0010".
                 - Choose i = 2 and j = 1. We have now s = "0110".
                 Since we can make s equal to target, we return true.

    Example 2:
    Input: s = "11", target = "00"
    Output: false
    Explanation: It is not possible to make s equal to target with any number
                 of operations.

    Constraints:
    * n == s.length == target.length
    * 2 <= n <= 10^5
    * s and target consist of only the digits 0 and 1.*/

    bool makeStringsEqual(string s, string target) {
        return (s.find('1') == string::npos) == (target.find('1') == string::npos);
    }


    /*2547. Minimum Cost to Split an Array (Hard)
    You are given an integer array nums and an integer k. Split the array into
    some number of non-empty subarrays. The cost of a split is the sum of the
    importance value of each subarray in the split. Let trimmed(subarray) be
    the version of the subarray where all numbers which appear only once are
    removed.
    * For example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].
    The importance value of a subarray is k + trimmed(subarray).length.
    * For example, if a subarray is [1,2,3,3,3,4,4], then
      trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this
      subarray will be k + 5.
    Return the minimum possible cost of a split of nums. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,1,2,1,3,3], k = 2
    Output: 8
    Explanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].
                 The importance value of [1,2] is 2 + (0) = 2.
                 The importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.
                 The cost of the split is 2 + 6 = 8. It can be shown that this
                 is the minimum possible cost among all the possible splits.

    Example 2:
    Input: nums = [1,2,1,2,1], k = 2
    Output: 6
    Explanation: We split nums to have two subarrays: [1,2], [1,2,1].
                 The importance value of [1,2] is 2 + (0) = 2.
                 The importance value of [1,2,1] is 2 + (2) = 4.
                 The cost of the split is 2 + 4 = 6. It can be shown that this
                 is the minimum possible cost among all the possible splits.

    Example 3:
    Input: nums = [1,2,1,2,1], k = 5
    Output: 10
    Explanation: We split nums to have one subarray: [1,2,1,2,1].
                 The importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.
                 The cost of the split is 10. It can be shown that this is the
                 minimum possible cost among all the possible splits.

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] < nums.length
    * 1 <= k <= 10^9*/

    int minCost(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n+1, INT_MAX);
        dp[n] = 0;
        for (int i = n-1; i >= 0; --i) {
            int val = 0;
            vector<int> freq(n);
            for (int ii = i; ii < n; ++ii) {
                ++freq[nums[ii]];
                if (freq[nums[ii]] == 2) val += 2;
                else if (freq[nums[ii]] > 2) ++val;
                dp[i] = min(dp[i], k + val + dp[ii+1]);
            }
        }
        return dp[0];
    }


    /*2548. Maximum Price to Fill a Bag (Medium)
    You are given a 2D integer array items where items[i] = [pricei, weighti]
    denotes the price and weight of the ith item, respectively. You are also
    given a positive integer capacity. Each item can be divided into two items
    with ratios part1 and part2, where part1 + part2 == 1.
    * The weight of the first item is weighti * part1 and the price of the
      first item is pricei * part1.
    * Similarly, the weight of the second item is weighti * part2 and the price
      of the second item is pricei * part2.
    Return the maximum total price to fill a bag of capacity capacity with
    given items. If it is impossible to fill a bag return -1. Answers within
    10^-5 of the actual answer will be considered accepted.

    Example 1:
    Input: items = [[50,1],[10,8]], capacity = 5
    Output: 55.00000
    Explanation: We divide the 2nd item into two parts with part1 = 0.5 and
                 part2 = 0.5. The price and weight of the 1st item are 5, 4.
                 And similarly, the price and the weight of the 2nd item are
                 5, 4. The array items after operation becomes
                 [[50,1],[5,4],[5,4]]. To fill a bag with capacity 5 we take
                 the 1st element with a price of 50 and the 2nd element with a
                 price of 5. It can be proved that 55.0 is the maximum total
                 price that we can achieve.

    Example 2:
    Input: items = [[100,30]], capacity = 50
    Output: -1.00000
    Explanation: It is impossible to fill a bag with the given item.

    Constraints:
    * 1 <= items.length <= 10^5
    * items[i].length == 2
    * 1 <= pricei, weighti <= 10^4
    * 1 <= capacity <= 10^9*/

    double maxPrice(vector<vector<int>>& items, int capacity) {
        double ans = 0;
        sort(items.begin(), items.end(), [&](auto& lhs, auto& rhs) {
            return (double) lhs[0]/lhs[1] > (double) rhs[0]/rhs[1];
        });
        for (auto& item : items) {
            double p = item[0];
            if (item[1] > capacity) p *= (double) capacity/item[1];
            ans += p;
            capacity -= min(item[1], capacity);
            if (capacity == 0) break;
        }
        return capacity == 0 ? ans : -1;
    }


    /*2549. Count Distinct Numbers on Board (Easy)
    You are given a positive integer n, that is initially placed on a board.
    Every day, for 10^9 days, you perform the following procedure:
    * For each number x present on the board, find all numbers 1 <= i <= n such
      that x % i == 1.
    * Then, place those numbers on the board.
    Return the number of distinct integers present on the board after 10^9 days
    have elapsed.

    Note:
    * Once a number is placed on the board, it will remain on it until the end.
    * % stands for the modulo operation. For example, 14 % 3 is 2.

    Example 1:
    Input: n = 5
    Output: 4
    Explanation: Initially, 5 is present on the board. The next day, 2 and 4
                 will be added since 5 % 2 == 1 and 5 % 4 == 1. After that day,
                 3 will be added to the board because 4 % 3 == 1. At the end of
                 a billion days, the distinct numbers on the board will be 2, 3,
                 4, and 5.

    Example 2:
    Input: n = 3
    Output: 2
    Explanation: Since 3 % 2 == 1, 2 will be added to the board. After a
                 billion days, the only two distinct numbers on the board are 2
                 and 3.

    Constraints: 1 <= n <= 100*/

    int distinctIntegers(int n) {
        return n == 1 ? 1 : n-1;
    }


    /*2550. Count Collisions of Monkeys on a Polygon (Medium)
    There is a regular convex polygon with n vertices. The vertices are labeled
    from 0 to n - 1 in a clockwise direction, and each vertex has exactly one
    monkey. The following figure shows a convex polygon of 6 vertices. Each
    monkey moves simultaneously to a neighboring vertex. A neighboring vertex
    for a vertex i can be:
    * the vertex (i + 1) % n in the clockwise direction, or
    * the vertex (i - 1 + n) % n in the counter-clockwise direction.
    A collision happens if at least two monkeys reside on the same vertex after
    the movement. Return the number of ways the monkeys can move so that at
    least one collision happens. Since the answer may be very large, return it
    modulo 10^9 + 7. Note that each monkey can only move once.

    Example 1:
    Input: n = 3
    Output: 6
    Explanation: There are 8 total possible movements. Two ways such that they
                 collide at some point are:
                 - Monkey 1 moves in a clockwise direction; monkey 2 moves in
                   an anticlockwise direction; monkey 3 moves in a clockwise
                   direction. Monkeys 1 and 2 collide.
                 - Monkey 1 moves in an anticlockwise direction; monkey 2 moves
                   in an anticlockwise direction; monkey 3 moves in a clockwise
                   direction. Monkeys 1 and 3 collide.
                 It can be shown 6 total movements result in a collision.

    Example 2:
    Input: n = 4
    Output: 14
    Explanation: It can be shown that there are 14 ways for the monkeys to
                 collide.

    Constraints: 3 <= n <= 10^9*/

    int monkeyMove(int n) {
        const int mod = 1'000'000'007;

        auto pow = [](long x, int p, int mod) {
            long ans = 1;
            for (; p; p >>= 1) {
                if (p&1) ans = ans * x % mod;
                x = x * x % mod;
            }
            return ans;
        };

        return (pow(2, n, mod) - 2 + mod) % mod;
    }


    /*2551. Put Marbles in Bags (Hard)
    You have k bags. You are given a 0-indexed integer array weights where
    weights[i] is the weight of the ith marble. You are also given the integer
    k. Divide the marbles into the k bags according to the following rules:
    * No bag is empty.
    * If the ith marble and jth marble are in a bag, then all marbles with an
      index between the ith and jth indices should also be in that same bag.
    * If a bag consists of all the marbles with an index from i to j
      inclusively, then the cost of the bag is weights[i] + weights[j].
    The score after distributing the marbles is the sum of the costs of all the
    k bags. Return the difference between the maximum and minimum scores among
    marble distributions.

    Example 1:
    Input: weights = [1,3,5,1], k = 2
    Output: 4
    Explanation: The distribution [1],[3,5,1] results in the minimal score of
                 (1+1) + (3+1) = 6. The distribution [1,3],[5,1], results in
                 the maximal score of (1+3) + (5+1) = 10. Thus, we return their
                 difference 10 - 6 = 4.

    Example 2:
    Input: weights = [1, 3], k = 2
    Output: 0
    Explanation: The only distribution possible is [1],[3]. Since both the
                 maximal and minimal score are the same, we return 0.

    Constraints:
    * 1 <= k <= weights.length <= 10^5
    * 1 <= weights[i] <= 10^9*/

    long long putMarbles(vector<int>& weight, int k) {
        if (k == 1) return 0;
        vector<int> vals;
        for (int i = 0; i < weight.size()-1; ++i)
            vals.push_back(weight[i] + weight[i+1]);
        sort(vals.begin(), vals.end());
        long long diff = 0;
        for (int i = 0; i < k-1; ++i) {
            diff -= vals[i];
            diff += vals[vals.size()-1-i];
        }
        return diff;
    }


    /*2552. Count Increasing Quadruplets (Hard)
    Given a 0-indexed integer array nums of size n containing all numbers from
    1 to n, return the number of increasing quadruplets. A quadruplet
    (i, j, k, l) is increasing if:
    * 0 <= i < j < k < l < n, and
    * nums[i] < nums[k] < nums[j] < nums[l].

    Example 1:
    Input: nums = [1,3,2,4,5]
    Output: 2
    Explanation: - When i = 0, j = 1, k = 2, and l = 3,
                   nums[i] < nums[k] < nums[j] < nums[l].
                 - When i = 0, j = 1, k = 2, and l = 4,
                   nums[i] < nums[k] < nums[j] < nums[l].
                 There are no other quadruplets, so we return 2.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: There exists only one quadruplet with i = 0, j = 1, k = 2,
                 l = 3, but since nums[j] < nums[k], we return 0.

    Constraints:
    * 4 <= nums.length <= 4000
    * 1 <= nums[i] <= nums.length
    * All the integers of nums are unique. nums is a permutation.*/

    long long countQuadruplets(vector<int>& nums) {
        long long ans = 0;
        vector<long long> dp(nums.size());
        for (int j = 0; j < nums.size(); ++j) {
            int prev = 0;
            for (int i = 0; i < j; ++i)
                if (nums[i] < nums[j]) {
                    ++prev;
                    ans += dp[i];
                } else if (nums[i] > nums[j]) dp[i] += prev;
        }
        return ans;
    }


    /*2553. Separate the Digits in an Array (Easy)
    Given an array of positive integers nums, return an array answer that
    consists of the digits of each integer in nums after separating them in the
    same order they appear in nums. To separate the digits of an integer is to
    get all the digits it has in the same order. For example, for the integer
    10921, the separation of its digits is [1,0,9,2,1].

    Example 1:
    Input: nums = [13,25,83,77]
    Output: [1,3,2,5,8,3,7,7]
    Explanation: - The separation of 13 is [1,3].
                 - The separation of 25 is [2,5].
                 - The separation of 83 is [8,3].
                 - The separation of 77 is [7,7].
                 answer = [1,3,2,5,8,3,7,7]. Note that answer contains the
                 separations in the same order.

    Example 2:
    Input: nums = [7,1,3,9]
    Output: [7,1,3,9]
    Explanation: The separation of each integer in nums is itself.
                 answer = [7,1,3,9].

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5*/

    vector<int> separateDigits(vector<int>& nums) {
        vector<int> ans;
        for (int i = nums.size()-1; i >= 0; --i)
            for (int x = nums[i]; x; x /= 10)
                ans.push_back(x % 10);
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*2554. Maximum Number of Integers to Choose From a Range I (Medium)
    You are given an integer array banned and two integers n and maxSum. You
    are choosing some number of integers following the below rules:
    * The chosen integers have to be in the range [1, n].
    * Each integer can be chosen at most once.
    * The chosen integers should not be in the array banned.
    * The sum of the chosen integers should not exceed maxSum.
    Return the maximum number of integers you can choose following the
    mentioned rules.

    Example 1:
    Input: banned = [1,6,5], n = 5, maxSum = 6
    Output: 2
    Explanation: You can choose the integers 2 and 4. 2 and 4 are from the
                 range [1, 5], both did not appear in banned, and their sum is
                 6, which did not exceed maxSum.

    Example 2:
    Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1
    Output: 0
    Explanation: You cannot choose any integer while following the mentioned
                 conditions.

    Example 3:
    Input: banned = [11], n = 7, maxSum = 50
    Output: 7
    Explanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7. They are
                 from the range [1, 7], all did not appear in banned, and their
                 sum is 28, which did not exceed maxSum.

    Constraints:
    * 1 <= banned.length <= 10^4
    * 1 <= banned[i], n <= 10^4
    * 1 <= maxSum <= 10^9*/

    int maxCount(vector<int>& banned, int n, int maxSum) {
        unordered_set<int> tabu(banned.begin(), banned.end());
        int ans = 0;
        for (int x = 1; x <= n && x <= maxSum; ++x)
            if (!tabu.count(x)) {
                maxSum -= x;
                ++ans;
            }
        return ans;
    }


    /*2555. Maximize Win From Two Segments (Medium)
    There are some prizes on the X-axis. You are given an integer array
    prizePositions that is sorted in non-decreasing order, where
    prizePositions[i] is the position of the ith prize. There could be
    different prizes at the same position on the line. You are also given an
    integer k. You are allowed to select two segments with integer endpoints.
    The length of each segment must be k. You will collect all prizes whose
    position falls within at least one of the two selected segments (including
    the endpoints of the segments). The two selected segments may intersect.
    For example if k = 2, you can choose segments [1, 3] and [2, 4], and you
    will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or
    2 <= prizePositions[i] <= 4. Return the maximum number of prizes you can
    win if you choose the two segments optimally.

    Example 1:
    Input: prizePositions = [1,1,2,2,3,3,5], k = 2
    Output: 7
    Explanation: In this example, you can win all 7 prizes by selecting two
                 segments [1, 3] and [3, 5].

    Example 2:
    Input: prizePositions = [1,2,3,4], k = 0
    Output: 2
    Explanation: For this example, one choice for the segments is [3, 3] and
                 [4, 4], and you will be able to get 2 prizes.

    Constraints:
    * 1 <= prizePositions.length <= 10^5
    * 1 <= prizePositions[i] <= 10^9
    * 0 <= k <= 10^9
    * prizePositions is sorted in non-decreasing order.*/

    int maximizeWin(vector<int>& prizePositions, int k) {
        int ans = 0;
        vector<int> dp(1);
        for (int i = 0, ii = 0; i < prizePositions.size(); ++i) {
            while (prizePositions[i] - prizePositions[ii] > k) ++ii;
            ans = max(ans, dp[ii] + i - ii + 1);
            dp.push_back(max(dp.back(), i - ii + 1));
        }
        return ans;
    }


    /*2556. Disconnect Path in a Binary Matrix by at Most One Flip (Medium)
    You are given a 0-indexed m x n binary matrix grid. You can move from a
    cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that
    has the value 1. The matrix is disconnected if there is no path from
    (0, 0) to (m - 1, n - 1). You can flip the value of at most one (possibly
    none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1). Return
    true if it is possible to make the matrix disconnect or false otherwise.
    Note that flipping a cell changes its value from 0 to 1 or from 1 to 0.

    Example 1:
    Input: grid = [[1,1,1],[1,0,0],[1,1,1]]
    Output: true
    Explanation: We can change the cell shown in the diagram above. There is no
                 path from (0, 0) to (2, 2) in the resulting grid.

    Example 2:
    Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
    Output: false
    Explanation: It is not possible to change at most one cell such that there
                 is not path from (0, 0) to (2, 2).

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 1000
    * 1 <= m * n <= 10^5
    * grid[i][j] is either 0 or 1.
    * grid[0][0] == grid[m - 1][n - 1] == 1*/

    bool isPossibleToCutPath(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if ((i || j) && (i == 0 || grid[i-1][j] == 0) && (j == 0 || grid[i][j-1] == 0)) grid[i][j] = 0;
        for (int i = m-1; i >= 0; --i)
            for (int j = n-1; j >= 0; --j)
                if ((i < m-1 || j < n-1) && (i == m-1 || grid[i+1][j] == 0) && (j == n-1 || grid[i][j+1] == 0)) grid[i][j] = 0;
        vector<int> freq(m+n-1);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                freq[i+j] += grid[i][j];
        return any_of(freq.begin()+1, freq.end()-1, [&](auto& x) {return x <= 1;});
    }


    /*2557. Maximum Number of Integers to Choose From a Range II (Medium)
    You are given an integer array banned and two integers n and maxSum. You
    are choosing some number of integers following the below rules:
    * The chosen integers have to be in the range [1, n].
    * Each integer can be chosen at most once.
    * The chosen integers should not be in the array banned.
    * The sum of the chosen integers should not exceed maxSum.
    Return the maximum number of integers you can choose following the
    mentioned rules.

    Example 1:
    Input: banned = [1,4,6], n = 6, maxSum = 4
    Output: 1
    Explanation: You can choose the integer 2 and 3. 2 and 3 are are in the
                 range [1, 6], both do not appear in banned, and their sum is 5,
                 which does not exceed maxSum.

    Example 2:
    Input: banned = [4,3,5,6], n = 7, maxSum = 18
    Output: 3
    Explanation: You can choose the integers 1, 2, 3 and 7. All these integers
                 are in the range [1, 7], all do not appear in banned, and
                 their sum is 13, which does not exceed maxSum.

    Constraints:
    * 1 <= banned.length <= 10^5
    * 1 <= banned[i] <= n <= 10^9
    * 1 <= maxSum <= 10^15*/

    int maxCount(vector<int>& banned, int n, long long maxSum) {
        int lo = 0, hi = n;
        while (lo < hi) {
            int mid = lo + (hi - lo + 1)/2;
            long total = (long) mid*(mid+1)/2;
            for (auto& x : banned)
                if (x <= mid) total -= x;
            if (total <= maxSum) lo = mid;
            else hi = mid-1;
        }
        return lo - count_if(banned.begin(), banned.end(), [&](auto& x) {return x <= lo;});
    }


    /*2558. Take Gifts From the Richest Pile (Easy)
    You are given an integer array gifts denoting the number of gifts in
    various piles. Every second, you do the following:
    * Choose the pile with the maximum number of gifts.
    * If there is more than one pile with the maximum number of gifts, choose
      any.
    * Leave behind the floor of the square root of the number of gifts in the
      pile. Take the rest of the gifts.
    Return the number of gifts remaining after k seconds.

    Example 1:
    Input: gifts = [25,64,9,4,100], k = 4
    Output: 29
    Explanation: The gifts are taken in the following way:
                 - In the first second, the last pile is chosen and 10 gifts
                   are left behind.
                 - Then the second pile is chosen and 8 gifts are left behind.
                 - After that the first pile is chosen and 5 gifts are left
                   behind.
                 - Finally, the last pile is chosen again and 3 gifts are left
                   behind.
                 The final remaining gifts are [5,8,9,4,3], so the total number
                 of gifts remaining is 29.

    Example 2:
    Input: gifts = [1,1,1,1], k = 4
    Output: 4
    Explanation: In this case, regardless which pile you choose, you have to
                 leave behind 1 gift in each pile. That is, you can't take any
                 pile with you. So, the total gifts remaining are 4.

    Constraints:
    * 1 <= gifts.length <= 10^3
    * 1 <= gifts[i] <= 10^9
    * 1 <= k <= 10^3*/

    long long pickGifts(vector<int>& gifts, int k) {
        long long ans = accumulate(gifts.begin(), gifts.end(), 0ll);
        priority_queue<int> pq(gifts.begin(), gifts.end());
        while (k--) {
            auto vv = pq.top(); pq.pop();
            int v = sqrt(vv);
            ans -= vv - v;
            pq.push(v);
        }
        return ans;
    }


    /*2559. Count Vowel Strings in Ranges (Medium)
    You are given a 0-indexed array of strings words and a 2D array of integers
    queries. Each query queries[i] = [li, ri] asks us to find the number of
    strings present in the range li to ri (both inclusive) of words that start
    and end with a vowel. Return an array ans of size queries.length, where
    ans[i] is the answer to the ith query. Note that the vowel letters are
    'a', 'e', 'i', 'o', and 'u'.

    Example 1:
    Input: words = ["aba","bcb","ece","aa","e"], queries = [[0,2],[1,4],[1,1]]
    Output: [2,3,0]
    Explanation: The strings starting and ending with a vowel are "aba", "ece",
                 "aa" and "e". The answer to the query [0,2] is 2 (strings
                 "aba" and "ece").
                 to query [1,4] is 3 (strings "ece", "aa", "e").
                 to query [1,1] is 0.
                 We return [2,3,0].

    Example 2:
    Input: words = ["a","e","i"], queries = [[0,2],[0,1],[2,2]]
    Output: [3,2,1]
    Explanation: Every string satisfies the conditions, so we return [3,2,1].

    Constraints:
    * 1 <= words.length <= 10^5
    * 1 <= words[i].length <= 40
    * words[i] consists only of lowercase English letters.
    * sum(words[i].length) <= 3 * 10^5
    * 1 <= queries.length <= 10^5
    * 0 <= li <= ri < words.length*/

    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {
        string vowel = "aeiou";
        vector<int> prefix(1);
        for (auto& word : words) {
            prefix.push_back(prefix.back());
            if (vowel.find(word[0]) != string::npos && vowel.find(word.back()) != string::npos) ++prefix.back();
        }
        vector<int> ans;
        for (auto& q : queries)
            ans.push_back(prefix[q[1]+1] - prefix[q[0]]);
        return ans;
    }


    /*2560. House Robber IV (Medium)
    There are several consecutive houses along a street, each of which has some
    money inside. There is also a robber, who wants to steal money from the
    homes, but he refuses to steal from adjacent homes. The capability of the
    robber is the maximum amount of money he steals from one house of all the
    houses he robbed. You are given an integer array nums representing how much
    money is stashed in each house. More formally, the ith house from the left
    has nums[i] dollars. You are also given an integer k, representing the
    minimum number of houses the robber will steal from. It is always possible
    to steal at least k houses. Return the minimum capability of the robber out
    of all the possible ways to steal at least k houses.

    Example 1:
    Input: nums = [2,3,5,9], k = 2
    Output: 5
    Explanation: There are three ways to rob at least 2 houses:
                 - Rob the houses at indices 0 and 2. Capability is
                   max(nums[0], nums[2]) = 5.
                 - Rob the houses at indices 0 and 3. Capability is
                   max(nums[0], nums[3]) = 9.
                 - Rob the houses at indices 1 and 3. Capability is
                   max(nums[1], nums[3]) = 9.
                 Therefore, we return min(5, 9, 9) = 5.

    Example 2:
    Input: nums = [2,7,9,3,1], k = 2
    Output: 2
    Explanation: There are 7 ways to rob the houses. The way which leads to
                 minimum capability is to rob the house at index 0 and 4.
                 Return max(nums[0], nums[4]) = 2.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= (nums.length + 1)/2*/

    int minCapability(vector<int>& nums, int k) {
        int lo = 0, hi = 1e9;
        while (lo < hi) {
            int mid = (lo + hi + 1)/2, cnt = 0, prev = INT_MIN;
            for (int i = 0; i < nums.size(); ++i)
                if (nums[i] <= mid && prev+1 < i) {
                    ++cnt;
                    prev = i;
                }
            if (cnt < k) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*2561. Rearranging Fruits (Hard)
    You have two fruit baskets containing n fruits each. You are given two 0-
    indexed integer arrays basket1 and basket2 representing the cost of fruit
    in each basket. You want to make both baskets equal. To do so, you can use
    the following operation as many times as you want:
    * Chose two indices i and j, and swap the ith fruit of basket1 with the jth
      fruit of basket2.
    * The cost of the swap is min(basket1[i],basket2[j]).
    Two baskets are considered equal if sorting them according to the fruit
    cost makes them exactly the same baskets. Return the minimum cost to make
    both the baskets equal or -1 if impossible.

    Example 1:
    Input: basket1 = [4,2,2,2], basket2 = [1,4,1,2]
    Output: 1
    Explanation: Swap index 1 of basket1 with index 0 of basket2, which has
                 cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2].
                 Rearranging both the arrays makes them equal.

    Example 2:
    Input: basket1 = [2,3,4,1], basket2 = [3,2,5,1]
    Output: -1
    Explanation: It can be shown that it is impossible to make both the baskets
                 equal.

    Constraints:
    * basket1.length == bakste2.length
    * 1 <= basket1.length <= 10^5
    * 1 <= basket1[i],basket2[i] <= 10^9*/

    long long minCost(vector<int>& basket1, vector<int>& basket2) {
        map<int, int> freq;
        for (auto& x : basket1) ++freq[x];
        for (auto& x : basket2) --freq[x];
        int total = 0, m = INT_MAX;
        for (auto& [k, v] : freq) {
            m = min(m, k);
            if (v & 1) return -1;
            total += abs(v/2);
        }
        total /= 2;
        long long ans = 0;
        for (auto& [k, v] : freq) {
            v = min(abs(v/2), total);
            ans += (long long) v * min(2*m, k);
            total -= v;
        }
        return ans;
    }


    /*2562. Find the Array Concatenation Value (Easy)
    You are given a 0-indexed integer array nums. The concatenation of two
    numbers is the number formed by concatenating their numerals.
    * For example, the concatenation of 15, 49 is 1549.
    The concatenation value of nums is initially equal to 0. Perform this
    operation until nums becomes empty:
    * If there exists more than one number in nums, pick the first element and
      last element in nums respectively and add the value of their
      concatenation to the concatenation value of nums, then delete the first
      and last element from nums.
    * If one element exists, add its value to the concatenation value of nums,
      then delete it.
    Return the concatenation value of the nums.

    Example 1:
    Input: nums = [7,52,2,4]
    Output: 596
    Explanation: Before performing any operation, nums is [7,52,2,4] and
                 concatenation value is 0.
                  - In the first operation:
                 We pick the first element, 7, and the last element, 4. Their
                 concatenation is 74, and we add it to the concatenation value,
                 so it becomes equal to 74. Then we delete them from nums, so
                 nums becomes equal to [52,2].
                  - In the second operation:
                 We pick the first element, 52, and the last element, 2. Their
                 concatenation is 522, and we add it to the concatenation value,
                 so it becomes equal to 596. Then we delete them from the nums,
                 so nums becomes empty. Since the concatenation value is 596 so
                 the answer is 596.

    Example 2:
    Input: nums = [5,14,13,8,12]
    Output: 673
    Explanation: Before performing any operation, nums is [5,14,13,8,12] and
                 concatenation value is 0.
                  - In the first operation:
                 We pick the first element, 5, and the last element, 12. Their
                 concatenation is 512, and we add it to the concatenation value,
                 so it becomes equal to 512. Then we delete them from the nums,
                 so nums becomes equal to [14,13,8].
                  - In the second operation:
                 We pick the first element, 14, and the last element, 8. Their
                 concatenation is 148, and we add it to the concatenation value,
                 so it becomes equal to 660. Then we delete them from the nums,
                 so nums becomes equal to [13].
                  - In the third operation:
                 nums has only one element, so we pick 13 and add it to the
                 concatenation value, so it becomes equal to 673. Then we
                 delete it from nums, so nums become empty. Since the
                 concatenation value is 673 so the answer is 673.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^4*/

    long long findTheArrayConcVal(vector<int>& nums) {
        long long ans = 0;
        for (int i = 0, n = nums.size(); i < (n+1)/2; ++i)
            if (i == n-1-i) ans += nums[i];
            else {
                int m = 1;
                for (int x = nums[n-1-i]; x; x /= 10, m *= 10);
                ans += m*nums[i] + nums[n-1-i];
            }
        return ans;
    }


    /*2563. Count the Number of Fair Pairs (Medium)
    Given a 0-indexed integer array nums of size n and two integers lower and
    upper, return the number of fair pairs. A pair (i, j) is fair if:
    * 0 <= i < j < n, and
    * lower <= nums[i] + nums[j] <= upper

    Example 1:
    Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6
    Output: 6
    Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and
                 (1,5).

    Example 2:
    Input: nums = [1,7,9,2,5], lower = 11, upper = 11
    Output: 1
    Explanation: There is a single fair pair: (2,3).

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums.length == n
    * -10^9 <= nums[i] <= 10^9
    * -10^9 <= lower <= upper <= 10^9*/

    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        sort(nums.begin(), nums.end());
        long long ans = 0;
        for (int i = 0, n = nums.size(), lo = n-1, hi = n-1; i < n; ++i) {
            while (0 <= hi && nums[i] + nums[hi] > upper) --hi;
            while (0 <= lo && nums[i] + nums[lo] >= lower) --lo;
            ans += hi - lo;
            if (lo < i && i <= hi) --ans;
        }
        return ans/2;
    }


    /*2564. Substring XOR Queries (Medium)
    You are given a binary string s, and a 2D integer array queries where
    queries[i] = [firsti, secondi]. For the ith query, find the shortest
    substring of s whose decimal value, val, yields secondi when bitwise XORed
    with firsti. In other words, val ^ firsti == secondi. The answer to the ith
    query is the endpoints (0-indexed) of the substring [lefti, righti] or
    [-1, -1] if no such substring exists. If there are multiple answers, choose
    the one with the minimum lefti. Return an array ans where
    ans[i] = [lefti, righti] is the answer to the ith query. A substring is a
    contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: s = "101101", queries = [[0,5],[1,2]]
    Output: [[0,2],[2,3]]
    Explanation: For the first query the substring in range [0,2] is "101"
                 which has a decimal value of 5, and 5 ^ 0 = 5, hence the
                 answer to the first query is [0,2]. In the second query, the
                 substring in range [2,3] is "11", and has a decimal value of 3,
                 and 3 ^ 1 = 2. So, [2,3] is returned for the second query.

    Example 2:
    Input: s = "0101", queries = [[12,8]]
    Output: [[-1,-1]]
    Explanation: In this example there is no substring that answers the query,
                 hence [-1,-1] is returned.

    Example 3:
    Input: s = "1", queries = [[4,5]]
    Output: [[0,0]]
    Explanation: For this example, the substring in range [0,0] has a decimal
                 value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].

    Constraints:
    * 1 <= s.length <= 10^4
    * s[i] is either '0' or '1'.
    * 1 <= queries.length <= 10^5
    * 0 <= firsti, secondi <= 10^9*/

    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {
        unordered_map<int, vector<int>> seen;
        for (int i = 0, n = s.size(); i < n; ++i)
            if (s[i] == '1') {
                int val = 0;
                for (int j = i; j < n && j < i+30; ++j) {
                    val <<= 1;
                    if (s[j] == '1') val ^= 1;
                    if (!seen.count(val)) seen[val] = {i, j};
                }
            } else if (!seen.count(0)) seen[0] = {i, i};
        vector<vector<int>> ans;
        for (auto& q : queries) {
            int val = q[0]^q[1];
            ans.push_back(seen.count(val) ? seen[val] : vector<int>{-1, -1});
        }
        return ans;
    }


    /*2565. Subsequence With the Minimum Score (Hard)
    You are given two strings s and t. You are allowed to remove any number of
    characters from the string t. The score string is 0 if no characters are
    removed from the string t, otherwise:
    * Let left be the minimum index among all removed characters.
    * Let right be the maximum index among all removed characters.
    Then the score of the string is right - left + 1. Return the minimum
    possible score to make t a subsequence of s. A subsequence of a string is a
    new string that is formed from the original string by deleting some (can be
    none) of the characters without disturbing the relative positions of the
    remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec"
    is not).

    Example 1:
    Input: s = "abacaba", t = "bzaa"
    Output: 1
    Explanation: In this example, we remove the character "z" at index 1
                 (0-indexed). The string t becomes "baa" which is a subsequence
                 of the string "abacaba" and the score is 1 - 1 + 1 = 1. It can
                 be proven that 1 is the minimum score that we can achieve.

    Example 2:
    Input: s = "cde", t = "xyz"
    Output: 3
    Explanation: In this example, we remove characters "x", "y" and "z" at
                 indices 0, 1, and 2 (0-indexed). The string t becomes "" which
                 is a subsequence of the string "cde" and the score is
                 2 - 0 + 1 = 3. It can be proven that 3 is the minimum score
                 that we can achieve.

    Constraints:
    * 1 <= s.length, t.length <= 10^5
    * s and t consist of only lowercase English letters.*/

    int minimumScore(string s, string t) {
        vector<int> prefix;
        int j = 0;
        for (auto& ch : s) {
            if (j < t.size() && ch == t[j]) ++j;
            prefix.push_back(j);
        }
        int ans = t.size() - j;
        j = t.size();
        for (int i = s.size()-1; i >= 0; --i) {
            ans = min(ans, max(0, j - prefix[i]));
            if (0 < j && s[i] == t[j-1]) --j;
        }
        return min(ans, j);
    }


    /*2566. Maximum Difference by Remapping a Digit (Easy)
    You are given an integer num. You know that Danny Mittal will sneakily
    remap one of the 10 possible digits (0 to 9) to another digit. Return the
    difference between the maximum and minimum values Danny can make by
    remapping exactly one digit in num.

    Notes:
    * When Danny remaps a digit d1 to another digit d2, Danny replaces all
      occurrences of d1 in num with d2.
    * Danny can remap a digit to itself, in which case num does not change.
    * Danny can remap different digits for obtaining minimum and maximum values
      respectively.
    * The resulting number after remapping can contain leading zeroes.
    * We mentioned "Danny Mittal" to congratulate him on being in the top 10 in
      Weekly Contest 326.

    Example 1:
    Input: num = 11891
    Output: 99009
    Explanation: To achieve the maximum value, Danny can remap the digit 1 to
                 the digit 9 to yield 99899. To achieve the minimum value,
                 Danny can remap the digit 1 to the digit 0, yielding 890. The
                 difference between these two numbers is 99009.

    Example 2:
    Input: num = 90
    Output: 99
    Explanation: The maximum value that can be returned by the function is 99
                 (if 0 is replaced by 9) and the minimum value that can be
                 returned by the function is 0 (if 9 is replaced by 0). Thus,
                 we return 99.

    Constraints: 1 <= num <= 10^8*/

    int findBug(int num) {
        vector<int> digits;
        int v = 9, diff = 0;
        for (int x = num; x; x /= 10) {
            int d = x % 10;
            if (d < 9) v = d;
            digits.push_back(d);
        }
        reverse(digits.begin(), digits.end());
        for (auto& x : digits) {
            diff = 10*diff;
            if (x == digits[0]) diff += x;
            if (x == v) diff += 9-x;
        }
        return diff;
    }


    /*2567. Minimum Score by Changing Two Elements (Medium)
    You are given a 0-indexed integer array nums.
    * The low score of nums is the minimum value of |nums[i] - nums[j]| over
      all 0 <= i < j < nums.length.
    * The high score of nums is the maximum value of |nums[i] - nums[j]| over
      all 0 <= i < j < nums.length.
    * The score of nums is the sum of the high and low scores of nums.
    To minimize the score of nums, we can change the value of at most two
    elements of nums. Return the minimum possible score after changing the
    value of at most two elements of nums. Note that |x| denotes the absolute
    value of x.

    Example 1:
    Input: nums = [1,4,3]
    Output: 0
    Explanation: Change value of nums[1] and nums[2] to 1 so that nums becomes
                 [1,1,1]. Now, the value of |nums[i] - nums[j]| is always equal
                 to 0, so we return 0 + 0 = 0.

    Example 2:
    Input: nums = [1,4,7,8,5]
    Output: 3
    Explanation: Change nums[0] and nums[1] to be 6. Now nums becomes
                 [6,6,7,8,5]. Our low score is achieved when i = 0 and j = 1,
                 in which case |nums[i] - nums[j]| = |6 - 6| = 0. Our high
                 score is achieved when i = 3 and j = 4, in which case
                 |nums[i] - nums[j]| = |8 - 5| = 3. The sum of our high and low
                 score is 3, which we can prove to be minimal.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int minimizeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return min({nums[n-1]-nums[2], nums[n-2]-nums[1], nums[n-3]-nums[0]});
    }


    /*2568. Minimum Impossible OR (Medium)
    You are given a 0-indexed integer array nums. We say that an integer x is
    expressible from nums if there exist some integers
    0 <= index1 < index2 < ... < indexk < nums.length for which
    nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an
    integer is expressible if it can be written as the bitwise OR of some
    subsequence of nums. Return the minimum positive non-zero integer that is
    not expressible from nums.

    Example 1:
    Input: nums = [2,1]
    Output: 4
    Explanation: 1 and 2 are already present in the array. We know that 3 is
                 expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is
                 not expressible, we return 4.

    Example 2:
    Input: nums = [5,3,2]
    Output: 1
    Explanation: We can show that 1 is the smallest number that is not
                 expressible.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int minImpossibleOR(vector<int>& nums) {
        int mask = 0;
        for (auto& x : nums)
            if ((x & x-1) == 0) mask |= x;
        for (int i = 0; i < 32; ++i)
            if ((mask & 1<<i) == 0) return 1<<i;
        return -1;
    }


    /*2569. Handling Sum Queries After Update (Hard)
    You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries
    of queries. There are three types of queries:
    * For a query of type 1, queries[i] = [1, l, r]. Flip the values from 0 to
      1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-
      indexed.
    * For a query of type 2, queries[i] = [2, p, 0]. For every index 0 <= i < n,
      set nums2[i] = nums2[i] + nums1[i] * p.
    * For a query of type 3, queries[i] = [3, 0, 0]. Find the sum of the
      elements in nums2.
    Return an array containing all the answers to the third type queries.

    Example 1:
    Input: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]
    Output: [3]
    Explanation: After the first query nums1 becomes [1,1,1]. After the second
                 query, nums2 becomes [1,1,1], so the answer to the third query
                 is 3. Thus, [3] is returned.

    Example 2:
    Input: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]
    Output: [5]
    Explanation: After the first query, nums2 remains [5], so the answer to the
                 second query is 5. Thus, [5] is returned.

    Constraints:
    * 1 <= nums1.length,nums2.length <= 10^5
    * nums1.length = nums2.length
    * 1 <= queries.length <= 10^5
    * queries[i].length = 3
    * 0 <= l <= r <= nums1.length - 1
    * 0 <= p <= 10^6
    * 0 <= nums1[i] <= 1
    * 0 <= nums2[i] <= 10^9

class SegTreeLazy {
    int n = 0;
    vector<int> tree;
    vector<int> lazy;
    void build(vector<int>& arr, int k, int lo, int hi) {
        if (lo+1 == hi) tree[k] = arr[lo];
        else {
            int mid = lo + (hi-lo)/2;
            build(arr, 2*k+1, lo, mid);
            build(arr, 2*k+2, mid, hi);
            tree[k] = tree[2*k+1] + tree[2*k+2];
        }
    }
public:
    SegTreeLazy(vector<int>& arr) {
        n = arr.size();
        tree.resize(4*n);
        lazy.resize(4*n);
        build(arr, 0, 0, n);
    }

    void update(int qlo, int qhi, int k = 0, int lo = 0, int hi = 0) {
        if (hi == 0) hi = n;
        if (lazy[k]) {
            tree[k] = (hi - lo) - tree[k];
            if (lo+1 < hi) {
                lazy[2*k+1] ^= 1;
                lazy[2*k+2] ^= 1;
            }
            lazy[k] = 0;
        }
        if (lo < hi && qlo < hi && lo < qhi)
            if (qlo <= lo && hi <= qhi) {
                tree[k] = (hi - lo) - tree[k];
                if (lo+1 < hi) {
                    lazy[2*k+1] ^= 1;
                    lazy[2*k+2] ^= 1;
                }
            } else {
                int mid = lo + (hi - lo)/2;
                update(qlo, qhi, 2*k+1, lo, mid);
                update(qlo, qhi, 2*k+2, mid, hi);
                tree[k] = tree[2*k+1] + tree[2*k+2];
            }
    }

    int query() {
        return tree[0];
    }
};*/

    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {
        SegTreeLazy tree(nums1);
        vector<long long> ans;
        long long val = accumulate(nums2.begin(), nums2.end(), 0ll);
        for (auto& q : queries) {
            if (q[0] == 1) tree.update(q[1], q[2]+1);
            else if (q[0] == 2) val += (long long) q[1] * tree.query();
            else ans.push_back(val);
        }
        return ans;
    }


    /*2570. Merge Two 2D Arrays by Summing Values (Easy)
    You are given two 2D integer arrays nums1 and nums2.
    * nums1[i] = [idi, vali] indicate that the number with the id idi has a
      value equal to vali.
    * nums2[i] = [idi, vali] indicate that the number with the id idi has a
      value equal to vali.
    Each array contains unique ids and is sorted in ascending order by id.
    Merge the two arrays into one array that is sorted in ascending order by
    id, respecting the following conditions:
    * Only ids that appear in at least one of the two arrays should be included
      in the resulting array.
    * Each id should be included only once and its value should be the sum of
      the values of this id in the two arrays. If the id does not exist in one
      of the two arrays then its value in that array is considered to be 0.
    Return the resulting array. The returned array must be sorted in ascending
    order by id.

    Example 1:
    Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
    Output: [[1,6],[2,3],[3,2],[4,6]]
    Explanation: The resulting array contains the following:
                 - id = 1, the value of this id is 2 + 4 = 6.
                 - id = 2, the value of this id is 3.
                 - id = 3, the value of this id is 2.
                 - id = 4, the value of this id is 5 + 1 = 6.

    Example 2:
    Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
    Output: [[1,3],[2,4],[3,6],[4,3],[5,5]]
    Explanation: There are no common ids, so we just include each id with its
                 value in the resulting list.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 200
    * nums1[i].length == nums2[j].length == 2
    * 1 <= idi, vali <= 1000
    * Both arrays contain unique ids.
    * Both arrays are in strictly ascending order by id.*/

    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {
        vector<vector<int>> ans;
        for (int i = 0, j = 0; i < nums1.size() || j < nums2.size(); )
            if (j == nums2.size() || i < nums1.size() && nums1[i][0] <= nums2[j][0])
                ans.push_back(nums1[i++]);
            else {
                if (ans.size() && ans.back()[0] == nums2[j][0]) ans.back()[1] += nums2[j][1];
                else ans.push_back(nums2[j]);
                ++j;
            }
        return ans;
    }


    /*2571. Minimum Operations to Reduce an Integer to 0 (Easy)
    You are given a positive integer n, you can do the following operation any
    number of times:
    * Add or subtract a power of 2 from n.
    Return the minimum number of operations to make n equal to 0. A number x is
    power of 2 if x == 2i where i >= 0.

    Example 1:
    Input: n = 39
    Output: 3
    Explanation: We can do the following operations:
                 - Add 20 = 1 to n, so now n = 40.
                 - Subtract 23 = 8 from n, so now n = 32.
                 - Subtract 25 = 32 from n, so now n = 0.
                 It can be shown that 3 is the minimum number of operations we
                 need to make n equal to 0.

    Example 2:
    Input: n = 54
    Output: 3
    Explanation: We can do the following operations:
                 - Add 21 = 2 to n, so now n = 56.
                 - Add 23 = 8 to n, so now n = 64.
                 - Subtract 26 = 64 from n, so now n = 0.
                 So the minimum number of operations is 3.

    Constraints: 1 <= n <= 10^5*/

    int minOperations(int n) {
        int ans = 0, carry = 0;
        for (; n; n >>= 1) {
            carry += n & 1;
            if (carry == 1) {
                if (!(n&2)) carry = 0;
                ++ans;
            } else if (carry == 2) carry = 1;
        }
        return ans + carry;
    }


    /*2572. Count the Number of Square-Free Subsets (Medium)
    You are given a positive integer 0-indexed array nums. A subset of the
    array nums is square-free if the product of its elements is a square-free
    integer. A square-free integer is an integer that is divisible by no square
    number other than 1. Return the number of square-free non-empty subsets of
    the array nums. Since the answer may be too large, return it modulo
    10^9 + 7. A non-empty subset of nums is an array that can be obtained by
    deleting some (possibly none but not all) elements from nums. Two subsets
    are different if and only if the chosen indices to delete are different.

    Example 1:
    Input: nums = [3,4,4,5]
    Output: 3
    Explanation: There are 3 square-free subsets in this example:
                 - The subset consisting of the 0th element [3]. The product of
                   its elements is 3, which is a square-free integer.
                 - The subset consisting of the 3rd element [5]. The product of
                   its elements is 5, which is a square-free integer.
                 - The subset consisting of 0th and 3rd elements [3,5]. The
                   product of its elements is 15, which is a square-free
                   integer.
                 It can be proven that there are no more than 3 square-free
                 subsets in the given array.

    Example 2:
    Input: nums = [1]
    Output: 1
    Explanation: There is 1 square-free subset in this example:
                 - The subset consisting of the 0th element [1]. The product of
                   its elements is 1, which is a square-free integer.
                 It can be proven that there is no more than 1 square-free
                 subset in the given array.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 30*/

    int squareFreeSubsets(vector<int>& nums) {
        const int mod = 1'000'000'007;
        vector<int> freq(31), mask(31), primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
        for (auto& x : nums) ++freq[x];
        long pow = 1, v = 2;
        for (int p = freq[1]; p; p >>= 1) {
            if (p & 1) pow = pow * v % mod;
            v = v * v % mod;
        }
        for (int x = 2; x <= 30; ++x) {
            int m = 0, v = 1;
            for (int i = 0; i < 10; ++i)
                if (x % primes[i] == 0) v *= primes[i], m ^= 1 <<i;
            if (v == x) mask[x] = m;
        }
        vector<vector<long>> dp(1<<10, vector<long>(32));
        for (int j = 0; j <= 31; ++j) dp[0][j] = 1;
        for (int i = 1; i < 1<<10; ++i)
            for (int j = 2; j <= 30; ++j)
                for (int jj = j; jj <= 30; ++jj)
                    if (mask[jj] && (mask[jj] & i) == mask[jj])
                        dp[i][j] = (dp[i][j] + freq[jj]*dp[i^mask[jj]][jj+1]) % mod;
        long ans = 1;
        for (int i = 1; i < 1<<10; ++i) ans = (ans + dp[i][2]) % mod;
        return (ans * pow - 1) % mod;
    }


    /*2573. Find the String with LCP (Hard)
    We define the lcp matrix of any 0-indexed string word of n lowercase
    English letters as an n x n grid such that:
    * lcp[i][j] is equal to the length of the longest common prefix between the
      substrings word[i,n-1] and word[j,n-1].
    Given an n x n matrix lcp, return the alphabetically smallest string word
    that corresponds to lcp. If there is no such string, return an empty string.
    A string a is lexicographically smaller than a string b (of the same length)
    if in the first position where a and b differ, string a has a letter that
    appears earlier in the alphabet than the corresponding letter in b. For
    example, "aabd" is lexicographically smaller than "aaca" because the first
    position they differ is at the third letter, and 'b' comes before 'c'.

    Example 1:
    Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]
    Output: "abab"
    Explanation: lcp corresponds to any 4 letter string with two alternating
                 letters. The lexicographically smallest of them is "abab".

    Example 2:
    Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]
    Output: "aaaa"
    Explanation: lcp corresponds to any 4 letter string with a single distinct
                 letter. The lexicographically smallest of them is "aaaa".

    Example 3:
    Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]
    Output: ""
    Explanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of
                 only a single letter; Thus, no answer exists.

    Constraints:
    * 1 <= n == lcp.length == lcp[i].length <= 1000
    * 0 <= lcp[i][j] <= n*/

    string findTheString(vector<vector<int>>& lcp) {
        int n = lcp.size();
        string ans = string(n, '*');
        for (int i = 0, c = 0; i < n; ++i) {
            if (lcp[i][i] != n-i) return "";
            for (int j = i+1; j < n; ++j)
                if (lcp[i][j] != lcp[j][i] || lcp[i][j] && lcp[i][j] != 1 + (i+1 < n && j+1 < n ? lcp[i+1][j+1] : 0)) return "";
            if (ans[i] == '*') {
                for (int j = i; j < n; ++j)
                    if (lcp[i][j]) {
                        if (ans[j] != '*' || c == 26) return "";
                        ans[j] = 'a' + c;
                    }
                ++c;
            }
        }
        return ans;
    }


    /*2574. Left and Right Sum Differences (Easy)
    Given a 0-indexed integer array nums, find a 0-indexed integer array answer
    where:
    * answer.length == nums.length.
    * answer[i] = |leftSum[i] - rightSum[i]|.
    Where:
    * leftSum[i] is the sum of elements to the left of the index i in the array
      nums. If there is no such element, leftSum[i] = 0.
    * rightSum[i] is the sum of elements to the right of the index i in the
      array nums. If there is no such element, rightSum[i] = 0.
    Return the array answer.

    Example 1:
    Input: nums = [10,4,8,3]
    Output: [15,1,11,22]
    Explanation: The array leftSum is [0,10,14,22] and the array rightSum is
                 [15,11,3,0]. The array answer is
                 [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].

    Example 2:
    Input: nums = [1]
    Output: [0]
    Explanation: The array leftSum is [0] and the array rightSum is [0]. The
                 array answer is [|0 - 0|] = [0].

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5*/

    vector<int> leftRigthDifference(vector<int>& nums) {
        vector<int> ans;
        int diff = accumulate(nums.begin(), nums.end(), 0);
        for (auto& x : nums) {
            ans.push_back(abs(diff - x));
            diff -= 2*x;
        }
        return ans;
    }


    /*2575. Find the Divisibility Array of a String (Medium)
    You are given a 0-indexed string word of length n consisting of digits, and
    a positive integer m. The divisibility array div of word is an integer
    array of length n such that:
    * div[i] = 1 if the numeric value of word[0,...,i] is divisible by m, or
    * div[i] = 0 otherwise.
    Return the divisibility array of word.

    Example 1:
    Input: word = "998244353", m = 3
    Output: [1,1,0,0,0,1,1,0,0]
    Explanation: There are only 4 prefixes that are divisible by 3: "9", "99",
                 "998244", and "9982443".

    Example 2:
    Input: word = "1010", m = 10
    Output: [0,1,0,1]
    Explanation: There are only 2 prefixes that are divisible by 10: "10", and
                 "1010".

    Constraints:
    * 1 <= n <= 10^5
    * word.length == n
    * word consists of digits from 0 to 9
    * 1 <= m <= 10^9*/

    vector<int> divisibilityArray(string word, int m) {
        vector<int> ans;
        long prefix = 0;
        for (auto& ch : word) {
            prefix = 10*prefix + (ch - '0');
            prefix %= m;
            if (prefix == 0) ans.push_back(1);
            else ans.push_back(0);
        }
        return ans;
    }


    /*2576. Find the Maximum Number of Marked Indices (Medium)
    You are given a 0-indexed integer array nums. Initially, all of the indices
    are unmarked. You are allowed to make this operation any number of times:
    * Pick two different unmarked indices i and j such that
      2 * nums[i] <= nums[j], then mark i and j.
    Return the maximum possible number of marked indices in nums using the
    above operation any number of times.

    Example 1:
    Input: nums = [3,5,2,4]
    Output: 2
    Explanation: In the first operation: pick i = 2 and j = 1, the operation is
                 allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and
                 1. It can be shown that there's no other valid operation so
                 the answer is 2.

    Example 2:
    Input: nums = [9,2,5,4]
    Output: 4
    Explanation: In the first operation: pick i = 3 and j = 0, the operation is
                 allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and
                 0. In the second operation: pick i = 1 and j = 2, the
                 operation is allowed because 2 * nums[1] <= nums[2]. Then mark
                 index 1 and 2. Since there is no other operation, the answer
                 is 4.

    Example 3:
    Input: nums = [7,6,8]
    Output: 0
    Explanation: There is no valid operation to do, so the answer is 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int maxNumOfMarkedIndices(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        for (int n = nums.size(), i = n/2-1, j = n-1; i >= 0; --i)
            if (nums[i] * 2 <= nums[j]) {
                ans += 2;
                --j;
            }
        return ans;
    }


    /*2577. Minimum Time to Visit a Cell In a Grid (Hard)
    You are given a m x n matrix grid consisting of non-negative integers where
    grid[row][col] represents the minimum time required to be able to visit the
    cell (row, col), which means you can visit the cell (row, col) only when
    the time you visit it is greater than or equal to grid[row][col]. You are
    standing in the top-left cell of the matrix in the 0th second, and you must
    move to any adjacent cell in the four directions: up, down, left, and right.
    Each move you make takes 1 second. Return the minimum time required in
    which you can visit the bottom-right cell of the matrix. If you cannot
    visit the bottom-right cell, then return -1.

    Example 1:
    Input: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
    Output: 7
    Explanation: One of the paths that we can take is the following:
                 - at t = 0, we are on the cell (0,0).
                 - at t = 1, we move to the cell (0,1). It is possible because
                   grid[0][1] <= 1.
                 - at t = 2, we move to the cell (1,1). It is possible because
                   grid[1][1] <= 2.
                 - at t = 3, we move to the cell (1,2). It is possible because
                   grid[1][2] <= 3.
                 - at t = 4, we move to the cell (1,1). It is possible because
                   grid[1][1] <= 4.
                 - at t = 5, we move to the cell (1,2). It is possible because
                   grid[1][2] <= 5.
                 - at t = 6, we move to the cell (1,3). It is possible because
                   grid[1][3] <= 6.
                 - at t = 7, we move to the cell (2,3). It is possible because
                   grid[1][3] <= 7.
                 The final time is 7. It can be shown that it is the minimum
                 time possible.

    Example 2:
    Input: grid = [[0,2,4],[3,2,1],[1,0,4]]
    Output: -1
    Explanation: There is no path from the top left to the bottom-right cell.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 1000
    * 4 <= m * n <= 10^5
    * 0 <= grid[i][j] <= 10^5
    * grid[0][0] == 0*/

    int minimumTime(vector<vector<int>>& grid) {
        if (grid[0][1] <= 1 || grid[1][0] <= 1) {
            int m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1};
            priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
            pq.emplace(0, 0, 0);
            vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
            dist[0][0] = 0;
            while (pq.size()) {
                auto [x, i, j] = pq.top(); pq.pop();
                if (i == m-1 && j == n-1) return x;
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n) {
                        int xx = x + 1 + max(0, (grid[ii][jj]-x)/2*2);
                        if (dist[ii][jj] > xx) {
                            pq.emplace(xx, ii, jj);
                            dist[ii][jj] = xx;
                        }
                    }
                }
            }
        }
        return -1;
    }


    /*2582. Pass the Pillow (Easy)
    There are n people standing in a line labeled from 1 to n. The first person
    in the line is holding a pillow initially. Every second, the person holding
    the pillow passes it to the next person standing in the line. Once the
    pillow reaches the end of the line, the direction changes, and people
    continue passing the pillow in the opposite direction.
    * For example, once the pillow reaches the nth person they pass it to the
      n - 1th person, then to the n - 2th person and so on.
    Given the two positive integers n and time, return the index of the person
    holding the pillow after time seconds.

    Example 1:
    Input: n = 4, time = 5
    Output: 2
    Explanation: People pass the pillow in the following way:
                 1 -> 2 -> 3 -> 4 -> 3 -> 2. Afer five seconds, the pillow is
                 given to the 2nd person.

    Example 2:
    Input: n = 3, time = 2
    Output: 3
    Explanation: People pass the pillow in the following way: 1 -> 2 -> 3. Afer
                 two seconds, the pillow is given to the 3rd person.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= time <= 1000*/

    int passThePillow(int n, int time) {
        time %= 2*(n-1);
        if (time > n-1) time = 2*(n-1) - time;
        return time+1;
    }


    /*2583. Kth Largest Sum in a Binary Tree (Medium)
    You are given the root of a binary tree and a positive integer k. The level
    sum in the tree is the sum of the values of the nodes that are on the same
    level. Return the kth largest level sum in the tree (not necessarily
    distinct). If there are fewer than k levels in the tree, return -1. Note
    that two nodes are on the same level if they have the same distance from
    the root.

    Example 1:
    Input: root = [5,8,9,2,1,3,7,4,6], k = 2
    Output: 13
    Explanation: The level sums are the following:
                 - Level 1: 5.
                 - Level 2: 8 + 9 = 17.
                 - Level 3: 2 + 1 + 3 + 7 = 13.
                 - Level 4: 4 + 6 = 10.
                 The 2nd largest level sum is 13.

    Example 2:
    Input: root = [1,2,null,3], k = 1
    Output: 3
    Explanation: The largest level sum is 3.

    Constraints:
    * The number of nodes in the tree is n.
    * 2 <= n <= 10^5
    * 1 <= Node.val <= 10^6
    * 1 <= k <= n*/

    long long kthLargestLevelSum(TreeNode* root, int k) {
        vector<long long> vals;
        stack<pair<TreeNode*, int>> stk;
        stk.emplace(root, 0);
        while (stk.size()) {
            auto [node, i] = stk.top(); stk.pop();
            if (i == vals.size()) vals.push_back(0);
            vals[i] += node->val;
            if (node->left) stk.emplace(node->left, i+1);
            if (node->right) stk.emplace(node->right, i+1);
        }
        if (vals.size() < k) return -1;
        nth_element(vals.begin(), vals.begin()+k-1, vals.end(), greater<>());
        return vals[k-1];
    }


    /*2584. Split the Array to Make Coprime Products (Medium)
    You are given a 0-indexed integer array nums of length n. A split at an
    index i where 0 <= i <= n - 2 is called valid if the product of the first
    i + 1 elements and the product of the remaining elements are coprime.
    * For example, if nums = [2, 3, 3], then a split at the index i = 0 is
      valid because 2 and 9 are coprime, while a split at the index i = 1 is
      not valid because 6 and 3 are not coprime. A split at the index i = 2 is
      not valid because i == n - 1.
    Return the smallest index i at which the array can be split validly or -1
    if there is no such split. Two values val1 and val2 are coprime if
    gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor
    of val1 and val2.

    Example 1:
    Input: nums = [4,7,8,15,3,5]
    Output: 2
    Explanation: The table above shows the values of the product of the first
                 i + 1 elements, the remaining elements, and their gcd at each
                 index i. The only valid split is at index 2.

    Example 2:
    Input: nums = [4,7,15,8,3,5]
    Output: -1
    Explanation: The table above shows the values of the product of the first
                 i + 1 elements, the remaining elements, and their gcd at each
                 index i. There is no valid split.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^4
    * 1 <= nums[i] <= 10^6*/

    int findValidSplit(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (auto x : nums) {
            for (int p = 2; p <= sqrt(x); ++p)
                for (; x % p == 0; ++freq[p], x /= p);
            if (x > 1) ++freq[x];
        }
        unordered_set<int> ovlp;
        for (int i = 0, x = nums[0]; i < nums.size()-1; x = nums[++i]) {
            for (int p = 2; p <= sqrt(x); ++p)
                for (; x % p == 0; x /= p) {
                    ovlp.insert(p);
                    if (--freq[p] == 0) ovlp.erase(p);
                }
            if (x > 1) {
                ovlp.insert(x);
                if (--freq[x] == 0) ovlp.erase(x);
            }
            if (!ovlp.size()) return i;
        }
        return -1;
    }


    /*2585. Number of Ways to Earn Points (Hard)
    There is a test that has n types of questions. You are given an integer
    target and a 0-indexed 2D integer array types where
    types[i] = [counti, marksi] indicates that there are counti questions of
    the ith type, and each one of them is worth marksi points. Return the
    number of ways you can earn exactly target points in the exam. Since the
    answer may be too large, return it modulo 10^9 + 7. Note that questions of
    the same type are indistinguishable. For example, if there are 3 questions
    of the same type, then solving the 1st and 2nd questions is the same as
    solving the 1st and 3rd questions, or the 2nd and 3rd questions.

    Example 1:
    Input: target = 6, types = [[6,1],[3,2],[2,3]]
    Output: 7
    Explanation: You can earn 6 points in one of the seven ways:
                 - Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6
                 - Solve 4 questions of the 0th type and 1 question of the 1st
                   type: 1 + 1 + 1 + 1 + 2 = 6
                 - Solve 2 questions of the 0th type and 2 questions of the 1st
                   type: 1 + 1 + 2 + 2 = 6
                 - Solve 3 questions of the 0th type and 1 question of the 2nd
                   type: 1 + 1 + 1 + 3 = 6
                 - Solve 1 question of the 0th type, 1 question of the 1st type
                   and 1 question of the 2nd type: 1 + 2 + 3 = 6
                 - Solve 3 questions of the 1st type: 2 + 2 + 2 = 6
                 - Solve 2 questions of the 2nd type: 3 + 3 = 6

    Example 2:
    Input: target = 5, types = [[50,1],[50,2],[50,5]]
    Output: 4
    Explanation: You can earn 5 points in one of the four ways:
                 - Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5
                 - Solve 3 questions of the 0th type and 1 question of the 1st
                   type: 1 + 1 + 1 + 2 = 5
                 - Solve 1 questions of the 0th type and 2 questions of the 1st
                   type: 1 + 2 + 2 = 5
                 - Solve 1 question of the 2nd type: 5

    Example 3:
    Input: target = 18, types = [[6,1],[3,2],[2,3]]
    Output: 1
    Explanation: You can only earn 18 points by answering all questions.

    Constraints:
    * 1 <= target <= 1000
    * n == types.length
    * 1 <= n <= 50
    * types[i].length == 2
    * 1 <= counti, marksi <= 50*/

    int waysToReachTarget(int target, vector<vector<int>>& types) {
        int n = types.size(), mod = 1'000'000'007;
        vector<vector<long>> dp(target+1, vector<long>(n+1));
        for (int j = 0; j <= n; ++j) dp[0][j] = 1;
        for (int i = 1; i <= target; ++i)
            for (int j = n-1; j >= 0; --j) {
                int c = types[j][0], m = types[j][1];
                for (int x = 0; x <= c && i-x*m >= 0; ++x)
                    dp[i][j] = (dp[i][j] + dp[i-x*m][j+1]) % mod;
            }
        return dp[target][0];
    }


    /*2586. Count the Number of Vowel Strings in Range (Easy)
    You are given a 0-indexed array of string words and two integers left and
    right. A string is called a vowel string if it starts with a vowel
    character and ends with a vowel character where vowel characters are 'a',
    'e', 'i', 'o', and 'u'. Return the number of vowel strings words[i] where i
    belongs to the inclusive range [left, right].

    Example 1:
    Input: words = ["are","amy","u"], left = 0, right = 2
    Output: 2
    Explanation: - "are" is a vowel string because it starts with 'a' and ends
                   with 'e'.
                 - "amy" is not a vowel string because it does not end with a
                   vowel.
                 - "u" is a vowel string because it starts with 'u' and ends
                   with 'u'.
                 The number of vowel strings in the mentioned range is 2.

    Example 2:
    Input: words = ["hey","aeo","mu","ooo","artro"], left = 1, right = 4
    Output: 3
    Explanation: - "aeo" is a vowel string because it starts with 'a' and ends
                   with 'o'.
                 - "mu" is not a vowel string because it does not start with a
                   vowel.
                 - "ooo" is a vowel string because it starts with 'o' and ends
                   with 'o'.
                 - "artro" is a vowel string because it starts with 'a' and
                   ends with 'o'.
                 The number of vowel strings in the mentioned range is 3.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 10
    * words[i] consists of only lowercase English letters.
    * 0 <= left <= right < words.length*/

    int vowelStrings(vector<string>& words, int left, int right) {
        int ans = 0;
        string vowel = "aeiou";
        for (int i = left; i <= right; ++i)
            if (vowel.find(words[i][0]) != string::npos && vowel.find(words[i].back()) != string::npos) ++ans;
        return ans;
    }


    /*2587. Rearrange Array to Maximize Prefix Score (Medium)
    You are given a 0-indexed integer array nums. You can rearrange the
    elements of nums to any order (including the given order). Let prefix be
    the array containing the prefix sums of nums after rearranging it. In other
    words, prefix[i] is the sum of the elements from 0 to i in nums after
    rearranging it. The score of nums is the number of positive integers in the
    array prefix. Return the maximum score you can achieve.

    Example 1:
    Input: nums = [2,-1,0,1,-3,3,-3]
    Output: 6
    Explanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].
                 prefix = [2,5,6,5,2,2,-1], so the score is 6. It can be shown
                 that 6 is the maximum score we can obtain.

    Example 2:
    Input: nums = [-2,-3,0]
    Output: 0
    Explanation: Any rearrangement of the array will result in a score of 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^6 <= nums[i] <= 10^6*/

    int maxScore(vector<int>& nums) {
        sort(nums.begin(), nums.end(), greater<>());
        long prefix = 0;
        for (int i = 0; i < nums.size(); ++i) {
            prefix += nums[i];
            if (prefix <= 0) return i;
        }
        return nums.size();
    }


    /*2588. Count the Number of Beautiful Subarrays (Medium)
    You are given a 0-indexed integer array nums. In one operation, you can:
    * Choose two different indices i and j such that 0 <= i, j < nums.length.
    * Choose a non-negative integer k such that the kth bit (0-indexed) in the
      binary representation of nums[i] and nums[j] is 1.
    * Subtract 2k from nums[i] and nums[j].
    A subarray is beautiful if it is possible to make all of its elements equal
    to 0 after applying the above operation any number of times. Return the
    number of beautiful subarrays in the array nums. A subarray is a contiguous
    non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [4,3,1,2,4]
    Output: 2
    Explanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and
                 [4,3,1,2,4].
                 - We can make all elements in the subarray [3,1,2] equal to 0
                   in the following way:
                   - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers.
                     The subarray becomes [1, 1, 0].
                   - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers.
                     The subarray becomes [0, 0, 0].
                 - We can make all elements in the subarray [4,3,1,2,4] equal
                   to 0 in the following way:
                   - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both
                     numbers. The subarray becomes [0, 3, 1, 2, 0].
                   - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both
                     numbers. The subarray becomes [0, 2, 0, 2, 0].
                   - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both
                     numbers. The subarray becomes [0, 0, 0, 0, 0].

    Example 2:
    Input: nums = [1,10,4]
    Output: 0
    Explanation: There are no beautiful subarrays in nums.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6*/

    long long beautifulSubarrays(vector<int>& nums) {
        long long ans = 0;
        int prefix = 0;
        unordered_map<int, int> freq = {{0, 1}};
        for (auto& x : nums) {
            prefix ^= x;
            ans += freq[prefix]++;
        }
        return ans;
    }


    /*2589. Minimum Time to Complete All Tasks (Hard)
    There is a computer that can run an unlimited number of tasks at the same
    time. You are given a 2D integer array tasks where
    tasks[i] = [starti, endi, durationi] indicates that the ith task should run
    for a total of durationi seconds (not necessarily continuous) within the
    inclusive time range [starti, endi]. You may turn on the computer only when
    it needs to run a task. You can also turn it off if it is idle. Return the
    minimum time during which the computer should be turned on to complete all
    tasks.

    Example 1:
    Input: tasks = [[2,3,1],[4,5,1],[1,5,2]]
    Output: 2
    Explanation: - The first task can be run in the inclusive time range [2, 2].
                 - The second task can be run in the inclusive time range [5, 5].
                 - The third task can be run in the two inclusive time ranges
                   [2, 2] and [5, 5].
                 The computer will be on for a total of 2 seconds.

    Example 2:
    Input: tasks = [[1,3,2],[2,5,3],[5,6,2]]
    Output: 4
    Explanation: - The first task can be run in the inclusive time range [2, 3].
                 - The second task can be run in the inclusive time ranges
                   [2, 3] and [5, 5].
                 - The third task can be run in the two inclusive time range
                   [5, 6].
                 The computer will be on for a total of 4 seconds.

    Constraints:
    * 1 <= tasks.length <= 2000
    * tasks[i].length == 3
    * 1 <= starti, endi <= 2000
    * 1 <= durationi <= endi - starti + 1*/

    int findMinimumTime(vector<vector<int>>& tasks) {
        vector<int> line(2001);
        sort(tasks.begin(), tasks.end(), [](auto& lhs, auto& rhs) {return lhs[1] < rhs[1];});
        for (auto& t : tasks) {
            int lo = t[0], hi = t[1], time = t[2], cnt = 0;
            for (int x = lo; x <= hi && time; ++x) time -= line[x];
            for (int x = hi; x >= lo && time; --x)
                if (!line[x]) {
                    line[x] = 1;
                    --time;
                }
        }
        return accumulate(line.begin(), line.end(), 0);
    }


    /*2591. Distribute Money to Maximum Children (Easy)
    You are given an integer money denoting the amount of money (in dollars)
    that you have and another integer children denoting the number of children
    that you must distribute the money to. You have to distribute the money
    according to the following rules:
    * All money must be distributed.
    * Everyone must receive at least 1 dollar.
    * Nobody receives 4 dollars.
    Return the maximum number of children who may receive exactly 8 dollars if
    you distribute the money according to the aforementioned rules. If there is
    no way to distribute the money, return -1.

    Example 1:
    Input: money = 20, children = 3
    Output: 1
    Explanation: The maximum number of children with 8 dollars will be 1. One
                 of the ways to distribute the money is:
                 - 8 dollars to the first child.
                 - 9 dollars to the second child.
                 - 3 dollars to the third child.
                 It can be proven that no distribution exists such that number
                 of children getting 8 dollars is greater than 1.

    Example 2:
    Input: money = 16, children = 2
    Output: 2
    Explanation: Each child can be given 8 dollars.

    Constraints:
    * 1 <= money <= 200
    * 2 <= children <= 30*/

    int distMoney(int money, int children) {
        if (money < children) return -1;
        if (money > 8*children) return children-1;
        int ans = (money-children)/7;
        if (ans == children-1 && (money-children) % 7 == 3) --ans;
        return ans;
    }


    /*2592. Maximize Greatness of an Array (Medium)
    You are given a 0-indexed integer array nums. You are allowed to permute
    nums into a new array perm of your choosing. We define the greatness of
    nums be the number of indices 0 <= i < nums.length for which
    perm[i] > nums[i]. Return the maximum possible greatness you can achieve
    after permuting nums.

    Example 1:
    Input: nums = [1,3,5,2,1,3,1]
    Output: 4
    Explanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].
                 At indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we
                 return 4.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 3
    Explanation: We can prove the optimal perm is [2,3,4,1]. At indices = 0, 1,
                 and 2, perm[i] > nums[i]. Hence, we return 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9*/

    int maximizeGreatness(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int k = 0;
        for (auto& x : nums)
            if (nums[k] < x) ++k;
        return k;
    }


    /*2593. Find Score of an Array After Marking All Elements (Medium)
    You are given an array nums consisting of positive integers. Starting with
    score = 0, apply the following algorithm:
    * Choose the smallest integer of the array that is not marked. If there is
      a tie, choose the one with the smallest index.
    * Add the value of the chosen integer to score.
    * Mark the chosen element and its two adjacent elements if they exist.
    * Repeat until all the array elements are marked.
    Return the score you get after applying the above algorithm.

    Example 1:
    Input: nums = [2,1,3,4,5,2]
    Output: 7
    Explanation: We mark the elements as follows:
                 - 1 is the smallest unmarked element, so we mark it and its
                   two adjacent elements: [2,1,3,4,5,2].
                 - 2 is the smallest unmarked element, so we mark it and its
                   left adjacent element: [2,1,3,4,5,2].
                 - 4 is the only remaining unmarked element, so we mark it:
                   [2,1,3,4,5,2].
                 Our score is 1 + 2 + 4 = 7.

    Example 2:
    Input: nums = [2,3,5,1,3,2]
    Output: 5
    Explanation: We mark the elements as follows:
                 - 1 is the smallest unmarked element, so we mark it and its
                   two adjacent elements: [2,3,5,1,3,2].
                 - 2 is the smallest unmarked element, since there are two of
                   them, we choose the left-most one, so we mark the one at
                   index 0 and its right adjacent element: [2,3,5,1,3,2].
                 - 2 is the only remaining unmarked element, so we mark it:
                   [2,3,5,1,3,2].
                 Our score is 1 + 2 + 2 = 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    long long findScore(vector<int>& nums) {
        long long ans = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        for (int i = 0; i < nums.size(); ++i)
            pq.emplace(nums[i], i);
        vector<bool> mark(nums.size());
        while (pq.size()) {
            auto [x, i] = pq.top(); pq.pop();
            if (!mark[i]) {
                ans += x;
                mark[i] = true;
                if (i) mark[i-1] = true;
                if (i+1 < nums.size()) mark[i+1] = true;
            }
        }
        return ans;
    }


    /*2594. Minimum Time to Repair Cars (Medium)
    You are given an integer array ranks representing the ranks of some
    mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r
    can repair n cars in r * n2 minutes. You are also given an integer cars
    representing the total number of cars waiting in the garage to be repaired.
    Return the minimum time taken to repair all the cars. Note: All the
    mechanics can repair the cars simultaneously.

    Example 1:
    Input: ranks = [4,2,3,1], cars = 10
    Output: 16
    Explanation: - The first mechanic will repair two cars. The time required
                   is 4 * 2 * 2 = 16 minutes.
                 - The second mechanic will repair two cars. The time required
                   is 2 * 2 * 2 = 8 minutes.
                 - The third mechanic will repair two cars. The time required
                   is 3 * 2 * 2 = 12 minutes.
                 - The fourth mechanic will repair four cars. The time required
                   is 1 * 4 * 4 = 16 minutes.
                 It can be proved that the cars cannot be repaired in less than
                 16 minutes.

    Example 2:
    Input: ranks = [5,1,8], cars = 6
    Output: 16
    Explanation: - The first mechanic will repair one car. The time required is
                   5 * 1 * 1 = 5 minutes.
                 - The second mechanic will repair four cars. The time required
                   is 1 * 4 * 4 = 16 minutes.
                 - The third mechanic will repair one car. The time required is
                   8 * 1 * 1 = 8 minutes.
                 It can be proved that the cars cannot be repaired in less than
                 16 minutes.

    Constraints:
    * 1 <= ranks.length <= 10^5
    * 1 <= ranks[i] <= 100
    * 1 <= cars <= 10^6*/

    long long repairCars(vector<int>& ranks, int cars) {
        long long lo = 0, hi = (long long) *max_element(ranks.begin(), ranks.end()) * cars * cars;
        while (lo < hi) {
            long long mid = lo + (hi - lo)/2, cnt = 0;
            for (auto& x : ranks) cnt += sqrt(mid/x);
            if (cnt < cars) lo = mid+1;
            else hi = mid;
        }
        return lo;
    }


    /*2595. Number of Even and Odd Bits (Easy)
    You are given a positive integer n. Let even denote the number of even
    indices in the binary representation of n (0-indexed) with value 1. Let odd
    denote the number of odd indices in the binary representation of n
    (0-indexed) with value 1. Return an integer array answer where
    answer = [even, odd].

    Example 1:
    Input: n = 17
    Output: [2,0]
    Explanation: The binary representation of 17 is 10001. It contains 1 on the
                 0th and 4th indices. There are 2 even and 0 odd indices.

    Example 2:
    Input: n = 2
    Output: [0,1]
    Explanation: The binary representation of 2 is 10. It contains 1 on the 1st
                 index. There are 0 even and 1 odd indices.

    Constraints: 1 <= n <= 1000*/

    vector<int> evenOddBit(int n) {
        vector<int> ans(2);
        for (int i = 0; n; n >>= 1, i ^= 1)
            if (n & 1) ++ans[i];
        return ans;
    }


    /*2596. Check Knight Tour Configuration (Medium)
    There is a knight on an n x n chessboard. In a valid configuration, the
    knight starts at the top-left cell of the board and visits every cell on
    the board exactly once. You are given an n x n integer matrix grid
    consisting of distinct integers from the range [0, n * n - 1] where
    grid[row][col] indicates that the cell (row, col) is the grid[row][col]th
    cell that the knight visited. The moves are 0-indexed. Return true if grid
    represents a valid configuration of the knight's movements or false
    otherwise. Note that a valid knight move consists of moving two squares
    vertically and one square horizontally, or two squares horizontally and one
    square vertically. The figure below illustrates all the possible eight
    moves of a knight from some cell.

    Example 1:
    Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
    Output: true
    Explanation: The above diagram represents the grid. It can be shown that it
                 is a valid configuration.

    Example 2:
    Input: grid = [[0,3,6],[5,8,1],[2,7,4]]
    Output: false
    Explanation: The above diagram represents the grid. The 8th move of the
                 knight is not valid considering its position after the 7th
                 move.

    Constraints:
    * n == grid.length == grid[i].length
    * 3 <= n <= 7
    * 0 <= grid[row][col] < n * n
    * All integers in grid are unique.*/

    bool checkValidGrid(vector<vector<int>>& grid) {
        int n = grid.size();
        unordered_map<int, pair<int, int>> loc;
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                loc[grid[i][j]] = {i, j};
        for (int ii = 0, jj = 0, x = 1; x < n*n; ++x) {
            auto [i, j] = loc[x];
            int di = abs(i-ii), dj = abs(j-jj);
            if (!(di == 1 && dj == 2 || di == 2 && dj == 1)) return false;
            ii = i, jj = j;
        }
        return true;
    }


    /*2597. The Number of Beautiful Subsets (Medium)
    You are given an array nums of positive integers and a positive integer k.
    A subset of nums is beautiful if it does not contain two integers with an
    absolute difference equal to k. Return the number of non-empty beautiful
    subsets of the array nums. A subset of nums is an array that can be
    obtained by deleting some (possibly none) elements from nums. Two subsets
    are different if and only if the chosen indices to delete are different.

    Example 1:
    Input: nums = [2,4,6], k = 2
    Output: 4
    Explanation: The beautiful subsets of the array nums are: [2], [4], [6],
                 [2, 6]. It can be proved that there are only 4 beautiful
                 subsets in the array [2,4,6].

    Example 2:
    Input: nums = [1], k = 1
    Output: 1
    Explanation: The beautiful subset of the array nums is [1]. It can be
                 proved that there is only 1 beautiful subset in the array [1].

    Constraints:
    * 1 <= nums.length <= 20
    * 1 <= nums[i], k <= 1000*/

    int beautifulSubsets(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        vector<int> keys;
        for (auto& [x, _] : freq) keys.push_back(x);
        sort(keys.begin(), keys.end());
        unordered_map<int, vector<int>> mp;
        for (auto& x : keys) {
            mp[x-k].push_back(x);
            mp[x] = mp[x-k];
            mp.erase(x-k);
        }
        int ans = 1;
        for (auto& [_, v] : mp) {
            int f0 = 1, f1 = 1;
            for (auto& x : v) {
                int f2 = f0 * (pow(2, freq[x])-1) + f1;
                f0 = f1;
                f1 = f2;
            }
            ans *= f1;
        }
        return ans-1;
    }


    /*2598. Smallest Missing Non-negative Integer After Operations (Medium)
    You are given a 0-indexed integer array nums and an integer value. In one
    operation, you can add or subtract value from any element of nums.
    * For example, if nums = [1,2,3] and value = 2, you can choose to subtract
      value from nums[0] to make nums = [-1,2,3].
    The MEX (minimum excluded) of an array is the smallest missing non-
    negative integer in it.
    * For example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.
    Return the maximum MEX of nums after applying the mentioned operation any
    number of times.

    Example 1:
    Input: nums = [1,-10,7,13,6,8], value = 5
    Output: 4
    Explanation: One can achieve this result by applying the following
                 operations:
                 - Add value to nums[1] twice to make nums = [1,0,7,13,6,8]
                 - Subtract value from nums[2] once to make
                   nums = [1,0,2,13,6,8]
                 - Subtract value from nums[3] twice to make
                   nums = [1,0,2,3,6,8]
                 The MEX of nums is 4. It can be shown that 4 is the maximum
                 MEX we can achieve.

    Example 2:
    Input: nums = [1,-10,7,13,6,8], value = 7
    Output: 2
    Explanation: One can achieve this result by applying the following
                 operation:
                 - subtract value from nums[2] once to make
                   nums = [1,-10,0,13,6,8]
                 The MEX of nums is 2. It can be shown that 2 is the maximum
                 MEX we can achieve.

    Constraints:
    * 1 <= nums.length, value <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    int findSmallestInteger(vector<int>& nums, int value) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[(x % value + value) % value];
        int k = 0;
        for (int x = 1; x < value; ++x)
            if (freq[x] < freq[k]) k = x;
        return k + freq[k] * value;
    }


    /*2599. Make the Prefix Sum Non-negative (Medium)
    You are given a 0-indexed integer array nums. You can apply the following
    operation any number of times:
    * Pick any element from nums and put it at the end of nums.
    The prefix sum array of nums is an array prefix of the same length as nums
    such that prefix[i] is the sum of all the integers nums[j] where j is in
    the inclusive range [0, i]. Return the minimum number of operations such
    that the prefix sum array does not contain negative integers. The test
    cases are generated such that it is always possible to make the prefix sum
    array non-negative.

    Example 1:
    Input: nums = [2,3,-5,4]
    Output: 0
    Explanation: we do not need to do any operations. The array is [2,3,-5,4].
                 The prefix sum array is [2, 5, 0, 4].

    Example 2:
    Input: nums = [3,-5,-2,6]
    Output: 1
    Explanation: we can do one operation on index 1. The array after the
                 operation is [3,-2,6,-5]. The prefix sum array is [3, 1, 7, 2].

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    int makePrefSumNonNegative(vector<int>& nums) {
        int ans = 0;
        long prefix = 0;
        priority_queue<int, vector<int>, greater<>> pq;
        for (int i = 0; i < nums.size(); ++i) {
            prefix += nums[i];
            pq.push(nums[i]);
            if (prefix < 0) {
                ++ans;
                int xx = pq.top(); pq.pop();
                prefix -= xx;
                nums.push_back(xx);
            }
        }
        return ans;
    }


    /*2600. K Items With the Maximum Sum (Easy)
    There is a bag that consists of items, each item has a number 1, 0, or -1
    written on it. You are given four non-negative integers numOnes, numZeros,
    numNegOnes, and k. The bag initially contains:
    * numOnes items with 1s written on them.
    * numZeroes items with 0s written on them.
    * numNegOnes items with -1s written on them.
    We want to pick exactly k items among the available items. Return the
    maximum possible sum of numbers written on the items.

    Example 1:
    Input: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2
    Output: 2
    Explanation: We have a bag of items with numbers written on them
                 {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and
                 get a sum in a total of 2. It can be proven that 2 is the
                 maximum possible sum.

    Example 2:
    Input: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4
    Output: 3
    Explanation: We have a bag of items with numbers written on them
                 {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1
                 item with 0 written on it, and get a sum in a total of 3. It
                 can be proven that 3 is the maximum possible sum.

    Constraints:
    * 0 <= numOnes, numZeros, numNegOnes <= 50
    * 0 <= k <= numOnes + numZeros + numNegOnes*/

    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        return min({k, numOnes, 2*numOnes+numZeros-k});
    }


    /*2601. Prime Subtraction Operation (Medium)
    You are given a 0-indexed integer array nums of length n. You can perform
    the following operation as many times as you want:
    * Pick an index i that you haven’t picked before, and pick a prime p
      strictly less than nums[i], then subtract p from nums[i].
    Return true if you can make nums a strictly increasing array using the
    above operation and false otherwise. A strictly increasing array is an
    array whose each element is strictly greater than its preceding element.

    Example 1:
    Input: nums = [4,9,6,10]
    Output: true
    Explanation: In the first operation: Pick i = 0 and p = 3, and then
                 subtract 3 from nums[0], so that nums becomes [1,9,6,10]. In
                 the second operation: i = 1, p = 7, subtract 7 from nums[1],
                 so nums becomes equal to [1,2,6,10]. After the second
                 operation, nums is sorted in strictly increasing order, so the
                 answer is true.

    Example 2:
    Input: nums = [6,8,11,12]
    Output: true
    Explanation: Initially nums is sorted in strictly increasing order, so we
                 don't need to make any operations.

    Example 3:
    Input: nums = [5,8,3]
    Output: false
    Explanation: It can be proven that there is no way to perform operations to
                 make nums sorted in strictly increasing order, so the answer
                 is false.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000
    * nums.length == n*/

    bool primeSubOperation(vector<int>& nums) {
        vector<bool> sieve(1001, true);
        sieve[0] = sieve[1] = false;
        for (int x = 2; x*x <= 1000; ++x)
            if (sieve[x])
                for (int xx = x*x; xx <= 1000; xx += x)
                    sieve[xx] = false;
        int prev = 0;
        for (auto& x : nums) {
            if (prev >= x) return false;
            int p = x-1;
            for (; p > 0; --p)
                if (sieve[p] && x-p > prev) break;
            prev = x - p;
        }
        return true;
    }


    /*2602. Minimum Operations to Make All Array Elements Equal (Medium)
    You are given an array nums consisting of positive integers. You are also
    given an integer array queries of size m. For the ith query, you want to
    make all of the elements of nums equal to queries[i]. You can perform the
    following operation on the array any number of times:
    * Increase or decrease an element of the array by 1.
    Return an array answer of size m where answer[i] is the minimum number of
    operations to make all elements of nums equal to queries[i]. Note that
    after each query the array is reset to its original state.

    Example 1:
    Input: nums = [3,1,6,8], queries = [1,5]
    Output: [14,10]
    Explanation: For the first query we can do the following operations:
                 - Decrease nums[0] 2 times, so that nums = [1,1,6,8].
                 - Decrease nums[2] 5 times, so that nums = [1,1,1,8].
                 - Decrease nums[3] 7 times, so that nums = [1,1,1,1].
                 So the total number of operations for the first query is
                 2 + 5 + 7 = 14. For the second query we can do the following
                 operations:
                 - Increase nums[0] 2 times, so that nums = [5,1,6,8].
                 - Increase nums[1] 4 times, so that nums = [5,5,6,8].
                 - Decrease nums[2] 1 time, so that nums = [5,5,5,8].
                 - Decrease nums[3] 3 times, so that nums = [5,5,5,5].
                 So the total number of operations for the second query is
                 2 + 4 + 1 + 3 = 10.

    Example 2:
    Input: nums = [2,9,6,3], queries = [10]
    Output: [20]
    Explanation: We can increase each value in the array to 10. The total
                 number of operations will be 8 + 1 + 4 + 7 = 20.

    Constraints:
    * n == nums.length
    * m == queries.length
    * 1 <= n, m <= 10^5
    * 1 <= nums[i], queries[i] <= 10^9*/

    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {
        sort(nums.begin(), nums.end());
        vector<pair<int, int>> aug;
        for (int i = 0; i < queries.size(); ++i) aug.emplace_back(queries[i], i);
        sort(aug.begin(), aug.end());
        vector<long long> ans(queries.size());
        long long total = accumulate(nums.begin(), nums.end(), 0ll), prefix = 0;
        int k = 0;
        for (auto& [q, i] : aug) {
            while (k < nums.size() && nums[k] < q) prefix += nums[k++];
            ans[i] = total - 2*prefix + (long long) q*(2*k - nums.size());
        }
        return ans;
    }


    /*2603. Collect Coins in a Tree (Hard)
    There exists an undirected and unrooted tree with n nodes indexed from 0 to
    n - 1. You are given an integer n and a 2D integer array edges of length
    n - 1, where edges[i] = [ai, bi] indicates that there is an edge between
    nodes ai and bi in the tree. You are also given an array coins of size n
    where coins[i] can be either 0 or 1, where 1 indicates the presence of a
    coin in the vertex i. Initially, you choose to start at any vertex in the
    tree. Then, you can perform the following operations any number of times:
    * Collect all the coins that are at a distance of at most 2 from the
      current vertex, or
    * Move to any adjacent vertex in the tree.
    Find the minimum number of edges you need to go through to collect all the
    coins and go back to the initial vertex. Note that if you pass an edge
    several times, you need to count it into the answer several times.

    Example 1:
    Input: coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]
    Output: 2
    Explanation: Start at vertex 2, collect the coin at vertex 0, move to
                 vertex 3, collect the coin at vertex 5 then move back to
                 vertex 2.

    Example 2:
    Input: coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]
    Output: 2
    Explanation: Start at vertex 0, collect the coins at vertices 4 and 3, move
                 to vertex 2,  collect the coin at vertex 7, then move back to
                 vertex 0.

    Constraints:
    * n == coins.length
    * 1 <= n <= 3 * 10^4
    * 0 <= coins[i] <= 1
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * edges represents a valid tree.*/

    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {
        int n = coins.size();
        vector<unordered_set<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].insert(e[1]);
            tree[e[1]].insert(e[0]);
        }
        queue<int> leaf;
        for (int i = 0; i < n; ++i) {
            int u = i;
            while (tree[u].size() == 1 && coins[u] == 0) {
                int v = *tree[u].begin();
                tree[u].erase(v);
                tree[v].erase(u);
                u = v;
            }
            if (tree[u].size() == 1) leaf.push(u);
        }
        for (int j = 0; j < 2; ++j) {
            for (int sz = leaf.size(); sz; --sz) {
                int u = leaf.front(); leaf.pop();
                if (tree[u].size()) {
                    int v = *tree[u].begin();
                    tree[u].erase(v);
                    tree[v].erase(u);
                    if (tree[v].size() == 1) leaf.push(v);
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) ans += tree[i].size();
        return ans;
    }


    /*2604. Minimum Time to Eat All Grains (Hard)
    There are n hens and m grains on a line. You are given the initial
    positions of the hens and the grains in two integer arrays hens and grains
    of size n and m respectively. Any hen can eat a grain if they are on the
    same position. The time taken for this is negligible. One hen can also eat
    multiple grains. In 1 second, a hen can move right or left by 1 unit. The
    hens can move simultaneously and independently of each other. Return the
    minimum time to eat all grains if the hens act optimally.

    Example 1:
    Input: hens = [3,6,7], grains = [2,4,7,9]
    Output: 2
    Explanation: One of the ways hens eat all grains in 2 seconds is described
                 below:
                 - The first hen eats the grain at position 2 in 1 second.
                 - The second hen eats the grain at position 4 in 2 seconds.
                 - The third hen eats the grains at positions 7 and 9 in 2
                   seconds.
                 So, the maximum time needed is 2. It can be proven that the
                 hens cannot eat all grains before 2 seconds.

    Example 2:
    Input: hens = [4,6,109,111,213,215], grains = [5,110,214]
    Output: 1
    Explanation: One of the ways hens eat all grains in 1 second is described
                 below:
                 - The first hen eats the grain at position 5 in 1 second.
                 - The fourth hen eats the grain at position 110 in 1 second.
                 - The sixth hen eats the grain at position 214 in 1 second.
                 - The other hens do not move.
                 So, the maximum time needed is 1.

    Constraints:
    * 1 <= hens.length, grains.length <= 2*10^4
    * 0 <= hens[i], grains[j] <= 10^9*/

    int minimumTime(vector<int>& hens, vector<int>& grains) {
        sort(hens.begin(), hens.end());
        sort(grains.begin(), grains.end());
        int lo = 0, hi = 1e9;
        while (lo < hi) {
            int mid = lo + (hi-lo)/2, i = 0;
            for (auto& h : hens)
                for (int ii = i; i < grains.size() && (grains[i] <= h && h-grains[i] <= mid || h <= grains[ii] && grains[i]-h<= mid || grains[ii] <= h && h <= grains[i] && grains[i]-grains[ii]+min(grains[i]-h, h-grains[ii]) <= mid); ++i);
            if (i == grains.size()) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }


    /*2605. Form Smallest Number From Two Digit Arrays (Easy)
    Given two arrays of unique digits nums1 and nums2, return the smallest
    number that contains at least one digit from each array.

    Example 1:
    Input: nums1 = [4,1,3], nums2 = [5,7]
    Output: 15
    Explanation: The number 15 contains the digit 1 from nums1 and the digit 5
                 from nums2. It can be proven that 15 is the smallest number we
                 can have.

    Example 2:
    Input: nums1 = [3,5,2,6], nums2 = [3,1,7]
    Output: 3
    Explanation: The number 3 contains the digit 3 which exists in both arrays.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 9
    * 1 <= nums1[i], nums2[i] <= 9
    * All digits in each array are unique.*/

    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> s1(nums1.begin(), nums1.end()), s2(nums2.begin(), nums2.end());
        for (int x = 0; x <= 9; ++x)
            if (s1.count(x) && s2.count(x)) return x;
        int d1 = *min_element(nums1.begin(), nums1.end()), d2 = *min_element(nums2.begin(), nums2.end());
        return 10*min(d1, d2) + max(d1, d2);
    }


    /*2606. Find the Substring With Maximum Cost (Medium)
    You are given a string s, a string chars of distinct characters and an
    integer array vals of the same length as chars. The cost of the substring
    is the sum of the values of each character in the substring. The cost of an
    empty string is considered 0. The value of the character is defined in the
    following way:
    * If the character is not in the string chars, then its value is its
      corresponding position (1-indexed) in the alphabet.
      + For example, the value of 'a' is 1, the value of 'b' is 2, and so on.
        The value of 'z' is 26.
    * Otherwise, assuming i is the index where the character occurs in the
      string chars, then its value is vals[i].
    Return the maximum cost among all substrings of the string s.

    Example 1:
    Input: s = "adaa", chars = "d", vals = [-1000]
    Output: 2
    Explanation: The value of the characters "a" and "d" is 1 and -1000
                 respectively. The substring with the maximum cost is "aa" and
                 its cost is 1 + 1 = 2. It can be proven that 2 is the maximum
                 cost.

    Example 2:
    Input: s = "abc", chars = "abc", vals = [-1,-1,-1]
    Output: 0
    Explanation: The value of the characters "a", "b" and "c" is -1, -1, and -1
                 respectively. The substring with the maximum cost is the empty
                 substring "" and its cost is 0. It can be proven that 0 is the
                 maximum cost.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consist of lowercase English letters.
    * 1 <= chars.length <= 26
    * chars consist of distinct lowercase English letters.
    * vals.length == chars.length
    * -1000 <= vals[i] <= 1000*/

    int maximumCostSubstring(string s, string chars, vector<int>& vals) {
        unordered_map<char, int> mp;
        for (int i = 0; i < chars.size(); ++i)
            mp[chars[i]] = vals[i];
        int ans = 0, val = 0;
        for (auto& ch : s) {
            int diff = ch - 'a' + 1;
            if (mp.count(ch)) diff = mp[ch];
            val = max(0, val + diff);
            ans = max(ans, val);
        }
        return ans;
    }


    /*2607. Make K-Subarray Sums Equal (Medium)
    You are given a 0-indexed integer array arr and an integer k. The array arr
    is circular. In other words, the first element of the array is the next
    element of the last element, and the last element of the array is the
    previous element of the first element. You can do the following operation
    any number of times:
    * Pick any element from arr and increase or decrease it by 1.
    Return the minimum number of operations such that the sum of each subarray
    of length k is equal. A subarray is a contiguous part of the array.

    Example 1:
    Input: arr = [1,4,1,3], k = 2
    Output: 1
    Explanation: we can do one operation on index 1 to make its value equal to
                 3. The array after the operation is [1,3,1,3]
                 - Subarray starts at index 0 is [1, 3], and its sum is 4
                 - Subarray starts at index 1 is [3, 1], and its sum is 4
                 - Subarray starts at index 2 is [1, 3], and its sum is 4
                 - Subarray starts at index 3 is [3, 1], and its sum is 4

    Example 2:
    Input: arr = [2,5,5,7], k = 3
    Output: 5
    Explanation: we can do three operations on index 0 to make its value equal
                 to 5 and two operations on index 3 to make its value equal to
                 5. The array after the operations is [5,5,5,5]
                 - Subarray starts at index 0 is [5, 5, 5], and its sum is 15
                 - Subarray starts at index 1 is [5, 5, 5], and its sum is 15
                 - Subarray starts at index 2 is [5, 5, 5], and its sum is 15
                 - Subarray starts at index 3 is [5, 5, 5], and its sum is 15

    Constraints:
    * 1 <= k <= arr.length <= 10^5
    * 1 <= arr[i] <= 10^9*/

    long long makeSubKSumEqual(vector<int>& arr, int k) {
        long long ans = 0;
        for (int i = 0, n = arr.size(), g = gcd(n, k); i < g; ++i) {
            vector<int> vals;
            for (int sz = n/g; sz; --sz, i = (i+k) % n)
                vals.push_back(arr[i]);
            nth_element(vals.begin(), vals.begin() + vals.size()/2, vals.end());
            int target = vals[vals.size()/2];
            for (auto& x : vals) ans += abs(x - target);
        }
        return ans;
    }


    /*2608. Shortest Cycle in a Graph (Hard)
    There is a bi-directional graph with n vertices, where each vertex is
    labeled from 0 to n - 1. The edges in the graph are represented by a given
    2D integer array edges, where edges[i] = [ui, vi] denotes an edge between
    vertex ui and vertex vi. Every vertex pair is connected by at most one
    edge, and no vertex has an edge to itself. Return the length of the
    shortest cycle in the graph. If no cycle exists, return -1. A cycle is a
    path that starts and ends at the same node, and each edge in the path is
    used only once.

    Example 1:
    Input: n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]
    Output: 3
    Explanation: The cycle with the smallest length is : 0 -> 1 -> 2 -> 0

    Example 2:
    Input: n = 4, edges = [[0,1],[0,2]]
    Output: -1
    Explanation: There are no cycles in this graph.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= edges.length <= 1000
    * edges[i].length == 2
    * 0 <= ui, vi < n
    * ui != vi
    * There are no repeated edges.*/

    int findShortestCycle(int n, vector<vector<int>>& edges) {
        vector<vector<int>> graph(n);
        for (auto& e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }
        int ans = INT_MAX;
        for (int u = 0; u < n; ++u) {
            vector<int> dist(n, -1);
            queue<tuple<int, int, int>> q; q.emplace(u, -1, 0);
            while (q.size()) {
                auto [u, p, d] = q.front(); q.pop();
                if (dist[u] >= 0) {
                    ans = min(ans, d + dist[u]);
                    break;
                }
                dist[u] = d;
                for (auto& v : graph[u])
                    if (v != p) q.emplace(v, u, d+1);
            }
        }
        return ans < INT_MAX ? ans : -1;
    }


    /*2609. Find the Longest Balanced Substring of a Binary String (Easy)
    You are given a binary string s consisting only of zeroes and ones. A
    substring of s is considered balanced if all zeroes are before ones and the
    number of zeroes is equal to the number of ones inside the substring.
    Notice that the empty substring is considered a balanced substring. Return
    the length of the longest balanced substring of s. A substring is a
    contiguous sequence of characters within a string.

    Example 1:
    Input: s = "01000111"
    Output: 6
    Explanation: The longest balanced substring is "000111", which has length 6.

    Example 2:
    Input: s = "00111"
    Output: 4
    Explanation: The longest balanced substring is "0011", which has length 4.

    Example 3:
    Input: s = "111"
    Output: 0
    Explanation: There is no balanced substring except the empty substring, so
                 the answer is 0.

    Constraints:
    * 1 <= s.length <= 50
    * '0' <= s[i] <= '1'*/

    int findTheLongestBalancedSubstring(string s) {
        int ans = 0, val = 0;
        for (int i = 0, ii = 0, n = s.size(); i <= n; ++i)
            if (i == n || i && s[i-1] != s[i]) {
                if (s[i-1] == '0') val = i - ii;
                else {
                    val = min(val, i - ii);
                    ans = max(2*val, ans);
                }
                ii = i;
            }
        return ans;
    }


    /*2610. Convert an Array Into a 2D Array With Conditions (Medium)
    You are given an integer array nums. You need to create a 2D array from
    nums satisfying the following conditions:
    * The 2D array should contain only the elements of the array nums.
    * Each row in the 2D array contains distinct integers.
    * The number of rows in the 2D array should be minimal.
    Return the resulting array. If there are multiple answers, return any of
    them. Note that the 2D array can have a different number of elements on
    each row.

    Example 1:
    Input: nums = [1,3,4,1,2,3,1]
    Output: [[1,3,4,2],[1,3],[1]]
    Explanation: We can create a 2D array that contains the following rows:
                 - 1,3,4,2
                 - 1,3
                 - 1
                 All elements of nums were used, and each row of the 2D array
                 contains distinct integers, so it is a valid answer. It can be
                 shown that we cannot have less than 3 rows in a valid array.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: [[4,3,2,1]]
    Explanation: All elements of the array are distinct, so we can keep all of
                 them in the first row of the 2D array.

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= nums.length*/

    vector<vector<int>> findMatrix(vector<int>& nums) {
        int m = 0;
        unordered_map<int, int> freq;
        for (auto& x : nums) m = max(m, ++freq[x]);
        vector<vector<int>> ans(m);
        for (auto& [k, v] : freq)
            for (int i = 0; i < v; ++i)
                ans[i].push_back(k);
        return ans;
    }


    /*2611. Mice and Cheese (Medium)
    There are two mice and n different types of cheese, each type of cheese
    should be eaten by exactly one mouse. A point of the cheese with index i
    (0-indexed) is:
    * reward1[i] if the first mouse eats it.
    * reward2[i] if the second mouse eats it.
    You are given a positive integer array reward1, a positive integer array
    reward2, and a non-negative integer k. Return the maximum points the mice
    can achieve if the first mouse eats exactly k types of cheese.

    Example 1:
    Input: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2
    Output: 15
    Explanation: In this example, the first mouse eats the 2nd (0-indexed) and
                 the 3rd types of cheese, and the second mouse eats the 0th and
                 the 1st types of cheese. The total points are
                 4 + 4 + 3 + 4 = 15. It can be proven that 15 is the maximum
                 total points that the mice can achieve.

    Example 2:
    Input: reward1 = [1,1], reward2 = [1,1], k = 2
    Output: 2
    Explanation: In this example, the first mouse eats the 0th (0-indexed) and
                 1st types of cheese, and the second mouse does not eat any
                 cheese. The total points are 1 + 1 = 2. It can be proven that
                 2 is the maximum total points that the mice can achieve.

    Constraints:
    * 1 <= n == reward1.length == reward2.length <= 10^5
    * 1 <= reward1[i], reward2[i] <= 1000
    * 0 <= k <= n*/

    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {
        int ans = 0;
        for (int i = 0; i < reward1.size(); ++i) {
            reward1[i] -= reward2[i];
            ans += reward2[i];
        }
        nth_element(reward1.begin(), reward1.begin()+k, reward1.end(), greater<>());
        return accumulate(reward1.begin(), reward1.begin()+k, ans);
    }


    /*2612. Minimum Reverse Operations (Hard)
    You are given an integer n and an integer p in the range [0, n - 1].
    Representing a 0-indexed array arr of length n where all positions are set
    to 0's, except position p which is set to 1. You are also given an integer
    array banned containing some positions from the array. For the ith position
    in banned, arr[banned[i]] = 0, and banned[i] != p. You can perform multiple
    operations on arr. In an operation, you can choose a subarray with size k
    and reverse the subarray. However, the 1 in arr should never go to any of
    the positions in banned. In other words, after each operation
    arr[banned[i]] remains 0. Return an array ans where for each i from
    [0, n - 1], ans[i] is the minimum number of reverse operations needed to
    bring the 1 to position i in arr, or -1 if it is impossible.
    * A subarray is a contiguous non-empty sequence of elements within an array.
    * The values of ans[i] are independent for all i's.
    * The reverse of an array is an array containing the values in reverse
      order.

    Example 1:
    Input: n = 4, p = 0, banned = [1,2], k = 4
    Output: [0,-1,-1,1]
    Explanation: In this case k = 4 so there is only one possible reverse
                 operation we can perform, which is reversing the whole array.
                 Initially, 1 is placed at position 0 so the amount of
                 operations we need for position 0 is 0. We can never place a 1
                 on the banned positions, so the answer for positions 1 and 2
                 is -1. Finally, with one reverse operation we can bring the 1
                 to index 3, so the answer for position 3 is 1.

    Example 2:
    Input: n = 5, p = 0, banned = [2,4], k = 3
    Output: [0,-1,-1,-1,-1]
    Explanation: In this case the 1 is initially at position 0, so the answer
                 for that position is 0. We can perform reverse operations of
                 size 3. The 1 is currently located at position 0, so we need
                 to reverse the subarray [0, 2] for it to leave that position,
                 but reversing that subarray makes position 2 have a 1, which
                 shouldn't happen. So, we can't move the 1 from position 0,
                 making the result for all the other positions -1.

    Example 3:
    Input: n = 4, p = 2, banned = [0,1,3], k = 1
    Output: [-1,-1,0,-1]
    Explanation: In this case we can only perform reverse operations of size 1.
                 So the 1 never changes its position.

    Constraints:
    * 1 <= n <= 10^5
    * 0 <= p <= n - 1
    * 0 <= banned.length <= n - 1
    * 0 <= banned[i] <= n - 1
    * 1 <= k <= n
    * banned[i] != p
    * all values in banned are unique*/

    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {
        vector<int> ans(n, -1);
        vector<bool> ban(n);
        for (auto& x : banned) ban[x] = true;
        vector<set<int>> avail(2);
        for (int i = 0; i < n; ++i)
            if (!ban[i]) avail[i&1].insert(i);
        queue<int> q; q.push(p);
        avail[p&1].erase(p);
        for (int val = 0; q.size(); ++val)
            for (int sz = q.size(); sz; --sz) {
                auto v = q.front(); q.pop();
                ans[v] = val;
                int lo = abs(v-k+1), hi = n-1-abs(n-v-k);
                auto ptr = avail[lo&1].lower_bound(lo);
                while (ptr != avail[lo&1].end() && *ptr <= hi) {
                    q.push(*ptr);
                    avail[lo&1].erase(*ptr++);
                }
            }
        return ans;
    }


    /*2613. Beautiful Pairs (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2 of the same
    length. A pair of indices (i,j) is called beautiful if
    |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]| is the smallest amongst all
    possible indices pairs where i < j. Return the beautiful pair. In the case
    that there are multiple beautiful pairs, return the lexicographically
    smallest pair. Note that
    * |x| denotes the absolute value of x.
    * A pair of indices (i1, j1) is lexicographically smaller than (i2, j2) if
      i1 < i2 or i1 == i2 and j1 < j2.

    Example 1:
    Input: nums1 = [1,2,3,2,4], nums2 = [2,3,1,2,3]
    Output: [0,3]
    Explanation: Consider index 0 and index 3. The value of
                 |nums1[i]-nums1[j]| + |nums2[i]-nums2[j]| is 1, which is the
                 smallest value we can achieve.

    Example 2:
    Input: nums1 = [1,2,4,3,2,5], nums2 = [1,4,2,3,5,1]
    Output: [1,4]
    Explanation: Consider index 1 and index 4. The value of
                 |nums1[i]-nums1[j]| + |nums2[i]-nums2[j]| is 1, which is the
                 smallest value we can achieve.

    Constraints:
    * 2 <= nums1.length, nums2.length <= 10^5
    * nums1.length == nums2.length
    * 0 <= nums1i <= nums1.length
    * 0 <= nums2i <= nums2.length*/

    vector<int> beautifulPair(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> points;
        for (int i = 0; i < nums1.size(); ++i)
            points.push_back({i, nums1[i], nums2[i]});
        sort(points.begin(), points.end(), [&](auto& lhs, auto& rhs) {return lhs[1] < rhs[1] || lhs[1] == rhs[1] && lhs[0] < rhs[0];});

        function<tuple<int, int, int>(int, int)> fn = [&](int lo, int hi) {
            int delta = INT_MAX, i = -1, ii = -1;
            if (lo+2 == hi) {
                delta = abs(points[lo][1]-points[lo+1][1]) + abs(points[lo][2]-points[lo+1][2]);
                i = points[lo][0];
                ii = points[lo+1][0];
                if (i > ii) swap(i, ii);
            } else if (lo+2 < hi) {
                int mid = (lo + hi)/2;
                auto [ld, li, lii] = fn(lo, mid);
                auto [rd, ri, rii] = fn(mid, hi);
                if (ld < rd || ld == rd && li < ri) delta = ld, i = li, ii = lii;
                else delta = rd, i = ri, ii = rii;
                int split = points[mid][1];
                vector<vector<int>> strip;
                for (int k = lo; k < hi; ++k)
                    if (split - delta <= points[k][1] && points[k][1] <= split + delta) strip.push_back(points[k]);
                sort(strip.begin(), strip.end(), [&](auto& lhs, auto& rhs) {return lhs[2] < rhs[2] || lhs[2] == rhs[2] && lhs[0] < rhs[0];});
                for (int k = 0, n = strip.size(); k < n; ++k)
                    for (int kk = k+1; kk < n && kk < k+10; ++kk) {
                        int j = strip[k][0], jj = strip[kk][0], cand = abs(strip[k][1]-strip[kk][1]) + abs(strip[k][2]-strip[kk][2]);
                        if (j > jj) swap(j, jj);
                        if (cand < delta || cand == delta && (j < i || j == i && jj < ii)) delta = cand, i = j, ii = jj;
                    }
            }
            return make_tuple(delta, i, ii);
        };

        auto [_, i, ii] = fn(0, points.size());
        return {i, ii};
    }


    /*2614. Prime In Diagonal (Easy)
    You are given a 0-indexed two-dimensional integer array nums. Return the
    largest prime number that lies on at least one of the diagonals of nums. In
    case, no prime is present on any of the diagonals, return 0. Note that:
    * An integer is prime if it is greater than 1 and has no positive integer
      divisors other than 1 and itself.
    * An integer val is on one of thediagonals of nums if there exists an
      integer i for which nums[i][i] = val or an i for which
      nums[i][nums.length - i - 1]= val.
    In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].

    Example 1:
    Input: nums = [[1,2,3],[5,6,7],[9,10,11]]
    Output: 11
    Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on
                 at least one of the diagonals. Since 11 is the largest prime,
                 we return 11.

    Example 2:
    Input: nums = [[1,2,3],[5,17,7],[9,11,10]]
    Output: 17
    Explanation: The numbers 1, 3, 9, 10, and 17 are all present on at least
                 one of the diagonals. 17 is the largest prime, so we return 17.

    Constraints:
    * 1 <= nums.length <= 300
    * nums.length == numsi.length
    * 1 <= nums[i][j] <= 4*10^6*/

    int diagonalPrime(vector<vector<int>>& nums) {
        auto fn = [&](int x) {
            if (x == 1) return false;
            for (int p = 2; p <= sqrt(x); ++p)
                if (x % p == 0) return false;
            return true;
        };

        int ans = 0;
        for (int i = 0, n = nums.size(); i < n; ++i) {
            if (fn(nums[i][i])) ans = max(ans, nums[i][i]);
            if (fn(nums[i][n-1-i])) ans = max(ans, nums[i][n-1-i]);
        }
        return ans;
    }


    /*2615. Sum of Distances (Medium)
    You are given a 0-indexed integer array nums. There exists an array arr of
    length nums.length, where arr[i] is the sum of |i - j| over all j such that
    nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0.
    Return the array arr.

    Example 1:
    Input: nums = [1,3,1,1,2]
    Output: [5,0,3,4,0]
    Explanation: - When i = 0, nums[0] == nums[2] and nums[0] == nums[3].
                 Therefore, arr[0] = |0 - 2| + |0 - 3| = 5.
                 - When i = 1, arr[1] = 0 because there is no other index with
                   value 3.
                 - When i = 2, nums[2] == nums[0] and nums[2] == nums[3].
                   Therefore, arr[2] = |2 - 0| + |2 - 3| = 3.
                 - When i = 3, nums[3] == nums[0] and nums[3] == nums[2].
                   Therefore, arr[3] = |3 - 0| + |3 - 2| = 4.
                 - When i = 4, arr[4] = 0 because there is no other index with
                   value 2.

    Example 2:
    Input: nums = [0,5,3]
    Output: [0,0,0]
    Explanation: Since each element in nums is distinct, arr[i] = 0 for all i.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9*/

    vector<long long> distance(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, vector<int>> mp;
        for (int i = 0; i < n; ++i) mp[nums[i]].push_back(i);
        vector<long long> ans(n);
        for (auto& [_, idx] : mp) {
            vector<long long> prefix(1);
            for (auto& x : idx) prefix.push_back(prefix.back() + x);
            for (int i = 0; i < idx.size(); ++i)
                ans[idx[i]] = prefix.back() - 2*prefix[i] + (2*i - idx.size()) * idx[i];
        }
        return ans;
    }


    /*2616. Minimize the Maximum Difference of Pairs (Medium)
    You are given a 0-indexed integer array nums and an integer p. Find p pairs
    of indices of nums such that the maximum difference amongst all the pairs
    is minimized. Also, ensure no index appears more than once amongst the p
    pairs. Note that for a pair of elements at the index i and j, the
    difference of this pair is |nums[i] - nums[j]|, where |x| represents the
    absolute value of x. Return the minimum maximum difference among all p
    pairs.

    Example 1:
    Input: nums = [10,1,2,7,1,3], p = 2
    Output: 1
    Explanation: The first pair is formed from the indices 1 and 4, and the
                 second pair is formed from the indices 2 and 5. The maximum
                 difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|)
                 = max(0, 1) = 1. Therefore, we return 1.

    Example 2:
    Input: nums = [4,2,1,2], p = 1
    Output: 0
    Explanation: Let the indices 1 and 3 form a pair. The difference of that
                 pair is |2 - 2| = 0, which is the minimum we can attain.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 0 <= p <= (nums.length)/2*/

    int minimizeMax(vector<int>& nums, int p) {
        sort(nums.begin(), nums.end());
        int lo = 0, hi = 1e9;
        while (lo < hi) {
            int mid = lo + (hi-lo)/2, cnt = 0;
            for (int i = 0, n = nums.size(); i < n; ++i)
                if (i+1 < n && nums[i+1]-nums[i] <= mid) ++cnt, ++i;
            if (cnt < p) lo = mid+1;
            else hi = mid;
        }
        return lo;
    }


    /*2617. Minimum Number of Visited Cells in a Grid (Hard)
    You are given a 0-indexed m x n integer matrix grid. Your initial position
    is at the top-left cell (0, 0). Starting from the cell (i, j), you can move
    to one of the following cells:
    * Cells (i, k) with j < k <= grid[i][j] + j (rightward movement), or
    * Cells (k, j) with i < k <= grid[i][j] + i (downward movement).
    Return the minimum number of cells you need to visit to reach the bottom-
    right cell (m - 1, n - 1). If there is no valid path, return -1.

    Example 1:
    Input: grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
    Output: 4
    Explanation: The image above shows one of the paths that visits exactly 4 cells.

    Example 2:
    Input: grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
    Output: 3
    Explanation: The image above shows one of the paths that visits exactly 3 cells.

    Example 3:
    Input: grid = [[2,1,0],[1,0,0]]
    Output: -1
    Explanation: It can be proven that no path exists.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 105
    * 1 <= m * n <= 105
    * 0 <= grid[i][j] < m * n
    * grid[m - 1][n - 1] == 0*/

    int minimumVisitedCells(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>> pqs(n);
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        dist[0][0] = 1;
        for (int i = 0; i < m; ++i) {
            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
            for (int j = 0; j < n; ++j) {
                while (pq.size() && pq.top().second < j) pq.pop();
                while (pqs[j].size() && pqs[j].top().second < i) pqs[j].pop();
                if (pq.size()) dist[i][j] = min(dist[i][j], pq.top().first + 1);
                if (pqs[j].size()) dist[i][j] = min(dist[i][j], pqs[j].top().first + 1);
                if (dist[i][j] < INT_MAX) {
                    pq.emplace(dist[i][j], j + grid[i][j]);
                    pqs[j].emplace(dist[i][j], i + grid[i][j]);
                }
            }
        }
        return dist[m-1][n-1] < INT_MAX ? dist[m-1][n-1] : -1;
    }


    /*2638. Count the Number of K-Free Subsets (Medium)
    You are given an integer array nums, which contains distinct elements and
    an integer k. A subset is called a k-Free subset if it contains no two
    elements with an absolute difference equal to k. Notice that the empty set
    is a k-Free subset. Return the number of k-Free subsets of nums. A subset
    of an array is a selection of elements (possibly none) of the array.

    Example 1:
    Input: nums = [5,4,6], k = 1
    Output: 5
    Explanation: There are 5 valid subsets: {}, {5}, {4}, {6} and {4, 6}.

    Example 2:
    Input: nums = [2,3,5,8], k = 5
    Output: 12
    Explanation: There are 12 valid subsets: {}, {2}, {3}, {5}, {8}, {2, 3},
                 {2, 3, 5}, {2, 5}, {2, 5, 8}, {2, 8}, {3, 5} and {5, 8}.

    Example 3:
    Input: nums = [10,5,9,11], k = 20
    Output: 16
    Explanation: All subsets are valid. Since the total count of subsets is
                 2^4 = 16, so the answer is 16.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 1000
    * 1 <= k <= 1000*/

    long long countTheNumOfKFreeSubsets(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        unordered_map<int, int> size;
        int m = 0;
        for (auto& x : nums) {
            size[x] = 1 + size[x-k];
            size.erase(x-k);
            m = max(m, size[x]);
        }
        vector<long long> fib(m+2);
        fib[0] = fib[1] = 1;
        for (int i = 2; i < m+2; ++i) fib[i] = fib[i-2] + fib[i-1];
        long long ans = 1;
        for (auto& [_, v] : size)
            ans *= fib[v+1];
        return ans;
    }


    /*2639. Find the Width of Columns of a Grid (Easy)
    You are given a 0-indexed m x n integer matrix grid. The width of a column
    is the maximum length of its integers.
    * For example, if grid = [[-10], [3], [12]], the width of the only column
      is 3 since -10 is of length 3.
    Return an integer array ans of size n where ans[i] is the width of the ith
    column. The length of an integer x with len digits is equal to len if x is
    non-negative, and len + 1 otherwise.

    Example 1:
    Input: grid = [[1],[22],[333]]
    Output: [3]
    Explanation: In the 0th column, 333 is of length 3.

    Example 2:
    Input: grid = [[-15,1,3],[15,7,12],[5,6,-2]]
    Output: [3,1,2]
    Explanation: In the 0th column, only -15 is of length 3.
                 In the 1st column, all integers are of length 1.
                 In the 2nd column, both 12 and -2 are of length 2.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 100
    * -10^9 <= grid[r][c] <= 10^9*/

    vector<int> findColumnWidth(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> ans(n);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                int val = 0;
                for (int x = grid[i][j]; x; ++val, x /= 10);
                if (grid[i][j] < 0) ++val;
                ans[j] = max(ans[j], max(1, val));
            }
        return ans;
    }


    /*2640. Find the Score of All Prefixes of an Array (Medium)
    We define the conversion array conver of an array arr as follows:
    * conver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum
      value of arr[j] over 0 <= j <= i.
    We also define the score of an array arr as the sum of the values of the
    conversion array of arr. Given a 0-indexed integer array nums of length n,
    return an array ans of length n where ans[i] is the score of the prefix
    nums[0..i].

    Example 1:
    Input: nums = [2,3,7,5,10]
    Output: [4,10,24,36,56]
    Explanation: - For the prefix [2], the conversion array is [4] hence the
                   score is 4
                 - For the prefix [2, 3], the conversion array is [4, 6] hence
                   the score is 10
                 - For the prefix [2, 3, 7], the conversion array is [4, 6, 14]
                   hence the score is 24
                 - For the prefix [2, 3, 7, 5], the conversion array is
                   [4, 6, 14, 12] hence the score is 36
                 - For the prefix [2, 3, 7, 5, 10], the conversion array is
                   [4, 6, 14, 12, 20] hence the score is 56

    Example 2:
    Input: nums = [1,1,2,4,8,16]
    Output: [2,4,8,16,32,64]
    Explanation: - For the prefix [1], the conversion array is [2] hence the
                   score is 2
                 - For the prefix [1, 1], the conversion array is [2, 2] hence
                   the score is 4
                 - For the prefix [1, 1, 2], the conversion array is [2, 2, 4]
                   hence the score is 8
                 - For the prefix [1, 1, 2, 4], the conversion array is
                   [2, 2, 4, 8] hence the score is 16
                 - For the prefix [1, 1, 2, 4, 8], the conversion array is
                   [2, 2, 4, 8, 16] hence the score is 32
                 - For the prefix [1, 1, 2, 4, 8, 16], the conversion array is
                   [2, 2, 4, 8, 16, 32] hence the score is 64

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    vector<long long> findPrefixScore(vector<int>& nums) {
        vector<long long> ans;
        long long prefix = 0;
        int most = 0;
        for (auto& x : nums) {
            most = max(most, x);
            prefix += x + most;
            ans.push_back(prefix);
        }
        return ans;
    }


    /*2641. Cousins in Binary Tree II (Medium)
    Given the root of a binary tree, replace the value of each node in the tree
    with the sum of all its cousins' values. Two nodes of a binary tree are
    cousins if they have the same depth with different parents. Return the root
    of the modified tree. Note that the depth of a node is the number of edges
    in the path from the root node to it.

    Example 1:
    Input: root = [5,4,9,1,10,null,7]
    Output: [0,0,0,7,7,null,11]
    Explanation: The diagram above shows the initial binary tree and the binary
                 tree after changing the value of each node.
                 - Node with value 5 does not have any cousins so its sum is 0.
                 - Node with value 4 does not have any cousins so its sum is 0.
                 - Node with value 9 does not have any cousins so its sum is 0.
                 - Node with value 1 has a cousin with value 7 so its sum is 7.
                 - Node with value 10 has a cousin with value 7 so its sum is 7.
                 - Node with value 7 has cousins with values 1 and 10 so its
                   sum is 11.

    Example 2:
    Input: root = [3,1,2]
    Output: [0,0,0]
    Explanation: The diagram above shows the initial binary tree and the binary
                 tree after changing the value of each node.
                 - Node with value 3 does not have any cousins so its sum is 0.
                 - Node with value 1 does not have any cousins so its sum is 0.
                 - Node with value 2 does not have any cousins so its sum is 0.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 10^4*/

    TreeNode* replaceValueInTree(TreeNode* root) {
        vector<int> total;
        unordered_map<TreeNode*, int> mp;
        stack<tuple<TreeNode*, TreeNode*, int>> stk; stk.emplace(root, nullptr, 0);
        while (stk.size()) {
            auto [node, p, d] = stk.top(); stk.pop();
            if (total.size() == d) total.push_back(0);
            total[d] += node->val;
            mp[p] += node->val;
            if (node->left) stk.emplace(node->left, node, d+1);
            if (node->right) stk.emplace(node->right, node, d+1);
        }
        stk.emplace(root, nullptr, 0);
        while (stk.size()) {
            auto [node, p, d] = stk.top(); stk.pop();
            node->val = total[d] - mp[p];
            if (node->left) stk.emplace(node->left, node, d+1);
            if (node->right) stk.emplace(node->right, node, d+1);
        }
        return root;
    }


    /*2643. Row With Maximum Ones (Easy)
    Given a m x n binary matrix mat, find the 0-indexed position of the row
    that contains the maximum count of ones, and the number of ones in that row.
    In case there are multiple rows that have the maximum count of ones, the
    row with the smallest row number should be selected. Return an array
    containing the index of the row, and the number of ones in it.

    Example 1:
    Input: mat = [[0,1],[1,0]]
    Output: [0,1]
    Explanation: Both rows have the same number of 1's. So we return the index
                 of the smaller row, 0, and the maximum count of ones (1). So,
                 the answer is [0,1].

    Example 2:
    Input: mat = [[0,0,0],[0,1,1]]
    Output: [1,2]
    Explanation: The row indexed 1 has the maximum count of ones (2). So we
                 return its index, 1, and the count. So, the answer is [1,2].

    Example 3:
    Input: mat = [[0,0],[1,1],[0,0]]
    Output: [1,2]
    Explanation: The row indexed 1 has the maximum count of ones (2). So the
                 answer is [1,2].

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 100
    * mat[i][j] is either 0 or 1.*/

    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {
        int idx = 0, cnt = 0;
        for (int i = 0; i < mat.size(); ++i) {
            int c = count(mat[i].begin(), mat[i].end(), 1);
            if (c > cnt) idx = i, cnt = c;
        }
        return {idx, cnt};
    }


    /*2644. Find the Maximum Divisibility Score (Easy)
    You are given two 0-indexed integer arrays nums and divisors. The
    divisibility score of divisors[i] is the number of indices j such that
    nums[j] is divisible by divisors[i]. Return the integer divisors[i] with
    the maximum divisibility score. If there is more than one integer with the
    maximum score, return the minimum of them.

    Example 1:
    Input: nums = [4,7,9,3,9], divisors = [5,2,3]
    Output: 3
    Explanation: The divisibility score for every element in divisors is:
                 - The divisibility score of divisors[0] is 0 since no number
                   in nums is divisible by 5.
                 - The divisibility score of divisors[1] is 1 since nums[0] is
                   divisible by 2.
                 - The divisibility score of divisors[2] is 3 since nums[2],
                   nums[3], and nums[4] are divisible by 3.
                 - Since divisors[2] has the maximum divisibility score, we
                   return it.

    Example 2:
    Input: nums = [20,14,21,10], divisors = [5,7,5]
    Output: 5
    Explanation: The divisibility score for every element in divisors is:
                 - The divisibility score of divisors[0] is 2 since nums[0] and
                   nums[3] are divisible by 5.
                 - The divisibility score of divisors[1] is 2 since nums[1] and
                   nums[2] are divisible by 7.
                 - The divisibility score of divisors[2] is 2 since nums[0] and
                   nums[3] are divisible by 5.
                 Since divisors[0], divisors[1], and divisors[2] all have the
                 maximum divisibility score, we return the minimum of them
                 (i.e., divisors[2]).

    Example 3:
    Input: nums = [12], divisors = [10,16]
    Output: 10
    Explanation: The divisibility score for every element in divisors is:
                 - The divisibility score of divisors[0] is 0 since no number
                   in nums is divisible by 10.
                 - The divisibility score of divisors[1] is 0 since no number
                   in nums is divisible by 16.
                 Since divisors[0] and divisors[1] both have the maximum
                 divisibility score, we return the minimum of them (i.e.,
                 divisors[0]).

    Constraints:
    * 1 <= nums.length, divisors.length <= 1000
    * 1 <= nums[i], divisors[i] <= 10^9*/

    int maxDivScore(vector<int>& nums, vector<int>& divisors) {
        int ans = 0, most = -1;
        for (auto& d : divisors) {
            int cnt = 0;
            for (auto& n : nums)
                if (n % d == 0) ++cnt;
            if (cnt > most || cnt == most && d < ans) {
                ans = d;
                most = cnt;
            }
        }
        return ans;
    }


    /*2645. Minimum Additions to Make Valid String (Medium)
    Given a string word to which you can insert letters "a", "b" or "c"
    anywhere and any number of times, return the minimum number of letters that
    must be inserted so that word becomes valid. A string is called valid if it
    can be formed by concatenating the string "abc" several times.

    Example 1:
    Input: word = "b"
    Output: 2
    Explanation: Insert the letter "a" right before "b", and the letter "c"
                 right next to "a" to obtain the valid string "abc".

    Example 2:
    Input: word = "aaa"
    Output: 6
    Explanation: Insert letters "b" and "c" next to each "a" to obtain the
                 valid string "abcabcabc".

    Example 3:
    Input: word = "abc"
    Output: 0
    Explanation: word is already valid. No modifications are needed.

    Constraints:
    * 1 <= word.length <= 50
    * word consists of letters "a", "b" and "c" only.*/

    int addMinimum(string word) {
        int ans = 0, cnt = 3;
        for (int i = 0; i < word.size(); ++i, --cnt)
            if (i && word[i-1] >= word[i]) {
                ans += cnt;
                cnt = 3;
            }
        return ans + cnt;
    }


    /*2646. Minimize the Total Price of the Trips (Hard)
    There exists an undirected and unrooted tree with n nodes indexed from 0 to
    n - 1. You are given the integer n and a 2D integer array edges of length
    n - 1, where edges[i] = [ai, bi] indicates that there is an edge between
    nodes ai and bi in the tree. Each node has an associated price. You are
    given an integer array price, where price[i] is the price of the ith node.
    The price sum of a given path is the sum of the prices of all nodes lying
    on that path. Additionally, you are given a 2D integer array trips, where
    trips[i] = [starti, endi] indicates that you start the ith trip from the
    node starti and travel to the node endi by any path you like. Before
    performing your first trip, you can choose some non-adjacent nodes and
    halve the prices. Return the minimum total price sum to perform all the
    given trips.

    Example 1:
    Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]
    Output: 23
    Explanation: The diagram above denotes the tree after rooting it at node 2.
                 The first part shows the initial tree and the second part
                 shows the tree after choosing nodes 0, 2, and 3, and making
                 their price half.
                 - For the 1st trip, we choose path [0,1,3]. The price sum of
                   that path is 1 + 2 + 3 = 6.
                 - For the 2nd trip, we choose path [2,1]. The price sum of
                   that path is 2 + 5 = 7.
                 - For the 3rd trip, we choose path [2,1,3]. The price sum of
                   that path is 5 + 2 + 3 = 10.
                 The total price sum of all trips is 6 + 7 + 10 = 23. It can be
                 proven, that 23 is the minimum answer that we can achieve.

    Example 2:
    Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]
    Output: 1
    Explanation: The diagram above denotes the tree after rooting it at node 0.
                 The first part shows the initial tree and the second part
                 shows the tree after choosing node 0, and making its price
                 half.
                 - For the 1st trip, we choose path [0]. The price sum of that
                   path is 1.
                 The total price sum of all trips is 1. It can be proven, that
                 1 is the minimum answer that we can achieve.

    Constraints:
    * 1 <= n <= 50
    * edges.length == n - 1
    * 0 <= ai, bi <= n - 1
    * edges represents a valid tree.
    * price.length == n
    * price[i] is an even integer.
    * 1 <= price[i] <= 1000
    * 1 <= trips.length <= 100
    * 0 <= starti, endi <= n - 1*/

    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        vector<int> freq(n);
        for (auto& t : trips) {
            queue<pair<int, int>> q;
            q.emplace(t[0], -1);
            unordered_map<int, int> parent = {{t[0], -1}};
            while (q.size()) {
                auto [u, p] = q.front(); q.pop();
                if (u == t[1]) break;
                for (auto& v : tree[u]) {
                    if (v != p) {
                        q.emplace(v, u);
                        parent[v] = u;
                    }
                }
            }
            for (int u = t[1]; u >= 0; ++freq[u], u = parent[u]);
        }

        function<pair<int, int>(int, int)> dfs = [&](int u, int p) {
            int full = 0, half = 0;
            for (auto& v : tree[u])
                if (v != p) {
                    auto [ff, hh] = dfs(v, u);
                    full += ff;
                    half += min(ff, hh);
                }
            return make_pair(price[u]*freq[u] + half, price[u]*freq[u]/2 + full);
        };

        auto [f, h] = dfs(0, -1);
        return min(f, h);
    }


    /*2647. Color the Triangle Red (Hard)
    You are given an integer n. Consider an equilateral triangle of side length
    n, broken up into n2 unit equilateral triangles. The triangle has n
    1-indexed rows where the ith row has 2i - 1 unit equilateral triangles.
    The triangles in the ith row are also 1-indexed with coordinates from (i, 1)
    to (i, 2i - 1). The following image shows a triangle of side length 4 with
    the indexing of its triangle. Two triangles are neighbors if they share a
    side. For example:
    * Triangles (1,1) and (2,2) are neighbors
    * Triangles (3,2) and (3,3) are neighbors.
    * Triangles (2,2) and (3,3) are not neighbors because they do not share any
      side.
    Initially, all the unit triangles are white. You want to choose k triangles
    and color them red. We will then run the following algorithm:
    * Choose a white triangle that has at least two red neighbors.
      - If there is no such triangle, stop the algorithm.
    * Color that triangle red.
    * Go to step 1.
    Choose the minimum k possible and set k triangles red before running this
    algorithm such that after the algorithm stops, all unit triangles are
    colored red. Return a 2D list of the coordinates of the triangles that you
    will color red initially. The answer has to be of the smallest size
    possible. If there are multiple valid solutions, return any.

    Example 1:
    Input: n = 3
    Output: [[1,1],[2,1],[2,3],[3,1],[3,5]]
    Explanation: Initially, we choose the shown 5 triangles to be red. Then, we
                 run the algorithm:
                 - Choose (2,2) that has three red neighbors and color it red.
                 - Choose (3,2) that has two red neighbors and color it red.
                 - Choose (3,4) that has three red neighbors and color it red.
                 - Choose (3,3) that has three red neighbors and color it red.
                 It can be shown that choosing any 4 triangles and running the
                 algorithm will not make all triangles red.

    Example 2:
    Input: n = 2
    Output: [[1,1],[2,1],[2,3]]
    Explanation: Initially, we choose the shown 3 triangles to be red. Then, we
                 run the algorithm:
                 - Choose (2,2) that has three red neighbors and color it red.
                 It can be shown that choosing any 2 triangles and running the
                 algorithm will not make all triangles red.

    Constraints: 1 <= n <= 1000*/

    vector<vector<int>> colorRed(int n) {
        vector<vector<int>> ans;
        int p = 0;
        for (int i = n; i >= 1; --i, p = (p+1)%4)
            if (p == 0)
                for (int j = 2*i-1; j > 0; j -= 2) ans.push_back({i, j});
            else if (p == 1) {
                if (2 <= i) ans.push_back({i, 2});
            } else if (p == 2)
                for (int j = 2*i-1; j >= 3; j -= 2) ans.push_back({i, j});
            else ans.push_back({i, 1});
        if (p == 2 || p == 3) ans.push_back({1, 1});
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*2655. Find Maximal Uncovered Ranges (Medium)
    You are given an integer n which is the length of a 0-indexed array nums,
    and a 0-indexed 2D-array ranges, which is a list of sub-ranges of nums
    (sub-ranges may overlap). Each row ranges[i] has exactly 2 cells:
    * ranges[i][0], which shows the start of the ith range (inclusive)
    * ranges[i][1], which shows the end of the ith range (inclusive)
    These ranges cover some cells of nums and leave some cells uncovered. Your
    task is to find all of the uncovered ranges with maximal length. Return a
    2D-array answer of the uncovered ranges, sorted by the starting point in
    ascending order. By all of the uncovered ranges with maximal length, we
    mean satisfying two conditions:
    * Each uncovered cell should belong to exactly one sub-range
    * There should not exist two ranges (l1, r1) and (l2, r2) such that
      r1 + 1 = l2

    Example 1:
    Input: n = 10, ranges = [[3,5],[7,8]]
    Output: [[0,2],[6,6],[9,9]]
    Explanation: The ranges (3, 5) and (7, 8) are covered, so if we simplify
                 the array nums to a binary array where 0 shows an uncovered
                 cell and 1 shows a covered cell, the array becomes
                 [0,0,0,1,1,1,0,1,1,0] in which we can observe that the ranges
                 (0, 2), (6, 6) and (9, 9) aren't covered.

    Example 2:
    Input: n = 3, ranges = [[0,2]]
    Output: []
    Explanation: In this example, the whole of the array nums is covered and
                 there are no uncovered cells so the output is an empty array.

    Example 3:
    Input: n = 7, ranges = [[2,4],[0,3]]
    Output: [[5,6]]
    Explanation: The ranges (0, 3) and (2, 4) are covered, so if we simplify
                 the array nums to a binary array where 0 shows an uncovered
                 cell and 1 shows a covered cell, the array becomes
                 [1,1,1,1,1,0,0] in which we can observe that the range
                 (5, 6) is uncovered.

    Constraints:
    * 1 <= n <= 10^9
    * 0 <= ranges.length <= 10^6
    * ranges[i].length = 2
    * 0 <= ranges[i][j] <= n - 1
    * ranges[i][0] <= ranges[i][1]*/

    vector<vector<int>> findMaximalUncoveredRanges(int n, vector<vector<int>>& ranges) {
        sort(ranges.begin(), ranges.end(), [&](auto& lhs, auto& rhs) {return lhs[1] < rhs[1];});
        vector<pair<int, int>> stk;
        for (auto& r : ranges) {
            int x = r[0], y = r[1];
            while (stk.size() && x <= stk.back().second) {
                auto [xx, _] = stk.back(); stk.pop_back();
                x = min(x, xx);
            }
            stk.emplace_back(x, y);
        }
        vector<vector<int>> ans;
        int prev = 0;
        for (auto& [x, y] : stk) {
            if (prev < x) ans.push_back({prev, x-1});
            prev = max(prev, y+1);
        }
        if (prev <= n-1) ans.push_back({prev, n-1});
        return ans;
    }


    /*2656. Maximum Sum With Exactly K Elements (Easy)
    You are given a 0-indexed integer array nums and an integer k. Your task is
    to perform the following operation exactly k times in order to maximize
    your score:
    * Select an element m from nums.
    * Remove the selected element m from the array.
    * Add a new element with a value of m + 1 to the array.
    * Increase your score by m.
    Return the maximum score you can achieve after performing the operation
    exactly k times.

    Example 1:
    Input: nums = [1,2,3,4,5], k = 3
    Output: 18
    Explanation: We need to choose exactly 3 elements from nums to maximize the
                 sum.
                 - For the first iteration, we choose 5. Then sum is 5 and
                   nums = [1,2,3,4,6]
                 - For the second iteration, we choose 6. Then sum is 5 + 6 and
                   nums = [1,2,3,4,7]
                 - For the third iteration, we choose 7. Then sum is
                   5 + 6 + 7 = 18 and nums = [1,2,3,4,8]
                 So, we will return 18. It can be proven, that 18 is the
                 maximum answer that we can achieve.

    Example 2:
    Input: nums = [5,5,5], k = 2
    Output: 11
    Explanation: We need to choose exactly 2 elements from nums to maximize the
                 sum.
                 - For the first iteration, we choose 5. Then sum is 5 and
                   nums = [5,5,6]
                 - For the second iteration, we choose 6. Then sum is
                   5 + 6 = 11 and nums = [5,5,7]
                 So, we will return 11. It can be proven, that 11 is the
                 maximum answer that we can achieve.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= k <= 100*/

    int maximizeSum(vector<int>& nums, int k) {
        int m = *max_element(nums.begin(), nums.end());
        return k*(2*m+k-1)/2;
    }


    /*2657. Find the Prefix Common Array of Two Arrays (Medium)
    You are given two 0-indexed integer permutations A and B of length n. A
    prefix common array of A and B is an array C such that C[i] is equal to the
    count of numbers that are present at or before the index i in both A and B.
    Return the prefix common array of A and B. A sequence of n integers is
    called a permutation if it contains all integers from 1 to n exactly once.

    Example 1:
    Input: A = [1,3,2,4], B = [3,1,2,4]
    Output: [0,2,3,4]
    Explanation: At i = 0: no number is common, so C[0] = 0.
                 At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
                 At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
                 At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.

    Example 2:
    Input: A = [2,3,1], B = [3,1,2]
    Output: [0,1,3]
    Explanation: At i = 0: no number is common, so C[0] = 0.
                 At i = 1: only 3 is common in A and B, so C[1] = 1.
                 At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.

    Constraints:
    * 1 <= A.length == B.length == n <= 50
    * 1 <= A[i], B[i] <= n
    * It is guaranteed that A and B are both a permutation of n integers.*/

    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {
        int n = A.size();
        vector<int> ans, seen(n+1);
        for (int i = 0, prefix = 0; i < n; ++i) {
            if (++seen[A[i]] == 0) ++prefix;
            if (--seen[B[i]] == 0) ++prefix;
            ans.push_back(prefix);
        }
        return ans;
    }


    /*2658. Maximum Number of Fish in a Grid (Hard)
    You are given a 0-indexed 2D matrix grid of size m x n, where (r, c)
    represents:
    * A land cell if grid[r][c] = 0, or
    * A water cell containing grid[r][c] fish, if grid[r][c] > 0.
    A fisher can start at any water cell (r, c) and can do the following
    operations any number of times:
    * Catch all the fish at cell (r, c), or
    * Move to any adjacent water cell.
    Return the maximum number of fish the fisher can catch if he chooses his
    starting cell optimally, or 0 if no water cell exists. An adjacent cell of
    the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or
    (r - 1, c) if it exists.

    Example 1:
    Input: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]
    Output: 7
    Explanation: The fisher can start at cell (1,3) and collect 3 fish, then
                 move to cell (2,3) and collect 4 fish.

    Example 2:
    Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]
    Output: 1
    Explanation: The fisher can start at cells (0,0) or (3,3) and collect a
                 single fish.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10
    * 0 <= grid[i][j] <= 10*/

    int findMaxFish(vector<vector<int>>& grid) {
        int ans = 0, m = grid.size(), n = grid[0].size(), dir[5] = {-1, 0, 1, 0, -1};
        for (int r = 0; r < m; ++r)
            for (int c = 0; c < n; ++c)
                if (grid[r][c]) {
                    int cand = grid[r][c];
                    grid[r][c] = 0;
                    stack<pair<int, int>> stk; stk.emplace(r, c);
                    while (stk.size()) {
                        auto [i, j] = stk.top(); stk.pop();
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj]) {
                                cand += grid[ii][jj];
                                grid[ii][jj] = 0;
                                stk.emplace(ii, jj);
                            }
                        }
                    }
                    ans = max(ans, cand);
                }
        return ans;
    }


    /*2659. Make Array Empty (Hard)
    You are given an integer array nums containing distinct numbers, and you
    can perform the following operations until the array is empty:
    * If the first element has the smallest value, remove it
    * Otherwise, put the first element at the end of the array.
    Return an integer denoting the number of operations it takes to make nums
    empty.

    Example 1:
    Input: nums = [3,4,-1]
    Output: 5
    Operation   Array
            1   [4, -1, 3]
            2   [-1, 3, 4]
            3   [3, 4]
            4   [4]
            5   []

    Example 2:
    Input: nums = [1,2,4,3]
    Output: 5
    Operation   Array
            1   [2, 4, 3]
            2   [4, 3]
            3   [3, 4]
            4   [4]
            5   []

    Example 3:
    Input: nums = [1,2,3]
    Output: 3
    Operation   Array
            1   [2, 3]
            2   [3]
            3   []

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9
    * All values in nums are distinct.*/

    long long countOperationsToEmptyArray(vector<int>& nums) {
        int n = nums.size();
        long long ans = n;
        unordered_map<int, int> loc;
        for (int i = 0; i < n; ++i) loc[nums[i]] = i;
        sort(nums.begin(), nums.end());
        for (int i = 1; i < n; ++i)
            if (loc[nums[i-1]] > loc[nums[i]]) ans += n-i;
        return ans;
    }


    /*2660. Determine the Winner of a Bowling Game (Easy)
    You are given two 0-indexed integer arrays player1 and player2, that
    represent the number of pins that player 1 and player 2 hit in a bowling
    game, respectively. The bowling game consists of n turns, and the number of
    pins in each turn is exactly 10. Assume a player hit xi pins in the ith
    turn. The value of the ith turn for the player is:
    * 2xi if the player hit 10 pins in any of the previous two turns.
    * Otherwise, It is xi.
    The score of the player is the sum of the values of their n turns. Return
    * 1 if the score of player 1 is more than the score of player 2,
    * 2 if the score of player 2 is more than the score of player 1, and
    * 0 in case of a draw.

    Example 1:
    Input: player1 = [4,10,7,9], player2 = [6,5,2,3]
    Output: 1
    Explanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.
                 The score of player2 is 6 + 5 + 2 + 3 = 16.
                 Score of player1 is more than the score of player2, so,
                 player1 is the winner, and the answer is 1.

    Example 2:
    Input: player1 = [3,5,7,6], player2 = [8,10,10,2]
    Output: 2
    Explanation: The score of player1 is 3 + 5 + 7 + 6 = 21.
                 The score of player2 is 8 + 10 + 2*10 + 2*2 = 42.
                 Score of player2 is more than the score of player1, so,
                 player2 is the winner, and the answer is 2.

    Example 3:
    Input: player1 = [2,3], player2 = [4,1]
    Output: 0
    Explanation: The score of player1 is 2 + 3 = 5
                 The score of player2 is 4 + 1 = 5
                 The score of player1 equals to the score of player2, so,
                 there is a draw, and the answer is 0.

    Constraints:
    * n == player1.length == player2.length
    * 1 <= n <= 1000
    * 0 <= player1[i], player2[i] <= 10*/

    int isWinner(vector<int>& player1, vector<int>& player2) {

        auto fn = [&](vector<int>& player) {
            int ans = 0;
            for (int i = 0; i < player.size(); ++i) {
                ans += player[i];
                if (i && player[i-1] == 10 || i >= 2 && player[i-2] == 10) ans += player[i];
            }
            return ans;
        };

        int diff = fn(player1) - fn(player2);
        return diff > 0 ? 1 : diff < 0 ? 2 : 0;
    }


    /*2661. First Completely Painted Row or Column (Medium)
    You are given a 0-indexed integer array arr, and an m x n integer matrix
    mat. arr and mat both contain all the integers in the range [1, m * n].
    Go through each index i in arr starting from index 0 and paint the cell in
    mat containing the integer arr[i]. Return the smallest index i at which
    either a row or a column will be completely painted in mat.

    Example 1:
    image explanation for example 1
    Input: arr = [1,3,4,2], mat = [[1,4],[2,3]]
    Output: 2
    Explanation: The moves are shown in order, and both the first row and
                 second column of the matrix become fully painted at arr[2].

    Example 2:
    image explanation for example 2
    Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]
    Output: 3
    Explanation: The second column becomes fully painted at arr[3].

    Constraints:
    * m == mat.length
    * n = mat[i].length
    * arr.length == m * n
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 1 <= arr[i], mat[r][c] <= m * n
    * All the integers of arr are unique.
    * All the integers of mat are unique.*/

    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size();
        vector<pair<int, int>> loc(m*n);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                loc[mat[i][j]-1] = {i, j};
        vector<int> rows(m), cols(n);
        for (int k = 0; k < arr.size(); ++k) {
            auto [i, j] = loc[arr[k]-1];
            if (++rows[i] == n || ++cols[j] == m) return k;
        }
        return -1;
    }


    /*2662. Minimum Cost of a Path With Special Roads (Medium)
    You are given an array start where start = [startX, startY] represents your
    initial position (startX, startY) in a 2D space. You are also given the
    array target where target = [targetX, targetY] represents your target
    position (targetX, targetY). The cost of going from a position (x1, y1) to
    any other position in the space (x2, y2) is |x2 - x1| + |y2 - y1|. There
    are also some special roads. You are given a 2D array specialRoads where
    specialRoads[i] = [x1i, y1i, x2i, y2i, costi] indicates that the ith
    special road can take you from (x1i, y1i) to (x2i, y2i) with a cost equal
    to costi. You can use each special road any number of times. Return the
    minimum cost required to go from (startX, startY) to (targetX, targetY).

    Example 1:
    Input: start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]
    Output: 5
    Explanation: The optimal path from (1,1) to (4,5) is the following:
                 - (1,1) -> (1,2). This move has a cost of |1 - 1| + |2 - 1| = 1.
                 - (1,2) -> (3,3). This move uses the first special edge, the
                   cost is 2.
                 - (3,3) -> (3,4). This move has a cost of |3 - 3| + |4 - 3| = 1.
                 - (3,4) -> (4,5). This move uses the second special edge, the
                   cost is 1.
                 So the total cost is 1 + 2 + 1 + 1 = 5. It can be shown that
                 we cannot achieve a smaller total cost than 5.

    Example 2:
    Input: start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]
    Output: 7
    Explanation: It is optimal to not use any special edges and go directly
                 from the starting to the ending position with a cost
                 |5 - 3| + |7 - 2| = 7.

    Constraints:
    * start.length == target.length == 2
    * 1 <= startX <= targetX <= 10^5
    * 1 <= startY <= targetY <= 10^5
    * 1 <= specialRoads.length <= 200
    * specialRoads[i].length == 5
    * startX <= x1i, x2i <= targetX
    * startY <= y1i, y2i <= targetY
    * 1 <= costi <= 10^5*/

    int minimumCost(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {
        long m = 100001;
        unordered_map<long, vector<pair<long, int>>> mp = {{target[0]*m + target[1], {{0, 0}}}};
        for (auto& x : specialRoads)
            mp[x[0]*m + x[1]].emplace_back(x[2]*m + x[3], x[4]);
        unordered_map<long, int> dist;
        dist[start[0]*m + start[1]] = 0;
        priority_queue<pair<int, long>, vector<pair<int, long>>, greater<>> pq;
        pq.emplace(0, start[0]*m + start[1]);
        while (pq.size()) {
            auto [d, x] = pq.top(); pq.pop();
            if (x == target[0]*m + target[1]) return d;
            for (auto& [xx, cost] : mp[x])
                if (!dist.count(xx) || d + cost < dist[xx]) {
                    dist[xx] = d + cost;
                    pq.emplace(d + cost, xx);
                }
            for (auto& [xx, _] : mp) {
                int dd = d + abs(xx%m - x%m) + abs(xx/m - x/m);
                if (!dist.count(xx) || dd < dist[xx]) {
                    dist[xx] = dd;
                    pq.emplace(dd, xx);
                }
            }
        }
        return -1;
    }


    /*2663. Lexicographically Smallest Beautiful String (Hard)
    A string is beautiful if:
    * It consists of the first k letters of the English lowercase alphabet.
    * It does not contain any substring of length 2 or more which is a
      palindrome.
    You are given a beautiful string s of length n and a positive integer k.
    Return the lexicographically smallest string of length n, which is larger
    than s and is beautiful. If there is no such string, return an empty string.
    A string a is lexicographically larger than a string b (of the same length)
    if in the first position where a and b differ, a has a character strictly
    larger than the corresponding character in b.
    * For example, "abcd" is lexicographically larger than "abcc" because the
      first position they differ is at the fourth character, and d is greater
      than c.

    Example 1:
    Input: s = "abcz", k = 26
    Output: "abda"
    Explanation: The string "abda" is beautiful and lexicographically larger
                 than the string "abcz". It can be proven that there is no
                 string that is lexicographically larger than the string
                 "abcz", beautiful, and lexicographically smaller than the
                 string "abda".

    Example 2:
    Input: s = "dc", k = 4
    Output: ""
    Explanation: It can be proven that there is no string that is
                 lexicographically larger than the string "dc" and is
                 beautiful.

    Constraints:
    * 1 <= n == s.length <= 10^5
    * 4 <= k <= 26
    * s is a beautiful string.*/

    string smallestBeautifulString(string s, int k) {
        for (int n = s.size(), i = n-1; i >= 0; --i)
            for (char c = s[i]+1; c < 'a'+k; ++c)
                if ((i == 0 || s[i-1] != c) && (i <= 1 || s[i-2] != c)) {
                    s[i] = c;
                    for (int ii = i+1; ii < n; ++ii)
                        for (char cc = 'a'; cc < 'a'+k; ++cc)
                            if (cc != s[ii-1] && (ii == 1 || cc != s[ii-2])) {
                                s[ii] = cc;
                                break;
                            }
                    return s;
                }
        return "";
    }


    /*2664. The Knight’s Tour (Medium)
    Given two positive integers m and n which are the height and width of a
    0-indexed 2D-array board, a pair of positive integers (r, c) which is the
    starting position of the knight on the board. Your task is to find an order
    of movements for the knight, in a manner that every cell of the board gets
    visited exactly once (the starting cell is considered visited and you
    shouldn't visit it again). Return the array board in which the cells'
    values show the order of visiting the cell starting from 0 (the initial
    place of the knight). Note that a knight can move from cell (r1, c1) to
    cell (r2, c2) if 0 <= r2 <= m - 1 and 0 <= c2 <= n - 1 and
    min(abs(r1 - r2), abs(c1 - c2)) = 1 and max(abs(r1 - r2), abs(c1 - c2)) = 2.

    Example 1:
    Input: m = 1, n = 1, r = 0, c = 0
    Output: [[0]]
    Explanation: There is only 1 cell and the knight is initially on it so
                 there is only a 0 inside the 1x1 grid.

    Example 2:
    Input: m = 3, n = 4, r = 0, c = 0
    Output: [[0,3,6,9],[11,8,1,4],[2,5,10,7]]
    Explanation: By the following order of movements we can visit the entire
                 board. (0,0)->(1,2)->(2,0)->(0,1)->(1,3)->(2,1)->(0,2)->(2,3)
                 ->(1,1)->(0,3)->(2,2)->(1,0)

    Constraints:
    * 1 <= m, n <= 5
    * 0 <= r <= m - 1
    * 0 <= c <= n - 1
    * The inputs will be generated such that there exists at least one possible
      order of movements with the given condition*/

    vector<vector<int>> tourOfKnight(int m, int n, int r, int c) {
        vector<vector<int>> board(m, vector<int>(n, -1));
        vector<pair<int, int>> dir = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};

        function<bool(int, int, int)> fn = [&](int i, int j, int k) {
            if (k == m*n) return true;
            for (auto& [di, dj] : dir) {
                int ii = i + di, jj = j + dj;
                if (0 <= ii && ii < m && 0 <= jj && jj < n && board[ii][jj] == -1) {
                    board[ii][jj] = k;
                    if (fn(ii, jj, k+1)) return true;
                    board[ii][jj] = -1;
                }
            }
            return false;
        };

        board[r][c] = 0;
        fn(r, c, 1);
        return board;
    }


    /*2670. Find the Distinct Difference Array (Easy)
    You are given a 0-indexed array nums of length n. The distinct difference
    array of nums is an array diff of length n such that diff[i] is equal to
    the number of distinct elements in the suffix nums[i + 1, ..., n - 1]
    subtracted from the number of distinct elements in the prefix
    nums[0, ..., i]. Return the distinct difference array of nums. Note that
    nums[i, ..., j] denotes the subarray of nums starting at index i and
    ending at index j inclusive. Particularly, if i > j then nums[i, ..., j]
    denotes an empty subarray.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: [-3,-1,1,3,5]
    Explanation: - For index i = 0, there is 1 element in the prefix and 4
                   distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.
                 - For index i = 1, there are 2 distinct elements in the prefix
                   and 3 distinct elements in the suffix. Thus,
                   diff[1] = 2 - 3 = -1.
                 - For index i = 2, there are 3 distinct elements in the prefix
                   and 2 distinct elements in the suffix. Thus,
                   diff[2] = 3 - 2 = 1.
                 - For index i = 3, there are 4 distinct elements in the prefix
                   and 1 distinct element in the suffix. Thus,
                   diff[3] = 4 - 1 = 3.
                 - For index i = 4, there are 5 distinct elements in the prefix
                   and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.

    Example 2:
    Input: nums = [3,2,3,4,2]
    Output: [-2,-1,0,2,3]
    Explanation: - For index i = 0, there is 1 element in the prefix and 3
                   distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.
                 - For index i = 1, there are 2 distinct elements in the prefix
                   and 3 distinct elements in the suffix. Thus,
                   diff[1] = 2 - 3 = -1.
                 - For index i = 2, there are 2 distinct elements in the prefix
                   and 2 distinct elements in the suffix. Thus,
                   diff[2] = 2 - 2 = 0.
                 - For index i = 3, there are 3 distinct elements in the prefix
                   and 1 distinct element in the suffix. Thus,
                   diff[3] = 3 - 1 = 2.
                 - For index i = 4, there are 3 distinct elements in the prefix
                   and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.

    Constraints:
    * 1 <= n == nums.length <= 50
    * 1 <= nums[i] <= 50*/

    vector<int> distinctDifferenceArray(vector<int>& nums) {
        vector<int> ans;
        unordered_set<int> prefix;
        unordered_map<int, int> suffix;
        for (auto& x : nums) ++suffix[x];
        for (auto& x : nums) {
            prefix.insert(x);
            if (--suffix[x] == 0) suffix.erase(x);
            ans.push_back(prefix.size() - suffix.size());
        }
        return ans;
    }


    /*2672. Number of Adjacent Elements With the Same Color (Medium)
    There is a 0-indexed array nums of length n. Initially, all elements are
    uncolored (has a value of 0). You are given a 2D integer array queries
    where queries[i] = [indexi, colori]. For each query, you color the index
    indexi with the color colori in the array nums. Return an array answer of
    the same length as queries where answer[i] is the number of adjacent
    elements with the same color after the ith query. More formally, answer[i]
    is the number of indices j, such that 0 <= j < n - 1 and
    nums[j] == nums[j + 1] and nums[j] != 0 after the ith query.

    Example 1:
    Input: n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]
    Output: [0,1,1,0,2]
    Explanation: Initially array nums = [0,0,0,0], where 0 denotes uncolored
                 elements of the array.
                 - After the 1st query nums = [2,0,0,0]. The count of adjacent
                   elements with the same color is 0.
                 - After the 2nd query nums = [2,2,0,0]. The count of adjacent
                   elements with the same color is 1.
                 - After the 3rd query nums = [2,2,0,1]. The count of adjacent
                   elements with the same color is 1.
                 - After the 4th query nums = [2,1,0,1]. The count of adjacent
                   elements with the same color is 0.
                 - After the 5th query nums = [2,1,1,1]. The count of adjacent
                   elements with the same color is 2.

    Example 2:
    Input: n = 1, queries = [[0,100000]]
    Output: [0]
    Explanation: Initially array nums = [0], where 0 denotes uncolored elements
                 of the array.
                 - After the 1st query nums = [100000]. The count of adjacent
                   elements with the same color is 0.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= indexi <= n - 1
    * 1 <=  colori <= 10^5*/

    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {
        vector<int> ans, nums(n);
        int cnt = 0;
        for (auto& q : queries) {
            int i = q[0], x = q[1];
            if (i && nums[i] && nums[i-1] == nums[i]) --cnt;
            if (i+1 < n && nums[i] && nums[i] == nums[i+1]) --cnt;
            nums[i] = x;
            if (i && nums[i] && nums[i-1] == nums[i]) ++cnt;
            if (i+1 < n && nums[i] == nums[i+1]) ++cnt;
            ans.push_back(cnt);
        }
        return ans;
    }


    /*2673. Make Costs of Paths Equal in a Binary Tree (Medium)
    You are given an integer n representing the number of nodes in a perfect
    binary tree consisting of nodes numbered from 1 to n. The root of the tree
    is node 1 and each node i in the tree has two children where the left child
    is the node 2 * i and the right child is 2 * i + 1. Each node in the tree
    also has a cost represented by a given 0-indexed integer array cost of size
    n where cost[i] is the cost of node i + 1. You are allowed to increment the
    cost of any node by 1 any number of times. Return the minimum number of
    increments you need to make the cost of paths from the root to each leaf
    node equal.

    Note:
    * A perfect binary tree is a tree where each node, except the leaf nodes,
      has exactly 2 children.
    * The cost of a path is the sum of costs of nodes in the path.

    Example 1:
    Input: n = 7, cost = [1,5,2,2,3,3,1]
    Output: 6
    Explanation: We can do the following increments:
                 - Increase the cost of node 4 one time.
                 - Increase the cost of node 3 three times.
                 - Increase the cost of node 7 two times.
                 Each path from the root to a leaf will have a total cost of 9.
                 The total increments we did is 1 + 3 + 2 = 6. It can be shown
                 that this is the minimum answer we can achieve.

    Example 2:
    Input: n = 3, cost = [5,3,3]
    Output: 0
    Explanation: The two paths already have equal total costs, so no increments
                 are needed.

    Constraints:
    * 3 <= n <= 10^5
    * n + 1 is a power of 2
    * cost.length == n
    * 1 <= cost[i] <= 10^4*/

    int minIncrements(int n, vector<int>& cost) {
        int ans = 0;
        for (int i = n/2-1; i >= 0; --i) {
            ans += abs(cost[2*i+1] - cost[2*i+2]);
            cost[i] += max(cost[2*i+1], cost[2*i+2]);
        }
        return ans;
    }


    /*2674. Split a Circular Linked Listn (Medium)
    Given a circular linked list list of positive integers, your task is to
    split it into 2 circular linked lists so that the first one contains the
    first half of the nodes in list (exactly ceil(list.length / 2) nodes) in the
    same order they appeared in list, and the second one contains the rest of
    the nodes in list in the same order they appeared in list. Return an array
    answer of length 2 in which the first element is a circular linked list
    representing the first half and the second element is a circular linked list
    representing the second half. A circular linked list is a normal linked list
    with the only difference being that the last node's next node, is the first
    node.

    Example 1:
    Input: nums = [1,5,7]
    Output: [[1,5],[7]]
    Explanation: The initial list has 3 nodes so the first half would be the
                 first 2 elements since ceil(3 / 2) = 2 and the rest which is 1
                 node is in the second half.

    Example 2:
    Input: nums = [2,6,1,5]
    Output: [[2,6],[1,5]]
    Explanation: The initial list has 4 nodes so the first half would be the
                 first 2 elements since ceil(4 / 2) = 2 and the rest which is 2
                 nodes are in the second half.

    Constraints:
    * The number of nodes in list is in the range [2, 10^5]
    * 0 <= Node.val <= 10^9
    * LastNode.next = FirstNode where LastNode is the last node of the list and
      FirstNode is the first one*/

    vector<ListNode*> splitCircularLinkedList(ListNode* list) {
        ListNode *fast = list, *slow = list;
        while (fast->next != list && fast->next->next != list) {
            fast = fast->next->next;
            slow = slow->next;
        }
        if (fast->next != list) fast = fast->next;
        ListNode *head = slow->next;
        slow->next = list;
        fast->next = head;
        return {list, head};
    }


    /*2678. Number of Senior Citizens (Easy)
    You are given a 0-indexed array of strings details. Each element of details
    provides information about a given passenger compressed into a string of
    length 15. The system is such that:
    * The first ten characters consist of the phone number of passengers.
    * The next character denotes the gender of the person.
    * The following two characters are used to indicate the age of the person.
    * The last two characters determine the seat allotted to that person.
    Return the number of passengers who are strictly more than 60 years old.

    Example 1:
    Input: details = ["7868190130M7522","5303914400F9211","9273338290F4010"]
    Output: 2
    Explanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40.
                 Thus, there are 2 people who are over 60 years old.

    Example 2:
    Input: details = ["1313579440F2036","2921522980M5644"]
    Output: 0
    Explanation: None of the passengers are older than 60.

    Constraints:
    * 1 <= details.length <= 100
    * details[i].length == 15
    * details[i] consists of digits from '0' to '9'.
    * details[i][10] is either 'M' or 'F' or 'O'.
    * The phone numbers and seat numbers of the passengers are distinct.*/

    int countSeniors(vector<string>& details) {
        return accumulate(details.begin(), details.end(), 0, [&](int s, auto& d) {
            return s + (stoi(d.substr(11, 2)) > 60 ? 1 : 0);
        });
    }


    /*2689. Extract Kth Character From The Rope Tree (Easy)
    You are given the root of a binary tree and an integer k. Besides the left
    and right children, every node of this tree has two other properties, a
    string node.val containing only lowercase English letters (possibly empty)
    and a non-negative integer node.len. There are two types of nodes in this tree:
    * Leaf: These nodes have no children, node.len = 0, and node.val is some
      non-empty string.
    * Internal: These nodes have at least one child (also at most two children),
      node.len > 0, and node.val is an empty string.
    The tree described above is called a Rope binary tree. Now we define S[node]
    recursively as follows:
    * If node is some leaf node, S[node] = node.val,
    * Otherwise if node is some internal node,
      S[node] = concat(S[node.left], S[node.right]) and
      S[node].length = node.len.
    Return k-th character of the string S[root]. Note: If s and p are two
    strings, concat(s, p) is a string obtained by concatenating p to s. For
    example, concat("ab", "zz") = "abzz".

    Example 1:
    Input: root = [10,4,"abcpoe","g","rta"], k = 6
    Output: "b"
    Explanation: In the picture below, we put an integer on internal nodes that
                 represents node.len, and a string on leaf nodes that represents
                 node.val. You can see that
                 S[root] = concat(concat("g", "rta"), "abcpoe") = "grtaabcpoe".
                 So S[root][5], which represents 6th character of it, is equal
                 to "b".

    Example 2:
    Input: root = [12,6,6,"abc","efg","hij","klm"], k = 3
    Output: "c"
    Explanation: In the picture below, we put an integer on internal nodes that
                 represents node.len, and a string on leaf nodes that represents
                 node.val. You can see that
                 S[root] = concat(concat("abc", "efg"), concat("hij", "klm")) =
                 "abcefghijklm". So S[root][2], which represents the 3rd
                 character of it, is equal to "c".

    Example 3:
    Input: root = ["ropetree"], k = 8
    Output: "e"
    Explanation: In the picture below, we put an integer on internal nodes that
                 represents node.len, and a string on leaf nodes that represents
                 node.val. You can see that S[root] = "ropetree". So S[root][7],
                 which represents 8th character of it, is equal to "e".

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^3]
    * node.val contains only lowercase English letters
    * 0 <= node.val.length <= 50
    * 0 <= node.len <= 10^4
    * for leaf nodes, node.len = 0 and node.val is non-empty
    * for internal nodes, node.len > 0 and node.val is empty
    * 1 <= k <= S[root].length*/

    char getKthCharacter(RopeTreeNode* root, int k) {
        RopeTreeNode* node = root;
        while (node->len) {
            int val = node->left ? max(node->left->len, (int) node->left->val.size()) : 0;
            if (val >= k) node = node->left;
            else {
                k -= val;
                node = node->right;
            }
        }
        return node->val[k-1];
    }


    /*2699. Modify Graph Edge Weights (Hard)
    You are given an undirected weighted connected graph containing n nodes
    labeled from 0 to n - 1, and an integer array edges where
    edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and
    bi with weight wi. Some edges have a weight of -1 (wi = -1), while others
    have a positive weight (wi > 0). Your task is to modify all edges with a
    weight of -1 by assigning them positive integer values in the range
    [1, 2 * 10^9] so that the shortest distance between the nodes source and
    destination becomes equal to an integer target. If there are multiple
    modifications that make the shortest distance between source and destination
    equal to target, any of them will be considered correct. Return an array
    containing all edges (even unmodified ones) in any order if it is possible
    to make the shortest distance from source to destination equal to target, or
    an empty array if it's impossible. Note: You are not allowed to modify the
    weights of edges with initial positive weights.

    Example 1:
    Input: n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5
    Output: [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]
    Explanation: The graph above shows a possible modification to the edges,
                 making the distance from 0 to 1 equal to 5.

    Example 2:
    Input: n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6
    Output: []
    Explanation: The graph above contains the initial edges. It is not possible
                 to make the distance from 0 to 2 equal to 6 by modifying the
                 edge with weight -1. So, an empty array is returned.

    Example 3:
    Input: n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6
    Output: [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]
    Explanation: The graph above shows a modified graph having the shortest
                 distance from 0 to 2 as 6.

    Constraints:
    * 1 <= n <= 100
    * 1 <= edges.length <= n * (n - 1) / 2
    * edges[i].length == 3
    * 0 <= ai, bi < n
    * wi = -1 or 1 <= wi <= 10^7
    * ai != bi
    * 0 <= source, destination < n
    * source != destination
    * 1 <= target <= 10^9
    * The graph is connected, and there are no self-loops or repeated edges*/

    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {
        vector<vector<int>> graph(n, vector<int>(n));
        for (auto& e : edges) {
            int u = e[0], v = e[1], w = e[2];
            graph[u][v] = graph[v][u] = w;
        }
        vector<int> orig(n, INT_MAX);
        orig[source] = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.emplace(0, source);
        while (pq.size()) {
            auto [d, u] = pq.top(); pq.pop();
            if (d == orig[u]) {
                for (int v = 0; v < n; ++v) {
                    int w = graph[u][v];
                    if (w && w != -1 && d+w < orig[v]) {
                        orig[v] = d+w;
                        pq.emplace(d+w, v);
                    }
                }
            }
        }
        if (orig[destination] < target) return {};
        if (orig[destination] == target) {
            for (auto& e : edges)
                if (e[2] == -1) e[2] = 2'000'000'000;
            return edges;
        }
        vector<int> dist(n, INT_MAX), parent(n, -1);
        dist[source] = 0;
        pq.emplace(0, source);
        while (pq.size()) {
            auto [d, u] = pq.top(); pq.pop();
            if (u == destination) {
                if (d > target) return {};
                break;
            }
            if (d == dist[u]) {
                for (int v = 0; v < n; ++v) {
                    int w = graph[u][v];
                    if (w) {
                        int dd = w == -1 ? d+1 : d+w;
                        if (dd < dist[v]) {
                            dist[v] = dd;
                            parent[v] = u;
                            pq.emplace(dd, v);
                        }
                    }
                }
            }
        }
        for (int u = destination; u >= 0 && parent[u] >= 0; u = parent[u]) {
            int p = parent[u];
            if (graph[p][u] == -1) {
                if (orig[p] < target) {
                    graph[p][u] = graph[u][p] = target - orig[p];
                    break;
                }
                graph[p][u] = graph[u][p] = 1;
            }
            target -= graph[u][p];
        }
        for (auto& e : edges) {
            if (graph[e[0]][e[1]] == -1) e[2] = 2'000'000'000;
            else e[2] = graph[e[0]][e[1]];
        }
        return edges;
    }


    /*2728. Count Houses in a Circular Street (Easy)
    You are given an object street of class Street that represents a circular
    street and a positive integer k which represents a maximum bound for the
    number of houses in that street (in other words, the number of houses is
    less than or equal to k). Houses' doors could be open or closed initially.
    Initially, you are standing in front of a door to a house on this street.
    Your task is to count the number of houses in the street. The class Street
    contains the following functions which may help you:
    * void openDoor(): Open the door of the house you are in front of.
    * void closeDoor(): Close the door of the house you are in front of.
    * boolean isDoorOpen(): Returns true if the door of the current house is
      open and false otherwise.
    * void moveRight(): Move to the right house.
    * void moveLeft(): Move to the left house.
    Return ans which represents the number of houses on this street.

    Example 1:
    Input: street = [0,0,0,0], k = 10
    Output: 4
    Explanation: There are 4 houses, and all their doors are closed. The number
                 of houses is less than k, which is 10.

    Example 2:
    Input: street = [1,0,1,1,0], k = 5
    Output: 5
    Explanation: There are 5 houses, and the doors of the 1st, 3rd, and 4th
                 house (moving in the right direction) are open, and the rest
                 are closed. The number of houses is equal to k, which is 5.

    Constraints:
    * n == number of houses
    * 1 <= n <= k <= 10^3*/

    int houseCount(Street* street, int k) {
        for (; k; --k) {
            street->openDoor();
            street->moveRight();
        }
        int ans = 0;
        for (; street->isDoorOpen(); ++ans) {
            street->closeDoor();
            street->moveRight();
        }
        return ans;
    }


    /*2729. Check if The Number is Fascinating (Easy)
    You are given an integer n that consists of exactly 3 digits. We call the
    number n fascinating if, after the following modification, the resulting
    number contains all the digits from 1 to 9 exactly once and does not contain
    any 0's:
    * Concatenate n with the numbers 2 * n and 3 * n.
    Return true if n is fascinating, or false otherwise. Concatenating two
    numbers means joining them together. For example, the concatenation of 121
    and 371 is 121371.

    Example 1:
    Input: n = 192
    Output: true
    Explanation: We concatenate the numbers n = 192 and 2 * n = 384 and
                 3 * n = 576. The resulting number is 192384576. This number
                 contains all the digits from 1 to 9 exactly once.

    Example 2:
    Input: n = 100
    Output: false
    Explanation: We concatenate the numbers n = 100 and 2 * n = 200 and
                 3 * n = 300. The resulting number is 100200300. This number
                 does not satisfy any of the conditions.

    Constraints: 100 <= n <= 999*/

    bool isFascinating(int n) {
        unordered_set<int> seen;
        for (int x = n; x <= 3*n; x += n) {
            if (x >= 1000) return false;
            for (auto& ch : to_string(x)) seen.insert(ch);
        }
        return seen.size() == 9 && !seen.count('0');
    }


    /*2730. Find the Longest Semi-Repetitive Substring (Medium)
    You are given a digit string s that consists of digits from 0 to 9. A string
    is called semi-repetitive if there is at most one adjacent pair of the same
    digit. For example, "0010", "002020", "0123", "2002", and "54944" are semi-
    repetitive while the following are not: "00101022" (adjacent same digit
    pairs are 00 and 22), and "1101234883" (adjacent same digit pairs are 11 and
    88). Return the length of the longest semi-repetitive substring of s.

    Example 1:
    Input: s = "52233"
    Output: 4
    Explanation: The longest semi-repetitive substring is "5223". Picking the
                 whole string "52233" has two adjacent same digit pairs 22 and
                 33, but at most one is allowed.

    Example 2:
    Input: s = "5494"
    Output: 4
    Explanation: s is a semi-repetitive string.

    Example 3:
    Input: s = "1111111"
    Output: 2
    Explanation: The longest semi-repetitive substring is "11". Picking the
                 substring "111" has two adjacent same digit pairs, but at most
                 one is allowed.

    Constraints:
    * 1 <= s.length <= 50
    * '0' <= s[i] <= '9'*/

    int longestSemiRepetitiveSubstring(string s) {
        int ans = 1;
        for (int i = 1, ii = 0, q = 0; i < s.size(); ++i) {
            if (s[i-1] == s[i]) {
                if (q) ii = q;
                q = i;
            }
            ans = max(ans, i-ii+1);
        }
        return ans;
    }


    /*2731. Movement of Robots (Medium)
    Some robots are standing on an infinite number line with their initial
    coordinates given by a 0-indexed integer array nums and will start moving
    once given the command to move. The robots will move a unit distance each
    second. You are given a string s denoting the direction in which robots will
    move on command. 'L' means the robot will move towards the left side or
    negative side of the number line, whereas 'R' means the robot will move
    towards the right side or positive side of the number line. If two robots
    collide, they will start moving in opposite directions. Return the sum of
    distances between all the pairs of robots d seconds after the command. Since
    the sum can be very large, return it modulo 109 + 7.

    Note:
    * For two robots at the index i and j, pair (i,j) and pair (j,i) are
      considered the same pair.
    * When robots collide, they instantly change their directions without
      wasting any time.
    * Collision happens when two robots share the same place in a moment.
      - For example, if a robot is positioned in 0 going to the right and
        another is positioned in 2 going to the left, the next second they'll be
        both in 1 and they will change direction and the next second the first
        one will be in 0, heading left, and another will be in 2, heading right.
      - For example, if a robot is positioned in 0 going to the right and
        another is positioned in 1 going to the left, the next second the first
        one will be in 0, heading left, and another will be in 1, heading right.

    Example 1:
    Input: nums = [-2,0,2], s = "RLL", d = 3
    Output: 8
    Explanation: - After 1 second, the positions are [-1,-1,1]. Now, the robot
                   at index 0 will move left, and the robot at index 1 will move
                   right.
                 - After 2 seconds, the positions are [-2,0,0]. Now, the robot
                   at index 1 will move left, and the robot at index 2 will move
                   right.
                 - After 3 seconds, the positions are [-3,-1,1].
                 - The distance between the robot at index 0 and 1 is
                   abs(-3 - (-1)) = 2.
                 - The distance between the robot at index 0 and 2 is
                   abs(-3 - 1) = 4.
                 - The distance between the robot at index 1 and 2 is
                   abs(-1 - 1) = 2.
                 - The sum of the pairs of all distances = 2 + 4 + 2 = 8.

    Example 2:
    Input: nums = [1,0], s = "RL", d = 2
    Output: 5
    Explanation: - After 1 second, the positions are [2,-1].
                 - After 2 seconds, the positions are [3,-2].
                 The distance between the two robots is abs(-2 - 3) = 5.

    Constraints:
    * 2 <= nums.length <= 10^5
    * -2 * 10^9 <= nums[i] <= 2 * 10^9
    * 0 <= d <= 10^9
    * nums.length == s.length
    * s consists of 'L' and 'R' only
    * nums[i] will be unique.*/

    int sumDistance(vector<int>& nums, string s, int d) {
        const int mod = 1'000'000'007;
        for (int i = 0; i < nums.size(); ++i) {
            if (s[i] == 'L') nums[i] -= d;
            else nums[i] += d;
        }
        sort(nums.begin(), nums.end());
        long ans = 0;
        for (long i = 0, prefix = 0; i < nums.size(); ++i) {
            ans = (ans + i*nums[i] - prefix) % mod;
            prefix = (prefix + nums[i]) % mod;
        }
        return ans;
    }


    /*2732. Find a Good Subset of the Matrix (Hard)
    You are given a 0-indexed m x n binary matrix grid. Let us call a non-empty
    subset of rows good if the sum of each column of the subset is at most half
    of the length of the subset. More formally, if the length of the chosen
    subset of rows is k, then the sum of each column should be at most
    floor(k / 2). Return an integer array that contains row indices of a good
    subset sorted in ascending order. If there are multiple good subsets, you
    can return any of them. If there are no good subsets, return an empty array.
    A subset of rows of the matrix grid is any matrix that can be obtained by
    deleting some (possibly none or all) rows from grid.

    Example 1:
    Input: grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]
    Output: [0,1]
    Explanation: We can choose the 0th and 1st rows to create a good subset of rows.
                 The length of the chosen subset is 2.
                 - The sum of the 0th column is 0 + 0 = 0, which is at most half of the length of the subset.
                 - The sum of the 1st column is 1 + 0 = 1, which is at most half of the length of the subset.
                 - The sum of the 2nd column is 1 + 0 = 1, which is at most half of the length of the subset.
                 - The sum of the 3rd column is 0 + 1 = 1, which is at most half of the length of the subset.

    Example 2:
    Input: grid = [[0]]
    Output: [0]
    Explanation: We can choose the 0th row to create a good subset of rows.
                 The length of the chosen subset is 1.
                 - The sum of the 0th column is 0, which is at most half of the length of the subset.

    Example 3:
    Input: grid = [[1,1,1],[1,1,1]]
    Output: []
    Explanation: It is impossible to choose any subset of rows to create a good subset.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m <= 10^4
    * 1 <= n <= 5
    * grid[i][j] is either 0 or 1.*/

    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        unordered_map<int, int> seen;
        for (int i = 0; i < m; ++i) {
            int v = 0;
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) v ^= 1<<j;
            if (v == 0) return {i};
            for (auto& [vv, ii] : seen)
                if ((vv & v) == 0) return {ii, i};
            seen[v] = i;
        }
        return {};
    }


    /*2733. Neither Minimum nor Maximum (Easy)
    Given an integer array nums containing distinct positive integers, find and
    return any number from the array that is neither the minimum nor the maximum
    value in the array, or -1 if there is no such number. Return the selected
    integer.

    Example 1:
    Input: nums = [3,2,1,4]
    Output: 2
    Explanation: In this example, the minimum value is 1 and the maximum value
                 is 4. Therefore, either 2 or 3 can be valid answers.

    Example 2:
    Input: nums = [1,2]
    Output: -1
    Explanation: Since there is no number in nums that is neither the maximum
                 nor the minimum, we cannot select a number that satisfies the
                 given condition. Therefore, there is no answer.

    Example 3:
    Input: nums = [2,1,3]
    Output: 2
    Explanation: Since 2 is neither the maximum nor the minimum value in nums,
                 it is the only valid answer.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * All values in nums are distinct*/

    int findNonMinOrMax(vector<int>& nums) {
        if (nums.size() < 3) return -1;
        sort(nums.begin(), nums.begin()+3);
        return nums[1];
    }


    /*2734. Lexicographically Smallest String After Substring Operation (Medium)
    Given a string s consisting of lowercase English letters. Perform the
    following operation:
    * Select any non-empty substring then replace every letter of the substring
      with the preceding letter of the English alphabet. For example, 'b' is
      converted to 'a', and 'a' is converted to 'z'.
    Return the lexicographically smallest string after performing the operation.

    Example 1:
    Input: s = "cbabc"
    Output: "baabc"
    Explanation: Perform the operation on the substring starting at index 0, and
                 ending at index 1 inclusive.

    Example 2:
    Input: s = "aa"
    Output: "az"
    Explanation: Perform the operation on the last letter.

    Example 3:
    Input: s = "acbbc"
    Output: "abaab"
    Explanation: Perform the operation on the substring starting at index 1, and
                 ending at index 4 inclusive.

    Example 4:
    Input: s = "leetcode"
    Output: "kddsbncd"
    Explanation: Perform the operation on the entire string.

    Constraints:
    * 1 <= s.length <= 3 * 10^5
    * s consists of lowercase English letters*/

    string smallestString(string s) {
        int i = 0, n = s.size();
        for (; i < n && s[i] == 'a'; ++i);
        if (i == n) s.back() = 'z';
        for (; i < n && s[i] != 'a'; --s[i], ++i);
        return s;
    }


    /*2735. Collecting Chocolates (Medium)
    You are given a 0-indexed integer array nums of size n representing the cost
    of collecting different chocolates. The cost of collecting the chocolate at
    the index i is nums[i]. Each chocolate is of a different type, and initially,
    the chocolate at the index i is of ith type. In one operation, you can do
    the following with an incurred cost of x:
    * Simultaneously change the chocolate of ith type to ((i + 1) mod n)th type
      for all chocolates.
    Return the minimum cost to collect chocolates of all types, given that you
    can perform as many operations as you would like.

    Example 1:
    Input: nums = [20,1,15], x = 5
    Output: 13
    Explanation: - Initially, the chocolate types are [0,1,2]. We will buy the
                   1st type of chocolate at a cost of 1.
                 - Now, we will perform the operation at a cost of 5, and the
                   types of chocolates will become [1,2,0]. We will buy the 2nd
                   type of chocolate at a cost of 1.
                 - Now, we will again perform the operation at a cost of 5, and
                   the chocolate types will become [2,0,1]. We will buy the 0th
                   type of chocolate at a cost of 1.
                 Thus, the total cost will become (1 + 5 + 1 + 5 + 1) = 13. We
                 can prove that this is optimal.

    Example 2:
    Input: nums = [1,2,3], x = 4
    Output: 6
    Explanation: We will collect all three types of chocolates at their own
                 price without performing any operations. Therefore, the total
                 cost is 1 + 2 + 3 = 6.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^9
    * 1 <= x <= 10^9*/

    long long minCost(vector<int>& nums, int x) {
        int n = nums.size();
        vector<long long> ans(n);
        for (int i = 0; i < n; ++i) {
            ans[i] += (long) i*x;
            int prefix = nums[i];
            for (int j = 0; j < n; ++j) {
                prefix = min(prefix, nums[(i-j+n)%n]);
                ans[j] += prefix;
            }
        }
        return *min_element(ans.begin(), ans.end());
    }


    /*2736. Maximum Sum Queries (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2, each of length
    n, and a 1-indexed 2D array queries where queries[i] = [xi, yi]. For the ith
    query, find the maximum value of nums1[j] + nums2[j] among all indices j
    (0 <= j < n), where nums1[j] >= xi and nums2[j] >= yi, or -1 if there is no
    j satisfying the constraints. Return an array answer where answer[i] is the
    answer to the ith query.

    Example 1:
    Input: nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]
    Output: [6,10,7]
    Explanation: - For the 1st query xi = 4 and yi = 1, we can select index
                   j = 0 since nums1[j] >= 4 and nums2[j] >= 1. The sum
                   nums1[j] + nums2[j] is 6, and we can show that 6 is the
                   maximum we can obtain.
                 - For the 2nd query xi = 1 and yi = 3, we can select index
                   j = 2 since nums1[j] >= 1 and nums2[j] >= 3. The sum
                   nums1[j] + nums2[j] is 10, and we can show that 10 is the
                   maximum we can obtain.
                 - For the 3rd query xi = 2 and yi = 5, we can select index
                   j = 3 since nums1[j] >= 2 and nums2[j] >= 5. The sum
                   nums1[j] + nums2[j] is 7, and we can show that 7 is the
                   maximum we can obtain.
                 Therefore, we return [6,10,7].

    Example 2:
    Input: nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]
    Output: [9,9,9]
    Explanation: For this example, we can use index j = 2 for all the queries
                 since it satisfies the constraints for each query.

    Example 3:
    Input: nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]
    Output: [-1]
    Explanation: There is one query in this example with xi = 3 and yi = 3. For
                 every index, j, either nums1[j] < xi or nums2[j] < yi. Hence,
                 there is no solution.

    Constraints:
    * nums1.length == nums2.length
    * n == nums1.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^9
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * xi == queries[i][1]
    * yi == queries[i][2]
    * 1 <= xi, yi <= 10^9*/

    vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {
        int n = nums1.size(), q = queries.size();
        vector<vector<int>> both;
        for (int i = 0; i < n; ++i)
            both.push_back({nums1[i], nums2[i]});
        sort(both.begin(), both.end(), [&](auto& lhs, auto& rhs) { return lhs[0] > rhs[0]; });
        vector<int> ans(q), idx(q);
        iota(idx.begin(), idx.end(), 0);
        sort(idx.begin(), idx.end(), [&](auto& lhs, auto& rhs) { return queries[lhs][0] > queries[rhs][0]; });
        map<int, int> mp;
        int j = 0;
        for (auto& i : idx) {
            int x = queries[i][0], y = queries[i][1];
            for (; j < n && both[j][0] >= x; ++j) {
                int key = both[j][1], val = both[j][0] + both[j][1];
                auto it = mp.lower_bound(key);
                if (it != mp.end() && val <= it->second) continue;
                for (; it != mp.begin() && prev(it)->second <= val;)
                    mp.erase(prev(it));
                mp[key] = val;
            }
            auto it = mp.lower_bound(y);
            if (it == mp.end()) ans[i] = -1;
            else ans[i] = it->second;
        }
        return ans;
    }


    /*2737. Find the Closest Marked Node (Medium)
    You are given a positive integer n which is the number of nodes of a 0-
    indexed directed weighted graph and a 0-indexed 2D array edges where
    edges[i] = [ui, vi, wi] indicates that there is an edge from node ui to node
    vi with weight wi. You are also given a node s and a node array marked; your
    task is to find the minimum distance from s to any of the nodes in marked.
    Return an integer denoting the minimum distance from s to any node in marked
    or -1 if there are no paths from s to any of the marked nodes.

    Example 1:
    Input: n = 4, edges = [[0,1,1],[1,2,3],[2,3,2],[0,3,4]], s = 0, marked = [2,3]
    Output: 4
    Explanation: There is one path from node 0 (the green node) to node 2 (a red
                 node), which is 0->1->2, and has a distance of 1 + 3 = 4. There
                 are two paths from node 0 to node 3 (a red node), which are
                 0->1->2->3 and 0->3, the first one has a distance of
                 1 + 3 + 2 = 6 and the second one has a distance of 4. The
                 minimum of them is 4.

    Example 2:
    Input: n = 5, edges = [[0,1,2],[0,2,4],[1,3,1],[2,3,3],[3,4,2]], s = 1, marked = [0,4]
    Output: 3
    Explanation: There are no paths from node 1 (the green node) to node 0 (a
                 red node). There is one path from node 1 to node 4 (a red
                 node), which is 1->3->4, and has a distance of 1 + 2 = 3. So
                 the answer is 3.

    Example 3:
    Input: n = 4, edges = [[0,1,1],[1,2,3],[2,3,2]], s = 3, marked = [0,1]
    Output: -1
    Explanation: There are no paths from node 3 (the green node) to any of the
                 marked nodes (the red nodes), so the answer is -1.

    Constraints:
    * 2 <= n <= 500
    * 1 <= edges.length <= 10^4
    * edges[i].length = 3
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * 1 <= edges[i][2] <= 10^6
    * 1 <= marked.length <= n - 1
    * 0 <= s, marked[i] <= n - 1
    * s != marked[i]
    * marked[i] != marked[j] for every i != j
    * The graph might have repeated edges.
    * The graph is generated such that it has no self-loops.*/

    int minimumDistance(int n, vector<vector<int>>& edges, int s, vector<int>& marked) {
        vector<vector<pair<int, int>>> graph(n);
        for (auto& e : edges) {
            int u = e[0], v = e[1], w = e[2];
            graph[u].emplace_back(e[1], e[2]);
        }
        unordered_set<int> seen(marked.begin(), marked.end());
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.emplace(0, s);
        vector<int> dist(n, INT_MAX);
        dist[s] = 0;
        while (pq.size()) {
            auto [x, u] = pq.top(); pq.pop();
            if (seen.count(u)) return x;
            for (auto& [v, w] : graph[u])
                if (x + w < dist[v]) {
                    dist[v] = x + w;
                    pq.emplace(x+w, v);
                }
        }
        return -1;
    }


    /*2739. Total Distance Traveled (Easy)
    A truck has two fuel tanks. You are given two integers, mainTank
    representing the fuel present in the main tank in liters and additionalTank
    representing the fuel present in the additional tank in liters. The truck
    has a mileage of 10 km per liter. Whenever 5 liters of fuel get used up in
    the main tank, if the additional tank has at least 1 liters of fuel, 1
    liters of fuel will be transferred from the additional tank to the main
    tank. Return the maximum distance which can be traveled. Note: Injection
    from the additional tank is not continuous. It happens suddenly and
    immediately for every 5 liters consumed.

    Example 1:
    Input: mainTank = 5, additionalTank = 10
    Output: 60
    Explanation: - After spending 5 litre of fuel, fuel remaining is
                   (5 - 5 + 1) = 1 litre and distance traveled is 50km.
                 - After spending another 1 litre of fuel, no fuel gets injected
                   in the main tank and the main tank becomes empty.
                 Total distance traveled is 60km.

    Example 2:
    Input: mainTank = 1, additionalTank = 2
    Output: 10
    Explanation: After spending 1 litre of fuel, the main tank becomes empty.
                 Total distance traveled is 10km.

    Constraints: 1 <= mainTank, additionalTank <= 100*/

    int distanceTraveled(int mainTank, int additionalTank) {
        int ans = 0;
        while (mainTank >= 5) {
            int q = mainTank/5;
            ans += 50*q;
            q = min(q, additionalTank);
            mainTank %= 5;
            mainTank += q;
            additionalTank -= q;
        }
        return ans + 10*mainTank;
    }


    /*2740. Find the Value of the Partition (Medium)
    You are given a positive integer array nums. Partition nums into two arrays,
    nums1 and nums2, such that:
    * Each element of the array nums belongs to either the array nums1 or the
      array nums2.
    * Both arrays are non-empty.
    * The value of the partition is minimized.
    The value of the partition is |max(nums1) - min(nums2)|. Here, max(nums1)
    denotes the maximum element of the array nums1, and min(nums2) denotes the
    minimum element of the array nums2. Return the integer denoting the value of
    such partition.

    Example 1:
    Input: nums = [1,3,2,4]
    Output: 1
    Explanation: We can partition the array nums into nums1 = [1,2] and
                 nums2 = [3,4].
                 - The maximum element of the array nums1 is equal to 2.
                 - The minimum element of the array nums2 is equal to 3.
                 The value of the partition is |2 - 3| = 1. It can be proven
                 that 1 is the minimum value out of all partitions.

    Example 2:
    Input: nums = [100,1,10]
    Output: 9
    Explanation: We can partition the array nums into nums1 = [10] and
                 nums2 = [100,1].
                 - The maximum element of the array nums1 is equal to 10.
                 - The minimum element of the array nums2 is equal to 1.
                 The value of the partition is |10 - 1| = 9. It can be proven
                 that 9 is the minimum value out of all partitions.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int findValueOfPartition(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int ans = INT_MAX;
        for (int i = 0; i < nums.size()-1; ++i)
            ans = min(ans, nums[i+1]-nums[i]);
        return ans;
    }


    /*2741. Special Permutations (Medium)
    You are given a 0-indexed integer array nums containing n distinct positive
    integers. A permutation of nums is called special if:
    * For all indexes 0 <= i < n - 1, either nums[i] % nums[i+1] == 0 or
      nums[i+1] % nums[i] == 0.
    Return the total number of special permutations. As the answer could be
    large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,3,6]
    Output: 2
    Explanation: [3,6,2] and [2,6,3] are the two special permutations of nums.

    Example 2:
    Input: nums = [1,4,3]
    Output: 2
    Explanation: [3,1,4] and [4,1,3] are the two special permutations of nums.

    Constraints:
    * 2 <= nums.length <= 14
    * 1 <= nums[i] <= 10^9*/

    int specialPerm(vector<int>& nums) {
        int mod = 1'000'000'007, n = nums.size();
        int memo[14][1<<14];
        memset(memo, -1, sizeof(memo));

        function<int(int, int)> fn = [&](int i, int m) {
            if (m+1 == 1<<n) return 1;
            if (memo[i][m] == -1) {
                memo[i][m] = 0;
                for (int j = 0; j < n; ++j)
                    if ((m & 1<<j) == 0 && (nums[i]%nums[j] == 0 || nums[j]%nums[i] == 0))
                        memo[i][m] = (memo[i][m] + fn(j, m ^ 1<<j)) % mod;
            }
            return memo[i][m];
        };

        fn(0, 1);

        int ans = 0;
        for (int i = 0; i < n; ++i)
            ans = (ans + fn(i, 1<<i)) % mod;
        return ans;
    }


    /*2742. Painting the Walls (Hard)
    You are given two 0-indexed integer arrays, cost and time, of size n
    representing the costs and the time taken to paint n different walls
    respectively. There are two painters available:
    * A paid painter that paints the ith wall in time[i] units of time and takes
      cost[i] units of money.
    * A free painter that paints any wall in 1 unit of time at a cost of 0. But
      the free painter can only be used if the paid painter is already occupied.
    Return the minimum amount of money required to paint the n walls.

    Example 1:
    Input: cost = [1,2,3,2], time = [1,2,3,2]
    Output: 3
    Explanation: The walls at index 0 and 1 will be painted by the paid painter,
                 and it will take 3 units of time; meanwhile, the free painter
                 will paint the walls at index 2 and 3, free of cost in 2 units
                 of time. Thus, the total cost is 1 + 2 = 3.

    Example 2:
    Input: cost = [2,3,4,2], time = [1,1,1,1]
    Output: 4
    Explanation: The walls at index 0 and 3 will be painted by the paid painter,
                 and it will take 2 units of time; meanwhile, the free painter
                 will paint the walls at index 1 and 2, free of cost in 2 units
                 of time. Thus, the total cost is 2 + 2 = 4.

    Constraints:
    * 1 <= cost.length <= 500
    * cost.length == time.length
    * 1 <= cost[i] <= 10^6
    * 1 <= time[i] <= 500*/

    int paintWalls(vector<int>& cost, vector<int>& time) {
        int n = cost.size();
        vector<vector<int>> dp(n+1, vector<int>(n+1, 5e8));
        for (int i = n-1; i >= 0; --i)
            for (int j = 0; j <= n; ++j) {
                dp[i][j] = dp[i+1][j];
                int cand = cost[i];
                if (j > 1+time[i]) cand += dp[i+1][j-1-time[i]];
                dp[i][j] = min(dp[i][j], cand);
            }
        return dp[0][n];
    }


    /*2743. Count Substrings Without Repeating Character (Medium)
    You are given a string s consisting only of lowercase English letters. We
    call a substring special if it contains no character which has occurred at
    least twice (in other words, it does not contain a repeating character).
    Your task is to count the number of special substrings. For example, in the
    string "pop", the substring "po" is a special substring, however, "pop" is
    not special (since 'p' has occurred twice). Return the number of special
    substrings. A substring is a contiguous sequence of characters within a
    string. For example, "abc" is a substring of "abcd", but "acd" is not.

    Example 1:
    Input: s = "abcd"
    Output: 10
    Explanation: Since each character occurs once, every substring is a special
                 substring. We have 4 substrings of length one, 3 of length two,
                 2 of length three, and 1 substring of length four. So overall
                 there are 4 + 3 + 2 + 1 = 10 special substrings.

    Example 2:
    Input: s = "ooo"
    Output: 3
    Explanation: Any substring with a length of at least two contains a
                 repeating character. So we have to count the number of
                 substrings of length one, which is 3.

    Example 3:
    Input: s = "abab"
    Output: 7
    Explanation: Special substrings are as follows (sorted by their start positions):
                 Special substrings of length 1: "a", "b", "a", "b"
                 Special substrings of length 2: "ab", "ba", "ab"
                 And it can be shown that there are no special substrings with a
                 length of at least three. So the answer would be 4 + 3 = 7.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters*/

    int numberOfSpecialSubstrings(string s) {
        int ans = 0;
        unordered_map<char, int> prev;
        for (int i = 0, ii = -1; i < s.size(); ++i) {
            if (prev.count(s[i])) ii = max(ii, prev[s[i]]);
            ans += i-ii;
            prev[s[i]] = i;
        }
        return ans;
    }


    /*2744. Find Maximum Number of String Pairs (Easy)
    You are given a 0-indexed array words consisting of distinct strings. The
    string words[i] can be paired with the string words[j] if:
    * The string words[i] is equal to the reversed string of words[j].
    * 0 <= i < j < words.length.
    Return the maximum number of pairs that can be formed from the array words.
    Note that each string can belong in at most one pair.

    Example 1:
    Input: words = ["cd","ac","dc","ca","zz"]
    Output: 2
    Explanation: In this example, we can form 2 pair of strings in the following
                 way:
                 - We pair the 0th string with the 2nd string, as the reversed
                   string of word[0] is "dc" and is equal to words[2].
                 - We pair the 1st string with the 3rd string, as the reversed
                   string of word[1] is "ca" and is equal to words[3].
                 It can be proven that 2 is the maximum number of pairs that can
                 be formed.

    Example 2:
    Input: words = ["ab","ba","cc"]
    Output: 1
    Explanation: In this example, we can form 1 pair of strings in the following
                 way:
                 - We pair the 0th string with the 1st string, as the reversed
                   string of words[1] is "ab" and is equal to words[0].
                 It can be proven that 1 is the maximum number of pairs that can
                 be formed.

    Example 3:
    Input: words = ["aa","ab"]
    Output: 0
    Explanation: In this example, we are unable to form any pair of strings.

    Constraints:
    * 1 <= words.length <= 50
    * words[i].length == 2
    * words consists of distinct strings.
    * words[i] contains only lowercase English letters.*/

    int maximumNumberOfStringPairs(vector<string>& words) {
        int ans = 0;
        unordered_set<string> seen;
        for (auto& w : words) {
            string ww = w;
            reverse(w.begin(), w.end());
            if (seen.contains(w)) ++ans;
            seen.insert(ww);
        }
        return ans;
    }


    /*2745. Construct the Longest New String (Medium)
    You are given three integers x, y, and z. You have x strings equal to "AA",
    y strings equal to "BB", and z strings equal to "AB". You want to choose
    some (possibly all or none) of these strings and concatenate them in some
    order to form a new string. This new string must not contain "AAA" or "BBB"
    as a substring. Return the maximum possible length of the new string. A
    substring is a contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: x = 2, y = 5, z = 1
    Output: 12
    Explanation: We can concactenate the strings "BB", "AA", "BB", "AA", "BB",
                 and "AB" in that order. Then, our new string is "BBAABBAABBAB".
                 That string has length 12, and we can show that it is
                 impossible to construct a string of longer length.

    Example 2:
    Input: x = 3, y = 2, z = 2
    Output: 14
    Explanation: We can concactenate the strings "AB", "AB", "AA", "BB", "AA",
                 "BB", and "AA" in that order. Then, our new string is
                 "ABABAABBAABBAA". That string has length 14, and we can show
                 that it is impossible to construct a string of longer length.

    Constraints: 1 <= x, y, z <= 50*/

    int longestString(int x, int y, int z) {
        return 2*(min({x+y, 2*x+1, 2*y+1}) + z);
    }


    /*2746. Decremental String Concatenation (Medium)
    You are given a 0-indexed array words containing n strings. Let's define a
    join operation join(x, y) between two strings x and y as concatenating them
    into xy. However, if the last character of x is equal to the first character
    of y, one of them is deleted. For example join("ab", "ba") = "aba" and
    join("ab", "cde") = "abcde". You are to perform n - 1 join operations. Let
    str0 = words[0]. Starting from i = 1 up to i = n - 1, for the ith operation,
    you can do one of the following:
    * Make stri = join(stri - 1, words[i])
    * Make stri = join(words[i], stri - 1)
    Your task is to minimize the length of strn - 1. Return an integer denoting
    the minimum possible length of strn - 1.

    Example 1:
    Input: words = ["aa","ab","bc"]
    Output: 4
    Explanation: In this example, we can perform join operations in the
                 following order to minimize the length of str2:
                 - str0 = "aa"
                 - str1 = join(str0, "ab") = "aab"
                 - str2 = join(str1, "bc") = "aabc"
                 It can be shown that the minimum possible length of str2 is 4.

    Example 2:
    Input: words = ["ab","b"]
    Output: 2
    Explanation: In this example, str0 = "ab", there are two ways to get str1:
                 join(str0, "b") = "ab" or join("b", str0) = "bab".
                 The first string, "ab", has the minimum length. Hence, the
                 answer is 2.

    Example 3:
    Input: words = ["aaa","c","aba"]
    Output: 6
    Explanation: In this example, we can perform join operations in the
                 following order to minimize the length of str2:
                 - str0 = "aaa"
                 - str1 = join(str0, "c") = "aaac"
                 - str2 = join("aba", str1) = "abaaac"
                 It can be shown that the minimum possible length of str2 is 6.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 50
    * Each character in words[i] is an English lowercase letter*/

    int minimizeConcatenatedLength(vector<string>& words) {
        int n = words.size();
        vector<vector<vector<int>>> memo(n, vector<vector<int>>(26, vector<int>(26, -1)));

        function<int(int, int, int)> fn = [&](int i, int s, int e) {
            if (i == n) return 0;
            if (memo[i][s][e] == -1) {
                string w = words[i];
                int cand1 = fn(i+1, s, w.back()-'a') - (e == w[0] - 'a' ? 1 : 0);
                int cand2 = fn(i+1, w[0]-'a', e) - (w.back() - 'a' == s ? 1 : 0);
                memo[i][s][e] = w.size() + min(cand1, cand2);
            }
            return memo[i][s][e];
        };

        return words[0].size() + fn(1, words[0][0]-'a', words[0].back()-'a');
    }


    /*2747. Count Zero Request Servers (Medium)
    You are given an integer n denoting the total number of servers and a 2D
    0-indexed integer array logs, where logs[i] = [server_id, time] denotes that
    the server with id server_id received a request at time time. You are also
    given an integer x and a 0-indexed integer array queries. Return a 0-indexed
    integer array arr of length queries.length where arr[i] represents the
    number of servers that did not receive any requests during the time interval
    [queries[i] - x, queries[i]]. Note that the time intervals are inclusive.

    Example 1:
    Input: n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]
    Output: [1,2]
    Explanation:  - For queries[0]: The servers with ids 1 and 2 get requests in
                    the duration of [5, 10]. Hence, only server 3 gets zero
                    requests.
                  - For queries[1]: Only the server with id 2 gets a request in
                    duration of [6,11]. Hence, the servers with ids 1 and 3 are
                    the only servers that do not receive any requests during
                    that time period.

    Example 2:
    Input: n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]
    Output: [0,1]
    Explanation: - For queries[0]: All servers get at least one request in the
                   duration of [1, 3].
                 - For queries[1]: Only server with id 3 gets no request in the
                   duration [2,4].

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= logs.length <= 10^5
    * 1 <= queries.length <= 10^5
    * logs[i].length == 2
    * 1 <= logs[i][0] <= n
    * 1 <= logs[i][1] <= 10^6
    * 1 <= x <= 10^5
    * x < queries[i] <= 10^6*/

    vector<int> countServers(int n, vector<vector<int>>& logs, int x, vector<int>& queries) {
        sort(logs.begin(), logs.end(), [&](auto& lhs, auto& rhs) { return lhs[1] < rhs[1]; });
        int sz = queries.size();
        vector<int> ans(sz), idx(sz);
        iota(idx.begin(), idx.end(), 0);
        sort(idx.begin(), idx.end(), [&](auto& lhs, auto& rhs) { return queries[lhs] < queries[rhs]; });
        int j = 0, jj = 0;
        unordered_map<int, int> freq;
        for (auto& i : idx) {
            for (; j < logs.size() && logs[j][1] <= queries[i]; ++j)
                ++freq[logs[j][0]];
            for (; jj < logs.size() && logs[jj][1] < queries[i]-x; ++jj)
                if (--freq[logs[jj][0]] == 0) freq.erase(logs[jj][0]);
            ans[i] = n - freq.size();
        }
        return ans;
    }


    /*2748. Number of Beautiful Pairs (Easy)
    You are given a 0-indexed integer array nums. A pair of indices i, j where
    0 <= i < j < nums.length is called beautiful if the first digit of nums[i]
    and the last digit of nums[j] are coprime. Return the total number of
    beautiful pairs in nums. Two integers x and y are coprime if there is no
    integer greater than 1 that divides both of them. In other words, x and y
    are coprime if gcd(x, y) == 1, where gcd(x, y) is the greatest common
    divisor of x and y.

    Example 1:
    Input: nums = [2,5,1,4]
    Output: 5
    Explanation: There are 5 beautiful pairs in nums:
                 - When i = 0 and j = 1: the first digit of nums[0] is 2, and
                   the last digit of nums[1] is 5. We can confirm that 2 and 5
                   are coprime, since gcd(2,5) == 1.
                 - When i = 0 and j = 2: the first digit of nums[0] is 2, and
                   the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.
                 - When i = 1 and j = 2: the first digit of nums[1] is 5, and
                   the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.
                 - When i = 1 and j = 3: the first digit of nums[1] is 5, and
                   the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.
                 - When i = 2 and j = 3: the first digit of nums[2] is 1, and
                   the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.
                 Thus, we return 5.

    Example 2:
    Input: nums = [11,21,12]
    Output: 2
    Explanation: There are 2 beautiful pairs:
                 - When i = 0 and j = 1: the first digit of nums[0] is 1, and
                   the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.
                 - When i = 0 and j = 2: the first digit of nums[0] is 1, and
                   the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.
                 Thus, we return 2.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 9999
    * nums[i] % 10 != 0*/

    int countBeautifulPairs(vector<int>& nums) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (auto x : nums) {
            for (int y = 0; y < 10; ++y)
                if (gcd(x%10, y) == 1) ans += freq[y];
            for (; x >= 10; x /= 10);
            ++freq[x];
        }
        return ans;
    }


    /*2749. Minimum Operations to Make the Integer Zero (Medium)
    You are given two integers num1 and num2. In one operation, you can choose
    integer i in the range [0, 60] and subtract 2i + num2 from num1. Return the
    integer denoting the minimum number of operations needed to make num1 equal
    to 0. If it is impossible to make num1 equal to 0, return -1.

    Example 1:
    Input: num1 = 3, num2 = -2
    Output: 3
    Explanation: We can make 3 equal to 0 with the following operations:
                 - We choose i = 2 and substract 22 + (-2) from 3,
                   3 - (4 + (-2)) = 1.
                 - We choose i = 2 and substract 22 + (-2) from 1,
                   1 - (4 + (-2)) = -1.
                 - We choose i = 0 and substract 20 + (-2) from -1,
                   (-1) - (1 + (-2)) = 0.
                 It can be proven, that 3 is the minimum number of operations
                 that we need to perform.

    Example 2:
    Input: num1 = 5, num2 = 7
    Output: -1
    Explanation: It can be proven, that it is impossible to make 5 equal to 0
                 with the given operation.

    Constraints:
    * 1 <= num1 <= 10^9
    * -10^9 <= num2 <= 10^9*/

    int makeTheIntegerZero(int num1, int num2) {
        for (long i = 1; true; ++i) {
            long diff = num1 - i*num2;
            if (diff <= 0) break;
            if (__popcount(diff) <= i && i <= diff) return i;
        }
        return -1;
    }


    /*2750. Ways to Split Array Into Good Subarrays (Medium)
    You are given a binary array nums. A subarray of an array is good if it
    contains exactly one element with the value 1. Return an integer denoting
    the number of ways to split the array nums into good subarrays. As the
    number may be too large, return it modulo 10^9 + 7. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [0,1,0,0,1]
    Output: 3
    Explanation: There are 3 ways to split nums into good subarrays:
                 - [0,1] [0,0,1]
                 - [0,1,0] [0,1]
                 - [0,1,0,0] [1]

    Example 2:
    Input: nums = [0,1,0]
    Output: 1
    Explanation: There is 1 way to split nums into good subarrays:
                 - [0,1,0]

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1*/

    int numberOfGoodSubarraySplits(vector<int>& nums) {
        int ans = 0, cnt = 0;
        for (auto& x : nums)
            if (x == 0) ++cnt;
            else {
                if (ans) ans = (long) ans * (cnt+1) % 1'000'000'007;
                else ans = 1;
                cnt = 0;
            }
        return ans;
    }


    /*2751. Robot Collisions (Hard)
    There are n 1-indexed robots, each having a position on a line, health, and
    movement direction. You are given 0-indexed integer arrays positions,
    healths, and a string directions (directions[i] is either 'L' for left or
    'R' for right). All integers in positions are unique. All robots start
    moving on the line simultaneously at the same speed in their given
    directions. If two robots ever share the same position while moving, they
    will collide. If two robots collide, the robot with lower health is removed
    from the line, and the health of the other robot decreases by one. The
    surviving robot continues in the same direction it was going. If both robots
    have the same health, they are both removed from the line. Your task is to
    determine the health of the robots that survive the collisions, in the same
    order that the robots were given, i.e. final heath of robot 1 (if survived),
    final health of robot 2 (if survived), and so on. If there are no survivors,
    return an empty array. Return an array containing the health of the
    remaining robots (in the order they were given in the input), after no
    further collisions can occur. Note: The positions may be unsorted.

    Example 1:
    Input: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = "RRRRR"
    Output: [2,17,9,15,10]
    Explanation: No collision occurs in this example, since all robots are
                 moving in the same direction. So, the health of the robots in
                 order from the first robot is returned, [2, 17, 9, 15, 10].

    Example 2:
    Input: positions = [3,5,2,6], healths = [10,10,15,12], directions = "RLRL"
    Output: [14]
    Explanation: There are 2 collisions in this example. Firstly, robot 1 and
                 robot 2 will collide, and since both have the same health, they
                 will be removed from the line. Next, robot 3 and robot 4 will
                 collide and since robot 4's health is smaller, it gets removed,
                 and robot 3's health becomes 15 - 1 = 14. Only robot 3 remains,
                 so we return [14].

    Example 3:
    Input: positions = [1,2,5,6], healths = [10,10,11,11], directions = "RLRL"
    Output: []
    Explanation: Robot 1 and robot 2 will collide and since both have the same
                 health, they are both removed. Robot 3 and 4 will collide and
                 since both have the same health, they are both removed. So, we
                 return an empty array, [].

    Constraints:
    * 1 <= positions.length == healths.length == directions.length == n <= 10^5
    * 1 <= positions[i], healths[i] <= 10^9
    * directions[i] == 'L' or directions[i] == 'R'
    * All values in positions are distinct*/

    vector<int> survivedRobotsHealths(vector<int>& positions, vector<int>& healths, string directions) {
        int n = positions.size();
        vector<int> ans(n);
        vector<tuple<int, int, char, int>> aug;
        for (int i = 0; i < n; ++i)
            aug.emplace_back(positions[i], healths[i], directions[i], i);
        sort(aug.begin(), aug.end());
        stack<tuple<int, int, int, int>> stk;
        for (auto& [p, h, d, i] : aug)
            if (d == 'R') stk.emplace(p, h, d, i);
            else {
                while (stk.size() && h) {
                    auto [pp, hh, dd, ii] = stk.top(); stk.pop();
                    if (hh < h) --h;
                    else {
                        if (hh > h) stk.emplace(pp, --hh, dd, ii);
                        h = 0;
                    }
                }
                ans[i] = h;
            }
        while (stk.size()) {
            auto [p, h, d, i] = stk.top(); stk.pop();
            ans[i] = h;
        }
        ans.erase(remove(ans.begin(), ans.end(), 0), ans.end());
        return ans;
    }


    /*2764. Is Array a Preorder of Some Binary Tree (Medium）
    Given a 0-indexed integer 2D array nodes, your task is to determine if the
    given array represents the preorder traversal of some binary tree. For each
    index i, nodes[i] = [id, parentId], where id is the id of the node at the
    index i and parentId is the id of its parent in the tree (if the node has no
    parent, then parentId == -1). Return true if the given array represents the
    preorder traversal of some tree, and false otherwise. Note: the preorder
    traversal of a tree is a recursive way to traverse a tree in which we first
    visit the current node, then we do the preorder traversal for the left child,
    and finally, we do it for the right child.

    Example 1:
    Input: nodes = [[0,-1],[1,0],[2,0],[3,2],[4,2]]
    Output: true
    Explanation: The given nodes make the tree in the picture below. We can show
                 that this is the preorder traversal of the tree, first we visit
                 node 0, then we do the preorder traversal of the right child
                 which is [1], then we do the preorder traversal of the left
                 child which is [2,3,4].

    Example 2:
    Input: nodes = [[0,-1],[1,0],[2,0],[3,1],[4,1]]
    Output: false
    Explanation: The given nodes make the tree in the picture below. For the
                 preorder traversal, first we visit node 0, then we do the
                 preorder traversal of the right child which is [1,3,4], but we
                 can see that in the given order, 2 comes between 1 and 3, so,
                 it's not the preorder traversal of the tree.

    Constraints:
    * 1 <= nodes.length <= 10^5
    * nodes[i].length == 2
    * 0 <= nodes[i][0] <= 10^5
    * -1 <= nodes[i][1] <= 10^5
    * The input is generated such that nodes make a binary tree.*/

    bool isPreorder(vector<vector<int>>& nodes) {
        stack<int> stk;
        stk.push(-1);
        for (auto& x : nodes) {
            int n = x[0], p = x[1];
            while (stk.size() && stk.top() != p) stk.pop();
            if (stk.empty()) return false;
            stk.push(n);
        }
        return true;
    }


    /*2769. Find the Maximum Achievable Number (Easy)
    You are given two integers, num and t. An integer x is called achievable if
    it can become equal to num after applying the following operation no more
    than t times:
    * Increase or decrease x by 1, and simultaneously increase or decrease num
      by 1.
    Return the maximum possible achievable number. It can be proven that there
    exists at least one achievable number.

    Example 1:
    Input: num = 4, t = 1
    Output: 6
    Explanation: The maximum achievable number is x = 6; it can become equal to
                 num after performing this operation:
                 * 1- Decrease x by 1, and increase num by 1. Now, x = 5 and
                 num = 5.
                 It can be proven that there is no achievable number larger
                 than 6.

    Example 2:
    Input: num = 3, t = 2
    Output: 7
    Explanation: The maximum achievable number is x = 7; after performing these
                 operations, x will equal num:
                 * 1- Decrease x by 1, and increase num by 1. Now, x = 6 and
                   num = 4.
                 * 2- Decrease x by 1, and increase num by 1. Now, x = 5 and
                   num = 5.
                 It can be proven that there is no achievable number larger
                 than 7.

    Constraints: 1 <= num, t <= 50*/

    int theMaximumAchievableX(int num, int t) {
        return num + 2*t;
    }


    /*2770. Maximum Number of Jumps to Reach the Last Index (Medium)
    You are given a 0-indexed array nums of n integers and an integer target.
    You are initially positioned at index 0. In one step, you can jump from
    index i to any index j such that:
    * 0 <= i < j < n
    * -target <= nums[j] - nums[i] <= target
    Return the maximum number of jumps you can make to reach index n - 1. If
    there is no way to reach index n - 1, return -1.

    Example 1:
    Input: nums = [1,3,6,4,1,2], target = 2
    Output: 3
    Explanation: To go from index 0 to index n - 1 with the maximum number of
                 jumps, you can perform the following jumping sequence:
                 - Jump from index 0 to index 1.
                 - Jump from index 1 to index 3.
                 - Jump from index 3 to index 5.
                 It can be proven that there is no other jumping sequence that
                 goes from 0 to n - 1 with more than 3 jumps. Hence, the answer
                 is 3.

    Example 2:
    Input: nums = [1,3,6,4,1,2], target = 3
    Output: 5
    Explanation: To go from index 0 to index n - 1 with the maximum number of
                 jumps, you can perform the following jumping sequence:
                 - Jump from index 0 to index 1.
                 - Jump from index 1 to index 2.
                 - Jump from index 2 to index 3.
                 - Jump from index 3 to index 4.
                 - Jump from index 4 to index 5.
                 It can be proven that there is no other jumping sequence that
                 goes from 0 to n - 1 with more than 5 jumps. Hence, the answer
                 is 5.

    Example 3:
    Input: nums = [1,3,6,4,1,2], target = 0
    Output: -1
    Explanation: It can be proven that there is no jumping sequence that goes
                 from 0 to n - 1. Hence, the answer is -1.

    Constraints:
    * 2 <= nums.length == n <= 1000
    * -10^9 <= nums[i] <= 10^9
    * 0 <= target <= 2 * 10^9*/

    int maximumJumps(vector<int>& nums, int target) {
        int n = nums.size();
        vector<int> dp(n, -1);
        dp[n-1] = 0;
        for (int i = n-2; i >= 0; --i) {
            for (int j = i+1; j < n; ++j) {
                if (dp[j] != -1 && abs(nums[i] - nums[j]) <= target)
                    dp[i] = max(dp[i], 1 + dp[j]);
            }
        }
        return dp[0];
    }


    /*2771. Longest Non-decreasing Subarray From Two Arrays (Medium)
    You are given two 0-indexed integer arrays nums1 and nums2 of length n.
    Let's define another 0-indexed integer array, nums3, of length n. For each
    index i in the range [0, n - 1], you can assign either nums1[i] or nums2[i]
    to nums3[i]. Your task is to maximize the length of the longest non-
    decreasing subarray in nums3 by choosing its values optimally. Return an
    integer representing the length of the longest non-decreasing subarray in
    nums3. Note: A subarray is a contiguous non-empty sequence of elements
    within an array.

    Example 1:
    Input: nums1 = [2,3,1], nums2 = [1,2,1]
    Output: 2
    Explanation: One way to construct nums3 is:
                 nums3 = [nums1[0], nums2[1], nums2[2]] => [2,2,1].
                 The subarray starting from index 0 and ending at index 1,
                 [2,2], forms a non-decreasing subarray of length 2. We can
                 show that 2 is the maximum achievable length.

    Example 2:
    Input: nums1 = [1,3,2,1], nums2 = [2,2,3,4]
    Output: 4
    Explanation: One way to construct nums3 is:
                 nums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] => [1,2,3,4].
                 The entire array forms a non-decreasing subarray of length 4,
                 making it the maximum achievable length.

    Example 3:
    Input: nums1 = [1,1], nums2 = [2,2]
    Output: 2
    Explanation: One way to construct nums3 is:
                 nums3 = [nums1[0], nums1[1]] => [1,1].
                 The entire array forms a non-decreasing subarray of length 2,
                 making it the maximum achievable length.

    Constraints:
    * 1 <= nums1.length == nums2.length == n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^9*/

    int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {
        int ans = 0, dp1 = 1, dp2 = 1;
        for (int i = 0; i < nums1.size(); ++i) {
            int dp11 = 1, dp12 = 1, dp21 = 1, dp22 = 1;
            if (i && nums1[i-1] <= nums1[i]) dp11 += dp1;
            if (i && nums2[i-1] <= nums1[i]) dp21 += dp2;
            if (i && nums1[i-1] <= nums2[i]) dp12 += dp1;
            if (i && nums2[i-1] <= nums2[i]) dp22 += dp2;
            dp1 = max(dp11, dp21);
            dp2 = max(dp12, dp22);
            ans = max({ans, dp1, dp2});
        }
        return ans;
    }


    /*2772. Apply Operations to Make All Array Elements Equal to Zero (Medium)
    You are given a 0-indexed integer array nums and a positive integer k. You
    can apply the following operation on the array any number of times:
    * Choose any subarray of size k from the array and decrease all its
      elements by 1.
    Return true if you can make all the array elements equal to 0, or false
    otherwise. A subarray is a contiguous non-empty part of an array.

    Example 1:
    Input: nums = [2,2,3,1,1,0], k = 3
    Output: true
    Explanation: We can do the following operations:
                 - Choose the subarray [2,2,3]. The resulting array will be
                   nums = [1,1,2,1,1,0].
                 - Choose the subarray [2,1,1]. The resulting array will be
                   nums = [1,1,1,0,0,0].
                 - Choose the subarray [1,1,1]. The resulting array will be
                   nums = [0,0,0,0,0,0].

    Example 2:
    Input: nums = [1,3,1,1], k = 2
    Output: false
    Explanation: It is not possible to make all the array elements equal to 0.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6*/

    bool checkArray(vector<int>& nums, int k) {
        int prefix = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (prefix > nums[i]) return false;
            int temp = nums[i];
            nums[i] -= prefix;
            prefix = temp;
            if (i >= k-1) prefix -= nums[i-k+1];
        }
        return prefix == 0;
    }


    /*2778. Sum of Squares of Special Elements (Easy)
    You are given a 1-indexed integer array nums of length n. An element nums[i]
    of nums is called special if i divides n, i.e. n % i == 0. Return the sum
    of the squares of all special elements of nums.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 21
    Explanation: There are exactly 3 special elements in nums: nums[1] since 1
                 divides 4, nums[2] since 2 divides 4, and nums[4] since 4
                 divides 4. Hence, the sum of the squares of all special
                 elements of nums is
                 nums[1] * nums[1] + nums[2] * nums[2] + nums[4] * nums[4] =
                 1 * 1 + 2 * 2 + 4 * 4 = 21.

    Example 2:
    Input: nums = [2,7,1,19,18,3]
    Output: 63
    Explanation: There are exactly 4 special elements in nums: nums[1] since 1
                 divides 6, nums[2] since 2 divides 6, nums[3] since 3 divides
                 6, and nums[6] since 6 divides 6. Hence, the sum of the
                 squares of all special elements of nums is
                 nums[1] * nums[1] + nums[2] * nums[2] + nums[3] * nums[3] +
                 nums[6] * nums[6] = 2 * 2 + 7 * 7 + 1 * 1 + 3 * 3 = 63.

    Constraints:
    * 1 <= nums.length == n <= 50
    * 1 <= nums[i] <= 50*/

    int sumOfSquares(vector<int>& nums) {
        int ans = 0;
        for (int i = 0, n = nums.size(); i < n; ++i)
            if (n % (i+1) == 0) ans += nums[i] * nums[i];
        return ans;
    }


    /*2779. Maximum Beauty of an Array After Applying Operation (Medium)
    You are given a 0-indexed array nums and a non-negative integer k. In one
    operation, you can do the following:
    * Choose an index i that hasn't been chosen before from the range
      [0, nums.length - 1].
    * Replace nums[i] with any integer from the range
      [nums[i] - k, nums[i] + k].
    The beauty of the array is the length of the longest subsequence consisting
    of equal elements. Return the maximum possible beauty of the array nums
    after applying the operation any number of times. Note that you can apply
    the operation to each index only once. A subsequence of an array is a new
    array generated from the original array by deleting some elements (possibly
    none) without changing the order of the remaining elements.

    Example 1:
    Input: nums = [4,6,1,2], k = 2
    Output: 3
    Explanation: In this example, we apply the following operations:
                 - Choose index 1, replace it with 4 (from range [4,8]),
                   nums = [4,4,1,2].
                 - Choose index 3, replace it with 4 (from range [0,4]),
                   nums = [4,4,1,4].
                 After the applied operations, the beauty of the array nums is
                 3 (subsequence consisting of indices 0, 1, and 3). It can be
                 proven that 3 is the maximum possible length we can achieve.

    Example 2:
    Input: nums = [1,1,1,1], k = 10
    Output: 4
    Explanation: In this example we don't have to apply any operations. The
                 beauty of the array nums is 4 (whole array).

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i], k <= 10^5*/

    int maximumBeauty(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int i = 0, ii = 0;
        for (; i < nums.size(); ++i)
            if (nums[i] - nums[ii] > 2*k) ++ii;
        return i - ii;
    }


    /*2780. Minimum Index of a Valid Split (Medium)
    An element x of an integer array arr of length m is dominant if
    freq(x) * 2 > m, where freq(x) is the number of occurrences of x in arr.
    Note that this definition implies that arr can have at most one dominant
    element. You are given a 0-indexed integer array nums of length n with one
    dominant element. You can split nums at an index i into two arrays
    nums[0, ..., i] and nums[i + 1, ..., n - 1], but the split is only valid if:
    * 0 <= i < n - 1
    * nums[0, ..., i], and nums[i + 1, ..., n - 1] have the same dominant
      element.
    Here, nums[i, ..., j] denotes the subarray of nums starting at index i and
    ending at index j, both ends being inclusive. Particularly, if j < i then
    nums[i, ..., j] denotes an empty subarray. Return the minimum index of a
    valid split. If no valid split exists, return -1.

    Example 1:
    Input: nums = [1,2,2,2]
    Output: 2
    Explanation: We can split the array at index 2 to obtain arrays [1,2,2] and
                 [2]. In array [1,2,2], element 2 is dominant since it occurs
                 twice in the array and 2 * 2 > 3. In array [2], element 2 is
                 dominant since it occurs once in the array and 1 * 2 > 1. Both
                 [1,2,2] and [2] have the same dominant element as nums, so
                 this is a valid split. It can be shown that index 2 is the
                 minimum index of a valid split.

    Example 2:
    Input: nums = [2,1,3,1,1,1,7,1,2,1]
    Output: 4
    Explanation: We can split the array at index 4 to obtain arrays [2,1,3,1,1]
                 and [1,7,1,2,1]. In array [2,1,3,1,1], element 1 is dominant
                 since it occurs thrice in the array and 3 * 2 > 5. In array
                 [1,7,1,2,1], element 1 is dominant since it occurs thrice in
                 the array and 3 * 2 > 5. Both [2,1,3,1,1] and [1,7,1,2,1] have
                 the same dominant element as nums, so this is a valid split.
                 It can be shown that index 4 is the minimum index of a valid
                 split.

    Example 3:
    Input: nums = [3,3,3,3,7,2,2]
    Output: -1
    Explanation: It can be shown that there is no valid split.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * nums has exactly one dominant element.*/

    int minimumIndex(vector<int>& nums) {
        unordered_map<int, int> freq;
        int k = 0, v = 0;
        for (auto& x : nums)
            if (++freq[x] > v) k = x, v = freq[x];
        for (int i = 0, n = nums.size(), prefix = 0; i < n-1; ++i) {
            if (nums[i] == k) ++prefix;
            if (prefix*2 > i+1 && (v-prefix)*2 > n-i-1) return i;
        }
        return -1;
    }


    /*2781. Length of the Longest Valid Substring (Hard)
    You are given a string word and an array of strings forbidden. A string is
    called valid if none of its substrings are present in forbidden. Return the
    length of the longest valid substring of the string word. A substring is a
    contiguous sequence of characters in a string, possibly empty.

    Example 1:
    Input: word = "cbaaaabc", forbidden = ["aaa","cb"]
    Output: 4
    Explanation: There are 9 valid substrings in word: "c", "b", "a", "ba",
                 "aa", "bc", "baa", "aab", and "aabc". The length of the
                 longest valid substring is 4. It can be shown that all other
                 substrings contain either "aaa" or "cb" as a substring.

    Example 2:
    Input: word = "leetcode", forbidden = ["de","le","e"]
    Output: 4
    Explanation: There are 11 valid substrings in word: "l", "t", "c", "o",
                 "d", "tc", "co", "od", "tco", "cod", and "tcod". The length of
                 the longest valid substring is 4. It can be shown that all
                 other substrings contain either "de", "le", or "e" as a
                 substring.

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists only of lowercase English letters.
    * 1 <= forbidden.length <= 10^5
    * 1 <= forbidden[i].length <= 10
    * forbidden[i] consists only of lowercase English letters.*/

    int longestValidSubstring(string word, vector<string>& forbidden) {
        unordered_set<string> forbid(forbidden.begin(), forbidden.end());
        int ans = 0, val = 0;
        for (int i = word.size()-1; i >= 0; --i) {
            ++val;
            for (int k = 0; k < 10 && k < val; ++k)
                if (forbid.count(word.substr(i, k+1))) {
                    val = k;
                    break;
                }
            ans = max(ans, val);
        }
        return ans;
    }


    /*2782. Number of Unique Categories (Medium)
    You are given an integer n and an object categoryHandler of class
    CategoryHandler. There are n elements, numbered from 0 to n - 1. Each
    element has a category, and your task is to find the number of unique
    categories. The class CategoryHandler contains the following function, which
    may help you:
    * boolean haveSameCategory(integer a, integer b): Returns true if a and b
      are in the same category and false otherwise. Also, if either a or b is
      not a valid number (i.e. it's greater than or equal to nor less than 0),
      it returns false.
    Return the number of unique categories.

    Example 1:
    Input: n = 6, categoryHandler = [1,1,2,2,3,3]
    Output: 3
    Explanation: There are 6 elements in this example. The first two elements
                 belong to category 1, the second two belong to category 2, and
                 the last two elements belong to category 3. So there are 3
                 unique categories.

    Example 2:
    Input: n = 5, categoryHandler = [1,2,3,4,5]
    Output: 5
    Explanation: There are 5 elements in this example. Each element belongs to a
                 unique category. So there are 5 unique categories.

    Example 3:
    Input: n = 3, categoryHandler = [1,1,1]
    Output: 1
    Explanation: There are 3 elements in this example. All of them belong to one
                 category. So there is only 1 unique category.

    Constraints: 1 <= n <= 100*/

    int numberOfCategories(int n, CategoryHandler* categoryHandler) {
        int ans = 0;
        for (int j = 0; j < n; ++j) {
            bool found = false;
            for (int i = 0; i < j; ++i)
                if (categoryHandler->haveSameCategory(i, j)) {
                    found = true;
                    break;
                }
            if (!found) ++ans;
        }
        return ans;
    }


    /*2784. Check if Array is Good (Easy)
    You are given an integer array nums. We consider an array good if it is a
    permutation of an array base[n]. base[n] = [1, 2, ..., n - 1, n, n] (in
    other words, it is an array of length n + 1 which contains 1 to n - 1
    exactly once, plus two occurrences of n). For example, base[1] = [1, 1] and
    base[3] = [1, 2, 3, 3]. Return true if the given array is good, otherwise
    return false. Note: A permutation of integers represents an arrangement of
    these numbers.

    Example 1:
    Input: nums = [2, 1, 3]
    Output: false
    Explanation: Since the maximum element of the array is 3, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 3. However, base[3] has four elements but
                 array nums has three. Therefore, it can not be a permutation
                 of base[3] = [1, 2, 3, 3]. So the answer is false.

    Example 2:
    Input: nums = [1, 3, 3, 2]
    Output: true
    Explanation: Since the maximum element of the array is 3, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 3. It can be seen that nums is a permutation
                 of base[3] = [1, 2, 3, 3] (by swapping the second and fourth
                 elements in nums, we reach base[3]). Therefore, the answer is
                 true.

    Example 3:
    Input: nums = [1, 1]
    Output: true
    Explanation: Since the maximum element of the array is 1, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 1. It can be seen that nums is a permutation
                 of base[1] = [1, 1]. Therefore, the answer is true.

    Example 4:
    Input: nums = [3, 4, 4, 1, 2, 1]
    Output: false
    Explanation: Since the maximum element of the array is 4, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 4. However, base[4] has five elements but
                 array nums has six. Therefore, it can not be a permutation of
                 base[4] = [1, 2, 3, 4, 4]. So the answer is false.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= num[i] <= 200*/

    bool isGood(vector<int>& nums) {
        int n = nums.size()-1, cnt = 0;
        for (int i = 0; i <= n && cnt <= n; )
            if (nums[i] == i+1 || i == n && nums[n] == n) ++i;
            else {
                if (nums[i] < 0 || nums[i] > n) return false;
                int ii = nums[i]-1;
                if (nums[i] == n && nums[n] != n) ii = n;
                swap(nums[i], nums[ii]);
                ++cnt;
            }
        return n && cnt <= n;
    }


    /*2785. Sort Vowels in a String (Medium)
    Given a 0-indexed string s, permute s to get a new string t such that:
    * All consonants remain in their original places. More formally, if there
      is an index i with 0 <= i < s.length such that s[i] is a consonant, then
      t[i] = s[i].
    * The vowels must be sorted in the nondecreasing order of their ASCII
      values. More formally, for pairs of indices i, j with
      0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must
      not have a higher ASCII value than t[j].
    Return the resulting string. The vowels are 'a', 'e', 'i', 'o', and 'u',
    and they can appear in lowercase or uppercase. Consonants comprise all
    letters that are not vowels.

    Example 1:
    Input: s = "lEetcOde"
    Output: "lEOtcede"
    Explanation: 'E', 'O', and 'e' are the vowels in s; 'l', 't', 'c', and 'd'
                 are all consonants. The vowels are sorted according to their
                 ASCII values, and the consonants remain in the same places.

    Example 2:
    Input: s = "lYmpH"
    Output: "lYmpH"
    Explanation: There are no vowels in s (all characters in s are consonants),
                 so we return "lYmpH".

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of letters of the English alphabet in uppercase and
      lowercase.*/

    string sortVowels(string s) {
        string vowels;
        copy_if(begin(s), end(s), back_inserter(vowels), [&](auto& ch) {
            return string("aeiouAEIOU").find(ch) != string::npos;
        });
        sort(begin(vowels), end(vowels));
        int i = 0;
        string ans;
        for (auto& ch : s)
            if (string("aeiouAEIOU").find(ch) != string::npos) ans.push_back(vowels[i++]);
            else ans.push_back(ch);
        return ans;
    }


    /*2786. Visit Array Positions to Maximize Score (Medium)
    You are given a 0-indexed integer array nums and a positive integer x. You
    are initially at position 0 in the array and you can visit other positions
    according to the following rules:
    * If you are currently in position i, then you can move to any position j
      such that i < j.
    * For each position i that you visit, you get a score of nums[i].
    * If you move from a position i to a position j and the parities of nums[i]
      and nums[j] differ, then you lose a score of x.
    Return the maximum total score you can get. Note that initially you have
    nums[0] points.

    Example 1:
    Input: nums = [2,3,6,1,9,2], x = 5
    Output: 13
    Explanation: We can visit the following positions in the array: 0 -> 2 ->
                 3 -> 4. The corresponding values are 2, 6, 1 and 9. Since the
                 integers 6 and 1 have different parities, the move 2 -> 3 will
                 make you lose a score of x = 5. The total score will be:
                 2 + 6 + 1 + 9 - 5 = 13.

    Example 2:
    Input: nums = [2,4,6,8], x = 3
    Output: 20
    Explanation: All the integers in the array have the same parities, so we
                 can visit all of them without losing any score. The total
                 score is: 2 + 4 + 6 + 8 = 20.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i], x <= 10^6*/

    long long maxScore(vector<int>& nums, int x) {
        vector<long long> dp(2, -x);
        for (int i = 0; i < nums.size(); ++i)
            if (i) dp[nums[i]&1] = nums[i] + max(dp[nums[i]&1], dp[nums[i]&1 ^ 1]-x);
            else dp[nums[i]&1] = nums[i];
        return *max_element(dp.begin(), dp.end());
    }


    /*2787. Ways to Express an Integer as Sum of Powers (Medium)
    Given two positive integers n and x. Return the number of ways n can be
    expressed as the sum of the xth power of unique positive integers, in other
    words, the number of sets of unique integers [n1, n2, ..., nk] where
    n = n1^x + n2^x + ... + nk^x. Since the result can be very large, return it
    modulo 10^9 + 7. For example, if n = 160 and x = 3, one way to express n is
    n = 2^3 + 3^3 + 5^3.

    Example 1:
    Input: n = 10, x = 2
    Output: 1
    Explanation: We can express n as the following: n = 32 + 12 = 10. It can be
                 shown that it is the only way to express 10 as the sum of the
                 2nd power of unique integers.

    Example 2:
    Input: n = 4, x = 1
    Output: 2
    Explanation: We can express n in the following ways:
                 - n = 4^1 = 4.
                 - n = 3^1 + 1^1 = 4.

    Constraints:
    * 1 <= n <= 300
    * 1 <= x <= 5*/

    int numberOfWays(int n, int x) {
        vector<long> dp(n+1);
        dp[0] = 1;
        for (int k = 1, v = 1; v <= n; v = pow(++k, x))
            for (int i = n; i >= v; --i)
                dp[i] = (dp[i-v] + dp[i]) % 1'000'000'007;
        return dp[n];
    }


    /*2802. Find The K-th Lucky Number (Medium）
    We know that 4 and 7 are lucky digits. Also, a number is called lucky if it
    contains only lucky digits. You are given an integer k, return the kth lucky
    number represented as a string.

    Example 1:
    Input: k = 4
    Output: "47"
    Explanation: The first lucky number is 4, the second one is 7, the third one
                 is 44 and the fourth one is 47.

    Example 2:
    Input: k = 10
    Output: "477"
    Explanation: Here are lucky numbers sorted in increasing order:
                 4, 7, 44, 47, 74, 77, 444, 447, 474, 477. So the 10th lucky
                 number is 477.

    Example 3:
    Input: k = 1000
    Output: "777747447"
    Explanation: It can be shown that the 1000th lucky number is 777747447.

    Constraints: 1 <= k <= 10^9*/

    string kthLuckyNumber(int k) {
        int n = log2(k+1);
        k -= (1<<n)-1;
        string ans;
        for (int i = n-1; i >= 0; --i)
            if (k & 1<<i) ans.push_back('7');
            else ans.push_back('4');
        return ans;
    }


    /*2806. Account Balance After Rounded Purchase (Easy)
    Initially, you have a bank account balance of 100 dollars. You are given an
    integer purchaseAmount representing the amount you will spend on a purchase
    in dollars. At the store where you will make the purchase, the purchase
    amount is rounded to the nearest multiple of 10. In other words, you pay a
    non-negative amount, roundedAmount, such that roundedAmount is a multiple
    of 10 and abs(roundedAmount - purchaseAmount) is minimized. If there is
    more than one nearest multiple of 10, the largest multiple is chosen.
    Return an integer denoting your account balance after making a purchase
    worth purchaseAmount dollars from the store. Note: 0 is considered to be a
    multiple of 10 in this problem.

    Example 1:
    Input: purchaseAmount = 9
    Output: 90
    Explanation: In this example, the nearest multiple of 10 to 9 is 10. Hence,
                 your account balance becomes 100 - 10 = 90.

    Example 2:
    Input: purchaseAmount = 15
    Output: 80
    Explanation: In this example, there are two nearest multiples of 10 to 15:
                 10 and 20. So, the larger multiple, 20, is chosen. Hence,
                 your account balance becomes 100 - 20 = 80.

    Constraints: 0 <= purchaseAmount <= 100*/

    int accountBalanceAfterPurchase(int purchaseAmount) {
        return 100 - (purchaseAmount+5)/10*10;
    }


    /*2807. Insert Greatest Common Divisors in Linked List (Medium)
    Given the head of a linked list head, in which each node contains an
    integer value. Between every pair of adjacent nodes, insert a new node with
    a value equal to the greatest common divisor of them. Return the linked
    list after insertion. The greatest common divisor of two numbers is the
    largest positive integer that evenly divides both numbers.

    Example 1:
    Input: head = [18,6,10,3]
    Output: [18,6,6,2,10,1,3]
    Explanation: The 1st diagram denotes the initial linked list and the 2nd
                 diagram denotes the linked list after inserting the new nodes
                 (nodes in blue are the inserted nodes).
                 - We insert the greatest common divisor of 18 and 6 = 6
                   between the 1st and the 2nd nodes.
                 - We insert the greatest common divisor of 6 and 10 = 2
                   between the 2nd and the 3rd nodes.
                 - We insert the greatest common divisor of 10 and 3 = 1
                   between the 3rd and the 4th nodes.
                 There are no more adjacent nodes, so we return the linked list.

    Example 2:
    Input: head = [7]
    Output: [7]
    Explanation: The 1st diagram denotes the initial linked list and the 2nd
                 diagram denotes the linked list after inserting the new nodes.
                 There are no pairs of adjacent nodes, so we return the initial
                 linked list.

    Constraints:
    * The number of nodes in the list is in the range [1, 5000].
    * 1 <= Node.val <= 1000*/

    ListNode* insertGreatestCommonDivisors(ListNode* head) {
        ListNode *node = head;
        while (node && node->next) {
            ListNode* temp = new ListNode(gcd(node->val, node->next->val), node->next);
            node->next = temp;
            node = node->next->next;
        }
        return head;
    }


    /*2808. Minimum Seconds to Equalize a Circular Array (Medium)
    You are given a 0-indexed array nums containing n integers. At each second,
    you perform the following operation on the array:
    * For every index i in the range [0, n - 1], replace nums[i] with either
      nums[i], nums[(i - 1 + n) % n], or nums[(i + 1) % n].
    Note that all the elements get replaced simultaneously. Return the minimum
    number of seconds needed to make all elements in the array nums equal.

    Example 1:
    Input: nums = [1,2,1,2]
    Output: 1
    Explanation: We can equalize the array in 1 second in the following way:
                 - At 1st second, replace values at each index with
                   [nums[3],nums[1],nums[3],nums[3]]. After replacement,
                   nums = [2,2,2,2].
                 It can be proven that 1 second is the minimum amount of
                 seconds needed for equalizing the array.

    Example 2:
    Input: nums = [2,1,3,3,2]
    Output: 2
    Explanation: We can equalize the array in 2 seconds in the following way:
                 - At 1st second, replace values at each index with
                   [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement,
                   nums = [2,3,3,3,3].
                 - At 2nd second, replace values at each index with
                   [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement,
                   nums = [3,3,3,3,3].
                 It can be proven that 2 seconds is the minimum amount of
                 seconds needed for equalizing the array.

    Example 3:
    Input: nums = [5,5,5,5]
    Output: 0
    Explanation: We don't need to perform any operations as all elements in the
                 initial array are the same.

    Constraints:
    * 1 <= n == nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int minimumSeconds(vector<int>& nums) {
        int ans = INT_MAX, n = nums.size();
        unordered_map<int, vector<int>> pos;
        for (int i = 0; i < n; ++i) pos[nums[i]].push_back(i);
        for (auto& [k, v] : pos) {
            int cand = 0, prev = -1;
            for (auto& x : v) {
                if (prev >= 0) cand = max(cand, x - prev);
                prev = x;
            }
            cand = max(cand, v[0] + n - v.back());
            ans = min(ans, cand);
        }
        return ans/2;
    }


    /*2809. Minimum Time to Make Array Sum At Most x (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2 of equal length.
    Every second, for all indices 0 <= i < nums1.length, value of nums1[i] is
    incremented by nums2[i]. After this is done, you can do the following
    operation:
    * Choose an index 0 <= i < nums1.length and make nums1[i] = 0.
    You are also given an integer x. Return the minimum time in which you can
    make the sum of all elements of nums1 to be less than or equal to x, or -1
    if this is not possible.

    Example 1:
    Input: nums1 = [1,2,3], nums2 = [1,2,3], x = 4
    Output: 3
    Explanation: For the 1st second, we apply the operation on i = 0. Therefore
                 nums1 = [0,2+2,3+3] = [0,4,6].
                 For the 2nd second, we apply the operation on i = 1. Therefore
                 nums1 = [0+1,0,6+3] = [1,0,9].
                 For the 3rd second, we apply the operation on i = 2. Therefore
                 nums1 = [1+1,0+2,0] = [2,2,0].
                 Now sum of nums1 = 4. It can be shown that these operations
                 are optimal, so we return 3.

    Example 2:
    Input: nums1 = [1,2,3], nums2 = [3,3,3], x = 4
    Output: -1
    Explanation: It can be shown that the sum of nums1 will always be greater
                 than x, no matter which operations are performed.

    Constraints:
    * 1 <= nums1.length <= 10^3
    * 1 <= nums1[i] <= 10^3
    * 0 <= nums2[i] <= 10^3
    * nums1.length == nums2.length
    * 0 <= x <= 10^6*/

    int minimumTime(vector<int>& nums1, vector<int>& nums2, int x) {
        int n = nums1.size(), s1 = accumulate(nums1.begin(), nums1.end(), 0), s2 = accumulate(nums2.begin(), nums2.end(), 0);
        vector<array<int, 2>> aug;
        for (int i = 0; i < n; ++i) aug.push_back({nums1[i], nums2[i]});
        sort(aug.begin(), aug.end(), [&](auto& lhs, auto& rhs) { return lhs[1] < rhs[1]; });
        vector<vector<int>> dp(n+1, vector<int>(n+1));
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + aug[i-1][1]*j + aug[i-1][0]);
        for (int t = 0; t <= n; ++t)
            if (s1 + s2*t - dp[n][t] <= x) return t;
        return -1;
    }


    /*2810. Faulty Keyboard (Easy)
    Your laptop keyboard is faulty, and whenever you type a character 'i' on it,
    it reverses the string that you have written. Typing other characters works
    as expected. You are given a 0-indexed string s, and you type each
    character of s using your faulty keyboard. Return the final string that
    will be present on your laptop screen.

    Example 1:
    Input: s = "string"
    Output: "rtsng"
    Explanation: - After typing first character, the text on the screen is "s".
                 - After the second character, the text is "st".
                 - After the third character, the text is "str".
                 - Since the fourth character is an 'i', the text gets reversed
                 - and becomes "rts".
                 - After the fifth character, the text is "rtsn".
                 - After the sixth character, the text is "rtsng".
                 - Therefore, we return "rtsng".

    Example 2:
    Input: s = "poiinter"
    Output: "ponter"
    Explanation: - After the first character, the text on the screen is "p".
                 - After the second character, the text is "po".
                 - Since the third character you type is an 'i', the text gets
                   reversed and becomes "op".
                 - Since the fourth character you type is an 'i', the text gets
                   reversed and becomes "po".
                 - After the fifth character, the text is "pon".
                 - After the sixth character, the text is "pont".
                 - After the seventh character, the text is "ponte".
                 - After the eighth character, the text is "ponter".
                 - Therefore, we return "ponter".

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters.
    * s[0] != 'i'*/

    string finalString(string s) {
        deque<char> ans;
        bool flip = false;
        for (auto& ch : s) {
            if (ch == 'i') flip = !flip;
            else if (!flip) ans.push_back(ch);
            else ans.push_front(ch);
        }
        if (flip) return string(rbegin(ans), rend(ans));
        return string(begin(ans), end(ans));
    }


    /*2811. Check if it is Possible to Split Array (Medium)
    You are given an array nums of length n and an integer m. You need to
    determine if it is possible to split the array into n non-empty arrays by
    performing a series of steps. In each step, you can select an existing
    array (which may be the result of previous steps) with a length of at least
    two and split it into two subarrays, if, for each resulting subarray, at
    least one of the following holds:
    * The length of the subarray is one, or
    * The sum of elements of the subarray is greater than or equal to m.
    Return true if you can split the given array into n arrays, otherwise
    return false. Note: A subarray is a contiguous non-empty sequence of
    elements within an array.

    Example 1:
    Input: nums = [2, 2, 1], m = 4
    Output: true
    Explanation: We can split the array into [2, 2] and [1] in the first step.
                 Then, in the second step, we can split [2, 2] into [2] and [2].
                 As a result, the answer is true.

    Example 2:
    Input: nums = [2, 1, 3], m = 5
    Output: false
    Explanation: We can try splitting the array in two different ways: the
                 first way is to have [2, 1] and [3], and the second way is to
                 have [2] and [1, 3]. However, both of these ways are not valid.
                 So, the answer is false.

    Example 3:
    Input: nums = [2, 3, 3, 2, 3], m = 6
    Output: true
    Explanation: We can split the array into [2, 3, 3, 2] and [3] in the first
                 step. Then, in the second step, we can split [2, 3, 3, 2] into
                 [2, 3, 3] and [2]. Then, in the third step, we can split
                 [2, 3, 3] into [2] and [3, 3]. And in the last step we can
                 split [3, 3] into [3] and [3]. As a result, the answer is true.

    Constraints:
    * 1 <= n == nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= m <= 200*/

    bool canSplitArray(vector<int>& nums, int m) {
        if (nums.size() <= 2) return true;
        for (int i = 0; i < nums.size()-1; ++i)
            if (nums[i] + nums[i+1] >= m) return true;
        return false;
    }


    /*2812. Find the Safest Path in a Grid (Medium)
    You are given a 0-indexed 2D matrix grid of size n x n, where (r, c)
    represents:
    * A cell containing a thief if grid[r][c] = 1
    * An empty cell if grid[r][c] = 0
    You are initially positioned at cell (0, 0). In one move, you can move to
    any adjacent cell in the grid, including cells containing thieves. The
    safeness factor of a path on the grid is defined as the minimum manhattan
    distance from any cell in the path to any thief in the grid. Return the
    maximum safeness factor of all paths leading to cell (n - 1, n - 1). An
    adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1),
    (r + 1, c) and (r - 1, c) if it exists. The Manhattan distance between two
    cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes
    the absolute value of val.

    Example 1:
    Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
    Output: 0
    Explanation: All paths from (0, 0) to (n - 1, n - 1) go through the thieves
                 in cells (0, 0) and (n - 1, n - 1).

    Example 2:
    Input: grid = [[0,0,1],[0,0,0],[0,0,0]]
    Output: 2
    Explanation: The path depicted in the picture above has a safeness factor
                 of 2 since:
                 - The closest cell of the path to the thief at cell (0, 2) is
                   cell (0, 0). The distance between them is
                   | 0 - 0 | + | 0 - 2 | = 2.
                 It can be shown that there are no other paths with a higher
                 safeness factor.

    Example 3:
    Input: grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
    Output: 2
    Explanation: The path depicted in the picture above has a safeness factor
                 of 2 since:
                 - The closest cell of the path to the thief at cell (0, 3) is
                   cell (1, 2). The distance between them is
                   | 0 - 1 | + | 3 - 2 | = 2.
                 - The closest cell of the path to the thief at cell (3, 0) is
                   cell (3, 2). The distance between them is
                   | 3 - 3 | + | 0 - 2 | = 2.
                 It can be shown that there are no other paths with a higher
                 safeness factor.

    Constraints:
    * 1 <= grid.length == n <= 400
    * grid[i].length == n
    * grid[i][j] is either 0 or 1.
    * There is at least one thief in the grid.*/

    int maximumSafenessFactor(vector<vector<int>>& grid) {
        int n = grid.size(), dir[5] = {-1, 0, 1, 0, -1};
        vector<vector<int>> dist(n, vector<int>(n, -1));
        queue<pair<int, int>> q;
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) {
                    dist[i][j] = 0;
                    q.emplace(i, j);
                }
        for (int v = 1; q.size(); ++v)
            for (int sz = q.size(); sz; --sz) {
                auto [i, j] = q.front(); q.pop();
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < n && 0 <= jj && jj < n && dist[ii][jj] == -1) {
                        dist[ii][jj] = v;
                        q.emplace(ii, jj);
                    }
                }
            }

        auto check = [&](int mid) {
            if (dist[0][0] >= mid) {
                vector<vector<int>> seen(n, vector<int>(n, 0)); seen[0][0] = 1;
                stack<pair<int, int>> stk; stk.emplace(0, 0);
                while (stk.size()) {
                    auto [i, j] = stk.top(); stk.pop();
                    if (i == n-1 && j == n-1) return true;
                    for (int k = 0; k < 4; ++k) {
                        int ii = i + dir[k], jj = j + dir[k+1];
                        if (0 <= ii && ii < n && 0 <= jj && jj < n && seen[ii][jj] == 0 && dist[ii][jj] >= mid) {
                            seen[ii][jj] = 1;
                            stk.emplace(ii, jj);
                        }
                    }
                }
            }
            return false;
        };

        int lo = 0, hi = n;
        while (lo < hi) {
            int mid = lo + (hi - lo + 1)/2;
            if (check(mid)) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*2813. Maximum Elegance of a K-Length Subsequence (Hard)
    You are given a 0-indexed 2D integer array items of length n and an integer
    k. items[i] = [profiti, categoryi], where profiti and categoryi denote the
    profit and category of the ith item respectively. Let's define the elegance
    of a subsequence of items as total_profit + distinct_categories2, where
    total_profit is the sum of all profits in the subsequence, and
    distinct_categories is the number of distinct categories from all the
    categories in the selected subsequence. Your task is to find the maximum
    elegance from all subsequences of size k in items. Return an integer
    denoting the maximum elegance of a subsequence of items with size exactly k.
    Note: A subsequence of an array is a new array generated from the original
    array by deleting some elements (possibly none) without changing the
    remaining elements' relative order.

    Example 1:
    Input: items = [[3,2],[5,1],[10,1]], k = 2
    Output: 17
    Explanation: In this example, we have to select a subsequence of size 2. We
                 can select items[0] = [3,2] and items[2] = [10,1]. The total
                 profit in this subsequence is 3 + 10 = 13, and the subsequence
                 contains 2 distinct categories [2,1]. Hence, the elegance is
                 13 + 22 = 17, and we can show that it is the maximum
                 achievable elegance.

    Example 2:
    Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3
    Output: 19
    Explanation: In this example, we have to select a subsequence of size 3. We
                 can select items[0] = [3,1], items[2] = [2,2], and
                 items[3] = [5,3]. The total profit in this subsequence is
                 3 + 2 + 5 = 10, and the subsequence contains 3 distinct
                 categories [1,2,3]. Hence, the elegance is 10 + 32 = 19, and
                 we can show that it is the maximum achievable elegance.

    Example 3:
    Input: items = [[1,1],[2,1],[3,1]], k = 3
    Output: 7
    Explanation: In this example, we have to select a subsequence of size 3. We
                 should select all the items. The total profit will be
                 1 + 2 + 3 = 6, and the subsequence contains 1 distinct
                 category [1]. Hence, the maximum elegance is 6 + 12 = 7.

    Constraints:
    * 1 <= items.length == n <= 10^5
    * items[i].length == 2
    * items[i][0] == profiti
    * items[i][1] == categoryi
    * 1 <= profiti <= 10^9
    * 1 <= categoryi <= n
    * 1 <= k <= n*/

    long long findMaximumElegance(vector<vector<int>>& items, int k) {
        sort(items.begin(), items.end(), [&](auto& lhs, auto& rhs) { return lhs[0] > rhs[0]; });
        long long ans = 0, cand = 0;
        unordered_set<int> seen;
        stack<int> stk;
        for (int i = 0; i < items.size(); ++i) {
            int p = items[i][0], c = items[i][1];
            if (i <= k-1 || !seen.count(c) && stk.size()) {
                cand += p;
                if (i >= k) cand -= stk.top(), stk.pop();
                if (seen.count(c)) stk.push(p);
                seen.insert(c);
            }
            ans = max(ans, cand + (long long) pow(seen.size(), 2));
        }
        return ans;
    }


    /*2815. Max Pair Sum in an Array (Easy)
    You are given a 0-indexed integer array nums. You have to find the maximum
    sum of a pair of numbers from nums such that the maximum digit in both
    numbers are equal. Return the maximum sum or -1 if no such pair exists.

    Example 1:
    Input: nums = [51,71,17,24,42]
    Output: 88
    Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum
                 digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4,
                 nums[i] and nums[j] have equal maximum digits with a pair sum
                 of 24 + 42 = 66. It can be shown that there are no other pairs
                 with equal maximum digits, so the answer is 88.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: -1
    Explanation: No pair exists in nums with equal maximum digits.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 10^4*/

    int maxSum(vector<int>& nums) {
        int ans = -1;
        vector<int> seen(10);
        for (auto& v : nums) {
            int d = 0;
            for (int x = v; x; d = max(d, x % 10), x /= 10);
            if (seen[d]) ans = max(ans, seen[d] + v);
            seen[d] = max(seen[d], v);
        }
        return ans;
    }


    /*2816. Double a Number Represented as a Linked List (Medium)
    You are given the head of a non-empty linked list representing a non-
    negative integer without leading zeroes. Return the head of the linked list
    after doubling it.

    Example 1:
    Input: head = [1,8,9]
    Output: [3,7,8]
    Explanation: The figure above corresponds to the given linked list which
                 represents the number 189. Hence, the returned linked list
                 represents the number 189 * 2 = 378.

    Example 2:
    Input: head = [9,9,9]
    Output: [1,9,9,8]
    Explanation: The figure above corresponds to the given linked list which
                 represents the number 999. Hence, the returned linked list
                 reprersents the number 999 * 2 = 1998.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^4]
    * 0 <= Node.val <= 9
    * The input is generated such that the list represents a number that does
      not have leading zeros, except the number 0 itself.*/

    ListNode* doubleIt(ListNode* head) {
        if (head->val >= 5) head = new ListNode(0, head);
        for (ListNode* node = head; node; node = node->next) {
            node->val = 2*node->val % 10;
            if (node->next && node->next->val >= 5) ++node->val;
        }
        return head;
    }


    /*2817. Minimum Absolute Difference Between Elements With Constraint (Medium)
    You are given a 0-indexed integer array nums and an integer x. Find the
    minimum absolute difference between two elements in the array that are at
    least x indices apart. In other words, find two indices i and j such that
    abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized. Return an integer
    denoting the minimum absolute difference between two elements that are at
    least x indices apart.

    Example 1:
    Input: nums = [4,3,2,4], x = 2
    Output: 0
    Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2
                 indices apart, and their absolute difference is the minimum, 0.
                 It can be shown that 0 is the optimal answer.

    Example 2:
    Input: nums = [5,3,2,10,15], x = 1
    Output: 1
    Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1
                 index apart, and their absolute difference is the minimum, 1.
                 It can be shown that 1 is the optimal answer.

    Example 3:
    Input: nums = [1,2,3,4], x = 3
    Output: 3
    Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3
                 indices apart, and their absolute difference is the minimum, 3.
                 It can be shown that 3 is the optimal answer.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 0 <= x < nums.length*/

    int minAbsoluteDifference(vector<int>& nums, int x) {
        set<int> vals;
        int ans = INT_MAX;
        for (int i = 0; i < nums.size(); ++i) {
            if (i >= x) {
                vals.insert(nums[i-x]);
                auto it = vals.lower_bound(nums[i]);
                if (it != vals.begin()) ans = min(ans, nums[i] - *prev(it));
                if (it != vals.end()) ans = min(ans, *it - nums[i]);
            }
        }
        return ans;
    }


    /*2818. Apply Operations to Maximize Score (Hard)
    You are given an array nums of n positive integers and an integer k.
    Initially, you start with a score of 1. You have to maximize your score by
    applying the following operation at most k times:
    * Choose any non-empty subarray nums[l, ..., r] that you haven't chosen
      previously.
    * Choose an element x of nums[l, ..., r] with the highest prime score. If
      multiple such elements exist, choose the one with the smallest index.
    * Multiply your score by x.
    Here, nums[l, ..., r] denotes the subarray of nums starting at index l and
    ending at the index r, both ends being inclusive. The prime score of an
    integer x is equal to the number of distinct prime factors of x. For
    example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5. Return
    the maximum possible score after applying at most k operations. Since the
    answer may be large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [8,3,9,3,8], k = 2
    Output: 81
    Explanation: To get a score of 81, we can apply the following operations:
                 - Choose subarray nums[2, ..., 2]. nums[2] is the only element
                   in this subarray. Hence, we multiply the score by nums[2].
                   The score becomes 1 * 9 = 9.
                 - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3]
                   have a prime score of 1, but nums[2] has the smaller index.
                   Hence, we multiply the score by nums[2]. The score becomes
                   9 * 9 = 81.
                 It can be proven that 81 is the highest score one can obtain.

    Example 2:
    Input: nums = [19,12,14,6,10,18], k = 3
    Output: 4788
    Explanation: To get a score of 4788, we can apply the following operations:
                 - Choose subarray nums[0, ..., 0]. nums[0] is the only element
                   in this subarray. Hence, we multiply the score by nums[0].
                   The score becomes 1 * 19 = 19.
                 - Choose subarray nums[5, ..., 5]. nums[5] is the only element
                   in this subarray. Hence, we multiply the score by nums[5].
                   The score becomes 19 * 18 = 342.
                 - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3]
                   have a prime score of 2, but nums[2] has the smaller index.
                   Hence, we multipy the score by nums[2]. The score becomes
                   342 * 14 = 4788.
                 It can be proven that 4788 is the highest score one can obtain.

    Constraints:
    * 1 <= nums.length == n <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= min(n * (n + 1) / 2, 10^9)*/

    int maximumScore(vector<int>& nums, int k) {
        const int MOD = 1'000'000'007;
        vector<pair<int, int>> vals;
        for (int i = 0; i < nums.size(); ++i) {
            int x = nums[i], s = 0;
            for (int p = 2, sx = sqrt(x); p <= sx; ++p) {
                if (x % p == 0) ++s;
                for (; x % p == 0; x /= p);
            }
            if (x > 1) ++s;
            vals.emplace_back(i, s);
        }
        sort(vals.begin(), vals.end(), [&](auto& lhs, auto& rhs) { return lhs.second != rhs.second ? lhs.second > rhs.second : lhs.first < rhs.first; });
        set<int> indices({-1, (int) nums.size()});
        unordered_map<int, int> freq;
        for (auto& [i, _] : vals) {
            auto pt = indices.lower_bound(i);
            int left = i - *prev(pt), right = *pt - i;
            freq[nums[i]] += left * right;
            indices.insert(i);
        }

        auto powmod = [&](long x, int p, int m) {
            long ans = 1;
            for (; p; p >>= 1) {
                if (p & 1) ans = ans * x % m;
                x = x * x % m;
            }
            return ans;
        };

        long ans = 1;
        int prefix = 0;
        vector<pair<int, int>> aug;
        for (auto& [x, v] : freq) aug.emplace_back(x, v);
        sort(aug.begin(), aug.end(), [&](auto& lhs, auto& rhs) { return lhs.first > rhs.first; });
        for (auto& [x, v] : aug)
            if (prefix < k) {
                ans = ans * powmod(x, min(k - prefix, v), MOD) % MOD;
                prefix += v;
            }
        return ans;
    }


    /*2824. Count Pairs Whose Sum is Less than Target (Easy)
    Given a 0-indexed integer array nums of length n and an integer target,
    return the number of pairs (i, j) where 0 <= i < j < n and
    nums[i] + nums[j] < target.

    Example 1:
    Input: nums = [-1,1,2,3,1], target = 2
    Output: 3
    Explanation: There are 3 pairs of indices that satisfy the conditions in the
                 statement:
                 - (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target
                 - (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target
                 - (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target
                 Note that (0, 3) is not counted since nums[0] + nums[3] is not
                 strictly less than the target.

    Example 2:
    Input: nums = [-6,2,5,-2,-7,-1,3], target = -2
    Output: 10
    Explanation: There are 10 pairs of indices that satisfy the conditions in
                 the statement:
                 - (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target
                 - (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target
                 - (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target
                 - (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target
                 - (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target
                 - (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target
                 - (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target
                 - (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target
                 - (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target
                 - (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target

    Constraints:
    * 1 <= nums.length == n <= 50
    * -50 <= nums[i], target <= 50*/

    int countPairs(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int ans = 0;
        for (int lo = 0, hi = nums.size()-1; lo < hi; )
            if (nums[lo] + nums[hi] < target) {
                ans += hi - lo;
                ++lo;
            } else --hi;
        return ans;
    }


    /*2828. Check if a String Is an Acronym of Words (Easy)
    Given an array of strings words and a string s, determine if s is an acronym
    of words. The string s is considered an acronym of words if it can be formed
    by concatenating the first character of each string in words in order. For
    example, "ab" can be formed from ["apple", "banana"], but it can't be formed
    from ["bear", "aardvark"]. Return true if s is an acronym of words, and
    false otherwise.

    Example 1:
    Input: words = ["alice","bob","charlie"], s = "abc"
    Output: true
    Explanation: The first character in the words "alice", "bob", and "charlie"
                 are 'a', 'b', and 'c', respectively. Hence, s = "abc" is the
                 acronym.

    Example 2:
    Input: words = ["an","apple"], s = "a"
    Output: false
    Explanation: The first character in the words "an" and "apple" are 'a' and
                 'a', respectively. The acronym formed by concatenating these
                 characters is "aa". Hence, s = "a" is not the acronym.

    Example 3:
    Input: words = ["never","gonna","give","up","on","you"], s = "ngguoy"
    Output: true
    Explanation: By concatenating the first character of the words in the array,
                 we get the string "ngguoy". Hence, s = "ngguoy" is the acronym.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 10
    * 1 <= s.length <= 100
    * words[i] and s consist of lowercase English letters.*/

    bool isAcronym(vector<string>& words, string s) {
        return words.size() == s.size() && all_of(words.begin(), words.end(), [idx=0, s](string w) mutable {
            return w[0] == s[idx++];
        });
    }


    /*2829. Determine the Minimum Sum of a k-avoiding Array (Medium)
    You are given two integers, n and k. An array of distinct positive integers
    is called a k-avoiding array if there does not exist any pair of distinct
    elements that sum to k. Return the minimum possible sum of a k-avoiding
    array of length n.

    Example 1:
    Input: n = 5, k = 4
    Output: 18
    Explanation: Consider the k-avoiding array [1,2,4,5,6], which has a sum of
                 18. It can be proven that there is no k-avoiding array with a
                 sum less than 18.

    Example 2:
    Input: n = 2, k = 6
    Output: 3
    Explanation: We can construct the array [1,2], which has a sum of 3. It can
                 be proven that there is no k-avoiding array with a sum less
                 than 3.

    Constraints: 1 <= n, k <= 50*/

    int minimumSum(int n, int k) {
        if (n <= k/2) return n*(n+1)/2;
        return pow(k/2, 2) - k/2*(n+k-1) + n*(n+2*k-1)/2;
    }


    /*2830. Maximize the Profit as the Salesman (Medium)
    You are given an integer n representing the number of houses on a number
    line, numbered from 0 to n - 1. Additionally, you are given a 2D integer
    array offers where offers[i] = [starti, endi, goldi], indicating that ith
    buyer wants to buy all the houses from starti to endi for goldi amount of
    gold. As a salesman, your goal is to maximize your earnings by strategically
    selecting and selling houses to buyers. Return the maximum amount of gold
    you can earn. Note that different buyers can't buy the same house, and some
    houses may remain unsold.

    Example 1:
    Input: n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]
    Output: 3
    Explanation: There are 5 houses numbered from 0 to 4 and there are 3
                 purchase offers. We sell houses in the range [0,0] to 1st buyer
                 for 1 gold and houses in the range [1,3] to 3rd buyer for 2
                 golds. It can be proven that 3 is the maximum amount of gold we
                 can achieve.

    Example 2:
    Input: n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]
    Output: 10
    Explanation: There are 5 houses numbered from 0 to 4 and there are 3
                 purchase offers. We sell houses in the range [0,2] to 2nd buyer
                 for 10 golds. It can be proven that 10 is the maximum amount of
                 gold we can achieve.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= offers.length <= 10^5
    * offers[i].length == 3
    * 0 <= starti <= endi <= n - 1
    * 1 <= goldi <= 10^3*/

    int maximizeTheProfit(int n, vector<vector<int>>& offers) {
        vector<vector<pair<int, int>>> mp(n);
        for (auto& offer : offers) {
            int start = offer[0], end = offer[1], gold = offer[2];
            mp[start].emplace_back(end, gold);
        }
        vector<int> dp(n+1);
        for (int i = n-1; i >= 0; --i) {
            dp[i] = dp[i+1];
            for (auto& [j, x] : mp[i])
                dp[i] = max(dp[i], x + dp[j+1]);
        }
        return dp[0];
    }


    /*2831. Find the Longest Equal Subarray (Medium)
    You are given a 0-indexed integer array nums and an integer k. A subarray is
    called equal if all of its elements are equal. Note that the empty subarray
    is an equal subarray. Return the length of the longest possible equal
    subarray after deleting at most k elements from nums. A subarray is a
    contiguous, possibly empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,3,2,3,1,3], k = 3
    Output: 3
    Explanation: It's optimal to delete the elements at index 2 and index 4.
                 After deleting them, nums becomes equal to [1, 3, 3, 3]. The
                 longest equal subarray starts at i = 1 and ends at j = 3 with
                 length equal to 3. It can be proven that no longer equal
                 subarrays can be created.

    Example 2:
    Input: nums = [1,1,2,2,1,1], k = 2
    Output: 4
    Explanation: It's optimal to delete the elements at index 2 and index 3.
                 After deleting them, nums becomes equal to [1, 1, 1, 1]. The
                 array itself is an equal subarray, so the answer is 4. It can
                 be proven that no longer equal subarrays can be created.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= nums.length
    * 0 <= k <= nums.length*/

    int longestEqualSubarray(vector<int>& nums, int k) {
        int most = 0;
        unordered_map<int, int> freq;
        for (int i = 0, ii = 0; i < nums.size(); ++i) {
            most = max(most, ++freq[nums[i]]);
            if (i - ii - most >= k) {
                --freq[nums[ii]];
                ++ii;
            }
        }
        return most;
    }


    /*2832. Maximal Range That Each Element Is Maximum in It (Medium)
    You are given a 0-indexed array nums of distinct integers. Let us define a
    0-indexed array ans of the same length as nums in the following way:
    * ans[i] is the maximum length of a subarray nums[l..r], such that the
      maximum element in that subarray is equal to nums[i].
    Return the array ans. Note that a subarray is a contiguous part of the
    array.

    Example 1:
    Input: nums = [1,5,4,3,6]
    Output: [1,4,2,1,5]
    Explanation: - For nums[0] the longest subarray in which 1 is the maximum is
                   nums[0..0] so ans[0] = 1.
                 - For nums[1] the longest subarray in which 5 is the maximum is
                   nums[0..3] so ans[1] = 4.
                 - For nums[2] the longest subarray in which 4 is the maximum is
                   nums[2..3] so ans[2] = 2.
                 - For nums[3] the longest subarray in which 3 is the maximum is
                   nums[3..3] so ans[3] = 1.
                 - For nums[4] the longest subarray in which 6 is the maximum is
                   nums[0..4] so ans[4] = 5.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: [1,2,3,4,5]
    Explanation: For nums[i] the longest subarray in which it's the maximum is
                 nums[0..i] so ans[i] = i + 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * All elements in nums are distinct.*/

    vector<int> maximumLengthOfRanges(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        stack<int> stk; stk.push(-1);
        nums.push_back(INT_MAX);
        for (int i = 0; i <= n; ++i) {
            while (stk.size() > 1 && nums[stk.top()] < nums[i]) {
                int ii = stk.top(); stk.pop();
                ans[ii] += i-stk.top()-1;
            }
            stk.push(i);
        }
        return ans;
    }


    /*2833. Furthest Point From Origin (Easy)
    You are given a string moves of length n consisting only of characters 'L',
    'R', and '_'. The string represents your movement on a number line starting
    from the origin 0. In the ith move, you can choose one of the following
    directions:
    * move to the left if moves[i] = 'L' or moves[i] = '_'
    * move to the right if moves[i] = 'R' or moves[i] = '_'
    Return the distance from the origin of the furthest point you can get to
    after n moves.

    Example 1:
    Input: moves = "L_RL__R"
    Output: 3
    Explanation: The furthest point we can reach from the origin 0 is point -3
                 through the following sequence of moves "LLRLLLR".

    Example 2:
    Input: moves = "_R__LL_"
    Output: 5
    Explanation: The furthest point we can reach from the origin 0 is point -5
                 through the following sequence of moves "LRLLLLL".

    Example 3:
    Input: moves = "_______"
    Output: 7
    Explanation: The furthest point we can reach from the origin 0 is point 7
                 through the following sequence of moves "RRRRRRR".

    Constraints:
    * 1 <= moves.length == n <= 50
    * moves consists only of characters 'L', 'R' and '_'.*/

    int furthestDistanceFromOrigin(string moves) {
        int L = 0, R = 0;
        for (auto& ch : moves)
            if (ch == 'L') ++L;
            else if (ch == 'R') ++R;
        return moves.size() - L - R + abs(L - R);
    }


    /*2834. Find the Minimum Possible Sum of a Beautiful Array (Medium)
    You are given positive integers n and target. An array nums is beautiful if
    it meets the following conditions:
    * nums.length == n.
    * nums consists of pairwise distinct positive integers.
    * There doesn't exist two distinct indices, i and j, in the range
      [0, n - 1], such that nums[i] + nums[j] == target.
    Return the minimum possible sum that a beautiful array could have.

    Example 1:
    Input: n = 2, target = 3
    Output: 4
    Explanation: We can see that nums = [1,3] is beautiful.
                 - The array nums has length n = 2.
                 - The array nums consists of pairwise distinct positive integers.
                 - There doesn't exist two distinct indices, i and j, with
                   nums[i] + nums[j] == 3.
                 It can be proven that 4 is the minimum possible sum that a
                 beautiful array could have.

    Example 2:
    Input: n = 3, target = 3
    Output: 8
    Explanation: We can see that nums = [1,3,4] is beautiful.
                 - The array nums has length n = 3.
                 - The array nums consists of pairwise distinct positive integers.
                 - There doesn't exist two distinct indices, i and j, with
                   nums[i] + nums[j] == 3.
                 It can be proven that 8 is the minimum possible sum that a
                 beautiful array could have.

    Example 3:
    Input: n = 1, target = 1
    Output: 1
    Explanation: We can see, that nums = [1] is beautiful.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= target <= 10^5*/

    long long minimumPossibleSum(int n, int target) {
        long long m = target/2;
        return n <= m ? (long long) n*(n+1)/2 : m*(m+1)/2 + target*(n-m) + (n-m-1)*(n-m)/2;
    }


    /*2835. Minimum Operations to Form Subsequence With Target Sum (Hard)
    You are given a 0-indexed array nums consisting of non-negative powers of 2,
    and an integer target. In one operation, you must apply the following
    changes to the array:
    * Choose any element of the array nums[i] such that nums[i] > 1.
    * Remove nums[i] from the array.
    * Add two occurrences of nums[i] / 2 to the end of nums.
    Return the minimum number of operations you need to perform so that nums
    contains a subsequence whose elements sum to target. If it is impossible to
    obtain such a subsequence, return -1. A subsequence is an array that can be
    derived from another array by deleting some or no elements without changing
    the order of the remaining elements.

    Example 1:
    Input: nums = [1,2,8], target = 7
    Output: 1
    Explanation: In the first operation, we choose element nums[2]. The array
                 becomes equal to nums = [1,2,4,4]. At this stage, nums
                 contains the subsequence [1,2,4] which sums up to 7. It can be
                 shown that there is no shorter sequence of operations that
                 results in a subsequnce that sums up to 7.

    Example 2:
    Input: nums = [1,32,1,2], target = 12
    Output: 2
    Explanation: In the first operation, we choose element nums[1]. The array
                 becomes equal to nums = [1,1,2,16,16]. In the second operation,
                 we choose element nums[3]. The array becomes equal to
                 nums = [1,1,2,16,8,8]. At this stage, nums contains the
                 subsequence [1,1,2,8] which sums up to 12. It can be shown
                 that there is no shorter sequence of operations that results
                 in a subsequence that sums up to 12.

    Example 3:
    Input: nums = [1,32,1], target = 35
    Output: -1
    Explanation: It can be shown that no sequence of operations results in a
                 subsequence that sums up to 35.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 2^30
    * nums consists only of non-negative powers of two.
    * 1 <= target < 2^31*/

    int minOperations(vector<int>& nums, int target) {
        int ans = 0, ii = -1;
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        for (int i = 0, cnt = 0; i <= 30; ++i) {
            cnt /= 2;
            cnt += freq[1<<i];
            if (target & 1<<i)
                if (cnt) --cnt;
                else if (ii == -1) ii = i;
            if (cnt && ii >= 0) {
                ans += i - ii;
                --cnt;
                ii = -1;
            }
        }
        return ii == -1 ? ans : -1;
    }


    /*2836. Maximize Value of Function in a Ball Passing Game (Hard)
    You are given a 0-indexed integer array receiver of length n and an integer
    k. There are n players having a unique id in the range [0, n - 1] who will
    play a ball passing game, and receiver[i] is the id of the player who
    receives passes from the player with id i. Players can pass to themselves,
    i.e. receiver[i] may be equal to i. You must choose one of the n players as
    the starting player for the game, and the ball will be passed exactly k
    times starting from the chosen player. For a chosen starting player having
    id x, we define a function f(x) that denotes the sum of x and the ids of
    all players who receive the ball during the k passes, including repetitions.
    In other words,
    f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver(k)[x].
    Your task is to choose a starting player having id x that maximizes the
    value of f(x). Return an integer denoting the maximum value of the function.
    Note: receiver may contain duplicates.

    Example 1:
    Pass Number Sender ID   Receiver ID x + Receiver IDs
                2
    1   2   1   3
    2   1   0   3
    3   0   2   5
    4   2   1   6
    Input: receiver = [2,0,1], k = 4
    Output: 6
    Explanation: The table above shows a simulation of the game starting with
                 the player having id x = 2. From the table, f(2) is equal to 6.
                 It can be shown that 6 is the maximum achievable value of the
                 function. Hence, the output is 6.

    Example 2:
    Pass Number Sender ID   Receiver ID x + Receiver IDs
                4
    1   4   3   7
    2   3   2   9
    3   2   1   10
    Input: receiver = [1,1,1,2,3], k = 3
    Output: 10
    Explanation: The table above shows a simulation of the game starting with
                 the player having id x = 4. From the table, f(4) is equal to
                 10. It can be shown that 10 is the maximum achievable value of
                 the function. Hence, the output is 10.

    Constraints:
    * 1 <= receiver.length == n <= 10^5
    * 0 <= receiver[i] <= n - 1
    * 1 <= k <= 10^10*/

    long long getMaxFunctionValue(vector<int>& receiver, long long k) {
        int n = receiver.size(), m = (int) log2(k) + 2;
        vector<vector<int>> lift(n, vector<int>(m, -1));
        vector<vector<long long>> score(n, vector<long long>(m, 0));
        for (int i = 0; i < m; ++i)
            for (int x = 0; x < n; ++x)
                if (i == 0) {
                    lift[x][0] = receiver[x];
                    score[x][0] = x;
                } else if (lift[x][i-1] != -1) {
                    lift[x][i] = lift[lift[x][i-1]][i-1];
                    score[x][i] = score[x][i-1] + score[lift[x][i-1]][i-1];
                }
        long long ans = 0;
        for (int v = 0; v < n; ++v) {
            long long cand = 0;
            for (int i = 0, x = v; i < m; ++i)
                if (k+1 & 1ll<<i) {
                    cand += score[x][i];
                    x = lift[x][i];
                }
            ans = max(ans, cand);
        }
        return ans;
    }


    /*2838. Maximum Coins Heroes Can Collect (Medium)
    There is a battle and n heroes are trying to defeat m monsters. You are
    given two 1-indexed arrays of positive integers heroes and monsters of
    length n and m, respectively. heroes[i] is the power of ith hero, and
    monsters[i] is the power of ith monster. The ith hero can defeat the jth
    monster if monsters[j] <= heroes[i]. You are also given a 1-indexed array
    coins of length m consisting of positive integers. coins[i] is the number of
    coins that each hero earns after defeating the ith monster. Return an array
    ans of length n where ans[i] is the maximum number of coins that the ith
    hero can collect from this battle.

    Notes
    * The health of a hero doesn't get reduced after defeating a monster.
    * Multiple heroes can defeat a monster, but each monster can be defeated by
      a given hero only once.

    Example 1:
    Input: heroes = [1,4,2], monsters = [1,1,5,2,3], coins = [2,3,4,5,6]
    Output: [5,16,10]
    Explanation: For each hero, we list the index of all the monsters he can
                 defeat:
                 - 1st hero: [1,2] since the power of this hero is 1 and
                             monsters[1], monsters[2] <= 1. So this hero
                             collects coins[1] + coins[2] = 5 coins.
                 - 2nd hero: [1,2,4,5] since the power of this hero is 4 and
                             monsters[1], monsters[2], monsters[4], monsters[5]
                             <= 4. So this hero collects
                             coins[1] + coins[2] + coins[4] + coins[5] = 16 coins.
                 - 3rd hero: [1,2,4] since the power of this hero is 2 and
                             monsters[1], monsters[2], monsters[4] <= 2. So this
                             hero collects coins[1] + coins[2] + coins[4] = 10
                             coins.
                 - So the answer would be [5,16,10].

    Example 2:
    Input: heroes = [5], monsters = [2,3,1,2], coins = [10,6,5,2]
    Output: [23]
    Explanation: This hero can defeat all the monsters since monsters[i] <= 5.
                 So he collects all of the coins:
                 coins[1] + coins[2] + coins[3] + coins[4] = 23, and the answer
                 would be [23].

    Example 3:
    Input: heroes = [4,4], monsters = [5,7,8], coins = [1,1,1]
    Output: [0,0]
    Explanation: In this example, no hero can defeat a monster. So the answer
                 would be [0,0],

    Constraints:
    * 1 <= n == heroes.length <= 10^5
    * 1 <= m == monsters.length <= 10^5
    * coins.length == m
    * 1 <= heroes[i], monsters[i], coins[i] <= 10^9*/

    vector<long long> maximumCoins(vector<int>& heroes, vector<int>& monsters, vector<int>& coins) {
        vector<pair<int, int>> mc, hi;
        for (int i = 0; i < monsters.size(); ++i)
            mc.emplace_back(monsters[i], coins[i]);
        sort(mc.begin(), mc.end());
        for (int i = 0; i < heroes.size(); ++i)
            hi.emplace_back(heroes[i], i);
        sort(hi.begin(), hi.end());
        vector<long long> ans(hi.size());
        long long prefix = 0;
        for (int i = 0, j = 0; i < hi.size(); ++i) {
            for (; j < mc.size() && mc[j].first <= hi[i].first; ++j)
                prefix += mc[j].second;
            ans[hi[i].second] = prefix;
        }
        return ans;
    }


    /*2839. Check if Strings Can be Made Equal With Operations I (Easy)
    You are given two strings s1 and s2, both of length 4, consisting of
    lowercase English letters. You can apply the following operation on any of
    the two strings any number of times:
    * Choose any two indices i and j such that j - i = 2, then swap the two
      characters at those indices in the string.
    Return true if you can make the strings s1 and s2 equal, and false
    otherwise.

    Example 1:
    Input: s1 = "abcd", s2 = "cdab"
    Output: true
    Explanation: We can do the following operations on s1:
                 - Choose the indices i = 0, j = 2. The resulting string is
                   s1 = "cbad".
                 - Choose the indices i = 1, j = 3. The resulting string is
                   s1 = "cdab" = s2.

    Example 2:
    Input: s1 = "abcd", s2 = "dacb"
    Output: false
    Explanation: It is not possible to make the two strings equal.

    Constraints:
    * s1.length == s2.length == 4
    * s1 and s2 consist only of lowercase English letters.*/

    bool canBeEqual(string s1, string s2) {
        if (s1[0] != s2[0]) swap(s1[0], s1[2]);
        if (s1[1] != s2[1]) swap(s1[1], s1[3]);
        return s1 == s2;
    }


    /*2840. Check if Strings Can be Made Equal With Operations II (Medium)
    You are given two strings s1 and s2, both of length n, consisting of
    lowercase English letters. You can apply the following operation on any of
    the two strings any number of times:
    * Choose any two indices i and j such that i < j and the difference j - i
      is even, then swap the two characters at those indices in the string.
    Return true if you can make the strings s1 and s2 equal, and false
    otherwise.

    Example 1:
    Input: s1 = "abcdba", s2 = "cabdab"
    Output: true
    Explanation: We can apply the following operations on s1:
                 - Choose the indices i = 0, j = 2. The resulting string is
                   s1 = "cbadba".
                 - Choose the indices i = 2, j = 4. The resulting string is
                   s1 = "cbbdaa".
                 - Choose the indices i = 1, j = 5. The resulting string is
                   s1 = "cabdab" = s2.

    Example 2:
    Input: s1 = "abe", s2 = "bea"
    Output: false
    Explanation: It is not possible to make the two strings equal.

    Constraints:
    * n == s1.length == s2.length
    * 1 <= n <= 10^5
    * s1 and s2 consist only of lowercase English letters.*/

    bool checkStrings(string s1, string s2) {
        vector<int> freq(52);
        for (int i = 0; i < s1.size(); ++i) {
            ++freq[s1[i]-'a' + 26*(i&1)];
            --freq[s2[i]-'a' + 26*(i&1)];
        }
        return all_of(freq.begin(), freq.end(), [&](auto& x){ return x == 0; });
    }


    /*2841. Maximum Sum of Almost Unique Subarray (Medium)
    You are given an integer array nums and two positive integers m and k.
    Return the maximum sum out of all almost unique subarrays of length k of
    nums. If no such subarray exists, return 0. A subarray of nums is almost
    unique if it contains at least m distinct elements. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [2,6,7,3,1,7], m = 3, k = 4
    Output: 18
    Explanation: There are 3 almost unique subarrays of size k = 4. These
                 subarrays are [2, 6, 7, 3], [6, 7, 3, 1], and [7, 3, 1, 7].
                 Among these subarrays, the one with the maximum sum is
                 [2, 6, 7, 3] which has a sum of 18.

    Example 2:
    Input: nums = [5,9,9,2,4,5,4], m = 1, k = 3
    Output: 23
    Explanation: There are 5 almost unique subarrays of size k. These subarrays
                 are [5, 9, 9], [9, 9, 2], [9, 2, 4], [2, 4, 5], and [4, 5, 4].
                 Among these subarrays, the one with the maximum sum is
                 [5, 9, 9] which has a sum of 23.

    Example 3:
    Input: nums = [1,2,1,2,1,2,1], m = 3, k = 3
    Output: 0
    Explanation: There are no subarrays of size k = 3 that contain at least
                 m = 3 distinct elements in the given array [1,2,1,2,1,2,1].
                 Therefore, no almost unique subarrays exist, and the maximum
                 sum is 0.

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= m <= k <= nums.length
    * 1 <= nums[i] <= 10^9*/

    long long maxSum(vector<int>& nums, int m, int k) {
        long long ans = 0, prefix = 0;
        unordered_map<int, int> freq;
        for (int i = 0; i < nums.size(); ++i) {
            prefix += nums[i];
            ++freq[nums[i]];
            if (i >= k) {
                prefix -= nums[i-k];
                if (--freq[nums[i-k]] == 0) freq.erase(nums[i-k]);
            }
            if (i >= k-1 && freq.size() >= m) ans = max(ans, prefix);
        }
        return ans;
    }


    /*2842. Count K-Subsequences of a String With Maximum Beauty (Hard)
    You are given a string s and an integer k. A k-subsequence is a subsequence
    of s, having length k, and all its characters are unique, i.e., every
    character occurs once. Let f(c) denote the number of times the character c
    occurs in s. The beauty of a k-subsequence is the sum of f(c) for every
    character c in the k-subsequence. For example, consider s = "abbbdd" and
    k = 2:
    * f('a') = 1, f('b') = 3, f('d') = 2
    * Some k-subsequences of s are:
      + "abbbdd" -> "ab" having a beauty of f('a') + f('b') = 4
      + "abbbdd" -> "ad" having a beauty of f('a') + f('d') = 3
      + "abbbdd" -> "bd" having a beauty of f('b') + f('d') = 5
    Return an integer denoting the number of k-subsequences whose beauty is the
    maximum among all k-subsequences. Since the answer may be too large, return
    it modulo 10^9 + 7. A subsequence of a string is a new string formed from
    the original string by deleting some (possibly none) of the characters
    without disturbing the relative positions of the remaining characters.

    Notes
    * f(c) is the number of times a character c occurs in s, not a k-subsequence.
    * Two k-subsequences are considered different if one is formed by an index
      that is not present in the other. So, two k-subsequences may form the
      same string.

    Example 1:
    Input: s = "bcca", k = 2
    Output: 4
    Explanation: From s we have f('a') = 1, f('b') = 1, and f('c') = 2.
                 The k-subsequences of s are:
                 bcca having a beauty of f('b') + f('c') = 3
                 bcca having a beauty of f('b') + f('c') = 3
                 bcca having a beauty of f('b') + f('a') = 2
                 bcca having a beauty of f('c') + f('a') = 3
                 bcca having a beauty of f('c') + f('a') = 3
                 There are 4 k-subsequences that have the maximum beauty, 3.
                 Hence, the answer is 4.

    Example 2:
    Input: s = "abbcd", k = 4
    Output: 2
    Explanation: From s we have f('a') = 1, f('b') = 2, f('c') = 1, and f('d') = 1.
                 The k-subsequences of s are:
                 abbcd having a beauty of f('a') + f('b') + f('c') + f('d') = 5
                 abbcd having a beauty of f('a') + f('b') + f('c') + f('d') = 5
                 There are 2 k-subsequences that have the maximum beauty, 5.
                 Hence, the answer is 2.

    Constraints:
    * 1 <= s.length <= 2 * 10^5
    * 1 <= k <= s.length
    * s consists only of lowercase English letters.*/

    int countKSubsequencesWithMaxBeauty(string s, int k) {
        vector<int> freq(26);
        for (char& ch : s) freq[ch - 'a']++;
        nth_element(freq.begin(), freq.end() - k, freq.end());
        if (k > 26 || freq[26 - k] == 0) return 0;
        long long ans = 1, comb = 1;
        int bep = freq[26 - k], mod = 1e9 + 7, n = 0;
        for (int& x : freq)
            if (x > bep) {
                --k;
                ans = ans * x % mod;
            } else if (x == bep) ++n;
        for (int i = 0; i < k; ++i) {
            comb = comb * (n - i) / (i + 1);
            ans = ans * bep % mod;
        }
        return ans * comb % mod;
    }


    /*2843. Count Symmetric Integers (Easy)
    You are given two positive integers low and high. An integer x consisting
    of 2 * n digits is symmetric if the sum of the first n digits of x is equal
    to the sum of the last n digits of x. Numbers with an odd number of digits
    are never symmetric. Return the number of symmetric integers in the range
    [low, high].

    Example 1:
    Input: low = 1, high = 100
    Output: 9
    Explanation: There are 9 symmetric integers between 1 and 100: 11, 22, 33,
                 44, 55, 66, 77, 88, and 99.

    Example 2:
    Input: low = 1200, high = 1230
    Output: 4
    Explanation: There are 4 symmetric integers between 1200 and 1230: 1203,
                 1212, 1221, and 1230.

    Constraints: 1 <= low <= high <= 10^4*/

    int countSymmetricIntegers(int low, int high) {
        int ans = 0;
        for (int x = low; x <= high; ++x) {
            string s = to_string(x);
            if (!(s.size() & 1)) {
                int bal = 0;
                for (int i = 0, n = s.size(); i < n; ++i)
                    if (i < n/2) bal += s[i] - '0';
                    else bal -= s[i] - '0';
                if (bal == 0) ++ans;
            }
        }
        return ans;
    }


    /*2844. Minimum Operations to Make a Special Number (Medium)
    You are given a 0-indexed string num representing a non-negative integer.
    In one operation, you can pick any digit of num and delete it. Note that if
    you delete all the digits of num, num becomes 0. Return the minimum number
    of operations required to make num special. An integer x is considered
    special if it is divisible by 25.

    Example 1:
    Input: num = "2245047"
    Output: 2
    Explanation: Delete digits num[5] and num[6]. The resulting number is
                 "22450" which is special since it is divisible by 25. It can
                 be shown that 2 is the minimum number of operations required
                 to get a special number.

    Example 2:
    Input: num = "2908305"
    Output: 3
    Explanation: Delete digits num[3], num[4], and num[6]. The resulting number
                 is "2900" which is special since it is divisible by 25. It can
                 be shown that 3 is the minimum number of operations required
                 to get a special number.

    Example 3:
    Input: num = "10"
    Output: 1
    Explanation: Delete digit num[0]. The resulting number is "0" which is
                 special since it is divisible by 25. It can be shown that 1 is
                 the minimum number of operations required to get a special
                 number.

    Constraints:
    * 1 <= num.length <= 100
    * num only consists of digits '0' through '9'.
    * num does not contain any leading zeros.*/

    int minimumOperations(string num) {
        int ans = INT_MAX;
        for (auto& p : {"00", "25", "50", "75"}) {
            int cand = 0, k = 1;
            for (auto pt = num.rbegin(); pt != num.rend(); ++pt) {
                if (p[k] == *pt) --k;
                else ++cand;
                if (k == -1) {
                    ans = min(ans, cand);
                    break;
                }
            }
        }
        return ans < INT_MAX ? ans : num.size() - int(num.find('0') != string::npos);
    }


    /*2845. Count of Interesting Subarrays (Medium)
    You are given a 0-indexed integer array nums, an integer modulo, and an
    integer k. Your task is to find the count of subarrays that are interesting.
    A subarray nums[l..r] is interesting if the following condition holds:
    * Let cnt be the number of indices i in the range [l, r] such that
      nums[i] % modulo == k. Then, cnt % modulo == k.
    Return an integer denoting the count of interesting subarrays. Note: A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [3,2,4], modulo = 2, k = 1
    Output: 3
    Explanation: In this example the interesting subarrays are:
                 The subarray nums[0..0] which is [3].
                 - There is only one index, i = 0, in the range [0, 0] that
                   satisfies nums[i] % modulo == k.
                 - Hence, cnt = 1 and cnt % modulo == k.
                 The subarray nums[0..1] which is [3,2].
                 - There is only one index, i = 0, in the range [0, 1] that
                   satisfies nums[i] % modulo == k.
                 - Hence, cnt = 1 and cnt % modulo == k.
                 The subarray nums[0..2] which is [3,2,4].
                 - There is only one index, i = 0, in the range [0, 2] that
                   satisfies nums[i] % modulo == k.
                 - Hence, cnt = 1 and cnt % modulo == k.
                 It can be shown that there are no other interesting subarrays.
                 So, the answer is 3.

    Example 2:
    Input: nums = [3,1,9,6], modulo = 3, k = 0
    Output: 2
    Explanation: In this example the interesting subarrays are:
                 The subarray nums[0..3] which is [3,1,9,6].
                 - There are three indices, i = 0, 2, 3, in the range [0, 3]
                   that satisfy nums[i] % modulo == k.
                 - Hence, cnt = 3 and cnt % modulo == k.
                 The subarray nums[1..1] which is [1].
                 - There is no index, i, in the range [1, 1] that satisfies
                   nums[i] % modulo == k.
                 - Hence, cnt = 0 and cnt % modulo == k.
                 It can be shown that there are no other interesting subarrays.
                 So, the answer is 2.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= modulo <= 10^9
    * 0 <= k < modulo*/

    long long countInterestingSubarrays(vector<int>& nums, int modulo, int k) {
        long long ans = 0;
        unordered_map<int, int> freq;
        freq[0] = 1;
        int prefix = 0;
        for (auto& x : nums) {
            if (x % modulo == k) ++prefix;
            prefix %= modulo;
            ans += freq[(prefix-k+modulo) % modulo];
            ++freq[prefix];
        }
        return ans;
    }


    /*2846. Minimum Edge Weight Equilibrium Queries in a Tree (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui
    and vi with weight wi in the tree. You are also given a 2D integer array
    queries of length m, where queries[i] = [ai, bi]. For each query, find the
    minimum number of operations required to make the weight of every edge on
    the path from ai to bi equal. In one operation, you can choose any edge of
    the tree and change its weight to any value.

    Note that:
    * Queries are independent of each other, meaning that the tree returns to
      its initial state on each new query.
    * The path from ai to bi is a sequence of distinct nodes starting with node
      ai and ending with node bi such that every two adjacent nodes in the
      sequence share an edge in the tree.
    Return an array answer of length m where answer[i] is the answer to the ith
    query.

    Example 1:
    Input: n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]]
    Output: [0,0,1,3]
    Explanation: In the first query, all the edges in the path from 0 to 3 have
                 a weight of 1. Hence, the answer is 0. In the second query,
                 all the edges in the path from 3 to 6 have a weight of 2.
                 Hence, the answer is 0. In the third query, we change the
                 weight of edge [2,3] to 2. After this operation, all the edges
                 in the path from 2 to 6 have a weight of 2. Hence, the answer
                 is 1. In the fourth query, we change the weights of edges
                 [0,1], [1,2] and [2,3] to 2. After these operations, all the
                 edges in the path from 0 to 6 have a weight of 2. Hence, the
                 answer is 3. For each queries[i], it can be shown that
                 answer[i] is the minimum number of operations needed to
                 equalize all the edge weights in the path from ai to bi.

    Example 2:
    Input: n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]]
    Output: [1,2,2,3]
    Explanation: In the first query, we change the weight of edge [1,3] to 6.
                 After this operation, all the edges in the path from 4 to 6
                 have a weight of 6. Hence, the answer is 1. In the second
                 query, we change the weight of edges [0,3] and [3,1] to 6.
                 After these operations, all the edges in the path from 0 to 4
                 have a weight of 6. Hence, the answer is 2. In the third
                 query, we change the weight of edges [1,3] and [5,2] to 6.
                 After these operations, all the edges in the path from 6 to 5
                 have a weight of 6. Hence, the answer is 2. In the fourth
                 query, we change the weights of edges [0,7], [0,3] and [1,3]
                 to 6. After these operations, all the edges in the path from 7
                 to 4 have a weight of 6. Hence, the answer is 3. For each
                 queries[i], it can be shown that answer[i] is the minimum
                 number of operations needed to equalize all the edge weights
                 in the path from ai to bi.

    Constraints:
    * 1 <= n <= 10^4
    * edges.length == n - 1
    * edges[i].length == 3
    * 0 <= ui, vi < n
    * 1 <= wi <= 26
    * The input is generated such that edges represents a valid tree.
    * 1 <= queries.length == m <= 2 * 10^4
    * queries[i].length == 2
    * 0 <= ai, bi < n*/

    vector<int> minOperationsQueries(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {
        vector<vector<pair<int, int>>> tree(n);
        for (auto& edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            tree[u].emplace_back(v, w);
            tree[v].emplace_back(u, w);
        }
        int m = int(log2(n)) + 1;
        vector<vector<int>> lift(n, vector<int>(m, -1)), freq(n, vector<int>(27));
        vector<int> depth(n, -1);
        stack<tuple<int, int, int>> stk; stk.emplace(0, -1, 0);
        while (stk.size()) {
            auto [u, p, d] = stk.top(); stk.pop();
            depth[u] = d;
            for (auto& [v, w] : tree[u]) {
                if (v != p) {
                    lift[v][0] = u;
                    for (int x = 1; x < 27; ++x) freq[v][x] = freq[u][x];
                    ++freq[v][w];
                    for (int j = 1; j < m; ++j) {
                        if (lift[v][j-1] == -1) break;
                        lift[v][j] = lift[lift[v][j-1]][j-1];
                    }
                    stk.emplace(v, u, d+1);
                }
            }
        }
        vector<int> ans;
        for (auto& q : queries) {
            int u = q[0], v = q[1], uu = u, vv = v, k = 0, sm = 0, mx = 0;

            if (depth[u] > depth[v]) swap(u, v);
            for (int i = 0; i < m; ++i)
                if (depth[v]-depth[u] & 1<<i) v = lift[v][i];
            if (u == v) k = u;
            else {
                for (int i = m-1; i >= 0; --i)
                    if (lift[u][i] != lift[v][i]) {
                        u = lift[u][i];
                        v = lift[v][i];
                    }
                k = lift[u][0];
            }
            for (int w = 1; w < 27; ++w) {
                int cand = freq[uu][w] + freq[vv][w] - 2*freq[k][w];
                sm += cand;
                mx = max(mx, cand);
            }
            ans.push_back(sm-mx);
        }
        return ans;
    }


    /*2847. Smallest Number With Given Digit Product (Medium)
    Given a positive integer n, return a string representing the smallest
    positive integer such that the product of its digits is equal to n, or "-1"
    if no such number exists.

    Example 1:
    Input: n = 105
    Output: "357"
    Explanation: 3 * 5 * 7 = 105. It can be shown that 357 is the smallest
                 number with a product of digits equal to 105. So the answer
                 would be "105".

    Example 2:
    Input: n = 7
    Output: "7"
    Explanation: Since 7 has only one digit, its product of digits would be 7.
                 We will show that 7 is the smallest number with a product of
                 digits equal to 7. Since the product of numbers 1 to 6 is 1 to
                 6 respectively, so "7" would be the answer.

    Example 3:
    Input: n = 44
    Output: "-1"
    Explanation: It can be shown that there is no number such that its product
                 of digits is equal to 44. So the answer would be "-1".

    Constraints: 1 <= n <= 10^18*/

    string smallestNumber(long long n) {
        if (n == 1) return "1";
        string ans;
        for (int d = 9; d >= 2; --d)
            for (; n && n % d == 0; n /= d)
                ans.push_back(d+'0');
        if (n > 1) return "-1";
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*2852. Sum of Remoteness of All Cells (Medium)
    You are given a 0-indexed matrix grid of order n * n. Each cell in this
    matrix has a value grid[i][j], which is either a positive integer or -1
    representing a blocked cell. You can move from a non-blocked cell to any
    non-blocked cell that shares an edge. For any cell (i, j), we represent its
    remoteness as R[i][j] which is defined as the following:
    * If the cell (i, j) is a non-blocked cell, R[i][j] is the sum of the values
      grid[x][y] such that there is no path from the non-blocked cell (x, y) to
      the cell (i, j).
    * For blocked cells, R[i][j] == 0.
    Return the sum of R[i][j] over all cells.

    Example 1:
    Input: grid = [[-1,1,-1],[5,-1,4],[-1,3,-1]]
    Output: 39
    Explanation: In the picture above, there are four grids. The top-left grid
                 contains the initial values in the grid. Blocked cells are
                 colored black, and other cells get their values as it is in the
                 input. In the top-right grid, you can see the value of R[i][j]
                 for all cells. So the answer would be the sum of them. That is:
                 0 + 12 + 0 + 8 + 0 + 9 + 0 + 10 + 0 = 39. Let's jump on the
                 bottom-left grid in the above picture and calculate R[0][1]
                 (the target cell is colored green). We should sum up the value
                 of cells that can't be reached by the cell (0, 1). These cells
                 are colored yellow in this grid. So R[0][1] = 5 + 4 + 3 = 12.
                 Now let's jump on the bottom-right grid in the above picture
                 and calculate R[1][2] (the target cell is colored green). We
                 should sum up the value of cells that can't be reached by the
                 cell (1, 2). These cells are colored yellow in this grid. So
                 R[1][2] = 1 + 5 + 3 = 9.

    Example 2:
    Input: grid = [[-1,3,4],[-1,-1,-1],[3,-1,-1]]
    Output: 13
    Explanation: In the picture above, there are four grids. The top-left grid
                 contains the initial values in the grid. Blocked cells are
                 colored black, and other cells get their values as it is in the
                 input. In the top-right grid, you can see the value of R[i][j]
                 for all cells. So the answer would be the sum of them. That is:
                 3 + 3 + 0 + 0 + 0 + 0 + 7 + 0 + 0 = 13. Let's jump on the
                 bottom-left grid in the above picture and calculate R[0][2]
                 (the target cell is colored green). We should sum up the value
                 of cells that can't be reached by the cell (0, 2). This cell is
                 colored yellow in this grid. So R[0][2] = 3. Now let's jump on
                 the bottom-right grid in the above picture and calculate
                 R[2][0] (the target cell is colored green). We should sum up
                 the value of cells that can't be reached by the cell (2, 0).
                 These cells are colored yellow in this grid. So
                 R[2][0] = 3 + 4 = 7.

    Example 3:
    Input: grid = [[1]]
    Output: 0
    Explanation: Since there are no other cells than (0, 0), R[0][0] is equal to
                 0. So the sum of R[i][j] over all cells would be 0.

    Constraints:
    * 1 <= n <= 300
    * 1 <= grid[i][j] <= 10^6 or grid[i][j] == -1*/

    long long sumRemoteness(vector<vector<int>>& grid) {
        int dir[5] = {-1, 0, 1, 0, -1};
        long long ans = 0, value = 0, count = 0;
        for (int r = 0, n = grid.size(); r < n; ++r)
            for (int c = 0; c < n; ++c)
                if (grid[r][c] != -1) {
                    long val = grid[r][c], cnt = 1;
                    grid[r][c] = -1;
                    stack<pair<int, int>> stk; stk.emplace(r, c);
                    while (stk.size()) {
                        auto [i, j] = stk.top(); stk.pop();
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < n && 0 <= jj && jj < n && grid[ii][jj] != -1) {
                                val += grid[ii][jj];
                                ++cnt;
                                grid[ii][jj] = -1;
                                stk.emplace(ii, jj);
                            }
                        }
                    }
                    ans -= val*cnt;
                    value += val;
                    count += cnt;
                }
        return ans + value*count;
    }


    /*2855. Minimum Right Shifts to Sort the Array (Easy)
    You are given a 0-indexed array nums of length n containing distinct
    positive integers. Return the minimum number of right shifts required to
    sort nums and -1 if this is not possible. A right shift is defined as
    shifting the element at index i to index (i + 1) % n, for all indices.

    Example 1:
    Input: nums = [3,4,5,1,2]
    Output: 2
    Explanation: After the first right shift, nums = [2,3,4,5,1]. After the
                 second right shift, nums = [1,2,3,4,5]. Now nums is sorted;
                 therefore the answer is 2.

    Example 2:
    Input: nums = [1,3,5]
    Output: 0
    Explanation: nums is already sorted therefore, the answer is 0.

    Example 3:
    Input: nums = [2,1,4]
    Output: -1
    Explanation: It's impossible to sort the array using right shifts.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * nums contains distinct integers.*/

    int minimumRightShifts(vector<int>& nums) {
        int c = 0, k = 0, n = nums.size();
        for (int i = 0; i < n; ++i)
            if (nums[i] > nums[(i+1)%n]) ++c, k = i;
        switch (c) {
            case 0: return 0;
            case 1: return n-1-k;
        }
        return -1;
    }


    /*2856. Minimum Array Length After Pair Removals (Medium)
    Given an integer array num sorted in non-decreasing order. You can perform
    the following operation any number of times:
    * Choose two indices, i and j, where nums[i] < nums[j].
    * Then, remove the elements at indices i and j from nums. The remaining
      elements retain their original order, and the array is re-indexed.
    Return the minimum length of nums after applying the operation zero or more
    times.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation:

    Example 2:
    Input: nums = [1,1,2,2,3,3]
    Output: 0
    Explanation:

    Example 3:
    Input: nums = [1000000000,1000000000]
    Output: 2
    Explanation: Since both numbers are equal, they cannot be removed.

    Example 4:
    Input: nums = [2,3,4,4,4]
    Output: 1
    Explanation:

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * nums is sorted in non-decreasing order.*/

    int minLengthAfterRemovals(vector<int>& nums) {
        int most = 0, n = nums.size();
        unordered_map<int, int> freq;
        for (auto& x : nums)
            most = max(most, ++freq[x]);
        return 2*most >= n ? 2*most - n : n&1;
    }


    /*2857. Count Pairs of Points With Distance k (Medium)
    You are given a 2D integer array coordinates and an integer k, where
    coordinates[i] = [xi, yi] are the coordinates of the ith point in a 2D
    plane. We define the distance between two points (x1, y1) and (x2, y2) as
    (x1 XOR x2) + (y1 XOR y2) where XOR is the bitwise XOR operation. Return the
    number of pairs (i, j) such that i < j and the distance between points i and
    j is equal to k.

    Example 1:
    Input: coordinates = [[1,2],[4,2],[1,3],[5,2]], k = 5
    Output: 2
    Explanation: We can choose the following pairs:
                 - (0,1): Because we have (1 XOR 4) + (2 XOR 2) = 5.
                 - (2,3): Because we have (1 XOR 5) + (3 XOR 2) = 5.

    Example 2:
    Input: coordinates = [[1,3],[1,3],[1,3],[1,3],[1,3]], k = 0
    Output: 10
    Explanation: Any two chosen pairs will have a distance of 0. There are 10
                 ways to choose two pairs.

    Constraints:
    * 2 <= coordinates.length <= 50000
    * 0 <= xi, yi <= 10^6
    * 0 <= k <= 100*/

    int countPairs(vector<vector<int>>& coordinates, int k) {
        int ans = 0;
        unordered_map<long, int> freq;
        for (auto& coordinate : coordinates) {
            long x = coordinate[0], y = coordinate[1];
            for (int v = 0; v <= k; ++v) {
                long xx = x ^ v, yy = y ^ (k-v);
                ans += freq[1000001*xx + yy];
            }
            ++freq[1000001*x + y];
        }
        return ans;
    }


    /*2858. Minimum Edge Reversals So Every Node Is Reachable (Hard)
    There is a simple directed graph with n nodes labeled from 0 to n - 1. The
    graph would form a tree if its edges were bi-directional. You are given an
    integer n and a 2D integer array edges, where edges[i] = [ui, vi] represents
    a directed edge going from node ui to node vi. An edge reversal changes the
    direction of an edge, i.e., a directed edge going from node ui to node vi
    becomes a directed edge going from node vi to node ui. For every node i in
    the range [0, n - 1], your task is to independently calculate the minimum
    number of edge reversals required so it is possible to reach any other node
    starting from node i through a sequence of directed edges. Return an integer
    array answer, where answer[i] is the minimum number of edge reversals
    required so it is possible to reach any other node starting from node i
    through a sequence of directed edges.

    Example 1:
    Input: n = 4, edges = [[2,0],[2,1],[1,3]]
    Output: [1,1,0,2]
    Explanation: The image above shows the graph formed by the edges.
                 - For node 0: after reversing the edge [2,0], it is possible to
                   reach any other node starting from node 0. So, answer[0] = 1.
                 - For node 1: after reversing the edge [2,1], it is possible to
                   reach any other node starting from node 1. So, answer[1] = 1.
                 - For node 2: it is already possible to reach any other node
                   starting from node 2. So, answer[2] = 0.
                 - For node 3: after reversing the edges [1,3] and [2,1], it is
                   possible to reach any other node starting from node 3. So,
                   answer[3] = 2.

    Example 2:
    Input: n = 3, edges = [[1,2],[2,0]]
    Output: [2,0,1]
    Explanation: The image above shows the graph formed by the edges.
                 - For node 0: after reversing the edges [2,0] and [1,2], it is
                   possible to reach any other node starting from node 0. So,
                   answer[0] = 2.
                 - For node 1: it is already possible to reach any other node
                   starting from node 1. So, answer[1] = 0.
                 - For node 2: after reversing the edge [1, 2], it is possible
                   to reach any other node starting from node 2. So,
                   answer[2] = 1.

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ui == edges[i][0] < n
    * 0 <= vi == edges[i][1] < n
    * ui != vi
    * The input is generated such that if the edges were bi-directional, the
      graph would be a tree.*/

    vector<int> minEdgeReversals(int n, vector<vector<int>>& edges) {
        vector<unordered_map<int, int>> tree(n);
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            tree[u][v] = 1;
            tree[v][u] = -1;
        }
        vector<int> ans(n);

        function<int(int, int)> fn = [&](int u, int p) {
            for (auto& [v, x] : tree[u])
                if (v != p) {
                    ans[u] += fn(v, u);
                    if (x == -1) ++ans[u];
                }
            return ans[u];
        };

        fn(0, -1);
        stack<pair<int, int>> stk; stk.emplace(0, -1);
        while (stk.size()) {
            auto [u, p] = stk.top(); stk.pop();
            for (auto& [v, x] : tree[u])
                if (v != p) {
                    ans[v] += ans[u] - ans[v] + tree[u][v];
                    stk.emplace(v, u);
                }
        }
        return ans;
    }


    /*2859. Sum of Values at Indices With K Set Bits (Easy)
    You are given a 0-indexed integer array nums and an integer k. Return an
    integer that denotes the sum of elements in nums whose corresponding
    indices have exactly k set bits in their binary representation. The set
    bits in an integer are the 1's present when it is written in binary. For
    example, the binary representation of 21 is 10101, which has 3 set bits.

    Example 1:
    Input: nums = [5,10,1,5,2], k = 1
    Output: 13
    Explanation: The binary representation of the indices are:
                 0 = 0002
                 1 = 0012
                 2 = 0102
                 3 = 0112
                 4 = 1002
                 Indices 1, 2, and 4 have k = 1 set bits in their binary
                 representation. Hence, the answer is
                 nums[1] + nums[2] + nums[4] = 13.

    Example 2:
    Input: nums = [4,3,2,1], k = 2
    Output: 1
    Explanation: The binary representation of the indices are:
                 0 = 002
                 1 = 012
                 2 = 102
                 3 = 112
                 Only index 3 has k = 2 set bits in its binary representation.
                 Hence, the answer is nums[3] = 1.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5
    * 0 <= k <= 10*/

    int sumIndicesWithKSetBits(vector<int>& nums, int k) {
        int ans = 0;
        for (int i = 0; i < nums.size(); ++i)
            if (__builtin_popcount(i) == k) ans += nums[i];
        return ans;
    }


    /*2860. Happy Students (Medium)
    You are given a 0-indexed integer array nums of length n where n is the
    total number of students in the class. The class teacher tries to select a
    group of students so that all the students remain happy. The ith student
    will become happy if one of these two conditions is met:
    * The student is selected and the total number of selected students is
      strictly greater than nums[i].
    * The student is not selected and the total number of selected students is
      strictly less than nums[i].
    Return the number of ways to select a group of students so that everyone
    remains happy.

    Example 1:
    Input: nums = [1,1]
    Output: 2
    Explanation: The two possible ways are:
                 1. The class teacher selects no student.
                 2. The class teacher selects both students to form the group.
                 If the class teacher selects just one student to form a group
                 then the both students will not be happy. Therefore, there are
                 only two possible ways.

    Example 2:
    Input: nums = [6,0,3,3,6,7,2,7]
    Output: 3
    Explanation: The three possible ways are:
                 1. The class teacher selects the student with index = 1 to
                    form the group.
                 2. The class teacher selects the students with
                    index = 1, 2, 3, 6 to form the group.
                 The class teacher selects all the students to form the group.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] < nums.length*/

    int countWays(vector<int>& nums) {
        int ans = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0, n = nums.size(); i < n; ++i) {
            if (i == 0 && nums[i]) ++ans;
            if (nums[i] < i+1 && (i+1 == n || i+1 < nums[i+1])) ++ans;
        }
        return ans;
    }


    /*2861. Maximum Number of Alloys (Medium)
    You are the owner of a company that creates alloys using various types of
    metals. There are n different types of metals available, and you have
    access to k machines that can be used to create alloys. Each machine
    requires a specific amount of each metal type to create an alloy. For the
    ith machine to create an alloy, it needs composition[i][j] units of metal
    of type j. Initially, you have stock[i] units of metal type i, and
    purchasing one unit of metal type i costs cost[i] coins. Given integers
    n, k, budget, a 1-indexed 2D array composition, and 1-indexed arrays stock
    and cost, your goal is to maximize the number of alloys the company can
    create while staying within the budget of budget coins. All alloys must be
    created with the same machine. Return the maximum number of alloys that the
    company can create.

    Example 1:
    Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]
    Output: 2
    Explanation: It is optimal to use the 1st machine to create alloys.
                 To create 2 alloys we need to buy the:
                 - 2 units of metal of the 1st type.
                 - 2 units of metal of the 2nd type.
                 - 2 units of metal of the 3rd type.
                 In total, we need 2 * 1 + 2 * 2 + 2 * 3 = 12 coins, which is
                 smaller than or equal to budget = 15. Notice that we have 0
                 units of metal of each type and we have to buy all the
                 required units of metal. It can be proven that we can create
                 at most 2 alloys.

    Example 2:
    Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,100], cost = [1,2,3]
    Output: 5
    Explanation: It is optimal to use the 2nd machine to create alloys.
                 To create 5 alloys we need to buy:
                 - 5 units of metal of the 1st type.
                 - 5 units of metal of the 2nd type.
                 - 0 units of metal of the 3rd type.
                 In total, we need 5 * 1 + 5 * 2 + 0 * 3 = 15 coins, which is
                 smaller than or equal to budget = 15. It can be proven that we
                 can create at most 5 alloys.

    Example 3:
    Input: n = 2, k = 3, budget = 10, composition = [[2,1],[1,2],[1,1]], stock = [1,1], cost = [5,5]
    Output: 2
    Explanation: It is optimal to use the 3rd machine to create alloys.
                 To create 2 alloys we need to buy the:
                 - 1 unit of metal of the 1st type.
                 - 1 unit of metal of the 2nd type.
                 In total, we need 1 * 5 + 1 * 5 = 10 coins, which is smaller
                 than or equal to budget = 10. It can be proven that we can
                 create at most 2 alloys.

    Constraints:
    * 1 <= n, k <= 100
    * 0 <= budget <= 10^8
    * composition.length == k
    * composition[i].length == n
    * 1 <= composition[i][j] <= 100
    * stock.length == cost.length == n
    * 0 <= stock[i] <= 10^8
    * 1 <= cost[i] <= 100*/

    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {
        int ans = 0;
        for (auto& comp : composition) {
            int lo = 0, hi = 2e8;
            while (lo < hi) {
                long mid = lo + (hi-lo+1)/2, spend = 0;
                for (int i = 0; i < n; ++i)
                    spend += cost[i]*max(0l, mid*comp[i] - stock[i]);
                if (spend <= budget) lo = mid;
                else hi = mid-1;
            }
            ans = max(ans, lo);
        }
        return ans;
    }


    /*2862. Maximum Element-Sum of a Complete Subset of Indices (Hard)
    You are given a 1-indexed array nums of n integers. A set of numbers is
    complete if the product of every pair of its elements is a perfect square.
    For a subset of the indices set {1, 2, ..., n} represented as
    {i1, i2, ..., ik}, we define its element-sum as:
    nums[i1] + nums[i2] + ... + nums[ik]. Return the maximum element-sum of a
    complete subset of the indices set {1, 2, ..., n}. A perfect square is a
    number that can be expressed as the product of an integer by itself.

    Example 1:
    Input: nums = [8,7,3,5,7,2,4,9]
    Output: 16
    Explanation: Apart from the subsets consisting of a single index, there are
                 two other complete subsets of indices: {1,4} and {2,8}.
                 - The sum of the elements corresponding to indices 1 and 4 is
                   equal to nums[1] + nums[4] = 8 + 5 = 13.
                 - The sum of the elements corresponding to indices 2 and 8 is
                   equal to nums[2] + nums[8] = 7 + 9 = 16.
                 Hence, the maximum element-sum of a complete subset of indices
                 is 16.

    Example 2:
    Input: nums = [5,10,3,10,1,13,7,9,4]
    Output: 19
    Explanation: Apart from the subsets consisting of a single index, there are
                 four other complete subsets of indices:
                 {1,4}, {1,9}, {2,8}, {4,9}, and {1,4,9}.
                 - The sum of the elements corresponding to indices 1 and 4 is
                   equal to nums[1] + nums[4] = 5 + 10 = 15.
                 - The sum of the elements corresponding to indices 1 and 9 is
                   equal to nums[1] + nums[9] = 5 + 4 = 9.
                 - The sum of the elements corresponding to indices 2 and 8 is
                   equal to nums[2] + nums[8] = 10 + 9 = 19.
                 - The sum of the elements corresponding to indices 4 and 9 is
                   equal to nums[4] + nums[9] = 10 + 4 = 14.
                 - The sum of the elements corresponding to indices 1, 4, and 9
                   is equal to nums[1] + nums[4] + nums[9] = 5 + 10 + 4 = 19.
                 Hence, the maximum element-sum of a complete subset of indices
                 is 19.

    Constraints:
    * 1 <= n == nums.length <= 10^4
    * 1 <= nums[i] <= 10^9*/

    long long maximumSum(vector<int>& nums) {
        long long ans = 0;
        unordered_map<int, long long> mp;
        for (int i = 0; i < nums.size(); ++i) {
            int k = i+1;
            for (int v = 2; v*v <= k; ++v)
                while (k % (v*v) == 0) k /= v*v;
            mp[k] += nums[i];
            ans = max(ans, mp[k]);
        }
        return ans;
    }


    /*2863. Maximum Length of Semi-Decreasing Subarrays (Medium)
    You are given an integer array nums. Return the length of the longest semi-
    decreasing subarray of nums, and 0 if there are no such subarrays. A
    subarray is a contiguous non-empty sequence of elements within an array. A
    non-empty array is semi-decreasing if its first element is strictly greater
    than its last element.

    Example 1:
    Input: nums = [7,6,5,4,3,2,1,6,10,11]
    Output: 8
    Explanation: Take the subarray [7,6,5,4,3,2,1,6]. The first element is 7 and
                 the last one is 6 so the condition is met. Hence, the answer
                 would be the length of the subarray or 8. It can be shown that
                 there aren't any subarrays with the given condition with a
                 length greater than 8.

    Example 2:
    Input: nums = [57,55,50,60,61,58,63,59,64,60,63]
    Output: 6
    Explanation: Take the subarray [61,58,63,59,64,60]. The first element is 61
                 and the last one is 60 so the condition is met. Hence, the
                 answer would be the length of the subarray or 6. It can be
                 shown that there aren't any subarrays with the given condition
                 with a length greater than 6.

    Example 3:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: Since there are no semi-decreasing subarrays in the given
                 array, the answer is 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    int maxSubarrayLength(vector<int>& nums) {
        stack<int> stk;
        for (int i = 0; i < nums.size(); ++i)
            if (stk.empty() || nums[stk.top()] < nums[i])
                stk.emplace(i);
        int ans = 0;
        for (int i = nums.size()-1; i >= 0; --i)
            while (stk.size() && nums[stk.top()] > nums[i]) {
                ans = max(ans, i-stk.top()+1);
                stk.pop();
            }
        return ans;
    }


    /*2864. Maximum Odd Binary Number (Easy)
    You are given a binary string s that contains at least one '1'. You have to
    rearrange the bits in such a way that the resulting binary number is the
    maximum odd binary number that can be created from this combination. Return
    a string representing the maximum odd binary number that can be created
    from the given combination. Note that the resulting string can have leading
    zeros.

    Example 1:
    Input: s = "010"
    Output: "001"
    Explanation: Because there is just one '1', it must be in the last position.
                 So the answer is "001".

    Example 2:
    Input: s = "0101"
    Output: "1001"
    Explanation: One of the '1's must be in the last position. The maximum
                 number that can be made with the remaining digits is "100". So
                 the answer is "1001".

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of '0' and '1'.
    * s contains at least one '1'.*/

    string maximumOddBinaryNumber(string s) {
        int ones = count_if(s.begin(), s.end(), [&](auto& c) { return c == '1';});
        return string(ones-1, '1') + string(s.size()-ones, '0') + '1';
    }


    /*2865. Beautiful Towers I (Medium)
    You are given a 0-indexed array maxHeights of n integers. You are tasked
    with building n towers in the coordinate line. The ith tower is built at
    coordinate i and has a height of heights[i]. A configuration of towers is
    beautiful if the following conditions hold:
    * 1 <= heights[i] <= maxHeights[i]
    * heights is a mountain array.
    Array heights is a mountain if there exists an index i such that:
    * For all 0 < j <= i, heights[j - 1] <= heights[j]
    * For all i <= k < n - 1, heights[k + 1] <= heights[k]
    Return the maximum possible sum of heights of a beautiful configuration of
    towers.

    Example 1:
    Input: maxHeights = [5,3,4,1,1]
    Output: 13
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [5,3,3,1,1]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 0.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 13.

    Example 2:
    Input: maxHeights = [6,5,3,9,2,7]
    Output: 22
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [3,3,3,9,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 3.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 22.

    Example 3:
    Input: maxHeights = [3,2,5,5,2,3]
    Output: 18
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [2,2,5,5,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 2.
                 Note that, for this configuration, i = 3 can also be
                 considered a peak. It can be shown that there exists no other
                 beautiful configuration with a sum of heights greater than 18.

    Constraints:
    * 1 <= n == maxHeights <= 10^3
    * 1 <= maxHeights[i] <= 10^9*/

    long long maximumSumOfHeights(vector<int>& maxHeights) {
        vector<long long> prefix;
        stack<long long> stk; stk.push(-1);
        long long val = 0, n = maxHeights.size();
        for (long long i = 0; i < n; ++i) {
            while (stk.size() > 1 && maxHeights[stk.top()] >= maxHeights[i]) {
                auto ii = stk.top(); stk.pop();
                val -= (ii - stk.top())*maxHeights[ii];
            }
            val += (i - stk.top())*maxHeights[i];
            prefix.push_back(val);
            stk.push(i);
        }
        long long ans = 0;
        val = 0;
        stack<long long>().swap(stk); stk.push(n);
        for (long long i = n-1; i >= 0; --i) {
            while (stk.size() > 1 && maxHeights[stk.top()] >= maxHeights[i]) {
                auto ii = stk.top(); stk.pop();
                val -= (stk.top() - ii)*maxHeights[ii];
            }
            val += (stk.top() - i)*maxHeights[i];
            stk.push(i);
            ans = max(ans, prefix[i] + val - maxHeights[i]);
        }
        return ans;
    }


    /*2866. Beautiful Towers II (Medium)
    You are given a 0-indexed array maxHeights of n integers. You are tasked
    with building n towers in the coordinate line. The ith tower is built at
    coordinate i and has a height of heights[i]. A configuration of towers is
    beautiful if the following conditions hold:
    * 1 <= heights[i] <= maxHeights[i]
    * heights is a mountain array.
    Array heights is a mountain if there exists an index i such that:
    * For all 0 < j <= i, heights[j - 1] <= heights[j]
    * For all i <= k < n - 1, heights[k + 1] <= heights[k]
    Return the maximum possible sum of heights of a beautiful configuration of
    towers.

    Example 1:
    Input: maxHeights = [5,3,4,1,1]
    Output: 13
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [5,3,3,1,1]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 0.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 13.

    Example 2:
    Input: maxHeights = [6,5,3,9,2,7]
    Output: 22
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [3,3,3,9,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 3.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 22.

    Example 3:
    Input: maxHeights = [3,2,5,5,2,3]
    Output: 18
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [2,2,5,5,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 2.
                 Note that, for this configuration, i = 3 can also be
                 considered a peak. It can be shown that there exists no other
                 beautiful configuration with a sum of heights greater than 18.

    Constraints:
    * 1 <= n == maxHeights <= 10^5
    * 1 <= maxHeights[i] <= 10^9*/

    long long maximumSumOfHeights(vector<int>& maxHeights) {
        vector<long long> prefix;
        stack<long long> stk; stk.push(-1);
        long long val = 0, n = maxHeights.size();
        for (long long i = 0; i < n; ++i) {
            while (stk.size() > 1 && maxHeights[stk.top()] >= maxHeights[i]) {
                auto ii = stk.top(); stk.pop();
                val -= (ii - stk.top())*maxHeights[ii];
            }
            val += (i - stk.top())*maxHeights[i];
            prefix.push_back(val);
            stk.push(i);
        }
        long long ans = 0;
        val = 0;
        stack<long long>().swap(stk); stk.push(n);
        for (long long i = n-1; i >= 0; --i) {
            while (stk.size() > 1 && maxHeights[stk.top()] >= maxHeights[i]) {
                auto ii = stk.top(); stk.pop();
                val -= (stk.top() - ii)*maxHeights[ii];
            }
            val += (stk.top() - i)*maxHeights[i];
            stk.push(i);
            ans = max(ans, prefix[i] + val - maxHeights[i]);
        }
        return ans;
    }


    /*2867. Count Valid Paths in a Tree (Hard)
    There is an undirected tree with n nodes labeled from 1 to n. You are given
    the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi
    in the tree. Return the number of valid paths in the tree. A path (a, b) is
    valid if there exists exactly one prime number among the node labels in the
    path from a to b.

    Note that:
    * The path (a, b) is a sequence of distinct nodes starting with node a and
      ending with node b such that every two adjacent nodes in the sequence
      share an edge in the tree.
    * Path (a, b) and path (b, a) are considered the same and counted only once.

    Example 1:
    Input: n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]
    Output: 4
    Explanation: The pairs with exactly one prime number on the path between
                 them are:
                 - (1, 2) since the path from 1 to 2 contains prime number 2.
                 - (1, 3) since the path from 1 to 3 contains prime number 3.
                 - (1, 4) since the path from 1 to 4 contains prime number 2.
                 - (2, 4) since the path from 2 to 4 contains prime number 2.
                 It can be shown that there are only 4 valid paths.

    Example 2:
    Input: n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]
    Output: 6
    Explanation: The pairs with exactly one prime number on the path between
                 them are:
                 - (1, 2) since the path from 1 to 2 contains prime number 2.
                 - (1, 3) since the path from 1 to 3 contains prime number 3.
                 - (1, 4) since the path from 1 to 4 contains prime number 2.
                 - (1, 6) since the path from 1 to 6 contains prime number 3.
                 - (2, 4) since the path from 2 to 4 contains prime number 2.
                 - (3, 6) since the path from 3 to 6 contains prime number 3.
                 It can be shown that there are only 6 valid paths.

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 1 <= ui, vi <= n
    * The input is generated such that edges represent a valid tree.*/

    long long countPaths(int n, vector<vector<int>>& edges) {
        vector<bool> prime(n+1, true);
        prime[0] = prime[1] = false;
        for (int x = 2; x <= sqrt(n); ++x)
            if (prime[x])
                for (int xx = x*x; xx <= n; xx += x)
                    prime[xx] = false;
        vector<vector<int>> tree(n+1);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        vector<int> mp(n+1);
        iota(mp.begin(), mp.end(), 0);
        for (int x = 1; x <= n; ++x)
            if (!prime[x] && mp[x] == x) {
                stack<pair<int, int>> stk; stk.emplace(x, -1);
                while (stk.size()) {
                    auto [u, p] = stk.top(); stk.pop();
                    for (auto& v : tree[u])
                        if (v != p && !prime[v]) {
                            mp[v] = x;
                            stk.emplace(v, u);
                        }
                }
            }
        unordered_map<int, int> freq;
        for (auto& x : mp) ++freq[x];
        long long ans = 0;
        for (int u = 2; u <= n; ++u)
            if (prime[u]) {
                long long cand = 0, prefix = 1;
                for (auto& v : tree[u])
                    if (!prime[v]) {
                        cand += prefix * freq[mp[v]];
                        prefix += freq[mp[v]];
                    }
                ans += cand;
            }
        return ans;
    }


    /*2869. Minimum Operations to Collect Elements (Easy)
    You are given an array nums of positive integers and an integer k. In one
    operation, you can remove the last element of the array and add it to your
    collection. Return the minimum number of operations needed to collect
    elements 1, 2, ..., k.

    Example 1:
    Input: nums = [3,1,5,4,2], k = 2
    Output: 4
    Explanation: After 4 operations, we collect elements 2, 4, 5, and 1, in
                 this order. Our collection contains elements 1 and 2. Hence,
                 the answer is 4.

    Example 2:
    Input: nums = [3,1,5,4,2], k = 5
    Output: 5
    Explanation: After 5 operations, we collect elements 2, 4, 5, 1, and 3, in
                 this order. Our collection contains elements 1 through 5.
                 Hence, the answer is 5.

    Example 3:
    Input: nums = [3,2,5,3,1], k = 3
    Output: 4
    Explanation: After 4 operations, we collect elements 1, 3, 5, and 2, in
                 this order. Our collection contains elements 1 through 3.
                 Hence, the answer is 4.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= nums.length
    * 1 <= k <= nums.length
    * The input is generated such that you can collect elements 1, 2, ..., k.*/

    int minOperations(vector<int>& nums, int k) {
        long left = (1l<<k) - 1;
        for (int n = nums.size(), i = n-1; i >= 0; --i) {
            if (nums[i] <= k && left & 1l<<nums[i]-1) left ^= 1l<<nums[i]-1;
            if (left == 0) return n-i;
        }
        return -1;
    }


    /*2870. Minimum Number of Operations to Make Array Empty (Medium)
    You are given a 0-indexed array nums consisting of positive integers. There
    are two types of operations that you can apply on the array any number of
    times:
    * Choose two elements with equal values and delete them from the array.
    * Choose three elements with equal values and delete them from the array.
    Return the minimum number of operations required to make the array empty,
    or -1 if it is not possible.

    Example 1:
    Input: nums = [2,3,3,2,2,4,2,3,4]
    Output: 4
    Explanation: We can apply the following operations to make the array empty:
                 - Apply the first operation on the elements at indices 0 and 3.
                   The resulting array is nums = [3,3,2,4,2,3,4].
                 - Apply the first operation on the elements at indices 2 and 4.
                   The resulting array is nums = [3,3,4,3,4].
                 - Apply the second operation on the elements at indices 0, 1,
                   and 3. The resulting array is nums = [4,4].
                 - Apply the first operation on the elements at indices 0 and 1.
                   The resulting array is nums = [].
                 It can be shown that we cannot make the array empty in less
                 than 4 operations.

    Example 2:
    Input: nums = [2,1,2,2,3,3]
    Output: -1
    Explanation: It is impossible to empty the array.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    int minOperations(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        int ans = 0;
        for (auto& [_, v] : freq) {
            if (v == 1) return -1;
            ans += (v + 2)/3;
        }
        return ans;
    }


    /*2871. Split Array Into Maximum Number of Subarrays (Medium)
    You are given an array nums consisting of non-negative integers. We define
    the score of subarray nums[l..r] such that l <= r as
    nums[l] AND nums[l + 1] AND ... AND nums[r] where AND is the bitwise AND
    operation. Consider splitting the array into one or more subarrays such
    that the following conditions are satisfied:
    * Each element of the array belongs to exactly one subarray.
    * The sum of scores of the subarrays is the minimum possible.
    Return the maximum number of subarrays in a split that satisfies the
    conditions above. A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1,0,2,0,1,2]
    Output: 3
    Explanation: We can split the array into the following subarrays:
                 - [1,0]. The score of this subarray is 1 AND 0 = 0.
                 - [2,0]. The score of this subarray is 2 AND 0 = 0.
                 - [1,2]. The score of this subarray is 1 AND 2 = 0.
                 The sum of scores is 0 + 0 + 0 = 0, which is the minimum
                 possible score that we can obtain. It can be shown that we
                 cannot split the array into more than 3 subarrays with a total
                 score of 0. So we return 3.

    Example 2:
    Input: nums = [5,7,1,3]
    Output: 1
    Explanation: We can split the array into one subarray: [5,7,1,3] with a
                 score of 1, which is the minimum possible score that we can
                 obtain. It can be shown that we cannot split the array into
                 more than 1 subarray with a total score of 1. So we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6*/

    int maxSubarrays(vector<int>& nums) {
        int ans = 0, prefix = -1;
        for (auto& x : nums) {
            prefix &= x;
            if (prefix == 0) {
                ++ans;
                prefix = -1;
            }
        }
        return max(1, ans);
    }


    /*2872. Maximum Number of K-Divisible Components (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. You are also given a 0-indexed integer array values of length
    n, where values[i] is the value associated with the ith node, and an
    integer k. A valid split of the tree is obtained by removing any set of
    edges, possibly empty, from the tree such that the resulting components all
    have values that are divisible by k, where the value of a connected
    component is the sum of the values of its nodes. Return the maximum number
    of components in any valid split.

    Example 1:
    Input: n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6
    Output: 2
    Explanation: We remove the edge connecting node 1 with 2. The resulting
                 split is valid because:
                 - The value of the component containing nodes 1 and 3 is
                   values[1] + values[3] = 12.
                 - The value of the component containing nodes 0, 2, and 4 is
                   values[0] + values[2] + values[4] = 6.
                 It can be shown that no other valid split has more than 2
                 connected components.

    Example 2:
    Input: n = 7, edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [3,0,6,1,5,2,1], k = 3
    Output: 3
    Explanation: We remove the edge connecting node 0 with 2, and the edge
                 connecting node 0 with 1. The resulting split is valid because:
                 - The value of the component containing node 0 is values[0] = 3.
                 - The value of the component containing nodes 2, 5, and 6 is
                   values[2] + values[5] + values[6] = 9.
                 - The value of the component containing nodes 1, 3, and 4 is
                   values[1] + values[3] + values[4] = 6.
                 It can be shown that no other valid split has more than 3
                 connected components.

    Constraints:
    * 1 <= n <= 3 * 10^4
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * values.length == n
    * 0 <= values[i] <= 10^9
    * 1 <= k <= 10^9
    * Sum of values is divisible by k.
    * The input is generated such that edges represents a valid tree.*/

    int maxKDivisibleComponents(int n, vector<vector<int>>& edges, vector<int>& values, int k) {
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }

        function<long(int, int)> fn = [&](int u, int p) {
            for (auto& v : tree[u])
                if (v != p) values[u] = (values[u] + fn(v, u)) % k;
            return values[u];
        };

        fn(0, -1);
        return count_if(values.begin(), values.end(), [&](auto& x) { return x % k == 0; });
    }


    /*2873. Maximum Value of an Ordered Triplet I (Easy)
    You are given a 0-indexed integer array nums. Return the maximum value over
    all triplets of indices (i, j, k) such that i < j < k. If all such triplets
    have a negative value, return 0. The value of a triplet of indices (i, j, k)
    is equal to (nums[i] - nums[j]) * nums[k].

    Example 1:
    Input: nums = [12,6,1,2,7]
    Output: 77
    Explanation: The value of the triplet (0, 2, 4) is
                 (nums[0] - nums[2]) * nums[4] = 77. It can be shown that there
                 are no ordered triplets of indices with a value greater than
                 77.

    Example 2:
    Input: nums = [1,10,3,4,19]
    Output: 133
    Explanation: The value of the triplet (1, 2, 4) is
                 (nums[1] - nums[2]) * nums[4] = 133. It can be shown that
                 there are no ordered triplets of indices with a value greater
                 than 133.

    Example 3:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: The only ordered triplet of indices (0, 1, 2) has a negative
                 value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer
                 would be 0.

    Constraints:
    * 3 <= nums.length <= 100
    * 1 <= nums[i] <= 10^6*/

    long long maximumTripletValue(vector<int>& nums) {
        long long ans = 0;
        int diff = 0, prefix = 0;
        for (auto& x : nums) {
            ans = max(ans, (long long) x * diff);
            diff = max(diff, prefix - x);
            prefix = max(prefix, x);
        }
        return ans;
    }


    /*2874. Maximum Value of an Ordered Triplet II (Medium)
    You are given a 0-indexed integer array nums. Return the maximum value over
    all triplets of indices (i, j, k) such that i < j < k. If all such triplets
    have a negative value, return 0. The value of a triplet of indices (i, j, k)
    is equal to (nums[i] - nums[j]) * nums[k].

    Example 1:
    Input: nums = [12,6,1,2,7]
    Output: 77
    Explanation: The value of the triplet (0, 2, 4) is
                 (nums[0] - nums[2]) * nums[4] = 77. It can be shown that there
                 are no ordered triplets of indices with a value greater than
                 77.

    Example 2:
    Input: nums = [1,10,3,4,19]
    Output: 133
    Explanation: The value of the triplet (1, 2, 4) is
                 (nums[1] - nums[2]) * nums[4] = 133. It can be shown that
                 there are no ordered triplets of indices with a value greater
                 than 133.

    Example 3:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: The only ordered triplet of indices (0, 1, 2) has a negative
                 value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer
                 would be 0.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    long long maximumTripletValue(vector<int>& nums) {
        long long ans = 0;
        int diff = 0, prefix = 0;
        for (auto& x : nums) {
            ans = max(ans, (long long) x * diff);
            diff = max(diff, prefix - x);
            prefix = max(prefix, x);
        }
        return ans;
    }


    /*2875. Minimum Size Subarray in Infinite Array (Medium)
    You are given a 0-indexed array nums and an integer target. A 0-indexed
    array infinite_nums is generated by infinitely appending the elements of
    nums to itself. Return the length of the shortest subarray of the array
    infinite_nums with a sum equal to target. If there is no such subarray
    return -1.

    Example 1:
    Input: nums = [1,2,3], target = 5
    Output: 2
    Explanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...]. The
                 subarray in the range [1,2], has the sum equal to target = 5
                 and length = 2. It can be proven that 2 is the shortest length
                 of a subarray with sum equal to target = 5.

    Example 2:
    Input: nums = [1,1,1,2,3], target = 4
    Output: 2
    Explanation: In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
                 The subarray in the range [4,5], has the sum equal to
                 target = 4 and length = 2. It can be proven that 2 is the
                 shortest length of a subarray with sum equal to target = 4.

    Example 3:
    Input: nums = [2,4,6,8], target = 3
    Output: -1
    Explanation: In this example infinite_nums = [2,4,6,8,2,4,6,8,...]. It can
                 be proven that there is no subarray with sum equal to
                 target = 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= target <= 10^9*/

    int minSizeSubarray(vector<int>& nums, int target) {
        long total = accumulate(nums.begin(), nums.end(), 0l);
        int ans = (target / total) * nums.size(), cand = INT_MAX;
        target %= total;
        for (int i = 0, ii = 0, n = nums.size(); i < 2*n; ++i) {
            target -= nums[i % n];
            for (; target < 0; ++ii)
                target += nums[ii % n];
            if (target == 0) cand = min(cand, i-ii+1);
        }
        return cand < INT_MAX ? ans + cand : -1;
    }


    /*2876. Count Visited Nodes in a Directed Graph (Hard)
    There is a directed graph consisting of n nodes numbered from 0 to n - 1
    and n directed edges. You are given a 0-indexed array edges where edges[i]
    indicates that there is an edge from node i to node edges[i]. Consider the
    following process on the graph:
    * You start from a node x and keep visiting other nodes through edges until
      you reach a node that you have already visited before on this same
      process.
    Return an array answer where answer[i] is the number of different nodes
    that you will visit if you perform the process starting from node i.

    Example 1:
    Input: edges = [1,2,0,0]
    Output: [3,3,3,4]
    Explanation: We perform the process starting from each node in the
                 following way:
                 - Starting from node 0, we visit the nodes 0 -> 1 -> 2 -> 0.
                   The number of different nodes we visit is 3.
                 - Starting from node 1, we visit the nodes 1 -> 2 -> 0 -> 1.
                   The number of different nodes we visit is 3.
                 - Starting from node 2, we visit the nodes 2 -> 0 -> 1 -> 2.
                   The number of different nodes we visit is 3.
                 - Starting from node 3, we visit the nodes 3 -> 0 -> 1 -> 2 ->
                   0. The number of different nodes we visit is 4.

    Example 2:
    Input: edges = [1,2,3,4,0]
    Output: [5,5,5,5,5]
    Explanation: Starting from any node we can visit every node in the graph in
                 the process.

    Constraints:
    * n == edges.length
    * 2 <= n <= 10^5
    * 0 <= edges[i] <= n - 1
    * edges[i] != i*/

    vector<int> countVisitedNodes(vector<int>& edges) {
        int n = edges.size();
        vector<int> ans(n);
        for (int x = 0; x < n; ++x)
            if (ans[x] == 0) {
                stack<int> stk;
                int v = 0, k = x;
                for (; ans[k] == 0; k = edges[k]) {
                    ans[k] = --v;
                    stk.push(k);
                }
                for (int pp = k; stk.size(); ) {
                    auto kk = stk.top(); stk.pop();
                    if (ans[k] > 0) ans[kk] = ans[pp] + 1;
                    else ans[kk] = ans[k] - v + 1;
                    pp = kk;
                }
            }
        return ans;
    }


    /*2892. Minimizing Array After Replacing Pairs With Their Product (Medium)
    Given an integer array nums and an integer k, you can perform the following
    operation on the array any number of times:
    * Select two adjacent elements of the array like x and y, such that
      x * y <= k, and replace both of them with a single element with value
      x * y (e.g. in one operation the array [1, 2, 2, 3] with k = 5 can become
      [1, 4, 3] or [2, 2, 3], but can't become [1, 2, 6]).
    Return the minimum possible length of nums after any number of operations.

    Example 1:
    Input: nums = [2,3,3,7,3,5], k = 20
    Output: 3
    Explanation: We perform these operations:
                 1. [2,3,3,7,3,5] -> [6,3,7,3,5]
                 2. [6,3,7,3,5] -> [18,7,3,5]
                 3. [18,7,3,5] -> [18,7,15]
                 It can be shown that 3 is the minimum length possible to
                 achieve with the given operation.

    Example 2:
    Input: nums = [3,3,3,3], k = 6
    Output: 4
    Explanation: We can't perform any operations since the product of every two
                 adjacent elements is greater than 6. Hence, the answer is 4.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 1 <= k <= 10^9*/

    int minArrayLength(vector<int>& nums, int k) {
        int ans = 0;
        long long prefix = 0;
        for (auto& x : nums)
            if (x == 0) return 1;
            else if (prefix && prefix*x <= k) prefix *= x;
            else {
                ++ans;
                prefix = x;
            }
        return ans;
    }


    /*2894. Divisible and Non-divisible Sums Difference (Easy)
    You are given positive integers n and m. Define two integers, num1 and num2,
    as follows:
    * num1: The sum of all integers in the range [1, n] that are not divisible
      by m.
    * num2: The sum of all integers in the range [1, n] that are divisible by m.
    Return the integer num1 - num2.

    Example 1:
    Input: n = 10, m = 3
    Output: 19
    Explanation: In the given example:
                 - Integers in the range [1, 10] that are not divisible by 3
                   are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.
                 - Integers in the range [1, 10] that are divisible by 3 are
                   [3,6,9], num2 is the sum of those integers = 18.
                 We return 37 - 18 = 19 as the answer.

    Example 2:
    Input: n = 5, m = 6
    Output: 15
    Explanation: In the given example:
                 - Integers in the range [1, 5] that are not divisible by 6 are
                   [1,2,3,4,5], num1 is the sum of those integers = 15.
                 - Integers in the range [1, 5] that are divisible by 6 are [],
                   num2 is the sum of those integers = 0.
                 We return 15 - 0 = 15 as the answer.

    Example 3:
    Input: n = 5, m = 1
    Output: -15
    Explanation: In the given example:
                 - Integers in the range [1, 5] that are not divisible by 1 are
                   [], num1 is the sum of those integers = 0.
                 - Integers in the range [1, 5] that are divisible by 1 are
                   [1,2,3,4,5], num2 is the sum of those integers = 15.
                 We return 0 - 15 = -15 as the answer.

    Constraints: 1 <= n, m <= 1000*/

    int differenceOfSums(int n, int m) {
        return n*(n+1)/2 - (n/m)*(n/m+1)*m;
    }


    /*2895. Minimum Processing Time (Medium)
    You have n processors each having 4 cores and n * 4 tasks that need to be
    executed such that each core should perform only one task. Given a
    0-indexed integer array processorTime representing the time at which each
    processor becomes available for the first time and a 0-indexed integer
    array tasks representing the time it takes to execute each task, return the
    minimum time when all of the tasks have been executed by the processors.
    Note: Each core executes the task independently of the others.

    Example 1:
    Input: processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]
    Output: 16
    Explanation: It's optimal to assign the tasks at indexes 4, 5, 6, 7 to the
                 first processor which becomes available at time = 8, and the
                 tasks at indexes 0, 1, 2, 3 to the second processor which
                 becomes available at time = 10. Time taken by the first
                 processor to finish execution of all tasks =
                 max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16. Time taken by the second
                 processor to finish execution of all tasks =
                 max(10 + 2, 10 + 2, 10 + 3, 10 + 1) = 13. Hence, it can be
                 shown that the minimum time taken to execute all the tasks is
                 16.

    Example 2:
    Input: processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]
    Output: 23
    Explanation: It's optimal to assign the tasks at indexes 1, 4, 5, 6 to the
                 first processor which becomes available at time = 10, and the
                 tasks at indexes 0, 2, 3, 7 to the second processor which
                 becomes available at time = 20. Time taken by the first
                 processor to finish execution of all tasks =
                 max(10 + 3, 10 + 5, 10 + 8, 10 + 4) = 18. Time taken by the
                 second processor to finish execution of all tasks =
                 max(20 + 2, 20 + 1, 20 + 2, 20 + 3) = 23. Hence, it can be
                 shown that the minimum time taken to execute all the tasks is
                 23.

    Constraints:
    * 1 <= n == processorTime.length <= 25000
    * 1 <= tasks.length <= 10^5
    * 0 <= processorTime[i] <= 10^9
    * 1 <= tasks[i] <= 10^9
    * tasks.length == 4 * n*/

    int minProcessingTime(vector<int>& processorTime, vector<int>& tasks) {
        sort(processorTime.begin(), processorTime.end());
        sort(tasks.begin(), tasks.end(), [&](auto& lhs, auto& rhs) { return lhs > rhs; });
        int ans = 0;
        for (int i = 0; i < tasks.size(); ++i)
            ans = max(ans, processorTime[i/4] + tasks[i]);
        return ans;
    }


    /*2896. Apply Operations to Make Two Strings Equal (Medium)
    You are given two 0-indexed binary strings s1 and s2, both of length n, and
    a positive integer x. You can perform any of the following operations on
    the string s1 any number of times:
    * Choose two indices i and j, and flip both s1[i] and s1[j]. The cost of
      this operation is x.
    * Choose an index i such that i < n - 1 and flip both s1[i] and s1[i + 1].
      The cost of this operation is 1.
    Return the minimum cost needed to make the strings s1 and s2 equal, or
    return -1 if it is impossible. Note that flipping a character means
    changing it from 0 to 1 or vice-versa.

    Example 1:
    Input: s1 = "1100011000", s2 = "0101001010", x = 2
    Output: 4
    Explanation: We can do the following operations:
                 - Choose i = 3 and apply the second operation. The resulting
                   string is s1 = "1101111000".
                 - Choose i = 4 and apply the second operation. The resulting
                   string is s1 = "1101001000".
                 - Choose i = 0 and j = 8 and apply the first operation. The
                   resulting string is s1 = "0101001010" = s2.
                 The total cost is 1 + 1 + 2 = 4. It can be shown that it is
                 the minimum cost possible.

    Example 2:
    Input: s1 = "10110", s2 = "00011", x = 4
    Output: -1
    Explanation: It is not possible to make the two strings equal.

    Constraints:
    * n == s1.length == s2.length
    * 1 <= n, x <= 500
    * s1 and s2 consist only of the characters '0' and '1'.*/

    int minOperations(string s1, string s2, int x) {
        vector<int> diff;
        for (int i = 0; i < s1.size(); ++i)
            if (s1[i] != s2[i]) diff.push_back(i);
        int n = diff.size();
        if (n & 1) return -1;
        double f0 = 0, f1 = 0;
        for (int i = 0; i < n; ++i) {
            double f2 = f1 + x/2.0;
            if (i) f2 = min(f2, f0 + diff[i] - diff[i-1]);
            f0 = f1;
            f1 = f2;
        }
        return int(f1);
    }


    /*2897. Apply Operations on Array to Maximize Sum of Squares (Hard)
    You are given a 0-indexed integer array nums and a positive integer k. You
    can do the following operation on the array any number of times:
    * Choose any two distinct indices i and j and simultaneously update the
      values of nums[i] to (nums[i] AND nums[j]) and nums[j] to
      (nums[i] OR nums[j]). Here, OR denotes the bitwise OR operation, and AND
      denotes the bitwise AND operation.
    You have to choose k elements from the final array and calculate the sum of
    their squares. Return the maximum sum of squares you can achieve. Since the
    answer can be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,6,5,8], k = 2
    Output: 261
    Explanation: We can do the following operations on the array:
                 - Choose i = 0 and j = 3, then change nums[0] to (2 AND 8) = 0
                   and nums[3] to (2 OR 8) = 10. The resulting array is
                   nums = [0,6,5,10].
                 - Choose i = 2 and j = 3, then change nums[2] to (5 AND 10) = 0
                   and nums[3] to (5 OR 10) = 15. The resulting array is
                   nums = [0,6,0,15].
                 We can choose the elements 15 and 6 from the final array. The
                 sum of squares is 152 + 62 = 261. It can be shown that this is
                 the maximum value we can get.

    Example 2:
    Input: nums = [4,5,4,7], k = 3
    Output: 90
    Explanation: We do not need to apply any operations. We can choose the
                 elements 7, 5, and 4 with a sum of squares: 72 + 52 + 42 = 90.
                 It can be shown that this is the maximum value we can get.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int maxSum(vector<int>& nums, int k) {
        vector<int> freq(32);
        for (auto& x : nums)
            for (int i = 0; i < 32; ++i)
                if (x & 1<<i) ++freq[i];
        long ans = 0;
        while (k--) {
            long val = 0;
            for (int i = 31; i >= 0; --i)
                if (freq[i]) {
                    --freq[i];
                    val ^= 1<<i;
                }
            ans = (ans + val*val) % 1'000'000'007;
        }
        return ans;
    }


    /*2898. Maximum Linear Stock Score (Medium)
    Given a 1-indexed integer array prices, where prices[i] is the price of a
    particular stock on the ith day, your task is to select some of the elements
    of prices such that your selection is linear. A selection indexes, where
    indexes is a 1-indexed integer array of length k which is a subsequence of
    the array [1, 2, ..., n], is linear if:
    * For every 1 < j <= k,
      prices[indexes[j]] - prices[indexes[j - 1]] == indexes[j] - indexes[j - 1].
    A subsequence is an array that can be derived from another array by deleting
    some or no elements without changing the order of the remaining elements.
    The score of a selection indexes, is equal to the sum of the following array:
    [prices[indexes[1]], prices[indexes[2]], ..., prices[indexes[k]]. Return the
    maximum score that a linear selection can have.

    Example 1:
    Input: prices = [1,5,3,7,8]
    Output: 20
    Explanation: We can select the indexes [2,4,5]. We show that our selection
                 is linear:
                 For j = 2, we have:
                 indexes[2] - indexes[1] = 4 - 2 = 2.
                 prices[4] - prices[2] = 7 - 5 = 2.
                 For j = 3, we have:
                 indexes[3] - indexes[2] = 5 - 4 = 1.
                 prices[5] - prices[4] = 8 - 7 = 1.
                 The sum of the elements is:
                 prices[2] + prices[4] + prices[5] = 20.
                 It can be shown that the maximum sum a linear selection can
                 have is 20.

    Example 2:
    Input: prices = [5,6,7,8,9]
    Output: 35
    Explanation: We can select all of the indexes [1,2,3,4,5]. Since each
                 element has a difference of exactly 1 from its previous
                 element, our selection is linear. The sum of all the elements
                 is 35 which is the maximum possible some out of every
                 selection.

    Constraints:
    * 1 <= prices.length <= 10^5
    * 1 <= prices[i] <= 10^9*/

    long long maxScore(vector<int>& prices) {
        unordered_map<int, long long> mp;
        for (int i = 0; i < prices.size(); ++i)
            mp[prices[i]-i] += prices[i];
        return max_element(mp.begin(), mp.end(), [&](auto& lhs, auto& rhs) {
            return lhs.second < rhs.second;
        })->second;
    }


    /*2899. Last Visited Integers (Easy)
    Given a 0-indexed array of strings words where words[i] is either a positive
    integer represented as a string or the string "prev". Start iterating from
    the beginning of the array; for every "prev" string seen in words, find the
    last visited integer in words which is defined as follows:
    * Let k be the number of consecutive "prev" strings seen so far (containing
      the current string). Let nums be the 0-indexed array of integers seen so
      far and nums_reverse be the reverse of nums, then the integer at (k - 1)th
      index of nums_reverse will be the last visited integer for this "prev".
    * If k is greater than the total visited integers, then the last visited
      integer will be -1.
    Return an integer array containing the last visited integers.

    Example 1:
    Input: words = ["1","2","prev","prev","prev"]
    Output: [2,1,-1]
    Explanation: - For "prev" at index = 2, last visited integer will be 2 as
                   here the number of consecutive "prev" strings is 1, and in
                   the array reverse_nums, 2 will be the first element.
                 - For "prev" at index = 3, last visited integer will be 1 as
                   there are a total of two consecutive "prev" strings including
                   this "prev" which are visited, and 1 is the second last
                   visited integer.
                 - For "prev" at index = 4, last visited integer will be -1 as
                   there are a total of three consecutive "prev" strings
                   including this "prev" which are visited, but the total number
                   of integers visited is two.

    Example 2:
    Input: words = ["1","prev","2","prev","prev"]
    Output: [1,2,1]
    Explanation: - For "prev" at index = 1, last visited integer will be 1.
                 - For "prev" at index = 3, last visited integer will be 2.
                 - For "prev" at index = 4, last visited integer will be 1 as
                   there are a total of two consecutive "prev" strings including
                   this "prev" which are visited, and 1 is the second last
                   visited integer.

    Constraints:
    * 1 <= words.length <= 100
    * words[i] == "prev" or 1 <= int(words[i]) <= 100*/

    vector<int> lastVisitedIntegers(vector<string>& words) {
        vector<int> ans, seen;
        int k = 0;
        for (auto& w : words)
            if (w == "prev")
                if (k >= seen.size()) ans.push_back(-1);
                else ans.push_back(seen[seen.size()-1-k++]);
            else {
                seen.push_back(stoi(w));
                k = 0;
            }
        return ans;
    }


    /*2900. Longest Unequal Adjacent Groups Subsequence I (Easy)
    You are given a string array words and a binary array groups both of length
    n, where words[i] is associated with groups[i]. Your task is to select the
    longest alternating subsequence from words. A subsequence of words is
    alternating if for any two consecutive strings in the sequence, their
    corresponding elements in the binary array groups differ. Essentially, you
    are to choose strings such that adjacent elements have non-matching
    corresponding bits in the groups array. Formally, you need to find the
    longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as
    [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each
    0 <= j < k - 1 and then find the words corresponding to these indices.
    Return the selected subsequence. If there are multiple answers, return any
    of them. Note: The elements in words are distinct.

    Example 1:
    Input: words = ["e","a","b"], groups = [0,0,1]
    Output: ["e","b"]
    Explanation: A subsequence that can be selected is ["e","b"] because
                 groups[0] != groups[2]. Another subsequence that can be
                 selected is ["a","b"] because groups[1] != groups[2]. It can be
                 demonstrated that the length of the longest subsequence of
                 indices that satisfies the condition is 2.

    Example 2:
    Input: words = ["a","b","c","d"], groups = [1,0,1,1]
    Output: ["a","b","c"]
    Explanation: A subsequence that can be selected is ["a","b","c"] because
                 groups[0] != groups[1] and groups[1] != groups[2]. Another
                 subsequence that can be selected is ["a","b","d"] because
                 groups[0] != groups[1] and groups[1] != groups[3]. It can be
                 shown that the length of the longest subsequence of indices
                 that satisfies the condition is 3.

    Constraints:
    * 1 <= n == words.length == groups.length <= 100
    * 1 <= words[i].length <= 10
    * groups[i] is either 0 or 1.
    * words consists of distinct strings.
    * words[i] consists of lowercase English letters.*/

    vector<string> getLongestSubsequence(vector<string>& words, vector<int>& groups) {
        vector<string> ans;
        for (int i = 0; i < words.size(); ++i)
            if (i == 0 || groups[i-1] != groups[i])
                ans.push_back(words[i]);
        return ans;
    }


    /*2913. Subarrays Distinct Element Sum of Squares I (Easy)
    You are given a 0-indexed integer array nums. The distinct count of a
    subarray of nums is defined as:
    * Let nums[i..j] be a subarray of nums consisting of all the indices from i
      to j such that 0 <= i <= j < nums.length. Then the number of distinct
      values in nums[i..j] is called the distinct count of nums[i..j].
    Return the sum of the squares of distinct counts of all subarrays of nums. A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,1]
    Output: 15
    Explanation: Six possible subarrays are:
                 [1]: 1 distinct value
                 [2]: 1 distinct value
                 [1]: 1 distinct value
                 [1,2]: 2 distinct values
                 [2,1]: 2 distinct values
                 [1,2,1]: 2 distinct values
                 The sum of the squares of the distinct counts in all subarrays
                 is equal to 12 + 12 + 12 + 22 + 22 + 22 = 15.

    Example 2:
    Input: nums = [1,1]
    Output: 3
    Explanation: Three possible subarrays are:
                 [1]: 1 distinct value
                 [1]: 1 distinct value
                 [1,1]: 1 distinct value
                 The sum of the squares of the distinct counts in all subarrays
                 is equal to 12 + 12 + 12 = 3.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100*/

        int sumCounts(vector<int>& nums) {
            int ans = 0;
            for (int i = 0, n = nums.size(); i < n; ++i) {
                unordered_set<int> seen;
                for (int j = i; j < n; ++j) {
                    seen.insert(nums[j]);
                    ans += pow(seen.size(), 2);
                }
            }
            return ans;
        }


    /*2917. Find the K-or of an Array (Easy)
    You are given a 0-indexed integer array nums, and an integer k. The K-or of
    nums is a non-negative integer that satisfies the following:
    * The ith bit is set in the K-or if and only if there are at least k
      elements of nums in which bit i is set.
    Return the K-or of nums. Note that a bit i is set in x if (2i AND x) == 2i,
    where AND is the bitwise AND operator.

    Example 1:
    Input: nums = [7,12,9,8,9,15], k = 4
    Output: 9
    Explanation: Bit 0 is set at nums[0], nums[2], nums[4], and nums[5].
                 Bit 1 is set at nums[0], and nums[5].
                 Bit 2 is set at nums[0], nums[1], and nums[5].
                 Bit 3 is set at nums[1], nums[2], nums[3], nums[4], and nums[5].
                 Only bits 0 and 3 are set in at least k elements of the array,
                 and bits i >= 4 are not set in any of the array's elements.
                 Hence, the answer is 2^0 + 2^3 = 9.

    Example 2:
    Input: nums = [2,12,1,11,4,5], k = 6
    Output: 0
    Explanation: Since k == 6 == nums.length, the 6-or of the array is equal to
                 the bitwise AND of all its elements. Hence, the answer is 2 AND
                 12 AND 1 AND 11 AND 4 AND 5 = 0.

    Example 3:
    Input: nums = [10,8,5,9,11,6,8], k = 1
    Output: 15
    Explanation: Since k == 1, the 1-or of the array is equal to the bitwise OR
                 of all its elements. Hence, the answer is
                 10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15.

    Constraints:
    * 1 <= nums.length <= 50
    * 0 <= nums[i] < 2^31
    * 1 <= k <= nums.length*/

    int findKOr(vector<int>& nums, int k) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int freq = 0;
            for (auto& x : nums)
                if (x & 1<<i && ++freq == k) {
                    ans ^= 1<<i;
                    break;
                }
        }
        return ans;
    }


    /*2918. Minimum Equal Sum of Two Arrays After Replacing Zeros (Medium)
    You are given two arrays nums1 and nums2 consisting of positive integers.
    You have to replace all the 0's in both arrays with strictly positive
    integers such that the sum of elements of both arrays becomes equal. Return
    the minimum equal sum you can obtain, or -1 if it is impossible.

    Example 1:
    Input: nums1 = [3,2,0,1,0], nums2 = [6,5,0]
    Output: 12
    Explanation: We can replace 0's in the following way:
                 - Replace the two 0's in nums1 with the values 2 and 4. The
                   resulting array is nums1 = [3,2,2,1,4].
                 - Replace the 0 in nums2 with the value 1. The resulting array
                   is nums2 = [6,5,1].
                 Both arrays have an equal sum of 12. It can be shown that it is
                 the minimum sum we can obtain.

    Example 2:
    Input: nums1 = [2,0,2,0], nums2 = [1,4]
    Output: -1
    Explanation: It is impossible to make the sum of both arrays equal.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 10^5
    * 0 <= nums1[i], nums2[i] <= 10^6*/

    long long minSum(vector<int>& nums1, vector<int>& nums2) {
        long long s1 = accumulate(nums1.begin(), nums1.end(), 0ll, [&](auto s, int x) { return s + max(x, 1); });
        long long s2 = accumulate(nums2.begin(), nums2.end(), 0ll, [&](auto s, int x) { return s + max(x, 1); });
        if (s1 < s2 && count(nums1.begin(), nums1.end(), 0) == 0) return -1;
        if (s2 < s1 && count(nums2.begin(), nums2.end(), 0) == 0) return -1;
        return max(s1, s2);
    }


    /*2919. Minimum Increment Operations to Make Array Beautiful (Medium)
    You are given a 0-indexed integer array nums having length n, and an integer
    k. You can perform the following increment operation any number of times
    (including zero):
    * Choose an index i in the range [0, n - 1], and increase nums[i] by 1.
    An array is considered beautiful if, for any subarray with a size of 3 or
    more, its maximum element is greater than or equal to k. Return an integer
    denoting the minimum number of increment operations needed to make nums
    beautiful. A subarray is a contiguous non-empty sequence of elements within
    an array.

    Example 1:
    Input: nums = [2,3,0,0,2], k = 4
    Output: 3
    Explanation: We can perform the following increment operations to make nums
                 beautiful:
                 - Choose index i = 1 and increase nums[1] by 1 -> [2,4,0,0,2].
                 - Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,3].
                 - Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,4].
                 The subarrays with a size of 3 or more are: [2,4,0], [4,0,0],
                 [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4]. In all the
                 subarrays, the maximum element is equal to k = 4, so nums is
                 now beautiful. It can be shown that nums cannot be made
                 beautiful with fewer than 3 increment operations. Hence, the
                 answer is 3.

    Example 2:
    Input: nums = [0,1,3,3], k = 5
    Output: 2
    Explanation: We can perform the following increment operations to make nums
                 beautiful:
                 - Choose index i = 2 and increase nums[2] by 1 -> [0,1,4,3].
                 - Choose index i = 2 and increase nums[2] by 1 -> [0,1,5,3].
                 The subarrays with a size of 3 or more are: [0,1,5], [1,5,3],
                 [0,1,5,3]. In all the subarrays, the maximum element is equal
                 to k = 5, so nums is now beautiful. It can be shown that nums
                 cannot be made beautiful with fewer than 2 increment
                 operations. Hence, the answer is 2.

    Example 3:
    Input: nums = [1,1,2], k = 1
    Output: 0
    Explanation: The only subarray with a size of 3 or more in this example is
                 [1,1,2]. The maximum element, 2, is already greater than k = 1,
                 so we don't need any increment operation. Hence, the answer is
                 0.

    Constraints:
    * 3 <= n == nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 0 <= k <= 10^9*/

    long long minIncrementOperations(vector<int>& nums, int k) {
        int n = nums.size();
        vector<long long> dp(n+1);
        for (int i = n-1; i >= 0; --i) {
            dp[i] = LLONG_MAX;
            for (int j = i+1; j <= i+3 && j <= n; ++j)
                dp[i] = min(dp[i], dp[j]);
            dp[i] += max(0, k-nums[i]);
        }
        return min({dp[0], dp[1], dp[2]});
    }


    /*2920. Maximum Points After Collecting Coins From All Nodes (Hard)
    There exists an undirected tree rooted at node 0 with n nodes labeled from 0
    to n - 1. You are given a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. You are also given a 0-indexed array coins of size n where
    coins[i] indicates the number of coins in the vertex i, and an integer k.
    Starting from the root, you have to collect all the coins such that the
    coins at a node can only be collected if the coins of its ancestors have
    been already collected. Coins at nodei can be collected in one of the
    following ways:
    * Collect all the coins, but you will get coins[i] - k points. If
      coins[i] - k is negative then you will lose abs(coins[i] - k) points.
    * Collect all the coins, but you will get floor(coins[i] / 2) points. If
      this way is used, then for all the nodej present in the subtree of nodei,
      coins[j] will get reduced to floor(coins[j] / 2).
    Return the maximum points you can get after collecting the coins from all
    the tree nodes.

    Example 1:
    Input: edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5
    Output: 11
    Explanation: - Collect all the coins from node 0 using the first way. Total
                   points = 10 - 5 = 5.
                 - Collect all the coins from node 1 using the first way. Total
                   points = 5 + (10 - 5) = 10.
                 - Collect all the coins from node 2 using the second way so
                   coins left at node 3 will be floor(3 / 2) = 1. Total points
                   = 10 + floor(3 / 2) = 11.
                 - Collect all the coins from node 3 using the second way. Total
                   points = 11 + floor(1 / 2) = 11.
                 It can be shown that the maximum points we can get after
                 collecting coins from all the nodes is 11.

    Example 2:
    Input: edges = [[0,1],[0,2]], coins = [8,4,4], k = 0
    Output: 16
    Explanation: Coins will be collected from all the nodes using the first way.
                 Therefore, total points = (8 - 0) + (4 - 0) + (4 - 0) = 16.

    Constraints:
    * n == coins.length
    * 2 <= n <= 10^5
    * 0 <= coins[i] <= 10^4
    * edges.length == n - 1
    * 0 <= edges[i][0], edges[i][1] < n
    * 0 <= k <= 10^4*/

    int maximumPoints(vector<vector<int>>& edges, vector<int>& coins, int k) {
        int n = 1 + edges.size();
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            tree[u].push_back(v);
            tree[v].push_back(u);
        }
        vector<short> memo(n);

        function<int(int, int, int)> fn = [&](int u, int p, int d) {
            if (d >= 14 || memo[u] & 1<<d) return 0;
            memo[u] ^= 1<<d;
            int op1 = 0, op2 = 0;
            for (auto& v : tree[u])
                if (v != p) {
                    op1 += fn(v, u, d);
                    op2 += fn(v, u, d+1);
                }
            return max((coins[u]>>d)-k+op1, (coins[u]>>d+1)+op2);
        };

        return fn(0, -1, 0);
    }


    /*2928. Distribute Candies Among Children I (Easy)
    You are given two positive integers n and limit. Return the total number of
    ways to distribute n candies among 3 children such that no child gets more
    than limit candies.

    Example 1:
    Input: n = 5, limit = 2
    Output: 3
    Explanation: There are 3 ways to distribute 5 candies such that no child
                 gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).

    Example 2:
    Input: n = 3, limit = 3
    Output: 10
    Explanation: There are 10 ways to distribute 3 candies such that no child
                 gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1),
                 (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1),
                 (2, 1, 0) and (3, 0, 0).

    Constraints:
    * 1 <= n <= 50
    * 1 <= limit <= 50*/

    int distributeCandies(int n, int limit) {
        int ans = 0;
        for (int x = 0; x <= limit; ++x)
            for (int y = 0; y <= limit; ++y)
                if (0 <= n-x-y && n-x-y <= limit) ++ans;
        return ans;
    }


    /*2929. Distribute Candies Among Children II (Medium)
    You are given two positive integers n and limit. Return the total number of
    ways to distribute n candies among 3 children such that no child gets more
    than limit candies.

    Example 1:
    Input: n = 5, limit = 2
    Output: 3
    Explanation: There are 3 ways to distribute 5 candies such that no child
                 gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).
    Example 2:
    Input: n = 3, limit = 3
    Output: 10
    Explanation: There are 10 ways to distribute 3 candies such that no child
                 gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1),
                 (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1),
                 (2, 1, 0) and (3, 0, 0).

    Constraints:
    * 1 <= n <= 10^6
    * 1 <= limit <= 10^6*/

    long long distributeCandies(int n, int limit) {
        long long ans = 0;
        for (int x = 0; x <= limit; ++x)
            ans += max(0, min(n-x, 2*limit-n+x)+1);
        return ans;
    }

    /*2930. Number of Strings Which Can Be Rearranged to Contain Substring (Medium)
    You are given an integer n. A string s is called good if it contains only
    lowercase English characters and it is possible to rearrange the characters
    of s such that the new string contains "leet" as a substring.

    For example:
    * The string "lteer" is good because we can rearrange it to form "leetr" .
    * "letl" is not good because we cannot rearrange it to contain "leet" as a
      substring.
    Return the total number of good strings of length n. Since the answer may
    be large, return it modulo 10^9 + 7. A substring is a contiguous sequence
    of characters within a string.

    Example 1:
    Input: n = 4
    Output: 12
    Explanation: The 12 strings which can be rearranged to have "leet" as a
                 substring are: "eelt", "eetl", "elet", "elte", "etel", "etle",
                 "leet", "lete", "ltee", "teel", "tele", and "tlee".

    Example 2:
    Input: n = 10
    Output: 83943898
    Explanation: The number of strings with length 10 which can be rearranged
                 to have "leet" as a substring is 526083947580. Hence the
                 answer is 526083947580 % (10^9 + 7) = 83943898.

    Constraints: 1 <= n <= 10^5*/

    int stringCount(int n) {
        const int mod = 1'000'000'007;

        auto pow = [&](long x, int p, int m) {
            long ans = 1;
            for (; p; p >>= 1) {
                if (p & 1) ans = ans * x % m;
                x = x * x % m;
            }
            return ans;
        };

        return ((pow(26, n, mod) - (75+n)*pow(25, n-1, mod) + (72+2*n)*pow(24, n-1, mod) - (23+n)*pow(23, n-1, mod)) % mod + mod) % mod;
    }


    /*2931. Maximum Spending After Buying Items (Hard)
    You are given a 0-indexed m * n integer matrix values, representing the
    values of m * n different items in m different shops. Each shop has n items
    where the jth item in the ith shop has a value of values[i][j].
    Additionally, the items in the ith shop are sorted in non-increasing order
    of value. That is, values[i][j] >= values[i][j + 1] for all 0 <= j < n - 1.
    On each day, you would like to buy a single item from one of the shops.
    Specifically, On the dth day you can:
    * Pick any shop i.
    * Buy the rightmost available item j for the price of values[i][j] * d.
      That is, find the greatest index j such that item j was never bought
      before, and buy it for the price of values[i][j] * d.
    Note that all items are pairwise different. For example, if you have bought
    item 0 from shop 1, you can still buy item 0 from any other shop. Return
    the maximum amount of money that can be spent on buying all m * n products.

    Example 1:
    Input: values = [[8,5,2],[6,4,1],[9,7,3]]
    Output: 285
    Explanation: - On the first day, we buy product 2 from shop 1 for a price
                   of values[1][2] * 1 = 1.
                 - On the second day, we buy product 2 from shop 0 for a price
                   of values[0][2] * 2 = 4.
                 - On the third day, we buy product 2 from shop 2 for a price
                   of values[2][2] * 3 = 9.
                 - On the fourth day, we buy product 1 from shop 1 for a price
                   of values[1][1] * 4 = 16.
                 - On the fifth day, we buy product 1 from shop 0 for a price
                   of values[0][1] * 5 = 25.
                 - On the sixth day, we buy product 0 from shop 1 for a price
                   of values[1][0] * 6 = 36.
                 - On the seventh day, we buy product 1 from shop 2 for a price
                   of values[2][1] * 7 = 49.
                 - On the eighth day, we buy product 0 from shop 0 for a price
                   of values[0][0] * 8 = 64.
                 - On the ninth day, we buy product 0 from shop 2 for a price
                   of values[2][0] * 9 = 81.
                 Hence, our total spending is equal to 285. It can be shown
                 that 285 is the maximum amount of money that can be spent
                 buying all m * n products.

    Example 2:
    Input: values = [[10,8,6,4,2],[9,7,5,3,2]]
    Output: 386
    Explanation: - On the first day, we buy product 4 from shop 0 for a price
                   of values[0][4] * 1 = 2.
                 - On the second day, we buy product 4 from shop 1 for a price
                   of values[1][4] * 2 = 4.
                 - On the third day, we buy product 3 from shop 1 for a price of values[1][3] * 3 = 9.
                 - On the fourth day, we buy product 3 from shop 0 for a price of values[0][3] * 4 = 16.
                 - On the fifth day, we buy product 2 from shop 1 for a price of values[1][2] * 5 = 25.
                 - On the sixth day, we buy product 2 from shop 0 for a price of values[0][2] * 6 = 36.
                 - On the seventh day, we buy product 1 from shop 1 for a price of values[1][1] * 7 = 49.
                 - On the eighth day, we buy product 1 from shop 0 for a price of values[0][1] * 8 = 64
                 - On the ninth day, we buy product 0 from shop 1 for a price of values[1][0] * 9 = 81.
                 - On the tenth day, we buy product 0 from shop 0 for a price of values[0][0] * 10 = 100.
                 Hence, our total spending is equal to 386. It can be shown
                 that 386 is the maximum amount of money that can be spent
                 buying all m * n products.

    Constraints:
    * 1 <= m == values.length <= 10
    * 1 <= n == values[i].length <= 10^4
    * 1 <= values[i][j] <= 10^6
    * values[i] are sorted in non-increasing order.*/

    long long maxSpending(vector<vector<int>>& values) {
        int m = values.size(), n = values[0].size();
        priority_queue<tuple<int, int, int>> pq;
        for (int i = 0; i < m; ++i)
            pq.emplace(-values[i][n-1], i, n-1);
        long long ans = 0;
        for (int k = 0; k < m*n; ++k) {
            auto [v, i, j] = pq.top(); pq.pop();
            ans += (long long) -v*(k+1);
            if (j) pq.emplace(-values[i][j-1], i, j-1);
        }
        return ans;
    }


    /*2932. Maximum Strong Pair XOR I (Easy)
    You are given a 0-indexed integer array nums. A pair of integers x and y is
    called a strong pair if it satisfies the condition:
    * |x - y| <= min(x, y)
    You need to select two integers from nums such that they form a strong pair
    and their bitwise XOR is the maximum among all strong pairs in the array.
    Return the maximum XOR value out of all possible strong pairs in the array
    nums. Note that you can pick the same integer twice to form a pair.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 7
    Explanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2),
                 (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5)
                 and (5, 5). The maximum XOR possible from these pairs is
                 3 XOR 4 = 7.

    Example 2:
    Input: nums = [10,100]
    Output: 0
    Explanation: There are 2 strong pairs in the array nums: (10, 10) and
                 (100, 100). The maximum XOR possible from these pairs is
                 10 XOR 10 = 0 since the pair (100, 100) also gives
                 100 XOR 100 = 0.

    Example 3:
    Input: nums = [5,6,25,30]
    Output: 7
    Explanation: There are 6 strong pairs in the array nums: (5, 5), (5, 6),
                 (6, 6), (25, 25), (25, 30) and (30, 30). The maximum XOR
                 possible from these pairs is 25 XOR 30 = 7 since the only other
                 non-zero XOR value is 5 XOR 6 = 3.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 100*/

    int maximumStrongPairXor(vector<int>& nums) {
        int ans = 0;
        for (int i = 0, n = nums.size(); i < n; ++i)
            for (int j = i+1; j < n; ++j)
                if (abs(nums[i] - nums[j]) <= min(nums[i], nums[j]))
                    ans = max(ans, nums[i] ^ nums[j]);
        return ans;
    }


    /*2933. High-Access Employees (Medium)
    You are given a 2D 0-indexed array of strings, access_times, with size n.
    For each i where 0 <= i <= n - 1, access_times[i][0] represents the name of
    an employee, and access_times[i][1] represents the access time of that
    employee. All entries in access_times are within the same day. The access
    time is represented as four digits using a 24-hour time format, for example,
    "0800" or "2250". An employee is said to be high-access if he has accessed
    the system three or more times within a one-hour period. Times with exactly
    one hour of difference are not considered part of the same one-hour period.
    For example, "0815" and "0915" are not part of the same one-hour period.
    Access times at the start and end of the day are not counted within the same
    one-hour period. For example, "0005" and "2350" are not part of the same
    one-hour period. Return a list that contains the names of high-access
    employees with any order you want.

    Example 1:
    Input: access_times = [["a","0549"],["b","0457"],["a","0532"],["a","0621"],["b","0540"]]
    Output: ["a"]
    Explanation: "a" has three access times in the one-hour period of
                 [05:32, 06:31] which are 05:32, 05:49, and 06:21. But "b" does
                 not have more than two access times at all. So the answer is
                 ["a"].

    Example 2:
    Input: access_times = [["d","0002"],["c","0808"],["c","0829"],["e","0215"],["d","1508"],["d","1444"],["d","1410"],["c","0809"]]
    Output: ["c","d"]
    Explanation: "c" has three access times in the one-hour period of
                 [08:08, 09:07] which are 08:08, 08:09, and 08:29. "d" has also
                 three access times in the one-hour period of [14:10, 15:09]
                 which are 14:10, 14:44, and 15:08. However, "e" has just one
                 access time, so it can not be in the answer and the final
                 answer is ["c","d"].

    Example 3:
    Input: access_times = [["cd","1025"],["ab","1025"],["cd","1046"],["cd","1055"],["ab","1124"],["ab","1120"]]
    Output: ["ab","cd"]
    Explanation: "ab" has three access times in the one-hour period of
                 [10:25, 11:24] which are 10:25, 11:20, and 11:24. "cd" has also
                 three access times in the one-hour period of [10:25, 11:24]
                 which are 10:25, 10:46, and 10:55. So the answer is ["ab","cd"].

    Constraints:
    * 1 <= access_times.length <= 100
    * access_times[i].length == 2
    * 1 <= access_times[i][0].length <= 10
    * access_times[i][0] consists only of English small letters.
    * access_times[i][1].length == 4
    * access_times[i][1] is in 24-hour time format.
    * access_times[i][1] consists only of '0' to '9'.*/

    vector<string> findHighAccessEmployees(vector<vector<string>>& access_times) {
        unordered_map<string, vector<int>> mp;
        for (auto& x : access_times) {
            string name = x[0], time = x[1];
            int t = 60*stoi(time.substr(0, 2)) + stoi(time.substr(2));
            mp[name].push_back(t);
        }
        vector<string> ans;
        for (auto& [name, times] : mp) {
            sort(times.begin(), times.end());
            for (int i = 2; i < times.size(); ++i)
                if (times[i] - times[i-2] < 60) {
                    ans.push_back(name);
                    break;
                }
        }
        return ans;
    }


    /*2934. Minimum Operations to Maximize Last Elements in Arrays (Medium)
    You are given two 0-indexed integer arrays, nums1 and nums2, both having
    length n. You are allowed to perform a series of operations (possibly none).
    In an operation, you select an index i in the range [0, n - 1] and swap the
    values of nums1[i] and nums2[i]. Your task is to find the minimum number of
    operations required to satisfy the following conditions:
    * nums1[n - 1] is equal to the maximum value among all elements of nums1,
      i.e., nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]).
    * nums2[n - 1] is equal to the maximum value among all elements of nums2,
      i.e., nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]).
    Return an integer denoting the minimum number of operations needed to meet
    both conditions, or -1 if it is impossible to satisfy both conditions.

    Example 1:
    Input: nums1 = [1,2,7], nums2 = [4,5,3]
    Output: 1
    Explanation: In this example, an operation can be performed using index
                 i = 2. When nums1[2] and nums2[2] are swapped, nums1 becomes
                 [1,2,3] and nums2 becomes [4,5,7]. Both conditions are now
                 satisfied. It can be shown that the minimum number of
                 operations needed to be performed is 1. So, the answer is 1.

    Example 2:
    Input: nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]
    Output: 2
    Explanation: In this example, the following operations can be performed:
                 - First operation using index i = 4. When nums1[4] and nums2[4]
                   are swapped, nums1 becomes [2,3,4,5,4], and nums2 becomes
                   [8,8,4,4,9].
                 - Another operation using index i = 3. When nums1[3] and
                   nums2[3] are swapped, nums1 becomes [2,3,4,4,4], and nums2
                   becomes [8,8,4,5,9].
                 Both conditions are now satisfied. It can be shown that the
                 minimum number of operations needed to be performed is 2. So,
                 the answer is 2.

    Example 3:
    Input: nums1 = [1,5,4], nums2 = [2,5,3]
    Output: -1
    Explanation: In this example, it is not possible to satisfy both conditions.
                 So, the answer is -1.

    Constraints:
    * 1 <= n == nums1.length == nums2.length <= 1000
    * 1 <= nums1[i] <= 10^9
    * 1 <= nums2[i] <= 10^9*/

    int minOperations(vector<int>& nums1, vector<int>& nums2) {
        int yes = 0, no = 0;
        for (int i = 0, n = nums1.size(); i < n; ++i) {
            int x1 = nums1[i], x2 = nums2[i];
            if (max(nums1[n-1], nums2[n-1]) < max(x1, x2) || min(nums1[n-1], nums2[n-1]) < min(x1, x2)) return -1;
            if (nums1[n-1] < x1 || nums2[n-1] < x2) ++yes;
            else if (nums1[n-1] < x2 || nums2[n-1] < x1) ++no;
        }
        return min(yes, no);
    }


    /*2935. Maximum Strong Pair XOR II (Hard)
    You are given a 0-indexed integer array nums. A pair of integers x and y is
    called a strong pair if it satisfies the condition:
    * |x - y| <= min(x, y)
    You need to select two integers from nums such that they form a strong pair
    and their bitwise XOR is the maximum among all strong pairs in the array.
    Return the maximum XOR value out of all possible strong pairs in the array
    nums. Note that you can pick the same integer twice to form a pair.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 7
    Explanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2),
                 (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5)
                 and (5, 5). The maximum XOR possible from these pairs is
                 3 XOR 4 = 7.

    Example 2:
    Input: nums = [10,100]
    Output: 0
    Explanation: There are 2 strong pairs in the array nums: (10, 10) and
                 (100, 100). The maximum XOR possible from these pairs is
                 10 XOR 10 = 0 since the pair (100, 100) also gives
                 100 XOR 100 = 0.

    Example 3:
    Input: nums = [500,520,2500,3000]
    Output: 1020
    Explanation: There are 6 strong pairs in the array nums: (500, 500),
                 (500, 520), (520, 520), (2500, 2500), (2500, 3000) and
                 (3000, 3000). The maximum XOR possible from these pairs is
                 500 XOR 520 = 1020 since the only other non-zero XOR value is
                 2500 XOR 3000 = 636.

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 1 <= nums[i] <= 2^20 - 1

    class TrieNode {
    public:
        TrieNode *child[2] = {nullptr};
        int count = 0;
        int value = 0;
        ~TrieNode() = default;
    };*/

    int maximumStrongPairXor(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        TrieNode *trie = new TrieNode();
        int ans = 0, k = 0;
        for (auto& x : nums) {
            TrieNode *node = trie;
            for (int i = 19; i >= 0; --i) {
                int b = x>>i & 1;
                if (!node->child[b])
                    node->child[b] = new TrieNode();
                node = node->child[b];
                ++node->count;
            }
            node->value = x;
            for (; 2*nums[k] < x; ++k) {
                node = trie;
                for (int i = 19; i >= 0; --i) {
                    int b = nums[k]>>i & 1;
                    if (--node->child[b]->count == 0) {
                        delete node->child[b];
                        node->child[b] = nullptr;
                        break;
                    }
                    node = node->child[b];
                }
            }
            node = trie;
            for (int i = 19; i >= 0; --i) {
                int b = x>>i & 1;
                if (node->child[1^b]) node = node->child[1^b];
                else node = node->child[b];
            }
            ans = max(ans, x ^ node->value);
        }
        delete trie;
        return ans;
    }


    /*2936. Number of Equal Numbers Blocks (Medium)
    You are given a 0-indexed array of integers, nums. The following property
    holds for nums:
    * All occurrences of a value are adjacent. In other words, if there are two
      indices i < j such that nums[i] == nums[j], then for every index k that
      i < k < j, nums[k] == nums[i].
    Since nums is a very large array, you are given an instance of the class
    BigArray which has the following functions:
    * int at(long long index): Returns the value of nums[i].
    * void size(): Returns nums.length.
    Let's partition the array into maximal blocks such that each block contains
    equal values. Return the number of these blocks. Note that if you want to
    test your solution using a custom test, behavior for tests with
    nums.length > 10 is undefined.

    Example 1:
    Input: nums = [3,3,3,3,3]
    Output: 1
    Explanation: There is only one block here which is the whole array (because
                 all numbers are equal) and that is: [3,3,3,3,3]. So the answer
                 would be 1.

    Example 2:
    Input: nums = [1,1,1,3,9,9,9,2,10,10]
    Output: 5
    Explanation: There are 5 blocks here:
    Block number 1: [1,1,1,3,9,9,9,2,10,10]
    Block number 2: [1,1,1,3,9,9,9,2,10,10]
    Block number 3: [1,1,1,3,9,9,9,2,10,10]
    Block number 4: [1,1,1,3,9,9,9,2,10,10]
    Block number 5: [1,1,1,3,9,9,9,2,10,10]
    So the answer would be 5.

    Example 3:
    Input: nums = [1,2,3,4,5,6,7]
    Output: 7
    Explanation: Since all numbers are distinct, there are 7 blocks here and
                 each element representing one block. So the answer would be 7.

    Constraints:
    * 1 <= nums.length <= 10^15
    * 1 <= nums[i] <= 10^9
    * The input is generated such that all equal values are adjacent.
    * The sum of the elements of nums is at most 10^15.*/

    int countBlocks(BigArray* nums) {

        function<int(long long, long long)> fn = [&](long long lo, long long hi) {
            if (lo == hi || nums->at(lo) == nums->at(hi)) return 1;
            long long mid = lo + (hi - lo)/2;
            int ans = fn(lo, mid) + fn(mid+1, hi);
            if (nums->at(mid) == nums->at(mid+1)) --ans;
            return ans;
        };

        return fn(0, nums->size()-1);
    }


    /*2937. Make Three Strings Equal (Easy)
    You are given three strings s1, s2, and s3. You have to perform the
    following operation on these three strings as many times as you want. In
    one operation you can choose one of these three strings such that its
    length is at least 2 and delete the rightmost character of it. Return the
    minimum number of operations you need to perform to make the three strings
    equal if there is a way to make them equal, otherwise, return -1.

    Example 1:
    Input: s1 = "abc", s2 = "abb", s3 = "ab"
    Output: 2
    Explanation: Performing operations on s1 and s2 once will lead to three
                 equal strings. It can be shown that there is no way to make
                 them equal with less than two operations.

    Example 2:
    Input: s1 = "dac", s2 = "bac", s3 = "cac"
    Output: -1
    Explanation: Because the leftmost letters of s1 and s2 are not equal, they
                 could not be equal after any number of operations. So the
                 answer is -1.

    Constraints:
    * 1 <= s1.length, s2.length, s3.length <= 100
    * s1, s2 and s3 consist only of lowercase English letters.*/

    int findMinimumOperations(string s1, string s2, string s3) {
        int i = 0;
        for (int m = min({s1.size(), s2.size(), s3.size()}); i < m && s1[i] == s2[i] && s2[i] == s3[i]; ++i);
        return i ? s1.size() + s2.size() + s3.size() - 3*i : -1;
    }


    /*2938. Separate Black and White Balls (Medium)
    There are n balls on a table, each ball has a color black or white. You are
    given a 0-indexed binary string s of length n, where 1 and 0 represent
    black and white balls, respectively. In each step, you can choose two
    adjacent balls and swap them. Return the minimum number of steps to group
    all the black balls to the right and all the white balls to the left.

    Example 1:
    Input: s = "101"
    Output: 1
    Explanation: We can group all the black balls to the right in the following
                 way:
                 - Swap s[0] and s[1], s = "011".
                 Initially, 1s are not grouped together, requiring at least 1
                 step to group them to the right.

    Example 2:
    Input: s = "100"
    Output: 2
    Explanation: We can group all the black balls to the right in the following
                 way:
                 - Swap s[0] and s[1], s = "010".
                 - Swap s[1] and s[2], s = "001".
                 It can be proven that the minimum number of steps needed is 2.

    Example 3:
    Input: s = "0111"
    Output: 0
    Explanation: All the black balls are already grouped to the right.

    Constraints:
    * 1 <= n == s.length <= 10^5
    * s[i] is either '0' or '1'.*/

    long long minimumSteps(string s) {
        long long ans = 0;
        int prefix = 0;
        for (auto& ch : s)
            if (ch == '1') ++prefix;
            else ans += prefix;
        return ans;
    }


    /*2939. Maximum Xor Product (Medium)
    Given three integers a, b, and n, return the maximum value of
    (a XOR x) * (b XOR x) where 0 <= x < 2n. Since the answer may be too large,
    return it modulo 10^9 + 7. Note that XOR is the bitwise XOR operation.

    Example 1:
    Input: a = 12, b = 5, n = 4
    Output: 98
    Explanation: For x = 2, (a XOR x) = 14 and (b XOR x) = 7. Hence,
                 (a XOR x) * (b XOR x) = 98. It can be shown that 98 is the
                 maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.

    Example 2:
    Input: a = 6, b = 7 , n = 5
    Output: 930
    Explanation: For x = 25, (a XOR x) = 31 and (b XOR x) = 30. Hence,
                 (a XOR x) * (b XOR x) = 930. It can be shown that 930 is the
                 maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.

    Example 3:
    Input: a = 1, b = 6, n = 3
    Output: 12
    Explanation: For x = 5, (a XOR x) = 4 and (b XOR x) = 3. Hence,
                 (a XOR x) * (b XOR x) = 12. It can be shown that 12 is the
                 maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.

    Constraints:
    * 0 <= a, b < 2^50
    * 0 <= n <= 50*/

    int maximumXorProduct(long long a, long long b, int n) {
        const int mod = 1'000'000'007;
        for (int i = n-1; i >= 0; --i)
            if ((min(a, b) & 1l<<i) == 0) {
                a ^= 1l<<i;
                b ^= 1l<<i;
            }
        return a % mod * (b % mod) % mod;
    }


    /*2940. Find Building Where Alice and Bob Can Meet (Hard)
    You are given a 0-indexed array heights of positive integers, where
    heights[i] represents the height of the ith building. If a person is in
    building i, they can move to any other building j if and only if i < j and
    heights[i] < heights[j]. You are also given another array queries where
    queries[i] = [ai, bi]. On the ith query, Alice is in building ai while Bob
    is in building bi. Return an array ans where ans[i] is the index of the
    leftmost building where Alice and Bob can meet on the ith query. If Alice
    and Bob cannot move to a common building on query i, set ans[i] to -1.

    Example 1:
    Input: heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]
    Output: [2,5,-1,5,2]
    Explanation: - In the first query, Alice and Bob can move to building 2
                   since heights[0] < heights[2] and heights[1] < heights[2].
                 - In the second query, Alice and Bob can move to building 5
                   since heights[0] < heights[5] and heights[3] < heights[5].
                 - In the third query, Alice cannot meet Bob since Alice cannot
                   move to any other building.
                 - In the fourth query, Alice and Bob can move to building 5
                   since heights[3] < heights[5] and heights[4] < heights[5].
                 - In the fifth query, Alice and Bob are already in the same
                   building.
                 For ans[i] != -1, It can be shown that ans[i] is the leftmost
                 building where Alice and Bob can meet. For ans[i] == -1, It
                 can be shown that there is no building where Alice and Bob can
                 meet.

    Example 2:
    Input: heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]
    Output: [7,6,-1,4,6]
    Explanation: - In the first query, Alice can directly move to Bob's
                   building since heights[0] < heights[7].
                 - In the second query, Alice and Bob can move to building 6
                   since heights[3] < heights[6] and heights[5] < heights[6].
                 - In the third query, Alice cannot meet Bob since Bob cannot
                   move to any other building.
                 - In the fourth query, Alice and Bob can move to building 4
                   since heights[3] < heights[4] and heights[0] < heights[4].
                 - In the fifth query, Alice can directly move to Bob's
                   building since heights[1] < heights[6].
                 For ans[i] != -1, It can be shown that ans[i] is the leftmost
                 building where Alice and Bob can meet. For ans[i] == -1, It
                 can be shown that there is no building where Alice and Bob can
                 meet.

    Constraints:
    * 1 <= heights.length <= 5 * 10^4
    * 1 <= heights[i] <= 10^9
    * 1 <= queries.length <= 5 * 10^4
    * queries[i] = [ai, bi]
    * 0 <= ai, bi <= heights.length - 1*/

    vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {
        int m = heights.size(), n = queries.size();
        vector<vector<pair<int, int>>> qs(m);
        vector<int> ans(n, -1);
        for (int i = 0; i < n; ++i) {
            int a = queries[i][0], b = queries[i][1];
            if (a > b) swap(a, b);
            if (a == b || heights[a] < heights[b]) ans[i] = b;
            else qs[b].emplace_back(heights[a], i);
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        for (int k = 0; k < m; ++k) {
            while (pq.size() && pq.top().first < heights[k]) {
                auto [_, i] = pq.top(); pq.pop();
                ans[i] = k;
            }
            for (auto& elem : qs[k]) pq.emplace(elem);
        }
        return ans;
    }


    /*2942. Find Words Containing Character (Easy)
    You are given a 0-indexed array of strings words and a character x. Return
    an array of indices representing the words that contain the character x.
    Note that the returned array may be in any order.

    Example 1:
    Input: words = ["leet","code"], x = "e"
    Output: [0,1]
    Explanation: "e" occurs in both words: "leet", and "code". Hence, we return
                 indices 0 and 1.

    Example 2:
    Input: words = ["abc","bcd","aaaa","cbc"], x = "a"
    Output: [0,2]
    Explanation: "a" occurs in "abc", and "aaaa". Hence, we return indices 0 and
                 2.

    Example 3:
    Input: words = ["abc","bcd","aaaa","cbc"], x = "z"
    Output: []
    Explanation: "z" does not occur in any of the words. Hence, we return an
                 empty array.

    Constraints:
    * 1 <= words.length <= 50
    * 1 <= words[i].length <= 50
    * x is a lowercase English letter.
    * words[i] consists only of lowercase English letters.*/

    vector<int> findWordsContaining(vector<string>& words, char x) {
        vector<int> ans;
        for (int i = 0; i < words.size(); ++i)
            if (words[i].find(x) != string::npos) ans.push_back(i);
        return ans;
    }


    /*2946. Matrix Similarity After Cyclic Shifts (Easy)
    You are given a 0-indexed m x n integer matrix mat and an integer k. You
    have to cyclically right shift odd indexed rows k times and cyclically left
    shift even indexed rows k times. Return true if the initial and final
    matrix are exactly the same and false otherwise.

    Example 1:
    Input: mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2
    Output: true
    Explanation: Initially, the matrix looks like the first figure. Second
                 figure represents the state of the matrix after one right and
                 left cyclic shifts to even and odd indexed rows. Third figure
                 is the final state of the matrix after two cyclic shifts which
                 is similar to the initial matrix. Therefore, return true.

    Example 2:
    Input: mat = [[2,2],[2,2]], k = 3
    Output: true
    Explanation: As all the values are equal in the matrix, even after
                 performing cyclic shifts the matrix will remain the same.
                 Therefeore, we return true.

    Example 3:
    Input: mat = [[1,2]], k = 1
    Output: false
    Explanation: After one cyclic shift, mat = [[2,1]] which is not equal to
                 the initial matrix. Therefore we return false.

    Constraints:
    * 1 <= mat.length <= 25
    * 1 <= mat[i].length <= 25
    * 1 <= mat[i][j] <= 25
    * 1 <= k <= 50*/

    bool areSimilar(vector<vector<int>>& mat, int k) {
        for (auto& row : mat)
            for (int j = 0, n = row.size(); j < n; ++j)
                if (row[j] != row[(j+k)%n]) return false;
        return true;
    }


    /*2947. Count Beautiful Substrings I (Medium)
    You are given a string s and a positive integer k. Let vowels and
    consonants be the number of vowels and consonants in a string. A string is
    beautiful if:
    * vowels == consonants.
    * (vowels * consonants) % k == 0, in other terms the multiplication of
      vowels and consonants is divisible by k.
    Return the number of non-empty beautiful substrings in the given string s.
    A substring is a contiguous sequence of characters in a string. Vowel
    letters in English are 'a', 'e', 'i', 'o', and 'u'. Consonant letters in
    English are every letter except vowels.

    Example 1:
    Input: s = "baeyh", k = 2
    Output: 2
    Explanation: There are 2 beautiful substrings in the given string.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["y","h"]). You can see that string "aeyh"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["b","y"]). You can see that string "baey"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 It can be shown that there are only 2 beautiful substrings in
                 the given string.

    Example 2:
    Input: s = "abba", k = 1
    Output: 3
    Explanation: There are 3 beautiful substrings in the given string.
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 2 (["a","a"]),
                   consonants = 2 (["b","b"]).
                 It can be shown that there are only 3 beautiful substrings in
                 the given string.

    Example 3:
    Input: s = "bcdf", k = 1
    Output: 0
    Explanation: There are no beautiful substrings in the given string.

    Constraints:
    * 1 <= s.length <= 1000
    * 1 <= k <= 1000
    * s consists of only English lowercase letters.*/

    int beautifulSubstrings(string s, int k) {
        int ans = 0;
        for (int i = 0, n = s.size(); i < n; ++i) {
            int vowels = 0, consonants = 0;
            for (int j = i; j < n; ++j) {
                if (string("aeiou").find(s[j]) != string::npos) ++vowels;
                else ++consonants;
                if (vowels == consonants && vowels * consonants % k == 0) ++ans;
            }
        }
        return ans;
    }


    /*2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)
    You are given a 0-indexed array of positive integers nums and a positive
    integer limit. In one operation, you can choose any two indices i and j and
    swap nums[i] and nums[j] if |nums[i] - nums[j]| <= limit. Return the
    lexicographically smallest array that can be obtained by performing the
    operation any number of times. An array a is lexicographically smaller than
    an array b if in the first position where a and b differ, array a has an
    element that is less than the corresponding element in b. For example, the
    array [2,10,3] is lexicographically smaller than the array [10,2,3] because
    they differ at index 0 and 2 < 10.

    Example 1:
    Input: nums = [1,5,3,9,8], limit = 2
    Output: [1,3,5,8,9]
    Explanation: Apply the operation 2 times:
                 - Swap nums[1] with nums[2]. The array becomes [1,3,5,9,8]
                 - Swap nums[3] with nums[4]. The array becomes [1,3,5,8,9]
                 We cannot obtain a lexicographically smaller array by applying
                 any more operations. Note that it may be possible to get the
                 same result by doing different operations.

    Example 2:
    Input: nums = [1,7,6,18,2,1], limit = 3
    Output: [1,6,7,18,1,2]
    Explanation: Apply the operation 3 times:
                 - Swap nums[1] with nums[2]. The array becomes [1,6,7,18,2,1]
                 - Swap nums[0] with nums[4]. The array becomes [2,6,7,18,1,1]
                 - Swap nums[0] with nums[5]. The array becomes [1,6,7,18,1,2]
                 We cannot obtain a lexicographically smaller array by applying
                 any more operations.

    Example 3:
    Input: nums = [1,7,28,19,10], limit = 3
    Output: [1,7,28,19,10]
    Explanation: [1,7,28,19,10] is the lexicographically smallest array we can
                 obtain because we cannot apply the operation on any two
                 indices.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= limit <= 10^9*/

    vector<int> lexicographicallySmallestArray(vector<int>& nums, int limit) {
        vector<pair<int, int>> vals;
        for (int i = 0; i < nums.size(); ++i) vals.emplace_back(nums[i], i);
        sort(vals.begin(), vals.end());
        vector<int> idx;
        for (int k = 0, kk = 0, n = vals.size(); k < n; ++k) {
            auto& [x, i] = vals[k];
            idx.push_back(i);
            if (k == n-1 || x+limit < vals[k+1].first) {
                sort(idx.begin(), idx.end());
                for (int i = 0; i < idx.size(); ++i) nums[idx[i]] = vals[kk+i].first;
                idx.clear();
                kk = k+1;
            }
        }
        return nums;
    }


    /*2949. Count Beautiful Substrings II (Hard)
    You are given a string s and a positive integer k. Let vowels and
    consonants be the number of vowels and consonants in a string. A string is
    beautiful if:
    * vowels == consonants.
    * (vowels * consonants) % k == 0, in other terms the multiplication of
      vowels and consonants is divisible by k.
    Return the number of non-empty beautiful substrings in the given string s.
    A substring is a contiguous sequence of characters in a string. Vowel
    letters in English are 'a', 'e', 'i', 'o', and 'u'. Consonant letters in
    English are every letter except vowels.

    Example 1:
    Input: s = "baeyh", k = 2
    Output: 2
    Explanation: There are 2 beautiful substrings in the given string.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["y","h"]). You can see that string "aeyh"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["b","y"]). You can see that string "baey"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 It can be shown that there are only 2 beautiful substrings in
                 the given string.

    Example 2:
    Input: s = "abba", k = 1
    Output: 3
    Explanation: There are 3 beautiful substrings in the given string.
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 2 (["a","a"]), consonants = 2
                   (["b","b"]).
                 It can be shown that there are only 3 beautiful substrings in
                 the given string.

    Example 3:
    Input: s = "bcdf", k = 1
    Output: 0
    Explanation: There are no beautiful substrings in the given string.

    Constraints:
    * 1 <= s.length <= 5 * 10^4
    * 1 <= k <= 1000
    * s consists of only English lowercase letters.*/

    long long beautifulSubstrings(string s, int k) {
        int n = 1;
        for (; n <= k; ++n)
            if (n*n % k == 0) break;
        n *= 2;
        vector<unordered_map<int, int>> seen(n);
        seen[n-1][0] = 1;
        long long ans = 0;
        for (int i = 0, diff = 0; i < s.size(); ++i) {
            if (string("aeiou").find(s[i]) != string::npos) ++diff;
            else --diff;
            ans += seen[i % n][diff];
            ++seen[i % n][diff];
        }
        return ans;
    }


    /*2950. Number of Divisible Substrings (Medium)
    Each character of the English alphabet has been mapped to a digit as shown
    below. A string is divisible if the sum of the mapped values of its
    characters is divisible by its length. Given a string s, return the number
    of divisible substrings of s. A substring is a contiguous non-empty sequence
    of characters within a string.

    Example 1: Substring   Mapped  Sum Length  Divisible?
               a   1   1   1   Yes
               s   7   7   1   Yes
               d   2   2   1   Yes
               f   3   3   1   Yes
               as  1, 7    8   2   Yes
               sd  7, 2    9   2   No
               df  2, 3    5   2   No
               asd 1, 7, 2 10  3   No
               sdf 7, 2, 3 12  3   Yes
               asdf    1, 7, 2, 3  13  4   No
    Input: word = "asdf"
    Output: 6
    Explanation: The table above contains the details about every substring of
                 word, and we can see that 6 of them are divisible.

    Example 2:
    Input: word = "bdh"
    Output: 4
    Explanation: The 4 divisible substrings are: "b", "d", "h", "bdh". It can be
                 shown that there are no other substrings of word that are
                 divisible.

    Example 3:
    Input: word = "abcd"
    Output: 6
    Explanation: The 6 divisible substrings are: "a", "b", "c", "d", "ab", "cd".
                 It can be shown that there are no other substrings of word that
                 are divisible.

    Constraints:
    * 1 <= word.length <= 2000
    * word consists only of lowercase English letters.*/

    int countDivisibleSubstrings(string word) {
        int ans = 0;
        for (int k = 1; k <= 9; ++k) {
            int prefix = 0;
            unordered_map<int, int> freq = {{0, 1}};
            for (int i = 0; i < word.size(); ++i) {
                prefix += 2 + floor((word[i]-'a'-2)/3.);
                ans += freq[prefix-k*(i+1)];
                ++freq[prefix-k*(i+1)];
            }
        }
        return ans;
    }


    /*2955. Number of Same-End Substrings (Medium)
    You are given a 0-indexed string s, and a 2D array of integers queries,
    where queries[i] = [li, ri] indicates a substring of s starting from the
    index li and ending at the index ri (both inclusive), i.e. s[li..ri]. Return
    an array ans where ans[i] is the number of same-end substrings of queries[i].
    A 0-indexed string t of length n is called same-end if it has the same
    character at both of its ends, i.e., t[0] == t[n - 1]. A substring is a
    contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: s = "abcaab", queries = [[0,0],[1,4],[2,5],[0,5]]
    Output: [1,5,5,10]
    Explanation: Here is the same-end substrings of each query:
                 - 1st query: s[0..0] is "a" which has 1 same-end substring: "a".
                 - 2nd query: s[1..4] is "bcaa" which has 5 same-end substrings:
                   "bcaa", "bcaa", "bcaa", "bcaa", "bcaa".
                 - 3rd query: s[2..5] is "caab" which has 5 same-end substrings:
                   "caab", "caab", "caab", "caab", "caab".
                 - 4th query: s[0..5] is "abcaab" which has 10 same-end
                   substrings: "abcaab", "abcaab", "abcaab", "abcaab", "abcaab",
                   "abcaab", "abcaab", "abcaab", "abcaab", "abcaab".

    Example 2:
    Input: s = "abcd", queries = [[0,3]]
    Output: [4]
    Explanation: The only query is s[0..3] which is "abcd". It has 4 same-end
                 substrings: "abcd", "abcd", "abcd", "abcd".

    Constraints:
    * 2 <= s.length <= 3 * 10^4
    * s consists only of lowercase English letters.
    * 1 <= queries.length <= 3 * 10^4
    * queries[i] = [li, ri]
    * 0 <= li <= ri < s.length*/

    vector<int> sameEndSubstringCount(string s, vector<vector<int>>& queries) {
        vector<int> ans(queries.size());
        for (auto& c : string("abcdefghijklmnopqrstuvwxyz")) {
            vector<int> prefix(1, 0);
            for (auto& ch : s) {
                prefix.push_back(prefix.back());
                if (ch == c) ++prefix.back();
            }
            for (int i = 0; i < queries.size(); ++i) {
                int l = queries[i][0], r = queries[i][1], diff = prefix[r+1] - prefix[l];
                ans[i] += diff*(diff+1)/2;
            }
        }
        return ans;
    }


    /*2956. Find Common Elements Between Two Arrays (Easy)
    You are given two 0-indexed integer arrays nums1 and nums2 of sizes n and m,
    respectively. Consider calculating the following values:
    * The number of indices i such that 0 <= i < n and nums1[i] occurs at least
      once in nums2.
    * The number of indices i such that 0 <= i < m and nums2[i] occurs at least
      once in nums1.
    Return an integer array answer of size 2 containing the two values in the
    above order.

    Example 1:
    Input: nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]
    Output: [3,4]
    Explanation: We calculate the values as follows:
                 - The elements at indices 1, 2, and 3 in nums1 occur at least
                   once in nums2. So the first value is 3.
                 - The elements at indices 0, 1, 3, and 4 in nums2 occur at
                   least once in nums1. So the second value is 4.

    Example 2:
    Input: nums1 = [3,4,2,3], nums2 = [1,5]
    Output: [0,0]
    Explanation: There are no common elements between the two arrays, so the two
                 values will be 0.

    Constraints:
    * n == nums1.length
    * m == nums2.length
    * 1 <= n, m <= 100
    * 1 <= nums1[i], nums2[i] <= 100*/

    vector<int> findIntersectionValues(vector<int>& nums1, vector<int>& nums2) {
        vector<int> ans = {0, 0};
        for (auto& x : nums1)
            if (find(nums2.begin(), nums2.end(), x) != nums2.end()) ++ans[0];
        for (auto& x : nums2)
            if (find(nums1.begin(), nums1.end(), x) != nums1.end()) ++ans[1];
        return ans;
    }


    /*2957. Remove Adjacent Almost-Equal Characters (Medium)
    You are given a 0-indexed string word. In one operation, you can pick any
    index i of word and change word[i] to any lowercase English letter. Return
    the minimum number of operations needed to remove all adjacent almost-equal
    characters from word. Two characters a and b are almost-equal if a == b or
    a and b are adjacent in the alphabet.

    Example 1:
    Input: word = "aaaaa"
    Output: 2
    Explanation: We can change word into "acaca" which does not have any
                 adjacent almost-equal characters. It can be shown that the
                 minimum number of operations needed to remove all adjacent
                 almost-equal characters from word is 2.

    Example 2:
    Input: word = "abddez"
    Output: 2
    Explanation: We can change word into "ybdoez" which does not have any
                 adjacent almost-equal characters. It can be shown that the
                 minimum number of operations needed to remove all adjacent
                 almost-equal characters from word is 2.

    Example 3:
    Input: word = "zyxyxyz"
    Output: 3
    Explanation: We can change word into "zaxaxaz" which does not have any
                 adjacent almost-equal characters. It can be shown that the
                 minimum number of operations needed to remove all adjacent
                 almost-equal characters from word is 3.

    Constraints:
    * 1 <= word.length <= 100
    * word consists only of lowercase English letters.*/

    int removeAlmostEqualCharacters(string word) {
        int ans = 0;
        for (int i = 0; i < word.size(); ++i)
            if (i && abs(word[i]-word[i-1]) <= 1) ++ans, ++i;
        return ans;
    }


    /*2958. Length of Longest Subarray With at Most K Frequency (Medium)
    You are given an integer array nums and an integer k. The frequency of an
    element x is the number of times it occurs in an array. An array is called
    good if the frequency of each element in this array is less than or equal to
    k. Return the length of the longest good subarray of nums. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,3,1,2,3,1,2], k = 2
    Output: 6
    Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the
                 values 1, 2, and 3 occur at most twice in this subarray. Note
                 that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also
                 good. It can be shown that there are no good subarrays with
                 length more than 6.

    Example 2:
    Input: nums = [1,2,1,2,1,2,1,2], k = 1
    Output: 2
    Explanation: The longest possible good subarray is [1,2] since the values 1
                 and 2 occur at most once in this subarray. Note that the
                 subarray [2,1] is also good. It can be shown that there are no
                 good subarrays with length more than 2.

    Example 3:
    Input: nums = [5,5,5,5,5,5,5], k = 4
    Output: 4
    Explanation: The longest possible good subarray is [5,5,5,5] since the value
                 5 occurs 4 times in this subarray. It can be shown that there
                 are no good subarrays with length more than 4.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= nums.length*/

    int maxSubarrayLength(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        int ans = 0;
        for (int i = 0, ii = 0; i < nums.size(); ++i) {
            ++freq[nums[i]];
            while (freq[nums[i]] > k) --freq[nums[ii++]];
            ans = max(ans, i-ii+1);
        }
        return ans;
    }


    /*2959. Number of Possible Sets of Closing Branches (Hard)
    There is a company with n branches across the country, some of which are
    connected by roads. Initially, all branches are reachable from each other by
    traveling some roads. The company has realized that they are spending an
    excessive amount of time traveling between their branches. As a result, they
    have decided to close down some of these branches (possibly none). However,
    they want to ensure that the remaining branches have a distance of at most
    maxDistance from each other. The distance between two branches is the
    minimum total traveled length needed to reach one branch from another. You
    are given integers n, maxDistance, and a 0-indexed 2D array roads, where
    roads[i] = [ui, vi, wi] represents the undirected road between branches ui
    and vi with length wi. Return the number of possible sets of closing
    branches, so that any branch has a distance of at most maxDistance from any
    other. Note that, after closing a branch, the company will no longer have
    access to any roads connected to it. Note that, multiple roads are allowed.

    Example 1:
    Input: n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]
    Output: 5
    Explanation: The possible sets of closing branches are:
                 - The set [2], after closing, active branches are [0,1] and
                   they are reachable to each other within distance 2.
                 - The set [0,1], after closing, the active branch is [2].
                 - The set [1,2], after closing, the active branch is [0].
                 - The set [0,2], after closing, the active branch is [1].
                 - The set [0,1,2], after closing, there are no active branches.
                 It can be proven, that there are only 5 possible sets of
                 closing branches.

    Example 2:
    Input: n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]
    Output: 7
    Explanation: The possible sets of closing branches are:
                 - The set [], after closing, active branches are [0,1,2] and
                   they are reachable to each other within distance 4.
                 - The set [0], after closing, active branches are [1,2] and
                   they are reachable to each other within distance 2.
                 - The set [1], after closing, active branches are [0,2] and
                   they are reachable to each other within distance 2.
                 - The set [0,1], after closing, the active branch is [2].
                 - The set [1,2], after closing, the active branch is [0].
                 - The set [0,2], after closing, the active branch is [1].
                 - The set [0,1,2], after closing, there are no active branches.
                 It can be proven, that there are only 7 possible sets of
                 closing branches.

    Example 3:
    Input: n = 1, maxDistance = 10, roads = []
    Output: 2
    Explanation: The possible sets of closing branches are:
                 - The set [], after closing, the active branch is [0].
                 - The set [0], after closing, there are no active branches.
                 It can be proven, that there are only 2 possible sets of
                 closing branches.

    Constraints:
    * 1 <= n <= 10
    * 1 <= maxDistance <= 10^5
    * 0 <= roads.length <= 1000
    * roads[i].length == 3
    * 0 <= ui, vi <= n - 1
    * ui != vi
    * 1 <= wi <= 1000
    * All branches are reachable from each other by traveling some roads.*/

    int numberOfSets(int n, int maxDistance, vector<vector<int>>& roads) {
        int ans = 0;
        for (int m = 0; m < 1<<n; ++m) {
            vector<vector<int>> dist(n, vector<int>(n, 1e6));
            for (int u = 0; u < n; ++u)
                if (m & 1<<u) dist[u][u] = 0;
            for (auto& road : roads) {
                int u = road[0], v = road[1], w = road[2];
                if (m & 1<<u && m & 1<<v)
                    dist[u][v] = dist[v][u] = min(dist[u][v], w);
            }
            for (int k = 0; k < n; ++k)
                for (int u = 0; u < n; ++u)
                    for (int v = 0; v < n; ++v)
                        dist[u][v] = min(dist[u][v], dist[u][k] + dist[k][v]);
            bool found = false;
            for (int u = 0; u < n; ++u)
                if (m & 1<<u)
                    for (int v = 0; v < n; ++v)
                        if (m & 1<<v && dist[u][v] > maxDistance) found = true;
            if (!found) ++ans;
        }
        return ans;
    }


    /*2960. Count Tested Devices After Test Operations (Easy)
    You are given a 0-indexed integer array batteryPercentages having length n,
    denoting the battery percentages of n 0-indexed devices. Your task is to
    test each device i in order from 0 to n - 1, by performing the following
    test operations:
    * If batteryPercentages[i] is greater than 0:
      + Increment the count of tested devices.
      + Decrease the battery percentage of all devices with indices j in the
        range [i + 1, n - 1] by 1, ensuring their battery percentage never goes
        below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).
      + Move to the next device.
    * Otherwise, move to the next device without performing any test.
    Return an integer denoting the number of devices that will be tested after
    performing the test operations in order.

    Example 1:
    Input: batteryPercentages = [1,1,2,1,3]
    Output: 3
    Explanation: Performing the test operations in order starting from device 0:
                 - At device 1, batteryPercentages [1] == 0, so we move to the
                   next device without testing.
                 - At device 2, batteryPercentages[2] > 0, so there are now 2
                   tested devices, and batteryPercentages becomes [1,0,1,0,1].
                 - At device 3, batteryPercentages [3] == 0, so we move to the
                   next device without testing.
                 - At device 0, batteryPercentages[0] > 0, so there is now 1
                   tested device, and batteryPercentages becomes [1,0,1,0,2].
                 - At device 4, batteryPercentages[4] > 0, so there are now 3
                   tested devices, and batteryPercentages stays the same.
                 So, the answer is 3.

    Example 2:
    Input: batteryPercentages = [0,1,2]
    Output: 2
    Explanation: Performing the test operations in order starting from device 0:
                 - At device 0, batteryPercentages[0] == 0, so we move to the
                   next device without testing.
                 - At device 1, batteryPercentages[1] > 0, so there is now 1
                   tested device, and batteryPercentages becomes [0,1,1].
                 - At device 2, batteryPercentages [2] > 0, so there are now 2
                   tested devices, and batteryPercentages stays the same.
                 So, the answer is 2.

    Constraints:
    * 1 <= n == batteryPercentages.length <= 100
    * 0 <= batteryPercentages[i] <= 100*/

    int countTestedDevices(vector<int>& batteryPercentages) {
        int ans = 0;
        for (auto & x : batteryPercentages)
            if (ans < x) ++ans;
        return ans;
    }


    /*2961. Double Modular Exponentiation (Medium)
    You are given a 0-indexed 2D array variables where
    variables[i] = [ai, bi, ci, mi], and an integer target. An index i is good
    if the following formula holds:
    * 0 <= i < variables.length
    * ((aibi % 10)ci) % mi == target
    Return an array consisting of good indices in any order.

    Example 1:
    Input: variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2
    Output: [0,2]
    Explanation: For each index i in the variables array:
                 1) For the index 0, variables[0] = [2,3,3,10],
                    (23 % 10)3 % 10 = 2.
                 2) For the index 1, variables[1] = [3,3,3,1],
                    (33 % 10)3 % 1 = 0.
                 3) For the index 2, variables[2] = [6,1,1,4],
                    (61 % 10)1 % 4 = 2.
                 Therefore we return [0,2] as the answer.

    Example 2:
    Input: variables = [[39,3,1000,1000]], target = 17
    Output: []
    Explanation: For each index i in the variables array:
                 1) For the index 0, variables[0] = [39,3,1000,1000],
                    (393 % 10)1000 % 1000 = 1.
                 Therefore we return [] as the answer.

    Constraints:
    * 1 <= variables.length <= 100
    * variables[i] == [ai, bi, ci, mi]
    * 1 <= ai, bi, ci, mi <= 10^3
    * 0 <= target <= 10^3*/

    vector<int> getGoodIndices(vector<vector<int>>& variables, int target) {
        vector<int> ans;

        auto pow = [&](long x, int p, int m) {
            long ans = 1;
            for (; p; p >>= 1) {
                if (p & 1) ans = ans * x % m;
                x = x * x % m;
            }
            return ans;
        };

        for (int i = 0; i < variables.size(); ++i) {
            int a = variables[i][0], b = variables[i][1], c = variables[i][2], m = variables[i][3];
            if (pow(pow(a, b, 10), c, m) == target) ans.push_back(i);
        }
        return ans;
    }


    /*2962. Count Subarrays Where Max Element Appears at Least K Times (Meidum)
    You are given an integer array nums and a positive integer k. Return the
    number of subarrays where the maximum element of nums appears at least k
    times in that subarray. A subarray is a contiguous sequence of elements
    within an array.

    Example 1:
    Input: nums = [1,3,2,3,3], k = 2
    Output: 6
    Explanation: The subarrays that contain the element 3 at least 2 times are:
                 [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].

    Example 2:
    Input: nums = [1,4,2,1], k = 3
    Output: 0
    Explanation: No subarray contains the element 4 at least 3 times.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6
    * 1 <= k <= 10^5*/

    long long countSubarrays(vector<int>& nums, int k) {
        long long ans = 0;
        int m = *max_element(nums.begin(), nums.end()), ii = 0, freq = 0;
        for (auto& x : nums) {
            if (x == m) ++freq;
            while (freq == k)
                if (nums[ii++] == m) --freq;
            ans += ii;
        }
        return ans;
    }


    /*2963. Count the Number of Good Partitions (Hard)
    You are given a 0-indexed array nums consisting of positive integers. A
    partition of an array into one or more contiguous subarrays is called good
    if no two subarrays contain the same number. Return the total number of good
    partitions of nums. Since the answer may be large, return it modulo
    10^9 + 7.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 8
    Explanation: The 8 possible good partitions are: ([1], [2], [3], [4]),
                 ([1], [2], [3,4]), ([1], [2,3], [4]), ([1], [2,3,4]),
                 ([1,2], [3], [4]), ([1,2], [3,4]), ([1,2,3], [4]), and
                 ([1,2,3,4]).

    Example 2:
    Input: nums = [1,1,1,1]
    Output: 1
    Explanation: The only possible good partition is: ([1,1,1,1]).

    Example 3:
    Input: nums = [1,2,1,3]
    Output: 2
    Explanation: The 2 possible good partitions are: ([1,2,1], [3]) and
                 ([1,2,1,3]).

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int numberOfGoodPartitions(vector<int>& nums) {
        const int mod = 1'000'000'007;
        unordered_map<int, int> last;
        for (int i = 0; i < nums.size(); ++i) last[nums[i]] = i;
        long ans = 1;
        for (int i = 0, ii = 0; i < nums.size(); ++i) {
            if (ii < i) ans = ans * 2 % mod;
            ii = max(ii, last[nums[i]]);
        }
        return ans;
    }


    /*2964. Number of Divisible Triplet Sums (Medium)
    Given a 0-indexed integer array nums and an integer d, return the number of
    triplets (i, j, k) such that i < j < k and
    (nums[i] + nums[j] + nums[k]) % d == 0.

    Example 1:
    Input: nums = [3,3,4,7,8], d = 5
    Output: 3
    Explanation: The triplets which are divisible by 5 are: (0, 1, 2),
                 (0, 2, 4), (1, 2, 4). It can be shown that no other triplet is
                 divisible by 5. Hence, the answer is 3.

    Example 2:
    Input: nums = [3,3,3,3], d = 3
    Output: 4
    Explanation: Any triplet chosen here has a sum of 9, which is divisible by
                 3. Hence, the answer is the total number of triplets which is 4.

    Example 3:
    Input: nums = [3,3,3,3], d = 6
    Output: 0
    Explanation: Any triplet chosen here has a sum of 9, which is not divisible
                 by 6. Hence, the answer is 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^9
    * 1 <= d <= 10^9*/

    int divisibleTripletCount(vector<int>& nums, int d) {
        int ans = 0;
        for (int i = 0, n = nums.size(); i < n; ++i) {
            unordered_map<int, int> freq;
            for (int ii = i+1; ii < n; ++ii) {
                ans += freq[(d - nums[ii]%d) % d];
                ++freq[(nums[i] + nums[ii]) % d];
            }
        }
        return ans;
    }


    /*2965. Find Missing and Repeated Values (Easy)
    You are given a 0-indexed 2D integer matrix grid of size n * n with values
    in the range [1, n2]. Each integer appears exactly once except a which
    appears twice and b which is missing. The task is to find the repeating and
    missing numbers a and b. Return a 0-indexed integer array ans of size 2
    where ans[0] equals to a and ans[1] equals to b.

    Example 1:
    Input: grid = [[1,3],[2,2]]
    Output: [2,4]
    Explanation: Number 2 is repeated and number 4 is missing so the answer is
                 [2,4].

    Example 2:
    Input: grid = [[9,1,7],[8,9,2],[3,4,6]]
    Output: [9,5]
    Explanation: Number 9 is repeated and number 5 is missing so the answer is
                 [9,5].

    Constraints:
    * 2 <= n == grid.length == grid[i].length <= 50
    * 1 <= grid[i][j] <= n * n
    * For all x that 1 <= x <= n * n there is exactly one x that is not equal to
      any of the grid members.
    * For all x that 1 <= x <= n * n there is exactly one x that is equal to
      exactly two of the grid members.
    * For all x that 1 <= x <= n * n except two of them there is exatly one pair
      of i, j that 0 <= i, j <= n - 1 and grid[i][j] == x.*/

    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {
        long s = 0, s2 = 0, n = grid.size()*grid.size();
        for (auto& row : grid)
            for (auto& x : row) {
                s += x;
                s2 += x*x;
            }
        int diff = s - n*(n+1)/2, total = (s2 - n*(n+1)*(2*n+1)/6) / diff;
        return {(total+diff)/2, (total-diff)/2};
    }


    /*2966. Divide Array Into Arrays With Max Difference (Medium)
    You are given an integer array nums of size n and a positive integer k.
    Divide the array into one or more arrays of size 3 satisfying the following
    conditions:
    * Each element of nums should be in exactly one array.
    * The difference between any two elements in one array is less than or equal
      to k.
    Return a 2D array containing all the arrays. If it is impossible to satisfy
    the conditions, return an empty array. And if there are multiple answers,
    return any of them.

    Example 1:
    Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
    Output: [[1,1,3],[3,4,5],[7,8,9]]
    Explanation: We can divide the array into the following arrays: [1,1,3],
                 [3,4,5] and [7,8,9]. The difference between any two elements in
                 each array is less than or equal to 2. Note that the order of
                 elements is not important.

    Example 2:
    Input: nums = [1,3,3,2,7,3], k = 3
    Output: []
    Explanation: It is not possible to divide the array satisfying all the
                 conditions.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * n is a multiple of 3.
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= 10^5*/

    vector<vector<int>> divideArray(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        for (int i = 2; i < nums.size(); i += 3) {
            if (nums[i] - nums[i-2] > k) return {};
            ans.push_back({nums[i-2], nums[i-1], nums[i]});
        }
        return ans;
    }


    /*2967. Minimum Cost to Make Array Equalindromic (Medium)
    You are given a 0-indexed integer array nums having length n. You are
    allowed to perform a special move any number of times (including zero) on
    nums. In one special move you perform the following steps in order:
    * Choose an index i in the range [0, n - 1], and a positive integer x.
    * Add |nums[i] - x| to the total cost.
    * Change the value of nums[i] to x.
    A palindromic number is a positive integer that remains the same when its
    digits are reversed. For example, 121, 2552 and 65756 are palindromic
    numbers whereas 24, 46, 235 are not palindromic numbers. An array is
    considered equalindromic if all the elements in the array are equal to an
    integer y, where y is a palindromic number less than 10^9. Return an integer
    denoting the minimum possible total cost to make nums equalindromic by
    performing any number of special moves.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 6
    Explanation: We can make the array equalindromic by changing all elements to
                 3 which is a palindromic number. The cost of changing the array
                 to [3,3,3,3,3] using 4 special moves is given by
                 |1 - 3| + |2 - 3| + |4 - 3| + |5 - 3| = 6. It can be shown that
                 changing all elements to any palindromic number other than 3
                 cannot be achieved at a lower cost.

    Example 2:
    Input: nums = [10,12,13,14,15]
    Output: 11
    Explanation: We can make the array equalindromic by changing all elements to
                 11 which is a palindromic number. The cost of changing the
                 array to [11,11,11,11,11] using 5 special moves is given by
                 |10 - 11| + |12 - 11| + |13 - 11| + |14 - 11| + |15 - 11| = 11.
                 It can be shown that changing all elements to any palindromic
                 number other than 11 cannot be achieved at a lower cost.

    Example 3:
    Input: nums = [22,33,22,33,22]
    Output: 22
    Explanation: We can make the array equalindromic by changing all elements to
                 22 which is a palindromic number. The cost of changing the
                 array to [22,22,22,22,22] using 2 special moves is given by
                 |33 - 22| + |33 - 22| = 22. It can be shown that changing all
                 elements to any palindromic number other than 22 cannot be
                 achieved at a lower cost.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= 10^9*/

    long long minimumCost(vector<int>& nums) {
        int sz = nums.size();
        nth_element(nums.begin(), nums.begin() + sz/2, nums.end());
        int median = nums[sz/2];
        string digits = to_string(median);
        int n = digits.size();
        string h = digits.substr(0, (n+1)/2), hh = h;
        reverse(hh.begin(), hh.end());
        int val = stoi(h + hh.substr(n&1)), cand = 0;

        auto fn = [&](auto v) {
            return accumulate(nums.begin(), nums.end(), 0ll, [&](auto x, auto y) { return x + abs(v-y); });
        };

        long long ans = fn(val);
        if (val < median) {
            string t = to_string(stoi(h)+1), tt = t;
            reverse(tt.begin(), tt.end());
            if (t.size() > (n+1)/2) cand = val + 2;
            else cand = stoi(t + tt.substr(n&1));
            ans = min(ans, fn(cand));
        } else if (val > median) {
            string t = to_string(stoi(h)-1), tt = t;
            reverse(tt.begin(), tt.end());
            if (t.size() < (n+1)/2 || t == "0" && val > 10) cand = val - 2;
            else cand = stoi(t + tt.substr(n&1));
            ans = min(ans, fn(cand));
        }
        return ans;
    }


    /*2968. Apply Operations to Maximize Frequency Score (Hard)
    You are given a 0-indexed integer array nums and an integer k. You can
    perform the following operation on the array at most k times:
    * Choose any index i from the array and increase or decrease nums[i] by 1.
    The score of the final array is the frequency of the most frequent element
    in the array. Return the maximum score you can achieve. The frequency of an
    element is the number of occurences of that element in the array.

    Example 1:
    Input: nums = [1,2,6,4], k = 3
    Output: 3
    Explanation: We can do the following operations on the array:
                 - Choose i = 0, and increase the value of nums[0] by 1. The
                   resulting array is [2,2,6,4].
                 - Choose i = 3, and decrease the value of nums[3] by 1. The
                   resulting array is [2,2,6,3].
                 - Choose i = 3, and decrease the value of nums[3] by 1. The
                   resulting array is [2,2,6,2].
                 The element 2 is the most frequent in the final array so our
                 score is 3. It can be shown that we cannot achieve a better
                 score.

    Example 2:
    Input: nums = [1,4,4,2,4], k = 0
    Output: 3
    Explanation: We cannot apply any operations so our score will be the
                 frequency of the most frequent element in the original array,
                 which is 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= 10^14*/

    int maxFrequencyScore(vector<int>& nums, long long k) {
        sort(nums.begin(), nums.end());
        int ii = 0;
        for (int i = 0; i < nums.size(); ++i) {
            k -= nums[i] - nums[(ii+i)/2];
            if (k < 0)
                k += nums[(ii+i+1)/2] - nums[ii++];
        }
        return nums.size()-ii;
    }


    /*2971. Find Polygon With the Largest Perimeter (Medium)
    You are given an array of positive integers nums of length n. A polygon is a
    closed plane figure that has at least 3 sides. The longest side of a polygon
    is smaller than the sum of its other sides. Conversely, if you have k
    (k >= 3) positive real numbers a1, a2, a3, ..., ak where
    a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there
    always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.
    The perimeter of a polygon is the sum of lengths of its sides. Return the
    largest possible perimeter of a polygon whose sides can be formed from nums,
    or -1 if it is not possible to create a polygon.

    Example 1:
    Input: nums = [5,5,5]
    Output: 15
    Explanation: The only possible polygon that can be made from nums has 3
                 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.

    Example 2:
    Input: nums = [1,12,1,2,5,50,3]
    Output: 12
    Explanation: The polygon with the largest perimeter which can be made from
                 nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is
                 1 + 1 + 2 + 3 + 5 = 12. We cannot have a polygon with either 12
                 or 50 as the longest side because it is not possible to include
                 2 or more smaller sides that have a greater sum than either of
                 them. It can be shown that the largest possible perimeter is 12.

    Example 3:
    Input: nums = [5,5,50]
    Output: -1
    Explanation: There is no possible way to form a polygon from nums, as a
                 polygon has at least 3 sides and 50 > 5 + 5.

    Constraints:
    * 3 <= n <= 10^5
    * 1 <= nums[i] <= 10^9*/

    long long largestPerimeter(vector<int>& nums) {
        long long ans = -1, prefix = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); ++i) {
            if (i >= 2 && prefix > nums[i]) ans = max(ans, prefix + nums[i]);
            prefix += nums[i];
        }
        return ans;
    }


    /*2979. Most Expensive Item That Can Not Be Bought (Medium)
    You are given two distinct prime numbers primeOne and primeTwo. Alice and
    Bob are visiting a market. The market has an infinite number of items, for
    any positive integer x there exists an item whose price is x. Alice wants to
    buy some items from the market to gift to Bob. She has an infinite number of
    coins in the denomination primeOne and primeTwo. She wants to know the most
    expensive item she can not buy to gift to Bob. Return the price of the most
    expensive item which Alice can not gift to Bob.

    Example 1:
    Input: primeOne = 2, primeTwo = 5
    Output: 3
    Explanation: The prices of items which cannot be bought are [1,3]. It can be
                 shown that all items with a price greater than 3 can be bought
                 using a combination of coins of denominations 2 and 5.

    Example 2:
    Input: primeOne = 5, primeTwo = 7
    Output: 23
    Explanation: The prices of items which cannot be bought are
                 [1,2,3,4,6,8,9,11,13,16,18,23]. It can be shown that all items
                 with a price greater than 23 can be bought.

    Constraints:
    * 1 < primeOne, primeTwo < 10^4
    * primeOne, primeTwo are prime numbers.
    * primeOne * primeTwo < 10^5*/

    int mostExpensiveItem(int primeOne, int primeTwo) {
        return primeOne * primeTwo - primeOne - primeTwo;
    }


    /*2992. Number of Self-Divisible Permutations (Medium)
    Given an integer n, return the number of permutations of the 1-indexed array
    nums = [1, 2, ..., n], such that it's self-divisible. A 1-indexed array a of
    length n is self-divisible if for every 1 <= i <= n, gcd(a[i], i) == 1. A
    permutation of an array is a rearrangement of the elements of that array,
    for example here are all of the permutations of the array [1, 2, 3]:
    * [1, 2, 3]
    * [1, 3, 2]
    * [2, 1, 3]
    * [2, 3, 1]
    * [3, 1, 2]
    * [3, 2, 1]

    Example 1:
    Input: n = 1
    Output: 1
    Explanation: The array [1] has only 1 permutation which is self-divisible.

    Example 2:
    Input: n = 2
    Output: 1
    Explanation: The array [1,2] has 2 permutations and only one of them is
                 self-divisible:
                 * nums = [1,2]: This is not self-divisible since
                   gcd(nums[2], 2) != 1.
                 * nums = [2,1]: This is self-divisible since
                   gcd(nums[1], 1) == 1 and gcd(nums[2], 2) == 1.

    Example 3:
    Input: n = 3
    Output: 3
    Explanation: The array [1,2,3] has 3 self-divisble permutations: [1,3,2],
                 [3,1,2], [2,3,1]. It can be shown that the other 3 permutations
                 are not self-divisible. Hence the answer is 3.

    Constraints: 1 <= n <= 12*/

    int selfDivisiblePermutationCount(int n) {
        vector<vector<int>> memo(n+1, vector<int>(1<<n, -1));

        function<int(int, int)> fn = [&](int i, int m) {
            if (memo[i][m] == -1)
                if (i == n) memo[i][m] = 1;
                else {
                    memo[i][m] = 0;
                    for (int x = 0; x < n; ++x)
                        if ((m & 1<<x) == 0 && gcd(i+1, x+1) == 1)
                            memo[i][m] += fn(i+1, m ^ 1<<x);
                }
            return memo[i][m];
        };

        return fn(0, 0);
    }


    /*2996. Smallest Missing Integer Greater Than Sequential Prefix Sum (Easy)
    You are given a 0-indexed array of integers nums. A prefix nums[0..i] is
    sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In
    particular, the prefix consisting only of nums[0] is sequential. Return the
    smallest integer x missing from nums such that x is greater than or equal to
    the sum of the longest sequential prefix.

    Example 1:
    Input: nums = [1,2,3,2,5]
    Output: 6
    Explanation: The longest sequential prefix of nums is [1,2,3] with a sum of
                 6. 6 is not in the array, therefore 6 is the smallest missing
                 integer greater than or equal to the sum of the longest
                 sequential prefix.

    Example 2:
    Input: nums = [3,4,5,1,12,14,13]
    Output: 15
    Explanation: The longest sequential prefix of nums is [3,4,5] with a sum of
                 12. 12, 13, and 14 belong to the array while 15 does not.
                 Therefore 15 is the smallest missing integer greater than or
                 equal to the sum of the longest sequential prefix.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50*/

    int missingInteger(vector<int>& nums) {
        int prefix = 0;
        for (int i = 0; i < nums.size() && (i == 0 || nums[i] == 1 + nums[i-1]); ++i)
            prefix += nums[i];
        unordered_set<int> seen(nums.begin(), nums.end());
        while (seen.find(prefix) != seen.end()) ++prefix;
        return prefix;
    }


    /*2997. Minimum Number of Operations to Make Array XOR Equal to K (Medium)
    You are given a 0-indexed integer array nums and a positive integer k. You
    can apply the following operation on the array any number of times:
    * Choose any element of the array and flip a bit in its binary
      representation. Flipping a bit means changing a 0 to 1 or vice versa.
    Return the minimum number of operations required to make the bitwise XOR of
    all elements of the final array equal to k. Note that you can flip leading
    zero bits in the binary representation of elements. For example, for the
    number (101)2 you can flip the fourth bit and obtain (1101)2.

    Example 1:
    Input: nums = [2,1,3,4], k = 1
    Output: 2
    Explanation: We can do the following operations:
                 - Choose element 2 which is 3 == (011)2, we flip the first bit
                   and we obtain (010)2 == 2. nums becomes [2,1,2,4].
                 - Choose element 0 which is 2 == (010)2, we flip the third bit
                   and we obtain (110)2 = 6. nums becomes [6,1,2,4].
                 The XOR of elements of the final array is
                 (6 XOR 1 XOR 2 XOR 4) == 1 == k. It can be shown that we cannot
                 make the XOR equal to k in less than 2 operations.

    Example 2:
    Input: nums = [2,0,2,0], k = 0
    Output: 0
    Explanation: The XOR of elements of the array is
                 (2 XOR 0 XOR 2 XOR 0) == 0 == k. So no operation is needed.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6
    * 0 <= k <= 10^6*/

    int minOperations(vector<int>& nums, int k) {
        return __builtin_popcount(reduce(begin(nums), end(nums), k, bit_xor<>()));
    }


    /*2998. Minimum Number of Operations to Make X and Y Equal (Medium)
    You are given two positive integers x and y. In one operation, you can do
    one of the four following operations:
    * Divide x by 11 if x is a multiple of 11.
    * Divide x by 5 if x is a multiple of 5.
    * Decrement x by 1.
    * Increment x by 1.
    Return the minimum number of operations required to make x and y equal.

    Example 1:
    Input: x = 26, y = 1
    Output: 3
    Explanation: We can make 26 equal to 1 by applying the following operations:
                 1. Decrement x by 1
                 2. Divide x by 5
                 3. Divide x by 5
                 It can be shown that 3 is the minimum number of operations
                 required to make 26 equal to 1.

    Example 2:
    Input: x = 54, y = 2
    Output: 4
    Explanation: We can make 54 equal to 2 by applying the following operations:
                 1. Increment x by 1
                 2. Divide x by 11
                 3. Divide x by 5
                 4. Increment x by 1
                 It can be shown that 4 is the minimum number of operations
                 required to make 54 equal to 2.

    Example 3:
    Input: x = 25, y = 30
    Output: 5
    Explanation: We can make 25 equal to 30 by applying the following operations:
                 1. Increment x by 1
                 2. Increment x by 1
                 3. Increment x by 1
                 4. Increment x by 1
                 5. Increment x by 1
                 It can be shown that 5 is the minimum number of operations
                 required to make 25 equal to 30.

    Constraints: 1 <= x, y <= 10^4*/

    int minimumOperationsToMakeEqual(int x, int y) {
        if (x <= y) return y - x;
        int ans = x - y;
        for (auto& v : {5, 11}) {
            ans = min(ans, minimumOperationsToMakeEqual(x/v, y) + 1 + x % v);
            ans = min(ans, minimumOperationsToMakeEqual(x/v + 1, y) + 1 + v - x % v);
        }
        return ans;
    }


    /*2999. Count the Number of Powerful Integers (Hard)
    You are given three integers start, finish, and limit. You are also given a
    0-indexed string s representing a positive integer. A positive integer x is
    called powerful if it ends with s (in other words, s is a suffix of x) and
    each digit in x is at most limit. Return the total number of powerful
    integers in the range [start..finish]. A string x is a suffix of a string y
    if and only if x is a substring of y that starts from some index (including
    0) in y and extends to the index y.length - 1. For example, 25 is a suffix
    of 5125 whereas 512 is not.

    Example 1:
    Input: start = 1, finish = 6000, limit = 4, s = "124"
    Output: 5
    Explanation: The powerful integers in the range [1..6000] are 124, 1124,
                 2124, 3124, and, 4124. All these integers have each digit <= 4,
                 and "124" as a suffix. Note that 5124 is not a powerful integer
                 because the first digit is 5 which is greater than 4. It can be
                 shown that there are only 5 powerful integers in this range.

    Example 2:
    Input: start = 15, finish = 215, limit = 6, s = "10"
    Output: 2
    Explanation: The powerful integers in the range [15..215] are 110 and 210.
                 All these integers have each digit <= 6, and "10" as a suffix.
                 It can be shown that there are only 2 powerful integers in this
                 range.

    Example 3:
    Input: start = 1000, finish = 2000, limit = 4, s = "3000"
    Output: 0
    Explanation: All integers in the range [1000..2000] are smaller than 3000,
                 hence "3000" cannot be a suffix of any integer in this range.

    Constraints:
    * 1 <= start <= finish <= 10^15
    * 1 <= limit <= 9
    * 1 <= s.length <= floor(log10(finish)) + 1
    * s only consists of numeric digits which are at most limit.
    * s does not have leading zeros.*/

    long long numberOfPowerfulInt(long long start, long long finish, int limit, string s) {

        auto fn = [&](string val) {
            int n = val.size() - s.size();
            if (n < 0) return 0ll;
            vector<vector<long long>> dp(n+1, vector<long long>(2));
            dp[n][0] = 1;
            if (val.substr(n) >= s) dp[n][1] = 1;
            for (int i = n-1; i >= 0; --i) {
                dp[i][0] = (1 + limit)*dp[i+1][0];
                if (val[i]-'0' <= limit) dp[i][1] = (val[i]-'0') * dp[i+1][0] + dp[i+1][1];
                else dp[i][1] = (1 + limit)*dp[i+1][0];
            }
            return dp[0][1];
        };

        return fn(to_string(finish)) - fn(to_string(start-1));
    }


    /*3004. Maximum Subtree of the Same Color (Medium)
    You are given a 2D integer array edges representing a tree with n nodes,
    numbered from 0 to n - 1, rooted at node 0, where edges[i] = [ui, vi] means
    there is an edge between the nodes vi and ui. You are also given a 0-indexed
    integer array colors of size n, where colors[i] is the color assigned to
    node i. We want to find a node v such that every node in the subtree of v
    has the same color. Return the size of such subtree with the maximum number
    of nodes possible.

    Example 1:
    Input: edges = [[0,1],[0,2],[0,3]], colors = [1,1,2,3]
    Output: 1
    Explanation: Each color is represented as: 1 -> Red, 2 -> Green, 3 -> Blue.
                 We can see that the subtree rooted at node 0 has children with
                 different colors. Any other subtree is of the same color and
                 has a size of 1. Hence, we return 1.

    Example 2:
    Input: edges = [[0,1],[0,2],[0,3]], colors = [1,1,1,1]
    Output: 4
    Explanation: The whole tree has the same color, and the subtree rooted at
                 node 0 has the most number of nodes which is 4. Hence, we
                 return 4.

    Example 3:
    Input: edges = [[0,1],[0,2],[2,3],[2,4]], colors = [1,2,3,3,3]
    Output: 3
    Explanation: Each color is represented as: 1 -> Red, 2 -> Green, 3 -> Blue.
                 We can see that the subtree rooted at node 0 has children with
                 different colors. Any other subtree is of the same color, but
                 the subtree rooted at node 2 has a size of 3 which is the
                 maximum. Hence, we return 3.

    Constraints:
    * n == edges.length + 1
    * 1 <= n <= 5 * 10^4
    * edges[i] == [ui, vi]
    * 0 <= ui, vi < n
    * colors.length == n
    * 1 <= colors[i] <= 10^5
    * The input is generated such that the graph represented by edges is a
      tree.*/

    int maximumSubtreeSize(vector<vector<int>>& edges, vector<int>& colors) {
        int n = colors.size();
        vector<vector<int>> graph(n);
        for (auto& e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }

        function<pair<int, bool>(int, int)> fn = [&](int u, int p) {
            int val = 1, most = 0;
            bool same = true;
            for (auto& v : graph[u])
                if (v != p) {
                    auto [vv, ss] = fn(v, u);
                    if (ss && colors[u] == colors[v]) val += vv;
                    else same = false;
                    most = max(most, vv);
                }
            if (same) most = val;
            return pair<int, int>{most, same};
        };

        return fn(0, -1).first;
    }


    /*3005. Count Elements With Maximum Frequency (Easy)
    You are given an array nums consisting of positive integers. Return the
    total frequencies of elements in nums such that those elements all have the
    maximum frequency. The frequency of an element is the number of occurrences
    of that element in the array.

    Example 1:
    Input: nums = [1,2,2,3,1,4]
    Output: 4
    Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum
                 frequency in the array. So the number of elements in the array
                 with maximum frequency is 4.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: 5
    Explanation: All elements of the array have a frequency of 1 which is the
                 maximum. So the number of elements in the array with maximum
                 frequency is 5.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100*/

    int maxFrequencyElements(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        int ans = 0, m = INT_MIN;
        for (auto& [_, v] : freq)
            if (v > m) ans = m = v;
            else if (v == m) ans += v;
        return ans;
    }


    /*3006. Find Beautiful Indices in the Given Array I (Medium)
    You are given a 0-indexed string s, a string a, a string b, and an integer
    k. An index i is beautiful if:
    * 0 <= i <= s.length - a.length
    * s[i..(i + a.length - 1)] == a
    * There exists an index j such that:
      - 0 <= j <= s.length - b.length
      - s[j..(j + b.length - 1)] == b
      - |j - i| <= k
    Return the array that contains beautiful indices in sorted order from
    smallest to largest.

    Example 1:
    Input: s = "isawsquirrelnearmysquirrelhouseohmy", a = "my", b = "squirrel", k = 15
    Output: [16,33]
    Explanation: There are 2 beautiful indices: [16,33].
                 - The index 16 is beautiful as s[16..17] == "my" and there
                   exists an index 4 with s[4..11] == "squirrel" and
                   |16 - 4| <= 15.
                 - The index 33 is beautiful as s[33..34] == "my" and there
                   exists an index 18 with s[18..25] == "squirrel" and
                   |33 - 18| <= 15.
                 Thus we return [16,33] as the result.

    Example 2:
    Input: s = "abcd", a = "a", b = "a", k = 4
    Output: [0]
    Explanation: There is 1 beautiful index: [0].
                 - The index 0 is beautiful as s[0..0] == "a" and there exists
                   an index 0 with s[0..0] == "a" and |0 - 0| <= 4.
                 Thus we return [0] as the result.

    Constraints:
    * 1 <= k <= s.length <= 10^5
    * 1 <= a.length, b.length <= 10
    * s, a, and b contain only lowercase English letters.*/

    vector<int> beautifulIndices(string s, string a, string b, int k) {
        vector<int> ans;
        for (int i = 0, j = 0, n = s.size(); i < n; ++i)
            if (s.substr(i, a.size()) == a) {
                bool found = false;
                for (; j < n && j <= i+k; ++j)
                    if (s.substr(j, b.size()) == b && abs(i-j) <= k) {
                        found = true;
                        break;
                    }
                if (found) ans.push_back(i);
            }
        return ans;
    }


    /*3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)
    You are given an integer k and an integer x. Consider s is the 1-indexed
    binary representation of an integer num. The price of a number num is the
    number of i's such that i % x == 0 and s[i] is a set bit. Return the
    greatest integer num such that the sum of prices of all numbers from 1 to
    num is less than or equal to k.

    Note:
    * In the binary representation of a number set bit is a bit of value 1.
    * The binary representation of a number will be indexed from right to left.
      For example, if s == 11100, s[4] == 1 and s[2] == 0.

    Example 1:
    Input: k = 9, x = 1
    Output: 6
    Explanation: The numbers 1, 2, 3, 4, 5, and 6 can be written in binary
                 representation as "1", "10", "11", "100", "101", and "110"
                 respectively. Since x is equal to 1, the price of each number
                 is the number of its set bits. The number of set bits in these
                 numbers is 9. So the sum of the prices of the first 6 numbers
                 is 9. So the answer is 6.

    Example 2:
    Input: k = 7, x = 2
    Output: 9
    Explanation: Since x is equal to 2, we should just check eventh bits. The
                 second bit of binary representation of numbers 2 and 3 is a set
                 bit. So the sum of their prices is 2. The second bit of binary
                 representation of numbers 6 and 7 is a set bit. So the sum of
                 their prices is 2. The fourth bit of binary representation of
                 numbers 8 and 9 is a set bit but their second bit is not. So
                 the sum of their prices is 2. Numbers 1, 4, and 5 don't have
                 set bits in their eventh bits in their binary representation.
                 So the sum of their prices is 0. The second and the fourth bit
                 of the binary representation of the number 10 are a set bit. So
                 its price is 2. The sum of the prices of the first 9 numbers is
                 6. Because the sum of the prices of the first 10 numbers is 8,
                 the answer is 9.

    Constraints:
    * 1 <= k <= 10^15
    * 1 <= x <= 8*/

    long long findMaximumNumber(long long k, int x) {

        function<long long(long long)> fn = [&](long long mid) {
            if (mid == 0) return 0ll;
            int n = 0;
            for (long long m = mid; m >>= 1; ++n);
            mid ^= 1ll << n;
            return n/x*(long long) pow(2, n-1) + fn(mid) + ((n+1) % x == 0 ? mid+1 : 0ll);
        };

        long long lo = 1, hi = 1e15;
        while (lo < hi) {
            long long mid = lo + (hi - lo + 1)/2;
            if (fn(mid) <= k) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*3008. Find Beautiful Indices in the Given Array II (Hard)
    You are given a 0-indexed string s, a string a, a string b, and an integer
    k. An index i is beautiful if:
    * 0 <= i <= s.length - a.length
    * s[i..(i + a.length - 1)] == a
    * There exists an index j such that:
      - 0 <= j <= s.length - b.length
      - s[j..(j + b.length - 1)] == b
      - |j - i| <= k
    Return the array that contains beautiful indices in sorted order from
    smallest to largest.

    Example 1:
    Input: s = "isawsquirrelnearmysquirrelhouseohmy", a = "my", b = "squirrel", k = 15
    Output: [16,33]
    Explanation: There are 2 beautiful indices: [16,33].
                 - The index 16 is beautiful as s[16..17] == "my" and there
                   exists an index 4 with s[4..11] == "squirrel" and
                   |16 - 4| <= 15.
                 - The index 33 is beautiful as s[33..34] == "my" and there
                   exists an index 18 with s[18..25] == "squirrel" and
                   |33 - 18| <= 15.
                 Thus we return [16,33] as the result.

    Example 2:
    Input: s = "abcd", a = "a", b = "a", k = 4
    Output: [0]
    Explanation: There is 1 beautiful index: [0].
                 - The index 0 is beautiful as s[0..0] == "a" and there exists
                   an index 0 with s[0..0] == "a" and |0 - 0| <= 4.
                 Thus we return [0] as the result.

    Constraints:
    * 1 <= k <= s.length <= 5 * 10^5
    * 1 <= a.length, b.length <= 5 * 10^5
    * s, a, and b contain only lowercase English letters.*/

    vector<int> beautifulIndices(string s, string a, string b, int k) {

        auto kmp = [&](string pattern, string text) {
            vector<int> lps(1);
            for (int i = 1, k = 0, n = pattern.size(); i < n; ++i) {
                while (k && pattern[k] != pattern[i]) k = lps[k-1];
                if (pattern[k] == pattern[i]) ++k;
                lps.push_back(k);
            }
            vector<int> ans;
            for (int i = 0, k = 0, n = pattern.size(); i < text.size(); ++i) {
                while (k && (k == n || pattern[k] != text[i])) k = lps[k-1];
                if (pattern[k] == text[i]) ++k;
                if (k == n) ans.push_back(i - n + 1);
            }
            return ans;
        };

        vector<int> ans, vals = kmp(b, s);
        int j = 0;
        for (auto& i : kmp(a, s)) {
            bool found = false;
            for (; j < vals.size() && vals[j] <= i+k; ++j)
                if (abs(i-vals[j]) <= k) {
                    found = true;
                    break;
                }
            if (found) ans.push_back(i);
        }
        return ans;
    }


    /*3010. Divide an Array Into Subarrays With Minimum Cost I (Easy)
    You are given an array of integers nums of length n. The cost of an array is
    the value of its first element. For example, the cost of [1,2,3] is 1 while
    the cost of [3,4,1] is 3. You need to divide nums into 3 disjoint contiguous
    subarrays. Return the minimum possible sum of the cost of these subarrays.

    Example 1:
    Input: nums = [1,2,3,12]
    Output: 6
    Explanation: The best possible way to form 3 subarrays is: [1], [2], and
                 [3,12] at a total cost of 1 + 2 + 3 = 6. The other possible
                 ways to form 3 subarrays are:
                 - [1], [2,3], and [12] at a total cost of 1 + 2 + 12 = 15.
                 - [1,2], [3], and [12] at a total cost of 1 + 3 + 12 = 16.

    Example 2:
    Input: nums = [5,4,3]
    Output: 12
    Explanation: The best possible way to form 3 subarrays is: [5], [4], and [3]
                 at a total cost of 5 + 4 + 3 = 12. It can be shown that 12 is
                 the minimum cost achievable.

    Example 3:
    Input: nums = [10,3,1,1]
    Output: 12
    Explanation: The best possible way to form 3 subarrays is: [10,3], [1], and
                 [1] at a total cost of 10 + 1 + 1 = 12. It can be shown that 12
                 is the minimum cost achievable.

    Constraints:
    * 3 <= n <= 50
    * 1 <= nums[i] <= 50*/

    int minimumCost(vector<int>& nums) {
        int m0 = 50, m1 = 50;
        for (int i = 1; i < nums.size(); ++i)
            if (nums[i] < m0) tie(m0, m1) = make_tuple(nums[i], m0);
            else if (nums[i] < m1) m1 = nums[i];
        return nums[0] + m0 + m1;
    }


    /*3011. Find if Array Can Be Sorted (Medium)
    You are given a 0-indexed array of positive integers nums. In one operation,
    you can swap any two adjacent elements if they have the same number of set
    bits. You are allowed to do this operation any number of times (including
    zero). Return true if you can sort the array, else return false.

    Example 1:
    Input: nums = [8,4,2,30,15]
    Output: true
    Explanation: Let's look at the binary representation of every element. The
                 numbers 2, 4, and 8 have one set bit each with binary
                 representation "10", "100", and "1000" respectively. The
                 numbers 15 and 30 have four set bits each with binary
                 representation "1111" and "11110". We can sort the array using
                 4 operations:
                 - Swap nums[0] with nums[1]. This operation is valid because 8
                   and 4 have one set bit each. The array becomes [4,8,2,30,15].
                 - Swap nums[1] with nums[2]. This operation is valid because 8
                   and 2 have one set bit each. The array becomes [4,2,8,30,15].
                 - Swap nums[0] with nums[1]. This operation is valid because 4
                   and 2 have one set bit each. The array becomes [2,4,8,30,15].
                 - Swap nums[3] with nums[4]. This operation is valid because 30
                   and 15 have four set bits each. The array becomes [2,4,8,15,30].
                 The array has become sorted, hence we return true. Note that
                 there may be other sequences of operations which also sort the
                 array.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: true
    Explanation: The array is already sorted, hence we return true.

    Example 3:
    Input: nums = [3,16,8,4,2]
    Output: false
    Explanation: It can be shown that it is not possible to sort the input array
                 using any number of operations.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 2^8*/

    bool canSortArray(vector<int>& nums) {
        int bits = 0, curr = 0, prev = 0;
        for (auto& x : nums) {
            int b = __builtin_popcount(x);
            if (bits != b) bits = b, prev = curr;
            if (prev > x) return false;
            curr = max(curr, x);
        }
        return true;
    }


    /*3012. Minimize Length of Array Using Operations (Medium)
    You are given a 0-indexed integer array nums containing positive integers.
    Your task is to minimize the length of nums by performing the following
    operations any number of times (including zero):
    * Select two distinct indices i and j from nums, such that nums[i] > 0 and
      nums[j] > 0.
    * Insert the result of nums[i] % nums[j] at the end of nums.
    * Delete the elements at indices i and j from nums.
    Return an integer denoting the minimum length of nums after performing the
    operation any number of times.

    Example 1:
    Input: nums = [1,4,3,1]
    Output: 1
    Explanation: One way to minimize the length of the array is as follows:
                 - Operation 1: Select indices 2 and 1, insert nums[2] % nums[1]
                   at the end and it becomes [1,4,3,1,3], then delete elements
                   at indices 2 and 1. nums becomes [1,1,3].
                 - Operation 2: Select indices 1 and 2, insert nums[1] % nums[2]
                   at the end and it becomes [1,1,3,1], then delete elements at
                   indices 1 and 2. nums becomes [1,1].
                 - Operation 3: Select indices 1 and 0, insert nums[1] % nums[0]
                   at the end and it becomes [1,1,0], then delete elements at
                   indices 1 and 0. nums becomes [0].
                 The length of nums cannot be reduced further. Hence, the answer
                 is 1. It can be shown that 1 is the minimum achievable length.

    Example 2:
    Input: nums = [5,5,5,10,5]
    Output: 2
    Explanation: One way to minimize the length of the array is as follows:
                 - Operation 1: Select indices 0 and 3, insert nums[0] % nums[3]
                   at the end and it becomes [5,5,5,10,5,5], then delete
                   elements at indices 0 and 3. nums becomes [5,5,5,5].
                 - Operation 2: Select indices 2 and 3, insert nums[2] % nums[3]
                   at the end and it becomes [5,5,5,5,0], then delete elements
                   at indices 2 and 3. nums becomes [5,5,0].
                 - Operation 3: Select indices 0 and 1, insert nums[0] % nums[1]
                   at the end and it becomes [5,5,0,0], then delete elements at
                   indices 0 and 1. nums becomes [0,0].
                 The length of nums cannot be reduced further. Hence, the answer
                 is 2. It can be shown that 2 is the minimum achievable length.

    Example 3:
    Input: nums = [2,3,4]
    Output: 1
    Explanation: One way to minimize the length of the array is as follows:
                 - Operation 1: Select indices 1 and 2, insert nums[1] % nums[2]
                   at the end and it becomes [2,3,4,3], then delete elements at
                   indices 1 and 2. nums becomes [2,3].
                 - Operation 2: Select indices 1 and 0, insert nums[1] % nums[0]
                   at the end and it becomes [2,3,1], then delete elements at
                   indices 1 and 0. nums becomes [1].
                 The length of nums cannot be reduced further. Hence, the answer
                 is 1. It can be shown that 1 is the minimum achievable length.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int minimumArrayLength(vector<int>& nums) {
        int m = *min_element(nums.begin(), nums.end()), cnt = 0;
        for (auto& x : nums)
            if (x % m) return 1;
            else if (x == m) ++cnt;
        return (cnt+1)/2;
    }


    /*3013. Divide an Array Into Subarrays With Minimum Cost II (Hard)
    You are given a 0-indexed array of integers nums of length n, and two
    positive integers k and dist. The cost of an array is the value of its first
    element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is
    3. You need to divide nums into k disjoint contiguous subarrays, such that
    the difference between the starting index of the second subarray and the
    starting index of the kth subarray should be less than or equal to dist. In
    other words, if you divide nums into the subarrays nums[0..(i1 - 1)],
    nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)], then ik-1 - i1 <= dist. Return
    the minimum possible sum of the cost of these subarrays.

    Example 1:
    Input: nums = [1,3,2,6,4,2], k = 3, dist = 3
    Output: 5
    Explanation: The best possible way to divide nums into 3 subarrays is:
                 [1,3], [2,6,4], and [2]. This choice is valid because ik-1 - i1
                 is 5 - 2 = 3 which is equal to dist. The total cost is
                 nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5. It can be
                 shown that there is no possible way to divide nums into 3
                 subarrays at a cost lower than 5.

    Example 2:
    Input: nums = [10,1,2,2,2,1], k = 4, dist = 3
    Output: 15
    Explanation: The best possible way to divide nums into 4 subarrays is:
                 [10], [1], [2], and [2,2,1]. This choice is valid because
                 ik-1 - i1 is 3 - 1 = 2 which is less than dist. The total cost
                 is nums[0] + nums[1] + nums[2] + nums[3] which is
                 10 + 1 + 2 + 2 = 15. The division [10], [1], [2,2,2], and [1]
                 is not valid, because the difference between ik-1 and i1 is
                 5 - 1 = 4, which is greater than dist. It can be shown that
                 there is no possible way to divide nums into 4 subarrays at a
                 cost lower than 15.

    Example 3:
    Input: nums = [10,8,18,9], k = 3, dist = 1
    Output: 36
    Explanation: The best possible way to divide nums into 4 subarrays is:
                 [10], [8], and [18,9]. This choice is valid because ik-1 - i1
                 is 2 - 1 = 1 which is equal to dist.The total cost is
                 nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36. The
                 division [10], [8,18], and [9] is not valid, because the
                 difference between ik-1 and i1 is 3 - 1 = 2, which is greater
                 than dist. It can be shown that there is no possible way to
                 divide nums into 3 subarrays at a cost lower than 36.

    Constraints:
    * 3 <= n <= 10^5
    * 1 <= nums[i] <= 10^9
    * 3 <= k <= n
    * k - 2 <= dist <= n - 2*/

    long long minimumCost(vector<int>& nums, int k, int dist) {
        long long ans = LONG_MAX, total = 0;
        multiset<long long> small, large;
        for (int i = 1; i < nums.size(); ++i) {
            if (i > dist+1) {
                int v = nums[i-dist-1];
                if (v <= *small.rbegin()) {
                    small.erase(small.lower_bound(v));
                    total -= v;
                    if (large.size()) {
                        auto it = large.begin();
                        total += *it;
                        small.insert(*it);
                        large.erase(it);
                    }
                } else large.erase(large.lower_bound(v));
            }
            small.insert(nums[i]);
            total += nums[i];
            if (small.size() > k-1) {
                auto it = prev(small.end());
                total -= *it;
                large.insert(*it);
                small.erase(it);
            }
            if (i >= k-1) ans = min(ans, total);
        }
        return nums[0] + ans;
    }


    /*3016. Minimum Number of Pushes to Type Word II (Medium)
    You are given a string word containing lowercase English letters. Telephone
    keypads have keys mapped with distinct collections of lowercase English
    letters, which can be used to form words by pushing them. For example, the
    key 2 is mapped with ["a","b","c"], we need to push the key one time to type
    "a", two times to type "b", and three times to type "c". It is allowed to
    remap the keys numbered 2 to 9 to distinct collections of letters. The keys
    can be remapped to any amount of letters, but each letter must be mapped to
    exactly one key. You need to find the minimum number of times the keys will
    be pushed to type the string word. Return the minimum number of pushes
    needed to type word after remapping the keys. An example mapping of letters
    to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do
    not map to any letters.

    Example 1:
    Input: word = "abcde"
    Output: 5
    Explanation: The remapped keypad given in the image provides the minimum cost.
                 "a" -> one push on key 2
                 "b" -> one push on key 3
                 "c" -> one push on key 4
                 "d" -> one push on key 5
                 "e" -> one push on key 6
                 Total cost is 1 + 1 + 1 + 1 + 1 = 5. It can be shown that no
                 other mapping can provide a lower cost.

    Example 2:
    Input: word = "xyzxyzxyzxyz"
    Output: 12
    Explanation: The remapped keypad given in the image provides the minimum cost.
                 "x" -> one push on key 2
                 "y" -> one push on key 3
                 "z" -> one push on key 4
                 Total cost is 1 * 4 + 1 * 4 + 1 * 4 = 12
                 It can be shown that no other mapping can provide a lower cost.
                 Note that the key 9 is not mapped to any letter: it is not
                 necessary to map letters to every key, but to map all the letters.

    Example 3:
    Input: word = "aabbccddeeffgghhiiiiii"
    Output: 24
    Explanation: The remapped keypad given in the image provides the minimum cost.
                 "a" -> one push on key 2
                 "b" -> one push on key 3
                 "c" -> one push on key 4
                 "d" -> one push on key 5
                 "e" -> one push on key 6
                 "f" -> one push on key 7
                 "g" -> one push on key 8
                 "h" -> two pushes on key 9
                 "i" -> one push on key 9
                 Total cost is 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 +
                 1 * 2 + 2 * 2 + 6 * 1 = 24. It can be shown that no other
                 mapping can provide a lower cost.

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists of lowercase English letters.*/

    int minimumPushes(string word) {
        vector<int> freq(26);
        for (auto& ch : word) ++freq[ch - 'a'];
        sort(freq.begin(), freq.end(), greater<>());
        int ans = 0;
        for (int i = 0, cnt = 0; i < 26; ++i) {
            if (i % 8 == 0) ++cnt;
            ans += cnt * freq[i];
        }
        return ans;
    }


    /*3019. Number of Changing Keys (Easy)
    You are given a 0-indexed string s typed by a user. Changing a key is
    defined as using a key different from the last used key. For example,
    s = "ab" has a change of a key while s = "bBBb" does not have any. Return
    the number of times the user had to change the key. Note: Modifiers like
    shift or caps lock won't be counted in changing the key that is if a user
    typed the letter 'a' and then the letter 'A' then it will not be considered
    as a changing of key.

    Example 1:
    Input: s = "aAbBcC"
    Output: 2
    Explanation: - From s[0] = 'a' to s[1] = 'A', there is no change of key as
                   caps lock or shift is not counted.
                 - From s[1] = 'A' to s[2] = 'b', there is a change of key.
                 - From s[2] = 'b' to s[3] = 'B', there is no change of key as
                   caps lock or shift is not counted.
                 - From s[3] = 'B' to s[4] = 'c', there is a change of key.
                 - From s[4] = 'c' to s[5] = 'C', there is no change of key as
                   caps lock or shift is not counted.

    Example 2:
    Input: s = "AaAaAaaA"
    Output: 0
    Explanation: There is no change of key since only the letters 'a' and 'A'
                 are pressed which does not require change of key.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of only upper case and lower case English letters.*/

    int countKeyChanges(string s) {
        int ans = 0;
        for (int i = 1; i < s.size(); ++i)
            if (tolower(s[i-1]) != tolower(s[i])) ++ans;
        return ans;
    }


    /*3020. Find the Maximum Number of Elements in Subset (Medium)
    You are given an array of positive integers nums. You need to select a
    subset of nums which satisfies the following condition:
    * You can place the selected elements in a 0-indexed array such that it
      follows the pattern: [x, x2, x4, ..., xk/2, xk, xk/2, ..., x4, x2, x]
      (Note that k can be be any non-negative power of 2). For example,
      [2, 4, 16, 4, 2] and [3, 9, 3] follow the pattern while [2, 4, 8, 4, 2]
      does not.
    Return the maximum number of elements in a subset that satisfies these
    conditions.

    Example 1:
    Input: nums = [5,4,1,2,2]
    Output: 3
    Explanation: We can select the subset {4,2,2}, which can be placed in the
                 array as [2,4,2] which follows the pattern and 22 == 4. Hence
                 the answer is 3.

    Example 2:
    Input: nums = [1,3,2,4]
    Output: 1
    Explanation: We can select the subset {1}, which can be placed in the array
                 as [1] which follows the pattern. Hence the answer is 1. Note
                 that we could have also selected the subsets {2}, {4}, or {3},
                 there may be multiple subsets which provide the same answer.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    int maximumLength(vector<int>& nums) {
        int ans = 0;
        unordered_map<long, int> freq;
        for (auto& x : nums) ++freq[x];
        for (auto& [k, v] : freq) {
            int cand = v;
            if (k != 1) {
                cand = 0;
                for (long x = k; freq.count(x); x *= x) {
                    cand += 2;
                    if (freq[x] == 1) break;
                }
            }
            if (cand % 2 == 0) --cand;
            ans = max(ans, cand);
        }
        return ans;
    }


    /*3021. Alice and Bob Playing Flower Game (Medium)
    Alice and Bob are playing a turn-based game on a circular field surrounded
    by flowers. The circle represents the field, and there are x flowers in the
    clockwise direction between Alice and Bob, and y flowers in the anti-
    clockwise direction between them. The game proceeds as follows:
    * Alice takes the first turn.
    * In each turn, a player must choose either the clockwise or anti-clockwise
      direction and pick one flower from that side.
    * At the end of the turn, if there are no flowers left at all, the current
      player captures their opponent and wins the game.
    Given two integers, n and m, the task is to compute the number of possible
    pairs (x, y) that satisfy the conditions:
    * Alice must win the game according to the described rules.
    * The number of flowers x in the clockwise direction must be in the range
      [1,n].
    * The number of flowers y in the anti-clockwise direction must be in the
      range [1,m].
    Return the number of possible pairs (x, y) that satisfy the conditions
    mentioned in the statement.

    Example 1:
    Input: n = 3, m = 2
    Output: 3
    Explanation: The following pairs satisfy conditions described in the
                 statement: (1,2), (3,2), (2,1).

    Example 2:
    Input: n = 1, m = 1
    Output: 0
    Explanation: No pairs satisfy the conditions described in the statement.

    Constraints: 1 <= n, m <= 10^5*/

    long long flowerGame(int n, int m) {
        return (long long) m*n/2;
    }


    /*3022. Minimize OR of Remaining Elements Using Operations (Hard)
    You are given a 0-indexed integer array nums and an integer k. In one
    operation, you can pick any index i of nums such that
    0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a single
    occurrence of nums[i] & nums[i + 1], where & represents the bitwise AND
    operator. Return the minimum possible value of the bitwise OR of the
    remaining elements of nums after applying at most k operations.

    Example 1:
    Input: nums = [3,5,3,2,7], k = 2
    Output: 3
    Explanation: Let's do the following operations:
                 1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [1,3,2,7].
                 2. Replace nums[2] and nums[3] with (nums[2] & nums[3]) so that
                    nums becomes equal to [1,3,2].
                 The bitwise-or of the final array is 3. It can be shown that 3
                 is the minimum possible value of the bitwise OR of the
                 remaining elements of nums after applying at most k operations.

    Example 2:
    Input: nums = [7,3,15,14,2,8], k = 4
    Output: 2
    Explanation: Let's do the following operations:
                 1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [3,15,14,2,8].
                 2. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [3,14,2,8].
                 3. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [2,2,8].
                 4. Replace nums[1] and nums[2] with (nums[1] & nums[2]) so that
                    nums becomes equal to [2,0].
                 The bitwise-or of the final array is 2. It can be shown that 2
                 is the minimum possible value of the bitwise OR of the
                 remaining elements of nums after applying at most k operations.

    Example 3:
    Input: nums = [10,7,10,3,9,14,9,4], k = 1
    Output: 15
    Explanation: Without applying any operations, the bitwise-or of nums is 15.
                 It can be shown that 15 is the minimum possible value of the
                 bitwise OR of the remaining elements of nums after applying at
                 most k operations.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] < 2^30
    * 0 <= k < nums.length*/

    int minOrAfterOperations(vector<int>& nums, int k) {
        int ans = 0, n = nums.size();
        for (int bit = 30; bit >= 0; --bit) {
            int cnt = 0, mask = (1<<30) - 1, target = ans | ((1<<bit) - 1);
            for (auto& x : nums) {
                mask &= x;
                if ((mask | target) > target) ++cnt;
                else mask = (1<<30) - 1;
            }
            if (cnt > k) ans |= 1<<bit;
        }
        return ans;
    }


    /*3023. Find Pattern in Infinite Stream I (Medium)
    You are given a binary array pattern and an object stream of class
    InfiniteStream representing a 0-indexed infinite stream of bits. The class
    InfiniteStream contains the following function:
    * int next(): Reads a single bit (which is either 0 or 1) from the stream
      and returns it.
    Return the first starting index where the pattern matches the bits read from
    the stream. For example, if the pattern is [1, 0], the first match is the
    highlighted part in the stream [0, 1, 0, 1, ...].

    Example 1:
    Input: stream = [1,1,1,0,1,1,1,...], pattern = [0,1]
    Output: 3
    Explanation: The first occurrence of the pattern [0,1] is highlighted in the
                 stream [1,1,1,0,1,...], which starts at index 3.

    Example 2:
    Input: stream = [0,0,0,0,...], pattern = [0]
    Output: 0
    Explanation: The first occurrence of the pattern [0] is highlighted in the
                 stream [0,...], which starts at index 0.

    Example 3:
    Input: stream = [1,0,1,1,0,1,1,0,1,...], pattern = [1,1,0,1]
    Output: 2
    Explanation: The first occurrence of the pattern [1,1,0,1] is highlighted in
                 the stream [1,0,1,1,0,1,...], which starts at index 2.

    Constraints:
    * 1 <= pattern.length <= 100
    * pattern consists only of 0 and 1.
    * stream consists only of 0 and 1.
    * The input is generated such that the pattern's start index exists in the
      first 10^5 bits of the stream.*/

    int findPattern(InfiniteStream* stream, vector<int>& pattern) {
        vector<int> lps(1);
        for (int i = 1, k = 0; i < pattern.size(); ++i) {
            while (k && pattern[k] != pattern[i]) k = lps[k-1];
            if (pattern[k] == pattern[i]) ++k;
            lps.push_back(k);
        }
        for (int i = 0, k = 0, n = pattern.size(); true; ++i) {
            int ch = stream->next();
            while (k && pattern[k] != ch) k = lps[k-1];
            if (pattern[k] == ch) ++k;
            if (k == n) return i-n+1;
        }
    }


    /*3024. Type of Triangle II (Easy)
    You are given a 0-indexed integer array nums of size 3 which can form the
    sides of a triangle.
    * A triangle is called equilateral if it has all sides of equal length.
    * A triangle is called isosceles if it has exactly two sides of equal length.
    * A triangle is called scalene if all its sides are of different lengths.
    Return a string representing the type of triangle that can be formed or
    "none" if it cannot form a triangle.

    Example 1:
    Input: nums = [3,3,3]
    Output: "equilateral"
    Explanation: Since all the sides are of equal length, therefore, it will
                 form an equilateral triangle.

    Example 2:
    Input: nums = [3,4,5]
    Output: "scalene"
    Explanation: nums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.
                 nums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.
                 nums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3.
                 Since the sum of the two sides is greater than the third side
                 for all three cases, therefore, it can form a triangle. As all
                 the sides are of different lengths, it will form a scalene
                 triangle.

    Constraints:
    * nums.length == 3
    * 1 <= nums[i] <= 100*/

    string triangleType(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int x = nums[0], y = nums[1], z = nums[2];
        if (x + y <= z) return "none";
        if (x == z) return "equilateral";
        if (x == y || y == z) return "isosceles";
        return "scalene";
    }


    /*3025. Find the Number of Ways to Place People I (Medium)
    You are given a 2D array points of size n x 2 representing integer
    coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. We
    define the right direction as positive x-axis (increasing x-coordinate) and
    the left direction as negative x-axis (decreasing x-coordinate). Similarly,
    we define the up direction as positive y-axis (increasing y-coordinate) and
    the down direction as negative y-axis (decreasing y-coordinate). You have to
    place n people, including Chisato and Takina, at these points such that
    there is exactly one person at every point. Chisato wants to be alone with
    Takina, so Chisato will build a rectangular fence with Chisato's position as
    the upper left corner and Takina's position as the lower right corner of the
    fence (Note that the fence might not enclose any area, i.e. it can be a
    line). If any person other than Chisato and Takina is either inside the
    fence or on the fence, Chisato will be sad. Return the number of pairs of
    points where you can place Chisato and Takina, such that Chisato does not
    become sad on building the fence. Note that Chisato can only build a fence
    with Chisato's position as the upper left corner, and Takina's position as
    the lower right corner. For example, Chisato cannot build either of the
    fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and
    (3, 3), because:
    * With Chisato at (3, 3) and Takina at (1, 1), Chisato's position is not the
      upper left corner and Takina's position is not the lower right corner of
      the fence.
    * With Chisato at (1, 3) and Takina at (1, 1), Takina's position is not the
      lower right corner of the fence.

    Example 1:
    Input: points = [[1,1],[2,2],[3,3]]
    Output: 0
    Explanation: There is no way to place Chisato and Takina such that Chisato
                 can build a fence with Chisato's position as the upper left
                 corner and Takina's position as the lower right corner. Hence
                 we return 0.

    Example 2:
    Input: points = [[6,2],[4,4],[2,6]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (4, 4) and Takina at (6, 2).
                 - Place Chisato at (2, 6) and Takina at (4, 4).
                 You cannot place Chisato at (2, 6) and Takina at (6, 2) because
                 the person at (4, 4) will be inside the fence.

    Example 3:
    Input: points = [[3,1],[1,3],[1,1]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (1, 1) and Takina at (3, 1).
                 - Place Chisato at (1, 3) and Takina at (1, 1).
                 You cannot place Chisato at (1, 3) and Takina at (3, 1) because
                 the person at (1, 1) will be on the fence. Note that it does
                 not matter if the fence encloses any area, the first and second
                 fences in the image are valid.

    Constraints:
    * 2 <= n <= 50
    * points[i].length == 2
    * 0 <= points[i][0], points[i][1] <= 50
    * All points[i] are distinct.*/

    int numberOfPairs(vector<vector<int>>& points) {
        int ans = 0;
        sort(points.begin(), points.end(), [&](auto& lhs, auto& rhs) {
            return lhs[0] == rhs[0] ? lhs[1] > rhs[1] : lhs[0] < rhs[0];
        });
        for (int i = 0, n = points.size(); i < n; ++i) {
            int val = INT_MIN;
            for (int j = i+1; j < n; ++j)
                if (points[i][1] >= points[j][1] && points[j][1] > val) {
                    ++ans;
                    val = points[j][1];
                }
        }
        return ans;
    }


    /*3026. Maximum Good Subarray Sum (Medium)
    You are given an array nums of length n and a positive integer k. A subarray
    of nums is called good if the absolute difference between its first and last
    element is exactly k, in other words, the subarray nums[i..j] is good if
    |nums[i] - nums[j]| == k. Return the maximum sum of a good subarray of nums.
    If there are no good subarrays, return 0.

    Example 1:
    Input: nums = [1,2,3,4,5,6], k = 1
    Output: 11
    Explanation: The absolute difference between the first and last element must
                 be 1 for a good subarray. All the good subarrays are:
                 [1,2], [2,3], [3,4], [4,5], and [5,6]. The maximum subarray sum
                 is 11 for the subarray [5,6].

    Example 2:
    Input: nums = [-1,3,2,4,5], k = 3
    Output: 11
    Explanation: The absolute difference between the first and last element must
                 be 3 for a good subarray. All the good subarrays are: [-1,3,2],
                 and [2,4,5]. The maximum subarray sum is 11 for the subarray
                 [2,4,5].

    Example 3:
    Input: nums = [-1,-2,-3,-4], k = 2
    Output: -6
    Explanation: The absolute difference between the first and last element must
                 be 2 for a good subarray. All the good subarrays are:
                 [-1,-2,-3], and [-2,-3,-4]. The maximum subarray sum is -6 for
                 the subarray [-1,-2,-3].

    Constraints:
    * 2 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9
    * 1 <= k <= 10^9*/

    long long maximumSubarraySum(vector<int>& nums, int k) {
        long long ans = LLONG_MIN, prefix = 0;
        unordered_map<int, long long> seen;
        for (auto& x : nums) {
            prefix += x;
            if (seen.count(x-k)) ans = max(ans, prefix-seen[x-k]);
            if (seen.count(x+k)) ans = max(ans, prefix-seen[x+k]);
            if (seen.count(x)) seen[x] = min(seen[x], prefix-x);
            else seen[x] = prefix-x;
        }
        return ans > LLONG_MIN ? ans : 0;
    }


    /*3027. Find the Number of Ways to Place People II (Hard)
    You are given a 2D array points of size n x 2 representing integer
    coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. We
    define the right direction as positive x-axis (increasing x-coordinate) and
    the left direction as negative x-axis (decreasing x-coordinate). Similarly,
    we define the up direction as positive y-axis (increasing y-coordinate) and
    the down direction as negative y-axis (decreasing y-coordinate). You have to
    place n people, including Chisato and Takina, at these points such that
    there is exactly one person at every point. Chisato wants to be alone with
    Takina, so Chisato will build a rectangular fence with Chisato's position as
    the upper left corner and Takina's position as the lower right corner of the
    fence (Note that the fence might not enclose any area, i.e. it can be a
    line). If any person other than Chisato and Takina is either inside the
    fence or on the fence, Chisato will be sad. Return the number of pairs of
    points where you can place Chisato and Takina, such that Chisato does not
    become sad on building the fence. Note that Chisato can only build a fence
    with Chisato's position as the upper left corner, and Takina's position as
    the lower right corner. For example, Chisato cannot build either of the
    fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and
    (3, 3), because:
    * With Chisato at (3, 3) and Takina at (1, 1), Chisato's position is not the
      upper left corner and Takina's position is not the lower right corner of
      the fence.
    * With Chisato at (1, 3) and Takina at (1, 1), Takina's position is not the
      lower right corner of the fence.

    Example 1:
    Input: points = [[1,1],[2,2],[3,3]]
    Output: 0
    Explanation: There is no way to place Chisato and Takina such that Chisato
                 can build a fence with Chisato's position as the upper left
                 corner and Takina's position as the lower right corner. Hence
                 we return 0.

    Example 2:
    Input: points = [[6,2],[4,4],[2,6]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (4, 4) and Takina at (6, 2).
                 - Place Chisato at (2, 6) and Takina at (4, 4).
                 You cannot place Chisato at (2, 6) and Takina at (6, 2) because
                 the person at (4, 4) will be inside the fence.

    Example 3:
    Input: points = [[3,1],[1,3],[1,1]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (1, 1) and Takina at (3, 1).
                 - Place Chisato at (1, 3) and Takina at (1, 1).
                 You cannot place Chisato at (1, 3) and Takina at (3, 1) because
                 the person at (1, 1) will be on the fence. Note that it does
                 not matter if the fence encloses any area, the first and second
                 fences in the image are valid.

    Constraints:
    * 2 <= n <= 1000
    * points[i].length == 2
    * -10^9 <= points[i][0], points[i][1] <= 10^9
    * All points[i] are distinct.*/

    int numberOfPairs(vector<vector<int>>& points) {
        int ans = 0;
        sort(points.begin(), points.end(), [&](auto& lhs, auto& rhs) {
            return lhs[0] == rhs[0] ? lhs[1] > rhs[1] : lhs[0] < rhs[0];
        });
        for (int i = 0, n = points.size(); i < n; ++i) {
            int val = INT_MIN;
            for (int j = i+1; j < n; ++j)
                if (points[i][1] >= points[j][1] && points[j][1] > val) {
                    ++ans;
                    val = points[j][1];
                }
        }
        return ans;
    }


    /*3028. Ant on the Boundary (Easy)
    An ant is on a boundary. It sometimes goes left and sometimes right. You are
    given an array of non-zero integers nums. The ant starts reading nums from
    the first element of it to its end. At each step, it moves according to the
    value of the current element:
    * If nums[i] < 0, it moves left by -nums[i] units.
    * If nums[i] > 0, it moves right by nums[i] units.
    Return the number of times the ant returns to the boundary.

    Notes:
    * There is an infinite space on both sides of the boundary.
    * We check whether the ant is on the boundary only after it has moved
      |nums[i]| units. In other words, if the ant crosses the boundary during
      its movement, it does not count.

    Example 1:
    Input: nums = [2,3,-5]
    Output: 1
    Explanation: - After the first step, the ant is 2 steps to the right of the
                   boundary.
                 - After the second step, the ant is 5 steps to the right of the
                   boundary.
                 - After the third step, the ant is on the boundary.
                 So the answer is 1.

    Example 2:
    Input: nums = [3,2,-3,-4]
    Output: 0
    Explanation: - After the first step, the ant is 3 steps to the right of the
                   boundary.
                 - After the second step, the ant is 5 steps to the right of the
                   boundary.
                 - After the third step, the ant is 2 steps to the right of the
                   boundary.
                 - After the fourth step, the ant is 2 steps to the left of the
                   boundary.
                 The ant never returned to the boundary, so the answer is 0.

    Constraints:
    * 1 <= nums.length <= 100
    * -10 <= nums[i] <= 10
    * nums[i] != 0*/

    int returnToBoundaryCount(vector<int>& nums) {
        partial_sum(begin(nums), end(nums), begin(nums));
        return count(begin(nums), end(nums), 0);
    }


    /*3029. Minimum Time to Revert Word to Initial State I (Medium)
    You are given a 0-indexed string word and an integer k. At every second, you
    must perform the following operations:
    * Remove the first k characters of word.
    * Add any k characters to the end of word.
    Note that you do not necessarily need to add the same characters that you
    removed. However, you must perform both operations at every second. Return
    the minimum time greater than zero required for word to revert to its
    initial state.

    Example 1:
    Input: word = "abacaba", k = 3
    Output: 2
    Explanation: - At the 1st second, we remove characters "aba" from the prefix
                   of word, and add characters "bac" to the end of word. Thus,
                   word becomes equal to "cababac".
                 - At the 2nd second, we remove characters "cab" from the prefix
                   of word, and add "aba" to the end of word. Thus, word becomes
                   equal to "abacaba" and reverts to its initial state.
                 It can be shown that 2 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 2:
    Input: word = "abacaba", k = 4
    Output: 1
    Explanation: - At the 1st second, we remove characters "abac" from the
                   prefix of word, and add characters "caba" to the end of word.
                   Thus, word becomes equal to "abacaba" and reverts to its
                   initial state.
                 It can be shown that 1 second is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 3:
    Input: word = "abcbabcd", k = 2
    Output: 4
    Explanation: - At every second, we will remove the first 2 characters of
                   word, and add the same characters to the end of word.
                 - After 4 seconds, word becomes equal to "abcbabcd" and reverts
                   to its initial state.
                 It can be shown that 4 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Constraints:
    * 1 <= word.length <= 50
    * 1 <= k <= word.length
    * word consists only of lowercase English letters.*/

    int minimumTimeToInitialState(string word, int k) {

        auto z_algo = [&](string s) {
            int n = s.size();
            vector<int> ans(n);
            for (int i = 0, ii = 0, lo = 0, hi = 0; i < n; ++i) {
                if (i <= hi) ii = i - lo;
                if (i+ans[ii] <= hi) ans[i] = ans[ii];
                else {
                    lo = i;
                    hi = max(hi, i);
                    while (hi < n && s[hi] == s[hi-lo]) ++hi;
                    ans[i] = hi - lo;
                    --hi;
                }
            }
            return ans;
        };

        vector<int> z = z_algo(word);
        int i = 0;
        for (int n = word.size(); i*k < n; ++i)
            if (z[i*k] + i*k == n) break;
        return i;
    }


    /*3030. Find the Grid of Region Average (Medium)
    You are given m x n grid image which represents a grayscale image, where
    image[i][j] represents a pixel with intensity in the range [0..255]. You are
    also given a non-negative integer threshold. Two pixels are adjacent if they
    share an edge. A region is a 3 x 3 subgrid where the absolute difference in
    intensity between any two adjacent pixels is less than or equal to threshold.
    All pixels in a region belong to that region, note that a pixel can belong
    to multiple regions. You need to calculate a m x n grid result, where
    result[i][j] is the average intensity of the regions to which image[i][j]
    belongs, rounded down to the nearest integer. If image[i][j] belongs to
    multiple regions, result[i][j] is the average of the rounded-down average
    intensities of these regions, rounded down to the nearest integer. If
    image[i][j] does not belong to any region, result[i][j] is equal to
    image[i][j]. Return the grid result.

    Example 1:
    Input: image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3
    Output: [[9,9,9,9],[9,9,9,9],[9,9,9,9]]
    Explanation: There are two regions as illustrated above. The average
                 intensity of the first region is 9, while the average intensity
                 of the second region is 9.67 which is rounded down to 9. The
                 average intensity of both of the regions is (9 + 9) / 2 = 9. As
                 all the pixels belong to either region 1, region 2, or both of
                 them, the intensity of every pixel in the result is 9. Please
                 note that the rounded-down values are used when calculating the
                 average of multiple regions, hence the calculation is done
                 using 9 as the average intensity of region 2, not 9.67.

    Example 2:
    Input: image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12
    Output: [[25,25,25],[27,27,27],[27,27,27],[30,30,30]]
    Explanation: There are two regions as illustrated above. The average
                 intensity of the first region is 25, while the average
                 intensity of the second region is 30. The average intensity of
                 both of the regions is (25 + 30) / 2 = 27.5 which is rounded
                 down to 27. All the pixels in row 0 of the image belong to
                 region 1, hence all the pixels in row 0 in the result are 25.
                 Similarly, all the pixels in row 3 in the result are 30. The
                 pixels in rows 1 and 2 of the image belong to region 1 and
                 region 2, hence their assigned value is 27 in the result.

    Example 3:
    Input: image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1
    Output: [[5,6,7],[8,9,10],[11,12,13]]
    Explanation: There is only one 3 x 3 subgrid, while it does not have the
                 condition on difference of adjacent pixels, for example, the
                 difference between image[0][0] and image[1][0] is
                 |5 - 8| = 3 > threshold = 1. None of them belong to any valid
                 regions, so the result should be the same as image.

    Constraints:
    * 3 <= n, m <= 500
    * 0 <= image[i][j] <= 255
    * 0 <= threshold <= 255*/

    vector<vector<int>> resultGrid(vector<vector<int>>& image, int threshold) {
        int m = image.size(), n = image[0].size();
        vector<vector<pair<int, int>>> ans(m, vector<pair<int, int>>(n));
        for (int i = 0; i < m-2; ++i)
            for (int j = 0; j < n-2; ++j) {
                int total = 0, diff = 0;
                for (int ii = i; ii <= i+2; ++ii)
                    for (int jj = j; jj <= j+2; ++jj) {
                        total += image[ii][jj];
                        if (ii+1 <= i+2) diff = max(diff, abs(image[ii][jj]-image[ii+1][jj]));
                        if (jj+1 <= j+2) diff = max(diff, abs(image[ii][jj]-image[ii][jj+1]));
                    }
                if (diff <= threshold) {
                    for (int ii = i; ii <= i+2; ++ii)
                        for (int jj = j; jj <= j+2; ++jj) {
                            ans[ii][jj].first += total/9;
                            ans[ii][jj].second += 1;
                        }
                }
            }
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (ans[i][j].second)
                    image[i][j] = ans[i][j].first / ans[i][j].second;
        return image;

    }


    /*3031. Minimum Time to Revert Word to Initial State II (Hard)
    You are given a 0-indexed string word and an integer k. At every second, you
    must perform the following operations:
    * Remove the first k characters of word.
    * Add any k characters to the end of word.
    Note that you do not necessarily need to add the same characters that you
    removed. However, you must perform both operations at every second. Return
    the minimum time greater than zero required for word to revert to its
    initial state.

    Example 1:
    Input: word = "abacaba", k = 3
    Output: 2
    Explanation: - At the 1st second, we remove characters "aba" from the prefix
                   of word, and add characters "bac" to the end of word. Thus,
                   word becomes equal to "cababac".
                 - At the 2nd second, we remove characters "cab" from the prefix
                   of word, and add "aba" to the end of word. Thus, word becomes
                   equal to "abacaba" and reverts to its initial state.
                 It can be shown that 2 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 2:
    Input: word = "abacaba", k = 4
    Output: 1
    Explanation: - At the 1st second, we remove characters "abac" from the
                   prefix of word, and add characters "caba" to the end of word.
                   Thus, word becomes equal to "abacaba" and reverts to its
                   initial state.
                 It can be shown that 1 second is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 3:
    Input: word = "abcbabcd", k = 2
    Output: 4
    Explanation: - At every second, we will remove the first 2 characters of
                   word, and add the same characters to the end of word.
                 - After 4 seconds, word becomes equal to "abcbabcd" and reverts
                   to its initial state.
                 It can be shown that 4 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Constraints:
    * 1 <= word.length <= 10^6
    * 1 <= k <= word.length
    * word consists only of lowercase English letters.*/

    int minimumTimeToInitialState(string word, int k) {

        auto z_algo = [&](string s) {
            int n = s.size();
            vector<int> ans(n);
            for (int i = 0, ii = 0, lo = 0, hi = 0; i < n; ++i) {
                if (i <= hi) ii = i - lo;
                if (i+ans[ii] <= hi) ans[i] = ans[ii];
                else {
                    lo = i;
                    hi = max(hi, i);
                    while (hi < n && s[hi] == s[hi-lo]) ++hi;
                    ans[i] = hi - lo;
                    --hi;
                }
            }
            return ans;
        };

        vector<int> z = z_algo(word);
        int i = 0;
        for (int n = word.size(); i*k < n; ++i)
            if (z[i*k] + i*k == n) break;
        return i;
    }


    /*3032. Count Numbers With Unique Digits II (Easy)
    Given two positive integers a and b, return the count of numbers having
    unique digits in the range [a, b] (inclusive).

    Example 1:
    Input: a = 1, b = 20
    Output: 19
    Explanation: All the numbers in the range [1, 20] have unique digits except
                 11. Hence, the answer is 19.

    Example 2:
    Input: a = 9, b = 19
    Output: 10
    Explanation: All the numbers in the range [9, 19] have unique digits except
                 11. Hence, the answer is 10.

    Example 3:
    Input: a = 80, b = 120
    Output: 27
    Explanation: There are 41 numbers in the range [80, 120], 27 of which have
                 unique digits.

    Constraints: 1 <= a <= b <= 1000*/

    int numberCount(int a, int b) {
        int ans = 0;
        for (int x = a; x <= b; ++x) {
            bool found = false;
            for (int xx = x, mask = 0; xx; xx /= 10) {
                int d = xx % 10;
                if (mask & 1<<d) {
                    found = true;
                    break;
                }
                mask ^= 1<<d;
            }
            if (!found) ++ans;
        }
        return ans;
    }


    /*3033. Modify the Matrix （Easy）
    Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix
    called answer. Make answer equal to matrix, then replace each element with
    the value -1 with the maximum element in its respective column. Return the
    matrix answer.

    Example 1:
    Input: matrix = [[1,2,-1],[4,-1,6],[7,8,9]]
    Output: [[1,2,9],[4,8,6],[7,8,9]]
    Explanation: The diagram above shows the elements that are changed (in blue).
                 - We replace the value in the cell [1][1] with the maximum
                   value in the column 1, that is 8.
                 - We replace the value in the cell [0][2] with the maximum
                   value in the column 2, that is 9.

    Example 2:
    Input: matrix = [[3,-1],[5,2]]
    Output: [[3,2],[5,2]]
    Explanation: The diagram above shows the elements that are changed (in blue).

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 2 <= m, n <= 50
    * -1 <= matrix[i][j] <= 100
    * The input is generated such that each column contains at least one non-
      negative integer.*/

    vector<vector<int>> modifiedMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        for (int j = 0; j < n; ++j) {
            int mv = -1;
            for (int i = 0; i < m; ++i)
                mv = max(mv, matrix[i][j]);
            for (int i = 0; i < m; ++i)
                if (matrix[i][j] == -1) matrix[i][j] = mv;
        }
        return matrix;
    }


    /*3034. Number of Subarrays That Match a Pattern I (Medium)
    You are given a 0-indexed integer array nums of size n, and a 0-indexed
    integer array pattern of size m consisting of integers -1, 0, and 1. A
    subarray nums[i..j] of size m + 1 is said to match the pattern if the
    following conditions hold for each element pattern[k]:
    * nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
    * nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
    * nums[i + k + 1] < nums[i + k] if pattern[k] == -1.
    Return the count of subarrays in nums that match the pattern.

    Example 1:
    Input: nums = [1,2,3,4,5,6], pattern = [1,1]
    Output: 4
    Explanation: The pattern [1,1] indicates that we are looking for strictly
                 increasing subarrays of size 3. In the array nums, the
                 subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this
                 pattern. Hence, there are 4 subarrays in nums that match the
                 pattern.

    Example 2:
    Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
    Output: 2
    Explanation: Here, the pattern [1,0,-1] indicates that we are looking for a
                 sequence where the first number is smaller than the second, the
                 second is equal to the third, and the third is greater than the
                 fourth. In the array nums, the subarrays [1,4,4,1], and
                 [3,5,5,3] match this pattern. Hence, there are 2 subarrays in
                 nums that match the pattern.

    Constraints:
    * 2 <= n == nums.length <= 100
    * 1 <= nums[i] <= 10^9
    * 1 <= m == pattern.length < n
    * -1 <= pattern[i] <= 1*/

    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {
        vector<int> text;
        for (int i = 1; i < nums.size(); ++i) {
            int diff = nums[i] - nums[i-1];
            if (diff) diff /= abs(diff);
            text.push_back(diff);
        }
        vector<int> lps(1);
        for (int i = 1, k = 0; i < pattern.size(); ++i) {
            while (k && pattern[k] != pattern[i]) k = lps[k-1];
            if (pattern[k] == pattern[i]) ++k;
            lps.push_back(k);
        }
        int ans = 0;
        for (int i = 0, k = 0; i < text.size(); ++i) {
            while (k && (k == pattern.size() || pattern[k] != text[i])) k = lps[k-1];
            if (pattern[k] == text[i]) ++k;
            if (k == pattern.size()) ++ans;
        }
        return ans;
    }


    /*3035. Maximum Palindromes After Operations (Medium)
    You are given a 0-indexed string array words having length n and containing
    0-indexed strings. You are allowed to perform the following operation any
    number of times (including zero):
    * Choose integers i, j, x, and y such that 0 <= i, j < n,
      0 <= x < words[i].length, 0 <= y < words[j].length, and swap the
      characters words[i][x] and words[j][y].
    Return an integer denoting the maximum number of palindromes words can
    contain, after performing some operations. Note: i and j may be equal during
    an operation.

    Example 1:
    Input: words = ["abbb","ba","aa"]
    Output: 3
    Explanation: In this example, one way to get the maximum number of
                 palindromes is:
                 - Choose i = 0, j = 1, x = 0, y = 0, so we swap words[0][0] and
                   words[1][0]. words becomes ["bbbb","aa","aa"].
                 All strings in words are now palindromes. Hence, the maximum
                 number of palindromes achievable is 3.

    Example 2:
    Input: words = ["abc","ab"]
    Output: 2
    Explanation: In this example, one way to get the maximum number of
                 palindromes is:
                 - Choose i = 0, j = 1, x = 1, y = 0, so we
                   words[1][0]. words becomes ["aac","bb"].
                 - Choose i = 0, j = 0, x = 1, y = 2, so we swap words[0][1] and
                   words[0][2]. words becomes ["aca","bb"].
                 Both strings are now palindromes. Hence, the maximum number of
                 palindromes achievable is 2.

    Example 3:
    Input: words = ["cd","ef","a"]
    Output: 1
    Explanation: In this example, there is no need to perform any operation.
                 There is one palindrome in words "a". It can be shown that it
                 is not possible to get more than one palindrome after any
                 number of operations. Hence, the answer is 1.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 100
    * words[i] consists only of lowercase English letters.*/

    int maxPalindromesAfterOperations(vector<string>& words) {
        vector<int> freq(26);
        for (auto& word : words)
            for (auto& ch : word)
                ++freq[ch-97];
        int pairs = accumulate(freq.begin(), freq.end(), 0, [](auto lhs, auto rhs) { return lhs + rhs/2; });
        sort(words.begin(), words.end(), [&](auto& lhs, auto& rhs) { return lhs.size() < rhs.size(); });
        for (int i = 0; i < words.size(); ++i) {
            pairs -= words[i].size()/2;
            if (pairs < 0) return i;
        }
        return words.size();
    }


    /*3036. Number of Subarrays That Match a Pattern II (Hard)
    You are given a 0-indexed integer array nums of size n, and a 0-indexed
    integer array pattern of size m consisting of integers -1, 0, and 1. A
    subarray nums[i..j] of size m + 1 is said to match the pattern if the
    following conditions hold for each element pattern[k]:
    * nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
    * nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
    * nums[i + k + 1] < nums[i + k] if pattern[k] == -1.
    Return the count of subarrays in nums that match the pattern.

    Example 1:
    Input: nums = [1,2,3,4,5,6], pattern = [1,1]
    Output: 4
    Explanation: The pattern [1,1] indicates that we are looking for strictly
                 increasing subarrays of size 3. In the array nums, the
                 subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this
                 pattern. Hence, there are 4 subarrays in nums that match the
                 pattern.

    Example 2:
    Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
    Output: 2
    Explanation: Here, the pattern [1,0,-1] indicates that we are looking for a
                 sequence where the first number is smaller than the second, the
                 second is equal to the third, and the third is greater than the
                 fourth. In the array nums, the subarrays [1,4,4,1], and
                 [3,5,5,3] match this pattern. Hence, there are 2 subarrays in
                 nums that match the pattern.

    Constraints:
    * 2 <= n == nums.length <= 10^6
    * 1 <= nums[i] <= 10^9
    * 1 <= m == pattern.length < n
    * -1 <= pattern[i] <= 1*/

    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {
        vector<int> text;
        for (int i = 1; i < nums.size(); ++i) {
            int diff = nums[i] - nums[i-1];
            if (diff) diff /= abs(diff);
            text.push_back(diff);
        }
        vector<int> lps(1);
        for (int i = 1, k = 0; i < pattern.size(); ++i) {
            while (k && pattern[k] != pattern[i]) k = lps[k-1];
            if (pattern[k] == pattern[i]) ++k;
            lps.push_back(k);
        }
        int ans = 0;
        for (int i = 0, k = 0; i < text.size(); ++i) {
            while (k && (k == pattern.size() || pattern[k] != text[i])) k = lps[k-1];
            if (pattern[k] == text[i]) ++k;
            if (k == pattern.size()) ++ans;
        }
        return ans;
    }


    /*3037. Find Pattern in Infinite Stream II (Hard)
    You are given a binary array pattern and an object stream of class
    InfiniteStream representing a 0-indexed infinite stream of bits. The class
    InfiniteStream contains the following function:
    * int next(): Reads a single bit (which is either 0 or 1) from the stream
      and returns it.
    Return the first starting index where the pattern matches the bits read from
    the stream. For example, if the pattern is [1, 0], the first match is the
    highlighted part in the stream [0, 1, 0, 1, ...].

    Example 1:
    Input: stream = [1,1,1,0,1,1,1,...], pattern = [0,1]
    Output: 3
    Explanation: The first occurrence of the pattern [0,1] is highlighted in the
                 stream [1,1,1,0,1,...], which starts at index 3.

    Example 2:
    Input: stream = [0,0,0,0,...], pattern = [0]
    Output: 0
    Explanation: The first occurrence of the pattern [0] is highlighted in the
                 stream [0,...], which starts at index 0.

    Example 3:
    Input: stream = [1,0,1,1,0,1,1,0,1,...], pattern = [1,1,0,1]
    Output: 2
    Explanation: The first occurrence of the pattern [1,1,0,1] is highlighted in
                 the stream [1,0,1,1,0,1,...], which starts at index 2.

    Constraints:
    * 1 <= pattern.length <= 10^4
    * pattern consists only of 0 and 1.
    * stream consists only of 0 and 1.
    * The input is generated such that the pattern's start index exists in the
      first 10^5 bits of the stream.*/

    int findPattern(InfiniteStream* stream, vector<int>& pattern) {
        vector<int> lps(1);
        for (int i = 1, k = 0; i < pattern.size(); ++i) {
            while (k && pattern[k] != pattern[i]) k = lps[k-1];
            if (pattern[k] == pattern[i]) ++k;
            lps.push_back(k);
        }
        for (int i = 0, k = 0; ; ++i) {
            int ch = stream->next();
            while (k && pattern[k] != ch) k = lps[k-1];
            if (pattern[k] == ch) ++k;
            if (k == pattern.size()) return i-k+1;
        }
    }


    /*3038. Maximum Number of Operations With the Same Score I (Easy)
    Given an array of integers called nums, you can perform the following
    operation while nums contains at least 2 elements:
    * Choose the first two elements of nums and delete them.
    The score of the operation is the sum of the deleted elements. Your task is
    to find the maximum number of operations that can be performed, such that
    all operations have the same score. Return the maximum number of operations
    possible that satisfy the condition mentioned above.

    Example 1:
    Input: nums = [3,2,1,4,5]
    Output: 2
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [1,4,5].
                 - Delete the first two elements, with score 1 + 4 = 5,
                   nums = [5].
                 We are unable to perform any more operations as nums contain
                 only 1 element.

    Example 2:
    Input: nums = [3,2,6,1,4]
    Output: 1
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [6,1,4].
                 We are unable to perform any more operations as the score of
                 the next operation isn't the same as the previous one.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 1000*/

    int maxOperations(vector<int>& nums) {
        int ans = 0, score = nums[0]+nums[1];
        for (int i = 0; i+1 < nums.size(); i += 2)
            if (nums[i] + nums[i+1] == score) ++ans;
            else break;
        return ans;
    }


    /*3039. Apply Operations to Make String Empty (Medium)
    You are given a string s. Consider performing the following operation until
    s becomes empty:
    * For every alphabet character from 'a' to 'z', remove the first occurrence
      of that character in s (if it exists).
    For example, let initially s = "aabcbbca". We do the following operations:
    * Remove the underlined characters s = "aabcbbca". The resulting string is
      s = "abbca".
    * Remove the underlined characters s = "abbca". The resulting string is
      s = "ba".
    * Remove the underlined characters s = "ba". The resulting string is s = "".
    Return the value of the string s right before applying the last operation.
    In the example above, answer is "ba".

    Example 1:
    Input: s = "aabcbbca"
    Output: "ba"
    Explanation: Explained in the statement.

    Example 2:
    Input: s = "abcd"
    Output: "abcd"
    Explanation: We do the following operation:
                 - Remove the underlined characters s = "abcd". The resulting
                   string is s = "".
                 The string just before the last operation is "abcd".

    Constraints:
    * 1 <= s.length <= 5 * 10^5
    * s consists only of lowercase English letters.*/

    string lastNonEmptyString(string s) {
        int m = 0;
        unordered_map<char, int> freq;
        for (auto& ch : s) m = max(m, ++freq[ch]);
        string ans;
        for (auto it = s.rbegin(); it != s.rend(); ++it)
            if (freq[*it] == m) {
                ans.push_back(*it);
                --freq[*it];
            }
        return string(ans.rbegin(), ans.rend());
    }


    /*3040. Maximum Number of Operations With the Same Score II (Medium)
    Given an array of integers called nums, you can perform any of the following
    operation while nums contains at least 2 elements:
    * Choose the first two elements of nums and delete them.
    * Choose the last two elements of nums and delete them.
    * Choose the first and the last elements of nums and delete them.
    The score of the operation is the sum of the deleted elements. Your task is
    to find the maximum number of operations that can be performed, such that
    all operations have the same score. Return the maximum number of operations
    possible that satisfy the condition mentioned above.

    Example 1:
    Input: nums = [3,2,1,2,3,4]
    Output: 3
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [1,2,3,4].
                 - Delete the first and the last elements, with score 1 + 4 = 5,
                   nums = [2,3].
                 - Delete the first and the last elements, with score 2 + 3 = 5,
                   nums = [].
                 We are unable to perform any more operations as nums is empty.

    Example 2:
    Input: nums = [3,2,6,1,4]
    Output: 2
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [6,1,4].
                 - Delete the last two elements, with score 1 + 4 = 5,
                   nums = [6].
                 It can be proven that we can perform at most 2 operations.

    Constraints:
    * 2 <= nums.length <= 2000
    * 1 <= nums[i] <= 1000*/

    int maxOperations(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, vector<vector<int>>> memo;

        function<int(int, int, int)> fn = [&](int i, int j, int t) {
            if (i >= j) return 0;
            if (!memo.contains(t))
                memo[t] = vector<vector<int>>(n, vector<int>(n));
            if (memo[t][i][j] == 0) {
                int ans = 0;
                if (nums[i]+nums[i+1] == t) ans = max(ans, 1 + fn(i+2, j, t));
                if (nums[j-1]+nums[j] == t) ans = max(ans, 1 + fn(i, j-2, t));
                if (nums[i]+nums[j] == t) ans = max(ans, 1 + fn(i+1, j-1, t));
                memo[t][i][j] = ans;
            }
            return memo[t][i][j];
        };

        int ans = 0;
        for (auto& t : {nums[0]+nums[1], nums[n-2]+nums[n-1], nums[0]+nums[n-1]})
            ans = max(ans, fn(0, n-1, t));
        return ans;
    }


    /*3041. Maximize Consecutive Elements in an Array After Modification (Hard)
    You are given a 0-indexed array nums consisting of positive integers.
    Initially, you can increase the value of any element in the array by at most
    1. After that, you need to select one or more elements from the final array
    such that those elements are consecutive when sorted in increasing order.
    For example, the elements [3, 4, 5] are consecutive while [3, 4, 6] and
    [1, 1, 2, 3] are not. Return the maximum number of elements that you can
    select.

    Example 1:
    Input: nums = [2,1,5,1,1]
    Output: 3
    Explanation: We can increase the elements at indices 0 and 3. The resulting
                 array is nums = [3,1,5,2,1]. We select the elements [3,1,5,2,1]
                 and we sort them to obtain [1,2,3], which are consecutive. It
                 can be shown that we cannot select more than 3 consecutive
                 elements.

    Example 2:
    Input: nums = [1,4,7,10]
    Output: 1
    Explanation: The maximum consecutive elements that we can select is 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    int maxSelectedElements(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int ans = 1, n = nums.size();
        vector<vector<int>> dp(n, vector<int>(2, 1));
        for (int i = 1; i < n; ++i) {
            if (nums[i-1]+2 == nums[i]) dp[i][0] = dp[i-1][1] + 1;
            else if (nums[i-1]+1 == nums[i]) {
                dp[i][0] = dp[i-1][0] + 1;
                dp[i][1] = dp[i-1][1] + 1;
            } else if (nums[i-1] == nums[i]) {
                dp[i][0] = dp[i-1][0];
                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + 1);
            }
            ans = max({ans, dp[i][0], dp[i][1]});
        }
        return ans;
    }


    /*3042. Count Prefix and Suffix Pairs I (Easy)
    You are given a 0-indexed string array words. Let's define a boolean
    function isPrefixAndSuffix that takes two strings, str1 and str2:
    * isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a
      suffix of str2, and false otherwise.
    For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a
    prefix of "ababa" and also a suffix, but isPrefixAndSuffix("abc", "abcd") is
    false. Return an integer denoting the number of index pairs (i, j) such that
    i < j, and isPrefixAndSuffix(words[i], words[j]) is true.

    Example 1:
    Input: words = ["a","aba","ababa","aa"]
    Output: 4
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("a", "aba") is true.
                 - i = 0 and j = 2 because isPrefixAndSuffix("a", "ababa") is
                   true.
                 - i = 0 and j = 3 because isPrefixAndSuffix("a", "aa") is true.
                 - i = 1 and j = 2 because isPrefixAndSuffix("aba", "ababa") is
                   true.
                 Therefore, the answer is 4.

    Example 2:
    Input: words = ["pa","papa","ma","mama"]
    Output: 2
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("pa", "papa") is
                   true.
                 - i = 2 and j = 3 because isPrefixAndSuffix("ma", "mama") is
                   true.
                 Therefore, the answer is 2.

    Example 3:
    Input: words = ["abab","ab"]
    Output: 0
    Explanation: In this example, the only valid index pair is i = 0 and j = 1,
                 and isPrefixAndSuffix("abab", "ab") is false. Therefore, the
                 answer is 0.

    Constraints:
    * 1 <= words.length <= 50
    * 1 <= words[i].length <= 10
    * words[i] consists only of lowercase English letters.*/

    int countPrefixSuffixPairs(vector<string>& words) {
        int ans = 0;
        for (int i = 0; i < words.size(); ++i)
            for (int ii = 0; ii < i; ++ii)
                if (words[i].starts_with(words[ii]) && words[i].ends_with(words[ii])) ++ans;
        return ans;
    }


    /*3043. Find the Length of the Longest Common Prefix (Medium)
    You are given two arrays with positive integers arr1 and arr2. A prefix of a
    positive integer is an integer formed by one or more of its digits, starting
    from its leftmost digit. For example, 123 is a prefix of the integer 12345,
    while 234 is not. A common prefix of two integers a and b is an integer c,
    such that c is a prefix of both a and b. For example, 5655359 and 56554 have
    a common prefix 565 while 1223 and 43456 do not have a common prefix. You
    need to find the length of the longest common prefix between all pairs of
    integers (x, y) such that x belongs to arr1 and y belongs to arr2. Return
    the length of the longest common prefix among all pairs. If no common prefix
    exists among them, return 0.

    Example 1:
    Input: arr1 = [1,10,100], arr2 = [1000]
    Output: 3
    Explanation: There are 3 pairs (arr1[i], arr2[j]):
                 - The longest common prefix of (1, 1000) is 1.
                 - The longest common prefix of (10, 1000) is 10.
                 - The longest common prefix of (100, 1000) is 100.
                 The longest common prefix is 100 with a length of 3.

    Example 2:
    Input: arr1 = [1,2,3], arr2 = [4,4,4]
    Output: 0
    Explanation: There exists no common prefix for any pair (arr1[i], arr2[j]),
                 hence we return 0. Note that common prefixes between elements
                 of the same array do not count.

    Constraints:
    * 1 <= arr1.length, arr2.length <= 5 * 10^4
    * 1 <= arr1[i], arr2[i] <= 10^8

    class TrieNode {
    public:
        TrieNode* child[10] = {nullptr};
    };*/

    int longestCommonPrefix(vector<int>& arr1, vector<int>& arr2) {
        TrieNode *trie = new TrieNode();
        for (auto& x : arr1) {
            TrieNode *node = trie;
            for (auto& d : to_string(x)) {
                if (!node->child[d-'0']) node->child[d-'0'] = new TrieNode();
                node = node->child[d-'0'];
            }
        }
        int ans = 0;
        for (auto& x : arr2) {
            TrieNode *node = trie;
            int prefix = 0;
            for (auto& d : to_string(x)) {
                if (!node->child[d-'0']) break;
                node = node->child[d-'0'];
                ++prefix;
            }
            ans = max(ans, prefix);
        }
        return ans;
    }


    /*3044. Most Frequent Prime (Medium)
    You are given a m x n 0-indexed 2D matrix mat. From every cell, you can
    create numbers in the following way:
    * There could be at most 8 paths from the cells namely: east, south-east,
      south, south-west, west, north-west, north, and north-east.
    * Select a path from them and append digits in this path to the number being
      formed by traveling in this direction.
    * Note that numbers are generated at every step, for example, if the digits
      along the path are 1, 9, 1, then there will be three numbers generated
      along the way: 1, 19, 191.
    Return the most frequent prime number greater than 10 out of all the numbers
    created by traversing the matrix or -1 if no such prime number exists. If
    there are multiple prime numbers with the highest frequency, then return the
    largest among them. Note: It is invalid to change the direction during the
    move.

    Example 1:
    Input: mat = [[1,1],[9,9],[1,1]]
    Output: 19
    Explanation: From cell (0,0) there are 3 possible directions and the numbers
                 greater than 10 which can be created in those directions are:
                 East: [11], South-East: [19], South: [19,191].
                 - Numbers greater than 10 created from the cell (0,1) in all
                   possible directions are: [19,191,19,11].
                 - Numbers greater than 10 created from the cell (1,0) in all
                   possible directions are: [99,91,91,91,91].
                 - Numbers greater than 10 created from the cell (1,1) in all
                   possible directions are: [91,91,99,91,91].
                 - Numbers greater than 10 created from the cell (2,0) in all
                   possible directions are: [11,19,191,19].
                 - Numbers greater than 10 created from the cell (2,1) in all
                   possible directions are: [11,19,19,191].
                 The most frequent prime number among all the created numbers is
                 19.

    Example 2:
    Input: mat = [[7]]
    Output: -1
    Explanation: The only number which can be formed is 7. It is a prime number
                 however it is not greater than 10, so return -1.

    Example 3:
    Input: mat = [[9,7,8],[4,6,5],[2,8,6]]
    Output: 97
    Explanation: - Numbers greater than 10 created from the cell (0,0) in all
                   possible directions are: [97,978,96,966,94,942].
                 - Numbers greater than 10 created from the cell (0,1) in all
                   possible directions are: [78,75,76,768,74,79].
                 - Numbers greater than 10 created from the cell (0,2) in all
                   possible directions are: [85,856,86,862,87,879].
                 - Numbers greater than 10 created from the cell (1,0) in all
                   possible directions are: [46,465,48,42,49,47].
                 - Numbers greater than 10 created from the cell (1,1) in all
                   possible directions are: [65,66,68,62,64,69,67,68].
                 - Numbers greater than 10 created from the cell (1,2) in all
                   possible directions are: [56,58,56,564,57,58].
                 - Numbers greater than 10 created from the cell (2,0) in all
                   possible directions are: [28,286,24,249,26,268].
                 - Numbers greater than 10 created from the cell (2,1) in all
                   possible directions are: [86,82,84,86,867,85].
                 - Numbers greater than 10 created from the cell (2,2) in all
                   possible directions are: [68,682,66,669,65,658].
                 The most frequent prime number among all the created numbers is
                 97.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 6
    * 1 <= mat[i][j] <= 9*/

    int mostFrequentPrime(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size(), dir[] = {-1, -1, 0, 1, 0, -1, 1, 1, -1};

        auto check = [](int x) {
            for (int p = 2; p <= sqrt(x); ++p)
                if (x % p == 0) return false;
            return true;
        };

        int ans = -1;
        unordered_map<int, int> freq;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                for (int k = 0; k < 8; ++k) {
                    int di = dir[k], dj = dir[k+1];
                    for (int ii = i, jj = j, prefix = 0; 0 <= ii && ii < m && 0 <= jj && jj < n; ii += di, jj += dj) {
                        prefix = 10*prefix + mat[ii][jj];
                        if (prefix > 10 && check(prefix)) {
                            ++freq[prefix];
                            if (ans == -1 || freq[ans] < freq[prefix] || freq[ans] == freq[prefix] && ans < prefix)
                                ans = prefix;
                        }
                    }
                }
        return ans;
    }


    /*3045. Count Prefix and Suffix Pairs II (Hard)
    You are given a 0-indexed string array words. Let's define a boolean
    function isPrefixAndSuffix that takes two strings, str1 and str2:
    * isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a
      suffix of str2, and false otherwise.
    For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a
    prefix of "ababa" and also a suffix, but isPrefixAndSuffix("abc", "abcd") is
    false. Return an integer denoting the number of index pairs (i, j) such that
    i < j, and isPrefixAndSuffix(words[i], words[j]) is true.

    Example 1:
    Input: words = ["a","aba","ababa","aa"]
    Output: 4
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("a", "aba") is true.
                 - i = 0 and j = 2 because isPrefixAndSuffix("a", "ababa") is
                   true.
                 - i = 0 and j = 3 because isPrefixAndSuffix("a", "aa") is true.
                 - i = 1 and j = 2 because isPrefixAndSuffix("aba", "ababa") is
                   true.
                 Therefore, the answer is 4.

    Example 2:
    Input: words = ["pa","papa","ma","mama"]
    Output: 2
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("pa", "papa") is
                   true.
                 - i = 2 and j = 3 because isPrefixAndSuffix("ma", "mama") is
                   true.
                 Therefore, the answer is 2.

    Example 3:
    Input: words = ["abab","ab"]
    Output: 0
    Explanation: In this example, the only valid index pair is i = 0 and j = 1,
                 and isPrefixAndSuffix("abab", "ab") is false. Therefore, the
                 answer is 0.

    Constraints:
    * 1 <= words.length <= 10^5
    * 1 <= words[i].length <= 10^5
    * words[i] consists only of lowercase English letters.
    * The sum of the lengths of all words[i] does not exceed 5 * 10^5.

    class TrieNode {
    public:
        unordered_map<string, TrieNode*> child;
        int count = 0;
        ~TrieNode() = default;
    };*/

    long long countPrefixSuffixPairs(vector<string>& words) {
        long long ans = 0;
        TrieNode* trie = new TrieNode();
        for (auto& w : words) {
            TrieNode* node = trie;
            for (int i = 0, n = w.size(); i < n; ++i) {
                string k = string() + w[i] + w[n-1-i];
                if (!node->child.contains(k))
                    node->child[k] = new TrieNode();
                node = node->child[k];
                ans += node->count;
            }
            ++node->count;
        }
        return ans;
    }


    /*3063. Linked List Frequency (Medium)
    Given the head of a linked list containing k distinct elements, return the
    head to a linked list of length k containing the frequency of each distinct
    element in the given linked list in any order.

    Example 1:
    Input: head = [1,1,1,2,2,3]
    Output: [3,2,1]
    Explanation: There are 3 distinct elements in the list. The frequency of 1
                 is 3, the frequency of 2 is 2 and the frequency of 3 is 1.
                 Hence, we return 3 -> 2 -> 1. Note that 1 -> 2 -> 3,
                 1 -> 3 -> 2, 2 -> 1 -> 3, 2 -> 3 -> 1, and 3 -> 1 -> 2 are also
                 valid answers.

    Example 2:
    Input: head = [1,1,2,2,2]
    Output: [2,3]
    Explanation: There are 2 distinct elements in the list. The frequency of 1
                 is 2 and the frequency of 2 is 3. Hence, we return 2 -> 3.

    Example 3:
    Input: head = [6,5,4,3,2,1]
    Output: [1,1,1,1,1,1]
    Explanation: There are 6 distinct elements in the list. The frequency of
                 each of them is 1. Hence, we return 1 -> 1 -> 1 -> 1 -> 1 -> 1.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5*/

    ListNode* frequenciesOfElements(ListNode* head) {
        ListNode *node = new ListNode(), *dummy = node;
        for (int prev = 0; head; head = head->next) {
            if (prev != head->val)
                node = node->next = new ListNode();
            ++node->val;
            prev = head->val;
        }
        return dummy->next;
    }


    /*3064. Guess the Number Using Bitwise Questions I (Medium)
    There is a number n that you have to find. There is also a pre-defined API
    int commonSetBits(int num), which returns the number of bits where both n
    and num are 1 in that position of their binary representation. In other
    words, it returns the number of set bits in n & num, where & is the bitwise
    AND operator. Return the number n.

    Example 1:
    Input: n = 31
    Output: 31
    Explanation: It can be proven that it's possible to find 31 using the
                 provided API.

    Example 2:
    Input: n = 33
    Output: 33
    Explanation: It can be proven that it's possible to find 33 using the
                 provided API.

    Constraints:
    * 1 <= n <= 2^30 - 1
    * 0 <= num <= 2^30 - 1
    * If you ask for some num out of the given range, the output wouldn't be
      reliable.*/

    int findNumber() {
        int ans = 0;
        for (int i = 0; i < 30; ++i)
            if (commonSetBits(1<<i))
                ans ^= 1<<i;
        return ans;
    }


    /*3065. Minimum Operations to Exceed Threshold Value I (Easy)
    You are given a 0-indexed integer array nums, and an integer k. In one
    operation, you can remove one occurrence of the smallest element of nums.
    Return the minimum number of operations needed so that all elements of the
    array are greater than or equal to k.

    Example 1:
    Input: nums = [2,11,10,1,3], k = 10
    Output: 3
    Explanation: After one operation, nums becomes equal to [2, 11, 10, 3].
                 After two operations, nums becomes equal to [11, 10, 3].
                 After three operations, nums becomes equal to [11, 10].
                 At this stage, all the elements of nums are greater than or
                 equal to 10 so we can stop. It can be shown that 3 is the
                 minimum number of operations needed so that all elements of the
                 array are greater than or equal to 10.

    Example 2:
    Input: nums = [1,1,2,4,9], k = 1
    Output: 0
    Explanation: All elements of the array are greater than or equal to 1 so we
                 do not need to apply any operations on nums.

    Example 3:
    Input: nums = [1,1,2,4,9], k = 9
    Output: 4
    Explanation: only a single element of nums is greater than or equal to 9 so
                 we need to apply the operations 4 times on nums.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9
    * The input is generated such that there is at least one index i such that
      nums[i] >= k.*/

    int minOperations(vector<int>& nums, int k) {
        return count_if(nums.begin(), nums.end(), [&](auto& x) { return x < k; });
    }


    /*3066. Minimum Operations to Exceed Threshold Value II (Medium)
    You are given a 0-indexed integer array nums, and an integer k. In one
    operation, you will:
    * Take the two smallest integers x and y in nums.
    * Remove x and y from nums.
    * Add min(x, y) * 2 + max(x, y) anywhere in the array.
    Note that you can only apply the described operation if nums contains at
    least two elements. Return the minimum number of operations needed so that
    all elements of the array are greater than or equal to k.

    Example 1:
    Input: nums = [2,11,10,1,3], k = 10
    Output: 2
    Explanation: In the first operation, we remove elements 1 and 2, then add
                 1 * 2 + 2 to nums. nums becomes equal to [4, 11, 10, 3]. In the
                 second operation, we remove elements 3 and 4, then add
                 3 * 2 + 4 to nums. nums becomes equal to [10, 11, 10]. At this
                 stage, all the elements of nums are greater than or equal to 10
                 so we can stop. It can be shown that 2 is the minimum number of
                 operations needed so that all elements of the array are greater
                 than or equal to 10.

    Example 2:
    Input: nums = [1,1,2,4,9], k = 20
    Output: 4
    Explanation: After one operation, nums becomes equal to [2, 4, 9, 3].
                 After two operations, nums becomes equal to [7, 4, 9].
                 After three operations, nums becomes equal to [15, 9].
                 After four operations, nums becomes equal to [33].
                 At this stage, all the elements of nums are greater than 20 so
                 we can stop. It can be shown that 4 is the minimum number of
                 operations needed so that all elements of the array are greater
                 than or equal to 20.

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9
    * The input is generated such that an answer always exists. That is, there
      exists some sequence of operations after which all elements of the array
      are greater than or equal to k.*/

    int minOperations(vector<int>& nums, int k) {
        int n = nums.size();
        priority_queue<long, vector<long>, greater<>> pq;
        for (auto& x : nums)
            pq.push(x);
        while (pq.top() < k) {
            long v = pq.top()*2; pq.pop();
            v += pq.top(); pq.pop();
            pq.push(v);
        }
        return n - pq.size();
    }


    /*3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)
    You are given an unrooted weighted tree with n vertices representing servers
    numbered from 0 to n - 1, an array edges where edges[i] = [ai, bi, weighti]
    represents a bidirectional edge between vertices ai and bi of weight
    weighti. You are also given an integer signalSpeed. Two servers a and b are
    connectable through a server c if:
    * a < b, a != c and b != c.
    * The distance from c to a is divisible by signalSpeed.
    * The distance from c to b is divisible by signalSpeed.
    * The path from c to b and the path from c to a do not share any edges.
    Return an integer array count of length n where count[i] is the number of
    server pairs that are connectable through the server i.

    Example 1:
    Input: edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1
    Output: [0,4,6,6,4,0]
    Explanation: Since signalSpeed is 1, count[c] is equal to the number of
                 pairs of paths that start at c and do not share any edges. In
                 the case of the given path graph, count[c] is equal to the
                 number of servers to the left of c multiplied by the servers to
                 the right of c.

    Example 2:
    Input: edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3
    Output: [2,0,0,0,0,0,2]
    Explanation: Through server 0, there are 2 pairs of connectable servers:
                 (4, 5) and (4, 6). Through server 6, there are 2 pairs of
                 connectable servers: (4, 5) and (0, 5). It can be shown that no
                 two servers are connectable through servers other than 0 and 6.

    Constraints:
    * 2 <= n <= 1000
    * edges.length == n - 1
    * edges[i].length == 3
    * 0 <= ai, bi < n
    * edges[i] = [ai, bi, weighti]
    * 1 <= weighti <= 10^6
    * 1 <= signalSpeed <= 106^
    * The input is generated such that edges represents a valid tree.*/

    vector<int> countPairsOfConnectableServers(vector<vector<int>>& edges, int signalSpeed) {
        int n = edges.size()+1;
        vector<vector<pair<int, int>>> tree(n);
        for (auto& e : edges) {
            int u = e[0], v = e[1], w = e[2];
            tree[u].emplace_back(v, w);
            tree[v].emplace_back(u, w);
        }
        vector<int> ans(n);
        for (int x = 0; x < n; ++x) {
            int prefix = 0;
            for (auto& [v, w] : tree[x]) {
                int cnt = 0;
                stack<tuple<int, int, int>> stk;
                stk.emplace(x, v, w);
                while (stk.size()) {
                    auto [p, u, w] = stk.top(); stk.pop();
                    if (w % signalSpeed == 0) ++cnt;
                    for (auto& [v, wt] : tree[u])
                        if (v != p)
                            stk.emplace(u, v, w+wt);
                }
                ans[x] += prefix*cnt;
                prefix += cnt;
            }
        }
        return ans;
    }


    /*3068. Find the Maximum Sum of Node Values (Hard)
    There exists an undirected tree with n nodes numbered 0 to n - 1. You are
    given a 0-indexed 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi
    in the tree. You are also given a positive integer k, and a 0-indexed array
    of non-negative integers nums of length n, where nums[i] represents the
    value of the node numbered i. Bogdan wants the sum of values of tree nodes
    to be maximum, for which Bogdan can perform the following operation any
    number of times (including zero) on the tree:
    * Choose any edge [u, v] connecting the nodes u and v, and update their
      values as follows:
      + nums[u] = nums[u] XOR k
      + nums[v] = nums[v] XOR k
    Return the maximum possible sum of the values Bogdan can achieve by
    performing the operation any number of times.

    Example 1:
    Input: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]
    Output: 6
    Explanation: Bogdan can achieve the maximum sum of 6 using a single
                 operation:
                 - Choose the edge [0,2]. nums[0] and nums[2] become:
                   1 XOR 3 = 2, and the array nums becomes: [1,2,1] -> [2,2,2].
                 The total sum of values is 2 + 2 + 2 = 6. It can be shown that
                 6 is the maximum achievable sum of values.

    Example 2:
    Input: nums = [2,3], k = 7, edges = [[0,1]]
    Output: 9
    Explanation: Bogdan can achieve the maximum sum of 9 using a single
                 operation:
                 - Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and
                   nums[1] become: 3 XOR 7 = 4, and the array nums becomes:
                   [2,3] -> [5,4].
                 The total sum of values is 5 + 4 = 9. It can be shown that 9 is
                 the maximum achievable sum of values.

    Example 3:
    Input: nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]]
    Output: 42
    Explanation: The maximum achievable sum is 42 which can be achieved by
                 Bogdan performing no operations.

    Constraints:
    * 2 <= n == nums.length <= 2 * 10^4
    * 1 <= k <= 10^9
    * 0 <= nums[i] <= 10^9
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * The input is generated such that edges represent a valid tree.*/

    long long maximumValueSum(vector<int>& nums, int k, vector<vector<int>>& edges) {
        long long ans = 0;
        int cnt = 0, diff = INT_MAX;
        for (auto& x : nums) {
            int xx = x ^ k;
            if (x < xx) cnt ^= 1;
            ans += max(x, xx);
            diff = min(diff, abs(x-xx));
        }
        return cnt ? ans - diff : ans;
    }


    /*3074. Apple Redistribution into Boxes (Easy)
    You are given an array apple of size n and an array capacity of size m.
    There are n packs where the ith pack contains apple[i] apples. There are m
    boxes as well, and the ith box has a capacity of capacity[i] apples. Return
    the minimum number of boxes you need to select to redistribute these n packs
    of apples into boxes. Note that, apples from the same pack can be
    distributed into different boxes.

    Example 1:
    Input: apple = [1,3,2], capacity = [4,3,1,5,2]
    Output: 2
    Explanation: We will use boxes with capacities 4 and 5. It is possible to
                 distribute the apples as the total capacity is greater than or
                 equal to the total number of apples.

    Example 2:
    Input: apple = [5,5,5], capacity = [2,4,2,7]
    Output: 4
    Explanation: We will need to use all the boxes.

    Constraints:
    * 1 <= n == apple.length <= 50
    * 1 <= m == capacity.length <= 50
    * 1 <= apple[i], capacity[i] <= 50
    * The input is generated such that it's possible to redistribute packs of
      apples into boxes.*/

    int minimumBoxes(vector<int>& apple, vector<int>& capacity) {
        int total = accumulate(apple.begin(), apple.end(), 0);
        sort(capacity.begin(), capacity.end(), [&](auto& x, auto& y) { return x > y; });
        for (int i = 0; i < capacity.size(); ++i) {
            total -= capacity[i];
            if (total <= 0) return i+1;
        }
        return -1;
    }


    /*3075. Maximize Happiness of Selected Children (Medium)
    You are given an array happiness of length n, and a positive integer k.
    There are n children standing in a queue, where the ith child has happiness
    value happiness[i]. You want to select k children from these n children in k
    turns. In each turn, when you select a child, the happiness value of all the
    children that have not been selected till now decreases by 1. Note that the
    happiness value cannot become negative and gets decremented only if it is
    positive. Return the maximum sum of the happiness values of the selected
    children you can achieve by selecting k children.

    Example 1:
    Input: happiness = [1,2,3], k = 2
    Output: 4
    Explanation: We can pick 2 children in the following way:
                 - Pick the child with the happiness value == 3. The happiness
                   value of the remaining children becomes [0,1].
                 - Pick the child with the happiness value == 1. The happiness
                   value of the remaining child becomes [0]. Note that the
                   happiness value cannot become less than 0.
                 The sum of the happiness values of the selected children is
                 3 + 1 = 4.

    Example 2:
    Input: happiness = [1,1,1,1], k = 2
    Output: 1
    Explanation: We can pick 2 children in the following way:
                 - Pick any child with the happiness value == 1. The happiness
                   value of the remaining children becomes [0,0,0].
                 - Pick the child with the happiness value == 0. The happiness
                   value of the remaining child becomes [0,0].
                 The sum of the happiness values of the selected children is
                 1 + 0 = 1.
    Example 3:
    Input: happiness = [2,3,4,5], k = 1
    Output: 5
    Explanation: We can pick 1 child in the following way:
                 - Pick the child with the happiness value == 5. The happiness
                   value of the remaining children becomes [1,2,3].
                 The sum of the happiness values of the selected children is 5.

    Constraints:
    * 1 <= n == happiness.length <= 2 * 10^5
    * 1 <= happiness[i] <= 10^8
    * 1 <= k <= n*/

    long long maximumHappinessSum(vector<int>& happiness, int k) {
        sort(happiness.begin(), happiness.end(), [&](auto& x, auto& y) { return x > y; });
        long long ans = 0;
        for (int i = 0; i < k; ++i)
            ans += max(0, happiness[i]-i);
        return ans;
    }


    /*3076. Shortest Uncommon Substring in an Array (Medium)
    You are given an array arr of size n consisting of non-empty strings. Find a
    string array answer of size n such that:
    * answer[i] is the shortest substring of arr[i] that does not occur as a
      substring in any other string in arr. If multiple such substrings exist,
      answer[i] should be the lexicographically smallest. And if no such
      substring exists, answer[i] should be an empty string.
    Return the array answer.

    Example 1:
    Input: arr = ["cab","ad","bad","c"]
    Output: ["ab","","ba",""]
    Explanation: We have the following:
                 - For the string "cab", the shortest substring that does not
                   occur in any other string is either "ca" or "ab", we choose
                   the lexicographically smaller substring, which is "ab".
                 - For the string "ad", there is no substring that does not
                   occur in any other string.
                 - For the string "bad", the shortest substring that does not
                   occur in any other string is "ba".
                 - For the string "c", there is no substring that does not occur
                   in any other string.

    Example 2:
    Input: arr = ["abc","bcd","abcd"]
    Output: ["","","abcd"]
    Explanation: We have the following:
                 - For the string "abc", there is no substring that does not
                   occur in any other string.
                 - For the string "bcd", there is no substring that does not
                   occur in any other string.
                 - For the string "abcd", the shortest substring that does not
                   occur in any other string is "abcd".

    Constraints:
    * n == arr.length
    * 2 <= n <= 100
    * 1 <= arr[i].length <= 20
    * arr[i] consists only of lowercase English letters.*/

    vector<string> shortestSubstrings(vector<string>& arr) {
        unordered_map<string, vector<int>> seen;
        for (int i = 0; i < arr.size(); ++i) {
            string word = arr[i];
            for (int j = 0, n = word.size(); j < n; ++j)
                for (int k = j; k < n; ++k) {
                    string key = word.substr(j, k-j+1);
                    if (!seen.count(key) || seen[key].back() != i) seen[key].push_back(i);
                }
        }
        vector<string> ans(arr.size(), "");
        for (auto& [k, v] : seen)
            if (v.size() == 1) {
                int i = v.back();
                if (ans[i] == "" || k.size() < ans[i].size() || k.size() == ans[i].size() && k < ans[i])
                    ans[i] = k;
            }
        return ans;
    }


    /*3077. Maximum Strength of K Disjoint Subarrays (Hard)
    You are given a 0-indexed array of integers nums of length n, and a positive
    odd integer k. The strength of x subarrays is defined as
    strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1
    where sum[i] is the sum of the elements in the ith subarray. Formally,
    strength is sum of (-1)i+1 * sum[i] * (x - i + 1) over all i's such that
    1 <= i <= x. You need to select k disjoint subarrays from nums, such that
    their strength is maximum. Return the maximum possible strength that can be
    obtained. Note that the selected subarrays don't need to cover the entire
    array.

    Example 1:
    Input: nums = [1,2,3,-1,2], k = 3
    Output: 22
    Explanation: The best possible way to select 3 subarrays is: nums[0..2],
                 nums[3..3], and nums[4..4]. The strength is
                 (1 + 2 + 3) * 3 - (-1) * 2 + 2 * 1 = 22.

    Example 2:
    Input: nums = [12,-2,-2,-2,-2], k = 5
    Output: 64
    Explanation: The only possible way to select 5 disjoint subarrays is:
                 nums[0..0], nums[1..1], nums[2..2], nums[3..3], and nums[4..4].
                 The strength is
                 12 * 5 - (-2) * 4 + (-2) * 3 - (-2) * 2 + (-2) * 1 = 64.

    Example 3:
    Input: nums = [-1,-2,-3], k = 1
    Output: -1
    Explanation: The best possible way to select 1 subarray is: nums[0..0]. The
                 strength is -1.

    Constraints:
    * 1 <= n <= 10^4
    * -10^9 <= nums[i] <= 10^9
    * 1 <= k <= n
    * 1 <= n * k <= 10^6
    * k is odd.*/

    long long maximumStrength(vector<int>& nums, int k) {
        vector<vector<long long>> dp(k+1, vector<long long>(2, -1e17));
        dp[0][0] = dp[0][1] = 0;
        for (int i = nums.size()-1; i >= 0; --i)
            for (int j = k; j > 0; --j) {
                long long cand = pow(-1l, k-j)*nums[i]*j + max(dp[j][1], dp[j-1][0]);
                dp[j][0] = max(cand, dp[j][0]);
                dp[j][1] = max(cand, dp[j-1][0]);
            }
        return dp[k][0];
    }


    /*3079. Find the Sum of Encrypted Integers (Easy)
    You are given an integer array nums containing positive integers. We define
    a function encrypt such that encrypt(x) replaces every digit in x with the
    largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.
    Return the sum of encrypted elements.

    Example 1:
    Input: nums = [1,2,3]
    Output: 6
    Explanation: The encrypted elements are [1,2,3]. The sum of encrypted
                 elements is 1 + 2 + 3 == 6.

    Example 2:
    Input: nums = [10,21,31]
    Output: 66
    Explanation: The encrypted elements are [11,22,33]. The sum of encrypted
                 elements is 11 + 22 + 33 == 66.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 1000*/

    int sumOfEncryptedInt(vector<int>& nums) {
        int ans = 0;
        for (auto x : nums) {
            int most = 0, mul = 0;
            for (; x; x /= 10) {
                most = max(most, x % 10);
                mul = 10*mul + 1;
            }
            ans += most * mul;
        }
        return ans;
    }


    /*3080. Mark Elements on Array by Performing Queries (Medium)
    You are given a 0-indexed array nums of size n consisting of positive
    integers. You are also given a 2D array queries of size m where
    queries[i] = [indexi, ki]. Initially all elements of the array are unmarked.
    You need to apply m queries on the array in order, where on the ith query
    you do the following:
    * Mark the element at index indexi if it is not already marked.
    * Then mark ki unmarked elements in the array with the smallest values. If
      multiple such elements exist, mark the ones with the smallest indices. And
      if less than ki unmarked elements exist, then mark all of them.
    Return an array answer of size m where answer[i] is the sum of unmarked
    elements in the array after the ith query.

    Example 1:
    Input: nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]
    Output: [8,3,0]
    Explanation: We do the following queries on the array:
                 - Mark the element at index 1, and 2 of the smallest unmarked
                   elements with the smallest indices if they exist, the marked
                   elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked
                   elements is 2 + 2 + 3 + 1 = 8.
                 - Mark the element at index 3, since it is already marked we
                   skip it. Then we mark 3 of the smallest unmarked elements
                   with the smallest indices, the marked elements now are
                   nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 3.
                 - Mark the element at index 4, since it is already marked we
                   skip it. Then we mark 2 of the smallest unmarked elements
                   with the smallest indices if they exist, the marked elements
                   now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements
                   is 0.

    Example 2:
    Input: nums = [1,4,2,3], queries = [[0,1]]
    Output: [7]
    Explanation: We do one query which is mark the element at index 0 and mark
                 the smallest element among unmarked elements. The marked
                 elements will be nums = [1,4,2,3], and the sum of unmarked
                 elements is 4 + 3 = 7.

    Constraints:
    * n == nums.length
    * m == queries.length
    * 1 <= m <= n <= 10^5
    * 1 <= nums[i] <= 10^5
    * queries[i].length == 2
    * 0 <= indexi, ki <= n - 1*/

    vector<long long> unmarkedSumArray(vector<int>& nums, vector<vector<int>>& queries) {
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        for (int i = 0; i < nums.size(); ++i)
            pq.emplace(nums[i], i);
        long long suffix = accumulate(nums.begin(), nums.end(), 0ll);
        vector<long long> ans;
        for (auto& q : queries) {
            int i = q[0], k = q[1];
            if (nums[i]) {
                suffix -= nums[i];
                nums[i] = 0;
            }
            while (k && pq.size()) {
                auto [_, j] = pq.top(); pq.pop();
                if (nums[j]) {
                    --k;
                    suffix -= nums[j];
                    nums[j] = 0;
                }
            }
            ans.push_back(suffix);
        }
        return ans;
    }


    /*3081. Replace Question Marks in String to Minimize Its Value (Medium)
    You are given a string s. s[i] is either a lowercase English letter or '?'.
    For a string t having length m containing only lowercase English letters, we
    define the function cost(i) for an index i as the number of characters equal
    to t[i] that appeared before it, i.e. in the range [0, i - 1]. The value of
    t is the sum of cost(i) for all indices i. For example, for the string
    t = "aab":
    * cost(0) = 0
    * cost(1) = 1
    * cost(2) = 0
    * Hence, the value of "aab" is 0 + 1 + 0 = 1.
    Your task is to replace all occurrences of '?' in s with any lowercase
    English letter so that the value of s is minimized. Return a string denoting
    the modified string with replaced occurrences of '?'. If there are multiple
    strings resulting in the minimum value, return the lexicographically
    smallest one.

    Example 1:
    Input:  s = "???"
    Output:  "abc"
    Explanation: In this example, we can replace the occurrences of '?' to make
                 s equal to "abc". For "abc", cost(0) = 0, cost(1) = 0, and
                 cost(2) = 0. The value of "abc" is 0. Some other modifications
                 of s that have a value of 0 are "cba", "abz", and, "hey". Among
                 all of them, we choose the lexicographically smallest.

    Example 2:
    Input: s = "a?a?"
    Output: "abac"
    Explanation: In this example, the occurrences of '?' can be replaced to make
                 s equal to "abac". For "abac", cost(0) = 0, cost(1) = 0,
                 cost(2) = 1, and cost(3) = 0. The value of "abac" is 1.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either a lowercase English letter or '?'.*/

    string minimizeStringValue(string s) {
        vector<int> loc, freq(26);
        for (int i = 0; i < s.size(); ++i)
            if (s[i] != '?') ++freq[s[i] - 'a'];
            else loc.push_back(i);
        priority_queue<pair<int, char>, vector<pair<int, char>>, greater<>> pq;
        for (int i = 0; i < 26; ++i)
            pq.emplace(freq[i], 'a' + i);
        vector<char> vals;
        for (auto& _ : loc) {
            auto [x, c] = pq.top(); pq.pop();
            vals.push_back(c);
            pq.emplace(x+1, c);
        }
        sort(vals.begin(), vals.end());
        for (int i = 0; i < loc.size(); ++i)
            s[loc[i]] = vals[i];
        return s;
    }


    /*3082. Find the Sum of the Power of All Subsequences (Hard)
    You are given an integer array nums of length n and a positive integer k.
    The power of an array of integers is defined as the number of subsequences
    with their sum equal to k. Return the sum of power of all subsequences of
    nums. Since the answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input:  nums = [1,2,3], k = 3
    Output:  6
    Explanation: There are 5 subsequences of nums with non-zero power:
                 - The subsequence [1,2,3] has 2 subsequences with sum == 3:
                   [1,2,3] and [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 Hence the answer is 2 + 1 + 1 + 1 + 1 = 6.

    Example 2:
    Input:  nums = [2,3,3], k = 5
    Output:  4
    Explanation: There are 3 subsequences of nums with non-zero power:
                 - The subsequence [2,3,3] has 2 subsequences with sum == 5:
                   [2,3,3] and [2,3,3].
                 - The subsequence [2,3,3] has 1 subsequence with sum == 5:
                   [2,3,3].
                 - The subsequence [2,3,3] has 1 subsequence with sum == 5:
                   [2,3,3].
                 Hence the answer is 2 + 1 + 1 = 4.

    Example 3:
    Input:  nums = [1,2,3], k = 7
    Output:  0
    Explanation: There exists no subsequence with sum 7. Hence all subsequences
                 of nums have power = 0.

    Constraints:
    * 1 <= n <= 100
    * 1 <= nums[i] <= 10^4
    * 1 <= k <= 100*/

    int sumOfPower(vector<int>& nums, int k) {
        int n = nums.size(), mod = 1'000'000'007;
        vector<vector<long>> dp(n+1, vector<long>(k+1));
        dp[0][0] = 1;
        vector<long> p2(n+1, 1);
        for (int i = 1; i <= n; ++i)
            p2[i] = p2[i-1]*2 % mod;
        for (auto& x : nums)
            for (int i = n; i > 0; --i)
                for (int j = k; j >= x; --j)
                    dp[i][j] = (dp[i][j] + dp[i-1][j-x]) % mod;
        long ans = 0;
        for (int i = 0; i <= n; ++i)
            ans = (ans + dp[i][k]*p2[n-i]) % mod;
        return ans;
    }


    /*3083. Existence of a Substring in a String and Its Reverse (Easy)
    Given a string s, find any substring of length 2 which is also present in
    the reverse of s. Return true if such a substring exists, and false
    otherwise.

    Example 1:
    Input: s = "leetcode"
    Output: true
    Explanation: Substring "ee" is of length 2 which is also present in
                 reverse(s) == "edocteel".

    Example 2:
    Input: s = "abcba"
    Output: true
    Explanation: All of the substrings of length 2 "ab", "bc", "cb", "ba" are
                 also present in reverse(s) == "abcba".

    Example 3:
    Input: s = "abcd"
    Output: false
    Explanation: There is no substring of length 2 in s, which is also present
                 in the reverse of s.

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of lowercase English letters.*/

    bool isSubstringPresent(string s) {
        unordered_set<string> seen;
        for (int i = 0; i < s.size()-1; ++i)
            seen.insert(s.substr(i, 2));
        reverse(s.begin(), s.end());
        for (int i = 0; i < s.size()-1; ++i)
            if (seen.count(s.substr(i, 2))) return true;
        return false;
    }


    /*3084. Count Substrings Starting and Ending with Given Character (Medium)
    You are given a string s and a character c. Return the total number of
    substrings of s that start and end with c.

    Example 1:
    Input: s = "abada", c = "a"
    Output: 6
    Explanation: Substrings starting and ending with "a" are: "abada", "abada",
                 "abada", "abada", "abada", "abada".

    Example 2:
    Input: s = "zzz", c = "z"
    Output: 6
    Explanation: There are a total of 6 substrings in s and all start and end
                 with "z".

    Constraints:
    * 1 <= s.length <= 10^5
    * s and c consist only of lowercase English letters.*/

    long long countSubstrings(string s, char c) {
        long long n = count(s.begin(), s.end(), c);
        return n*(n+1)/2;
    }


    /*3085. Minimum Deletions to Make String K-Special (Medium)
    You are given a string word and an integer k. We consider word to be
    k-special if |freq(word[i]) - freq(word[j])| <= k for all indices i and j in
    the string. Here, freq(x) denotes the frequency of the character x in word,
    and |y| denotes the absolute value of y. Return the minimum number of
    characters you need to delete to make word k-special.

    Example 1:
    Input: word = "aabcaba", k = 0
    Output: 3
    Explanation: We can make word 0-special by deleting 2 occurrences of "a" and
                 1 occurrence of "c". Therefore, word becomes equal to "baba"
                 where freq('a') == freq('b') == 2.

    Example 2:
    Input: word = "dabdcbdcdcd", k = 2
    Output: 2
    Explanation: We can make word 2-special by deleting 1 occurrence of "a" and
                 1 occurrence of "d". Therefore, word becomes equal to
                 "bdcbdcdcd" where freq('b') == 2, freq('c') == 3, and
                 freq('d') == 4.

    Example 3:
    Input: word = "aaabaaa", k = 2
    Output: 1
    Explanation: We can make word 2-special by deleting 1 occurrence of "b".
                 Therefore, word becomes equal to "aaaaaa" where each letter's
                 frequency is now uniformly 6.

    Constraints:
    * 1 <= word.length <= 10^5
    * 0 <= k <= 10^5
    * word consists only of lowercase English letters.*/

    int minimumDeletions(string word, int k) {
        unordered_map<char, int> mp;
        for (auto& ch : word)
            ++mp[ch];
        vector<int> freq;
        transform(mp.begin(), mp.end(), back_inserter(freq), [](auto& x) { return x.second; });
        sort(freq.begin(), freq.end());
        int n = freq.size();
        vector<int> prefix(n+1);
        for (int i = 0; i < n; ++i)
            prefix[i+1] = prefix[i] + freq[i];
        int ans = INT_MAX;
        for (int i = 0, j = 0; i < n; ++i) {
            for (; j < n && freq[j] - freq[i] <= k; ++j);
            int cand = prefix[i] + prefix[n] - prefix[j] - (n-j)*(freq[i] + k);
            ans = min(ans, cand);
        }
        return ans;
    }


    /*3086. Minimum Moves to Pick K Ones (Hard)
    You are given a binary array nums of length n, a positive integer k and a
    non-negative integer maxChanges. Alice plays a game, where the goal is for
    Alice to pick up k ones from nums using the minimum number of moves. When
    the game starts, Alice picks up any index aliceIndex in the range [0, n - 1]
    and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and
    nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice
    can make any number of moves (including zero) where in each move Alice must
    perform exactly one of the following actions:
    * Select any index j != aliceIndex such that nums[j] == 0 and set
      nums[j] = 1. This action can be performed at most maxChanges times.
    * Select any two adjacent indices x and y (|x - y| == 1) such that
      nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 and
      nums[x] = 0). If y == aliceIndex, Alice picks up the one after this move
      and nums[y] becomes 0.
    Return the minimum number of moves required by Alice to pick exactly k ones.

    Example 1:
    Input: nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1
    Output: 3
    Explanation: Alice can pick up 3 ones in 3 moves, if Alice performs the
                 following actions in each move when standing at
                 aliceIndex == 1:
                 * At the start of the game Alice picks up the one and nums[1]
                   becomes 0. nums becomes [1,1,1,0,0,1,1,0,0,1].
                 * Select j == 2 and perform an action of the first type. nums
                   becomes [1,0,1,0,0,1,1,0,0,1]
                 * Select x == 2 and y == 1, and perform an action of the second
                   type. nums becomes [1,1,0,0,0,1,1,0,0,1]. As y == aliceIndex,
                   Alice picks up the one and nums becomes [1,0,0,0,0,1,1,0,0,1].
                 * Select x == 0 and y == 1, and perform an action of the second
                   type. nums becomes [0,1,0,0,0,1,1,0,0,1]. As y == aliceIndex,
                   Alice picks up the one and nums becomes [0,0,0,0,0,1,1,0,0,1].
                 Note that it may be possible for Alice to pick up 3 ones using
                 some other sequence of 3 moves.

    Example 2:
    Input: nums = [0,0,0,0], k = 2, maxChanges = 3
    Output: 4
    Explanation: Alice can pick up 2 ones in 4 moves, if Alice performs the
                 following actions in each move when standing at
                 aliceIndex == 0:
                 * Select j == 1 and perform an action of the first type. nums
                   becomes [0,1,0,0].
                 * Select x == 1 and y == 0, and perform an action of the second
                   type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks
                   up the one and nums becomes [0,0,0,0].
                 * Select j == 1 again and perform an action of the first type.
                   nums becomes [0,1,0,0].
                 * Select x == 1 and y == 0 again, and perform an action of the
                   second type. nums becomes [1,0,0,0]. As y == aliceIndex,
                   Alice picks up the one and nums becomes [0,0,0,0].

    Constraints:
    * 2 <= n <= 10^5
    * 0 <= nums[i] <= 1
    * 1 <= k <= 10^5
    * 0 <= maxChanges <= 10^5
    * maxChanges + sum(nums) >= k*/

    long long minimumMoves(vector<int>& nums, int k, int maxChanges) {
        int cnt = 0, seq = 0;
        vector<int> ones;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i]) {
                ones.push_back(i);
                ++cnt;
            } else cnt = 0;
            seq = max(seq, cnt);
        }
        seq = min({3, k, seq});
        if (seq + maxChanges >= k) return max(0, seq-1) + 2*(k-seq);
        long long ans = LONG_MAX;
        int n = k - maxChanges;
        vector<long long> prefix(1);
        for (auto& x : ones)
            prefix.push_back(prefix.back() + x);
        for (int i = 0; i <= ones.size()-n; ++i) {
            long long cand = (prefix[i+n] - prefix[i+(n+1)/2]) - (prefix[i+n/2] - prefix[i]);
            ans = min(ans, cand + 2*maxChanges);
        }
        return ans;
    }


    /*3090. Maximum Length Substring With Two Occurrences (Easy)
    Given a string s, return the maximum length of a substring such that it
    contains at most two occurrences of each character.

    Example 1:
    Input: s = "bcbbbcba"
    Output: 4
    Explanation: The following substring has a length of 4 and contains at most
                 two occurrences of each character: "bcbbbcba".

    Example 2:
    Input: s = "aaaa"
    Output: 2
    Explanation: The following substring has a length of 2 and contains at most
                 two occurrences of each character: "aaaa".

    Constraints:
    * 2 <= s.length <= 100
    * s consists only of lowercase English letters.*/

    int maximumLengthSubstring(string s) {
        int ans = 0;
        unordered_map<char, int> freq;
        for (int i = 0, ii = 0; i < s.size(); ++i) {
            ++freq[s[i]];
            while (freq[s[i]] == 3) --freq[s[ii++]];
            ans = max(ans, i-ii+1);
        }
        return ans;
    }


    /*3091. Apply Operations to Make Sum of Array Greater Than or Equal to k (Medium)
    You are given a positive integer k. Initially, you have an array nums = [1].
    You can perform any of the following operations on the array any number of
    times (possibly zero):
    * Choose any element in the array and increase its value by 1.
    * Duplicate any element in the array and add it to the end of the array.
    Return the minimum number of operations required to make the sum of elements
    of the final array greater than or equal to k.

    Example 1:
    Input: k = 11
    Output: 5
    Explanation: We can do the following operations on the array nums = [1]:
                 * Increase the element by 1 three times. The resulting array is
                   nums = [4].
                 * Duplicate the element two times. The resulting array is
                   nums = [4,4,4].
                 The sum of the final array is 4 + 4 + 4 = 12 which is greater
                 than or equal to k = 11. The total number of operations
                 performed is 3 + 2 = 5.

    Example 2:
    Input: k = 1
    Output: 0
    Explanation: The sum of the original array is already greater than or equal
                 to 1, so no operations are needed.

    Constraints: 1 <= k <= 10^5*/

    int minOperations(int k) {
        int p = sqrt(k), q = (k+p-1)/p;
        return p + q - 2;
    }


    /*3092. Most Frequent IDs (Medium)
    The problem involves tracking the frequency of IDs in a collection that
    changes over time. You have two integer arrays, nums and freq, of equal
    length n. Each element in nums represents an ID, and the corresponding
    element in freq indicates how many times that ID should be added to or
    removed from the collection at each step.
    * Addition of IDs: If freq[i] is positive, it means freq[i] IDs with the
      value nums[i] are added to the collection at step i.
    * Removal of IDs: If freq[i] is negative, it means -freq[i] IDs with the
      value nums[i] are removed from the collection at step i.
    Return an array ans of length n, where ans[i] represents the count of the
    most frequent ID in the collection after the ith step. If the collection is
    empty at any step, ans[i] should be 0 for that step.

    Example 1:
    Input: nums = [2,3,2,1], freq = [3,2,-3,1]
    Output: [3,3,2,2]
    Explanation: * After step 0, we have 3 IDs with the value of 2. So
                   ans[0] = 3.
                 * After step 1, we have 3 IDs with the value of 2 and 2 IDs
                   with the value of 3. So ans[1] = 3.
                 * After step 2, we have 2 IDs with the value of 3. So
                   ans[2] = 2.
                 * After step 3, we have 2 IDs with the value of 3 and 1 ID with
                   the value of 1. So ans[3] = 2.

    Example 2:
    Input: nums = [5,5,3], freq = [2,-2,1]
    Output: [2,0,1]
    Explanation: * After step 0, we have 2 IDs with the value of 5. So
                   ans[0] = 2.
                 * After step 1, there are no IDs. So ans[1] = 0.
                 * After step 2, we have 1 ID with the value of 3. So ans[2] = 1.

    Constraints:
    * 1 <= nums.length == freq.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * -10^5 <= freq[i] <= 10^5
    * freq[i] != 0
    * The input is generated such that the occurrences of an ID will not be
      negative in any step.*/

    vector<long long> mostFrequentIDs(vector<int>& nums, vector<int>& freq) {
        priority_queue<pair<long long, int>> pq;
        unordered_map<int, long long> cnt;
        vector<long long> ans;
        for (int i = 0, n = nums.size(); i < n; ++i) {
            int x = nums[i], f = freq[i];
            cnt[x] += f;
            while (pq.size() && cnt[pq.top().second] != pq.top().first) pq.pop();
            pq.emplace(cnt[x], x);
            ans.push_back(pq.top().first);
        }
        return ans;
    }


    /*3093. Longest Common Suffix Queries (Hard)
    You are given two arrays of strings wordsContainer and wordsQuery. For each
    wordsQuery[i], you need to find a string from wordsContainer that has the
    longest common suffix with wordsQuery[i]. If there are two or more strings
    in wordsContainer that share the longest common suffix, find the string that
    is the smallest in length. If there are two or more such strings that have
    the same smallest length, find the one that occurred earlier in
    wordsContainer. Return an array of integers ans, where ans[i] is the index
    of the string in wordsContainer that has the longest common suffix with
    wordsQuery[i].

    Example 1:
    Input: wordsContainer = ["abcd","bcd","xbcd"], wordsQuery = ["cd","bcd","xyz"]
    Output: [1,1,1]
    Explanation: Let's look at each wordsQuery[i] separately:
                 - For wordsQuery[0] = "cd", strings from wordsContainer that
                   share the longest common suffix "cd" are at indices 0, 1, and
                   2. Among these, the answer is the string at index 1 because
                   it has the shortest length of 3.
                 - For wordsQuery[1] = "bcd", strings from wordsContainer that
                   share the longest common suffix "bcd" are at indices 0, 1,
                   and 2. Among these, the answer is the string at index 1
                   because it has the shortest length of 3.
                 - For wordsQuery[2] = "xyz", there is no string from
                   wordsContainer that shares a common suffix. Hence the longest
                   common suffix is "", that is shared with strings at index 0,
                   1, and 2. Among these, the answer is the string at index 1
                   because it has the shortest length of 3.

    Example 2:
    Input: wordsContainer = ["abcdefgh","poiuygh","ghghgh"], wordsQuery = ["gh","acbfgh","acbfegh"]
    Output: [2,0,2]
    Explanation: Let's look at each wordsQuery[i] separately:
                 - For wordsQuery[0] = "gh", strings from wordsContainer that
                   share the longest common suffix "gh" are at indices 0, 1, and
                   2. Among these, the answer is the string at index 2 because
                   it has the shortest length of 6.
                 - For wordsQuery[1] = "acbfgh", only the string at index 0
                   shares the longest common suffix "fgh". Hence it is the
                   answer, even though the string at index 2 is shorter.
                 - For wordsQuery[2] = "acbfegh", strings from wordsContainer
                   that share the longest common suffix "gh" are at indices 0,
                   1, and 2. Among these, the answer is the string at index 2
                   because it has the shortest length of 6.

    Constraints:
    * 1 <= wordsContainer.length, wordsQuery.length <= 10^4
    * 1 <= wordsContainer[i].length <= 5 * 10^3
    * 1 <= wordsQuery[i].length <= 5 * 10^3
    * wordsContainer[i] consists only of lowercase English letters.
    * wordsQuery[i] consists only of lowercase English letters.
    * Sum of wordsContainer[i].length is at most 5 * 10^5.
    * Sum of wordsQuery[i].length is at most 5 * 10^5.

    class TrieNode {
    public:
        TrieNode* next[26] = {nullptr};
        int idx = -1;
        int val = -1;
    };*/

    vector<int> stringIndices(vector<string>& wordsContainer, vector<string>& wordsQuery) {
        TrieNode* trie = new TrieNode();
        for (int i = 0; i < wordsContainer.size(); ++i) {
            string word = wordsContainer[i];
            reverse(word.begin(), word.end());
            TrieNode* node = trie;
            if (node->val == -1 || word.size() < node->val) {
                node->idx = i;
                node->val = word.size();
            }
            for (auto& ch : word) {
                if (!node->next[ch-'a'])
                    node->next[ch-'a'] = new TrieNode();
                node = node->next[ch-'a'];
                if (node->val == -1 || word.size() < node->val) {
                    node->idx = i;
                    node->val = word.size();
                }
            }
        }
        vector<int> ans;
        for (int i = 0; i < wordsQuery.size(); ++i) {
            string word = wordsQuery[i];
            reverse(word.begin(), word.end());
            TrieNode* node = trie;
            for (auto& ch : word) {
                if (!node->next[ch-'a']) break;
                node = node->next[ch-'a'];
            }
            ans.push_back(node->idx);
        }
        return ans;
    }


    /*3099. Harshad Number (Easy)
    An integer divisible by the sum of its digits is said to be a Harshad
    number. You are given an integer x. Return the sum of the digits of x if x
    is a Harshad number, otherwise, return -1.

    Example 1:
    Input: x = 18
    Output: 9
    Explanation: The sum of digits of x is 9. 18 is divisible by 9. So 18 is a
                 Harshad number and the answer is 9.

    Example 2:
    Input: x = 23
    Output: -1
    Explanation: The sum of digits of x is 5. 23 is not divisible by 5. So 23 is
                 not a Harshad number and the answer is -1.

    Constraints: 1 <= x <= 100*/

    int sumOfTheDigitsOfHarshadNumber(int x) {
        int val = 0;
        for (int xx = x; xx; xx /= 10)
            val += xx % 10;
        return x % val == 0 ? val : -1;
    }


    /*3100. Water Bottles II (Medium)
    You are given two integers numBottles and numExchange. numBottles represents
    the number of full water bottles that you initially have. In one operation,
    you can perform one of the following operations:
    * Drink any number of full water bottles turning them into empty bottles.
    * Exchange numExchange empty bottles with one full water bottle. Then,
      increase numExchange by one.
    Note that you cannot exchange multiple batches of empty bottles for the same
    value of numExchange. For example, if numBottles == 3 and numExchange == 1,
    you cannot exchange 3 empty water bottles for 3 full bottles. Return the
    maximum number of water bottles you can drink.

    Example 1:
    Input: numBottles = 13, numExchange = 6
    Output: 15
    Explanation: The table above shows the number of full water bottles, empty
                 water bottles, the value of numExchange, and the number of
                 bottles drunk.

    Example 2:
    Input: numBottles = 10, numExchange = 3
    Output: 13
    Explanation: The table above shows the number of full water bottles, empty
                 water bottles, the value of numExchange, and the number of
                 bottles drunk.

    Constraints:
    * 1 <= numBottles <= 100
    * 1 <= numExchange <= 100*/

    int maxBottlesDrunk(int numBottles, int numExchange) {
        int ans = 0, empty = 0;
        while (numBottles) {
            ans += numBottles;
            empty += numBottles;
            numBottles = 0;
            for (; empty >= numExchange; ++numExchange) {
                empty -= numExchange;
                ++numBottles;
            }
        }
        return ans;
    }


    /*3101. Count Alternating Subarrays (Medium)
    You are given a binary array nums. We call a subarray alternating if no two
    adjacent elements in the subarray have the same value. Return the number of
    alternating subarrays in nums.

    Example 1:
    Input: nums = [0,1,1,1]
    Output: 5
    Explanation: The following subarrays are alternating: [0], [1], [1], [1],
                 and [0,1].

    Example 2:
    Input: nums = [1,0,1,0]
    Output: 10
    Explanation: Every subarray of the array is alternating. There are 10
                 possible subarrays that we can choose.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1.*/

    long long countAlternatingSubarrays(vector<int>& nums) {
        long long ans = 0;
        for (int i = 0, cnt = 0; i < nums.size(); ++i) {
            if (i && nums[i-1] == nums[i]) cnt = 0;
            ans += ++cnt;
        }
        return ans;
    }


    /*3102. Minimize Manhattan Distances (Hard)
    You are given a 0-indexed array points representing integer coordinates of
    some points on a 2D plane, where points[i] = [xi, yi]. The distance between
    two points is defined as their Manhattan distance. Return the minimum
    possible value for maximum distance between any two points by removing
    exactly one point.

    Example 1:
    Input: points = [[3,10],[5,15],[10,2],[4,4]]
    Output: 12
    Explanation: The maximum distance after removing each point is the following:
                 - After removing the 0th point the maximum distance is between
                   points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.
                 - After removing the 1st point the maximum distance is between
                   points (3, 10) and (10, 2), which is |3 - 10| + |10 - 2| = 15.
                 - After removing the 2nd point the maximum distance is between
                   points (5, 15) and (4, 4), which is |5 - 4| + |15 - 4| = 12.
                 - After removing the 3rd point the maximum distance is between
                   points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.
                 It can be seen that 12 is the minimum possible maximum distance
                 between any two points after removing exactly one point.

    Example 2:
    Input: points = [[1,1],[1,1],[1,1]]
    Output: 0
    Explanation: It can be seen that removing any of the points results in the
                 maximum distance between any two points of 0.

    Constraints:
    * 3 <= points.length <= 10^5
    * points[i].length == 2=
    * 1 <= points[i][0], points[i][1] <= 10^8*/

    int minimumDistance(vector<vector<int>>& points) {
        vector<vector<int>> diff = {{INT_MAX, -1}, {INT_MAX, -1}, {INT_MIN, -1}, {INT_MIN, -1}};
        vector<vector<int>> summ = {{INT_MAX, -1}, {INT_MAX, -1}, {INT_MIN, -1}, {INT_MIN, -1}};
        for (int i = 0; i < points.size(); ++i) {
            int x = points[i][0], y = points[i][1];
            if (x-y <= diff[0][0]) {
                diff[1] = diff[0];
                diff[0] = {x-y, i};
            } else if (x-y < diff[1][0]) diff[1] = {x-y, i};
            if (x-y >= diff[3][0]) {
                diff[2] = diff[3];
                diff[3] = {x-y, i};
            } else if (x-y > diff[2][0]) diff[2] = {x-y, i};
            if (x+y <= summ[0][0]) {
                summ[1] = summ[0];
                summ[0] = {x+y, i};
            } else if (x+y < summ[1][0]) summ[1] = {x+y, i};
            if (x+y >= summ[3][0]) {
                summ[2] = summ[3];
                summ[3] = {x+y, i};
            } else if (x+y > summ[2][0]) summ[2] = {x+y, i};
        }
        vector<int> cand = {diff[0][1], diff[3][1]};
        if (diff[3][0] - diff[0][0] < summ[3][0] - summ[0][0])
            cand = {summ[0][1], summ[3][1]};
        int ans = INT_MAX;
        for (auto& x : cand) {
            int val = 0;
            if (summ[0][1] == x) val = max(val, summ[3][0] - summ[1][0]);
            else if (summ[3][1] == x) val = max(val, summ[2][0] - summ[0][0]);
            else val = max(val, summ[3][0] - summ[0][0]);
            if (diff[0][1] == x) val = max(val, diff[3][0] - diff[1][0]);
            else if (diff[3][1] == x) val = max(val, diff[2][0] - diff[0][0]);
            else val = max(val, diff[3][0] - diff[0][0]);
            ans = min(ans, val);
        }
        return ans;
    }


    /*3105. Longest Strictly Increasing or Strictly Decreasing Subarray (Easy)
    You are given an array of integers nums. Return the length of the longest
    subarray of nums which is either strictly increasing or strictly decreasing.

    Example 1:
    Input: nums = [1,4,3,3,2]
    Output: 2
    Explanation: The strictly increasing subarrays of nums are [1], [2], [3],
                 [3], [4], and [1,4]. The strictly decreasing subarrays of nums
                 are [1], [2], [3], [3], [4], [3,2], and [4,3]. Hence, we return
                 2.

    Example 2:
    Input: nums = [3,3,3,3]
    Output: 1
    Explanation: The strictly increasing subarrays of nums are [3], [3], [3],
                 and [3]. The strictly decreasing subarrays of nums are [3],
                 [3], [3], and [3]. Hence, we return 1.

    Example 3:
    Input: nums = [3,2,1]
    Output: 3
    Explanation: The strictly increasing subarrays of nums are [3], [2], and
                 [1]. The strictly decreasing subarrays of nums are [3], [2],
                 [1], [3,2], [2,1], and [3,2,1]. Hence, we return 3.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50*/

    int longestMonotonicSubarray(vector<int>& nums) {
        int ans = 0;
        for (int i = 0, val = 0; i < nums.size(); ++i) {
            if (i && nums[i-1] == nums[i]) val = 0;
            else if (i >= 2 && (nums[i-2]-nums[i-1]) * (nums[i-1]-nums[i]) <= 0) val = 1;
            ans = max(ans, ++val);
        }
        return ans;
    }


    /*3106. Lexicographically Smallest String After Operations With Constraint (Medium)
    You are given a string s and an integer k. Define a function
    distance(s1, s2) between two strings s1 and s2 of the same length n as:
    * The sum of the minimum distance between s1[i] and s2[i] when the
      characters from 'a' to 'z' are placed in a cyclic order, for all i in the
      range [0, n - 1].
    For example, distance("ab", "cd") == 4, and distance("a", "z") == 1. You can
    change any letter of s to any other lowercase English letter, any number of
    times. Return a string denoting the lexicographically smallest string t you
    can get after some changes, such that distance(s, t) <= k.

    Example 1:
    Input: s = "zbbz", k = 3
    Output: "aaaz"
    Explanation: Change s to "aaaz". The distance between "zbbz" and "aaaz" is
                 equal to k = 3.

    Example 2:
    Input: s = "xaxcd", k = 4
    Output: "aawcd"
    Explanation: The distance between "xaxcd" and "aawcd" is equal to k = 4.

    Example 3:
    Input: s = "lol", k = 0
    Output: "lol"
    Explanation: It's impossible to change any character as k = 0.

    Constraints:
    * 1 <= s.length <= 100
    * 0 <= k <= 2000
    * s consists only of lowercase English letters.*/

    string getSmallestString(string s, int k) {
        for (int i = 0; i < s.size() && k; ++i) {
            int dist = min(s[i] - 'a', 'z' - s[i] + 1);
            if (dist <= k) s[i] = 'a';
            else s[i] -= k;
            k -= min(k, dist);
        }
        return s;
    }


    /*3107. Minimum Operations to Make Median of Array Equal to K (Medium)
    You are given an integer array nums and a non-negative integer k. In one
    operation, you can increase or decrease any element by 1. Return the minimum
    number of operations needed to make the median of nums equal to k. The
    median of an array is defined as the middle element of the array when it is
    sorted in non-decreasing order. If there are two choices for a median, the
    larger of the two values is taken.

    Example 1:
    Input: nums = [2,5,6,8,5], k = 4
    Output: 2
    Explanation: We can subtract one from nums[1] and nums[4] to obtain
                 [2, 4, 6, 8, 4]. The median of the resulting array is equal to
                 k.

    Example 2:
    Input: nums = [2,5,6,8,5], k = 7
    Output: 3
    Explanation: We can add one to nums[1] twice and add one to nums[2] once to
                 obtain [2, 7, 7, 8, 5].

    Example 3:
    Input: nums = [1,2,3,4,5,6], k = 4
    Output: 0
    Explanation: The median of the array is already equal to k.

    Constraints:
    * 1 <= nums.length <= 2 * 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9*/

    long long minOperationsToMakeMedianK(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        long long ans = 0;
        for (int i = 0, n = nums.size(); i < n; ++i)
            if (i < n/2) ans += max(0, nums[i] - k);
            else if (i == n/2) ans += abs(nums[i] - k);
            else ans += max(0, k - nums[i]);
        return ans;
    }


    /*3108. Minimum Cost Walk in Weighted Graph (Hard)
    There is an undirected weighted graph with n vertices labeled from 0 to
    n - 1. You are given the integer n and an array edges, where
    edges[i] = [ui, vi, wi] indicates that there is an edge between vertices ui
    and vi with a weight of wi. A walk on a graph is a sequence of vertices and
    edges. The walk starts and ends with a vertex, and each edge connects the
    vertex that comes before it and the vertex that comes after it. It's
    important to note that a walk may visit the same edge or vertex more than
    once. The cost of a walk starting at node u and ending at node v is defined
    as the bitwise AND of the weights of the edges traversed during the walk. In
    other words, if the sequence of edge weights encountered during the walk is
    w0, w1, w2, ..., wk, then the cost is calculated as w0 & w1 & w2 & ... & wk,
    where & denotes the bitwise AND operator. You are also given a 2D array
    query, where query[i] = [si, ti]. For each query, you need to find the
    minimum cost of the walk starting at vertex si and ending at vertex ti. If
    there exists no such walk, the answer is -1. Return the array answer, where
    answer[i] denotes the minimum cost of a walk for query i.

    Example 1:
    Input: n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]
    Output: [1,-1]
    Explanation: To achieve the cost of 1 in the first query, we need to move on
                 the following edges: 0->1 (weight 7), 1->2 (weight 1),
                 2->1 (weight 1), 1->3 (weight 7). In the second query, there is
                 no walk between nodes 3 and 4, so the answer is -1.

    Example 2:
    Input: n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]
    Output: [0]
    Explanation: To achieve the cost of 0 in the first query, we need to move on
                 the following edges: 1->2 (weight 1), 2->1 (weight 6),
                 1->2 (weight 1).

    Constraints:
    * 1 <= n <= 10^5
    * 0 <= edges.length <= 10^5
    * edges[i].length == 3
    * 0 <= ui, vi <= n - 1
    * ui != vi
    * 0 <= wi <= 10^5
    * 1 <= query.length <= 10^5
    * query[i].length == 2
    * 0 <= si, ti <= n - 1*/

    vector<int> minimumCost(int n, vector<vector<int>>& edges, vector<vector<int>>& query) {
        vector<int> parent(n), weight(n, -1);
        iota(parent.begin(), parent.end(), 0);

        function<int(int)> find = [&](int p) {
            if (p != parent[p])
                parent[p] = find(parent[p]);
            return parent[p];
        };

        for (auto& e : edges) {
            int u = find(e[0]), v = find(e[1]), w = e[2];
            if (u != v) parent[u] = v;
            weight[v] &= weight[u] & w;
        }
        vector<int> ans;
        for (auto& q : query)
            if (q[0] == q[1]) ans.push_back(0);
            else {
                int u = find(q[0]), v = find(q[1]);
                if (u == v) ans.push_back(weight[u]);
                else ans.push_back(-1);
            }
        return ans;
    }


    /*3110. Score of a String (Easy)
    You are given a string s. The score of a string is defined as the sum of the
    absolute difference between the ASCII values of adjacent characters. Return
    the score of s.

    Example 1:
    Input: s = "hello"
    Output: 13
    Explanation: The ASCII values of the characters in s are: 'h' = 104,
                 'e' = 101, 'l' = 108, 'o' = 111. So, the score of s would be
                 |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111|
                 = 3 + 7 + 0 + 3 = 13.

    Example 2:
    Input: s = "zaz"
    Output: 50
    Explanation: The ASCII values of the characters in s are: 'z' = 122,
                 'a' = 97. So, the score of s would be
                 |122 - 97| + |97 - 122| = 25 + 25 = 50.

    Constraints:
    * 2 <= s.length <= 100
    * s consists only of lowercase English letters.*/

    int scoreOfString(string s) {
        int ans = 0;
        for (int i = 1; i < s.size(); ++i)
            ans += abs(s[i] - s[i-1]);
        return ans;
    }


    /*3111. Minimum Rectangles to Cover Points (Medium)
    You are given a 2D integer array points, where points[i] = [xi, yi]. You are
    also given an integer w. Your task is to cover all the given points with
    rectangles. Each rectangle has its lower end at some point (x1, 0) and its
    upper end at some point (x2, y2), where x1 <= x2, y2 >= 0, and the condition
    x2 - x1 <= w must be satisfied for each rectangle. A point is considered
    covered by a rectangle if it lies within or on the boundary of the
    rectangle. Return an integer denoting the minimum number of rectangles
    needed so that each point is covered by at least one rectangle. Note: A
    point may be covered by more than one rectangle.

    Example 1:
    Input: points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1
    Output: 2
    Explanation: The image above shows one possible placement of rectangles to
                 cover the points:
                 - A rectangle with a lower end at (1, 0) and its upper end at
                   (2, 8)
                 - A rectangle with a lower end at (3, 0) and its upper end at
                   (4, 8)

    Example 2:
    Input: points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2
    Output: 3
    Explanation: The image above shows one possible placement of rectangles to
                 cover the points:
                 - A rectangle with a lower end at (0, 0) and its upper end at
                   (2, 2)
                 - A rectangle with a lower end at (3, 0) and its upper end at
                   (5, 5)
                 - A rectangle with a lower end at (6, 0) and its upper end at
                   (6, 6)

    Example 3:
    Input: points = [[2,3],[1,2]], w = 0
    Output: 2
    Explanation: The image above shows one possible placement of rectangles to
                 cover the points:
                 - A rectangle with a lower end at (1, 0) and its upper end at
                   (1, 2)
                 - A rectangle with a lower end at (2, 0) and its upper end at
                   (2, 3)

    Constraints:
    * 1 <= points.length <= 10^5
    * points[i].length == 2
    * 0 <= xi == points[i][0] <= 10^9
    * 0 <= yi == points[i][1] <= 10^9
    * 0 <= w <= 10^9
    * All pairs (xi, yi) are distinct.*/

    int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {
        sort(points.begin(), points.end());
        int ans = 0, prev = INT_MIN;
        for (auto& p : points)
            if (prev + w < p[0]) {
                ++ans;
                prev = p[0];
            }
        return ans;
    }


    /*3112. Minimum Time to Visit Disappearing Nodes (Medium)
    There is an undirected graph of n nodes. You are given a 2D array edges,
    where edges[i] = [ui, vi, lengthi] describes an edge between node ui and
    node vi with a traversal time of lengthi units. Additionally, you are given
    an array disappear, where disappear[i] denotes the time when the node i
    disappears from the graph and you won't be able to visit it. Notice that the
    graph might be disconnected and might contain multiple edges. Return the
    array answer, with answer[i] denoting the minimum units of time required to
    reach node i from node 0. If node i is unreachable from node 0 then
    answer[i] is -1.

    Example 1:
    Input:  n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]
    Output:  [0,-1,4]
    Explanation: We are starting our journey from node 0, and our goal is to
                 find the minimum time required to reach each node before it
                 disappears.
                 - For node 0, we don't need any time as it is our starting
                   point.
                 - For node 1, we need at least 2 units of time to traverse
                   edges[0]. Unfortunately, it disappears at that moment, so we
                   won't be able to visit it.
                 - For node 2, we need at least 4 units of time to traverse
                   edges[2].

    Example 2:
    Input:  n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]
    Output:  [0,2,3]
    Explanation: We are starting our journey from node 0, and our goal is to
                 find the minimum time required to reach each node before it
                 disappears.
                 - For node 0, we don't need any time as it is the starting
                   point.
                 - For node 1, we need at least 2 units of time to traverse
                   edges[0].
                 - For node 2, we need at least 3 units of time to traverse
                   edges[0] and edges[1].

    Example 3:
    Input: n = 2, edges = [[0,1,1]], disappear = [1,1]
    Output: [0,-1]
    Explanation: Exactly when we reach node 1, it disappears.

    Constraints:
    * 1 <= n <= 5 * 10^4
    * 0 <= edges.length <= 10^5
    * edges[i] == [ui, vi, lengthi]
    * 0 <= ui, vi <= n - 1
    * 1 <= lengthi <= 10^5
    * disappear.length == n
    * 1 <= disappear[i] <= 10^5*/

    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {
        vector<pair<int, int>> graph[n];
        for (auto& e : edges) {
            int u = e[0], v = e[1], w = e[2];
            graph[u].emplace_back(v, w);
            graph[v].emplace_back(u, w);
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.emplace(0, 0);
        vector<int> ans(n, INT_MAX);
        ans[0] = 0;
        while (pq.size()) {
            auto [x, u] = pq.top(); pq.pop();
            if (x == ans[u])
                for (auto& [v, w] : graph[u])
                    if (x+w < disappear[v] && x+w < ans[v]) {
                        ans[v] = x+w;
                        pq.emplace(x+w, v);
                    }
        }
        replace(ans.begin(), ans.end(), INT_MAX, -1);
        return ans;
    }


    /*3113. Find the Number of Subarrays Where Boundary Elements Are Maximum (Hard)
    You are given an array of positive integers nums. Return the number of
    subarrays of nums, where the first and the last elements of the subarray are
    equal to the largest element in the subarray.

    Example 1:
    Input: nums = [1,4,3,3,2]
    Output: 6
    Explanation: There are 6 subarrays which have the first and the last
                 elements equal to the largest element of the subarray:
                 - subarray [1,4,3,3,2], with its largest element 1. The first
                   element is 1 and the last element is also 1.
                 - subarray [1,4,3,3,2], with its largest element 4. The first
                   element is 4 and the last element is also 4.
                 - subarray [1,4,3,3,2], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [1,4,3,3,2], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [1,4,3,3,2], with its largest element 2. The first
                   element is 2 and the last element is also 2.
                 - subarray [1,4,3,3,2], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 Hence, we return 6.

    Example 2:
    Input: nums = [3,3,3]
    Output: 6
    Explanation: There are 6 subarrays which have the first and the last
                 elements equal to the largest element of the subarray:
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 Hence, we return 6.

    Example 3:
    Input: nums = [1]
    Output: 1
    Explanation: There is a single subarray of nums which is [1], with its
                 largest element 1. The first element is 1 and the last element
                 is also 1. Hence, we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    long long numberOfSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        stack<int> stk;
        for (int i = 0; i < n; ++i) {
            while (stk.size() && nums[stk.top()] <= nums[i]) {
                int ii = stk.top(); stk.pop();
                if (nums[ii] == nums[i]) {
                    dp[i] = dp[ii]+1;
                    break;
                }
            }
            stk.push(i);
        }
        return accumulate(dp.begin(), dp.end(), 0ll);
    }


    /*3114. Latest Time You Can Obtain After Replacing Characters (Easy)
    You are given a string s representing a 12-hour format time where some of
    the digits (possibly none) are replaced with a "?". 12-hour times are
    formatted as "HH:MM", where HH is between 00 and 11, and MM is between 00
    and 59. The earliest 12-hour time is 00:00, and the latest is 11:59. You
    have to replace all the "?" characters in s with digits such that the time
    we obtain by the resulting string is a valid 12-hour format time and is the
    latest possible. Return the resulting string.

    Example 1:
    Input: s = "1?:?4"
    Output: "11:54"
    Explanation: The latest 12-hour format time we can achieve by replacing "?"
                 characters is "11:54".

    Example 2:
    Input: s = "0?:5?"
    Output: "09:59"
    Explanation: The latest 12-hour format time we can achieve by replacing "?"
                 characters is "09:59".

    Constraints:
    * s.length == 5
    * s[2] is equal to the character ":".
    * All characters except s[2] are digits or "?" characters.
    * The input is generated such that there is at least one time between
      "00:00" and "11:59" that you can obtain after replacing the "?"
      characters.*/

    string findLatestTime(string s) {
        if (s[0] == '?')
            s[0] = s[1] == '?' || s[1] <= '1' ? '1' : '0';
        if (s[1] == '?')
            s[1] = s[0] == '1' ? '1' : '9';
        if (s[3] == '?') s[3] = '5';
        if (s[4] == '?') s[4] = '9';
        return s;
    }


    /*3115. Maximum Prime Difference (Medium)
    You are given an integer array nums. Return an integer that is the maximum
    distance between the indices of two (not necessarily different) prime
    numbers in nums.

    Example 1:
    Input: nums = [4,2,9,5,3]
    Output: 3
    Explanation: nums[1], nums[3], and nums[4] are prime. So the answer is
                 |4 - 1| = 3.

    Example 2:
    Input: nums = [4,8,2,8]
    Output: 0
    Explanation: nums[2] is prime. Because there is just one prime number, the
                 answer is |2 - 2| = 0.

    Constraints:
    * 1 <= nums.length <= 3 * 10^5
    * 1 <= nums[i] <= 100
    * The input is generated such that the number of prime numbers in the nums
      is at least one.*/

    int maximumPrimeDifference(vector<int>& nums) {
        vector<bool> sieve(101, true);
        sieve[0] = sieve[1] = false;
        for (int x = 2; x <= 10; ++x)
            if (sieve[x])
                for (int xx = x*x; xx <= 100; xx += x)
                    sieve[xx] = false;
        int lo = -1, hi = -1;
        for (int i = 0; i < nums.size(); ++i)
            if (sieve[nums[i]]) {
                if (lo == -1) lo = i;
                hi = i;
            }
        return hi - lo;
    }


    /*3116. Kth Smallest Amount With Single Denomination Combination (Hard)
    You are given an integer array coins representing coins of different
    denominations and an integer k. You have an infinite number of coins of each
    denomination. However, you are not allowed to combine coins of different
    denominations. Return the kth smallest amount that can be made using these
    coins.

    Example 1:
    Input: coins = [3,6,9], k = 3
    Output:  9
    Explanation: The given coins can make the following amounts:
                 Coin 3 produces multiples of 3: 3, 6, 9, 12, 15, etc.
                 Coin 6 produces multiples of 6: 6, 12, 18, 24, etc.
                 Coin 9 produces multiples of 9: 9, 18, 27, 36, etc.
                 All of the coins combined produce: 3, 6, 9, 12, 15, etc.

    Example 2:
    Input: coins = [5,2], k = 7
    Output: 12
    Explanation: The given coins can make the following amounts:
                 Coin 5 produces multiples of 5: 5, 10, 15, 20, etc.
                 Coin 2 produces multiples of 2: 2, 4, 6, 8, 10, 12, etc.
                 All of the coins combined produce: 2, 4, 5, 6, 8, 10, 12, 14,
                 15, etc.

    Constraints:
    * 1 <= coins.length <= 15
    * 1 <= coins[i] <= 25
    * 1 <= k <= 2 * 10^9
    * coins contains pairwise distinct integers.*/

    long long findKthSmallest(vector<int>& coins, int k) {
        int n = coins.size();
        vector<int> comb[n+1];
        for (int m = 1; m < 1<<n; ++m) {
            int cnt = 0, v = 1;
            for (int i = 0; i < n; ++i)
                if (m & 1<<i) {
                    ++cnt;
                    v = lcm(v, coins[i]);
                }
            comb[cnt].push_back(v);
        }

        auto fn = [&](long long val) {
            long long ans = 0;
            for (int i = 1; i <= n; ++i)
                for (auto& v : comb[i])
                    ans -= pow(-1, i)*(val/v);
            return ans;
        };

        long long lo = 0, hi = (long long) k*coins[0];
        while (lo < hi) {
            long long mid = lo + (hi - lo)/2;
            if (fn(mid) < k) lo = mid + 1;
            else hi = mid;
        }
        return hi;
    }


    /*3117. Minimum Sum of Values by Dividing Array (Hard)
    You are given two arrays nums and andValues of length n and m respectively.
    The value of an array is equal to the last element of that array. You have
    to divide nums into m disjoint contiguous subarrays such that for the ith
    subarray [li, ri], the bitwise AND of the subarray elements is equal to
    andValues[i], in other words, nums[li] & nums[li + 1] & ... &
    nums[ri] == andValues[i] for all 1 <= i <= m, where & represents the bitwise
    AND operator. Return the minimum possible sum of the values of the m
    subarrays nums is divided into. If it is not possible to divide nums into m
    subarrays satisfying these conditions, return -1.

    Example 1:
    Input: nums = [1,4,3,3,2], andValues = [0,3,3,2]
    Output: 12
    Explanation: The only possible way to divide nums is:
                 - [1,4] as 1 & 4 == 0.
                 - [3] as the bitwise AND of a single element subarray is that
                   element itself.
                 - [3] as the bitwise AND of a single element subarray is that
                   element itself.
                 - [2] as the bitwise AND of a single element subarray is that
                   element itself.
                 - The sum of the values for these subarrays is
                   4 + 3 + 3 + 2 = 12.

    Example 2:
    Input: nums = [2,3,5,7,7,7,5], andValues = [0,7,5]
    Output: 17
    Explanation: There are three ways to divide nums:
                 - [[2,3,5],[7,7,7],[5]] with the sum of the values
                   5 + 7 + 5 == 17.
                 - [[2,3,5,7],[7,7],[5]] with the sum of the values
                   7 + 7 + 5 == 19.
                 - [[2,3,5,7,7],[7],[5]] with the sum of the values
                   7 + 7 + 5 == 19.
                 - The minimum possible sum of the values is 17.

    Example 3:
    Input: nums = [1,2,3,4], andValues = [2]
    Output: -1
    Explanation: The bitwise AND of the entire array nums is 0. As there is no
                 possible way to divide nums into a single subarray to have the
                 bitwise AND of elements 2, return -1.

    Constraints:
    * 1 <= n == nums.length <= 10^4
    * 1 <= m == andValues.length <= min(n, 10)
    * 1 <= nums[i] < 10^5
    * 0 <= andValues[j] < 10^5*/

    int minimumValueSum(vector<int>& nums, vector<int>& andValues) {
        int m = nums.size(), n = andValues.size(), inf = 10'000'000;
        vector<vector<unordered_map<int, int>>> memo(m+1, vector<unordered_map<int, int>>(n+1));

        function<int(int, int, int)> fn = [&](int i, int j, int mask) {
            if (memo[i][j].count(mask) == 0) {
                if (i == m && j == n) memo[i][j][mask] = 0;
                else if (i == m || j == n) memo[i][j][mask] = inf;
                else {
                    int mm = mask & nums[i];
                    if (mm < andValues[j]) memo[i][j][mask] = inf;
                    else if (mm == andValues[j]) memo[i][j][mask] = min(fn(i+1, j, mm), nums[i] + fn(i+1, j+1, -1));
                    else memo[i][j][mask] = fn(i+1, j, mm);
                }
            }
            return memo[i][j][mask];
        };

        int ans = fn(0, 0, -1);
        return ans < inf ? ans : -1;
    }


    /*3120. Count the Number of Special Characters I (Easy)
    You are given a string word. A letter is called special if it appears both
    in lowercase and uppercase in word. Return the number of special letters in
    word.

    Example 1:
    Input: word = "aaAbcBC"
    Output: 3
    Explanation: The special characters in word are 'a', 'b', and 'c'.

    Example 2:
    Input: word = "abc"
    Output: 0
    Explanation: No character in word appears in uppercase.

    Example 3:
    Input: word = "abBCab"
    Output: 1
    Explanation: The only special character in word is 'b'.

    Constraints:
    * 1 <= word.length <= 50
    * word consists of only lowercase and uppercase English letters.*/

    int numberOfSpecialChars(string word) {
        int lower = 0, upper = 0;
        for (auto& ch : word)
            if (islower(ch)) lower |= 1 << (ch-'a');
            else upper |= 1 << (ch-'A');
        return __popcount(lower&upper);
    }


    /*3121. Count the Number of Special Characters II (Medium)
    You are given a string word. A letter c is called special if it appears both
    in lowercase and uppercase in word, and every lowercase occurrence of c
    appears before the first uppercase occurrence of c. Return the number of
    special letters in word.

    Example 1:
    Input: word = "aaAbcBC"
    Output: 3
    Explanation: The special characters are 'a', 'b', and 'c'.

    Example 2:
    Input: word = "abc"
    Output: 0
    Explanation: There are no special characters in word.

    Example 3:
    Input: word = "AbBCab"
    Output: 0
    Explanation: There are no special characters in word.

    Constraints:
    * 1 <= word.length <= 2 * 10^5
    * word consists of only lowercase and uppercase English letters.*/

    int numberOfSpecialChars(string word) {
        int lower = 0, upper = 0;
        for (auto& ch : word)
            if (islower(ch)) {
                lower &= ~(1 << ch-'a');
                lower |= ~upper & 1 << ch-'a';
            } else
                upper |= 1 << ch - 'A';
        return __popcount(lower & upper);
    }


    /*3122. Minimum Number of Operations to Satisfy Conditions (Medium)
    You are given a 2D matrix grid of size m x n. In one operation, you can
    change the value of any cell to any non-negative number. You need to perform
    some operations such that each cell grid[i][j] is:
    * Equal to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it
      exists).
    * Different from the cell to its right, i.e. grid[i][j] != grid[i][j + 1]
      (if it exists).
    Return the minimum number of operations needed.

    Example 1:
    Input: grid = [[1,0,2],[1,0,2]]
    Output: 0
    Explanation: All the cells in the matrix already satisfy the properties.

    Example 2:
    Input: grid = [[1,1,1],[0,0,0]]
    Output: 3
    Explanation: The matrix becomes [[1,0,1],[1,0,1]] which satisfies the
                 properties, by doing these 3 operations:
                 - Change grid[1][0] to 1.
                 - Change grid[0][1] to 0.
                 - Change grid[1][2] to 1.

    Example 3:
    Input: grid = [[1],[2],[3]]
    Output: 2
    Explanation: There is a single column. We can change the value to 1 in each
                 cell using 2 operations.

    Constraints:
    * 1 <= n, m <= 1000
    * 0 <= grid[i][j] <= 9*/

    int minimumOperations(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(10, vector<int>(n+1));
        vector<int> vals(10);
        iota(vals.begin(), vals.end(), 0);
        for (int j = n-1; j >= 0; --j) {
            vector<int> freq(10);
            for (int i = 0; i < m; ++i)
                ++freq[grid[i][j]];
            sort(vals.begin(), vals.end(), [&](auto& lhs, auto& rhs) { return dp[lhs][j+1] < dp[rhs][j+1]; });
            for (int x = 0; x < 10; ++x) {
                dp[x][j] = m - freq[x];
                if (x != vals[0]) dp[x][j] += dp[vals[0]][j+1];
                else dp[x][j] += dp[vals[1]][j+1];
            }
        }
        return (*min_element(dp.begin(), dp.end(), [&](auto& lhs, auto& rhs) { return lhs[0] < rhs[0]; }))[0];
    }


    /*3123. Find Edges in Shortest Paths (Hard)
    You are given an undirected weighted graph of n nodes numbered from 0 to
    n - 1. The graph consists of m edges represented by a 2D array edges, where
    edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and
    bi with weight wi. Consider all the shortest paths from node 0 to node n - 1
    in the graph. You need to find a boolean array answer where answer[i] is
    true if the edge edges[i] is part of at least one shortest path. Otherwise,
    answer[i] is false. Return the array answer. Note that the graph may not be
    connected.

    Example 1:
    Input: n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]
    Output: [true,true,true,false,true,true,true,false]
    Explanation: The following are all the shortest paths between nodes 0 and 5:
                 - The path 0 -> 1 -> 5: The sum of weights is 4 + 1 = 5.
                 - The path 0 -> 2 -> 3 -> 5: The sum of weights is
                   1 + 1 + 3 = 5.
                 - The path 0 -> 2 -> 3 -> 1 -> 5: The sum of weights is
                   1 + 1 + 2 + 1 = 5.

    Example 2:
    Input: n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]
    Output: [true,false,false,true]
    Explanation: There is one shortest path between nodes 0 and 3, which is the
                 path 0 -> 2 -> 3 with the sum of weights 1 + 2 = 3.

    Constraints:
    * 2 <= n <= 5 * 10^4
    * m == edges.length
    * 1 <= m <= min(5 * 10^4, n * (n - 1) / 2)
    * 0 <= ai, bi < n
    * ai != bi
    * 1 <= wi <= 10^5
    * There are no repeated edges.*/

    vector<bool> findAnswer(int n, vector<vector<int>>& edges) {
        vector<pair<int, int>> graph[n];
        for (auto& e : edges) {
            int u = e[0], v = e[1], w = e[2];
            graph[u].emplace_back(v, w);
            graph[v].emplace_back(u, w);
        }

        auto fn = [&](int source) {
            vector<int> dist(n, -1);
            dist[source] = 0;
            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
            pq.emplace(0, source);
            while (pq.size()) {
                auto [x, u] = pq.top(); pq.pop();
                if (dist[u] == x) {
                    for (auto& [v, w] : graph[u]) {
                        if (dist[v] == -1 || x+w < dist[v]) {
                            dist[v] = x+w;
                            pq.emplace(x+w, v);
                        }
                    }
                }
            }
            return dist;
        };

        vector<int> dist0 = fn(0), dist1 = fn(n-1);
        if (dist0[n-1] == -1) return vector<bool>(edges.size(), false);
        vector<bool> ans;
        for (auto& e : edges) {
            int u = e[0], v = e[1], w = e[2];
            if (dist0[u] != -1 && dist1[v] != -1 && dist0[u]+w+dist1[v] == dist0[n-1] || dist1[u] != -1 && dist0[v] != -1 && dist1[u]+w+dist0[v] == dist0[n-1])
                ans.push_back(true);
            else ans.push_back(false);
        }
        return ans;
    }


    /*3127. Make a Square with the Same Color (Easy)
    You are given a 2D matrix grid of size 3 x 3 consisting only of characters
    'B' and 'W'. Character 'W' represents the white color, and character 'B'
    represents the black color. Your task is to change the color of at most one
    cell so that the matrix has a 2 x 2 square where all cells are of the same
    color. Return true if it is possible to create a 2 x 2 square of the same
    color, otherwise, return false.

    Example 1:
    Input: grid = [["B","W","B"],["B","W","W"],["B","W","B"]]
    Output: true
    Explanation: It can be done by changing the color of the grid[0][2].

    Example 2:
    Input: grid = [["B","W","B"],["W","B","W"],["B","W","B"]]
    Output: false
    Explanation: It cannot be done by changing at most one cell.

    Example 3:
    Input: grid = [["B","W","B"],["B","W","W"],["B","W","W"]]
    Output: true
    Explanation: The grid already contains a 2 x 2 square of the same color.

    Constraints:
    * grid.length == 3
    * grid[i].length == 3
    * grid[i][j] is either 'W' or 'B'.*/

    bool canMakeSquare(vector<vector<char>>& grid) {
        int m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m-1; ++i)
            for (int j = 0; j < n-1; ++j) {
                int cnt = 0;
                for (int ii = i; ii <= i+1; ++ii)
                    cnt += count_if(grid[ii].begin()+j, grid[ii].begin()+j+2, [&](auto& x) { return x == 'B'; });
                if (cnt != 2) return true;
            }
        return false;

    }


    /*3128. Right Triangles (Medium)
    You are given a 2D boolean matrix grid. Return an integer that is the number
    of right triangles that can be made with the 3 elements of grid such that
    all of them have a value of 1. Note: A collection of 3 elements of grid is a
    right triangle if one of its elements is in the same row with another
    element and in the same column with the third element. The 3 elements do not
    have to be next to each other.

    Example 1: 0   1   0
               0   1   1
               0   1   0
               0   1   0
               0   1   1
               0   1   0
    Input: grid = [[0,1,0],[0,1,1],[0,1,0]]
    Output: 2
    Explanation: There are two right triangles.

    Example 2: 1   0   0   0
               0   1   0   1
               1   0   0   0
    Input: grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]
    Output: 0
    Explanation: There are no right triangles.

    Example 3: 1   0   1
               1   0   0
               1   0   0
               1   0   1
               1   0   0
               1   0   0
    Input: grid = [[1,0,1],[1,0,0],[1,0,0]]
    Output: 2
    Explanation: There are two right triangles.

    Constraints:
    * 1 <= grid.length <= 1000
    * 1 <= grid[i].length <= 1000
    * 0 <= grid[i][j] <= 1*/

    long long numberOfRightTriangles(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> rows(m), cols(n);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) {
                    ++rows[i];
                    ++cols[j];
                }
        long long ans = 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j])
                    ans += (long long) (rows[i]-1) * (cols[j]-1);
        return ans;
    }


    /*3129. Find All Possible Stable Binary Arrays I (Medium)
    You are given 3 positive integers zero, one, and limit. A binary array arr
    is called stable if:
    * The number of occurrences of 0 in arr is exactly zero.
    * The number of occurrences of 1 in arr is exactly one.
    * Each subarray of arr with a size greater than limit must contain both 0
      and 1.
    Return the total number of stable binary arrays. Since the answer may be
    very large, return it modulo 10^9 + 7.

    Example 1:
    Input: zero = 1, one = 1, limit = 2
    Output: 2
    Explanation: The two possible stable binary arrays are [1,0] and [0,1], as
                 both arrays have a single 0 and a single 1, and no subarray has
                 a length greater than 2.

    Example 2:
    Input: zero = 1, one = 2, limit = 1
    Output: 1
    Explanation: The only possible stable binary array is [1,0,1]. Note that the
                 binary arrays [1,1,0] and [0,1,1] have subarrays of length 2
                 with identical elements, hence, they are not stable.

    Example 3:
    Input: zero = 3, one = 3, limit = 2
    Output: 14
    Explanation: All the possible stable binary arrays are [0,0,1,0,1,1],
                 [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0],
                 [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0],
                 [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and
                 [1,1,0,1,0,0].

    Constraints: 1 <= zero, one, limit <= 200*/

    int numberOfStableArrays(int zero, int one, int limit) {
        int mod = 1'000'000'007;
        vector<vector<vector<int>>> dp(zero+1, vector<vector<int>>(one+1, vector<int>(2)));
        for (int i = 1; i <= zero && i <= limit; ++i)
            dp[i][0][0] = 1;
        for (int j = 1; j <= one && j <= limit; ++j)
            dp[0][j][1] = 1;
        for (int i = 1; i <= zero; ++i)
            for (int j = 1; j <= one; ++j) {
                dp[i][j][0] = (dp[i-1][j][1] + dp[i-1][j][0]) % mod;
                if (i-1-limit >= 0) dp[i][j][0] = ((dp[i][j][0] - dp[i-1-limit][j][1]) % mod + mod) % mod;
                dp[i][j][1] = (dp[i][j-1][0] + dp[i][j-1][1]) % mod;
                if (j-1-limit >= 0) dp[i][j][1] = ((dp[i][j][1] - dp[i][j-1-limit][0]) % mod + mod) % mod;
            }
        return (dp[zero][one][0] + dp[zero][one][1]) % mod;
    }


    /*3130. Find All Possible Stable Binary Arrays II (Hard)
    You are given 3 positive integers zero, one, and limit. A binary array arr
    is called stable if:
    * The number of occurrences of 0 in arr is exactly zero.
    * The number of occurrences of 1 in arr is exactly one.
    * Each subarray of arr with a size greater than limit must contain both 0
      and 1.
    Return the total number of stable binary arrays. Since the answer may be
    very large, return it modulo 10^9 + 7.

    Example 1:
    Input: zero = 1, one = 1, limit = 2
    Output: 2
    Explanation: The two possible stable binary arrays are [1,0] and [0,1].

    Example 2:
    Input: zero = 1, one = 2, limit = 1
    Output: 1
    Explanation: The only possible stable binary array is [1,0,1].

    Example 3:
    Input: zero = 3, one = 3, limit = 2
    Output: 14
    Explanation: All the possible stable binary arrays are [0,0,1,0,1,1],
                 [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0],
                 [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0],
                 [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and
                 [1,1,0,1,0,0].

    Constraints: 1 <= zero, one, limit <= 1000*/

    int numberOfStableArrays(int zero, int one, int limit) {
        int mod = 1'000'000'007;
        vector<vector<vector<int>>> dp(zero+1, vector<vector<int>>(one+1, vector<int>(2)));
        for (int i = 1; i <= zero && i <= limit; ++i)
            dp[i][0][0] = 1;
        for (int j = 1; j <= one && j <= limit; ++j)
            dp[0][j][1] = 1;
        for (int i = 1; i <= zero; ++i)
            for (int j = 1; j <= one; ++j) {
                dp[i][j][0] = (dp[i-1][j][1] + dp[i-1][j][0]) % mod;
                if (i-1-limit >= 0) dp[i][j][0] = ((dp[i][j][0] - dp[i-1-limit][j][1]) % mod + mod) % mod;
                dp[i][j][1] = (dp[i][j-1][0] + dp[i][j-1][1]) % mod;
                if (j-1-limit >= 0) dp[i][j][1] = ((dp[i][j][1] - dp[i][j-1-limit][0]) % mod + mod) % mod;
            }
        return (dp[zero][one][0] + dp[zero][one][1]) % mod;
    }


    /*3131. Find the Integer Added to Array I (Easy)
    You are given two arrays of equal length, nums1 and nums2. Each element in
    nums1 has been increased (or decreased in the case of negative) by an
    integer, represented by the variable x. As a result, nums1 becomes equal to
    nums2. Two arrays are considered equal when they contain the same integers
    with the same frequencies. Return the integer x.

    Example 1:
    Input: nums1 = [2,6,4], nums2 = [9,7,5]
    Output: 3
    Explanation: The integer added to each element of nums1 is 3.

    Example 2:
    Input: nums1 = [10], nums2 = [5]
    Output: -5
    Explanation: The integer added to each element of nums1 is -5.

    Example 3:
    Input: nums1 = [1,1,1,1], nums2 = [1,1,1,1]
    Output: 0
    Explanation: The integer added to each element of nums1 is 0.

    Constraints:
    * 1 <= nums1.length == nums2.length <= 100
    * 0 <= nums1[i], nums2[i] <= 1000
    * The test cases are generated in a way that there is an integer x such that
      nums1 can become equal to nums2 by adding x to each element of nums1.*/

    int addedInteger(vector<int>& nums1, vector<int>& nums2) {
        return *min_element(nums2.begin(), nums2.end()) - *min_element(nums1.begin(), nums1.end());
    }


    /*3132. Find the Integer Added to Array II (Medium)
    You are given two integer arrays nums1 and nums2. From nums1 two elements
    have been removed, and all other elements have been increased (or decreased
    in the case of negative) by an integer, represented by the variable x. As a
    result, nums1 becomes equal to nums2. Two arrays are considered equal when
    they contain the same integers with the same frequencies. Return the minimum
    possible integer x that achieves this equivalence.

    Example 1:
    Input: nums1 = [4,20,16,12,8], nums2 = [14,18,10]
    Output: -2
    Explanation: After removing elements at indices [0,4] and adding -2, nums1
                 becomes [18,14,10].

    Example 2:
    Input: nums1 = [3,5,5,3], nums2 = [7,7]
    Output: 2
    Explanation: After removing elements at indices [0,3] and adding 2, nums1
                 becomes [7,7].

    Constraints:
    * 3 <= nums1.length <= 200
    * nums2.length == nums1.length - 2
    * 0 <= nums1[i], nums2[i] <= 1000
    * The test cases are generated in a way that there is an integer x such that
      nums1 can become equal to nums2 by removing two elements and adding x to
      each element of nums1.*/

    int minimumAddedInteger(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int ans = INT_MAX;
        for (int x = 0, n = nums1.size(); x < n; ++x) {
            for (int y = x+1; y < n; ++y) {
                int seen = INT_MIN;
                bool found = false;
                for (int i = 0, j = 0; i < n; ++i)
                    if (i != x && i != y) {
                        int diff = nums2[j] - nums1[i];
                        if (seen == INT_MIN) seen = diff;
                        else if (seen != diff) {
                            found = true;
                            break;
                        }
                        ++j;
                    }
                if (!found) ans = min(ans, seen);
            }
        }
        return ans;
    }


    /*3133. Minimum Array End (Medium)
    You are given two integers n and x. You have to construct an array of
    positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1]
    is greater than nums[i], and the result of the bitwise AND operation between
    all elements of nums is x. Return the minimum possible value of nums[n - 1].

    Example 1:
    Input: n = 3, x = 4
    Output: 6
    Explanation: nums can be [4,5,6] and its last element is 6.

    Example 2:
    Input: n = 2, x = 7
    Output: 15
    Explanation: nums can be [7,15] and its last element is 15.

    Constraints: 1 <= n, x <= 10^8*/

    long long minEnd(int n, int x) {
        --n;
        long long ans = x;
        for (int i = 0; n; ++i)
            if (!(x & 1ll<<i)) {
                if (n & 1) ans ^= 1ll << i;
                n >>= 1;
            }
        return ans;
    }


    /*3134. Find the Median of the Uniqueness Array (Hard)
    You are given an integer array nums. The uniqueness array of nums is the
    sorted array that contains the number of distinct elements of all the
    subarrays of nums. In other words, it is a sorted array consisting of
    distinct(nums[i..j]), for all 0 <= i <= j < nums.length. Here,
    distinct(nums[i..j]) denotes the number of distinct elements in the subarray
    that starts at index i and ends at index j. Return the median of the
    uniqueness array of nums. Note that the median of an array is defined as the
    middle element of the array when it is sorted in non-decreasing order. If
    there are two choices for a median, the smaller of the two values is taken.

    Example 1:
    Input: nums = [1,2,3]
    Output: 1
    Explanation: The uniqueness array of nums is [distinct(nums[0..0]),
                 distinct(nums[1..1]), distinct(nums[2..2]),
                 distinct(nums[0..1]), distinct(nums[1..2]),
                 distinct(nums[0..2])] which is equal to [1, 1, 1, 2, 2, 3]. The
                 uniqueness array has a median of 1. Therefore, the answer is 1.

    Example 2:
    Input: nums = [3,4,3,4,5]
    Output: 2
    Explanation: The uniqueness array of nums is
                 [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]. The uniqueness
                 array has a median of 2. Therefore, the answer is 2.

    Example 3:
    Input: nums = [4,3,5,4]
    Output: 2
    Explanation: The uniqueness array of nums is [1, 1, 1, 1, 2, 2, 2, 3, 3, 3].
                 The uniqueness array has a median of 2. Therefore, the answer
                 is 2.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    int medianOfUniquenessArray(vector<int>& nums) {
        int n = nums.size(), lo = 0, hi = n;
        while (lo < hi) {
            int mid = lo + (hi-lo)/2;
            long long val = 0;
            unordered_map<int, int> freq;
            for (int i = 0, ii = 0; i < n; ++i) {
                ++freq[nums[i]];
                for (; freq.size() > mid; ++ii) {
                    --freq[nums[ii]];
                    if (freq[nums[ii]] == 0) freq.erase(nums[ii]);
                }
                val += i-ii+1;
            }
            if (val < ((long long) n*(n+1)/2+1)/2) lo = mid+1;
            else hi = mid;
        }
        return lo;
    }


    /*3146. Permutation Difference between Two Strings (Easy)
    You are given two strings s and t such that every character occurs at most
    once in s and t is a permutation of s. The permutation difference between s
    and t is defined as the sum of the absolute difference between the index of
    the occurrence of each character in s and the index of the occurrence of the
    same character in t. Return the permutation difference between s and t.

    Example 1:
    Input: s = "abc", t = "bac"
    Output: 2
    Explanation: For s = "abc" and t = "bac", the permutation difference of s
                 and t is equal to the sum of:
                 - The absolute difference between the index of the occurrence
                   of "a" in s and the index of the occurrence of "a" in t.
                 - The absolute difference between the index of the occurrence
                   of "b" in s and the index of the occurrence of "b" in t.
                 - The absolute difference between the index of the occurrence
                   of "c" in s and the index of the occurrence of "c" in t.
                 - That is, the permutation difference between s and t is equal
                   to |0 - 1| + |1 - 0| + |2 - 2| = 2.

    Example 2:
    Input: s = "abcde", t = "edbac"
    Output: 12
    Explanation: The permutation difference between s and t is equal to
                 |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12.

    Constraints:
    * 1 <= s.length <= 26
    * Each character occurs at most once in s.
    * t is a permutation of s.
    * s consists only of lowercase English letters.*/

    int findPermutationDifference(string s, string t) {
        int ans = 0, loc[26] = {-1};
        for (int i = 0; i < s.size(); ++i)
            loc[s[i] - 'a'] = i;
        for (int i = 0; i < t.size(); ++i)
            ans += abs(i - loc[t[i] - 'a']);
        return ans;
    }


    /*3147. Taking Maximum Energy From the Mystic Dungeon (Medium)
    In a mystic dungeon, n magicians are standing in a line. Each magician has
    an attribute that gives you energy. Some magicians can give you negative
    energy, which means taking energy from you. You have been cursed in such a
    way that after absorbing energy from magician i, you will be instantly
    transported to magician (i + k). This process will be repeated until you
    reach the magician where (i + k) does not exist. In other words, you will
    choose a starting point and then teleport with k jumps until you reach the
    end of the magicians' sequence, absorbing all the energy during the journey.
    You are given an array energy and an integer k. Return the maximum possible
    energy you can gain.

    Example 1:
    Input:  energy = [5,2,-10,-5,1], k = 3
    Output: 3
    Explanation: We can gain a total energy of 3 by starting from magician 1
                 absorbing 2 + 1 = 3.

    Example 2:
    Input: energy = [-2,-3,-1], k = 2
    Output: -1
    Explanation: We can gain a total energy of -1 by starting from magician 2.

    Constraints:
    * 1 <= energy.length <= 10^5
    * -1000 <= energy[i] <= 1000
    * 1 <= k <= energy.length - 1*/

    int maximumEnergy(vector<int>& energy, int k) {
        vector<int> dp(k, INT_MIN);
        for (int i = 0; i < energy.size(); ++i)
            dp[i % k] = max(0, dp[i % k]) + energy[i];
        return *max_element(dp.begin(), dp.end());
    }


    /*3148. Maximum Difference Score in a Grid (Medium)
    You are given an m x n matrix grid consisting of positive integers. You can
    move from a cell in the matrix to any other cell that is either to the
    bottom or to the right (not necessarily adjacent). The score of a move from
    a cell with the value c1 to a cell with the value c2 is c2 - c1. You can
    start at any cell, and you have to make at least one move. Return the
    maximum total score you can achieve.

    Example 1:
    Input: grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]
    Output: 9
    Explanation: We start at the cell (0, 1), and we perform the following moves:
                 - Move from the cell (0, 1) to (2, 1) with a score of 7 - 5 = 2.
                 - Move from the cell (2, 1) to (2, 2) with a score of 14 - 7 = 7.
                 The total score is 2 + 7 = 9.

    Example 2:
    Input: grid = [[4,3,2],[3,2,1]]
    Output: -1
    Explanation: We start at the cell (0, 0), and we perform one move: (0, 0) to
                 (0, 1). The score is 3 - 4 = -1.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 1000
    * 4 <= m * n <= 10^5
    * 1 <= grid[i][j] <= 10^5*/

    int maxScore(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int ans = INT_MIN;
        vector<vector<int>> prefix(m+1, vector<int>(n+1, INT_MAX));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                int cand = min(prefix[i+1][j], prefix[i][j+1]);
                ans = max(ans, grid[i][j] - cand);
                prefix[i+1][j+1] = min(grid[i][j], cand);
            }
        return ans;
    }


    /*3149. Find the Minimum Cost Array Permutation (Hard)
    You are given an array nums which is a permutation of [0, 1, 2, ..., n - 1].
    The score of any permutation of [0, 1, 2, ..., n - 1] named perm is defined
    as:
    * score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ...
      + |perm[n - 1] - nums[perm[0]]|
    Return the permutation perm which has the minimum possible score. If
    multiple permutations exist with this score, return the one that is
    lexicographically smallest among them.

    Example 1:
    Input: nums = [1,0,2]
    Output: [0,1,2]
    Explanation: The lexicographically smallest permutation with minimum cost is
                 [0,1,2]. The cost of this permutation is
                 |0 - 0| + |1 - 2| + |2 - 1| = 2.

    Example 2:
    Input: nums = [0,2,1]
    Output: [0,2,1]
    Explanation: The lexicographically smallest permutation with minimum cost is
                 [0,2,1]. The cost of this permutation is
                 |0 - 1| + |2 - 2| + |1 - 0| = 2.

    Constraints:
    * 2 <= n == nums.length <= 14
    * nums is a permutation of [0, 1, 2, ..., n - 1].*/

    vector<int> findPermutation(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(1<<n, vector<int>(n, INT_MAX));
        vector<vector<int>> jump(1<<n, vector<int>(n, 0));
        for (int m = (1<<n)-1; m > 0; --m) {
            int i = __popcount(m);
            for (int p = 0; p < n; ++p)
                if (i == n) dp[m][p] = abs(p - nums[0]);
                else
                    for (int k = 0; k < n; ++k)
                        if ((m & 1<<k) == 0) {
                            int cand = abs(p - nums[k]) + dp[m^1<<k][k];
                            if (cand < dp[m][p]) {
                                dp[m][p] = cand;
                                jump[m][p] = k;
                            }
                        }
        }
        vector<int> ans(1);
        for (int i = 1, m = 1; i < n; ++i) {
            int k = jump[m][ans.back()];
            ans.push_back(k);
            m ^= 1<<k;
        }
        return ans;
    }


    /*3151. Special Array I (Easy)
    An array is considered special if every pair of its adjacent elements
    contains two numbers with different parity. You are given an array of
    integers nums. Return true if nums is a special array, otherwise, return
    false.

    Example 1:
    Input: nums = [1]
    Output: true
    Explanation: There is only one element. So the answer is true.

    Example 2:
    Input: nums = [2,1,4]
    Output: true
    Explanation: There is only two pairs: (2,1) and (1,4), and both of them
                 contain numbers with different parity. So the answer is true.

    Example 3:
    Input: nums = [4,3,1,6]
    Output: false
    Explanation: nums[1] and nums[2] are both odd. So the answer is false.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100*/

    bool isArraySpecial(vector<int>& nums) {
        for (int i = 1; i < nums.size(); ++i)
            if ((nums[i-1] - nums[i]) % 2 == 0) return false;
        return true;
    }


    /*3152. Special Array II (Medium)
    An array is considered special if every pair of its adjacent elements
    contains two numbers with different parity. You are given an array of
    integer nums and a 2D integer matrix queries, where for
    queries[i] = [fromi, toi] your task is to check that subarray
    nums[fromi..toi] is special or not. Return an array of booleans answer such
    that answer[i] is true if nums[fromi..toi] is special.

    Example 1:
    Input: nums = [3,4,1,2,6], queries = [[0,4]]
    Output: [false]
    Explanation: The subarray is [3,4,1,2,6]. 2 and 6 are both even.

    Example 2:
    Input: nums = [4,3,1,6], queries = [[0,2],[2,3]]
    Output: [false,true]
    Explanation: The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to
                 this query is false. The subarray is [1,6]. There is only one
                 pair: (1,6) and it contains numbers with different parity. So
                 the answer to this query is true.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= queries[i][0] <= queries[i][1] <= nums.length - 1*/

    vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& queries) {
        vector<int> dp;
        for (int i = 0, v = 0; i < nums.size(); ++i) {
            if (i && (nums[i-1] - nums[i]) % 2 == 0) v = i;
            dp.push_back(v);
        }
        vector<bool> ans(queries.size());
        transform(queries.begin(), queries.end(), ans.begin(), [&](auto& x) { return x[0] >= dp[x[1]]; });
        return ans;
    }


    /*3153. Sum of Digit Differences of All Pairs (Medium)
    You are given an array nums consisting of positive integers where all
    integers have the same number of digits. The digit difference between two
    integers is the count of different digits that are in the same position in
    the two integers. Return the sum of the digit differences between all pairs
    of integers in nums.

    Example 1:
    Input: nums = [13,23,12]
    Output: 4
    Explanation: We have the following:
                 - The digit difference between 13 and 23 is 1.
                 - The digit difference between 13 and 12 is 1.
                 - The digit difference between 23 and 12 is 2.
                 So the total sum of digit differences between all pairs of
                 integers is 1 + 1 + 2 = 4.

    Example 2:
    Input: nums = [10,10,10,10]
    Output: 0
    Explanation: All the integers in the array are the same. So the total sum of
                 digit differences between all pairs of integers will be 0.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] < 10^9
    * All integers in nums have the same number of digits.*/

    long long sumDigitDifferences(vector<int>& nums) {
        long long ans = 0;
        while (nums[0]) {
            vector<int> freq(10);
            for (auto& x : nums) {
                ++freq[x % 10];
                x /= 10;
            }
            ans += accumulate(freq.begin(), freq.end(), 0ll, [&](long long x, int y) { return x + y*(nums.size()-y); });
        }
        return ans/2;
    }


    /*3154. Find Number of Ways to Reach the K-th Stair (Hard)
    You are given a non-negative integer k. There exists a staircase with an
    infinite number of stairs, with the lowest stair numbered 0. Alice has an
    integer jump, with an initial value of 0. She starts on stair 1 and wants to
    reach stair k using any number of operations. If she is on stair i, in one
    operation she can:
    * Go down to stair i - 1. This operation cannot be used consecutively or on
      stair 0.
    * Go up to stair i + 2jump. And then, jump becomes jump + 1.
    Return the total number of ways Alice can reach stair k. Note that it is
    possible that Alice reaches the stair k, and performs some operations to
    reach the stair k again.

    Example 1:
    Input: k = 0
    Output: 2
    Explanation: The 2 possible ways of reaching stair 0 are:
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.

    Example 2:
    Input: k = 1
    Output: 4
    Explanation: The 4 possible ways of reaching stair 1 are:
                 - Alice starts at stair 1. Alice is at stair 1.
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 1.
                 - Alice starts at stair 1.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 2.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 1.
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 21 stairs
                   to reach stair 2.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 1.

    Constraints: 0 <= k <= 10^9*/

    int waysToReachStair(int k) {
        int ans = 0;
        for (int jump = 0; jump <= 30; ++jump) {
            int n = jump+1, v = (1<<jump)-k;
            v = min(v, n-v);
            if (v >= 0) {
                long val = 1;
                for (int i = 0; i < v; ++i) {
                    val *= n-i;
                    val /= i+1;
                }
                ans += val;
            }
        }
        return ans;
    }


    /*3158. Find the XOR of Numbers Which Appear Twice (Easy)
    You are given an array nums, where each number in the array appears either
    once or twice. Return the bitwise XOR of all the numbers that appear twice
    in the array, or 0 if no number appears twice.

    Example 1:
    Input: nums = [1,2,1,3]
    Output: 1
    Explanation: The only number that appears twice in nums is 1.

    Example 2:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: No number appears twice in nums.

    Example 3:
    Input: nums = [1,2,2,1]
    Output: 3
    Explanation: Numbers 1 and 2 appeared twice. 1 XOR 2 == 3.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50
    * Each number in nums appears either once or twice.*/

    int duplicateNumbersXOR(vector<int>& nums) {
        int ans = 0;
        long long seen = 0;
        for (auto& x : nums) {
            if (seen & 1ll<<x) ans ^= x;
            seen ^= 1ll<<x;
        }
        return ans;
    }


    /*3159. Find Occurrences of an Element in an Array (Medium)
    You are given an integer array nums, an integer array queries, and an
    integer x. For each queries[i], you need to find the index of the
    queries[i]th occurrence of x in the nums array. If there are fewer than
    queries[i] occurrences of x, the answer should be -1 for that query. Return
    an integer array answer containing the answers to all queries.

    Example 1:
    Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1
    Output: [0,-1,2,-1]
    Explanation: - For the 1st query, the first occurrence of 1 is at index 0.
                 - For the 2nd query, there are only two occurrences of 1 in
                   nums, so the answer is -1.
                 - For the 3rd query, the second occurrence of 1 is at index 2.
                 - For the 4th query, there are only two occurrences of 1 in
                   nums, so the answer is -1.

    Example 2:
    Input: nums = [1,2,3], queries = [10], x = 5
    Output: [-1]
    Explanation: For the 1st query, 5 doesn't exist in nums, so the answer is -1.

    Constraints:
    * 1 <= nums.length, queries.length <= 10^5
    * 1 <= queries[i] <= 10^5
    * 1 <= nums[i], x <= 10^4*/

    vector<int> occurrencesOfElement(vector<int>& nums, vector<int>& queries, int x) {
        vector<int> loc;
        for (int i = 0; i < nums.size(); ++i)
            if (nums[i] == x) loc.push_back(i);
        vector<int> ans(queries.size());
        transform(queries.begin(), queries.end(), ans.begin(), [&](auto& q) {
            return q <= loc.size() ? loc[q-1] : -1;
        });
        return ans;
    }


    /*3160. Find the Number of Distinct Colors Among the Balls (Medium)
    You are given an integer limit and a 2D array queries of size n x 2. There
    are limit + 1 balls with distinct labels in the range [0, limit]. Initially,
    all balls are uncolored. For every query in queries that is of the form
    [x, y], you mark ball x with the color y. After each query, you need to find
    the number of distinct colors among the balls. Return an array result of
    length n, where result[i] denotes the number of distinct colors after ith
    query. Note that when answering a query, lack of a color will not be
    considered as a color.

    Example 1:
    Input: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]
    Output: [1,2,2,3]
    Explanation: - After query 0, ball 1 has color 4.
                 - After query 1, ball 1 has color 4, and ball 2 has color 5.
                 - After query 2, ball 1 has color 3, and ball 2 has color 5.
                 - After query 3, ball 1 has color 3, ball 2 has color 5, and
                   ball 3 has color 4.

    Example 2:
    Input: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]
    Output: [1,2,2,3,4]
    Explanation: - After query 0, ball 0 has color 1.
                 - After query 1, ball 0 has color 1, and ball 1 has color 2.
                 - After query 2, ball 0 has color 1, and balls 1 and 2 have
                   color 2.
                 - After query 3, ball 0 has color 1, balls 1 and 2 have color
                   2, and ball 3 has color 4.
                 - After query 4, ball 0 has color 1, balls 1 and 2 have color
                   2, ball 3 has color 4, and ball 4 has color 5.

    Constraints:
    * 1 <= limit <= 10^9
    * 1 <= n == queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= queries[i][0] <= limit
    * 1 <= queries[i][1] <= 10^9*/

    vector<int> queryResults(int limit, vector<vector<int>>& queries) {
        vector<int> ans;
        unordered_map<int, int> mp, freq;
        for (auto& q : queries) {
            int b = q[0], c = q[1];
            if (mp[b] && --freq[mp[b]] == 0)
                freq.erase(mp[b]);
            mp[b] = c;
            ++freq[c];
            ans.push_back(freq.size());
        }
        return ans;
    }


    /*3161. Block Placement Queries (Hard）
    There exists an infinite number line, with its origin at 0 and extending
    towards the positive x-axis. You are given a 2D array queries, which
    contains two types of queries:
    * For a query of type 1, queries[i] = [1, x]. Build an obstacle at distance
      x from the origin. It is guaranteed that there is no obstacle at distance
      x when the query is asked.
    * For a query of type 2, queries[i] = [2, x, sz]. Check if it is possible to
      place a block of size sz anywhere in the range [0, x] on the line, such
      that the block entirely lies in the range [0, x]. A block cannot be placed
      if it intersects with any obstacle, but it may touch it. Note that you do
      not actually place the block. Queries are separate.
    Return a boolean array results, where results[i] is true if you can place
    the block specified in the ith query of type 2, and false otherwise.

    Example 1:
    Input: queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]
    Output: [false,true,true]
    Explanation: For query 0, place an obstacle at x = 2. A block of size at
                 most 2 can be placed before x = 3.

    Example 2:
    Input: queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]
    Output: [true,true,false]
    Explanation: - Place an obstacle at x = 7 for query 0. A block of size at
                   most 7 can be placed before x = 7.
                 - Place an obstacle at x = 2 for query 2. Now, a block of size
                   at most 5 can be placed before x = 7, and a block of size at
                   most 2 before x = 2.

    Constraints:
    * 1 <= queries.length <= 15 * 10^4
    * 2 <= queries[i].length <= 3
    * 1 <= queries[i][0] <= 2
    * 1 <= x, sz <= min(5 * 104, 3 * queries.length)
    * The input is generated such that for queries of type 1, no obstacle exists
      at distance x when the query is asked.
    * The input is generated such that there is at least one query of type 2.

    template <typename T>
    class Fenwick {
        vector<T> nums;
    public:
        Fenwick(int n) {
            nums.resize(n+1);
        }

        void update(int k, T val) {
            for (++k; k < nums.size(); k += k & -k)
                nums[k] = max(nums[k], val);
        }

        T query(int k) {
            T ans = 0;
            for (++k; k; k -= k & -k)
                ans = max(ans, nums[k]);
            return ans;
        }
    };*/

    vector<bool> getResults(vector<vector<int>>& queries) {
        set<int> vals;
        vals.insert(0);
        Fenwick<int>* tree = new Fenwick<int>(50001);
        vector<vector<int>> part;
        for (auto& q : queries)
            if (q[0] == 1) part.push_back(q);
        int pp = 0;
        sort(part.begin(), part.end());
        for (auto& p : part) {
            vals.insert(p[1]);
            tree->update(p[1], p[1] - pp);
            pp = p[1];
        }
        vector<bool> ans;
        reverse(queries.begin(), queries.end());
        for (auto& q : queries) {
            auto it = vals.lower_bound(q[1]);
            if (q[0] == 1) {
                tree->update(*next(it), *next(it) - *prev(it));
                vals.erase(it);
            } else
                ans.push_back(max(tree->query(q[1]), q[1] - *prev(it)) >= q[2]);
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }


    /*3162. Find the Number of Good Pairs I (Easy)
    You are given 2 integer arrays nums1 and nums2 of lengths n and m
    respectively. You are also given a positive integer k. A pair (i, j) is
    called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1,
    0 <= j <= m - 1). Return the total number of good pairs.

    Example 1:
    Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
    Output: 5
    Explanation: The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).

    Example 2:
    Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
    Output: 2
    Explanation: The 2 good pairs are (3, 0) and (3, 1).

    Constraints:
    * 1 <= n, m <= 50
    * 1 <= nums1[i], nums2[j] <= 50
    * 1 <= k <= 50*/

    int numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        int ans = 0;
        for (auto& x : nums1)
            for (auto& y : nums2)
                if (x % (y*k) == 0) ++ans;
        return ans;
    }


    /*3163. String Compression III (Medium)
    Given a string word, compress it using the following algorithm:
    * Begin with an empty string comp. While word is not empty, use the
      following operation:
      - Remove a maximum length prefix of word made of a single character c
        repeating at most 9 times.
      - Append the length of the prefix followed by c to comp.
    Return the string comp.

    Example 1:
    Input: word = "abcde"
    Output: "1a1b1c1d1e"
    Explanation: Initially, comp = "". Apply the operation 5 times, choosing
                 "a", "b", "c", "d", and "e" as the prefix in each operation.
                 For each prefix, append "1" followed by the character to comp.

    Example 2:
    Input: word = "aaaaaaaaaaaaaabb"
    Output: "9a5a2b"
    Explanation: Initially, comp = "". Apply the operation 3 times, choosing
                 "aaaaaaaaa", "aaaaa", and "bb" as the prefix in each operation.
                 - For prefix "aaaaaaaaa", append "9" followed by "a" to comp.
                 - For prefix "aaaaa", append "5" followed by "a" to comp.
                 - For prefix "bb", append "2" followed by "b" to comp.

    Constraints:
    * 1 <= word.length <= 2 * 10^5
    * word consists only of lowercase English letters.*/

    string compressedString(string word) {
        string ans;
        for (int i = 0, n = word.size(), ii = 0; i < n; ++i)
            if (i == n-1 || word[i] != word[i+1] || i-ii+1 == 9) {
                ans.push_back('0'+(i-ii+1));
                ans.push_back(word[i]);
                ii = i+1;
            }
        return ans;
    }


    /*3164. Find the Number of Good Pairs II (Medium)
    You are given 2 integer arrays nums1 and nums2 of lengths n and m
    respectively. You are also given a positive integer k. A pair (i, j) is
    called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1,
    0 <= j <= m - 1). Return the total number of good pairs.

    Example 1:
    Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
    Output: 5
    Explanation: The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).

    Example 2:
    Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
    Output: 2
    Explanation: The 2 good pairs are (3, 0) and (3, 1).

    Constraints:
    * 1 <= n, m <= 10^5
    * 1 <= nums1[i], nums2[j] <= 10^6
    * 1 <= k <= 10^3*/

    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        int m = *max_element(nums1.begin(), nums1.end());
        unordered_map<int, int> freq1, freq2;
        for (auto& x : nums1)
            if (x % k == 0) ++freq1[x/k];
        for (auto& x : nums2) ++freq2[x];
        long long ans = 0;
        for (auto& [x, v] : freq2)
            for (int xx = x; xx <= m; xx += x)
                ans += (long long) freq1[xx]*v;
        return ans;
    }


    /*3165. Maximum Sum of Subsequence With Non-adjacent Elements (Hard)
    You are given an array nums consisting of integers. You are also given a 2D
    array queries, where queries[i] = [posi, xi]. For query i, we first set
    nums[posi] equal to xi, then we calculate the answer to query i which is the
    maximum sum of a subsequence of nums where no two adjacent elements are
    selected. Return the sum of the answers to all queries. Since the final
    answer may be very large, return it modulo 10^9 + 7. A subsequence is an
    array that can be derived from another array by deleting some or no elements
    without changing the order of the remaining elements.

    Example 1:
    Input: nums = [3,5,9], queries = [[1,-2],[0,-3]]
    Output: 21
    Explanation: - After the 1st query, nums = [3,-2,9] and the maximum sum of a
                   subsequence with non-adjacent elements is 3 + 9 = 12.
                 - After the 2nd query, nums = [-3,-2,9] and the maximum sum of
                   a subsequence with non-adjacent elements is 9.

    Example 2:
    Input: nums = [0,-1], queries = [[0,-5]]
    Output: 0
    Explanation: After the 1st query, nums = [-5,-1] and the maximum sum of a
                 subsequence with non-adjacent elements is 0 (choosing an empty
                 subsequence).

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * -10^5 <= nums[i] <= 10^5
    * 1 <= queries.length <= 5 * 10^4
    * queries[i] == [posi, xi]
    * 0 <= posi <= nums.length - 1
    * -10^5 <= xi <= 10^5

    class SegTree {
        int n, mod = 1'000'000'007;
        vector<array<long, 4>> tree;

        array<long, 4> op(array<long, 4> left, array<long, 4> right) {
            long lv = left[0], ls = left[1], le = left[2], lse = left[3];
            long rv = right[0], rs = right[1], re = right[2], rse = right[3];
            long v = max(le+rv, lv+rs), s = max(ls+rs, lse+rv), e = max(le+re, lv+rse), se = max(lse+re, ls+rse);
            return {v, s, e, se};
        }

        void build(vector<int>& arr, int k, int lo, int hi) {
            if (lo+1 == hi) tree[k] = {max(0, arr[lo]), 0, 0, 0};
            else {
                int mid = lo + (hi-lo)/2;
                build(arr, 2*k+1, lo, mid);
                build(arr, 2*k+2, mid, hi);
                tree[k] = op(tree[2*k+1], tree[2*k+2]);
            }
        }


    public:
        SegTree(vector<int>& arr) {
            n = arr.size();
            tree.resize(4*n);
            build(arr, 0, 0, n);
        }

        void update(int i, int val, int k = 0, int lo = 0, int hi = 0) {
            if (hi == 0) hi = n;
            if (lo+1 == hi) tree[k][0] = max(0, val);
            else {
                int mid = lo + (hi-lo)/2;
                if (i < mid) update(i, val, 2*k+1, lo, mid);
                else update(i, val, 2*k+2, mid, hi);
                tree[k] = op(tree[2*k+1], tree[2*k+2]);
            }
        }

        array<long, 4> query(int qlo, int qhi, int k = 0, int lo = 0, int hi = 0) {
            if (hi == 0) hi = n;
            if (qhi <= lo || hi <= qlo) return {0, 0, 0, 0};
            if (qlo <= lo && hi <= qhi) return tree[k];
            int mid = lo + (hi-lo)/2;
            return op(query(qlo, qhi, 2*k+1, lo, mid), query(qlo, qhi, 2*k+2, mid, hi));
        }
    };*/

    int maximumSumSubsequence(vector<int>& nums, vector<vector<int>>& queries) {
        SegTree tree = SegTree(nums);
        long ans = 0;
        for (auto& q : queries) {
            int i = q[0], x = q[1];
            tree.update(i, x);
            ans = (ans + tree.query(0, nums.size())[0]) % 1'000'000'007;
        }
        return ans;
    }


    /*3168. Minimum Number of Chairs in a Waiting Room (Easy)
    You are given a string s. Simulate events at each second i:
    * If s[i] == 'E', a person enters the waiting room and takes one of the
      chairs in it.
    * If s[i] == 'L', a person leaves the waiting room, freeing up a chair.
    Return the minimum number of chairs needed so that a chair is available for
    every person who enters the waiting room given that it is initially empty.

    Example 1:
    Input: s = "EEEEEEE"
    Output: 7
    Explanation: After each second, a person enters the waiting room and no
                 person leaves it. Therefore, a minimum of 7 chairs is needed.

    Example 2:
    Input: s = "ELELEEL"
    Output: 2
    Explanation: Let's consider that there are 2 chairs in the waiting room. The
                 table below shows the state of the waiting room at each second.
                 Second  Event   People in the Waiting Room  Available Chairs
                 0   Enter   1   1
                 1   Leave   0   2
                 2   Enter   1   1
                 3   Leave   0   2
                 4   Enter   1   1
                 5   Enter   2   0
                 6   Leave   1   1

    Example 3:
    Input: s = "ELEELEELLL"
    Output: 3
    Explanation: Let's consider that there are 3 chairs in the waiting room. The
                 table below shows the state of the waiting room at each second.
                 Second  Event   People in the Waiting Room  Available Chairs
                 0   Enter   1   2
                 1   Leave   0   3
                 2   Enter   1   2
                 3   Enter   2   1
                 4   Leave   1   2
                 5   Enter   2   1
                 6   Enter   3   0
                 7   Leave   2   1
                 8   Leave   1   2
                 9   Leave   0   3

    Constraints:
    * 1 <= s.length <= 50
    * s consists only of the letters 'E' and 'L'.
    * s represents a valid sequence of entries and exits.*/

    int minimumChairs(string s) {
        int ans = 0, prefix = 0;
        for (auto& ch : s) {
            if (ch == 'E') ++prefix;
            else --prefix;
            ans = max(ans, prefix);
        }
        return ans;
    }


    /*3169. Count Days Without Meetings (Medium)
    You are given a positive integer days representing the total number of days
    an employee is available for work (starting from day 1). You are also given
    a 2D array meetings of size n where, meetings[i] = [start_i, end_i]
    represents the starting and ending days of meeting i (inclusive). Return the
    count of days when the employee is available for work but no meetings are
    scheduled. Note: The meetings may overlap.

    Example 1:
    Input: days = 10, meetings = [[5,7],[1,3],[9,10]]
    Output: 2
    Explanation: There is no meeting scheduled on the 4th and 8th days.

    Example 2:
    Input: days = 5, meetings = [[2,4],[1,3]]
    Output: 1
    Explanation: There is no meeting scheduled on the 5th day.

    Example 3:
    Input: days = 6, meetings = [[1,6]]
    Output: 0
    Explanation: Meetings are scheduled for all working days.

    Constraints:
    * 1 <= days <= 10^9
    * 1 <= meetings.length <= 10^5
    * meetings[i].length == 2
    * 1 <= meetings[i][0] <= meetings[i][1] <= days*/

    int countDays(int days, vector<vector<int>>& meetings) {
        int ans = 0, prev = 0;
        sort(meetings.begin(), meetings.end());
        for (auto& m : meetings) {
            int x = m[0], y = m[1];
            ans += max(0, min(x, days)-prev-1);
            prev = max(prev, y);
        }
        return ans + max(0, days-prev);
    }


    /*3170. Lexicographically Minimum String After Removing Stars (Medium)
    You are given a string s. It may contain any number of '*' characters. Your
    task is to remove all '*' characters. While there is a '*', do the following
    operation:
    * Delete the leftmost '*' and the smallest non-'*' character to its left. If
      there are several smallest characters, you can delete any of them.
    Return the lexicographically smallest resulting string after removing all
    '*' characters.

    Example 1:
    Input: s = "aaba*"
    Output: "aab"
    Explanation: We should delete one of the 'a' characters with '*'. If we
                 choose s[3], s becomes the lexicographically smallest.

    Example 2:
    Input: s = "abc"
    Output: "abc"
    Explanation: There is no '*' in the string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters and '*'.
    * The input is generated such that it is possible to delete all '*'
    characters.*/

    string clearStars(string s) {
        auto compare = [&](int i, int j) { return s[i] > s[j] || s[i] == s[j] && i < j; };
        priority_queue<int, vector<int>, decltype(compare)> pq(compare);
        for (int i = 0; i < s.size(); ++i)
            if (s[i] == '*') s[pq.top()] = '*', pq.pop();
            else pq.emplace(i);
        s.erase(remove(s.begin(), s.end(), '*'), s.end());
        return s;
    }


    /*3171. Find Subarray With Bitwise AND Closest to K (Hard)
    You are given an array nums and an integer k. You need to find a subarray of
    nums such that the absolute difference between k and the bitwise AND of the
    subarray elements is as small as possible. In other words, select a subarray
    nums[l..r] such that |k - (nums[l] AND nums[l + 1] ... AND nums[r])| is
    minimum. Return the minimum possible value of the absolute difference. A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,4,5], k = 3
    Output: 1
    Explanation: The subarray nums[2..3] has AND value 4, which gives the
                 minimum absolute difference |3 - 4| = 1.

    Example 2:
    Input: nums = [1,2,1,2], k = 2
    Output: 0
    Explanation: The subarray nums[1..1] has AND value 2, which gives the
                 minimum absolute difference |2 - 2| = 0.

    Example 3:
    Input: nums = [1], k = 10
    Output: 9
    Explanation: There is a single subarray with AND value 1, which gives the
                 minimum absolute difference |10 - 1| = 9.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9*/

    int minimumDifference(vector<int>& nums, int k) {
        vector<int> freq(30);
        int ans = INT_MAX, mask = (1<<30)-1;
        for (int i = 0, ii = 0; i < nums.size(); ++i) {
            for (int j = 0; j < 30; ++j)
                if ((nums[i] & 1<<j) == 0 && freq[j]++ == 0)
                    mask ^= 1<<j;
            ans = min(ans, abs(mask-k));
            for (; ii < i && mask < k; ++ii) {
                for (int j = 0; j < 30; ++j)
                    if ((nums[ii] & 1<<j) == 0 && --freq[j] == 0)
                        mask ^= 1<<j;
                ans = min(ans, abs(mask-k));
            }
        }
        return ans;
    }


    /*3174. Clear Digits (Easy)
    You are given a string s. Your task is to remove all digits by doing this
    operation repeatedly:
    * Delete the first digit and the closest non-digit character to its left.
    Return the resulting string after removing all digits.

    Example 1:
    Input: s = "abc"
    Output: "abc"
    Explanation: There is no digit in the string.

    Example 2:
    Input: s = "cb34"
    Output: ""
    Explanation: First, we apply the operation on s[2], and s becomes "c4". Then
                 we apply the operation on s[1], and s becomes "".

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of lowercase English letters and digits.
    * The input is generated such that it is possible to delete all digits.*/

    string clearDigits(string s) {
        string ans;
        for (auto& ch : s)
            if (isdigit(ch)) ans.pop_back();
            else ans.push_back(ch);
        return ans;
    }


    /*3175. Find The First Player to win K Games in a Row (Medium)
    A competition consists of n players numbered from 0 to n - 1. You are given
    an integer array skills of size n and a positive integer k, where skills[i]
    is the skill level of player i. All integers in skills are unique. All
    players are standing in a queue in order from player 0 to player n - 1. The
    competition process is as follows:
    * The first two players in the queue play a game, and the player with the
      higher skill level wins.
    * After the game, the winner stays at the beginning of the queue, and the
      loser goes to the end of it.
    The winner of the competition is the first player who wins k games in a row.
    Return the initial index of the winning player.

    Example 1:
    Input: skills = [4,2,6,3,9], k = 2
    Output: 2
    Explanation: Initially, the queue of players is [0,1,2,3,4]. The following
                 process happens:
                 - Players 0 and 1 play a game, since the skill of player 0 is
                   higher than that of player 1, player 0 wins. The resulting
                   queue is [0,2,3,4,1].
                 - Players 0 and 2 play a game, since the skill of player 2 is
                   higher than that of player 0, player 2 wins. The resulting
                   queue is [2,3,4,1,0].
                 - Players 2 and 3 play a game, since the skill of player 2 is
                   higher than that of player 3, player 2 wins. The resulting
                   queue is [2,4,1,0,3].
                 - Player 2 won k = 2 games in a row, so the winner is player 2.

    Example 2:
    Input: skills = [2,5,4], k = 3
    Output: 1
    Explanation: Initially, the queue of players is [0,1,2]. The following
                 process happens:
                 - Players 0 and 1 play a game, since the skill of player 1 is
                   higher than that of player 0, player 1 wins. The resulting
                   queue is [1,2,0].
                 - Players 1 and 2 play a game, since the skill of player 1 is
                   higher than that of player 2, player 1 wins. The resulting
                   queue is [1,0,2].
                 - Players 1 and 0 play a game, since the skill of player 1 is
                   higher than that of player 0, player 1 wins. The resulting
                   queue is [1,2,0].
                 - Player 1 won k = 3 games in a row, so the winner is player 1.

    Constraints:
    * n == skills.length
    * 2 <= n <= 10^5
    * 1 <= k <= 10^9
    * 1 <= skills[i] <= 10^6
    * All integers in skills are unique.*/

    int findWinningPlayer(vector<int>& skills, int k) {
        int j = 0;
        for (int i = 1, cnt = 0; i < skills.size() && cnt < k; ++i, ++cnt)
            if (skills[j] < skills[i]) {
                j = i;
                cnt = 0;
            }
        return j;
    }


    /*3176. Find the Maximum Length of a Good Subsequence I (Medium)
    You are given an integer array nums and a non-negative integer k. A sequence
    of integers seq is called good if there are at most k indices i in the range
    [0, seq.length - 2] such that seq[i] != seq[i + 1]. Return the maximum
    possible length of a good subsequence of nums.

    Example 1:
    Input: nums = [1,2,1,1,3], k = 2
    Output: 4
    Explanation: The maximum length subsequence is [1,2,1,1,3].

    Example 2:
    Input: nums = [1,2,3,4,5,1], k = 0
    Output: 2
    Explanation: The maximum length subsequence is [1,2,3,4,5,1].

    Constraints:
    * 1 <= nums.length <= 500
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= min(nums.length, 25)*/

    int maximumLength(vector<int>& nums, int k) {
        vector<unordered_map<int, int>> dp(k+1);
        vector<int> most(k+1);
        for (auto& x : nums)
            for (int i = k; i >= 0; --i) {
                ++dp[i][x];
                if (i) dp[i][x] = max(dp[i][x], 1 + most[i-1]);
                most[i] = max(most[i], dp[i][x]);
            }
        return most[k];
    }


    /*3177. Find the Maximum Length of a Good Subsequence II (Hard)
    You are given an integer array nums and a non-negative integer k. A sequence
    of integers seq is called good if there are at most k indices i in the range
    [0, seq.length - 2] such that seq[i] != seq[i + 1]. Return the maximum
    possible length of a good subsequence of nums.

    Example 1:
    Input: nums = [1,2,1,1,3], k = 2
    Output: 4
    Explanation: The maximum length subsequence is [1,2,1,1,3].

    Example 2:
    Input: nums = [1,2,3,4,5,1], k = 0
    Output: 2
    Explanation: The maximum length subsequence is [1,2,3,4,5,1].

    Constraints:
    * 1 <= nums.length <= 5 * 10^3
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= min(50, nums.length)*/

    int maximumLength(vector<int>& nums, int k) {
        vector<unordered_map<int, int>> dp(k+1);
        vector<int> most(k+1);
        for (auto& x : nums)
            for (int i = k; i >= 0; --i) {
                ++dp[i][x];
                if (i) dp[i][x] = max(dp[i][x], 1 + most[i-1]);
                most[i] = max(most[i], dp[i][x]);
            }
        return most[k];
    }


    /*3179. Find the N-th Value After K Seconds (Medium)
    You are given two integers n and k. Initially, you start with an array a of
    n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you
    simultaneously update each element to be the sum of all its preceding
    elements plus the element itself. For example, after one second, a[0]
    remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2],
    and so on. Return the value of a[n - 1] after k seconds. Since the answer
    may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 4, k = 5
    Output: 56
    Explanation: Second  State After
                 0   [1,1,1,1]
                 1   [1,2,3,4]
                 2   [1,3,6,10]
                 3   [1,4,10,20]
                 4   [1,5,15,35]
                 5   [1,6,21,56]

    Example 2:
    Input: n = 5, k = 3
    Output: 35
    Explanation: Second  State After
                 0   [1,1,1,1,1]
                 1   [1,2,3,4,5]
                 2   [1,3,6,10,15]
                 3   [1,4,10,20,35]

    Constraints: 1 <= n, k <= 1000*/

    int valueAfterKSeconds(int n, int k) {
        long ans = 1, mod = 1'000'000'007;
        vector<long> inv(k+1, 1);
        for (int i = 1; i <= k; ++i) {
            if (i >= 2)
                inv[i] = mod - mod/i * inv[mod % i] % mod;
            ans = ans * (n+k-i) % mod;
            ans = ans * inv[i] % mod;
        }
        return ans;
    }


    /*3184. Count Pairs That Form a Complete Day I (Easy)
    Given an integer array hours representing times in hours, return an integer
    denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms
    a complete day. A complete day is defined as a time duration that is an
    exact multiple of 24 hours. For example, 1 day is 24 hours, 2 days is 48
    hours, 3 days is 72 hours, and so on.

    Example 1:
    Input: hours = [12,12,30,24,24]
    Output: 2
    Explanation: The pairs of indices that form a complete day are (0, 1) and
                 (3, 4).

    Example 2:
    Input: hours = [72,48,24,3]
    Output: 3
    Explanation: The pairs of indices that form a complete day are (0, 1),
                 (0, 2), and (1, 2).

    Constraints:
    * 1 <= hours.length <= 100
    * 1 <= hours[i] <= 10^9*/

    int countCompleteDayPairs(vector<int>& hours) {
        int ans = 0;
        vector<int> freq(24);
        for (auto& h : hours) {
            ans += freq[(24-h%24) % 24];
            ++freq[h % 24];
        }
        return ans;
    }


    /*3185. Count Pairs That Form a Complete Day II (Medium)
    Given an integer array hours representing times in hours, return an integer
    denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms
    a complete day. A complete day is defined as a time duration that is an
    exact multiple of 24 hours. For example, 1 day is 24 hours, 2 days is 48
    hours, 3 days is 72 hours, and so on.

    Example 1:
    Input: hours = [12,12,30,24,24]
    Output: 2
    Explanation: The pairs of indices that form a complete day are (0, 1) and
                 (3, 4).

    Example 2:
    Input: hours = [72,48,24,3]
    Output: 3
    Explanation: The pairs of indices that form a complete day are (0, 1),
                 (0, 2), and (1, 2).

    Constraints:
    * 1 <= hours.length <= 5 * 10^5
    * 1 <= hours[i] <= 10^9*/

    long long countCompleteDayPairs(vector<int>& hours) {
        long ans = 0;
        vector<int> freq(24);
        for (auto& h : hours) {
            ans += freq[(24-h%24) % 24];
            ++freq[h % 24];
        }
        return ans;
    }


    /*3186. Maximum Total Damage With Spell Casting (Medium)
    A magician has various spells. You are given an array power, where each
    element represents the damage of a spell. Multiple spells can have the same
    damage value. It is a known fact that if a magician decides to cast a spell
    with a damage of power[i], they cannot cast any spell with a damage of
    power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2. Each spell can be
    cast only once. Return the maximum possible total damage that a magician can
    cast.

    Example 1:
    Input: power = [1,1,3,4]
    Output: 6
    Explanation: The maximum possible damage of 6 is produced by casting spells
                 0, 1, 3 with damage 1, 1, 4.

    Example 2:
    Input: power = [7,1,6,6]
    Output: 13
    Explanation: The maximum possible damage of 13 is produced by casting spells
                 1, 2, 3 with damage 1, 6, 6.

    Constraints:
    * 1 <= power.length <= 10^5
    * 1 <= power[i] <= 10^9*/

    long long maximumTotalDamage(vector<int>& power) {
        sort(power.begin(), power.end());
        int n = power.size();
        vector<long long> dp(power.size());
        long long prefix = 0;
        for (int i = 0, j = 0; i < power.size(); ++i)
            if (i && power[i-1] == power[i]) dp[i] = dp[i-1] + power[i];
            else {
                for (; power[j] < power[i]-2; ++j)
                    prefix = max(prefix, dp[j]);
                dp[i] = prefix + power[i];
            }
        return *max_element(dp.begin(), dp.end());
    }


    /*3187. Peaks in Array (Hard)
    A peak in an array arr is an element that is greater than its previous and
    next element in arr. You are given an integer array nums and a 2D integer
    array queries. You have to process queries of two types:
    * queries[i] = [1, li, ri], determine the count of peak elements in the
      subarray nums[li..ri].
    * queries[i] = [2, indexi, vali], change nums[indexi] to vali.
    Return an array answer containing the results of the queries of the first
    type in order. Notes:
    * The first and the last element of an array or a subarray cannot be a peak.

    Example 1:
    Input: nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]
    Output: [0]
    Explanation: First query: We change nums[3] to 4 and nums becomes
                 [3,1,4,4,5]. Second query: The number of peaks in the
                 [3,1,4,4,5] is 0.

    Example 2:
    Input: nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]
    Output: [0,1]
    Explanation: First query: nums[2] should become 4, but it is already set to
                 4. Second query: The number of peaks in the [4,1,4] is 0. Third
                 query: The second 4 is a peak in the [4,1,4,2,1].

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i][0] == 1 or queries[i][0] == 2
    * For all i that:
      - queries[i][0] == 1: 0 <= queries[i][1] <= queries[i][2] <= nums.length - 1
      - queries[i][0] == 2: 0 <= queries[i][1] <= nums.length - 1,
        1 <= queries[i][2] <= 10^5

    class Fenwick {
        vector<int> nums;
    public:
        Fenwick(int n) {
            nums.resize(n+1);
        }

        void add(int k, int delta) {
            for (++k; k < nums.size(); k += k & -k)
                nums[k] += delta;
        }

        long query(int k) {
            long ans = 0;
            for (++k; k; k -= k & -k)
                ans += nums[k];
            return ans;
        }
    };*/

    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        Fenwick *tree = new Fenwick(n);
        for (int i = 1; i < n-1; ++i)
            if (nums[i-1] < nums[i] && nums[i] > nums[i+1])
                tree->add(i, 1);
        vector<int> ans;
        for (auto& q : queries) {
            if (q[0] == 1) {
                int lo = q[1], hi = q[2];
                ans.push_back(tree->query(max(lo, hi-1)) - tree->query(lo));
            } else {
                int k = q[1], v = q[2];
                for (int i = max(1, k-1); i <= k+1 && i+1 < n; ++i)
                    if (nums[i-1] < nums[i] && nums[i] > nums[i+1])
                        tree->add(i, -1);
                nums[k] = v;
                for (int i = max(1, k-1); i <= k+1 && i+1 < n; ++i)
                    if (nums[i-1] < nums[i] && nums[i] > nums[i+1])
                        tree->add(i, 1);
            }
        }
        return ans;
    }


    /*3190. Find Minimum Operations to Make All Elements Divisible by Three (Easy)
    You are given an integer array nums. In one operation, you can add or
    subtract 1 from any element of nums. Return the minimum number of operations
    to make all elements of nums divisible by 3.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 3
    Explanation: All array elements can be made divisible by 3 using 3
                 operations:
                 - Subtract 1 from 1.
                 - Add 1 to 2.
                 - Subtract 1 from 4.

    Example 2:
    Input: nums = [3,6,9]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50*/

    int minimumOperations(vector<int>& nums) {
        return accumulate(nums.begin(), nums.end(), 0, [&](auto s, auto& x) {
            return s + min(x%3, 3-x%3);
        });
    }


    /*3191. Minimum Operations to Make Binary Array Elements Equal to One I (Medium)
    You are given a binary array nums. You can do the following operation on the
    array any number of times (possibly zero):
    * Choose any 3 consecutive elements from the array and flip all of them.
    Flipping an element means changing its value from 0 to 1, and from 1 to 0.
    Return the minimum number of operations required to make all elements in
    nums equal to 1. If it is impossible, return -1.

    Example 1:
    Input: nums = [0,1,1,1,0,0]
    Output: 3
    Explanation: We can do the following operations:
                 - Choose the elements at indices 0, 1 and 2. The resulting
                   array is nums = [1,0,0,1,0,0].
                 - Choose the elements at indices 1, 2 and 3. The resulting
                   array is nums = [1,1,1,0,0,0].
                 - Choose the elements at indices 3, 4 and 5. The resulting
                   array is nums = [1,1,1,1,1,1].

    Example 2:
    Input: nums = [0,1,1,1]
    Output: -1
    Explanation: It is impossible to make all elements equal to 1.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1*/

    int minOperations(vector<int>& nums) {
        int ans = 0, flip = 0, n = nums.size();
        vector<int> line(n);
        for (int i = 0; i < n; ++i) {
            if (line[i]) flip ^= 1;
            nums[i] ^= flip;
            if (nums[i] == 0) {
                if (i+2 >= n) return -1;
                ++ans;
                flip ^= 1;
                if (i+3 < n) line[i+3] = 1;
            }
        }
        return ans;
    }


    /*3192. Minimum Operations to Make Binary Array Elements Equal to One II (Medium)
    You are given a binary array nums. You can do the following operation on
    the array any number of times (possibly zero):
    * Choose any index i from the array and flip all the elements from index i
      to the end of the array.
    Flipping an element means changing its value from 0 to 1, and from 1 to 0.
    Return the minimum number of operations required to make all elements in
    nums equal to 1.

    Example 1:
    Input: nums = [0,1,1,0,1]
    Output: 4
    Explanation: We can do the following operations:
                 - Choose the index i = 1. The resulting array will be
                   nums = [0,0,0,1,0].
                 - Choose the index i = 0. The resulting array will be
                   nums = [1,1,1,0,1].
                 - Choose the index i = 4. The resulting array will be
                   nums = [1,1,1,0,0].
                 - Choose the index i = 3. The resulting array will be
                   nums = [1,1,1,1,1].

    Example 2:
    Input: nums = [1,0,0,0]
    Output: 1
    Explanation: We can do the following operation:
                 - Choose the index i = 1. The resulting array will be
                   nums = [1,1,1,1].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1*/

    int minOperations(vector<int>& nums) {
        int ans = 0;
        for (auto& x : nums)
            if (x == (ans & 1)) ++ans;
        return ans;
    }


    /*3193. Count the Number of Inversions (Hard)
    You are given an integer n and a 2D array requirements, where
    requirements[i] = [endi, cnti] represents the end index and the inversion
    count of each requirement. A pair of indices (i, j) from an integer array
    nums is called an inversion if:
    * i < j and nums[i] > nums[j]
    Return the number of permutations perm of [0, 1, 2, ..., n - 1] such that
    for all requirements[i], perm[0..endi] has exactly cnti inversions. Since
    the answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, requirements = [[2,2],[0,0]]
    Output: 2
    Explanation: The two permutations are:
                 - [2, 0, 1]
                   + Prefix [2, 0, 1] has inversions (0, 1) and (0, 2).
                   + Prefix [2] has 0 inversions.
                 - [1, 2, 0]
                   + Prefix [1, 2, 0] has inversions (0, 2) and (1, 2).
                   + Prefix [1] has 0 inversions.

    Example 2:
    Input: n = 3, requirements = [[2,2],[1,1],[0,0]]
    Output: 1
    Explanation: The only satisfying permutation is [2, 0, 1]:
                 - Prefix [2, 0, 1] has inversions (0, 1) and (0, 2).
                 - Prefix [2, 0] has an inversion (0, 1).
                 - Prefix [2] has 0 inversions.

    Example 3:
    Input: n = 2, requirements = [[0,0],[1,0]]
    Output: 1
    Explanation: The only satisfying permutation is [0, 1]:
                 - Prefix [0] has 0 inversions.
                 - Prefix [0, 1] has an inversion (0, 1).

    Constraints:
    * 2 <= n <= 300
    * 1 <= requirements.length <= n
    * requirements[i] = [endi, cnti]
    * 0 <= endi <= n - 1
    * 0 <= cnti <= 400
    * The input is generated such that there is at least one i such that
      endi == n - 1.
    * The input is generated such that all endi are unique.*/

    int numberOfPermutations(int n, vector<vector<int>>& requirements) {
        int m = 0, mod = 1'000'000'007;
        vector<int> line(n, -1);
        for (auto& r : requirements) {
            line[r[0]] = r[1];
            m = max(m, r[1]);
        }
        vector<vector<long>> dp(n, vector<long>(m+1));
        dp[0][0] = 1;
        for (int i = 0; i < n; ++i) {
            long prefix = 0;
            for (int j = 0; j <= m; ++j) {
                if (i) {
                    prefix += dp[i-1][j];
                    if (j > i) prefix -= dp[i-1][j-1-i];
                    dp[i][j] = prefix = (mod + prefix % mod) % mod;
                }
                if (line[i] != -1 && line[i] != j) dp[i][j] = 0;
            }
        }
        return dp[n-1][line[n-1]];
    }


    /*3194. Minimum Average of Smallest and Largest Elements (Easy)
    You have an array of floating point numbers averages which is initially
    empty. You are given an array nums of n integers where n is even. You repeat
    the following procedure n / 2 times:
    * Remove the smallest element, minElement, and the largest element
      maxElement, from nums.
    * Add (minElement + maxElement) / 2 to averages.
    Return the minimum element in averages.

    Example 1:
    Input: nums = [7,8,3,4,15,13,4,1]
    Output: 5.5
    Explanation: step  nums                 averages
                 0     [7,8,3,4,15,13,4,1]  []
                 1     [7,8,3,4,13,4]       [8]
                 2     [7,8,4,4]            [8,8]
                 3     [7,4]                [8,8,6]
                 4     []                   [8,8,6,5.5]
                 The smallest element of averages, 5.5, is returned.

    Example 2:
    Input: nums = [1,9,8,3,10,5]
    Output: 5.5
    Explanation: step  nums                 averages
                 0     [1,9,8,3,10,5]       []
                 1     [9,8,3,5]            [5.5]
                 2     [8,5]                [5.5,6]
                 3     []                   [5.5,6,6.5]

    Example 3:
    Input: nums = [1,2,3,7,8,9]
    Output: 5.0
    Explanation: step  nums                 averages
                 0     [1,2,3,7,8,9]        []
                 1     [2,3,7,8]            [5]
                 2     [3,7]                [5,5]
                 3     []                   [5,5,5]

    Constraints:
    * 2 <= n == nums.length <= 50
    * n is even.
    * 1 <= nums[i] <= 50*/

    double minimumAverage(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        double ans = DBL_MAX;
        for (int lo = 0, hi = nums.size()-1; lo < hi; ++lo, --hi)
            ans = min(ans, 0.5*(nums[lo] + nums[hi]));
        return ans;
    }


    /*3195. Find the Minimum Area to Cover All Ones I (Medium)
    You are given a 2D binary array grid. Find a rectangle with horizontal and
    vertical sides with the smallest area, such that all the 1's in grid lie
    inside this rectangle. Return the minimum possible area of the rectangle.

    Example 1:
    Input: grid = [[0,1,0],[1,0,1]]
    Output: 6
    Explanation: The smallest rectangle has a height of 2 and a width of 3, so
                 it has an area of 2 * 3 = 6.

    Example 2:
    Input: grid = [[1,0],[0,0]]
    Output: 1
    Explanation: The smallest rectangle has both height and width 1, so its area
                 is 1 * 1 = 1.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 1000
    * grid[i][j] is either 0 or 1.
    * The input is generated such that there is at least one 1 in grid.*/

    int minimumArea(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int imin = INT_MAX, imax = INT_MIN, jmin = INT_MAX, jmax = INT_MIN;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j]) {
                    imin = min(imin, i);
                    imax = max(imax, i);
                    jmin = min(jmin, j);
                    jmax = max(jmax, j);
                }
        return (imax-imin+1)*(jmax-jmin+1);
    }


    /*3196. Maximize Total Cost of Alternating Subarrays (Medium)
    You are given an integer array nums with length n. The cost of a subarray
    nums[l..r], where 0 <= l <= r < n, is defined as:

    * cost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)r − l

    Your task is to split nums into subarrays such that the total cost of the
    subarrays is maximized, ensuring each element belongs to exactly one
    subarray. Formally, if nums is split into k subarrays, where k > 1, at
    indices i1, i2, ..., ik − 1, where 0 <= i1 < i2 < ... < ik - 1 < n - 1, then
    the total cost will be:

    * cost(0, i1) + cost(i1 + 1, i2) + ... + cost(ik − 1 + 1, n − 1)

    Return an integer denoting the maximum total cost of the subarrays after
    splitting the array optimally. Note: If nums is not split into subarrays,
    i.e. k = 1, the total cost is simply cost(0, n - 1).

    Example 1:
    Input: nums = [1,-2,3,4]
    Output: 10
    Explanation: One way to maximize the total cost is by splitting
                 [1, -2, 3, 4] into subarrays [1, -2, 3] and [4]. The total cost
                 will be (1 + 2 + 3) + 4 = 10.

    Example 2:
    Input: nums = [1,-1,1,-1]
    Output: 4
    Explanation: One way to maximize the total cost is by splitting
                 [1, -1, 1, -1] into subarrays [1, -1] and [1, -1]. The total
                 cost will be (1 + 1) + (1 + 1) = 4.

    Example 3:
    Input: nums = [0]
    Output: 0
    Explanation: We cannot split the array further, so the answer is 0.

    Example 4:
    Input: nums = [1,-1]
    Output: 2
    Explanation: Selecting the whole array gives a total cost of 1 + 1 = 2,
                 which is the maximum.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    long long maximumTotalCost(vector<int>& nums) {
        long long ans = 0, suffix = 0;
        for (int i = nums.size()-1; i >= 0; --i) {
            suffix = nums[i] - suffix;
            if (suffix > 0) {
                ans += suffix;
                suffix = 0;
            }
        }
        return ans + suffix;
    }


    /*3197. Find the Minimum Area to Cover All Ones II (Hard)
    You are given a 2D binary array grid. You need to find 3 non-overlapping
    rectangles having non-zero areas with horizontal and vertical sides such
    that all the 1's in grid lie inside these rectangles. Return the minimum
    possible sum of the area of these rectangles. Note that the rectangles are
    allowed to touch.

    Example 1:
    Input: grid = [[1,0,1],[1,1,1]]
    Output: 5
    Explanation: - The 1's at (0, 0) and (1, 0) are covered by a rectangle of
                   area 2.
                 - The 1's at (0, 2) and (1, 2) are covered by a rectangle of
                   area 2.
                 - The 1 at (1, 1) is covered by a rectangle of area 1.

    Example 2:
    Input: grid = [[1,0,1,0],[0,1,0,1]]
    Output: 5
    Explanation: - The 1's at (0, 0) and (0, 2) are covered by a rectangle of
                   area 3.
                 - The 1 at (1, 1) is covered by a rectangle of area 1.
                 - The 1 at (1, 3) is covered by a rectangle of area 1.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 30
    * grid[i][j] is either 0 or 1.
    * The input is generated such that there are at least three 1's in grid.*/

    int minimumSum(vector<vector<int>>& grid) {

        function<vector<int>(vector<vector<int>>&)> fn = [&](vector<vector<int>>& grid) {
            vector<int> ans;
            int imin = 30, jmin = 30, imax = 0, jmax = 0;
            for (int i = 0; i < grid.size()-1; ++i) {
                for (int j = 0; j < grid[i].size(); ++j)
                    if (grid[i][j]) {
                        imin = min(imin, i);
                        jmin = min(jmin, j);
                        imax = max(imax, i);
                        jmax = max(jmax, j);
                    }
                int val = 0;
                if (imin <= imax && jmin <= jmax)
                    val = (imax-imin+1) * (jmax-jmin+1);
                ans.push_back(val);
            }
            return ans;
        };

        auto rotate = [&](vector<vector<int>>& grid) {
            int m = grid.size(), n = grid[0].size();
            vector<vector<int>> ans(n, vector<int>(m));
            reverse(grid.begin(), grid.end());
            for (int i = 0; i < m; ++i)
                for (int j = 0; j < n; ++j)
                    ans[j][i] = grid[i][j];
            return ans;
        };

        int ans = INT_MAX;
        for (int k = 4; k--; ) {
            vector<int> half = fn(grid);
            for (int i = 0; i < half.size(); ++i) {
                if (half[i]) {
                    vector<vector<int>> sub(grid.begin()+i+1, grid.end());
                    for (int sz = 2; sz--; ) {
                        vector<int> top = fn(sub);
                        reverse(sub.begin(), sub.end());
                        vector<int> bottom = fn(sub);
                        for (int j = 0, n = top.size(); j < n; ++j)
                            if (top[j] && bottom[n-1-j])
                                ans = min(ans, half[i] + top[j] + bottom[n-1-j]);
                        sub = rotate(sub);
                    }
                }
            }
            grid = rotate(grid);
        }
        return ans;
    }


    /*3200. Maximum Height of a Triangle (Easy)
    You are given two integers red and blue representing the count of red and
    blue colored balls. You have to arrange these balls to form a triangle such
    that the 1st row will have 1 ball, the 2nd row will have 2 balls, the 3rd
    row will have 3 balls, and so on. All the balls in a particular row should
    be the same color, and adjacent rows should have different colors. Return
    the maximum height of the triangle that can be achieved.

    Example 1:
    Input: red = 2, blue = 4
    Output: 3
    Explanation: The only possible arrangement is shown above.

    Example 2:
    Input: red = 2, blue = 1
    Output: 2
    Explanation: The only possible arrangement is shown above.

    Example 3:
    Input: red = 1, blue = 1
    Output: 1

    Example 4:
    Input: red = 10, blue = 1
    Output: 2
    Explanation: The only possible arrangement is shown above.

    Constraints: 1 <= red, blue <= 100*/

    int maxHeightOfTriangle(int red, int blue) {
        int ans = 0;
        vector<vector<int>> balls = {{red, blue}, {blue, red}};
        for (auto& ball : balls) {
            int cand = 0;
            for (int k = 1, i = 0; ball[i] >= k; ++k, i ^= 1) {
                ball[i] -= k;
                ++cand;
            }
            ans = max(ans, cand);
        }
        return ans;
    }


    /*3201. Find the Maximum Length of Valid Subsequence I (Medium)
    You are given an integer array nums. A subsequence sub of nums with length x
    is called valid if it satisfies:
    * (sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ...
      == (sub[x - 2] + sub[x - 1]) % 2.
    Return the length of the longest valid subsequence of nums. A subsequence is
    an array that can be derived from another array by deleting some or no
    elements without changing the order of the remaining elements.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 4
    Explanation: The longest valid subsequence is [1, 2, 3, 4].

    Example 2:
    Input: nums = [1,2,1,1,2,1,2]
    Output: 6
    Explanation: The longest valid subsequence is [1, 2, 1, 2, 1, 2].

    Example 3:
    Input: nums = [1,3]
    Output: 2
    Explanation: The longest valid subsequence is [1, 3].

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * 1 <= nums[i] <= 10^7*/

    int maximumLength(vector<int>& nums) {
        vector<vector<int>> dp(2, vector<int>(2));
        for (auto& x : nums) {
            x %= 2;
            dp[x][0] = 1 + dp[0][x];
            dp[x][1] = 1 + dp[1][x];
        }
        return max({dp[0][0], dp[0][1], dp[1][0], dp[1][1]});
    }


    /*3202. Find the Maximum Length of Valid Subsequence II (Medium)
    You are given an integer array nums and a positive integer k. A subsequence
    sub of nums with length x is called valid if it satisfies:
    * (sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k.
    Return the length of the longest valid subsequence of nums.

    Example 1:
    Input: nums = [1,2,3,4,5], k = 2
    Output: 5
    Explanation: The longest valid subsequence is [1, 2, 3, 4, 5].

    Example 2:
    Input: nums = [1,4,2,3,1,4], k = 3
    Output: 4
    Explanation: The longest valid subsequence is [1, 4, 1, 4].

    Constraints:
    * 2 <= nums.length <= 10^3
    * 1 <= nums[i] <= 10^7
    * 1 <= k <= 10^3*/

    int maximumLength(vector<int>& nums, int k) {
        vector<vector<int>> dp(k, vector<int>(k));
        for (auto& x : nums) {
            x %= k;
            for (int y = 0; y < k; ++y)
                dp[x][y] = 1 + dp[y][x];
        }
        int ans = 0;
        for (int i = 0; i < k; ++i)
            ans = max(ans, *max_element(dp[i].begin(), dp[i].end()));
        return ans;
    }


    /*3203. Find Minimum Diameter After Merging Two Trees (Hard)
    There exist two undirected trees with n and m nodes, numbered from 0 to
    n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays
    edges1 and edges2 of lengths n - 1 and m - 1, respectively, where
    edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the first tree and edges2[i] = [ui, vi] indicates that there is an edge
    between nodes ui and vi in the second tree. You must connect one node from
    the first tree with another node from the second tree with an edge. Return
    the minimum possible diameter of the resulting tree. The diameter of a tree
    is the length of the longest path between any two nodes in the tree.

    Example 1:
    Input: edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]
    Output: 3
    Explanation: We can obtain a tree of diameter 3 by connecting node 0 from
                 the first tree with any node from the second tree.

    Example 2:
    Input: edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]
    Output: 5
    Explanation: We can obtain a tree of diameter 5 by connecting node 0 from
                 the first tree with node 0 from the second tree.

    Constraints:
    * 1 <= n, m <= 10^5
    * edges1.length == n - 1
    * edges2.length == m - 1
    * edges1[i].length == edges2[i].length == 2
    * edges1[i] = [ai, bi]
    * 0 <= ai, bi < n
    * edges2[i] = [ui, vi]
    * 0 <= ui, vi < m
    * The input is generated such that edges1 and edges2 represent valid trees.*/

    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {

        auto bfs = [&](int u, vector<vector<int>>& graph) {
            int ans = 0;
            queue<pair<int, int>> q; q.emplace(u, -1);
            while (q.size()) {
                ++ans;
                for (int sz = q.size(); sz; --sz) {
                    auto [x, p] = q.front(); q.pop();
                    u = x;
                    for (auto& v : graph[u])
                        if (v != p)
                            q.emplace(v, u);
                }
            }
            return make_pair(ans-1, u);
        };

        auto fn = [&](vector<vector<int>>& edges) {
            int n = 1 + edges.size();
            vector<vector<int>> graph(n);
            for (auto& e : edges) {
                int u = e[0], v = e[1];
                graph[u].push_back(v);
                graph[v].push_back(u);
            }
            auto [_, u] = bfs(0, graph);
            auto [d, v] = bfs(u, graph);
            return d;
        };

        int d1 = fn(edges1), d2 = fn(edges2);
        return max({d1, d2, (d1+1)/2 + (d2+1)/2 + 1});
    }


    /*3206. Alternating Groups I (Easy)
    There is a circle of red and blue tiles. You are given an array of integers
    colors. The color of tile i is represented by colors[i]:
    * colors[i] == 0 means that tile i is red.
    * colors[i] == 1 means that tile i is blue.
    Every 3 contiguous tiles in the circle with alternating colors (the middle
    tile has a different color from its left and right tiles) is called an
    alternating group. Return the number of alternating groups. Note that since
    colors represents a circle, the first and the last tiles are considered to
    be next to each other.

    Example 1:
    Input: colors = [1,1,1]
    Output: 0
    Explanation:

    Example 2:
    Input: colors = [0,1,0,0,1]
    Output: 3
    Explanation:
    Alternating groups:

    Constraints:
    * 3 <= colors.length <= 100
    * 0 <= colors[i] <= 1*/

    int numberOfAlternatingGroups(vector<int>& colors) {
        int ans = 0;
        for (int i = 0, cnt = 0, n = colors.size(); i < n+2; ++i) {
            if (i && colors[(i-1)%n] == colors[i%n]) cnt = 0;
            if (++cnt >= 3) ++ans;
        }
        return ans;
    }


    /*3207. Maximum Points After Enemy Battles (Medium)
    You are given an integer array enemyEnergies denoting the energy values of
    various enemies. You are also given an integer currentEnergy denoting the
    amount of energy you have initially. You start with 0 points, and all the
    enemies are unmarked initially. You can perform either of the following
    operations zero or multiple times to gain points:
    * Choose an unmarked enemy, i, such that currentEnergy >= enemyEnergies[i].
      By choosing this option:
      + You gain 1 point.
      + Your energy is reduced by the enemy's energy, i.e. currentEnergy =
        currentEnergy - enemyEnergies[i].
    * If you have at least 1 point, you can choose an unmarked enemy, i. By
      choosing this option:
      + Your energy increases by the enemy's energy, i.e. currentEnergy =
        currentEnergy + enemyEnergies[i].
      + The enemy i is marked.
    Return an integer denoting the maximum points you can get in the end by
    optimally performing operations.

    Example 1:
    Input: enemyEnergies = [3,2,2], currentEnergy = 2
    Output: 3
    Explanation: The following operations can be performed to get 3 points,
                 which is the maximum:
                 - First operation on enemy 1: points increases by 1, and
                   currentEnergy decreases by 2. So, points = 1, and
                   currentEnergy = 0.
                 - Second operation on enemy 0: currentEnergy increases by 3,
                   and enemy 0 is marked. So, points = 1, currentEnergy = 3, and
                   marked enemies = [0].
                 - First operation on enemy 2: points increases by 1, and
                   currentEnergy decreases by 2. So, points = 2,
                   currentEnergy = 1, and marked enemies = [0].
                 - Second operation on enemy 2: currentEnergy increases by 2,
                   and enemy 2 is marked. So, points = 2, currentEnergy = 3, and
                   marked enemies = [0, 2].
                 - First operation on enemy 1: points increases by 1, and
                   currentEnergy decreases by 2. So, points = 3,
                   currentEnergy = 1, and marked enemies = [0, 2].

    Example 2:
    Input: enemyEnergies = [2], currentEnergy = 10
    Output: 5
    Explanation: Performing the first operation 5 times on enemy 0 results in
                 the maximum number of points.

    Constraints:
    * 1 <= enemyEnergies.length <= 10^5
    * 1 <= enemyEnergies[i] <= 10^9
    * 0 <= currentEnergy <= 10^9*/

    long long maximumPoints(vector<int>& enemyEnergies, int currentEnergy) {
        int m = *min_element(enemyEnergies.begin(), enemyEnergies.end());
        if (currentEnergy < m) return 0;
        return (currentEnergy + accumulate(enemyEnergies.begin(), enemyEnergies.end(), 0ll) - m)/m;
    }


    /*3208. Alternating Groups II (Medium）
    There is a circle of red and blue tiles. You are given an array of integers
    colors and an integer k. The color of tile i is represented by colors[i]:
    * colors[i] == 0 means that tile i is red.
    * colors[i] == 1 means that tile i is blue.
    An alternating group is every k contiguous tiles in the circle with
    alternating colors (each tile in the group except the first and last one has
    a different color from its left and right tiles). Return the number of
    alternating groups. Note that since colors represents a circle, the first
    and the last tiles are considered to be next to each other.

    Example 1:
    Input: colors = [0,1,0,1,0], k = 3
    Output: 3
    Explanation:
    Alternating groups:

    Example 2:
    Input: colors = [0,1,0,0,1,0,1], k = 6
    Output: 2
    Explanation:
    Alternating groups:

    Example 3:
    Input: colors = [1,1,0,1], k = 4
    Output: 0
    Explanation:

    Constraints:
    * 3 <= colors.length <= 10^5
    * 0 <= colors[i] <= 1
    * 3 <= k <= colors.length*/

    int numberOfAlternatingGroups(vector<int>& colors, int k) {
        int ans = 0;
        for (int i = 0, cnt = 0, n = colors.size(); i < n+k-1; ++i) {
            if (i && colors[(i-1)%n] == colors[i%n]) cnt = 0;
            if (++cnt >= k) ++ans;
        }
        return ans;
    }


    /*3209. Number of Subarrays With AND Value of K (Hard)
    Given an array of integers nums and an integer k, return the number of
    subarrays of nums where the bitwise AND of the elements of the subarray
    equals k.

    Example 1:
    Input: nums = [1,1,1], k = 1
    Output: 6
    Explanation: All subarrays contain only 1's.

    Example 2:
    Input: nums = [1,1,2], k = 1
    Output: 3
    Explanation: Subarrays having an AND value of 1 are: [1,1,2], [1,1,2], [1,1,2].

    Example 3:
    Input: nums = [1,2,3], k = 2
    Output: 2
    Explanation: Subarrays having an AND value of 2 are: [1,2,3], [1,2,3].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i], k <= 10^9*/

    long long countSubarrays(vector<int>& nums, int k) {
        long long ans = 0;
        unordered_map<int, int> freq;
        for (auto& x : nums) {
            unordered_map<int, int> temp;
            if ((k & x) == k) {
                ++freq[x];
                for (auto& [key, val] : freq)
                    temp[key & x] += val;
                ans += temp[k];
            }
            freq = temp;
        }
        return ans;
    }


    /*3216. Lexicographically Smallest String After a Swap (Easy)
    Given a string s containing only digits, return the lexicographically
    smallest string that can be obtained after swapping adjacent digits in s
    with the same parity at most once. Digits have the same parity if both are
    odd or both are even. For example, 5 and 9, as well as 2 and 4, have the
    same parity, while 6 and 9 do not.

    Example 1:
    Input: s = "45320"
    Output: "43520"
    Explanation: s[1] == '5' and s[2] == '3' both have the same parity, and
                 swapping them results in the lexicographically smallest string.

    Example 2:
    Input: s = "001"
    Output: "001"
    Explanation: There is no need to perform a swap because s is already the
                 lexicographically smallest.

    Constraints:
    * 2 <= s.length <= 100
    * s consists only of digits.*/

    string getSmallestString(string s) {
        for (int i = 0; i < s.size()-1; ++i) {
            int v = s[i]-'0', n = s[i+1]-'0';
            if ((v-n)%2 == 0 && v > n) {
                swap(s[i], s[i+1]);
                break;
            }
        }
        return s;
    }


    /*3217. Delete Nodes From Linked List Present in Array (Medium)
    You are given an array of integers nums and the head of a linked list.
    Return the head of the modified linked list after removing all nodes from
    the linked list that have a value that exists in nums.

    Example 1:
    Input: nums = [1,2,3], head = [1,2,3,4,5]
    Output: [4,5]
    Explanation: Remove the nodes with values 1, 2, and 3.

    Example 2:
    Input: nums = [1], head = [1,2,1,2,1,2]
    Output: [2,2,2]
    Explanation: Remove the nodes with value 1.

    Example 3:
    Input: nums = [5], head = [1,2,3,4]
    Output: [1,2,3,4]
    Explanation: No node has value 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * All elements in nums are unique.
    * The number of nodes in the given list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5
    * The input is generated such that there is at least one node in the linked
      list that has a value not present in nums.*/

    ListNode* modifiedList(vector<int>& nums, ListNode* head) {
        unordered_set<int> seen(nums.begin(), nums.end());
        ListNode dummy(0, head);
        for (auto *node = &dummy; node->next; )
            if (seen.contains(node->next->val))
                node->next = node->next->next;
            else
                node = node->next;
        return dummy.next;
    }


    /*3218. Minimum Cost for Cutting Cake I (Medium)
    There is an m x n cake that needs to be cut into 1 x 1 pieces. You are given
    integers m, n, and two arrays:
    * horizontalCut of size m - 1, where horizontalCut[i] represents the cost to
      cut along the horizontal line i.
    * verticalCut of size n - 1, where verticalCut[j] represents the cost to cut
      along the vertical line j.
    In one operation, you can choose any piece of cake that is not yet a 1 x 1
    square and perform one of the following cuts:
    * Cut along a horizontal line i at a cost of horizontalCut[i].
    * Cut along a vertical line j at a cost of verticalCut[j].
    After the cut, the piece of cake is divided into two distinct pieces. The
    cost of a cut depends only on the initial cost of the line and does not
    change. Return the minimum total cost to cut the entire cake into 1 x 1
    pieces.

    Example 1:
    Input: m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]
    Output: 13
    Explanation: Perform a cut on the vertical line 0 with cost 5, current total
                 cost is 5.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 The total cost is 5 + 1 + 1 + 3 + 3 = 13.

    Example 2:
    Input: m = 2, n = 2, horizontalCut = [7], verticalCut = [4]
    Output: 15
    Explanation: Perform a cut on the horizontal line 0 with cost 7.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 The total cost is 7 + 4 + 4 = 15.

    Constraints:
    * 1 <= m, n <= 20
    * horizontalCut.length == m - 1
    * verticalCut.length == n - 1
    * 1 <= horizontalCut[i], verticalCut[i] <= 10^3*/

    int minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {
        int ans = 0;
        sort(horizontalCut.begin(), horizontalCut.end());
        sort(verticalCut.begin(), verticalCut.end());
        int hh = accumulate(horizontalCut.begin(), horizontalCut.end(), 0);
        int vv = accumulate(verticalCut.begin(), verticalCut.end(), 0);
        int h = horizontalCut.size()-1, v = verticalCut.size()-1;
        while (h >= 0 || v >= 0)
            if (h < 0 || v >= 0 && verticalCut[v] > horizontalCut[h]) {
                ans += verticalCut[v] + hh;
                vv -= verticalCut[v--];
            } else {
                ans += horizontalCut[h] + vv;
                hh -= horizontalCut[h--];
            }
        return ans;
    }


    /*3219. Minimum Cost for Cutting Cake II (Hard)
    There is an m x n cake that needs to be cut into 1 x 1 pieces. You are given
    integers m, n, and two arrays:
    * horizontalCut of size m - 1, where horizontalCut[i] represents the cost to
      cut along the horizontal line i.
    * verticalCut of size n - 1, where verticalCut[j] represents the cost to cut
      along the vertical line j.
    In one operation, you can choose any piece of cake that is not yet a 1 x 1
    square and perform one of the following cuts:
    * Cut along a horizontal line i at a cost of horizontalCut[i].
    * Cut along a vertical line j at a cost of verticalCut[j].
    After the cut, the piece of cake is divided into two distinct pieces. The
    cost of a cut depends only on the initial cost of the line and does not
    change. Return the minimum total cost to cut the entire cake into 1 x 1
    pieces.

    Example 1:
    Input: m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]
    Output: 13
    Explanation: Perform a cut on the vertical line 0 with cost 5, current total
                 cost is 5.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 The total cost is 5 + 1 + 1 + 3 + 3 = 13.

    Example 2:
    Input: m = 2, n = 2, horizontalCut = [7], verticalCut = [4]
    Output: 15
    Explanation: Perform a cut on the horizontal line 0 with cost 7.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 The total cost is 7 + 4 + 4 = 15.

    Constraints:
    * 1 <= m, n <= 10^5
    * horizontalCut.length == m - 1
    * verticalCut.length == n - 1
    * 1 <= horizontalCut[i], verticalCut[i] <= 10^3*/

    long long minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {
        long long ans = 0;
        sort(horizontalCut.begin(), horizontalCut.end());
        sort(verticalCut.begin(), verticalCut.end());
        long long hh = accumulate(horizontalCut.begin(), horizontalCut.end(), 0ll);
        long long vv = accumulate(verticalCut.begin(), verticalCut.end(), 0ll);
        int h = horizontalCut.size()-1, v = verticalCut.size()-1;
        while (h >= 0 || v >= 0)
            if (h < 0 || v >= 0 && verticalCut[v] > horizontalCut[h]) {
                ans += verticalCut[v] + hh;
                vv -= verticalCut[v--];
            } else {
                ans += horizontalCut[h] + vv;
                hh -= horizontalCut[h--];
            }
        return ans;
    }


    /*3222. Find the Winning Player in Coin Game (Easy)
    You are given two positive integers x and y, denoting the number of coins
    with values 75 and 10 respectively. Alice and Bob are playing a game. Each
    turn, starting with Alice, the player must pick up coins with a total value
    115. If the player is unable to do so, they lose the game. Return the name
    of the player who wins the game if both players play optimally.

    Example 1:
    Input: x = 2, y = 7
    Output: "Alice"
    Explanation: The game ends in a single turn:
                 - Alice picks 1 coin with a value of 75 and 4 coins with a value
                   of 10.

    Example 2:
    Input: x = 4, y = 11
    Output: "Bob"
    Explanation: The game ends in 2 turns:
                 - Alice picks 1 coin with a value of 75 and 4 coins with a
                   value of 10.
                 - Bob picks 1 coin with a value of 75 and 4 coins with a value
                   of 10.

    Constraints: 1 <= x, y <= 100*/

    string losingPlayer(int x, int y) {
        return min(x, y/4) & 1 ? "Alice" : "Bob";
    }


    /*3223. Minimum Length of String After Operations (Medium)
    You are given a string s. You can perform the following process on s any
    number of times:
    * Choose an index i in the string such that there is at least one character
      to the left of index i that is equal to s[i], and at least one character
      to the right that is also equal to s[i].
    * Delete the closest character to the left of index i that is equal to s[i].
    * Delete the closest character to the right of index i that is equal to s[i].
    Return the minimum length of the final string s that you can achieve.

    Example 1:
    Input: s = "abaacbcbb"
    Output: 5
    Explanation: We do the following operations:
                 - Choose index 2, then remove the characters at indices 0 and
                   3. The resulting string is s = "bacbcbb".
                 - Choose index 3, then remove the characters at indices 0 and
                   5. The resulting string is s = "acbcb".

    Example 2:
    Input: s = "aa"
    Output: 2
    Explanation: We cannot perform any operations, so we return the length of
                 the original string.

    Constraints:
    * 1 <= s.length <= 2 * 10^5
    * s consists only of lowercase English letters.*/

    int minimumLength(string s) {
        unordered_map<char, int> freq;
        for (auto& ch : s)
            ++freq[ch];
        return accumulate(freq.begin(), freq.end(), 0, [&](int s, auto x) { return s + 2 - x.second%2; });
    }


    /*3224. Minimum Array Changes to Make Differences Equal (Medium)
    You are given an integer array nums of size n where n is even, and an
    integer k. You can perform some changes on the array, where in one change
    you can replace any element in the array with any integer in the range from
    0 to k. You need to perform some changes (possibly none) such that the final
    array satisfies the following condition:
    * There exists an integer X such that abs(a[i] - a[n - i - 1]) = X for all
      (0 <= i < n).
    Return the minimum number of changes required to satisfy the above
    condition.

    Example 1:
    Input: nums = [1,0,1,2,4,3], k = 4
    Output: 2
    Explanation: We can perform the following changes:
                 - Replace nums[1] by 2. The resulting array is
                   nums = [1,2,1,2,4,3].
                 - Replace nums[3] by 3. The resulting array is
                   nums = [1,2,1,3,4,3].
                 The integer X will be 2.

    Example 2:
    Input: nums = [0,1,2,3,3,6,5,4], k = 6
    Output: 2
    Explanation: We can perform the following operations:
                 - Replace nums[3] by 0. The resulting array is
                   nums = [0,1,2,0,3,6,5,4].
                 - Replace nums[4] by 4. The resulting array is
                   nums = [0,1,2,0,4,6,5,4].
                 The integer X will be 4.

    Constraints:
    * 2 <= n == nums.length <= 10^5
    * n is even.
    * 0 <= nums[i] <= k <= 10^5*/

    int minChanges(vector<int>& nums, int k) {
        vector<int> line(k+2);
        int n = nums.size();
        for (int i = 0; i < n/2; ++i) {
            if (nums[i] > nums[n-1-i])
                swap(nums[i], nums[n-1-i]);
            int diff = nums[n-1-i] - nums[i];
            --line[diff];
            ++line[diff+1];
            diff += max(nums[i], k - nums[n-1-i]);
            ++line[diff+1];
        }
        int ans = n/2;
        for (int x = 0, prefix = n/2; x <= k; ++x) {
            prefix += line[x];
            ans = min(ans, prefix);
        }
        return ans;
    }


    /*3225. Maximum Score From Grid Operations (Hard)
    You are given a 2D matrix grid of size n x n. Initially, all cells of the
    grid are colored white. In one operation, you can select any cell of indices
    (i, j), and color black all the cells of the jth column starting from the
    top row down to the ith row. The grid score is the sum of all grid[i][j]
    such that cell (i, j) is white and it has a horizontally adjacent black
    cell. Return the maximum score that can be achieved after some number of
    operations.

    Example 1:
    Input: grid = [[0,0,0,0,0],[0,0,3,0,0],[0,1,0,0,0],[5,0,0,3,0],[0,0,0,0,2]]
    Output: 11
    Explanation: In the first operation, we color all cells in column 1 down to
                 row 3, and in the second operation, we color all cells in
                 column 4 down to the last row. The score of the resulting grid
                 is grid[3][0] + grid[1][2] + grid[3][3] which is equal to 11.

    Example 2:
    Input: grid = [[10,9,0,0,15],[7,1,0,8,0],[5,20,0,11,0],[0,0,0,1,2],[8,12,1,10,3]]
    Output: 94
    Explanation: We perform operations on 1, 2, and 3 down to rows 1, 4, and 0,
                 respectively. The score of the resulting grid is
                 grid[0][0] + grid[1][0] + grid[2][1] + grid[4][1] + grid[1][3]
                 + grid[2][3] + grid[3][3] + grid[4][3] + grid[0][4] which is
                 equal to 94.

    Constraints:
    * 1 <= n == grid.length <= 100
    * n == grid[i].length
    * 0 <= grid[i][j] <= 10^9*/

    long long maximumScore(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<long long>> prefix(n+1, vector<long long>(n)), excl(n+1, vector<long long>(n)), incl(n+1, vector<long long>(n));
        for (int j = 0; j < n ; ++j) {
            for (int i = 0; i < n; ++i)
                prefix[i+1][j] = prefix[i][j] + grid[i][j];
            if (j) {
                for (int p = 0; p <= n; ++p)
                    for (int c = 0; c <= n; ++c) {
                        long long pv = 0, cv = 0;
                        if (c > p) pv = prefix[c][j-1] - prefix[p][j-1];
                        else cv = prefix[p][j] - prefix[c][j];
                        excl[c][j] = max({excl[c][j], pv + excl[p][j-1], incl[p][j-1]});
                        incl[c][j] = max({incl[c][j], cv + incl[p][j-1], pv + cv + excl[p][j-1]});
                    }
            }
        }
        long long ans = 0;
        for (int i = 0; i <= n; ++i)
            ans = max(ans, incl[i][n-1]);
        return ans;
    }


    /*3226. Number of Bit Changes to Make Two Integers Equal (Easy)
    You are given two positive integers n and k. You can choose any bit in the
    binary representation of n that is equal to 1 and change it to 0. Return the
    number of changes needed to make n equal to k. If it is impossible, return
    -1.

    Example 1:
    Input: n = 13, k = 4
    Output: 2
    Explanation: Initially, the binary representations of n and k are
                 n = (1101)2 and k = (0100)2. We can change the first and fourth
                 bits of n. The resulting integer is n = (0100)2 = k.

    Example 2:
    Input: n = 21, k = 21
    Output: 0
    Explanation: n and k are already equal, so no changes are needed.

    Example 3:
    Input: n = 14, k = 13
    Output: -1
    Explanation: It is not possible to make n equal to k.

    Constraints: 1 <= n, k <= 10^6*/

    int minChanges(int n, int k) {
        return (n & k) == k ? __builtin_popcount(n ^ k) : -1;
    };


    /*3227. Vowels Game in a String (Medium)
    Alice and Bob are playing a game on a string. You are given a string s,
    Alice and Bob will take turns playing the following game where Alice starts
    first:
    * On Alice's turn, she has to remove any non-empty substring from s that
      contains an odd number of vowels.
    * On Bob's turn, he has to remove any non-empty substring from s that
      contains an even number of vowels.
    The first player who cannot make a move on their turn loses the game. We
    assume that both Alice and Bob play optimally. Return true if Alice wins the
    game, and false otherwise. The English vowels are: a, e, i, o, and u.

    Example 1:
    Input: s = "leetcoder"
    Output: true
    Explanation: Alice can win the game as follows:
                 * Alice plays first, she can delete the underlined substring in
                   s = "leetcoder" which contains 3 vowels. The resulting string
                   is s = "der".
                 * Bob plays second, he can delete the underlined substring in
                   s = "der" which contains 0 vowels. The resulting string is
                   s = "er".
                 * Alice plays third, she can delete the whole string s = "er"
                   which contains 1 vowel.
                 * Bob plays fourth, since the string is empty, there is no
                 valid play for Bob. So Alice wins the game.

    Example 2:
    Input: s = "bbcd"
    Output: false
    Explanation: There is no valid play for Alice in her first turn, so Alice
                 loses the game.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters.*/

    bool doesAliceWin(string s) {
        for (auto& ch : string("aeiou"))
            if (s.find(ch) != string::npos)
                return true;
        return false;
    }


    /*3228. Maximum Number of Operations to Move Ones to the End (Medium)
    You are given a binary string s. You can perform the following operation on
    the string any number of times:
    * Choose any index i from the string where i + 1 < s.length such that
      s[i] == '1' and s[i + 1] == '0'.
    * Move the character s[i] to the right until it reaches the end of the
      string or another '1'. For example, for s = "010010", if we choose i = 1,
      the resulting string will be s = "000110".
    Return the maximum number of operations that you can perform.

    Example 1:
    Input: s = "1001101"
    Output: 4
    Explanation: We can perform the following operations:
                 Choose index i = 0. The resulting string is s = "0011101".
                 Choose index i = 4. The resulting string is s = "0011011".
                 Choose index i = 3. The resulting string is s = "0010111".
                 Choose index i = 2. The resulting string is s = "0001111".

    Example 2:
    Input: s = "00111"
    Output: 0

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'.*/

    int maxOperations(string s) {
        int ans = 0, cnt = 0;
        for (int n = s.size(), i = n-1; i >= 0; --i)
            if (s[i] == '0') {
                if (i+1 == n || s[i+1] == '1') ++cnt;
            } else ans += cnt;
        return ans;
    }


    /*3229. Minimum Operations to Make Array Equal to Target (Hard)
    You are given two positive integer arrays nums and target, of the same
    length. In a single operation, you can select any subarray of nums and
    increment or decrement each element within that subarray by 1. Return the
    minimum number of operations required to make nums equal to the array
    target.

    Example 1:
    Input: nums = [3,5,1,2], target = [4,6,2,4]
    Output: 2
    Explanation: We will perform the following operations to make nums equal to
                 target:
                - Increment nums[0..3] by 1, nums = [4,6,2,3].
                 - Increment nums[3..3] by 1, nums = [4,6,2,4].

    Example 2:
    Input: nums = [1,3,2], target = [2,1,4]
    Output: 5
    Explanation: We will perform the following operations to make nums equal to
                 target:
                 - Increment nums[0..0] by 1, nums = [2,3,2].
                 - Decrement nums[1..1] by 1, nums = [2,2,2].
                 - Decrement nums[1..1] by 1, nums = [2,1,2].
                 - Increment nums[2..2] by 1, nums = [2,1,3].
                 - Increment nums[2..2] by 1, nums = [2,1,4].

    Constraints:
    * 1 <= nums.length == target.length <= 10^5
    * 1 <= nums[i], target[i] <= 10^8*/

    long long minimumOperations(vector<int>& nums, vector<int>& target) {
        long long ans = 0;
        int prev = 0;
        for (int i = 0; i < nums.size(); ++i) {
            int diff = target[i] - nums[i];
            ans += max(0, diff - prev);
            prev = diff;
        }
        return ans + max(0, -prev);
    }


    /*3232. Find if Digit Game Can Be Won (Easy)
    You are given an array of positive integers nums. Alice and Bob are playing
    a game. In the game, Alice can choose either all single-digit numbers or all
    double-digit numbers from nums, and the rest of the numbers are given to
    Bob. Alice wins if the sum of her numbers is strictly greater than the sum
    of Bob's numbers. Return true if Alice can win this game, otherwise, return
    false.

    Example 1:
    Input: nums = [1,2,3,4,10]
    Output: false
    Explanation: Alice cannot win by choosing either single-digit or double-
                 digit numbers.

    Example 2:
    Input: nums = [1,2,3,4,5,14]
    Output: true
    Explanation: Alice can win by choosing single-digit numbers which have a sum
                 equal to 15.

    Example 3:
    Input: nums = [5,5,5,25]
    Output: true
    Explanation: Alice can win by choosing double-digit numbers which have a sum
                 equal to 25.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 99*/

    bool canAliceWin(vector<int>& nums) {
        int single = 0, total = 0;
        for (auto& x : nums) {
            if (x < 10) single += x;
            total += x;
        }
        return 2*single != total;
    }


    /*3233. Find the Count of Numbers Which Are Not Special (Medium)
    You are given 2 positive integers l and r. For any number x, all positive
    divisors of x except x are called the proper divisors of x. A number is
    called special if it has exactly 2 proper divisors. For example:
    * The number 4 is special because it has proper divisors 1 and 2.
    * The number 6 is not special because it has proper divisors 1, 2, and 3.
    Return the count of numbers in the range [l, r] that are not special.

    Example 1:
    Input: l = 5, r = 7
    Output: 3
    Explanation: There are no special numbers in the range [5, 7].

    Example 2:
    Input: l = 4, r = 16
    Output: 11
    Explanation: The special numbers in the range [4, 16] are 4 and 9.

    Constraints: 1 <= l <= r <= 10^9*/

    int nonSpecialCount(int l, int r) {
        int lo = ceil(sqrt(l)), hi = floor(sqrt(r));
        vector<int> sieve(hi+1, 1);
        sieve[0] = sieve[1] = 0;
        for (int x = 2; x <= hi; ++x)
            if (sieve[x])
                for (int xx = x*x; xx <= hi; xx += x)
                    sieve[xx] = 0;
        return r-l+1 - accumulate(sieve.begin()+lo, sieve.end(), 0);
    }


    /*3234. Count the Number of Substrings With Dominant Ones (Medium)
    You are given a binary string s. Return the number of substrings with
    dominant ones. A string has dominant ones if the number of ones in the
    string is greater than or equal to the square of the number of zeros in the
    string.

    Example 1:
    Input: s = "00011"
    Output: 5
    Explanation: The substrings with dominant ones are shown in the table below.
                 i   j   s[i..j] Number of Zeros Number of Ones
                 3   3   1   0   1
                 4   4   1   0   1
                 2   3   01  1   1
                 3   4   11  0   2
                 2   4   011 1   2

    Example 2:
    Input: s = "101101"
    Output: 16
    Explanation: The substrings with non-dominant ones are shown in the table
                 below. Since there are 21 substrings total and 5 of them have
                 non-dominant ones, it follows that there are 16 substrings with
                 dominant ones.
                 i   j   s[i..j] Number of Zeros Number of Ones
                 1   1   0   1   0
                 4   4   0   1   0
                 1   4   0110    2   2
                 0   4   10110   2   3
                 1   5   01101   2   3

    Constraints:
    * 1 <= s.length <= 4 * 10^4
    * s consists only of characters '0' and '1'.*/

    int numberOfSubstrings(string s) {
        int ans = 0;
        for (int n = s.size(), z = 0; z*z <= n; ++z) {
            int j = 0, zeroj = 0, k = 0, zerok = 0, onek = 0;
            for (int i = 0; i < n; ++i) {
                if (s[i] == '0') ++zeroj, ++zerok;
                else ++onek;
                for (; zeroj > z; ++j)
                    if (s[j] == '0') --zeroj;
                for (; zerok > z || k <= i && zerok == z && onek >= pow(zerok, 2); ++k)
                    if (s[k] == '0') --zerok;
                    else --onek;
                ans += k - j;
            }
        }
        return ans;
    }


    /*3235. Check if the Rectangle Corner Is Reachable (Hard)
    You are given two positive integers X and Y, and a 2D array circles, where
    circles[i] = [xi, yi, ri] denotes a circle with center at (xi, yi) and
    radius ri. There is a rectangle in the coordinate plane with its bottom left
    corner at the origin and top right corner at the coordinate (X, Y). You need
    to check whether there is a path from the bottom left corner to the top
    right corner such that the entire path lies inside the rectangle, does not
    touch or lie inside any circle, and touches the rectangle only at the two
    corners. Return true if such a path exists, and false otherwise.

    Example 1:
    Input: X = 3, Y = 4, circles = [[2,1,1]]
    Output: true
    Explanation: The black curve shows a possible path between (0, 0) and (3, 4).

    Example 2:
    Input: X = 3, Y = 3, circles = [[1,1,2]]
    Output: false
    Explanation: No path exists from (0, 0) to (3, 3).

    Example 3:
    Input: X = 3, Y = 3, circles = [[2,1,1],[1,2,1]]
    Output: false
    Explanation: No path exists from (0, 0) to (3, 3).

    Constraints:
    * 3 <= X, Y <= 10^9
    * 1 <= circles.length <= 1000
    * circles[i].length == 3
    * 1 <= xi, yi, ri <= 10^9*/

    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {
        vector<vector<int>> vals;
        for (auto& c : circles) {
            int x = c[0], y = c[1], r = c[2];
            if (pow(x, 2) + pow(y, 2) <= pow(r, 2)) return false;
            if (pow(X-x, 2) + pow(Y-y, 2) <= pow(r, 2)) return false;
            if (x >= X+r || y >= Y+r) continue;
            vals.push_back({x, y, r});
        }
        circles = vals;
        int n = circles.size();
        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);

        function<int(int)> find = [&](int p) {
            if (p != parent[p])
                parent[p] = find(parent[p]);
            return parent[p];
        };

        for (int i = 0; i < n; ++i) {
            int xi = circles[i][0], yi = circles[i][1], ri = circles[i][2];
            for (int j = i+1; j < n; ++j) {
                int xj = circles[j][0], yj = circles[j][1], rj = circles[j][2];
                if (pow(xi-xj, 2) + pow(yi-yj, 2) <= pow(ri+rj, 2)) {
                    int ii = find(i), jj = find(j);
                    parent[ii] = jj;
                }
            }
        }

        unordered_map<int, vector<int>> group;
        for (int i = 0; i < n; ++i) {
            int ii = find(i);
            group[ii].push_back(i);
        }

        for (auto& [_, grp] : group) {
            bool inside = false;
            int imax = INT_MIN, jmax = INT_MIN, imin = INT_MAX, jmin = INT_MAX;
            for (auto& i : grp) {
                int x = circles[i][0], y = circles[i][1], r = circles[i][2];
                if (0 <= x && x <= X || 0 <= y && y <= Y) inside = true;
                imax = max(imax, x+r);
                jmax = max(jmax, y+r);
                imin = min(imin, x-r);
                jmin = min(jmin, y-r);
            }
            if (inside) {
                if (imin <= 0 && imax >= X) return false;
                if (jmin <= 0 && jmax >= Y) return false;
                if (imax >= X && jmax >= Y) return false;
                if (imin <= 0 && jmin <= 0) return false;
            }
        }
        return true;
    }


    /*3238. Find the Number of Winning Players (Easy)
    You are given an integer n representing the number of players in a game and
    a 2D array pick where pick[i] = [xi, yi] represents that the player xi
    picked a ball of color yi. Player i wins the game if they pick strictly more
    than i balls of the same color. In other words,
    * Player 0 wins if they pick any ball.
    * Player 1 wins if they pick at least two balls of the same color.
    * ...
    * Player i wins if they pick at leasti + 1 balls of the same color.
    Return the number of players who win the game. Note that multiple players
    can win the game.

    Example 1:
    Input: n = 4, pick = [[0,0],[1,0],[1,0],[2,1],[2,1],[2,0]]
    Output: 2
    Explanation: Player 0 and player 1 win the game, while players 2 and 3 do
    not win.

    Example 2:
    Input: n = 5, pick = [[1,1],[1,2],[1,3],[1,4]]
    Output: 0
    Explanation: No player wins the game.

    Example 3:
    Input: n = 5, pick = [[1,1],[2,4],[2,4],[2,4]]
    Output: 1
    Explanation: Player 2 wins the game by picking 3 balls with color 4.

    Constraints:
    * 2 <= n <= 10
    * 1 <= pick.length <= 100
    * pick[i].length == 2
    * 0 <= xi <= n - 1
    * 0 <= yi <= 10*/

    int winningPlayerCount(int n, vector<vector<int>>& pick) {
        vector<vector<int>> freq(n, vector<int>(11));
        for (auto& p : pick) {
            int x = p[0], y = p[1];
            ++freq[x][y];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i)
            if (any_of(freq[i].begin(), freq[i].end(), [&](auto& x) { return x >= i+1; })) ++ans;
        return ans;
    }


    /*3239. Minimum Number of Flips to Make Binary Grid Palindromic I (Medium)
    You are given an m x n binary matrix grid. A row or column is considered
    palindromic if its values read the same forward and backward. You can flip
    any number of cells in grid from 0 to 1, or from 1 to 0. Return the minimum
    number of cells that need to be flipped to make either all rows palindromic
    or all columns palindromic.

    Example 1:
    Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
    Output: 2
    Explanation: Flipping the highlighted cells makes all the rows palindromic.

    Example 2:
    Input: grid = [[0,1],[0,1],[0,0]]
    Output: 1
    Explanation: Flipping the highlighted cell makes all the columns palindromic.

    Example 3:
    Input: grid = [[1],[0]]
    Output: 0
    Explanation: All rows are already palindromic.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m * n <= 2 * 10^5
    * 0 <= grid[i][j] <= 1*/

    int minFlips(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int row = 0, col = 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                row += grid[i][j] ^ grid[m-1-i][j];
                col += grid[i][j] ^ grid[i][n-1-j];
            }
        return min(row, col)/2;
    }


    /*3240. Minimum Number of Flips to Make Binary Grid Palindromic II (Medium)
    You are given an m x n binary matrix grid. A row or column is considered
    palindromic if its values read the same forward and backward. You can flip
    any number of cells in grid from 0 to 1, or from 1 to 0. Return the minimum
    number of cells that need to be flipped to make all rows and columns
    palindromic, and the total number of 1's in grid divisible by 4.

    Example 1:
    Input: grid = [[1,0,0],[0,1,0],[0,0,1]]
    Output: 3
    Explanation:

    Example 2:
    Input: grid = [[0,1],[0,1],[0,0]]
    Output: 2
    Explanation:

    Example 3:
    Input: grid = [[1],[1]]
    Output: 2
    Explanation:

    * Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m * n <= 2 * 10^5
    * 0 <= grid[i][j] <= 1*/

    int minFlips(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int ans = 0, ones = 0;
        if (n & 1)
            for (int i = 0; i < m/2; ++i) {
                int total = grid[i][n/2] + grid[m-1-i][n/2];
                if (total == 2) ++ones;
                else if (total == 1) ++ans;
            }
        if (m & 1)
            for (int j = 0; j < n/2; ++j) {
                int total = grid[m/2][j] + grid[m/2][n-1-j];
                if (total == 2) ++ones;
                else if (total == 1) ++ans;
            }
        if (ones % 2 && ans == 0) ans += 2;
        if (m&1 && n&1 && grid[m/2][n/2]) ++ans;
        for (int i = 0; i < m/2; ++i)
            for (int j = 0; j < n/2; ++j) {
                int total = grid[i][j] + grid[i][n-1-j] + grid[m-1-i][j] + grid[m-1-i][n-1-j];
                ans += min(total, 4-total);
            }
        return ans;
    }


    /*3241. Time Taken to Mark All Nodes (Hard)
    There exists an undirected tree with n nodes numbered 0 to n - 1. You are
    given a 2D integer array edges of length n - 1, where edges[i] = [ui, vi]
    indicates that there is an edge between nodes ui and vi in the tree.
    Initially, all nodes are unmarked. For each node i:
    * If i is odd, the node will get marked at time x if there is at least one
      node adjacent to it which was marked at time x - 1.
    * If i is even, the node will get marked at time x if there is at least one
      node adjacent to it which was marked at time x - 2.
    Return an array times where times[i] is the time when all nodes get marked
    in the tree, if you mark node i at time t = 0. Note that the answer for each
    times[i] is independent, i.e. when you mark node i all other nodes are
    unmarked.

    Example 1:
    Input: edges = [[0,1],[0,2]]
    Output: [2,4,3]
    Explanation: For i = 0: Node 1 is marked at t = 1, and Node 2 at t = 2.
                 For i = 1: Node 0 is marked at t = 2, and Node 2 at t = 4.
                 For i = 2: Node 0 is marked at t = 2, and Node 1 at t = 3.

    Example 2:
    Input: edges = [[0,1]]
    Output: [1,2]
    Explanation: For i = 0: Node 1 is marked at t = 1.
                 For i = 1: Node 0 is marked at t = 2.

    Example 3:
    Input: edges = [[2,4],[0,1],[2,3],[0,2]]
    Output: [4,6,3,5,5]
    Explanation:

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * The input is generated such that edges represents a valid tree.*/

    vector<int> timeTaken(vector<vector<int>>& edges) {
        int n = 1 + edges.size();
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            tree[u].push_back(v);
            tree[v].push_back(u);
        }
        vector<vector<vector<int>>> vals(n, vector<vector<int>>(2, vector<int>{-1, 0}));

        function<int(int, int)> dfs = [&](int u, int p) {
            for (auto& v : tree[u])
                if (v != p) {
                    int cand = 2 - v%2 + dfs(v, u);
                    if (cand > vals[u][0][1]) {
                        vals[u][1] = vals[u][0];
                        vals[u][0] = {v, cand};
                    } else if (cand > vals[u][1][1])
                        vals[u][1] = {v, cand};
                }
            return vals[u][0][1];
        };

        dfs(0, -1);
        vector<int> ans(n);
        stack<tuple<int, int, int>> stk; stk.emplace(0, -1, 0);
        while (stk.size()) {
            auto [u, p, x] = stk.top(); stk.pop();
            if (x > vals[u][0][1]) {
                vals[u][1] = vals[u][0];
                vals[u][0] = {p, x};
            } else if (x > vals[u][1][1])
                vals[u][1] = {p, x};
            ans[u] = vals[u][0][1];
            for (auto& v : tree[u])
                if (v != p) {
                    int xx = vals[u][0][1];
                    if (v == vals[u][0][0]) xx = vals[u][1][1];
                    stk.emplace(v, u, xx + 2 - u%2);
                }
        }
        return ans;
    }


    /*3243. Shortest Distance After Road Addition Queries I (Medium)
    You are given an integer n and a 2D integer array queries. There are n
    cities numbered from 0 to n - 1. Initially, there is a unidirectional road
    from city i to city i + 1 for all 0 <= i < n - 1. queries[i] = [ui, vi]
    represents the addition of a new unidirectional road from city ui to city
    vi. After each query, you need to find the length of the shortest path from
    city 0 to city n - 1. Return an array answer where for each i in the range
    [0, queries.length - 1], answer[i] is the length of the shortest path from
    city 0 to city n - 1 after processing the first i + 1 queries.

    Example 1:
    Input: n = 5, queries = [[2,4],[0,2],[0,4]]
    Output: [3,2,1]
    Explanation: - After the addition of the road from 2 to 4, the length of the
                   shortest path from 0 to 4 is 3.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path from 0 to 4 is 2.
                 - After the addition of the road from 0 to 4, the length of the
                   shortest path from 0 to 4 is 1.

    Example 2:
    Input: n = 4, queries = [[0,3],[0,2]]
    Output: [1,1]
    Explanation: - After the addition of the road from 0 to 3, the length of the
                   shortest path from 0 to 3 is 1.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path remains 1.

    Constraints:
    * 3 <= n <= 500
    * 1 <= queries.length <= 500
    * queries[i].length == 2
    * 0 <= queries[i][0] < queries[i][1] < n
    * 1 < queries[i][1] - queries[i][0]
    * There are no repeated roads among the queries.*/

    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {
        vector<vector<int>> graph(n);
        for (int i = 0; i+1 < n; ++i)
            graph[i].push_back(i+1);

        auto bfs = [&](vector<vector<int>>& graph) {
            queue<int> q; q.push(0);
            vector<bool> seen(n); seen[0] = true;
            for (int ans = 0; q.size(); ++ans)
                for (int sz = q.size(); sz; --sz) {
                    int u = q.front(); q.pop();
                    if (u == n-1) return ans;
                    for (auto& v : graph[u])
                        if (!seen[v]) {
                            q.push(v);
                            seen[v] = true;
                        }
                }
            return -1;
        };

        vector<int> ans;
        for (auto& q : queries) {
            int u = q[0], v = q[1];
            graph[u].push_back(v);
            ans.push_back(bfs(graph));
        }
        return ans;
    }


    /*3244. Shortest Distance After Road Addition Queries II (Hard)
    You are given an integer n and a 2D integer array queries. There are n
    cities numbered from 0 to n - 1. Initially, there is a unidirectional road
    from city i to city i + 1 for all 0 <= i < n - 1. queries[i] = [ui, vi]
    represents the addition of a new unidirectional road from city ui to city
    vi. After each query, you need to find the length of the shortest path from
    city 0 to city n - 1. There are no two queries such that
    queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]. Return an
    array answer where for each i in the range [0, queries.length - 1],
    answer[i] is the length of the shortest path from city 0 to city n - 1 after
    processing the first i + 1 queries.

    Example 1:
    Input: n = 5, queries = [[2,4],[0,2],[0,4]]
    Output: [3,2,1]
    Explanation: - After the addition of the road from 2 to 4, the length of the
                   shortest path from 0 to 4 is 3.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path from 0 to 4 is 2.
                 - After the addition of the road from 0 to 4, the length of the
                   shortest path from 0 to 4 is 1.

    Example 2:
    Input: n = 4, queries = [[0,3],[0,2]]
    Output: [1,1]
    Explanation: - After the addition of the road from 0 to 3, the length of the
                   shortest path from 0 to 3 is 1.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path remains 1.

    Constraints:
    * 3 <= n <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= queries[i][0] < queries[i][1] < n
    * 1 < queries[i][1] - queries[i][0]
    * There are no repeated roads among the queries.
    * There are no two queries such that i != j and queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1].*/

    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {
        vector<int> ans, jump(--n);
        iota(jump.begin(), jump.end(), 1);
        for (auto& q : queries) {
            int u = q[0], v = q[1];
            for (; jump[u] < v; --n)
                tie(jump[u], u) = make_tuple(v, jump[u]);
            ans.push_back(n);
        }
        return ans;
    }


    /*3245. Alternating Groups III (Hard)
    There are some red and blue tiles arranged circularly. You are given an
    array of integers colors and a 2D integers array queries. The color of tile
    i is represented by colors[i]:
    * colors[i] == 0 means that tile i is red.
    * colors[i] == 1 means that tile i is blue.
    An alternating group is a contiguous subset of tiles in the circle with
    alternating colors (each tile in the group except the first and last one has
    a different color from its adjacent tiles in the group). You have to process
    queries of two types:
    * queries[i] = [1, sizei], determine the count of alternating groups with
      size sizei.
    * queries[i] = [2, indexi, colori], change colors[indexi] to colori.
    Return an array answer containing the results of the queries of the first
    type in order. Note that since colors represents a circle, the first and the
    last tiles are considered to be next to each other.

    Example 1:
    Input: colors = [0,1,1,0,1], queries = [[2,1,0],[1,4]]
    Output: [2]
    Explanation: First query:
                 Change colors[1] to 0.
                 Second query:
                 Count of the alternating groups with size 4:

    Example 2:
    Input: colors = [0,0,1,0,1,1], queries = [[1,3],[2,3,0],[1,5]]
    Output: [2,0]
    Explanation: First query:
                 Count of the alternating groups with size 3:
                 Second query: colors will not change.
                 Third query: There is no alternating group with size 5.

    Constraints:
    * 4 <= colors.length <= 5 * 10^4
    * 0 <= colors[i] <= 1
    * 1 <= queries.length <= 5 * 10^4
    * queries[i][0] == 1 or queries[i][0] == 2
    * For all i that:
    * queries[i][0] == 1: queries[i].length == 2, 3 <= queries[i][1] <= colors.length - 1
    * queries[i][0] == 2: queries[i].length == 3, 0 <= queries[i][1] <= colors.length - 1, 0 <= queries[i][2] <= 1

    class Fenwick {
        vector<int> cnts, vals;
    public:
        Fenwick(int n) {
            cnts.resize(n+1);
            vals.resize(n+1);
        }

        void add(int k, int v) {
            for (int i = k+1; i < cnts.size(); i += i & -i) {
                cnts[i] += v;
                vals[i] += v*k;
            }
        }

        int query(int k, int v) {
            int ans = 0;
            for (int i = k+1; i; i -= i & -i)
                ans += vals[i] - v*cnts[i];
            return ans;
        }
    }; */

    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {
        int n = colors.size();
        map<int, int> groups;
        for (int i = 0, j = 0; i < n; i = j+1) {
            for (j = i; j < i+n-1 && colors[j%n] != colors[(j+1)%n]; ++j);
            groups[j%n] = i;
        }
        Fenwick *fen = new Fenwick(n+1);

        auto dist = [&](int lo, int hi) {
            return lo <= hi ? hi-lo+1 : n+hi-lo+1;
        };

        auto add = [&](int lo, int hi) {
            groups[hi] = lo;
            fen->add(dist(lo, hi), 1);
        };

        auto remove = [&](int i) {
            auto p = groups.lower_bound(i);
            if (p == groups.end())
                p = groups.begin();
            auto [hi, lo] = *p;
            groups.erase(p);
            fen->add(dist(lo, hi), -1);
            return make_pair(lo, hi);
        };

        for (auto& [hi, lo] : groups) add(lo, hi);
        vector<int> ans;
        for (auto& q : queries) {
            if (q[0] == 1) {
                if (groups.size() == 1 && colors[groups.begin()->first] != colors[groups.begin()->second]) ans.push_back(n);
                else {
                    int sz = q[1];
                    ans.push_back(fen->query(n, sz-1) - fen->query(sz-1, sz-1));
                }
            } else {
                int i = q[1], c = q[2];
                if (colors[i] != c) {
                    colors[i] = c;
                    auto [lo, hi] = remove(i);
                    if (lo == hi) {
                        if (colors[(i-1+n)%n] != colors[i]) lo = remove((i-1+n)%n).first;
                        if (colors[i] != colors[(i+1)%n] && groups.size()) hi = remove((i+1)%n).second;
                        add(lo, hi);
                    } else if (lo == i) {
                        add((i+1)%n, hi);
                        if (colors[(i-1+n)%n] != colors[i]) lo = remove((i-1+n)%n).first;
                        add(lo, i);
                    } else if (i == hi) {
                        add(lo, (i-1+n)%n);
                        if (colors[i] != colors[(i+1)%n]) hi = remove((i+1)%n).second;
                        add(i, hi);
                    } else {
                        int i0 = (i-1+n)%n, i1 = (i+1)%n;
                        if (dist(lo, hi) == n && colors[lo] != colors[hi]) add(i1, i0);
                        else {
                            add(lo, i0);
                            add(i1, hi);
                        }
                        add(i, i);
                    }
                }
            }
        }
        return ans;
    }


    /*3248. Snake in Matrix (Easy)
    There is a snake in an n x n matrix grid and can move in four possible
    directions. Each cell in the grid is identified by the position:
    grid[i][j] = (i * n) + j. The snake starts at cell 0 and follows a sequence
    of commands. You are given an integer n representing the size of the grid
    and an array of strings commands where each command[i] is either "UP",
    "RIGHT", "DOWN", and "LEFT". It's guaranteed that the snake will remain
    within the grid boundaries throughout its movement. Return the position of
    the final cell where the snake ends up after executing commands.

    Example 1:
    Input: n = 2, commands = ["RIGHT","DOWN"]
    Output: 3
    Explanation: 0   1
                 2   3
                 0   1
                 2   3
                 0   1
                 2   3

    Example 2:
    Input: n = 3, commands = ["DOWN","RIGHT","UP"]
    Output: 1
    Explanation: 0   1   2
                 3   4   5
                 6   7   8
                 0   1   2
                 3   4   5
                 6   7   8
                 0   1   2
                 3   4   5
                 6   7   8
                 0   1   2
                 3   4   5
                 6   7   8

    Constraints:
    * 2 <= n <= 10
    * 1 <= commands.length <= 100
    * commands consists only of "UP", "RIGHT", "DOWN", and "LEFT".
    * The input is generated such the snake will not move outside of the
      boundaries.*/

    int finalPositionOfSnake(int n, vector<string>& commands) {
        int i = 0, j = 0;
        for (auto& c : commands)
            if (c == "UP") --i;
            else if (c == "RIGHT") ++j;
            else if (c == "DOWN") ++i;
            else --j;
        return i*n + j;
    }


    /*3249. Count the Number of Good Nodes (Medium)
    There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted
    at node 0. You are given a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. A node is good if all the subtrees rooted at its children have
    the same size. Return the number of good nodes in the given tree. A subtree
    of treeName is a tree consisting of a node in treeName and all of its
    descendants.

    Example 1:
    Input: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
    Output: 7
    Explanation: All of the nodes of the given tree are good.

    Example 2:
    Input: edges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]]
    Output: 6
    Explanation: There are 6 good nodes in the given tree. They are colored in
                 the image above.

    Example 3:
    Input: edges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]]
    Output: 12
    Explanation: All nodes except node 9 are good.

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * The input is generated such that edges represents a valid tree.*/

    int countGoodNodes(vector<vector<int>>& edges) {
        int n = 1 + edges.size();
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            tree[u].push_back(v);
            tree[v].push_back(u);
        }
        int ans = 0;

        function<int(int, int)> fn = [&](int u, int p) {
            unordered_map<int, int> freq;
            for (auto& v : tree[u])
                if (v != p) ++freq[fn(v, u)];
            if (freq.size() <= 1) ++ans;
            return 1 + accumulate(freq.begin(), freq.end(), 0, [&](int s, auto& item) {
                return s + item.first * item.second;
            });
        };

        fn(0, -1);
        return ans;
    }


    /*3250. Find the Count of Monotonic Pairs I (Hard)
    You are given an array of positive integers nums of length n. We call a pair
    of non-negative integer arrays (arr1, arr2) monotonic if:
    * The lengths of both arrays are n.
    * arr1 is monotonically non-decreasing, in other words,
      arr1[0] <= arr1[1] <= ... <= arr1[n - 1].
    * arr2 is monotonically non-increasing, in other words,
      arr2[0] >= arr2[1] >= ... >= arr2[n - 1].
    * arr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.
    Return the count of monotonic pairs. Since the answer may be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,3,2]
    Output: 4
    Explanation: The good pairs are:
                 ([0, 1, 1], [2, 2, 1])
                 ([0, 1, 2], [2, 2, 0])
                 ([0, 2, 2], [2, 1, 0])
                 ([1, 2, 2], [1, 1, 0])

    Example 2:
    Input: nums = [5,5,5,5]
    Output: 126

    Constraints:
    * 1 <= n == nums.length <= 2000
    * 1 <= nums[i] <= 50*/

    int countOfPairs(vector<int>& nums) {
        int n = nums.size();
        vector<vector<long>> dp(n+1, vector<long>(51));
        fill_n(dp[n].begin(), 51, 1);
        for (int i = n-1; i >= 0; --i) {
            int diff = 0;
            if (i) diff = max(0, nums[i] - nums[i-1]);
            for (int j = 50; j >= 0; --j) {
                if (j+1 <= 50) dp[i][j] = dp[i][j+1];
                if (j+diff <= nums[i])
                    dp[i][j] = (dp[i][j] + dp[i+1][j+diff]) % 1'000'000'007;
            }
        }
        return dp[0][0];
    }


    /*3251. Find the Count of Monotonic Pairs II (Hard)
    You are given an array of positive integers nums of length n. We call a pair
    of non-negative integer arrays (arr1, arr2) monotonic if:
    * The lengths of both arrays are n.
    * arr1 is monotonically non-decreasing, in other words,
      arr1[0] <= arr1[1] <= ... <= arr1[n - 1].
    * arr2 is monotonically non-increasing, in other words,
      arr2[0] >= arr2[1] >= ... >= arr2[n - 1].
    * arr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.
    Return the count of monotonic pairs. Since the answer may be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,3,2]
    Output: 4
    Explanation: The good pairs are:
                 ([0, 1, 1], [2, 2, 1])
                 ([0, 1, 2], [2, 2, 0])
                 ([0, 2, 2], [2, 1, 0])
                 ([1, 2, 2], [1, 1, 0])

    Example 2:
    Input: nums = [5,5,5,5]
    Output: 126

    Constraints:
    * 1 <= n == nums.length <= 2000
    * 1 <= nums[i] <= 1000*/

    int countOfPairs(vector<int>& nums) {
        int n = nums.size();
        vector<vector<long>> dp(n+1, vector<long>(1001));
        fill_n(dp[n].begin(), 1001, 1);
        for (int i = n-1; i >= 0; --i) {
            int diff = 0;
            if (i) diff = max(0, nums[i] - nums[i-1]);
            for (int j = 1000; j >= 0; --j) {
                if (j+1 <= 1000) dp[i][j] = dp[i][j+1];
                if (j+diff <= nums[i])
                    dp[i][j] = (dp[i][j] + dp[i+1][j+diff]) % 1'000'000'007;
            }
        }
        return dp[0][0];
    }


    /*3254. Find the Power of K-Size Subarrays I (Medium)
    You are given an array of integers nums of length n and a positive integer
    k. The power of an array is defined as:
    * Its maximum element if all of its elements are consecutive and sorted in
      ascending order.
    * -1 otherwise.
    You need to find the power of all subarrays of nums of size k. Return an
    integer array results of size n - k + 1, where results[i] is the power of
    nums[i..(i + k - 1)].

    Example 1:
    Input: nums = [1,2,3,4,3,2,5], k = 3
    Output: [3,4,-1,-1,-1]
    Explanation: There are 5 subarrays of nums of size 3:
                 - [1, 2, 3] with the maximum element 3.
                 - [2, 3, 4] with the maximum element 4.
                 - [3, 4, 3] whose elements are not consecutive.
                 - [4, 3, 2] whose elements are not sorted.
                 - [3, 2, 5] whose elements are not consecutive.

    Example 2:
    Input: nums = [2,2,2,2,2], k = 4
    Output: [-1,-1]

    Example 3:
    Input: nums = [3,2,3,2,3,2], k = 2
    Output: [-1,3,-1,3,-1]

    Constraints:
    * 1 <= n == nums.length <= 500
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= n*/

    vector<int> resultsArray(vector<int>& nums, int k) {
        vector<int> ans;
        for (int i = 0, cnt = 0; i < nums.size(); ++i) {
            if (i && nums[i-1]+1 != nums[i]) cnt = 0;
            ++cnt;
            if (i >= k-1)
                if (cnt >= k) ans.push_back(nums[i]);
                else ans.push_back(-1);
        }
        return ans;
    }


    /*3255. Find the Power of K-Size Subarrays II (Medium)
    You are given an array of integers nums of length n and a positive integer
    k. The power of an array is defined as:
    * Its maximum element if all of its elements are consecutive and sorted in
      ascending order.
    * -1 otherwise.
    You need to find the power of all subarrays of nums of size k. Return an
    integer array results of size n - k + 1, where results[i] is the power of
    nums[i..(i + k - 1)].

    Example 1:
    Input: nums = [1,2,3,4,3,2,5], k = 3
    Output: [3,4,-1,-1,-1]
    Explanation: There are 5 subarrays of nums of size 3:
                 - [1, 2, 3] with the maximum element 3.
                 - [2, 3, 4] with the maximum element 4.
                 - [3, 4, 3] whose elements are not consecutive.
                 - [4, 3, 2] whose elements are not sorted.
                 - [3, 2, 5] whose elements are not consecutive.

    Example 2:
    Input: nums = [2,2,2,2,2], k = 4
    Output: [-1,-1]

    Example 3:
    Input: nums = [3,2,3,2,3,2], k = 2
    Output: [-1,3,-1,3,-1]

    Constraints:
    * 1 <= n == nums.length <= 10^5
    * 1 <= nums[i] <= 10^6
    * 1 <= k <= n*/

    vector<int> resultsArray(vector<int>& nums, int k) {
        vector<int> ans;
        for (int i = 0, cnt = 0; i < nums.size(); ++i) {
            if (i && nums[i-1]+1 != nums[i]) cnt = 0;
            ++cnt;
            if (i >= k-1)
                if (cnt >= k) ans.push_back(nums[i]);
                else ans.push_back(-1);
        }
        return ans;
    }


    /*3256. Maximum Value Sum by Placing Three Rooks I (Hard)
    You are given a m x n 2D array board representing a chessboard, where
    board[i][j] represents the value of the cell (i, j). Rooks in the same row
    or column attack each other. You need to place three rooks on the chessboard
    such that the rooks do not attack each other. Return the maximum sum of the
    cell values on which the rooks are placed.

    Example 1:
    Input: board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]
    Output: 4
    Explanation: We can place the rooks in the cells (0, 2), (1, 3), and (2, 1)
                 for a sum of 1 + 1 + 2 = 4.

    Example 2:
    Input: board = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 15
    Explanation: We can place the rooks in the cells (0, 0), (1, 1), and (2, 2)
                 for a sum of 1 + 5 + 9 = 15.

    Example 3:
    Input: board = [[1,1,1],[1,1,1],[1,1,1]]
    Output: 3
    Explanation: We can place the rooks in the cells (0, 2), (1, 1), and (2, 0)
                 for a sum of 1 + 1 + 1 = 3.

    Constraints:
    * 3 <= m == board.length <= 100
    * 3 <= n == board[i].length <= 100
    * -10^9 <= board[i][j] <= 10^9*/

    long long maximumValueSum(vector<vector<int>>& board) {
        int m = board.size(), n = board[0].size();
        vector<vector<pair<int, int>>> cols(n);
        for (int i = 0; i < m; ++i) {
            vector<pair<int, int>> aug;
            for (int j = 0; j < n; ++j)
                aug.emplace_back(board[i][j], j);
            nth_element(aug.begin(), aug.begin()+3, aug.end(), [&](auto& lhs, auto& rhs) { return lhs.first > rhs.first; });
            for (int k = 0; k < 3; ++k) {
                auto [x, j] = aug[k];
                cols[j].emplace_back(x, i);
            }
        }
        vector<tuple<int, int, int>> vals;
        for (int j = 0; j < n; ++j) {
            if (cols[j].size() > 3)
                nth_element(cols[j].begin(), cols[j].begin()+3, cols[j].end(), [&](auto& lhs, auto& rhs) { return lhs.first > rhs.first; });
            for (int k = 0; k < 3 && k < cols[j].size(); ++k) {
                auto [x, i] = cols[j][k];
                vals.emplace_back(x, i, j);
            }
        }
        nth_element(vals.begin(), vals.begin()+9, vals.end(), [&](auto& lhs, auto& rhs) { return get<0>(lhs) > get<0>(rhs); });
        long long ans = -1e10;
        for (int i = 0; i < 9; ++i) {
            auto [xi, ii, ji] = vals[i];
            for (int j = i+1; j < 9; ++j) {
                auto [xj, ij, jj] = vals[j];
                if (ii != ij && ji != jj) {
                    for (int k = j+1; k < 9; ++k) {
                        auto [xk, ik, jk] = vals[k];
                        if (ii != ik && ij != ik && ji != jk && jj != jk) {
                            ans = max(ans, (long long) xi + xj + xk);
                        }
                    }
                }
            }
        }
        return ans;

    }


    /*3257. Maximum Value Sum by Placing Three Rooks II (Hard)
    You are given a m x n 2D array board representing a chessboard, where
    board[i][j] represents the value of the cell (i, j). Rooks in the same row
    or column attack each other. You need to place three rooks on the chessboard
    such that the rooks do not attack each other. Return the maximum sum of the
    cell values on which the rooks are placed.

    Example 1:
    Input: board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]
    Output: 4
    Explanation: We can place the rooks in the cells (0, 2), (1, 3), and (2, 1)
                 for a sum of 1 + 1 + 2 = 4.

    Example 2:
    Input: board = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 15
    Explanation: We can place the rooks in the cells (0, 0), (1, 1), and (2, 2)
                 for a sum of 1 + 5 + 9 = 15.

    Example 3:
    Input: board = [[1,1,1],[1,1,1],[1,1,1]]
    Output: 3
    Explanation: We can place the rooks in the cells (0, 2), (1, 1), and (2, 0)
                 for a sum of 1 + 1 + 1 = 3.

    Constraints:
    * 3 <= m == board.length <= 500
    * 3 <= n == board[i].length <= 500
    * -10^9 <= board[i][j] <= 10^9*/

    long long maximumValueSum(vector<vector<int>>& board) {
        int m = board.size(), n = board[0].size();
        vector<vector<pair<int, int>>> cols(n);
        for (int i = 0; i < m; ++i) {
            vector<pair<int, int>> aug;
            for (int j = 0; j < n; ++j)
                aug.emplace_back(board[i][j], j);
            nth_element(aug.begin(), aug.begin()+3, aug.end(), [&](auto& lhs, auto& rhs) { return lhs.first > rhs.first; });
            for (int k = 0; k < 3; ++k) {
                auto [x, j] = aug[k];
                cols[j].emplace_back(x, i);
            }
        }
        vector<tuple<int, int, int>> vals;
        for (int j = 0; j < n; ++j) {
            if (cols[j].size() > 3)
                nth_element(cols[j].begin(), cols[j].begin()+3, cols[j].end(), [&](auto& lhs, auto& rhs) { return lhs.first > rhs.first; });
            for (int k = 0; k < 3 && k < cols[j].size(); ++k) {
                auto [x, i] = cols[j][k];
                vals.emplace_back(x, i, j);
            }
        }
        nth_element(vals.begin(), vals.begin()+9, vals.end(), [&](auto& lhs, auto& rhs) { return get<0>(lhs) > get<0>(rhs); });
        long long ans = -1e10;
        for (int i = 0; i < 9; ++i) {
            auto [xi, ii, ji] = vals[i];
            for (int j = i+1; j < 9; ++j) {
                auto [xj, ij, jj] = vals[j];
                if (ii != ij && ji != jj) {
                    for (int k = j+1; k < 9; ++k) {
                        auto [xk, ik, jk] = vals[k];
                        if (ii != ik && ij != ik && ji != jk && jj != jk) {
                            ans = max(ans, (long long) xi + xj + xk);
                        }
                    }
                }
            }
        }
        return ans;

    }


    /*3258. Count Substrings That Satisfy K-Constraint I (Easy)
    You are given a binary string s and an integer k. A binary string satisfies
    the k-constraint if either of the following conditions holds:
    * The number of 0's in the string is at most k.
    * The number of 1's in the string is at most k.
    Return an integer denoting the number of substrings of s that satisfy the k-
    constraint.

    Example 1:
    Input: s = "10101", k = 1
    Output: 12
    Explanation: Every substring of s except the substrings "1010", "10101", and
                 "0101" satisfies the k-constraint.

    Example 2:
    Input: s = "1010101", k = 2
    Output: 25
    Explanation: Every substring of s except the substrings with a length
                 greater than 5 satisfies the k-constraint.

    Example 3:
    Input: s = "11111", k = 1
    Output: 15
    Explanation: All substrings of s satisfy the k-constraint.

    Constraints:
    * 1 <= s.length <= 50
    * 1 <= k <= s.length
    * s[i] is either '0' or '1'.*/

    int countKConstraintSubstrings(string s, int k) {
        int ans = 0;
        for (int i = 0, ii = 0, one = 0, zero = 0; i < s.size(); ++i) {
            if (s[i] == '1') ++one;
            else ++zero;
            for (; one > k && zero > k; ++ii) {
                if (s[ii] == '1') --one;
                else --zero;
            }
            ans += i-ii+1;
        }
        return ans;
    }


    /*3259. Maximum Energy Boost From Two Drinks (Medium)
    You are given two integer arrays energyDrinkA and energyDrinkB of the same
    length n by a futuristic sports scientist. These arrays represent the energy
    boosts per hour provided by two different energy drinks, A and B,
    respectively. You want to maximize your total energy boost by drinking one
    energy drink per hour. However, if you want to switch from consuming one
    energy drink to the other, you need to wait for one hour to cleanse your
    system (meaning you won't get any energy boost in that hour). Return the
    maximum total energy boost you can gain in the next n hours. Note that you
    can start consuming either of the two energy drinks.

    Example 1:
    Input: energyDrinkA = [1,3,1], energyDrinkB = [3,1,1]
    Output: 5
    Explanation: To gain an energy boost of 5, drink only the energy drink A (or
                 only B).

    Example 2:
    Input: energyDrinkA = [4,1,1], energyDrinkB = [1,1,3]
    Output: 7
    Explanation: To gain an energy boost of 7:
                 Drink the energy drink A for the first hour. Switch to the
                 energy drink B and we lose the energy boost of the second hour.
                 Gain the energy boost of the drink B in the third hour.

    Constraints:
    * n == energyDrinkA.length == energyDrinkB.length
    * 3 <= n <= 10^5
    * 1 <= energyDrinkA[i], energyDrinkB[i] <= 10^5*/

    long long maxEnergyBoost(vector<int>& energyDrinkA, vector<int>& energyDrinkB) {
        vector<long long> dp(2);
        for (int i = 0; i < energyDrinkA.size(); ++i) {
            long long temp = max(dp[0] + energyDrinkA[i], dp[1]);
            dp[1] = max(dp[0], dp[1] + energyDrinkB[i]);
            dp[0] = temp;
        }
        return max(dp[0], dp[1]);
    }


    /*3260. Find the Largest Palindrome Divisible by K (Hard)
    You are given two positive integers n and k. An integer x is called k-
    palindromic if:
    * x is a palindrome.
    * x is divisible by k.
    Return the largest integer having n digits (as a string) that is k-
    palindromic. Note that the integer must not have leading zeros.

    Example 1:
    Input: n = 3, k = 5
    Output: "595"
    Explanation: 595 is the largest k-palindromic integer with 3 digits.

    Example 2:
    Input: n = 1, k = 4
    Output: "8"
    Explanation: 4 and 8 are the only k-palindromic integers with 1 digit.

    Example 3:
    Input: n = 5, k = 6
    Output: "89898"

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= k <= 9*/

    string largestPalindrome(int n, int k) {
        vector<int> pw(n, 1);
        for (int i = 1; i < n; ++i)
            pw[i] = pw[i-1]*10 % k;
        vector<vector<bool>> dp((n+1)/2, vector<bool>(k));
        dp[(n-1)/2][0] = true;
        for (int i = (n-1)/2; i > 0; --i) {
            int coef = pw[i];
            if (i != n-1-i) coef += pw[n-1-i];
            for (int j = 0; j < k; ++j)
                if (dp[i][j])
                    for (int d = 0; d < 10; ++d) {
                        int jj = (j + coef*d) % k;
                        dp[i-1][jj] = true;
                    }
        }
        string ans = string(n, '9');
        int total = 0;
        for (int i = 0; i <= (n-1)/2; ++i) {
            int coef = pw[i];
            if (i != n-1-i) coef += pw[n-1-i];
            for (int d = 9; d >= 0; --d) {
                int j = (total - coef*d) % k;
                if (j < 0) j += k;
                if (dp[i][j]) {
                    ans[i] = ans[n-1-i] = '0' + d;
                    total = j;
                    break;
                }
            }
        }
        return ans;
    }


    /*3261. Count Substrings That Satisfy K-Constraint II (Hard)
    You are given a binary string s and an integer k. You are also given a 2D
    integer array queries, where queries[i] = [li, ri]. A binary string
    satisfies the k-constraint if either of the following conditions holds:
    * The number of 0's in the string is at most k.
    * The number of 1's in the string is at most k.
    Return an integer array answer, where answer[i] is the number of substrings
    of s[li..ri] that satisfy the k-constraint.

    Example 1:
    Input: s = "0001111", k = 2, queries = [[0,6]]
    Output: [26]
    Explanation: For the query [0, 6], all substrings of s[0..6] = "0001111"
                 satisfy the k-constraint except for the substrings
                 s[0..5] = "000111" and s[0..6] = "0001111".

    Example 2:
    Input: s = "010101", k = 1, queries = [[0,5],[1,4],[2,3]]
    Output: [15,9,3]
    Explanation: The substrings of s with a length greater than 3 do not satisfy
                 the k-constraint.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'.
    * 1 <= k <= s.length
    * 1 <= queries.length <= 10^5
    * queries[i] == [li, ri]
    * 0 <= li <= ri < s.length
    * All queries are distinct.*/

    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {
        int n = s.size();
        vector<long long> prefix(n+1);
        vector<int> jump(n);
        for (int i = 0, ii = 0, one = 0; i < n; ++i) {
            if (s[i] == '1') ++one;
            for (; one > k && i-ii-one+1 > k; ++ii)
                if (s[ii] == '1') --one;
            prefix[i+1] = prefix[i] + (i-ii+1);
            jump[ii] = i;
        }
        if (jump[0] == 0) jump[0] = n;
        for (int i = 1; i < n; ++i)
            if (jump[i] == 0) jump[i] = jump[i-1];
        vector<long long> ans;
        for (auto& q : queries) {
            int lo = q[0], hi = q[1], mid = min(jump[lo], hi);
            long c = mid-lo+1, cand = c*(c+1)/2;
            if (mid < hi) cand += prefix[hi+1] - prefix[mid+1];
            ans.push_back(cand);
        }
        return ans;
    }


    /*3264. Final Array State After K Multiplication Operations I (Easy)
    You are given an integer array nums, an integer k, and an integer
    multiplier. You need to perform k operations on nums. In each operation:
    * Find the minimum value x in nums. If there are multiple occurrences of the
      minimum value, select the one that appears first.
    * Replace the selected minimum value x with x * multiplier.
    Return an integer array denoting the final state of nums after performing
    all k operations.

    Example 1:
    Input: nums = [2,1,3,5,6], k = 5, multiplier = 2
    Output: [8,4,6,5,6]
    Explanation: Operation           Result
                 After operation 1   [2, 2, 3, 5, 6]
                 After operation 2   [4, 2, 3, 5, 6]
                 After operation 3   [4, 4, 3, 5, 6]
                 After operation 4   [4, 4, 6, 5, 6]
                 After operation 5   [8, 4, 6, 5, 6]

    Example 2:
    Input: nums = [1,2], k = 3, multiplier = 4
    Output: [16,8]
    Explanation: Operation           Result
                 After operation 1   [4, 2]
                 After operation 2   [4, 8]
                 After operation 3   [16, 8]

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= k <= 10
    * 1 <= multiplier <= 5*/

    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {
        while (k--) {
            auto it = min_element(nums.begin(), nums.end());
            *it *= multiplier;
        }
        return nums;
    }


    /*3265. Count Almost Equal Pairs I (Medium)
    You are given an array nums consisting of positive integers. We call two
    integers x and y in this problem almost equal if both integers can become
    equal after performing the following operation at most once:
    * Choose either x or y and swap any two digits within the chosen number.
    Return the number of indices i and j in nums where i < j such that nums[i]
    and nums[j] are almost equal. Note that it is allowed for an integer to have
    leading zeros after performing an operation.

    Example 1:
    Input: nums = [3,12,30,17,21]
    Output: 2
    Explanation: The almost equal pairs of elements are:
                 - 3 and 30. By swapping 3 and 0 in 30, you get 3.
                 - 12 and 21. By swapping 1 and 2 in 12, you get 21.

    Example 2:
    Input: nums = [1,1,1,1,1]
    Output: 10
    Explanation: Every two elements in the array are almost equal.

    Example 3:
    Input: nums = [123,231]
    Output: 0
    Explanation: We cannot swap any two digits of 123 or 231 to reach the other.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 10^6*/

    int countPairs(vector<int>& nums) {
        unordered_map<int, int> freq;
        int ans = 0;
        for (auto& x : nums) {
            ans += freq[x]++;
            string s = to_string(x);
            s = string(6-s.size(), '0') + s;
            for (int i = 0; i < 6; ++i)
                for (int j = i+1; j < 6; ++j)
                    if (s[i] != s[j]) {
                        swap(s[i], s[j]);
                        ans += freq[stoi(s)];
                        swap(s[i], s[j]);
                    }
        }
        return ans;
    }


    /*3266. Final Array State After K Multiplication Operations II (Hard)
    You are given an integer array nums, an integer k, and an integer
    multiplier. You need to perform k operations on nums. In each operation:
    * Find the minimum value x in nums. If there are multiple occurrences of the
      minimum value, select the one that appears first.
    * Replace the selected minimum value x with x * multiplier.
    After the k operations, apply modulo 109 + 7 to every value in nums. Return
    an integer array denoting the final state of nums after performing all k
    operations and then applying the modulo.

    Example 1:
    Input: nums = [2,1,3,5,6], k = 5, multiplier = 2
    Output: [8,4,6,5,6]
    Explanation: Operation           Result
                 After operation 1   [2, 2, 3, 5, 6]
                 After operation 2   [4, 2, 3, 5, 6]
                 After operation 3   [4, 4, 3, 5, 6]
                 After operation 4   [4, 4, 6, 5, 6]
                 After operation 5   [8, 4, 6, 5, 6]
                 After applying modulo   [8, 4, 6, 5, 6]

    Example 2:
    Input: nums = [100000,2000], k = 2, multiplier = 1000000
    Output: [999999307,999999993]
    Explanation: Operation               Result
                 After operation 1       [100000, 2000000000]
                 After operation 2       [100000000000, 2000000000]
                 After applying modulo   [999999307, 999999993]

    Constraints:
    * 1 <= nums.length <= 10^4
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9
    * 1 <= multiplier <= 10^6*/

    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {
        if (multiplier == 1) return nums;
        int m = *max_element(nums.begin(), nums.end()), n = nums.size();
        int mod = 1'000'000'007;
        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<>> pq;
        for (int i = 0; i < n; ++i)
            pq.emplace(nums[i], i);
        for (; k && pq.top().first*multiplier <= m; --k) {
            auto [x, i] = pq.top(); pq.pop();
            pq.emplace(x*multiplier, i);
        }
        vector<pair<long, int>> vals;
        while (pq.size()) {
            auto [x, i] = pq.top(); pq.pop();
            vals.emplace_back(x, i);
        }
        long q = 1, mul = multiplier;
        for (int p = k/n; p; p >>= 1) {
            if (p & 1) q = q * mul % mod;
            mul = mul * mul % mod;
        }
        for (int i = 0; i < n; ++i)
            vals[i].first = vals[i].first * q % mod;
        for (int i = 0; i < k % n; ++i)
            vals[i].first = vals[i].first * multiplier % mod;
        vector<int> ans(n);
        for (auto& [x, i] : vals)
            ans[i] = x;
        return ans;
    }


    /*3267. Count Almost Equal Pairs II (Hard)
    Attention: In this version, the number of operations that can be performed,
    has been increased to twice. You are given an array nums consisting of
    positive integers. We call two integers x and y almost equal if both
    integers can become equal after performing the following operation at most
    twice:
    * Choose either x or y and swap any two digits within the chosen number.
    Return the number of indices i and j in nums where i < j such that nums[i]
    and nums[j] are almost equal. Note that it is allowed for an integer to have
    leading zeros after performing an operation.

    Example 1:
    Input: nums = [1023,2310,2130,213]
    Output: 4
    Explanation: The almost equal pairs of elements are:
                 - 1023 and 2310. By swapping the digits 1 and 2, and then the
                   digits 0 and 3 in 1023, you get 2310.
                 - 1023 and 213. By swapping the digits 1 and 0, and then the
                   digits 1 and 2 in 1023, you get 0213, which is 213.
                 - 2310 and 213. By swapping the digits 2 and 0, and then the
                   digits 3 and 2 in 2310, you get 0213, which is 213.
                 - 2310 and 2130. By swapping the digits 3 and 1 in 2310, you
                   get 2130.

    Example 2:
    Input: nums = [1,10,100]
    Output: 3
    Explanation: The almost equal pairs of elements are:
                 - 1 and 10. By swapping the digits 1 and 0 in 10, you get 01
                   which is 1.
                 - 1 and 100. By swapping the second 0 with the digit 1 in 100,
                   you get 001, which is 1.
                 - 10 and 100. By swapping the first 0 with the digit 1 in 100,
                   you get 010, which is 10.

    Constraints:
    * 2 <= nums.length <= 5000
    * 1 <= nums[i] < 10^7*/

    int countPairs(vector<int>& nums) {
        int ans = 0;
        unordered_map<int, int> freq;
        for (auto& x : nums) ++freq[x];
        for (auto& [x, v] : freq) {
            ans += v*(v-1);
            string s = to_string(x);
            s = string(7-s.size(), '0') + s;
            unordered_set<int> neighbor;
            for (int i = 0; i < 7; ++i)
                for (int j = i+1; j < 7; ++j)
                    if (s[i] != s[j]) {
                        swap(s[i], s[j]);
                        neighbor.insert(stoi(s));
                        for (int k = 0; k < 7; ++k)
                            for (int l = k+1; l < 7; ++l)
                                if (s[k] != s[l] && (k != i || l != j)) {
                                    swap(s[k], s[l]);
                                    neighbor.insert(stoi(s));
                                    swap(s[k], s[l]);
                                }
                        swap(s[i], s[j]);
                    }
            for (auto& y : neighbor)
                if (x != y && freq.contains(y)) ans += freq[x] * freq[y];
        }
        return ans/2;
    }


    /*3270. Find the Key of the Numbers (Easy)
    You are given three positive integers num1, num2, and num3. The key of num1,
    num2, and num3 is defined as a four-digit number such that:
    * Initially, if any number has less than four digits, it is padded with
      leading zeros.
    * The ith digit (1 <= i <= 4) of the key is generated by taking the smallest
      digit among the ith digits of num1, num2, and num3.
    Return the key of the three numbers without leading zeros (if any).

    Example 1:
    Input: num1 = 1, num2 = 10, num3 = 1000
    Output: 0
    Explanation: On padding, num1 becomes "0001", num2 becomes "0010", and num3
                 remains "1000".
                 - The 1st digit of the key is min(0, 0, 1).
                 - The 2nd digit of the key is min(0, 0, 0).
                 - The 3rd digit of the key is min(0, 1, 0).
                 - The 4th digit of the key is min(1, 0, 0).
                 Hence, the key is "0000", i.e. 0.

    Example 2:
    Input: num1 = 987, num2 = 879, num3 = 798
    Output: 777

    Example 3:
    Input: num1 = 1, num2 = 2, num3 = 3
    Output: 1

    Constraints: 1 <= num1, num2, num3 <= 9999*/

    int generateKey(int num1, int num2, int num3) {
        string s1 = to_string(num1), s2 = to_string(num2), s3 = to_string(num3);
        s1 = string(4-s1.size(), '0') + s1;
        s2 = string(4-s2.size(), '0') + s2;
        s3 = string(4-s3.size(), '0') + s3;
        int ans = 0;
        for (int j = 0; j < 4; ++j) {
            char d = min({s1[j], s2[j], s3[j]});
            ans = 10*ans + (d - '0');
        }
        return ans;
    }


    /*3271. Hash Divided String (Medium)
    You are given a string s of length n and an integer k, where n is a multiple
    of k. Your task is to hash the string s into a new string called result,
    which has a length of n / k. First, divide s into n / k substrings, each
    with a length of k. Then, initialize result as an empty string. For each
    substring in order from the beginning:
    * The hash value of a character is the index of that character in the
      English alphabet (e.g., 'a' → 0, 'b' → 1, ..., 'z' → 25).
    * Calculate the sum of all the hash values of the characters in the
      substring.
    * Find the remainder of this sum when divided by 26, which is called
      hashedChar.
    * Identify the character in the English lowercase alphabet that corresponds
      to hashedChar.
    * Append that character to the end of result.
    Return result.

    Example 1:
    Input: s = "abcd", k = 2
    Output: "bf"
    Explanation: First substring: "ab", 0 + 1 = 1, 1 % 26 = 1, result[0] = 'b'.
                 Second substring: "cd", 2 + 3 = 5, 5 % 26 = 5, result[1] = 'f'.

    Example 2:
    Input: s = "mxz", k = 3
    Output: "i"
    Explanation: The only substring: "mxz", 12 + 23 + 25 = 60, 60 % 26 = 8,
                 result[0] = 'i'.

    Constraints:
    * 1 <= k <= 100
    * k <= s.length <= 1000
    * s.length is divisible by k.
    * s consists only of lowercase English letters.*/

    string stringHash(string s, int k) {
        string ans;
        for (int i = 0, prefix = 0; i < s.size(); ++i) {
            prefix += s[i] - 'a';
            if ((i+1)%k == 0) {
                ans.push_back('a' + prefix%26);
                prefix = 0;
            }
        }
        return ans;
    }


    /*3272. Find the Count of Good Integers (Hard)
    You are given two positive integers n and k. An integer x is called k-
    palindromic if:
    * x is a palindrome.
    * x is divisible by k.
    An integer is called good if its digits can be rearranged to form a k-
    palindromic integer. For example, for k = 2, 2020 can be rearranged to form
    the k-palindromic integer 2002, whereas 1010 cannot be rearranged to form a
    k-palindromic integer. Return the count of good integers containing n digits.
    Note that any integer must not have leading zeros, neither before nor after
    rearrangement. For example, 1010 cannot be rearranged to form 101.

    Example 1:
    Input: n = 3, k = 5
    Output: 27
    Explanation: Some of the good integers are:
                 - 551 because it can be rearranged to form 515.
                 - 525 because it is already k-palindromic.

    Example 2:
    Input: n = 1, k = 4
    Output: 2
    Explanation: The two good integers are 4 and 8.

    Example 3:
    Input: n = 5, k = 6
    Output: 2468

    Constraints:
    * 1 <= n <= 10
    * 1 <= k <= 9*/

    long long countGoodIntegers(int n, int k) {
        long long ans = 0;
        unordered_set<long> seen;

        auto multinom = [&](vector<int>& vals) {
            long long ans = 1, k = 1;
            for (auto& v : vals)
                for (int x = 1; x <= v; ++x, ++k) {
                    ans *= k;
                    ans /= x;
                }
            return ans;
        };

        for (int half = (n+1)/2, v = pow(10, half-1); v < pow(10, half); ++v) {
            long rev = 0, base = 1;
            for (int x = n%2 ? v/10 : v; x; rev = 10*rev + x%10, x /= 10, base *= 10);
            long cand = v*base + rev;
            if (cand % k == 0) {
                vector<int> freq(10);
                for (; cand; cand /= 10) ++freq[cand % 10];
                long key = accumulate(freq.begin(), freq.end(), 0, [&](long s, int x) { return s = 11*s+x; });
                if (!seen.contains(key)) {
                    seen.insert(key);
                    long long val = multinom(freq);
                    if (freq[0]) {
                        --freq[0];
                        val -= multinom(freq);
                    }
                    ans += val;
                }

            }
        }
        return ans;
    }


    /*3273. Minimum Amount of Damage Dealt to Bob (Hard)
    You are given an integer power and two integer arrays damage and health,
    both having length n. Bob has n enemies, where enemy i will deal Bob
    damage[i] points of damage per second while they are alive (i.e.
    health[i] > 0). Every second, after the enemies deal damage to Bob, he
    chooses one of the enemies that is still alive and deals power points of
    damage to them. Determine the minimum total amount of damage points that
    will be dealt to Bob before all n enemies are dead.

    Example 1:
    Input: power = 4, damage = [1,2,3,4], health = [4,5,6,8]
    Output: 39
    Explanation: - Attack enemy 3 in the first two seconds, after which enemy 3
                   will go down, the number of damage points dealt to Bob is
                   10 + 10 = 20 points.
                 - Attack enemy 2 in the next two seconds, after which enemy 2
                   will go down, the number of damage points dealt to Bob is
                   6 + 6 = 12 points.
                 - Attack enemy 0 in the next second, after which enemy 0 will
                   go down, the number of damage points dealt to Bob is 3 points.
                 - Attack enemy 1 in the next two seconds, after which enemy 1
                   will go down, the number of damage points dealt to Bob is
                   2 + 2 = 4 points.

    Example 2:
    Input: power = 1, damage = [1,1,1,1], health = [1,2,3,4]
    Output: 20
    Explanation: - Attack enemy 0 in the first second, after which enemy 0 will
                   go down, the number of damage points dealt to Bob is 4 points.
                 - Attack enemy 1 in the next two seconds, after which enemy 1
                   will go down, the number of damage points dealt to Bob is
                   3 + 3 = 6 points.
                 - Attack enemy 2 in the next three seconds, after which enemy 2
                   will go down, the number of damage points dealt to Bob is
                   2 + 2 + 2 = 6 points.
                 - Attack enemy 3 in the next four seconds, after which enemy 3
                   will go down, the number of damage points dealt to Bob is
                   1 + 1 + 1 + 1 = 4 points.

    Example 3:
    Input: power = 8, damage = [40], health = [59]
    Output: 320

    Constraints:
    * 1 <= power <= 10^4
    * 1 <= n == damage.length == health.length <= 10^5
    * 1 <= damage[i], health[i] <= 10^4*/

    long long minDamage(int power, vector<int>& damage, vector<int>& health) {
        int n = damage.size();
        vector<pair<int, int>> aug;
        for (int i = 0; i < n; ++i)
            aug.emplace_back(damage[i], (health[i]+power-1)/power);
        sort(aug.begin(),aug.end(), [&](auto& lhs, auto& rhs) {
            return lhs.first*rhs.second > lhs.second*rhs.first;
        });
        long long ans = 0, prefix = 0;
        for (auto& [d, h] : aug) {
            prefix += h;
            ans += d*prefix;
        }
        return ans;
    }


    /*3274. Check if Two Chessboard Squares Have the Same Color (Easy)
    You are given two strings, coordinate1 and coordinate2, representing the
    coordinates of a square on an 8 x 8 chessboard. Below is the chessboard for
    reference. Return true if these two squares have the same color and false
    otherwise. The coordinate will always represent a valid chessboard square.
    The coordinate will always have the letter first (indicating its column),
    and the number second (indicating its row).

    Example 1:
    Input: coordinate1 = "a1", coordinate2 = "c3"
    Output: true
    Explanation: Both squares are black.

    Example 2:
    Input: coordinate1 = "a1", coordinate2 = "h3"
    Output: false
    Explanation: Square "a1" is black and "h3" is white.

    Constraints:
    * coordinate1.length == coordinate2.length == 2
    * 'a' <= coordinate1[0], coordinate2[0] <= 'h'
    * '1' <= coordinate1[1], coordinate2[1] <= '8'*/

    bool checkTwoChessboards(string coordinate1, string coordinate2) {
        return (coordinate1[0] + coordinate1[1]) % 2 == (coordinate2[0] + coordinate2[1]) % 2;
    }


    /*3275. K-th Nearest Obstacle Queries (Medium)
    There is an infinite 2D plane. You are given a positive integer k. You are
    also given a 2D array queries, which contains the following queries:
    * queries[i] = [x, y]: Build an obstacle at coordinate (x, y) in the plane.
      It is guaranteed that there is no obstacle at this coordinate when this
      query is made.
    After each query, you need to find the distance of the kth nearest obstacle
    from the origin. Return an integer array results where results[i] denotes
    the kth nearest obstacle after query i, or results[i] == -1 if there are
    less than k obstacles. Note that initially there are no obstacles anywhere.
    The distance of an obstacle at coordinate (x, y) from the origin is given by
    |x| + |y|.

    Example 1:
    Input: queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2
    Output: [-1,7,5,3]
    Explanation: Initially, there are 0 obstacles.
                 - After queries[0], there are less than 2 obstacles.
                 - After queries[1], there are obstacles at distances 3 and 7.
                 - After queries[2], there are obstacles at distances 3, 5, and
                   7.
                 - After queries[3], there are obstacles at distances 3, 3, 5,
                   and 7.

    Example 2:
    Input: queries = [[5,5],[4,4],[3,3]], k = 1
    Output: [10,8,6]
    Explanation: - After queries[0], there is an obstacle at distance 10.
                 - After queries[1], there are obstacles at distances 8 and 10.
                 - After queries[2], there are obstacles at distances 6, 8, and
                   10.

    Constraints:
    * 1 <= queries.length <= 2 * 10^5
    * All queries[i] are unique.
    * -10^9 <= queries[i][0], queries[i][1] <= 10^9
    * 1 <= k <= 10^5*/

    vector<int> resultsArray(vector<vector<int>>& queries, int k) {
        vector<int> ans;
        priority_queue<int> pq;
        for (auto& q : queries) {
            int x = q[0], y = q[1];
            pq.push(abs(x) + abs(y));
            while (pq.size() > k) pq.pop();
            ans.push_back(pq.size() == k ? pq.top() : -1);
        }
        return ans;
    }


    /*3276. Select Cells in Grid With Maximum Score (Hard)
    You are given a 2D matrix grid consisting of positive integers. You have to
    select one or more cells from the matrix such that the following conditions
    are satisfied:
    * No two selected cells are in the same row of the matrix.
    * The values in the set of selected cells are unique.
    Your score will be the sum of the values of the selected cells. Return the
    maximum score you can achieve.

    Example 1:
    Input: grid = [[1,2,3],[4,3,2],[1,1,1]]
    Output: 8
    Explanation: We can select the cells with values 1, 3, and 4 that are
                 colored above.

    Example 2:
    Input: grid = [[8,7,6],[8,3,2]]
    Output: 15
    Explanation: We can select the cells with values 7 and 8 that are colored
                 above.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 10
    * 1 <= grid[i][j] <= 100*/

    int maxScore(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<pair<int, int>> vals;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                vals.emplace_back(grid[i][j], i);
        sort(vals.begin(), vals.end());
        vector<vector<int>> dp(m*n+1, vector<int>(1<<m));
        for (int i = m*n-1; i >= 0; --i) {
            auto [v, k] = vals[i];
            for (int x = 0; x < (1<<m); ++x) {
                dp[i][x] = dp[i+1][x];
                if ((x & 1<<k) == 0) {
                    int ii = i+1;
                    while (ii < vals.size() && vals[ii].first == vals[i].first) ++ii;
                    dp[i][x] = max(dp[i][x], v + dp[ii][x ^ 1<<k]);
                }
            }
        }
        return dp[0][0];
    }


    /*3277. Maximum XOR Score Subarray Queries (Hard)
    You are given an array nums of n integers, and a 2D integer array queries of
    size q, where queries[i] = [li, ri]. For each query, you must find the
    maximum XOR score of any subarray of nums[li..ri]. The XOR score of an array
    a is found by repeatedly applying the following operations on a so that only
    one element remains, that is the score:
    * Simultaneously replace a[i] with a[i] XOR a[i + 1] for all indices i
      except the last one.
    * Remove the last element of a.
    Return an array answer of size q where answer[i] is the answer to query i.

    Example 1:
    Input: nums = [2,8,4,32,16,1], queries = [[0,2],[1,4],[0,5]]
    Output: [12,60,60]
    Explanation: - In the first query, nums[0..2] has 6 subarrays [2], [8], [4],
                   [2, 8], [8, 4], and [2, 8, 4] each with a respective XOR
                   score of 2, 8, 4, 10, 12, and 6. The answer for the query is
                   12, the largest of all XOR scores.
                 - In the second query, the subarray of nums[1..4] with the
                   largest XOR score is nums[1..4] with a score of 60.
                 - In the third query, the subarray of nums[0..5] with the
                   largest XOR score is nums[1..4] with a score of 60.

    Example 2:
    Input: nums = [0,7,3,2,8,5,1], queries = [[0,3],[1,5],[2,4],[2,6],[5,6]]
    Output: [7,14,11,14,5]
    Explanation: Index   nums[li..ri]    Maximum XOR Score Subarray  Maximum Subarray XOR Score
                     0   [0, 7, 3, 2]    [7]                         7
                     1   [7, 3, 2, 8, 5] [7, 3, 2, 8]                14
                     2   [3, 2, 8]       [3, 2, 8]                   11
                     3   [3, 2, 8, 5, 1] [2, 8, 5, 1]                14
                     4   [5, 1]          [5]                         5

    Constraints:
    * 1 <= n == nums.length <= 2000
    * 0 <= nums[i] <= 2^31 - 1
    * 1 <= q == queries.length <= 10^5
    * queries[i].length == 2
    * queries[i] = [li, ri]
    * 0 <= li <= ri <= n - 1*/

    vector<int> maximumSubarrayXor(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<vector<int>> dp(n+1, vector<int>(n));
        for (int l = n-1; l >= 0; --l) {
            dp[l][l] = nums[l];
            for (int r = l+1; r < n; ++r)
                dp[l][r] = dp[l][r-1] ^ dp[l+1][r];
        }
        for (int l = 0; l < n; ++l)
            for (int r = l+1; r < n; ++r)
                dp[l][r] = max(dp[l][r], dp[l][r-1]);
        for (int r = 0; r < n; ++r)
            for (int l = r-1; l >= 0; --l)
                dp[l][r] = max(dp[l][r], dp[l+1][r]);
        vector<int> ans;
        for (auto& q : queries) {
            int l = q[0], r = q[1];
            ans.push_back(dp[l][r]);
        }
        return ans;
    }


    /*3280. Convert Date to Binary (Easy)
    You are given a string date representing a Gregorian calendar date in the
    yyyy-mm-dd format. date can be written in its binary representation obtained
    by converting year, month, and day to their binary representations without
    any leading zeroes and writing them down in year-month-day format. Return
    the binary representation of date.

    Example 1:
    Input: date = "2080-02-29"
    Output: "100000100000-10-11101"
    Explanation: 100000100000, 10, and 11101 are the binary representations of
                 2080, 02, and 29 respectively.

    Example 2:
    Input: date = "1900-01-01"
    Output: "11101101100-1-1"
    Explanation: 11101101100, 1, and 1 are the binary representations of 1900,
                 1, and 1 respectively.

    Constraints:
    * date.length == 10
    * date[4] == date[7] == '-', and all other date[i]'s are digits.
    * The input is generated such that date represents a valid Gregorian
      calendar date between Jan 1st, 1900 and Dec 31st, 2100 (both inclusive).*/

    string convertDateToBinary(string date) {
        string year = bitset<16>(stoi(date.substr(0, 4))).to_string();
        string month = bitset<8>(stoi(date.substr(5, 2))).to_string();
        string day = bitset<8>(stoi(date.substr(8, 2))).to_string();
        return year.substr(year.find('1')) + "-" + month.substr(month.find('1')) + "-" + day.substr(day.find('1'));
    }


    /*3281. Maximize Score of Numbers in Ranges (Medium)
    You are given an array of integers start and an integer d, representing n
    intervals [start[i], start[i] + d]. You are asked to choose n integers where
    the ith integer must belong to the ith interval. The score of the chosen
    integers is defined as the minimum absolute difference between any two
    integers that have been chosen. Return the maximum possible score of the
    chosen integers.

    Example 1:
    Input: start = [6,0,3], d = 2
    Output: 4
    Explanation: The maximum possible score can be obtained by choosing
                 integers: 8, 0, and 4. The score of these chosen integers is
                 min(|8 - 0|, |8 - 4|, |0 - 4|) which equals 4.

    Example 2:
    Input: start = [2,6,13,13], d = 5
    Output: 5
    Explanation: The maximum possible score can be obtained by choosing
                 integers: 2, 7, 13, and 18. The score of these chosen integers
                 is min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|)
                 which equals 5.

    Constraints:
    * 2 <= start.length <= 10^5
    * 0 <= start[i] <= 10^9
    * 0 <= d <= 10^9*/

    int maxPossibleScore(vector<int>& start, int d) {
        sort(start.begin(), start.end());

        auto fn = [&](int mid) {
            long x = LONG_MIN;
            for (long s : start) {
                x += mid;
                if (x > s+d) return false;
                x = max(x, s);
            }
            return true;
        };

        int lo = 0, hi = 2'000'000'000;
        while (lo < hi) {
            int mid = lo + (hi-lo+1)/2;
            if (fn(mid)) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*3282. Reach End of Array With Max Score (Medium)
    You are given an integer array nums of length n. Your goal is to start at
    index 0 and reach index n - 1. You can only jump to indices greater than
    your current index. The score for a jump from index i to index j is
    calculated as (j - i) * nums[i]. Return the maximum possible total score by
    the time you reach the last index.

    Example 1:
    Input: nums = [1,3,1,5]
    Output: 7
    Explanation: First, jump to index 1 and then jump to the last index. The
                 final score is 1 * 1 + 2 * 3 = 7.

    Example 2:
    Input: nums = [4,3,1,3,2]
    Output: 16
    Explanation: Jump directly to the last index. The final score is 4 * 4 = 16.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    long long findMaximumScore(vector<int>& nums) {
        long long dp = 0;
        int prefix = 0;
        for (auto& x : nums) {
            dp += prefix;
            prefix = max(prefix, x);
        }
        return dp;
    }


    /*3283. Maximum Number of Moves to Kill All Pawns (Hard)
    There is a 50 x 50 chessboard with one knight and some pawns on it. You are
    given two integers kx and ky where (kx, ky) denotes the position of the
    knight, and a 2D array positions where positions[i] = [xi, yi] denotes the
    position of the pawns on the chessboard. Alice and Bob play a turn-based
    game, where Alice goes first. In each player's turn:
    * The player selects a pawn that still exists on the board and captures it
      with the knight in the fewest possible moves. Note that the player can
      select any pawn, it might not be one that can be captured in the least
      number of moves.
    * In the process of capturing the selected pawn, the knight may pass other
      pawns without capturing them. Only the selected pawn can be captured in
      this turn.
    Alice is trying to maximize the sum of the number of moves made by both
    players until there are no more pawns on the board, whereas Bob tries to
    minimize them. Return the maximum total number of moves made during the game
    that Alice can achieve, assuming both players play optimally. Note that in
    one move, a chess knight has eight possible positions it can move to, as
    illustrated below. Each move is two cells in a cardinal direction, then one
    cell in an orthogonal direction.

    Example 1:
    Input: kx = 1, ky = 1, positions = [[0,0]]
    Output: 4
    Explanation: The knight takes 4 moves to reach the pawn at (0, 0).

    Example 2:
    Input: kx = 0, ky = 2, positions = [[1,1],[2,2],[3,3]]
    Output: 8
    Explanation: - Alice picks the pawn at (2, 2) and captures it in two moves:
                   (0, 2) -> (1, 4) -> (2, 2).
                 - Bob picks the pawn at (3, 3) and captures it in two moves:
                   (2, 2) -> (4, 1) -> (3, 3).
                 - Alice picks the pawn at (1, 1) and captures it in four moves:
                   (3, 3) -> (4, 1) -> (2, 2) -> (0, 3) -> (1, 1).

    Example 3:
    Input: kx = 0, ky = 0, positions = [[1,2],[2,4]]
    Output: 3
    Explanation: - Alice picks the pawn at (2, 4) and captures it in two moves:
                   (0, 0) -> (1, 2) -> (2, 4). Note that the pawn at (1, 2) is
                   not captured.
                 - Bob picks the pawn at (1, 2) and captures it in one move:
                   (2, 4) -> (1, 2).

    Constraints:
    * 0 <= kx, ky <= 49
    * 1 <= positions.length <= 15
    * positions[i].length == 2
    * 0 <= positions[i][0], positions[i][1] <= 49
    * All positions[i] are unique.
    * The input is generated such that positions[i] != [kx, ky] for all
    0 <= i < positions.length.*/

    int maxMoves(int kx, int ky, vector<vector<int>>& positions) {
        int n = positions.size();
        vector<vector<int>> dist(n+1, vector<int>(n+1)), dir = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2},{1, 2}, {2, -1}, {2, 1}};
        positions.push_back({kx, ky});

        auto bfs = [&](int i, int j) {
            queue<vector<int>> q; q.push(positions[i]);
            bool seen[50][50] = {false};
            seen[positions[i][0]][positions[i][1]] = true;
            for (int step = 0; q.size(); ++step)
                for (int sz = q.size(); sz; --sz) {
                    auto elem = q.front(); q.pop();
                    if (elem == positions[j]) return step;
                    int x = elem[0], y = elem[1];
                    for (int k = 0; k < 8; ++k) {
                        int xx = x + dir[k][0], yy = y + dir[k][1];
                        if (0 <= xx && xx < 50 && 0 <= yy && yy < 50 && !seen[xx][yy]) {
                            q.push({xx, yy});
                            seen[xx][yy] = true;
                        }
                    }
                }
            return -1;
        };

        for (int i = 0; i <= n; ++i)
            for (int j = i+1; j <= n; ++j)
                dist[i][j] = dist[j][i] = bfs(i, j);
        vector<vector<vector<int>>> dp(1<<n, vector<vector<int>>(n+1, vector<int>(2)));
        for (int m = (1<<n)-2; m >= 0; --m)
            for (int i = 0; i <= n; ++i)
                if (m & 1<<i || i == n) {
                    dp[m][i][0] = 0;
                    dp[m][i][1] = INT_MAX;
                    for (int j = 0; j < n; ++j)
                        if ((m & 1<<j) == 0) {
                            int mm = m ^ 1<<j;
                            dp[m][i][0] = max(dp[m][i][0], dist[i][j] + dp[mm][j][1]);
                            dp[m][i][1] = min(dp[m][i][1], dist[i][j] + dp[mm][j][0]);

                        }
                }
        return dp[0][n][0];
    }
}


/*155. Min Stack (Easy)
Design a stack that supports push, pop, top, and retrieving the minimum element
in constant time. Implement the MinStack class:
* MinStack() initializes the stack object.
* void push(int val) pushes the element val onto the stack.
* void pop() removes the element on the top of the stack.
* int top() gets the top element of the stack.
* int getMin() retrieves the minimum element in the stack.

Example 1:
Input: ["MinStack","push","push","push","getMin","pop","top","getMin"]
       [[],[-2],[0],[-3],[],[],[],[]]
Output: [null,null,null,null,-3,null,0,-2]
Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2

Constraints:
* -2^31 <= val <= 2^31 - 1
* Methods pop, top and getMin operations will always be called on non-empty
  stacks.
* At most 3 * 10^4 calls will be made to push, pop, top, and getMin.*/

class MinStack {
    stack<pair<int, int>> stk;
public:
    MinStack() {}

    void push(int val) {
        if (stk.size()) stk.emplace(val, min(val, stk.top().second));
        else stk.emplace(val, val);
    }

    void pop() {
        stk.pop();
    }

    int top() {
        return stk.top().first;
    }

    int getMin() {
        return stk.top().second;
    }
};


/*170. Two Sum III - Data structure design (Easy)
Design a data structure that accepts a stream of integers and checks if it has
a pair of integers that sum up to a particular value. Implement the TwoSum
class:
* TwoSum() Initializes the TwoSum object, with an empty array initially.
* void add(int number) Adds number to the data structure.
* boolean find(int value) Returns true if there exists any pair of numbers
  whose sum is equal to value, otherwise, it returns false.

Example 1:
Input: ["TwoSum", "add", "add", "add", "find", "find"]
       [[], [1], [3], [5], [4], [7]]
Output: [null, null, null, null, true, false]
Explanation
TwoSum twoSum = new TwoSum();
twoSum.add(1);   // [] --> [1]
twoSum.add(3);   // [1] --> [1,3]
twoSum.add(5);   // [1,3] --> [1,3,5]
twoSum.find(4);  // 1 + 3 = 4, return true
twoSum.find(7);  // No two integers sum up to 7, return false

Constraints:
* -10^5 <= number <= 10^5
* -2^31 <= value <= 2^31 - 1
* At most 10^4 calls will be made to add and find.*/

class TwoSum {
    unordered_map<int, int> freq;
public:
    TwoSum() {}

    void add(int number) {
        ++freq[number];
    }

    bool find(int value) {
        for (auto& [k, v] : freq)
            if (freq.count((long) value-k) && (k != (long) value-k || freq[k] > 1)) return true;
        return false;
    }
};


/*173. Binary Search Tree Iterator (Medium)
Implement the BSTIterator class that represents an iterator over the in-order
traversal of a binary search tree (BST):
* BSTIterator(TreeNode root) Initializes an object of the BSTIterator class.
  The root of the BST is given as part of the constructor. The pointer should
  be initialized to a non-existent number smaller than any element in the BST.
* boolean hasNext() Returns true if there exists a number in the traversal to
  the right of the pointer, otherwise returns false.
* int next() Moves the pointer to the right, then returns the number at the
  pointer.
Notice that by initializing the pointer to a non-existent smallest number, the
first call to next() will return the smallest element in the BST. You may
assume that next() calls will always be valid. That is, there will be at least
a next number in the in-order traversal when next() is called.

Example 1:
Input: ["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
       [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Output: [null, 3, 7, true, 9, true, 15, true, 20, false]
Explanation
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False

Constraints:
* The number of nodes in the tree is in the range [1, 10^5].
* 0 <= Node.val <= 10^6
* At most 10^5 calls will be made to hasNext, and next.

Follow up: Could you implement next() and hasNext() to run in average O(1) time
           and use O(h) memory, where h is the height of the tree?*/

class BSTIterator {
    TreeNode* node = nullptr;
    stack<TreeNode*> stk;
public:
    BSTIterator(TreeNode* root): node(root) {}

    int next() {
        hasNext();
        node = stk.top(); stk.pop();
        int ans = node->val;
        node = node->right;
        return ans;
    }

    bool hasNext() {
        while (node) {
            stk.push(node);
            node = node->left;
        }
        return stk.size();
    }
};


/*208. Implement Trie (Prefix Tree) (Medium)
A trie (pronounced as "try") or prefix tree is a tree data structure used to
efficiently store and retrieve keys in a dataset of strings. There are various
applications of this data structure, such as autocomplete and spellchecker.
Implement the Trie class:
* Trie() Initializes the trie object.
* void insert(String word) Inserts the string word into the trie.
* boolean search(String word) Returns true if the string word is in the trie
  (i.e., was inserted before), and false otherwise.
* boolean startsWith(String prefix) Returns true if there is a previously
  inserted string word that has the prefix prefix, and false otherwise.

Example 1:
Input: ["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
       [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
Output: [null, null, true, false, true, null, true]
Explanation:
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True

Constraints:
* 1 <= word.length, prefix.length <= 2000
* word and prefix consist only of lowercase English letters.
* At most 3 * 10^4 calls in total will be made to insert, search, and startsWith.*/

class TrieNode {
    TrieNode* children[26] = {nullptr};
    bool isword;
public:
    ~TrieNode() {
        for (auto& child : children)
            delete child;
    }
friend class Trie;
};


class Trie {
    TrieNode* root;
public:
    Trie() {
        root = new TrieNode();
    }

    ~Trie() {
        delete root;
    }

    void insert(string word) {
        TrieNode* node = root;
        for (auto& ch : word) {
            if (!node->children[ch-'a']) node->children[ch-'a'] = new TrieNode();
            node = node->children[ch-'a'];
        }
        node->isword = true;
    }

    bool search(string word) {
        TrieNode* node = root;
        for (auto& ch : word) {
            if (!node->children[ch-'a']) return false;
            node = node->children[ch-'a'];
        }
        return node->isword;
    }

    bool startsWith(string prefix) {
        TrieNode* node = root;
        for (auto& ch : prefix) {
            if (!node->children[ch-'a']) return false;
            node = node->children[ch-'a'];
        }
        return true;
    }
};


/*211. Design Add and Search Words Data Structure (Medium)
Design a data structure that supports adding new words and finding if a string
matches any previously added string. Implement the WordDictionary class:
* WordDictionary() Initializes the object.
* void addWord(word) Adds word to the data structure, it can be matched later.
* bool search(word) Returns true if there is any string in the data structure
  that matches word or false otherwise. word may contain dots '.' where dots
  can be matched with any letter.

Example:
Input: ["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
       [[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output: [null,null,null,null,false,true,true,true]
Explanation
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True

Constraints:
* 1 <= word.length <= 500
* word in addWord consists lower-case English letters.
* word in search consist of  '.' or lower-case English letters.
* At most 50000 calls will be made to addWord and search.

class TrieNode {
public:
    TrieNode* next[26] = {nullptr};
    bool isword;
    ~TrieNode() {
        for (int i = 0; i < 26; ++i)
            delete next[i];
    }
};*/

class WordDictionary {
    TrieNode *trie = new TrieNode();
public:
    WordDictionary() {}

    ~WordDictionary() { delete trie; }

    void addWord(string word) {
        TrieNode *node = trie;
        for (auto& ch : word) {
            if (!node->next[ch - 'a']) node->next[ch - 'a'] = new TrieNode();
            node = node->next[ch - 'a'];
        }
        node->isword = true;
    }

    bool search(string word) {

        function<bool(TrieNode*, int)> fn = [&](TrieNode *node, int k) {
            if (!node) return false;
            if (k == word.size()) return node->isword;
            if (word[k] == '.') {
                for (int i = 0; i < 26; ++i)
                    if (node->next[i] && fn(node->next[i], k+1)) return true;
                return false;
            }
            return fn(node->next[word[k]-'a'], k+1);
        };

        return fn(trie, 0);
    }
};


/*232. Implement Queue using Stacks (Easy)
Implement a first in first out (FIFO) queue using only two stacks. The
implemented queue should support all the functions of a normal queue (push,
peek, pop, and empty). Implement the MyQueue class:
* void push(int x) Pushes element x to the back of the queue.
* int pop() Removes the element from the front of the queue and returns it.
* int peek() Returns the element at the front of the queue.
* boolean empty() Returns true if the queue is empty, false otherwise.

Notes:
* You must use only standard operations of a stack, which means only push to
  top, peek/pop from top, size, and is empty operations are valid.
* Depending on your language, the stack may not be supported natively. You may
  simulate a stack using a list or deque (double-ended queue) as long as you
  use only a stack's standard operations.

Example 1:
Input: ["MyQueue", "push", "push", "peek", "pop", "empty"]
       [[], [1], [2], [], [], []]
Output: [null, null, null, 1, 1, false]
Explanation:
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false

Constraints:
* 1 <= x <= 9
* At most 100 calls will be made to push, pop, peek, and empty.
* All the calls to pop and peek are valid.

Follow-up: Can you implement the queue such that each operation is amortized
           O(1) time complexity? In other words, performing n operations will
           take overall O(n) time even if one of those operations may take
           longer.*/

class MyQueue {
    stack<int> in_, out;
public:
    MyQueue() {}

    void push(int x) {
        in_.push(x);
    }

    int pop() {
        int ans = peek();
        out.pop();
        return ans;
    }

    int peek() {
        if (out.empty())
            while (in_.size()) {
                out.push(in_.top());
                in_.pop();
            }
        return out.top();
    }

    bool empty() {
        return in_.empty() && out.empty();
    }
};


/*295. Find Median from Data Stream (Hard)
The median is the middle value in an ordered integer list. If the size of the
list is even, there is no middle value and the median is the mean of the two
middle values.
* For example, for arr = [2,3,4], the median is 3.
* For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.

Implement the MedianFinder class:
* MedianFinder() initializes the MedianFinder object.
* void addNum(int num) adds the integer num from the data stream to the data
  structure.
* double findMedian() returns the median of all elements so far. Answers within
  10^-5 of the actual answer will be accepted.

Example 1:
Input: ["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
       [[], [1], [2], [], [3], []]
Output: [null, null, null, 1.5, null, 2.0]
Explanation:
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0

Constraints:
-10^5 <= num <= 10^5
There will be at least one element in the data structure before calling findMedian.
At most 5 * 10^4 calls will be made to addNum and findMedian.

Follow up:
* If all integer numbers from the stream are in the range [0, 100], how would
  you optimize your solution?
* If 99% of all integer numbers from the stream are in the range [0, 100], how
  would you optimize your solution?*/

class MedianFinder {
    priority_queue<int, vector<int>, greater<>> small;
    priority_queue<int> large;

public:
    /** initialize your data structure here. */
    MedianFinder() {}

    void addNum(int num) {
        if (small.empty() || num >= small.top()) small.push(num);
        else large.push(num);
        if (small.size() > 1 + large.size()) {
            large.push(small.top()); small.pop();
        } else if (small.size() < large.size()) {
            small.push(large.top()); large.pop();
        }
    }

    double findMedian() {
        if (small.size() == large.size()) return ((double) small.top() + large.top())/2;
        return small.top();
    }
};


/*297. Serialize and Deserialize Binary Tree (Hard)
Serialization is the process of converting a data structure or object into a
sequence of bits so that it can be stored in a file or memory buffer, or
transmitted across a network connection link to be reconstructed later in the
same or another computer environment. Design an algorithm to serialize and
deserialize a binary tree. There is no restriction on how your serialization/
deserialization algorithm should work. You just need to ensure that a binary
tree can be serialized to a string and this string can be deserialized to the
original tree structure. Clarification: The input/output format is the same as
how LeetCode serializes a binary tree. You do not necessarily need to follow
this format, so please be creative and come up with different approaches
yourself.

Example 1:
Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]

Example 2:
Input: root = []
Output: []

Example 3:
Input: root = [1]
Output: [1]

Example 4:
Input: root = [1,2]
Output: [1,2]

Constraints:
* The number of nodes in the tree is in the range [0, 10^4].
* -1000 <= Node.val <= 1000*/

class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        vector<string> vals;
        stack<TreeNode*> stk; stk.push(root);
        while (stk.size()) {
            TreeNode* node = stk.top(); stk.pop();
            if (node) {
                vals.push_back(to_string(node->val));
                stk.push(node->right);
                stk.push(node->left);
            } else vals.push_back("$");
        }
        string ans;
        for (auto& x : vals) {
            if (ans.size()) ans.push_back(' ');
            ans += x;
        }
        return ans;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        vector<string> vals;
        istringstream iss(data);
        string buf;
        while (iss >> buf) vals.push_back(buf);

        stack<TreeNode*> stk;
        TreeNode *root = nullptr, *prev = nullptr, *node = nullptr;
        for (auto& x : vals) {
            if (x == "$") {
                node = nullptr;
                if (stk.size() && !prev) stk.pop();
            } else {
                node = new TreeNode(stoi(x));
                if (!root) root = node;
                else if (prev) stk.top()->left = node;
                else stk.top()->right = node, stk.pop();
                stk.push(node);
            }
            prev = node;
        }
        return root;
    }
};

/*303. Range Sum Query - Immutable (Easy)
Given an integer array nums, handle multiple queries of the following type:
* Calculate the sum of the elements of nums between indices left and right
  inclusive where left <= right.
Implement the NumArray class:
* NumArray(int[] nums) Initializes the object with the integer array nums.
* int sumRange(int left, int right) Returns the sum of the elements of nums
  between indices left and right inclusive (i.e.
  nums[left] + nums[left + 1] + ... + nums[right]).

Example 1:
Input: ["NumArray", "sumRange", "sumRange", "sumRange"]
       [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
Output: [null, 1, -1, -3]
Explanation:
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1
numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1
numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3

Constraints:
* 1 <= nums.length <= 10^4
* -10^5 <= nums[i] <= 10^5
* 0 <= left <= right < nums.length
* At most 10^4 calls will be made to sumRange.*/

class NumArray {
    vector<int> prefix;
public:
    NumArray(vector<int>& nums) : prefix(1) {
        for (auto& x : nums)
            prefix.push_back(prefix.back() + x);
    }

    int sumRange(int left, int right) {
        return prefix[right+1] - prefix[left];
    }
};


/*304. Range Sum Query 2D - Immutable (Medium)
Given a 2D matrix matrix, handle multiple queries of the following type:
* Calculate the sum of the elements of matrix inside the rectangle defined by
  its upper left corner (row1, col1) and lower right corner (row2, col2).
Implement the NumMatrix class:
* NumMatrix(int[][] matrix) Initializes the object with the integer matrix
  matrix.
* int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the
  elements of matrix inside the rectangle defined by its upper left corner
  (row1, col1) and lower right corner (row2, col2).

Example 1:
Input: ["NumMatrix", "sumRegion", "sumRegion", "sumRegion"]
       [[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
Output: [null, 8, 11, 12]
Explanation
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)

Constraints:
* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 200
* -10^5 <= matrix[i][j] <= 10^5
* 0 <= row1 <= row2 < m
* 0 <= col1 <= col2 < n
* At most 10^4 calls will be made to sumRegion.*/

class NumMatrix {
    vector<vector<int>> prefix;
public:
    NumMatrix(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        prefix = vector<vector<int>>(m+1, vector<int>(n+1));
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                prefix[i+1][j+1] = matrix[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j];
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        return prefix[row2+1][col2+1] - prefix[row2+1][col1] - prefix[row1][col2+1] + prefix[row1][col1];
    }
};


/*308. Range Sum Query 2D - Mutable (Hard)
Given a 2D matrix matrix, handle multiple queries of the following types:
* Update the value of a cell in matrix.
* Calculate the sum of the elements of matrix inside the rectangle defined by
  its upper left corner (row1, col1) and lower right corner (row2, col2).
Implement the NumMatrix class:
* NumMatrix(int[][] matrix) Initializes the object with the integer matrix
  matrix.
* void update(int row, int col, int val) Updates the value of matrix[row][col]
  to be val.
* int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the
  elements of matrix inside the rectangle defined by its upper left corner
  (row1, col1) and lower right corner (row2, col2).

Example 1:
Input: ["NumMatrix", "sumRegion", "update", "sumRegion"]
       [[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [3, 2, 2], [2, 1, 4, 3]]
Output: [null, 8, null, 10]
Explanation:
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e. sum of the left red rectangle)
numMatrix.update(3, 2, 2);       // matrix changes from left image to right image
numMatrix.sumRegion(2, 1, 4, 3); // return 10 (i.e. sum of the right red rectangle)

Constraints:
* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 200
* -1000 <= matrix[i][j] <= 1000
* 0 <= row < m
* 0 <= col < n
* -1000 <= val <= 1000
* 0 <= row1 <= row2 < m
* 0 <= col1 <= col2 < n
* At most 5000 calls will be made to sumRegion and update.*/

class Fenwick2D {
    int m, n;
    vector<vector<int>> nums;
public:
    Fenwick2D(int m, int n) : m(m), n(n) {
        nums = vector<vector<int>>(m+1, vector<int>(n+1));
    }

    int query(int i, int j) {
        int ans = 0;
        for (++i, ++j; i; i -= i & -i)
            for (int jj = j; jj; jj -= jj & -jj)
                ans += nums[i][jj];
        return ans;
    }

    void add(int i, int j, int delta) {
        for (++i, ++j; i <= m; i += i & -i)
            for (int jj = j; jj <= n; jj += jj & -jj)
                nums[i][jj] += delta;
    }
};


class NumMatrix {
    int m, n;
    vector<vector<int>> vals;
    Fenwick2D *tree;
public:
    NumMatrix(vector<vector<int>>& matrix) {
        m = matrix.size();
        n = matrix[0].size();
        vals = vector<vector<int>>(m+1, vector<int>(n+1));
        tree = new Fenwick2D(m, n);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                update(i, j, matrix[i][j]);
    }

    void update(int row, int col, int val) {
        int delta = val - vals[row][col];
        vals[row][col] = val;
        tree->add(row, col, delta);
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        return tree->query(row2, col2) - tree->query(row1-1, col2) - tree->query(row2, col1-1) + tree->query(row1-1, col1-1);
    }
};


/*341. Flatten Nested List Iterator (Medium)
You are given a nested list of integers nestedList. Each element is either an
integer or a list whose elements may also be integers or other lists. Implement
an iterator to flatten it. Implement the NestedIterator class:
* NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with
  the nested list nestedList.
* int next() Returns the next integer in the nested list.
* boolean hasNext() Returns true if there are still some integers in the nested
  list and false otherwise.
Your code will be tested with the following pseudocode:
    initialize iterator with nestedList
    res = []
    while iterator.hasNext()
        append iterator.next() to the end of res
    return res
If res matches the expected flattened list, then your code will be judged as
correct.

Example 1:
Input: nestedList = [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, the order
             of elements returned by next should be: [1,1,2,1,1].

Example 2:
Input: nestedList = [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false, the order
             of elements returned by next should be: [1,4,6].

Constraints:
* 1 <= nestedList.length <= 500
* The values of the integers in the nested list is in the range [-10^6, 10^6].*/

class NestedIterator {
public:
    stack<pair<vector<NestedInteger>, int>> stk;
    int val = 0;

    NestedIterator(vector<NestedInteger> &nestedList) {
        stk.emplace(nestedList, 0);
        val = read();
    }

    int next() {
        int ans = val;
        val = read();
        return ans;
    }

    bool hasNext() {
        return val > INT_MIN;
    }

    int read() {
        while (stk.size()) {
            auto [data, i] = stk.top(); stk.pop();
            if (i+1 < data.size()) stk.emplace(data, i+1);
            if (data[i].isInteger()) return data[i].getInteger();
            else if (data[i].getList().size()) stk.emplace(data[i].getList(), 0);
        }
        return INT_MIN;
    }
};


/*352. Data Stream as Disjoint Intervals (Hard)
Given a data stream input of non-negative integers a1, a2, ..., an, summarize
the numbers seen so far as a list of disjoint intervals. Implement the
SummaryRanges class:
* SummaryRanges() Initializes the object with an empty stream.
* void addNum(int val) Adds the integer val to the stream.
* int[][] getIntervals() Returns a summary of the integers in the stream
  currently as a list of disjoint intervals [starti, endi].

Example 1:
Input: ["SummaryRanges", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals"]
       [[], [1], [], [3], [], [7], [], [2], [], [6], []]
Output: [null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]
Explanation:
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // return [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]

Constraints:
* 0 <= val <= 10^4
* At most 3 * 10^4 calls will be made to addNum and getIntervals.

Follow up: What if there are lots of merges and the number of disjoint
           intervals is small compared to the size of the data stream?*/

class SummaryRanges {
    set<vector<int>> data;
public:
    /** Initialize your data structure here. */
    SummaryRanges() {}

    void addNum(int val) {
        auto it = data.lower_bound({val, val});
        int start = val, end = val;
        if (it != data.end() && (*it)[0] <= val+1) {
            end = max(end, (*it)[1]);
            it = data.erase(it);
        }
        if (it != data.begin()) {
            --it;
            if (val <= (*it)[1]+1) {
                start = min(start, (*it)[0]);
                end = max(end, (*it)[1]);
                it = data.erase(it);
            }
        }
        data.insert({start, end});
    }

    vector<vector<int>> getIntervals() {
        vector<vector<int>> ans;
        for (auto it = begin(data); it != end(data); ++it)
            ans.push_back(*it);
        return ans;
    }
};


/*380. Insert Delete GetRandom O(1) (Medium)
Implement the RandomizedSet class:
* RandomizedSet() Initializes the RandomizedSet object.
* bool insert(int val) Inserts an item val into the set if not present. Returns
  true if the item was not present, false otherwise.
* bool remove(int val) Removes an item val from the set if present. Returns
  true if the item was present, false otherwise.
* int getRandom() Returns a random element from the current set of elements
  (it's guaranteed that at least one element exists when this method is called).
  Each element must have the same probability of being returned.
You must implement the functions of the class such that each function works in
average O(1) time complexity.

Example 1:
Input: ["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
       [[], [1], [2], [2], [], [1], [2], []]
Output: [null, true, false, true, 2, true, false, 2]
Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.

Constraints:
* -2^31 <= val <= 2^31 - 1
* At most 2 * 10^5 calls will be made to insert, remove, and getRandom.
* There will be at least one element in the data structure when getRandom is
  called.*/

class RandomizedSet {
    unordered_map<int, int> loc;
    vector<int> vals;
public:
    RandomizedSet() {}

    bool insert(int val) {
        if (loc.count(val)) return false;
        loc[val] = vals.size();
        vals.push_back(val);
        return true;
    }

    bool remove(int val) {
        if (!loc.count(val)) return false;
        int i = loc[val];
        loc[vals.back()] = i;
        loc.erase(val);
        vals[i] = vals.back();
        vals.pop_back();
        return true;
    }

    int getRandom() {
        return vals[rand() % vals.size()];
    }
};


/*382. Linked List Random Node (Medium)
Given a singly linked list, return a random node's value from the linked list.
Each node must have the same probability of being chosen. Implement the
Solution class:
* Solution(ListNode head) Initializes the object with the integer array nums.
* int getRandom() Chooses a node randomly from the list and returns its value.
  All the nodes of the list should be equally likely to be choosen.

Example 1:
Input: ["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]
       [[[1, 2, 3]], [], [], [], [], []]
Output: [null, 1, 3, 2, 2, 3]
Explanation
Solution solution = new Solution([1, 2, 3]);
solution.getRandom(); // return 1
solution.getRandom(); // return 3
solution.getRandom(); // return 2
solution.getRandom(); // return 2
solution.getRandom(); // return 3
// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.

Constraints:
* The number of nodes in the linked list will be in the range [1, 10^4].
* -10^4 <= Node.val <= 10^4
* At most 10^4 calls will be made to getRandom.

Follow up:
* What if the linked list is extremely large and its length is unknown to you?
* Could you solve this efficiently without using extra space?*/

class Solution {
    ListNode* head;
public:
    Solution(ListNode* head) : head(head) {}

    int getRandom() {
        int ans = 0, n = 0;
        for (ListNode* node = head; node; ++n, node = node->next)
            if (rand() % (n+1) == 0) ans = node->val;
        return ans;
    }
};


/*384. Shuffle an Array (Medium)
Given an integer array nums, design an algorithm to randomly shuffle the array.
All permutations of the array should be equally likely as a result of the
shuffling. Implement the Solution class:
* Solution(int[] nums) Initializes the object with the integer array nums.
* int[] reset() Resets the array to its original configuration and returns it.
* int[] shuffle() Returns a random shuffling of the array.

Example 1:
Input: ["Solution", "shuffle", "reset", "shuffle"]
       [[[1, 2, 3]], [], [], []]
Output: [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]
Explanation:
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // Shuffle the array [1,2,3] and return its result.
                       // Any permutation of [1,2,3] must be equally likely to be returned.
                       // Example: return [3, 1, 2]
solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]
solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]

Constraints:
* 1 <= nums.length <= 200
* -10^6 <= nums[i] <= 10^6
* All the elements of nums are unique.
* At most 5 * 10^4 calls in total will be made to reset and shuffle.*/

class Solution {
    // Knuth shuffle aka Fisher-Yates shuffle
    vector<int> orig, nums;
public:
    Solution(vector<int>& nums) {
        orig = nums;
        this->nums = nums;
    }

    vector<int> reset() {
        return orig;
    }

    vector<int> shuffle() {
        for (int i = 1; i < nums.size(); ++i) {
            int ii = rand() % (i+1);
            swap(nums[ii], nums[i]);
        }
        return nums;
    }
};


/*432. All O`one Data Structure (Hard)
Design a data structure to store the strings' count with the ability to return
the strings with minimum and maximum counts. Implement the AllOne class:
* AllOne() Initializes the object of the data structure.
* inc(String key) Increments the count of the string key by 1. If key does not
  exist in the data structure, insert it with count 1.
* dec(String key) Decrements the count of the string key by 1. If the count of
  key is 0 after the decrement, remove it from the data structure. It is
  guaranteed that key exists in the data structure before the decrement.
* getMaxKey() Returns one of the keys with the maximal count. If no element
  exists, return an empty string "".
* getMinKey() Returns one of the keys with the minimum count. If no element
  exists, return an empty string "".

Example 1:
Input: ["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
       [[], ["hello"], ["hello"], [], [], ["leet"], [], []]
Output: [null, null, null, "hello", "hello", null, "hello", "leet"]
Explanation
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "hello"
allOne.inc("leet");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "leet"

Constraints:
* 1 <= key.length <= 10
* key consists of lowercase English letters.
* It is guaranteed that for each call to dec, key is existing in the data structure.
* At most 5 * 10^4 calls will be made to inc, dec, getMaxKey, and getMinKey.*/

class Node {
public:
    unordered_set<string> keys;
    int freq;
    Node *prev, *next;

    Node(unordered_set<string> keys, int freq, Node* prev, Node* next) {
        this->keys = keys;
        this->freq = freq;
        this->prev = prev;
        this->next = next;
    }
};


class AllOne {
    unordered_map<string, Node*> mp;
    Node *head, *tail;
public:
    /** Initialize your data structure here. */
    AllOne() {
        head = new Node({}, 0, nullptr, nullptr);
        tail = new Node({}, 0, nullptr, nullptr);
        head->next = tail;
        tail->prev = head;
    }

    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */
    void inc(string key) {
        Node* node = head;
        if (mp.find(key) != mp.end()) {
            node = mp[key];
            node->keys.erase(key);
        }
        if (node->freq + 1 == node->next->freq) {
            node->next->keys.insert(key);
            mp[key] = node->next;
        } else {
            Node* newn = new Node({key}, node->freq+1, node, node->next);
            mp[key] = node->next = node->next->prev = newn;
        }

        if (node != head && node->keys.empty()) {
            node->prev->next = node->next;
            node->next->prev = node->prev;
            delete node;
        }
    }

    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */
    void dec(string key) {
        Node* node = mp[key];
        node->keys.erase(key);
        if (node->freq == 1) {
            mp.erase(key);
        } else if (node->prev->freq + 1 == node->freq) {
            node->prev->keys.insert(key);
            mp[key] = node->prev;
        } else {
            Node* newn = new Node({key}, node->freq-1, node->prev, node);
            mp[key] = node->prev = node->prev->next = newn;
        }
        if (node->keys.empty()) {
            node->prev->next = node->next;
            node->next->prev = node->prev;
            delete node;
        }
    }

    /** Returns one of the keys with maximal value. */
    string getMaxKey() {
        return head != tail->prev ? *begin(tail->prev->keys) : "";
    }

    /** Returns one of the keys with Minimal value. */
    string getMinKey() {
        return head->next != tail ? *begin(head->next->keys) : "";
    }
};


/*460. LFU Cache (Hard)
Design and implement a data structure for a Least Frequently Used (LFU) cache.
Implement the LFUCache class:
* LFUCache(int capacity) Initializes the object with the capacity of the data
  structure.
* int get(int key) Gets the value of the key if the key exists in the cache.
  Otherwise, returns -1.
* void put(int key, int value) Update the value of the key if present, or
  inserts the key if not already present. When the cache reaches its capacity,
  it should invalidate and remove the least frequently used key before
  inserting a new item. For this problem, when there is a tie (i.e., two or
  more keys with the same frequency), the least recently used key would be
  invalidated.
To determine the least frequently used key, a use counter is maintained for
each key in the cache. The key with the smallest use counter is the least
frequently used key. When a key is first inserted into the cache, its use
counter is set to 1 (due to the put operation). The use counter for a key in
the cache is incremented either a get or put operation is called on it. The
functions get and put must each run in O(1) average time complexity.

Example 1:
Input: ["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
       [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
Output: [null, null, null, 1, null, -1, 3, null, -1, 3, 4]
Explanation
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[4,3], cnt(4)=2, cnt(3)=3

Constraints:
* 0 <= capacity <= 10^4
* 0 <= key <= 10^5
* 0 <= value <= 10^9
* At most 2 * 10^5 calls will be made to get and put.*/

struct Node {
    int key, val, freq;
    Node *prev, *next;
    Node(int key=0, int val=0, int freq=0, Node* prev=nullptr, Node* next=nullptr) : key(key), val(val), freq(freq), prev(prev), next(next) {}
};

class LFUCache {
    int capacity, lo;
    unordered_map<int, Node*> mp;
    vector<pair<Node*, Node*>> freq;

    void remove(Node* node) {
        if (lo == node->freq && freq[node->freq] == make_pair(node->prev, node->next)) ++lo;
        node->next->prev = node->prev;
        node->prev->next = node->next;
        mp.erase(node->key);
    }

    void insert(Node* node) {
        if (node->freq == freq.size()) {
            Node *head = new Node(), *tail = new Node();
            head->next = tail;
            tail->prev = head;
            freq.emplace_back(head, tail);
        }
        Node* head = freq[node->freq].first;
        node->next = head->next;
        node->prev = head;
        head->next = head->next->prev = node;
        mp[node->key] = node;
    }
public:
    LFUCache(int capacity) {
        this->capacity = capacity;
        lo = 0;
    }

    int get(int key) {
        if (!mp.count(key)) return -1;
        Node* node = mp[key];
        remove(node);
        ++node->freq;
        insert(node);
        return node->val;
    }

    void put(int key, int value) {
        if (get(key) == -1) {
            if (capacity == 0 && freq.size()) {
                ++capacity;
                Node* node = freq[lo].second->prev;
                remove(node);
            }
            if (capacity) {
                --capacity;
                Node* node = new Node(key, value);
                insert(node);
                lo = 0;
            }
        } else {
            Node* node = mp[key];
            node->val = value;
        }
    }
};


/*635. Design Log Storage System (Medium)
You are given several logs, where each log contains a unique ID and timestamp.
Timestamp is a string that has the following format:
Year:Month:Day:Hour:Minute:Second, for example, 2017:01:01:23:59:59. All
domains are zero-padded decimal numbers. Implement the LogSystem class:
* LogSystem() Initializes the LogSystem object.
* void put(int id, string timestamp) Stores the given log (id, timestamp) in
  your storage system.
* int[] retrieve(string start, string end, string granularity) Returns the IDs
  of the logs whose timestamps are within the range from start to end inclusive.
  start and end all have the same format as timestamp, and granularity means
  how precise the range should be (i.e. to the exact Day, Minute, etc.). For
  example, start = "2017:01:01:23:59:59", end = "2017:01:02:23:59:59", and
  granularity = "Day" means that we need to find the logs within the inclusive
  range from Jan. 1st 2017 to Jan. 2nd 2017, and the Hour, Minute, and Second
  for each log entry can be ignored.

Example 1:
Input: ["LogSystem", "put", "put", "put", "retrieve", "retrieve"]
       [[], [1, "2017:01:01:23:59:59"], [2, "2017:01:01:22:59:59"], [3, "2016:01:01:00:00:00"], ["2016:01:01:01:01:01", "2017:01:01:23:00:00", "Year"], ["2016:01:01:01:01:01", "2017:01:01:23:00:00", "Hour"]]
Output: [null, null, null, null, [3, 2, 1], [2, 1]]
Explanation:
LogSystem logSystem = new LogSystem();
logSystem.put(1, "2017:01:01:23:59:59");
logSystem.put(2, "2017:01:01:22:59:59");
logSystem.put(3, "2016:01:01:00:00:00");

// return [3,2,1], because you need to return all logs between 2016 and 2017.
logSystem.retrieve("2016:01:01:01:01:01", "2017:01:01:23:00:00", "Year");

// return [2,1], because you need to return all logs between Jan. 1, 2016 01:XX:XX and Jan. 1, 2017 23:XX:XX.
// Log 3 is not returned because Jan. 1, 2016 00:00:00 comes before the start of the range.
logSystem.retrieve("2016:01:01:01:01:01", "2017:01:01:23:00:00", "Hour");

Constraints:
* 1 <= id <= 500
* 2000 <= Year <= 2017
* 1 <= Month <= 12
* 1 <= Day <= 31
* 0 <= Hour <= 23
* 0 <= Minute, Second <= 59
* granularity is one of the values ["Year", "Month", "Day", "Hour", "Minute", "Second"].
* At most 500 calls will be made to put and retrieve.*/

class LogSystem {
    vector<pair<int, string>> log;
    unordered_map<string, int> mp;
public:
    LogSystem() {
        mp = {{"Year", 4}, {"Month", 7}, {"Day", 10}, {"Hour", 13}, {"Minute", 16}, {"Second", 19}};
    }

    void put(int id, string timestamp) {
        log.emplace_back(id, timestamp);
    }

    vector<int> retrieve(string start, string end, string granularity) {
        vector<int> ans;
        int k = mp[granularity];
        for (auto& [id, timestamp] : log)
            if (start.substr(0, k) <= timestamp.substr(0, k) && timestamp.substr(0, k) <= end.substr(0, k))
                ans.push_back(id);
        return ans;
    }
};


/*677. Map Sum Pairs (Medium)
Implement the MapSum class:
* MapSum() Initializes the MapSum object.
* void insert(String key, int val) Inserts the key-val pair into the map. If
  the key already existed, the original key-value pair will be overridden to
  the new one.
* int sum(string prefix) Returns the sum of all the pairs' value whose key
  starts with the prefix.

Example 1:
Input: ["MapSum", "insert", "sum", "insert", "sum"]
       [[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
Output: [null, null, 3, null, 5]
Explanation:
MapSum mapSum = new MapSum();
mapSum.insert("apple", 3);
mapSum.sum("ap");           // return 3 (apple = 3)
mapSum.insert("app", 2);
mapSum.sum("ap");           // return 5 (apple + app = 3 + 2 = 5)

Constraints:
* 1 <= key.length, prefix.length <= 50
* key and prefix consist of only lowercase English letters.
* 1 <= val <= 1000
* At most 50 calls will be made to insert and sum.*/

struct TrieNode {
    int val = 0;
    TrieNode* child[26] = {};
};


class MapSum {
    TrieNode* root = new TrieNode();
    unordered_map<string, int> seen;
public:
    MapSum() {}

    void insert(string key, int val) {
        val -= seen[key];
        TrieNode* node = root;
        for (auto& ch : key) {
            if (!node->child[ch-'a']) node->child[ch-'a'] = new TrieNode();
            node = node->child[ch-'a'];
            node->val += val;
        }
        seen[key] += val;
    }

    int sum(string prefix) {
        TrieNode* node = root;
        for (auto& ch : prefix) {
            if (!node->child[ch-'a']) return 0;
            node = node->child[ch-'a'];
        }
        return node->val;
    }
};


/*703. Kth Largest Element in a Stream (Easy)
Design a class to find the kth largest element in a stream. Note that it is the
kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:
* KthLargest(int k, int[] nums) Initializes the object with the integer k and
  the stream of integers nums.
* int add(int val) Returns the element representing the kth largest element in
  the stream.

Example 1:
Input: ["KthLargest", "add", "add", "add", "add", "add"]
       [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output: [null, 4, 5, 5, 8, 8]
Explanation:
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8

Constraints:
* 1 <= k <= 10^4
* 0 <= nums.length <= 10^4
* -10^4 <= nums[i] <= 10^4
* -10^4 <= val <= 10^4
* At most 10^4 calls will be made to add.
* It is guaranteed that there will be at least k elements in the array when you
  search for the kth element.*/

class KthLargest {
private:
    int k = 0;
    priority_queue<int, vector<int>, greater<>> pq; // min heap
public:
    KthLargest(int k, vector<int>& nums) : k(k) {
        for (auto& x : nums) {
            pq.push(x);
            if (pq.size() > k) pq.pop();
        }
    }

    int add(int val) {
        pq.push(val);
        if (pq.size() > k) pq.pop();
        return pq.top();
    }
};


/*707. Design Linked List (Medium)
Design your implementation of the linked list. You can choose to use a singly
or doubly linked list. A node in a singly linked list should have two
attributes: val and next. val is the value of the current node, and next is a
pointer/reference to the next node. If you want to use the doubly linked list,
you will need one more attribute prev to indicate the previous node in the
linked list. Assume all nodes in the linked list are 0-indexed. Implement the
MyLinkedList class:
* MyLinkedList() Initializes the MyLinkedList object.
* int get(int index) Get the value of the indexth node in the linked list. If
  the index is invalid, return -1.
* void addAtHead(int val) Add a node of value val before the first element of
  the linked list. After the insertion, the new node will be the first node of
  the linked list.
* void addAtTail(int val) Append a node of value val as the last element of the
  linked list.
* void addAtIndex(int index, int val) Add a node of value val before the
  indexth node in the linked list. If index equals the length of the linked
  list, the node will be appended to the end of the linked list. If index is
  greater than the length, the node will not be inserted.
* void deleteAtIndex(int index) Delete the indexth node in the linked list, if
  the index is valid.

Example 1:
Input: ["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
       [[], [1], [3], [1, 2], [1], [1], [1]]
Output: [null, null, null, null, 2, null, 3]
Explanation:
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3
myLinkedList.get(1);              // return 2
myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3
myLinkedList.get(1);              // return 3

Constraints:
* 0 <= index, val <= 1000
* Please do not use the built-in LinkedList library.
* At most 2000 calls will be made to get, addAtHead, addAtTail, addAtIndex and
  deleteAtIndex.

struct Node {
    int val = 0;
    Node *prev, *next;
    Node(int val, Node* prev=nullptr, Node* next=nullptr) {
        this->val = val;
        this->prev = prev;
        this->next = next;
    }
};*/

class MyLinkedList {
    int size = 0;
    Node *head = nullptr, *tail = nullptr;

    Node* _moveTo(int index) {
        Node* node = nullptr;
        if (0 <= index && index <= size)
            if (index <= size/2) {
                node = head->next;
                for (int i = 0; i < index; ++i) node = node->next;
            } else {
                node = tail;
                for (int i = 0; i < size-index; ++i) node = node->prev;
            }
        return node;
    }

public:
    MyLinkedList() {
        head = new Node(-1);
        tail = new Node(-1);
        head->next = tail;
        tail->prev = head;
    }

    ~MyLinkedList() {
        delete head;
        delete tail;
    }

    int get(int index) {
        Node* node = _moveTo(index);
        return node ? node->val : -1;
    }

    void addAtHead(int val) {
        addAtIndex(0, val);
    }

    void addAtTail(int val) {
        addAtIndex(size, val);
    }

    void addAtIndex(int index, int val) {
        Node* node = _moveTo(index);
        if (node) {
            ++size;
            Node* temp = new Node(val, node->prev, node);
            node->prev = node->prev->next = temp;
        }
    }

    void deleteAtIndex(int index) {
        Node* node = _moveTo(index);
        if (node && node != tail) {
            --size;
            node->next->prev = node->prev;
            node->prev->next = node->next;
            delete node;
        }
    }
};


/*715. Range Module (Hard)
A Range Module is a module that tracks ranges of numbers. Design a data
structure to track the ranges represented as half-open intervals and query
about them. A half-open interval [left, right) denotes all the real numbers x
where left <= x < right. Implement the RangeModule class:
* RangeModule() Initializes the object of the data structure.
* void addRange(int left, int right) Adds the half-open interval [left, right),
  tracking every real number in that interval. Adding an interval that
  partially overlaps with currently tracked numbers should add any numbers in
  the interval [left, right) that are not already tracked.
* boolean queryRange(int left, int right) Returns true if every real number in
  the interval [left, right) is currently being tracked, and false otherwise.
* void removeRange(int left, int right) Stops tracking every real number
  currently being tracked in the half-open interval [left, right).

Example 1:
Input: ["RangeModule", "addRange", "removeRange", "queryRange", "queryRange", "queryRange"]
       [[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]
Output: [null, null, null, true, false, true]
Explanation
RangeModule rangeModule = new RangeModule();
rangeModule.addRange(10, 20);
rangeModule.removeRange(14, 16);
rangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is
                                // being tracked)
rangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17
                                // in [13, 15) are not being tracked)
rangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is
                                // still being tracked, despite the remove
                                // operation)

Constraints:
* 1 <= left < right <= 10^9
* At most 10^4 calls will be made to addRange, queryRange, and removeRange.*/

class RangeModule {
    map<int, int> intervals;
public:
    RangeModule() {}

    void addRange(int left, int right) {
        auto it = intervals.lower_bound(left);
        while (it != intervals.end() && it->first <= right) {
            right = max(right, it->second);
            intervals.erase(prev(++it));
        }
        if (intervals.begin() != it && left <= prev(it)->second) {
            left = min(left, prev(it)->first);
            right = max(right, prev(it)->second);
            intervals.erase(prev(it));
        }
        intervals[left] = right;
    }

    bool queryRange(int left, int right) {
        auto it = intervals.lower_bound(left);
        return (intervals.begin() != it && prev(it)->first <= left && right <= prev(it)->second) || (it != intervals.end() && it->first <= left && right <= it->second);
    }

    void removeRange(int left, int right) {
        auto it = intervals.lower_bound(left);
        while (it != intervals.end() && it->first <= right) {
            if (right < it->second) {
                intervals[right] = it->second;
                intervals.erase(prev(++it));
                break;
            }
            intervals.erase(prev(++it));
        }
        if (intervals.begin() != it && left < prev(it)->second) {
            auto [lo, hi] = *prev(it);
            prev(it)->second = left;
            if (right < hi) intervals[right] = hi;
        }
    }
};


/*729. My Calendar I (Medium)
Implement a MyCalendar class to store your events. A new event can be added if
adding the event will not cause a double booking. Your class will have the
method, book(int start, int end). Formally, this represents a booking on the
half open interval [start, end), the range of real numbers x such that
start <= x < end. A double booking happens when two events have some non-empty
intersection (ie., there is some time that is common to both events.) For each
call to the method MyCalendar.book, return true if the event can be added to
the calendar successfully without causing a double booking. Otherwise, return
false and do not add the event to the calendar. Your class will be called like
this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)

Example 1:
MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(15, 25); // returns false
MyCalendar.book(20, 30); // returns true
Explanation: The first event can be booked.  The second can't because time 15
             is already booked by another event. The third event can be booked,
             as the first event takes every time less than 20, but not
             including 20.

Note:
* The number of calls to MyCalendar.book per test case will be at most 1000.
* In calls to MyCalendar.book(start, end), start and end are integers in the
  range [0, 10^9].*/

class MyCalendar {
    set<pair<int, int>> cal;
public:
    MyCalendar() {}

    bool book(int start, int end) {
        auto it = cal.lower_bound({start, end});
        if (it != cal.begin() && prev(it)->second > start) return false;
        if (it != cal.end() && end > it->first) return false;
        cal.insert({start, end});
        return true;
    }
};


/*745. Prefix and Suffix Search (Hard)
Design a special dictionary with some words that searchs the words in it by a
prefix and a suffix. Implement the WordFilter class:
* WordFilter(string[] words) Initializes the object with the words in the
  dictionary.
* f(string prefix, string suffix) Returns the index of the word in the
  dictionary, which has the prefix prefix and the suffix suffix. If there is
  more than one valid index, return the largest of them. If there is no such
  word in the dictionary, return -1.

Example 1:
Input: ["WordFilter", "f"]
       [[["apple"]], ["a", "e"]]
Output: [null, 0]
Explanation:
WordFilter wordFilter = new WordFilter(["apple"]);
wordFilter.f("a", "e"); // return 0, because the word at index 0 has prefix = "a" and suffix = 'e".

Constraints:
* 1 <= words.length <= 15000
* 1 <= words[i].length <= 10
* 1 <= prefix.length, suffix.length <= 10
* words[i], prefix and suffix consist of lower-case English letters only.
* At most 15000 calls will be made to the function f.

class TrieNode {
public:
    unordered_map<char, TrieNode*> children = {};
    int index = 0;
    ~TrieNode() {
        for (auto& child : children)
            delete child.second;
    }
};


class Trie {
public:
    TrieNode* root;
    Trie() { root = new TrieNode(); }
    ~Trie() { delete root; }

    void insert(string word, int index) {
        TrieNode* node = root;
        for (auto& letter : word) {
            if (!node->children[letter])
                node->children[letter] = new TrieNode();
            node = node->children[letter];
            node->index = index;
        }
    }

    int prefix(string word) {
        TrieNode* node = root;
        for (auto& letter : word) {
            node = node->children[letter];
            if (!node) return -1;
        }
        return node->index;
    }
}; */


class WordFilter {
    Trie* trie;
public:
    WordFilter(vector<string>& words) {
        trie = new Trie();
        for (int i = 0; i < size(words); ++i) {
            for (int j = 0; j < size(words[i]); ++j) {
                string key = words[i].substr(j) + "$" + words[i];
                trie->insert(key, i);
            }
        }
    }

    int f(string prefix, string suffix) {
        string key = suffix + "$" + prefix;
        return trie->prefix(key);
    }
};


/*911. Online Election (Medium)
You are given two integer arrays persons and times. In an election, the ith
vote was cast for persons[i] at time times[i]. For each query at a time t, find
the person that was leading the election at time t. Votes cast at time t will
count towards our query. In the case of a tie, the most recent vote (among tied
candidates) wins. Implement the TopVotedCandidate class:
* TopVotedCandidate(int[] persons, int[] times) Initializes the object with the
  persons and times arrays.
* int q(int t) Returns the number of the person that was leading the election
  at time t according to the mentioned rules.

Example 1:
Input: ["TopVotedCandidate", "q", "q", "q", "q", "q", "q"]
       [[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]
Output: [null, 0, 1, 1, 0, 0, 1]
Explanation
TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);
topVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.
topVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.
topVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)
topVotedCandidate.q(15); // return 0
topVotedCandidate.q(24); // return 0
topVotedCandidate.q(8); // return 1

Constraints:
* 1 <= persons.length <= 5000
* times.length == persons.length
* 0 <= persons[i] < persons.length
* 0 <= times[i] <= 10^9
* times is sorted in a strictly increasing order.
* times[0] <= t <= 10^9
* At most 10^4 calls will be made to q.*/

class TopVotedCandidate {
    vector<int> times, lead;
public:
    TopVotedCandidate(vector<int>& persons, vector<int>& times) : times(times) {
        unordered_map<int, int> freq;
        int pp = 0;
        for (auto& p : persons) {
            ++freq[p];
            if (freq[p] >= freq[pp]) pp = p;
            lead.push_back(pp);
        }
    }

    int q(int t) {
        int k = upper_bound(times.begin(), times.end(), t) - times.begin();
        return lead[k-1];
    }
};


/*933. Number of Recent Calls (Easy)
You have a RecentCounter class which counts the number of recent requests
within a certain time frame. Implement the RecentCounter class:
* RecentCounter() Initializes the counter with zero recent requests.
* int ping(int t) Adds a new request at time t, where t represents some time in
  milliseconds, and returns the number of requests that has happened in the
  past 3000 milliseconds (including the new request). Specifically, return the
  number of requests that have happened in the inclusive range [t - 3000, t].
It is guaranteed that every call to ping uses a strictly larger value of t than
the previous call.

Example 1:
Input: ["RecentCounter", "ping", "ping", "ping", "ping"]
       [[], [1], [100], [3001], [3002]]
Output: [null, 1, 2, 3, 3]
Explanation:
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1
recentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2
recentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3

Constraints:
* 1 <= t <= 10^9
* Each test case will call ping with strictly increasing values of t.
* At most 10^4 calls will be made to ping.*/

class RecentCounter {
private:
    queue<int> q;

public:
    RecentCounter() {}

    int ping(int t) {
        q.push(t);
        while (q.front() < t-3000) {
            q.pop();
        }
        return q.size();
    }
};


/*981. Time Based Key-Value Store (Medium)
Design a time-based key-value data structure that can store multiple values for
the same key at different time stamps and retrieve the key's value at a certain
timestamp. Implement the TimeMap class:
* TimeMap() Initializes the object of the data structure.
* void set(String key, String value, int timestamp) Stores the key key with the
  value value at the given time timestamp.
* String get(String key, int timestamp) Returns a value such that set was
  called previously, with timestamp_prev <= timestamp. If there are multiple
  such values, it returns the value associated with the largest timestamp_prev.
  If there are no values, it returns "".

Example 1:
Input: ["TimeMap", "set", "get", "get", "set", "get", "get"]
       [[], ["foo", "bar", 1], ["foo", 1], ["foo", 3], ["foo", "bar2", 4], ["foo", 4], ["foo", 5]]
Output: [null, null, "bar", "bar", null, "bar2", "bar2"]
Explanation
TimeMap timeMap = new TimeMap();
timeMap.set("foo", "bar", 1);  // store the key "foo" and value "bar" along with timestamp = 1.
timeMap.get("foo", 1);         // return "bar"
timeMap.get("foo", 3);         // return "bar", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is "bar".
timeMap.set("foo", "bar2", 4); // store the key "foo" and value "bar2" along with timestamp = 4.
timeMap.get("foo", 4);         // return "bar2"
timeMap.get("foo", 5);         // return "bar2"

Constraints:
* 1 <= key.length, value.length <= 100
* key and value consist of lowercase English letters and digits.
* 1 <= timestamp <= 10^7
* All the timestamps timestamp of set are strictly increasing.
* At most 2 * 10^5 calls will be made to set and get.*/

class TimeMap {
    unordered_map<string, map<int, string>> mp;
public:
    TimeMap() {}

    void set(string key, string value, int timestamp) {
        mp[key].insert({timestamp, value});
    }

    string get(string key, int timestamp) {
        auto it = mp[key].upper_bound(timestamp);
        return it == mp[key].begin() ? "" : prev(it)->second;
    }
};


/*1032. Stream of Characters (Hard)
Design an algorithm that accepts a stream of characters and checks if a suffix
of these characters is a string of a given array of strings words. For example,
if words = ["abc", "xyz"] and the stream added the four characters (one by one)
'a', 'x', 'y', and 'z', your algorithm should detect that the suffix "xyz" of
the characters "axyz" matches "xyz" from words. Implement the StreamChecker
class:
* StreamChecker(String[] words) Initializes the object with the strings array
  words.
* boolean query(char letter) Accepts a new character from the stream and
  returns true if any non-empty suffix from the stream forms a word that is in
  words.

Example 1:
Input: ["StreamChecker", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query"]
       [[["cd", "f", "kl"]], ["a"], ["b"], ["c"], ["d"], ["e"], ["f"], ["g"], ["h"], ["i"], ["j"], ["k"], ["l"]]
Output: [null, false, false, false, true, false, true, false, false, false, false, false, true]
Explanation
StreamChecker streamChecker = new StreamChecker(["cd", "f", "kl"]);
streamChecker.query("a"); // return False
streamChecker.query("b"); // return False
streamChecker.query("c"); // return False
streamChecker.query("d"); // return True, because 'cd' is in the wordlist
streamChecker.query("e"); // return False
streamChecker.query("f"); // return True, because 'f' is in the wordlist
streamChecker.query("g"); // return False
streamChecker.query("h"); // return False
streamChecker.query("i"); // return False
streamChecker.query("j"); // return False
streamChecker.query("k"); // return False
streamChecker.query("l"); // return True, because 'kl' is in the wordlist

Constraints:
* 1 <= words.length <= 2000
* 1 <= words[i].length <= 2000
* words[i] consists of lowercase English letters.
* letter is a lowercase English letter.
* At most 4 * 10^4 calls will be made to query.*/

class StreamChecker {
    TrieNode *root = nullptr;
    vector<char> stream;
public:
    StreamChecker(vector<string>& words) {
        root = new TrieNode();
        for (auto word : words) {
            reverse(word.begin(), word.end());
            TrieNode* node = root;
            for (auto& ch : word) {
                if (!node->child[ch - 'a']) node->child[ch - 'a'] = new TrieNode();
                node = node->child[ch - 'a'];
            }
            node->is_word = true;
        }
    }

    bool query(char letter) {
        stream.push_back(letter);
        TrieNode* node = root;
        for (int i = stream.size()-1; i >= 0; --i) {
            if (!node->child[stream[i] - 'a']) break;
            node = node->child[stream[i] - 'a'];
            if (node->is_word) return true;
        }
        return false;
    }
};


/*1166. Design File System (Medium)
You are asked to design a file system that allows you to create new paths and
associate them with different values. The format of a path is one or more
concatenated strings of the form: / followed by one or more lowercase English
letters. For example, "/leetcode" and "/leetcode/problems" are valid paths
while an empty string "" and "/" are not. Implement the FileSystem class:
* bool createPath(string path, int value) Creates a new path and associates a
  value to it if possible and returns true. Returns false if the path already
  exists or its parent path doesn't exist.
* int get(string path) Returns the value associated with path or returns -1 if
  the path doesn't exist.

Example 1:
Input: ["FileSystem","createPath","get"]
       [[],["/a",1],["/a"]]
Output: [null,true,1]
Explanation:
FileSystem fileSystem = new FileSystem();
fileSystem.createPath("/a", 1); // return true
fileSystem.get("/a"); // return 1

Example 2:
Input: ["FileSystem","createPath","createPath","get","createPath","get"]
       [[],["/leet",1],["/leet/code",2],["/leet/code"],["/c/d",1],["/c"]]
Output: [null,true,true,2,false,-1]
Explanation:
FileSystem fileSystem = new FileSystem();
fileSystem.createPath("/leet", 1); // return true
fileSystem.createPath("/leet/code", 2); // return true
fileSystem.get("/leet/code"); // return 2
fileSystem.createPath("/c/d", 1); // return false because the parent path "/c" doesn't exist.
fileSystem.get("/c"); // return -1 because this path doesn't exist.

Constraints:
* The number of calls to the two functions is less than or equal to 10^4 in total.
* 2 <= path.length <= 100
* 1 <= value <= 10^9*/

class FileSystem {
    unordered_map<string, int> mp;
public:
    FileSystem() {}

    bool createPath(string path, int value) {
        if (mp.count(path)) return false;
        string parent = path.substr(0, path.rfind('/'));
        if (parent.size() && !mp.count(parent)) return false;
        mp[path] = value;
        return true;
    }

    int get(string path) {
        if (mp.count(path)) return mp[path];
        return -1;
    }
};


/*1226. The Dining Philosophers (Medium)
Five silent philosophers sit at a round table with bowls of spaghetti. Forks
are placed between each pair of adjacent philosophers. Each philosopher must
alternately think and eat. However, a philosopher can only eat spaghetti when
they have both left and right forks. Each fork can be held by only one
philosopher and so a philosopher can use the fork only if it is not being used
by another philosopher. After an individual philosopher finishes eating, they
need to put down both forks so that the forks become available to others. A
philosopher can take the fork on their right or the one on their left as they
become available, but cannot start eating before getting both forks. Eating is
not limited by the remaining amounts of spaghetti or stomach space; an infinite
supply and an infinite demand are assumed. Design a discipline of behaviour (a
concurrent algorithm) such that no philosopher will starve; i.e., each can
forever continue to alternate between eating and thinking, assuming that no
philosopher can know when others may want to eat or think. The problem
statement and the image above are taken from wikipedia.org.

The philosophers' ids are numbered from 0 to 4 in a clockwise order. Implement
the function void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat,
putLeftFork, putRightFork) where:
* philosopher is the id of the philosopher who wants to eat.
* pickLeftFork and pickRightFork are functions you can call to pick the
  corresponding forks of that philosopher.
* eat is a function you can call to let the philosopher eat once he has picked
  both forks.
* putLeftFork and putRightFork are functions you can call to put down the
  corresponding forks of that philosopher.
* The philosophers are assumed to be thinking as long as they are not asking to
  eat (the function is not being called with their number).
Five threads, each representing a philosopher, will simultaneously use one
object of your class to simulate the process. The function may be called for
the same philosopher more than once, even before the last call ends.

Example 1:
Input: n = 1
Output: [[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]
Explanation: n is the number of times each philosopher will call the function.
             The output array describes the calls you made to the functions
             controlling the forks and the eat function, its format is:
             output[i] = [a, b, c] (three integers)
             - a is the id of a philosopher.
             - b specifies the fork: {1 : left, 2 : right}.
             - c specifies the operation: {1 : pick, 2 : put, 3 : eat}.

Constraints: 1 <= n <= 60*/

class DiningPhilosophers {
    vector<mutex> locks;
public:
    DiningPhilosophers() {
        locks = vector<mutex>(5);
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
        int small = min(philosopher, (philosopher+1) % 5), large = max(philosopher, (philosopher+1) % 5);
        locks[small].lock();
        locks[large].lock();
        pickLeftFork();
        pickRightFork();
        eat();
        putLeftFork();
        putRightFork();
        locks[large].unlock();
        locks[small].unlock();
    }
};


/*1244. Design A Leaderboard (Medium)
Design a Leaderboard class, which has 3 functions:
* addScore(playerId, score): Update the leaderboard by adding score to the
  given player's score. If there is no player with such id in the leaderboard,
  add him to the leaderboard with the given score.
* top(K): Return the score sum of the top K players.
* reset(playerId): Reset the score of the player with the given id to 0 (in
  other words erase it from the leaderboard). It is guaranteed that the player
  was added to the leaderboard before calling this function.
Initially, the leaderboard is empty.

Example 1:
Input: ["Leaderboard","addScore","addScore","addScore","addScore","addScore","top","reset","reset","addScore","top"]
       [[],[1,73],[2,56],[3,39],[4,51],[5,4],[1],[1],[2],[2,51],[3]]
Output: [null,null,null,null,null,null,73,null,null,null,141]
Explanation:
Leaderboard leaderboard = new Leaderboard ();
leaderboard.addScore(1,73);   // leaderboard = [[1,73]];
leaderboard.addScore(2,56);   // leaderboard = [[1,73],[2,56]];
leaderboard.addScore(3,39);   // leaderboard = [[1,73],[2,56],[3,39]];
leaderboard.addScore(4,51);   // leaderboard = [[1,73],[2,56],[3,39],[4,51]];
leaderboard.addScore(5,4);    // leaderboard = [[1,73],[2,56],[3,39],[4,51],[5,4]];
leaderboard.top(1);           // returns 73;
leaderboard.reset(1);         // leaderboard = [[2,56],[3,39],[4,51],[5,4]];
leaderboard.reset(2);         // leaderboard = [[3,39],[4,51],[5,4]];
leaderboard.addScore(2,51);   // leaderboard = [[2,51],[3,39],[4,51],[5,4]];
leaderboard.top(3);           // returns 141 = 51 + 51 + 39;

Constraints:
* 1 <= playerId, K <= 10000
* It's guaranteed that K is less than or equal to the current number of players.
* 1 <= score <= 100
* There will be at most 1000 function calls.*/

class Leaderboard {
    multiset<int> scores;
    unordered_map<int, int> mp;
public:
    Leaderboard() {}

    void addScore(int playerId, int score) {
        if (mp.count(playerId)) scores.erase(scores.find(mp[playerId]));
        mp[playerId] += score;
        scores.insert(mp[playerId]);
    }

    int top(int K) {
        int ans = 0;
        auto it = scores.rbegin();
        while (K-- && it != scores.rend()) ans += *it++;
        return ans;
    }

    void reset(int playerId) {
        scores.erase(scores.find(mp[playerId]));
        mp.erase(playerId);
    }
};


/*1483. Kth Ancestor of a Tree Node (Hard)
You are given a tree with n nodes numbered from 0 to n - 1 in the form of a
parent array parent where parent[i] is the parent of ith node. The root of the
tree is node 0. Find the kth ancestor of a given node. The kth ancestor of a
tree node is the kth node in the path from that node to the root node.
Implement the TreeAncestor class:
* TreeAncestor(int n, int[] parent) Initializes the object with the number of
  nodes in the tree and the parent array.
* int getKthAncestor(int node, int k) return the kth ancestor of the given node
  node. If there is no such ancestor, return -1.

Example 1:
Input: ["TreeAncestor", "getKthAncestor", "getKthAncestor", "getKthAncestor"]
       [[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]
Output: [null, 1, 0, -1]
Explanation
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);
treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3
treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5
treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor

Constraints:
* 1 <= k <= n <= 5 * 10^4
* parent.length == n
* parent[0] == -1
* 0 <= parent[i] < n for all 0 < i < n
* 0 <= node < n
* There will be at most 5 * 10^4 queries.*/

class TreeAncestor {
    int m = 0;
    vector<vector<int>> lift;
public:
    TreeAncestor(int n, vector<int>& parent) {
        m = 1 + int(log2(n));
        lift = vector<vector<int>>(n, vector<int>(m, -1)); // binary lifting
        for (int j = 0; j < m; ++j)
            for (int i = 0; i < n; ++i)
                if (j == 0) lift[i][j] = parent[i];
                else if (lift[i][j-1] != -1) lift[i][j] = lift[lift[i][j-1]][j-1];
    }

    int getKthAncestor(int node, int k) {
        for (int i = 0; i < m; ++i)
            if (k & 1<<i && 0 <= node) node = lift[node][i];
        return node;
    }
};


/*1500. Design a File Sharing System (Medium)
We will use a file-sharing system to share a very large file which consists of
m small chunks with IDs from 1 to m. When users join the system, the system
should assign a unique ID to them. The unique ID should be used once for each
user, but when a user leaves the system, the ID can be reused again. Users can
request a certain chunk of the file, the system should return a list of IDs of
all the users who own this chunk. If the user receives a non-empty list of IDs,
they receive the requested chunk successfully.

Implement the FileSharing class:
* FileSharing(int m) Initializes the object with a file of m chunks.
* int join(int[] ownedChunks): A new user joined the system owning some chunks
  of the file, the system should assign an id to the user which is the smallest
  positive integer not taken by any other user. Return the assigned id.
* void leave(int userID): The user with userID will leave the system, you
  cannot take file chunks from them anymore.
* int[] request(int userID, int chunkID): The user userID requested the file
  chunk with chunkID. Return a list of the IDs of all users that own this chunk
  sorted in ascending order.

Example:
Input: ["FileSharing","join","join","join","request","request","leave","request","leave","join"]
       [[4],[[1,2]],[[2,3]],[[4]],[1,3],[2,2],[1],[2,1],[2],[[]]]
Output: [null,1,2,3,[2],[1,2],null,[],null,1]
Explanation:
FileSharing fileSharing = new FileSharing(4); // We use the system to share a file of 4 chunks.
fileSharing.join([1, 2]);    // A user who has chunks [1,2] joined the system, assign id = 1 to them and return 1.
fileSharing.join([2, 3]);    // A user who has chunks [2,3] joined the system, assign id = 2 to them and return 2.
fileSharing.join([4]);       // A user who has chunk [4] joined the system, assign id = 3 to them and return 3.
fileSharing.request(1, 3);   // The user with id = 1 requested the third file chunk, as only the user with id = 2 has the file, return [2] . Notice that user 1 now has chunks [1,2,3].
fileSharing.request(2, 2);   // The user with id = 2 requested the second file chunk, users with ids [1,2] have this chunk, thus we return [1,2].
fileSharing.leave(1);        // The user with id = 1 left the system, all the file chunks with them are no longer available for other users.
fileSharing.request(2, 1);   // The user with id = 2 requested the first file chunk, no one in the system has this chunk, we return empty list [].
fileSharing.leave(2);        // The user with id = 2 left the system.
fileSharing.join([]);        // A user who doesn't have any chunks joined the system, assign id = 1 to them and return 1. Notice that ids 1 and 2 are free and we can reuse them.

Constraints:
* 1 <= m <= 10^5
* 0 <= ownedChunks.length <= min(100, m)
* 1 <= ownedChunks[i] <= m
* Values of ownedChunks are unique.
* 1 <= chunkID <= m
* userID is guaranteed to be a user in the system if you assign the IDs
  correctly.
* At most 10^4 calls will be made to join, leave and request.
* Each call to leave will have a matching call for join.

Follow-up:
* What happens if the system identifies the user by their IP address instead of
  their unique ID and users disconnect and connect from the system with the
  same IP?
* If the users in the system join and leave the system frequently without
  requesting any chunks, will your solution still be efficient?
* If all users join the system one time, request all files, and then leave,
  will your solution still be efficient?
* If the system will be used to share n files where the ith file consists of
  m[i], what are the changes you have to make?*/

class FileSharing {
    int n = 1;
    priority_queue<int, vector<int>, greater<>> pq;
    unordered_map<int, set<int>> chunks;
    unordered_map<int, set<int>> owners;
public:
    FileSharing(int m) {}

    int join(vector<int> ownedChunks) {
        int userID = 0;
        if (pq.size()) {
            userID = pq.top(); pq.pop();
        } else
            userID = n++;
        for (auto& chunkID : ownedChunks) {
            owners[userID].insert(chunkID);
            chunks[chunkID].insert(userID);
        }
        return userID;
    }

    void leave(int userID) {
        pq.push(userID);
        for (auto& chunkID : owners[userID])
            chunks[chunkID].erase(userID);
        owners.erase(userID);
    }

    vector<int> request(int userID, int chunkID) {
        vector<int> ans(chunks[chunkID].begin(), chunks[chunkID].end());
        if (ans.size()) {
            sort(ans.begin(), ans.end());
            chunks[chunkID].insert(userID);
            owners[userID].insert(chunkID);
        }
        return ans;
    }
};


/*1586. Binary Search Tree Iterator II (Medium)
Implement the BSTIterator class that represents an iterator over the in-order
traversal of a binary search tree (BST):
* BSTIterator(TreeNode root) Initializes an object of the BSTIterator class.
  The root of the BST is given as part of the constructor. The pointer should
  be initialized to a non-existent number smaller than any element in the BST.
* boolean hasNext() Returns true if there exists a number in the traversal to
  the right of the pointer, otherwise returns false.
* int next() Moves the pointer to the right, then returns the number at the
  pointer.
* boolean hasPrev() Returns true if there exists a number in the traversal to
  the left of the pointer, otherwise returns false.
* int prev() Moves the pointer to the left, then returns the number at the
  pointer.
Notice that by initializing the pointer to a non-existent smallest number, the
first call to next() will return the smallest element in the BST. You may
assume that next() and prev() calls will always be valid. That is, there will
be at least a next/previous number in the in-order traversal when next()/prev()
is called.

Example 1:
Input: ["BSTIterator", "next", "next", "prev", "next", "hasNext", "next", "next", "next", "hasNext", "hasPrev", "prev", "prev"]
       [[[7, 3, 15, null, null, 9, 20]], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null]]
Output: [null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9]
Explanation:
// The underlined element is where the pointer currently is.
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); // state is   [3, 7, 9, 15, 20]
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 3
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7
bSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 3
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7
bSTIterator.hasNext(); // return true
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 9
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 15
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 20
bSTIterator.hasNext(); // return false
bSTIterator.hasPrev(); // return true
bSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 15
bSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 9

Constraints:
* The number of nodes in the tree is in the range [1, 10^5].
* 0 <= Node.val <= 10^6
* At most 10^5 calls will be made to hasNext, next, hasPrev, and prev.

Follow up: Could you solve the problem without precalculating the values of the
           tree?*/

class BSTIterator {
    vector<int> vals;
    int i = -1;
public:
    BSTIterator(TreeNode* root) {
        TreeNode* node = root;
        stack<TreeNode*> stk;
        while (stk.size() || node) {
            if (node) {
                stk.push(node);
                node = node->left;
            } else {
                node = stk.top();
                stk.pop();
                vals.push_back(node->val);
                node = node->right;
            }
        }
    }

    bool hasNext() {
        return i+1 < vals.size();
    }

    int next() {
        return vals[++i];
    }

    bool hasPrev() {
        return 0 <= i-1;
    }

    int prev() {
        return vals[--i];
    }
};


/*1724. Checking Existence of Edge Length Limited Paths II (Hard)
An undirected graph of n nodes is defined by edgeList, where
edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with
distance disi. Note that there may be multiple edges between two nodes, and
the graph may not be connected. Implement the DistanceLimitedPathsExist
class:
* DistanceLimitedPathsExist(int n, int[][] edgeList) Initializes the class
  with an undirected graph.
* boolean query(int p, int q, int limit) Returns true if there exists a
  path from p to q such that each edge on the path has a distance strictly
  less than limit, and otherwise false.

Example 1:
Input: ["DistanceLimitedPathsExist", "query", "query", "query", "query"]
       [[6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]], [2, 3, 2], [1, 3, 3], [2, 0, 3], [0, 5, 6]]
Output: [null, true, false, true, false]
Explanation:
DistanceLimitedPathsExist distanceLimitedPathsExist = new DistanceLimitedPathsExist(6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]);
distanceLimitedPathsExist.query(2, 3, 2); // return true. There is an edge from 2 to 3 of distance 1, which is less than 2.
distanceLimitedPathsExist.query(1, 3, 3); // return false. There is no way to go from 1 to 3 with distances strictly less than 3.
distanceLimitedPathsExist.query(2, 0, 3); // return true. There is a way to go from 2 to 0 with distance < 3: travel from 2 to 3 to 0.
distanceLimitedPathsExist.query(0, 5, 6); // return false. There are no paths from 0 to 5.

Constraints:
* 2 <= n <= 10^4
* 0 <= edgeList.length <= 10^4
* edgeList[i].length == 3
* 0 <= ui, vi, p, q <= n-1
* ui != vi
* p != q
* 1 <= disi, limit <= 10^9
* At most 104 calls will be made to query.*/

class DistanceLimitedPathsExist {
    vector<int> parent, depth;
    vector<vector<int>> lift, weight;

    int find(int p) {
        if (p != parent[p])
            parent[p] = find(parent[p]);
        return parent[p];
    }
public:
    DistanceLimitedPathsExist(int n, vector<vector<int>>& edgeList) {
        vector<vector<pair<int, int>>> tree(n);
        parent.resize(n);
        iota(parent.begin(), parent.end(), 0);
        sort(edgeList.begin(), edgeList.end(), [](auto& lhs, auto& rhs) { return lhs[2] < rhs[2]; });
        for (auto& e : edgeList) {
            int uu = find(e[0]), vv = find(e[1]);
            if (uu != vv) {
                tree[e[0]].emplace_back(e[1], e[2]);
                tree[e[1]].emplace_back(e[0], e[2]);
                parent[uu] = vv;
            }
        }
        depth = vector<int>(n, -1);
        lift = vector<vector<int>>(n, vector<int>(32, -1));
        weight = vector<vector<int>>(n, vector<int>(32, 0));
        for (int i = 0; i < n; ++i)
            if (depth[i] == -1) {
                stack<tuple<int, int, int>> stk;
                stk.emplace(i, -1, 0);
                while (stk.size()) {
                    auto [u, p, d] = stk.top(); stk.pop();
                    depth[u] = d;
                    for (auto& [v, w] : tree[u])
                        if (v != p) {
                            lift[v][0] = u;
                            weight[v][0] = w;
                            for (int j = 1; j < 32 && lift[v][j-1] != -1; ++j) {
                                weight[v][j] = max(weight[v][j-1], weight[lift[v][j-1]][j-1]);
                                lift[v][j] = lift[lift[v][j-1]][j-1];
                            }
                            stk.emplace(v, u, d+1);
                        }
                }
            }
    }

    bool query(int p, int q, int limit) {
        if (find(p) != find(q)) return false;
        if (depth[p] > depth[q]) swap(p, q);
        int wt = 0;
        for (int i = 0; i < 32; ++i)
            if ((depth[q] - depth[p]) & (1<<i)) {
                wt = max(wt, weight[q][i]);
                q = lift[q][i];
            }
        if (p == q) return wt < limit;
        for (int i = 31; i >= 0; --i)
            if (lift[p][i] != lift[q][i]) {
                wt = max({wt, weight[p][i], weight[q][i]});
                p = lift[p][i];
                q = lift[q][i];
            }
        return max({wt, weight[p][0], weight[q][0]}) < limit;
    }
};


/*1797. Design Authentication Manager (Medium)
There is an authentication system that works with authentication tokens. For
each session, the user will receive a new authentication token that will expire
timeToLive seconds after the currentTime. If the token is renewed, the expiry
time will be extended to expire timeToLive seconds after the (potentially
different) currentTime. Implement the AuthenticationManager class:
* AuthenticationManager(int timeToLive) constructs the AuthenticationManager
  and sets the timeToLive.
* generate(string tokenId, int currentTime) generates a new token with the
  given tokenId at the given currentTime in seconds.
* renew(string tokenId, int currentTime) renews the unexpired token with the
  given tokenId at the given currentTime in seconds. If there are no unexpired
  tokens with the given tokenId, the request is ignored, and nothing happens.
* countUnexpiredTokens(int currentTime) returns the number of unexpired tokens
  at the given currentTime.
Note that if a token expires at time t, and another action happens on time t
(renew or countUnexpiredTokens), the expiration takes place before the other
actions.

Example 1:
Input: ["AuthenticationManager", "renew", "generate", "countUnexpiredTokens", "generate", "renew", "renew", "countUnexpiredTokens"]
       [[5], ["aaa", 1], ["aaa", 2], [6], ["bbb", 7], ["aaa", 8], ["bbb", 10], [15]]
Output: [null, null, null, 1, null, null, null, 0]
Explanation:
AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.
authenticationManager.renew("aaa", 1); // No token exists with tokenId "aaa" at time 1, so nothing happens.
authenticationManager.generate("aaa", 2); // Generates a new token with tokenId "aaa" at time 2.
authenticationManager.countUnexpiredTokens(6); // The token with tokenId "aaa" is the only unexpired one at time 6, so return 1.
authenticationManager.generate("bbb", 7); // Generates a new token with tokenId "bbb" at time 7.
authenticationManager.renew("aaa", 8); // The token with tokenId "aaa" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.
authenticationManager.renew("bbb", 10); // The token with tokenId "bbb" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.
authenticationManager.countUnexpiredTokens(15); // The token with tokenId "bbb" expires at time 15, and the token with tokenId "aaa" expired at time 7, so currently no token is unexpired, so return 0.

Constraints:
* 1 <= timeToLive <= 10^8
* 1 <= currentTime <= 10^8
* 1 <= tokenId.length <= 5
* tokenId consists only of lowercase letters.
* All calls to generate will contain unique values of tokenId.
* The values of currentTime across all the function calls will be strictly increasing.
* At most 2000 calls will be made to all functions combined.*/

class AuthenticationManager {
    int timeToLive = 0;
    unordered_map<string, int> expiry;

public:
    AuthenticationManager(int timeToLive) : timeToLive(timeToLive) {}

    void generate(string tokenId, int currentTime) {
        expiry[tokenId] = currentTime + timeToLive;
    }

    void renew(string tokenId, int currentTime) {
        if (expiry.count(tokenId) && expiry[tokenId] > currentTime)
            expiry[tokenId] = currentTime + timeToLive;
    }

    int countUnexpiredTokens(int currentTime) {
        int ans = 0;
        vector<string> expired;
        for (auto& x : expiry) {
            if (x.second > currentTime) ++ans;
            else expired.push_back(x.first);
        }
        for (auto& x : expired) expiry.erase(x);
        return ans;
    }
};


/*1845. Seat Reservation Manager (Medium)
Design a system that manages the reservation state of n seats that are numbered
from 1 to n. Implement the SeatManager class:
* SeatManager(int n) Initializes a SeatManager object that will manage n seats
  numbered from 1 to n. All seats are initially available.
* int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and
  returns its number.
* void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.

Example 1:
Input: ["SeatManager", "reserve", "reserve", "unreserve", "reserve", "reserve", "reserve", "reserve", "unreserve"]
       [[5], [], [], [2], [], [], [], [], [5]]
Output: [null, 1, 2, null, 2, 3, 4, 5, null]
Explanation:
SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.
seatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1.
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5].
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3.
seatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4.
seatManager.reserve();    // The only available seat is seat 5, so return 5.
seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].

Constraints:
* 1 <= n <= 10^5
* 1 <= seatNumber <= n
* For each call to reserve, it is guaranteed that there will be at least one unreserved seat.
* For each call to unreserve, it is guaranteed that seatNumber will be reserved.
* At most 10^5 calls in total will be made to reserve and unreserve.*/

class SeatManager {
private:
    priority_queue<int, vector<int>, greater<>> pq; // min-heap
public:
    SeatManager(int n) {
        for (int x = 1; x <= n; ++x)
            pq.push(x);
    }

    int reserve() {
        int ans = pq.top();
        pq.pop();
        return ans;
    }

    void unreserve(int seatNumber) {
        pq.push(seatNumber);
    }
};


/*1865. Finding Pairs With a Certain Sum (Medium)
You are given two integer arrays nums1 and nums2. You are tasked to implement a
data structure that supports queries of two types:
* Add a positive integer to an element of a given index in the array nums2.
* Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given
  value (0 <= i < nums1.length and 0 <= j < nums2.length).

Implement the FindSumPairs class:
* FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object
  with two integer arrays nums1 and nums2.
* void add(int index, int val) Adds val to nums2[index], i.e., apply
  nums2[index] += val.
* int count(int tot) Returns the number of pairs (i, j) such that
  nums1[i] + nums2[j] == tot.

Example 1:
Input: ["FindSumPairs", "count", "add", "count", "count", "add", "add", "count"]
       [[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]
Output: [null, 8, null, 2, 1, null, null, 11]
Explanation
FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);
findSumPairs.count(7);  // return 8; pairs (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) make 2 + 5 and pairs (5,1), (5,5) make 3 + 4
findSumPairs.add(3, 2); // now nums2 = [1,4,5,4,5,4]
findSumPairs.count(8);  // return 2; pairs (5,2), (5,4) make 3 + 5
findSumPairs.count(4);  // return 1; pair (5,0) makes 3 + 1
findSumPairs.add(0, 1); // now nums2 = [2,4,5,4,5,4]
findSumPairs.add(1, 1); // now nums2 = [2,5,5,4,5,4]
findSumPairs.count(7);  // return 11; pairs (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) make 2 + 5 and pairs (5,3), (5,5) make 3 + 4

Constraints:
* 1 <= nums1.length <= 1000
* 1 <= nums2.length <= 10^5
* 1 <= nums1[i] <= 10^9
* 1 <= nums2[i] <= 10^5
* 0 <= index < nums2.length
* 1 <= val <= 10^5
* 1 <= tot <= 10^9
* At most 1000 calls are made to add and count each.*/

class FindSumPairs {
    vector<int> nums1, nums2;
    unordered_map<int, int> freq;
public:
    FindSumPairs(vector<int>& nums1, vector<int>& nums2) {
        this->nums1 = nums1;
        this->nums2 = nums2;
        for (auto x : nums2)
            ++freq[x];
    }

    void add(int index, int val) {
        --freq[nums2[index]];
        nums2[index] += val;
        ++freq[nums2[index]];
    }

    int count(int tot) {
        int ans = 0;
        for (auto x : nums1) {
            ans += freq[tot - x];
        }
        return ans;
    }
};


/*1912. Design Movie Rental System (Hard)
You have a movie renting company consisting of n shops. You want to implement a
renting system that supports searching for, booking, and returning movies. The
system should also support generating a report of the currently rented movies.
Each movie is given as a 2D integer array entries where
entries[i] = [shopi, moviei, pricei] indicates that there is a copy of movie
moviei at shop shopi with a rental price of pricei. Each shop carries at most
one copy of a movie moviei.

The system should support the following functions:
* Search: Finds the cheapest 5 shops that have an unrented copy of a given
  movie. The shops should be sorted by price in ascending order, and in case of
  a tie, the one with the smaller shopi should appear first. If there are less
  than 5 matching shops, then all of them should be returned. If no shop has an
  unrented copy, then an empty list should be returned.
* Rent: Rents an unrented copy of a given movie from a given shop.
* Drop: Drops off a previously rented copy of a given movie at a given shop.
* Report: Returns the cheapest 5 rented movies (possibly of the same movie ID)
  as a 2D list res where res[j] = [shopj, moviej] describes that the jth
  cheapest rented movie moviej was rented from the shop shopj. The movies in
  res should be sorted by price in ascending order, and in case of a tie, the
  one with the smaller shopj should appear first, and if there is still tie,
  the one with the smaller moviej should appear first. If there are fewer than
  5 rented movies, then all of them should be returned. If no movies are
  currently being rented, then an empty list should be returned.

Implement the MovieRentingSystem class:
* MovieRentingSystem(int n, int[][] entries) Initializes the MovieRentingSystem
  object with n shops and the movies in entries.
* List<Integer> search(int movie) Returns a list of shops that have an unrented
  copy of the given movie as described above.
* void rent(int shop, int movie) Rents the given movie from the given shop.
* void drop(int shop, int movie) Drops off a previously rented movie at the
  given shop.
* List<List<Integer>> report() Returns a list of cheapest rented movies as
  described above.

Note: The test cases will be generated such that rent will only be called if
the shop has an unrented copy of the movie, and drop will only be called if the
shop had previously rented out the movie.

Example 1:
Input: ["MovieRentingSystem", "search", "rent", "rent", "report", "drop", "search"]
       [[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]
Output: [null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]
Explanation:
MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);
movieRentingSystem.search(1);  // return [1, 0, 2], Movies of ID 1 are unrented at shops 1, 0, and 2. Shop 1 is cheapest; shop 0 and 2 are the same price, so order by shop number.
movieRentingSystem.rent(0, 1); // Rent movie 1 from shop 0. Unrented movies at shop 0 are now [2,3].
movieRentingSystem.rent(1, 2); // Rent movie 2 from shop 1. Unrented movies at shop 1 are now [1].
movieRentingSystem.report();   // return [[0, 1], [1, 2]]. Movie 1 from shop 0 is cheapest, followed by movie 2 from shop 1.
movieRentingSystem.drop(1, 2); // Drop off movie 2 at shop 1. Unrented movies at shop 1 are now [1,2].
movieRentingSystem.search(2);  // return [0, 1]. Movies of ID 2 are unrented at shops 0 and 1. Shop 0 is cheapest, followed by shop 1.

Constraints:
* 1 <= n <= 3 * 10^5
* 1 <= entries.length <= 10^5
* 0 <= shopi < n
* 1 <= moviei, pricei <= 10^4
* Each shop carries at most one copy of a movie moviei.
* At most 10^5 calls in total will be made to search, rent, drop and report.*/

class MovieRentingSystem {
    unordered_map<int, set<array<int,2>>> avail;
    map<array<int,2> int> cost;
    set<array<int,3>> rented;
public:
    MovieRentingSystem(int n, vector<vector<int>>& entries) {
        for (auto& entry : entries) {
            int shop = entry[0], movie = entry[1], price = entry[2];
            avail.insert({movie, {price, shop}});
            cost.insert({{shop, movie}, price});
        }
    }

    vector<int> search(int movie) {
        if (avail.find(movie) == avail.end()) return {};
        vector<int> ans;
        for (auto it = begin(avail[movie]), k = 0; it != end(avail[end]) && k < 5; ++it, ++k) {
            ans.push_back(*it[1]);
        }
        return ans;
    }

    void rent(int shop, int movie) {
        int price = cost[{shop, movie}];
        avail[movie].erase({price, shop});
        rented.insert({price, shop, movie});
    }

    void drop(int shop, int movie) {
        int price = cost[{shop, movie}];
        avail[movie].insert({price, shop});
        rented.erase({price, shop, movie});
    }

    vector<vector<int>> report() {
        vector<vector<int>> ans;
        for (auto it = begin(rented), k = 0; it != end(rented) && k < 5; ++it, ++k) {
            ans.push_back(*it);
        }
        return ans;
    }
};


/*1993. Operations on Tree (Medium)
You are given a tree with n nodes numbered from 0 to n - 1 in the form of a
parent array parent where parent[i] is the parent of the ith node. The root of
the tree is node 0, so parent[0] = -1 since it has no parent. You want to
design a data structure that allows users to lock, unlock, and upgrade nodes in
the tree. The data structure should support the following functions:
* Lock: Locks the given node for the given user and prevents other users from
  locking the same node. You may only lock a node if the node is unlocked.
* Unlock: Unlocks the given node for the given user. You may only unlock a node
  if it is currently locked by the same user.
* Upgrade: Locks the given node for the given user and unlocks all of its
  descendants. You may only upgrade a node if all 3 conditions are true:
  + The node is unlocked,
  + It has at least one locked descendant (by any user), and
  + It does not have any locked ancestors.

Implement the LockingTree class:
* LockingTree(int[] parent) initializes the data structure with the parent
  array.
* lock(int num, int user) returns true if it is possible for the user with id
  user to lock the node num, or false otherwise. If it is possible, the node
  num will become locked by the user with id user.
* unlock(int num, int user) returns true if it is possible for the user with id
  user to unlock the node num, or false otherwise. If it is possible, the node
  num will become unlocked.
* upgrade(int num, int user) returns true if it is possible for the user with
  id user to upgrade the node num, or false otherwise. If it is possible, the
  node num will be upgraded.

Example 1:
Input: ["LockingTree", "lock", "unlock", "unlock", "lock", "upgrade", "lock"]
       [[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
Output: [null, true, false, true, true, true, false]
Explanation:
LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
lockingTree.lock(2, 2);    // return true because node 2 is unlocked.
                           // Node 2 will now be locked by user 2.
lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.
lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.
                           // Node 2 will now be unlocked.
lockingTree.lock(4, 5);    // return true because node 4 is unlocked.
                           // Node 4 will now be locked by user 5.
lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).
                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.
lockingTree.lock(0, 1);    // return false because node 0 is already locked.

Constraints:
* n == parent.length
* 2 <= n <= 2000
* 0 <= parent[i] <= n - 1 for i != 0
* parent[0] == -1
* 0 <= num <= n - 1
* 1 <= user <= 10^4
* parent represents a valid tree.
* At most 2000 calls in total will be made to lock, unlock, and upgrade.*/

class LockingTree {
    vector<int> parent;
    vector<int> locked;
    vector<vector<int>> tree;
public:
    LockingTree(vector<int>& parent) {
        this->parent = parent;
        int n = parent.size();
        locked.resize(n);
        tree.resize(n);
        for (int i = 0; i < parent.size(); ++i)
            if (parent[i] != -1) tree[parent[i]].push_back(i);
    }

    bool lock(int num, int user) {
        if (locked[num]) return false;
        locked[num] = user;
        return true;
    }

    bool unlock(int num, int user) {
        if (locked[num] != user) return false;
        locked[num] = 0;
        return true;
    }

    bool upgrade(int num, int user) {
        if (locked[num]) return false; // locked node found
        int x = num;
        while (x != -1) {
            if (locked[x]) return false; // locked ancestor found
            x = parent[x];
        }
        stack<int> stk; stk.push(num);
        vector<int> descendants;
        while (stk.size()) {
            int x = stk.top(); stk.pop();
            if (locked[x]) descendants.push_back(x);
            for (auto& xx : tree[x]) stk.push(xx);
        }
        if (descendants.size()) {
            locked[num] = user;
            for (auto& x : descendants) locked[x] = 0;
            return true;
        }
        return false;
    }
};


/*2013. Detect Squares (Medium)
You are given a stream of points on the X-Y plane. Design an algorithm that:
* Adds new points from the stream into a data structure. Duplicate points are
  allowed and should be treated as different points.
* Given a query point, counts the number of ways to choose three points from
  the data structure such that the three points and the query point form an
  axis-aligned square with positive area.
An axis-aligned square is a square whose edges are all the same length and are
either parallel or perpendicular to the x-axis and y-axis.

Implement the DetectSquares class:
* DetectSquares() Initializes the object with an empty data structure.
* void add(int[] point) Adds a new point point = [x, y] to the data structure.
* int count(int[] point) Counts the number of ways to form axis-aligned squares
  with point point = [x, y] as described above.

Example 1:
Input: ["DetectSquares", "add", "add", "add", "count", "count", "add", "count"]
       [[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
Output: [null, null, null, null, 1, 0, null, 2]
Explanation:
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // return 1. You can choose:
                               //   - The first, second, and third points
detectSquares.count([14, 8]);  // return 0. The query point cannot form a
                               // square with any points in the data structure.
detectSquares.add([11, 2]);    // Adding duplicate points is allowed.
detectSquares.count([11, 10]); // return 2. You can choose:
                               //   - The first, second, and third points
                               //   - The first, third, and fourth points

Constraints:
* point.length == 2
* 0 <= x, y <= 1000
* At most 5000 calls in total will be made to add and count.*/

class DetectSquares {
    unordered_map<int, int> freq;
public:
    DetectSquares() {}

    void add(vector<int> point) {
        ++freq[point[0]*1001 + point[1]];
    }

    int count(vector<int> point) {
        int ans = 0, x = point[0], y = point[1];
        for (auto& [k, v] : freq) {
            int xx = k/1001, yy = k%1001;
            if (xx != x && abs(x-xx) == abs(y-yy) && freq.count(xx*1001+y) && freq.count(x*1001+yy))
                ans += v * freq[xx*1001+y] * freq[x*1001+yy];
        }
        return ans;
    }
};


/*2034. Stock Price Fluctuation (Medium)
You are given a stream of records about a particular stock. Each record
contains a timestamp and the corresponding price of the stock at that timestamp.
Unfortunately due to the volatile nature of the stock market, the records do
not come in order. Even worse, some records may be incorrect. Another record
with the same timestamp may appear later in the stream correcting the price of
the previous wrong record. Design an algorithm that:
* Updates the price of the stock at a particular timestamp, correcting the
  price from any previous records at the timestamp.
* Finds the latest price of the stock based on the current records. The latest
  price is the price at the latest timestamp recorded.
* Finds the maximum price the stock has been based on the current records.
* Finds the minimum price the stock has been based on the current records.

Implement the StockPrice class:
* StockPrice() Initializes the object with no price records.
* void update(int timestamp, int price) Updates the price of the stock at the
  given timestamp.
* int current() Returns the latest price of the stock.
* int maximum() Returns the maximum price of the stock.
* int minimum() Returns the minimum price of the stock.

Example 1:
Input: ["StockPrice", "update", "update", "current", "maximum", "update", "maximum", "update", "minimum"]
       [[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]
Output: [null, null, null, 5, 10, null, 5, null, 2]
Explanation:
StockPrice stockPrice = new StockPrice();
stockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].
stockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].
stockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.
stockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.
stockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.
                          // Timestamps are [1,2] with corresponding prices [3,5].
stockPrice.maximum();     // return 5, the maximum price is 5 after the correction.
stockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].
stockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.

Constraints:
* 1 <= timestamp, price <= 10^9
* At most 10^5 calls will be made in total to update, current, maximum, and
  minimum.
* current, maximum, and minimum will be called only after update has been
  called at least once.*/

class StockPrice {
    unordered_map<int, int> mp;
    priority_queue<pair<int, int>> maxp;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minp;
    int latest = 0;

public:
    StockPrice() {}

    void update(int timestamp, int price) {
        mp[timestamp] = price;
        if (latest < timestamp) latest = timestamp;
        maxp.emplace(price, timestamp);
        minp.emplace(price, timestamp);
    }

    int current() {
        return mp[latest];
    }

    int maximum() {
        while (mp[maxp.top().second] != maxp.top().first) maxp.pop();
        return maxp.top().first;
    }

    int minimum() {
        while (mp[minp.top().second] != minp.top().first) minp.pop();
        return minp.top().first;
    }
};


/*2043. Simple Bank System (Medium)
You have been tasked with writing a program for a popular bank that will
automate all its incoming transactions (transfer, deposit, and withdraw). The
bank has n accounts numbered from 1 to n. The initial balance of each account
is stored in a 0-indexed integer array balance, with the (i + 1)th account
having an initial balance of balance[i]. Execute all the valid transactions. A
transaction is valid if:
* The given account number(s) are between 1 and n, and
* The amount of money withdrawn or transferred from is less than or equal to
  the balance of the account.

Implement the Bank class:
* Bank(long[] balance) Initializes the object with the 0-indexed integer array
  balance.
* boolean transfer(int account1, int account2, long money) Transfers money
  dollars from the account numbered account1 to the account numbered account2.
  Return true if the transaction was successful, false otherwise.
* boolean deposit(int account, long money) Deposit money dollars into the
  account numbered account. Return true if the transaction was successful,
  false otherwise.
* boolean withdraw(int account, long money) Withdraw money dollars from the
  account numbered account. Return true if the transaction was successful,
  false otherwise.

Example 1:
Input: ["Bank", "withdraw", "transfer", "deposit", "transfer", "withdraw"]
       [[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]
Output: [null, true, true, true, false, false]
Explanation
Bank bank = new Bank([10, 100, 20, 50, 30]);
bank.withdraw(3, 10);    // return true, account 3 has a balance of $20, so it is valid to withdraw $10.
                         // Account 3 has $20 - $10 = $10.
bank.transfer(5, 1, 20); // return true, account 5 has a balance of $30, so it is valid to transfer $20.
                         // Account 5 has $30 - $20 = $10, and account 1 has $10 + $20 = $30.
bank.deposit(5, 20);     // return true, it is valid to deposit $20 to account 5.
                         // Account 5 has $10 + $20 = $30.
bank.transfer(3, 4, 15); // return false, the current balance of account 3 is $10,
                         // so it is invalid to transfer $15 from it.
bank.withdraw(10, 50);   // return false, it is invalid because account 10 does not exist.

Constraints:
* n == balance.length
* 1 <= n, account, account1, account2 <= 10^5
* 0 <= balance[i], money <= 10^12
* At most 10^4 calls will be made to each function transfer, deposit, withdraw.*/

class Bank {
    vector<long long> balance;
public:
    Bank(vector<long long>& balance) {
        this->balance = balance;
    }

    bool transfer(int account1, int account2, long long money) {
        if (withdraw(account1, money)) {
            if (deposit(account2, money)) return true;
            deposit(account1, money);
            return false;
        }
        return false;
    }

    bool deposit(int account, long long money) {
        if (account <= balance.size()) {
            balance[account-1] += money;
            return true;
        }
        return false;
    }

    bool withdraw(int account, long long money) {
        if (account <= balance.size() && balance[account-1] >= money) {
            balance[account-1] -= money;
            return true;
        }
        return false;
    }
};


/*2069. Walking Robot Simulation II (Medium)
A width x height grid is on an XY-plane with the bottom-left cell at (0, 0) and
the top-right cell at (width - 1, height - 1). The grid is aligned with the
four cardinal directions ("North", "East", "South", and "West"). A robot is
initially at cell (0, 0) facing direction "East". The robot can be instructed
to move for a specific number of steps. For each step, it does the following.

Attempts to move forward one cell in the direction it is facing.
* If the cell the robot is moving to is out of bounds, the robot instead turns
  90 degrees counterclockwise and retries the step.
* After the robot finishes moving the number of steps required, it stops and
  awaits the next instruction.

Implement the Robot class:
* Robot(int width, int height) Initializes the width x height grid with the
  robot at (0, 0) facing "East".
* void move(int num) Instructs the robot to move forward num steps.
* int[] getPos() Returns the current cell the robot is at, as an array of
  length 2, [x, y].
* String getDir() Returns the current direction of the robot, "North", "East",
  "South", or "West".

Example 1:
Input: ["Robot", "move", "move", "getPos", "getDir", "move", "move", "move", "getPos", "getDir"]
       [[6, 3], [2], [2], [], [], [2], [1], [4], [], []]
Output: [null, null, null, [4, 0], "East", null, null, null, [1, 2], "West"]
Explanation
Robot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East.
robot.move(2);  // It moves two steps East to (2, 0), and faces East.
robot.move(2);  // It moves two steps East to (4, 0), and faces East.
robot.getPos(); // return [4, 0]
robot.getDir(); // return "East"
robot.move(2);  // It moves one step East to (5, 0), and faces East.
                // Moving the next step East would be out of bounds, so it turns and faces North.
                // Then, it moves one step North to (5, 1), and faces North.
robot.move(1);  // It moves one step North to (5, 2), and faces North (not West).
robot.move(4);  // Moving the next step North would be out of bounds, so it turns and faces West.
                // Then, it moves four steps West to (1, 2), and faces West.
robot.getPos(); // return [1, 2]
robot.getDir(); // return "West"

Constraints:
* 2 <= width, height <= 100
* 1 <= num <= 10^5
* At most 10^4 calls in total will be made to move, getPos, and getDir.*/

class Robot {
    int width = 0, height = 0, perimeter = 0, x = 0, y = 0, dx = 1, dy = 0;
public:
    Robot(int width, int height): width(width), height(height) {
        perimeter = 2*(width + height) - 4;
    }

    void move(int num) {
        num %= perimeter;
        if (num == 0 && x == 0 && y == 0 && dx == 1 && dy == 0) dx = 0, dy = -1; // edge case
        while (num) {
            int most = 0;
            if (dx == 1 && dy == 0) most = width - 1 - x;
            else if (dx == 0 && dy == 1) most = height - 1 - y;
            else if (dx == -1 && dy == 0) most = x;
            else most = y;
            int step = min(num, most);
            x += dx * step;
            y += dy * step;
            if (num > most) swap(dx, dy), dx *= -1;
            num -= step;
        }
    }

    vector<int> getPos() {
        return {x, y};
    }

    string getDir() {
        if (dx == 1 && dy == 0) return "East";
        if (dx == 0 && dy == 1) return "North";
        if (dx == -1 && dy == 0) return "West";
        return "South";
    }
};


/*2080. Range Frequency Queries (Medium)
Design a data structure to find the frequency of a given value in a given
subarray. The frequency of a value in a subarray is the number of occurrences
of that value in the subarray. Implement the RangeFreqQuery class:
* RangeFreqQuery(int[] arr) Constructs an instance of the class with the given
  0-indexed integer array arr.
* int query(int left, int right, int value) Returns the frequency of value in
  the subarray arr[left...right].
A subarray is a contiguous sequence of elements within an array.
arr[left...right] denotes the subarray that contains the elements of nums
between indices left and right (inclusive).

Example 1:
Input: ["RangeFreqQuery", "query", "query"]
       [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
Output: [null, 1, 2]
Explanation:
RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);
rangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4]
rangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array.

Constraints:
* 1 <= arr.length <= 10^5
* 1 <= arr[i], value <= 10^4
* 0 <= left <= right < arr.length
* At most 10^5 calls will be made to query*/

class RangeFreqQuery {
    unordered_map<int, vector<int>> loc;
public:
    RangeFreqQuery(vector<int>& arr) {
        for (int i = 0; i < arr.size(); ++i) loc[arr[i]].push_back(i);
    }

    int query(int left, int right, int value) {
        auto lo = lower_bound(loc[value].begin(), loc[value].end(), left);
        auto hi = upper_bound(loc[value].begin(), loc[value].end(), right);
        return hi - lo;
    }
};


/*2102. Sequentially Ordinal Rank Tracker (Hard)
A scenic location is represented by its name and attractiveness score, where
name is a unique string among all locations and score is an integer. Locations
can be ranked from the best to the worst. The higher the score, the better the
location. If the scores of two locations are equal, then the location with the
lexicographically smaller name is better. You are building a system that tracks
the ranking of locations with the system initially starting with no locations.
It supports:
* Adding scenic locations, one at a time.
* Querying the ith best location of all locations already added, where i is the
  number of times the system has been queried (including the current query).
For example, when the system is queried for the 4th time, it returns the 4th
best location of all locations already added. Note that the test data are
generated so that at any time, the number of queries does not exceed the number
of locations added to the system. Implement the SORTracker class:
* SORTracker() Initializes the tracker system.
* void add(string name, int score) Adds a scenic location with name and score
  to the system.
* string get() Queries and returns the ith best location, where i is the number
  of times this method has been invoked (including this invocation).

Example 1:
Input: ["SORTracker", "add", "add", "get", "add", "get", "add", "get", "add", "get", "add", "get", "get"]
       [[], ["bradford", 2], ["branford", 3], [], ["alps", 2], [], ["orland", 2], [], ["orlando", 3], [], ["alpine", 2], [], []]
Output: [null, null, null, "branford", null, "alps", null, "bradford", null, "bradford", null, "bradford", "orland"]
Explanation
SORTracker tracker = new SORTracker(); // Initialize the tracker system.
tracker.add("bradford", 2); // Add location with name="bradford" and score=2 to the system.
tracker.add("branford", 3); // Add location with name="branford" and score=3 to the system.
tracker.get();              // The sorted locations, from best to worst, are: branford, bradford.
                            // Note that branford precedes bradford due to its higher score (3 > 2).
                            // This is the 1st time get() is called, so return the best location: "branford".
tracker.add("alps", 2);     // Add location with name="alps" and score=2 to the system.
tracker.get();              // Sorted locations: branford, alps, bradford.
                            // Note that alps precedes bradford even though they have the same score (2).
                            // This is because "alps" is lexicographically smaller than "bradford".
                            // Return the 2nd best location "alps", as it is the 2nd time get() is called.
tracker.add("orland", 2);   // Add location with name="orland" and score=2 to the system.
tracker.get();              // Sorted locations: branford, alps, bradford, orland.
                            // Return "bradford", as it is the 3rd time get() is called.
tracker.add("orlando", 3);  // Add location with name="orlando" and score=3 to the system.
tracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.
                            // Return "bradford".
tracker.add("alpine", 2);   // Add location with name="alpine" and score=2 to the system.
tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.
                            // Return "bradford".
tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.
                            // Return "orland".

Constraints:
* name consists of lowercase English letters, and is unique among all locations.
* 1 <= name.length <= 10
* 1 <= score <= 10^5
* At any time, the number of calls to get does not exceed the number of calls
  to add.
* At most 4 * 10^4 calls in total will be made to add and get.*/

class SORTracker {
    set<pair<int, string>> st;
    set<pair<int, string>>::iterator it = st.end();
public:
    SORTracker() {}

    void add(string name, int score) {
        auto cand = st.insert({-score, name}).first;
        if (it == st.end() || *cand < *it) --it;
    }

    string get() {
        return (it++)->second;
    }
};


/*2254. Design Video Sharing Platform (Hard)
You have a video sharing platform where users can upload and delete videos.
Each video is a string of digits, where the ith digit of the string represents
the content of the video at minute i. For example, the first digit represents
the content at minute 0 in the video, the second digit represents the content
at minute 1 in the video, and so on. Viewers of videos can also like and
dislike videos. Internally, the platform keeps track of the number of views,
likes, and dislikes on each video. When a video is uploaded, it is associated
with the smallest available integer videoId starting from 0. Once a video is
deleted, the videoId associated with that video can be reused for another
video. Implement the VideoSharingPlatform class:
* VideoSharingPlatform() Initializes the object.
* int upload(String video) The user uploads a video. Return the videoId
  associated with the video.
* void remove(int videoId) If there is a video associated with videoId, remove
  the video.
* String watch(int videoId, int startMinute, int endMinute) If there is a video
  associated with videoId, increase the number of views on the video by 1 and
  return the substring of the video string starting at startMinute and ending
  at min(endMinute, video.length - 1) (inclusive). Otherwise, return "-1".
* void like(int videoId) Increases the number of likes on the video associated
  with videoId by 1 if there is a video associated with videoId.
* void dislike(int videoId) Increases the number of dislikes on the video
  associated with videoId by 1 if there is a video associated with videoId.
* int[] getLikesAndDislikes(int videoId) Return a 0-indexed integer array
  values of length 2 where values[0] is the number of likes and values[1] is
  the number of dislikes on the video associated with videoId. If there is no
  video associated with videoId, return [-1].
* int getViews(int videoId) Return the number of views on the video associated
  with videoId, if there is no video associated with videoId, return -1.

Example 1:
Input: ["VideoSharingPlatform", "upload", "upload", "remove", "remove", "upload", "watch", "watch", "like", "dislike", "dislike", "getLikesAndDislikes", "getViews"]
       [[], ["123"], ["456"], [4], [0], ["789"], [1, 0, 5], [1, 0, 1], [1], [1], [1], [1], [1]]
Output: [null, 0, 1, null, null, 0, "456", "45", null, null, null, [1, 2], 2]
Explanation
VideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform();
videoSharingPlatform.upload("123");          // The smallest available videoId is 0, so return 0.
videoSharingPlatform.upload("456");          // The smallest available videoId is 1, so return 1.
videoSharingPlatform.remove(4);              // There is no video associated with videoId 4, so do nothing.
videoSharingPlatform.remove(0);              // Remove the video associated with videoId 0.
videoSharingPlatform.upload("789");          // Since the video associated with videoId 0 was deleted,
                                             // 0 is the smallest available videoId, so return 0.
videoSharingPlatform.watch(1, 0, 5);         // The video associated with videoId 1 is "456".
                                             // The video from minute 0 to min(5, 3 - 1) = 2 is "456", so return "453".
videoSharingPlatform.watch(1, 0, 1);         // The video associated with videoId 1 is "456".
                                             // The video from minute 0 to min(1, 3 - 1) = 1 is "45", so return "45".
videoSharingPlatform.like(1);                // Increase the number of likes on the video associated with videoId 1.
videoSharingPlatform.dislike(1);             // Increase the number of dislikes on the video associated with videoId 1.
videoSharingPlatform.dislike(1);             // Increase the number of dislikes on the video associated with videoId 1.
videoSharingPlatform.getLikesAndDislikes(1); // There is 1 like and 2 dislikes on the video associated with videoId 1, so return [1, 2].
videoSharingPlatform.getViews(1);            // The video associated with videoId 1 has 2 views, so return 2.

Example 2:
Input: ["VideoSharingPlatform", "remove", "watch", "like", "dislike", "getLikesAndDislikes", "getViews"]
       [[], [0], [0, 0, 1], [0], [0], [0], [0]]
Output: [null, null, "-1", null, null, [-1], -1]
Explanation
VideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform();
videoSharingPlatform.remove(0);              // There is no video associated with videoId 0, so do nothing.
videoSharingPlatform.watch(0, 0, 1);         // There is no video associated with videoId 0, so return "-1".
videoSharingPlatform.like(0);                // There is no video associated with videoId 0, so do nothing.
videoSharingPlatform.dislike(0);             // There is no video associated with videoId 0, so do nothing.
videoSharingPlatform.getLikesAndDislikes(0); // There is no video associated with videoId 0, so return [-1].
videoSharingPlatform.getViews(0);            // There is no video associated with videoId 0, so return -1.

Constraints:
* 1 <= video.length <= 10^5
* The sum of video.length over all calls to upload does not exceed 10^5
* video consists of digits.
* 0 <= videoId <= 10^5
* 0 <= startMinute < endMinute < 10^5
* startMinute < video.length
* The sum of endMinute - startMinute over all calls to watch does not exceed 10^5.
* At most 10^5 calls in total will be made to all functions.*/

class VideoSharingPlatform {
    priority_queue<int, vector<int>, greater<>> pq;
    vector<tuple<string, int, int, int>> videos;

public:
    VideoSharingPlatform() {}

    int upload(string video) {
        int videoId = videos.size();
        if (pq.size()) {
            videoId = pq.top(); pq.pop();
            videos[videoId] = make_tuple(video, 0, 0, 0);
        } else
            videos.emplace_back(video, 0, 0, 0);
        return videoId;
    }

    void remove(int videoId) {
        if (videoId < videos.size() && get<0>(videos[videoId]).size()) {
            pq.push(videoId);
            videos[videoId] = make_tuple("", 0, 0, 0);
        }
    }

    string watch(int videoId, int startMinute, int endMinute) {
        if (videoId < videos.size() && get<0>(videos[videoId]).size()) {
            ++get<1>(videos[videoId]);
            return get<0>(videos[videoId]).substr(startMinute, endMinute - startMinute + 1);
        }
        return "-1";
    }

    void like(int videoId) {
        if (videoId < videos.size() && get<0>(videos[videoId]).size())
            ++get<2>(videos[videoId]);
    }

    void dislike(int videoId) {
        if (videoId < videos.size() && get<0>(videos[videoId]).size())
            ++get<3>(videos[videoId]);
    }

    vector<int> getLikesAndDislikes(int videoId) {
        if (videoId < videos.size() && get<0>(videos[videoId]).size())
            return {get<2>(videos[videoId]), get<3>(videos[videoId])};
        return {-1};
    }

    int getViews(int videoId) {
        if (videoId < videos.size() && get<0>(videos[videoId]).size())
            return get<1>(videos[videoId]);
        return -1;
    }
};


/*2408. Design SQL (Medium)
You are given n tables represented with two arrays names and columns, where
names[i] is the name of the ith table and columns[i] is the number of columns
of the ith table. You should be able to perform the following operations:
* Insert a row in a specific table. Each row you insert has an id. The id is
  assigned using an auto-increment method where the id of the first inserted
  row is 1, and the id of each other row inserted into the same table is the id
  of the last inserted row (even if it was deleted) plus one.
* Delete a row from a specific table. Note that deleting a row does not affect
  the id of the next inserted row.
* Select a specific cell from any table and return its value.

Implement the SQL class:
* SQL(String[] names, int[] columns) Creates the n tables.
* void insertRow(String name, String[] row) Adds a row to the table name. It is
  guaranteed that the table will exist, and the size of the array row is equal
  to the number of columns in the table.
* void deleteRow(String name, int rowId) Removes the row rowId from the table
  name. It is guaranteed that the table and row will exist.
* String selectCell(String name, int rowId, int columnId) Returns the value of
  the cell in the row rowId and the column columnId from the table name.

Example 1:
Input: ["SQL", "insertRow", "selectCell", "insertRow", "deleteRow", "selectCell"]
       [[["one", "two", "three"], [2, 3, 1]], ["two", ["first", "second", "third"]], ["two", 1, 3], ["two", ["fourth", "fifth", "sixth"]], ["two", 1], ["two", 2, 2]]
Output:[null, null, "third", null, null, "fifth"]
Explanation
SQL sql = new SQL(["one", "two", "three"], [2, 3, 1]); // creates three tables.
sql.insertRow("two", ["first", "second", "third"]); // adds a row to the table "two". Its id is 1.
sql.selectCell("two", 1, 3); // return "third", finds the value of the third column in the row with id 1 of the table "two".
sql.insertRow("two", ["fourth", "fifth", "sixth"]); // adds another row to the table "two". Its id is 2.
sql.deleteRow("two", 1); // deletes the first row of the table "two". Note that the second row will still have the id 2.
sql.selectCell("two", 2, 2); // return "fifth", finds the value of the second column in the row with id 2 of the table "two".

Constraints:
* n == names.length == columns.length
* 1 <= n <= 10^4
* 1 <= names[i].length, row[i].length, name.length <= 20
* names[i], row[i], and name consist of lowercase English letters.
* 1 <= columns[i] <= 100
* All the strings of names are distinct.
* name exists in the array names.
* row.length equals the number of columns in the chosen table.
* rowId and columnId will be valid.
* At most 250 calls will be made to insertRow and deleteRow.
* At most 10^4 calls will be made to selectCell.*/

class SQL {
    unordered_map<string, vector<vector<string>>> data;
public:
    SQL(vector<string>& names, vector<int>& columns) {}

    void insertRow(string name, vector<string> row) {
        data[name].push_back(row);
    }

    void deleteRow(string name, int rowId) {}

    string selectCell(string name, int rowId, int columnId) {
        return data[name][rowId-1][columnId-1];
    }
};


/*2424. Longest Uploaded Prefix (Medium)
You are given a stream of n videos, each represented by a distinct number from
1 to n that you need to "upload" to a server. You need to implement a data
structure that calculates the length of the longest uploaded prefix at various
points in the upload process. We consider i to be an uploaded prefix if all
videos in the range 1 to i (inclusive) have been uploaded to the server. The
longest uploaded prefix is the maximum value of i that satisfies this
definition. Implement the LUPrefix class:
* LUPrefix(int n) Initializes the object for a stream of n videos.
* void upload(int video) Uploads video to the server.
* int longest() Returns the length of the longest uploaded prefix defined above.

Example 1:
Input:  ["LUPrefix", "upload", "longest", "upload", "longest", "upload", "longest"]
        [[4], [3], [], [1], [], [2], []]
Output: [null, null, 0, null, 1, null, 3]
Explanation
LUPrefix server = new LUPrefix(4);   // Initialize a stream of 4 videos.
server.upload(3);                    // Upload video 3.
server.longest();                    // Since video 1 has not been uploaded yet, there is no prefix.
                                     // So, we return 0.
server.upload(1);                    // Upload video 1.
server.longest();                    // The prefix [1] is the longest uploaded prefix, so we return 1.
server.upload(2);                    // Upload video 2.
server.longest();                    // The prefix [1,2,3] is the longest uploaded prefix, so we return 3.

Constraints:
* 1 <= n <= 10^5
* 1 <= video <= n
* All values of video are distinct.
* At most 2 * 10^5 calls in total will be made to upload and longest.
* At least one call will be made to longest.*/

class LUPrefix {
    int ans = 0;
    vector<pair<int, int>> jump;
public:
    LUPrefix(int n) {
        jump.resize(n+2);
        for (int x = 1; x <= n; ++x)
            jump[x] = {x-1, x+1};
    }

    void upload(int video) {
        auto [lo, hi] = jump[video];
        if (lo == 0) ans = hi-1;
        jump[lo].second = hi;
        jump[hi].first = lo;
    }

    int longest() {
        return ans;
    }
};


/*2502. Design Memory Allocator (Medium)
You are given an integer n representing the size of a 0-indexed memory array.
All memory units are initially free. You have a memory allocator with the
following functionalities:
* Allocate a block of size consecutive free memory units and assign it the id
  mID.
* Free all memory units with the given id mID.
Note that:
* Multiple blocks can be allocated to the same mID.
* You should free all the memory units with mID, even if they were allocated in
  different blocks.
Implement the Allocator class:
* Allocator(int n) Initializes an Allocator object with a memory array of size
  n.
* int allocate(int size, int mID) Find the leftmost block of size consecutive
  free memory units and allocate it with the id mID. Return the block's first
  index. If such a block does not exist, return -1.
* int free(int mID) Free all memory units with the id mID. Return the number of
  memory units you have freed.

Example 1:
Input: ["Allocator", "allocate", "allocate", "allocate", "free", "allocate", "allocate", "allocate", "free", "allocate", "free"]
       [[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]
Output: [null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]
Explanation:
Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.
loc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.
loc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.
loc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.
loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.
loc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.
loc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.
loc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.
loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.
loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.
loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.

Constraints:
* 1 <= n, size, mID <= 1000
* At most 1000 calls will be made to allocate and free.*/

class Allocator {
    vector<int> memory;
public:
    Allocator(int n) {
        memory.resize(n);
    }

    int allocate(int size, int mID) {
        int cnt = 0;
        for (int i = 0; i < memory.size(); ++i)
            if (memory[i] == 0) {
                if (++cnt == size) {
                    for (int ii = i; ii >= i-size+1; --ii)
                        memory[ii] = mID;
                    return i-size+1;
                }
            } else cnt = 0;
        return -1;
    }

    int free(int mID) {
        int ans = 0;
        for (int i = 0; i < memory.size(); ++i)
            if (memory[i] == mID) {
                ++ans;
                memory[i] = 0;
            }
        return ans;
    }
};


/*2526. Find Consecutive Integers from a Data Stream (Medium)
For a stream of integers, implement a data structure that checks if the last k
integers parsed in the stream are equal to value. Implement the DataStream
class:
* DataStream(int value, int k) Initializes the object with an empty integer
  stream and the two integers value and k.
* boolean consec(int num) Adds num to the stream of integers. Returns true if
  the last k integers are equal to value, and false otherwise. If there are
  less than k integers, the condition does not hold true, so returns false.

Example 1:
Input: ["DataStream", "consec", "consec", "consec", "consec"]
       [[4, 3], [4], [4], [4], [3]]
Output: [null, false, false, true, false]
Explanation:
DataStream dataStream = new DataStream(4, 3); //value = 4, k = 3
dataStream.consec(4); // Only 1 integer is parsed, so returns False.
dataStream.consec(4); // Only 2 integers are parsed.
                      // Since 2 is less than k, returns False.
dataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True.
dataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].
                      // Since 3 is not equal to value, it returns False.

Constraints:
* 1 <= value, num <= 10^9
* 1 <= k <= 10^5
* At most 10^5 calls will be made to consec.*/

class DataStream {
    int value = 0, k = 0, cnt = 0;
public:
    DataStream(int value, int k) : value(value), k(k) {}

    bool consec(int num) {
        if (value == num) ++cnt;
        else cnt = 0;
        return cnt >= k;
    }
};


/*2642. Design Graph With Shortest Path Calculator (Hard)
There is a directed weighted graph that consists of n nodes numbered from 0 to
n - 1. The edges of the graph are initially represented by the given array
edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge
from fromi to toi with the cost edgeCosti. Implement the Graph class:
* Graph(int n, int[][] edges) initializes the object with n nodes and the given
  edges.
* addEdge(int[] edge) adds an edge to the list of edges where
  edge = [from, to, edgeCost]. It is guaranteed that there is no edge between
  the two nodes before adding this one.
* int shortestPath(int node1, int node2) returns the minimum cost of a path
  from node1 to node2. If no path exists, return -1. The cost of a path is the
  sum of the costs of the edges in the path.

Example 1:
Input: ["Graph", "shortestPath", "shortestPath", "addEdge", "shortestPath"]
[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]
Output: [null, 6, -1, null, 6]
Explanation:
Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);
g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first
                      // diagram above is 3 -> 0 -> 1 -> 2 with a total cost of
                      // 3 + 2 + 1 = 6.
g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.
g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the
                      // second diagram above.
g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is
                      // 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.

Constraints:
* 1 <= n <= 100
* 0 <= edges.length <= n * (n - 1)
* edges[i].length == edge.length == 3
* 0 <= fromi, toi, from, to, node1, node2 <= n - 1
* 1 <= edgeCosti, edgeCost <= 10^6
* There are no repeated edges and no self-loops in the graph at any point.
* At most 100 calls will be made for addEdge.
* At most 100 calls will be made for shortestPath.*/

class Graph {
    vector<vector<pair<int, int>>> graph;

public:
    Graph(int n, vector<vector<int>>& edges) {
        graph.resize(n);
        for (auto& e : edges)
            graph[e[0]].emplace_back(e[1], e[2]);
    }

    void addEdge(vector<int> edge) {
        graph[edge[0]].emplace_back(edge[1], edge[2]);
    }

    int shortestPath(int node1, int node2) {
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.emplace(0, node1);
        vector<int> dist(graph.size(), INT_MAX);
        dist[node1] = 0;
        while (pq.size()) {
            auto [cost, u] = pq.top(); pq.pop();
            if (u == node2) return cost;
            for (auto& [v, w] : graph[u])
                if (cost + w < dist[v]) {
                    dist[v] = cost + w;
                    pq.emplace(cost + w, v);
                }
        }
        return -1;
    }
};


/*2671. Frequency Tracker (Medium)
Design a data structure that keeps track of the values in it and answers some
queries regarding their frequencies. Implement the FrequencyTracker class.
* FrequencyTracker(): Initializes the FrequencyTracker object with an empty
  array initially.
* void add(int number): Adds number to the data structure.
* void deleteOne(int number): Deletes one occurence of number from the data
  structure. The data structure may not contain number, and in this case
  nothing is deleted.
* bool hasFrequency(int frequency): Returns true if there is a number in the
  data structure that occurs frequency number of times, otherwise, it returns
  false.

Example 1:
Input: ["FrequencyTracker", "add", "add", "hasFrequency"]
       [[], [3], [3], [2]]
Output: [null, null, null, true]
Explanation
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.add(3); // The data structure now contains [3]
frequencyTracker.add(3); // The data structure now contains [3, 3]
frequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice

Example 2:
Input: ["FrequencyTracker", "add", "deleteOne", "hasFrequency"]
       [[], [1], [1], [1]]
Output: [null, null, null, false]
Explanation
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.add(1); // The data structure now contains [1]
frequencyTracker.deleteOne(1); // The data structure becomes empty []
frequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty

Example 3:
Input: ["FrequencyTracker", "hasFrequency", "add", "hasFrequency"]
       [[], [2], [3], [1]]
Output: [null, false, null, true]
Explanation
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty
frequencyTracker.add(3); // The data structure now contains [3]
frequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once

Constraints:
* 1 <= number <= 10^5
* 1 <= frequency <= 10^5
* At most, 2 * 10^5 calls will be made to add, deleteOne, and hasFrequency in total.*/

class FrequencyTracker {
    unordered_map<int, int> freq;
    unordered_map<int, unordered_set<int>> group;
public:
    FrequencyTracker() {}

    void add(int number) {
        if (freq[number]) group[freq[number]].erase(number);
        group[++freq[number]].insert(number);
    }

    void deleteOne(int number) {
        if (freq[number]) {
            group[freq[number]].erase(number);
            if (--freq[number]) group[freq[number]].insert(number);
        }
    }

    bool hasFrequency(int frequency) {
        return group[frequency].size();
    }
};


/*3242. Design Neighbor Sum Service (Easy)
You are given a n x n 2D array grid containing distinct elements in the range
[0, n^2 - 1]. Implement the NeighborSum class:
* NeighborSum(int [][]grid) initializes the object.
* int adjacentSum(int value) returns the sum of elements which are adjacent
  neighbors of value, that is either to the top, left, right, or bottom of value
  in grid.
* int diagonalSum(int value) returns the sum of elements which are diagonal
  neighbors of value, that is either to the top-left, top-right, bottom-left, or
  bottom-right of value in grid.

Example 1:
Input:
["NeighborSum", "adjacentSum", "adjacentSum", "diagonalSum", "diagonalSum"]
[[[[0, 1, 2], [3, 4, 5], [6, 7, 8]]], [1], [4], [4], [8]]
Output: [null, 6, 16, 16, 4]

Explanation: The adjacent neighbors of 1 are 0, 2, and 4.
             The adjacent neighbors of 4 are 1, 3, 5, and 7.
             The diagonal neighbors of 4 are 0, 2, 6, and 8.
             The diagonal neighbor of 8 is 4.

Example 2:
Input:
["NeighborSum", "adjacentSum", "diagonalSum"]
[[[[1, 2, 0, 3], [4, 7, 15, 6], [8, 9, 10, 11], [12, 13, 14, 5]]], [15], [9]]
Output: [null, 23, 45]
Explanation: The adjacent neighbors of 15 are 0, 10, 7, and 6.
             The diagonal neighbors of 9 are 4, 12, 14, and 15.

Constraints:
* 3 <= n == grid.length == grid[0].length <= 10
* 0 <= grid[i][j] <= n^2 - 1
* All grid[i][j] are distinct.
* value in adjacentSum and diagonalSum will be in the range [0, n^2 - 1].
* At most 2 * n^2 calls will be made to adjacentSum and diagonalSum.*/

class neighborSum {
    vector<vector<int>> vals;

public:
    neighborSum(vector<vector<int>>& grid) {
        int n = grid.size(), adj[] = {-1, 0, 1, 0, -1}, dia[] = {-1, -1, 1, 1, -1};
        vals = vector<vector<int>>(2, vector<int>(n*n));
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j) {
                for (auto& [ii, jj] : vector<pair<int, int>>{{i-1, j}, {i, j-1}, {i, j+1}, {i+1, j}})
                    if (0 <= ii && ii < n && 0 <= jj && jj < n)
                        vals[0][grid[i][j]] += grid[ii][jj];
                for (auto& [ii, jj] : vector<pair<int, int>>{{i-1, j-1}, {i-1, j+1}, {i+1, j-1}, {i+1, j+1}})
                    if (0 <= ii && ii < n && 0 <= jj && jj < n)
                        vals[1][grid[i][j]] += grid[ii][jj];
            }
    }

    int adjacentSum(int value) {
        return vals[0][value];
    }

    int diagonalSum(int value) {
        return vals[1][value];
    }
};
