"""This file is a minimal colleciton of solutions to leetcode problems in
Python3. No algorithm or reasoning is provided for the sake of saving spaces.
For more details, the readers are suggested to explore on their own effort.
"""

from fractions import Fraction
from functools import cache, lru_cache, reduce
from hashlib import sha256
from heapq import heapify, heappop, heappush
from itertools import groupby, zip_longest
from math import ceil, inf, sqrt
from operator import gt, lt, or_, xor
from sortedcontainers import SortedDict, SortedList
from threading import Lock, Semaphore
from unionfind import UnionFind


class Solution:

    """1. Two Sum (Easy)
    Given an array of integers, return indices of the two numbers such that
    they add up to a specific target. You may assume that each input would have
    exactly one solution, and you may not use the same element twice.

    Example:
    Given nums = [2, 7, 11, 15], target = 9,
    Because nums[0] + nums[1] = 2 + 7 = 9,
    return [0, 1]."""

    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}
        for i, x in enumerate(nums):
            if target - x in seen: return [seen[target-x], i]
            seen[x] = i


    """2. Add Two Numbers (Medium)
    You are given two non-empty linked lists representing two non-negative
    integers. The digits are stored in reverse order and each of their nodes
    contain a single digit. Add the two numbers and return it as a linked list.
    You may assume the two numbers do not contain any leading zero, except the
    number 0 itself.

    Example:
    Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
    Output: 7 -> 0 -> 8
    Explanation: 342 + 465 = 807."""

    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = node = ListNode()
        carry = 0
        while l1 or l2 or carry:
            if l1:
                carry += l1.val
                l1 = l1.next
            if l2:
                carry += l2.val
                l2 = l2.next
            node.next = node = ListNode(carry%10)
            carry //= 10
        return dummy.next


    """3. Longest Substring Without Repeating Characters (Medium)
    Given a string, find the length of the longest substring without repeating
    characters.

    Example 1:
    Input: "abcabcbb"
    Output: 3
    Explanation: The answer is "abc", with the length of 3.

    Example 2:
    Input: "bbbbb"
    Output: 1
    Explanation: The answer is "b", with the length of 1.

    Example 3:
    Input: "pwwkew"
    Output: 3
    Explanation: The answer is "wke", with the length of 3.
    Note that the answer must be a substring, "pwke" is a subsequence and not a
    substring."""

    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = ii = 0
        loc = {}
        for i, x in enumerate(s):
            if x in loc: ii = max(ii, loc[x]+1)
            ans = max(ans, i - ii + 1)
            loc[x] = i
        return ans


    """4. Median of Two Sorted Arrays (Hard)
    There are two sorted arrays nums1 and nums2 of size m and n respectively.
    Find the median of the two sorted arrays. The overall run time complexity
    should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty.

    Example 1:
    nums1 = [1, 3], nums2 = [2]
    The median is 2.0

    Example 2:
    nums1 = [1, 2], nums2 = [3, 4]
    The median is (2 + 3)/2 = 2.5"""

    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1
        m, n = len(nums1), len(nums2)
        lo, hi = 0, m

        while lo <= hi:
            mid = (lo + hi)//2
            k = (m+n)//2 - mid
            if mid > 0 and nums1[mid-1] > nums2[k]: hi = mid
            elif mid < m and nums1[mid] < nums2[k-1]: lo = mid+1
            else:
                if mid == m: right = nums2[k]
                elif k == n: right = nums1[mid]
                else: right = min(nums1[mid], nums2[k])

                if (m+n)%2: return right

                if mid == 0: left = nums2[k-1]
                elif k == 0: left = nums1[mid-1]
                else: left = max(nums1[mid-1], nums2[k-1])

                return (left + right)/2


    """5. Longest Palindromic Substring (Medium)
    Given a string s, find the longest palindromic substring in s. You may
    assume that the maximum length of s is 1000.

    Example 1:
    Input: "babad"
    Output: "bab"
    Note: "aba" is also a valid answer.

    Example 2:
    Input: "cbbd"
    Output: "bb"""

    def longestPalindrome(self, s: str) -> str:
        """Manacher's algo"""
        ss = "#" + "#".join(s) + "#" # augmented string (even-length palindromes)
        n = len(ss)
        hlen = [0] * n # half-length
        center = right = 0
        for i in range(n):
            if i < right: hlen[i] = min(right-i, hlen[2*center-i])
            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(ss) and ss[i-1-hlen[i]] == ss[i+1+hlen[i]]: hlen[i] += 1
            if right < i+hlen[i]: center, right = i, i+hlen[i]
        xx, ii = max((x, i) for i, x in enumerate(hlen))
        return s[(ii-xx)//2 : (ii+xx)//2]


    """6. ZigZag Conversion (Medium)
    The string "PAYPALISHIRING" is written in a zigzag pattern on a given
    number of rows like this: (you may want to display this pattern in a fixed
    font for better legibility)

    P   A   H   N
    A P L S I I G
    Y   I   R
    And then read line by line: "PAHNAPLSIIGYIR"

    Write the code that will take a string and make this conversion given a
    number of rows:

    string convert(string s, int numRows);

    Example 1:
    Input: s = "PAYPALISHIRING", numRows = 3
    Output: "PAHNAPLSIIGYIR"

    Example 2:
    Input: s = "PAYPALISHIRING", numRows = 4
    Output: "PINALSIGYAHRPI"

    Explanation:

    P     I    N
    A   L S  I G
    Y A   H R
    P     I"""

    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1: return s #edge case
        ans = [[] for _ in range(numRows)]
        i, di = 0, 1
        for c in s:
            ans[i].append(c)
            i += di
            if i == 0 or i == numRows-1: di *= -1
        return "".join("".join(x) for x in ans)


    """7. Reverse Integer (Easy)
    Given a 32-bit signed integer, reverse digits of an integer.

    Example 1:
    Input: 123
    Output: 321

    Example 2:
    Input: -123
    Output: -321

    Example 3:
    Input: 120
    Output: 21

    Note:
    Assume we are dealing with an environment which could only store integers
    within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose
    of this problem, assume that your function returns 0 when the reversed
    integer overflows."""

    def reverse(self, x: int) -> int:
        x = ((x>0) - (x<0)) * int(str(abs(x))[::-1])
        return x if x.bit_length() < 32 else 0


    """8. String to Integer (atoi) (Medium)
    Implement atoi which converts a string to an integer. The function first
    discards as many whitespace characters as necessary until the first non-
    whitespace character is found. Then, starting from this character, takes
    an optional initial plus or minus sign followed by as many numerical digits
    as possible, and interprets them as a numerical value. The string can
    contain additional characters after those that form the integral number,
    which are ignored and have no effect on the behavior of this function. If
    the first sequence of non-whitespace characters in str is not a valid
    integral number, or if no such sequence exists because either str is empty
    or it contains only whitespace characters, no conversion is performed. If
    no valid conversion could be performed, a zero value is returned.

    Note:

    Only the space character ' ' is considered as whitespace character.
    Assume we are dealing with an environment which could only store integers
    within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical
    value is out of the range of representable values, INT_MAX (2^31 − 1) or
    INT_MIN (−2^31) is returned.

    Example 1:
    Input: "42"
    Output: 42

    Example 2:
    Input: "   -42"
    Output: -42
    Explanation: The first non-whitespace character is '-', which is the minus sign.
                 Then take as many numerical digits as possible, which gets 42.

    Example 3:
    Input: "4193 with words"
    Output: 4193
    Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.

    Example 4:
    Input: "words and 987"
    Output: 0
    Explanation: The first non-whitespace character is 'w', which is not a numerical
                 digit or a +/- sign. Therefore no valid conversion could be performed.

    Example 5:
    Input: "-91283472332"
    Output: -2147483648
    Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.
    Thefore INT_MIN (−2^31) is returned."""

    def myAtoi(self, s: str) -> int:
        ii = -1
        for i in range(len(s)):
            if ii == -1:
                if s[i] in "+-" or s[i].isdigit(): ii = i
                elif not s[i].isspace(): return 0
            elif not s[i].isdigit(): break
        else: i = len(s)

        ans = 0
        if 0 <= ii and (ii+1 < i or s[ii].isdigit()): ans = int(s[ii:i])
        return max(-(1<<31), min((1<<31)-1, ans))


    """9. Palindrome Number (Easy)
    Determine whether an integer is a palindrome. An integer is a palindrome
    when it reads the same backward as forward.

    Example 1:
    Input: 121
    Output: true

    Example 2:
    Input: -121
    Output: false
    Explanation: From left to right, it reads -121. From right to left, it
    becomes 121-. Therefore it is not a palindrome.

    Example 3:
    Input: 10
    Output: false
    Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

    Follow up: Coud you solve it without converting the integer to a string?"""

    def isPalindrome(self, x: int) -> bool:
        if x < 0 or x % 10 == 0 and x != 0: return False
        y = 0
        while x > y:
            y = 10*y + x % 10
            x //= 10
        return x == y or x == y//10


    """10. Regular Expression Matching (Hard)
    Given an input string (s) and a pattern (p), implement regular expression
    matching with support for '.' and '*'.

    '.' Matches any single character.
    '*' Matches zero or more of the preceding element.
    The matching should cover the entire input string (not partial).

    Note:
    s could be empty and contains only lowercase letters a-z.
    p could be empty and contains only lowercase letters a-z, and characters like . or *.

    Example 1:
    Input:
    s = "aa"
    p = "a"
    Output: false

    Example 2:
    Input:
    s = "aa"
    p = "a*"
    Output: true

    Example 3:
    Input:
    s = "ab"
    p = ".*"
    Output: true

    Example 4:
    Input:
    s = "aab"
    p = "c*a*b"
    Output: true

    Example 5:
    Input:
    s = "mississippi"
    p = "mis*is*p*."
    Output: false"""

    def isMatch(self, s: str, p: str) -> bool:

        @cache
        def fn(i, j):
            """Return True if s[i:] matches p[j:]"""
            if j == len(p): return i == len(s)
            match = i < len(s) and (s[i] == p[j] or p[j] == ".")
            if j+1 < len(p) and p[j+1] == "*":
                return fn(i, j+2) or match and fn(i+1, j)
            else:
                return match and fn(i+1, j+1)

        return fn(0, 0)



    """11. Container With Most Water (Medium)
    Given n non-negative integers a1, a2, ..., an , where each represents a
    point at coordinate (i, ai). n vertical lines are drawn such that the two
    endpoints of line i is at (i, ai) and (i, 0). Find two lines, which
    together with x-axis forms a container, such that the container contains
    the most water.

    Note: You may not slant the container and n is at least 2.

    Example:
    Input: [1,8,6,2,5,4,8,3,7]
    Output: 49"""

    def maxArea(self, height: List[int]) -> int:
        ans = 0
        lo, hi = 0, len(height)-1
        while lo < hi:
            ans = max(ans, (hi-lo)*min(height[lo], height[hi]))
            if height[lo] < height[hi]: lo += 1
            else: hi -= 1
        return ans



    """12. Integer to Roman (Medium)
    Roman numerals are represented by seven different symbols: I, V, X, L, C, D
    and M.

    Symbol       Value
    I             1
    V             5
    X             10
    L             50
    C             100
    D             500
    M             1000
    For example, two is written as II in Roman numeral, just two one's added
    together. Twelve is written as, XII, which is simply X + II. The number
    twenty seven is written as XXVII, which is XX + V + II.

    Roman numerals are usually written largest to smallest from left to right.
    However, the numeral for four is not IIII. Instead, the number four is
    written as IV. Because the one is before the five we subtract it making
    four. The same principle applies to the number nine, which is written as
    IX. There are six instances where subtraction is used:

    I can be placed before V (5) and X (10) to make 4 and 9.
    X can be placed before L (50) and C (100) to make 40 and 90.
    C can be placed before D (500) and M (1000) to make 400 and 900.
    Given an integer, convert it to a roman numeral. Input is guaranteed to be
    within the range from 1 to 3999.

    Example 1:
    Input: 3
    Output: "III"

    Example 2:
    Input: 4
    Output: "IV"

    Example 3:
    Input: 9
    Output: "IX"

    Example 4:
    Input: 58
    Output: "LVIII"
    Explanation: L = 50, V = 5, III = 3.

    Example 5:
    Input: 1994
    Output: "MCMXCIV"
    Explanation: M = 1000, CM = 900, XC = 90 and IV = 4."""

    def intToRoman(self, num: int) -> str:
        mp = {1000:"M", 900:"CM", 500:"D", 400:"CD", 100:"C", 90:"XC", 50:"L", 40:"XL", 10:"X", 9:"IX", 5:"V", 4:"IV", 1:"I"}
        ans = []
        for k, v in mp.items():
            ans.append(num//k * v)
            num %= k
        return "".join(ans)

    """13. Roman to Integer (Easy)
    Roman numerals are represented by seven different symbols: I, V, X, L, C,
    D and M.

    Symbol       Value
    I             1
    V             5
    X             10
    L             50
    C             100
    D             500
    M             1000
    For example, two is written as II in Roman numeral, just two one's added
    together. Twelve is written as, XII, which is simply X + II. The number
    twenty seven is written as XXVII, which is XX + V + II.

    Roman numerals are usually written largest to smallest from left to right.
    However, the numeral for four is not IIII. Instead, the number four is
    written as IV. Because the one is before the five we subtract it making
    four. The same principle applies to the number nine, which is written as
    IX. There are six instances where subtraction is used:

    I can be placed before V (5) and X (10) to make 4 and 9.
    X can be placed before L (50) and C (100) to make 40 and 90.
    C can be placed before D (500) and M (1000) to make 400 and 900.
    Given a roman numeral, convert it to an integer. Input is guaranteed to be
    within the range from 1 to 3999.

    Example 1:
    Input: "III"
    Output: 3

    Example 2:
    Input: "IV"
    Output: 4

    Example 3:
    Input: "IX"
    Output: 9

    Example 4:
    Input: "LVIII"
    Output: 58
    Explanation: L = 50, V= 5, III = 3.

    Example 5:
    Input: "MCMXCIV"
    Output: 1994
    Explanation: M = 1000, CM = 900, XC = 90 and IV = 4."""

    def romanToInt(self, s: str) -> int:
        mp = {"I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000}
        ans = 0
        for i in range(len(s)):
            if i+1 < len(s) and mp[s[i]] < mp[s[i+1]]: ans -= mp[s[i]]
            else: ans += mp[s[i]]
        return ans


    """14. Longest Common Prefix (Easy)
    Write a function to find the longest common prefix string amongst an array
    of strings. If there is no common prefix, return an empty string "".

    Example 1:
    Input: ["flower","flow","flight"]
    Output: "fl"

    Example 2:
    Input: ["dog","racecar","car"]
    Output: ""
    Explanation: There is no common prefix among the input strings."""

    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs: return ""
        for i, c in enumerate(zip(*strs)):
            if len(set(c)) > 1: return strs[0][:i]
        return min(strs)


    """15. 3Sum (Medium)
    Given an array nums of n integers, are there elements a, b, c in nums such
    that a + b + c = 0? Find all unique triplets in the array which gives the
    sum of zero.

    Note: The solution set must not contain duplicate triplets.

    Example:
    Given array nums = [-1, 0, 1, 2, -1, -4],
    A solution set is:
    [
      [-1, 0, 1],
      [-1, -1, 2]
    ]"""

    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        for i in range(len(nums)):
            if i == 0 or nums[i-1] != nums[i]:
                lo, hi = i+1, len(nums)-1
                while lo < hi:
                    sm = nums[i] + nums[lo] + nums[hi]
                    if sm < 0: lo += 1
                    elif sm == 0:
                        ans.append([nums[i], nums[lo], nums[hi]])
                        lo += 1
                        while lo < hi and nums[lo-1] == nums[lo]: lo += 1
                    else: hi -= 1
        return ans


    """16. 3Sum Closest (Medium)
    Given an array nums of n integers and an integer target, find three
    integers in nums such that the sum is closest to target. Return the sum of
    the three integers. You may assume that each input would have exactly one
    solution.

    Example 1:
    Input: nums = [-1,2,1,-4], target = 1
    Output: 2
    Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

    Constraints:
    3 <= nums.length <= 10^3
    -10^3 <= nums[i] <= 10^3
    -10^4 <= target <= 10^4"""

    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        ans = inf
        for i in range(len(nums)):
            lo, hi = i+1, len(nums)-1
            while lo < hi:
                sm = nums[i] + nums[lo] + nums[hi]
                ans = min(ans, sm, key=lambda x: abs(x-target))
                if sm < target: lo += 1
                else: hi -= 1
        return ans


    """17. Letter Combinations of a Phone Number (Medium)
    Given a string containing digits from 2-9 inclusive, return all possible
    letter combinations that the number could represent.

    A mapping of digit to letters (just like on the telephone buttons) is given
    below. Note that 1 does not map to any letters.

    Example:
    Input: "23"
    Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

    Note: Although the above answer is in lexicographical order, your answer
    could be in any order you want."""

    def letterCombinations(self, digits: str) -> List[str]:
        phone = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
        letters = [phone[int(ch)] for ch in digits]
        return ["".join(x) for x in product(*letters) if x]


    """18. 4Sum (Medium)
    Given an array nums of n integers and an integer target, are there elements
    a, b, c, and d in nums such that a + b + c + d = target? Find all unique
    quadruplets in the array which gives the sum of target.

    Note: The solution set must not contain duplicate quadruplets.

    Example:
    Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

    A solution set is:
    [
      [-1,  0, 0, 1],
      [-2, -1, 1, 2],
      [-2,  0, 0, 2]
    ]"""

    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        ans = []
        for i in range(len(nums)):
            if i and nums[i-1] == nums[i]: continue
            for j in range(i+1, len(nums)):
                if j > i+1 and nums[j-1] == nums[j]: continue
                lo, hi = j+1, len(nums)-1
                while lo < hi:
                    val = nums[i] + nums[j] + nums[lo] + nums[hi]
                    if val < target: lo += 1
                    elif val > target: hi -= 1
                    else:
                        ans.append([nums[i], nums[j], nums[lo], nums[hi]])
                        lo += 1
                        while lo < hi and nums[lo-1] == nums[lo]: lo += 1
        return ans


    """19. Remove Nth Node From End of List (Medium)
    Given a linked list, remove the n-th node from the end of list and return
    its head.

    Example:
    Given linked list: 1->2->3->4->5, and n = 2.
    After removing the second node from the end, the linked list becomes 1->2->3->5.

    Note: Given n will always be valid.
    Follow up: Could you do this in one pass?"""

    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = slow = fast = ListNode(next=head)
        while fast:
            fast = fast.next
            if n < 0: slow = slow.next
            n -= 1
        slow.next = slow.next.next
        return dummy.next


    """20. Valid Parentheses (Easy)
    Given a string containing just the characters '(', ')', '{', '}', '[' and
    ']', determine if the input string is valid.

    An input string is valid if:
    * Open brackets must be closed by the same type of brackets.
    * Open brackets must be closed in the correct order.
    Note: an empty string is also considered valid.

    Example 1:
    Input: "()"
    Output: true

    Example 2:
    Input: "()[]{}"
    Output: true

    Example 3:
    Input: "(]"
    Output: false

    Example 4:
    Input: "([)]"
    Output: false

    Example 5:
    Input: "{[]}"
    Output: true"""

    def isValid(self, s: str) -> bool:
        mp = {"(": ")", "[": "]", "{": "}"}
        stack = []
        for ch in s:
            if ch in mp: stack.append(ch)
            elif not stack or mp[stack.pop()] != ch: return False
        return not stack


    """21. Merge Two Sorted Lists (Easy)
    Merge two sorted linked lists and return it as a sorted list. The list
    should be made by splicing together the nodes of the first two lists.

    Example 1:
    Input: l1 = [1,2,4], l2 = [1,3,4]
    Output: [1,1,2,3,4,4]

    Example 2:
    Input: l1 = [], l2 = []
    Output: []

    Example 3:
    Input: l1 = [], l2 = [0]
    Output: [0]

    Constraints:
    * The number of nodes in both lists is in the range [0, 50].
    * -100 <= Node.val <= 100
    * Both l1 and l2 are sorted in non-decreasing order."""

    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = node = ListNode()
        while list1 and list2:
            if list1.val > list2.val: list1, list2 = list2, list1
            node.next = node = list1
            list1 = list1.next
        node.next = list1 or list2
        return dummy.next


    """22. Generate Parentheses (Medium)
    Given n pairs of parentheses, write a function to generate all
    combinations of well-formed parentheses.

    For example, given n = 3, a solution set is:

    [
      "((()))",
      "(()())",
      "(())()",
      "()(())",
      "()()()"
    ]"""

    @cache
    def generateParenthesis(self, n: int) -> List[str]:
        if n == 0: return [""]
        ans = []
        for i in range(n):
            for x in self.generateParenthesis(n-1-i):
                for y in self.generateParenthesis(i):
                    ans.append(f"({x}){y}")
        return ans


    """23. Merge k Sorted Lists (Hard)
    Merge k sorted linked lists and return it as one sorted list. Analyze and
    describe its complexity.

    Example:
    Input:
    [
      1->4->5,
      1->3->4,
      2->6
    ]
    Output: 1->1->2->3->4->4->5->6"""

    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        pq = [(x.val, i, x) for i, x in enumerate(lists) if x]
        heapify(pq)
        dummy = node = ListNode()
        while pq:
            _, i, x = heappop(pq)
            node.next = node = x
            if x.next: heappush(pq, (x.next.val, i, x.next))
        return dummy.next


    """24. Swap Nodes in Pairs (Medium)
    Given a linked list, swap every two adjacent nodes and return its head.

    You may not modify the values in the list's nodes, only nodes itself may be
    changed.

    Example:
    Given 1->2->3->4, you should return the list as 2->1->4->3."""

    def swapPairs(self, head: ListNode) -> ListNode:
        node = dummy = ListNode(next=head)
        while node.next and node.next.next:
            node.next.next.next, node.next.next, node.next = node.next, node.next.next.next, node.next.next
            node = node.next.next
        return dummy.next


    """25. Reverse Nodes in k-Group (Hard)
    Given a linked list, reverse the nodes of a linked list k at a time and
    return its modified list. k is a positive integer and is less than or
    equal to the length of the linked list. If the number of nodes is not a
    multiple of k then left-out nodes in the end should remain as it is.

    Example:
    Given this linked list: 1->2->3->4->5
    For k = 2, you should return: 2->1->4->3->5
    For k = 3, you should return: 3->2->1->4->5

    Note: Only constant extra memory is allowed.
    You may not alter the values in the list's nodes, only nodes itself may be changed."""

    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        dummy = node = ListNode(next=head)
        while True:
            temp = node.next
            for _ in range(k):
                if not temp: return dummy.next
                temp = temp.next
            prev, curr = node, node.next
            for _ in range(k): curr.next, curr, prev = prev, curr.next, curr
            node.next.next, node.next, node = curr, prev, node.next
        return dummy.next


    """26. Remove Duplicates from Sorted Array (Easy)
    Given a sorted array nums, remove the duplicates in-place such that each
    element appear only once and return the new length. Do not allocate extra
    space for another array, you must do this by modifying the input array in-
    place with O(1) extra memory.

    Example 1:
    Given nums = [1,1,2], your function should return length = 2, with the
    first two elements of nums being 1 and 2 respectively. It doesn't matter
    what you leave beyond the returned length.

    Example 2:
    Given nums = [0,0,1,1,1,2,2,3,3,4], your function should return length = 5,
    with the first five elements of nums being modified to 0, 1, 2, 3, and 4
    respectively. It doesn't matter what values are set beyond the returned
    length.

    Clarification: Confused why the returned value is an integer but your
    answer is an array?

    Note that the input array is passed in by reference, which means
    modification to the input array will be known to the caller as well.

    Internally you can think of this:
    // nums is passed in by reference. (i.e., without making a copy)
    int len = removeDuplicates(nums);
    // any modification to nums in your function would be known by the caller.
    // using the length returned by your function, it prints the first len
    elements.
    for (int i = 0; i < len; i++) {
        print(nums[i]);
    }"""

    def removeDuplicates(self, nums: List[int]) -> int:
        i = 0
        for num in nums:
            if i < 1 or nums[i-1] < num:
                nums[i] = num
                i += 1
        return i


    """27. Remove Element (Easy)
    Given an array nums and a value val, remove all instances of that value in-
    place and return the new length. Do not allocate extra space for another
    array, you must do this by modifying the input array in-place with O(1)
    extra memory. The order of elements can be changed. It doesn't matter what
    you leave beyond the new length.

    Example 1:
    Given nums = [3,2,2,3], val = 3, your function should return length = 2,
    with the first two elements of nums being 2. It doesn't matter what you
    leave beyond the returned length.

    Example 2:
    Given nums = [0,1,2,2,3,0,4,2], val = 2, your function should return
    length = 5, with the first five elements of nums containing 0, 1, 3, 0,
    and 4. Note that the order of those five elements can be arbitrary. It
    doesn't matter what values are set beyond the returned length.

    Clarification:

    Confused why the returned value is an integer but your answer is an array?

    Note that the input array is passed in by reference, which means
    modification to the input array will be known to the caller as well.

    Internally you can think of this:
    // nums is passed in by reference. (i.e., without making a copy)
    int len = removeElement(nums, val);
    // any modification to nums in your function would be known by the caller.
    // using the length returned by your function, it prints the first len elements.
    for (int i = 0; i < len; i++) {
        print(nums[i]);
    }"""

    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        for x in nums:
            if x != val: nums[i], i = x, i+1
        return i


    """28. Implement strStr() (Easy)
    Implement strStr(). Return the index of the first occurrence of needle in
    haystack, or -1 if needle is not part of haystack.

    Example 1:
    Input: haystack = "hello", needle = "ll"
    Output: 2

    Example 2:
    Input: haystack = "aaaaa", needle = "bba"
    Output: -1

    Clarification:  What should we return when needle is an empty string? This
    is a great question to ask during an interview. For the purpose of this
    problem, we will return 0 when needle is an empty string. This is
    consistent to C's strstr() and Java's indexOf()."""

    def strStr(self, haystack: str, needle: str) -> int:
        """Knuth-Morris-Pratt algo (1977)"""
        if not needle: return 0 # edge case

        lps = [0]
        k = 0
        for i in range(1, len(needle)):
            while k and needle[k] != needle[i]: k = lps[k-1]
            if needle[k] == needle[i]: k += 1
            lps.append(k)

        k = 0
        for i, ch in enumerate(haystack):
            while k and needle[k] != ch: k = lps[k-1]
            if needle[k] == ch: k += 1
            if k == len(needle): return i - k + 1
        return -1


    """29. Divide Two Integers (Medium)
    Given two integers dividend and divisor, divide two integers without using
    multiplication, division and mod operator. Return the quotient after
    dividing dividend by divisor. The integer division should truncate toward
    zero, which means losing its fractional part.

    For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.

    Example 1:
    Input: dividend = 10, divisor = 3
    Output: 3
    Explanation: 10/3 = truncate(3.33333..) = 3.

    Example 2:
    Input: dividend = 7, divisor = -3
    Output: -2
    Explanation: 7/-3 = truncate(-2.33333..) = -2.

    Note: Both dividend and divisor will be 32-bit signed integers. The divisor
    will never be 0. Assume we are dealing with an environment which could only
    store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1].
    For the purpose of this problem, assume that your function returns 2^31 − 1
    when the division result overflows."""

    def divide(self, dividend: int, divisor: int) -> int:
        if dividend == -2147483648 and divisor == -1: return 2147483647 #edge case

        neg = (dividend > 0) ^ (divisor > 0)
        ans, dividend, divisor = 0, abs(dividend), abs(divisor)
        for i in reversed(range(32)):
            if dividend >= divisor << i:
                ans |= 1 << i
                dividend -= divisor << i
        return -ans if neg else ans


    """30. Substring with Concatenation of All Words (Hard)
    You are given a string, s, and a list of words, words, that are all of the
    same length. Find all starting indices of substring(s) in s that is a
    concatenation of each word in words exactly once and without any
    intervening characters.

    Example 1:
    Input:
      s = "barfoothefoobarman",
      words = ["foo","bar"]
    Output: [0,9]

    Explanation: Substrings starting at index 0 and 9 are "barfoo" and "foobar" respectively.
    The output order does not matter, returning [9,0] is fine too.

    Example 2:
    Input:
      s = "wordgoodgoodgoodbestword",
      words = ["word","good","best","word"]
    Output: []"""

    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if not words: return []

        target = dict()
        for word in words: target[word] = target.get(word, 0) + 1

        ans, n = [], len(words[0])
        for i in range(n):
            freq, kk = dict(), i
            for j in range(i, len(s), n):
                word = s[j:j+n]
                freq[word] = freq.get(word, 0) + 1
                while freq[word] > target.get(word, 0):
                    freq[s[kk:(kk:=kk+n)]] -= 1
                if j + n - kk == n * len(words): ans.append(kk)
        return ans


    """31. Next Permutation (Medium)
    Implement next permutation, which rearranges numbers into the
    lexicographically next greater permutation of numbers. If such arrangement
    is not possible, it must rearrange it as the lowest possible order (ie,
    sorted in ascending order). The replacement must be in-place and use only
    constant extra memory. Here are some examples. Inputs are in the left-hand
    column and its corresponding outputs are in the right-hand column.

    1,2,3 → 1,3,2
    3,2,1 → 1,2,3
    1,1,5 → 1,5,1"""

    def nextPermutation(self, nums: List[int]) -> None:
        k = len(nums)-1
        while k and nums[k-1] >= nums[k]: k -= 1

        if k:
            lo, hi = k, len(nums)
            while lo < hi:
                mid = (lo + hi)//2
                if nums[mid] <= nums[k-1]: hi = mid
                else: lo = mid+1
            nums[k-1], nums[lo-1] = nums[lo-1], nums[k-1]

        lo, hi = k, len(nums)-1
        while lo < hi:
            nums[lo], nums[hi] = nums[hi], nums[lo]
            lo, hi = lo+1, hi-1


    """32. Longest Valid Parentheses (Hard)
    Given a string containing just the characters '(' and ')', find the length
    of the longest valid (well-formed) parentheses substring.

    Example 1:
    Input: "(()"
    Output: 2
    Explanation: The longest valid parentheses substring is "()"

    Example 2:
    Input: ")()())"
    Output: 4
    Explanation: The longest valid parentheses substring is "()()"""

    def longestValidParentheses(self, s: str) -> int:

        def fn(fwd, ans=0):
            op = cl = 0
            for c in s if fwd else reversed(s):
                if c == "(": op += 1
                else: cl += 1
                if (lt if fwd else gt)(op, cl): op = cl = 0
                elif op == cl: ans = max(ans, op + cl)
            return ans

        return fn(False, fn(True))

    """33. Search in Rotated Sorted Array (Medium)
    Suppose an array sorted in ascending order is rotated at some pivot unknown
    to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
    You are given a target value to search. If found in the array return its
    index, otherwise return -1. You may assume no duplicate exists in the array.
    Your algorithm's runtime complexity must be in the order of O(log n).

    Example 1:
    Input: nums = [4,5,6,7,0,1,2], target = 0
    Output: 4

    Example 2:
    Input: nums = [4,5,6,7,0,1,2], target = 3
    Output: -1"""

    def search(self, nums: List[int], target: int) -> int:
        lo, hi = 0, len(nums)-1
        while lo <= hi:
            mid = lo + hi >> 1
            if nums[mid] == target: return mid
            if nums[lo] <= nums[mid]:
                if nums[lo] <= target < nums[mid]: hi = mid - 1
                else: lo = mid + 1
            else:
                if nums[mid] < target <= nums[hi]: lo = mid + 1
                else: hi = mid - 1
        return -1


    """34. Find First and Last Position of Element in Sorted Array (Medium)
    Given an array of integers nums sorted in ascending order, find the
    starting and ending position of a given target value. Your algorithm's
    runtime complexity must be in the order of O(log n). If the target is not
    found in the array, return [-1, -1].

    Example 1:
    Input: nums = [5,7,7,8,8,10], target = 8
    Output: [3,4]

    Example 2:
    Input: nums = [5,7,7,8,8,10], target = 6
    Output: [-1,-1]"""

    def searchRange(self, nums: List[int], target: int) -> List[int]:
        lo = bisect_left(nums, target)
        hi = bisect_left(nums, target+1)-1
        return [lo, hi] if lo < len(nums) and nums[lo] == target else [-1, -1]


    """35. Search Insert Position (Easy)
    Given a sorted array and a target value, return the index if the target is
    found. If not, return the index where it would be if it were inserted in
    order. You may assume no duplicates in the array.

    Example 1:
    Input: [1,3,5,6], 5
    Output: 2

    Example 2:
    Input: [1,3,5,6], 2
    Output: 1

    Example 3:
    Input: [1,3,5,6], 7
    Output: 4

    Example 4:
    Input: [1,3,5,6], 0
    Output: 0"""

    def searchInsert(self, nums: List[int], target: int) -> int:
        lo, hi = 0, len(nums)
        while lo < hi:
            mid = (lo + hi)//2
            if nums[mid] < target: lo = mid + 1
            else: hi = mid
        return lo


    """36. Valid Sudoku (Medium)
    Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be
    validated according to the following rules:

    + Each row must contain the digits 1-9 without repetition.
    + Each column must contain the digits 1-9 without repetition.
    + Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9
    without repetition.

    A partially filled sudoku which is valid. The Sudoku board could be
    partially filled, where empty cells are filled with the character '.'.

    Example 1:
    Input:
    [
      ["5","3",".",".","7",".",".",".","."],
      ["6",".",".","1","9","5",".",".","."],
      [".","9","8",".",".",".",".","6","."],
      ["8",".",".",".","6",".",".",".","3"],
      ["4",".",".","8",".","3",".",".","1"],
      ["7",".",".",".","2",".",".",".","6"],
      [".","6",".",".",".",".","2","8","."],
      [".",".",".","4","1","9",".",".","5"],
      [".",".",".",".","8",".",".","7","9"]
    ]
    Output: true

    Example 2:
    Input:
    [
      ["8","3",".",".","7",".",".",".","."],
      ["6",".",".","1","9","5",".",".","."],
      [".","9","8",".",".",".",".","6","."],
      ["8",".",".",".","6",".",".",".","3"],
      ["4",".",".","8",".","3",".",".","1"],
      ["7",".",".",".","2",".",".",".","6"],
      [".","6",".",".",".",".","2","8","."],
      [".",".",".","4","1","9",".",".","5"],
      [".",".",".",".","8",".",".","7","9"]
    ]
    Output: false

    Explanation: Same as Example 1, except with the 5 in the top left corner
    being modified to 8. Since there are two 8's in the top left 3x3 sub-box,
    it is invalid.

    Note:
    A Sudoku board (partially filled) could be valid but is not necessarily
    solvable. Only the filled cells need to be validated according to the
    mentioned rules. The given board contain only digits 1-9 and the character
    '.'. The given board size is always 9x9."""

    def isValidSudoku(self, board: List[List[str]]) -> bool:
        seen = set()
        for i in range(9):
            for j in range(9):
                if board[i][j] != ".":
                    cand = {(i, board[i][j]), (board[i][j], j), (i//3, j//3, board[i][j])}
                    if seen & cand: return False
                    seen |= cand
        return True


    """37. Sudoku Solver (Hard)
    Write a program to solve a Sudoku puzzle by filling the empty cells. A
    sudoku solution must satisfy all of the following rules:

    Each of the digits 1-9 must occur exactly once in each row.
    Each of the digits 1-9 must occur exactly once in each column.
    Each of the the digits 1-9 must occur exactly once in each of the 9 3x3
    sub-boxes of the grid.

    Empty cells are indicated by the character '.'.

    Note:
    The given board contain only digits 1-9 and the character '.'.
    You may assume that the given Sudoku puzzle will have a single unique solution.
    The given board size is always 9x9."""

    def solveSudoku(self, board: List[List[str]]) -> None:
        empty = []
        seen = set()
        for i in range(9):
            for j in range(9):
                if board[i][j] == ".": empty.append((i, j))
                else: seen |= {(i, board[i][j]), (board[i][j], j), (i//3, board[i][j], j//3)}

        def fn(k, seen):
            """Return True if Sudoku is filled properly (for early termination)"""
            if k == len(empty): return True
            i, j = empty[k]
            for x in "123456789":
                if seen & {(i, x), (x, j), (i//3, x, j//3)}: continue
                seen |= {(i, x), (x, j), (i//3, x, j//3)}
                board[i][j] = x
                if fn(k+1, seen): return True
                seen -= {(i, x), (x, j), (i//3, x, j//3)}

        fn(0, seen)


    """38. Count and Say (Easy)
    The count-and-say sequence is the sequence of integers with the first five
    terms as following:

    1.     1
    2.     11
    3.     21
    4.     1211
    5.     111221
    1 is read off as "one 1" or 11.
    11 is read off as "two 1s" or 21.
    21 is read off as "one 2, then one 1" or 1211.

    Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-
    and-say sequence. You can do so recursively, in other words from the
    previous member read off the digits, counting the number of digits in
    groups of the same digit.

    Note: Each term of the sequence of integers will be represented as a string.

    Example 1:
    Input: 1
    Output: "1"
    Explanation: This is the base case.

    Example 2:
    Input: 4
    Output: "1211"
    Explanation: For n = 3 the term was "21" in which we have two groups "2"
    and "1", "2" can be read as "12" which means frequency = 1 and value = 2,
    the same way "1" is read as "11", so the answer is the concatenation of
    "12" and "11" which is "1211"."""

    def countAndSay(self, n: int) -> str:
        if n == 1: return "1"
        return "".join(str(len(list(v))) + g for g, v in groupby(self.countAndSay(n-1)))


    """39. Combination Sum (Medium)
    Given a set of candidate numbers (candidates) (without duplicates) and a
    target number (target), find all unique combinations in candidates where
    the candidate numbers sums to target. The same repeated number may be
    chosen from candidates unlimited number of times.

    Note:
    All numbers (including target) will be positive integers.
    The solution set must not contain duplicate combinations.

    Example 1:
    Input: candidates = [2,3,6,7], target = 7,
    A solution set is:
    [
      [7],
      [2,2,3]
    ]

    Example 2:
    Input: candidates = [2,3,5], target = 8,
    A solution set is:
    [
      [2,2,2,2],
      [2,3,3],
      [3,5]
    ]"""

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [[] for _ in range(target + 1)]
        dp[0].append([])
        for x in candidates:
            for i in range(target):
                if i+x <= target:
                    for seq in dp[i]: dp[i+x].append(seq + [x])
        return dp[-1]


    """40. Combination Sum II (Medium)
    Given a collection of candidate numbers (candidates) and a target number
    (target), find all unique combinations in candidates where the candidate
    numbers sums to target. Each number in candidates may only be used once in
    the combination.

    Note:
    All numbers (including target) will be positive integers. The solution set
    must not contain duplicate combinations.

    Example 1:
    Input: candidates = [10,1,2,7,6,1,5], target = 8,
    A solution set is:
    [
      [1, 7],
      [1, 2, 5],
      [2, 6],
      [1, 1, 6]
    ]

    Example 2:
    Input: candidates = [2,5,2,1,2], target = 5,
    A solution set is:
    [
      [1,2,2],
      [5]
    ]"""

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        ans = []
        stack = []

        def fn(i, x, prev):
            if x == 0: ans.append(stack.copy())
            elif i < len(candidates):
                if candidates[i] > x: return
                fn(i+1, x, False)
                if i == 0 or candidates[i-1] != candidates[i] or prev:
                    stack.append(candidates[i])
                    fn(i+1, x-candidates[i], True)
                    stack.pop()

        fn(0, target, False)
        return ans


    """41. First Missing Positive (Hard)
    Given an unsorted integer array, find the smallest missing positive integer.

    Example 1:

    Input: [1,2,0]
    Output: 3
    Example 2:

    Input: [3,4,-1,1]
    Output: 2
    Example 3:

    Input: [7,8,9,11,12]
    Output: 1
    Note:

    Your algorithm should run in O(n) time and uses constant extra space."""

    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        for x in nums:
            while 0 < x <= n and nums[x-1] != x:
                nums[x-1], x = x, nums[x-1]
        return next((i+1 for i, x in enumerate(nums) if i+1 != x), n+1)


    """42. Trapping Rain Water (Hard)
    Given n non-negative integers representing an elevation map where the width
    of each bar is 1, compute how much water it is able to trap after raining.
    The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1].
    In this case, 6 units of rain water (blue section) are being trapped.

    Example:
    Input: [0,1,0,2,1,0,1,3,2,1,2,1]
    Output: 6"""

    def trap(self, height: List[int]) -> int:
        ans = val = 0
        lo, hi = 0, len(height)-1
        while lo < hi:
            if height[lo] <= height[hi]:
                val = max(val, height[lo])
                ans += val - height[lo]
                lo += 1
            else:
                val = max(val, height[hi])
                ans += val - height[hi]
                hi -= 1
        return ans


    """43. Multiply Strings (Medium)
    Given two non-negative integers num1 and num2 represented as strings,
    return the product of num1 and num2, also represented as a string.

    Example 1:
    Input: num1 = "2", num2 = "3"
    Output: "6"

    Example 2:
    Input: num1 = "123", num2 = "456"
    Output: "56088"

    Note:
    + The length of both num1 and num2 is < 110.
    + Both num1 and num2 contain only digits 0-9.
    + Both num1 and num2 do not contain any leading zero, except the number 0
      itself.
    + You must not use any built-in BigInteger library or convert the inputs to
      integer directly."""

    def multiply(self, num1: str, num2: str) -> str:
        ans = [0]*(len(num1) + len(num2))
        for i, x in enumerate(num1):
            for j, y in enumerate(num2):
                carry = (ord(x)-48) * (ord(y)-48)
                k = i+j+1
                while carry:
                    carry, ans[k] = divmod(carry + ans[k], 10)
                    k -= 1
        return "".join(map(str, ans)).lstrip("0") or "0"


    """44. Wildcard Matching (Hard)
    Given an input string (s) and a pattern (p), implement wildcard pattern
    matching with support for '?' and '*'.

    '?' Matches any single character.
    '*' Matches any sequence of characters (including the empty sequence).
    The matching should cover the entire input string (not partial).

    Note:
    s could be empty and contains only lowercase letters a-z.
    p could be empty and contains only lowercase letters a-z, and characters
    like ? or *.

    Example 1:
    Input:
    s = "aa"
    p = "a"
    Output: false
    Explanation: "a" does not match the entire string "aa".

    Example 2:
    Input:
    s = "aa"
    p = "*"
    Output: true
    Explanation: '*' matches any sequence.

    Example 3:
    Input:
    s = "cb"
    p = "?a"
    Output: false
    Explanation: '?' matches 'c', but the second letter is 'a', which does not
    match 'b'.

    Example 4:
    Input:
    s = "adceb"
    p = "*a*b"
    Output: true
    Explanation: The first '*' matches the empty sequence, while the second '*'
    matches the substring "dce".

    Example 5:
    Input:
    s = "acdcb"
    p = "a*c?b"
    Output: false"""

    def isMatch(self, s: str, p: str) -> bool:

        @cache
        def fn(i, j):
            """Return True if s[i:] matches p[j:]"""
            if j == len(p): return i == len(s)
            if i < len(s) and (s[i] == p[j] or p[j] == "?"): return fn(i+1, j+1)
            if p[j] == "*": return fn(i, j+1) or i < len(s) and fn(i+1, j)
            return False

        return fn(0, 0)


    """45. Jump Game II (Hard)
    Given an array of non-negative integers, you are initially positioned at
    the first index of the array. Each element in the array represents your
    maximum jump length at that position. Your goal is to reach the last index
    in the minimum number of jumps.

    Example:
    Input: [2,3,1,1,4]
    Output: 2
    Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.

    Note: You can assume that you can always reach the last index."""

    def jump(self, nums: List[int]) -> int:
        ans = prev = curr = 0
        for i, x in enumerate(nums):
            if prev < i:
                ans += 1
                prev = curr
            curr = max(curr, i + x)
        return ans


    """46. Permutations (Medium)
    Given a collection of distinct integers, return all possible permutations.

    Example:
    Input: [1,2,3]
    Output:
    [
      [1,2,3],
      [1,3,2],
      [2,1,3],
      [2,3,1],
      [3,1,2],
      [3,2,1]
    ]"""

    def permute(self, nums: List[int]) -> List[List[int]]:

        def fn(i):
            """Heap's algo (1963)"""
            if i == len(nums): ans.append(nums.copy())
            for k in reversed(range(i, len(nums))):
                fn(i+1)
                if (len(nums)-i) & 1: nums[i], nums[-1] = nums[-1], nums[i]
                else: nums[i], nums[k] = nums[k], nums[i]

        ans = []
        fn(0)
        return ans


    """47. Permutations II (Medium)
    Given a collection of numbers that might contain duplicates, return all
    possible unique permutations.

    Example:
    Input: [1,1,2]
    Output:
    [
      [1,1,2],
      [1,2,1],
      [2,1,1]
    ]"""

    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()

        def fn(i):
            """Backtracking to get permutations (not Heap's algo)"""
            if i == len(nums): ans.append(nums.copy())
            seen = set()
            for k in range(i, len(nums)):
                if nums[k] not in seen:
                    seen.add(nums[k])
                    nums[i], nums[k] = nums[k], nums[i]
                    fn(i+1)
                    nums[i], nums[k] = nums[k], nums[i]

        ans = []
        fn(0)
        return ans

    """48. Rotate Image (Medium)
    You are given an n x n 2D matrix representing an image. Rotate the image by
    90 degrees (clockwise).

    Note:
    You have to rotate the image in-place, which means you have to modify the
    input 2D matrix directly. DO NOT allocate another 2D matrix and do the
    rotation.

    Example 1:
    Given input matrix =
    [
      [1,2,3],
      [4,5,6],
      [7,8,9]
    ],
    rotate the input matrix in-place such that it becomes:
    [
      [7,4,1],
      [8,5,2],
      [9,6,3]
    ]

    Example 2:
    Given input matrix =
    [
      [ 5, 1, 9,11],
      [ 2, 4, 8,10],
      [13, 3, 6, 7],
      [15,14,12,16]
    ],
    rotate the input matrix in-place such that it becomes:
    [
      [15,13, 2, 5],
      [14, 3, 4, 1],
      [12, 6, 8, 9],
      [16, 7,10,11]
    ]"""

    def rotate(self, matrix: List[List[int]]) -> None:
        matrix[:] = list(zip(*matrix[::-1]))


    """49. Group Anagrams (Medium)
    Given an array of strings, group anagrams together.

    Example:
    Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
    Output:
    [
      ["ate","eat","tea"],
      ["nat","tan"],
      ["bat"]
    ]

    Note:
    All inputs will be in lowercase.
    The order of your output does not matter."""

    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = {}
        for word in strs:
            mp.setdefault("".join(sorted(word)), []).append(word)
        return mp.values()


    """50. Pow(x, n) (Medium)
    Implement pow(x, n), which calculates x raised to the power n (x^n).

    Example 1:
    Input: 2.00000, 10
    Output: 1024.00000

    Example 2:
    Input: 2.10000, 3
    Output: 9.26100

    Example 3:
    Input: 2.00000, -2
    Output: 0.25000
    Explanation: 2-2 = 1/22 = 1/4 = 0.25

    Note:
    -100.0 < x < 100.0
    n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1]"""

    def myPow(self, x: float, n: int) -> float:
        if n < 0: x, n = 1/x, -n
        ans = 1
        while n:
            if n & 1: ans *= x
            x, n = x*x, n//2
        return ans


    """51. N-Queens (Hard)
    The n-queens puzzle is the problem of placing n queens on an n×n chessboard
    such that no two queens attack each other. Given an integer n, return all
    distinct solutions to the n-queens puzzle. Each solution contains a
    distinct board configuration of the n-queens' placement, where 'Q' and '.'
    both indicate a queen and an empty space respectively.

    Example:
    Input: 4
    Output: [
     [".Q..",  // Solution 1
      "...Q",
      "Q...",
      "..Q."],

     ["..Q.",  // Solution 2
      "Q...",
      "...Q",
      ".Q.."]
    ]
    Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above."""

    def solveNQueens(self, n: int) -> List[List[str]]:
        board = [["."]*n for _ in range(n)]

        def fn(i, seen):
            """Recursively populate the n queens via backtracking."""
            if i == n: return ans.append(["".join(x) for x in board])
            for j in range(n):
                pos = {("col", j), ("diag", i-j), ("anti", i+j)}
                if not pos & seen:
                    board[i][j] = "Q"
                    seen |= pos
                    fn(i+1, seen)
                    board[i][j] = "."
                    seen -= pos

        ans = []
        fn(0, set())
        return ans


    """52. N-Queens II (Hard)
    The n-queens puzzle is the problem of placing n queens on an n×n chessboard
    such that no two queens attack each other. Given an integer n, return the
    number of distinct solutions to the n-queens puzzle.

    Example:
    Input: 4
    Output: 2
    Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.
    [
     [".Q..",  // Solution 1
      "...Q",
      "Q...",
      "..Q."],

     ["..Q.",  // Solution 2
      "Q...",
      "...Q",
      ".Q.."]
    ]"""

    def totalNQueens(self, n: int) -> int:

        def fn(i, seen=set(), ans=0):
            """Return the number of solutions"""
            if i == n: ans += 1
            for j in range(n):
                place = {("col", j), ("diag", i-j), ("anti", i+j)}
                if not (place & seen):
                    seen |= place
                    ans = fn(i+1, seen, ans)
                    seen -= place
            return ans

        return fn(0)


    """53. Maximum Subarray (Easy)
    Given an integer array nums, find the contiguous subarray (containing at
    least one number) which has the largest sum and return its sum.

    Example:

    Input: [-2,1,-3,4,-1,2,1,-5,4],
    Output: 6
    Explanation: [4,-1,2,1] has the largest sum = 6.

    Follow up: If you have figured out the O(n) solution, try coding another
    solution using the divide and conquer approach, which is more subtle."""

    def maxSubArray(self, nums: List[int]) -> int:
        ans, val = float("-inf"), 0
        for x in nums:
            val = max(0, val) + x
            ans = max(ans, val)
        return ans


    """54. Spiral Matrix (Medium)
    Given a matrix of m x n elements (m rows, n columns), return all elements
    of the matrix in spiral order.

    Example 1:
    Input: [[ 1, 2, 3 ],
            [ 4, 5, 6 ],
            [ 7, 8, 9 ]]
    Output: [1,2,3,6,9,8,7,4,5]

    Example 2:
    Input: [[1, 2, 3, 4],
            [5, 6, 7, 8],
            [9,10,11,12]]
    Output: [1,2,3,4,8,12,11,10,9,5,6,7]"""

    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        m, n = len(matrix), len(matrix[0])
        ans = []
        i = j = 0 # position
        di, dj = 0, 1 # direction
        for _ in range(m*n):
            ans.append(matrix[i][j])
            matrix[i][j] = None # mark "visited"
            if not (0 <= i+di < m and 0 <= j+dj < n and matrix[i+di][j+dj] is not None):
                di, dj = dj, -di # rotate clockwise
            i += di
            j += dj
        return ans


    """55. Jump Game (Medium)
    Given an array of non-negative integers, you are initially positioned at
    the first index of the array. Each element in the array represents your
    maximum jump length at that position. Determine if you are able to reach
    the last index.

    Example 1:
    Input: nums = [2,3,1,1,4]
    Output: true
    Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

    Example 2:
    Input: nums = [3,2,1,0,4]
    Output: false
    Explanation: You will always arrive at index 3 no matter what. Its maximum
    jump length is 0, which makes it impossible to reach the last index.

    Constraints:
    1 <= nums.length <= 3 * 10^4
    0 <= nums[i][j] <= 10^5"""

    def canJump(self, nums: List[int]) -> bool:
        hi = 0
        for i, x in enumerate(nums):
            if hi < i: return False
            hi = max(hi, i + x)
        return True


    """56. Merge Intervals (Medium)
    Given a collection of intervals, merge all overlapping intervals.

    Example 1:
    Input: [[1,3],[2,6],[8,10],[15,18]]
    Output: [[1,6],[8,10],[15,18]]
    Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into
    [1,6].

    Example 2:
    Input: [[1,4],[4,5]]
    Output: [[1,5]]
    Explanation: Intervals [1,4] and [4,5] are considered overlapping.

    NOTE: input types have been changed on April 15, 2019. Please reset to
    default code definition to get new method signature."""

    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        ans = []
        for x, y in sorted(intervals, key=lambda x: x[1]):
            while ans and x <= ans[-1][1]: x = min(x, ans.pop()[0])
            ans.append([x, y])
        return ans


    """57. Insert Interval (Hard)
    Given a set of non-overlapping intervals, insert a new interval into the
    intervals (merge if necessary). You may assume that the intervals were
    initially sorted according to their start times.

    Example 1:
    Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
    Output: [[1,5],[6,9]]

    Example 2:
    Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
    Output: [[1,2],[3,10],[12,16]]
    Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].

    NOTE: input types have been changed on April 15, 2019. Please reset to
    default code definition to get new method signature."""

    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        ans = []
        for i, interval in enumerate(intervals):
            if interval[1] < newInterval[0]: ans.append(interval)
            elif not (newInterval[1] < interval[0]):
                newInterval[0] = min(newInterval[0], interval[0])
                newInterval[1] = max(newInterval[1], interval[1])
            else:
                ans.append(newInterval)
                return ans + intervals[i:]
        return ans + [newInterval]


    """58. Length of Last Word (Easy)
    Given a string s consisting of words and spaces, return the length of the
    last word in the string. A word is a maximal substring consisting of non-
    space characters only.

    Example 1:
    Input: s = "Hello World"
    Output: 5
    Explanation: The last word is "World" with length 5.

    Example 2:
    Input: s = "   fly me   to   the moon  "
    Output: 4
    Explanation: The last word is "moon" with length 4.

    Example 3:
    Input: s = "luffy is still joyboy"
    Output: 6
    Explanation: The last word is "joyboy" with length 6.

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of only English letters and spaces ' '.
    * There will be at least one word in s."""

    def lengthOfLastWord(self, s: str) -> int:
        return len(s.split()[-1])


    """59. Spiral Matrix II (Medium)
    Given a positive integer n, generate a square matrix filled with elements
    from 1 to n2 in spiral order.

    Example:
    Input: 3
    Output:
    [
     [ 1, 2, 3 ],
     [ 8, 9, 4 ],
     [ 7, 6, 5 ]
    ]"""

    def generateMatrix(self, n: int) -> List[List[int]]:
        ans = [[0]*n for _ in range(n)]
        i = j = 0
        di, dj = 0, 1
        for v in range(n*n):
            ans[i][j] = v+1
            if ans[(i+di)%n][(j+dj)%n]: di, dj = dj, -di
            i, j = i+di, j+dj
        return ans


    """60. Permutation Sequence (Medium)
    The set [1,2,3,...,n] contains a total of n! unique permutations. By
    listing and labeling all of the permutations in order, we get the following
    sequence for n = 3:

    "123"
    "132"
    "213"
    "231"
    "312"
    "321"

    Given n and k, return the kth permutation sequence.

    Note:
    Given n will be between 1 and 9 inclusive.
    Given k will be between 1 and n! inclusive.

    Example 1:
    Input: n = 3, k = 3
    Output: "213"

    Example 2:
    Input: n = 4, k = 9
    Output: "2314" """

    def getPermutation(self, n: int, k: int) -> str:
        k -= 1
        ans, digits = [], list(range(1, n+1))
        for i in range(n):
            d, k = divmod(k, factorial(n-i-1))
            ans.append(digits.pop(d))
        return "".join(str(x) for x in ans)


    """61. Rotate List (Medium)
    Given a linked list, rotate the list to the right by k places, where k is
    non-negative.

    Example 1:
    Input: 1->2->3->4->5->NULL, k = 2
    Output: 4->5->1->2->3->NULL
    Explanation:
    rotate 1 steps to the right: 5->1->2->3->4->NULL
    rotate 2 steps to the right: 4->5->1->2->3->NULL

    Example 2:
    Input: 0->1->2->NULL, k = 4
    Output: 2->0->1->NULL
    Explanation:
    rotate 1 steps to the right: 2->0->1->NULL
    rotate 2 steps to the right: 1->2->0->NULL
    rotate 3 steps to the right: 0->1->2->NULL
    rotate 4 steps to the right: 2->0->1->NULL"""

    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if not head: return None

        n, node = 0, head
        while node: n, node = n+1, node.next

        k %= n
        if k:
            fast = slow = head
            while fast.next:
                if k == 0: slow = slow.next
                else: k -= 1
                fast = fast.next
            head, fast.next, slow.next = slow.next, head, None
        return head


    """62. Unique Paths (Medium)
    A robot is located at the top-left corner of a m x n grid (marked 'Start'
    in the diagram below). The robot can only move either down or right at any
    point in time. The robot is trying to reach the bottom-right corner of the
    grid (marked 'Finish' in the diagram below). How many possible unique paths
    are there?

    Example 1:
    Input: m = 3, n = 2
    Output: 3
    Explanation:
    From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
    1. Right -> Right -> Down
    2. Right -> Down -> Right
    3. Down -> Right -> Right

    Example 2:
    Input: m = 7, n = 3
    Output: 28

    Constraints:
    1 <= m, n <= 100
    It's guaranteed that the answer will be less than or equal to 2 * 10 ^ 9."""

    def uniquePaths(self, m: int, n: int) -> int:

        def choose(n, k):
            """Return n choose k"""
            ans = 1
            for i in range(min(k, n-k)):
                ans *= n-i
                ans //= i+1
            return ans

        return choose(m+n-2, m-1)


    """63. Unique Paths II (Medium)
    A robot is located at the top-left corner of a m x n grid (marked 'Start'
    in the diagram below). The robot can only move either down or right at any
    point in time. The robot is trying to reach the bottom-right corner of the
    grid (marked 'Finish' in the diagram below). Now consider if some obstacles
    are added to the grids. How many unique paths would there be? An obstacle
    and empty space is marked as 1 and 0 respectively in the grid.

    Note: m and n will be at most 100.

    Example 1:
    Input:
    [
      [0,0,0],
      [0,1,0],
      [0,0,0]
    ]
    Output: 2
    Explanation:
    There is one obstacle in the middle of the 3x3 grid above.
    There are two ways to reach the bottom-right corner:
    1. Right -> Right -> Down -> Down
    2. Down -> Down -> Right -> Right"""

    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [0]*n
        dp[0] = 1
        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j]: dp[j] = 0
                elif j: dp[j] += dp[j-1]
        return dp[-1]


    """64. Minimum Path Sum (Medium)
    Given a m x n grid filled with non-negative numbers, find a path from top
    left to bottom right which minimizes the sum of all numbers along its path.
    Note: You can only move either down or right at any point in time.

    Example:

    Input:
    [
      [1,3,1],
      [1,5,1],
      [4,2,1]
    ]
    Output: 7
    Explanation: Because the path 1→3→1→1→1 minimizes the sum."""

    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = [inf]*n
        ans[0] = 0
        for i in range(m):
            for j in range(n):
                if j: ans[j] = min(ans[j-1], ans[j])
                ans[j] += grid[i][j]
        return ans[-1]


    """65. Valid Number (Hard)
    Validate if a given string can be interpreted as a decimal number.

    Some examples:
    "0"         => true
    " 0.1 "     => true
    "abc"       => false
    "1 a"       => false
    "2e10"      => true
    " -90e3   " => true
    " 1e"       => false
    "e3"        => false
    " 6e-1"     => true
    " 99e2.5 "  => false
    "53.5e93"   => true
    " --6 "     => false
    "-+3"       => false
    "95a54e53"  => false

    Note: It is intended for the problem statement to be ambiguous. You should
    gather all requirements up front before implementing one. However, here is
    a list of characters that can be in a valid decimal number:

    Numbers 0-9
    Exponent - "e"
    Positive/negative sign - "+"/"-"
    Decimal point - "."
    Of course, the context of these characters also matters in the input.

    Update (2015-02-10): The signature of the C++ function had been updated. If
    you still see your function signature accepts a const char * argument,
    please click the reload button to reset your code definition."""

    def isNumber(self, s: str) -> bool:
        dfa = [{'space': 0, 'sign': 1, 'digit': 2, '.': 3}, # state 0 - leading space
               {'digit': 2, '.': 3},                        # state 1 - sign
               {'digit': 2, '.': 4, 'e': 5, 'space': 8},    # state 2 - digit (terminal)
               {'digit': 4},                                # state 3 - dot
               {'digit': 4, 'e': 5, 'space': 8},            # state 4 - digit post dot (terminal)
               {'sign': 6, 'digit': 7},                     # state 5 - exponential
               {'digit': 7},                                # state 6 - sign post exponential
               {'digit': 7, 'space': 8},                    # state 7 - digit post exponential (terminal)
               {'space': 8}]                                # state 8 - trailing space (terminal)

        state = 0
        for c in s.lower():
            if c in "0123456789": c = "digit"
            elif c == " ":  c = "space"
            elif c in "+-": c = "sign"
            if c not in dfa[state]: return False
            state = dfa[state][c]
        return state in [2, 4, 7, 8]


    """66. Plus One (Easy)
    Given a non-empty array of digits representing a non-negative integer, plus
    one to the integer. The digits are stored such that the most significant
    digit is at the head of the list, and each element in the array contain a
    single digit. You may assume the integer does not contain any leading zero,
    except the number 0 itself.

    Example 1:
    Input: [1,2,3]
    Output: [1,2,4]
    Explanation: The array represents the integer 123.

    Example 2:
    Input: [4,3,2,1]
    Output: [4,3,2,2]
    Explanation: The array represents the integer 4321."""

    def plusOne(self, digits: List[int]) -> List[int]:
        carry = 1
        for i in reversed(range(len(digits))):
            carry, digits[i] = divmod(digits[i] + carry, 10)
            if not carry: return digits
        return [carry] + digits


    """67. Add Binary (Easy)
    Given two binary strings, return their sum (also a binary string). The
    input strings are both non-empty and contains only characters 1 or 0.

    Example 1:
    Input: a = "11", b = "1"
    Output: "100"

    Example 2:
    Input: a = "1010", b = "1011"
    Output: "10101"

    Constraints:
    Each string consists only of '0' or '1' characters.
    1 <= a.length, b.length <= 10^4
    Each string is either "0" or doesn't contain any leading zero."""

    def addBinary(self, a: str, b: str) -> str:
        ans = []
        carry = 0
        for x, y in zip_longest(reversed(a), reversed(b), fillvalue='0'):
            if x == '1': carry += 1
            if y == '1': carry += 1
            carry, d = divmod(carry, 2)
            ans.append(d)
        if carry: ans.append(carry)
        return ''.join(map(str, reversed(ans)))


    """68. Text Justification (Hard)
    Given an array of words and a width maxWidth, format the text such that
    each line has exactly maxWidth characters and is fully (left and right)
    justified. You should pack your words in a greedy approach; that is, pack
    as many words as you can in each line. Pad extra spaces ' ' when necessary
    so that each line has exactly maxWidth characters. Extra spaces between
    words should be distributed as evenly as possible. If the number of spaces
    on a line do not divide evenly between words, the empty slots on the left
    will be assigned more spaces than the slots on the right. For the last line
    of text, it should be left justified and no extra space is inserted between
    words.

    Note:
    A word is defined as a character sequence consisting of non-space
    characters only. Each word's length is guaranteed to be greater than 0 and
    not exceed maxWidth. The input array words contains at least one word.

    Example 1:
    Input:
    words = ["This", "is", "an", "example", "of", "text", "justification."]
    maxWidth = 16
    Output:
    [
       "This    is    an",
       "example  of text",
       "justification.  "
    ]

    Example 2:
    Input:
    words = ["What","must","be","acknowledgment","shall","be"]
    maxWidth = 16
    Output:
    [
      "What   must   be",
      "acknowledgment  ",
      "shall be        "
    ]
    Explanation: Note that the last line is "shall be    " instead of "shall     be",
                 because the last line must be left-justified instead of fully-justified.
                 Note that the second line is also left-justified becase it contains only one word.

    Example 3:
    Input:
    words = ["Science","is","what","we","understand","well","enough","to","explain",
             "to","a","computer.","Art","is","everything","else","we","do"]
    maxWidth = 20
    Output:
    [
      "Science  is  what we",
      "understand      well",
      "enough to explain to",
      "a  computer.  Art is",
      "everything  else  we",
      "do                  "
    ]"""

    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        ans = []
        line, width = [], 0

        for word in words:
            if width + len(line) + len(word) > maxWidth:
                n, k = divmod(maxWidth - width, max(1, len(line)-1))
                for i in range(max(1, len(line)-1)):
                    line[i] += " " * (n + (i < k))
                ans.append("".join(line))
                line, width = [], 0
            line.append(word)
            width += len(word)

        ans.append(" ".join(line).ljust(maxWidth))
        return ans


    """69. Sqrt(x) (Easy)
    Given a non-negative integer x, return the square root of x rounded down to
    the nearest integer. The returned integer should be non-negative as well.
    You must not use any built-in exponent function or operator. For example,
    do not use pow(x, 0.5) in c++ or x ** 0.5 in python.

    Example 1:
    Input: x = 4
    Output: 2
    Explanation: The square root of 4 is 2, so we return 2.

    Example 2:
    Input: x = 8
    Output: 2
    Explanation: The square root of 8 is 2.82842..., and since we round it down
                 to the nearest integer, 2 is returned.

    Constraints: 0 <= x <= 2^31 - 1"""

    def mySqrt(self, x: int) -> int:
        ans = x
        while ans*ans > x:
            ans = (ans + x//ans)//2
        return ans


    """70. Climbing Stairs (Easy)
    You are climbing a staircase. It takes n steps to reach the top. Each time
    you can either climb 1 or 2 steps. In how many distinct ways can you climb
    to the top?

    Example 1:
    Input: n = 2
    Output: 2
    Explanation: There are two ways to climb to the top.
                 1. 1 step + 1 step
                 2. 2 steps

    Example 2:
    Input: n = 3
    Output: 3
    Explanation: There are three ways to climb to the top.
                 1. 1 step + 1 step + 1 step
                 2. 1 step + 2 steps
                 3. 2 steps + 1 step

    Constraints: 1 <= n <= 45"""

    def climbStairs(self, n: int) -> int:
        f0 = f1 = 1
        for _ in range(n-1): f0, f1 = f1, f0+f1
        return f1


    """71. Simplify Path (Medium)
    Given an absolute path for a file (Unix-style), simplify it. Or in other
    words, convert it to the canonical path. In a UNIX-style file system, a
    period . refers to the current directory. Furthermore, a double period ..
    moves the directory up a level. Note that the returned canonical path must
    always begin with a slash /, and there must be only a single slash /
    between two directory names. The last directory name (if it exists) must
    not end with a trailing /. Also, the canonical path must be the shortest
    string representing the absolute path.

    Example 1:
    Input: "/home/"
    Output: "/home"
    Explanation: Note that there is no trailing slash after the last directory
                 name.

    Example 2:
    Input: "/../"
    Output: "/"
    Explanation: Going one level up from the root directory is a no-op, as the
                 root level is the highest level you can go.

    Example 3:
    Input: "/home//foo/"
    Output: "/home/foo"
    Explanation: In the canonical path, multiple consecutive slashes are
                 replaced by a single one.

    Example 4:
    Input: "/a/./b/../../c/"
    Output: "/c"

    Example 5:
    Input: "/a/../../b/../c//.//"
    Output: "/c"

    Example 6:
    Input: "/a//b////c/d//././/.."
    Output: "/a/b/c" """

    def simplifyPath(self, path: str) -> str:
        stack = []
        for x in path.split('/'):
            if x == '..':
                if stack: stack.pop()
            elif x and x != '.': stack.append(x)
        return "/" + '/'.join(stack)


    """72. Edit Distance (Hard)
    Given two words word1 and word2, find the minimum number of operations
    required to convert word1 to word2. You have the following 3 operations
    permitted on a word:
    - Insert a character
    - Delete a character
    - Replace a character

    Example 1:
    Input: word1 = "horse", word2 = "ros"
    Output: 3
    Explanation:
    horse -> rorse (replace 'h' with 'r')
    rorse -> rose (remove 'r')
    rose -> ros (remove 'e')

    Example 2:
    Input: word1 = "intention", word2 = "execution"
    Output: 5
    Explanation:
    intention -> inention (remove 't')
    inention -> enention (replace 'i' with 'e')
    enention -> exention (replace 'n' with 'x')
    exention -> exection (replace 'n' with 'c')
    exection -> execution (insert 'u')"""

    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        dp = [n-j for j in range(n+1)]
        for i in reversed(range(m)):
            prev = dp[n]
            dp[n] += 1
            for j in reversed(range(n)):
                curr = dp[j]
                if word1[i] == word2[j]: dp[j] = prev
                else: dp[j] = 1 + min(dp[j], dp[j+1], prev)
                prev = curr
        return dp[0]


    """73. Set Matrix Zeroes (Medium)
    Given a m x n matrix, if an element is 0, set its entire row and column to
    0. Do it in-place.

    Example 1:
    Input:
    [
      [1,1,1],
      [1,0,1],
      [1,1,1]
    ]
    Output:
    [
      [1,0,1],
      [0,0,0],
      [1,0,1]
    ]

    Example 2:
    Input:
    [
      [0,1,2,0],
      [3,4,5,2],
      [1,3,1,5]
    ]
    Output:
    [
      [0,0,0,0],
      [0,4,5,0],
      [0,3,1,0]
    ]

    Follow up:
    A straight forward solution using O(mn) space is probably a bad idea. A
    simple improvement uses O(m + n) space, but still not the best solution.
    Could you devise a constant space solution?"""

    def setZeroes(self, matrix: List[List[int]]) -> None:
        m, n = len(matrix), len(matrix[0])
        zero = False

        for i in range(m):
            if not matrix[i][0]: zero = True
            for j in range(1, n):
                if not matrix[i][j]: matrix[i][0] = matrix[0][j] = 0

        for i in reversed(range(m)):
            for j in reversed(range(1, n)):
                if not matrix[i][0] or not matrix[0][j]: matrix[i][j] = 0
            if zero: matrix[i][0] = 0


    """74. Search a 2D Matrix (Medium)
    Write an efficient algorithm that searches for a value in an m x n matrix.
    This matrix has the following properties:
    - Integers in each row are sorted from left to right.
    - The first integer of each row is greater than the last integer of the
    previous row.

    Example 1:
    Input:
    matrix = [
      [1,   3,  5,  7],
      [10, 11, 16, 20],
      [23, 30, 34, 50]
    ]
    target = 3
    Output: true

    Example 2:
    Input:
    matrix = [
      [1,   3,  5,  7],
      [10, 11, 16, 20],
      [23, 30, 34, 50]
    ]
    target = 13
    Output: false"""

    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        lo, hi = 0, m*n
        while lo < hi:
            mid = lo + hi >> 1
            i, j = divmod(mid, n)
            if matrix[i][j] < target: lo = mid + 1
            elif matrix[i][j] == target: return True
            else: hi = mid
        return False


    """75. Sort Colors (Medium)
    Given an array with n objects colored red, white or blue, sort them in-
    place so that objects of the same color are adjacent, with the colors in
    the order red, white and blue. Here, we will use the integers 0, 1, and 2
    to represent the color red, white, and blue respectively.

    Note: You are not suppose to use the library's sort function for this problem.

    Example:
    Input: [2,0,2,1,1,0]
    Output: [0,0,1,1,2,2]
    Follow up:

    A rather straight forward solution is a two-pass algorithm using counting
    sort. First, iterate the array counting number of 0's, 1's, and 2's, then
    overwrite array with total number of 0's, then 1's and followed by 2's.
    Could you come up with a one-pass algorithm using only constant space?"""

    def sortColors(self, nums: List[int]) -> None:
        # Dijkstra's 3-way partitioning
        lo, mid, hi = 0, 0, len(nums)-1
        while mid <= hi:
            if nums[mid] == 0:
                nums[lo], nums[mid] = nums[mid], nums[lo]
                lo += 1
                mid += 1
            elif nums[mid] == 1: mid += 1
            else:
                nums[hi], nums[mid] = nums[mid], nums[hi]
                hi -= 1


    """76. Minimum Window Substring (Hard)
    Given a string S and a string T, find the minimum window in S which will
    contain all the characters in T in complexity O(n).

    Example:
    Input: S = "ADOBECODEBANC", T = "ABC"
    Output: "BANC"
    Note:

    If there is no such window in S that covers all characters in T, return the
    empty string "". If there is such window, you are guaranteed that there
    will always be only one unique minimum window in S."""

    def minWindow(self, s: str, t: str) -> str:
        freq = dict()
        for c in t: freq[c] = 1 + freq.get(c, 0) #target freq table

        count = ii = jj = 0
        queue, ts = deque(), set(t)
        for j, c in enumerate(s):
            if c in ts:
                queue.append((j, c))
                freq[c] -= 1
                if freq[c] == 0: count += 1 #enough c in s
                while count == len(ts):
                    i, c = queue.popleft()
                    if not jj or j - i < jj - ii: ii, jj = i, j+1
                    if freq[c] == 0: count -= 1 #not enough c in s
                    freq[c] += 1
        return s[ii:jj]


    """77. Combinations (Medium)
    Given two integers n and k, return all possible combinations of k numbers
    out of 1 ... n.

    Example:
    Input: n = 4, k = 2
    Output:
    [
      [2,4],
      [3,4],
      [2,3],
      [1,2],
      [1,3],
      [1,4],
    ]"""

    def combine(self, n: int, k: int) -> List[List[int]]:
        ans, stack = [], []
        x = 1
        while True:
            if len(stack) == k: ans.append(stack.copy())
            if len(stack) == k or k - len(stack) > n - x + 1:
                if not stack: break
                x = stack.pop() + 1
            else:
                stack.append(x)
                x += 1
        return ans


    """78. Subsets (Medium)
    Given a set of distinct integers, nums, return all possible subsets (the
    power set). Note that the solution set must not contain duplicate subsets.

    Example:
    Input: nums = [1,2,3]
    Output:
    [
      [3],
      [1],
      [2],
      [1,2,3],
      [1,3],
      [2,3],
      [1,2],
      []
    ]"""

    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        for m in range(1 << len(nums)):
            seq = []
            for i in range(len(nums)):
                if m & 1 << i: seq.append(nums[i])
            ans.append(seq)
        return ans


    """79. Word Search (Medium)
    Given a 2D board and a word, find if the word exists in the grid. The word
    can be constructed from letters of sequentially adjacent cell, where
    "adjacent" cells are those horizontally or vertically neighboring. The same
    letter cell may not be used more than once.

    Example:
    board =
    [
      ['A','B','C','E'],
      ['S','F','C','S'],
      ['A','D','E','E']
    ]

    Given word = "ABCCED", return true.
    Given word = "SEE", return true.
    Given word = "ABCB", return false.

    Constraints:
    board and word consists only of lowercase and uppercase English letters.
    1 <= board.length <= 200
    1 <= board[i].length <= 200
    1 <= word.length <= 10^3"""

    def exist(self, board: List[List[str]], word: str) -> bool:
        m, n = len(board), len(board[0])

        def fn(i, j, k):
            """Return True if a match is found."""
            if k+1 == len(word): return True
            ch = board[i][j]
            board[i][j] = '#'
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and board[ii][jj] == word[k+1] and fn(ii, jj, k+1):
                    return True
            board[i][j] = ch
            return False

        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0] and fn(i, j, 0):
                    return True
        return False


    """80. Remove Duplicates from Sorted Array II (Medium)
    Given a sorted array nums, remove the duplicates in-place such that
    duplicates appeared at most twice and return the new length. Do not
    allocate extra space for another array, you must do this by modifying the
    input array in-place with O(1) extra memory.

    Example 1:
    Given nums = [1,1,1,2,2,3], your function should return length = 5, with
    the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It
    doesn't matter what you leave beyond the returned length.

    Example 2:
    Given nums = [0,0,1,1,1,1,2,3,3], your function should return length = 7,
    with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3
    and 3 respectively. It doesn't matter what values are set beyond the
    returned length.

    Clarification:
    Confused why the returned value is an integer but your answer is an array?
    Note that the input array is passed in by reference, which means
    modification to the input array will be known to the caller as well.

    Internally you can think of this:
    // nums is passed in by reference. (i.e., without making a copy)
    int len = removeDuplicates(nums);

    // any modification to nums in your function would be known by the caller.
    // using the length returned by your function, it prints the first len
    elements.
    for (int i = 0; i < len; i++) {
        print(nums[i]);
    }"""

    def removeDuplicates(self, nums: List[int]) -> int:
        i = 0
        for x in nums:
            if i < 2 or nums[i-2] < x:
                nums[i] = x
                i += 1
        return i


    """81. Search in Rotated Sorted Array II (Medium)
    Suppose an array sorted in ascending order is rotated at some pivot unknown
    to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).
    You are given a target value to search. If found in the array return true,
    otherwise return false.

    Example 1:
    Input: nums = [2,5,6,0,0,1,2], target = 0
    Output: true

    Example 2:
    Input: nums = [2,5,6,0,0,1,2], target = 3
    Output: false

    Follow up: This is a follow up problem to Search in Rotated Sorted Array,
    where nums may contain duplicates. Would this affect the run-time
    complexity? How and why?"""

    def search(self, nums: List[int], target: int) -> bool:
        lo, hi = 0, len(nums)-1
        while lo <= hi:
            mid = lo + hi >> 1
            if nums[mid] == target: return True
            if nums[lo] == nums[mid] == nums[hi]:
                lo += 1
                hi -= 1
            elif nums[lo] <= nums[mid]:
                if nums[lo] <= target < nums[mid]: hi = mid - 1
                else: lo = mid + 1
            else:
                if nums[mid] < target <= nums[hi]: lo = mid + 1
                else: hi = mid - 1
        return False


    """82. Remove Duplicates from Sorted List II (Medium)
    Given a sorted linked list, delete all nodes that have duplicate numbers,
    leaving only distinct numbers from the original list. Return the linked
    list sorted as well.

    Example 1:
    Input: 1->2->3->3->4->4->5
    Output: 1->2->5

    Example 2:
    Input: 1->1->1->2->3
    Output: 2->3"""

    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = node = ListNode(next=head)
        while node and node.next:
            temp = node.next
            while temp and node.next.val == temp.val: temp = temp.next
            if node.next.next == temp: node = node.next
            else: node.next = temp
        return dummy.next


    """83. Remove Duplicates from Sorted List (Easy)
    Given a sorted linked list, delete all duplicates such that each element
    appear only once.

    Example 1:
    Input: 1->1->2
    Output: 1->2

    Example 2:
    Input: 1->1->2->3->3
    Output: 1->2->3"""

    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        while node:
            if node.next and node.val == node.next.val: node.next = node.next.next
            else: node = node.next
        return head


    """84. Largest Rectangle in Histogram (Hard)
    Given n non-negative integers representing the histogram's bar height where
    the width of each bar is 1, find the area of largest rectangle in the
    histogram.

    Example:
    Input: [2,1,5,6,2,3]
    Output: 10"""

    def largestRectangleArea(self, heights: List[int]) -> int:
        ans, stack = 0, [] # non-decreasing stack
        for i in range(len(heights)+1):
            height = heights[i] if i < len(heights) else 0
            while stack and heights[stack[-1]] > height:
                h = heights[stack.pop()]
                w = i - 1 - stack[-1] if stack else i
                ans = max(ans, h*w)
            stack.append(i)
        return ans


    """85. Maximal Rectangle (Hard)
    Given a 2D binary matrix filled with 0's and 1's, find the largest
    rectangle containing only 1's and return its area.

    Example:
    Input:
    [
      ["1","0","1","0","0"],
      ["1","0","1","1","1"],
      ["1","1","1","1","1"],
      ["1","0","0","1","0"]
    ]
    Output: 6"""

    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        ans = 0
        if matrix:
            m, n = len(matrix), len(matrix[0])
            ht, lo, hi = [0]*n, [0]*n, [n]*n
            for i in range(m):
                left, right = 0, n
                for j in range(n):
                    if matrix[i][j] == "1":
                        ht[j] += 1
                        lo[j] = max(lo[j], left)
                    else:
                        ht[j] = lo[j] = 0
                        left = j+1
                    if matrix[i][~j] == "1": hi[~j] = min(hi[~j], right)
                    else:
                        hi[~j] = n
                        right = n-j-1
                ans = max(ans, max((x-y)*h for x, y, h in zip(hi, lo, ht)))
        return ans


    """86. Partition List (Medium)
    Given a linked list and a value x, partition it such that all nodes less
    than x come before nodes greater than or equal to x. You should preserve
    the original relative order of the nodes in each of the two partitions.

    Example:
    Input: head = 1->4->3->2->5->2, x = 3
    Output: 1->2->2->4->3->5"""

    def partition(self, head: ListNode, x: int) -> ListNode:
        dummy1 = node1 = ListNode()
        dummy2 = node2 = ListNode()
        node = head

        while node:
            if node.val < x: node1.next = node1 = node
            else: node2.next = node2 = node
            node = node.next
        node1.next = dummy2.next
        node2.next = None
        return dummy1.next


    """87. Scramble String (Hard)
    Given a string s1, we may represent it as a binary tree by partitioning it
    to two non-empty substrings recursively. Below is one possible
    representation of s1 = "great":

        great
       /    \
      gr    eat
     / \    /  \
    g   r  e   at
               / \
              a   t

    To scramble the string, we may choose any non-leaf node and swap its two
    children. For example, if we choose the node "gr" and swap its two
    children, it produces a scrambled string "rgeat".

        rgeat
       /    \
      rg    eat
     / \    /  \
    r   g  e   at
               / \
              a   t

    We say that "rgeat" is a scrambled string of "great". Similarly, if we
    continue to swap the children of nodes "eat" and "at", it produces a
    scrambled string "rgtae".

        rgtae
       /    \
      rg    tae
     / \    /  \
    r   g  ta  e
           / \
          t   a

    We say that "rgtae" is a scrambled string of "great". Given two strings s1
    and s2 of the same length, determine if s2 is a scrambled string of s1.

    Example 1:
    Input: s1 = "great", s2 = "rgeat"
    Output: true

    Example 2:
    Input: s1 = "abcde", s2 = "caebd"
    Output: false"""

    def isScramble(self, s1: str, s2: str) -> bool:

        def fn(s1, s2):
            """Return True if s1 is a scrambled string of s2"""
            if len(s1) == 1: return s1 == s2
            if sorted(s1) != sorted(s2): return False #160ms -> 50ms
            return any(fn(s1[:i], s2[:i]) and fn(s1[i:], s2[i:]) or fn(s1[:i], s2[-i:]) and fn(s1[i:], s2[:-i]) for i in range(1, len(s1)))

        return fn(s1, s2)


    """88. Merge Sorted Array (Easy)
    Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as
    one sorted array.

    Note:
    The number of elements initialized in nums1 and nums2 are m and n respectively.
    You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.

    Example:
    Input:
    nums1 = [1,2,3,0,0,0], m = 3
    nums2 = [2,5,6],       n = 3
    Output: [1,2,2,3,5,6]"""

    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        while n:
            if m and nums1[m-1] >= nums2[n-1]: nums1[m+n] = nums1[(m:=m-1)]
            else: nums1[m+n] = nums2[(n:=n-1)]


    """89. Gray Code (Medium)
    The gray code is a binary numeral system where two successive values differ
    in only one bit. Given a non-negative integer n representing the total
    number of bits in the code, print the sequence of gray code. A gray code
    sequence must begin with 0.

    Example 1:
    Input: 2
    Output: [0,1,3,2]
    Explanation:
    00 - 0
    01 - 1
    11 - 3
    10 - 2

    For a given n, a gray code sequence may not be uniquely defined. For
    example, [0,2,3,1] is also a valid gray code sequence.

    00 - 0
    10 - 2
    11 - 3
    01 - 1

    Example 2:
    Input: 0
    Output: [0]
    Explanation: We define the gray code sequence to begin with 0. A gray code
    sequence of n has size = 2n, which for n = 0 the size is 20 = 1. Therefore,
    for n = 0 the gray code sequence is [0]."""

    def grayCode(self, n: int) -> List[int]:
        return [i ^ (i>>1) for i in range(1 << n)]


    """90. Subsets II (Medium)
    Given a collection of integers that might contain duplicates, nums, return
    all possible subsets (the power set). Note that the solution set must not
    contain duplicate subsets.

    Example:
    Input: [1,2,2]
    Output:
    [
      [2],
      [1],
      [1,2,2],
      [2,2],
      [1,2],
      []
    ]"""

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = [[]]
        sz = 0
        for i in range(len(nums)):
            if i and nums[i-1] == nums[i]: ii = sz
            else: ii = 0
            sz = len(ans)
            while ii < sz:
                ans.append(ans[ii] + [nums[i]])
                ii += 1
        return ans


    """91. Decode Ways (Medium)
    A message containing letters from A-Z is being encoded to numbers using the
    following mapping:

    'A' -> 1
    'B' -> 2
    ...
    'Z' -> 26

    Given a non-empty string containing only digits, determine the total number
    of ways to decode it.

    Example 1:
    Input: "12"
    Output: 2
    Explanation: It could be decoded as "AB" (1 2) or "L" (12).

    Example 2:
    Input: "226"
    Output: 3
    Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6)."""

    def numDecodings(self, s: str) -> int:
        dp = [0]*(len(s) + 1)
        dp[0] = 1
        for i, x in enumerate(s):
            if x != '0' and dp[i]:
                dp[i+1] += dp[i]
                if i+1 < len(s) and s[i:i+2] <= "26": dp[i+2] += dp[i]
        return dp[-1]


    """92. Reverse Linked List II (Medium)
    Given the head of a singly linked list and two integers left and right
    where left <= right, reverse the nodes of the list from position left to
    position right, and return the reversed list.

    Example 1:
    Input: head = [1,2,3,4,5], left = 2, right = 4
    Output: [1,4,3,2,5]

    Example 2:
    Input: head = [5], left = 1, right = 1
    Output: [5]

    Constraints:
    * The number of nodes in the list is n.
    * 1 <= n <= 500
    * -500 <= Node.val <= 500
    * 1 <= left <= right <= n

    Follow up: Could you do it in one pass?"""

    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        dummy = node = ListNode(next=head)
        prev = None
        for _ in range(left): node, prev = node.next, node
        pp, nn = prev, node
        for _ in range(left, right+1): node.next, node, prev = prev, node.next, node
        pp.next, nn.next = prev, node
        return dummy.next


    """93. Restore IP Addresses (Medium)
    Given a string containing only digits, restore it by returning all possible
    valid IP address combinations. A valid IP address consists of exactly four
    integers (each integer is between 0 and 255) separated by single points.

    Example:
    Input: "25525511135"
    Output: ["255.255.11.135", "255.255.111.35"]"""

    def restoreIpAddresses(self, s: str) -> List[str]:

        def fn(i, n):
            """Populate ans with a stack through backtracking"""
            if not (n <= len(s)-i <= 3*n): return
            if i == len(s): return ans.append(".".join(stack))
            k = i+1 if s[i] == "0" else i+3
            for j in range(i+1, min(k, len(s))+1):
                if j == i+3 and s[i:j] > "255": continue
                stack.append(s[i:j])
                fn(j, n-1)
                stack.pop()

        ans, stack = [], []
        fn(0, 4)
        return ans


    """94. Binary Tree Inorder Traversal (Medium)
    Given a binary tree, return the inorder traversal of its nodes' values.

    Example:
    Input: [1,null,2,3]
       1
        \
         2
        /
       3

    Output: [1,3,2]"""

    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans, stack = [], []
        node = root
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                ans.append(node.val)
                node = node.right
        return ans


    """95. Unique Binary Search Trees II (Medium)
    Given an integer n, generate all structurally unique BST's (binary search
    trees) that store values 1 ... n.

    Example:
    Input: 3
    Output:
    [
      [1,null,3,2],
      [3,2,null,1],
      [3,1,null,null,2],
      [2,1,3],
      [1,null,2,null,3]
    ]
    Explanation:
    The above output corresponds to the 5 unique BST's shown below:

       1         3     3      2      1
        \       /     /      / \      \
         3     2     1      1   3      2
        /     /       \                 \
       2     1         2                 3

    Constraints: 0 <= n <= 8"""

    def generateTrees(self, n: int) -> List[TreeNode]:

        @cache
        def fn(lo, hi):
            """Return root of tree using numbers from lo (inclusive) to hi (exclusive)"""
            if lo == hi: return [None]
            ans = []
            for mid in range(lo, hi):
                for left in fn(lo, mid):
                    for right in fn(mid+1, hi):
                        ans.append(TreeNode(mid, left, right))
            return ans

        return fn(1, n+1)


    """96. Unique Binary Search Trees (Medium)
    Given n, how many structurally unique BST's (binary search trees) that
    store values 1 ... n?

    Example:
    Input: 3
    Output: 5
    Explanation:
    Given n = 3, there are a total of 5 unique BST's:

       1         3     3      2      1
        \       /     /      / \      \
         3     2     1      1   3      2
        /     /       \                 \
       2     1         2                 3"""

    def numTrees(self, n: int) -> int:
        # Catalan number
        ans = 1
        for i in range(n):
            ans *= 2*n-i
            ans //= i+1
        return ans//(n+1)


    """97. Interleaving String (Hard)
    Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and
    s2.

    Example 1:
    Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
    Output: true

    Example 2:
    Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
    Output: false"""

    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        if len(s1) + len(s2) != len(s3): return False

        dp = [False]*len(s2) + [True]
        for i in reversed(range(len(s1)+1)):
            for j in reversed(range(len(s2)+1)):
                if i < len(s1): dp[j] = (dp[j] and s1[i] == s3[i+j])
                if j < len(s2): dp[j] = dp[j] or (dp[j+1] and s2[j] == s3[i+j])
        return dp[0]


    """98. Validate Binary Search Tree (Medium)
    Given a binary tree, determine if it is a valid binary search tree (BST).
    Assume a BST is defined as follows: The left subtree of a node contains
    only nodes with keys less than the node's key. The right subtree of a node
    contains only nodes with keys greater than the node's key. Both the left
    and right subtrees must also be binary search trees.

    Example 1:

        2
       / \
      1   3

    Input: [2,1,3]
    Output: true

    Example 2:

        5
       / \
      1   4
         / \
        3   6

    Input: [5,1,4,null,null,3,6]
    Output: false
    Explanation: The root node's value is 5 but its right child's value is 4."""

    def isValidBST(self, root: TreeNode) -> bool:
        stack = [(root, -inf, inf)]
        while stack:
            node, lo, hi = stack.pop()
            if lo < node.val < hi:
                if node.left: stack.append((node.left, lo, node.val))
                if node.right: stack.append((node.right, node.val, hi))
            else: return False
        return True


    """99. Recover Binary Search Tree (Hard)
    Two elements of a binary search tree (BST) are swapped by mistake. Recover
    the tree without changing its structure.

    Example 1:
    Input: [1,3,null,null,2]

       1
      /
     3
      \
       2

    Output: [3,1,null,null,2]

       3
      /
     1
      \
       2

    Example 2:
    Input: [3,1,4,null,null,2]

      3
     / \
    1   4
       /
      2

    Output: [2,1,4,null,null,3]

      2
     / \
    1   4
       /
      3

    Follow up:
    A solution using O(n) space is pretty straight forward.
    Could you devise a constant space solution?"""

    def recoverTree(self, root: TreeNode) -> None:
        node, stack = root, []
        prev = lo = hi = None
        while stack or node:
            if node:
                stack.append(node)
                node = node.left
                continue
            node = stack.pop()
            if prev and prev.val > node.val:
                if not lo: lo, hi = prev, node
                else: hi = node
            prev = node
            node = node.right
        lo.val, hi.val = hi.val, lo.val


    """100. Same Tree (Easy)
    Given two binary trees, write a function to check if they are the same or
    not. Two binary trees are considered the same if they are structurally
    identical and the nodes have the same value.

    Example 1:
    Input:     1         1
              / \       / \
             2   3     2   3

            [1,2,3],   [1,2,3]

    Output: true

    Example 2:
    Input:     1         1
              /           \
             2             2

            [1,2],     [1,null,2]

    Output: false

    Example 3:
    Input:     1         1
              / \       / \
             2   1     1   2

            [1,2,1],   [1,1,2]

    Output: false"""

    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p or not q: return p == q
        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)


    """101. Symmetric Tree (Easy)
    Given a binary tree, check whether it is a mirror of itself (ie, symmetric
    around its center). For example, this binary tree [1,2,2,3,4,4,3] is
    symmetric:

        1
       / \
      2   2
     / \ / \
    3  4 4  3

    But the following [1,2,2,null,3,null,3] is not:

        1
       / \
      2   2
       \   \
       3    3

    Follow up: Solve it both recursively and iteratively."""

    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        stack = [(root, root)]
        while stack:
            p, q = stack.pop()
            if not q or p.val != q.val: return False
            if p.left: stack.append((p.left, q.right))
            if p.right: stack.append((p.right, q.left))
        return True


    """102. Binary Tree Level Order Traversal (Medium)
    Given a binary tree, return the level order traversal of its nodes' values.
    (ie, from left to right, level by level).

    For example:
    Given binary tree [3,9,20,null,null,15,7],
        3
       / \
      9  20
        /  \
       15   7
    return its level order traversal as:
    [
      [3],
      [9,20],
      [15,7]
    ]"""

    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ans = []
        if root:
            queue = deque([root])
            while queue:
                vals = []
                for _ in range(len(queue)):
                    node = queue.popleft()
                    vals.append(node.val)
                    if node.left: queue.append(node.left)
                    if node.right: queue.append(node.right)
                ans.append(vals)
        return ans


    """103. Binary Tree Zigzag Level Order Traversal (Medium)
    Given a binary tree, return the zigzag level order traversal of its nodes'
    values. (ie, from left to right, then right to left for the next level and
    alternate between).

    For example:
    Given binary tree [3,9,20,null,null,15,7],
        3
       / \
      9  20
        /  \
       15   7
    return its zigzag level order traversal as:
    [
      [3],
      [20,9],
      [15,7]
    ]"""

    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ans = []
        if root:
            queue = deque([root])
            stride = 1
            while queue:
                vals = []
                for _ in range(len(queue)):
                    node = queue.popleft()
                    vals.append(node.val)
                    if node.left: queue.append(node.left)
                    if node.right: queue.append(node.right)
                ans.append(vals[::stride])
                stride *= -1
        return ans


    """104. Maximum Depth of Binary Tree (Easy)
    Given a binary tree, find its maximum depth. The maximum depth is the
    number of nodes along the longest path from the root node down to the
    farthest leaf node. Note that a leaf is a node with no children.

    Example:
    Given binary tree [3,9,20,null,null,15,7],

        3
       / \
      9  20
        /  \
       15   7"""

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root: return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))


    """105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)
    Given preorder and inorder traversal of a tree, construct the binary tree.

    Note: You may assume that duplicates do not exist in the tree.

    For example, given
    preorder = [3,9,20,15,7]
    inorder = [9,3,15,20,7]
    Return the following binary tree:

        3
       / \
      9  20
        /  \
       15   7"""

    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        loc = {x : i for i, x in enumerate(inorder)}
        root = None
        stack = []
        for x in preorder:
            if not root: root = node = TreeNode(x)
            elif loc[x] < loc[node.val]:
                stack.append(node)
                node.left = node = TreeNode(x)
            else:
                while stack and loc[stack[-1].val] < loc[x]: node = stack.pop()
                node.right = node = TreeNode(x)
        return root


    """106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)
    Given inorder and postorder traversal of a tree, construct the binary tree.

    Note that you may assume that duplicates do not exist in the tree.

    For example, given inorder = [9,3,15,20,7] and postorder = [9,15,7,20,3],
    return the following binary tree:

        3
       / \
      9  20
        /  \
       15   7"""

    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        loc = {x : i for i, x in enumerate(inorder)}
        root = None
        stack = []
        for x in reversed(postorder):
            if not root: root = node = TreeNode(x)
            elif loc[node.val] < loc[x]:
                stack.append(node)
                node.right = node = TreeNode(x)
            else:
                while stack and loc[x] < loc[stack[-1].val]: node = stack.pop()
                node.left = node = TreeNode(x)
        return root


    """107. Binary Tree Level Order Traversal II (Easy)
    Given a binary tree, return the bottom-up level order traversal of its
    nodes' values. (ie, from left to right, level by level from leaf to root).

    For example:
    Given binary tree [3,9,20,null,null,15,7],
        3
       / \
      9  20
        /  \
       15   7
    return its bottom-up level order traversal as:
    [
      [15,7],
      [9,20],
      [3]
    ]"""

    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        ans, queue = [], [root]
        while queue:
            tmp, val = [], []
            for node in queue:
                if node:
                    val.append(node.val)
                    tmp.extend([node.left, node.right])
            if val: ans.append(val)
            queue = tmp
        return ans[::-1]


    """108. Convert Sorted Array to Binary Search Tree (Easy)
    Given an array where elements are sorted in ascending order, convert it to
    a height balanced BST. For this problem, a height-balanced binary tree is
    defined as a binary tree in which the depth of the two subtrees of every
    node never differ by more than 1.

    Example:
    Given the sorted array: [-10,-3,0,5,9], one possible answer is:
    [0,-3,9,-10,null,5], which represents the following height balanced BST:

          0
         / \
       -3   9
       /   /
     -10  5"""

    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        root = None
        stack = [(root, 0, len(nums), False)]
        while stack:
            node, lo, hi, tf = stack.pop()
            if lo < hi:
                mid = lo + hi >> 1
                if not root: node = root = TreeNode(nums[mid])
                elif tf: node.right = node = TreeNode(nums[mid])
                else: node.left = node = TreeNode(nums[mid])
                stack.append((node, lo, mid, False))
                stack.append((node, mid+1, hi, True))
        return root


    """109. Convert Sorted List to Binary Search Tree (Medium)
    Given a singly linked list where elements are sorted in ascending order,
    convert it to a height balanced BST. For this problem, a height-balanced
    binary tree is defined as a binary tree in which the depth of the two
    subtrees of every node never differ by more than 1.

    Example:
    Given the sorted linked list: [-10,-3,0,5,9], one possible answer is:
    [0,-3,9,-10,null,5], which represents the following height balanced BST:

          0
         / \
       -3   9
       /   /
     -10  5"""

    def sortedListToBST(self, head: ListNode) -> TreeNode:
        node, n = head, 0
        while node: node, n = node.next, n+1

        def fn(lo, hi, node):
            """Return root of tree using nodes from lo (inclusive) to hi (exclusive)"""
            if lo == hi: return None, node
            mid = (lo + hi)//2
            left, node = fn(lo, mid, node)
            ans = TreeNode(node.val, left=left)
            node = node.next
            ans.right, node = fn(mid+1, hi, node)
            return ans, node

        return fn(0, n, head)[0]


    """110. Balanced Binary Tree (Easy)
    Given a binary tree, determine if it is height-balanced.

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
        3
       / \
      9  20
        /  \
       15   7
    Output: true

    Example 2:
    Input: root = [1,2,2,3,3,null,null,4,4]
           1
          / \
         2   2
        / \
       3   3
      / \
     4   4
    Output: false

    Example 3:
    Input: root = []
    Output: true

    Constraints:
    * The number of nodes in the tree is in the range [0, 5000].
    * -10^4 <= Node.val <= 10^4"""

    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        mp = {None : (True, 0)}
        node, prev = root, None
        stack = []
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack[-1]
                if node.right and node.right != prev: node = node.right
                else:
                    b0, d0 = mp[node.left]
                    b1, d1 = mp[node.right]
                    mp[node] = (b0 and b1 and abs(d0 - d1) <= 1, 1 + max(d0, d1))
                    stack.pop()
                    prev = node
                    node = None
        return mp[root][0]


    """111. Minimum Depth of Binary Tree (Easy)
    Given a binary tree, find its minimum depth. The minimum depth is the
    number of nodes along the shortest path from the root node down to the
    nearest leaf node. Note that a leaf is a node with no children.

    Example:
    Given binary tree [3,9,20,null,null,15,7],

        3
       / \
      9  20
        /  \
       15   7
    return its minimum depth = 2."""

    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root: return 0
        left, right = self.minDepth(root.left), self.minDepth(root.right)
        return 1 + min(left, right) if left and right else 1 + max(left, right)


    """112. Path Sum (Easy)
    Given a binary tree and a sum, determine if the tree has a root-to-leaf
    path such that adding up all the values along the path equals the given
    sum. Note that a leaf is a node with no children.

    Example:
    Given the below binary tree and sum = 22,

          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
    return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22."""

    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        stack = [(root, 0)]
        while stack:
            node, val = stack.pop()
            if node:
                val += node.val
                if not node.left and not node.right and val == targetSum: return True
                stack.append((node.right, val))
                stack.append((node.left, val))
        return False


    """113. Path Sum II (Medium)
    Given a binary tree and a sum, find all root-to-leaf paths where each
    path's sum equals the given sum. Note that a leaf is a node with no
    children.

    Example:
    Given the below binary tree and sum = 22,

          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
    Return:

    [
       [5,4,11,2],
       [5,8,4,5]
    ]"""

    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        ans = []
        if root:
            mp = {root: None}
            stack = [(root, 0)]
            while stack:
                node, val = stack.pop()
                val += node.val
                if node.left:
                    mp[node.left] = node
                    stack.append((node.left, val))
                if node.right:
                    mp[node.right] = node
                    stack.append((node.right, val))
                if not node.left and not node.right and val == targetSum:
                    path = []
                    while node:
                        path.append(node.val)
                        node = mp[node]
                    ans.append(path[::-1])
        return ans


    """114. Flatten Binary Tree to Linked List (Medium)
    Given a binary tree, flatten it to a linked list in-place.

    For example, given the following tree:

        1
       / \
      2   5
     / \   \
    3   4   6

    The flattened tree should look like:

    1
     \
      2
       \
        3
         \
          4
           \
            5
             \
              6"""

    def flatten(self, root: TreeNode) -> None:

        def fn(node, tail=None):
            """Return head of flattened binary tree"""
            if not node: return tail
            node.left, node.right = None, fn(node.left, fn(node.right, tail))
            return node

        return fn(root)


    """115. Distinct Subsequences (Hard)
    Given a string S and a string T, count the number of distinct subsequences
    of S which equals T. A subsequence of a string is a new string which is
    formed from the original string by deleting some (can be none) of the
    characters without disturbing the relative positions of the remaining
    characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).
    It's guaranteed the answer fits on a 32-bit signed integer.

    Example 1:
    Input: S = "rabbbit", T = "rabbit"
    Output: 3
    Explanation:
    As shown below, there are 3 ways you can generate "rabbit" from S.
    (The caret symbol ^ means the chosen letters)

    rabbbit
    ^^^^ ^^
    rabbbit
    ^^ ^^^^
    rabbbit
    ^^^ ^^^

    Example 2:
    Input: S = "babgbag", T = "bag"
    Output: 5
    Explanation:
    As shown below, there are 5 ways you can generate "bag" from S.
    (The caret symbol ^ means the chosen letters)

    babgbag
    ^^ ^
    babgbag
    ^^    ^
    babgbag
    ^    ^^
    babgbag
      ^  ^^
    babgbag
        ^^^"""

    def numDistinct(self, s: str, t: str) -> int:
        loc = {}
        for i, x in enumerate(t): loc.setdefault(x, []).append(i)

        ans = [0]*len(t) + [1]
        for c in reversed(s):
            for i in pos.get(c, []): ans[i] += ans[i+1]
        return ans[0]


    """116. Populating Next Right Pointers in Each Node (Medium)
    You are given a perfect binary tree where all leaves are on the same
    level, and every parent has two children. The binary tree has the
    following definition:

    struct Node {
      int val;
      Node *left;
      Node *right;
      Node *next;
    }

    Populate each next pointer to point to its next right node. If there is no
    next right node, the next pointer should be set to NULL. Initially, all
    next pointers are set to NULL.

    Follow up:
    You may only use constant extra space.
    Recursive approach is fine, you may assume implicit stack space does not
    count as extra space for this problem.

    Example 1:
    Input: root = [1,2,3,4,5,6,7]
    Output: [1,#,2,3,#,4,5,6,7,#]
    Explanation: Given the above perfect binary tree (Figure A), your function
    should populate each next pointer to point to its next right node, just
    like in Figure B. The serialized output is in level order as connected by
    the next pointers, with '#' signifying the end of each level.

    Constraints:
    The number of nodes in the given tree is less than 4096.
    -1000 <= node.val <= 1000"""

    def connect(self, root: 'Node') -> 'Node':
        head = root
        while head and head.left:
            node = head
            while node:
                node.left.next = node.right
                if node.next: node.right.next = node.next.left
                node = node.next
            head = head.left
        return root


    """117. Populating Next Right Pointers in Each Node II (Medium)
    Given a binary tree

    struct Node {
      int val;
      Node *left;
      Node *right;
      Node *next;
    }

    Populate each next pointer to point to its next right node. If there is no
    next right node, the next pointer should be set to NULL. Initially, all
    next pointers are set to NULL.

    Follow up:
    You may only use constant extra space. Recursive approach is fine, you may
    assume implicit stack space does not count as extra space for this problem.

    Example 1:
    Input: root = [1,2,3,4,5,null,7]
    Output: [1,#,2,3,#,4,5,7,#]
    Explanation: Given the above binary tree (Figure A), your function should
    populate each next pointer to point to its next right node, just like in
    Figure B. The serialized output is in level order as connected by the next
    pointers, with '#' signifying the end of each level.

    Constraints:
    The number of nodes in the given tree is less than 6000.
    -100 <= node.val <= 100"""

    def connect(self, root: 'Node') -> 'Node':
        if root:
            queue = deque([root])
            while queue:
                prev = None
                for _ in range(len(queue)):
                    node = queue.popleft()
                    node.next = prev
                    prev = node
                    if node.right: queue.append(node.right)
                    if node.left: queue.append(node.left)
        return root


    """118. Pascal's Triangle (Easy)
    Given a non-negative integer numRows, generate the first numRows of
    Pascal's triangle. In Pascal's triangle, each number is the sum of the two
    numbers directly above it.

    Example:
    Input: 5
    Output:
    [
         [1],
        [1,1],
       [1,2,1],
      [1,3,3,1],
     [1,4,6,4,1]
    ]"""

    def generate(self, numRows: int) -> List[List[int]]:
        ans, row = [], []
        for i in range(numRows):
            row.append(1)
            for j in reversed(range(1, i)): row[j] += row[j-1]
            ans.append(row.copy())
        return ans


    """119. Pascal's Triangle II (Easy)
    Given a non-negative index k where k ≤ 33, return the kth index row of the
    Pascal's triangle. Note that the row index starts from 0. In Pascal's
    triangle, each number is the sum of the two numbers directly above it.

    Example:
    Input: 3
    Output: [1,3,3,1]

    Follow up: Could you optimize your algorithm to use only O(k) extra space?"""

    def getRow(self, rowIndex: int) -> List[int]:
        ans = []
        for _ in range(rowIndex+1):
            ans.append(1)
            for i in reversed(range(1, len(ans)-1)): ans[i] += ans[i-1]
        return ans


    """120. Triangle (Medium)
    Given a triangle, find the minimum path sum from top to bottom. Each step
    you may move to adjacent numbers on the row below. For example, given the
    following triangle

    [
         [2],
        [3,4],
       [6,5,7],
      [4,1,8,3]
    ]

    The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

    Note: Bonus point if you are able to do this using only O(n) extra space,
    where n is the total number of rows in the triangle."""

    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for i in reversed(range(len(triangle)-1)):
            for j in range(i+1):
                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])
        return triangle[0][0]


    """121. Best Time to Buy and Sell Stock (Easy)
    Say you have an array for which the ith element is the price of a given
    stock on day i. If you were only permitted to complete at most one
    transaction (i.e., buy one and sell one share of the stock), design an
    algorithm to find the maximum profit. Note that you cannot sell a stock
    before you buy one.

    Example 1:
    Input: [7,1,5,3,6,4]
    Output: 5
    Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
                 Not 7-1 = 6, as selling price needs to be larger than buying price.

    Example 2:
    Input: [7,6,4,3,1]
    Output: 0
    Explanation: In this case, no transaction is done, i.e. max profit = 0."""

    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = inf, 0
        for x in prices:
            buy = min(buy, x)
            sell = max(sell, x - buy)
        return sell


    """122. Best Time to Buy and Sell Stock II (Easy)
    Say you have an array prices for which the ith element is the price of a
    given stock on day i. Design an algorithm to find the maximum profit. You
    may complete as many transactions as you like (i.e., buy one and sell one
    share of the stock multiple times). Note: You may not engage in multiple
    transactions at the same time (i.e., you must sell the stock before you buy
    again).

    Example 1:
    Input: [7,1,5,3,6,4]
    Output: 7
    Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
                 Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.

    Example 2:
    Input: [1,2,3,4,5]
    Output: 4
    Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
                 Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
                 engaging multiple transactions at the same time. You must sell before buying again.

    Example 3:
    Input: [7,6,4,3,1]
    Output: 0
    Explanation: In this case, no transaction is done, i.e. max profit = 0.

    Constraints:
    1 <= prices.length <= 3 * 10 ^ 4
    0 <= prices[i] <= 10 ^ 4"""

    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = inf, 0
        for x in prices:
            buy = min(buy, x - sell)
            sell = max(sell, x - buy)
        return sell


    """123. Best Time to Buy and Sell Stock III (Hard)
    Say you have an array for which the ith element is the price of a given
    stock on day i. Design an algorithm to find the maximum profit. You may
    complete at most two transactions. Note that you may not engage in multiple
    transactions at the same time (i.e., you must sell the stock before you buy
    again).

    Example 1:
    Input: [3,3,5,0,0,3,1,4]
    Output: 6
    Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
                 Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.

    Example 2:
    Input: [1,2,3,4,5]
    Output: 4
    Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
                 Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
                 engaging multiple transactions at the same time. You must sell before buying again.

    Example 3:
    Input: [7,6,4,3,1]
    Output: 0
    Explanation: In this case, no transaction is done, i.e. max profit = 0."""

    def maxProfit(self, prices: List[int]) -> int:
        buy, sell = [inf]*2, [0]*2
        for x in prices:
            for i in range(2):
                if i: buy[i] = min(buy[i], x - sell[i-1])
                else: buy[i] = min(buy[i], x)
                sell[i] = max(sell[i], x - buy[i])
        return sell[1]


    """124. Binary Tree Maximum Path Sum (Hard)
    Given a non-empty binary tree, find the maximum path sum. For this problem,
    a path is defined as any sequence of nodes from some starting node to any
    node in the tree along the parent-child connections. The path must contain
    at least one node and does not need to go through the root.

    Example 1:
    Input: [1,2,3]

           1
          / \
         2   3

    Output: 6

    Example 2:
    Input: [-10,9,20,null,null,15,7]

       -10
       / \
      9  20
        /  \
       15   7

    Output: 42"""

    def maxPathSum(self, root: TreeNode) -> int:

        def fn(node):
            """Return path sum ending at node and maximum path sum seen so far"""
            if not node: return 0, -inf
            lh, lps = fn(node.left)
            rh, rps = fn(node.right)
            return node.val + max(0, lh, rh), max(lps, rps, node.val + max(0, lh) + max(0, rh))

        return fn(root)[1]


    """125. Valid Palindrome (Easy)
    Given a string, determine if it is a palindrome, considering only
    alphanumeric characters and ignoring cases. Note that for the purpose of
    this problem, we define empty string as valid palindrome.

    Example 1:
    Input: "A man, a plan, a canal: Panama"
    Output: true

    Example 2:
    Input: "race a car"
    Output: false"""

    def isPalindrome(self, s: str) -> bool:
        s = "".join(c for c in s.lower() if c.isalnum())
        return s == s[::-1]


    """126. Word Ladder II (Hard)
    Given two words (beginWord and endWord), and a dictionary's word list, find
    all shortest transformation sequence(s) from beginWord to endWord, such
    that:
    1) Only one letter can be changed at a time
    2) Each transformed word must exist in the word list. Note that beginWord
    is not a transformed word.

    Note:
    * Return an empty list if there is no such transformation sequence.
    * All words have the same length.
    * All words contain only lowercase alphabetic characters.
    * You may assume no duplicates in the word list.
    * You may assume beginWord and endWord are non-empty and are not the same.

    Example 1:
    Input:
    beginWord = "hit",
    endWord = "cog",
    wordList = ["hot","dot","dog","lot","log","cog"]

    Output:
    [
      ["hit","hot","dot","dog","cog"],
      ["hit","hot","lot","log","cog"]
    ]

    Example 2:
    Input:
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot","dot","dog","lot","log"]

    Output: []

    Explanation: The endWord "cog" is not in wordList, therefore no possible
    transformation."""

    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        if endWord not in wordList: return [] # edge case

        graph = {}
        for word in wordList:
            for i in range(len(word)):
                key = word[:i] + "*" + word[i+1:]
                graph.setdefault(key, []).append(word)

        queue = [beginWord]
        prev = {beginWord: set()}
        while queue:
            qq = []
            pp = {}
            for w in queue:
                for i in range(len(w)):
                    key = w[:i] + "*" + w[i+1:]
                    for ww in graph.get(key, []):
                        if ww not in prev:
                            qq.append(ww)
                            pp.setdefault(ww, set()).add(w)
            queue = qq
            prev.update(pp)
            if endWord in prev: break

        if endWord not in prev: return []

        ans = [[endWord]]
        while prev[ans[0][-1]]:
            newq = []
            for seq in ans:
                w = seq[-1]
                for i, ww in enumerate(prev[w]):
                    newq.append(seq + [ww])
            ans = newq
        return [x[::-1] for x in ans]


    """127. Word Ladder (Medium)
    Given two words (beginWord and endWord), and a dictionary's word list,
    find the length of shortest transformation sequence from beginWord to
    endWord, such that:
    1) Only one letter can be changed at a time.
    2) Each transformed word must exist in the word list.

    Note:
    * Return 0 if there is no such transformation sequence.
    * All words have the same length.
    * All words contain only lowercase alphabetic characters.
    * You may assume no duplicates in the word list.
    * You may assume beginWord and endWord are non-empty and are not the same.

    Example 1:
    Input:
    beginWord = "hit",
    endWord = "cog",
    wordList = ["hot","dot","dog","lot","log","cog"]

    Output: 5
    Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" ->
    "dog" -> "cog", return its length 5.

    Example 2:
    Input:
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot","dot","dog","lot","log"]

    Output: 0
    Explanation: The endWord "cog" is not in wordList, therefore no possible
    transformation."""

    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord in wordList:
            mp = {}
            for word in wordList:
                for i in range(len(word)):
                    key = word[:i] + "*" + word[i+1:]
                    mp.setdefault(key, []).append(word)
            ans = 1
            seen = {beginWord, endWord}
            fwd, bwd = {beginWord}, {endWord}
            while fwd and bwd:
                ans += 1
                if len(fwd) > len(bwd): fwd, bwd = bwd, fwd
                temp = set()
                for word in fwd:
                    for i in range(len(w)):
                        key = word[:i] + "*" + word[i+1:]
                        for w in mp.get(key, []):
                            if w in bwd: return ans
                            if w not in seen:
                                temp.add(w)
                                seen.add(w)
                fwd = temp
        return 0


    """128. Longest Consecutive Sequence (Hard)
    Given an unsorted array of integers, find the length of the longest
    consecutive elements sequence. Your algorithm should run in O(n) complexity.

    Example:
    Input: [100, 4, 200, 1, 3, 2]
    Output: 4
    Explanation: The longest consecutive elements sequence is [1, 2, 3, 4].
    Therefore its length is 4."""

    def longestConsecutive(self, nums: List[int]) -> int:
        nums = set(nums)
        ans = 0
        for x in nums:
            if x-1 not in nums:
                xx = x + 1
                while xx in nums: xx += 1
                ans = max(ans, xx-x)
        return ans


    """129. Sum Root to Leaf Numbers (Medium)
    Given a binary tree containing digits from 0-9 only, each root-to-leaf path
    could represent a number. An example is the root-to-leaf path 1->2->3 which
    represents the number 123. Find the total sum of all root-to-leaf numbers.
    Note that a leaf is a node with no children.

    Example:
    Input: [1,2,3]
        1
       / \
      2   3
    Output: 25
    Explanation:
    The root-to-leaf path 1->2 represents the number 12.
    The root-to-leaf path 1->3 represents the number 13.
    Therefore, sum = 12 + 13 = 25.

    Example 2:
    Input: [4,9,0,5,1]
        4
       / \
      9   0
     / \
    5   1
    Output: 1026
    Explanation:
    The root-to-leaf path 4->9->5 represents the number 495.
    The root-to-leaf path 4->9->1 represents the number 491.
    The root-to-leaf path 4->0 represents the number 40.
    Therefore, sum = 495 + 491 + 40 = 1026."""

    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        ans = 0
        stack = [(root, 0)]
        while stack:
            node, val = stack.pop()
            val = 10*val + node.val
            if not node.left and not node.right: ans += val
            if node.left: stack.append((node.left, val))
            if node.right: stack.append((node.right, val))
        return ans


    """130. Surrounded Regions (Medium)
    Given a 2D board containing 'X' and 'O' (the letter O), capture all regions
    surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in
    that surrounded region.

    Example:
    X X X X
    X O O X
    X X O X
    X O X X
    After running your function, the board should be:

    X X X X
    X X X X
    X X X X
    X O X X

    Explanation:
    Surrounded regions shouldn’t be on the border, which means that any 'O' on
    the border of the board are not flipped to 'X'. Any 'O' that is not on the
    border and it is not connected to an 'O' on the border will be flipped to
    'X'. Two cells are connected if they are adjacent cells connected
    horizontally or vertically."""

    def solve(self, board: List[List[str]]) -> None:
        m, n = len(board), len(board[0])

        def fn(i, j):
            """Flood fill "O" with sentinel"""
            if 0 <= i < m and 0 <= j < n and board[i][j] == "O":
                board[i][j] = "#" #sentinel
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    fn(ii, jj)

        for i in range(m): fn(i, 0) or fn(i, n-1)
        for j in range(n): fn(0, j) or fn(m-1, j)

        for i in range(m):
            for j in range(n):
                if board[i][j] == "O": board[i][j] = "X"
                if board[i][j] == "#": board[i][j] = "O"


    """131. Palindrome Partitioning (Medium)
    Given a string s, partition s such that every substring of the partition
    is a palindrome. Return all possible palindrome partitioning of s.

    Example:
    Input: "aab"
    Output:
    [
      ["aa","b"],
      ["a","a","b"]
    ]"""

    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        part = [[] for _ in s]
        for i in range(2*n-1):
            lo = i//2
            hi = (i+1)//2
            while 0 <= lo <= hi < n and s[lo] == s[hi]:
                part[lo].append(hi+1)
                lo -= 1
                hi += 1
        ans = []

        def fn(i, seq):
            """Backtrack to find all palindrome partitions."""
            if i == n: return ans.append(seq[:])
            for j in part[i]:
                seq.append(s[i:j])
                fn(j, seq)
                seq.pop()

        fn(0, [])
        return ans


    """132. Palindrome Partitioning II (Hard)
    Given a string s, partition s such that every substring of the partition is
    a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.

    Example:
    Input: "aab"
    Output: 1
    Explanation: The palindrome partitioning ["aa","b"] could be produced using
    1 cut."""

    def minCut(self, s: str) -> int:
        #pre-processing
        palin = dict()
        for k in range(len(s)):
            for i, j in (k, k), (k, k+1):
                while 0 <= i and j < len(s) and s[i] == s[j]:
                    palin.setdefault(i, []).append(j)
                    i, j = i-1, j+1

        @cache
        def fn(i):
            """Return minimum palindrome partitioning of s[i:]"""
            if i == len(s): return 0
            return min(1 + fn(ii+1) for ii in palin[i])

        return fn(0)-1


    """133. Clone Graph (Medium)
    Given a reference of a node in a connected undirected graph. Return a deep
    copy (clone) of the graph. Each node in the graph contains a val (int) and
    a list (List[Node]) of its neighbors.

    class Node {
        public int val;
        public List<Node> neighbors;
    }

    Test case format:
    For simplicity sake, each node's value is the same as the node's index
    (1-indexed). For example, the first node with val = 1, the second node with
    val = 2, and so on. The graph is represented in the test case using an
    adjacency list. Adjacency list is a collection of unordered lists used to
    represent a finite graph. Each list describes the set of neighbors of a
    node in the graph. The given node will always be the first node with val = 1.
    You must return the copy of the given node as a reference to the cloned graph.

    Example 1:
    Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
    Output: [[2,4],[1,3],[2,4],[1,3]]
    Explanation: There are 4 nodes in the graph.
    1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
    2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
    3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
    4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).

    Example 2:
    Input: adjList = [[]]
    Output: [[]]
    Explanation: Note that the input contains one empty list. The graph consists
                 of only one node with val = 1 and it does not have any
                 neighbors.

    Example 3:
    Input: adjList = []
    Output: []
    Explanation: This an empty graph, it does not have any nodes.

    Example 4:
    Input: adjList = [[2],[1]]
    Output: [[2],[1]]

    Constraints:
    + 1 <= Node.val <= 100
    + Node.val is unique for each node.
    + Number of Nodes will not exceed 100.
    + There is no repeated edges and no self-loops in the graph.
    + The Graph is connected and all nodes can be visited starting from the given node."""

    def cloneGraph(self, node: 'Node') -> 'Node':
        memo = dict()

        def fn(n):
            """Return (deep) cloned node"""
            if n not in memo:
                cln = memo[n] = Node(n.val)
                cln.neighbors = [fn(nn) for nn in n.neighbors]
            return memo[n]

        return node and fn(node)


    """134. Gas Station (Medium)
    There are N gas stations along a circular route, where the amount of gas at
    station i is gas[i]. You have a car with an unlimited gas tank and it costs
    cost[i] of gas to travel from station i to its next station (i+1). You
    begin the journey with an empty tank at one of the gas stations. Return the
    starting gas station's index if you can travel around the circuit once in
    the clockwise direction, otherwise return -1.

    Note:
    * If there exists a solution, it is guaranteed to be unique.
    * Both input arrays are non-empty and have the same length.
    * Each element in the input arrays is a non-negative integer.

    Example 1:
    Input: gas  = [1,2,3,4,5]
           cost = [3,4,5,1,2]
    Output: 3
    Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas.
                 Your tank = 0 + 4 = 4
                 Travel to station 4. Your tank = 4 - 1 + 5 = 8
                 Travel to station 0. Your tank = 8 - 2 + 1 = 7
                 Travel to station 1. Your tank = 7 - 3 + 2 = 6
                 Travel to station 2. Your tank = 6 - 4 + 3 = 5
                 Travel to station 3. The cost is 5. Your gas is just enough to
                 travel back to station 3. Therefore, return 3 as the starting
                 index.

    Example 2:
    Input: gas  = [2,3,4]
           cost = [3,4,3]
    Output: -1
    Explanation: You can't start at station 0 or 1, as there is not enough gas
                 to travel to the next station. Let's start at station 2 and
                 fill up with 4 unit of gas. Your tank = 0 + 4 = 4. Travel to
                 station 0. Your tank = 4 - 3 + 2 = 3. Travel to station 1.
                 Your tank = 3 - 3 + 3 = 3. You cannot travel back to station 2,
                 as it requires 4 unit of gas but you only have 3. Therefore,
                 you can't travel around the circuit once no matter where you
                 start."""

    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        ans = prefix = least = 0
        for i, (g, c) in enumerate(zip(gas, cost)):
            prefix += g-c
            if prefix < least:
                ans = i+1
                least = prefix
        return ans % len(gas) if prefix >= 0 else -1


    """135. Candy (Hard)
    There are N children standing in a line. Each child is assigned a rating
    value. You are giving candies to these children subjected to the following
    requirements:
    + Each child must have at least one candy.
    + Children with a higher rating get more candies than their neighbors.

    What is the minimum candies you must give?

    Example 1:
    Input: [1,0,2]
    Output: 5
    Explanation: You can allocate to the first, second and third child with 2,
    1, 2 candies respectively.

    Example 2:
    Input: [1,2,2]
    Output: 4
    Explanation: You can allocate to the first, second and third child with 1,
    2, 1 candies respectively. The third child gets 1 candy because it
    satisfies the above two conditions."""

    def candy(self, ratings: List[int]) -> int:
        if not ratings: return 0 # edge case

        ans = 1
        down, up = 0, 1
        for i in range(1, len(ratings)):
            if ratings[i-1] < ratings[i]:
                if down: down, up = 0, 1 #reset
                up += 1
                ans += up
            elif ratings[i-1] == ratings[i]:
                down, up = 0, 1 #reset
                ans += 1
            else:
                down += 1
                ans += down if down < up else down + 1
        return ans


    """136. Single Number (Easy)
    Given a non-empty array of integers, every element appears twice except for
    one. Find that single one. Note that your algorithm should have a linear
    runtime complexity. Could you implement it without using extra memory?

    Example 1:
    Input: [2,2,1]
    Output: 1

    Example 2:
    Input: [4,1,2,1,2]
    Output: 4"""

    def singleNumber(self, nums: List[int]) -> int:
        return reduce(xor, nums)


    """137. Single Number II (Medium)
    Given a non-empty array of integers, every element appears three times
    except for one, which appears exactly once. Find that single one. Note that
    your algorithm should have a linear runtime complexity. Could you implement
    it without using extra memory?

    Example 1:
    Input: [2,2,3,2]
    Output: 3

    Example 2:
    Input: [0,1,0,1,0,1,99]
    Output: 99"""

    def singleNumber(self, nums: List[int]) -> int:
        one = two = 0
        for x in nums:
            two |= one & x
            one ^= x
            common = two & one
            two &= ~common
            one &= ~common
        return one


    """138. Copy List with Random Pointer (Medium)
    A linked list is given such that each node contains an additional random
    pointer which could point to any node in the list or null. Return a deep
    copy of the list. The Linked List is represented in the input/output as a
    list of n nodes. Each node is represented as a pair of [val, random_index]
    where:

    val: an integer representing Node.val
    random_index: the index of the node (range from 0 to n-1) where random
    pointer points to, or null if it does not point to any node.

    Example 1:
    Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
    Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]

    Example 2:
    Input: head = [[1,1],[2,1]]
    Output: [[1,1],[2,1]]

    Example 3:
    Input: head = [[3,null],[3,0],[3,null]]
    Output: [[3,null],[3,0],[3,null]]

    Example 4:
    Input: head = []
    Output: []
    Explanation: Given linked list is empty (null pointer), so return null.

    Constraints:
    * -10000 <= Node.val <= 10000
    * Node.random is null or pointing to a node in the linked list.
    * Number of Nodes will not exceed 1000."""

    def copyRandomList(self, head: 'Node') -> 'Node':
        mp = {}

        def fn(node):
            """Return a deep copy of node."""
            if node and node not in mp:
                temp = mp[node] = Node(node.val)
                temp.next, temp.random = fn(node.next), fn(node.random)
            return mp.get(node)

        return fn(head)


    """139. Word Break (Medium)
    Given a non-empty string s and a dictionary wordDict containing a list of
    non-empty words, determine if s can be segmented into a space-separated
    sequence of one or more dictionary words. Note that the same word in the
    dictionary may be reused multiple times in the segmentation. You may assume
    the dictionary does not contain duplicate words.

    Example 1:
    Input: s = "leetcode", wordDict = ["leet", "code"]
    Output: true
    Explanation: Return true because "leetcode" can be segmented as "leet code".

    Example 2:
    Input: s = "applepenapple", wordDict = ["apple", "pen"]
    Output: true
    Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
                 Note that you are allowed to reuse a dictionary word.

    Example 3:
    Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
    Output: false"""

    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        trie = {}
        for word in wordDict:
            node = trie
            for ch in word: node = node.setdefault(ch, {})
            node['$'] = word

        dp = [False] * (len(s) + 1)
        dp[0] = True
        for i in range(len(s)):
            if dp[i]:
                node = trie
                for ii in range(i, len(s)):
                    if s[ii] not in node: break
                    node = node[s[ii]]
                    if '$' in node: dp[ii+1] = True
        return dp[-1]


    """140. Word Break II (Hard)
    Given a non-empty string s and a dictionary wordDict containing a list of
    non-empty words, add spaces in s to construct a sentence where each word is
    a valid dictionary word. Return all such possible sentences. Note that the
    same word in the dictionary may be reused multiple times in the segmentation.
    You may assume the dictionary does not contain duplicate words.

    Example 1:
    Input:
    s = "catsanddog"
    wordDict = ["cat", "cats", "and", "sand", "dog"]
    Output:
    [
      "cats and dog",
      "cat sand dog"
    ]

    Example 2:
    Input:
    s = "pineapplepenapple"
    wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
    Output:
    [
      "pine apple pen apple",
      "pineapple pen apple",
      "pine applepen apple"
    ]
    Explanation: Note that you are allowed to reuse a dictionary word.

    Example 3:
    Input:
    s = "catsandog"
    wordDict = ["cats", "dog", "sand", "and", "cat"]
    Output:
    []"""

    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        @cache
        def fn(i):
            """Return segmentation of s[i:]"""
            if i == len(s): return [[]]
            ans = []
            for word in wordDict:
                if s[i:i+len(word)] == word:
                    ans.extend([word] + x for x in fn(i+len(word)))
            return ans

        return [" ".join(x) for x in fn(0)]



    """141. Linked List Cycle (Easy)
    Given a linked list, determine if it has a cycle in it. To represent a
    cycle in the given linked list, we use an integer pos which represents the
    position (0-indexed) in the linked list where tail connects to. If pos is
    -1, then there is no cycle in the linked list.

    Example 1:
    Input: head = [3,2,0,-4], pos = 1
    Output: true
    Explanation: There is a cycle in the linked list, where tail connects to
    the second node.

    Example 2:
    Input: head = [1,2], pos = 0
    Output: true
    Explanation: There is a cycle in the linked list, where tail connects to
    the first node.

    Example 3:
    Input: head = [1], pos = -1
    Output: false
    Explanation: There is no cycle in the linked list.

    Follow up:
    Can you solve it using O(1) (i.e. constant) memory?"""

    def hasCycle(self, head: ListNode) -> bool:
        """Floyd's tortoise and hare (phase 1)"""
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow: return True
        return False


    """142. Linked List Cycle II (Medium)
    Given a linked list, return the node where the cycle begins. If there is no
    cycle, return null. To represent a cycle in the given linked list, we use
    an integer pos which represents the position (0-indexed) in the linked list
    where tail connects to. If pos is -1, then there is no cycle in the linked
    list. Note that do not modify the linked list.

    Example 1:
    Input: head = [3,2,0,-4], pos = 1
    Output: tail connects to node index 1
    Explanation: There is a cycle in the linked list, where tail connects to
    the second node.

    Example 2:
    Input: head = [1,2], pos = 0
    Output: tail connects to node index 0
    Explanation: There is a cycle in the linked list, where tail connects to
    the first node.

    Example 3:
    Input: head = [1], pos = -1
    Output: no cycle
    Explanation: There is no cycle in the linked list.

    Follow-up:
    Can you solve it without using extra space?"""

    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """Floyd's tortoise & hare (phase 2)"""
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow: break
        else: return None
        fast = head
        while fast != slow:
            fast = fast.next
            slow = slow.next
        return slow


    """143. Reorder List (Medium)
    Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to:
    L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list's nodes,
    only nodes itself may be changed.

    Example 1:
    Given 1->2->3->4, reorder it to 1->4->2->3.

    Example 2:
    Given 1->2->3->4->5, reorder it to 1->5->2->4->3."""

    def reorderList(self, head: ListNode) -> None:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

        prev = None
        while slow: slow.next, slow, prev = prev, slow.next, slow

        node = head
        while prev and prev.next:
            node.next, node = prev, node.next
            prev.next, prev = node, prev.next


    """144. Binary Tree Preorder Traversal (Medium)
    Given a binary tree, return the preorder traversal of its nodes' values.

    Example:
    Input: [1,null,2,3]
       1
        \
         2
        /
       3

    Output: [1,2,3]
    Follow up: Recursive solution is trivial, could you do it iteratively?"""

    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans, stack = [], [root]
        while stack:
            node = stack.pop()
            if node:
                ans.append(node.val)
                stack.append(node.right)
                stack.append(node.left)
        return ans


    """145. Binary Tree Postorder Traversal (Hard)
    Given a binary tree, return the postorder traversal of its nodes' values.

    Example:
    Input: [1,null,2,3]
       1
        \
         2
        /
       3

    Output: [3,2,1]
    Follow up: Recursive solution is trivial, could you do it iteratively?"""

    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans, stack = [], []
        prev, node = None, root
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack[-1]
                if node.right and prev != node.right: node = node.right
                else:
                    ans.append(node.val)
                    stack.pop()
                    prev = node
                    node = None
        return ans


    """147. Insertion Sort List (Medium)
    Sort a linked list using insertion sort. A graphical example of insertion
    sort. The partial sorted list (black) initially contains only the first
    element in the list. With each iteration one element (red) is removed from
    the input data and inserted in-place into the sorted list

    Algorithm of Insertion Sort:
    Insertion sort iterates, consuming one input element each repetition, and
    growing a sorted output list. At each iteration, insertion sort removes one
    element from the input data, finds the location it belongs within the
    sorted list, and inserts it there. It repeats until no input elements remain.

    Example 1:
    Input: 4->2->1->3
    Output: 1->2->3->4

    Example 2:
    Input: -1->5->3->4->0
    Output: -1->0->3->4->5"""

    def insertionSortList(self, head: ListNode) -> ListNode:
        dummy = node = ListNode(val=-inf, next=head)
        while node.next:
            if node.val <= node.next.val: node = node.next
            else:
                temp = node.next
                prev = dummy
                while prev.next and prev.next.val <= temp.val: prev = prev.next
                node.next = node.next.next
                temp.next = prev.next
                prev.next = temp
        return dummy.next


    """148. Sort List (Medium)
    Sort a linked list in O(NlogN) time using constant space complexity.

    Example 1:
    Input: 4->2->1->3
    Output: 1->2->3->4

    Example 2:
    Input: -1->5->3->4->0
    Output: -1->0->3->4->5"""

    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next: return head

        fast = prev = slow = head
        while fast and fast.next: fast, prev, slow = fast.next.next, slow, slow.next

        prev.next = None
        l1, l2 = self.sortList(head), self.sortList(slow)
        dummy = node = ListNode()
        while l1 and l2:
            if l1.val > l2.val: l1, l2 = l2, l1
            node.next = node = l1
            l1 = l1.next
        node.next = l1 or l2
        return dummy.next


    """149. Max Points on a Line (Hard)
    Given an array of points where points[i] = [xi, yi] represents a point on
    the X-Y plane, return the maximum number of points that lie on the same
    straight line.

    Example 1:
    Input: [[1,1],[2,2],[3,3]]
    Output: 3
    Explanation:
    ^
    |
    |        o
    |     o
    |  o
    +------------->
    0  1  2  3  4

    Example 2:
    Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
    Output: 4
    Explanation:
    ^
    |
    |  o
    |     o        o
    |        o
    |  o        o
    +------------------->
    0  1  2  3  4  5  6

    Constraints:
    * 1 <= points.length <= 300
    * points[i].length == 2
    * -10^4 <= xi, yi <= 10^4
    * All the points are unique."""

    def maxPoints(self, points: List[List[int]]) -> int:
        ans = 0
        for i, (x, y) in enumerate(points):
            freq = defaultdict(int)
            for ii in range(i+1, len(points)):
                xx, yy = points[ii]
                dx, dy = xx-x, yy-y
                g = gcd(dx, dy)
                dx, dy = dx//g, dy//g
                if dx < 0 or dx == 0 and dy < 0:
                    dx *= -1
                    dy *= -1
                freq[dx, dy] += 1
            ans = max(ans, 1 + max(freq.values(), default=0))
        return ans


    """150. Evaluate Reverse Polish Notation (Medium)
    Evaluate the value of an arithmetic expression in Reverse Polish Notation.
    Valid operators are +, -, *, /. Each operand may be an integer or another
    expression.

    Note:
    Division between two integers should truncate toward zero. The given RPN
    expression is always valid. That means the expression would always evaluate
    to a result and there won't be any divide by zero operation.

    Example 1:
    Input: ["2", "1", "+", "3", "*"]
    Output: 9
    Explanation: ((2 + 1) * 3) = 9

    Example 2:
    Input: ["4", "13", "5", "/", "+"]
    Output: 6
    Explanation: (4 + (13 / 5)) = 6

    Example 3:
    Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
    Output: 22
    Explanation:
      ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
    = ((10 * (6 / (12 * -11))) + 17) + 5
    = ((10 * (6 / -132)) + 17) + 5
    = ((10 * 0) + 17) + 5
    = (0 + 17) + 5
    = 17 + 5
    = 22"""

    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token in "+-*/":
                rr, ll = stack.pop(), stack.pop()
                if token == "+": stack.append(ll + rr)
                elif token == "-": stack.append(ll - rr)
                elif token == "*": stack.append(ll * rr)
                else: stack.append(int(ll/rr))
            else:
                stack.append(int(token))
        return stack.pop()


    """151. Reverse Words in a String (Medium)
    Given an input string, reverse the string word by word.

    Example 1:
    Input: "the sky is blue"
    Output: "blue is sky the"

    Example 2:
    Input: "  hello world!  "
    Output: "world! hello"
    Explanation: Your reversed string should not contain leading or trailing
    spaces.

    Example 3:
    Input: "a good   example"
    Output: "example good a"
    Explanation: You need to reduce multiple spaces between two words to a
    single space in the reversed string.

    Note:
    + A word is defined as a sequence of non-space characters.
    + Input string may contain leading or trailing spaces. However, your
    reversed string should not contain leading or trailing spaces.
    + You need to reduce multiple spaces between two words to a single space in
    the reversed string.

    Follow up:
    For C programmers, try to solve it in-place in O(1) extra space."""

    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))


    """152. Maximum Product Subarray (Medium)
    Given an integer array nums, find the contiguous subarray within an array
    (containing at least one number) which has the largest product.

    Example 1:
    Input: [2,3,-2,4]
    Output: 6
    Explanation: [2,3] has the largest product 6.

    Example 2:
    Input: [-2,0,-1]
    Output: 0
    Explanation: The result cannot be 2, because [-2,-1] is not a subarray."""

    def maxProduct(self, nums: List[int]) -> int:
        ans = -inf
        pmin = pmax = 1
        for x in nums:
            if x < 0: pmin, pmax = pmax, pmin
            pmin = min(x, pmin * x)
            pmax = max(x, pmax * x)
            ans = max(ans, pmax)
        return ans


    """153. Find Minimum in Rotated Sorted Array (Medium)
    Suppose an array sorted in ascending order is rotated at some pivot unknown
    to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).
    Find the minimum element. You may assume no duplicate exists in the array.

    Example 1:
    Input: [3,4,5,1,2]
    Output: 1

    Example 2:
    Input: [4,5,6,7,0,1,2]
    Output: 0"""

    def findMin(self, nums: List[int]) -> int:
        lo, hi = 0, len(nums)-1
        while lo < hi:
            mid = lo + hi >> 1
            if nums[mid] < nums[hi]: hi = mid
            else: lo = mid + 1
        return nums[lo]


    """154. Find Minimum in Rotated Sorted Array II (Hard)
    Suppose an array sorted in ascending order is rotated at some pivot unknown
    to you beforehand. (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).
    Find the minimum element. The array may contain duplicates.

    Example 1:
    Input: [1,3,5]
    Output: 1

    Example 2:
    Input: [2,2,2,0,1]
    Output: 0

    Note:
    This is a follow up problem to Find Minimum in Rotated Sorted Array.
    Would allow duplicates affect the run-time complexity? How and why?"""

    def findMin(self, nums: List[int]) -> int:
        lo, hi = 0, len(nums)-1
        while lo < hi:
            mid = lo + hi >> 1
            if nums[mid] < nums[hi]: hi = mid
            elif nums[mid] == nums[hi]: hi -= 1 # duplicates
            else: lo = mid + 1
        return nums[lo]


    """156. Binary Tree Upside Down (Medium)
    Given the root of a binary tree, turn the tree upside down and return the
    new root. You can turn a binary tree upside down with the following steps:
    * The original left child becomes the new root.
    * The original root becomes the new right child.
    * The original right child becomes the new left child.
    The mentioned steps are done level by level, it is guaranteed that every
    node in the given tree has either 0 or 2 children.

    Example 1:
    Input: root = [1,2,3,4,5]
    Output: [4,5,2,null,null,3,1]

    Example 2:
    Input: root = []
    Output: []

    Example 3:
    Input: root = [1]
    Output: [1]

    Constraints:
    * The number of nodes in the tree will be in the range [0, 10].
    * 1 <= Node.val <= 10
    * Every node has either 0 or 2 children."""

    def upsideDownBinaryTree(self, root: TreeNode) -> TreeNode:
        if not root or not root.left: return root
        ans = self.upsideDownBinaryTree(root.left)
        root.left.left = root.right
        root.left.right = root
        root.left = root.right = None
        return ans


    """157. Read N Characters Given Read4 (Easy)
    Given a file and assume that you can only read the file using a given
    method read4, implement a method to read n characters.

    Method read4:
    The API read4 reads 4 consecutive characters from the file, then writes
    those characters into the buffer array buf4. The return value is the number
    of actual characters read. Note that read4() has its own file pointer, much
    like FILE *fp in C.

    Definition of read4:
        Parameter:  char[] buf4
        Returns:    int
    Note: buf4[] is destination not source, the results from read4 will be
          copied to buf4[]

    Below is a high level example of how read4 works:
    File file("abcde"); // File is "abcde", initially file pointer (fp) points to 'a'
    char[] buf4 = new char[4]; // Create buffer with enough space to store characters
    read4(buf4); // read4 returns 4. Now buf4 = "abcd", fp points to 'e'
    read4(buf4); // read4 returns 1. Now buf4 = "e", fp points to end of file
    read4(buf4); // read4 returns 0. Now buf4 = "", fp points to end of file

    Method read:
    By using the read4 method, implement the method read that reads n
    characters from the file and store it in the buffer array buf. Consider
    that you cannot manipulate the file directly. The return value is the
    number of actual characters read.

    Definition of read:
        Parameters: char[] buf, int n
        Returns:    int
    Note: buf[] is destination not source, you will need to write the results to buf[]

    Example 1:

    Input: file = "abc", n = 4
    Output: 3
    Explanation: After calling your read method, buf should contain "abc". We
                 read a total of 3 characters from the file, so return 3. Note
                 that "abc" is the file's content, not buf. buf is the
                 destination buffer that you will have to write the results to.

    Example 2:
    Input: file = "abcde", n = 5
    Output: 5
    Explanation: After calling your read method, buf should contain "abcde". We
                 read a total of 5 characters from the file, so return 5.

    Example 3:
    Input: file = "abcdABCD1234", n = 12
    Output: 12
    Explanation: After calling your read method, buf should contain "abcdABCD1234".
                 We read a total of 12 characters from the file, so return 12.

    Example 4:
    Input: file = "leetcode", n = 5
    Output: 5
    Explanation: After calling your read method, buf should contain "leetc". We
                 read a total of 5 characters from the file, so return 5.

    Note:
    * Consider that you cannot manipulate the file directly, the file is only
      accesible for read4 but not for read.
    * The read function will only be called once for each test case.
    * You may assume the destination buffer array, buf, is guaranteed to have
      enough space for storing n characters."""

    def read(self, buf, n):
        """
        :type buf: Destination buffer (List[str])
        :type n: Number of characters to read (int)
        :rtype: The number of actual characters read (int)
        """
        ans, k = 0, 4
        buf4 = [" "]*4
        while ans < n and k == 4:
            k = read4(buf4)
            buf[ans: ans+4] = buf4
            ans += k
        return min(n, ans)


    """159. Longest Substring with At Most Two Distinct Characters (Medium)
    Given a string s , find the length of the longest substring t  that
    contains at most 2 distinct characters.

    Example 1:
    Input: "eceba"
    Output: 3
    Explanation: t is "ece" which its length is 3.

    Example 2:
    Input: "ccaabbb"
    Output: 5
    Explanation: t is "aabbb" which its length is 5."""

    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
        ans, ii = 0, -1 # starting anchor
        queue = deque()
        seen = {} # last seen
        for i, x in enumerate(s):
            if not queue or queue[-1] != x: queue.append(x)
            if len(queue) > 2:
                xx = queue.popleft()
                if xx != x: ii = seen[xx] # update anchor
            ans = max(ans, i - ii)
            seen[x] = i
        return ans


    """160. Intersection of Two Linked Lists (Easy)
    Write a program to find the node at which the intersection of two singly
    linked lists begins.

    Example 1:
    Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5],
    skipA = 2, skipB = 3
    Output: Reference of the node with value = 8
    Input Explanation: The intersected node's value is 8 (note that this must
    not be 0 if the two lists intersect). From the head of A, it reads as
    [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2
    nodes before the intersected node in A; There are 3 nodes before the
    intersected node in B.

    Example 2:
    Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3,
    skipB = 1
    Output: Reference of the node with value = 2
    Input Explanation: The intersected node's value is 2 (note that this must
    not be 0 if the two lists intersect). From the head of A, it reads as
    [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes
    before the intersected node in A; There are 1 node before the intersected
    node in B.

    Example 3:
    Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3,
    skipB = 2
    Output: null
    Input Explanation: From the head of A, it reads as [2,6,4]. From the head
    of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal
    must be 0, while skipA and skipB can be arbitrary values.
    Explanation: The two lists do not intersect, so return null.

    Notes:
    If the two linked lists have no intersection at all, return null.
    The linked lists must retain their original structure after the function returns.
    You may assume there are no cycles anywhere in the entire linked structure.
    Each value on each linked list is in the range [1, 10^9].
    Your code should preferably run in O(n) time and use only O(1) memory."""

    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        nodeA, nodeB = headA, headB
        while nodeA != nodeB:
            nodeA = nodeA.next if nodeA else headB
            nodeB = nodeB.next if nodeB else headA
        return nodeA


    """161. One Edit Distance (Medium)
    Given two strings s and t, return true if they are both one edit distance
    apart, otherwise return false. A string s is said to be one distance apart
    from a string t if you can:
    * Insert exactly one character into s to get t.
    * Delete exactly one character from s to get t.
    * Replace exactly one character of s with a different character to get t.

    Example 1:
    Input: s = "ab", t = "acb"
    Output: true
    Explanation: We can insert 'c' into s to get t.

    Example 2:
    Input: s = "", t = ""
    Output: false
    Explanation: We cannot get t from s by only one step.

    Example 3:
    Input: s = "a", t = ""
    Output: true

    Example 4:
    Input: s = "", t = "A"
    Output: true

    Constraints:
    * 0 <= s.length <= 10^4
    * 0 <= t.length <= 10^4
    * s and t consist of lower-case letters, upper-case letters and/or digits."""

    def isOneEditDistance(self, s: str, t: str) -> bool:
        if s == t: return False
        i = 0
        while i < min(len(t), len(s)):
            if s[i] != t[i]: break
            i += 1
        return s[i:] == t[i+1:] or s[i+1:] == t[i+1:] or s[i+1:] == t[i:]


    """162. Find Peak Element (Medium)
    A peak element is an element that is greater than its neighbors. Given an
    input array nums, where nums[i] ≠ nums[i+1], find a peak element and return
    its index. The array may contain multiple peaks, in that case return the
    index to any one of the peaks is fine. You may imagine that
    nums[-1] = nums[n] = -∞.

    Example 1:
    Input: nums = [1,2,3,1]
    Output: 2
    Explanation: 3 is a peak element and your function should return the index
    number 2.

    Example 2:
    Input: nums = [1,2,1,3,5,6,4]
    Output: 1 or 5
    Explanation: Your function can return either index number 1 where the peak
    element is 2, or index number 5 where the peak element is 6.

    Follow up: Your solution should be in logarithmic complexity."""

    def findPeakElement(self, nums: List[int]) -> int:
        lo, hi = 0, len(nums)-1
        while lo < hi:
            mid = lo + hi >> 1
            if nums[mid] < nums[mid+1]: lo = mid + 1
            else: hi = mid
        return lo


    """163. Missing Ranges (Easy)
    You are given an inclusive range [lower, upper] and a sorted unique integer
    array nums, where all elements are in the inclusive range. A number x is
    considered missing if x is in the range [lower, upper] and x is not in nums.
    Return the smallest sorted list of ranges that cover every missing number
    exactly. That is, no element of nums is in any of the ranges, and each
    missing number is in one of the ranges. Each range [a,b] in the list should
    be output as:
    * "a->b" if a != b
    * "a" if a == b

    Example 1:
    Input: nums = [0,1,3,50,75], lower = 0, upper = 99
    Output: ["2","4->49","51->74","76->99"]
    Explanation: The ranges are:
    [2,2] --> "2"
    [4,49] --> "4->49"
    [51,74] --> "51->74"
    [76,99] --> "76->99"

    Example 2:
    Input: nums = [], lower = 1, upper = 1
    Output: ["1"]
    Explanation: The only missing range is [1,1], which becomes "1".

    Example 3:
    Input: nums = [], lower = -3, upper = -1
    Output: ["-3->-1"]
    Explanation: The only missing range is [-3,-1], which becomes "-3->-1".

    Example 4:
    Input: nums = [-1], lower = -1, upper = -1
    Output: []
    Explanation: There are no missing ranges since there are no missing numbers.

    Example 5:
    Input: nums = [-1], lower = -2, upper = -1
    Output: ["-2"]

    Constraints:
    * -10^9 <= lower <= upper <= 10^9
    * 0 <= nums.length <= 100
    * lower <= nums[i] <= upper
    * All the values of nums are unique."""

    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[str]:
        ans = []
        prev = lower-1
        nums.append(upper+1)
        for x in nums:
            if prev+1 <= x-1:
                if prev+1 == x-1: ans.append(str(prev+1))
                else: ans.append(f"{prev+1}->{x-1}")
            prev = x
        return ans


    """164. Maximum Gap (Hard)
    Given an unsorted array, find the maximum difference between the successive
    elements in its sorted form. Return 0 if the array contains less than 2
    elements.

    Example 1:
    Input: [3,6,9,1]
    Output: 3
    Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or
                 (6,9) has the maximum difference 3.

    Example 2:
    Input: [10]
    Output: 0
    Explanation: The array contains less than 2 elements, therefore return 0.

    Note:
    You may assume all elements in the array are non-negative integers and fit
    in the 32-bit signed integer range. Try to solve it in linear time/space."""

    def maximumGap(self, nums: List[int]) -> int:
        if len(nums) < 2: return 0 #edge case

        mn, mx = min(nums), max(nums)
        step = max(1, (mx - mn)//(len(nums) - 1))
        size = (mx - mn)//step + 1
        buckets = [[inf, -inf] for _ in range(size)]

        for num in nums:
            i = (num - mn)//step
            x, xx = buckets[i]
            buckets[i] = [min(x, num), max(xx, num)]

        ans = 0
        prev = mn
        for i in range(len(buckets)):
            x, xx = buckets[i]
            if x < inf:
                ans = max(ans, x - prev)
                prev = xx
        return ans


    """165. Compare Version Numbers (Medium)
    Compare two version numbers version1 and version2. If version1 > version2
    return 1; if version1 < version2 return -1;otherwise return 0. You may
    assume that the version strings are non-empty and contain only digits and
    the . character. The . character does not represent a decimal point and is
    used to separate number sequences. For instance, 2.5 is not "two and a half"
    or "half way to version three", it is the fifth second-level revision of
    the second first-level revision. You may assume the default revision number
    for each level of a version number to be 0. For example, version number 3.4
    has a revision number of 3 and 4 for its first and second level revision
    number. Its third and fourth level revision number are both 0.

    Example 1:
    Input: version1 = "0.1", version2 = "1.1"
    Output: -1

    Example 2:
    Input: version1 = "1.0.1", version2 = "1"
    Output: 1

    Example 3:
    Input: version1 = "7.5.2.4", version2 = "7.5.3"
    Output: -1

    Example 4:
    Input: version1 = "1.01", version2 = "1.001"
    Output: 0
    Explanation: Ignoring leading zeroes, both “01” and “001" represent the
                 same number "1"

    Example 5:
    Input: version1 = "1.0", version2 = "1.0.0"
    Output: 0
    Explanation: The first version number does not have a third level revision
                 number, which means its third level revision number is default
                 to "0"

    Note:
    * Version strings are composed of numeric strings separated by dots . and
      this numeric strings may have leading zeroes.
    * Version strings do not start or end with dots, and they will not be two
      consecutive dots."""

    def compareVersion(self, version1: str, version2: str) -> int:
        for x, y in zip_longest(version1.split("."), version2.split("."), fillvalue="0"):
            if int(x) > int(y): return 1
            elif int(x) < int(y): return -1
        return 0


    """166. Fraction to Recurring Decimal (Medium)
    Given two integers representing the numerator and denominator of a
    fraction, return the fraction in string format. If the fractional part
    is repeating, enclose the repeating part in parentheses.

    Example 1:
    Input: numerator = 1, denominator = 2
    Output: "0.5"

    Example 2:
    Input: numerator = 2, denominator = 1
    Output: "2"

    Example 3:
    Input: numerator = 2, denominator = 3
    Output: "0.(6)" """

    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        sign = "-" if numerator * denominator < 0 else ""
        q, r = divmod(abs(numerator), abs(denominator))
        if not r: return sign + str(q)

        seen = {r : (i := 0)}
        dcml = ""
        while r:
            d, r = divmod(10*r, abs(denominator))
            dcml += str(d)
            if r in seen:
                k = seen[r]
                return sign + f"{q}.{dcml[:k]}({dcml[k:]})"
            seen[r] = (i := i+1)
        return sign + f"{q}.{dcml}"


    """167. Two Sum II - Input array is sorted (Easy)
    Given an array of integers that is already sorted in ascending order, find
    two numbers such that they add up to a specific target number. The function
    twoSum should return indices of the two numbers such that they add up to
    the target, where index1 must be less than index2.

    Note:
    Your returned answers (both index1 and index2) are not zero-based.
    You may assume that each input would have exactly one solution and you may
    not use the same element twice.

    Example:
    Input: numbers = [2,7,11,15], target = 9
    Output: [1,2]
    Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2."""

    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        lo, hi = 0, len(numbers)-1
        while lo < hi:
            sm = numbers[lo] + numbers[hi]
            if sm < target: lo += 1
            elif sm == target: return [lo+1, hi+1]
            else: hi -= 1


    """168. Excel Sheet Column Title (Easy)
    Given a positive integer, return its corresponding column title as appear
    in an Excel sheet.  For example:
        1 -> A
        2 -> B
        3 -> C
        ...
        26 -> Z
        27 -> AA
        28 -> AB
        ...

    Example 1:
    Input: 1
    Output: "A"

    Example 2:
    Input: 28
    Output: "AB"

    Example 3:
    Input: 701
    Output: "ZY" """

    def convertToTitle(self, n: int) -> str:
        ans = []
        while n:
            n, r = divmod(n-1, 26)
            ans.append(r)
        return "".join(chr(r+65) for r in reversed(ans))


    """169. Majority Element (Easy)
    Given an array of size n, find the majority element. The majority element
    is the element that appears more than ⌊ n/2 ⌋ times. You may assume that
    the array is non-empty and the majority element always exist in the array.

    Example 1:
    Input: [3,2,3]
    Output: 3

    Example 2:
    Input: [2,2,1,1,1,2,2]
    Output: 2"""

    def majorityElement(self, nums: List[int]) -> int:
        """Boyer-Moore majority vote algo"""
        ans = vote = 0
        for x in nums:
            if vote == 0: ans = x
            if x == ans: vote += 1
            else: vote -= 1
        return ans


    """171. Excel Sheet Column Number (Easy)
    Given a column title as appear in an Excel sheet, return its corresponding
    column number. For example:
        A -> 1
        B -> 2
        C -> 3
        ...
        Z -> 26
        AA -> 27
        AB -> 28
        ...

    Example 1:
    Input: "A"
    Output: 1

    Example 2:
    Input: "AB"
    Output: 28

    Example 3:
    Input: "ZY"
    Output: 701

    Constraints:
    * 1 <= s.length <= 7
    * s consists only of uppercase English letters.
    * s is between "A" and "FXSHRXW"."""

    def titleToNumber(self, columnTitle: str) -> int:
        return reduce(lambda x, y: 26*x+ord(y)-64, columnTitle, 0)


    """172. Factorial Trailing Zeroes (Easy)
    Given an integer n, return the number of trailing zeroes in n!.

    Example 1:
    Input: 3
    Output: 0
    Explanation: 3! = 6, no trailing zero.

    Example 2:
    Input: 5
    Output: 1
    Explanation: 5! = 120, one trailing zero.

    Note: Your solution should be in logarithmic time complexity."""

    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n:
            n //= 5
            ans += n
        return ans


    """174. Dungeon Game (Hard)
    The demons had captured the princess (P) and imprisoned her in the bottom-
    right corner of a dungeon. The dungeon consists of M x N rooms laid out in
    a 2D grid. Our valiant knight (K) was initially positioned in the top-left
    room and must fight his way through the dungeon to rescue the princess. The
    knight has an initial health point represented by a positive integer. If at
    any point his health point drops to 0 or below, he dies immediately. Some
    of the rooms are guarded by demons, so the knight loses health (negative
    integers) upon entering these rooms; other rooms are either empty (0's) or
    contain magic orbs that increase the knight's health (positive integers).
    In order to reach the princess as quickly as possible, the knight decides
    to move only rightward or downward in each step.

    Write a function to determine the knight's minimum initial health so that
    he is able to rescue the princess. For example, given the dungeon below,
    the initial health of the knight must be at least 7 if he follows the
    optimal path RIGHT-> RIGHT -> DOWN -> DOWN.

    -2 (K)  -3  3
    -5  -10 1
    10  30  -5 (P)

    Note:
    * The knight's health has no upper bound.
    * Any room can contain threats or power-ups, even the first room the knight
      enters and the bottom-right room where the princess is imprisoned."""

    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])

        @cache
        def fn(i, j):
            """Return min health at (i,j)."""
            if i == m or j == n: return inf
            if i == m-1 and j == n-1: return max(1, 1 - dungeon[i][j])
            return max(1, min(fn(i+1, j), fn(i, j+1)) - dungeon[i][j])

        return fn(0, 0)


    """179. Largest Number (Medium)
    Given a list of non negative integers, arrange them such that they form the
    largest number.

    Example 1:
    Input: [10,2]
    Output: "210"

    Example 2:
    Input: [3,30,34,5,9]
    Output: "9534330"

    Note: The result may be very large, so you need to return a string instead
    of an integer."""

    def largestNumber(self, nums: List[int]) -> str:
        return "".join(sorted(map(str, nums), key=cmp_to_key(lambda x, y: -(x+y>y+x)))).lstrip("0") or "0"


    """186. Reverse Words in a String II (Medium)
    Given an input string , reverse the string word by word.

    Example:
    Input:  ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]
    Output: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]

    Note:
    * A word is defined as a sequence of non-space characters.
    * The input string does not contain leading or trailing spaces.
    * The words are always separated by a single space.
    Follow up: Could you do it in-place without allocating extra space?"""

    def reverseWords(self, s: List[str]) -> None:

        def fn(lo, hi):
            """Reverse s[lo:hi+1] in-place."""
            while lo < hi:
                s[lo], s[hi] = s[hi], s[lo]
                lo, hi = lo+1, hi-1

        fn(0, len(s)-1)
        lo = 0
        for i in range(len(s)+1):
            if i == len(s) or s[i] == " ":
                hi = i - 1
                fn(lo, hi)
                lo = i + 1


    """187. Repeated DNA Sequences (Medium)
    All DNA is composed of a series of nucleotides abbreviated as A, C, G, and
    T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to
    identify repeated sequences within the DNA. Write a function to find all
    the 10-letter-long sequences (substrings) that occur more than once in a
    DNA molecule.

    Example:
    Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
    Output: ["AAAAACCCCC", "CCCCCAAAAA"]"""

    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        mp = dict(zip("ACGT", range(4)))

        ans, seen = set(), set()
        hs = 0 # rolling hash
        for i, x in enumerate(s):
            hs = 4*hs + mp[x]
            if i >= 10: hs -= mp[s[i-10]]*4**10
            if i >= 9:
                if hs in seen: ans.add(s[i-9:i+1])
                seen.add(hs)
        return ans


    """188. Best Time to Buy and Sell Stock IV (Hard)
    Say you have an array for which the i-th element is the price of a given
    stock on day i. Design an algorithm to find the maximum profit. You may
    complete at most k transactions.

    Note: You may not engage in multiple transactions at the same time (ie,
    you must sell the stock before you buy again).

    Example 1:
    Input: [2,4,1], k = 2
    Output: 2
    Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4),
                 profit = 4-2 = 2.

    Example 2:
    Input: [3,2,6,5,0,3], k = 2
    Output: 7
    Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6),
                 profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on
                 day 6 (price = 3), profit = 3-0 = 3."""

    def maxProfit(self, k: int, prices: List[int]) -> int:
        if k >= len(prices)//2: return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))
        buy, sell = [inf]*k, [0]*k
        for x in prices:
            for i in range(k):
                if i: buy[i] = min(buy[i], x - sell[i-1])
                else: buy[i] = min(buy[i], x)
                sell[i] = max(sell[i], x - buy[i])
        return sell[-1] if k and prices else 0


    """189. Rotate Array (Easy)
    Given an array, rotate the array to the right by k steps, where k is non-
    negative.

    Follow up:
    Try to come up as many solutions as you can, there are at least 3 different
    ways to solve this problem. Could you do it in-place with O(1) extra space?

    Example 1:
    Input: nums = [1,2,3,4,5,6,7], k = 3
    Output: [5,6,7,1,2,3,4]
    Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6]
                 rotate 2 steps to the right: [6,7,1,2,3,4,5]
                 rotate 3 steps to the right: [5,6,7,1,2,3,4]

    Example 2:
    Input: nums = [-1,-100,3,99], k = 2
    Output: [3,99,-1,-100]
    Explanation: rotate 1 steps to the right: [99,-1,-100,3]
                 rotate 2 steps to the right: [3,99,-1,-100]

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * It's guaranteed that nums[i] fits in a 32 bit-signed integer.
    * k >= 0"""

    def rotate(self, nums: List[int], k: int) -> None:
        n = len(nums)
        for i in range(gcd(n, k)):
            ii = (i+k) % n
            while i != ii:
                nums[i], nums[ii] = nums[ii], nums[i]
                ii = (ii+k) % n


    """190. Reverse Bits (Easy)
    Reverse bits of a given 32 bits unsigned integer.

    Example 1:
    Input: 00000010100101000001111010011100
    Output: 00111001011110000010100101000000
    Explanation: The input binary string 00000010100101000001111010011100
    represents the unsigned integer 43261596, so return 964176192 which its
    binary representation is 00111001011110000010100101000000.

    Example 2:

    Input: 11111111111111111111111111111101
    Output: 10111111111111111111111111111111
    Explanation: The input binary string 11111111111111111111111111111101
    represents the unsigned integer 4294967293, so return 3221225471 which its
    binary representation is 10111111111111111111111111111111.

    Note:
    Note that in some languages such as Java, there is no unsigned integer type.
    In this case, both input and output will be given as signed integer type and
    should not affect your implementation, as the internal binary representation
    of the integer is the same whether it is signed or unsigned. In Java, the
    compiler represents the signed integers using 2's complement notation.
    Therefore, in Example 2 above the input represents the signed integer -3 and
    the output represents the signed integer -1073741825.

    Follow up: If this function is called many times, how would you optimize it?"""

    def reverseBits(self, n: int) -> int:
        return int(bin(n)[2:].zfill(32)[::-1], 2)


    """191. Number of 1 Bits (Easy)
    Write a function that takes an unsigned integer and return the number of
    '1' bits it has (also known as the Hamming weight).

    Example 1:
    Input: 00000000000000000000000000001011
    Output: 3
    Explanation: The input binary string 00000000000000000000000000001011 has a
    total of three '1' bits.

    Example 2:
    Input: 00000000000000000000000010000000
    Output: 1
    Explanation: The input binary string 00000000000000000000000010000000 has a
    total of one '1' bit.

    Example 3:
    Input: 11111111111111111111111111111101
    Output: 31
    Explanation: The input binary string 11111111111111111111111111111101 has a
    total of thirty one '1' bits.

    Note:
    Note that in some languages such as Java, there is no unsigned integer type.
    In this case, the input will be given as signed integer type and should not
    affect your implementation, as the internal binary representation of the
    integer is the same whether it is signed or unsigned. In Java, the compiler
    represents the signed integers using 2's complement notation. Therefore, in
    Example 3 above the input represents the signed integer -3.

    Follow up: If this function is called many times, how would you optimize it?"""

    def hammingWeight(self, n: int) -> int:
        # Brian Kernighan’s Algo
        ans = 0
        while n:
            ans += 1
            n &= n-1
        return ans


    """198. House Robber (Easy)
    You are a professional robber planning to rob houses along a street. Each
    house has a certain amount of money stashed, the only constraint stopping
    you from robbing each of them is that adjacent houses have security system
    connected and it will automatically contact the police if two adjacent
    houses were broken into on the same night. Given a list of non-negative
    integers representing the amount of money of each house, determine the
    maximum amount of money you can rob tonight without alerting the police.

    Example 1:
    Input: nums = [1,2,3,1]
    Output: 4
    Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
                 Total amount you can rob = 1 + 3 = 4.

    Example 2:
    Input: nums = [2,7,9,3,1]
    Output: 12
    Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house
                 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.

    Constraints:
    0 <= nums.length <= 100
    0 <= nums[i] <= 400"""

    def rob(self, nums: List[int]) -> int:

        @cache
        def fn(i):
            """Return the maximum amount of money after robbing ith house"""
            if i < 0: return 0
            return max(fn(i-1), fn(i-2) + nums[i])

        return fn(len(nums)-1)


    """199. Binary Tree Right Side View (Medium)
    Given a binary tree, imagine yourself standing on the right side of it,
    return the values of the nodes you can see ordered from top to bottom.

    Example:
    Input: [1,2,3,null,5,null,4]
    Output: [1, 3, 4]
    Explanation:

       1            <---
     /   \
    2     3         <---
     \     \
      5     4       <---"""

    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        if root:
            queue = [root]
            while queue:
                val = 0
                newq = []
                for x in queue:
                    val = x.val
                    if x.left: newq.append(x.left)
                    if x.right: newq.append(x.right)
                ans.append(val)
                queue = newq
        return ans


    """200. Number of Islands (Medium)
    Given a 2d grid map of '1's (land) and '0's (water), count the number of
    islands. An island is surrounded by water and is formed by connecting
    adjacent lands horizontally or vertically. You may assume all four edges
    of the grid are all surrounded by water.

    Example 1:
    Input: grid = [
      ["1","1","1","1","0"],
      ["1","1","0","1","0"],
      ["1","1","0","0","0"],
      ["0","0","0","0","0"]
    ]
    Output: 1

    Example 2:
    Input: grid = [
      ["1","1","0","0","0"],
      ["1","1","0","0","0"],
      ["0","0","1","0","0"],
      ["0","0","0","1","1"]
    ]
    Output: 3"""

    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        for r in range(m):
            for c in range(n):
                if grid[r][c] == '1':
                    ans += 1
                    grid[r][c] = '0'
                    stack = [(r, c)]
                    while stack:
                        i, j = stack.pop()
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                            if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == '1':
                                grid[ii][jj] = '0'
                                stack.append((ii, jj))
        return ans


   """201. Bitwise AND of Numbers Range (Medium)
    Given two integers left and right that represent the range [left, right],
    return the bitwise AND of all numbers in this range, inclusive.

    Example 1:
    Input: left = 5, right = 7
    Output: 4

    Example 2:
    Input: left = 0, right = 0
    Output: 0

    Example 3:
    Input: left = 1, right = 2147483647
    Output: 0

    Constraints: 0 <= left <= right <= 2^31 - 1"""

    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        while left < right: right &= right - 1
        return right


    """202. Happy Number (Easy)
    Write an algorithm to determine if a number n is "happy". A happy number is
    a number defined by the following process: Starting with any positive
    integer, replace the number by the sum of the squares of its digits, and
    repeat the process until the number equals 1 (where it will stay), or it
    loops endlessly in a cycle which does not include 1. Those numbers for
    which this process ends in 1 are happy numbers. Return True if n is a happy
    number, and False if not.

    Example:
    Input: 19
    Output: true
    Explanation:
    12 + 92 = 82
    82 + 22 = 68
    62 + 82 = 100
    12 + 02 + 02 = 1"""

    def isHappy(self, n: int) -> bool:
        fn = lambda n: sum(int(x)**2 for x in str(n))
        fast, slow = fn(n), n
        while fast != slow:
            fast = fn(fn(fast))
            slow = fn(slow)
        return fast == 1


    """203. Remove Linked List Elements (Easy)
    Remove all elements from a linked list of integers that have value val.

    Example:
    Input:  1->2->6->3->4->5->6, val = 6
    Output: 1->2->3->4->5"""

    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy = node = ListNode(next=head)
        while node.next:
            if node.next.val == val: node.next = node.next.next
            else: node = node.next
        return dummy.next


    """204. Count Primes (Easy)
    Count the number of prime numbers less than a non-negative number, n.

    Example:
    Input: 10
    Output: 4
    Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7."""

    def countPrimes(self, n: int) -> int:
        """Sieve of Eratosthenes"""
        sieve = [True]*n
        sieve[0] = sieve[1] = False # 0 and 1 are not prime
        for i in range(int(sqrt(n))+1):
            if sieve[i]:
                for ii in range(i*i, n, i):
                    sieve[ii] = False
        return sum(sieve)


    """205. Isomorphic Strings (Easy)
    Given two strings s and t, determine if they are isomorphic. Two strings
    are isomorphic if the characters in s can be replaced to get t. All
    occurrences of a character must be replaced with another character while
    preserving the order of characters. No two characters may map to the same
    character but a character may map to itself.

    Example 1:
    Input: s = "egg", t = "add"
    Output: true

    Example 2:
    Input: s = "foo", t = "bar"
    Output: false

    Example 3:
    Input: s = "paper", t = "title"
    Output: true
    Note:
    You may assume both s and t have the same length."""

    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(zip(s, t))) == len(set(s)) == len(set(t))


    """206. Reverse Linked List (Easy)
    Reverse a singly linked list.

    Example:
    Input: 1->2->3->4->5->NULL
    Output: 5->4->3->2->1->NULL

    Follow up: A linked list can be reversed either iteratively or recursively.
    Could you implement both?"""

    def reverseList(self, head: ListNode) -> ListNode:
        prev, node = None, head
        while node:
            node.next, node, prev = prev, node.next, node
        return prev


    """207. Course Schedule (Medium)
    There are a total of numCourses courses you have to take, labeled from 0 to
    numCourses-1. Some courses may have prerequisites, for example to take
    course 0 you have to first take course 1, which is expressed as a pair:
    [0,1]. Given the total number of courses and a list of prerequisite pairs,
    is it possible for you to finish all courses?

    Example 1:
    Input: numCourses = 2, prerequisites = [[1,0]]
    Output: true
    Explanation: There are a total of 2 courses to take. To take course 1 you
                 should have finished course 0. So it is possible.

    Example 2:
    Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
    Output: false
    Explanation: There are a total of 2 courses to take. To take course 1 you
                 should have finished course 0, and to take course 0 you should
                 also have finished course 1. So it is impossible.


    Constraints:
    * The input prerequisites is a graph represented by a list of edges, not
      adjacency matrices. Read more about how a graph is represented.
    * You may assume that there are no duplicate edges in the input
      prerequisites.
    * 1 <= numCourses <= 10^5"""

    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        indeg = [0]*numCourses
        graph = {}
        for u, v in prerequisites:
            indeg[u] += 1
            graph.setdefault(v, []).append(u)

        stack = [i for i, x in enumerate(indeg) if not x]
        seen = []
        while stack:
            x = stack.pop()
            seen.append(x)
            for xx in graph.get(x, []):
                indeg[xx] -= 1
                if indeg[xx] == 0: stack.append(xx)
        return len(seen) == numCourses


    """209. Minimum Size Subarray Sum (Medium)
    Given an array of n positive integers and a positive integer s, find the
    minimal length of a contiguous subarray of which the sum ≥ s. If there
    isn't one, return 0 instead.

    Example:
    Input: s = 7, nums = [2,3,1,2,4,3]
    Output: 2
    Explanation: the subarray [4,3] has the minimal length under the problem
                 constraint.

    Follow up: If you have figured out the O(n) solution, try coding another
               solution of which the time complexity is O(n log n). """

    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        ans, lo = inf, 0
        for hi in range(len(nums)):
            s -= nums[hi]
            while s <= 0:
                ans = min(ans, hi - lo + 1)
                s += nums[lo]
                lo += 1
        return ans if ans < inf else 0


    """210. Course Schedule II (Medium)
    There are a total of n courses you have to take, labeled from 0 to n-1.
    Some courses may have prerequisites, for example to take course 0 you have
    to first take course 1, which is expressed as a pair: [0,1]. Given the
    total number of courses and a list of prerequisite pairs, return the
    ordering of courses you should take to finish all courses. There may be
    multiple correct orders, you just need to return one of them. If it is
    impossible to finish all courses, return an empty array.

    Example 1:
    Input: 2, [[1,0]]
    Output: [0,1]
    Explanation: There are a total of 2 courses to take. To take course 1 you
                 should have finished course 0. So the correct course order is
                 [0,1].

    Example 2:
    Input: 4, [[1,0],[2,0],[3,1],[3,2]]
    Output: [0,1,2,3] or [0,2,1,3]
    Explanation: There are a total of 4 courses to take. To take course 3 you
                 should have finished both courses 1 and 2. Both courses 1 and
                 2 should be taken after you finished course 0. So one correct
                 course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .

    Note:
    * The input prerequisites is a graph represented by a list of edges, not
      adjacency matrices. Read more about how a graph is represented.
    * You may assume that there are no duplicate edges in the input prerequisites."""

    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(numCourses)]
        indeg = [0] * numCourses
        for v, u in prerequisites:
            graph[u].append(v)
            indeg[v] += 1
        ans = []
        for i, x in enumerate(indeg):
            if x == 0: ans.append(i)
        for u in ans:
            for v in graph[u]:
                indeg[v] -= 1
                if indeg[v] == 0: ans.append(v)
        return ans if len(ans) == numCourses else []


    """212. Word Search II (Hard)
    Given a 2D board and a list of words from the dictionary, find all words in
    the board. Each word must be constructed from letters of sequentially
    adjacent cell, where "adjacent" cells are those horizontally or vertically
    neighboring. The same letter cell may not be used more than once in a word.

    Example:
    Input:
    board = [
      ['o','a','a','n'],
      ['e','t','a','e'],
      ['i','h','k','r'],
      ['i','f','l','v']
    ]
    words = ["oath","pea","eat","rain"]

    Output: ["eat","oath"]

    Note:
    All inputs are consist of lowercase letters a-z.
    The values of words are distinct."""

    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        m, n = len(board), len(board[0])

        trie = Trie()
        for word in words: trie.insert(word)

        def fn(i, j, node):
            """Populate ans through backtracking"""
            if node.word:
                ans.append("".join(stack))
                node.word = False
            if not (0 <= i < m and 0 <= j < n) or board[i][j] not in node.children: return
            stack.append(board[i][j])
            board[i][j] = "#" #mark as visited
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                fn(ii, jj, node.children[stack[-1]])
            board[i][j] = stack.pop()

        ans, stack = [], []
        for i in range(m):
            for j in range(n):
                fn(i, j, trie.root)
        return ans


    """213. House Robber II (Medium)
    You are a professional robber planning to rob houses along a street. Each
    house has a certain amount of money stashed. All houses at this place are
    arranged in a circle. That means the first house is the neighbor of the
    last one. Meanwhile, adjacent houses have security system connected and it
    will automatically contact the police if two adjacent houses were broken
    into on the same night. Given a list of non-negative integers representing
    the amount of money of each house, determine the maximum amount of money
    you can rob tonight without alerting the police.

    Example 1:
    Input: [2,3,2]
    Output: 3
    Explanation: You cannot rob house 1 (money = 2) and then rob house 3
                 (money = 2), because they are adjacent houses.

    Example 2:
    Input: [1,2,3,1]
    Output: 4
    Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
                 Total amount you can rob = 1 + 3 = 4."""

    def rob(self, nums: List[int]) -> int:

        def fn(lo, hi):
            """Return max money by robbing houses from lo to hi (exclusive)."""
            f0 = f1 = 0
            for x in nums[lo:hi]: f0, f1 = f1, max(f0+x, f1)
            return f1

        n = len(nums)
        return max(fn(0, n-1), fn(1, n)) if n > 1 else nums[0]


    """214. Shortest Palindrome (Hard)
    Given a string s, you are allowed to convert it to a palindrome by adding
    characters in front of it. Find and return the shortest palindrome you can
    find by performing this transformation.

    Example 1:
    Input: "aacecaaa"
    Output: "aaacecaaa"

    Example 2:
    Input: "abcd"
    Output: "dcbabcd" """

    def shortestPalindrome(self, s: str) -> str:
        ss = s + "#" + s[::-1]
        lps = [0]*len(ss) #longest prefix suffix array
        k = 0
        for i in range(1, len(ss)):
            while k and ss[k] != ss[i]:
                k = lps[k-1]
            if ss[k] == ss[i]: k += 1
            lps[i] = k
        return s[k:][::-1] + s


    """215. Kth Largest Element in an Array (Medium)
    Find the kth largest element in an unsorted array. Note that it is the kth
    largest element in the sorted order, not the kth distinct element.

    Example 1:
    Input: [3,2,1,5,6,4] and k = 2
    Output: 5

    Example 2:
    Input: [3,2,3,1,2,4,5,5,6] and k = 4
    Output: 4

    Note: You may assume k is always valid, 1 ≤ k ≤ array's length."""

    def findKthLargest(self, nums: List[int], k: int) -> int:
        """Hoare's selection algo"""

        def partition(lo, hi):
            """Return partition of nums[lo:hi]."""
            i, j = lo+1, hi-1
            while i <= j:
                if nums[i] < nums[lo]: i += 1
                elif nums[j] > nums[lo]: j -= 1
                else:
                    nums[i], nums[j] = nums[j], nums[i]
                    i += 1
                    j -= 1
            nums[lo], nums[j] = nums[j], nums[lo]
            return j

        shuffle(nums)
        lo, hi = 0, len(nums)
        while True:
            mid = partition(lo, hi)
            if mid+k < len(nums): lo = mid + 1
            elif mid+k == len(nums): return nums[mid]
            else: hi = mid


    """216. Combination Sum III (Medium)
    Find all possible combinations of k numbers that add up to a number n,
    given that only numbers from 1 to 9 can be used and each combination should
    be a unique set of numbers.

    Note: All numbers will be positive integers. The solution set must not
    contain duplicate combinations.

    Example 1:
    Input: k = 3, n = 7
    Output: [[1,2,4]]

    Example 2:
    Input: k = 3, n = 9
    Output: [[1,2,6], [1,3,5], [2,3,4]]"""

    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        ans, stack = [], []
        x = 1
        while True:
            if len(stack) == k and sum(stack) == n: ans.append(stack.copy())
            if len(stack) == k or k - len(stack) > 10 - x:
                if not stack: break
                x = stack.pop() + 1
            else:
                stack.append(x)
                x += 1
        return ans


    """217. Contains Duplicate (Easy)
    Given an array of integers, find if the array contains any duplicates. Your
    function should return true if any value appears at least twice in the
    array, and it should return false if every element is distinct.

    Example 1:
    Input: [1,2,3,1]
    Output: true

    Example 2:
    Input: [1,2,3,4]
    Output: false

    Example 3:
    Input: [1,1,1,3,3,4,3,2,4,2]
    Output: true"""

    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(nums) != len(set(nums))


    """218. The Skyline Problem (Hard)
    A city's skyline is the outer contour of the silhouette formed by all the
    buildings in that city when viewed from a distance. Now suppose you are
    given the locations and height of all the buildings as shown on a cityscape
    photo (Figure A), write a program to output the skyline formed by these
    buildings collectively (Figure B).

    Buildings Skyline Contour
    The geometric information of each building is represented by a triplet of
    integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left
    and right edge of the ith building, respectively, and Hi is its height. It
    is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0.
    You may assume all buildings are perfect rectangles grounded on an
    absolutely flat surface at height 0. For instance, the dimensions of all
    buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12],
    [15 20 10], [19 24 8] ]. The output is a list of "key points" (red dots in
    Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that
    uniquely defines a skyline. A key point is the left endpoint of a
    horizontal line segment. Note that the last key point, where the rightmost
    building ends, is merely used to mark the termination of the skyline, and
    always has zero height. Also, the ground in between any two adjacent
    buildings should be considered part of the skyline contour. For instance,
    the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12],
    [12 0], [15 10], [20 8], [24, 0] ].

    Notes:
    The number of buildings in any input list is guaranteed to be in the range
    [0, 10000]. The input list is already sorted in ascending order by the left
    x position Li. The output list must be sorted by the x position. There must
    be no consecutive horizontal lines of equal height in the output skyline.
    For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable;
    the three lines of height 5 should be merged into one in the final output as
    such: [...[2 3], [4 5], [12 7], ...]"""

    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        ans, hp = [], [] #front of heap => current height
        buildings.append([inf, inf, 0]) #trick
        for li, ri, hi in buildings:
            #down-slope
            while hp and -hp[0][1] < li:                  #current height cannot reach li
                _, rj = heappop(hp)                       #current height ends at rj
                while hp and -hp[0][1] <= -rj: heappop(hp) #useless height ends earlier than rj
                hj = hp[0][0] if hp else 0                #next height
                ans.append((-rj, -hj))
            #up-slope
            if hi > 0 and (not hp or -hp[0][0] < hi):     #new height higher than current height
                if ans and ans[-1][0] == li: ans.pop()    #same left => update in-place
                ans.append([li, hi])
            heappush(hp, (-hi, -ri))
        return ans


    """219. Contains Duplicate II (Easy)
    Given an array of integers and an integer k, find out whether there are two
    distinct indices i and j in the array such that nums[i] = nums[j] and the
    absolute difference between i and j is at most k.

    Example 1:
    Input: nums = [1,2,3,1], k = 3
    Output: true

    Example 2:
    Input: nums = [1,0,1,1], k = 1
    Output: true

    Example 3:
    Input: nums = [1,2,3,1,2,3], k = 2
    Output: false"""

    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        seen = dict()
        for i, x in enumerate(nums):
            if x in seen and i - seen[x] <= k: return True
            seen[x] = i
        return False


    """220. Contains Duplicate III (Medium)
    Given an array of integers, find out whether there are two distinct indices
    i and j in the array such that the absolute difference between nums[i] and
    nums[j] is at most t and the absolute difference between i and j is at most
    k.

    Example 1:
    Input: nums = [1,2,3,1], k = 3, t = 0
    Output: true

    Example 2:
    Input: nums = [1,0,1,1], k = 1, t = 2
    Output: true

    Example 3:
    Input: nums = [1,5,9,1,5,9], k = 2, t = 3
    Output: false"""

    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        if t < 0: return False #edge case
        seen = dict()
        for i in range(len(nums)):
            bkt = nums[i]//(t + 1) #bucket
            if any(bkt+ii in seen and abs(nums[i]-seen[bkt+ii]) <= t for ii in (-1, 0, 1)): return True
            seen[bkt] = nums[i]
            if i >= k: seen.pop(nums[i-k]//(t+1)) #memory of length k
        return False


    """221. Maximal Square (Medium)
    Given a 2D binary matrix filled with 0's and 1's, find the largest square
    containing only 1's and return its area.

    Example:
    Input:
    1 0 1 0 0
    1 0 1 1 1
    1 1 1 1 1
    1 0 0 1 0
    Output: 4"""

    def maximalSquare(self, matrix: List[List[str]]) -> int:
        m, n = len(matrix), len(matrix[0])
        dp = [[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == "1":
                    if i and j: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
                    else: dp[i][j] = 1
        return max(map(max, dp))**2


    """222. Count Complete Tree Nodes (Medium)
    Given a complete binary tree, count the number of nodes. Note the
    definition of a complete binary tree from Wikipedia: in a complete binary
    tree every level, except possibly the last, is completely filled, and all
    nodes in the last level are as far left as possible. It can have between 1
    and 2h nodes inclusive at the last level h.

    Example:
    Input:
        1
       / \
      2   3
     / \  /
    4  5 6
    Output: 6"""

    def countNodes(self, root: TreeNode) -> int:

        def ht(node):
            """Return height of given node."""
            n = 0
            while node: n, node = n+1, node.left
            return n

        def fn(node):
            """Return number of nodes in the tree rooted at given node."""
            if not node: return 0
            h = ht(node.left)
            if h == ht(node.right): return 2**h + fn(node.right)
            else: return 2**(h-1) + fn(node.left)

        return fn(root)


    """223. Rectangle Area (Medium)
    Find the total area covered by two rectilinear rectangles in a 2D plane.
    Each rectangle is defined by its bottom left corner and top right corner as
    shown in the figure.

    Example:
    Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2
    Output: 45

    Note: Assume that the total area is never beyond the maximum possible value
    of int."""

    def computeArea(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int) -> int:
        area1 = (C-A) * (D-B)
        area2 = (G-E) * (H-F)
        overlap = max(0, min(C, G) - max(A, E)) * max(0, min(D, H) - max(B, F))
        return area1 + area2 - overlap


    """224. Basic Calculator (Hard)
    Implement a basic calculator to evaluate a simple expression string. The
    expression string may contain open ( and closing parentheses ), the plus +
    or minus sign -, non-negative integers and empty spaces .

    Example 1:
    Input: "1 + 1"
    Output: 2

    Example 2:
    Input: " 2-1 + 2 "
    Output: 3

    Example 3:
    Input: "(1+(4+5+2)-3)+(6+8)"
    Output: 23

    Note:
    You may assume that the given expression is always valid.
    Do not use the eval built-in library function."""

    def calculate(self, s: str) -> int:
        ans, sign, val = 0, 1, 0
        stack = []
        for c in s:
            if c.isdigit():
                val = 10*val + int(c)
            elif c in "+-":
                ans += sign * val
                sign = 1 if c == "+" else -1
                val = 0
            elif c == "(":
                stack.append(ans)
                stack.append(sign)
                ans, sign = 0, 1
            elif c == ")":
                ans += sign * val
                ans *= stack.pop()
                ans += stack.pop()
                sign, val = 1, 0
        return ans + sign * val


    """226. Invert Binary Tree (Easy)
    Invert a binary tree.

    Example:
    Input:
         4
       /   \
      2     7
     / \   / \
    1   3 6   9

    Output:

         4
       /   \
      7     2
     / \   / \
    9   6 3   1

    Trivia: This problem was inspired by this original tweet by Max Howell:
    Google: 90% of our engineers use the software you wrote (Homebrew), but you
    can’t invert a binary tree on a whiteboard so f*** off."""

    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root:
            stack = [root]
            while stack:
                node = stack.pop()
                node.left, node.right = node.right, node.left
                if node.left: stack.append(node.left)
                if node.right: stack.append(node.right)
        return root


    """227. Basic Calculator II (Medium)
    Implement a basic calculator to evaluate a simple expression string. The
    expression string contains only non-negative integers, +, -, *, / operators
    and empty spaces . The integer division should truncate toward zero.

    Example 1:
    Input: "3+2*2"
    Output: 7

    Example 2:
    Input: " 3/2 "
    Output: 1

    Example 3:
    Input: " 3+5 / 2 "
    Output: 5

    Note:
    You may assume that the given expression is always valid. Do not use the
    eval built-in library function."""

    def calculate(self, s: str) -> int:
        op, val = "+", 0
        stack = []
        for i, c in enumerate(s):
            if c.isdigit(): val = 10*val + int(c)
            if i == len(s) - 1 or c in "+-*/":
                if   op == "+": stack.append(val)
                elif op == "-": stack.append(-val)
                elif op == "*": stack.append(stack.pop()*val)
                elif op == "/": stack.append(int(stack.pop()/val))
                op, val = c, 0
        return sum(stack)


    """228. Summary Ranges (Medium)
    Given a sorted integer array without duplicates, return the summary of its
    ranges.

    Example 1:
    Input:  [0,1,2,4,5,7]
    Output: ["0->2","4->5","7"]
    Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.

    Example 2:
    Input:  [0,2,3,4,6,8,9]
    Output: ["0","2->4","6","8->9"]
    Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range."""

    def summaryRanges(self, nums: List[int]) -> List[str]:
        ans = []
        for i, x in enumerate(nums):
            if not i or nums[i-1]+1 != x: val = [x] #start of a range
            if i == len(nums)-1 or x+1 != nums[i+1]:
                if val[-1] != x: val.append(x) #end of a range
                ans.append(val)
        return ["->".join(map(str, x)) for x in ans]


    """229. Majority Element II (Medium)
    Given an integer array of size n, find all elements that appear more than
    ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1)
    space.

    Example 1:
    Input: [3,2,3]
    Output: [3]

    Example 2:
    Input: [1,1,1,3,3,2,2,2]
    Output: [1,2]"""

    def majorityElement(self, nums: List[int]) -> List[int]:
        ans, vote = [None]*2, [0]*2
        for x in nums:
            if vote[0] == 0 and x not in ans: ans[0] = x
            elif vote[1] == 0 and x not in ans: ans[1] = x

            if ans[0] == x: vote[0] += 1
            elif ans[1] == x: vote[1] += 1
            else: vote = [x-1 for x in vote]
        return [x for x in ans if nums.count(x) > len(nums)//3]


    """230. Kth Smallest Element in a BST (Medium)
    Given a binary search tree, write a function kthSmallest to find the kth
    smallest element in it.

    Example 1:
    Input: root = [3,1,4,null,2], k = 1
       3
      / \
     1   4
      \
       2
    Output: 1

    Example 2:
    Input: root = [5,3,6,2,4,null,null,1], k = 3
           5
          / \
         3   6
        / \
       2   4
      /
     1
    Output: 3

    Follow up: What if the BST is modified (insert/delete operations) often and
    you need to find the kth smallest frequently? How would you optimize the
    kth Smallest routine?

    Constraints:
    The number of elements of the BST is between 1 to 10^4.
    You may assume k is always valid, 1 ≤ k ≤ BST's total elements."""

    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        node = root
        stack = []
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                k -= 1
                if k == 0: return node.val
                node = node.right


    """231. Power of Two (Easy)
    Given an integer, write a function to determine if it is a power of two.

    Example 1:
    Input: 1
    Output: true
    Explanation: 20 = 1

    Example 2:
    Input: 16
    Output: true
    Explanation: 24 = 16

    Example 3:
    Input: 218
    Output: false"""

    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and n & (n-1) == 0


    """233. Number of Digit One (Hard)
    Given an integer n, count the total number of digit 1 appearing in all non-
    negative integers less than or equal to n.

    Example:
    Input: 13
    Output: 6

    Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13."""

    def countDigitOne(self, n: int) -> int:
        ans = digit = tail = 0
        magn = 1 # magnitude
        while n:
            tail = digit * magn//10 + tail # move digit to tail
            n, digit = divmod(n, 10) # seprate digit from head

            ans += n * magn
            if digit > 1: ans += magn
            elif digit == 1: ans += tail + 1 # tail + 1 considering 000...

            magn *= 10
        return ans


    """234. Palindrome Linked List (Easy)
    Given a singly linked list, determine if it is a palindrome.

    Example 1:
    Input: 1->2
    Output: false

    Example 2:
    Input: 1->2->2->1
    Output: true

    Follow up: Could you do it in O(n) time and O(1) space?"""

    def isPalindrome(self, head: ListNode) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

        prev = None
        while slow: slow.next, slow, prev = prev, slow.next, slow

        while prev and head.val == prev.val:
            head = head.next
            prev = prev.next

        return not prev


    """235. Lowest Common Ancestor of a Binary Search Tree (Easy)
    Given a binary search tree (BST), find the lowest common ancestor (LCA) of
    two given nodes in the BST. According to the definition of LCA on
    Wikipedia: "The lowest common ancestor is defined between two nodes p and q
    as the lowest node in T that has both p and q as descendants (where we
    allow a node to be a descendant of itself)."

    Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

    Example 1:
    Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
    Output: 6
    Explanation: The LCA of nodes 2 and 8 is 6.

    Example 2:
    Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
    Output: 2
    Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a
    descendant of itself according to the LCA definition.

    Constraints:
    All of the nodes' values will be unique.
    p and q are different and both values will exist in the BST."""

    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val > q.val: p, q = q, p
        node = root
        while node:
            if node.val < p.val: node = node.right
            elif p.val <= node.val <= q.val: return node
            else: node = node.left


    """236. Lowest Common Ancestor of a Binary Tree (Medium)
    Given a binary tree, find the lowest common ancestor (LCA) of two given
    nodes in the tree. According to the definition of LCA on Wikipedia: “The
    lowest common ancestor is defined between two nodes p and q as the lowest
    node in T that has both p and q as descendants (where we allow a node to be
    a descendant of itself).” Given the following binary tree:

    root = [3,5,1,6,2,0,8,null,null,7,4]

    Example 1:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    Output: 3
    Explanation: The LCA of nodes 5 and 1 is 3.

    Example 2:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    Output: 5
    Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a
                 descendant of itself according to the LCA definition.

    Note:
    All of the nodes' values will be unique.
    p and q are different and both values will exist in the binary tree."""

    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        def fn(node):
            """Return LCA of p and q in subtree rooted at node (if found)."""
            if not node or node in (p, q): return node
            left, right = fn(node.left), fn(node.right)
            return node if left and right else left or right

        return fn(root)


    """237. Delete Node in a Linked List (Easy)
    Write a function to delete a node (except the tail) in a singly linked
    list, given only access to that node. Given linked list --
    head = [4,5,1,9], which looks like following:

    4 -> 5 -> 1 -> 9

    Example 1:
    Input: head = [4,5,1,9], node = 5
    Output: [4,1,9]
    Explanation: You are given the second node with value 5, the linked list
    should become 4 -> 1 -> 9 after calling your function.

    Example 2:
    Input: head = [4,5,1,9], node = 1
    Output: [4,5,9]
    Explanation: You are given the third node with value 1, the linked list
    should become 4 -> 5 -> 9 after calling your function.

    Note:
    * The linked list will have at least two elements.
    * All of the nodes' values will be unique.
    * The given node will not be the tail and it will always be a valid node of
      the linked list.
    * Do not return anything from your function."""

    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next


    """238. Product of Array Except Self (Medium)
    Given an array nums of n integers where n > 1,  return an array output
    such that output[i] is equal to the product of all the elements of nums
    except nums[i].

    Example:
    Input:  [1,2,3,4]
    Output: [24,12,8,6]

    Constraint: It's guaranteed that the product of the elements of any prefix
                or suffix of the array (including the whole array) fits in a 32
                bit integer.

    Note: Please solve it without division and in O(n).

    Follow up: Could you solve it with constant space complexity? (The output
               array does not count as extra space for the purpose of space
               complexity analysis.)"""

    def productExceptSelf(self, nums: List[int]) -> List[int]:
        ans = [1] * len(nums)
        prefix = suffix = 1
        for i in range(len(nums)):
            ans[i] *= prefix
            ans[~i] *= suffix
            prefix *= nums[i]
            suffix *= nums[~i]
        return ans


    """239. Sliding Window Maximum (Hard)
    Given an array nums, there is a sliding window of size k which is moving
    from the very left of the array to the very right. You can only see the k
    numbers in the window. Each time the sliding window moves right by one
    position. Return the max sliding window.

    Follow up: Could you solve it in linear time?

    Example:
    Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
    Output: [3,3,5,5,6,7]
    Explanation:

    Window position                Max
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       3
     1 [3  -1  -3] 5  3  6  7       3
     1  3 [-1  -3  5] 3  6  7       5
     1  3  -1 [-3  5  3] 6  7       5
     1  3  -1  -3 [5  3  6] 7       6
     1  3  -1  -3  5 [3  6  7]      7

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^4 <= nums[i] <= 10^4
    * 1 <= k <= nums.length"""

    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []
        queue = deque() #decreasing queue
        for i, x in enumerate(nums):
            while queue and queue[-1][1] <= x: queue.pop() #remove redundant
            queue.append((i, x))
            if queue and i - queue[0][0] == k: queue.popleft() #remove expired
            if i+1 >= k: ans.append(queue[0][1])
        return ans


    """240. Search a 2D Matrix II (Medium)
    Write an efficient algorithm that searches for a target value in an m x n
    integer matrix. The matrix has the following properties:
    * Integers in each row are sorted in ascending from left to right.
    * Integers in each column are sorted in ascending from top to bottom.

    Example 1:
    Input: matrix = [[ 1, 4, 7,11,15],
                     [ 2, 5, 8,12,19],
                     [ 3, 6, 9,16,22],
                     [10,13,14,17,24],
                     [18,21,23,26,30]], target = 5
    Output: true

    Example 2:
    Input: matrix = [[ 1, 4, 7,11,15],
                     [ 2, 5, 8,12,19],
                     [ 3, 6, 9,16,22],
                     [10,13,14,17,24],
                     [18,21,23,26,30]], target = 20
    Output: false

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= n, m <= 300
    * -10^9 <= matix[i][j] <= 10^9
    * All the integers in each row are sorted in ascending order.
    * All the integers in each column are sorted in ascending order.
    * -10^9 <= target <= 10^9"""

    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        i, j = 0, n-1
        while i < m and 0 <= j:
            if matrix[i][j] < target: i += 1
            elif matrix[i][j] == target: return True
            else: j -= 1
        return False


    """241. Different Ways to Add Parentheses (Medium)
    Given a string of numbers and operators, return all possible results from
    computing all the different possible ways to group numbers and operators.
    The valid operators are +, - and *.

    Example 1:
    Input: "2-1-1"
    Output: [0, 2]
    Explanation: ((2-1)-1) = 0
                 (2-(1-1)) = 2

    Example 2:
    Input: "2*3-4*5"
    Output: [-34, -14, -10, -10, 10]
    Explanation: (2*(3-(4*5))) = -34
                 ((2*3)-(4*5)) = -14
                 ((2*(3-4))*5) = -10
                 (2*((3-4)*5)) = -10
                 (((2*3)-4)*5) = 10"""

    def diffWaysToCompute(self, input: str) -> List[int]:
        #pre-processing to tokenize input
        tokens = re.split(r'(\D)', input)
        mp = {"+": add, "-": sub, "*": mul}
        for i, token in enumerate(tokens):
            if token.isdigit(): tokens[i] = int(token)
            else: tokens[i] = mp[token]

        def fn(lo, hi):
            """Return possible outcomes of tokens[lo:hi]"""
            if lo+1 == hi: return [tokens[lo]]
            ans = []
            for mid in range(lo+1, hi, 2):
                ans.extend(tokens[mid](x, y) for x in fn(lo, mid) for y in fn(mid+1, hi))
            return ans

        return fn(0, len(tokens))



    """242. Valid Anagram (Easy)
    Given two strings s and t , write a function to determine if t is an
    anagram of s.

    Example 1:
    Input: s = "anagram", t = "nagaram"
    Output: true

    Example 2:
    Input: s = "rat", t = "car"
    Output: false

    Note: You may assume the string contains only lowercase alphabets.

    Follow up: What if the inputs contain unicode characters? How would you
               adapt your solution to such case?"""

    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)


    """243. Shortest Word Distance (Easy)
    Given a list of words and two words word1 and word2, return the shortest
    distance between these two words in the list.

    Example:
    Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
    Input: word1 = “coding”, word2 = “practice”
    Output: 3
    Input: word1 = "makes", word2 = "coding"
    Output: 1
    Note: You may assume that word1 does not equal to word2, and word1 and
          word2 are both in the list."""

    def shortestDistance(self, words: List[str], word1: str, word2: str) -> int:
        ans = i1 = i2 = inf
        for i, word in enumerate(words):
            if word == word1: i1 = i
            elif word == word2: i2 = i
            ans = min(ans, abs(i1 - i2))
        return ans


    """245. Shortest Word Distance III (Medium)
    Given a list of words and two words word1 and word2, return the shortest
    distance between these two words in the list. word1 and word2 may be the
    same and they represent two individual words in the list.

    Example:
    Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
    Input: word1 = “makes”, word2 = “coding”
    Output: 1
    Input: word1 = "makes", word2 = "makes"
    Output: 3

    Note: You may assume word1 and word2 are both in the list."""

    def shortestWordDistance(self, words: List[str], word1: str, word2: str) -> int:
        ans = i1 = i2 = inf
        for i, word in enumerate(words):
            if word == word1: i1 = i2 if word1 == word2 else i
            if word == word2: i2 = i
            ans = min(ans, abs(i1-i2))
        return ans


    """246. Strobogrammatic Number (Easy)
    A strobogrammatic number is a number that looks the same when rotated 180
    degrees (looked at upside down). Write a function to determine if a number
    is strobogrammatic. The number is represented as a string.

    Example 1:
    Input: num = "69"
    Output: true

    Example 2:
    Input: num = "88"
    Output: true

    Example 3:
    Input: num = "962"
    Output: false

    Example 4:
    Input: num = "1"
    Output: true"""

    def isStrobogrammatic(self, num: str) -> bool:
        mp = {"0":"0", "1":"1", "6":"9", "8":"8", "9":"6"}
        return all(mp.get(num[i]) == num[~i] for i in range(len(num)//2+1))


    """247. Strobogrammatic Number II (Medium)
    A strobogrammatic number is a number that looks the same when rotated 180
    degrees (looked at upside down). Find all strobogrammatic numbers that are
    of length = n.

    Example:
    Input:  n = 2
    Output: ["11","69","88","96"]"""

    def findStrobogrammatic(self, n: int) -> List[str]:
        mp = ["00", "11", "69", "88", "96"]

        def fn(n):
            """Return strobogrammatic number of length n."""
            if n == 0: return [""]
            if n == 1: return ["0", "1", "8"]
            return [x+y+xx for x, xx in mp for y in fn(n-2)]

        ans = fn(n)
        return [x for x in ans if not x.startswith("0")] if n > 1 else ans


    """249. Group Shifted Strings (Medium)
    Given a string, we can "shift" each of its letter to its successive letter,
    for example: "abc" -> "bcd". We can keep "shifting" which forms the sequence:
    "abc" -> "bcd" -> ... -> "xyz"
    Given a list of non-empty strings which contains only lowercase alphabets,
    group all strings that belong to the same shifting sequence.

    Example:
    Input: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"],
    Output:
    [
      ["abc","bcd","xyz"],
      ["az","ba"],
      ["acef"],
      ["a","z"]
    ]"""

    def groupStrings(self, strings: List[str]) -> List[List[str]]:
        ans = {}
        for string in strings:
            key = []
            for i in range(1, len(string)):
                key.append((ord(string[i]) - ord(string[0])) % 26)
            ans.setdefault("#".join(map(str, key)), []).append(string)
        return ans.values()


    """250. Count Univalue Subtrees (Medium)
    Given the root of a binary tree, return the number of uni-value subtrees. A
    uni-value subtree means all nodes of the subtree have the same value.

    Example 1:
    Input: root = [5,1,5,5,5,null,5]
    Output: 4

    Example 2:
    Input: root = []
    Output: 0

    Example 3:
    Input: root = [5,5,5,5,5,null,5]
    Output: 6

    Constraints:
    * The numbrt of the node in the tree will be in the range [0, 1000].
    * -1000 <= Node.val <= 1000"""

    def countUnivalSubtrees(self, root: TreeNode) -> int:
        if not root: return 0

        def fn(node):
            """Return count of univalue subtrees of sub-tree rooted at node."""
            lc = rc = 0
            lv = rv = node.val
            if node.left: lc, lv = fn(node.left)
            if node.right: rc, rv = fn(node.right)
            if lv == rv == node.val: return lc + rc + 1, node.val
            return lc + rc, None

        return fn(root)[0]


    """252. Meeting Rooms (Easy)
    Given an array of meeting time intervals where intervals[i] = [starti, endi],
    determine if a person could attend all meetings.

    Example 1:
    Input: intervals = [[0,30],[5,10],[15,20]]
    Output: false

    Example 2:
    Input: intervals = [[7,10],[2,4]]
    Output: true

    Constraints:
    * 0 <= intervals.length <= 10^4
    * intervals[i].length == 2
    * 0 <= starti < endi <= 10^6"""

    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        intervals.sort()
        return all(intervals[i-1][1] <= intervals[i][0] for i in range(1, len(intervals)))


    """253. Meeting Rooms II (Medium)
    Given an array of meeting time intervals intervals where
    intervals[i] = [starti, endi], return the minimum number of conference
    rooms required.

    Example 1:
    Input: intervals = [[0,30],[5,10],[15,20]]
    Output: 2

    Example 2:
    Input: intervals = [[7,10],[2,4]]
    Output: 1

    Constraints:
    *1 <= intervals.length <= 10^4
    *0 <= starti < endi <= 10^6"""

    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        pq = []
        for x, y in intervals:
            heappush(pq, (x, +1))
            heappush(pq, (y, -1))

        ans = prefix = 0
        while pq:
            _, x = heappop(pq)
            prefix += x
            ans = max(ans, prefix)
        return ans


    """254. Factor Combinations (Medium)
    Numbers can be regarded as product of its factors. For example,
    8 = 2 x 2 x 2 = = 2 x 4.
    Write a function that takes an integer n and return all possible
    combinations of its factors.

    Note:
    * You may assume that n is always positive.
    * Factors should be greater than 1 and less than n.

    Example 1:
    Input: 1
    Output: []

    Example 2:
    Input: 37
    Output:[]

    Example 3:
    Input: 12
    Output: [[2, 6],
             [2, 2, 3],
             [3, 4]]

    Example 4:
    Input: 32
    Output: [[2, 16],
             [2, 2, 8],
             [2, 2, 2, 4],
             [2, 2, 2, 2, 2],
             [2, 4, 4],
             [4, 8]]"""

    def getFactors(self, n: int) -> List[List[int]]:
        factors = [k for k in range(2, int(sqrt(n))+1) if n % k == 0]

        def fn(i, n):
            """Populate ans via a stack."""
            if len(stack) > 0 and stack[-1] <= n: ans.append(stack + [n])
            for ii in range(i, len(factors)):
                if n % factors[ii] == 0:
                    stack.append(factors[ii])
                    fn(ii, n//factors[ii])
                    stack.pop()

        ans, stack = [], []
        fn(0, n)
        return ans


    """255. Verify Preorder Sequence in Binary Search Tree (Medium)
    Given an array of numbers, verify whether it is the correct preorder
    traversal sequence of a binary search tree. You may assume each number in
    the sequence is unique. Consider the following binary search tree:

         5
        / \
       2   6
      / \
     1   3

    Example 1:
    Input: [5,2,6,1,3]
    Output: false

    Example 2:
    Input: [5,2,1,3,6]
    Output: true

    Follow up: Could you do it using only constant space complexity?"""

    def verifyPreorder(self, preorder: List[int]) -> bool:
        lo = -inf
        stack = []
        for x in preorder:
            if x < lo: return False
            while stack and stack[-1] < x: lo = stack.pop()
            stack.append(x)
        return True


    """256. Paint House (Medium)
    There is a row of n houses, where each house can be painted one of three
    colors: red, blue, or green. The cost of painting each house with a certain
    color is different. You have to paint all the houses such that no two
    adjacent houses have the same color. The cost of painting each house with a
    certain color is represented by a n x 3 cost matrix. For example,
    costs[0][0] is the cost of painting house 0 with the color red; costs[1][2]
    is the cost of painting house 1 with color green, and so on... Find the
    minimum cost to paint all houses.

    Example 1:
    Input: costs = [[17,2,17],[16,16,5],[14,3,19]]
    Output: 10
    Explanation: Paint house 0 into blue, paint house 1 into green, paint house
                 2 into blue. Minimum cost: 2 + 5 + 3 = 10.

    Example 2:
    Input: costs = []
    Output: 0

    Example 3:
    Input: costs = [[7,6,2]]
    Output: 2

    Constraints:
    * costs.length == n
    * costs[i].length == 3
    * 0 <= n <= 100
    * 1 <= costs[i][j] <= 20"""

    def minCost(self, costs: List[List[int]]) -> int:

        @cache
        def fn(i, j):
            """Return min cost of painting ith house w/ jth color."""
            if i == len(costs): return 0 # no more houses to paint
            return costs[i][j] + min(fn(i+1, jj) for jj in range(3) if j != jj)

        return min(fn(0, j) for j in range(3))


    """257. Binary Tree Paths (Easy)
    Given a binary tree, return all root-to-leaf paths.

    Note: A leaf is a node with no children.

    Example:
    Input:

       1
     /   \
    2     3
     \
      5
    Output: ["1->2->5", "1->3"]

    Explanation: All root-to-leaf paths are: 1->2->5, 1->3"""

    def binaryTreePaths(self, root: TreeNode) -> List[str]:

        def fn(node):
            """Populate ans with a stack via backtracking."""
            if not node: return #null node
            stack.append(node.val)
            if node.left is node.right: ans.append("->".join(map(str, stack))) #leaf node
            fn(node.left) or fn(node.right)
            stack.pop()

        ans, stack = [], []
        fn(root)
        return ans


    """258. Add Digits (Easy)
    Given a non-negative integer num, repeatedly add all its digits until the
    result has only one digit.

    Example:
    Input: 38
    Output: 2
    Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.
                 Since 2 has only one digit, return it.

    Follow up: Could you do it without any loop/recursion in O(1) runtime?"""

    def addDigits(self, num: int) -> int:
        return num and 1 + (num - 1) % 9


    """259. 3Sum Smaller (Medium)
    Given an array of n integers nums and an integer target, find the number of
    index triplets i, j, k with 0 <= i < j < k < n that satisfy the condition
    nums[i] + nums[j] + nums[k] < target.

    Follow up: Could you solve it in O(n2) runtime?

    Example 1:
    Input: nums = [-2,0,1,3], target = 2
    Output: 2
    Explanation: Because there are two triplets which sums are less than 2:
    [-2,0,1]
    [-2,0,3]

    Example 2:
    Input: nums = [], target = 0
    Output: 0

    Example 3:
    Input: nums = [0], target = 0
    Output: 0

    Constraints:
    * n == nums.length
    * 0 <= n <= 300
    * -100 <= nums[i] <= 100
    * -100 <= target <= 100"""

    def threeSumSmaller(self, nums: List[int], target: int) -> int:
        nums.sort()
        ans = 0
        for i in range(len(nums)):
            lo, hi = i+1, len(nums)-1
            while lo < hi:
                if nums[i] + nums[lo] + nums[hi] >= target: hi -= 1
                else:
                    ans += hi - lo
                    lo += 1
        return ans


    """260. Single Number III (Medium)
    Given an array of numbers nums, in which exactly two elements appear only
    once and all the other elements appear exactly twice. Find the two elements
    that appear only once.

    Example:
    Input:  [1,2,1,3,2,5]
    Output: [3,5]

    Note:
    The order of the result is not important. So in the above example, [5, 3]
    is also correct. Your algorithm should run in linear runtime complexity.
    Could you implement it using only constant space complexity?"""

    def singleNumber(self, nums: List[int]) -> List[int]:
        val = reduce(xor, nums)
        val &= -val
        ans = [0, 0]
        for x in nums:
            if x&val: ans[0] ^= x
            else: ans[1] ^= x
        return ans


    """261. Graph Valid Tree (Medium)
    You have a graph of n nodes labeled from 0 to n - 1. You are given an
    integer n and a list of edges where edges[i] = [ai, bi] indicates that
    there is an undirected edge between nodes ai and bi in the graph. Return
    true if the edges of the given graph make up a valid tree, and false
    otherwise.

    Example 1:
    Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
    Output: true

    Example 2:
    Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
    Output: false

    Constraints:
    * 1 <= 2000 <= n
    * 0 <= edges.length <= 5000
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * There are no self-loops or repeated edges."""

    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        uf = UnionFind(n)
        for u, v in edges:
            if not uf.union(u, v): return False
            n -= 1
        return n == 1


    """263. Ugly Number (Easy)
    Write a program to check whether a given number is an ugly number. Ugly
    numbers are positive numbers whose prime factors only include 2, 3, 5.

    Example 1:
    Input: 6
    Output: true
    Explanation: 6 = 2 × 3

    Example 2:
    Input: 8
    Output: true
    Explanation: 8 = 2 × 2 × 2

    Example 3:
    Input: 14
    Output: false
    Explanation: 14 is not ugly since it includes another prime factor 7.

    Note:
    * 1 is typically treated as an ugly number.
    * Input is within the 32-bit signed integer range: [−2^31,  2^31 − 1]."""

    def isUgly(self, n: int) -> bool:
        if n <= 0: return False
        for f in 2,3,5:
            while n%f == 0: n //= f
        return n == 1


    """264. Ugly Number II (Medium)
    Write a program to find the n-th ugly number. Ugly numbers are positive
    numbers whose prime factors only include 2, 3, 5.

    Example:
    Input: n = 10
    Output: 12
    Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first
                 10 ugly numbers.

    Note:
    * 1 is typically treated as an ugly number.
    * n does not exceed 1690."""

    def nthUglyNumber(self, n: int) -> int:
        ans = [1]
        p2 = p3 = p5 = 0
        for _ in range(n-1):
            cand = min(2*ans[p2], 3*ans[p3], 5*ans[p5])
            ans.append(cand)
            if 2*ans[p2] == cand: p2 += 1
            if 3*ans[p3] == cand: p3 += 1
            if 5*ans[p5] == cand: p5 += 1
        return ans[-1]


    """265. Paint House II (Hard)
    There are a row of n houses, each house can be painted with one of the k
    colors. The cost of painting each house with a certain color is different.
    You have to paint all the houses such that no two adjacent houses have the
    same color. The cost of painting each house with a certain color is
    represented by an n x k cost matrix costs. For example, costs[0][0] is the
    cost of painting house 0 with color 0; costs[1][2] is the cost of painting
    house 1 with color 2, and so on... Return the minimum cost to paint all
    houses.

    Example 1:
    Input: costs = [[1,5,3],[2,9,4]]
    Output: 5
    Explanation: Paint house 0 into color 0, paint house 1 into color 2.
                 Minimum cost: 1 + 4 = 5; Or paint house 0 into color 2, paint
                 house 1 into color 0. Minimum cost: 3 + 2 = 5.

    Example 2:
    Input: costs = [[1,3],[2,4]]
    Output: 5

    Constraints:
    * costs.length == n
    * costs[i].length == k
    * 1 <= n <= 100
    * 2 <= k <= 20
    * 1 <= costs[i][j] <= 20

    Follow up: Could you solve it in O(nk) runtime?"""

    def minCostII(self, costs: List[List[int]]) -> int:
        n, k = len(costs), len(costs[0])
        for i in range(1, n):
            m0 = m1 = -1
            for j in range(k):
                if m0 == -1 or costs[i-1][j] <= costs[i-1][m0]: m0, m1 = j, m0
                elif m1 == -1 or costs[i-1][j] < costs[i-1][m1]: m1 = j
            for j in range(k):
                if j == m0: costs[i][j] += costs[i-1][m1]
                else: costs[i][j] += costs[i-1][m0]
        return min(costs[-1])


    """266. Palindrome Permutation (Easy)
    Given a string, determine if a permutation of the string could form a
    palindrome.

    Example 1:
    Input: "code"
    Output: false

    Example 2:
    Input: "aab"
    Output: true

    Example 3:
    Input: "carerac"
    Output: true"""

    def canPermutePalindrome(self, s: str) -> bool:
        freq = {}
        for c in s: freq[c] = 1 + freq.get(c, 0)
        return sum(v&1 for v in freq.values()) <= 1


    """267. Palindrome Permutation II (Medium)
    Given a string s, return all the palindromic permutations (without
    duplicates) of it. Return an empty list if no palindromic permutation could
    be form.

    Example 1:
    Input: "aabb"
    Output: ["abba", "baab"]

    Example 2:
    Input: "abc"
    Output: []"""

    def generatePalindromes(self, s: str) -> List[str]:
        freq = {}
        for c in s: freq[c] = 1 + freq.get(c, 0)

        mid = []
        for k, v in freq.items():
            if v&1: mid.append(k)

        ans = []
        if len(mid) <= 1:

            def fn(x):
                """Populate ans via backtracking."""
                if len(x) == len(s): ans.append(x)
                for k, v in freq.items():
                    if v >= 2:
                        freq[k] -= 2
                        fn(k + x + k)
                        freq[k] += 2

            fn(mid.pop() if mid else "")
        return ans


    """268. Missing Number (Easy)
    Given an array containing n distinct numbers taken from 0, 1, 2, ..., n,
    find the one that is missing from the array.

    Example 1:
    Input: [3,0,1]
    Output: 2

    Example 2:
    Input: [9,6,4,2,3,5,7,0,1]
    Output: 8

    Note: Your algorithm should run in linear runtime complexity. Could you
    implement it using only constant extra space complexity?"""

    def missingNumber(self, nums: List[int]) -> int:
        ans = 0
        for i, x in enumerate(nums):
            ans ^= i+1 ^ x
        return ans


    """270. Closest Binary Search Tree Value (Easy)
    Given a non-empty binary search tree and a target value, find the value in
    the BST that is closest to the target.

    Note:
    * Given target value is a floating point.
    * You are guaranteed to have only one unique value in the BST that is closest to the target.

    Example:
    Input: root = [4,2,5,1,3], target = 3.714286
        4
       / \
      2   5
     / \
    1   3
    Output: 4"""

    def closestValue(self, root: TreeNode, target: float) -> int:
        ans = inf
        node = root
        while node:
            if node.val == target: return node.val
            ans = min(ans, node.val, key=lambda x: abs(x-target))
            if node.val < target: node = node.right
            else: node = node.left
        return ans


    """273. Integer to English Words (Hard)
    Convert a non-negative integer to its english words representation. Given
    input is guaranteed to be less than 2^31 - 1.

    Example 1:
    Input: 123
    Output: "One Hundred Twenty Three"

    Example 2:
    Input: 12345
    Output: "Twelve Thousand Three Hundred Forty Five"

    Example 3:
    Input: 1234567
    Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty
            Seven"

    Example 4:
    Input: 1234567891
    Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty
            Seven Thousand Eight Hundred Ninety One" """

    def numberToWords(self, num: int) -> str:
        mp = {1: "One",   11: "Eleven",    10: "Ten",
              2: "Two",   12: "Twelve",    20: "Twenty",
              3: "Three", 13: "Thirteen",  30: "Thirty",
              4: "Four",  14: "Fourteen",  40: "Forty",
              5: "Five",  15: "Fifteen",   50: "Fifty",
              6: "Six",   16: "Sixteen",   60: "Sixty",
              7: "Seven", 17: "Seventeen", 70: "Seventy",
              8: "Eight", 18: "Eighteen",  80: "Eighty",
              9: "Nine",  19: "Nineteen",  90: "Ninety"}

        def fn(n):
            """Return English words of n (0-999) in array."""
            if not n: return []
            elif n < 20: return [mp[n]]
            elif n < 100: return [mp[n//10*10]] + fn(n%10)
            else: return [mp[n//100], "Hundred"] + fn(n%100)

        ans = []
        for i, unit in zip((9, 6, 3, 0), ("Billion", "Million", "Thousand", "")):
            n, num = divmod(num, 10**i)
            ans.extend(fn(n))
            if n and unit: ans.append(unit)
        return " ".join(ans) or "Zero"


    """274. H-Index (Medium)
    Given an array of citations (each citation is a non-negative integer) of a
    researcher, write a function to compute the researcher's h-index. According
    to the definition of h-index on Wikipedia: "A scientist has index h if h of
    his/her N papers have at least h citations each, and the other N − h papers
    have no more than h citations each."

    Example:
    Input: citations = [3,0,6,1,5]
    Output: 3
    Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and
                 each of them had received 3, 0, 6, 1, 5 citations respectively.
                 Since the researcher has 3 papers with at least 3 citations
                 each and the remaining two with no more than 3 citations each,
                 her h-index is 3.

    Note: If there are several possible values for h, the maximum one is taken
          as the h-index."""

    def hIndex(self, citations: List[int]) -> int:
        citations.sort(reverse=True)
        arr = [i-c for i, c in enumerate(citations, 1)]
        return bisect_right(arr, 0) #right-most occurrence of i <= c


    """275. H-Index II (Medium)
    Given an array of citations sorted in ascending order (each citation is a
    non-negative integer) of a researcher, write a function to compute the
    researcher's h-index. According to the definition of h-index on Wikipedia:
    "A scientist has index h if h of his/her N papers have at least h citations
    each, and the other N − h papers have no more than h citations each."

    Example:
    Input: citations = [0,1,3,5,6]
    Output: 3
    Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and
                 each of them had received 0, 1, 3, 5, 6 citations respectively.
                 Since the researcher has 3 papers with at least 3 citations
                 each and the remaining two with no more than 3 citations each,
                 her h-index is 3.

    Note: If there are several possible values for h, the maximum one is taken
          as the h-index.

    Follow up:
    This is a follow up problem to H-Index, where citations is now guaranteed
    to be sorted in ascending order. Could you solve it in logarithmic time
    complexity?"""

    def hIndex(self, citations: List[int]) -> int:
        lo = 0
        hi = n = len(citations)
        while lo < hi:
            mid = (lo + hi)//2
            if citations[mid] >= n - mid: hi = mid #less paper than citation
            else: lo = mid + 1
        return n - lo


    """276. Paint Fence (Easy)
    There is a fence with n posts, each post can be painted with one of the k
    colors. You have to paint all the posts such that no more than two adjacent
    fence posts have the same color. Return the total number of ways you can
    paint the fence.

    Note: n and k are non-negative integers.

    Example:
    Input: n = 3, k = 2
    Output: 6
    Explanation: Take c1 as color 1, c2 as color 2. All possible ways are:

                post1  post2  post3
     -----      -----  -----  -----
       1         c1     c1     c2
       2         c1     c2     c1
       3         c1     c2     c2
       4         c2     c1     c1
       5         c2     c1     c2
       6         c2     c2     c1"""

    def numWays(self, n: int, k: int) -> int:
        if not n: return 0
        f0, f1 = k, k*k
        for _ in range(1, n):
            f0, f1 = f1, (k-1)*(f0+f1)
        return f0


    """277. Find the Celebrity (Medium)
    Suppose you are at a party with n people (labeled from 0 to n - 1), and
    among them, there may exist one celebrity. The definition of a celebrity is
    that all the other n - 1 people know him/her, but he/she does not know any
    of them. Now you want to find out who the celebrity is or verify that there
    is not one. The only thing you are allowed to do is to ask questions like:
    "Hi, A. Do you know B?" to get information about whether A knows B. You
    need to find out the celebrity (or verify there is not one) by asking as
    few questions as possible (in the asymptotic sense). You are given a helper
    function bool knows(a, b) which tells you whether A knows B. Implement a
    function int findCelebrity(n). There will be exactly one celebrity if
    he/she is in the party. Return the celebrity's label if there is a
    celebrity in the party. If there is no celebrity, return -1.

    Example 1:
    Input: graph = [[1,1,0],[0,1,0],[1,1,1]]
    Output: 1
    Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1
                 means person i knows person j, otherwise graph[i][j] = 0 means
                 person i does not know person j. The celebrity is the person
                 labeled as 1 because both 0 and 2 know him but 1 does not know
                 anybody.

    Example 2:
    Input: graph = [[1,0,1],[1,1,0],[0,1,1]]
    Output: -1
    Explanation: There is no celebrity.

    Constraints:
    * n == graph.length
    * n == graph[i].length
    * 2 <= n <= 100
    * graph[i][j] is 0 or 1.
    * graph[i][i] == 1

    Follow up: If the maximum number of allowed calls to the API knows is 3 * n,
               could you find a solution without exceeding the maximum number
               of calls?"""

    def findCelebrity(self, n: int) -> int:
        k = 0
        for i in range(1, n):
            if knows(k, i): k = i
        return k if all(knows(i, k) for i in range(n)) and not any(knows(k, i) for i in range(n) if i != k) else -1


    """278. First Bad Version (Easy)
    You are a product manager and currently leading a team to develop a new
    product. Unfortunately, the latest version of your product fails the
    quality check. Since each version is developed based on the previous
    version, all the versions after a bad version are also bad. Suppose you
    have n versions [1, 2, ..., n] and you want to find out the first bad one,
    which causes all the following ones to be bad. You are given an API bool
    isBadVersion(version) which will return whether version is bad. Implement
    a function to find the first bad version. You should minimize the number of
    calls to the API.

    Example:
    Given n = 5, and version = 4 is the first bad version.
    call isBadVersion(3) -> false
    call isBadVersion(5) -> true
    call isBadVersion(4) -> true

    Then 4 is the first bad version. """

    def firstBadVersion(self, n):
        lo, hi = 1, n
        while lo < hi:
            mid = (lo + hi)//2
            if isBadVersion(mid): hi = mid
            else: lo = mid + 1
        return lo


    """279. Perfect Squares (Medium)
    Given a positive integer n, find the least number of perfect square numbers
    (for example, 1, 4, 9, 16, ...) which sum to n.

    Example 1:
    Input: n = 12
    Output: 3
    Explanation: 12 = 4 + 4 + 4.

    Example 2:
    Input: n = 13
    Output: 2
    Explanation: 13 = 4 + 9."""

    def numSquares(self, n: int) -> int:
        """Lagrange's four-square theorem which states that every natural
           number can be represented as the sum of four integer (including zero)
           squares; Legendre's three-square theorem which says a positive
           integer can be expressed as the sum of three squares iff it is not
           of the form 4^k(8m+7) for integers k and m."""

        if int(sqrt(n))**2 == n: return 1
        for i in range(1, int(sqrt(n))+1):
            if int(sqrt(n - i*i))**2 == n - i*i: return 2
        while n % 4 == 0: n //= 4
        return 3 if n%8 != 7 else 4 #Lagrange four-square theorem & Lagendre three-square theorem


    """280. Wiggle Sort (Medium)
    Given an unsorted array nums, reorder it in-place such that
    nums[0] <= nums[1] >= nums[2] <= nums[3]....

    Example:
    Input: nums = [3,5,2,1,6,4]
    Output: One possible answer is [3,5,1,6,2,4]"""

    def wiggleSort(self, nums: List[int]) -> None:
        for i in range(len(nums)-1):
            if i&1 and nums[i] < nums[i+1] or not i&1 and nums[i] > nums[i+1]:
                nums[i], nums[i+1] = nums[i+1], nums[i]


    """282. Expression Add Operators (Hard)
    Given a string that contains only digits 0-9 and a target value, return
    all possibilities to add binary operators (not unary) +, -, or * between
    the digits so they evaluate to the target value.

    Example 1:
    Input: num = "123", target = 6
    Output: ["1+2+3", "1*2*3"]

    Example 2:
    Input: num = "232", target = 8
    Output: ["2*3+2", "2+3*2"]

    Example 3:
    Input: num = "10^5", target = 5
    Output: ["1*0+5","10-5"]

    Example 4:
    Input: num = "00", target = 0
    Output: ["0+0", "0-0", "0*0"]

    Example 5:
    Input: num = "3456237490", target = 9191
    Output: []

    Constraints:
    0 <= num.length <= 10
    num only contain digits."""

    def addOperators(self, num: str, target: int) -> List[str]:

        def fn(i, expr, total, last):
            """Populate ans with expression evaluated to target."""
            if i == len(num):
                if total == target: ans.append(expr)
            else:
                for ii in range(i, len(num) if num[i] != "0" else i+1):
                    val = int(num[i:ii+1])
                    if i == 0: fn(ii+1, num[i:ii+1], val, val)
                    else:
                        fn(ii+1, expr + "*" + num[i:ii+1], total - last + last * val, last * val)
                        fn(ii+1, expr + "+" + num[i:ii+1], total + val, val)
                        fn(ii+1, expr + "-" + num[i:ii+1], total - val, -val)

        ans = []
        fn(0, "", 0, 0)
        return ans


    """283. Move Zeroes (Easy)
    Given an array nums, write a function to move all 0's to the end of it
    while maintaining the relative order of the non-zero elements.

    Example:
    Input: [0,1,0,3,12]
    Output: [1,3,12,0,0]

    Note:
    You must do this in-place without making a copy of the array.
    Minimize the total number of operations."""

    def moveZeroes(self, nums: List[int]) -> None:
        ii = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[i], nums[ii] = nums[ii], nums[i]
                ii += 1


    """286. Walls and Gates (Medium)
    You are given an m x n grid rooms initialized with these three possible
    values.
    * -1 A wall or an obstacle.
    * 0 A gate.
    * INF Infinity means an empty room. We use the value 2^31 - 1 = 2147483647
      to represent INF as you may assume that the distance to a gate is less
      than 2147483647.
    Fill each empty room with the distance to its nearest gate. If it is
    impossible to reach a gate, it should be filled with INF.

    Example 1:
    Input: rooms = [[2147483647,        -1,         0,2147483647],
                    [2147483647,2147483647,2147483647,        -1],
                    [2147483647,        -1,2147483647,        -1],
                    [         0,        -1,2147483647,2147483647]]
    Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]

    Example 2:
    Input: rooms = [[-1]]
    Output: [[-1]]

    Example 3:
    Input: rooms = [[2147483647]]
    Output: [[2147483647]]

    Example 4:
    Input: rooms = [[0]]
    Output: [[0]]

    Constraints:
    * m == rooms.length
    * n == rooms[i].length
    * 1 <= m, n <= 250
    * rooms[i][j] is -1, 0, or 2^31 - 1."""

    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        m, n = len(rooms), len(rooms[0]) # dimensions
        dist = 0
        queue = [(i, j) for i in range(m) for j in range(n) if rooms[i][j] == 0]
        while queue:
            dist += 1
            newq = []
            for i, j in queue:
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and rooms[ii][jj] == 2147483647:
                        rooms[ii][jj] = dist
                        newq.append((ii, jj))
            queue = newq


    """287. Find the Duplicate Number (Medium)
    Given an array nums containing n + 1 integers where each integer is between
    1 and n (inclusive), prove that at least one duplicate number must exist.
    Assume that there is only one duplicate number, find the duplicate one.

    Example 1:
    Input: [1,3,4,2,2]
    Output: 2

    Example 2:
    Input: [3,1,3,4,2]
    Output: 3

    Note:
    * You must not modify the array (assume the array is read only).
    * You must use only constant, O(1) extra space.
    * Your runtime complexity should be less than O(n2).
    * There is only one duplicate number in the array, but it could be repeated
      more than once."""

    def findDuplicate(self, nums: List[int]) -> int:
        fast = slow = 0
        while True:
            fast = nums[nums[fast]]
            slow = nums[slow]
            if fast == slow: break
        fast = 0
        while fast != slow:
            fast = nums[fast]
            slow = nums[slow]
        return slow


    """289. Game of Life (Medium)
    According to the Wikipedia's article: "The Game of Life, also known simply
    as Life, is a cellular automaton devised by the British mathematician John
    Horton Conway in 1970."

    Given a board with m by n cells, each cell has an initial state live (1) or
    dead (0). Each cell interacts with its eight neighbors (horizontal,
    vertical, diagonal) using the following four rules (taken from the above
    Wikipedia article):

    * Any live cell with fewer than two live neighbors dies, as if caused by under-population.
    * Any live cell with two or three live neighbors lives on to the next generation.
    * Any live cell with more than three live neighbors dies, as if by over-population..
    * Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

    Write a function to compute the next state (after one update) of the board
    given its current state. The next state is created by applying the above
    rules simultaneously to every cell in the current state, where births and
    deaths occur simultaneously.

    Example:
    Input:
    [
      [0,1,0],
      [0,0,1],
      [1,1,1],
      [0,0,0]
    ]
    Output:
    [
      [0,0,0],
      [1,0,1],
      [0,1,1],
      [0,1,0]
    ]

    Follow up:
    * Could you solve it in-place? Remember that the board needs to be updated
      at the same time: You cannot update some cells first and then use their
      updated values to update other cells.
    * In this question, we represent the board using a 2D array. In principle,
      the board is infinite, which would cause problems when the active area
      encroaches the border of the array. How would you address these problems?"""

    def gameOfLife(self, board: List[List[int]]) -> None:
        m, n = len(board), len(board[0])

        for i in range(m):
            for j in range(n):
                nbr = 0 #neighbor of live cells
                for ii in range(i-1, i+2):
                    for jj in range(j-1, j+2):
                        if 0 <= ii < m and 0 <= jj < n and (ii != i or jj != j) and board[ii][jj] in (-1, 1): nbr += 1

                if board[i][j] and (nbr < 2 or nbr > 3): board[i][j] = -1 #overshoot
                elif not board[i][j] and nbr == 3: board[i][j] = 2 #overshoot

        for i in range(m):
            for j in range(n):
                board[i][j] = int(board[i][j] > 0)


    """290. Word Pattern (Easy)
    Given a pattern and a string str, find if str follows the same pattern.
    Here follow means a full match, such that there is a bijection between
    a letter in pattern and a non-empty word in str.

    Example 1:
    Input: pattern = "abba", str = "dog cat cat dog"
    Output: true

    Example 2:
    Input:pattern = "abba", str = "dog cat cat fish"
    Output: false

    Example 3:
    Input: pattern = "aaaa", str = "dog cat cat dog"
    Output: false

    Example 4:
    Input: pattern = "abba", str = "dog dog dog dog"
    Output: false

    Notes: You may assume pattern contains only lowercase letters, and str
           contains lowercase letters that may be separated by a single space."""

    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split()
        return len(set(pattern)) == len(set(words)) == len(set(zip_longest(pattern, words)))


    """291. Word Pattern II (Medium)
    Given a pattern and a string s, return true if s matches the pattern. A
    string s matches a pattern if there is some bijective mapping of single
    characters to strings such that if each character in pattern is replaced by
    the string it maps to, then the resulting string is s. A bijective mapping
    means that no two characters map to the same string, and no character maps
    to two different strings.

    Example 1:
    Input: pattern = "abab", s = "redblueredblue"
    Output: true
    Explanation: One possible mapping is as follows:
    'a' -> "red"
    'b' -> "blue"

    Example 2:
    Input: pattern = "aaaa", s = "asdasdasdasd"
    Output: true
    Explanation: One possible mapping is as follows:
    'a' -> "asd"

    Example 3:
    Input: pattern = "abab", s = "asdasdasdasd"
    Output: true
    Explanation: One possible mapping is as follows:
    'a' -> "a"
    'b' -> "sdasd"
    Note that 'a' and 'b' cannot both map to "asd" since the mapping is a bijection.

    Example 4:
    Input: pattern = "aabb", s = "xyzabcxzyabc"
    Output: false

    Constraints:
    * 1 <= pattern.length, s.length <= 20
    * pattern and s consist of only lower-case English letters."""

    def wordPatternMatch(self, pattern: str, s: str) -> bool:

        def fn(i, k):
            """Return True if pattern[i:] can be mapping to s[k:]"""
            if i == len(pattern): return k == len(s) # boundary condition
            if k == len(s): return i == len(pattern) # boundary condition

            if pattern[i] in mp:
                if mp[pattern[i]] == s[k:k+len(mp[pattern[i]])] and fn(i+1, k+len(mp[pattern[i]])): return True
                return False
            for kk in range(k+1, len(s)+1):
                if s[k:kk] not in mp:
                    mp[pattern[i]] = s[k:kk]
                    mp[s[k:kk]] = pattern[i]
                    if fn(i+1, kk): return True
                    mp.pop(pattern[i])
                    if pattern[i] != s[k:kk]: mp.pop(s[k:kk])
            return False

        mp = {}
        return fn(0, 0)


    """292. Nim Game (Easy)
    You are playing the following Nim Game with your friend: There is a heap of
    stones on the table, each time one of you take turns to remove 1 to 3
    stones. The one who removes the last stone will be the winner. You will
    take the first turn to remove the stones. Both of you are very clever and
    have optimal strategies for the game. Write a function to determine whether
    you can win the game given the number of stones in the heap.

    Example:
    Input: 4
    Output: false
    Explanation: If there are 4 stones in the heap, then you will never win the game;
                 No matter 1, 2, or 3 stones you remove, the last stone will always be
                 removed by your friend."""

    def canWinNim(self, n: int) -> bool:
        return n % 4


    """293. Flip Game (Easy)
    You are playing the following Flip Game with your friend: Given a string
    that contains only these two characters: + and -, you and your friend take
    turns to flip two consecutive "++" into "--". The game ends when a person
    can no longer make a move and therefore the other person will be the winner.
    Write a function to compute all possible states of the string after one
    valid move.

    Example:
    Input: s = "++++"
    Output: ["--++",
             "+--+",
             "++--"]
    Note: If there is no valid move, return an empty list []."""

    def generatePossibleNextMoves(self, s: str) -> List[str]:
        ans = []
        for i in range(len(s)-1):
            if s[i:i+2] == "++": ans.append(s[:i] + "--" + s[i+2:])
        return ans


    """294. Flip Game II (Medium)
    You are playing the following Flip Game with your friend: Given a string
    that contains only these two characters: + and -, you and your friend take
    turns to flip two consecutive "++" into "--". The game ends when a person
    can no longer make a move and therefore the other person will be the winner.
    Write a function to determine if the starting player can guarantee a win.

    Example:
    Input: s = "++++"
    Output: true
    Explanation: The starting player can guarantee a win by flipping the middle
                 "++" to become "+--+".

    Follow up: Derive your algorithm's runtime complexity."""

    def canWin(self, s: str) -> bool:

        @cache
        def fn(s):
            """Return True if player can win by playing optimally."""
            if "++" not in s: return False # already lost
            for i in range(len(s)-1):
                if s[i:i+2] == "++" and not fn(s[:i] + "--" + s[i+2:]): return True
            return False

        return fn(s)


    """296. Best Meeting Point (Hard)
    Given an m x n binary grid grid where each 1 marks the home of one friend,
    return the minimal total travel distance. The total travel distance is the
    sum of the distances between the houses of the friends and the meeting
    point. The distance is calculated using Manhattan Distance, where
    distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.

    Example 1:
    Input: grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]
    Output: 6
    Explanation: Given three friends living at (0,0), (0,4), and (2,2). The
                 point (0,2) is an ideal meeting point, as the total travel
                 distance of 2 + 2 + 2 = 6 is minimal. So return 6.

    Example 2:
    Input: grid = [[1,1]]
    Output: 1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 200
    * grid[i][j] is either 0 or 1.
    * There will be at least two friends in the grid."""

    def minTotalDistance(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        rows = []
        cols = []
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    rows.append(i)
                    cols.append(j)
        cols.sort()

        ans = 0
        lo, hi = 0, len(rows)-1
        while lo < hi:
            ans += rows[hi] - rows[lo] + cols[hi] - cols[lo]
            lo += 1
            hi -= 1
        return ans


    """298. Binary Tree Longest Consecutive Sequence (Medium)
    Given a binary tree, find the length of the longest consecutive sequence
    path. The path refers to any sequence of nodes from some starting node to
    any node in the tree along the parent-child connections. The longest
    consecutive path need to be from parent to child (cannot be the reverse).

    Example 1:
    Input:
       1
        \
         3
        / \
       2   4
            \
             5
    Output: 3
    Explanation: Longest consecutive sequence path is 3-4-5, so return 3.

    Example 2:
    Input:

       2
        \
         3
        /
       2
      /
     1
    Output: 2
    Explanation: Longest consecutive sequence path is 2-3, not 3-2-1, so return 2."""

    def longestConsecutive(self, root: TreeNode) -> int:
        if not root: return 0 # edge case

        ans = 0
        stack = [(root, 1)]
        while stack:
            node, val = stack.pop()
            ans = max(ans, val)
            if node.left: stack.append((node.left, val+1 if node.left.val == node.val+1 else 1))
            if node.right: stack.append((node.right, val+1 if node.right.val == node.val+1 else 1))
        return ans


    """299. Bulls and Cows (Easy)
    You are playing the following Bulls and Cows game with your friend: You
    write down a number and ask your friend to guess what the number is. Each
    time your friend makes a guess, you provide a hint that indicates how many
    digits in said guess match your secret number exactly in both digit and
    position (called "bulls") and how many digits match the secret number but
    locate in the wrong position (called "cows"). Your friend will use
    successive guesses and hints to eventually derive the secret number. Write
    a function to return a hint according to the secret number and friend's
    guess, use A to indicate the bulls and B to indicate the cows. Please note
    that both secret number and friend's guess may contain duplicate digits.

    Example 1:
    Input: secret = "1807", guess = "7810"
    Output: "1A3B"
    Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.

    Example 2:
    Input: secret = "1123", guess = "0111"
    Output: "1A1B"
    Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.

    Note: You may assume that the secret number and your friend's guess only
          contain digits, and their lengths are always equal."""

    def getHint(self, secret: str, guess: str) -> str:
        bulls = sum(s == g for s, g in zip(secret, guess))
        cows = sum((Counter(secret) & Counter(guess)).values()) - bulls
        return f"{bulls}A{cows}B"


    """300. Longest Increasing Subsequence (Medium)
    Given an unsorted array of integers, find the length of longest increasing
    subsequence.

    Example:
    Input: [10,9,2,5,3,7,101,18]
    Output: 4
    Explanation: The longest increasing subsequence is [2,3,7,101], therefore
                 the length is 4.

    Note:
    * There may be more than one LIS combination, it is only necessary for you
      to return the length.
    * Your algorithm should run in O(n2) complexity.

    Follow up: Could you improve it to O(n log n) time complexity?"""

    def lengthOfLIS(self, nums: List[int]) -> int:
        vals = []
        for x in nums:
            k = bisect_left(vals, x)
            if k == len(vals): vals.append(x)
            else: vals[k] = x
        return len(vals)


    """305. Number of Islands II (Hard)
    You are given an empty 2D binary grid grid of size m x n. The grid
    represents a map where 0's represent water and 1's represent land.
    Initially, all the cells of grid are water cells (i.e., all the cells are
    0's). We may perform an add land operation which turns the water at
    position into a land. You are given an array positions where
    positions[i] = [ri, ci] is the position (ri, ci) at which we should operate
    the ith operation. Return an array of integers answer where answer[i] is
    the number of islands after turning the cell (ri, ci) into a land. An
    island is surrounded by water and is formed by connecting adjacent lands
    horizontally or vertically. You may assume all four edges of the grid are
    all surrounded by water.

    Example 1:
    Input: m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
    Output: [1,1,2,3]
    Explanation: Initially, the 2d grid is filled with water.
                 - Operation #1: addLand(0, 0) turns the water at grid[0][0]
                                 into a land. We have 1 island.
                 - Operation #2: addLand(0, 1) turns the water at grid[0][1]
                                 into a land. We still have 1 island.
                 - Operation #3: addLand(1, 2) turns the water at grid[1][2]
                                 into a land. We have 2 islands.
                 - Operation #4: addLand(2, 1) turns the water at grid[2][1]
                                 into a land. We have 3 islands.

    Example 2:
    Input: m = 1, n = 1, positions = [[0,0]]
    Output: [1]

    Constraints:
    * 1 <= m, n, positions.length <= 10^4
    * 1 <= m * n <= 10^4
    * positions[i].length == 2
    * 0 <= ri < m
    * 0 <= ci < n

    Follow up: Could you solve it in time complexity O(k log(mn)), where
               k == positions.length?"""

    def numIslands2(self, m: int, n: int, positions: List[List[int]]) -> List[int]:
        parent = list(range(m*n))

        def find(p):
            if p != parent[p]:
                parent[p] = find(parent[p])
            return parent[p]

        ans = []
        seen = [[False]*n for _ in range(m)]
        prefix = 0
        for i, j in positions:
            if not seen[i][j]:
                prefix += 1
                seen[i][j] = True
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and seen[ii][jj]:
                        p = find(i*n+j)
                        pp = find(ii*n+jj)
                        if p != pp:
                            prefix -= 1
                            parent[p] = pp
            ans.append(prefix)
        return ans


    """306. Additive Number (Medium)
    Additive number is a string whose digits can form additive sequence. A
    valid additive sequence should contain at least three numbers. Except for
    the first two numbers, each subsequent number in the sequence must be the
    sum of the preceding two. Given a string containing only digits '0'-'9',
    write a function to determine if it's an additive number. Note: Numbers in
    the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1,
    02, 3 is invalid.

    Example 1:
    Input: "112358"
    Output: true
    Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.
                 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

    Example 2:
    Input: "199100199"
    Output: true
    Explanation: The additive sequence is: 1, 99, 100, 199.
                 1 + 99 = 100, 99 + 100 = 199

    Constraints:
    num consists only of digits '0'-'9'.
    1 <= num.length <= 35

    Follow up: gHow would you handle overflow for very large input integers?"""

    def isAdditiveNumber(self, num: str) -> bool:
        n = len(num)
        for i in range(1, n//2+1):
            x = num[:i]
            if x.startswith("0") and len(x) > 1: break #no leading zero
            for j in range(i+1, min(n-i, (n+i)//2)+1): #i <= n-j and j-i <= n-j
                yy = num[i:j]
                if yy.startswith("0") and len(yy) > 1: break #no leading zero

                ii, xx = i, x
                while num.startswith(yy, ii):
                    ii += len(yy)
                    xx, yy = yy, str(int(xx) + int(yy))
                if ii == len(num): return True

        return False


    """309. Best Time to Buy and Sell Stock with Cooldown (Medium)
    You are given an array prices where prices[i] is the price of a given stock
    on the ith day. Find the maximum profit you can achieve. You may complete
    as many transactions as you like (i.e., buy one and sell one share of the
    stock multiple times) with the following restrictions:
    * After you sell your stock, you cannot buy stock on the next day (i.e.,
      cooldown one day).
    Note: You may not engage in multiple transactions simultaneously (i.e., you
    must sell the stock before you buy again).

    Example 1:
    Input: prices = [1,2,3,0,2]
    Output: 3
    Explanation: transactions = [buy, sell, cooldown, buy, sell]

    Example 2:
    Input: prices = [1]
    Output: 0

    Constraints:
    * 1 <= prices.length <= 5000
    * 0 <= prices[i] <= 1000"""

    def maxProfit(self, prices: List[int]) -> int:
        buy, cooldown, sell = inf, 0, 0
        for x in prices:
            buy = min(buy, x - cooldown)
            cooldown = sell
            sell = max(sell, x - buy)
        return sell


    """310. Minimum Height Trees (Medium)
    A tree is an undirected graph in which any two vertices are connected by
    exactly one path. In other words, any connected graph without simple cycles
    is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array
    of n - 1 edges where edges[i] = [ai, bi] indicates that there is an
    undirected edge between the two nodes ai and bi in the tree, you can choose
    any node of the tree as the root. When you select a node x as the root, the
    result tree has height h. Among all possible rooted trees, those with
    minimum height (i.e. min(h))  are called minimum height trees (MHTs).
    Return a list of all MHTs' root labels. You can return the answer in any
    order. The height of a rooted tree is the number of edges on the longest
    downward path between the root and a leaf.

    Example 1:
    Input: n = 4, edges = [[1,0],[1,2],[1,3]]
    Output: [1]
    Explanation: As shown, the height of the tree is 1 when the root is the
                 node with label 1 which is the only MHT.

    Example 2:
    Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
    Output: [3,4]

    Example 3:
    Input: n = 1, edges = []
    Output: [0]

    Example 4:
    Input: n = 2, edges = [[0,1]]
    Output: [0,1]

    Constraints:
    * 1 <= n <= 2 * 10^4
    * edges.length == n - 1
    * 0 <= ai, bi < n
    * ai != bi
    * All the pairs (ai, bi) are distinct.
    * The given input is guaranteed to be a tree and there will be no repeated edges."""

    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = [set() for _ in range(n)]
        for u, v in edges:
            graph[u].add(v)
            graph[v].add(u)
        queue = deque([u for u in range(n) if len(graph[u]) <= 1])
        while n > 2:
            n -= len(queue)
            for _ in range(len(queue)):
                u = queue.popleft()
                v = graph[u].pop()
                graph[v].remove(u)
                if len(graph[v]) == 1: queue.append(v)
        return queue


    """311. Sparse Matrix Multiplication (Medium)
    Given two sparse matrices A and B, return the result of AB. You may assume
    that A's column number is equal to B's row number.

    Example:
    Input:
    A = [
      [ 1, 0, 0],
      [-1, 0, 3]
    ]

    B = [
      [ 7, 0, 0 ],
      [ 0, 0, 0 ],
      [ 0, 0, 1 ]
    ]

    Output:
         |  1 0 0 |   | 7 0 0 |   |  7 0 0 |
    AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |
                      | 0 0 1 |

    Constraints:
    * 1 <= A.length, B.length <= 100
    * 1 <= A[i].length, B[i].length <= 100
    * -100 <= A[i][j], B[i][j] <= 100"""

    def multiply(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        m, l, n = len(A), len(B), len(B[0]) # dimensions
        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            for k in range(l):
                if A[i][k]:
                    for j in range(n):
                        ans[i][j] += A[i][k] * B[k][j]
        return ans


    """312. Burst Balloons (Hard)
    You are given n balloons, indexed from 0 to n - 1. Each balloon is painted
    with a number on it represented by an array nums. You are asked to burst
    all the balloons. If you burst the ith balloon, you will get
    nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of
    bounds of the array, then treat it as if there is a balloon with a 1
    painted on it. Return the maximum coins you can collect by bursting the
    balloons wisely.

    Example 1:
    Input: nums = [3,1,5,8]
    Output: 167
    Explanation: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
                 coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

    Example 2:
    Input: nums = [1,5]
    Output: 10

    Constraints:
    * n == nums.length
    * 1 <= n <= 500
    * 0 <= nums[i] <= 100"""

    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        n = len(nums)
        dp = [[0]*n for _ in range(n)]
        for i in reversed(range(n)):
            for j in range(i, n):
                for k in range(i+1, j):
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])
        return dp[0][-1]


    """313. Super Ugly Number (Medium)
    Write a program to find the nth super ugly number. Super ugly numbers are
    positive numbers whose all prime factors are in the given prime list
    primes of size k.

    Example:
    Input: n = 12, primes = [2,7,13,19]
    Output: 32
    Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12
                 super ugly numbers given primes = [2,7,13,19] of size 4.

    Note:
    * 1 is a super ugly number for any given primes.
    * The given numbers in primes are in ascending order.
    * 0 < k ≤ 100, 0 < n ≤ 10^6, 0 < primes[i] < 1000.
    * The nth super ugly number is guaranteed to fit in a 32-bit signed integer."""

    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        ans = [1]
        hp = [(p, 0) for p in primes]
        heapify(hp)

        for _ in range(n-1):
            ans.append(hp[0][0])
            while hp[0][0] == ans[-1]:
                p, i = heappop(hp)
                heappush(hp, (p*ans[i+1]//ans[i], i+1))

        return ans[-1]


    """314. Binary Tree Vertical Order Traversal (Medium)
    Given the root of a binary tree, return the vertical order traversal of its
    nodes' values. (i.e., from top to bottom, column by column). If two nodes
    are in the same row and column, the order should be from left to right.

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
    Output: [[9],[3,15],[20],[7]]

    Example 2:
    Input: root = [3,9,8,4,0,1,7]
    Output: [[4],[9],[3,0,1],[8],[7]]

    Example 3:
    Input: root = [3,9,8,4,0,1,7,null,null,null,2,5]
    Output: [[4],[9,5],[3,0,1],[8,2],[7]]

    Example 4:
    Input: root = []
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100"""

    def verticalOrder(self, root: TreeNode) -> List[List[int]]:
        ans = {}
        queue = [(root, 0)]
        for node, k in queue:
            if node:
                ans.setdefault(k, []).append(node.val)
                queue.append((node.left, k-1))
                queue.append((node.right, k+1))
        return [ans[k] for k in sorted(ans)]


    """316. Remove Duplicate Letters (Medium)
    Given a string s, remove duplicate letters so that every letter appears
    once and only once. You must make sure your result is the smallest in
    lexicographical order among all possible results. Note: This question is
    the same as 1081:
    https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/

    Example 1:
    Input: s = "bcabc"
    Output: "abc"

    Example 2:
    Input: s = "cbacdcbc"
    Output: "acdb"

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of lowercase English letters."""

    def removeDuplicateLetters(self, s: str) -> str:
        last = {ch : i for i, ch in enumerate(s)}
        stack = []
        for i, ch in enumerate(s):
            if ch not in stack:
                while stack and stack[-1] > ch and last[stack[-1]] > i: stack.pop()
                stack.append(ch)
        return ''.join(stack)


    """318. Maximum Product of Word Lengths (Medium)
    Given a string array words, find the maximum value of
    length(word[i]) * length(word[j]) where the two words do not share common
    letters. You may assume that each word will contain only lower case letters.
    If no such two words exist, return 0.

    Example 1:
    Input: ["abcw","baz","foo","bar","xtfn","abcdef"]
    Output: 16
    Explanation: The two words can be "abcw", "xtfn".

    Example 2:
    Input: ["a","ab","abc","d","cd","bcd","abcd"]
    Output: 4
    Explanation: The two words can be "ab", "cd".

    Example 3:
    Input: ["a","aa","aaa","aaaa"]
    Output: 0
    Explanation: No such pair of words.

    Constraints:
    * 0 <= words.length <= 10^3
    * 0 <= words[i].length <= 10^3
    * words[i] consists only of lowercase English letters."""

    def maxProduct(self, words: List[str]) -> int:
        mp = defaultdict(int)
        for word in words:
            mask = 0
            for ch in word: mask |= 1 << ord(ch)-97
            mp[mask] = max(mp[mask], len(word))
        return max((mp[x]*mp[y] for x in mp for y in mp if not x & y), default=0)


    """319. Bulb Switcher (Medium)
    There are n bulbs that are initially off. You first turn on all the bulbs.
    Then, you turn off every second bulb. On the third round, you toggle every
    third bulb (turning on if it's off or turning off if it's on). For the i-th
    round, you toggle every i bulb. For the n-th round, you only toggle the
    last bulb. Find how many bulbs are on after n rounds.

    Example:
    Input: 3
    Output: 1

    Explanation:
    At first, the three bulbs are [off, off, off].
    After first round, the three bulbs are [on, on, on].
    After second round, the three bulbs are [on, off, on].
    After third round, the three bulbs are [on, off, off].
    So you should return 1, because there is only one bulb is on."""

    def bulbSwitch(self, n: int) -> int:
        return int(sqrt(n))


    """320. Generalized Abbreviation (Medium)
    A word's generalized abbreviation can be constructed by taking any number
    of non-overlapping substrings and replacing them with their respective
    lengths. For example, "abcde" can be abbreviated into "a3e" ("bcd" turned
    into "3"), "1bcd1" ("a" and "e" both turned into "1"), and "23" ("ab"
    turned into "2" and "cde" turned into "3"). Given a string word, return a
    list of all the possible generalized abbreviations of word. Return the
    answer in any order.

    Example 1:
    Input: word = "word"
    Output: ["4","3d","2r1","2rd","1o2","1o1d","1or1","1ord","w3","w2d","w1r1",
             "w1rd","wo2","wo1d","wor1","word"]

    Example 2:
    Input: word = "a"
    Output: ["1","a"]

    Constraints:
    * 1 <= word.length <= 15
    * word consists of only lowercase English letters."""

    def generateAbbreviations(self, word: str) -> List[str]:

        def fn(i, s="", n=0):
            """Populate ans via backtracking."""
            if i == len(word): return ans.append(s + (str(n) if n else ""))
            fn(i+1, s, n+1)
            fn(i+1, s + (str(n) if n else "") + word[i], 0)

        ans = []
        fn(0)
        return ans


    """321. Create Maximum Number (Hard)
    You are given two integer arrays nums1 and nums2 of lengths m and n
    respectively. nums1 and nums2 represent the digits of two numbers. You are
    also given an integer k. Create the maximum number of length k <= m + n
    from digits of the two numbers. The relative order of the digits from the
    same array must be preserved. Return an array of the k digits representing
    the answer.

    Example 1:
    Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5
    Output: [9,8,6,5,3]

    Example 2:
    Input: nums1 = [6,7], nums2 = [6,0,4], k = 5
    Output: [6,7,6,0,4]

    Example 3:
    Input: nums1 = [3,9], nums2 = [8,9], k = 3
    Output: [9,8,9]

    Constraints:
    * m == nums1.length
    * n == nums2.length
    * 1 <= m, n <= 500
    * 0 <= nums1[i], nums2[i] <= 9
    * 1 <= k <= m + n"""

    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:

        def fn(arr, k):
            """Return largest sub-sequence of arr of size k."""
            ans = []
            for i, x in enumerate(arr):
                while ans and ans[-1] < x and len(ans) + len(arr) - i > k: ans.pop()
                if len(ans) < k: ans.append(x)
            return ans

        ans = [0] * k
        for i in range(k+1):
            if k - len(nums2) <= i <= len(nums1):
                val1 = fn(nums1, i)
                val2 = fn(nums2, k-i)
                cand = []
                i1 = i2 = 0
                while i1 < len(val1) or i2 < len(val2):
                    if val1[i1:] >= val2[i2:]:
                        cand.append(val1[i1])
                        i1 += 1
                    else:
                        cand.append(val2[i2])
                        i2 += 1
                ans = max(ans, cand)
        return ans


    """322. Coin Change (Medium)
    You are given coins of different denominations and a total amount of money
    amount. Write a function to compute the fewest number of coins that you
    need to make up that amount. If that amount of money cannot be made up by
    any combination of the coins, return -1.

    Example 1:
    Input: coins = [1, 2, 5], amount = 11
    Output: 3
    Explanation: 11 = 5 + 5 + 1

    Example 2:
    Input: coins = [2], amount = 3
    Output: -1

    Note: You may assume that you have an infinite number of each kind of coin."""

    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [0] + [inf]*amount
        for x in range(amount):
            if dp[x] < inf:
                for coin in coins:
                    if x + coin <= amount:
                        dp[x+coin] = min(dp[x+coin], 1 + dp[x])
        return dp[-1] if dp[-1] < inf else -1


    """323. Number of Connected Components in an Undirected Graph (Medium)
    Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each
    edge is a pair of nodes), write a function to find the number of connected
    components in an undirected graph.

    Example 1:
    Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]]
         0          3
         |          |
         1 --- 2    4
    Output: 2

    Example 2:
    Input: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]]

         0           4
         |           |
         1 --- 2 --- 3
    Output:  1

    Note: You can assume that no duplicate edges will appear in edges. Since
          all edges are undirected, [0, 1] is the same as [1, 0] and thus will
          not appear together in edges."""

    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        uf = UnionFind(n)
        for u, v in edges: uf.union(u, v)
        return len({uf.find(i) for i in range(n)})


    """325. Maximum Size Subarray Sum Equals k (Medium)
    Given an array nums and a target value k, find the maximum length of a
    subarray that sums to k. If there isn't one, return 0 instead.

    Note: The sum of the entire nums array is guaranteed to fit within the
          32-bit signed integer range.

    Example 1:
    Input: nums = [1, -1, 5, -2, 3], k = 3
    Output: 4
    Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.

    Example 2:
    Input: nums = [-2, -1, 2, 1], k = 1
    Output: 2
    Explanation: The subarray [-1, 2] sums to 1 and is the longest.

    Follow Up: Can you do it in O(n) time?"""

    def maxSubArrayLen(self, nums: List[int], k: int) -> int:
        ans = prefix = 0
        seen = {0: -1}
        for i, x in enumerate(nums):
            prefix += x
            if prefix-k in seen: ans = max(ans, i - seen[prefix-k])
            seen.setdefault(prefix, i)
        return ans


    """327. Count of Range Sum (Hard)
    Given an integer array nums and two integers lower and upper, return the
    number of range sums that lie in [lower, upper] inclusive. Range sum
    S(i, j) is defined as the sum of the elements in nums between indices i and
    j inclusive, where i <= j.

    Example 1:
    Input: nums = [-2,5,-1], lower = -2, upper = 2
    Output: 3
    Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their
                 respective sums are: -2, -1, 2.

    Example 2:
    Input: nums = [0], lower = 0, upper = 0
    Output: 1

    Constraints:
    * 1 <= nums.length <= 10^4
    * -2^31 <= nums[i] <= 2^31 - 1
    * -10^5 <= lower <= upper <= 10^5
    * The answer is guaranteed to fit in a 32-bit integer."""

    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)

        def fn(lo, hi):
            """Return count of range sum between prefix[lo:hi]."""
            if lo+1 >= hi: return 0
            mid = lo + hi >> 1
            ans = fn(lo, mid) + fn(mid, hi)
            k = kk = mid
            for i in range(lo, mid):
                while k < hi and prefix[k] - prefix[i] < lower: k += 1
                while kk < hi and prefix[kk] - prefix[i] <= upper: kk += 1
                ans += kk - k
            prefix[lo:hi] = sorted(prefix[lo:hi])
            return ans

        return fn(0, len(prefix))


    """328. Odd Even Linked List (Medium)
    Given a singly linked list, group all odd nodes together followed by the
    even nodes. Please note here we are talking about the node number and not
    the value in the nodes. You should try to do it in place. The program
    should run in O(1) space complexity and O(nodes) time complexity.

    Example 1:
    Input: 1->2->3->4->5->NULL
    Output: 1->3->5->2->4->NULL

    Example 2:
    Input: 2->1->3->5->6->4->7->NULL
    Output: 2->3->6->7->1->5->4->NULL

    Constraints:
    * The relative order inside both the even and odd groups should remain as
      it was in the input.
    * The first node is considered odd, the second node even and so on ...
    * The length of the linked list is between [0, 10^4]."""

    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head:
            odd = head
            even = h0 = head.next
            while even and even.next:
                odd.next = odd = odd.next.next
                even.next = even = even.next.next
            odd.next = h0
        return head


    """329. Longest Increasing Path in a Matrix (Hard)
    Given an m x n integers matrix, return the length of the longest increasing
    path in matrix. From each cell, you can either move in four directions:
    left, right, up, or down. You may not move diagonally or move outside the
    boundary (i.e., wrap-around is not allowed).

    Example 1:
    Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
    Output: 4
    Explanation: The longest increasing path is [1, 2, 6, 9].

    Example 2:
    Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
    Output: 4
    Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally
                 is not allowed.

    Example 3:
    Input: matrix = [[1]]
    Output: 1

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 200
    * 0 <= matrix[i][j] <= 2^31 - 1"""

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        m, n = len(matrix), len(matrix[0])
        indeg = [[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and matrix[i][j] < matrix[ii][jj]:
                        indeg[ii][jj] += 1
        queue = deque([(i, j) for i in range(m) for j in range(n) if indeg[i][j] == 0])
        ans = 0
        while queue:
            for _ in range(len(queue)):
                i, j = queue.popleft()
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and matrix[i][j] < matrix[ii][jj]:
                        indeg[ii][jj] -= 1
                        if indeg[ii][jj] == 0: queue.append((ii, jj))
            ans += 1
        return ans


    """330. Patching Array (Hard)
    Given a sorted integer array nums and an integer n, add/patch elements to
    the array such that any number in the range [1, n] inclusive can be formed
    by the sum of some elements in the array. Return the minimum number of
    patches required.

    Example 1:
    Input: nums = [1,3], n = 6
    Output: 1
    Explanation: Combinations of nums are [1], [3], [1,3], which form possible
                 sums of: 1, 3, 4. Now if we add/patch 2 to nums, the
                 combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
                 Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range
                 [1, 6]. So we only need 1 patch.

    Example 2:
    Input: nums = [1,5,10], n = 20
    Output: 2
    Explanation: The two patches can be [2, 4].

    Example 3:
    Input: nums = [1,2,2], n = 5
    Output: 0

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^4
    * nums is sorted in ascending order.
    * 1 <= n <= 2^31 - 1"""

    def minPatches(self, nums: List[int], n: int) -> int:
        ans = prefix = k = 0
        while prefix < n:
            if k < len(nums) and nums[k] <= prefix + 1:
                prefix += nums[k]
                k += 1
            else:
                ans += 1
                prefix += prefix + 1
        return ans


    """331. Verify Preorder Serialization of a Binary Tree (Medium)
    One way to serialize a binary tree is to use pre-order traversal. When we
    encounter a non-null node, we record the node's value. If it is a null
    node, we record using a sentinel value such as #.

         _9_
        /   \
       3     2
      / \   / \
     4   1  #  6
    / \ / \   / \
    # # # #   # #

    For example, the above binary tree can be serialized to the string
    "9,3,4,#,#,1,#,#,2,#,6,#,#", where # represents a null node. Given a string
    of comma separated values, verify whether it is a correct preorder traversal
    serialization of a binary tree. Find an algorithm without reconstructing the
    tree. Each comma separated value in the string must be either an integer or
    a character '#' representing null pointer. You may assume that the input
    format is always valid, for example it could never contain two consecutive
    commas such as "1,,3".

    Example 1:
    Input: "9,3,4,#,#,1,#,#,2,#,6,#,#"
    Output: true

    Example 2:
    Input: "1,#"
    Output: false

    Example 3:
    Input: "9,#,#,1"
    Output: false"""

    def isValidSerialization(self, preorder: str) -> bool:
        cnt = 1
        for x in preorder.split(","):
            if cnt == 0: return False #intermediate
            cnt += 1 if x != "#" else -1
        return cnt == 0  #end result


    """332. Reconstruct Itinerary (Medium)
    Given a list of airline tickets represented by pairs of departure and
    arrival airports [from, to], reconstruct the itinerary in order. All of the
    tickets belong to a man who departs from JFK. Thus, the itinerary must
    begin with JFK.

    Note:
    If there are multiple valid itineraries, you should return the itinerary
    that has the smallest lexical order when read as a single string. For
    example, the itinerary ["JFK", "LGA"] has a smaller lexical order than
    ["JFK", "LGB"]. All airports are represented by three capital letters (IATA
    code). You may assume all tickets form at least one valid itinerary. One
    must use all the tickets once and only once.

    Example 1:
    Input: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
    Output: ["JFK", "MUC", "LHR", "SFO", "SJC"]

    Example 2:
    Input: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
    Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]

    Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"].
                 But it is larger in lexical order."""

    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        digraph = defaultdict(list)
        for u, v in tickets: heappush(digraph[u], v)

        def fn(n):
            """Return Eulerian path via Hierholzer's algo."""
            while digraph.get(n, []): fn(heappop(digraph[n]))
            ans.appendleft(n)

        ans = deque()
        fn("JFK")
        return ans


    """333. Largest BST Subtree (Medium)
    Given the root of a binary tree, find the largest subtree, which is also a
    Binary Search Tree (BST), where the largest means subtree has the largest
    number of nodes. A Binary Search Tree (BST) is a tree in which all the
    nodes follow the below-mentioned properties:
    * The left subtree values are less than the value of their parent (root)
      node's value.
    * The right subtree values are greater than the value of their parent
      (root) node's value.
    Note: A subtree must include all of its descendants.
    Follow up: Can you figure out ways to solve it with O(n) time complexity?

    Example 1:
    Input: root = [10,5,15,1,8,null,7]
    Output: 3
    Explanation: The Largest BST Subtree in this case is the highlighted one.
                 The return value is the subtree's size, which is 3.

    Example 2:
    Input: root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1]
    Output: 2

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * -10^4 <= Node.val <= 10^4"""

    def largestBSTSubtree(self, root: TreeNode) -> int:

        def fn(node):
            """Update largest BST subtree."""
            nonlocal ans
            if not node: return True, 0, inf, -inf # BST? | size | low | high
            ltf, lsz, llo, lhi = fn(node.left)
            rtf, rsz, rlo, rhi = fn(node.right)
            tf = ltf and rtf and lhi < node.val < rlo
            sz = 1 + lsz + rsz
            if tf: ans = max(ans, sz)
            return tf, sz, min(llo, node.val), max(rhi, node.val)

        ans = 0
        fn(root)
        return ans


    """334. Increasing Triplet Subsequence (Medium)
    Given an unsorted array return whether an increasing subsequence of length
    3 exists or not in the array. Formally the function should return true if
    there exists i, j, k such that arr[i] < arr[j] < arr[k] given
    0 ≤ i < j < k ≤ n-1 else return false.

    Note: Your algorithm should run in O(n) time complexity and O(1) space
          complexity.

    Example 1:
    Input: [1,2,3,4,5]
    Output: true

    Example 2:
    Input: [5,4,3,2,1]
    Output: false"""

    def increasingTriplet(self, nums: List[int]) -> bool:
        x0 = x1 = inf
        for x in nums:
            if x <= x0: x0 = x
            elif x <= x1: x1 = x
            else: return True
        return False


    """337. House Robber III (Medium)
    The thief has found himself a new place for his thievery again. There is
    only one entrance to this area, called the "root." Besides the root, each
    house has one and only one parent house. After a tour, the smart thief
    realized that "all houses in this place forms a binary tree". It will
    automatically contact the police if two directly-linked houses were broken
    into on the same night. Determine the maximum amount of money the thief can
    rob tonight without alerting the police.

    Example 1:
    Input: [3,2,3,null,3,null,1]

         3
        / \
       2   3
        \   \
         3   1
    Output: 7
    Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.

    Example 2:
    Input: [3,4,5,1,3,null,1]

         3
        / \
       4   5
      / \   \
     1   3   1
    Output: 9
    Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9."""

    def rob(self, root: TreeNode) -> int:

        def fn(node):
            """Return max money possible of robbing & skipping this house."""
            if not node: return 0, 0
            if node.left is node.right: return node.val, 0
            left, right = fn(node.left), fn(node.right)
            return node.val+left[1]+right[1], max(left)+max(right)

        return max(fn(root))


    """338. Counting Bits (Medium)
    Given a non negative integer number num. For every numbers i in the range
    0 ≤ i ≤ num calculate the number of 1's in their binary representation and
    return them as an array.

    Example 1:
    Input: 2
    Output: [0,1,1]

    Example 2:
    Input: 5
    Output: [0,1,1,2,1,2]

    Follow up:
    * It is very easy to come up with a solution with run time
      O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in
      a single pass?
    * Space complexity should be O(n).
    * Can you do it like a boss? Do it without using any builtin function like
      __builtin_popcount in c++ or in any other language."""

    def countBits(self, n: int) -> List[int]:
        ans = [0]*(n+1)
        for x in range(1, n+1):
            ans[x] = ans[x&(x-1)] + 1
        return ans


    """339. Nested List Weight Sum (Easy)
    You are given a nested list of integers nestedList. Each element is either
    an integer or a list whose elements may also be integers or other lists.
    The depth of an integer is the number of lists that it is inside of. For
    example, the nested list [1,[2,2],[[3],2],1] has each integer's value set
    to its depth. Return the sum of each integer in nestedList multiplied by
    its depth.

    Example 1:
    Input: nestedList = [[1,1],2,[1,1]]
    Output: 10
    Explanation: Four 1's at depth 2, one 2 at depth 1. 1*2 + 1*2 + 2*1 + 1*2 + 1*2 = 10.

    Example 2:
    Input: nestedList = [1,[4,[6]]]
    Output: 27
    Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1*1 + 4*2 + 6*3 = 27.

    Example 3:
    Input: nestedList = [0]
    Output: 0

    Constraints:
    * 1 <= nestedList.length <= 50
    * The values of the integers in the nested list is in the range [-100, 100].
    * The maximum depth of any integer is less than or equal to 50."""

    def depthSum(self, nestedList: List[NestedInteger]) -> int:
        ans = wt = 0
        queue = nestedList
        while queue:
            wt += 1
            newq = []
            for x in queue:
                if x.isInteger(): ans += wt * x.getInteger()
                else: newq.extend(x.getList())
            queue = newq
        return ans


    """340. Longest Substring with At Most K Distinct Characters (Medium)
    Given a string s and an integer k, return the length of the longest
    substring of s that contains at most k distinct characters.

    Example 1:
    Input: s = "eceba", k = 2
    Output: 3
    Explanation: The substring is "ece" with length 3.

    Example 2:
    Input: s = "aa", k = 1
    Output: 2
    Explanation: The substring is "aa" with length 2.

    Constraints:
    * 1 <= s.length <= 5 * 10^4
    * 0 <= k <= 50"""

    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        ans = ii = 0
        freq = {}
        for i, c in enumerate(s):
            freq[c] = 1 + freq.get(c, 0)
            while len(freq) > k:
                freq[s[ii]] -= 1
                if freq[s[ii]] == 0: freq.pop(s[ii])
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans


    """343. Integer Break (Medium)
    Given a positive integer n, break it into the sum of at least two positive
    integers and maximize the product of those integers. Return the maximum
    product you can get.

    Example 1:
    Input: 2
    Output: 1
    Explanation: 2 = 1 + 1, 1 × 1 = 1.

    Example 2:
    Input: 10
    Output: 36
    Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.

    Note: You may assume that n is not less than 2 and not larger than 58."""

    def integerBreak(self, n: int) -> int:

        @cache
        def fn(n):
            """Return the max product by splitting n."""
            if n == 1: return 1
            return max(max(i, fn(i))*max(n-i, fn(n-i)) for i in range(1, n//2+1))

        return fn(n)


    """344. Reverse String (Easy)
    Write a function that reverses a string. The input string is given as an
    array of characters s.

    Example 1:
    Input: s = ["h","e","l","l","o"]
    Output: ["o","l","l","e","h"]

    Example 2:
    Input: s = ["H","a","n","n","a","h"]
    Output: ["h","a","n","n","a","H"]

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is a printable ascii character.

    Follow up: Do not allocate extra space for another array. You must do this
               by modifying the input array in-place with O(1) extra memory."""

    def reverseString(self, s: List[str]) -> None:
        lo, hi = 0, len(s)-1
        while lo < hi:
            s[lo], s[hi] = s[hi], s[lo]
            lo += 1
            hi -= 1


    """347. Top K Frequent Elements (Medium)
    Given a non-empty array of integers, return the k most frequent elements.

    Example 1:
    Input: nums = [1,1,1,2,2,3], k = 2
    Output: [1,2]

    Example 2:
    Input: nums = [1], k = 1
    Output: [1]

    Note:
    * You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
    * Your algorithm's time complexity must be better than O(n log n), where n
      is the array's size.
    * It's guaranteed that the answer is unique, in other words the set of the
      top k frequent elements is unique.
    * You can return the answer in any order."""

    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        freq = Counter(nums)
        bucket = [[] for _ in nums]
        for x, v in freq.items(): bucket[-v].append(x)

        ans = []
        for x in bucket:
            ans.extend(x)
            if len(ans) >= k: break
        return ans


    """350. Intersection of Two Arrays II (Easy)
    Given two integer arrays nums1 and nums2, return an array of their
    intersection. Each element in the result must appear as many times as it
    shows in both arrays and you may return the result in any order.

    Example 1:
    Input: nums1 = [1,2,2,1], nums2 = [2,2]
    Output: [2,2]

    Example 2:
    Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
    Output: [4,9]
    Explanation: [9,4] is also accepted.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 1000
    * 0 <= nums1[i], nums2[i] <= 1000

    Follow up:
    * What if the given array is already sorted? How would you optimize your
      algorithm?
    * What if nums1's size is small compared to nums2's size? Which algorithm
      is better?
    * What if elements of nums2 are stored on disk, and the memory is limited
      such that you cannot load all elements into the memory at once?"""

    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return (Counter(nums1) & Counter(nums2)).elements()


    """351. Android Unlock Patterns (Medium)
    Android devices have a special lock screen with a 3 x 3 grid of dots. Users
    can set an "unlock pattern" by connecting the dots in a specific sequence,
    forming a series of joined line segments where each segment's endpoints are
    two consecutive dots in the sequence. A sequence of k dots is a valid
    unlock pattern if both of the following are true:
    * All the dots in the sequence are distinct.
    * If the line segment connecting two consecutive dots in the sequence
      passes through the center of any other dot, the other dot must have
      previously appeared in the sequence. No jumps through the center non-
      selected dots are allowed.
      + For example, connecting dots 2 and 9 without dots 5 or 6 appearing
        beforehand is valid because the line from dot 2 to dot 9 does not pass
        through the center of either dot 5 or 6.
      + However, connecting dots 1 and 3 without dot 2 appearing beforehand is
        invalid because the line from dot 1 to dot 3 passes through the center
        of dot 2.

    Two unlock patterns are considered unique if there is a dot in one sequence
    that is not in the other, or the order of the dots is different.

    Example 1:
    Input: m = 1, n = 1
    Output: 9

    Example 2:
    Input: m = 1, n = 2
    Output: 65

    Constraints: 1 <= m, n <= 9"""

    def numberOfPatterns(self, m: int, n: int) -> int:
        mp = {(1, 3): 2, (1, 7): 4, (1, 9): 5, (2, 8): 5, (3, 7): 5, (3, 9): 6, (4, 6): 5, (7, 9): 8, \
              (3, 1): 2, (7, 1): 4, (9, 1): 5, (8, 2): 5, (7, 3): 5, (9, 3): 6, (6, 4): 5, (9, 7): 8}

        @cache
        def fn(x, mask):
            """Return number of unlock patterns."""
            ans = size = 0
            for xx in range(1, 10):
                if not mask & (1 << xx):
                    if (x, xx) not in mp or mask & 1 << mp[x, xx]:
                        ans += fn(xx, mask^(1<<xx))
                    size += 1
            size = 9 - size
            if m <= size <= n: ans += 1
            return ans

        return fn(0, 0)


    """356. Line Reflection (Medium)
    Given n points on a 2D plane, find if there is such a line parallel to
    y-axis that reflect the given points symmetrically, in other words, answer
    whether or not if there exists a line that after reflecting all points over
    the given line the set of the original points is the same that the
    reflected ones. Note that there can be repeated points.

    Follow up: Could you do better than O(n2) ?

    Example 1:
    Input: points = [[1,1],[-1,1]]
    Output: true
    Explanation: We can choose the line x = 0.

    Example 2:
    Input: points = [[1,1],[-1,-1]]
    Output: false
    Explanation: We can't choose a line.

    Constraints:
    * n == points.length
    * 1 <= n <= 10^4
    * -10^8 <= points[i][j] <= 10^8"""

    def isReflected(self, points: List[List[int]]) -> bool:
        points = {(x, y) for x, y in points}
        avg = sum(x for x, _ in points)/len(points)
        for x, y in points:
            if (2*avg - x, y) not in points: return False
        return True


    """357. Count Numbers with Unique Digits (Medium)
    Given a non-negative integer n, count all numbers with unique digits, x,
    where 0 ≤ x < 10^n.

    Example:
    Input: 2
    Output: 91
    Explanation: The answer should be the total numbers in the range of 0 ≤ x < 100,
                 excluding 11,22,33,44,55,66,77,88,99

    Constraints: 0 <= n <= 8"""

    def countNumbersWithUniqueDigits(self, n: int) -> int:
        if n == 0: return 1
        ans, val = 10, 9
        for i in range(1, min(n, 10)):
            val *= 10 - i
            ans += val
        return ans


    """358. Rearrange String k Distance Apart (Hard)
    Given a string s and an integer k, rearrange s such that the same
    characters are at least distance k from each other. If it is not possible
    to rearrange the string, return an empty string "".

    Example 1:
    Input: s = "aabbcc", k = 3
    Output: "abcabc"
    Explanation: The same letters are at least a distance of 3 from each other.

    Example 2:
    Input: s = "aaabc", k = 3
    Output: ""
    Explanation: It is not possible to rearrange the string.

    Example 3:
    Input: s = "aaadbbcc", k = 2
    Output: "abacabcd"
    Explanation: The same letters are at least a distance of 2 from each other.

    Constraints:
    * 1 <= s.length <= 3 * 10^5
    * s consists of only lowercase English letters.
    * 0 <= k <= s.length"""

    def rearrangeString(self, s: str, k: int) -> str:
        ans = []
        freq = [0] * 26
        for c in s: freq[ord(c)-97] += 1
        prev = [-k] * 26
        for i in range(len(s)):
            m = -1
            for c in range(26):
                if freq[c] and (m == -1 or freq[c] > freq[m]) and i - prev[c] >= k: m = c
            if m == -1: return ""
            ans.append(chr(m + 97))
            freq[m] -= 1
            prev[m] = i
        return ''.join(ans)


    """360. Sort Transformed Array (Medium)
    Given a sorted array of integers nums and integer values a, b and c. Apply
    a quadratic function of the form f(x) = ax2 + bx + c to each element x in
    the array. The returned array must be in sorted order. Expected time
    complexity: O(n)

    Example 1:
    Input: nums = [-4,-2,2,4], a = 1, b = 3, c = 5
    Output: [3,9,15,33]

    Example 2:
    Input: nums = [-4,-2,2,4], a = -1, b = 3, c = 5
    Output: [-23,-5,1,7]"""

    def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -> List[int]:
        nums = [a*x*x + b*x + c for x in nums]
        ans = [None]*len(nums)

        lo, hi = 0, len(nums)-1 # 2-pointer
        i, ii = (-1, -1) if a >= 0 else (0, 1)
        while lo <= hi:
            if nums[lo] * ii > nums[hi] * ii:
                ans[i] = nums[hi]
                hi -= 1
            else:
                ans[i] = nums[lo]
                lo += 1
            i += ii
        return ans


    """361. Bomb Enemy (Medium)
    Given a 2D grid, each cell is either a wall 'W', an enemy 'E' or empty '0'
    (the number zero), return the maximum enemies you can kill using one bomb.
    The bomb kills all the enemies in the same row and column from the planted
    point until it hits the wall since the wall is too strong to be destroyed.
    Note: You can only put the bomb at an empty cell.

    Example:
    Input: [["0","E","0","0"],["E","0","W","E"],["0","E","0","0"]]
    Output: 3
    Explanation: For the given grid,
    0 E 0 0
    E 0 W E
    0 E 0 0
    Placing a bomb at (1,1) kills 3 enemies."""

    def maxKilledEnemies(self, grid: List[List[str]]) -> int:
        if not grid: return 0 # edge case
        m, n = len(grid), len(grid[0]) # dimensions

        ans = 0
        cnt = [[0]*n for _ in range(m)]
        up, dn = [0]*n, [0]*n

        for i in range(m):
            lt = rt = 0
            for j in range(n):
                cnt[i][j] += dn[j] + lt
                cnt[i][~j] += rt
                cnt[~i][j] += up[j]

                if grid[i][j] == "E": lt, dn[j] = lt+1, dn[j]+1
                elif grid[i][j] == "W": lt = dn[j] = 0
                else: ans = max(ans, cnt[i][j])

                if grid[i][~j] == "E": rt += 1
                elif grid[i][~j] == "W": rt = 0
                else: ans = max(ans, cnt[i][~j])

                if grid[~i][j] == "E": up[j] += 1
                elif grid[~i][j] == "W": up[j] = 0
                else: ans = max(ans, cnt[~i][j])

        return ans


    """363. Max Sum of Rectangle No Larger Than K (Hard)
    Given an m x n matrix matrix and an integer k, return the max sum of a
    rectangle in the matrix such that its sum is no larger than k. It is
    guaranteed that there will be a rectangle with a sum no larger than k.

    Example 1:
    Input: matrix = [[1,0,1],[0,-2,3]], k = 2
    Output: 2
    Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2,
                 and 2 is the max number no larger than k (k = 2).

    Example 2:
    Input: matrix = [[2,2,-1]], k = 3
    Output: 3

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 100
    * -100 <= matrix[i][j] <= 100
    * -10^5 <= k <= 10^5

    Follow up: What if the number of rows is much larger than the number of
               columns?"""

    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions

        ans = -inf
        rsum = [[0]*(n+1) for _ in range(m)] # row prefix sum
        for j in range(n):
            for i in range(m): rsum[i][j+1] = matrix[i][j] + rsum[i][j]
            for jj in range(j+1):
                prefix = 0
                vals = [0]
                for i in range(m):
                    prefix += rsum[i][j+1] - rsum[i][jj]
                    x = bisect_left(vals, prefix - k)
                    if x < len(vals): ans = max(ans, prefix - vals[x])
                    insort(vals, prefix)
        return ans


    """364. Nested List Weight Sum II (Medium)
    Given a nested list of integers, return the sum of all integers in the list
    weighted by their depth. Each element is either an integer, or a list --
    whose elements may also be integers or other lists. Different from the
    previous question where weight is increasing from root to leaf, now the
    weight is defined from bottom up. i.e., the leaf level integers have weight
    1, and the root level integers have the largest weight.

    Example 1:
    Input: [[1,1],2,[1,1]]
    Output: 8
    Explanation: Four 1's at depth 1, one 2 at depth 2.

    Example 2:
    Input: [1,[4,[6]]]
    Output: 17
    Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1;
                 1*3 + 4*2 + 6*1 = 17."""

    def depthSumInverse(self, nestedList: List[NestedInteger]) -> int:
        ans = val = 0
        queue = nestedList
        while queue:
            newq = []
            for x in queue:
                if x.isInteger(): val += x.getInteger()
                else: newq.extend(x.getList())
            queue = newq
            ans += val
        return ans


    """365. Water and Jug Problem (Medium)
    You are given two jugs with capacities x and y litres. There is an infinite
    amount of water supply available. You need to determine whether it is
    possible to measure exactly z litres using these two jugs. If z liters of
    water is measurable, you must have z liters of water contained within one
    or both buckets by the end.

    Operations allowed:
    * Fill any of the jugs completely with water.
    * Empty any of the jugs.
    * Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.

    Example 1: (From the famous "Die Hard" example)
    Input: x = 3, y = 5, z = 4
    Output: True

    Example 2:
    Input: x = 2, y = 6, z = 5
    Output: False

    Constraints:
    0 <= x <= 10^6
    0 <= y <= 10^6
    0 <= z <= 10^6"""

    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        if not z: return True #edge case

        def gcd(x, y):
            """Return greatest common divisor via Euclidean algo"""
            if x < y: x, y = y, x
            while y: x, y = y, x%y
            return x

        return z <= x + y and z % gcd(x, y) == 0


    """366. Find Leaves of Binary Tree (Medium)
    Given a binary tree, collect a tree's nodes as if you were doing this:
    Collect and remove all leaves, repeat until the tree is empty.

    Example:
    Input: [1,2,3,4,5]
              1
             / \
            2   3
           / \
          4   5
    Output: [[4,5,3],[2],[1]]

    Explanation:
    1. Removing the leaves [4,5,3] would result in this tree:
              1
             /
            2
    2. Now removing the leaf [2] would result in this tree:
              1

    3. Now removing the leaf [1] would result in the empty tree:
              []
    [[3,5,4],[2],[1]], [[3,4,5],[2],[1]], etc, are also consider correct
    answers since per each level it doesn't matter the order on which elements
    are returned."""

    def findLeaves(self, root: TreeNode) -> List[List[int]]:

        def fn(node):
            """Return height of give node."""
            if not node: return 0
            h = 1 + max(fn(node.left), fn(node.right))
            seen.setdefault(h, []).append(node.val)
            return h

        seen = {}
        fn(root)
        return seen.values()


    """368. Largest Divisible Subset (Medium)
    Given a set of distinct positive integers, find the largest subset such
    that every pair (Si, Sj) of elements in this subset satisfies:

    Si % Sj = 0 or Sj % Si = 0.

    If there are multiple solutions, return any subset is fine.

    Example 1:
    Input: [1,2,3]
    Output: [1,2] (of course, [1,3] will also be ok)

    Example 2:
    Input: [1,2,4,8]
    Output: [1,2,4,8]"""

    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        dp = []
        for i, x in enumerate(nums):
            dp.append([x])
            for ii in range(i):
                if x % nums[ii] == 0:
                    dp[-1] = max(dp[-1], dp[ii] + [x], key=len)
        return max(dp, key=len)


    """369. Plus One Linked List (Medium)
    Given a non-negative integer represented as a linked list of digits, plus
    one to the integer. The digits are stored such that the most significant
    digit is at the head of the list.

    Example 1:
    Input: head = [1,2,3]
    Output: [1,2,4]

    Example 2:
    Input: head = [0]
    Output: [1]

    Constraints:
    * The number of nodes in the linked list is in the range [1, 100].
    * 0 <= Node.val <= 9
    * The number represented by the linked list does not contain leading zeros
      except for the zero itself. """

    def plusOne(self, head: ListNode) -> ListNode:
        prev, node = None, head
        while node:
            if node.val < 9: prev = node
            node = node.next

        if not prev:
            head = ListNode(1, head)
            node = head.next
        else:
            prev.val += 1
            node = prev.next

        while node:
            node.val = 0
            node = node.next
        return head


    """370. Range Addition (Medium)
    Assume you have an array of length n initialized with all 0's and are given
    k update operations. Each operation is represented as a triplet:
    [startIndex, endIndex, inc] which increments each element of subarray
    A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc.
    Return the modified array after all k operations were executed.

    Example:
    Input: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
    Output: [-2,0,3,5,3]
    Explanation:
    Initial state: [0,0,0,0,0]
    After applying operation [1,3,2]: [0,2,2,2,0]
    After applying operation [2,4,3]: [0,2,5,5,3]
    After applying operation [0,2,-2]: [-2,0,3,5,3]"""

    def getModifiedArray(self, length: int, updates: List[List[int]]) -> List[int]:
        ans = [0]*length
        for si, ei, inc in updates:
            ans[si] += inc
            if ei+1 < length: ans[ei+1] -= inc
        for i in range(1, length): ans[i] += ans[i-1]
        return ans


    """371. Sum of Two Integers (Medium)
    Calculate the sum of two integers a and b, but you are not allowed to use
    the operator + and -.

    Example 1:
    Input: a = 1, b = 2
    Output: 3

    Example 2:
    Input: a = -2, b = 3
    Output: 1"""

    def getSum(self, a: int, b: int) -> int:
        mask = 0xffffffff
        while b&mask:
            a, b = a^b, (a&b) << 1
        return a&mask if b > mask else a


    """372. Super Pow (Medium)
    Your task is to calculate ab mod 1337 where a is a positive integer and b
    is an extremely large positive integer given in the form of an array.

    Example 1:
    Input: a = 2, b = [3]
    Output: 8

    Example 2:
    Input: a = 2, b = [1,0]
    Output: 1024"""

    def superPow(self, a: int, b: List[int]) -> int:
        ans = 1
        for bb in b:
            ans = pow(ans, 10, 1337) * pow(a, bb, 1337)
        return ans % 1337


    """373. Find K Pairs with Smallest Sums (Medium)
    You are given two integer arrays nums1 and nums2 sorted in ascending order
    and an integer k. Define a pair (u,v) which consists of one element from
    the first array and one element from the second array. Find the k pairs
    (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.

    Example 1:
    Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
    Output: [[1,2],[1,4],[1,6]]
    Explanation: The first 3 pairs are returned from the sequence:
                 [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

    Example 2:
    Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
    Output: [1,1],[1,1]
    Explanation: The first 2 pairs are returned from the sequence:
                 [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

    Example 3:
    Input: nums1 = [1,2], nums2 = [3], k = 3
    Output: [1,3],[2,3]
    Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]"""

    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2: return [] # edge case

        hp = [(nums1[0] + nums2[j], 0, j) for j in range(len(nums2))]
        heapify(hp)

        ans = []
        while k and hp:
            k -= 1
            _, i, j = heappop(hp)
            ans.append([nums1[i], nums2[j]])
            if i+1 < len(nums1): heappush(hp, (nums1[i+1] + nums2[j], i+1, j))
        return ans


    """374. Guess Number Higher or Lower (Easy)
    We are playing the Guess Game. The game is as follows:
    * I pick a number from 1 to n. You have to guess which number I picked.
    * Every time you guess wrong, I will tell you whether the number I picked
      is higher or lower than your guess.
    You call a pre-defined API int guess(int num), which returns 3 possible
    results:
    * -1: The number I picked is lower than your guess (i.e. pick < num).
    * 1: The number I picked is higher than your guess (i.e. pick > num).
    * 0: The number I picked is equal to your guess (i.e. pick == num).
    Return the number that I picked.

    Example 1:
    Input: n = 10, pick = 6
    Output: 6

    Example 2:
    Input: n = 1, pick = 1
    Output: 1

    Example 3:
    Input: n = 2, pick = 1
    Output: 1

    Example 4:
    Input: n = 2, pick = 2
    Output: 2

    Constraints:
    * 1 <= n <= 2^31 - 1
    * 1 <= pick <= n"""

    def guessNumber(self, n: int) -> int:
        lo, hi = 1, n
        while lo <= hi:
            mid = lo + hi >> 1
            val = guess(mid)
            if val == -1: hi = mid - 1
            elif val == 0: return mid
            else: lo = mid + 1


    """375. Guess Number Higher or Lower II (Medium)
    We are playing the Guess Game. The game is as follows:
    I pick a number from 1 to n. You have to guess which number I picked. Every
    time you guess wrong, I'll tell you whether the number I picked is higher
    or lower. However, when you guess a particular number x, and you guess
    wrong, you pay $x. You win the game when you guess the number I picked.

    Example:
    n = 10, I pick 8.
    First round:  You guess 5, I tell you that it's higher. You pay $5.
    Second round: You guess 7, I tell you that it's higher. You pay $7.
    Third round:  You guess 9, I tell you that it's lower. You pay $9.
    Game over. 8 is the number I picked. You end up paying $5 + $7 + $9 = $21.

    Given a particular n ≥ 1, find out how much money you need to have to
    guarantee a win."""

    def getMoneyAmount(self, n: int) -> int:

        @cache
        def fn(lo, hi):
            """The cost of guessing a number where lo <= x <= hi."""
            if lo >= hi: return 0 # no need to guess
            ans = inf
            for mid in range(lo, hi+1):
                ans = min(ans, mid + max(fn(lo, mid-1), fn(mid+1, hi)))
            return ans

        return fn(1, n)


    """376. Wiggle Subsequence (Medium)
    A sequence of numbers is called a wiggle sequence if the differences
    between successive numbers strictly alternate between positive and
    negative. The first difference (if one exists) may be either positive or
    negative. A sequence with fewer than two elements is trivially a wiggle
    sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the
    differences (6,-3,5,-7,3) are alternately positive and negative. In
    contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first
    because its first two differences are positive and the second because its
    last difference is zero. Given a sequence of integers, return the length of
    the longest subsequence that is a wiggle sequence. A subsequence is
    obtained by deleting some number of elements (eventually, also zero) from
    the original sequence, leaving the remaining elements in their original
    order.

    Example 1:
    Input: [1,7,4,9,2,5]
    Output: 6
    Explanation: The entire sequence is a wiggle sequence.

    Example 2:
    Input: [1,17,5,10,13,15,10,5,16,8]
    Output: 7
    Explanation: There are several subsequences that achieve this length. One
                 is [1,17,10,13,10,16,8].

    Example 3:
    Input: [1,2,3,4,5,6,7,8,9]
    Output: 2

    Follow up: Can you do it in O(n) time?"""

    def wiggleMaxLength(self, nums: List[int]) -> int:
        ans = 1
        prev = 0
        for i in range(1, len(nums)):
            diff = nums[i] - nums[i-1]
            if diff:
                if prev*diff <= 0: ans += 1
                prev = diff
        return ans


    """377. Combination Sum IV (Medium)
    Given an integer array with all positive numbers and no duplicates, find
    the number of possible combinations that add up to a positive integer
    target.

    Example:
    nums = [1, 2, 3]
    target = 4
    The possible combination ways are:
    (1, 1, 1, 1)
    (1, 1, 2)
    (1, 2, 1)
    (1, 3)
    (2, 1, 1)
    (2, 2)
    (3, 1)
    Note that different sequences are counted as different combinations.
    Therefore the output is 7.

    Follow up:
    * What if negative numbers are allowed in the given array?
    * How does it change the problem?
    * What limitation we need to add to the question to allow negative numbers?

    Credits: Special thanks to @pbrother for adding this problem and creating
             all test cases."""

    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0]*(target + 1)
        dp[0] = 1
        for i in range(target):
            if dp[i]:
                for x in nums:
                    if i+x <= target: dp[i+x] += dp[i]
        return dp[-1]


    """378. Kth Smallest Element in a Sorted Matrix (Medium)
    Given a n x n matrix where each of the rows and columns are sorted in
    ascending order, find the kth smallest element in the matrix. Note that
    it is the kth smallest element in the sorted order, not the kth distinct
    element.

    Example:
    matrix = [
       [ 1,  5,  9],
       [10, 11, 13],
       [12, 13, 15]
    ],
    k = 8,
    return 13.

    Note: You may assume k is always valid, 1 ≤ k ≤ n2."""

    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        pq = [(matrix[i][0], i, 0) for i in range(n)] # min-heap
        for _ in range(k):
            ans, i, j = heappop(pq)
            if j+1 < n: heappush(pq, (matrix[i][j+1], i, j+1))
        return ans


    """383. Ransom Note (Easy)
    Given two stings ransomNote and magazine, return true if ransomNote can be
    constructed from magazine and false otherwise. Each letter in magazine can
    only be used once in ransomNote.

    Example 1:
    Input: ransomNote = "a", magazine = "b"
    Output: false

    Example 2:
    Input: ransomNote = "aa", magazine = "ab"
    Output: false

    Example 3:
    Input: ransomNote = "aa", magazine = "aab"
    Output: true

    Constraints:
    * 1 <= ransomNote.length, magazine.length <= 10^5
    * ransomNote and magazine consist of lowercase English letters."""

    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        return not Counter(ransomNote) - Counter(magazine)


    """386. Lexicographical Numbers (Medium)
    Given an integer n, return 1 - n in lexicographical order. For example,
    given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9]. Please optimize your
    algorithm to use less time and space. The input size may be as large as
    5,000,000."""

    def lexicalOrder(self, n: int) -> List[int]:

        def dfs(x):
            """Pre-order traverse the tree."""
            if x <= n:
                ans.append(x)
                for xx in range(10): dfs(10*x + xx)

        ans = []
        for x in range(1, 10): dfs(x)
        return ans


    """387. First Unique Character in a String (Easy)
    Given a string s, find the first non-repeating character in it and return
    its index. If it does not exist, return -1.

    Example 1:
    Input: s = "leetcode"
    Output: 0

    Example 2:
    Input: s = "loveleetcode"
    Output: 2

    Example 3:
    Input: s = "aabb"
    Output: -1

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of only lowercase English letters."""

    def firstUniqChar(self, s: str) -> int:
        freq = Counter(s)
        return next((i for i, ch in enumerate(s) if freq[ch] == 1), -1)


    """388. Longest Absolute File Path (Medium)
    We will represent the file system as a string where "\n\t" mean a
    subdirectory of the main directory, "\n\t\t" means a subdirectory of the
    subdirectory of the main directory and so on. Each folder will be
    represented as a string of letters and/or digits. Each file will be in the
    form "s1.s2" where s1 and s2 are strings of letters and/or digits. For
    example, the file system above is represented as
    "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext".

    Given a string input representing the file system in the explained format,
    return the length of the longest absolute path to a file in the abstracted
    file system. If there is no file in the system, return 0.

    Example 1:
    Input: input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"
    Output: 20
    Explanation: We have only one file and its path is "dir/subdir2/file.ext" of length 20.
    The path "dir/subdir1" doesn't contain any files.

    Example 2:
    Input: input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
    Output: 32
    Explanation: We have two files:
    "dir/subdir1/file1.ext" of length 21
    "dir/subdir2/subsubdir2/file2.ext" of length 32.
    We return 32 since it is the longest path.

    Example 3:
    Input: input = "a"
    Output: 0
    Explanation: We don't have any files.

    Constraints:
    1 <= input.length <= 10^4
    input may contain lower-case or upper-case English letters, a new line
    character '\n', a tab character '\t', a dot '.', a space ' ' or digits."""

    def lengthLongestPath(self, input: str) -> int:
        ans = 0
        prefix = {-1: 0}
        for subd in input.split("\n"): # sub-directory
            depth = subd.count("\t")
            prefix[depth] = prefix[depth-1] + len(subd) - depth # not including delimiter
            if "." in subd: ans = max(ans, prefix[depth] + depth) # including delimiter
        return ans


    """389. Find the Difference (Easy)
    Given two strings s and t which consist of only lowercase letters. String t
    is generated by random shuffling string s and then add one more letter at a
    random position. Find the letter that was added in t.

    Example:
    Input: s = "abcd" t = "abcde"
    Output: e
    Explanation: 'e' is the letter that was added."""

    def findTheDifference(self, s: str, t: str) -> str:
        return chr(reduce(xor, map(ord, s+t)))


    """390. Elimination Game (Medium)
    There is a list of sorted integers from 1 to n. Starting from left to right,
    remove the first number and every other number afterward until you reach
    the end of the list. Repeat the previous step again, but this time from
    right to left, remove the right most number and every other number from the
    remaining numbers. We keep repeating the steps again, alternating left to
    right and right to left, until a single number remains. Find the last
    number that remains starting with a list of length n.

    Example:
    Input:  n = 9,
            1 2 3 4 5 6 7 8 9
            2 4 6 8
            2 6
            6
    Output: 6"""

    def lastRemaining(self, n: int) -> int:
        if n == 1: return 1
        if n&1: n -= 1
        return n + 2 - 2*self.lastRemaining(n//2)


    """391. Perfect Rectangle (Hard)
    Given N axis-aligned rectangles where N > 0, determine if they all together
    form an exact cover of a rectangular region. Each rectangle is represented
    as a bottom-left point and a top-right point. For example, a unit square is
    represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and
    top-right point is (2, 2)).

    Example 1:
    rectangles = [[1,1,3,3],
                  [3,1,4,2],
                  [3,2,4,4],
                  [1,3,2,4],
                  [2,3,3,4]]
    Return true. All 5 rectangles together form an exact cover of a rectangular
    region.

    Example 2:
    rectangles = [[1,1,2,3],
                  [1,3,2,4],
                  [3,1,4,2],
                  [3,2,4,4]]
    Return false. Because there is a gap between the two rectangular regions.

    Example 3:
    rectangles = [[1,1,3,3],
                  [3,1,4,2],
                  [1,3,2,4],
                  [3,2,4,4]]
    Return false. Because there is a gap in the top center.

    Example 4:
    rectangles = [[1,1,3,3],
                  [3,1,4,2],
                  [1,3,2,4],
                  [2,2,4,4]]
    Return false. Because two of the rectangles overlap with each other."""

    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        area = 0
        corner = set()
        X0 = Y0 = inf
        X1 = Y1 = -inf
        for x0, y0, x1, y1 in rectangles:
            area += (x1-x0)*(y1-y0)
            X0 = min(x0, X0)
            Y0 = min(y0, Y0)
            X1 = max(x1, X1)
            Y1 = max(y1, Y1)
            corner ^= {(x0, y0), (x0, y1), (x1, y0), (x1, y1)}
        return area == (X1-X0)*(Y1-Y0) and corner == {(X0, Y0), (X0, Y1), (X1, Y0), (X1, Y1)}


    """392. Is Subsequence (Easy)
    Given two strings s and t, return true if s is a subsequence of t, or false
    otherwise. A subsequence of a string is a new string that is formed from
    the original string by deleting some (can be none) of the characters
    without disturbing the relative positions of the remaining characters. (i.e.,
    "ace" is a subsequence of "abcde" while "aec" is not).

    Example 1:
    Input: s = "abc", t = "ahbgdc"
    Output: true

    Example 2:
    Input: s = "axc", t = "ahbgdc"
    Output: false

    Constraints:
    * 0 <= s.length <= 100
    * 0 <= t.length <= 10^4
    * s and t consist only of lowercase English letters.

    Follow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where
               k >= 10^9, and you want to check one by one to see if t has its
               subsequence. In this scenario, how would you change your code?"""

    def isSubsequence(self, s: str, t: str) -> bool:
        it = iter(t)
        return all(ch in it for ch in s)


    """393. UTF-8 Validation (Medium)
    A character in UTF8 can be from 1 to 4 bytes long, subjected to the
    following rules:
    + For 1-byte character, the first bit is a 0, followed by its unicode code.
    + For n-bytes character, the first n-bits are all one's, the n+1 bit is 0,
      followed by n-1 bytes with most significant 2 bits being 10.

    This is how the UTF-8 encoding would work:

       Char. number range  |        UTF-8 octet sequence
          (hexadecimal)    |              (binary)
       --------------------+---------------------------------------------
       0000 0000-0000 007F | 0xxxxxxx
       0000 0080-0000 07FF | 110xxxxx 10xxxxxx
       0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
       0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

    Given an array of integers representing the data, return whether it is a
    valid utf-8 encoding. Note that input is an array of integers. Only the
    least significant 8 bits of each integer is used to store the data. This
    means each integer represents only 1 byte of data.

    Example 1:
    data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.
    Return true.
    It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.

    Example 2:
    data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.
    Return false.
    The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.
    The next byte is a continuation byte which starts with 10 and that's correct.
    But the second continuation byte does not start with 10, so it is invalid."""

    def validUtf8(self, data: List[int]) -> bool:
        cnt = 0
        for x in data:
            x = bin(x)[2:].zfill(8)
            if cnt: # in the middle of multi-byte
                if x.startswith("10"): cnt -= 1
                else: return False
            else: # beginning
                cnt = x.find("0")
                if cnt == -1 or cnt == 1 or cnt > 4: return False
                if cnt: cnt -= 1
        return cnt == 0


    """394. Decode String (Medium)
    Given an encoded string, return its decoded string. The encoding rule is:
    k[encoded_string], where the encoded_string inside the square brackets is
    being repeated exactly k times. Note that k is guaranteed to be a positive
    integer. You may assume that the input string is always valid; No extra
    white spaces, square brackets are well-formed, etc. Furthermore, you may
    assume that the original data does not contain any digits and that digits
    are only for those repeat numbers, k. For example, there won't be input
    like 3a or 2[4].

    Example 1:
    Input: s = "3[a]2[bc]"
    Output: "aaabcbc"

    Example 2:
    Input: s = "3[a2[c]]"
    Output: "accaccacc"

    Example 3:
    Input: s = "2[abc]3[cd]ef"
    Output: "abcabccdcdcdef"

    Example 4:
    Input: s = "abc3[cd]xyz"
    Output: "abccdcdcdxyz" """

    def decodeString(self, s: str) -> str:
        stack = []
        nn = ss = ""
        for c in s:
            if c == "[":
                stack.append(ss)
                stack.append(nn)
                nn = ss = ""
            elif c == "]":
                ss *= int(stack.pop())
                ss = stack.pop() + ss
            elif c.isdigit(): nn += c
            else: ss += c
        return ss


    """395. Longest Substring with At Least K Repeating Characters (Medium)
    Find the length of the longest substring T of a given string (consists of
    lowercase letters only) such that every character in T appears no less than
    k times.

    Example 1:
    Input: s = "aaabb", k = 3
    Output: 3
    The longest substring is "aaa", as 'a' is repeated 3 times.

    Example 2:
    Input: s = "ababbc", k = 2
    Output: 5
    The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times."""

    def longestSubstring(self, s: str, k: int) -> int:
        if not s: return 0 # edge case

        freq = {} # frequency table
        for c in s: freq[c] = 1 + freq.get(c, 0)

        if min(freq.values()) < k:
            m = min(freq, key=freq.get)
            return max(self.longestSubstring(ss, k) for ss in s.split(m))
        return len(s)


    """396. Rotate Function (Medium)
    Given an array of integers A and let n to be its length. Assume Bk to be
    an array obtained by rotating the array A k positions clock-wise, we define
    a "rotation function" F on A as follow:

    F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].

    Calculate the maximum value of F(0), F(1), ..., F(n-1).

    Note: n is guaranteed to be less than 10^5.

    Example:
    A = [4, 3, 2, 6]
    F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
    F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
    F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
    F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
    So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26."""

    def maxRotateFunction(self, A: List[int]) -> int:
        ans = val = sum(i*x for i, x in enumerate(A))
        ss = sum(A)
        for x in reversed(A):
            val += ss - len(A)*x
            ans = max(ans, val)
        return ans


    """397. Integer Replacement (Medium)
    Given a positive integer n and you can do operations as follow:
    + If n is even, replace n with n/2.
    + If n is odd, you can replace n with either n + 1 or n - 1.
    What is the minimum number of replacements needed for n to become 1?

    Example 1:
    Input: 8
    Output: 3
    Explanation: 8 -> 4 -> 2 -> 1

    Example 2:
    Input: 7
    Output: 4
    Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1"""

    def integerReplacement(self, n: int) -> int:

        @cache
        def fn(n):
            """Return """
            if n == 1: return 0
            if not n&1: return 1 + fn(n//2)
            return 1 + min(fn(n+1), fn(n-1))

        return fn(n)


    """399. Evaluate Division (Medium)
    Equations are given in the format A / B = k, where A and B are variables
    represented as strings, and k is a real number (floating point number).
    Given some queries, return the answers. If the answer does not exist,
    return -1.0.

    Example:
    Given a / b = 2.0, b / c = 3.0.
    queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .
    return [6.0, 0.5, -1.0, 1.0, -1.0 ].

    The input is: vector<pair<string, string>> equations, vector<double>& values,
                  vector<pair<string, string>> queries , where equations.size() == values.size(),
                  and the values are positive. This represents the equations. Return vector<double>.

    According to the example above:
    equations = [ ["a", "b"], ["b", "c"] ],
    values = [2.0, 3.0],
    queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ].
    The input is always valid. You may assume that evaluating the queries will
    result in no division by zero and there is no contradiction."""

    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        graph = {}
        for (u, v), w in zip(equations, values):
            graph.setdefault(u, []).append((v, 1/w))
            graph.setdefault(v, []).append((u, w))

        def dfs(n, g, val=1):
            """Depth-first traverse the graph."""
            if n in vals: return
            vals[n] = val, g
            for nn, w in graph.get(n, []): dfs(nn, g, w*val)

        vals = dict()
        for i, n in enumerate(graph): dfs(n, i)

        ans = []
        for u, v in queries:
            if u in vals and v in vals and vals[u][1] == vals[v][1]: ans.append(vals[u][0]/vals[v][0])
            else: ans.append(-1)
        return ans


    """400. Nth Digit (Medium)
    Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8,
    9, 10, 11, ... Note that n is positive and will fit within the range of a
    32-bit signed integer (n < 2^31).

    Example 1:
    Input: 3
    Output: 3

    Example 2:
    Input: 11
    Output: 0
    Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                 11, ... is a 0, which is part of the number 10."""

    def findNthDigit(self, n: int) -> int:
        base = mult = 1
        while n > 9*base*mult:
            n -= 9*base*mult
            base *= 10
            mult += 1
        q, r = divmod(n-1, mult)
        return int(str(base + q)[r])


    """402. Remove K Digits (Medium)
    Given a non-negative integer num represented as a string, remove k digits
    from the number so that the new number is the smallest possible.

    Note:
    + The length of num is less than 10002 and will be ≥ k.
    + The given num does not contain any leading zero.

    Example 1:
    Input: num = "1432219", k = 3
    Output: "1219"
    Explanation: Remove the three digits 4, 3, and 2 to form the new number
                 1219 which is the smallest.

    Example 2:
    Input: num = "10200", k = 1
    Output: "200"
    Explanation: Remove the leading 1 and the number is 200. Note that the
                 output must not contain leading zeroes.

    Example 3:
    Input: num = "10", k = 2
    Output: "0"
    Explanation: Remove all the digits from the number and it is left with
                 nothing which is 0."""

    def removeKdigits(self, num: str, k: int) -> str:
        stack = []
        for x in num:
            while k and stack and stack[-1] > x:
                k -= 1
                stack.pop()
            stack.append(x)
        return "".join(stack[:-k or None]).lstrip("0") or "0"


    """403. Frog Jump (Hard)
    A frog is crossing a river. The river is divided into some number of units,
    and at each unit, there may or may not exist a stone. The frog can jump on
    a stone, but it must not jump into the water. Given a list of stones'
    positions (in units) in sorted ascending order, determine if the frog can
    cross the river by landing on the last stone. Initially, the frog is on the
    first stone and assumes the first jump must be 1 unit. If the frog's last
    jump was k units, its next jump must be either k - 1, k, or k + 1 units.
    The frog can only jump in the forward direction.

    Example 1:
    Input: stones = [0,1,3,5,6,8,12,17]
    Output: true
    Explanation: The frog can jump to the last stone by jumping 1 unit to the
                 2nd stone, then 2 units to the 3rd stone, then 2 units to the
                 4th stone, then 3 units to the 6th stone, 4 units to the 7th
                 stone, and 5 units to the 8th stone.

    Example 2:
    Input: stones = [0,1,2,3,4,8,9,11]
    Output: false
    Explanation: There is no way to jump to the last stone as the gap between
                 the 5th and 6th stone is too large.

    Constraints:
    * 2 <= stones.length <= 2000
    * 0 <= stones[i] <= 2^31 - 1
    * stones[0] == 0"""

    def canCross(self, stones: List[int]) -> bool:
        if stones[1] != 1: return False
        loc = set(stones)

        @cache
        def fn(x, step):
            """Return True if it is possible to cross river at stones[i]."""
            if x == stones[-1]: return True
            ans = False
            for ss in (step-1, step, step+1):
                if 0 < ss and x + ss in loc: ans = ans or fn(x + ss, ss)
            return ans

        return fn(1, 1)


    """404. Sum of Left Leaves (Easy)
    Given the root of a binary tree, return the sum of all left leaves.

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
    Output: 24
    Explanation: There are two left leaves in the binary tree, with values 9
                 and 15 respectively.

    Example 2:
    Input: root = [1]
    Output: 0

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * -1000 <= Node.val <= 1000"""

    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        ans = 0
        stack = [(root, False)]
        while stack:
            node, tf = stack.pop()
            if not node.left and not node.right and tf: ans += node.val
            if node.left: stack.append((node.left, True))
            if node.right: stack.append((node.right, False))
        return ans


    """406. Queue Reconstruction by Height (Medium)
    Suppose you have a random list of people standing in a queue. Each person
    is described by a pair of integers (h, k), where h is the height of the
    person and k is the number of people in front of this person who have a
    height greater than or equal to h. Write an algorithm to reconstruct the
    queue.
    Note: The number of people is less than 1,100.

    Example
    Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
    Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]"""

    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        ans = []
        for h, k in sorted(people, key=lambda x: (-x[0], x[1])): # tallest to shortest
            ans.insert(k, [h, k])
        return ans


    """407. Trapping Rain Water II (Hard)
    Given an m x n integer matrix heightMap representing the height of each
    unit cell in a 2D elevation map, return the volume of water it can trap
    after raining.

    Example 1:
    Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
    Output: 4
    Explanation: After the rain, water is trapped between the blocks. We have
                 two small pounds 1 and 3 units trapped. The total volume of
                 water trapped is 4.

    Example 2:
    Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
    Output: 10

    Constraints:
    * m == heightMap.length
    * n == heightMap[i].length
    * 1 <= m, n <= 200
    * 0 <= heightMap[i][j] <= 2 * 10^4"""

    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        m, n = len(heightMap), len(heightMap[0])

        pq = []
        for i in range(m):
            heappush(pq, (heightMap[i][0], i, 0))
            heappush(pq, (heightMap[i][n-1], i, n-1))
        for j in range(1, n-1):
            heappush(pq, (heightMap[0][j], 0, j))
            heappush(pq, (heightMap[m-1][j], m-1, j))

        ans = most = 0
        while pq:
            ht, i, j = heappop(pq)
            most = max(most, ht)
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 < ii < m-1 and 0 < jj < n-1 and heightMap[ii][jj] != -1:
                    ans += max(0, most - heightMap[ii][jj])
                    heappush(pq, (heightMap[ii][jj], ii, jj))
                    heightMap[ii][jj] = -1 # mark "visited"
        return ans


    """408. Valid Word Abbreviation (Easy)
    Given a non-empty string s and an abbreviation abbr, return whether the
    string matches with the given abbreviation. A string such as "word"
    contains only the following valid abbreviations:
    ["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d",
     "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
    Notice that only the above abbreviations are valid abbreviations of the
    string "word". Any other string is not a valid abbreviation of "word".

    Note: Assume s contains only lowercase letters and abbr contains only
          lowercase letters and digits.

    Example 1:
    Given s = "internationalization", abbr = "i12iz4n":
    Return true.

    Example 2:
    Given s = "apple", abbr = "a2e":
    Return false."""

    def validWordAbbreviation(self, word: str, abbr: str) -> bool:
        i = j = 0
        while i < len(word) and j < len(abbr):
            if abbr[j].isalpha():
                if word[i] == abbr[j]: i, j = i+1, j+1
                else: return False
            else:
                if abbr[j] == "0": return False # edge case
                jj = j
                while j < len(abbr) and abbr[j].isdigit(): j += 1
                i += int(abbr[jj:j])
        return i == len(word) and j == len(abbr)


    """409. Longest Palindrome (Easy)
    Given a string s which consists of lowercase or uppercase letters, return
    the length of the longest palindrome that can be built with those letters.
    Letters are case sensitive, for example, "Aa" is not considered a
    palindrome here.

    Example 1:
    Input: s = "abccccdd"
    Output: 7
    Explanation: One longest palindrome that can be built is "dccaccd", whose
                 length is 7.

    Example 2:
    Input: s = "a"
    Output: 1

    Example 3:
    Input: s = "bb"
    Output: 2

    Constraints:
    * 1 <= s.length <= 2000
    * s consists of lowercase and/or uppercase English letters only."""

    def longestPalindrome(self, s: str) -> int:
        ans = odd = 0
        for v in Counter(s).values():
            if v&1: odd = 1
            ans += v//2*2
        return ans + odd


    """410. Split Array Largest Sum (Hard)
    Given an array nums which consists of non-negative integers and an integer
    m, you can split the array into m non-empty continuous subarrays. Write an
    algorithm to minimize the largest sum among these m subarrays.

    Example 1:
    Input: nums = [7,2,5,10,8], m = 2
    Output: 18
    Explanation: There are four ways to split nums into two subarrays. The best
                 way is to split it into [7,2,5] and [10,8], where the largest
                 sum among the two subarrays is only 18.

    Example 2:
    Input: nums = [1,2,3,4,5], m = 2
    Output: 9

    Example 3:
    Input: nums = [1,4,4], m = 3
    Output: 4

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 10^6
    * 1 <= m <= min(50, nums.length)"""

    def splitArray(self, nums: List[int], m: int) -> int:

        def fn(val):
            """Return True if it is possible to split."""
            cnt = sm = 0
            for x in nums:
                if sm + x > val:
                    cnt += 1
                    sm = 0
                sm += x
            return cnt+1 <= m

        lo, hi = max(nums), sum(nums)
        while lo < hi:
            mid = lo + hi >> 1
            if fn(mid): hi = mid
            else: lo = mid + 1
        return lo


    """413. Arithmetic Slices (Medium)
    A sequence of numbers is called arithmetic if it consists of at least three
    elements and if the difference between any two consecutive elements is the
    same. For example, these are arithmetic sequences:
    1, 3, 5, 7, 9
    7, 7, 7, 7
    3, -1, -5, -9

    The following sequence is not arithmetic: 1, 1, 2, 5, 7. A zero-indexed
    array A consisting of N numbers is given. A slice of that array is any pair
    of integers (P, Q) such that 0 <= P < Q < N. A slice (P, Q) of the array A
    is called arithmetic if the sequence: A[P], A[P + 1], ..., A[Q - 1], A[Q]
    is arithmetic. In particular, this means that P + 1 < Q. The function
    should return the number of arithmetic slices in the array A.

    Example:
    A = [1, 2, 3, 4]
    return: 3, for 3 arithmetic slices in A:
    [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself."""

    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        ans = cnt = 0
        for i in range(2, len(nums)):
            if nums[i-2] - nums[i-1] == nums[i-1] - nums[i]: cnt += 1
            else: cnt = 0
            ans += cnt
        return ans


    """415. Add Strings (Easy)
    Given two non-negative integers, num1 and num2 represented as string,
    return the sum of num1 and num2 as a string. You must solve the problem
    without using any built-in library for handling large integers (such as
    BigInteger). You must also not convert the inputs to integers directly.

    Example 1:
    Input: num1 = "11", num2 = "123"
    Output: "134"

    Example 2:
    Input: num1 = "456", num2 = "77"
    Output: "533"

    Example 3:
    Input: num1 = "0", num2 = "0"
    Output: "0"

    Constraints:
    * 1 <= num1.length, num2.length <= 10^4
    * num1 and num2 consist of only digits.
    * num1 and num2 don't have any leading zeros except for the zero itself."""

    def addStrings(self, num1: str, num2: str) -> str:
        ans = []
        carry = 0
        for x, y in zip_longest(reversed(num1), reversed(num2), fillvalue="0"):
            carry, x = divmod(carry + int(x) + int(y), 10)
            ans.append(x)
        if carry: ans.append(carry)
        return "".join(map(str, reversed(ans)))


    """416. Partition Equal Subset Sum (Medium)
    Given a non-empty array nums containing only positive integers, find if the
    array can be partitioned into two subsets such that the sum of elements in
    both subsets is equal.

    Example 1:
    Input: nums = [1,5,11,5]
    Output: true
    Explanation: The array can be partitioned as [1, 5, 5] and [11].

    Example 2:
    Input: nums = [1,2,3,5]
    Output: false
    Explanation: The array cannot be partitioned into equal sum subsets.

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= 100"""

    def canPartition(self, nums: List[int]) -> bool:
        sm = sum(nums)
        if sm & 1: return False
        bits = 1
        for x in nums: bits |= bits << x
        return bool(bits & (1<<sm//2))


    """418. Sentence Screen Fitting (Medium)
    Given a rows x cols screen and a sentence represented by a list of non-
    empty words, find how many times the given sentence can be fitted on the
    screen.

    Note:
    * A word cannot be split into two lines.
    * The order of words in the sentence must remain unchanged.
    * Two consecutive words in a line must be separated by a single space.
    * Total words in the sentence won't exceed 100.
    * Length of each word is greater than 0 and won't exceed 10.
    * 1 ≤ rows, cols ≤ 20,000.

    Example 1:
    Input: rows = 2, cols = 8, sentence = ["hello", "world"]
    Output: 1
    Explanation:
        hello---
        world---
    The character '-' signifies an empty space on the screen.

    Example 2:
    Input: rows = 3, cols = 6, sentence = ["a", "bcd", "e"]
    Output: 2
    Explanation:
        a-bcd-
        e-a---
        bcd-e-
    The character '-' signifies an empty space on the screen.

    Example 3:
    Input: rows = 4, cols = 5, sentence = ["I", "had", "apple", "pie"]
    Output: 1
    Explanation:
        I-had
        apple
        pie-I
        had--
    The character '-' signifies an empty space on the screen."""

    def wordsTyping(self, sentence: List[str], rows: int, cols: int) -> int:
        ss = " ".join(sentence) + " "
        ans = 0
        for _ in range(rows):
            ans += cols
            while ss[ans % len(ss)] != " ": ans -= 1
            ans += 1
        return ans // len(ss)


    """419. Battleships in a Board (Medium)
    Given an m x n matrix board where each cell is a battleship 'X' or empty
    '.', return the number of the battleships on board. Battleships can only be
    placed horizontally or vertically on board. In other words, they can only
    be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column),
    where k can be of any size. At least one horizontal or vertical cell
    separates between two battleships (i.e., there are no adjacent battleships).

    Example 1:
    Input: board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]]
    Output: 2

    Example 2:
    Input: board = [["."]]
    Output: 0

    Constraints:
    * m == board.length
    * n == board[i].length
    * 1 <= m, n <= 200
    * board[i][j] is either '.' or 'X'.

    Follow up: Could you do it in one-pass, using only O(1) extra memory and
               without modifying the values board?"""

    def countBattleships(self, board: List[List[str]]) -> int:
        m, n = len(board), len(board[0])
        ans = 0
        for i in range(m):
            for j in range(n):
                if board[i][j] == 'X' and (i == 0 or board[i-1][j] == '.') and (j == 0 or board[i][j-1] == '.'):
                    ans += 1
        return ans


    """420. Strong Password Checker (Hard)
    A password is considered strong if the below conditions are all met:
    * It has at least 6 characters and at most 20 characters.
    * It contains at least one lowercase letter, at least one uppercase letter,
      and at least one digit.
    * It does not contain three repeating characters in a row (i.e., "...aaa..."
      is weak, but "...aa...a..." is strong, assuming other conditions are met).
    Given a string password, return the minimum number of steps required to
    make password strong. if password is already strong, return 0. In one step,
    you can:
    * Insert one character to password,
    * Delete one character from password, or
    * Replace one character of password with another character.

    Example 1:
    Input: password = "a"
    Output: 5

    Example 2:
    Input: password = "aA1"
    Output: 3

    Example 3:
    Input: password = "1337C0d3"
    Output: 0

    Constraints:
    * 1 <= password.length <= 50
    * password consists of letters, digits, dot '.' or exclamation mark '!'."""

    def strongPasswordChecker(self, password: str) -> int:
        digit = lower = upper = 1
        for ch in password:
            if ch.isdigit(): digit = 0
            elif ch.islower(): lower = 0
            elif ch.isupper(): upper = 0
        missing = digit + lower + upper
        reps = one = two = 0
        i = 2
        while i < len(password):
            if password[i-2] == password[i-1] == password[i]:
                sz = 3
                while i+1 < len(password) and password[i] == password[i+1]:
                    sz += 1
                    i += 1
                reps += sz // 3
                if sz % 3 == 0: one += 1
                elif sz % 3 == 1: two += 1
            i += 1
        if len(password) < 6: return max(missing, 6 - len(password))
        elif len(password) <= 20: return max(missing, reps)
        else:
            dels = len(password) - 20
            reps -= min(dels, one)
            reps -= min(max(dels - one, 0), two * 2) // 2
            reps -= max(dels - one - 2 * two, 0) // 3
            return dels + max(missing, reps)


    """421. Maximum XOR of Two Numbers in an Array (Medium)
    Given an integer array nums, return the maximum result of nums[i] XOR
    nums[j], where 0 <= i <= j < n.

    Example 1:
    Input: nums = [3,10,5,25,2,8]
    Output: 28
    Explanation: The maximum result is 5 XOR 25 = 28.

    Example 2:
    Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
    Output: 127

    Constraints:
    * 1 <= nums.length <= 2 * 10^5
    * 0 <= nums[i] <= 2^31 - 1"""

    def findMaximumXOR(self, nums: List[int]) -> int:
        ans = 0
        trie = {}
        for x in nums:
            node = oppo = trie
            for bit in map(int, bin(x)[2:].zfill(32)):
                node = node.setdefault(bit, {})
                oppo = oppo.get(1-bit) or oppo[bit]
            node['$'] = x
            ans = max(ans, oppo['$'] ^ x)
        return ans


    """422. Valid Word Square (Easy)
    Given a sequence of words, check whether it forms a valid word square. A
    sequence of words forms a valid word square if the kth row and column read
    the exact same string, where 0 ≤ k < max(numRows, numColumns).

    Note:
    * The number of words given is at least 1 and does not exceed 500.
    * Word length will be at least 1 and does not exceed 500.
    * Each word contains only lowercase English alphabet a-z.

    Example 1:
    Input: ["abcd",
            "bnrt",
            "crmy",
            "dtye"]
    Output: true
    Explanation:
    The first row and first column both read "abcd".
    The second row and second column both read "bnrt".
    The third row and third column both read "crmy".
    The fourth row and fourth column both read "dtye".
    Therefore, it is a valid word square.

    Example 2:
    Input: ["abcd",
            "bnrt",
            "crm",
            "dt"]
    Output: true
    Explanation:
    The first row and first column both read "abcd".
    The second row and second column both read "bnrt".
    The third row and third column both read "crm".
    The fourth row and fourth column both read "dt".
    Therefore, it is a valid word square.

    Example 3:
    Input: ["ball",
            "area",
            "read",
            "lady"]
    Output: false
    Explanation:
    The third row reads "read" while the third column reads "lead".
    Therefore, it is NOT a valid word square."""

    def validWordSquare(self, words: List[str]) -> bool:
        return words == ["".join(x) for x in zip_longest(*words, fillvalue="")]


    """426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium)
    Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in
    place. You can think of the left and right pointers as synonymous to the
    predecessor and successor pointers in a doubly-linked list. For a circular
    doubly linked list, the predecessor of the first element is the last
    element, and the successor of the last element is the first element. We
    want to do the transformation in place. After the transformation, the left
    pointer of the tree node should point to its predecessor, and the right
    pointer should point to its successor. You should return the pointer to the
    smallest element of the linked list.

    Example 1:
    Input: root = [4,2,5,1,3]
    Output: [1,2,3,4,5]
    Explanation: The figure below shows the transformed BST. The solid line
                 indicates the successor relationship, while the dashed line
                 means the predecessor relationship.

    Example 2:
    Input: root = [2,1,3]
    Output: [1,2,3]

    Example 3:
    Input: root = []
    Output: []
    Explanation: Input is an empty tree. Output is also an empty Linked List.

    Example 4:
    Input: root = [1]
    Output: [1]

    Constraints:
    * -1000 <= Node.val <= 1000
    * Node.left.val < Node.val < Node.right.val
    * All values of Node.val are unique.
    * 0 <= Number of Nodes <= 2000"""

    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: return # edge case

        def fn(node):
            """Return head & tail of flattened tree."""
            head = tail = node
            if node.left:
                head, tail0 = fn(node.left)
                tail0.right = node
                node.left = tail0
            if node.right:
                head1, tail = fn(node.right)
                node.right = head1
                head1.left = node
            return head, tail

        head, tail = fn(root)
        head.left = tail
        tail.right = head
        return head


    """427. Construct Quad Tree (Medium)
    Given a n * n matrix grid of 0's and 1's only. We want to represent the
    grid with a Quad-Tree. Return the root of the Quad-Tree representing the
    grid. Notice that you can assign the value of a node to True or False when
    isLeaf is False, and both are accepted in the answer. A Quad-Tree is a tree
    data structure in which each internal node has exactly four children.
    Besides, each node has two attributes:
    * val: True if the node represents a grid of 1's or False if the node
      represents a grid of 0's.
    * isLeaf: True if the node is leaf node on the tree or False if the node
      has the four children.
    class Node {
        public boolean val;
        public boolean isLeaf;
        public Node topLeft;
        public Node topRight;
        public Node bottomLeft;
        public Node bottomRight;
    }
    We can construct a Quad-Tree from a two-dimensional area using the
    following steps:
    * If the current grid has the same value (i.e all 1's or all 0's) set
      isLeaf True and set val to the value of the grid and set the four
      children to Null and stop.
    * If the current grid has different values, set isLeaf to False and set val
      to any value and divide the current grid into four sub-grids as shown in
      the photo.
    * Recurse for each of the children with the proper sub-grid.
    If you want to know more about the Quad-Tree, you can refer to the wiki.
    Quad-Tree format:
    * The output represents the serialized format of a Quad-Tree using level
      order traversal, where null signifies a path terminator where no node
      exists below.
    * It is very similar to the serialization of the binary tree. The only
      difference is that the node is represented as a list [isLeaf, val].
    * If the value of isLeaf or val is True we represent it as 1 in the list
      [isLeaf, val] and if the value of isLeaf or val is False we represent it
      as 0.

    Example 1:
    Input: grid = [[0,1],[1,0]]
    Output: [[0,1],[1,0],[1,1],[1,1],[1,0]]
    Explanation: The explanation of this example is shown below: Notice that 0
                 represnts False and 1 represents True in the photo
                 representing the Quad-Tree.

    Example 2:
    Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]
    Output: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
    Explanation: All values in the grid are not the same. We divide the grid
                 into four sub-grids. The topLeft, bottomLeft and bottomRight
                 each has the same value. The topRight have different values so
                 we divide it into 4 sub-grids where each has the same value.
                 Explanation is shown in the photo below:

    Constraints:
    * n == grid.length == grid[i].length
    * n == 2x where 0 <= x <= 6"""

    def construct(self, grid: List[List[int]]) -> 'Node':
        n = len(grid)
        prefix = [[0]*(n+1) for _ in range(n+1)]
        for i in range(n):
            for j in range(n):
                prefix[i+1][j+1] = prefix[i][j+1] + prefix[i+1][j] - prefix[i][j] + grid[i][j]

        def fn(i, ii, j, jj):
            """Return QuadTree subtree."""
            diff = prefix[ii][jj] - prefix[i][jj] - prefix[ii][j] + prefix[i][j]
            if diff in (0, (ii-i)*(jj-j)): return Node(grid[i][j], True)
            tl = fn(i, (i+ii)//2, j, (j+jj)//2)
            tr = fn(i, (i+ii)//2, (j+jj)//2, jj)
            bl = fn((i+ii)//2, ii, j, (j+jj)//2)
            br = fn((i+ii)//2, ii, (j+jj)//2, jj)
            return Node(False, False, tl, tr, bl, br)

        return fn(0, n, 0, n)


    """429. N-ary Tree Level Order Traversal (Medium)
    Given an n-ary tree, return the level order traversal of its nodes' values.
    Nary-Tree input serialization is represented in their level order traversal,
    each group of children is separated by the null value (See examples).

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: [[1],[3,2,4],[5,6]]

    Example 2:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]

    Constraints:
    * The height of the n-ary tree is less than or equal to 1000
    * The total number of nodes is between [0, 10^4]"""

    def levelOrder(self, root: 'Node') -> List[List[int]]:
        ans = []
        if root:
            queue = [root]
            while queue:
                newq, vals = [], []
                for x in queue:
                    vals.append(x.val)
                    newq.extend(x.children)
                ans.append(vals)
                queue = newq
        return ans


    """430. Flatten a Multilevel Doubly Linked List (Medium)
    You are given a doubly linked list which in addition to the next and
    previous pointers, it could have a child pointer, which may or may not
    point to a separate doubly linked list. These child lists may have one or
    more children of their own, and so on, to produce a multilevel data
    structure, as shown in the example below. Flatten the list so that all the
    nodes appear in a single-level, doubly linked list. You are given the head
    of the first level of the list.

    Example 1:
    Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
    Output: [1,2,3,7,8,11,12,9,10,4,5,6]

    Example 2:
    Input: head = [1,2,null,3]
    Output: [1,3,2]
    Explanation: The input multilevel linked list is as follows:
                 1---2---NULL
                 |
                 3---NULL

    Example 3:
    Input: head = []
    Output: []

    How multilevel linked list is represented in test case:
    We use the multilevel linked list from Example 1 above:
     1---2---3---4---5---6--NULL
             |
             7---8---9---10--NULL
                 |
                 11--12--NULL
    The serialization of each level is as follows:
    [1,2,3,4,5,6,null]
    [7,8,9,10,null]
    [11,12,null]
    To serialize all levels together we will add nulls in each level to signify
    no node connects to the upper node of the previous level. The serialization
    becomes:
    [1,2,3,4,5,6,null]
    [null,null,7,8,9,10,null]
    [null,11,12,null]
    Merging the serialization of each level and removing trailing nulls we obtain:
    [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]

    Constraints:
    * The number of Nodes will not exceed 1000.
    * 1 <= Node.val <= 10^5"""

    def flatten(self, head: 'Node') -> 'Node':
        node = head
        stack = []
        while node:
            if node.child:
                if node.next: stack.append(node.next)
                node.next = node.child
                node.next.prev = node
                node.child = None
            elif not node.next and stack:
                node.next = stack.pop()
                node.next.prev = node
            node = node.next
        return head


    """435. Non-overlapping Intervals (Medium)
    Given an array of intervals intervals where intervals[i] = [starti, endi],
    return the minimum number of intervals you need to remove to make the rest
    of the intervals non-overlapping.

    Example 1:
    Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
    Output: 1
    Explanation: [1,3] can be removed and the rest of the intervals are non-
                 overlapping.

    Example 2:
    Input: intervals = [[1,2],[1,2],[1,2]]
    Output: 2
    Explanation: You need to remove two [1,2] to make the rest of the intervals
                 non-overlapping.

    Example 3:
    Input: intervals = [[1,2],[2,3]]
    Output: 0
    Explanation: You don't need to remove any of the intervals since they're
                 already non-overlapping.

    Constraints:
    * 1 <= intervals.length <= 10^5
    * intervals[i].length == 2
    * -5 * 10^4 <= starti < endi <= 5 * 10^4"""

    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        ans, prev = 0, -inf
        for x, y in sorted(intervals, key=lambda x: x[1]):
            if x < prev: ans += 1
            else: prev = y
        return ans


    """438. Find All Anagrams in a String (Medium)
    Given two strings s and p, return an array of all the start indices of p's
    anagrams in s. You may return the answer in any order. An Anagram is a word
    or phrase formed by rearranging the letters of a different word or phrase,
    typically using all the original letters exactly once.

    Example 1:
    Input: s = "cbaebabacd", p = "abc"
    Output: [0,6]
    Explanation: The substring with start index = 0 is "cba", which is an
                 anagram of "abc". The substring with start index = 6 is "bac",
                 which is an anagram of "abc".

    Example 2:
    Input: s = "abab", p = "ab"
    Output: [0,1,2]
    Explanation: The substring with start index = 0 is "ab", which is an
                 anagram of "ab". The substring with start index = 1 is "ba",
                 which is an anagram of "ab". The substring with start
                 index = 2 is "ab", which is an anagram of "ab".

    Constraints:
    * 1 <= s.length, p.length <= 3 * 10^4
    * s and p consist of lowercase English letters."""

    def findAnagrams(self, s: str, p: str) -> List[int]:
        freq = Counter(p)
        ans = []
        for i, x in enumerate(s):
            freq[x] -= 1;
            if len(p) <= i: freq[s[i-len(p)]] += 1
            if not any(freq.values()): ans.append(i-len(p)+1)
        return ans


    """439. Ternary Expression Parser (Medium)
    Given a string expression representing arbitrarily nested ternary
    expressions, evaluate the expression, and return the result of it. You can
    always assume that the given expression is valid and only contains digits,
    '?', ':', 'T', and 'F' where 'T' is true and 'F' is false. All the numbers
    in the expression are one-digit numbers (i.e., in the range [0, 9]). The
    conditional expressions group right-to-left (as usual in most languages),
    and the result of the expression will always evaluate to either a digit,
    'T' or 'F'.

    Example 1:
    Input: expression = "T?2:3"
    Output: "2"
    Explanation: If true, then result is 2; otherwise result is 3.

    Example 2:
    Input: expression = "F?1:T?4:5"
    Output: "4"
    Explanation: The conditional expressions group right-to-left. Using
                 parenthesis, it is read/evaluated as:
                 "(F ? 1 : (T ? 4 : 5))" --> "(F ? 1 : 4)" --> "4"
                 or "(F ? 1 : (T ? 4 : 5))" --> "(T ? 4 : 5)" --> "4"

    Example 3:
    Input: expression = "T?T?F:5:3"
    Output: "F"
    Explanation: The conditional expressions group right-to-left. Using
                 parenthesis, it is read/evaluated as:
                 "(T ? (T ? F : 5) : 3)" --> "(T ? F : 3)" --> "F"
                 "(T ? (T ? F : 5) : 3)" --> "(T ? F : 5)" --> "F"

    Constraints:
    * 5 <= expression.length <= 10^4
    * expression consists of digits, 'T', 'F', '?', and ':'.
    * It is guaranteed that expression is a valid ternary expression and that
      each number is a one-digit number."""

    def parseTernary(self, expression: str) -> str:
        stack = []
        for ch in reversed(expression):
            if stack and stack[-1] == "?":
                stack.pop() # pop out "?"
                t = stack.pop()
                f = stack.pop()
                if ch == "T": stack.append(t)
                else: stack.append(f)
            elif ch != ":": stack.append(ch)
        return stack[-1]


    """440. K-th Smallest in Lexicographical Order (Hard)
    Given two integers n and k, return the kth lexicographically smallest
    integer in the range [1, n].

    Example 1:
    Input: n = 13, k = 2
    Output: 10
    Explanation: The lexicographical order is
                 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second
                 smallest number is 10.

    Example 2:
    Input: n = 1, k = 1
    Output: 1

    Constraints: 1 <= k <= n <= 10^9"""

    def findKthNumber(self, n: int, k: int) -> int:

        def fn(x):
            """Return node counts in denary trie."""
            ans, diff = 0, 1
            while x <= n:
                ans += min(n - x + 1, diff)
                x *= 10
                diff *= 10
            return ans

        x = 1
        while k > 1:
            cnt = fn(x)
            if k > cnt: k -= cnt; x += 1
            else: k -= 1; x *= 10
        return x


    """441. Arranging Coins (Easy)
    You have n coins and you want to build a staircase with these coins. The
    staircase consists of k rows where the ith row has exactly i coins. The
    last row of the staircase may be incomplete. Given the integer n, return
    the number of complete rows of the staircase you will build.

    Example 1:
    Input: n = 5
    Output: 2
    Explanation: Because the 3rd row is incomplete, we return 2.

    Example 2:
    Input: n = 8
    Output: 3
    Explanation: Because the 4th row is incomplete, we return 3.

    Constraints: 1 <= n <= 2^31 - 1"""

    def arrangeCoins(self, n: int) -> int:
        return int((sqrt(8*n + 1) - 1)//2)


    """442. Find All Duplicates in an Array (Medium)
    Given an integer array nums of length n where all the integers of nums are
    in the range [1, n] and each integer appears once or twice, return an array
    of all the integers that appears twice. You must write an algorithm that
    runs in O(n) time and uses only constant extra space.

    Example 1:
    Input: nums = [4,3,2,7,8,2,3,1]
    Output: [2,3]

    Example 2:
    Input: nums = [1,1,2]
    Output: [1]

    Example 3:
    Input: nums = [1]
    Output: []

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= n
    * Each element in nums appears once or twice."""

    def findDuplicates(self, nums: List[int]) -> List[int]:
        ans = []
        for x in nums:
            x = abs(x)
            if nums[x-1] < 0: ans.append(x)
            nums[x-1] *= -1
        return ans


    """446. Arithmetic Slices II - Subsequence (Hard)
    Given an integer array nums, return the number of all the arithmetic
    subsequences of nums. A sequence of numbers is called arithmetic if it
    consists of at least three elements and if the difference between any two
    consecutive elements is the same.
    * For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are
      arithmetic sequences.
    * For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.
    A subsequence of an array is a sequence that can be formed by removing some
    elements (possibly none) of the array.
    * For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].
    The answer is guaranteed to fit in 32-bit integer.

    Example 1:
    Input: nums = [2,4,6,8,10]
    Output: 7
    Explanation: All arithmetic subsequence slices are:
                 [2,4,6]
                 [4,6,8]
                 [6,8,10]
                 [2,4,6,8]
                 [4,6,8,10]
                 [2,4,6,8,10]
                 [2,6,10]

    Example 2:
    Input: nums = [7,7,7,7,7]
    Output: 16
    Explanation: Any subsequence of this array is arithmetic.

    Constraints:
    * 1  <= nums.length <= 1000
    * -2^31 <= nums[i] <= 2^31 - 1"""

    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        ans = 0
        freq = [defaultdict(int) for _ in range(len(nums))] # arithmetic sub-seqs
        for i, x in enumerate(nums):
            for ii in range(i):
                diff = x - nums[ii]
                ans += freq[ii].get(diff, 0)
                freq[i][diff] += 1 + freq[ii][diff]
        return ans


    """448. Find All Numbers Disappeared in an Array (Easy)
    Given an array nums of n integers where nums[i] is in the range [1, n],
    return an array of all the integers in the range [1, n] that do not appear
    in nums.

    Example 1:
    Input: nums = [4,3,2,7,8,2,3,1]
    Output: [5,6]

    Example 2:
    Input: nums = [1,1]
    Output: [2]

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= n

    Follow up: Could you do it without extra space and in O(n) runtime? You may
               assume the returned list does not count as extra space."""

    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for x in nums:
            x = abs(x)
            if nums[x-1] > 0: nums[x-1] *= -1
        return [i+1 for i, x in enumerate(nums) if x > 0]


    """450. Delete Node in a BST (Medium)
    Given a root node reference of a BST and a key, delete the node with the
    given key in the BST. Return the root node reference (possibly updated) of
    the BST. Basically, the deletion can be divided into two stages:
    * Search for a node to remove.
    * If the node is found, delete the node.

    Example 1:
    Input: root = [5,3,6,2,4,null,7], key = 3
    Output: [5,4,6,2,null,null,7]
    Explanation: Given key to delete is 3. So we find the node with value 3 and
                 delete it. One valid answer is [5,4,6,2,null,null,7], shown in
                 the above BST. Please notice that another valid answer is
                 [5,2,6,null,4,null,7] and it's also accepted.

    Example 2:
    Input: root = [5,3,6,2,4,null,7], key = 0
    Output: [5,3,6,2,4,null,7]
    Explanation: The tree does not contain a node with value = 0.

    Example 3:
    Input: root = [], key = 0
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * -10^5 <= Node.val <= 10^5
    * Each node has a unique value.
    * root is a valid binary search tree.
    * -10^5 <= key <= 10^5

    Follow up: Could you solve it with time complexity O(height of tree)?"""

    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if root:
            if root.val < key: root.right = self.deleteNode(root.right, key)
            elif root.val == key:
                if not root.left or not root.right: return root.left or root.right
                node = root.right
                while node.left: node = node.left
                root.val = node.val
                root.right = self.deleteNode(root.right, node.val)
            else: root.left = self.deleteNode(root.left, key)
        return root


    """451. Sort Characters By Frequency (Medium)
    Given a string s, sort it in decreasing order based on the frequency of the
    characters. The frequency of a character is the number of times it appears
    in the string. Return the sorted string. If there are multiple answers,
    return any of them.

    Example 1:
    Input: s = "tree"
    Output: "eert"
    Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e'
                 must appear before both 'r' and 't'. Therefore "eetr" is also
                 a valid answer.

    Example 2:
    Input: s = "cccaaa"
    Output: "aaaccc"
    Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and
                 "aaaccc" are valid answers. Note that "cacaca" is incorrect,
                 as the same characters must be together.

    Example 3:
    Input: s = "Aabb"
    Output: "bbAa"
    Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect. Note
                 that 'A' and 'a' are treated as two different characters.

    Constraints:
    * 1 <= s.length <= 5 * 10^5
    * s consists of uppercase and lowercase English letters and digits."""

    def frequencySort(self, s: str) -> str:
        return "".join(ch*x for ch, x in Counter(s).most_common())


    """452. Minimum Number of Arrows to Burst Balloons (Medium)
    There are some spherical balloons taped onto a flat wall that represents
    the XY-plane. The balloons are represented as a 2D integer array points
    where points[i] = [xstart, xend] denotes a balloon whose horizontal
    diameter stretches between xstart and xend. You do not know the exact
    y-coordinates of the balloons. Arrows can be shot up directly vertically
    (in the positive y-direction) from different points along the x-axis. A
    balloon with xstart and xend is burst by an arrow shot at x if
    xstart <= x <= xend. There is no limit to the number of arrows that can be
    shot. A shot arrow keeps traveling up infinitely, bursting any balloons in
    its path. Given the array points, return the minimum number of arrows that
    must be shot to burst all balloons.

    Example 1:
    Input: points = [[10,16],[2,8],[1,6],[7,12]]
    Output: 2
    Explanation: The balloons can be burst by 2 arrows:
                 - Shoot an arrow at x = 6, bursting the balloons [2,8] and
                   [1,6].
                 - Shoot an arrow at x = 11, bursting the balloons [10,16] and
                   [7,12].

    Example 2:
    Input: points = [[1,2],[3,4],[5,6],[7,8]]
    Output: 4
    Explanation: One arrow needs to be shot for each balloon for a total of 4
                 arrows.

    Example 3:
    Input: points = [[1,2],[2,3],[3,4],[4,5]]
    Output: 2
    Explanation: The balloons can be burst by 2 arrows:
                 - Shoot an arrow at x = 2, bursting the balloons [1,2] and
                   [2,3].
                 - Shoot an arrow at x = 4, bursting the balloons [3,4] and
                   [4,5].

    Constraints:
    * 1 <= points.length <= 10^5
    * points[i].length == 2
    * -2^31 <= xstart < xend <= 2^31 - 1"""

    def findMinArrowShots(self, points: List[List[int]]) -> int:
        ans = 0
        prev = -inf
        for x, y in sorted(points, key=lambda x: x[1]):
            if prev < x:
                ans += 1
                prev = y
        return ans


    """454. 4Sum II (Medium)
    Given four integer arrays nums1, nums2, nums3, and nums4 all of length n,
    return the number of tuples (i, j, k, l) such that:
    * 0 <= i, j, k, l < n
    * nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0

    Example 1:
    Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
    Output: 2
    Explanation: The two tuples are:
                 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
                 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0

    Example 2:
    Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
    Output: 1

    Constraints:
    * n == nums1.length
    * n == nums2.length
    * n == nums3.length
    * n == nums4.length
    * 1 <= n <= 200
    * -2^28 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 2^28"""

    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        freq = Counter(x+y for x in nums1 for y in nums2)
        return sum(freq[-x-y] for x in nums3 for y in nums4)


    """456. 132 Pattern (Medium)
    Given an array of n integers nums, a 132 pattern is a subsequence of three
    integers nums[i], nums[j] and nums[k] such that i < j < k and
    nums[i] < nums[k] < nums[j]. Return true if there is a 132 pattern in nums,
    otherwise, return false.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: false
    Explanation: There is no 132 pattern in the sequence.

    Example 2:
    Input: nums = [3,1,4,2]
    Output: true
    Explanation: There is a 132 pattern in the sequence: [1, 4, 2].

    Example 3:
    Input: nums = [-1,3,2,0]
    Output: true
    Explanation: There are three 132 patterns in the sequence: [-1, 3, 2],
                 [-1, 3, 0] and [-1, 2, 0].

    Constraints:
    * n == nums.length
    * 1 <= n <= 2 * 10^5
    * -10^9 <= nums[i] <= 10^9"""

    def find132pattern(self, nums: List[int]) -> bool:
        prev = -inf
        stack = []
        for x in reversed(nums):
            if x < prev: return True
            while stack and stack[-1] < x:
                prev = max(prev, stack.pop())
            stack.append(x)
        return False


    """461. Hamming Distance (Easy)
    The Hamming distance between two integers is the number of positions at
    which the corresponding bits are different. Given two integers x and y,
    return the Hamming distance between them.

    Example 1:
    Input: x = 1, y = 4
    Output: 2
    Explanation: 1   (0 0 0 1)
                 4   (0 1 0 0)
                        ↑   ↑
                 The above arrows point to positions where the corresponding
                 bits are different.

    Example 2:
    Input: x = 3, y = 1
    Output: 1

    Constraints: 0 <= x, y <= 2^31 - 1"""

    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x^y).count("1");


    """462. Minimum Moves to Equal Array Elements II (Medium)
    Given an integer array nums of size n, return the minimum number of moves
    required to make all array elements equal. In one move, you can increment
    or decrement an element of the array by 1.

    Example 1:
    Input: nums = [1,2,3]
    Output: 2
    Explanation: Only two moves are needed (remember each move increments or
                 decrements one element): [1,2,3]  =>  [2,2,3]  =>  [2,2,2]

    Example 2:
    Input: nums = [1,10,2,9]
    Output: 16

    Constraints:
    * n == nums.length
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9"""

    def minMoves2(self, nums: List[int]) -> int:

        def part(lo, hi):
            """Partition array via a random pivot."""
            i, j = lo+1, hi-1
            while i <= j:
                if nums[i] < nums[lo]: i += 1
                elif nums[lo] < nums[j]: j -= 1
                else:
                    nums[i], nums[j] = nums[j], nums[i]
                    i += 1
                    j -= 1
            nums[lo], nums[j] = nums[j], nums[lo]
            return j

        shuffle(nums) # statistical guarantee of O(NlogN)
        lo, hi = 0, len(nums)
        while lo < hi:
            mid = part(lo, hi)
            if mid == len(nums)//2: break
            if mid < len(nums)//2: lo = mid+1
            else: hi = mid
        return sum(abs(x-nums[mid]) for x in nums)


    """463. Island Perimeter (Easy)
    You are given row x col grid representing a map where grid[i][j] = 1
    represents land and grid[i][j] = 0 represents water. Grid cells are
    connected horizontally/vertically (not diagonally). The grid is completely
    surrounded by water, and there is exactly one island (i.e., one or more
    connected land cells). The island doesn't have "lakes", meaning the water
    inside isn't connected to the water around the island. One cell is a square
    with side length 1. The grid is rectangular, width and height don't exceed
    100. Determine the perimeter of the island.

    Example 1:
    Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
    Output: 16
    Explanation: The perimeter is the 16 yellow stripes in the image above.

    Example 2:
    Input: grid = [[1]]
    Output: 4

    Example 3:
    Input: grid = [[1,0]]
    Output: 4

    Constraints:
    * row == grid.length
    * col == grid[i].length
    * 1 <= row, col <= 100
    * grid[i][j] is 0 or 1.
    * There is exactly one island in grid."""

    def islandPerimeter(self, grid: List[List[int]]) -> int:
        ans = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    ans += 4
                    if i and grid[i-1][j]: ans -= 2
                    if j and grid[i][j-1]: ans -= 2
        return ans


    """466. Count The Repetitions (Hard)
    We define str = [s, n] as the string str which consists of the string s
    concatenated n times.
    * For example, str == ["abc", 3] =="abcabcabc".
    We define that string s1 can be obtained from string s2 if we can remove
    some characters from s2 such that it becomes s1.
    * For example, s1 = "abc" can be obtained from s2 = "abdbec" based on our
      definition by removing the bolded underlined characters.
    You are given two strings s1 and s2 and two integers n1 and n2. You have
    the two strings str1 = [s1, n1] and str2 = [s2, n2]. Return the maximum
    integer m such that str = [str2, m] can be obtained from str1.

    Example 1:
    Input: s1 = "acb", n1 = 4, s2 = "ab", n2 = 2
    Output: 2

    Example 2:
    Input: s1 = "acb", n1 = 1, s2 = "acb", n2 = 1
    Output: 1

    Constraints:
    * 1 <= s1.length, s2.length <= 100
    * s1 and s2 consist of lowercase English letters.
    * 1 <= n1, n2 <= 10^6"""

    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        cnt = idx = 0
        count = []
        index = []
        for i in range(n1):
            for ch in s1:
                if ch == s2[idx]:
                    idx += 1
                    if idx == len(s2):
                        cnt += 1
                        idx = 0
            count.append(cnt)
            index.append(idx)
            for ii in range(i):
                if index[ii] == idx:
                    prev = count[ii]
                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))
                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]
                    return (prev + repeat + post) // n2
        return count[-1]//n2


    """469. Convex Polygon (Medium)
    You are given an array of points on the X-Y plane points where
    points[i] = [xi, yi]. The points form a polygon when joined sequentially.
    Return true if this polygon is convex and false otherwise. You may assume
    the polygon formed by given points is always a simple polygon. In other
    words, we ensure that exactly two edges intersect at each vertex and that
    edges otherwise don't intersect each other.

    Example 1:
    Input: points = [[0,0],[0,5],[5,5],[5,0]]
    Output: true

    Example 2:
    Input: points = [[0,0],[0,10],[10,10],[10,0],[5,5]]
    Output: false

    Constraints:
    * 3 <= points.length <= 10^4
    * points[i].length == 2
    * -10^4 <= xi, yi <= 10^4
    * All the given points are unique."""

    def isConvex(self, points: List[List[int]]) -> bool:
        sign = 0
        for i in range(len(points)):
            val = (points[i][0] - points[i-1][0]) * (points[i-1][1] - points[i-2][1]) - (points[i-1][0] - points[i-2][0]) * (points[i][1] - points[i-1][1])
            if sign * val < 0: return False
            if val: sign = val
        return True


    """472. Concatenated Words (Hard)
    Given an array of strings words (without duplicates), return all the
    concatenated words in the given list of words. A concatenated word is
    defined as a string that is comprised entirely of at least two shorter
    words in the given array.

    Example 1:
    Input: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
    Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]
    Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats";
                 "dogcatsdog" can be concatenated by "dog", "cats" and "dog";
                 "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".

    Example 2:
    Input: words = ["cat","dog","catdog"]
    Output: ["catdog"]

    Constraints:
    * 1 <= words.length <= 10^4
    * 0 <= words[i].length <= 1000
    * words[i] consists of only lowercase English letters.
    * 0 <= sum(words[i].length) <= 10^5"""

    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        ans = []
        trie = Trie()
        for word in sorted(words, key=len):
            if word:
                dp = [False]*(len(word) + 1)
                dp[0] = True
                for i in range(len(word)):
                    node = trie.root
                    for ii in range(i, -1, -1):
                        if word[ii] not in node: break
                        node = node[word[ii]]
                        if dp[ii] and node.get('$'):
                            dp[i+1] = True
                            break
                if dp[-1]: ans.append(word)
                trie.insert(word[::-1])
        return ans


    """475. Heaters (Medium)
    Winter is coming! During the contest, your first job is to design a
    standard heater with a fixed warm radius to warm all the houses. Every
    house can be warmed, as long as the house is within the heater's warm
    radius range. Given the positions of houses and heaters on a horizontal
    line, return the minimum radius standard of heaters so that those heaters
    could cover all houses. Notice that all the heaters follow your radius
    standard, and the warm radius will the same.

    Example 1:
    Input: houses = [1,2,3], heaters = [2]
    Output: 1
    Explanation: The only heater was placed in the position 2, and if we use
                 the radius 1 standard, then all the houses can be warmed.

    Example 2:
    Input: houses = [1,2,3,4], heaters = [1,4]
    Output: 1
    Explanation: The two heater was placed in the position 1 and 4. We need to
                 use radius 1 standard, then all the houses can be warmed.

    Example 3:
    Input: houses = [1,5], heaters = [2]
    Output: 3

    Constraints:
    * 1 <= houses.length, heaters.length <= 3 * 10^4
    * 1 <= houses[i], heaters[i] <= 10^9"""

    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        heaters.sort()
        ans = k = 0
        for x in sorted(houses):
            while k < len(heaters) and heaters[k] < x: k += 1
            cand = inf
            if k < len(heaters): cand = min(cand, heaters[k] - x)
            if k: cand = min(cand, x - heaters[k-1])
            ans = max(ans, cand)
        return ans


    """476. Number Complement (Easy)
    The complement of an integer is the integer you get when you flip all the
    0's to 1's and all the 1's to 0's in its binary representation. For example,
    The integer 5 is "101" in binary and its complement is "010" which is the
    integer 2. Given an integer num, return its complement.

    Example 1:
    Input: num = 5
    Output: 2
    Explanation: The binary representation of 5 is 101 (no leading zero bits),
                 and its complement is 010. So you need to output 2.

    Example 2:
    Input: num = 1
    Output: 0
    Explanation: The binary representation of 1 is 1 (no leading zero bits),
                 and its complement is 0. So you need to output 0.

    Constraints: 1 <= num < 2^31

    Note: This question is the same as 1009:
          https://leetcode.com/problems/complement-of-base-10-integer/"""

    def findComplement(self, num: int) -> int:
        n = num.bit_length()
        return num ^ (1<<n) - 1


    """479. Largest Palindrome Product (Hard)
    Given an integer n, return the largest palindromic integer that can be
    represented as the product of two n-digits integers. Since the answer can
    be very large, return it modulo 1337.

    Example 1:
    Input: n = 2
    Output: 987
    Explanation: 99 x 91 = 9009, 9009 % 1337 = 987

    Example 2:
    Input: n = 1
    Output: 9

    Constraints: 1 <= n <= 8"""

    def largestPalindrome(self, n: int) -> int:
        if n == 1: return 9 # edge case
        for z in range(2, 10**n):
            left = 10**n - z
            right = int(str(left)[::-1])
            if z**2 >= 4*right:
                root1 = (z + sqrt(z**2 - 4*right))/2
                root2 = (z - sqrt(z**2 - 4*right))/2
                if root1.is_integer() or root2.is_integer(): return (10**n * left + right) % 1337


    """481. Magical String (Medium)
    A magical string S consists of only '1' and '2' and obeys the following
    rules:
    The string S is magical because concatenating the number of contiguous
    occurrences of characters '1' and '2' generates the string S itself. The
    first few elements of string S is the following: S = "1221121221221121122……"
    If we group the consecutive '1's and '2's in S, it will be:
    1 22 11 2 1 22 1 22 11 2 11 22 ......
    and the occurrences of '1's or '2's in each group are:
    1 2 2 1 1 2 1 2 2 1 2 2 ......
    You can see that the occurrence sequence above is the S itself. Given an
    integer N as input, return the number of '1's in the first N number in the
    magical string S.

    Example 1:
    Input: 6
    Output: 3
    Explanation: The first 6 elements of magical string S is "12211" and it
                 contains three 1's, so return 3.

    Note: N will not exceed 100,000."""

    def magicalString(self, n: int) -> int:
        if n == 0: return 0 # edge case

        S = [1,2,2]
        i = 2
        while len(S) < n:
            S.extend(S[i] * [3 ^ S[-1]])
            i += 1
        return S[:n].count(1)


    """483. Smallest Good Base (Hard)
    Given an integer n represented as a string, return the smallest good base
    of n. We call k >= 2 a good base of n, if all digits of n base k are 1's.

    Example 1:
    Input: n = "13"
    Output: "3"
    Explanation: 13 base 3 is 111.

    Example 2:
    Input: n = "4681"
    Output: "8"
    Explanation: 4681 base 8 is 11111.

    Example 3:
    Input: n = "1000000000000000000"
    Output: "999999999999999999"
    Explanation: 1000000000000000000 base 999999999999999999 is 11.

    Constraints:
    * n is an integer in the range [3, 10^18].
    * n does not contain any leading zeros."""

    def smallestGoodBase(self, n: str) -> str:
        n = int(n)
        for p in range(int(log2(n)), 1, -1):
            k = int(n**(1/p))
            if (k**(p+1)-1)//(k-1) == n: return str(k)
        return str(n-1)


    """484. Find Permutation (Medium)
    A permutation perm of n integers of all the integers in the range [1, n]
    can be represented as a string s of length n - 1 where:
    * s[i] == 'I' if perm[i] < perm[i + 1], and
    * s[i] == 'D' if perm[i] > perm[i + 1].
    Given a string s, reconstruct the lexicographically smallest permutation
    perm and return it.

    Example 1:
    Input: s = "I"
    Output: [1,2]
    Explanation: [1,2] is the only legal permutation that can represented by s,
                 where the number 1 and 2 construct an increasing relationship.

    Example 2:
    Input: s = "DI"
    Output: [2,1,3]
    Explanation: Both [2,1,3] and [3,1,2] can be represented as "DI", but since
                 we want to find the smallest lexicographical permutation, you
                 should return [2,1,3]

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either 'I' or 'D'."""

    def findPermutation(self, s: str) -> List[int]:
        ans, stack = [], []
        for i, ch in enumerate(s + "I"):
            if ch == "D": stack.append(i+1)
            else:
                ans.append(i+1)
                while stack: ans.append(stack.pop())
        return ans


    """485. Max Consecutive Ones (Easy)
    Given a binary array nums, return the maximum number of consecutive 1's in
    the array.

    Example 1:
    Input: nums = [1,1,0,1,1,1]
    Output: 3
    Explanation: The first two digits or the last three digits are consecutive
                 1s. The maximum number of consecutive 1s is 3.

    Example 2:
    Input: nums = [1,0,1,1,0,1]
    Output: 2

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1."""

    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        ans = cnt = 0
        for x in nums:
            if x: cnt += 1
            else: cnt = 0
            ans = max(ans, cnt)
        return ans


    """487. Max Consecutive Ones II (Medium)
    Given a binary array, find the maximum number of consecutive 1s in this
    array if you can flip at most one 0.

    Example 1:
    Input: [1,0,1,1,0]
    Output: 4
    Explanation: Flip the first zero will get the the maximum number of
                 consecutive 1s. After flipping, the maximum number of
                 consecutive 1s is 4.

    Note:
    * The input array will only contain 0 and 1.
    * The length of input array is a positive integer and will not exceed 10,000

    Follow up: What if the input numbers come in one by one as an infinite
               stream? In other words, you can't store all numbers coming from
               the stream as it's too large to hold in memory. Could you solve
               it efficiently?"""

    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        ans = curr = 0
        prev = -1
        for x in nums:
            if x == 0: prev, curr = curr, 0
            else: curr += 1
            ans = max(ans, prev + 1 + curr)
        return ans


    """488. Zuma Game (Hard)
    You are playing a variation of the game Zuma. In this variation of Zuma,
    there is a single row of colored balls on a board, where each ball can be
    colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also
    have several colored balls in your hand. Your goal is to clear all of the
    balls from the board. On each turn:
    * Pick any ball from your hand and insert it in between two balls in the
      row or on either end of the row.
    * If there is a group of three or more consecutive balls of the same color,
      remove the group of balls from the board.
      + If this removal causes more groups of three or more of the same color
        to form, then continue removing each group until there are none left.
    * If there are no more balls on the board, then you win the game.
    * Repeat this process until you either win or do not have any more balls in
      your hand.
    Given a string board, representing the row of balls on the board, and a
    string hand, representing the balls in your hand, return the minimum number
    of balls you have to insert to clear all the balls from the board. If you
    cannot clear all the balls from the board using the balls in your hand,
    return -1.

    Example 1:
    Input: board = "WRRBBW", hand = "RB"
    Output: -1
    Explanation: It is impossible to clear all the balls. The best you can do
                 is:
                 - Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.
                 - Insert 'B' so the board becomes WBBBW. WBBBW -> WW.
                 There are still balls remaining on the board, and you are out
                 of balls to insert.

    Example 2:
    Input: board = "WWRRBBWW", hand = "WRBRW"
    Output: 2
    Explanation: To make the board empty:
                 - Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW ->
                   WWBBWW.
                 - Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW ->
                   empty.
                 2 balls from your hand were needed to clear the board.

    Example 3:
    Input: board = "G", hand = "GGGGG"
    Output: 2
    Explanation: To make the board empty:
                 - Insert 'G' so the board becomes GG.
                 - Insert 'G' so the board becomes GGG. GGG -> empty.
                 2 balls from your hand were needed to clear the board.

    Constraints:
    * 1 <= board.length <= 16
    * 1 <= hand.length <= 5
    * board and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.
    * The initial row of balls on the board will not have any groups of three
      or more consecutive balls of the same color."""

    def findMinStep(self, board: str, hand: str) -> int:
        hand = ''.join(sorted(hand))

        @cache
        def fn(board, hand):
            """Return min number of balls to insert."""
            if not board: return 0
            if not hand: return inf
            ans = inf
            for i, ch in enumerate(hand):
                if i == 0 or hand[i-1] != ch: # pruning 1
                    hh = hand[:i] + hand[i+1:]
                    for j in range(0, len(board)):
                        if ch == board[j] or j and board[j-1] == board[j]: # pruning 2
                            bb, nn = "", board[:j] + ch + board[j:]
                            while bb != nn:
                                bb, nn = nn, ""
                                for k, grp in groupby(bb):
                                    x = len(list(grp))
                                    if x < 3: nn += k*x
                            ans = min(ans, 1 + fn(bb, hh))
            return ans

        return (lambda x: x if x < inf else -1)(fn(board, hand))


    """490. The Maze (Medium)
    There is a ball in a maze with empty spaces (represented as 0) and walls
    (represented as 1). The ball can go through the empty spaces by rolling up,
    down, left or right, but it won't stop rolling until hitting a wall. When
    the ball stops, it could choose the next direction. Given the m x n maze,
    the ball's start position and the destination, where
    start = [startrow, startcol] and
    destination = [destinationrow, destinationcol], return true if the ball can
    stop at the destination, otherwise return false. You may assume that the
    borders of the maze are all walls (see examples).

    Example 1:
    Input: maze = [[0,0,1,0,0],
                   [0,0,0,0,0],
                   [0,0,0,1,0],
                   [1,1,0,1,1],
                   [0,0,0,0,0]], start = [0,4], destination = [4,4]
    Output: true
    Explanation: One possible way is : left -> down -> left -> down -> right ->
                 down -> right.

    Example 2:
    Input: maze = [[0,0,1,0,0],
                   [0,0,0,0,0],
                   [0,0,0,1,0],
                   [1,1,0,1,1],
                   [0,0,0,0,0]], start = [0,4], destination = [3,2]
    Output: false
    Explanation: There is no way for the ball to stop at the destination.
                 Notice that you can pass through the destination but you
                 cannot stop there.

    Example 3:
    Input: maze = [[0,0,0,0,0],
                   [1,1,0,0,1],
                   [0,0,0,0,0],
                   [0,1,0,0,1],
                   [0,1,0,0,0]], start = [4,3], destination = [0,1]
    Output: false

    Constraints:
    * m == maze.length
    * n == maze[i].length
    * 1 <= m, n <= 100
    * maze[i][j] is 0 or 1.
    * start.length == 2
    * destination.length == 2
    * 0 <= startrow, destinationrow <= m
    * 0 <= startcol, destinationcol <= n
    * Both the ball and the destination exist in an empty space, and they will
      not be in the same position initially.
    * The maze contains at least 2 empty spaces."""

    def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -> bool:
        m, n = len(maze), len(maze[0])

        stack = [start]
        seen = {tuple(start)}
        while stack:
            i, j = stack.pop()
            if [i, j] == destination: return True
            for di, dj in (-1, 0), (0, -1), (0, 1), (1, 0):
                ii, jj = i, j
                while 0 <= ii+di < m and 0 <= jj+dj < n and maze[ii+di][jj+dj] == 0:
                    ii += di
                    jj += dj
                if (ii, jj) not in seen:
                    stack.append((ii, jj))
                    seen.add((ii, jj))
        return False


    """496. Next Greater Element I (Easy)
    The next greater element of some element x in an array is the first greater
    element that is to the right of x in the same array. You are given two
    distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset
    of nums2. For each 0 <= i < nums1.length, find the index j such that
    nums1[i] == nums2[j] and determine the next greater element of nums2[j] in
    nums2. If there is no next greater element, then the answer for this query
    is -1. Return an array ans of length nums1.length such that ans[i] is the
    next greater element as described above.

    Example 1:
    Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
    Output: [-1,3,-1]
    Explanation: The next greater element for each value of nums1 is as follows:
                 - 4 is underlined in nums2 = [1,3,4,2]. There is no next
                   greater element, so the answer is -1.
                 - 1 is underlined in nums2 = [1,3,4,2]. The next greater
                   element is 3.
                 - 2 is underlined in nums2 = [1,3,4,2]. There is no next
                   greater element, so the answer is -1.

    Example 2:
    Input: nums1 = [2,4], nums2 = [1,2,3,4]
    Output: [3,-1]
    Explanation: The next greater element for each value of nums1 is as follows:
                 - 2 is underlined in nums2 = [1,2,3,4]. The next greater
                   element is 3.
                 - 4 is underlined in nums2 = [1,2,3,4]. There is no next
                   greater element, so the answer is -1.

    Constraints:
    * 1 <= nums1.length <= nums2.length <= 1000
    * 0 <= nums1[i], nums2[i] <= 10^4
    * All integers in nums1 and nums2 are unique.
    * All the integers of nums1 also appear in nums2.

    Follow up: Could you find an O(nums1.length + nums2.length) solution?"""

    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        mp = {}
        stack = []
        for x in nums2:
            while stack and stack[-1] < x: mp[stack.pop()] = x
            stack.append(x)
        return [mp.get(x, -1) for x in nums1]


    """502. IPO (Hard)
    Suppose LeetCode will start its IPO soon. In order to sell a good price of
    its shares to Venture Capital, LeetCode would like to work on some projects
    to increase its capital before the IPO. Since it has limited resources, it
    can only finish at most k distinct projects before the IPO. Help LeetCode
    design the best way to maximize its total capital after finishing at most k
    distinct projects. You are given n projects where the ith project has a
    pure profit profits[i] and a minimum capital of capital[i] is needed to
    start it. Initially, you have w capital. When you finish a project, you
    will obtain its pure profit and the profit will be added to your total
    capital. Pick a list of at most k distinct projects from given projects to
    maximize your final capital, and return the final maximized capital. The
    answer is guaranteed to fit in a 32-bit signed integer.

    Example 1:
    Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
    Output: 4
    Explanation: Since your initial capital is 0, you can only start the
                 project indexed 0. After finishing it you will obtain profit 1
                 and your capital becomes 1. With capital 1, you can either
                 start the project indexed 1 or the project indexed 2. Since
                 you can choose at most 2 projects, you need to finish the
                 project indexed 2 to get the maximum capital. Therefore,
                 output the final maximized capital, which is 0 + 1 + 3 = 4.

    Example 2:
    Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
    Output: 6

    Constraints:
    * 1 <= k <= 10^5
    * 0 <= w <= 10^9
    * n == profits.length
    * n == capital.length
    * 1 <= n <= 10^5
    * 0 <= profits[i] <= 10^4
    * 0 <= capital[i] <= 10^9"""

    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        capital, profits = zip(*sorted(zip(capital, profits)))
        i = 0
        pq = []
        for _ in range(k):
            while i < len(capital) and capital[i] <= w:
                heappush(pq, -profits[i])
                i += 1
            if pq: w -= heappop(pq)
        return w


    """505. The Maze II (Medium)
    There is a ball in a maze with empty spaces (represented as 0) and walls
    (represented as 1). The ball can go through the empty spaces by rolling up,
    down, left or right, but it won't stop rolling until hitting a wall. When
    the ball stops, it could choose the next direction. Given the m x n maze,
    the ball's start position and the destination, where
    start = [startrow, startcol] and
    destination = [destinationrow, destinationcol], return the shortest
    distance for the ball to stop at the destination. If the ball cannot stop
    at destination, return -1. The distance is the number of empty spaces
    traveled by the ball from the start position (excluded) to the destination
    (included). You may assume that the borders of the maze are all walls (see
    examples).

    Example 1:
    Input: maze = [[0,0,1,0,0],
                   [0,0,0,0,0],
                   [0,0,0,1,0],
                   [1,1,0,1,1],
                   [0,0,0,0,0]], start = [0,4], destination = [4,4]
    Output: 12
    Explanation: One possible way is : left -> down -> left -> down -> right ->
                 down -> right. The length of the path is
                 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.

    Example 2:
    Input: maze = [[0,0,1,0,0],
                   [0,0,0,0,0],
                   [0,0,0,1,0],
                   [1,1,0,1,1],
                   [0,0,0,0,0]], start = [0,4], destination = [3,2]
    Output: -1
    Explanation: There is no way for the ball to stop at the destination.
                 Notice that you can pass through the destination but you
                 cannot stop there.

    Example 3:
    Input: maze = [[0,0,0,0,0],
                   [1,1,0,0,1],
                   [0,0,0,0,0],
                   [0,1,0,0,1],
                   [0,1,0,0,0]], start = [4,3], destination = [0,1]
    Output: -1

    Constraints:
    * m == maze.length
    * n == maze[i].length
    * 1 <= m, n <= 100
    * maze[i][j] is 0 or 1.
    * start.length == 2
    * destination.length == 2
    * 0 <= startrow, destinationrow <= m
    * 0 <= startcol, destinationcol <= n
    * Both the ball and the destination exist in an empty space, and they will
      not be in the same position initially.
    * The maze contains at least 2 empty spaces."""

    def shortestDistance(self, maze: List[List[int]], start: List[int], destination: List[int]) -> int:
        m, n = len(maze), len(maze[0])
        pq = [(0, start[0], start[1])] # min-heap
        dist = defaultdict(lambda: inf, {tuple(start): 0})
        while pq:
            x, i, j = heappop(pq)
            if [i, j] == destination: return x
            for di, dj in (-1, 0), (0, -1), (0, 1), (1, 0):
                ii, jj = i, j
                while 0 <= ii+di < m and 0 <= jj+dj < n and maze[ii+di][jj+dj] == 0:
                    ii += di
                    jj += dj
                xx = x + abs(ii - i) + abs(jj - j)
                if xx < dist[ii, jj]:
                    heappush(pq, (xx, ii, jj))
                    dist[ii, jj] = xx
        return -1


    """506. Relative Ranks (Easy)
    You are given an integer array score of size n, where score[i] is the score
    of the ith athlete in a competition. All the scores are guaranteed to be
    unique. The athletes are placed based on their scores, where the 1st place
    athlete has the highest score, the 2nd place athlete has the 2nd highest
    score, and so on. The placement of each athlete determines their rank:
    * The 1st place athlete's rank is "Gold Medal".
    * The 2nd place athlete's rank is "Silver Medal".
    * The 3rd place athlete's rank is "Bronze Medal".
    * For the 4th place to the nth place athlete, their rank is their placement
      number (i.e., the xth place athlete's rank is "x").
    Return an array answer of size n where answer[i] is the rank of the ith
    athlete.

    Example 1:
    Input: score = [5,4,3,2,1]
    Output: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
    Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].

    Example 2:
    Input: score = [10,3,8,9,4]
    Output: ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
    Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].

    Constraints:
    * n == score.length
    * 1 <= n <= 10^4
    * 0 <= score[i] <= 10^6
    * All the values in score are unique."""

    def findRelativeRanks(self, score: List[int]) -> List[str]:
        ans = [-1]*len(score)
        for i, x in enumerate(sorted(range(len(score)), key=score.__getitem__, reverse=True)):
            if i <= 2: ans[x] = ["Gold Medal", "Silver Medal", "Bronze Medal"][i]
            else: ans[x] = str(i+1)
        return ans


    """507. Perfect Number (Easy)
    A perfect number is a positive integer that is equal to the sum of its
    positive divisors, excluding the number itself. A divisor of an integer x
    is an integer that can divide x evenly. Given an integer n, return true if
    n is a perfect number, otherwise return false.

    Example 1:
    Input: num = 28
    Output: true
    Explanation: 28 = 1 + 2 + 4 + 7 + 14
                 1, 2, 4, 7, and 14 are all divisors of 28.

    Example 2:
    Input: num = 7
    Output: false

    Constraints: 1 <= num <= 10^8"""

    def checkPerfectNumber(self, num: int) -> bool:
        """Euclid-Euler theorem
        An even number is perfect iff it is of form 2^(p−1)(2^p − 1), where
        2^p − 1 is a Mersenne prime. The only perfect numbers no larger than
        10^8 are 6, 28, 496, 8128, 33550336.
        """
        for p in 2,3,5,7,13:
            if (1<<p-1)*((1<<p) - 1) == num: return True
        return False


    """509. Fibonacci Number (Easy)
    The Fibonacci numbers, commonly denoted F(n) form a sequence, called the
    Fibonacci sequence, such that each number is the sum of the two preceding
    ones, starting from 0 and 1. That is,
    * F(0) = 0, F(1) = 1
    * F(n) = F(n - 1) + F(n - 2), for n > 1.
    Given n, calculate F(n).

    Example 1:
    Input: n = 2
    Output: 1
    Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.

    Example 2:
    Input: n = 3
    Output: 2
    Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.

    Example 3:
    Input: n = 4
    Output: 3
    Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.

    Constraints: 0 <= n <= 30"""

    def fib(self, n: int) -> int:

        def fn(n):
            """Return nth and (n+1)st Fibonacci numbers via "fast doubling method"."""
            if n == 0: return [0, 1]
            x, y = fn(n >> 1)
            xx = x * (2* y - x)
            yy = x*x + y*y
            return [yy, xx+yy] if n&1 else [xx, yy]

        return fn(n)[0]


    """510. Inorder Successor in BST II (Medium)
    Given a node in a binary search tree, find the in-order successor of that
    node in the BST. If that node has no in-order successor, return null. The
    successor of a node is the node with the smallest key greater than node.val.
    You will have direct access to the node but not to the root of the tree.
    Each node will have a reference to its parent node. Below is the definition
    for Node:

    class Node {
        public int val;
        public Node left;
        public Node right;
        public Node parent;
    }
    Follow up: Could you solve it without looking up any of the node's values?

    Example 1:
    Input: tree = [2,1,3], node = 1
    Output: 2
    Explanation: 1's in-order successor node is 2. Note that both the node and
                 the return value is of Node type.

    Example 2:
    Input: tree = [5,3,6,2,4,null,null,1], node = 6
    Output: null
    Explanation: There is no in-order successor of the current node, so the
                 answer is null.

    Example 3:
    Input: tree = [15,6,18,3,7,17,20,2,4,null,13,null,null,null,null,null,null,null,null,9], node = 15
    Output: 17

    Example 4:
    Input: tree = [15,6,18,3,7,17,20,2,4,null,13,null,null,null,null,null,null,null,null,9], node = 13
    Output: 15

    Example 5:
    Input: tree = [0], node = 0
    Output: null

    Constraints:
    * -10^5 <= Node.val <= 10^5
    * 1 <= Number of Nodes <= 10^4
    * All Nodes will have unique values."""

    def inorderSuccessor(self, node: 'Node') -> 'Node':
        if node.right:
            node = node.right
            while node.left: node = node.left
            return node

        while node.parent:
            if node == node.parent.left: return node.parent
            node = node.parent


    """513. Find Bottom Left Tree Value (Medium)
    Given the root of a binary tree, return the leftmost value in the last row
    of the tree.

    Example 1:
    Input: root = [2,1,3]

          2
         / \
        1   3

    Output: 1

    Example 2:
    Input: root = [1,2,3,4,null,5,6,null,null,7]

            1
           / \
          2   3
         /   / \
        4   5   6
           /
          7

    Output: 7

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -2^31 <= Node.val <= 2^31 - 1"""

    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        queue = deque([root])
        while queue:
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.right: queue.append(node.right)
                if node.left: queue.append(node.left)
        return node.val


    """514. Freedom Trail (Hard)
    In the video game Fallout 4, the quest "Road to Freedom" requires players
    to reach a metal dial called the "Freedom Trail Ring" and use the dial to
    spell a specific keyword to open the door. Given a string ring that
    represents the code engraved on the outer ring and another string key that
    represents the keyword that needs to be spelled, return the minimum number
    of steps to spell all the characters in the keyword. Initially, the first
    character of the ring is aligned at the "12:00" direction. You should spell
    all the characters in key one by one by rotating ring clockwise or
    anticlockwise to make each character of the string key aligned at the
    "12:00" direction and then by pressing the center button. At the stage of
    rotating the ring to spell the key character key[i]:
    * You can rotate the ring clockwise or anticlockwise by one place, which
      counts as one step. The final purpose of the rotation is to align one of
      ring's characters at the "12:00" direction, where this character must
      equal key[i].
    * If the character key[i] has been aligned at the "12:00" direction, press
      the center button to spell, which also counts as one step. After the
      pressing, you could begin to spell the next character in the key (next
      stage). Otherwise, you have finished all the spelling.

    Example 1:
    Input: ring = "godding", key = "gd"
    Output: 4
    Explanation: For the first key character 'g', since it is already in place,
                 we just need 1 step to spell this character. For the second
                 key character 'd', we need to rotate the ring "godding"
                 anticlockwise by two steps to make it become "ddinggo". Also,
                 we need 1 more step for spelling. So the final output is 4.

    Example 2:
    Input: ring = "godding", key = "godding"
    Output: 13

    Constraints:
    * 1 <= ring.length, key.length <= 100
    * ring and key consist of only lower case English letters.
    * It is guaranteed that key could always be spelled by rotating ring."""

    def findRotateSteps(self, ring: str, key: str) -> int:
        locs = {}
        for i, ch in enumerate(ring): locs.setdefault(ch, []).append(i)

        @cache
        def fn(i, j):
            """Return turns to finish key[j:] startin from ith position on ring."""
            if j == len(key): return 0
            loc = locs[key[j]]
            k = bisect_left(loc, i) % len(loc)
            ans = min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1)
            k = (k-1) % len(loc)
            ans = min(ans, min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1))
            return ans

        return fn(0, 0) + len(key)


    """515. Find Largest Value in Each Tree Row (Medium)
    Given the root of a binary tree, return an array of the largest value in
    each row of the tree (0-indexed).

    Example 1:
    Input: root = [1,3,2,5,3,null,9]
    Output: [1,3,9]

    Example 2:
    Input: root = [1,2,3]
    Output: [1,3]

    Example 3:
    Input: root = [1]
    Output: [1]

    Example 4:
    Input: root = [1,null,2]
    Output: [1,2]

    Example 5:
    Input: root = []
    Output: []

    Constraints:
    * The number of nodes in the tree will be in the range [0, 10^4].
    * -2^31 <= Node.val <= 2^31 - 1"""

    def largestValues(self, root: TreeNode) -> List[int]:
        if not root: return [] # edge case

        ans = []
        stack = [(root, 0)]
        while stack:
            node, i = stack.pop()
            if i == len(ans): ans.append(node.val)
            else: ans[i] = max(ans[i], node.val)
            if node.left: stack.append((node.left, i+1))
            if node.right: stack.append((node.right, i+1))
        return ans


    """516. Longest Palindromic Subsequence (Medium)
    Given a string s, find the longest palindromic subsequence's length in s.
    You may assume that the maximum length of s is 1000.

    Example 1:
    Input: "bbbab"
    Output: 4
    One possible longest palindromic subsequence is "bbbb".

    Example 2:
    Input: "cbbd"
    Output: 2
    One possible longest palindromic subsequence is "bb".

    Constraints:
    * 1 <= s.length <= 1000
    * s consists only of lowercase English letters."""

    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        dp = [[0]*n for _ in range(n)]
        for i in reversed(range(n)):
            dp[i][i] = 1
            for j in range(i+1, n):
                if s[i] == s[j]: dp[i][j] = 2 + dp[i+1][j-1]
                else: dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return dp[0][-1]


    """517. Super Washing Machines (Hard)
    You have n super washing machines on a line. Initially, each washing
    machine has some dresses or is empty. For each move, you could choose any m
    (1 <= m <= n) washing machines, and pass one dress of each washing machine
    to one of its adjacent washing machines at the same time. Given an integer
    array machines representing the number of dresses in each washing machine
    from left to right on the line, return the minimum number of moves to make
    all the washing machines have the same number of dresses. If it is not
    possible to do it, return -1.

    Example 1:
    Input: machines = [1,0,5]
    Output: 3
    Explanation: 1st move:    1     0 <-- 5    =>    1     1     4
                 2nd move:    1 <-- 1 <-- 4    =>    2     1     3
                 3rd move:    2     1 <-- 3    =>    2     2     2

    Example 2:
    Input: machines = [0,3,0]
    Output: 2
    Explanation: 1st move:    0 <-- 3     0    =>    1     2     0
                 2nd move:    1     2 --> 0    =>    1     1     1

    Example 3:
    Input: machines = [0,2,0]
    Output: -1
    Explanation: It's impossible to make all three washing machines have the
                 same number of dresses.

    Constraints:
    * n == machines.length
    * 1 <= n <= 10^4
    * 0 <= machines[i] <= 10^5"""

    def findMinMoves(self, machines: List[int]) -> int:
        total = sum(machines)
        if total % len(machines): return -1 # impossible
        avg = total // len(machines)

        ans = prefix = 0
        for i, x in enumerate(machines):
            ans = max(ans, abs(prefix), x - avg)
            prefix += x - avg
        return ans


    """518. Coin Change 2 (Medium)
    You are given coins of different denominations and a total amount of money.
    Write a function to compute the number of combinations that make up that
    amount. You may assume that you have infinite number of each kind of coin.

    Example 1:
    Input: amount = 5, coins = [1, 2, 5]
    Output: 4
    Explanation: there are four ways to make up the amount:
    5=5
    5=2+2+1
    5=2+1+1+1
    5=1+1+1+1+1

    Example 2:
    Input: amount = 3, coins = [2]
    Output: 0
    Explanation: the amount of 3 cannot be made up just with coins of 2.

    Example 3:
    Input: amount = 10, coins = [10]
    Output: 1

    Note that you can assume that:
    * 0 <= amount <= 5000
    * 1 <= coin <= 5000
    * the number of coins is less than 500
    * the answer is guaranteed to fit into signed 32-bit integer"""

    def change(self, amount: int, coins: List[int]) -> int:
        dp = [1] + [0]*amount
        for coin in coins:
            for x in range(amount-coin+1):
                dp[x+coin] += dp[x]
        return dp[-1]


    """520. Detect Capital (Easy)
    We define the usage of capitals in a word to be right when one of the
    following cases holds:
    * All letters in this word are capitals, like "USA".
    * All letters in this word are not capitals, like "leetcode".
    * Only the first letter in this word is capital, like "Google".
    Given a string word, return true if the usage of capitals in it is right.

    Example 1:
    Input: word = "USA"
    Output: true

    Example 2:
    Input: word = "FlaG"
    Output: false

    Constraints:
    * 1 <= word.length <= 100
    * word consists of lowercase and uppercase English letters."""

    def detectCapitalUse(self, word: str) -> bool:
        return word.isupper() or word.islower() or word.istitle()


    """522. Longest Uncommon Subsequence II (Medium)
    Given a list of strings, you need to find the longest uncommon subsequence
    among them. The longest uncommon subsequence is defined as the longest
    subsequence of one of these strings and this subsequence should not be any
    subsequence of the other strings. A subsequence is a sequence that can be
    derived from one sequence by deleting some characters without changing the
    order of the remaining elements. Trivially, any string is a subsequence of
    itself and an empty string is a subsequence of any string. The input will
    be a list of strings, and the output needs to be the length of the longest
    uncommon subsequence. If the longest uncommon subsequence doesn't exist,
    return -1.

    Example 1:
    Input: "aba", "cdc", "eae"
    Output: 3

    Note:
    * All the given strings' lengths will not exceed 10.
    * The length of the given list will be in the range of [2, 50]."""

    def findLUSlength(self, strs: List[str]) -> int:

        def fn(p, s):
            """Return True if p is a subsequence of s."""
            ss = iter(s)
            return all(ch in ss for ch in p)

        ans = -1
        for i, s in enumerate(strs):
            for ii in range(len(strs)):
                if i != ii and len(s) <= len(strs[ii]) and fn(s, strs[ii]): break
            else: ans = max(ans, len(s))
        return ans


    """523. Continuous Subarray Sum (Medium)
    Given a list of non-negative numbers and a target integer k, write a
    function to check if the array has a continuous subarray of size at least 2
    that sums up to a multiple of k, that is, sums up to n*k where n is also an
    integer.

    Example 1:
    Input: [23, 2, 4, 6, 7],  k=6
    Output: True
    Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.

    Example 2:
    Input: [23, 2, 6, 4, 7],  k=6
    Output: True
    Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.

    Constraints:
    * The length of the array won't exceed 10,000.
    * You may assume the sum of all the numbers is in the range of a signed 32-bit integer."""

    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        seen = set()
        prefix = prev = 0
        for x in nums:
            prefix = (prefix + x) % k
            if prefix in seen: return True
            seen.add(prev)
            prev = prefix
        return False


    """524. Longest Word in Dictionary through Deleting (Medium)
    Given a string and a string dictionary, find the longest string in the
    dictionary that can be formed by deleting some characters of the given
    string. If there are more than one possible results, return the longest
    word with the smallest lexicographical order. If there is no possible
    result, return the empty string.

    Example 1:
    Input:
    s = "abpcplea", d = ["ale","apple","monkey","plea"]
    Output: "apple"

    Example 2:
    Input:
    s = "abpcplea", d = ["a","b","c"]
    Output: "a"

    Note:
    * All the strings in the input will only contain lower-case letters.
    * The size of the dictionary won't exceed 1,000.
    * The length of all the strings in the input won't exceed 1,000."""

    def findLongestWord(self, s: str, d: List[str]) -> str:
        for word in sorted(d, key=lambda x: (-len(x), x)):
            it = iter(s)
            if all(c in it for c in word): return word
        return ""


    """525. Contiguous Array (Medium)
    Given a binary array, find the maximum length of a contiguous subarray
    with equal number of 0 and 1.

    Example 1:
    Input: [0,1]
    Output: 2
    Explanation: [0, 1] is the longest contiguous subarray with equal number of
                 0 and 1.

    Example 2:
    Input: [0,1,0]
    Output: 2
    Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal
                 number of 0 and 1.

    Note: The length of the given binary array will not exceed 50,000."""

    def findMaxLength(self, nums: List[int]) -> int:
        seen = {0: -1}
        ans = prefix = 0
        for i, x in enumerate(nums):
            prefix += 2*x-1
            ans = max(ans, i - seen.setdefault(prefix, i))
        return ans


    """526. Beautiful Arrangement (Medium)
    Suppose you have N integers from 1 to N. We define a beautiful arrangement
    as an array that is constructed by these N numbers successfully if one of
    the following is true for the ith position (1 <= i <= N) in this array:
    * The number at the ith position is divisible by i.
    * i is divisible by the number at the ith position.
    Now given N, how many beautiful arrangements can you construct?

    Example 1:
    Input: 2
    Output: 2

    Explanation:
    The first beautiful arrangement is [1, 2]:
    Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).
    Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).
    The second beautiful arrangement is [2, 1]:
    Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).
    Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.

    Note: N is a positive integer and will not exceed 15."""

    def countArrangement(self, N: int) -> int:

        def fn(i):
            """Return the number of beautiful arrangements of N numbers."""
            if i == 0: return 1 # boundary condition
            ans = 0
            for k in range(1, N+1):
                if k not in seen and (k%i == 0 or i%k == 0):
                    seen.add(k)
                    ans += fn(i-1)
                    seen.remove(k)
            return ans

        seen = set()
        return fn(N)


    """529. Minesweeper (Medium)
    Let's play the minesweeper game (Wikipedia, online game)! You are given a
    2D char matrix representing the game board. 'M' represents an unrevealed
    mine, 'E' represents an unrevealed empty square, 'B' represents a revealed
    blank square that has no adjacent (above, below, left, right, and all 4
    diagonals) mines, digit ('1' to '8') represents how many mines are adjacent
    to this revealed square, and finally 'X' represents a revealed mine. Now
    given the next click position (row and column indices) among all the
    unrevealed squares ('M' or 'E'), return the board after revealing this
    position according to the following rules:

    * If a mine ('M') is revealed, then the game is over - change it to 'X'.
    * If an empty square ('E') with no adjacent mines is revealed, then change
      it to revealed blank ('B') and all of its adjacent unrevealed squares
      should be revealed recursively.
    * If an empty square ('E') with at least one adjacent mine is revealed,
      then change it to a digit ('1' to '8') representing the number of
      adjacent mines.
    * Return the board when no more squares will be revealed.

    Example 1:
    Input: [['E', 'E', 'E', 'E', 'E'],
            ['E', 'E', 'M', 'E', 'E'],
            ['E', 'E', 'E', 'E', 'E'],
            ['E', 'E', 'E', 'E', 'E']]
    Click : [3,0]
    Output:[['B', '1', 'E', '1', 'B'],
            ['B', '1', 'M', '1', 'B'],
            ['B', '1', '1', '1', 'B'],
            ['B', 'B', 'B', 'B', 'B']]

    Example 2:
    Input: [['B', '1', 'E', '1', 'B'],
            ['B', '1', 'M', '1', 'B'],
            ['B', '1', '1', '1', 'B'],
            ['B', 'B', 'B', 'B', 'B']]
    Click : [1,2]
    Output:[['B', '1', 'E', '1', 'B'],
            ['B', '1', 'X', '1', 'B'],
            ['B', '1', '1', '1', 'B'],
            ['B', 'B', 'B', 'B', 'B']]

    Note:
    * The range of the input matrix's height and width is [1,50].
    * The click position will only be an unrevealed square ('M' or 'E'), which
      also means the input board contains at least one clickable square.
    * The input board won't be a stage when game is over (some mines have been
      revealed).
    * For simplicity, not mentioned rules should be ignored in this problem.
      For example, you don't need to reveal all the unrevealed mines when the
      game is over, consider any cases that you will win the game or flag any squares."""

    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        m, n = len(board), len(board[0]) # dimensions
        i, j = click
        if board[i][j] == "M": board[i][j] = "X"
        elif board[i][j] == "E":
            stack = [(i, j)]
            while stack:
                i, j = stack.pop()
                cnt = 0
                for ii, jj in product(range(i-1, i+2), range(j-1, j+2)):
                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) != (i, j) and board[ii][jj] == "M": cnt += 1
                if cnt: board[i][j] = str(cnt)
                else:
                    board[i][j] = "B"
                    for ii, jj in product(range(i-1, i+2), range(j-1, j+2)):
                        if 0 <= ii < m and 0 <= jj < n and (ii, jj) != (i, j) and board[ii][jj] == "E": stack.append((ii, jj))
        return board


    """531. Lonely Pixel I (Medium)
    Given an m x n picture consisting of black 'B' and white 'W' pixels, return
    the number of black lonely pixels. A black lonely pixel is a character 'B'
    that located at a specific position where the same row and same column
    don't have any other black pixels.

    Example 1:
    Input: picture = [["W","W","B"],["W","B","W"],["B","W","W"]]
    Output: 3
    Explanation: All the three 'B's are black lonely pixels.

    Example 2:
    Input: picture = [["B","B","B"],["B","B","W"],["B","B","B"]]
    Output: 0

    Constraints:
    * m == picture.length
    * n == picture[i].length
    * 1 <= m, n <= 500
    * picture[i][j] is 'W' or 'B'."""

    def findLonelyPixel(self, picture: List[List[str]]) -> int:
        m, n = len(picture), len(picture[0])
        rows = [0] * m
        cols = [0] * n
        for i in range(m):
            for j in range(n):
                if picture[i][j] == "B":
                    rows[i] += 1
                    cols[j] += 1

        ans = 0
        for i in range(m):
            if rows[i] == 1:
                for j in range(n):
                    if picture[i][j] == "B" and cols[j] == 1: ans += 1
        return ans


    """532. K-diff Pairs in an Array (Medium)
    Given an array of integers nums and an integer k, return the number of
    unique k-diff pairs in the array. A k-diff pair is an integer pair
    (nums[i], nums[j]), where the following are true:
    * 0 <= i, j < nums.length
    * i != j
    * a <= b
    * b - a == k

    Example 1:
    Input: nums = [3,1,4,1,5], k = 2
    Output: 2
    Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
    Although we have two 1s in the input, we should only return the number of unique pairs.

    Example 2:
    Input: nums = [1,2,3,4,5], k = 1
    Output: 4
    Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).

    Example 3:
    Input: nums = [1,3,1,5,4], k = 0
    Output: 1
    Explanation: There is one 0-diff pair in the array, (1, 1).

    Example 4:
    Input: nums = [1,2,4,4,3,3,0,9,2,3], k = 3
    Output: 2

    Example 5:
    Input: nums = [-1,-2,-3], k = 1
    Output: 2

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^7 <= nums[i] <= 10^7
    * 0 <= k <= 10^7"""

    def findPairs(self, nums: List[int], k: int) -> int:
        freq = Counter(nums)
        return sum(k == 0 and v > 1 or k and x-k in freq for x, v in freq.items())


    """533. Lonely Pixel II (Medium)
    Given an m x n picture consisting of black 'B' and white 'W' pixels and an
    integer target, return the number of black lonely pixels. A black lonely
    pixel is a character 'B' that located at a specific position (r, c) where:
    * Row r and column c both contain exactly target black pixels.
    * For all rows that have a black pixel at column c, they should be exactly
      the same as row r.

    Example 1:
    Input: picture = [["W","B","W","B","B","W"],
                      ["W","B","W","B","B","W"],
                      ["W","B","W","B","B","W"],
                      ["W","W","B","W","B","W"]], target = 3
    Output: 6
    Explanation: All the green 'B' are the black pixels we need (all 'B's at
                 column 1 and 3). Take 'B' at row r = 0 and column c = 1 as an
                 example:
                 - Rule 1, row r = 0 and column c = 1 both have exactly
                   target = 3 black pixels.
                 - Rule 2, the rows have black pixel at column c = 1 are row 0,
                   row 1 and row 2. They are exactly the same as row r = 0.

    Example 2:
    Input: picture = [["W","W","B"],["W","W","B"],["W","W","B"]], target = 1
    Output: 0

    Constraints:
    * m == picture.length
    * n == picture[i].length
    * 1 <= m, n <= 200
    * picture[i][j] is 'W' or 'B'.
    * 1 <= target <= min(m, n)"""

    def findBlackPixel(self, picture: List[List[str]], target: int) -> int:
        m, n = len(picture), len(picture[0])
        freq = defaultdict(int)
        rows = [0] * m
        cols = [0] * n
        for i in range(m):
            for j in range(n):
                if picture[i][j] == "B":
                    rows[i] += 1
                    cols[j] += 1
            freq["".join(picture[i])] += 1

        ans = 0
        for i in range(m):
            key = "".join(picture[i])
            if freq[key] == target:
                for j in range(n):
                    if picture[i][j] == "B" and rows[i] == cols[j] == target: ans += 1
        return ans


    """536. Construct Binary Tree from String (Medium)
    You need to construct a binary tree from a string consisting of parenthesis
    and integers. The whole input represents a binary tree. It contains an
    integer followed by zero, one or two pairs of parenthesis. The integer
    represents the root's value and a pair of parenthesis contains a child
    binary tree with the same structure. You always start to construct the left
    child node of the parent first if it exists.

    Example 1:
    Input: s = "4(2(3)(1))(6(5))"
    Output: [4,2,6,3,1,5]

    Example 2:
    Input: s = "4(2(3)(1))(6(5)(7))"
    Output: [4,2,6,3,1,5,7]

    Example 3:
    Input: s = "-4(2(3)(1))(6(5)(7))"
    Output: [-4,2,6,3,1,5,7]

    Constraints:
    * 0 <= s.length <= 3 * 10^4
    * s consists of digits, '(', ')', and '-' only."""

    def str2tree(self, s: str) -> Optional[TreeNode]:
        if not s: return None # edge case
        stack = []
        val = ""
        for ch in s:
            if ch == "(":
                if val:
                    node = TreeNode(int(val))
                    stack.append(node)
                    val = ""
            elif ch == ")":
                if val:
                    node = TreeNode(int(val))
                    val = ""
                else: node = stack.pop()
                if stack[-1].left is None: stack[-1].left = node
                else: stack[-1].right = node
            else: val += ch
        return stack[-1] if stack else TreeNode(int(val))


    """537. Complex Number Multiplication (Medium)
    Given two strings representing two complex numbers. You need to return a
    string representing their multiplication. Note i2 = -1 according to the
    definition.

    Example 1:
    Input: "1+1i", "1+1i"
    Output: "0+2i"
    Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert
                 it to the form of 0+2i.

    Example 2:
    Input: "1+-1i", "1+-1i"
    Output: "0+-2i"
    Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert
                 it to the form of 0+-2i.

    Note: The input strings will not have extra blank. The input strings will
          be given in the form of a+bi, where the integer a and b will both
          belong to the range of [-100, 100]. And the output should be also in
          this form."""

    def complexNumberMultiply(self, num1: str, num2: str) -> str:
        r1, i1 = map(int, num1[:-1].split('+'))
        r2, i2 = map(int, num2[:-1].split('+'))
        return f"{r1*r2-i1*i2}+{r1*i2+r2*i1}i"


    """538. Convert BST to Greater Tree (Medium)
    Given the root of a Binary Search Tree (BST), convert it to a Greater Tree
    such that every key of the original BST is changed to the original key plus
    sum of all keys greater than the original key in BST. As a reminder, a
    binary search tree is a tree that satisfies these constraints:
    * The left subtree of a node contains only nodes with keys less than the node's key.
    * The right subtree of a node contains only nodes with keys greater than the node's key.
    * Both the left and right subtrees must also be binary search trees.

    Note: This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/

    Example 1:
    Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
    Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

    Example 2:
    Input: root = [0,null,1]
    Output: [1,null,1]

    Example 3:
    Input: root = [1,0,2]
    Output: [3,3,2]

    Example 4:
    Input: root = [3,2,4,1]
    Output: [7,9,4,10]

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * -10^4 <= Node.val <= 10^4
    * All the values in the tree are unique.
    * root is guaranteed to be a valid binary search tree."""

    def convertBST(self, root: TreeNode) -> TreeNode:

        def fn(node, x):
            """Inorder traverse the tree and update node's value."""
            if not node: return x
            x = fn(node.right, x) # sum of right subtree
            x += node.val
            node.val = x
            return fn(node.left, x)

        fn(root, 0)
        return root


    """540. Single Element in a Sorted Array (Medium)
    You are given a sorted array consisting of only integers where every
    element appears exactly twice, except for one element which appears exactly
    once. Return the single element that appears only once. Your solution must
    run in O(log n) time and O(1) space.

    Example 1:
    Input: nums = [1,1,2,3,3,4,4,8,8]
    Output: 2

    Example 2:
    Input: nums = [3,3,7,7,10,11,11]
    Output: 10

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5"""

    def singleNonDuplicate(self, nums: List[int]) -> int:
        lo, hi = 0, len(nums)-1
        while lo < hi:
            mid = lo + hi >> 1
            if nums[mid] == nums[mid^1]: lo = mid+1
            else: hi = mid
        return nums[lo]


    """542. 01 Matrix (Medium)
    Given an m x n binary matrix mat, return the distance of the nearest 0 for
    each cell. The distance between two adjacent cells is 1.

    Example 1:
    Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
    Output: [[0,0,0],[0,1,0],[0,0,0]]

    Example 2:
    Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
    Output: [[0,0,0],[0,1,0],[1,2,1]]

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 10^4
    * 1 <= m * n <= 10^4
    * mat[i][j] is either 0 or 1.
    * There is at least one 0 in mat."""

    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        ans = [[inf]*n for _ in range(m)]

        for i in range(m):
            for j in range(n):
                if not mat[i][j]: ans[i][j] = 0
                else:
                    if i: ans[i][j] = min(ans[i][j], 1 + ans[i-1][j])
                    if j: ans[i][j] = min(ans[i][j], 1 + ans[i][j-1])

        for i in reversed(range(m)):
            for j in reversed(range(n)):
                if mat[i][j]:
                    if i+1 < m: ans[i][j] = min(ans[i][j], 1 + ans[i+1][j])
                    if j+1 < n: ans[i][j] = min(ans[i][j], 1 + ans[i][j+1])
        return ans


    """543. Diameter of Binary Tree (Easy)
    Given the root of a binary tree, return the length of the diameter of the
    tree. The diameter of a binary tree is the length of the longest path
    between any two nodes in a tree. This path may or may not pass through the
    root. The length of a path between two nodes is represented by the number
    of edges between them.

    Example 1:
    Input: root = [1,2,3,4,5]
    Output: 3
    Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].

    Example 2:
    Input: root = [1,2]
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -100 <= Node.val <= 100"""

    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        def fn(node):
            """Return node's height and sub-tree's diameter."""
            if not node: return (0, 0)
            l1, d1 = fn(node.left)
            l2, d2 = fn(node.right)
            return 1 + max(l1, l2), max(d1, d2, l1+l2)

        return fn(root)[1]


    """544. Output Contest Matches (Medium)
    During the NBA playoffs, we always set the rather strong team to play with
    the rather weak team, like make the rank 1 team play with the rank nth team,
    which is a good strategy to make the contest more interesting. Given n
    teams, return their final contest matches in the form of a string. The n
    teams are labeled from 1 to n, which represents their initial rank (i.e.,
    Rank 1 is the strongest team and Rank n is the weakest team). We will use
    parentheses '(', and ')' and commas ',' to represent the contest team
    pairing. We use the parentheses for pairing and the commas for partition.
    During the pairing process in each round, you always need to follow the
    strategy of making the rather strong one pair with the rather weak one.

    Example 1:
    Input: n = 4
    Output: "((1,4),(2,3))"
    Explanation: In the first round, we pair the team 1 and 4, the teams 2 and
                 3 together, as we need to make the strong team and weak team
                 together. And we got (1, 4),(2, 3). In the second round, the
                 winners of (1, 4) and (2, 3) need to play again to generate
                 the final winner, so you need to add the paratheses outside
                 them. And we got the final answer ((1,4),(2,3)).

    Example 2:
    Input: n = 8
    Output: "(((1,8),(4,5)),((2,7),(3,6)))"
    Explanation: First round: (1, 8),(2, 7),(3, 6),(4, 5)
                 Second round: ((1, 8),(4, 5)),((2, 7),(3, 6))
                 Third round: (((1, 8),(4, 5)),((2, 7),(3, 6)))
                 Since the third round will generate the final winner, you need
                 to output the answer (((1,8),(4,5)),((2,7),(3,6))).

    Constraints: n == 2^x where x in in the range [1, 12]."""

    def findContestMatch(self, n: int) -> str:
        ans = [str(x) for x in range(1, n+1)]
        while len(ans) > 1:
            n = len(ans)
            for i in range(n//2):
                ans[i] = f"({ans[i]},{ans[n-i-1]})"
                ans.pop()
        return ans[0]


    """545. Boundary of Binary Tree (Medium)
    The boundary of a binary tree is the concatenation of the root, the left
    boundary, the leaves ordered from left-to-right, and the reverse order of
    the right boundary. The left boundary is the set of nodes defined by the
    following:
    * The root node's left child is in the left boundary. If the root does not
      have a left child, then the left boundary is empty.
    * If a node in the left boundary and has a left child, then the left child
      is in the left boundary.
    * If a node is in the left boundary, has no left child, but has a right
      child, then the right child is in the left boundary.
    * The leftmost leaf is not in the left boundary.
    The right boundary is similar to the left boundary, except it is the right
    side of the root's right subtree. Again, the leaf is not part of the right
    boundary, and the right boundary is empty if the root does not have a right
    child. The leaves are nodes that do not have any children. For this problem,
    the root is not a leaf. Given the root of a binary tree, return the values
    of its boundary.

    Example 1:
    Input: root = [1,null,2,3,4]
    Output: [1,3,4,2]
    Explanation: - The left boundary is empty because the root does not have a
                   left child.
                 - The right boundary follows the path starting from the root's
                   right child 2 -> 4. 4 is a leaf, so the right boundary is [2].
                 - The leaves from left to right are [3,4].
                 Concatenating everything results in
                 [1] + [] + [3,4] + [2] = [1,3,4,2].

    Example 2:
    Input: root = [1,2,3,4,5,6,null,null,null,7,8,9,10]
    Output: [1,2,4,7,8,9,10,6,3]
    Explanation: - The left boundary follows the path starting from the root's
                   left child 2 -> 4. 4 is a leaf, so the left boundary is [2].
                 - The right boundary follows the path starting from the root's
                   right child 3 -> 6 -> 10. 10 is a leaf, so the right
                   boundary is [3,6], and in reverse order is [6,3].
                 - The leaves from left to right are [4,7,8,9,10].
                 Concatenating everything results in
                 [1] + [2] + [4,7,8,9,10] + [6,3] = [1,2,4,7,8,9,10,6,3].

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -1000 <= Node.val <= 1000"""

    def boundaryOfBinaryTree(self, root: Optional[TreeNode]) -> List[int]:
        stack = []
        if root.right: stack.append((root.right, 1))
        if root.left: stack.append((root.left, -1))
        left, right, leaves = [], [], []
        while stack:
            node, v = stack.pop()
            if node.left is node.right: leaves.append(node.val)
            elif v == -1:
                left.append(node.val)
                if node.right:
                    if node.left: stack.append((node.right, 0))
                    else: stack.append((node.right, -1))
                if node.left: stack.append((node.left, -1))
            elif v == 1:
                right.append(node.val)
                if node.right: stack.append((node.right, 1))
                if node.left:
                    if node.right: stack.append((node.left, 0))
                    else: stack.append((node.left, 1))
            else:
                if node.right: stack.append((node.right, 0))
                if node.left: stack.append((node.left, 0))
        return [root.val] + left + leaves + right[::-1]


    """546. Remove Boxes (Hard)
    You are given several boxes with different colors represented by different
    positive numbers. You may experience several rounds to remove boxes until
    there is no box left. Each time you can choose some continuous boxes with
    the same color (i.e., composed of k boxes, k >= 1), remove them and get
    k * k points. Return the maximum points you can get.

    Example 1:
    Input: boxes = [1,3,2,2,2,3,4,3,1]
    Output: 23
    Explanation: [1, 3, 2, 2, 2, 3, 4, 3, 1]
                 ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)
                 ----> [1, 3, 3, 3, 1] (1*1=1 points)
                 ----> [1, 1] (3*3=9 points)
                 ----> [] (2*2=4 points)

    Example 2:
    Input: boxes = [1,1,1]
    Output: 9

    Example 3:
    Input: boxes = [1]
    Output: 1

    Constraints:
    * 1 <= boxes.length <= 100
    * 1 <= boxes[i] <= 100"""

    def removeBoxes(self, boxes: List[int]) -> int:

        @cache
        def fn(lo, hi, k):
            """Return max score of removing boxes from lo to hi with k to the left."""
            if lo == hi: return 0
            while lo+1 < hi and boxes[lo] == boxes[lo+1]: lo, k = lo+1, k+1
            ans = (k+1)*(k+1) + fn(lo+1, hi, 0)
            for mid in range(lo+2, hi):
                if boxes[lo] == boxes[mid]:
                    ans = max(ans, fn(lo+1, mid, 0) + fn(mid, hi, k+1))
            return ans

        return fn(0, len(boxes), 0)


    """547. Number of Provinces (Medium)
    There are n cities. Some of them are connected, while some are not. If city
    a is connected directly with city b, and city b is connected directly with
    city c, then city a is connected indirectly with city c. A province is a
    group of directly or indirectly connected cities and no other cities
    outside of the group. You are given an n x n matrix isConnected where
    isConnected[i][j] = 1 if the ith city and the jth city are directly
    connected, and isConnected[i][j] = 0 otherwise. Return the total number of
    provinces.

    Example 1:
    Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
    Output: 2

    Example 2:
    Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
    Output: 3

    Constraints:
    * 1 <= n <= 200
    * n == isConnected.length
    * n == isConnected[i].length
    * isConnected[i][j] is 1 or 0.
    * isConnected[i][i] == 1
    * isConnected[i][j] == isConnected[j][i]"""

    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        ans = 0
        visited = [False]*n
        for x in range(n):
            if not visited[x]:
                ans += 1
                stack = [x]
                visited[x] = True
                while stack:
                    i = stack.pop()
                    for ii in range(n):
                        if isConnected[i][ii] and not visited[ii]:
                            stack.append(ii)
                            visited[ii] = True
        return ans


    """548. Split Array with Equal Sum (Hard)
    Given an integer array nums of length n, return true if there is a triplet
    (i, j, k) which satisfies the following conditions:
    * 0 < i, i + 1 < j, j + 1 < k < n - 1
    * The sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and
      (k + 1, n - 1) is equal.
    A subarray (l, r) represents a slice of the original array starting from
    the element indexed l to the element indexed r.

    Example 1:
    Input: nums = [1,2,1,2,1,2,1]
    Output: true
    Explanation: i = 1, j = 3, k = 5.
                 sum(0, i - 1) = sum(0, 0) = 1
                 sum(i + 1, j - 1) = sum(2, 2) = 1
                 sum(j + 1, k - 1) = sum(4, 4) = 1
                 sum(k + 1, n - 1) = sum(6, 6) = 1

    Example 2:
    Input: nums = [1,2,1,2,1,2,1,2]
    Output: false

    Constraints:
    * n == nums.length
    * 1 <= n <= 2000
    * -10^6 <= nums[i] <= 10^6"""

    def splitArray(self, nums: List[int]) -> bool:
        prefix = list(accumulate(nums, initial=0))
        for j in range(len(nums)):
            seen = set()
            for i in range(1, j-1):
                if prefix[i] == prefix[j] - prefix[i+1]: seen.add(prefix[i])
            for k in range(j+2, len(nums)-1):
                if prefix[k] - prefix[j+1] == prefix[-1] - prefix[k+1] and prefix[k] - prefix[j+1] in seen: return True
        return False


    """549. Binary Tree Longest Consecutive Sequence II (Medium)
    Given the root of a binary tree, return the length of the longest
    consecutive path in the tree. A consecutive path is a path where the values
    of the consecutive nodes in the path differ by one. This path can be either
    increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both
    considered valid, but the path [1,2,4,3] is not valid. On the other hand,
    the path can be in the child-Parent-child order, where not necessarily be
    parent-child order.

    Example 1:
    Input: root = [1,2,3]
    Output: 2
    Explanation: The longest consecutive path is [1, 2] or [2, 1].

    Example 2:
    Input: root = [2,1,3]
    Output: 3
    Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1].

    Constraints:
    * The number of nodes in the tree is in the range [1, 3 * 10^4].
    * -3 * 10^4 <= Node.val <= 3 * 10^4"""

    def longestConsecutive(self, root: Optional[TreeNode]) -> int:
        ans = 0
        mp, stack = {None: (0, 0)}, []
        node, prev = root, None
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack[-1]
                if node.right and node.right != prev: node = node.right
                else:
                    mp[node] = [1, 1]
                    if node.left:
                        if node.left.val + 1 == node.val: mp[node][0] = 1 + mp[node.left][0]
                        if node.left.val - 1 == node.val: mp[node][1] = 1 + mp[node.left][1]
                    if node.right:
                        if node.right.val + 1 == node.val: mp[node][0] = max(mp[node][0], 1 + mp[node.right][0])
                        if node.right.val - 1 == node.val: mp[node][1] = max(mp[node][1], 1 + mp[node.right][1])
                    ans = max(ans, sum(mp[node]) - 1)
                    stack.pop()
                    prev = node
                    node = None
        return ans


    """552. Student Attendance Record II (Hard)
    An attendance record for a student can be represented as a string where
    each character signifies whether the student was absent, late, or present
    on that day. The record only contains the following three characters:
    * 'A': Absent.
    * 'L': Late.
    * 'P': Present.
    Any student is eligible for an attendance award if they meet both of the
    following criteria:
    * The student was absent ('A') for strictly fewer than 2 days total.
    * The student was never late ('L') for 3 or more consecutive days.
    Given an integer n, return the number of possible attendance records of
    length n that make a student eligible for an attendance award. The answer
    may be very large, so return it modulo 10^9 + 7.

    Example 1:
    Input: n = 2
    Output: 8
    Explanation: There are 8 records with length 2 that are eligible for an
                 award: "PP", "AP", "PA", "LP", "PL", "AL", "LA", "LL". Only
                 "AA" is not eligible because there are 2 absences (there need
                 to be fewer than 2).

    Example 2:
    Input: n = 1
    Output: 3

    Example 3:
    Input: n = 10101
    Output: 183236316

    Constraints: 1 <= n <= 10^5"""

    def checkRecord(self, n: int) -> int:
        dp = [1, 2, 4]
        for i in range(3, n+1):
            dp.append((dp[i-3] + dp[i-2] + dp[i-1]) % 1_000_000_007)
        ans = dp[n]
        for i in range(n):
            ans = (ans + dp[i] * dp[n-1-i]) % 1_000_000_007
        return ans


    """553. Optimal Division (Medium)
    You are given an integer array nums. The adjacent integers in nums will
    perform the float division. For example, for nums = [2,3,4], we will
    evaluate the expression "2/3/4". However, you can add any number of
    parenthesis at any position to change the priority of operations. You want
    to add these parentheses such the value of the expression after the
    evaluation is maximum. Return the corresponding expression that has the
    maximum value in string format. Note: your expression should not contain
    redundant parenthesis.

    Example 1:
    Input: nums = [1000,100,10,2]
    Output: "1000/(100/10/2)"
    Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200. However, the bold
                 parenthesis in "1000/((100/10)/2)" are redundant, since they
                 don't influence the operation priority. So you should return
                 "1000/(100/10/2)".
                 Other cases:
                 1000/(100/10)/2 = 50
                 1000/(100/(10/2)) = 50
                 1000/100/10/2 = 0.5
                 1000/100/(10/2) = 2

    Example 2:
    Input: nums = [2,3,4]
    Output: "2/(3/4)"

    Example 3:
    Input: nums = [2]
    Output: "2"

    Constraints:
    * 1 <= nums.length <= 10
    * 2 <= nums[i] <= 1000
    * There is only one optimal division for the given iput."""

    def optimalDivision(self, nums: List[int]) -> str:
        if len(nums) <= 2: return "/".join(map(str, nums))
        return f'{nums[0]}/({"/".join(map(str, nums[1:]))})'


    """555. Split Concatenated Strings (Medium)
    You are given an array of strings strs. You could concatenate these strings
    together into a loop, where for each string, you could choose to reverse it
    or not. Among all the possible loops, return the lexicographically largest
    string after cutting the loop, which will make the looped string into a
    regular one. Specifically, to find the lexicographically largest string,
    you need to experience two phases:
    * Concatenate all the strings into a loop, where you can reverse some
      strings or not and connect them in the same order as given.
    * Cut and make one breakpoint in any place of the loop, which will make the
      looped string into a regular one starting from the character at the
      cutpoint.
    And your job is to find the lexicographically largest one among all the
    possible regular strings.

    Example 1:
    Input: strs = ["abc","xyz"]
    Output: "zyxcba"
    Explanation: You can get the looped string "-abcxyz-", "-abczyx-",
                 "-cbaxyz-", "-cbazyx-", where '-' represents the looped status.
                 The answer string came from the fourth looped one, where you
                 could cut from the middle character 'a' and get "zyxcba".

    Example 2:
    Input: strs = ["abc"]
    Output: "cba"

    Constraints:
    * 1 <= strs.length <= 1000
    * 1 <= strs[i].length <= 1000
    * 1 <= sum(strs[i].length) <= 1000
    * strs[i] consists of lowercase English letters."""

    def splitLoopedString(self, strs: List[str]) -> str:
        strs = [max(x, x[::-1]) for x in strs]

        ans = ""
        for i in range(len(strs)):
            rev = strs[i][::-1]
            rest = "".join(strs[i+1:] + strs[:i])
            for k in range(len(strs[i])):
                ans = max(ans, strs[i][k:] + rest + strs[i][:k])
                ans = max(ans, rev[k:] + rest + rev[:k])
        return ans


    """557. Reverse Words in a String III (Easy)
    Given a string s, reverse the order of characters in each word within a
    sentence while still preserving whitespace and initial word order.

    Example 1:
    Input: s = "Let's take LeetCode contest"
    Output: "s'teL ekat edoCteeL tsetnoc"

    Example 2:
    Input: s = "God Ding"
    Output: "doG gniD"

    Constraints:
    * 1 <= s.length <= 5 * 10^4
    * s contains printable ASCII characters.
    * s does not contain any leading or trailing spaces.
    * There is at least one word in s.
    * All the words in s are separated by a single space."""

    def reverseWords(self, s: str) -> str:
        return " ".join(w[::-1] for w in s.split())


    """560. Subarray Sum Equals K (Medium)
    Given an array of integers nums and an integer k, return the total number
    of continuous subarrays whose sum equals to k.

    Example 1:
    Input: nums = [1,1,1], k = 2
    Output: 2

    Example 2:
    Input: nums = [1,2,3], k = 3
    Output: 2

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * -1000 <= nums[i] <= 1000
    * -10^7 <= k <= 10^7"""

    def subarraySum(self, nums: List[int], k: int) -> int:
        ans = prefix = 0
        freq = Counter({0 : 1})
        for x in nums:
            prefix += x
            ans += freq[prefix - k]
            freq[prefix] += 1
        return ans


    """562. Longest Line of Consecutive One in Matrix (Medium)
    Given a 01 matrix M, find the longest line of consecutive one in the matrix.
    The line could be horizontal, vertical, diagonal or anti-diagonal.

    Example:
    Input: [[0,1,1,0],
            [0,1,1,0],
            [0,0,0,1]]
    Output: 3
    Hint: The number of elements in the given matrix will not exceed 10,000."""

    def longestLine(self, M: List[List[int]]) -> int:
        ans = 0
        if M:
            m, n = len(M), len(M[0]) # dimensions
            rows, cols = [0]*m, [0]*n
            diag, anti = [0]*(m+n-1), [0]*(m+n-1)
            for i in range(m):
                for j in range(n):
                    if M[i][j]:
                        rows[i] += 1
                        cols[j] += 1
                        diag[j-i+m-1] += 1
                        anti[i+j] += 1
                    else: rows[i] = cols[j] = diag[j-i+m-1] = anti[i+j] = 0
                    ans = max(ans, rows[i], cols[j], diag[j-i+m-1], anti[i+j])
        return ans


    """563. Binary Tree Tilt (Easy)
    Given the root of a binary tree, return the sum of every tree node's tilt.
    The tilt of a tree node is the absolute difference between the sum of all
    left subtree node values and all right subtree node values. If a node does
    not have a left child, then the sum of the left subtree node values is
    treated as 0. The rule is similar if there the node does not have a right
    child.

    Example 1:
    Input: root = [1,2,3]
    Output: 1
    Explanation: Tilt of node 2 : |0-0| = 0 (no children)
                 Tilt of node 3 : |0-0| = 0 (no children)
                 Tilt of node 1 : |2-3| = 1 (left subtree is just left child,
                 so sum is 2; right subtree is just right child, so sum is 3)
                 Sum of every tilt : 0 + 0 + 1 = 1

    Example 2:
    Input: root = [4,2,9,3,5,null,7]
    Output: 15
    Explanation: Tilt of node 3 : |0-0| = 0 (no children)
                 Tilt of node 5 : |0-0| = 0 (no children)
                 Tilt of node 7 : |0-0| = 0 (no children)
                 Tilt of node 2 : |3-5| = 2 (left subtree is just left child,
                 so sum is 3; right subtree is just right child, so sum is 5)
                 Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right
                 subtree is just right child, so sum is 7)
                 Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree
                 values are 3, 5, and 2, which sums to 10; right subtree values
                 are 9 and 7, which sums to 16)
                 Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15

    Example 3:
    Input: root = [21,7,14,1,1,2,2,3,3]
    Output: 9

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * -1000 <= Node.val <= 1000"""

    def findTilt(self, root: Optional[TreeNode]) -> int:
        mp = {None: 0}
        ans = 0
        prev = None
        node = root
        stack = []
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack[-1]
                if node.right and prev != node.right: node = node.right
                else:
                    mp[node] = node.val + mp[node.left] + mp[node.right]
                    ans += abs(mp[node.left] - mp[node.right])
                    stack.pop()
                    prev = node
                    node = None
        return ans


    """564. Find the Closest Palindrome (Hard)
    Given a string n representing an integer, return the closest integer (not
    including itself), which is a palindrome. If there is a tie, return the
    smaller one. The closest is defined as the absolute difference minimized
    between two integers.

    Example 1:
    Input: n = "123"
    Output: "121"

    Example 2:
    Input: n = "1"
    Output: "0"
    Explanation: 0 and 2 are the closest palindromes but we return the smallest
                 which is 0.

    Constraints:
    * 1 <= n.length <= 18
    * n consists of only digits.
    * n does not have leading zeros.
    * n is representing an integer in the range [1, 10^18 - 1]."""

    def nearestPalindromic(self, n: str) -> str:
        sz = len(n)
        cand = n[:sz//2] + (n[sz//2] if sz&1 else "") + n[0:sz//2][::-1]

        def fn(carry):
            digits = list(map(int, n))[:(sz+1)//2]
            i = (sz-1)//2
            while i >= 0 and carry:
                digits[i] += carry
                carry = digits[i] // 10
                digits[i] = (digits[i] + 10) % 10
                i -= 1
            half = (str(carry)+''.join(map(str, digits))).lstrip('0')
            if len(half) < len(digits): return '9'*(sz-1) or '0'
            if len(half) > len(digits): return '1' + '0'*(sz-1) + '1'
            half = half or '0'
            if sz&1: return half + half[:-1:][::-1]
            else: return half + half[::-1]

        large = fn(1)
        small = fn(-1)
        if cand == n: return min(small, large, key=lambda x: (abs(int(x)-int(n)), int(x)))
        return min(cand, large, small, key=lambda x: (abs(int(x)-int(n)), int(x)))


    """565. Array Nesting (Medium)
    A zero-indexed array A of length N contains all integers from 0 to N-1.
    Find and return the longest length of set S, where
    S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.
    Suppose the first element in S starts with the selection of element A[i] of
    index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By
    that analogy, we stop adding right before a duplicate element occurs in S.

    Example 1:
    Input: A = [5,4,0,3,1,6,2]
    Output: 4
    Explanation: A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.
    One of the longest S[K]: S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}

    Note:
    * N is an integer within the range [1, 20,000].
    * The elements of A are all distinct.
    * Each element of A is an integer within the range [0, N-1]."""

    def arrayNesting(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums)):
            cnt = 0
            while nums[i] != -1:
                cnt += 1
                nums[i], i = -1, nums[i]
            ans = max(ans, cnt)
        return ans


    """566. Reshape the Matrix (Easy)
    In MATLAB, there is a handy function called reshape which can reshape an
    m x n matrix into a new one with a different size r x c keeping its
    original data. You are given an m x n matrix mat and two integers r and c
    representing the row number and column number of the wanted reshaped matrix.
    The reshaped matrix should be filled with all the elements of the original
    matrix in the same row-traversing order as they were. If the reshape
    operation with given parameters is possible and legal, output the new
    reshaped matrix; Otherwise, output the original matrix.

    Example 1:
    Input: mat = [[1,2],[3,4]], r = 1, c = 4
    Output: [[1,2,3,4]]

    Example 2:
    Input: mat = [[1,2],[3,4]], r = 2, c = 4
    Output: [[1,2],[3,4]]

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 100
    * -1000 <= mat[i][j] <= 1000
    * 1 <= r, c <= 300"""

    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        if m * n != r * c: return mat
        it = (x for row in mat for x in row)
        return [[next(it) for _ in range(c)] for i in range(r)]


    """567. Permutation in String (Medium)
    Given two strings s1 and s2, return true if s2 contains a permutation of s1,
    or false otherwise. In other words, return true if one of s1's permutations
    is the substring of s2.

    Example 1:
    Input: s1 = "ab", s2 = "eidbaooo"
    Output: true
    Explanation: s2 contains one permutation of s1 ("ba").

    Example 2:
    Input: s1 = "ab", s2 = "eidboaoo"
    Output: false

    Constraints:
    * 1 <= s1.length, s2.length <= 10^4
    * s1 and s2 consist of lowercase English letters."""

    def checkInclusion(self, s1: str, s2: str) -> bool:
        freq = Counter(s1)
        bal = len(freq)
        for i, ch in enumerate(s2):
            if freq[ch] == 0: bal += 1
            freq[ch] -= 1
            if freq[ch] == 0: bal -= 1
            if i >= len(s1):
                if freq[s2[i-len(s1)]] == 0: bal += 1
                freq[s2[i-len(s1)]] += 1
                if freq[s2[i-len(s1)]] == 0: bal -= 1
            if bal == 0: return True
        return False


    """572. Subtree of Another Tree (Easy)
    Given the roots of two binary trees root and subRoot, return true if there
    is a subtree of root with the same structure and node values of subRoot and
    false otherwise. A subtree of a binary tree tree is a tree that consists of
    a node in tree and all of this node's descendants. The tree tree could also
    be considered as a subtree of itself.

    Example 1:
    Input: root = [3,4,5,1,2], subRoot = [4,1,2]
    Output: true

    Example 2:
    Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
    Output: false

    Constraints:
    * The number of nodes in the root tree is in the range [1, 2000].
    * The number of nodes in the subRoot tree is in the range [1, 1000].
    * -10^4 <= root.val <= 10^4
    * -10^4 <= subRoot.val <= 10^4"""

    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        ans = False
        target = ""

        def fn(node):
            """Return hash of sub-tree rooted at node."""
            nonlocal ans
            if not node: return "$"
            left, right = fn(node.left), fn(node.right)
            sha = sha256()
            sha.update((left + str(node.val) + right).encode())
            if sha.hexdigest() == target: ans = True
            return sha.hexdigest()

        target = fn(subRoot)
        fn(root)
        return ans


    """573. Squirrel Simulation (Medium)
    There's a tree, a squirrel, and several nuts. Positions are represented by
    the cells in a 2D grid. Your goal is to find the minimal distance for the
    squirrel to collect all the nuts and put them under the tree one by one.
    The squirrel can only take at most one nut at one time and can move in four
    directions - up, down, left and right, to the adjacent cell. The distance
    is represented by the number of moves.

    Example 1:
    Input:
    Height : 5
    Width : 7
    Tree position : [2,2]
    Squirrel : [4,4]
    Nuts : [[3,0], [2,5]]
    Output: 12
    Note:
    * All given positions won't overlap.
    * The squirrel can take at most one nut at one time.
    * The given positions of nuts have no order.
    * Height and width are positive integers. 3 <= height * width <= 10,000.
    * The given positions contain at least one nut, only one tree and one squirrel."""

    def minDistance(self, height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:
        ans, mn = 0, inf
        for x, y in nuts:
            ans += 2*(abs(tree[0]-x) + abs(tree[1]-y))
            mn = min(mn, abs(squirrel[0]-x) + abs(squirrel[1]-y) - abs(tree[0]-x) - abs(tree[1]-y))
        return ans + mn


    """575. Distribute Candies (Easy)
    Alice has n candies, where the ith candy is of type candyType[i]. Alice
    noticed that she started to gain weight, so she visited a doctor. The
    doctor advised Alice to only eat n / 2 of the candies she has (n is always
    even). Alice likes her candies very much, and she wants to eat the maximum
    number of different types of candies while still following the doctor's
    advice. Given the integer array candyType of length n, return the maximum
    number of different types of candies she can eat if she only eats n / 2 of
    them.

    Example 1:
    Input: candyType = [1,1,2,2,3,3]
    Output: 3
    Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3
                 types, she can eat one of each type.

    Example 2:
    Input: candyType = [1,1,2,3]
    Output: 2
    Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types
                 [1,2], [1,3], or [2,3], she still can only eat 2 different
                 types.

    Example 3:
    Input: candyType = [6,6,6,6]
    Output: 1
    Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat
                 2 candies, she only has 1 type.

    Constraints:
    * n == candyType.length
    * 2 <= n <= 10^4
    * n is even.
    * -10^5 <= candyType[i] <= 10^5"""

    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(candyType)//2, len(set(candyType)))


    """576. Out of Boundary Paths (Medium)
    There is an m x n grid with a ball. The ball is initially at the position
    [startRow, startColumn]. You are allowed to move the ball to one of the
    four adjacent four cells in the grid (possibly out of the grid crossing the
    grid boundary). You can apply at most maxMove moves to the ball. Given the
    five integers m, n, maxMove, startRow, startColumn, return the number of
    paths to move the ball out of the grid boundary. Since the answer can be
    very large, return it modulo 10^9 + 7.

    Example 1:
    Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
    Output: 6

    Example 2:
    Input: m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1
    Output: 12

    Constraints:
    * 1 <= m, n <= 50
    * 0 <= maxMove <= 50
    * 0 <= startRow <= m
    * 0 <= startColumn <= n"""

    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:

        @cache
        def fn(i, j, mv):
            """Return out of boundary paths."""
            if not (0 <= i < m and 0 <= j < n): return 1
            if mv == 0: return 0
            return (fn(i-1, j, mv-1) + fn(i, j-1, mv-1) + fn(i, j+1, mv-1) + fn(i+1, j, mv-1)) % 1_000_000_007

        return fn(startRow, startColumn, maxMove)


    """582. Kill Process (Medium)
    Given n processes, each process has a unique PID (process id) and its PPID
    (parent process id). Each process only has one parent process, but may have
    one or more children processes. This is just like a tree structure. Only
    one process has PPID that is 0, which means this process has no parent
    process. All the PIDs will be distinct positive integers. We use two list
    of integers to represent a list of processes, where the first list contains
    PID for each process and the second list contains the corresponding PPID.
    Now given the two lists, and a PID representing a process you want to kill,
    return a list of PIDs of processes that will be killed in the end. You
    should assume that when a process is killed, all its children processes
    will be killed. No order is required for the final answer.

    Example 1:
    Input: pid =  [1, 3, 10, 5]
           ppid = [3, 0, 5, 3]
           kill = 5
    Output: [5,10]
    Explanation:
               3
             /   \
            1     5
                 /
                10
    Kill 5 will also kill 10.
    Note:
    * The given kill id is guaranteed to be one of the given PIDs.
    * n >= 1."""

    def killProcess(self, pid: List[int], ppid: List[int], kill: int) -> List[int]:
        tree = {}
        for x, px in zip(pid, ppid):
            tree.setdefault(px, []).append(x)

        ans, stack = [], [kill]
        while stack:
            x = stack.pop()
            ans.append(x)
            stack.extend(tree.get(x, []))
        return ans


    """583. Delete Operation for Two Strings (Medium)
    Given two strings word1 and word2, return the minimum number of steps
    required to make word1 and word2 the same. In one step, you can delete
    exactly one character in either string.

    Example 1:
    Input: word1 = "sea", word2 = "eat"
    Output: 2
    Explanation: You need one step to make "sea" to "ea" and another step to
                 make "eat" to "ea".

    Example 2:
    Input: word1 = "leetcode", word2 = "etco"
    Output: 4

    Constraints:
    * 1 <= word1.length, word2.length <= 500
    * word1 and word2 consist of only lowercase English letters."""

    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        dp = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m): dp[i][n] = m-i
        for j in range(n): dp[m][j] = n-j
        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                if word1[i] == word2[j]: dp[i][j] = dp[i+1][j+1]
                else: dp[i][j] = 1 + min(dp[i+1][j], dp[i][j+1])
        return dp[0][0]


    """587. Erect the Fence (Hard)
    You are given an array trees where trees[i] = [xi, yi] represents the
    location of a tree in the garden. You are asked to fence the entire garden
    using the minimum length of rope as it is expensive. The garden is well
    fenced only if all the trees are enclosed. Return the coordinates of trees
    that are exactly located on the fence perimeter.

    Example 1:
    Input: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
    Output: [[1,1],[2,0],[3,3],[2,4],[4,2]]

    Example 2:
    Input: points = [[1,2],[2,2],[4,2]]
    Output: [[4,2],[2,2],[1,2]]

    Constraints:
    * 1 <= points.length <= 3000
    * points[i].length == 2
    * 0 <= xi, yi <= 100
    * All the given points are unique."""

    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:
        # convex hull via Graham scan
        xx, yy = min(trees, key=lambda x: (x[1], x[0])) # reference point

        mp = {}
        for x, y in trees: mp.setdefault(atan2(y-yy, x-xx), []).append([x, y])

        trees = []
        m = max(mp)
        for k in sorted(mp):
            mp[k].sort(key=lambda p: abs(p[0]-xx)+abs(p[1]-yy))
            if k == m and trees: mp[k].reverse()
            trees.extend(mp[k])

        stack = []
        for x, y in trees:
            while len(stack) >= 2:
                x0, y0 = stack[-1]
                x1, y1 = stack[-2]
                if (x0-x1)*(y-y0) - (x-x0)*(y0-y1) >= 0: break
                else: stack.pop()
            stack.append([x, y])
        return stack


    """590. N-ary Tree Postorder Traversal (Easy)
    Given the root of an n-ary tree, return the postorder traversal of its
    nodes' values. Nary-Tree input serialization is represented in their level
    order traversal. Each group of children is separated by the null value (See
    examples)

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: [5,6,3,2,4,1]

    Example 2:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * 0 <= Node.val <= 10^4
    * The height of the n-ary tree is less than or equal to 1000.

    Follow up: Recursive solution is trivial, could you do it iteratively?"""

    def postorder(self, root: 'Node') -> List[int]:
        ans = []
        if root:
            stack = [root]
            prev = None
            while stack:
                node = stack[-1]
                if node.children and prev != node.children[-1]:
                    for child in reversed(node.children): stack.append(child)
                else:
                    ans.append(node.val)
                    stack.pop()
                    prev = node
        return ans


    """591. Tag Validator (Hard)
    Given a string representing a code snippet, implement a tag validator to
    parse the code and return whether it is valid. A code snippet is valid if
    all the following rules hold:
    * The code must be wrapped in a valid closed tag. Otherwise, the code is
      invalid.
    * A closed tag (not necessarily valid) has exactly the following format :
      <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag,
      and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should
      be the same. A closed tag is valid if and only if the TAG_NAME and
      TAG_CONTENT are valid.
    * A valid TAG_NAME only contain upper-case letters, and has length in range
      [1,9]. Otherwise, the TAG_NAME is invalid.
    * A valid TAG_CONTENT may contain other valid closed tags, cdata and any
      characters (see note1) EXCEPT unmatched <, unmatched start and end tag,
      and unmatched or closed tags with invalid TAG_NAME. Otherwise, the
      TAG_CONTENT is invalid.
    * A start tag is unmatched if no end tag exists with the same TAG_NAME, and
      vice versa. However, you also need to consider the issue of unbalanced
      when tags are nested.
    * A < is unmatched if you cannot find a subsequent >. And when you find a <
      or </, all the subsequent characters until the next > should be parsed as
      TAG_NAME (not necessarily valid).
    * The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range
      of CDATA_CONTENT is defined as the characters between <![CDATA[ and the
      first subsequent ]]>.
    * CDATA_CONTENT may contain any characters. The function of cdata is to
      forbid the validator to parse CDATA_CONTENT, so even it has some
      characters that can be parsed as tag (no matter valid or invalid), you
      should treat it as regular characters.

    Example 1:
    Input: code = "<DIV>This is the first line <![CDATA[<div>]]></DIV>"
    Output: true
    Explanation: The code is wrapped in a closed tag : <DIV> and </DIV>. The
                 TAG_NAME is valid, the TAG_CONTENT consists of some characters
                 and cdata. Although CDATA_CONTENT has an unmatched start tag
                 with invalid TAG_NAME, it should be considered as plain text,
                 not parsed as a tag. So TAG_CONTENT is valid, and then the
                 code is valid. Thus return true.

    Example 2:
    Input: code = "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"
    Output: true
    Explanation: We first separate the code into : start_tag|tag_content|
                 end_tag.
                 start_tag -> "<DIV>"
                 end_tag -> "</DIV>"
                 tag_content could also be separated into : text1|cdata|text2.
                 text1 -> ">>  ![cdata[]] "
                 cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is
                          "<div>]>"
                 text2 -> "]]>>]"
                 The reason why start_tag is NOT "<DIV>>>" is because of the
                 rule 6. The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>"
                 is because of the rule 7.

    Example 3:
    Input: code = "<A>  <B> </A>   </B>"
    Output: false
    Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched,
                 and vice versa.

    Constraints:
    * 1 <= code.length <= 500
    * code consists of English letters, digits, '<', '>', '/', '!', '[', ']',
      '.', and ' '."""

    def isValid(self, code: str) -> bool:
        prefix = suffix = False
        stack = []
        i = 0
        while i < len(code):
            if code[i:i+2] == '</':
                ii = i = i+2
                for i in range(i, len(code)):
                    if code[i] == '>': break
                else: return False
                if i == len(code)-1: suffix = True
                tag = code[ii:i]
                if not stack or stack[-1] != tag: return False
                stack.pop()
                if not stack and not suffix: return False
            elif code[i:i+3] == '<![':
                ii = i = i+3
                buffer = 1
                for i in range(i, len(code)):
                    if code[i] == '[':
                        if buffer:
                            buffer = 0
                            if code[ii:i] != "CDATA": return False
                    elif code[i:i+3] == ']]>':
                        if buffer: return False
                        break
                else: return False
            elif code[i] == '<':
                ii = i = i+1
                for i in range(i, len(code)):
                    if code[i] == '>': break
                else: return False
                if ii == 1: prefix = True
                tag = code[ii:i]
                if not (all(map(str.isupper, tag)) and 1 <= len(tag) <= 9): return False
                stack.append(tag)
            i += 1
        return prefix and suffix and not stack


    """594. Longest Harmonious Subsequence (Easy)
    We define a harmonious array as an array where the difference between its
    maximum value and its minimum value is exactly 1. Given an integer array
    nums, return the length of its longest harmonious subsequence among all its
    possible subsequences. A subsequence of array is a sequence that can be
    derived from the array by deleting some or no elements without changing the
    order of the remaining elements.

    Example 1:
    Input: nums = [1,3,2,2,5,2,3,7]
    Output: 5
    Explanation: The longest harmonious subsequence is [3,2,2,2,3].

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 2

    Example 3:
    Input: nums = [1,1,1,1]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * -10^9 <= nums[i] <= 10^9"""

    def findLHS(self, nums: List[int]) -> int:
        freq = {}
        for x in nums: freq[x] = 1 + freq.get(x, 0)

        ans = 0
        for x in nums:
            if x + 1 in freq: ans = max(ans, freq[x] + freq[x+1])
        return ans


    """598. Range Addition II (Easy)
    You are given an m x n matrix M initialized with all 0's and an array of
    operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented
    by one for all 0 <= x < ai and 0 <= y < bi. Count and return the number of
    maximum integers in the matrix after performing all the operations.

    Example 1:
    Input: m = 3, n = 3, ops = [[2,2],[3,3]]
    Output: 4
    Explanation: The maximum integer in M is 2, and there are four of it in M.
                 So return 4.

    Example 2:
    Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],
                                [3,3],[2,2],[3,3],[3,3],[3,3]]
    Output: 4

    Example 3:
    Input: m = 3, n = 3, ops = []
    Output: 9

    Constraints:
    * 1 <= m, n <= 4 * 10^4
    * 1 <= ops.length <= 10^4
    * ops[i].length == 2
    * 1 <= ai <= m
    * 1 <= bi <= n"""

    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        for x, y in ops:
            m = min(m, x)
            n = min(n, y)
        return m * n


    """600. Non-negative Integers without Consecutive Ones (Hard)
    Given a positive integer n, return the number of the integers in the range
    [0, n] whose binary representations do not contain consecutive ones.

    Example 1:
    Input: n = 5
    Output: 5
    Explanation: Here are the non-negative integers <= 5 with their
                 corresponding binary representations:
                 0 : 0
                 1 : 1
                 2 : 10
                 3 : 11
                 4 : 100
                 5 : 101
                 Among them, only integer 3 disobeys the rule (two consecutive
                 ones) and the other 5 satisfy the rule.

    Example 2:
    Input: n = 1
    Output: 2

    Example 3:
    Input: n = 2
    Output: 3

    Constraints: 1 <= n <= 10^9"""

    def findIntegers(self, n: int) -> int:
        fib = [1, 2]
        for _ in range(30): fib.append(fib[-2] + fib[-1])

        ans = prev = 0
        for i in range(31, -1, -1):
            if n & (1<<i):
                ans += fib[i]
                if prev: return ans
                else: prev = 1
            else: prev = 0
        return ans + 1


    """605. Can Place Flowers (Easy)
    You have a long flowerbed in which some of the plots are planted, and some
    are not. However, flowers cannot be planted in adjacent plots. Given an
    integer array flowerbed containing 0's and 1's, where 0 means empty and 1
    means not empty, and an integer n, return if n new flowers can be planted
    in the flowerbed without violating the no-adjacent-flowers rule.

    Example 1:
    Input: flowerbed = [1,0,0,0,1], n = 1
    Output: true

    Example 2:
    Input: flowerbed = [1,0,0,0,1], n = 2
    Output: false

    Constraints:
    * 1 <= flowerbed.length <= 2 * 10^4
    * flowerbed[i] is 0 or 1.
    * There are no two adjacent flowers in flowerbed.
    * 0 <= n <= flowerbed.length"""

    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        for i, x in enumerate(flowerbed):
            if x == 0 and (i == 0 or flowerbed[i-1] == 0) and (i+1 == len(flowerbed) or flowerbed[i+1] == 0):
                n -= 1
                flowerbed[i] = 1
        return n <= 0


    """611. Valid Triangle Number (Medium)
    Given an integer array nums, return the number of triplets chosen from the
    array that can make triangles if we take them as side lengths of a triangle.

    Example 1:
    Input: nums = [2,2,3,4]
    Output: 3
    Explanation: Valid combinations are:
                 2,3,4 (using the first 2)
                 2,3,4 (using the second 2)
                 2,2,3

    Example 2:
    Input: nums = [4,2,3,4]
    Output: 4

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 1000"""

    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        ans = 0
        for i in range(len(nums)):
            lo, hi = 0, i-1
            while lo < hi:
                if nums[lo] + nums[hi] > nums[i]:
                    ans += hi - lo
                    hi -= 1
                else: lo += 1
        return ans


    """616. Add Bold Tag in String (Medium)
    You are given a string s and an array of strings words. You should add a
    closed pair of bold tag <b> and </b> to wrap the substrings in s that exist
    in words.
    * If two such substrings overlap, you should wrap them together with only
      one pair of closed bold-tag.
    * If two substrings wrapped by bold tags are consecutive, you should
      combine them.
    Return s after adding the bold tags.

    Example 1:
    Input: s = "abcxyz123", words = ["abc","123"]
    Output: "<b>abc</b>xyz<b>123</b>"
    Explanation: The two strings of words are substrings of s as following:
                 "abcxyz123". We add <b> before each substring and </b> after
                 each substring.

    Example 2:
    Input: s = "aaabbb", words = ["aa","b"]
    Output: "<b>aaabbb</b>"
    Explanation: "aa" appears as a substring two times: "aaabbb" and "aaabbb".
                 "b" appears as a substring three times: "aaabbb", "aaabbb",
                 and "aaabbb". We add <b> before each substring and </b> after
                 each substring: "<b>a<b>a</b>a</b><b>b</b><b>b</b><b>b</b>".
                 Since the first two <b>'s overlap, we merge them:
                 "<b>aaa</b><b>b</b><b>b</b><b>b</b>". Since now the four <b>'s
                 are consecuutive, we merge them: "<b>aaabbb</b>".

    Constraints:
    * 1 <= s.length <= 1000
    * 0 <= words.length <= 100
    * 1 <= words[i].length <= 1000
    * s and words[i] consist of English letters and digits.
    * All the values of words are unique.

    Note: This question is the same as 758:
          https://leetcode.com/problems/bold-words-in-string/"""

    def addBoldTag(self, s: str, words: List[str]) -> str:
        line = [0] * (len(s)+1)
        for word in words:
            k = -1
            while True:
                k = s.find(word, k+1)
                if k == -1: break
                line[k] += 1
                line[k+len(word)] -= 1
        ans = []
        prefix = 0
        for i in range(len(s)):
            if not prefix and prefix + line[i]: ans.append("<b>")
            ans.append(s[i])
            prefix += line[i]
            if prefix and not prefix + line[i+1]: ans.append("</b>")
        return "".join(ans)


    """617. Merge Two Binary Trees (Easy)
    You are given two binary trees root1 and root2. Imagine that when you put
    one of them to cover the other, some nodes of the two trees are overlapped
    while the others are not. You need to merge the two trees into a new binary
    tree. The merge rule is that if two nodes overlap, then sum node values up
    as the new value of the merged node. Otherwise, the NOT null node will be
    used as the node of the new tree. Return the merged tree. Note: The merging
    process must start from the root nodes of both trees.

    Example 1:
    Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
    Output: [3,4,5,5,4,null,7]

    Example 2:
    Input: root1 = [1], root2 = [1,2]
    Output: [2,2]

    Constraints:
    * The number of nodes in both trees is in the range [0, 2000].
    * -10^4 <= Node.val <= 10^4"""

    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if root1 and root2: return TreeNode(root1.val + root2.val, self.mergeTrees(root1.left, root2.left), self.mergeTrees(root1.right, root2.right))
        return root1 or root2


    """623. Add One Row to Tree (Medium)
    Given the root of a binary tree and two integers val and depth, add a row of
    nodes with value val at the given depth depth. Note that the root node is at
    depth 1. The adding rule is:
    * Given the integer depth, for each not null tree node cur at the depth
      depth - 1, create two tree nodes with value val as cur's left subtree root
      and right subtree root.
    * cur's original left subtree should be the left subtree of the new left
      subtree root.
    * cur's original right subtree should be the right subtree of the new right
      subtree root.
    * If depth == 1 that means there is no depth depth - 1 at all, then create a
      tree node with value val as the new root of the whole original tree, and
      the original tree is the new root's left subtree.

    Example 1:
    Input: root = [4,2,6,3,1,5], val = 1, depth = 2
    Output: [4,1,1,2,null,null,6,3,1,5]

    Example 2:
    Input: root = [4,2,null,3,1], val = 1, depth = 3
    Output: [4,2,null,1,1,3,null,null,1]

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * The depth of the tree is in the range [1, 10^4].
    * -100 <= Node.val <= 100
    * -10^5 <= val <= 10^5
    * 1 <= depth <= the depth of tree + 1"""

    def addOneRow(self, root: Optional[TreeNode], val: int, depth: int) -> Optional[TreeNode]:
        if depth == 1: return TreeNode(val, left=root)
        queue = deque([root])
        while queue and depth-1 > 1:
            depth -= 1
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
        for node in queue:
            node.left = TreeNode(val, left=node.left)
            node.right = TreeNode(val, right=node.right)
        return root


    """624. Maximum Distance in Arrays (Medium)
    You are given m arrays, where each array is sorted in ascending order. You
    can pick up two integers from two different arrays (each array picks one)
    and calculate the distance. We define the distance between two integers a
    and b to be their absolute difference |a - b|. Return the maximum distance.

    Example 1:
    Input: arrays = [[1,2,3],[4,5],[1,2,3]]
    Output: 4
    Explanation: One way to reach the maximum distance 4 is to pick 1 in the
                 first or third array and pick 5 in the second array.

    Example 2:
    Input: arrays = [[1],[1]]
    Output: 0

    Constraints:
    * m == arrays.length
    * 2 <= m <= 10^5
    * 1 <= arrays[i].length <= 500
    * -10^4 <= arrays[i][j] <= 10^4
    * arrays[i] is sorted in ascending order.
    * There will be at most 10^5 integers in all the arrays."""

    def maxDistance(self, arrays: List[List[int]]) -> int:
        ans = 0
        small = inf
        large = -inf
        for array in arrays:
            ans = max(ans, array[-1] - small, large - array[0])
            small = min(small, array[0])
            large = max(large, array[-1])
        return ans


    """625. Minimum Factorization (Medium)
    Given a positive integer num, return the smallest positive integer x whose
    multiplication of each digit equals num. If there is no answer or the
    answer is not fit in 32-bit signed integer, return 0.

    Example 1:
    Input: num = 48
    Output: 68

    Example 2:
    Input: num = 15
    Output: 35

    Constraints: 1 <= num <= 2^31 - 1"""

    def smallestFactorization(self, num: int) -> int:
        if num == 1: return 1 # edge case
        ans, mult = 0, 1
        for x in range(9, 1, -1):
            while num % x == 0:
                num //= x
                ans = ans + mult * x
                mult *= 10
        return ans if num == 1 and ans < (1 << 31) else 0


    """629. K Inverse Pairs Array (Hard)
    For an integer array nums, an inverse pair is a pair of integers [i, j]
    where 0 <= i < j < nums.length and nums[i] > nums[j]. Given two integers n
    and k, return the number of different arrays consist of numbers from 1 to n
    such that there are exactly k inverse pairs. Since the answer can be huge,
    return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, k = 0
    Output: 1
    Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3
                 has exactly 0 inverse pairs.

    Example 2:
    Input: n = 3, k = 1
    Output: 2
    Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.

    Constraints:
    * 1 <= n <= 1000
    * 0 <= k <= 1000"""

    def kInversePairs(self, n: int, k: int) -> int:

        @cache
        def fn(n, k):
            """Return number of ways for n numbers with k inverse pairs."""
            if k == 0: return 1
            if n <= 0 or k < 0: return 0
            return fn(n-1, k) + fn(n, k-1) - fn(n-1, k-n)

        return fn(n, k) % 1_000_000_007


    """630. Course Schedule III (Hard)
    There are n different online courses numbered from 1 to n. You are given an
    array courses where courses[i] = [durationi, lastDayi] indicate that the ith
    course should be taken continuously for durationi days and must be finished
    before or on lastDayi. You will start on the 1st day and you cannot take two
    or more courses simultaneously. Return the maximum number of courses that
    you can take.

    Example 1:
    Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]
    Output: 3
    Explanation: There are totally 4 courses, but you can take 3 courses at most:
                 - First, take the 1st course, it costs 100 days so you will
                   finish it on the 100th day, and ready to take the next course
                   on the 101st day.
                 - Second, take the 3rd course, it costs 1000 days so you will
                   finish it on the 1100th day, and ready to take the next
                   course on the 1101st day.
                 - Third, take the 2nd course, it costs 200 days so you will
                   finish it on the 1300th day.
                 - The 4th course cannot be taken now, since you will finish it
                   on the 3300th day, which exceeds the closed date.

    Example 2:
    Input: courses = [[1,2]]
    Output: 1

    Example 3:
    Input: courses = [[3,2],[4,3]]
    Output: 0

    Constraints:
    * 1 <= courses.length <= 10^4
    * 1 <= durationi, lastDayi <= 10^4"""

    def scheduleCourse(self, courses: List[List[int]]) -> int:
        prefix = 0
        pq = [] # max-heap
        for x, y in sorted(courses, key=lambda x: x[1]):
            prefix += x
            heappush(pq, -x)
            if prefix > y: prefix += heappop(pq)
        return len(pq)


    """632. Smallest Range Covering Elements from K Lists (Hard)
    You have k lists of sorted integers in non-decreasing order. Find the
    smallest range that includes at least one number from each of the k lists.
    We define the range [a, b] is smaller than range [c, d] if b - a < d - c or
    a < c if b - a == d - c.

    Example 1:
    Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]
    Output: [20,24]
    Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
                 List 2: [0, 9, 12, 20], 20 is in range [20,24].
                 List 3: [5, 18, 22, 30], 22 is in range [20,24].

    Example 2:
    Input: nums = [[1,2,3],[1,2,3],[1,2,3]]
    Output: [1,1]

    Example 3:
    Input: nums = [[10,10],[11,11]]
    Output: [10,11]

    Example 4:
    Input: nums = [[10],[11]]
    Output: [10,11]

    Example 5:
    Input: nums = [[1],[2],[3],[4],[5],[6],[7]]
    Output: [1,7]

    Constraints:
    * nums.length == k
    * 1 <= k <= 3500
    * 1 <= nums[i].length <= 50
    * -10^5 <= nums[i][j] <= 10^5
    * nums[i] is sorted in non-decreasing order."""

    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        hi = -inf
        pq = []
        for i, num in enumerate(nums):
            heappush(pq, (num[0], i, 0))
            hi = max(hi, num[0])

        ans = [-inf, inf]
        while pq:
            ans = min(ans, [pq[0][0], hi], key=lambda x: (x[1]-x[0], x[0]))
            _, i, j = heappop(pq)
            if j+1 == len(nums[i]): break
            hi = max(hi, nums[i][j+1])
            heappush(pq, (nums[i][j+1], i, j+1))
        return ans


    """633. Sum of Square Numbers (Medium)
    Given a non-negative integer c, decide whether there're two integers a and
    b such that a^2 + b^2 = c.

    Example 1:
    Input: c = 5
    Output: true
    Explanation: 1 * 1 + 2 * 2 = 5

    Example 2:
    Input: c = 3
    Output: false

    Example 3:
    Input: c = 4
    Output: true

    Example 4:
    Input: c = 2
    Output: true

    Example 5:
    Input: c = 1
    Output: true

    Constraints: 0 <= c <= 2^31 - 1"""

    def judgeSquareSum(self, c: int) -> bool:
        # Fermat theorem on sum of two squares
        for x in range(2, isqrt(c)+1):
            if c % x == 0:
                mult = 0
                while c % x == 0:
                    mult += 1
                    c //= x
                if x % 4 == 3 and mult & 1: return False
        return c % 4 != 3


    """634. Find the Derangement of An Array (Medium)
    In combinatorial mathematics, a derangement is a permutation of the
    elements of a set, such that no element appears in its original position.
    You are given an integer n. There is originally an array consisting of n
    integers from 1 to n in ascending order, return the number of derangements
    it can generate. Since the answer may be huge, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3
    Output: 2
    Explanation: The original array is [1,2,3]. The two derangements are
                 [2,3,1] and [3,1,2].

    Example 2:
    Input: n = 2
    Output: 1

    Constraints: 1 <= n <= 10^6"""

    def findDerangement(self, n: int) -> int:
        f0, f1 = 1, 0
        for i in range(2, n+1):
            f0, f1 = f1, (i-1) * (f0+f1) % 1_000_000_007
        return f1


    """639. Decode Ways II (Hard)
    A message containing letters from A-Z can be encoded into numbers using the
    following mapping:
    'A' -> "1"
    'B' -> "2"
    ...
    'Z' -> "26"
    To decode an encoded message, all the digits must be grouped then mapped
    back into letters using the reverse of the mapping above (there may be
    multiple ways). For example, "11106" can be mapped into:
    * "AAJF" with the grouping (1 1 10 6)
    * "KJF" with the grouping (11 10 6)
    Note that the grouping (1 11 06) is invalid because "06" cannot be mapped
    into 'F' since "6" is different from "06". In addition to the mapping above,
    an encoded message may contain the '*' character, which can represent any
    digit from '1' to '9' ('0' is excluded). For example, the encoded message
    "1*" may represent any of the encoded messages "11", "12", "13", "14", "15",
    "16", "17", "18", or "19". Decoding "1*" is equivalent to decoding any of
    the encoded messages it can represent. Given a string s consisting of
    digits and '*' characters, return the number of ways to decode it. Since
    the answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: s = "*"
    Output: 9
    Explanation: The encoded message can represent any of the encoded messages
                 "1", "2", "3", "4", "5", "6", "7", "8", or "9". Each of these
                 can be decoded to the strings "A", "B", "C", "D", "E", "F",
                 "G", "H", and "I" respectively. Hence, there are a total of 9
                 ways to decode "*".

    Example 2:
    Input: s = "1*"
    Output: 18
    Explanation: The encoded message can represent any of the encoded messages
                 "11", "12", "13", "14", "15", "16", "17", "18", or "19". Each
                 of these encoded messages have 2 ways to be decoded (e.g. "11"
                 can be decoded to "AA" or "K"). Hence, there are a total of
                 9 * 2 = 18 ways to decode "1*".

    Example 3:
    Input: s = "2*"
    Output: 15
    Explanation: The encoded message can represent any of the encoded messages
                 "21", "22", "23", "24", "25", "26", "27", "28", or "29". "21",
                 "22", "23", "24", "25", and "26" have 2 ways of being decoded,
                 but "27", "28", and "29" only have 1 way. Hence, there are a
                 total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode "2*".

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is a digit or '*'."""

    def numDecodings(self, s: str) -> int:

        @cache
        def fn(i):
            """Return decode ways."""
            if i == len(s): return 1
            if s[i] == "0": return 0
            if i == len(s)-1: return 9 if s[i] == '*' else 1
            if s[i] == "*":
                ans = 9*fn(i+1)
                if s[i+1] == "*": ans += 15*fn(i+2)
                else:
                    ans += fn(i+2)
                    if s[i+1] <= "6": ans += fn(i+2)
            else:
                ans = fn(i+1)
                if s[i+1] == "*":
                    if s[i] == "1": ans += 9*fn(i+2)
                    elif s[i] == "2": ans += 6*fn(i+2)
                elif int(s[i:i+2]) <= 26: ans += fn(i+2)
            return ans % 1_000_000_007

        return fn(0)


    """644. Maximum Average Subarray II (Hard)
    You are given an integer array nums consisting of n elements, and an
    integer k. Find a contiguous subarray whose length is greater than or equal
    to k that has the maximum average value and return this value. Any answer
    with a calculation error less than 10-5 will be accepted.

    Example 1:
    Input: nums = [1,12,-5,-6,50,3], k = 4
    Output: 12.75000
    Explanation: - When the length is 4, averages are [0.5, 12.75, 10.5] and
                   the maximum average is 12.75
                 - When the length is 5, averages are [10.4, 10.8] and the
                   maximum average is 10.8
                 - When the length is 6, averages are [9.16667] and the maximum
                   average is 9.16667
                 The maximum average is when we choose a subarray of length 4
                 (i.e., the sub array [12, -5, -6, 50]) which has the max
                 average 12.75, so we return 12.75. Note that we do not
                 consider the subarrays of length < 4.

    Example 2:
    Input: nums = [5], k = 1
    Output: 5.00000

    Constraints:
    * n == nums.length
    * 1 <= k <= n <= 10^4
    * -10^4 <= nums[i] <= 10^4"""

    def findMaxAverage(self, nums: List[int], k: int) -> float:
        lo, hi = -1e4, 1e4
        while lo+1e-5 <= hi:
            mid = (lo + hi)/2
            lag = prefix = 0
            for i, x in enumerate(nums):
                prefix += x - mid
                if i >= k: lag += nums[i-k] - mid
                if lag < 0:
                    prefix -= lag
                    lag = 0
                if i >= k-1 and prefix >= 0: break
            else:
                hi = mid
                continue
            lo = mid
        return lo


    """645. Set Mismatch (Easy)
    You have a set of integers s, which originally contains all the numbers
    from 1 to n. Unfortunately, due to some error, one of the numbers in s got
    duplicated to another number in the set, which results in repetition of one
    number and loss of another number. You are given an integer array nums
    representing the data status of this set after the error. Find the number
    that occurs twice and the number that is missing and return them in the
    form of an array.

    Example 1:
    Input: nums = [1,2,2,4]
    Output: [2,3]

    Example 2:
    Input: nums = [1,1]
    Output: [1,2]

    Constraints:
    * 2 <= nums.length <= 10^4
    * 1 <= nums[i] <= 10^4"""

    def findErrorNums(self, nums: List[int]) -> List[int]:
        freq = [0]*len(nums)
        for x in nums: freq[x-1] += 1

        ans = [0]*2
        for i, x in enumerate(freq):
            if x == 2: ans[0] = i+1
            elif x == 0: ans[1] = i+1
        return ans


    """648. Replace Words (Medium)
    In English, we have a concept called root, which can be followed by some
    other word to form another longer word - let's call this word derivative.
    For example, when the root "help" is followed by the word "ful", we can form
    a derivative "helpful". Given a dictionary consisting of many roots and a
    sentence consisting of words separated by spaces, replace all the
    derivatives in the sentence with the root forming it. If a derivative can be
    replaced by more than one root, replace it with the root that has the
    shortest length. Return the sentence after the replacement.

    Example 1:
    Input: dictionary = ["cat","bat","rat"],
           sentence = "the cattle was rattled by the battery"
    Output: "the cat was rat by the bat"

    Example 2:
    Input: dictionary = ["a","b","c"],
           sentence = "aadsfasf absbs bbab cadsfafs"
    Output: "a a b c"

    Constraints:
    * 1 <= dictionary.length <= 1000
    * 1 <= dictionary[i].length <= 100
    * dictionary[i] consists of only lower-case letters.
    * 1 <= sentence.length <= 106
    * sentence consists of only lower-case letters and spaces.
    * The number of words in sentence is in the range [1, 1000]
    * The length of each word in sentence is in the range [1, 1000]
    * Every two consecutive words in sentence will be separated by exactly one
      space.
    * sentence does not have leading or trailing spaces."""

    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie = {}
        for word in dictionary:
            node = trie
            for ch in word:
                node = node.setdefault(ch, {})
            node["#"] = word
        ans = []
        for word in sentence.split():
            node = trie
            for ch in word:
                node = node.get(ch)
                if not node or "#" in node:
                    if node: word = node["#"]
                    break
            ans.append(word)
        return " ".join(ans)


    """650. 2 Keys Keyboard (Medium)
    Initially on a notepad only one character 'A' is present. You can perform
    two operations on this notepad for each step:
    * Copy All: You can copy all the characters present on the notepad (partial
      copy is not allowed).
    * Paste: You can paste the characters which are copied last time.

    Given a number n. You have to get exactly n 'A' on the notepad by
    performing the minimum number of steps permitted. Output the minimum number
    of steps to get n 'A'.

    Example 1:
    Input: 3
    Output: 3
    Explanation: Intitally, we have one character 'A'.
    In step 1, we use Copy All operation.
    In step 2, we use Paste operation to get 'AA'.
    In step 3, we use Paste operation to get 'AAA'.

    Note: The n will be in the range [1, 1000]."""

    def minSteps(self, n: int) -> int:
        dp = list(range(n+1))
        dp[1] = 0
        for x in range(2, n+1):
            for p in range(2, isqrt(x)+1):
                if x % p == 0:
                    dp[x] = min(dp[x], dp[x//p] + p)
        return dp[-1]


    """651. 4 Keys Keyboard (Medium)
    Imagine you have a special keyboard with the following keys:
    * A: Print one 'A' on the screen.
    * Ctrl-A: Select the whole screen.
    * Ctrl-C: Copy selection to buffer.
    * Ctrl-V: Print buffer on screen appending it after what has already been
      printed.
    Given an integer n, return the maximum number of 'A' you can print on the
    screen with at most n presses on the keys.

    Example 1:
    Input: n = 3
    Output: 3
    Explanation: We can at most get 3 A's on screen by pressing the following
                 key sequence: A, A, A

    Example 2:
    Input: n = 7
    Output: 9
    Explanation: We can at most get 9 A's on screen by pressing following key
                 sequence: A, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V

    Constraints: 1 <= n <= 50"""

    def maxA(self, n: int) -> int:
        dp = [0, 1]
        for x in range(2, n+1):
            dp.append(1 + dp[x-1])
            for xx in range(x-2): dp[x] = max(dp[x], dp[xx]*(x-xx-1))
        return dp[n]


    """653. Two Sum IV - Input is a BST (Easy)
    Given the root of a Binary Search Tree and a target number k, return true
    if there exist two elements in the BST such that their sum is equal to the
    given target.

    Example 1:
    Input: root = [5,3,6,2,4,null,7], k = 9
    Output: true

    Example 2:
    Input: root = [5,3,6,2,4,null,7], k = 28
    Output: false

    Example 3:
    Input: root = [2,1,3], k = 4
    Output: true

    Example 4:
    Input: root = [2,1,3], k = 1
    Output: false

    Example 5:
    Input: root = [2,1,3], k = 3
    Output: true

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -10^4 <= Node.val <= 10^4
    * root is guaranteed to be a valid binary search tree.
    * -10^5 <= k <= 10^5"""

    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:

        def fn(node, tf):
            if node:
                yield from fn(node.left, tf) if tf else fn(node.right, tf)
                yield node.val
                yield from fn(node.right, tf) if tf else fn(node.left, tf)

        fit = fn(root, 1) # forward iterator
        bit = fn(root, 0) # backward iterator
        lo, hi = next(fit), next(bit)
        while lo < hi:
            sm = lo + hi
            if sm < k: lo = next(fit)
            elif sm == k: return True
            else: hi = next(bit)
        return False


    """654. Maximum Binary Tree (Medium)
    Given an integer array with no duplicates. A maximum tree building on this
    array is defined as follow:
    * The root is the maximum number in the array.
    * The left subtree is the maximum tree constructed from left part subarray
      divided by the maximum number.
    * The right subtree is the maximum tree constructed from right part
      subarray divided by the maximum number.
    Construct the maximum tree by the given array and output the root node of
    this tree.

    Example 1:
    Input: [3,2,1,6,0,5]
    Output: return the tree root node representing the following tree:
          6
        /   \
       3     5
        \    /
         2  0
           \
            1
    Note: The size of the given array will be in the range [1,1000]."""

    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        stack = []
        for x in nums:
            node = TreeNode(x)
            while stack and stack[-1].val < x: node.left = stack.pop()
            if stack: stack[-1].right = node
            stack.append(node)
        return stack[0]


    """655. Print Binary Tree (Medium)
    Print a binary tree in an m*n 2D string array following these rules:
    1 The row number m should be equal to the height of the given binary tree.
    2 The column number n should always be an odd number.
    3 The root node's value (in string format) should be put in the exactly
      middle of the first row it can be put. The column and the row where the
      root node belongs will separate the rest space into two parts (left-
      bottom part and right-bottom part). You should print the left subtree in
      the left-bottom part and print the right subtree in the right-bottom part.
      The left-bottom part and the right-bottom part should have the same size.
      Even if one subtree is none while the other is not, you don't need to
      print anything for the none subtree but still need to leave the space as
      large as that for the other subtree. However, if two subtrees are none,
      then you don't need to leave space for both of them.
    4 Each unused space should contain an empty string "".
    5 Print the subtrees following the same rules.

    Example 1:
    Input:
         1
        /
       2
    Output:
    [["", "1", ""],
     ["2", "", ""]]

    Example 2:
    Input:
         1
        / \
       2   3
        \
         4
    Output:
    [["", "", "", "1", "", "", ""],
     ["", "2", "", "", "", "3", ""],
     ["", "", "4", "", "", "", ""]]

    Example 3:
    Input:
          1
         / \
        2   5
       /
      3
     /
    4
    Output:
    [["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]
     ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]
     ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]
     ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]

    Note: The height of binary tree is in the range of [1, 10]."""

    def printTree(self, root: TreeNode) -> List[List[str]]:
        ht = lambda node: 1 + max(ht(node.left), ht(node.right)) if node else 0 # height of binary tree
        m = ht(root) # rows
        n = 2**m - 1 # columns

        def dfs(node, i, lo=0, hi=n):
            """Populate ans via dfs."""
            if not node: return
            mid = lo + hi >> 1
            ans[i][mid] = str(node.val)
            dfs(node.left, i+1, lo, mid) or dfs(node.right, i+1, mid+1, hi)

        ans = [[""]*n for _ in range(m)]
        dfs(root, 0)
        return ans


    """656. Coin Path (Hard)
    You are given an integer array coins (1-indexed) of length n and an integer
    maxJump. You can jump to any index i of the array coins if coins[i] != -1
    and you have to pay coins[i] when you visit index i. In addition to that,
    if you are currently at index i, you can only jump to any index i + k where
    i + k <= n and k is a value in the range [1, maxJump]. You are initially
    positioned at index 1 (coins[1] is not -1). You want to find the path that
    reaches index n with the minimum cost. Return an integer array of the
    indices that you will visit in order so that you can reach index n with the
    minimum cost. If there are multiple paths with the same cost, return the
    lexicographically smallest such path. If it is not possible to reach index
    n, return an empty array. A path p1 = [Pa1, Pa2, ..., Pax] of length x is
    lexicographically smaller than p2 = [Pb1, Pb2, ..., Pbx] of length y, if
    and only if at the first j where Paj and Pbj differ, Paj < Pbj; when no
    such j exists, then x < y.

    Example 1:
    Input: coins = [1,2,4,-1,2], maxJump = 2
    Output: [1,3,5]

    Example 2:
    Input: coins = [1,2,4,-1,2], maxJump = 1
    Output: []

    Constraints:
    * 1 <= coins.length <= 1000
    * -1 <= coins[i] <= 100
    * coins[1] != -1
    * 1 <= maxJump <= 100"""

    def cheapestJump(self, coins: List[int], maxJump: int) -> List[int]:
        n = len(coins)
        dp = [-1]*n
        if coins[-1] != -1: dp[-1] = coins[-1]
        jump = [-1]*n
        for i in range(n-2, -1, -1):
            if coins[i] != -1:
                for ii in range(min(n-1, i+maxJump), i, -1):
                    if dp[ii] != -1:
                        cand = coins[i] + dp[ii]
                        if dp[i] == -1 or cand <= dp[i]:
                            dp[i] = cand
                            jump[i] = ii
        ans = []
        if dp[0] != -1:
            i = 0
            while i >= 0:
                ans.append(i+1)
                i = jump[i]
        return ans


    """658. Find K Closest Elements (Medium)
    Given a sorted array arr, two integers k and x, find the k closest elements
    to x in the array. The result should also be sorted in ascending order. If
    there is a tie, the smaller elements are always preferred.

    Example 1:
    Input: arr = [1,2,3,4,5], k = 4, x = 3
    Output: [1,2,3,4]

    Example 2:
    Input: arr = [1,2,3,4,5], k = 4, x = -1
    Output: [1,2,3,4]

    Constraints:
    * 1 <= k <= arr.length
    * 1 <= arr.length <= 10^4
    * Absolute value of elements in the array and x will not exceed 10^4"""

    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        lo, hi = 0, len(arr)-k
        while lo < hi:
            mid = lo + hi >> 1
            if x - arr[mid] > arr[mid+k] - x: lo = mid + 1
            else: hi = mid
        return arr[lo:lo+k]


    """659. Split Array into Consecutive Subsequences (Medium)
    Given an array nums sorted in ascending order, return true if and only if
    you can split it into 1 or more subsequences such that each subsequence
    consists of consecutive integers and has length at least 3.

    Example 1:
    Input: [1,2,3,3,4,5]
    Output: True
    Explanation: You can split them into two consecutive subsequences :
    1, 2, 3
    3, 4, 5

    Example 2:
    Input: [1,2,3,3,4,4,5,5]
    Output: True
    Explanation: You can split them into two consecutive subsequences :
    1, 2, 3, 4, 5
    3, 4, 5

    Example 3:
    Input: [1,2,3,4,4,5]
    Output: False

    Constraints: 1 <= nums.length <= 10000"""

    def isPossible(self, nums: List[int]) -> bool:
        freq = {}
        for x in nums: freq[x] = 1 + freq.get(x, 0) # frequency table of nums

        seen = deque()
        for i, x in enumerate(nums):
            if i == 0 or nums[i-1] != x:
                if (n := freq[x] - freq.get(x-1, 0)) > 0: seen.extend([x]*n)
                elif any(x - seen.popleft() < 3 for _ in range(-n)): return False
                if not freq.get(x+1, 0) and any(x - seen.popleft() < 2 for _ in range(freq[x])): return False
        return True


    """660. Remove 9 (Hard)
    Start from integer 1, remove any integer that contains 9 such as 9, 19, 29...
    Now, you will have a new integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...].
    Given an integer n, return the nth (1-indexed) integer in the new sequence.

    Example 1:
    Input: n = 9
    Output: 10

    Example 2:
    Input: n = 10
    Output: 11

    Constraints: 1 <= n <= 8 * 10^8"""

    def newInteger(self, n: int) -> int:
        ans = 0
        base = 1
        while n:
            ans = n%9 * base + ans
            n //= 9
            base *= 10
        return ans


    """662. Maximum Width of Binary Tree (Medium)
    Given a binary tree, write a function to get the maximum width of the given
    tree. The maximum width of a tree is the maximum width among all levels.
    The width of one level is defined as the length between the end-nodes (the
    leftmost and right most non-null nodes in the level, where the null nodes
    between the end-nodes are also counted into the length calculation. It is
    guaranteed that the answer will in the range of 32-bit signed integer.

    Example 1:
    Input:
               1
             /   \
            3     2
           / \     \
          5   3     9
    Output: 4
    Explanation: The maximum width existing in the third level with the length
                 4 (5,3,null,9).

    Example 2:
    Input:
              1
             /
            3
           / \
          5   3
    Output: 2
    Explanation: The maximum width existing in the third level with the length
                 2 (5,3).

    Example 3:
    Input:
              1
             / \
            3   2
           /
          5
    Output: 2
    Explanation: The maximum width existing in the second level with the length
                 2 (3,2).

    Example 4:
    Input:
              1
             / \
            3   2
           /     \
          5       9
         /         \
        6           7
    Output: 8
    Explanation:The maximum width existing in the fourth level with the length
                8 (6,null,null,null,null,null,null,7).

    Constraints: The given binary tree will have between 1 and 3000 nodes."""

    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans = 0
        queue = deque([(root, 0)])
        while queue:
            ans = max(ans, queue[-1][1] - queue[0][1] + 1)
            for _ in range(len(queue)):
                node, x = queue.popleft()
                if node.left: queue.append((node.left, 2*x))
                if node.right: queue.append((node.right, 2*x+1))
        return ans


    """663. Equal Tree Partition (Medium)
    Given the root of a binary tree, return true if you can partition the tree
    into two trees with equal sums of values after removing exactly one edge on
    the original tree.

    Example 1:
    Input: root = [5,10,10,null,null,2,3]
    Output: true

    Example 2:
    Input: root = [1,2,10,null,null,2,20]
    Output: false
    Explanation: You cannot split the tree into two trees with equal sums after
                 removing exactly one edge on the tree.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -10^5 <= Node.val <= 10^5"""

    def checkEqualTree(self, root: Optional[TreeNode]) -> bool:

        def fn(node):
            """Return sum of sub-tree."""
            if not node: return 0
            ans = node.val + fn(node.left) + fn(node.right)
            freq[ans] += 1
            return ans

        freq = defaultdict(int)
        total = fn(root)
        return not total and freq[total] > 1 or total and total % 2 == 0 and freq[total//2]


    """664. Strange Printer (Hard)
    There is a strange printer with the following two special properties:
    * The printer can only print a sequence of the same character each time.
    * At each turn, the printer can print new characters starting from and
      ending at any place and will cover the original existing characters.
    Given a string s, return the minimum number of turns the printer needed to
    print it.

    Example 1:
    Input: s = "aaabbb"
    Output: 2
    Explanation: Print "aaa" first and then print "bbb".

    Example 2:
    Input: s = "aba"
    Output: 2
    Explanation: Print "aaa" first and then print "b" from the second place of
                 the string, which will cover the existing character 'a'.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters."""

    def strangePrinter(self, s: str) -> int:
        n = len(s)
        dp = [[inf]*(n+1) for _ in range(n+1)]
        dp[n] = [0]*(n+1)
        for i in range(n-1, -1, -1):
            dp[i][i] = 0
            for j in range(i+1, n+1):
                dp[i][j] = 1 + dp[i+1][j]
                for k in range(i+1, j):
                    if s[i] == s[k]:
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
        return dp[0][n]


    """665. Non-decreasing Array (Medium)
    Given an array nums with n integers, your task is to check if it could
    become non-decreasing by modifying at most one element. We define an array
    is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based)
    such that (0 <= i <= n - 2).

    Example 1:
    Input: nums = [4,2,3]
    Output: true
    Explanation: You could modify the first 4 to 1 to get a non-decreasing array.

    Example 2:
    Input: nums = [4,2,1]
    Output: false
    Explanation: You can't get a non-decreasing array by modify at most one element.

    Constraints:
    n == nums.length
    1 <= n <= 10^4
    -10^5 <= nums[i] <= 10^5"""

    def checkPossibility(self, nums: List[int]) -> bool:
        cnt = 0
        for i in range(1, len(nums)):
            if nums[i-1] > nums[i]:
                if (i-1 == 0 or nums[i-2] <= nums[i]) or (i+1 == len(nums) or nums[i-1] <= nums[i+1]):
                    cnt += 1
                else: return False
        return cnt <= 1


    """666. Path Sum IV (Medium)
    If the depth of a tree is smaller than 5, then this tree can be represented
    by an array of three-digit integers. For each integer in this array:
    * The hundreds digit represents the depth d of this node where 1 <= d <= 4.
    * The tens digit represents the position p of this node in the level it
      belongs to where 1 <= p <= 8. The position is the same as that in a full
      binary tree.
    * The units digit represents the value v of this node where 0 <= v <= 9.
    Given an array of ascending three-digit integers nums representing a binary
    tree with a depth smaller than 5, return the sum of all paths from the root
    towards the leaves. It is guaranteed that the given array represents a
    valid connected binary tree.

    Example 1:
    Input: nums = [113,215,221]
    Output: 12
    Explanation: The tree that the list represents is shown. The path sum is
                 (3 + 5) + (3 + 1) = 12.

    Example 2:
    Input: nums = [113,221]
    Output: 4
    Explanation: The tree that the list represents is shown. The path sum is
                 (3 + 1) = 4.

    Constraints:
    * 1 <= nums.length <= 15
    * 110 <= nums[i] <= 489
    * nums represents a valid binary tree with depth less than 5."""

    def pathSum(self, nums: List[int]) -> int:
        tree = {}
        for num in nums:
            d, p, v = (int(x) for x in str(num))
            tree[d, p] = v

        ans = 0
        stack = [(1, 1, 0)]
        while stack:
            d, p, v = stack.pop()
            v += tree[d, p]
            dd, ll, rr = d+1, 2*p-1, 2*p
            if (dd, ll) not in tree and (dd, rr) not in tree: ans += v # leaf
            if (dd, ll) in tree: stack.append((dd, ll, v))
            if (dd, rr) in tree: stack.append((dd, rr, v))
        return ans


    """667. Beautiful Arrangement II (Medium)
    Given two integers n and k, you need to construct a list which contains n
    different positive integers ranging from 1 to n and obeys the following
    requirement:
    Suppose this list is [a1, a2, a3, ... , an], then the list
    [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct
    integers. If there are multiple answers, print any of them.

    Example 1:
    Input: n = 3, k = 1
    Output: [1, 2, 3]
    Explanation: The [1, 2, 3] has three different positive integers ranging
                 from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.

    Example 2:
    Input: n = 3, k = 2
    Output: [1, 3, 2]
    Explanation: The [1, 3, 2] has three different positive integers ranging
                 from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1
                 and 2.

    Note: The n and k are in the range 1 <= k < n <= 10^4."""

    def constructArray(self, n: int, k: int) -> List[int]:
        lo, hi = 1, n
        ans = []
        while lo <= hi:
            if k&1:
                ans.append(lo)
                lo += 1
            else:
                ans.append(hi)
                hi -= 1
            if k > 1: k -= 1
        return ans


    """668. Kth Smallest Number in Multiplication Table (Hard)
    Nearly everyone has used the Multiplication Table. The multiplication table
    of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed).
    Given three integers m, n, and k, return the kth smallest element in the
    m x n multiplication table.

    Example 1:
    Input: m = 3, n = 3, k = 5
    Output: 3
    Explanation: The 5th smallest number is 3.

    Example 2:
    Input: m = 2, n = 3, k = 6
    Output: 6
    Explanation: The 6th smallest number is 6.

    Constraints:
    * 1 <= m, n <= 3 * 10^4
    * 1 <= k <= m * n"""

    def findKthNumber(self, m: int, n: int, k: int) -> int:
        lo, hi = 1, m*n
        while lo < hi:
            mid = lo + hi >> 1
            cnt = sum(min(n, mid//(i+1)) for i in range(m))
            if cnt < k: lo = mid + 1
            else: hi = mid
        return lo


    """675. Cut Off Trees for Golf Event (Hard)
    You are asked to cut off all the trees in a forest for a golf event. The
    forest is represented as an m x n matrix. In this matrix:
    * 0 means the cell cannot be walked through.
    * 1 represents an empty cell that can be walked through.
    * A number greater than 1 represents a tree in a cell that can be walked
      through, and this number is the tree's height.
    In one step, you can walk in any of the four directions: north, east, south,
    and west. If you are standing in a cell with a tree, you can choose whether
    to cut it off. You must cut off the trees in order from shortest to tallest.
    When you cut off a tree, the value at its cell becomes 1 (an empty cell).
    Starting from the point (0, 0), return the minimum steps you need to walk
    to cut off all the trees. If you cannot cut off all the trees, return -1.
    You are guaranteed that no two trees have the same height, and there is at
    least one tree needs to be cut off.

    Example 1:
    Input: forest = [[1,2,3],[0,0,4],[7,6,5]]
    Output: 6
    Explanation: Following the path above allows you to cut off the trees from
                 shortest to tallest in 6 steps.

    Example 2:
    Input: forest = [[1,2,3],[0,0,0],[7,6,5]]
    Output: -1
    Explanation: The trees in the bottom row cannot be accessed as the middle
                 row is blocked.

    Example 3:
    Input: forest = [[2,3,4],[0,0,5],[8,7,6]]
    Output: 6
    Explanation: You can follow the same path as Example 1 to cut off all the
                 trees. Note that you can cut off the first tree at (0, 0)
                 before making any steps.

    Constraints:
    * m == forest.length
    * n == forest[i].length
    * 1 <= m, n <= 50
    * 0 <= forest[i][j] <= 10^9"""

    def cutOffTree(self, forest: List[List[int]]) -> int:
        m, n = len(forest), len(forest[0])

        def fn(start, end):
            """Return min steps to move from start to end."""
            ans = 0
            seen = {start}
            queue = deque([start])
            while queue:
                for _ in range(len(queue)):
                    i, j = queue.popleft()
                    if (i, j) == end: return ans
                    for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                        if 0 <= ii < m and 0 <= jj < n and forest[ii][jj] != 0 and (ii, jj) not in seen:
                            seen.add((ii, jj))
                            queue.append((ii, jj))
                ans += 1
            return -1

        ans = 0
        start = (0, 0)
        for _, i, j in sorted((forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1):
            val = fn(start, (i, j))
            if val == -1: return -1
            ans += val
            start = (i, j)
        return ans


    """678. Valid Parenthesis String (Medium)
    Given a string containing only three types of characters: '(', ')' and '*',
    write a function to check whether this string is valid. We define the
    validity of a string by these rules:
    1) Any left parenthesis '(' must have a corresponding right parenthesis ')'.
    2) Any right parenthesis ')' must have a corresponding left parenthesis '('.
    3) Left parenthesis '(' must go before the corresponding right parenthesis ')'.
    4) '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.
    5) An empty string is also valid.

    Example 1:
    Input: "()"
    Output: True

    Example 2:
    Input: "(*)"
    Output: True

    Example 3:
    Input: "(*))"
    Output: True

    Note: The string size will be in the range [1, 100]."""

    def checkValidString(self, s):
        lower = upper = 0
        for ch in s:
            lower += 1 if ch == '(' else -min(1, lower)
            upper += 1 if ch in "(*" else -1
            if upper < 0: return False
        return lower == 0


    """679. 24 Game (Hard)
    You are given an integer array cards of length 4. You have four cards, each
    containing a number in the range [1, 9]. You should arrange the numbers on
    these cards in a mathematical expression using the operators
    ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.
    You are restricted with the following rules:
    * The division operator '/' represents real division, not integer division.
      + For example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.
    * Every operation done is between two numbers. In particular, we cannot use
      '-' as a unary operator.
      + For example, if cards = [1, 1, 1, 1], the expression "-1 - 1 - 1 - 1"
        is not allowed.
    * You cannot concatenate numbers together
      + For example, if cards = [1, 2, 1, 2], the expression "12 + 12" is not
        valid.
    Return true if you can get such expression that evaluates to 24, and false
    otherwise.

    Example 1:
    Input: cards = [4,1,8,7]
    Output: true
    Explanation: (8-4) * (7-1) = 24

    Example 2:
    Input: cards = [1,2,1,2]
    Output: false

    Constraints:
    * cards.length == 4
    * 1 <= cards[i] <= 9"""

    def judgePoint24(self, cards: List[int]) -> bool:

        @cache
        def fn(*args):
            """Return True if existing arguments can be combined into 24."""
            if len(args) == 1: return args[0] == 24
            for x, y, *rem in permutations(args):
                for op in add, sub, mul, Fraction:
                    if (op != Fraction or y != 0) and fn(op(x, y), *rem): return True
            return False

        return fn(*cards)


    """680. Valid Palindrome II (Easy)
    Given a string s, return true if the s can be palindrome after deleting at
    most one character from it.

    Example 1:
    Input: s = "aba"
    Output: true

    Example 2:
    Input: s = "abca"
    Output: true
    Explanation: You could delete the character 'c'.

    Example 3:
    Input: s = "abc"
    Output: false

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters."""

    def validPalindrome(self, s: str) -> bool:
        for i in range(len(s)//2):
            if s[i] != s[~i]:
                ss = s[i:~i+1 or None]
                return ss[1:] == ss[1:][::-1] or ss[:-1] == ss[:-1][::-1]
        return True


    """681. Next Closest Time (Medium)
    Given a time represented in the format "HH:MM", form the next closest time
    by reusing the current digits. There is no limit on how many times a digit
    can be reused. You may assume the given input string is always valid. For
    example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.

    Example 1:
    Input: time = "19:34"
    Output: "19:39"
    Explanation: The next closest time choosing from digits 1, 9, 3, 4, is
                 19:39, which occurs 5 minutes later. It is not 19:33, because
                 this occurs 23 hours and 59 minutes later.

    Example 2:
    Input: time = "23:59"
    Output: "22:22"
    Explanation: The next closest time choosing from digits 2, 3, 5, 9, is
                 22:22. It may be assumed that the returned time is next day's
                 time since it is smaller than the input time numerically.

    Constraints:
    * time.length == 5
    * time is a valid time in the form "HH:MM".
    * 0 <= HH < 24
    * 0 <= MM < 60"""

    def nextClosestTime(self, time: str) -> str:
        digit = sorted([time[0], time[1], time[3], time[4]])

        upper = ["2", "9", None, "5", "9"]
        if time[0] == "2": upper[1] = "3"

        suffix = ""
        for i in reversed(range(5)):
            if i == 2: suffix = ":" + suffix
            else:
                k = digit.index(time[i])
                for kk in range(k+1, 4):
                    if time[i] < digit[kk] <= upper[i]: return time[:i] + digit[kk] + suffix
                suffix = digit[0] + suffix
        return suffix


    """683. K Empty Slots (Hard)
    You have n bulbs in a row numbered from 1 to n. Initially, all the bulbs
    are turned off. We turn on exactly one bulb every day until all bulbs are
    on after n days. You are given an array bulbs of length n where
    bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at
    position x where i is 0-indexed and x is 1-indexed. Given an integer k,
    return the minimum day number such that there exists two turned on bulbs
    that have exactly k bulbs between them that are all turned off. If there
    isn't such day, return -1.

    Example 1:
    Input: bulbs = [1,3,2], k = 1
    Output: 2
    Explanation: - On the first day: bulbs[0] = 1, first bulb is turned on:
                   [1,0,0]
                 - On the second day: bulbs[1] = 3, third bulb is turned on:
                   [1,0,1]
                 - On the third day: bulbs[2] = 2, second bulb is turned on:
                   [1,1,1]
                 We return 2 because on the second day, there were two on
                 bulbs with one off bulb between them.

    Example 2:
    Input: bulbs = [1,2,3], k = 1
    Output: -1

    Constraints:
    * n == bulbs.length
    * 1 <= n <= 2 * 10^4
    * 1 <= bulbs[i] <= n
    * bulbs is a permutation of numbers from 1 to n.
    * 0 <= k <= 2 * 10^4"""

    def kEmptySlots(self, bulbs: List[int], k: int) -> int:
        n = len(bulbs)
        days = [0]*n
        for i, x in enumerate(bulbs): days[x-1] = i+1
        ans = inf
        i, lo, hi = 0, 0, k+1
        while hi < n:
            if days[lo] > days[i] or days[i] < days[hi] or i == hi:
                if i == hi: ans = min(ans, max(days[lo], days[hi]))
                lo, hi = i, i+k+1
            i += 1
        return -1 if ans == inf else ans


    """684. Redundant Connection (Medium)
    In this problem, a tree is an undirected graph that is connected and has no
    cycles. You are given a graph that started as a tree with n nodes labeled from
    1 to n, with one additional edge added. The added edge has two different
    vertices chosen from 1 to n, and was not an edge that already existed. The
    graph is represented as an array edges of length n where edges[i] = [ai, bi]
    indicates that there is an edge between nodes ai and bi in the graph. Return an
    edge that can be removed so that the resulting graph is a tree of n nodes. If
    there are multiple answers, return the answer that occurs last in the input.

    Example 1:
    Input: edges = [[1,2],[1,3],[2,3]]
    Output: [2,3]

    Example 2:
    Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
    Output: [1,4]

    Constraints:
    * n == edges.length
    * 3 <= n <= 1000
    * edges[i].length == 2
    * 1 <= ai < bi <= edges.length
    * ai != bi
    * There are no repeated edges.
    * The given graph is connected."""

    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        uf = UnionFind(len(edges))
        for u, v in edges:
            if not uf.union(u-1, v-1): return [u, v]


    """685. Redundant Connection II (Hard)
    In this problem, a rooted tree is a directed graph such that, there is
    exactly one node (the root) for which all other nodes are descendants of
    this node, plus every node has exactly one parent, except for the root node
    which has no parents. The given input is a directed graph that started as a
    rooted tree with n nodes (with distinct values from 1 to n), with one
    additional directed edge added. The added edge has two different vertices
    chosen from 1 to n, and was not an edge that already existed.  resulting
    graph is given as a 2D-array of edges. Each element of edges is a pair
    [ui, vi] that represents a directed edge connecting nodes ui and vi, where
    ui is a parent of child vi. Return an edge that can be removed so that the
    resulting graph is a rooted tree of n nodes. If there are multiple answers,
    return the answer that occurs last in the given 2D-array.

    Example 1:
    Input: edges = [[1,2],[1,3],[2,3]]
    Output: [2,3]

    Example 2:
    Input: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
    Output: [4,1]

    Constraints:
    * n == edges.length
    * 3 <= n <= 1000
    * edges[i].length == 2
    * 1 <= ui, vi <= n
    * ui != vi"""

    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        uf = UnionFind(n)
        mult = cycle = False
        parent = [0]*(n)
        for u, v in edges:
            if parent[v-1]:
                mult = True # seeing multiple parents
                cand0 = [parent[v-1], v]
                cand1 = [u, v]
            else:
                parent[v-1] = u
                if not uf.union(u-1, v-1):
                    cycle = True # seeing cycle
                    cand2 = [u, v]
        return cand0 if mult and cycle else cand1 if mult else cand2


    """686. Repeated String Match (Medium)
    Given two strings a and b, return the minimum number of times you should
    repeat string a so that string b is a substring of it. If it is impossible
    for b to be a substring of a after repeating it, return -1. Notice: string
    "abc" repeated 0 times is "",  repeated 1 time is "abc" and repeated 2
    times is "abcabc".

    Example 1:
    Input: a = "abcd", b = "cdabcdab"
    Output: 3
    Explanation: We return 3 because by repeating a three times "abcdabcdabcd",
                 b is a substring of it.

    Example 2:
    Input: a = "a", b = "aa"
    Output: 2

    Example 3:
    Input: a = "a", b = "a"
    Output: 1

    Example 4:
    Input: a = "abc", b = "wxyz"
    Output: -1

    Constraints:
    * 1 <= a.length <= 10^4
    * 1 <= b.length <= 10^4
    * a and b consist of lower-case English letters."""

    def repeatedStringMatch(self, a: str, b: str) -> int:
        n = ceil(len(b)/len(a)) # ceiling of len(b)/len(a)
        return next((n+i for i in range(2) if b in (n+i)*a), -1)


    """687. Longest Univalue Path (Medium)
    Given the root of a binary tree, return the length of the longest path,
    where each node in the path has the same value. This path may or may not
    pass through the root. The length of the path between two nodes is
    represented by the number of edges between them.

    Example 1:
    Input: root = [5,4,5,1,1,5]
    Output: 2

    Example 2:
    Input: root = [1,4,5,4,4,5]
    Output: 2

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * -1000 <= Node.val <= 1000
    * The depth of the tree will not exceed 1000."""

    def longestUnivaluePath(self, root: TreeNode) -> int:

        def dfs(node):
            """Return longest univalue branch and longest univalue path (post-order traversal)."""
            nonlocal ans
            if not node: return 0
            lx, rx = dfs(node.left), dfs(node.right)
            if not node.left or node.left.val != node.val: lx = 0
            if not node.right or node.right.val != node.val: rx = 0
            ans = max(ans, 1 + lx + rx)
            return 1 + max(lx, rx)

        ans = 0
        dfs(root)
        return max(0, ans-1)


    """688. Knight Probability in Chessboard (Medium)
    On an NxN chessboard, a knight starts at the r-th row and c-th column and
    attempts to make exactly K moves. The rows and columns are 0 indexed, so
    the top-left square is (0, 0), and the bottom-right square is (N-1, N-1). A
    chess knight has 8 possible moves it can make, as illustrated below. Each
    move is two squares in a cardinal direction, then one square in an
    orthogonal direction. Each time the knight is to move, it chooses one of
    eight possible moves uniformly at random (even if the piece would go off
    the chessboard) and moves there. The knight continues moving until it has
    made exactly K moves or has moved off the chessboard. Return the
    probability that the knight remains on the board after it has stopped
    moving.

    Example:
    Input: 3, 2, 0, 0
    Output: 0.0625
    Explanation: There are two moves (to (1,2), (2,1)) that will keep the
                 knight on the board. From each of those positions, there are
                 also two moves that will keep the knight on the board. The
                 total probability the knight stays on the board is 0.0625.

    Note:
    * N will be between 1 and 25.
    * K will be between 0 and 100.
    * The knight always initially starts on the board."""

    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:

        @cache
        def fn(k, i, j):
            """Return probability in chessboard at (i, j) with k moves left."""
            if not (0 <= i < N and 0 <= j < N): return 0
            if k == 0: return 1
            return 1/8*sum(fn(k-1, i+ii, j+jj) for ii, jj in ((-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)))

        return fn(K, r, c)


    """689. Maximum Sum of 3 Non-Overlapping Subarrays (Hard)
    Given an integer array nums and an integer k, find three non-overlapping
    subarrays of length k with maximum sum and return them. Return the result
    as a list of indices representing the starting position of each interval
    (0-indexed). If there are multiple answers, return the lexicographically
    smallest one.

    Example 1:
    Input: nums = [1,2,1,2,6,7,5,1], k = 2
    Output: [0,3,5]
    Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting
                 indices [0, 3, 5]. We could have also taken [2, 1], but an
                 answer of [1, 3, 5] would be lexicographically larger.

    Example 2:
    Input: nums = [1,2,1,2,1,2,1,2,1], k = 2
    Output: [0,2,4]

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= nums[i] < 2^16
    * 1 <= k <= floor(nums.length / 3)"""

    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        rs0, rs1, rs2 = sum(nums[:k]), sum(nums[k:2*k]), sum(nums[2*k:3*k])
        m0, m1, m2 = rs0, rs0 + rs1, rs0 + rs1 + rs2
        i0, i1, i2 = [0], [0, k], [0, k, 2*k]
        for i in range(len(nums)-3*k):
            rs0 += nums[i+k] - nums[i]
            rs1 += nums[i+2*k] - nums[i+k]
            rs2 += nums[i+3*k] - nums[i+2*k]
            if rs0 > m0: m0, i0 = rs0, [i+1]
            if m0 + rs1 > m1: m1, i1 = m0 + rs1, i0 + [i+k+1]
            if m1 + rs2 > m2: m2, i2 = m1 + rs2, i1 + [i+2*k+1]
        return i2


    """690. Employee Importance (Easy)
    You are given a data structure of employee information, which includes the
    employee's unique id, their importance value and their direct subordinates'
    id. For example, employee 1 is the leader of employee 2, and employee 2 is
    the leader of employee 3. They have importance value 15, 10 and 5,
    respectively. Then employee 1 has a data structure like [1, 15, [2]], and
    employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that
    although employee 3 is also a subordinate of employee 1, the relationship
    is not direct. Now given the employee information of a company, and an
    employee id, you need to return the total importance value of this employee
    and all their subordinates.

    Example 1:
    Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
    Output: 11
    Explanation: Employee 1 has importance value 5, and he has two direct
                 subordinates: employee 2 and employee 3. They both have
                 importance value 3. So the total importance value of employee
                 1 is 5 + 3 + 3 = 11.

    Note:
    * One employee has at most one direct leader and may have several subordinates.
    * The maximum number of employees won't exceed 2000."""

    def getImportance(self, employees: List['Employee'], id: int) -> int:
        mp = {x.id: x for x in employees}

        ans = 0
        stack = [id]
        while stack:
            x = stack.pop()
            ans += mp[x].importance
            stack.extend(mp[x].subordinates)
        return ans


    """691. Stickers to Spell Word (Hard)
    We are given n different types of stickers. Each sticker has a lowercase
    English word on it. You would like to spell out the given string target by
    cutting individual letters from your collection of stickers and rearranging
    them. You can use each sticker more than once if you want, and you have
    infinite quantities of each sticker. Return the minimum number of stickers
    that you need to spell out target. If the task is impossible, return -1.
    Note: In all test cases, all words were chosen randomly from the 1000 most
    common US English words, and target was chosen as a concatenation of two
    random words.

    Example 1:
    Input: stickers = ["with","example","science"], target = "thehat"
    Output: 3
    Explanation: We can use 2 "with" stickers, and 1 "example" sticker. After
                 cutting and rearrange the letters of those stickers, we can
                 form the target "thehat". Also, this is the minimum number of
                 stickers necessary to form the target string.

    Example 2:
    Input: stickers = ["notice","possible"], target = "basicbasic"
    Output: -1
    Explanation: We cannot form the target "basicbasic" from cutting letters
                 from the given stickers.

    Constraints:
    * n == stickers.length
    * 1 <= n <= 50
    * 1 <= stickers[i].length <= 10
    * 1 <= target <= 15
    * stickers[i] and target consist of lowercase English letters."""

    def minStickers(self, stickers: List[str], target: str) -> int:
        freqs = [Counter(x) for x in stickers]

        @cache
        def fn(x):
            """Return min sticks to give x."""
            if not x: return 0
            ans = inf
            freq = Counter(x)
            for cnt in freqs:
                if x[0] in cnt:
                    xx = "".join(k*v for k, v in (freq - cnt).items())
                    ans = min(ans, 1 + fn(xx))
            return ans

        ans = fn(target)
        return ans if ans < inf else -1


    """692. Top K Frequent Words (Medium)
    Given a non-empty list of words, return the k most frequent elements. Your
    answer should be sorted by frequency from highest to lowest. If two words
    have the same frequency, then the word with the lower alphabetical order
    comes first.

    Example 1:
    Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
    Output: ["i", "love"]
    Explanation: "i" and "love" are the two most frequent words. Note that "i"
                 comes before "love" due to a lower alphabetical order.

    Example 2:
    Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
    Output: ["the", "is", "sunny", "day"]
    Explanation: "the", "is", "sunny" and "day" are the four most frequent
                 words, with the number of occurrence being 4, 3, 2 and 1
                 respectively.
    Note:
    * You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
    * Input words contain only lowercase letters.

    Follow up: Try to solve it in O(n log k) time and O(n) extra space."""

    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        freq = {} # frequency table
        for x in words: freq[x] = 1 + freq.get(x, 0)
        return nsmallest(k, freq, key=lambda x: (-freq[x], x))


    """694. Number of Distinct Islands (Medium)
    Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's
    (representing land) connected 4-directionally (horizontal or vertical.) You
    may assume all four edges of the grid are surrounded by water. Count the
    number of distinct islands. An island is considered to be the same as
    another if and only if one island can be translated (and not rotated or
    reflected) to equal the other.

    Example 1:
    11000
    11000
    00011
    00011
    Given the above grid map, return 1.

    Example 2:
    11011
    10000
    00001
    11011
    Given the above grid map, return 3.

    Notice that:
    11 and  1 are considered different island shapes, because we do not consider
    1      11
    reflection / rotation.

    Note: The length of each dimension in the given grid does not exceed 50."""

    def numDistinctIslands(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions
        seen = set()

        def fn(i, j):
            """Travere grid depth-first."""
            grid[i][j] = 0 # mark visited
            vals.add((i, j))
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: fn(ii, jj)

        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    vals = set()
                    fn(i, j)
                    mi = min(i for i, _ in vals)
                    mj = min(j for _, j in vals)
                    seen.add(tuple(sorted((i-mi, j-mj) for i, j in vals)))
        return len(seen)


    """695. Max Area of Island (Medium)
    Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's
    (representing land) connected 4-directionally (horizontal or vertical.) You
    may assume all four edges of the grid are surrounded by water. Find the
    maximum area of an island in the given 2D array. (If there is no island,
    the maximum area is 0.)

    Example 1:
    [[0,0,1,0,0,0,0,1,0,0,0,0,0],
     [0,0,0,0,0,0,0,1,1,1,0,0,0],
     [0,1,1,0,1,0,0,0,0,0,0,0,0],
     [0,1,0,0,1,1,0,0,1,0,1,0,0],
     [0,1,0,0,1,1,0,0,1,1,1,0,0],
     [0,0,0,0,0,0,0,0,0,0,1,0,0],
     [0,0,0,0,0,0,0,1,1,1,0,0,0],
     [0,0,0,0,0,0,0,1,1,0,0,0,0]]
    Given the above grid, return 6. Note the answer is not 11, because the
    island must be connected 4-directionally.

    Example 2:
    [[0,0,0,0,0,0,0,0]]
    Given the above grid, return 0.

    Note: The length of each dimension in the given grid does not exceed 50."""

    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        for r in range(m):
            for c in range(n):
                if grid[r][c]:
                    val = 1
                    grid[r][c] = 0
                    stack = [(r, c)]
                    while stack:
                        i, j = stack.pop()
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                            if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]:
                                val += 1
                                grid[ii][jj] = 0
                                stack.append((ii, jj))
                    ans = max(ans, val)
        return ans


    """698. Partition to K Equal Sum Subsets (Medium)
    Given an integer array nums and an integer k, return true if it is possible
    to divide this array into k non-empty subsets whose sums are all equal.

    Example 1:
    Input: nums = [4,3,2,3,5,2,1], k = 4
    Output: true
    Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3),
                 (2,3) with equal sums.

    Example 2:
    Input: nums = [1,2,3,4], k = 3
    Output: false

    Constraints:
    * 1 <= k <= nums.length <= 16
    * 1 <= nums[i] <= 10^4
    * The frequency of each element is in the range [1, 4]."""

    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        total = sum(nums)
        if total % k: return False
        avg = total // k

        @cache
        def fn(x, mask):
            """Return True if possible to partition."""
            if x > avg: return False
            if x == avg: return fn(0, mask)
            if not mask: return True
            for i in range(len(nums)):
                if mask & 1<<i and fn(x + nums[i], mask ^ 1<<i): return True
            return False

        nums.sort(reverse=True)
        return fn(0, (1 << len(nums))-1)


    """700. Search in a Binary Search Tree (Easy)
    You are given the root of a binary search tree (BST) and an integer val.
    Find the node in the BST that the node's value equals val and return the
    subtree rooted with that node. If such a node does not exist, return null.

    Example 1:
    Input: root = [4,2,7,1,3], val = 2
    Output: [2,1,3]

    Example 2:
    Input: root = [4,2,7,1,3], val = 5
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [1, 5000].
    * 1 <= Node.val <= 10^7
    * root is a binary search tree.
    * 1 <= val <= 10^7"""

    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        node = root
        while node:
            if node.val < val: node = node.right
            elif node.val == val: break
            else: node = node.left
        return node


    """701. Insert into a Binary Search Tree (Medium)
    You are given the root node of a binary search tree (BST) and a value to
    insert into the tree. Return the root node of the BST after the insertion.
    It is guaranteed that the new value does not exist in the original BST.
    Notice that there may exist multiple valid ways for the insertion, as long
    as the tree remains a BST after insertion. You can return any of them.

    Example 1:
    Input: root = [4,2,7,1,3], val = 5
    Output: [4,2,7,1,3,5]
    Explanation: Another accepted tree is:

    Example 2:
    Input: root = [40,20,60,10,30,50,70], val = 25
    Output: [40,20,60,10,30,50,70,null,null,25]

    Example 3:
    Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
    Output: [4,2,7,1,3,5]

    Constraints:
    * The number of nodes in the tree will be in the range [0, 10^4].
    * -10^8 <= Node.val <= 10^8
    * All the values Node.val are unique.
    * -10^8 <= val <= 10^8
    * It's guaranteed that val does not exist in the original BST."""

    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root: return TreeNode(val)
        node = root
        while node:
            if node.val < val:
                if node.right: node = node.right
                else:
                    node.right = TreeNode(val)
                    break
            else:
                if node.left: node = node.left
                else:
                    node.left = TreeNode(val)
                    break
        return root


    """702. Search in a Sorted Array of Unknown Size (Medium)
    This is an interactive problem. You have a sorted array of unique elements
    and an unknown size. You do not have an access to the array but you can use
    the ArrayReader interface to access it. You can call ArrayReader.get(i)
    that:
    * returns the value at the ith index (0-indexed) of the secret array (i.e.,
      secret[i]), or
    * returns 2^31 - 1 if the i is out of the boundary of the array.
    You are also given an integer target. Return the index k of the hidden
    array where secret[k] == target or return -1 otherwise. You must write an
    algorithm with O(log n) runtime complexity.

    Example 1:
    Input: secret = [-1,0,3,5,9,12], target = 9
    Output: 4
    Explanation: 9 exists in secret and its index is 4.

    Example 2:
    Input: secret = [-1,0,3,5,9,12], target = 2
    Output: -1
    Explanation: 2 does not exist in secret so return -1.

    Constraints:
    * 1 <= secret.length <= 10^4
    * -10^4 <= secret[i], target <= 10^4
    * secret is sorted in a strictly increasing order."""

    def search(self, reader, target):
        lo, hi = 0, 10_000
        while lo <= hi:
            mid = lo + hi >> 1
            val = reader.get(mid)
            if val < target: lo = mid + 1
            elif val == target: return mid
            else: hi = mid - 1
        return -1


    """704. Binary Search (Easy)
    Given an array of integers nums which is sorted in ascending order, and an
    integer target, write a function to search target in nums. If target exists,
    then return its index. Otherwise, return -1. You must write an algorithm
    with O(log n) runtime complexity.

    Example 1:
    Input: nums = [-1,0,3,5,9,12], target = 9
    Output: 4
    Explanation: 9 exists in nums and its index is 4

    Example 2:
    Input: nums = [-1,0,3,5,9,12], target = 2
    Output: -1
    Explanation: 2 does not exist in nums so return -1

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^4 < nums[i], target < 10^4
    * All the integers in nums are unique.
    * nums is sorted in ascending order."""

    def search(self, nums: List[int], target: int) -> int:
        lo, hi = 0, len(nums)
        while lo < hi:
            mid = lo + hi >> 1
            if nums[mid] < target: lo = mid + 1
            elif nums[mid] == target: return mid
            else: hi = mid
        return -1


    """708. Insert into a Sorted Circular Linked List (Medium)
    Given a Circular Linked List node, which is sorted in ascending order,
    write a function to insert a value insertVal into the list such that it
    remains a sorted circular list. The given node can be a reference to any
    single node in the list and may not necessarily be the smallest value in
    the circular list. If there are multiple suitable places for insertion,
    you may choose any place to insert the new value. After the insertion, the
    circular list should remain sorted. If the list is empty (i.e., the given
    node is null), you should create a new single circular list and return the
    reference to that single node. Otherwise, you should return the originally
    given node.

    Example 1:
    Input: head = [3,4,1], insertVal = 2
    Output: [3,4,1,2]
    Explanation: In the figure above, there is a sorted circular list of three
                 elements. You are given a reference to the node with value 3,
                 and we need to insert 2 into the list. The new node should be
                 inserted between node 1 and node 3. After the insertion, the
                 list should look like this, and we should still return node 3.

    Example 2:
    Input: head = [], insertVal = 1
    Output: [1]
    Explanation: The list is empty (given head is null). We create a new single
                 circular list and return the reference to that single node.

    Example 3:
    Input: head = [1], insertVal = 0
    Output: [1,0]

    Constraints:
    * 0 <= Number of Nodes <= 5 * 10^4
    * -10^6 <= Node.val, insertVal <= 10^6"""

    def insert(self, head: 'Node', insertVal: int) -> 'Node':
        temp = Node(insertVal)
        if not head:
            temp.next = temp
            return temp
        prev, node = head, head.next
        while True:
            if prev.val <= insertVal <= node.val: break
            if prev.val > node.val and (insertVal < node.val or prev.val < insertVal): break
            prev, node = node, node.next
            if prev == head: break
        prev.next = temp
        temp.next = node
        return head


    """709. To Lower Case (Easy)
    Given a string s, return the string after replacing every uppercase letter
    with the same lowercase letter.

    Example 1:
    Input: s = "Hello"
    Output: "hello"

    Example 2:
    Input: s = "here"
    Output: "here"

    Example 3:
    Input: s = "LOVELY"
    Output: "lovely"

    Constraints:
    * 1 <= s.length <= 100
    * s consists of printable ASCII characters."""

    def toLowerCase(self, s: str) -> str:
        s = list(s)
        for i in range(len(s)):
            if s[i].isupper(): s[i] = chr(ord(s[i]) ^ 32) # convert lowercase to uppercase or uppercase to lowercase
        return "".join(s)


    """711. Number of Distinct Islands II (Hard)
    You are given an m x n binary matrix grid. An island is a group of 1's
    (representing land) connected 4-directionally (horizontal or vertical.) You
    may assume all four edges of the grid are surrounded by water. An island is
    considered to be the same as another if they have the same shape, or have
    the same shape after rotation (90, 180, or 270 degrees only) or reflection
    (left/right direction or up/down direction). Return the number of distinct
    islands.

    Example 1:
    Input: grid = [[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,1],[0,0,0,1,1]]
    Output: 1
    Explanation: The two islands are considered the same because if we make a
                 180 degrees clockwise rotation on the first island, then two
                 islands will have the same shapes.

    Example 2:
    Input: grid = [[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]
    Output: 1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * grid[i][j] is either 0 or 1."""

    def numDistinctIslands2(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        seen = set()
        for r in range(m):
            for c in range(n):
                if grid[r][c]:
                    vals = [[] for _ in range(8)]
                    grid[r][c] = 0
                    stack = [(r, c)]
                    while stack:
                        i, j = stack.pop()
                        for k, (x, y) in enumerate(((1, 1), (1, -1), (-1, 1), (-1, -1)), 0):
                            vals[k].append([i*x, j*y])
                            vals[k+4].append([j*x, i*y])
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                            if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]:
                                grid[ii][jj] = 0
                                stack.append((ii, jj))
                    temp = set()
                    for k in range(8):
                        mx = min(x for x, _ in vals[k])
                        my = min(y for _, y in vals[k])
                        vals[k] = [[x-mx, y-my] for x, y in vals[k]]
                        key = tuple(tuple(v) for v in sorted(vals[k]))
                        if key in seen: break
                        temp.add(key)
                    else:
                        ans += 1
                        seen |= temp
        return ans


    """713. Subarray Product Less Than K (Medium)
    Given an array of integers nums and an integer k, return the number of
    contiguous subarrays where the product of all the elements in the subarray
    is strictly less than k.

    Example 1:
    Input: nums = [10,5,2,6], k = 100
    Output: 8
    Explanation: The 8 subarrays that have product less than 100 are:
                 [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note
                 that [10, 5, 2] is not included as the product of 100 is not
                 strictly less than k.

    Example 2:
    Input: nums = [1,2,3], k = 0
    Output: 0

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * 1 <= nums[i] <= 1000
    * 0 <= k <= 10^6"""

    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        ans = ii = 0
        prod = 1
        for i, x in enumerate(nums):
            prod *= x
            while ii <= i and k <= prod:
                prod //= nums[ii]
                ii += 1
            ans += i - ii + 1
        return ans


    """714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)
    You are given an array prices where prices[i] is the price of a given stock
    on the ith day, and an integer fee representing a transaction fee. Find the
    maximum profit you can achieve. You may complete as many transactions as
    you like, but you need to pay the transaction fee for each transaction.
    Note: You may not engage in multiple transactions simultaneously (i.e., you
    must sell the stock before you buy again).

    Example 1:
    Input: prices = [1,3,2,8,4,9], fee = 2
    Output: 8
    Explanation: The maximum profit can be achieved by:
                 - Buying at prices[0] = 1
                 - Selling at prices[3] = 8
                 - Buying at prices[4] = 4
                 - Selling at prices[5] = 9
                 The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

    Example 2:
    Input: prices = [1,3,7,5,10,3], fee = 3
    Output: 6

    Constraints:
    * 1 <= prices.length <= 5 * 10^4
    * 1 <= prices[i] < 5 * 10^4
    * 0 <= fee < 5 * 10^4"""

    def maxProfit(self, prices: List[int], fee: int) -> int:
        buy, sell = inf, 0
        for x in prices:
            buy = min(buy, x - sell)
            sell = max(sell, x - buy - fee)
        return sell


    """717. 1-bit and 2-bit Characters (Easy)
    We have two special characters:
    * The first character can be represented by one bit 0.
    * The second character can be represented by two bits (10 or 11).
    Given a binary array bits that ends with 0, return true if the last
    character must be a one-bit character.

    Example 1:
    Input: bits = [1,0,0]
    Output: true
    Explanation: The only way to decode it is two-bit character and one-bit
                 character. So the last character is one-bit character.

    Example 2:
    Input: bits = [1,1,1,0]
    Output: false
    Explanation: The only way to decode it is two-bit character and two-bit
                 character. So the last character is not one-bit character.

    Constraints:
    * 1 <= bits.length <= 1000
    * bits[i] is either 0 or 1."""

    def isOneBitCharacter(self, bits: List[int]) -> bool:
        i = 0
        while i < len(bits)-1:
            if bits[i] == 0: i += 1
            else: i += 2
        return i == len(bits)-1


    """719. Find K-th Smallest Pair Distance (Hard)
    The distance of a pair of integers a and b is defined as the absolute
    difference between a and b. Given an integer array nums and an integer k,
    return the kth smallest distance among all the pairs nums[i] and nums[j]
    where 0 <= i < j < nums.length.

    Example 1:
    Input: nums = [1,3,1], k = 1
    Output: 0
    Explanation: Here are all the pairs: (1,3) -> 2
                                         (1,1) -> 0
                                         (3,1) -> 2
                 Then the 1st smallest distance pair is (1,1), and its distance
                 is 0.

    Example 2:
    Input: nums = [1,1,1], k = 2
    Output: 0

    Example 3:
    Input: nums = [1,6,1], k = 3
    Output: 5

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^4
    * 0 <= nums[i] <= 10^6
    * 1 <= k <= n * (n - 1) / 2"""

    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        nums.sort()

        def fn(val):
            """Return count of pairs whose diff <= val."""
            ans = ii = 0
            for i, x in enumerate(nums):
                while ii < i and x - nums[ii] > val: ii += 1
                ans += i - ii
            return ans

        lo, hi = 0, nums[-1] - nums[0]
        while lo < hi:
            mid = lo + hi >> 1
            if fn(mid) < k: lo = mid + 1
            else: hi = mid
        return lo


    """720. Longest Word in Dictionary (Medium)
    Given an array of strings words representing an English Dictionary, return
    the longest word in words that can be built one character at a time by
    other words in words. If there is more than one possible answer, return the
    longest word with the smallest lexicographical order. If there is no answer,
    return the empty string.

    Example 1:
    Input: words = ["w","wo","wor","worl","world"]
    Output: "world"
    Explanation: The word "world" can be built one character at a time by "w",
                 "wo", "wor", and "worl".

    Example 2:
    Input: words = ["a","banana","app","appl","ap","apply","apple"]
    Output: "apple"
    Explanation: Both "apply" and "apple" can be built from other words in the
                 dictionary. However, "apple" is lexicographically smaller than
                 "apply".

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 30
    * words[i] consists of lowercase English letters."""

    def longestWord(self, words: List[str]) -> str:
        ans = ""
        seen = {""}
        for word in sorted(words):
            if word[:-1] in seen:
                seen.add(word)
                if len(word) > len(ans): ans = word
        return ans


    """721. Accounts Merge (Medium)
    Given a list of accounts where each element accounts[i] is a list of
    strings, where the first element accounts[i][0] is a name, and the rest of
    the elements are emails representing emails of the account. Now, we would
    like to merge these accounts. Two accounts definitely belong to the same
    person if there is some common email to both accounts. Note that even if
    two accounts have the same name, they may belong to different people as
    people could have the same name. A person can have any number of accounts
    initially, but all of their accounts definitely have the same name. After
    merging the accounts, return the accounts in the following format: the
    first element of each account is the name, and the rest of the elements are
    emails in sorted order. The accounts themselves can be returned in any order.

    Example 1:
    Input: accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],
                       ["John","johnsmith@mail.com","john00@mail.com"],
                       ["Mary","mary@mail.com"],
                       ["John","johnnybravo@mail.com"]]
    Output: [["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],
             ["Mary","mary@mail.com"],
             ["John","johnnybravo@mail.com"]]
    Explanation:
    The first and third John's are the same person as they have the common email "johnsmith@mail.com".
    The second John and Mary are different people as none of their email addresses are used by other accounts.
    We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'],
    ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.

    Example 2:
    Input: accounts = [["Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"],
                       ["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],
                       ["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],
                       ["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],
                       ["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]
    Output: [["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],
             ["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],
             ["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],
             ["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],
             ["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]

    Constraints:
    * 1 <= accounts.length <= 1000
    * 2 <= accounts[i].length <= 10
    * 1 <= accounts[i][j] <= 30
    * accounts[i][0] consists of English letters.
    * accounts[i][j] (for j > 0) is a valid email."""

    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        email = {}
        uf = UnionFindDict()
        for account in accounts:
            for i in range(1, len(account)):
                email[account[i]] = account[0]
                uf.union(account[1], account[i])

        groups = {}
        for x in email:
            groups.setdefault(uf.find(x), []).append(x)

        ans = []
        for value in groups.values():
            ans.append([email[value[0]]] + sorted(value))
        return ans


    """722. Remove Comments (Medium)
    Given a C++ program, remove comments from it. The program source is an
    array of strings source where source[i] is the ith line of the source code.
    This represents the result of splitting the original source code string by
    the newline character '\n'. In C++, there are two types of comments, line
    comments, and block comments.
    * The string "//" denotes a line comment, which represents that it and the
      rest of the characters to the right of it in the same line should be
      ignored.
    * The string "/*" denotes a block comment, which represents that all
      characters until the next (non-overlapping) occurrence of "*/" should be
      ignored. (Here, occurrences happen in reading order: line by line from
      left to right.) To be clear, the string "/*/" does not yet end the block
      comment, as the ending would be overlapping the beginning.

    The first effective comment takes precedence over others.
    * For example, if the string "//" occurs in a block comment, it is ignored.
    * Similarly, if the string "/*" occurs in a line or block comment, it is
      also ignored.
    If a certain line of code is empty after removing comments, you must not
    output that line: each string in the answer list will be non-empty. There
    will be no control characters, single quote, or double quote characters.
    * For example, source = "string s = "/* Not a comment. */";" will not be a
      test case.
    Also, nothing else such as defines or macros will interfere with the
    comments. It is guaranteed that every open block comment will eventually be
    closed, so "/*" outside of a line or block comment always starts a new
    comment. Finally, implicit newline characters can be deleted by block
    comments. Please see the examples below for details. After removing the
    comments from the source code, return the source code in the same format.

    Example 1:
    Input: source = ["/*Test program */",
                     "int main()",
                     "{ ",
                     "  // variable declaration ",
                     "int a, b, c;",
                     "/* This is a test",
                     "   multiline  ",
                     "   comment for ",
                     "   testing */",
                     "a = b + c;", "}"]
    Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]
    Explanation: The line by line code is visualized as below:
                     /*Test program */
                     int main()
                     {
                       // variable declaration
                     int a, b, c;
                     /* This is a test
                        multiline
                        comment for
                        testing */
                     a = b + c;
                     }
                 The string /* denotes a block comment, including line 1 and
                 lines 6-9. The string // denotes line 4 as comments. The line
                 by line output code is visualized as below:
                     int main()
                     {

                     int a, b, c;
                     a = b + c;
                     }

    Example 2:
    Input: source = ["a/*comment",
                     "line",
                     "more_comment*/b"]
    Output: ["ab"]
    Explanation: The original source string is "a/*comment\nline\nmore_comment*/b",
                 where we have bolded the newline characters.  After deletion,
                 the implicit newline characters are deleted, leaving the
                 string "ab", which when delimited by newline characters
                 becomes ["ab"].

    Constraints:
    * 1 <= source.length <= 100
    * 0 <= source[i].length <= 80
    * source[i] consists of printable ASCII characters.
    * Every open block comment is eventually closed.
    * There are no single-quote or double-quote in the input."""

    def removeComments(self, source: List[str]) -> List[str]:
        ans = []
        comment = False # True for block comment

        for line in source:
            if not comment: ans.append([]) # if not started as comment
            i = 0
            while i < len(line):
                if comment:
                    if line[i:i+2] == "*/":
                        comment = False
                        i += 1
                else:
                    if line[i:i+2] == "//": break
                    elif line[i:i+2] == "/*":
                        comment = True
                        i += 1
                    else: ans[-1].append(line[i])
                i += 1
        return filter(None, map("".join, ans))


    """723. Candy Crush (Medium)
    This question is about implementing a basic elimination algorithm for Candy
    Crush. Given an m x n integer array board representing the grid of candy
    where board[i][j] represents the type of candy. A value of board[i][j] == 0
    represents that the cell is empty. The given board represents the state of
    the game following the player's move. Now, you need to restore the board to
    a stable state by crushing candies according to the following rules:
    * If three or more candies of the same type are adjacent vertically or
      horizontally, crush them all at the same time - these positions become
      empty.
    * After crushing all candies simultaneously, if an empty space on the board
      has candies on top of itself, then these candies will drop until they hit
      a candy or bottom at the same time. No new candies will drop outside the
      top boundary.
    * After the above steps, there may exist more candies that can be crushed.
      If so, you need to repeat the above steps.
    * If there does not exist more candies that can be crushed (i.e., the board
      is stable), then return the current board.
    You need to perform the above rules until the board becomes stable, then
    return the stable board.

    Example 1:
    Input: board = [[110,  5,112,113, 114],
                    [210,211,  5,213, 214],
                    [310,311,  3,313, 314],
                    [410,411,412,  5, 414],
                    [  5,  1,512,  3,   3],
                    [610,  4,  1,613, 614],
                    [710,  1,  2,713, 714],
                    [810,  1,  2,  1,   1],
                    [  1,  1,  2,  2,   2],
                    [  4,  1,  4,  4,1014]]
    Output: [[  0,  0,  0,  0,   0],
             [  0,  0,  0,  0,   0],
             [  0,  0,  0,  0,   0],
             [110,  0,  0,  0, 114],
             [210,  0,  0,  0, 214],
             [310,  0,  0,113, 314],
             [410,  0,  0,213, 414],
             [610,211,112,313, 614],
             [710,311,412,613, 714],
             [810,411,512,713,1014]]
    Example 2:

    Input: board = [[1,3,5,5,2],
                    [3,4,3,3,1],
                    [3,2,4,5,2],
                    [2,4,4,5,5],
                    [1,4,4,1,1]]
    Output: [[1,3,0,0,0],
             [3,4,0,5,2],
             [3,2,0,3,1],
             [2,4,0,5,2],
             [1,4,3,1,1]]

    Constraints:
    * m == board.length
    * n == board[i].length
    * 3 <= m, n <= 50
    * 1 <= board[i][j] <= 2000"""

    def candyCrush(self, board: List[List[int]]) -> List[List[int]]:
        m, n = len(board), len(board[0])

        while True:
            vals = []
            for i in range(m):
                for j in range(n):
                    if board[i][j]:
                        if 0 <= i-2 and board[i-2][j] == board[i-1][j] == board[i][j] \
                        or 0 <= i-1 and i+1 < m and board[i-1][j] == board[i][j] == board[i+1][j] \
                        or i+2 < m and board[i][j] == board[i+1][j] == board[i+2][j] \
                        or 0 <= j-2 and board[i][j-2] == board[i][j-1] == board[i][j] \
                        or 0 <= j-1 and j+1 < n and board[i][j-1] == board[i][j] == board[i][j+1] \
                        or j+2 < n and board[i][j] == board[i][j+1] == board[i][j+2]: vals.append((i, j))

            if not vals: break
            for i, j in vals: board[i][j] = 0

            # precipitate
            for j in range(n):
                ii = m-1
                for i in reversed(range(m)):
                    if board[i][j]:
                        board[ii][j], board[i][j] = board[i][j], board[ii][j]
                        ii -= 1
        return board


    """724. Find Pivot Index (Easy)
    Given an array of integers nums, calculate the pivot index of this array.
    The pivot index is the index where the sum of all the numbers strictly to
    the left of the index is equal to the sum of all the numbers strictly to
    the index's right. If the index is on the left edge of the array, then the
    left sum is 0 because there are no elements to the left. This also applies
    to the right edge of the array. Return the leftmost pivot index. If no such
    index exists, return -1.

    Example 1:
    Input: nums = [1,7,3,6,5,6]
    Output: 3
    Explanation: The pivot index is 3.
                 Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
                 Right sum = nums[4] + nums[5] = 5 + 6 = 11

    Example 2:
    Input: nums = [1,2,3]
    Output: -1
    Explanation: There is no index that satisfies the conditions in the problem
                 statement.

    Example 3:
    Input: nums = [2,1,-1]
    Output: 0
    Explanation: The pivot index is 0.
                 Left sum = 0 (no elements to the left of index 0)
                 Right sum = nums[1] + nums[2] = 1 + -1 = 0

    Constraints:
    * 1 <= nums.length <= 10^4
    * -1000 <= nums[i] <= 1000


    Note: This question is the same as 1991:
          https://leetcode.com/problems/find-the-middle-index-in-array/"""

    def pivotIndex(self, nums: List[int]) -> int:
        total = sum(nums)
        prefix = 0
        for i, x in enumerate(nums):
            if prefix == total - prefix - x: return i
            prefix += x
        return -1


    """725. Split Linked List in Parts (Medium)
    Given a (singly) linked list with head node root, write a function to split
    the linked list into k consecutive linked list "parts". The length of each
    part should be as equal as possible: no two parts should have a size
    differing by more than 1. This may lead to some parts being null. The parts
    should be in order of occurrence in the input list, and parts occurring
    earlier should always have a size greater than or equal parts occurring
    later. Return a List of ListNode's representing the linked list parts that
    are formed. Examples 1->2->3->4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]

    Example 1:
    Input: root = [1, 2, 3], k = 5
    Output: [[1],[2],[3],[],[]]
    Explanation: The input and each element of the output are ListNodes, not
    arrays. For example, the input root has root.val = 1, root.next.val = 2,
    root.next.next.val = 3, and root.next.next.next = null. The first element
    output[0] has output[0].val = 1, output[0].next = null. The last element
    output[4] is null, but it's string representation as a ListNode is [].

    Example 2:
    Input: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
    Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
    Explanation: The input has been split into consecutive parts with size
    difference at most 1, and earlier parts are a larger size than the later
    parts.

    Note:
    * The length of root will be in the range [0, 1000].
    * Each value of a node in the input will be an integer in the range [0, 999].
    * k will be an integer in the range [1, 50]."""

    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        sz = 0
        node = head
        while node:
            sz += 1
            node = node.next
        q, r = divmod(sz+k, k)
        ans = []
        node = head
        for i in range(k):
            ans.append(node)
            if i == r: q -= 1
            for _ in range(q-1): node = node.next
            if node: node.next, node = None, node.next
        return ans


    """726. Number of Atoms (Hard)
    Given a string formula representing a chemical formula, return the count of
    each atom. The atomic element always starts with an uppercase character,
    then zero or more lowercase letters, representing the name. One or more
    digits representing that element's count may follow if the count is greater
    than 1. If the count is 1, no digits will follow. For example, "H2O" and
    "H2O2" are possible, but "H1O2" is impossible. Two formulas are
    concatenated together to produce another formula. For example, "H2O2He3Mg4"
    is also a formula. A formula placed in parentheses, and a count (optionally
    added) is also a formula. For example, "(H2O2)" and "(H2O2)3" are formulas.
    Return the count of all elements as a string in the following form: the
    first name (in sorted order), followed by its count (if that count is more
    than 1), followed by the second name (in sorted order), followed by its
    count (if that count is more than 1), and so on.

    Example 1:
    Input: formula = "H2O"
    Output: "H2O"
    Explanation: The count of elements are {'H': 2, 'O': 1}.

    Example 2:
    Input: formula = "Mg(OH)2"
    Output: "H2MgO2"
    Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.

    Example 3:
    Input: formula = "K4(ON(SO3)2)2"
    Output: "K4N2O14S4"
    Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.

    Example 4:
    Input: formula = "Be32"
    Output: "Be32"

    Constraints:
    * 1 <= formula.length <= 1000
    * formula consists of English letters, digits, '(', and ')'.
    * formula is always valid.
    * All the values in the output will fit in a 32-bit integer."""

    def countOfAtoms(self, formula: str) -> str:
        mp = {}
        stack = []
        for i, x in enumerate(formula):
            if x == "(": stack.append(i)
            elif x == ")": mp[stack.pop()] = i

        def fn(lo, hi):
            """Return count of atom in a freq table."""
            k = lo
            ans = defaultdict(int)
            while k < hi:
                cnt = 0
                if formula[k] == "(":
                    freq = fn(k+1, mp[k])
                    k = mp[k] + 1
                    while k < hi and formula[k].isdigit():
                        cnt = 10*cnt + int(formula[k])
                        k += 1
                    for key, val in freq.items(): ans[key] += val * max(1, cnt)
                else:
                    atom = formula[k]
                    k += 1
                    while k < hi and formula[k] != "(" and not formula[k].isupper():
                        if formula[k].isalpha(): atom += formula[k]
                        else: cnt = 10*cnt + int(formula[k])
                        k += 1
                    ans[atom] += max(1, cnt)
            return ans


        ans = []
        for k, v in sorted(fn(0, len(formula)).items()):
            ans.append(k)
            if v > 1: ans.append(str(v))
        return "".join(ans)


    """727. Minimum Window Subsequence (Hard)
    Given strings s1 and s2, return the minimum contiguous substring part of s1,
    so that s2 is a subsequence of the part. If there is no such window in s1
    that covers all characters in s2, return the empty string "". If there are
    multiple such minimum-length windows, return the one with the left-most
    starting index.

    Example 1:
    Input: s1 = "abcdebdde", s2 = "bde"
    Output: "bcde"
    Explanation: "bcde" is the answer because it occurs before "bdde" which has
                 the same length. "deb" is not a smaller window because the
                 elements of s2 in the window must occur in order.

    Example 2:
    Input: s1 = "jmeqksfrsdcmsiwvaovztaqenprpvnbstl", s2 = "u"
    Output: ""

    Constraints:
    * 1 <= s1.length <= 2 * 10^4
    * 1 <= s2.length <= 100
    * s1 and s2 consist of lowercase English letters."""

    def minWindow(self, s1: str, s2: str) -> str:
        m, n = len(s1), len(s2)
        dp = [[-1]*n for _ in range(m)]
        if s1[0] == s2[0]: dp[0][0] = 0
        for i in range(1, m):
            for j in range(n):
                if s1[i] == s2[j]:
                    if j: dp[i][j] = dp[i-1][j-1]
                    else: dp[i][j] = i
                else: dp[i][j] = dp[i-1][j]
        ans = ""
        for i in range(m):
            k = dp[i][-1]
            if k != -1 and (not ans or i-k+1 < len(ans)): ans = s1[k:i+1]
        return ans


    """733. Flood Fill (Easy)
    An image is represented by an m x n integer grid image where image[i][j]
    represents the pixel value of the image. You are also given three integers
    sr, sc, and newColor. You should perform a flood fill on the image starting
    from the pixel image[sr][sc]. To perform a flood fill, consider the
    starting pixel, plus any pixels connected 4-directionally to the starting
    pixel of the same color as the starting pixel, plus any pixels connected
    4-directionally to those pixels (also with the same color), and so on.
    Replace the color of all of the aforementioned pixels with newColor. Return
    the modified image after performing the flood fill.

    Example 1:
    Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2
    Output: [[2,2,2],[2,2,0],[2,0,1]]
    Explanation: From the center of the image with position (sr, sc) = (1, 1)
                 (i.e., the red pixel), all pixels connected by a path of the
                 same color as the starting pixel (i.e., the blue pixels) are
                 colored with the new color. Note the bottom corner is not
                 colored 2, because it is not 4-directionally connected to the
                 starting pixel.

    Example 2:
    Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2
    Output: [[2,2,2],[2,2,2]]

    Constraints:
    * m == image.length
    * n == image[i].length
    * 1 <= m, n <= 50
    * 0 <= image[i][j], newColor < 2^16
    * 0 <= sr < m
    * 0 <= sc < n"""

    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        m, n = len(image), len(image[0])
        oldColor = image[sr][sc]
        if oldColor != newColor:
            stack = [(sr, sc)]
            while stack:
                i, j = stack.pop()
                image[i][j] = newColor
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and image[ii][jj] == oldColor:
                        stack.append((ii, jj))
        return image


    """734. Sentence Similarity (Easy)
    We can represent a sentence as an array of words, for example, the sentence
    "I am happy with leetcode" can be represented as
    arr = ["I","am",happy","with","leetcode"]. Given two sentences sentence1
    and sentence2 each represented as a string array and given an array of
    string pairs similarPairs where similarPairs[i] = [xi, yi] indicates that
    the two words xi and yi are similar. Return true if sentence1 and sentence2
    are similar, or false if they are not similar.

    Two sentences are similar if:
    * They have the same length (i.e. the same number of words)
    * sentence1[i] and sentence2[i] are similar.
    Notice that a word is always similar to itself, also notice that the
    similarity relation is not transitive. For example, if the words a and b
    are similar and the words b and c are similar, a and c are not necessarily
    similar.

    Example 1:
    Input: sentence1 = ["great","acting","skills"],
           sentence2 = ["fine","drama","talent"],
           similarPairs = [["great","fine"],["drama","acting"],["skills","talent"]]
    Output: true
    Explanation: The two sentences have the same length and each word i of
                 sentence1 is also similar to the corresponding word in
                 sentence2.

    Example 2:
    Input: sentence1 = ["great"],
           sentence2 = ["great"],
           similarPairs = []
    Output: true
    Explanation: A word is similar to itself.

    Example 3:
    Input: sentence1 = ["great"],
           sentence2 = ["doubleplus","good"],
           similarPairs = [["great","doubleplus"]]
    Output: false
    Explanation: As they don't have the same length, we return false.

    Constraints:
    * 1 <= sentence1.length, sentence2.length <= 1000
    * 1 <= sentence1[i].length, sentence2[i].length <= 20
    * sentence1[i] and sentence2[i] consist of lower-case and upper-case English letters.
    * 0 <= similarPairs.length <= 1000
    * similarPairs[i].length == 2
    * 1 <= xi.length, yi.length <= 20
    * xi and yi consist of lower-case and upper-case English letters.
    * All the pairs (xi, yi) are distinct."""

    def areSentencesSimilar(self, sentence1: List[str], sentence2: List[str], similarPairs: List[List[str]]) -> bool:
        if len(sentence1) != len(sentence2): return False
        mp = defaultdict(set)
        for x, y in similarPairs:
            mp[x].add(y)
            mp[y].add(x)
        return all(w1 == w2 or w1 in mp[w2] for w1, w2, in zip(sentence1, sentence2))


    """737. Sentence Similarity II (Medium)
    We can represent a sentence as an array of words, for example, the sentence
    "I am happy with leetcode" can be represented as
    arr = ["I","am",happy","with","leetcode"]. Given two sentences sentence1
    and sentence2 each represented as a string array and given an array of
    string pairs similarPairs where similarPairs[i] = [xi, yi] indicates that
    the two words xi and yi are similar. Return true if sentence1 and sentence2
    are similar, or false if they are not similar. Two sentences are similar if:
    * They have the same length (i.e., the same number of words)
    * sentence1[i] and sentence2[i] are similar.
    Notice that a word is always similar to itself, also notice that the
    similarity relation is transitive. For example, if the words a and b are
    similar, and the words b and c are similar, then a and c are similar.

    Example 1:
    Input: sentence1 = ["great","acting","skills"],
           sentence2 = ["fine","drama","talent"],
           similarPairs = [["great","good"],["fine","good"],["drama","acting"],["skills","talent"]]
    Output: true
    Explanation: The two sentences have the same length and each word i of
                 sentence1 is also similar to the corresponding word in
                 sentence2.

    Example 2:
    Input: sentence1 = ["I","love","leetcode"],
           sentence2 = ["I","love","onepiece"],
           similarPairs = [["manga","onepiece"],["platform","anime"],["leetcode","platform"],["anime","manga"]]
    Output: true
    Explanation: "leetcode" --> "platform" --> "anime" --> "manga" --> "onepiece".
                 Since "leetcode is similar to "onepiece" and the first two
                 words are the same, the two sentences are similar.

    Example 3:
    Input: sentence1 = ["I","love","leetcode"],
           sentence2 = ["I","love","onepiece"],
           similarPairs = [["manga","hunterXhunter"],["platform","anime"],["leetcode","platform"],["anime","manga"]]
    Output: false
    Explanation: "leetcode" is not similar to "onepiece".

    Constraints:
    * 1 <= sentence1.length, sentence2.length <= 1000
    * 1 <= sentence1[i].length, sentence2[i].length <= 20
    * sentence1[i] and sentence2[i] consist of lower-case and upper-case English letters.
    * 0 <= similarPairs.length <= 2000
    * similarPairs[i].length == 2
    * 1 <= xi.length, yi.length <= 20
    * xi and yi consist of English letters.

    class UnionFind:

        def __init__(self):
            self.parent = {}
            self.rank = defaultdict(lambda: 1)

        def find(self, p):
            if p not in self.parent: self.parent[p] = p
            if p != self.parent[p]:
                self.parent[p] = self.find(self.parent[p])
            return self.parent[p]

        def union(self, p, q):
            prt, qrt = self.find(p), self.find(q)
            if prt == qrt: return False
            if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt
            self.parent[prt] = qrt
            self.rank[qrt] += self.rank[prt]
            return True"""

    def areSentencesSimilarTwo(self, sentence1: List[str], sentence2: List[str], similarPairs: List[List[str]]) -> bool:
        if len(sentence1) != len(sentence2): return False

        uf = UnionFind()
        for x, y in similarPairs: uf.union(x, y)
        for x, y in zip(sentence1, sentence2):
            if uf.find(x) != uf.find(y): return False
        return True


    """739. Daily Temperatures (Medium)
    Given a list of daily temperatures T, return a list such that, for each day
    in the input, tells you how many days you would have to wait until a warmer
    temperature. If there is no future day for which this is possible, put 0
    instead. For example, given the list of temperatures T = [73, 74, 75, 71,
    69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0]. Note that
    the length of temperatures will be in the range [1, 30000]. Each temperature
    will be an integer in the range [30, 100]."""

    def dailyTemperatures(self, T: List[int]) -> List[int]:
        ans = [0]*len(T)
        stack = []
        for i in range(len(T)):
            while stack and T[stack[-1]] < T[i]:
                ii = stack.pop()
                ans[ii] = i - ii
            stack.append(i)
        return ans


    """740. Delete and Earn (Medium)
    Given an array nums of integers, you can perform operations on the array.
    In each operation, you pick any nums[i] and delete it to earn nums[i]
    points. After, you must delete every element equal to nums[i] - 1 or
    nums[i] + 1. You start with 0 points. Return the maximum number of points
    you can earn by applying such operations.

    Example 1:
    Input: nums = [3, 4, 2]
    Output: 6
    Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted.
                 Then, delete 2 to earn 2 points. 6 total points are earned.
    Example 2:
    Input: nums = [2, 2, 3, 3, 3, 4]
    Output: 9
    Explanation: Delete 3 to earn 3 points, deleting both 2's and the 4. Then,
                 delete 3 again to earn 3 points, and 3 again to earn 3 points.
                 9 total points are earned.
    Note:
    * The length of nums is at most 20000.
    * Each element nums[i] is an integer in the range [1, 10000]."""

    def deleteAndEarn(self, nums: List[int]) -> int:
        freq = Counter(nums)
        prev = -1
        f0 = f1 = 0
        for x in sorted(freq):
            if prev + 1 == x: f0, f1 = f1, max(f0+x*freq[x], f1)
            else: f0, f1 = f1, f1+x*freq[x]
            prev = x
        return f1


    """742. Closest Leaf in a Binary Tree (Medium)
    Given the root of a binary tree where every node has a unique value and a
    target integer k, return the value of the nearest leaf node to the target k
    in the tree. Nearest to a leaf means the least number of edges traveled on
    the binary tree to reach any leaf of the tree. Also, a node is called a
    leaf if it has no children.

    Example 1:
    Input: root = [1,3,2], k = 1
    Output: 2
    Explanation: Either 2 or 3 is the nearest leaf node to the target of 1.

    Example 2:
    Input: root = [1], k = 1
    Output: 1
    Explanation: The nearest leaf node is the root node itself.

    Example 3:
    Input: root = [1,2,3,4,null,null,null,5,null,6], k = 2
    Output: 3
    Explanation: The leaf node with value 3 (and not the leaf node with value 6)
                 is nearest to the node with value 2.

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * 1 <= Node.val <= 1000
    * All the values of the tree are unique.
    * There exist some node in the tree where Node.val == k."""

    def findClosestLeaf(self, root: Optional[TreeNode], k: int) -> int:
        mp = {root: None}
        stack = [root]
        while stack:
            node = stack.pop()
            if node.val == k: source = node
            if node.left:
                mp[node.left] = node
                stack.append(node.left)
            if node.right:
                mp[node.right] = node
                stack.append(node.right)

        queue = deque([source])
        seen = {source}
        while queue:
            x = queue.popleft()
            if x.left is x.right is None: return x.val
            for xx in (x.left, x.right, mp[x]):
                if xx and xx not in seen:
                    queue.append(xx)
                    seen.add(xx)


    """746. Min Cost Climbing Stairs (Easy)
    You are given an integer array cost where cost[i] is the cost of ith step
    on a staircase. Once you pay the cost, you can either climb one or two
    steps. You can either start from the step with index 0, or the step with
    index 1. Return the minimum cost to reach the top of the floor.

    Example 1:
    Input: cost = [10,15,20]
    Output: 15
    Explanation: Cheapest is: start on cost[1], pay that cost, and go to the
                 top.

    Example 2:
    Input: cost = [1,100,1,1,1,100,1,1,100,1]
    Output: 6
    Explanation: Cheapest is: start on cost[0], and only step on 1s, skipping
                 cost[3].

    Constraints:
    * 2 <= cost.length <= 1000
    * 0 <= cost[i] <= 999"""

    def minCostClimbingStairs(self, cost: List[int]) -> int:
        f0 = f1 = 0
        for x in reversed(cost):
            f0, f1 = f1, min(f0, f1) + x
        return min(f0, f1)


    """748. Shortest Completing Word (Easy)
    Given a string licensePlate and an array of strings words, find the
    shortest completing word in words. A completing word is a word that
    contains all the letters in licensePlate. Ignore numbers and spaces in
    licensePlate, and treat letters as case insensitive. If a letter appears
    more than once in licensePlate, then it must appear in the word the same
    number of times or more. For example, if licensePlate = "aBc 12c", then it
    contains letters 'a', 'b' (ignoring case), and 'c' twice. Possible
    completing words are "abccdef", "caaacab", and "cbca". Return the shortest
    completing word in words. It is guaranteed an answer exists. If there are
    multiple shortest completing words, return the first one that occurs in
    words.

    Example 1:
    Input: licensePlate = "1s3 PSt",
           words = ["step","steps","stripe","stepple"]
    Output: "steps"
    Explanation: licensePlate contains letters 's', 'p', 's' (ignoring case),
                 and 't'. "step" contains 't' and 'p', but only contains 1 's'.
                 "steps" contains 't', 'p', and both 's' characters. "stripe"
                 is missing an 's'. "stepple" is missing an 's'. Since "steps"
                 is the only word containing all the letters, that is the
                 answer.

    Example 2:
    Input: licensePlate = "1s3 456",
           words = ["looks","pest","stew","show"]
    Output: "pest"
    Explanation: licensePlate only contains the letter 's'. All the words
                 contain 's', but among these "pest", "stew", and "show" are
                 shortest. The answer is "pest" because it is the word that
                 appears earliest of the 3.

    Example 3:
    Input: licensePlate = "Ah71752",
           words = ["suggest","letter","of","husband","easy","education","drug","prevent","writer","old"]
    Output: "husband"

    Example 4:
    Input: licensePlate = "OgEu755",
           words = ["enough","these","play","wide","wonder","box","arrive","money","tax","thus"]
    Output: "enough"

    Example 5:
    Input: licensePlate = "iMSlpe4",
           words = ["claim","consumer","student","camera","public","never","wonder","simple","thought","use"]
    Output: "simple"

    Constraints:
    * 1 <= licensePlate.length <= 7
    * licensePlate contains digits, letters (uppercase or lowercase), or space ' '.
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 15
    * words[i] consists of lower case English letters."""

    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        freq = Counter(ch for ch in licensePlate.lower() if ch.isalpha())
        ans = ""
        for word in words:
            if (not ans or len(word) < len(ans)) and not freq - Counter(word): ans = word
        return ans


    """749. Contain Virus (Hard)
    A virus is spreading rapidly, and your task is to quarantine the infected
    area by installing walls. The world is modeled as an m x n binary grid
    isInfected, where isInfected[i][j] == 0 represents uninfected cells, and
    isInfected[i][j] == 1 represents cells contaminated with the virus. A wall
    (and only one wall) can be installed between any two 4-directionally
    adjacent cells, on the shared boundary. Every night, the virus spreads to
    all neighboring cells in all four directions unless blocked by a wall.
    Resources are limited. Each day, you can install walls around only one
    region (i.e., the affected area (continuous block of infected cells) that
    threatens the most uninfected cells the following night). There will never
    be a tie. Return the number of walls used to quarantine all the infected
    regions. If the world will become fully infected, return the number of
    walls used.

    Example 1:
    Input: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]
    Output: 10
    Explanation: There are 2 contaminated regions. On the first day, add 5
                 walls to quarantine the viral region on the left. On the
                 second day, add 5 walls to quarantine the viral region on the
                 right. The virus is fully contained.

    Example 2:
    Input: isInfected = [[1,1,1],[1,0,1],[1,1,1]]
    Output: 4
    Explanation: Even though there is only one cell saved, there are 4 walls
                 built. Notice that walls are only built on the shared boundary
                 of two different cells.

    Example 3:
    Input: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]
    Output: 13
    Explanation: The region on the left only builds two new walls.

    Constraints:
    * m == isInfected.length
    * n == isInfected[i].length
    * 1 <= m, n <= 50
    * isInfected[i][j] is either 0 or 1.
    * There is always a contiguous viral region throughout the described
      process that will infect strictly more uncontaminated squares in the next
      round."""

    def containVirus(self, isInfected: List[List[int]]) -> int:
        m, n = len(isInfected), len(isInfected[0])
        ans = 0
        while True:
            regions = []
            fronts = []
            walls = []
            seen = set()
            for i in range(m):
                for j in range(n):
                    if isInfected[i][j] == 1 and (i, j) not in seen:
                        seen.add((i, j))
                        stack = [(i, j)]
                        regions.append([(i, j)])
                        fronts.append(set())
                        walls.append(0)
                        while stack:
                            r, c = stack.pop()
                            for rr, cc in (r-1, c), (r, c-1), (r, c+1), (r+1, c):
                                if 0 <= rr < m and 0 <= cc < n:
                                    if isInfected[rr][cc] == 1 and (rr, cc) not in seen:
                                        seen.add((rr, cc))
                                        stack.append((rr, cc))
                                        regions[-1].append((rr, cc))
                                    elif isInfected[rr][cc] == 0:
                                        fronts[-1].add((rr, cc))
                                        walls[-1] += 1
            if not regions: break
            idx = fronts.index(max(fronts, key = len))
            ans += walls[idx]
            for i, region in enumerate(regions):
                if i == idx:
                    for r, c in region: isInfected[r][c] = -1 # mark as quaranteened
                else:
                    for r, c in fronts[i]: isInfected[r][c] = 1 # mark as infected
        return ans


    """750. Number Of Corner Rectangles (Medium)
    Given a grid where each entry is only 0 or 1, find the number of corner
    rectangles. A corner rectangle is 4 distinct 1s on the grid that form an
    axis-aligned rectangle. Note that only the corners need to have the value
    1. Also, all four 1s used must be distinct.

    Example 1:
    Input: grid = [[1, 0, 0, 1, 0],
                   [0, 0, 1, 0, 1],
                   [0, 0, 0, 1, 0],
                   [1, 0, 1, 0, 1]]
    Output: 1
    Explanation: There is only one corner rectangle, with corners grid[1][2],
                 grid[1][4], grid[3][2], grid[3][4].

    Example 2:
    Input: grid = [[1, 1, 1],
                   [1, 1, 1],
                   [1, 1, 1]]
    Output: 9
    Explanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles,
                 and one 3x3 rectangle.

    Example 3:
    Input: grid = [[1, 1, 1, 1]]
    Output: 0
    Explanation: Rectangles must have four distinct corners.

    Note:
    * The number of rows and columns of grid will each be in the range [1, 200].
    * Each grid[i][j] will be either 0 or 1.
    * The number of 1s in the grid will be at most 6000."""

    def countCornerRectangles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions
        seen = {}
        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    for jj in range(j):
                        if grid[i][jj]:
                            ans += seen.get((jj, j), 0)
                            seen[jj, j] = 1 + seen.get((jj, j), 0)
        return ans


    """751. IP to CIDR (Medium)
    An IP address is a formatted 32-bit unsigned integer where each group of 8
    bits is printed as a decimal number and the dot character '.' splits the
    groups. For example, the binary number 00001111 10001000 11111111 01101011
    (spaces added for clarity) formatted as an IP address would be
    "15.136.255.107". A CIDR block is a format used to denote a specific set of
    IP addresses. It is a string consisting of a base IP address, followed by a
    slash, followed by a prefix length k. The addresses it covers are all the
    IPs whose first k bits are the same as the base IP address. For example,
    "123.45.67.89/20" is a CIDR block with a prefix length of 20. Any IP
    address whose binary representation matches
    01111011 00101101 0100xxxx xxxxxxxx, where x can be either 0 or 1, is in
    the set covered by the CIDR block. You are given a start IP address ip and
    the number of IP addresses we need to cover n. Your goal is to use as few
    CIDR blocks as possible to cover all the IP addresses in the inclusive
    range [ip, ip + n - 1] exactly. No other IP addresses outside of the range
    should be covered. Return the shortest list of CIDR blocks that covers the
    range of IP addresses. If there are multiple answers, return any of them.

    Example 1:
    Input: ip = "255.0.0.7", n = 10
    Output: ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
    Explanation: The IP addresses that need to be covered are:
                 - 255.0.0.7  -> 11111111 00000000 00000000 00000111
                 - 255.0.0.8  -> 11111111 00000000 00000000 00001000
                 - 255.0.0.9  -> 11111111 00000000 00000000 00001001
                 - 255.0.0.10 -> 11111111 00000000 00000000 00001010
                 - 255.0.0.11 -> 11111111 00000000 00000000 00001011
                 - 255.0.0.12 -> 11111111 00000000 00000000 00001100
                 - 255.0.0.13 -> 11111111 00000000 00000000 00001101
                 - 255.0.0.14 -> 11111111 00000000 00000000 00001110
                 - 255.0.0.15 -> 11111111 00000000 00000000 00001111
                 - 255.0.0.16 -> 11111111 00000000 00000000 00010000
                 The CIDR block "255.0.0.7/32" covers the first address. The
                 CIDR block "255.0.0.8/29" covers the middle 8 addresses
                 (binary format of 11111111 00000000 00000000 00001xxx). The
                 CIDR block "255.0.0.16/32" covers the last address. Note that
                 while the CIDR block "255.0.0.0/28" does cover all the
                 addresses, it also includes addresses outside of the range, so
                 we cannot use it.

    Example 2:
    Input: ip = "117.145.102.62", n = 8
    Output: ["117.145.102.62/31","117.145.102.64/30","117.145.102.68/31"]

    Constraints:
    * 7 <= ip.length <= 15
    * ip is a valid IPv4 on the form "a.b.c.d" where a, b, c, and d are
      integers in the range [0, 255].
    * 1 <= n <= 1000
    * Every implied address ip + x (for x < n) will be a valid IPv4 address."""

    def ipToCIDR(self, ip: str, n: int) -> List[str]:
        val = 0
        for x in ip.split('.'): val = (val << 8) | int(x)
        ans = []
        while n:
            for i in range(32):
                if val & 1<<i or (1<<i+1) > n: break
            parts = (val>>k & 255 for k in (24, 16, 8, 0))
            ans.append(f"{'.'.join(map(str, parts))}/{32-i}")
            n -= 1<<i
            val += 1<<i
        return ans


    """752. Open the Lock (Medium)
    You have a lock in front of you with 4 circular wheels. Each wheel has 10
    slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can
    rotate freely and wrap around: for example we can turn '9' to be '0', or
    '0' to be '9'. Each move consists of turning one wheel one slot. The lock
    initially starts at '0000', a string representing the state of the 4 wheels.
    You are given a list of deadends dead ends, meaning if the lock displays
    any of these codes, the wheels of the lock will stop turning and you will
    be unable to open it. Given a target representing the value of the wheels
    that will unlock the lock, return the minimum total number of turns
    required to open the lock, or -1 if it is impossible.

    Example 1:
    Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202"
    Output: 6
    Explanation:
    A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202".
    Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid,
    because the wheels of the lock become stuck after the display becomes the dead end "0102".

    Example 2:
    Input: deadends = ["8888"], target = "0009"
    Output: 1
    Explanation:
    We can turn the last wheel in reverse to move from "0000" -> "0009".

    Example 3:
    Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
    Output: -1
    Explanation:
    We can't reach the target without getting stuck.

    Example 4:
    Input: deadends = ["0000"], target = "8888"
    Output: -1

    Constraints:
    * 1 <= deadends.length <= 500
    * deadends[i].length == 4
    * target.length == 4
    * target will not be in the list deadends.
    * target and deadends[i] consist of digits only."""

    def openLock(self, deadends: List[str], target: str) -> int:
        pq = [(0, "0000")] # min priority queue
        seen = set(deadends)

        while pq:
            k, n = heappop(pq)
            if n not in seen:
                if n == target: return k
                seen.add(n)  # marked as seen upon processing
                for i in range(4):
                    for chg in (-1, 1):
                        nn = n[:i] + str((int(n[i]) + chg)%10) + n[i+1:]
                        if nn not in seen: heappush(pq, (k+1, nn))
        return -1


    """753. Cracking the Safe (Hard)
    There is a box protected by a password. The password is a sequence of n
    digits where each digit can be in the range [0, k - 1]. While entering a
    password, the last n digits entered will automatically be matched against
    the correct password. For example, assuming the correct password is "345",
    if you type "012345", the box will open because the correct password
    matches the suffix of the entered password. Return any password of minimum
    length that is guaranteed to open the box at some point of entering it.

    Example 1:
    Input: n = 1, k = 2
    Output: "10"
    Explanation: "01" will be accepted too.

    Example 2:
    Input: n = 2, k = 2
    Output: "01100"
    Explanation: "01100", "10011", "11001" will be accepted too.

    Constraints:
    * 1 <= n <= 4
    * 1 <= k <= 10
    * 1 <= kn <= 4096"""

    def crackSafe(self, n: int, k: int) -> str:
        """This problem is to find De Bruijn sequence"""
        if n == 1: return "".join(map(str, reversed(range(k))))

        def fn(x):
            """Return Eulerian path via Hierholzer's algo."""
            while mp.get(x, 0) < k:
                mp[x] = 1 + mp.get(x, 0)
                fn(x[1:] + str(mp[x]-1))
            if not ans: ans.append(x)
            else: ans.append(x[0])

        mp = {}
        ans = []
        fn("0"*(n-1))
        return "".join(ans)


    """754. Reach a Number (Medium)
    You are standing at position 0 on an infinite number line. There is a goal
    at position target. On each move, you can either go left or right. During
    the n-th move (starting from 1), you take n steps. Return the minimum
    number of steps required to reach the destination.

    Example 1:
    Input: target = 3
    Output: 2
    Explanation:
    On the first move we step from 0 to 1.
    On the second step we step from 1 to 3.

    Example 2:
    Input: target = 2
    Output: 3
    Explanation:
    On the first move we step from 0 to 1.
    On the second move we step  from 1 to -1.
    On the third move we step from -1 to 2.

    Note: target will be a non-zero integer in the range [-10^9, 10^9]."""

    def reachNumber(self, target: int) -> int:
        target = abs(target)
        k = ceil((-1 + sqrt(1 + 8*target))/2)
        return k if not k*(k+1)//2 - target & 1 else k + 1 + k%2


    """755. Pour Water (Medium)
    You are given an elevation map represents as an integer array heights where
    heights[i] representing the height of the terrain at index i. The width at
    each index is 1. You are also given two integers volume and k. volume units
    of water will fall at index k. Water first drops at the index k and rests
    on top of the highest terrain or water at that index. Then, it flows
    according to the following rules:
    * If the droplet would eventually fall by moving left, then move left.
    * Otherwise, if the droplet would eventually fall by moving right, then
      move right.
    * Otherwise, rise to its current position.
    Here, "eventually fall" means that the droplet will eventually be at a
    lower level if it moves in that direction. Also, level means the height of
    the terrain plus any water in that column. We can assume there is
    infinitely high terrain on the two sides out of bounds of the array. Also,
    there could not be partial water being spread out evenly on more than one
    grid block, and each unit of water has to be in exactly one block.

    Example 1:
    Input: heights = [2,1,1,2,1,2,2], volume = 4, k = 3
    Output: [2,2,2,3,2,2,2]
    Explanation: The first drop of water lands at index k = 3. When moving left
                 or right, the water can only move to the same level or a lower
                 level. (By level, we mean the total height of the terrain plus
                 any water in that column.) Since moving left will eventually
                 make it fall, it moves left. (A droplet "made to fall" means
                 go to a lower height than it was at previously.) Since moving
                 left will not make it fall, it stays in place. The next
                 droplet falls at index k = 3. Since the new droplet moving
                 left will eventually make it fall, it moves left. Notice that
                 the droplet still preferred to move left, even though it could
                 move right (and moving right makes it fall quicker.) The third
                 droplet falls at index k = 3. Since moving left would not
                 eventually make it fall, it tries to move right. Since moving
                 right would eventually make it fall, it moves right. Finally,
                 the fourth droplet falls at index k = 3. Since moving left
                 would not eventually make it fall, it tries to move right.
                 Since moving right would not eventually make it fall, it stays
                 in place.

    Example 2:
    Input: heights = [1,2,3,4], volume = 2, k = 2
    Output: [2,3,3,4]
    Explanation: The last droplet settles at index 1, since moving further left
                 would not cause it to eventually fall to a lower height.

    Example 3:
    Input: heights = [3,1,3], volume = 5, k = 1
    Output: [4,4,4]

    Constraints:
    * 1 <= heights.length <= 100
    * 0 <= heights[i] <= 99
    * 0 <= volume <= 2000
    * 0 <= k < heights.length"""

    def pourWater(self, heights: List[int], volume: int, k: int) -> List[int]:
        left, right = [], [] # 2 stacks
        lo = hi = k
        for _ in range(volume):

            while lo and heights[lo-1] <= heights[lo]:
                if heights[lo-1] < heights[lo]: left.append(lo-1)
                lo -= 1
            while hi+1 < len(heights) and heights[hi] >= heights[hi+1]:
                if heights[hi] > heights[hi+1]: right.append(hi+1)
                hi += 1

            if left:
                i = left[-1]
                heights[i] += 1
                if heights[i] == heights[i+1]: left.pop()
                if lo <= i-1: left.append(i-1)
            elif right:
                i = right[-1]
                heights[i] += 1
                if heights[i-1] == heights[i]: right.pop()
                if i+1 <= hi: right.append(i+1)
            else:
                heights[k] += 1
                if k and heights[k-1] < heights[k]: left.append(k-1)
                if k+1 < len(heights) and heights[k] > heights[k+1]: right.append(k+1)
        return heights


    """756. Pyramid Transition Matrix (Medium)
    We are stacking blocks to form a pyramid. Each block has a color which is a
    one letter string. We are allowed to place any color block C on top of two
    adjacent blocks of colors A and B, if and only if ABC is an allowed triple.
    We start with a bottom row of bottom, represented as a single string. We
    also start with a list of allowed triples allowed. Each allowed triple is
    represented as a string of length 3. Return true if we can build the pyramid
    all the way to the top, otherwise false.

    Example 1:
    Input: bottom = "BCD", allowed = ["BCG", "CDE", "GEA", "FFF"]
    Output: true
    Explanation: We can stack the pyramid like this:
        A
       / \
      G   E
     / \ / \
    B   C   D
    We are allowed to place G on top of B and C because BCG is an allowed triple.
    Similarly, we can place E on top of C and D, then A on top of G and E.

    Example 2:
    Input: bottom = "AABA", allowed = ["AAA", "AAB", "ABA", "ABB", "BAC"]
    Output: false
    Explanation: We can't stack the pyramid to the top. Note that there could
                 be allowed triples (A, B, C) and (A, B, D) with C != D.

    Constraints:
    * bottom will be a string with length in range [2, 8].
    * allowed will have length in range [0, 200].
    * Letters in all strings will be chosen from the set {'A', 'B', 'C', 'D', 'E', 'F', 'G'}."""

    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        mp = {}
        for x, y, z in allowed: mp.setdefault((x, y), []).append(z)

        def fn(row):
            """Return True if row could be built from allowed transition."""
            if len(row) == 1: return True
            for xx in product(*(mp.get((x, y), []) for x, y in zip(row, row[1:]))):
                if fn(xx): return True
            return False

        return fn(bottom)


    """757. Set Intersection Size At Least Two (Hard)
    An integer interval [a, b] (for integers a < b) is a set of all consecutive
    integers from a to b, including a and b. Find the minimum size of a set S
    such that for every integer interval A in intervals, the intersection of S
    with A has a size of at least two.

    Example 1:
    Input: intervals = [[1,3],[1,4],[2,5],[3,5]]
    Output: 3
    Explanation: Consider the set S = {2, 3, 4}.  For each interval, there are
                 at least 2 elements from S in the interval. Also, there isn't
                 a smaller size set that fulfills the above condition. Thus, we
                 output the size of this set, which is 3.

    Example 2:
    Input: intervals = [[1,2],[2,3],[2,4],[4,5]]
    Output: 5
    Explanation: An example of a minimum sized set is {1, 2, 3, 4, 5}.

    Constraints:
    * 1 <= intervals.length <= 3000
    * intervals[i].length == 2
    * 0 <= ai < bi <= 10^8"""

    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        ans = []
        for x, y in sorted(intervals, key=lambda x: (x[1], -x[0])):
            if not ans or ans[-2] < x:
                if ans and x <= ans[-1]: ans.append(y)
                else: ans.extend([y-1, y])
        return len(ans)


    """758. Bold Words in String (Easy)
    Given a set of keywords words and a string S, make all appearances of all
    keywords in S bold. Any letters between <b> and </b> tags become bold. The
    returned string should use the least number of tags possible, and of course
    the tags should form a valid combination. For example, given that
    words = ["ab", "bc"] and S = "aabcd", we should return "a<b>abc</b>d". Note
    that returning "a<b>a<b>b</b>c</b>d" would use more tags, so it is incorrect.

    Constraints:
    * words has length in range [0, 50].
    * words[i] has length in range [1, 10].
    * S has length in range [0, 500].
    * All characters in words[i] and S are lowercase letters.
    * Note: This question is the same as 616: https://leetcode.com/problems/add-bold-tag-in-string/"""

    def boldWords(self, words: List[str], s: str) -> str:
        line = [0] * (len(s)+1)
        for word in words:
            k = -1
            while True:
                k = s.find(word, k+1)
                if k == -1: break
                line[k] += 1
                line[k+len(word)] -= 1
        ans = []
        prefix = 0
        for i in range(len(s)):
            if not prefix and prefix + line[i]: ans.append("<b>")
            ans.append(s[i])
            prefix += line[i]
            if prefix and not prefix + line[i+1]: ans.append("</b>")
        return "".join(ans)


    """759. Employee Free Time (Hard)
    We are given a list schedule of employees, which represents the working
    time for each employee. Each employee has a list of non-overlapping
    Intervals, and these intervals are in sorted order. Return the list of
    finite intervals representing common, positive-length free time for all
    employees, also in sorted order. (Even though we are representing Intervals
    in the form [x, y], the objects inside are Intervals, not lists or arrays.
    For example, schedule[0][0].start = 1, schedule[0][0].end = 2, and
    schedule[0][0][0] is not defined).  Also, we wouldn't include intervals
    like [5, 5] in our answer, as they have zero length.

    Example 1:
    Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
    Output: [[3,4]]
    Explanation: There are a total of three employees, and all common free time
                 intervals would be [-inf, 1], [3, 4], [10, inf]. We discard
                 any intervals that contain inf as they aren't finite.

    Example 2:
    Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
    Output: [[5,6],[7,9]]

    Constraints:
    * 1 <= schedule.length , schedule[i].length <= 50
    * 0 <= schedule[i].start < schedule[i].end <= 10^8"""

    def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
        line = defaultdict(int)
        for elem in schedule:
            for x in elem:
                line[x.start] += 1
                line[x.end] -= 1
        ans = []
        prev = -inf
        prefix = 0
        for k, v in sorted(line.items()):
            if prefix == 0 and prev > -inf: ans.append(Interval(prev, k))
            prefix += v
            if prefix == 0: prev = k
        return ans


    """760. Find Anagram Mappings (Easy)
    Given two lists Aand B, and B is an anagram of A. B is an anagram of A
    means B is made by randomizing the order of the elements in A. We want to
    find an index mapping P, from A to B. A mapping P[i] = j means the ith
    element in A appears in B at index j. These lists A and B may contain
    duplicates. If there are multiple answers, output any of them. For example,
    given
    A = [12, 28, 46, 32, 50]
    B = [50, 12, 32, 46, 28]

    We should return [1, 4, 3, 2, 0] as P[0] = 1 because the 0th element of A
    appears at B[1], and P[1] = 4 because the 1st element of A appears at B[4],
    and so on.

    Note:
    * A, B have equal lengths in range [1, 100].
    * A[i], B[i] are integers in range [0, 10^5]."""

    def anagramMappings(self, A: List[int], B: List[int]) -> List[int]:
        mp = {}
        for i, x in enumerate(B):
            mp.setdefault(x, []).append(i)

        ans = []
        for x in A:
            ans.append(mp[x].pop())
        return ans


    """763. Partition Labels (Medium)
    A string S of lowercase English letters is given. We want to partition this
    string into as many parts as possible so that each letter appears in at
    most one part, and return a list of integers representing the size of these
    parts.

    Example 1:
    Input: S = "ababcbacadefegdehijhklij"
    Output: [9,7,8]
    Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a
                 partition so that each letter appears in at most one part. A
                 partition like "ababcbacadefegde", "hijhklij" is incorrect,
                 because it splits S into less parts.
    Note:
    * S will have length in range [1, 500].
    * S will consist of lowercase English letters ('a' to 'z') only."""

    def partitionLabels(self, s: str) -> List[int]:
        last = {ch : i for i, ch in enumerate(s)}
        ans = []
        lo = hi = 0
        for i, ch in enumerate(s):
            hi = max(hi, last[ch])
            if i == hi:
                ans.append(hi - lo + 1)
                lo = hi + 1
        return ans


    """764. Largest Plus Sign (Medium)
    In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except
    those cells in the given list mines which are 0. What is the largest axis-
    aligned plus sign of 1s contained in the grid? Return the order of the
    plus sign. If there is none, return 0. An "axis-aligned plus sign of 1s of
    order k" has some center grid[x][y] = 1 along with 4 arms of length k-1
    going up, down, left, and right, and made of 1s. This is demonstrated in
    the diagrams below. Note that there could be 0s or 1s beyond the arms of
    the plus sign, only the relevant area of the plus sign is checked for 1s.

    Examples of Axis-Aligned Plus Signs of Order k:
    Order 1:
    000
    010
    000

    Order 2:
    00000
    00100
    01110
    00100
    00000

    Order 3:
    0000000
    0001000
    0001000
    0111110
    0001000
    0001000
    0000000

    Example 1:
    Input: N = 5, mines = [[4, 2]]
    Output: 2
    Explanation:
    11111
    11111
    11111
    11111
    11011
    In the above grid, the largest plus sign can only be order 2. One of them
    is marked in bold.

    Example 2:
    Input: N = 2, mines = []
    Output: 1
    Explanation: There is no plus sign of order 2, but there is of order 1.

    Example 3:

    Input: N = 1, mines = [[0, 0]]
    Output: 0
    Explanation:
    There is no plus sign, so return 0.

    Note:
    * N will be an integer in the range [1, 500].
    * mines will have length at most 5000.
    * mines[i] will be length 2 and consist of integers in the range [0, N-1].
    * (Additionally, programs submitted in C, C++, or C# will be judged with a
      slightly smaller time limit.)"""

    def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -> int:
        dp = [[n] * n for _ in range(n)]
        for i, j in mines: dp[i][j] = 0

        for i in range(n):
            ll = dd = rr = uu = 0
            for j in range(n):
                dp[i][j] = min(dp[i][j], ll := ll+1 if dp[i][j] else 0)
                dp[j][i] = min(dp[j][i], dd := dd+1 if dp[j][i] else 0)
                dp[i][~j] = min(dp[i][~j], rr := rr+1 if dp[i][~j] else 0)
                dp[~j][i] = min(dp[~j][i], uu := uu+1 if dp[~j][i] else 0)

        return max(map(max, dp))


    """765. Couples Holding Hands (Hard)
    N couples sit in 2N seats arranged in a row and want to hold hands. We want
    to know the minimum number of swaps so that every couple is sitting side by
    side. A swap consists of choosing any two people, then they stand up and
    switch seats. The people and seats are represented by an integer from 0 to
    2N-1, the couples are numbered in order, the first couple being (0, 1), the
    second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).
    The couples' initial seating is given by row[i] being the value of the person
    who is initially sitting in the i-th seat.

    Example 1:
    Input: row = [0, 2, 1, 3]
    Output: 1
    Explanation: We only need to swap the second (row[1]) and third (row[2]) person.

    Example 2:
    Input: row = [3, 2, 0, 1]
    Output: 0
    Explanation: All couples are already seated side by side.

    Note:
    * len(row) is even and in the range of [4, 60].
    * row is guaranteed to be a permutation of 0...len(row)-1."""

    def minSwapsCouples(self, row: List[int]) -> int:
        loc = {x: i for i, x in enumerate(row)}
        ans = 0
        for i in range(0, len(row), 2):
            p = row[i] - 1 if row[i]&1 else row[i]+1
            if row[i+1] != p:
                ans += 1
                ii = loc[p]
                loc[row[i+1]], loc[row[ii]] = loc[row[ii]], loc[row[i+1]] # swap mappings
                row[i+1], row[ii] = row[ii], row[i+1] # swap values
        return ans


    """767. Reorganize String (Medium)
    Given a string S, check if the letters can be rearranged so that two
    characters that are adjacent to each other are not the same. If possible,
    output any possible result.  If not possible, return the empty string.

    Example 1:
    Input: S = "aab"
    Output: "aba"

    Example 2:
    Input: S = "aaab"
    Output: ""
    Note: S will consist of lowercase letters and have length in range [1, 500]."""

    def reorganizeString(self, S: str) -> str:
        freq = {}
        for c in S: freq[c] = 1 +freq.get(c, 0) # frequency table

        ans = [""]*len(S)
        i = 0
        for k in sorted(freq, reverse=True, key=freq.get):
            if 2*freq[k] - 1 > len(S): return "" # impossible
            for _ in range(freq[k]):
                ans[i] = k
                i = i+2 if i+2 < len(S) else 1 # reset to 1
        return "".join(ans)


    """768. Max Chunks To Make Sorted II (Hard)
    You are given an integer array arr. We split arr into some number of chunks
    (i.e., partitions), and individually sort each chunk. After concatenating
    them, the result should equal the sorted array. Return the largest number
    of chunks we can make to sort the array.

    Example 1:
    Input: arr = [5,4,3,2,1]
    Output: 1
    Explanation: Splitting into two or more chunks will not return the required
                 result. For example, splitting into [5, 4], [3, 2, 1] will
                 result in [4, 5, 1, 2, 3], which isn't sorted.

    Example 2:
    Input: arr = [2,1,3,4,4]
    Output: 4
    Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4].
                 However, splitting into [2, 1], [3], [4], [4] is the highest
                 number of chunks possible.

    Constraints:
    * 1 <= arr.length <= 2000
    * 0 <= arr[i] <= 10^8"""

    def maxChunksToSorted(self, arr: List[int]) -> int:
        stack = []
        for i, x in enumerate(arr):
            most = x
            while stack and stack[-1] > x: most = max(most, stack.pop())
            stack.append(most)
        return len(stack)


    """769. Max Chunks To Make Sorted (Medium)
    Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we
    split the array into some number of "chunks" (partitions), and individually
    sort each chunk.  After concatenating them, the result equals the sorted
    array. What is the most number of chunks we could have made?

    Example 1:
    Input: arr = [4,3,2,1,0]
    Output: 1
    Explanation: Splitting into two or more chunks will not return the required
                 result. For example, splitting into [4, 3], [2, 1, 0] will
                 result in [3, 4, 0, 1, 2], which isn't sorted.

    Example 2:
    Input: arr = [1,0,2,3,4]
    Output: 4
    Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4].
                 However, splitting into [1, 0], [2], [3], [4] is the highest
                 number of chunks possible.

    Note:
    * arr will have length in range [1, 10].
    * arr[i] will be a permutation of [0, 1, ..., arr.length - 1]."""

    def maxChunksToSorted(self, arr: List[int]) -> int:
        ans = prefix = 0
        for i, x in enumerate(arr):
            prefix = max(prefix, x)
            if i == prefix: ans += 1
        return ans


    """772. Basic Calculator III (Hard)
    Implement a basic calculator to evaluate a simple expression string. The
    expression string contains only non-negative integers, '+', '-', '*', '/'
    operators, and open '(' and closing parentheses ')'. The integer division
    should truncate toward zero. You may assume that the given expression is
    always valid. All intermediate results will be in the range of
    [-2^31, 2^31 - 1]. Note: You are not allowed to use any built-in function
    which evaluates strings as mathematical expressions, such as eval().

    Example 1:
    Input: s = "1+1"
    Output: 2

    Example 2:
    Input: s = "6-4/2"
    Output: 4

    Example 3:
    Input: s = "2*(5+5*2)/3+(6/2+8)"
    Output: 21

    Constraints:
    * 1 <= s <= 10^4
    * s consists of digits, '+', '-', '*', '/', '(', and ')'.
    * s is a valid expression."""

    def calculate(self, s: str) -> int:
        s = f"({s})"
        precedence = {'(' : 0, ')' : 1, '+' : 1, '-' : 1, '*' : 2, '/' : 2}
        ops = []
        postfix = []
        for i, ch in enumerate(s):
            if ch.isdigit(): v = 10*v + int(ch)
            else:
                if i and s[i-1].isdigit(): postfix.append(v)
                v = 0
                if ch == '(': ops.append(ch)
                else:
                    while ops and precedence[ops[-1]] >= precedence[ch]: postfix.append(ops.pop())
                    if ch == ')': ops.pop()
                    else: ops.append(ch)
        stack = []
        for v in postfix:
            if isinstance(v, str):
                y = stack.pop()
                x = stack.pop()
                if v == '+': x += y
                elif v == '-': x -= y
                elif v == '*': x *= y
                else: x = int(x/y)
                stack.append(x)
            else: stack.append(v)
        return stack.pop()


    """773. Sliding Puzzle (Hard)
    On a 2x3 board, there are 5 tiles represented by the integers 1 through 5,
    and an empty square represented by 0. A move consists of choosing 0 and a
    4-directionally adjacent number and swapping it. The state of the board is
    solved if and only if the board is [[1,2,3],[4,5,0]]. Given a puzzle board,
    return the least number of moves required so that the state of the board is
    solved. If it is impossible for the state of the board to be solved, return
    -1.

    Examples:
    Input: board = [[1,2,3],[4,0,5]]
    Output: 1
    Explanation: Swap the 0 and the 5 in one move.

    Input: board = [[1,2,3],[5,4,0]]
    Output: -1
    Explanation: No number of moves will make the board solved.

    Input: board = [[4,1,2],[5,0,3]]
    Output: 5
    Explanation: 5 is the smallest number of moves that solves the board.
    An example path:
    After move 0: [[4,1,2],[5,0,3]]
    After move 1: [[4,1,2],[0,5,3]]
    After move 2: [[0,1,2],[4,5,3]]
    After move 3: [[1,0,2],[4,5,3]]
    After move 4: [[1,2,0],[4,5,3]]
    After move 5: [[1,2,3],[4,5,0]]

    Input: board = [[3,2,4],[1,5,0]]
    Output: 14

    Note:
    * board will be a 2 x 3 array as described above.
    * board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5]."""

    def slidingPuzzle(self, board: List[List[int]]) -> int:
        board = board[0] + board[1] # flatten into vector

        ans = 0
        seen = set([tuple(board)])
        queue = [board]
        while queue:
            newq = []
            for x in queue:
                if x == [1,2,3,4,5,0]: return ans
                k = x.index(0)
                for kk in (k-1, k+1, k-3, k+3):
                    if 0 <= kk < 6 and (k, kk) not in ((2, 3), (3, 2)):
                        xx = x.copy()
                        xx[k], xx[kk] = xx[kk], xx[k]
                        if tuple(xx) not in seen:
                            seen.add(tuple(xx))
                            newq.append(xx)
            queue = newq
            ans += 1
        return -1


    """774. Minimize Max Distance to Gas Station (Hard)
    You are given an integer array stations that represents the positions of
    the gas stations on the x-axis. You are also given an integer k. You should
    add k new gas stations. You can add the stations anywhere on the x-axis,
    and not necessarily on an integer position. Let penalty() be the maximum
    distance between adjacent gas stations after adding the k new stations.
    Return the smallest possible value of penalty(). Answers within 10^-6 of
    the actual answer will be accepted.

    Example 1:
    Input: stations = [1,2,3,4,5,6,7,8,9,10], k = 9
    Output: 0.50000

    Example 2:
    Input: stations = [23,24,36,39,46,56,57,65,84,98], k = 1
    Output: 14.00000

    Constraints:
    * 10 <= stations.length <= 2000
    * 0 <= stations[i] <= 10^8
    * stations is sorted in a strictly increasing order.
    * 1 <= k <= 10^6"""

    def minmaxGasDist(self, stations: List[int], k: int) -> float:
        lo, hi = 0, stations[-1] - stations[0]
        while lo + 1e-6 < hi:
            mid = (lo + hi)/2
            if sum((stations[i+1]-stations[i])//mid for i in range(len(stations)-1)) <= k: hi = mid
            else: lo = mid
        return lo


    """776. Split BST (Medium)
    Given the root of a binary search tree (BST) and an integer target, split
    the tree into two subtrees where one subtree has nodes that are all smaller
    or equal to the target value, while the other subtree has all nodes that
    are greater than the target value. It Is not necessarily the case that the
    tree contains a node with the value target. Additionally, most of the
    structure of the original tree should remain. Formally, for any child c
    with parent p in the original tree, if they are both in the same subtree
    after the split, then node c should still have the parent p. Return an
    array of the two roots of the two subtrees.

    Example 1:
    Input: root = [4,2,6,1,3,5,7], target = 2
    Output: [[2,1],[4,3,6,null,null,5,7]]

    Example 2:
    Input: root = [1], target = 1
    Output: [[1],[]]

    Constraints:
    * The number of nodes in the tree is in the range [1, 50].
    * 0 <= Node.val, target <= 1000"""

    def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:

        def fn(node):
            """Return splitted BST."""
            if not node: return None, None
            if node.val <= target:
                left, right = fn(node.right)
                node.right = left
                return node, right
            else:
                left, right = fn(node.left)
                node.left = right
                return left, node

        return fn(root)


    """777. Swap Adjacent in LR String (Medium)
    In a string composed of 'L', 'R', and 'X' characters, like "RXXLRXRXL", a
    move consists of either replacing one occurrence of "XL" with "LX", or
    replacing one occurrence of "RX" with "XR". Given the starting string start
    and the ending string end, return True if and only if there exists a
    sequence of moves to transform one string to the other.

    Example 1:
    Input: start = "RXXLRXRXL", end = "XRLXXRRLX"
    Output: true
    Explanation: We can transform start to end following these steps:
    RXXLRXRXL ->
    XRXLRXRXL ->
    XRLXRXRXL ->
    XRLXXRRXL ->
    XRLXXRRLX

    Example 2:
    Input: start = "X", end = "L"
    Output: false

    Example 3:
    Input: start = "LLR", end = "RRL"
    Output: false

    Example 4:
    Input: start = "XL", end = "LX"
    Output: true

    Example 5:
    Input: start = "XLLR", end = "LXLX"
    Output: false

    Constraints:
    * 1 <= start.length <= 10^4
    * start.length == end.length
    * Both start and end will only consist of characters in 'L', 'R', and 'X'."""

    def canTransform(self, start: str, end: str) -> bool:
        ss = [(x, i) for i, x in enumerate(start) if x != "X"]
        ee = [(x, i) for i, x in enumerate(end) if x != "X"]

        if len(ss) != len(ee): return False

        for (s, i), (e, j) in zip(ss, ee):
            if s != e: return False
            if s == e == "L" and i < j: return False
            if s == e == "R" and i > j: return False
        return True


    """778. Swim in Rising Water (Hard)
    On an N x N grid, each square grid[i][j] represents the elevation at that
    point (i,j). Now rain starts to fall. At time t, the depth of the water
    everywhere is t. You can swim from a square to another 4-directionally
    adjacent square if and only if the elevation of both squares individually
    are at most t. You can swim infinite distance in zero time. Of course, you
    must stay within the boundaries of the grid during your swim. You start at
    the top left square (0, 0). What is the least time until you can reach the
    bottom right square (N-1, N-1)?

    Example 1:
    Input: [[0,2],[1,3]]
    Output: 3
    Explanation: At time 0, you are in grid location (0, 0). You cannot go
                 anywhere else because 4-directionally adjacent neighbors have
                 a higher elevation than t = 0. You cannot reach point (1, 1)
                 until time 3. When the depth of water is 3, we can swim
                 anywhere inside the grid.

    Example 2:
    Input: [[ 0, 1, 2, 3, 4],
            [24,23,22,21, 5],
            [12,13,14,15,16],
            [11,17,18,19,20],
            [10, 9, 8, 7, 6]]
    Output: 16
    Explanation:
     0  1  2  3  4
    24 23 22 21  5
    12 13 14 15 16
    11 17 18 19 20
    10  9  8  7  6

    The final route is marked in bold. We need to wait until time 16 so that
    (0, 0) and (4, 4) are connected.

    Note:
    * 2 <= N <= 50.
    * grid[i][j] is a permutation of [0, ..., N*N - 1]."""

    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid) # dimension
        pq = [(grid[0][0], 0, 0)]
        seen = {(0, 0)}
        while pq:
            k, i, j = heappop(pq)
            if i == j == n-1: return k
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < n and 0 <= jj < n and (ii, jj) not in seen:
                    heappush(pq, (max(k, grid[ii][jj]), ii, jj))
                    seen.add((ii, jj))


    """779. K-th Symbol in Grammar (Medium)
    On the first row, we write a 0. Now in every subsequent row, we look at the
    previous row and replace each occurrence of 0 with 01, and each occurrence
    of 1 with 10. Given row N and index K, return the K-th indexed symbol in
    row N. (The values of K are 1-indexed.) (1 indexed).

    Examples:
    Input: N = 1, K = 1
    Output: 0

    Input: N = 2, K = 1
    Output: 0

    Input: N = 2, K = 2
    Output: 1

    Input: N = 4, K = 5
    Output: 1

    Explanation:
    row 1: 0
    row 2: 01
    row 3: 0110
    row 4: 01101001

    Note:
    * N will be an integer in the range [1, 30].
    * K will be an integer in the range [1, 2^(N-1)]."""

    def kthGrammar(self, N: int, K: int) -> int:
        return bin(K-1).count("1") & 1


    """780. Reaching Points (Hard)
    Given four integers sx, sy, tx, and ty, return true if it is possible to
    convert the point (sx, sy) to the point (tx, ty) through some operations,
    or false otherwise. The allowed operation on some point (x, y) is to
    convert it to either (x, x + y) or (x + y, y).

    Example 1:
    Input: sx = 1, sy = 1, tx = 3, ty = 5
    Output: true
    Explanation: One series of moves that transforms the starting point to the
                 target is:
                 (1, 1) -> (1, 2)
                 (1, 2) -> (3, 2)
                 (3, 2) -> (3, 5)

    Example 2:
    Input: sx = 1, sy = 1, tx = 2, ty = 2
    Output: false

    Example 3:
    Input: sx = 1, sy = 1, tx = 1, ty = 1
    Output: true

    Constraints: 1 <= sx, sy, tx, ty <= 10^9"""

    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
        while sx < tx or sy < ty:
            if tx > ty:
                k = (tx - sx)//ty
                if k == 0: break
                tx -= k * ty
            else:
                k = (ty - sy)//tx
                if k == 0: break
                ty -= k * tx
        return sx == tx and sy == ty


    """781. Rabbits in Forest (Medium)
    In a forest, each rabbit has some color. Some subset of rabbits (possibly
    all of them) tell you how many other rabbits have the same color as them.
    Those answers are placed in an array. Return the minimum number of rabbits
    that could be in the forest.

    Examples:
    Input: answers = [1, 1, 2]
    Output: 5
    Explanation:
    The two rabbits that answered "1" could both be the same color, say red.
    The rabbit than answered "2" can't be red or the answers would be
    inconsistent. Say the rabbit that answered "2" was blue. Then there should
    be 2 other blue rabbits in the forest that didn't answer into the array.
    The smallest possible number of rabbits in the forest is therefore 5: 3
    that answered plus 2 that didn't.

    Input: answers = [10, 10, 10]
    Output: 11

    Input: answers = []
    Output: 0

    Note:
    * answers will have length at most 1000.
    * Each answers[i] will be an integer in the range [0, 999]."""

    def numRabbits(self, answers: List[int]) -> int:
        ans = 0
        cnt = defaultdict(int)
        for x in answers:
            if not cnt[x] % (1 + x): ans += 1 + x # reached capacity & update ans
            cnt[x] += 1
        return ans


    """782. Transform to Chessboard (Hard)
    You are given an n x n binary grid board. In each move, you can swap any
    two rows with each other, or any two columns with each other. Return the
    minimum number of moves to transform the board into a chessboard board. If
    the task is impossible, return -1. A chessboard board is a board where no
    0's and no 1's are 4-directionally adjacent.

    Example 1:
    Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
    Output: 2
    Explanation: One potential sequence of moves is shown. The first move swaps
                 the first and second column. The second move swaps the second
                 and third row.

    Example 2:
    Input: board = [[0,1],[1,0]]
    Output: 0
    Explanation: Also note that the board with 0 in the top left corner, is
                 also a valid chessboard.

    Example 3:
    Input: board = [[1,0],[1,0]]
    Output: -1
    Explanation: No matter what sequence of moves you make, you cannot end with
                 a valid chessboard.

    Constraints:
    * n == board.length
    * n == board[i].length
    * 2 <= n <= 30
    * board[i][j] is either 0 or 1."""

    def movesToChessboard(self, board: List[List[int]]) -> int:
        n = len(board)

        def fn(vals):
            """Return min moves to transform to chessboard."""
            total = odd = 0
            for i, x in enumerate(vals):
                if vals[0] == x:
                    total += 1
                    if i&1: odd += 1
                elif vals[0] ^ x != (1 << n) - 1: return inf
            ans = inf
            if len(vals) <= 2*total <= len(vals)+1: ans = min(ans, odd)
            if len(vals)-1 <= 2*total <= len(vals): ans = min(ans, total - odd)
            return ans

        rows, cols = [0]*n, [0]*n
        for i in range(n):
            for j in range(n):
                if board[i][j]:
                    rows[i] ^= 1 << j
                    cols[j] ^= 1 << i
        ans = fn(rows) + fn(cols)
        return ans if ans < inf else -1


    """783. Minimum Distance Between BST Nodes (Easy)
    Given the root of a Binary Search Tree (BST), return the minimum difference
    between the values of any two different nodes in the tree.

    Example 1:
    Input: root = [4,2,6,1,3]
    Output: 1

    Example 2:
    Input: root = [1,0,48,null,null,12,49]
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [2, 100].
    * 0 <= Node.val <= 10^5

    Note: This question is the same as 530:
          https://leetcode.com/problems/minimum-absolute-difference-in-bst/"""

    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        ans, prev = inf, -1
        node = root
        stack = []
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                if prev >= 0: ans = min(ans, node.val - prev)
                prev = node.val
                node = node.right
        return ans


    """784. Letter Case Permutation (Medium)
    Given a string S, we can transform every letter individually to be
    lowercase or uppercase to create another string. Return a list of all
    possible strings we could create. You can return the output in any order.

    Example 1:
    Input: S = "a1b2"
    Output: ["a1b2","a1B2","A1b2","A1B2"]

    Example 2:
    Input: S = "3z4"
    Output: ["3z4","3Z4"]

    Example 3:
    Input: S = "12345"
    Output: ["12345"]

    Example 4:
    Input: S = "0"
    Output: ["0"]

    Constraints:
    * S will be a string with length between 1 and 12.
    * S will consist only of letters or digits."""

    def letterCasePermutation(self, S: str) -> List[str]:
        ans = [""]
        for c in S:
            ans = [x + cc for x in ans for cc in {c, c.swapcase()}]
        return ans


    """785. Is Graph Bipartite? (Medium)
    There is an undirected graph with n nodes, where each node is numbered
    between 0 and n - 1. You are given a 2D array graph, where graph[u] is an
    array of nodes that node u is adjacent to. More formally, for each v in
    graph[u], there is an undirected edge between node u and node v. The graph
    has the following properties:
    * There are no self-edges (graph[u] does not contain u).
    * There are no parallel edges (graph[u] does not contain duplicate values).
    * If v is in graph[u], then u is in graph[v] (the graph is undirected).
    * The graph may not be connected, meaning there may be two nodes u and v
      such that there is no path between them.
    A graph is bipartite if the nodes can be partitioned into two independent
    sets A and B such that every edge in the graph connects a node in set A and
    a node in set B. Return true if and only if it is bipartite.

    Example 1:
    Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
    Output: false
    Explanation: There is no way to partition the nodes into two independent
                 sets such that every edge connects a node in one and a node in
                 the other.

    Example 2:
    Input: graph = [[1,3],[0,2],[1,3],[0,2]]
    Output: true
    Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.

    Constraints:
    * graph.length == n
    * 1 <= n <= 100
    * 0 <= graph[u].length < n
    * 0 <= graph[u][i] <= n - 1
    * graph[u] does not contain u.
    * All the values of graph[u] are unique.
    * If graph[u] contains v, then graph[v] contains u."""

    def isBipartite(self, graph: List[List[int]]) -> bool:
        seen = [0]*len(graph)

        for k in range(len(graph)):
            if not seen[k]:
                seen[k] = 1
                stack = [k]
                while stack:
                    n = stack.pop()
                    for nn in graph[n]:
                        if not seen[nn]:
                            seen[nn] = seen[n] + 1
                            stack.append(nn)
                        elif seen[n] & 1 == seen[nn] & 1: return False # check parity
        return True


    """786. K-th Smallest Prime Fraction (Hard)
    You are given a sorted integer array arr containing 1 and prime numbers,
    where all the integers of arr are unique. You are also given an integer k.
    For every i and j where 0 <= i < j < arr.length, we consider the fraction
    arr[i] / arr[j]. Return the kth smallest fraction considered. Return your
    answer as an array of integers of size 2, where answer[0] == arr[i] and
    answer[1] == arr[j].

    Example 1:
    Input: arr = [1,2,3,5], k = 3
    Output: [2,5]
    Explanation: The fractions to be considered in sorted order are:
                 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.
                 The third fraction is 2/5.

    Example 2:
    Input: arr = [1,7], k = 1
    Output: [1,7]

    Constraints:
    * 2 <= arr.length <= 1000
    * 1 <= arr[i] <= 3 * 10^4
    * arr[0] == 1
    * arr[i] is a prime number for i > 0.
    * All the numbers of arr are unique and sorted in strictly increasing order.
    * 1 <= k <= arr.length * (arr.length - 1) / 2"""

    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
        pq = [(arr[i]/arr[-1], i, -1) for i in range(len(arr)-1)]
        for _ in range(k):
            _, i, j = heappop(pq)
            if i - j + 1 < len(arr): heappush(pq, (arr[i]/arr[j-1], i, j-1))
        return [arr[i], arr[j]]


    """787. Cheapest Flights Within K Stops (Medium)
    There are n cities connected by m flights. Each flight starts from city u
    and arrives at v with a price w. Now given all the cities and flights,
    together with starting city src and the destination dst, your task is to
    find the cheapest price from src to dst with up to k stops. If there is no
    such route, output -1.

    Example 1:
    Input:
    n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
    src = 0, dst = 2, k = 1
    Output: 200
    Explanation: The cheapest price from city 0 to city 2 with at most 1 stop
                 costs 200, as marked red in the picture.

    Example 2:
    Input:
    n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
    src = 0, dst = 2, k = 0
    Output: 500
    Explanation: The cheapest price from city 0 to city 2 with at most 0 stop
                 costs 500, as marked blue in the picture.

    Constraints:
    * The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.
    * The size of flights will be in range [0, n * (n - 1) / 2].
    * The format of each flight will be (src, dst, price).
    * The price of each flight will be in the range [1, 10000].
    * k is in the range of [0, n - 1].
    * There will not be any duplicated flights or self cycles."""

    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        graph = [[] for _ in range(n)]
        for u, v, p in flights: graph[u].append((v, p))
        pq = [(0, src, 0)]
        dist = [(inf, inf)] * n
        dist[src] = (0, 0)
        while pq:
            p, u, x = heappop(pq)
            if u == dst: return p
            if x <= k:
                for v, pp in graph[u]:
                    if p+pp < dist[v][0] or x+1 < dist[v][1]:
                        heappush(pq, (p+pp, v, x+1))
                        dist[v] = min(dist[v], (p+pp, x+1))
        return -1


    """789. Escape The Ghosts (Medium)
    You are playing a simplified PAC-MAN game on an infinite 2-D grid. You
    start at the point [0, 0], and you are given a destination point
    target = [xtarget, ytarget], which you are trying to get to. There are
    several ghosts on the map with their starting positions given as an array
    ghosts, where ghosts[i] = [xi, yi] represents the starting position of the
    ith ghost. All inputs are integral coordinates. Each turn, you and all the
    ghosts may independently choose to either move 1 unit in any of the four
    cardinal directions: north, east, south, or west or stay still. All actions
    happen simultaneously. You escape if and only if you can reach the target
    before any ghost reaches you. If you reach any square (including the
    target) at the same time as a ghost, it does not count as an escape. Return
    true if it is possible to escape, otherwise return false.

    Example 1:
    Input: ghosts = [[1,0],[0,3]], target = [0,1]
    Output: true
    Explanation: You can reach the destination (0, 1) after 1 turn, while the
                 ghosts located at (1, 0) and (0, 3) cannot catch up with you.

    Example 2:
    Input: ghosts = [[1,0]], target = [2,0]
    Output: false
    Explanation: You need to reach the destination (2, 0), but the ghost at
                 (1, 0) lies between you and the destination.

    Example 3:
    Input: ghosts = [[2,0]], target = [1,0]
    Output: false
    Explanation: The ghost can reach the target at the same time as you.

    Example 4:
    Input: ghosts = [[5,0],[-10,-2],[0,-5],[-2,-2],[-7,1]], target = [7,7]
    Output: false

    Example 5:
    Input: ghosts = [[-1,0],[0,1],[-1,0],[0,1],[-1,0]], target = [0,0]
    Output: true

    Constraints:
    * 1 <= ghosts.length <= 100
    * ghosts[i].length == 2
    * -10^4 <= xi, yi <= 10^4
    * There can be multiple ghosts in the same location.
    * target.length == 2
    * -10^4 <= xtarget, ytarget <= 10^4"""

    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:
        xx, yy = target
        return all(abs(x-xx) + abs(y-yy) > abs(xx) + abs(yy) for x, y in ghosts)


    """790. Domino and Tromino Tiling (Medium)
    We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape.
    These shapes may be rotated.
    XX  <- domino
    XX  <- "L" tromino
    X
    Given N, how many ways are there to tile a 2 x N board? Return your answer
    modulo 10^9 + 7. (In a tiling, every square must be covered by a tile. Two
    tilings are different if and only if there are two 4-directionally adjacent
    cells on the board such that exactly one of the tilings has both squares
    occupied by a tile.)

    Example:
    Input: 3
    Output: 5
    Explanation:
    The five different ways are listed below, different letters indicates different tiles:
    XYZ XXZ XYY XXY XYY
    XYZ YYZ XZZ XYY XXY

    Note: N  will be in range [1, 1000]."""

    def numTilings(self, N: int) -> int:
        f0, f1, f2 = 0, 1, 1
        for i in range(N-1): f0, f1, f2 = f1, f2, (2*f2 + f0) % 1_000_000_007
        return f2


    """791. Custom Sort String (Medium)
    S and T are strings composed of lowercase letters. In S, no letter occurs
    more than once. S was sorted in some custom order previously. We want to
    permute the characters of T so that they match the order that S was sorted.
    More specifically, if x occurs before y in S, then x should occur before y
    in the returned string. Return any permutation of T (as a string) that
    satisfies this property.

    Example :
    Input: S = "cba"
           T = "abcd"
    Output: "cbad"
    Explanation: "a", "b", "c" appear in S, so the order of "a", "b", "c"
                 should be "c", "b", and "a". Since "d" does not appear in S,
                 it can be at any position in T. "dcba", "cdba", "cbda" are
                 also valid outputs.
    Note:
    * S has length at most 26, and no character is repeated in S.
    * T has length at most 200.
    * S and T consist of lowercase letters only."""

    def customSortString(self, order: str, str: str) -> str:
        freq = {}
        for c in str: freq[c] = 1 + freq.get(c, 0)

        ans = []
        for c in order:
            if c in freq: ans.append(c * freq.pop(c))
        return "".join(ans) + "".join(k*v for k, v in freq.items())


    """792. Number of Matching Subsequences (Medium)
    Given a string s and an array of strings words, return the number of
    words[i] that is a subsequence of s. A subsequence of a string is a new
    string generated from the original string with some characters (can be
    none) deleted without changing the relative order of the remaining
    characters. For example, "ace" is a subsequence of "abcde".

    Example 1:
    Input: s = "abcde", words = ["a","bb","acd","ace"]
    Output: 3
    Explanation: There are three strings in words that are a subsequence of s:
                 "a", "acd", "ace".

    Example 2:
    Input: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]
    Output: 2

    Constraints:
    * 1 <= s.length <= 5 * 10^4
    * 1 <= words.length <= 5000
    * 1 <= words[i].length <= 50
    * s and words[i] consist of only lowercase English letters."""

    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        loc = {}
        for i, ch in enumerate(s):
            loc.setdefault(ch, []).append(i)

        ans = 0
        for word in words:
            x = 0
            for ch in word:
                i = bisect_left(loc.get(ch, []), x)
                if i == len(loc.get(ch, [])): break
                x = loc[ch][i] + 1
            else: ans += 1
        return ans


    """793. Preimage Size of Factorial Zeroes Function (Hard)
    Let f(x) be the number of zeroes at the end of x!. (Recall that
    x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0
    because 3! = 6 has no zeroes at the end, while f(11) = 2 because
    11! = 39916800 has 2 zeroes at the end. Given k, find how many non-negative
    integers x have the property that f(x) = k.

    Example 1:
    Input: k = 0
    Output: 5
    Explanation: 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes.

    Example 2:
    Input: k = 5
    Output: 0
    Explanation: There is no x such that x! ends in k = 5 zeroes.

    Note: k will be an integer in the range [0, 10^9]."""

    def preimageSizeFZF(self, k: int) -> int:
        lo, hi = 0, 1 << 32
        while lo <= hi:
            mid = lo + hi >> 1
            x, y = mid, 0
            while x:
                x //= 5
                y += x
            if y < k: lo = mid + 1
            elif y > k: hi = mid - 1
            else: return 5
        return 0


    """794. Valid Tic-Tac-Toe State (Medium)
    Given a Tic-Tac-Toe board as a string array board, return true if and only
    if it is possible to reach this board position during the course of a valid
    tic-tac-toe game. The board is a 3 x 3 array that consists of characters
    ' ', 'X', and 'O'. The ' ' character represents an empty square. Here are
    the rules of Tic-Tac-Toe:
    * Players take turns placing characters into empty squares ' '.
    * The first player always places 'X' characters, while the second player
      always places 'O' characters.
    * 'X' and 'O' characters are always placed into empty squares, never filled
      ones.
    * The game ends when there are three of the same (non-empty) character
      filling any row, column, or diagonal.
    * The game also ends if all squares are non-empty.
    * No more moves can be played if the game is over.

    Example 1:
    Input: board = ["O  ","   ","   "]
    Output: false
    Explanation: The first player always plays "X".

    Example 2:
    Input: board = ["XOX"," X ","   "]
    Output: false
    Explanation: Players take turns making moves.

    Example 3:
    Input: board = ["XXX","   ","OOO"]
    Output: false

    Example 4:
    Input: board = ["XOX","O O","XOX"]
    Output: true

    Constraints:
    * board.length == 3
    * board[i].length == 3
    * board[i][j] is either 'X', 'O', or ' '."""

    def validTicTacToe(self, board: List[str]) -> bool:
        anti = diag = diff = 0
        freq = [0]*8
        mp = {"O": -1, " ": 0, "X": 1} # increment & decrement
        for i in range(3):
            for j in range(3):
                x = mp[board[i][j]]
                diff += x
                freq[i] += x
                freq[j+3] += x
                if i == j: freq[6] += x
                if i+j == 2: freq[7] += x
        xwin = 3 in freq
        owin = -3 in freq
        if xwin and owin or xwin and diff != 1 or owin and diff != 0: return False
        return 0 <= diff <= 1


    """795. Number of Subarrays with Bounded Maximum (Medium)
    We are given an array A of positive integers, and two positive integers L
    and R (L <= R). Return the number of (contiguous, non-empty) subarrays such
    that the value of the maximum array element in that subarray is at least L
    and at most R.

    Example :
    Input: A = [2, 1, 4, 3]
           L = 2
           R = 3
    Output: 3
    Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].

    Note:
    * L, R  and A[i] will be an integer in the range [0, 10^9].
    * The length of A will be in the range of [1, 50000]."""

    def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
        ans = inc = cnt = 0
        for x in nums:
            if x < left: cnt += 1
            elif left <= x <= right: inc = cnt = cnt + 1
            else: inc = cnt = 0
            ans += inc
        return ans


    """797. All Paths From Source to Target (Medium)
    Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1,
    find all possible paths from node 0 to node n - 1, and return them in any
    order. The graph is given as follows: graph[i] is a list of all nodes you
    can visit from node i (i.e., there is a directed edge from node i to node
    graph[i][j]).

    Example 1:
    Input: graph = [[1,2],[3],[3],[]]
    Output: [[0,1,3],[0,2,3]]
    Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.

    Example 2:
    Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]
    Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]

    Example 3:
    Input: graph = [[1],[]]
    Output: [[0,1]]

    Example 4:
    Input: graph = [[1,2,3],[2],[3],[]]
    Output: [[0,1,2,3],[0,2,3],[0,3]]

    Example 5:
    Input: graph = [[1,3],[2],[3],[]]
    Output: [[0,1,2,3],[0,3]]

    Constraints:
    * n == graph.length
    * 2 <= n <= 15
    * 0 <= graph[i][j] < n
    * graph[i][j] != i (i.e., there will be no self-loops).
    * The input graph is guaranteed to be a DAG."""

    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        ans = []
        stack = [(0, [0])]
        while stack:
            x, path = stack.pop()
            if x == len(graph)-1: ans.append(path)
            else:
                for xx in graph[x]: stack.append((xx, path+[xx]))
        return ans


    """798. Smallest Rotation with Highest Score (Hard)
    Given an array nums, we may rotate it by a non-negative integer k so that
    the array becomes nums[k], nums[k+1], nums[k+2], ... nums[nums.length - 1],
    nums[0], nums[1], ..., nums[k-1].  Afterward, any entries that are less
    than or equal to their index are worth 1 point. For example, if we have
    [2, 4, 1, 3, 0], and we rotate by k = 2, it becomes [1, 3, 0, 2, 4]. This
    is worth 3 points because 1 > 0 [no points], 3 > 1 [no points],
    0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point]. Over all
    possible rotations, return the rotation index k that corresponds to the
    highest score we could receive. If there are multiple answers, return the
    smallest such index k.

    Example 1:
    Input: [2, 3, 1, 4, 0]
    Output: 3
    Explanation: Scores for each k are listed below:
                 k = 0,  nums = [2,3,1,4,0],    score 2
                 k = 1,  nums = [3,1,4,0,2],    score 3
                 k = 2,  nums = [1,4,0,2,3],    score 3
                 k = 3,  nums = [4,0,2,3,1],    score 4
                 k = 4,  nums = [0,2,3,1,4],    score 3
                 So we should choose k = 3, which has the highest score.

    Example 2:
    Input: [1, 3, 0, 2, 4]
    Output: 0
    Explanation: nums will always have 3 points no matter how it shifts. So we
                 will choose the smallest k, which is 0.

    Note:
    * nums will have length at most 20000.
    * nums[i] will be in the range [0, nums.length]."""

    def bestRotation(self, nums: List[int]) -> int:
        diff = [1] * len(nums)
        for i, x in enumerate(nums):
            diff[(i-x+1)%len(nums)] -= 1

        ans = prefix = 0
        mx = -inf
        for i, x in enumerate(diff):
            prefix += x
            if prefix > mx: mx, ans = prefix, i
        return ans


    """800. Similar RGB Color (Easy)
    In the following, every capital letter represents some hexadecimal digit
    from 0 to f. The red-green-blue color "#AABBCC" can be written as "#ABC" in
    shorthand.  For example, "#15c" is shorthand for the color "#1155cc". Now,
    say the similarity between two colors "#ABCDEF" and "#UVWXYZ" is
    -(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2. Given the color "#ABCDEF", return
    a 7 character color that is most similar to #ABCDEF, and has a shorthand
    (that is, it can be represented as some "#XYZ"

    Example 1:
    Input: color = "#09f166"
    Output: "#11ee66"
    Explanation: The similarity is
                 -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73.
                 This is the highest among any shorthand color.

    Note:
    * color is a string of length 7.
    * color is a valid RGB color: for i > 0, color[i] is a hexadecimal digit from 0 to f
    * Any answer which has the same (highest) similarity as the best answer will be accepted.
    * All inputs and outputs should use lowercase letters, and the output is 7 characters."""

    def similarRGB(self, color: str) -> str:

        def fn(c):
            """Return color of xx closest to input."""
            ans = 0
            for k in range(1, 16):
                ans = min(ans, k*16+k, key=lambda x: abs(x - int(c, 16)))
            return hex(ans)[2:].zfill(2)

        return "#" + "".join(fn(color[i:i+2]) for i in (1,3,5))


    """803. Bricks Falling When Hit (Hard)
    You are given an m x n binary grid, where each 1 represents a brick and 0
    represents an empty space. A brick is stable if:
    * It is directly connected to the top of the grid, or
    * At least one other brick in its four adjacent cells is stable.
    You are also given an array hits, which is a sequence of erasures we want
    to apply. Each time we want to erase the brick at the location
    hits[i] = (rowi, coli). The brick on that location (if it exists) will
    disappear. Some other bricks may no longer be stable because of that
    erasure and will fall. Once a brick falls, it is immediately erased from
    the grid (i.e., it does not land on other stable bricks). Return an array
    result, where each result[i] is the number of bricks that will fall after
    the ith erasure is applied. Note that an erasure may refer to a location
    with no brick, and if it does, no bricks drop.

    Example 1:
    Input: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
    Output: [2]
    Explanation: Starting with the grid:
                 [[1,0,0,0],
                  [1,1,1,0]]
                 We erase the underlined brick at (1,0), resulting in the grid:
                 [[1,0,0,0],
                  [0,1,1,0]]
                 The two underlined bricks are no longer stable as they are no
                 longer connected to the top nor adjacent to another stable
                 brick, so they will fall. The resulting grid is:
                 [[1,0,0,0],
                  [0,0,0,0]]
                 Hence the result is [2].

    Example 2:
    Input: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
    Output: [0,0]
    Explanation: Starting with the grid:
                 [[1,0,0,0],
                  [1,1,0,0]]
                 We erase the underlined brick at (1,1), resulting in the grid:
                 [[1,0,0,0],
                  [1,0,0,0]]
                 All remaining bricks are still stable, so no bricks fall. The
                 grid remains the same:
                 [[1,0,0,0],
                  [1,0,0,0]]
                 Next, we erase the underlined brick at (1,0), resulting in the
                 grid:
                 [[1,0,0,0],
                  [0,0,0,0]]
                 Once again, all remaining bricks are still stable, so no bricks
                 fall. Hence the result is [0,0].

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 200
    * grid[i][j] is 0 or 1.
    * 1 <= hits.length <= 4 * 10^4
    * hits[i].length == 2
    * 0 <= xi <= m - 1
    * 0 <= yi <= n - 1
    * All (xi, yi) are unique."""

    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0]) # dimensions

        seen = set()
        for i, j in hits:
            if grid[i][j]:
                seen.add((i, j))
                grid[i][j] = 0

        uf = UnionFind(m*n+1)
        for i in range(m):
            for j in range(n):
                if i == 0 and grid[i][j]: uf.union(j, m*n)
                if grid[i][j]:
                    for ii, jj in (i-1, j), (i, j-1):
                        if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: uf.union(i*n+j, ii*n+jj)

        ans = []
        prev = uf.rank[uf.find(m*n)]
        for i, j in reversed(hits):
            if (i, j) in seen:
                grid[i][j] = 1
                if i == 0: uf.union(j, m*n)
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: uf.union(i*n+j, ii*n+jj)
                rank = uf.rank[uf.find(m*n)]
                ans.append(max(0, rank - prev - 1))
                prev = rank
            else: ans.append(0)
        return ans[::-1]


    """810. Chalkboard XOR Game (Hard)
    We are given non-negative integers nums[i] which are written on a
    chalkboard. Alice and Bob take turns erasing exactly one number from the
    chalkboard, with Alice starting first.  If erasing a number causes the
    bitwise XOR of all the elements of the chalkboard to become 0, then that
    player loses.  (Also, we'll say the bitwise XOR of one element is that
    element itself, and the bitwise XOR of no elements is 0.) Also, if any
    player starts their turn with the bitwise XOR of all the elements of the
    chalkboard equal to 0, then that player wins. Return True if and only if
    Alice wins the game, assuming both players play optimally.

    Example:
    Input: nums = [1, 1, 2]
    Output: false
    Explanation: Alice has two choices: erase 1 or erase 2. If she erases 1,
                 the nums array becomes [1, 2]. The bitwise XOR of all the
                 elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove
                 any element he wants, because Alice will be the one to erase
                 the last element and she will lose. If Alice erases 2 first,
                 now nums becomes [1, 1]. The bitwise XOR of all the elements
                 of the chalkboard is 1 XOR 1 = 0. Alice will lose.

    Notes:
    * 1 <= N <= 1000.
    * 0 <= nums[i] <= 2^16."""

    def xorGame(self, nums: List[int]) -> bool:
        return reduce(xor, nums) == 0 or not len(nums)&1


    """813. Largest Sum of Averages (Medium)
    We partition a row of numbers A into at most K adjacent (non-empty) groups,
    then our score is the sum of the average of each group. What is the largest
    score we can achieve? Note that our partition must use every number in A,
    and that scores are not necessarily integers.

    Example:
    Input: A = [9,1,2,3,9]
           K = 3
    Output: 20
    Explanation: The best choice is to partition A into [9], [1, 2, 3], [9].
                 The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also
                 partitioned A into [9, 1], [2], [3, 9], for example. That
                 partition would lead to a score of 5 + 2 + 6 = 13, which is worse.

    Note:
    * 1 <= A.length <= 100.
    * 1 <= A[i] <= 10000.
    * 1 <= K <= A.length.
    * Answers within 10^-6 of the correct answer will be accepted as correct."""

    def largestSumOfAverages(self, A: List[int], K: int) -> float:
        prefix = [0]
        for x in A: prefix.append(prefix[-1] + x) # prefix sum

        @cache
        def fn(i, k):
            """Return largest sum of average of A[lo:hi+1] with at most k groups."""
            if i == 1 or k == 1: return prefix[i]/i # boundary condition
            if i <= k: return prefix[i] # shortcut
            ans = fn(i, k-1)
            for ii in range(1, i):
                ans = max(ans, fn(i-ii, k-1) + (prefix[i] - prefix[i-ii])/ii)
            return ans

        return fn(len(A), K)


    """814. Binary Tree Pruning (Medium)
    Given the root of a binary tree, return the same tree where every subtree
    (of the given tree) not containing a 1 has been removed. A subtree of a
    node node is node plus every node that is a descendant of node.

    Example 1:
    Input: root = [1,null,0,0,1]
    Output: [1,null,0,null,1]
    Explanation: Only the red nodes satisfy the property "every subtree not
                 containing a 1". The diagram on the right represents the
                 answer.

    Example 2:
    Input: root = [1,0,1,0,0,0,1]
    Output: [1,null,1,null,1]

    Example 3:
    Input: root = [1,1,0,1,1,0,1,0]
    Output: [1,1,0,1,1,null,1]

    Constraints:
    * The number of nodes in the tree is in the range [1, 200].
    * Node.val is either 0 or 1."""

    def pruneTree(self, root: TreeNode) -> TreeNode:

        def fn(node):
            """Return pruned node."""
            if node:
                node.left, node.right = fn(node.left), fn(node.right)
                if node.left or node.val == 1 or node.right: return node

        return fn(root)


    """815. Bus Routes (Hard)
    You are given an array routes representing bus routes where routes[i] is a
    bus route that the ith bus repeats forever. For example, if
    routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence
    1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever. You will start at the bus
    stop source (You are not on any bus initially), and you want to go to the
    bus stop target. You can travel between bus stops by buses only. Return the
    least number of buses you must take to travel from source to target. Return
    -1 if it is not possible.

    Example 1:
    Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
    Output: 2
    Explanation: The best strategy is take the first bus to the bus stop 7,
                 then take the second bus to the bus stop 6.

    Example 2:
    Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
    Output: -1

    Constraints:
    * 1 <= routes.length <= 500.
    * 1 <= routes[i].length <= 10^5
    * All the values of routes[i] are unique.
    * sum(routes[i].length) <= 10^5
    * 0 <= routes[i][j] < 10^6
    * 0 <= source, target < 10^6"""

    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        mp = {}
        for i, route in enumerate(routes):
            for x in route:
                mp.setdefault(x, []).append(i)

        ans = 0
        seen = {source}
        queue = [source]
        while queue:
            newq = []
            for x in queue:
                if x == target: return ans
                for i in mp[x]:
                    for xx in routes[i]:
                        if xx not in seen:
                            seen.add(xx)
                            newq.append(xx)
                    routes[i] = []
            ans += 1
            queue = newq
        return -1


    """816. Ambiguous Coordinates (Medium)
    We had some 2-dimensional coordinates, like "(1, 3)" or "(2, 0.5)".  Then,
    we removed all commas, decimal points, and spaces, and ended up with the
    string S.  Return a list of strings representing all possibilities for what
    our original coordinates could have been. Our original representation never
    had extraneous zeroes, so we never started with numbers like "00", "0.0",
    "0.00", "1.0", "001", "00.01", or any other number that can be represented
    with less digits.  Also, a decimal point within a number never occurs
    without at least one digit occuring before it, so we never started with
    numbers like ".1". The final answer list can be returned in any order.
    Also note that all coordinates in the final answer have exactly one space
    between them (occurring after the comma.)

    Example 1:
    Input: "(123)"
    Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]

    Example 2:
    Input: "(00011)"
    Output:  ["(0.001, 1)", "(0, 0.011)"]
    Explanation: 0.0, 00, 0001 or 00.01 are not allowed.

    Example 3:
    Input: "(0123)"
    Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]

    Example 4:
    Input: "(100)"
    Output: [(10, 0)]
    Explanation: 1.0 is not allowed.

    Note:
    * 4 <= S.length <= 12.
    * S[0] = "(", S[S.length - 1] = ")", and the other elements in S are digits."""

    def ambiguousCoordinates(self, S: str) -> List[str]:
        S = S[1:-1] # strip "(" and ")"

        def fn(s):
            """Return valid number derived from s."""
            if len(s) == 1: return [s] # edge case
            if s.startswith("0") and s.endswith("0"): return []
            if s.startswith("0"): return [s[:1] + "." + s[1:]]
            if s.endswith("0"): return [s]
            return [s] + [s[:i] + "." + s[i:] for i in range(1, len(s))]

        ans = []
        for i in range(1, len(S)):
            ans.extend([f"({x}, {y})" for x in fn(S[:i]) for y in fn(S[i:])])
        return ans



    """817. Linked List Components (Medium)
    We are given head, the head node of a linked list containing unique integer
    values. We are also given the list G, a subset of the values in the linked
    list. Return the number of connected components in G, where two values are
    connected if they appear consecutively in the linked list.

    Example 1:
    Input: head: 0->1->2->3
           G = [0, 1, 3]
    Output: 2
    Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected
                 components.

    Example 2:
    Input: head: 0->1->2->3->4
           G = [0, 3, 1, 4]
    Output: 2
    Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and
                 [3, 4] are the two connected components.

    Note:
    * If N is the length of the linked list given by head, 1 <= N <= 10000.
    * The value of each node in the linked list will be in the range [0, N - 1].
    * 1 <= G.length <= 10000.
    * G is a subset of all values in the linked list."""

    def numComponents(self, head: ListNode, G: List[int]) -> int:
        Gs = set(G)
        ans = 0
        while head:
            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1
            head = head.next
        return ans


    """821. Shortest Distance to a Character (Easy)
    Given a string s and a character c that occurs in s, return an array of
    integers answer where answer.length == s.length and answer[i] is the
    shortest distance from s[i] to the character c in s.

    Example 1:
    Input: s = "loveleetcode", c = "e"
    Output: [3,2,1,0,1,0,0,1,2,2,1,0]

    Example 2:
    Input: s = "aaab", c = "b"
    Output: [3,2,1,0]

    Constraints:
    * 1 <= s.length <= 10^4
    * s[i] and c are lowercase English letters.
    * c occurs at least once in s."""

    def shortestToChar(self, s: str, c: str) -> List[int]:
        locs = [i for i, x in enumerate(s) if x == c]
        ans = []
        k = 0
        for i, c in enumerate(s):
            if k+1 < len(locs) and locs[k+1]-i < i - locs[k]: k += 1
            ans.append(abs(i - locs[k]))
        return ans


    """822. Card Flipping Game (Medium)
    On a table are N cards, with a positive integer printed on the front and
    back of each card (possibly different). We flip any number of cards, and
    after we choose one card. If the number X on the back of the chosen card
    is not on the front of any card, then this number X is good. What is the
    smallest number that is good?  If no number is good, output 0. Here,
    fronts[i] and backs[i] represent the number on the front and back of card
    i. A flip swaps the front and back numbers, so the value on the front is
    now on the back and vice versa.

    Example:
    Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]
    Output: 2
    Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the
                 backs are [1,2,4,1,3]. We choose the second card, which has
                 number 2 on the back, and it isn't on the front of any card,
                 so 2 is good.
    Note:
    * 1 <= fronts.length == backs.length <= 1000.
    * 1 <= fronts[i] <= 2000.
    * 1 <= backs[i] <= 2000."""

    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        same = {ff for ff, bb in zip(fronts, backs) if ff == bb}
        return min((x for x in fronts+backs if x not in same), default=0)


    """823. Binary Trees With Factors (Medium)
    Given an array of unique integers, each integer is strictly greater than 1.
    We make a binary tree using these integers and each number may be used for
    any number of times. Each non-leaf node's value should be equal to the
    product of the values of it's children. How many binary trees can we make?
    Return the answer modulo 10 ** 9 + 7.

    Example 1:
    Input: A = [2, 4]
    Output: 3
    Explanation: We can make these trees: [2], [4], [4, 2, 2]

    Example 2:
    Input: A = [2, 4, 5, 10]
    Output: 7
    Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2],
                 [10, 2, 5], [10, 5, 2].

    Note:
    * 1 <= A.length <= 1000.
    * 2 <= A[i] <= 10 ^ 9."""

    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        freq = {}
        for x in sorted(arr):
            freq[x] = 1
            for xx in freq:
                freq[x] += freq[xx] * freq.get(x/xx, 0)
        return sum(freq.values()) % 1_000_000_007


    """825. Friends Of Appropriate Ages (Medium)
    Some people will make friend requests. The list of their ages is given and
    ages[i] is the age of the ith person. Person A will NOT friend request
    person B (B != A) if any of the following conditions are true:
    * age[B] <= 0.5 * age[A] + 7
    * age[B] > age[A]
    * age[B] > 100 && age[A] < 100
    Otherwise, A will friend request B. Note that if A requests B, B does not
    necessarily request A.  Also, people will not friend request themselves.
    How many total friend requests are made?

    Example 1:
    Input: [16,16]
    Output: 2
    Explanation: 2 people friend request each other.

    Example 2:
    Input: [16,17,18]
    Output: 2
    Explanation: Friend requests are made 17 -> 16, 18 -> 17.

    Example 3:
    Input: [20,30,100,110,120]
    Output: 3
    Explanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.

    Notes:
    * 1 <= ages.length <= 20000.
    * 1 <= ages[i] <= 120."""

    def numFriendRequests(self, ages: List[int]) -> int:
        ages.sort()
        ans = lo = hi = 0
        for x in ages:
            while hi < len(ages) and x == ages[hi]: hi += 1
            while lo+1 < hi and ages[lo] <= x//2 + 7: lo += 1
            ans += hi - lo - 1
        return ans


    """826. Most Profit Assigning Work (Medium)
    We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i]
    is the profit of the ith job. Now we have some workers. worker[i] is the
    ability of the ith worker, which means that this worker can only complete a
    job with difficulty at most worker[i]. Every worker can be assigned at most
    one job, but one job can be completed multiple times. For example, if 3
    people attempt the same job that pays $1, then the total profit will be $3.
    If a worker cannot complete any job, his profit is $0. What is the most
    profit we can make?

    Example 1:
    Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
    Output: 100
    Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get
                 profit of [20,20,30,30] seperately.

    Notes:
    * 1 <= difficulty.length = profit.length <= 10000
    * 1 <= worker.length <= 10000
    * difficulty[i], profit[i], worker[i]  are in range [1, 10^5]"""

    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
        ans = k = prefix = 0
        job = sorted(zip(difficulty, profit))
        for w in sorted(worker):
            while k < len(job) and job[k][0] <= w:
                prefix = max(prefix, job[k][1])
                k += 1
            ans += prefix
        return ans


    """827. Making A Large Island (Hard)
    You are given an n x n binary matrix grid. You are allowed to change at
    most one 0 to be 1. Return the size of the largest island in grid after
    applying this operation. An island is a 4-directionally connected group
    of 1s.

    Example 1:
    Input: grid = [[1,0],[0,1]]
    Output: 3
    Explanation: Change one 0 to 1 and connect two 1s, then we get an island
                 with area = 3.

    Example 2:
    Input: grid = [[1,1],[1,0]]
    Output: 4
    Explanation: Change the 0 to 1 and make the island bigger, only one island
                 with area = 4.

    Example 3:
    Input: grid = [[1,1],[1,1]]
    Output: 4
    Explanation: Can't change any 0 to 1, only one island with area = 4.

    Constraints:
    * n == grid.length
    * n == grid[i].length
    * 1 <= n <= 500
    * grid[i][j] is either 0 or 1."""

    def largestIsland(self, grid: List[List[int]]) -> int:
        n = len(grid)
        k = 2
        freq = defaultdict(int)
        for r in range(n):
            for c in range(n):
                if grid[r][c] == 1:
                    stack = [(r, c)]
                    grid[r][c] = k
                    while stack:
                        i, j = stack.pop()
                        freq[k] += 1
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] == 1:
                                stack.append((ii, jj))
                                grid[ii][jj] = k
                    k += 1

        ans = 0
        for i in range(n):
            for j in range(n):
                if grid[i][j]: ans = max(ans, freq[grid[i][j]])
                else:
                    cand = 1
                    seen = set()
                    for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                        if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] and grid[ii][jj] not in seen:
                            seen.add(grid[ii][jj])
                            cand += freq[grid[ii][jj]]
                    ans = max(ans, cand)
        return ans


    """828. Count Unique Characters of All Substrings of a Given String (Hard)
    Let's define a function countUniqueChars(s) that returns the number of
    unique characters on s.
    * For example if s = "LEETCODE" then "L", "T", "C", "O", "D" are the unique
    characters since they appear only once in s, therefore countUniqueChars(s) = 5.
    Given a string s, return the sum of countUniqueChars(t) where t is a
    substring of s. Notice that some substrings can be repeated so in this case
    you have to count the repeated ones too.

    Example 1:
    Input: s = "ABC"
    Output: 10
    Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC".
                 Evey substring is composed with only unique letters. Sum of
                 lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10

    Example 2:
    Input: s = "ABA"
    Output: 8
    Explanation: The same as example 1, except countUniqueChars("ABA") = 1.

    Example 3:
    Input: s = "LEETCODE"
    Output: 92

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of uppercase English letters only."""

    def uniqueLetterString(self, s: str) -> int:
        locs = [[-1] for _ in range(26)]
        for i, x in enumerate(s): locs[ord(x)-65].append(i)

        ans = 0
        for i in range(26):
            locs[i].append(len(s))
            for k in range(1, len(locs[i])-1):
                ans += (locs[i][k] - locs[i][k-1]) * (locs[i][k+1] - locs[i][k])
        return ans


    """829. Consecutive Numbers Sum (Hard)
    Given an integer n, return the number of ways you can write n as the sum of
    consecutive positive integers.

    Example 1:
    Input: n = 5
    Output: 2
    Explanation: 5 = 2 + 3

    Example 2:
    Input: n = 9
    Output: 3
    Explanation: 9 = 4 + 5 = 2 + 3 + 4

    Example 3:
    Input: n = 15
    Output: 4
    Explanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5

    Constraints: 1 <= n <= 10^9"""

    def consecutiveNumbersSum(self, n: int) -> int:
        ans = 0
        for x in range(1, int(sqrt(2*n))+1):
            if (n - x*(x+1)//2) % x == 0: ans += 1
        return ans


    """831. Masking Personal Information (Medium)
    We are given a personal information string S, which may represent either an
    email address or a phone number. We would like to mask this personal
    information according to the following rules:

    1. Email address:
    We define a name to be a string of length ≥ 2 consisting of only lowercase
    letters a-z or uppercase letters A-Z. An email address starts with a name,
    followed by the symbol '@', followed by a name, followed by the dot '.' and
    followed by a name. All email addresses are guaranteed to be valid and in
    the format of "name1@name2.name3". To mask an email, all names must be
    converted to lowercase and all letters between the first and last letter of
    the first name must be replaced by 5 asterisks '*'.

    2. Phone number:
    A phone number is a string consisting of only the digits 0-9 or the
    characters from the set {'+', '-', '(', ')', ' '}. You may assume a phone
    number contains 10 to 13 digits. The last 10 digits make up the local
    number, while the digits before those make up the country code. Note that
    the country code is optional. We want to expose only the last 4 digits and
    mask all other digits. The local number should be formatted and masked as
    "***-***-1111", where 1 represents the exposed digits. To mask a phone
    number with country code like "+111 111 111 1111", we write it in the form
    "+***-***-***-1111".  The '+' sign and the first '-' sign before the local
    number should only exist if there is a country code.  For example, a 12
    digit phone number mask should start with "+**-". Note that extraneous
    characters like "(", ")", " ", as well as extra dashes or plus signs not
    part of the above formatting scheme should be removed.

    Return the correct "mask" of the information provided.

    Example 1:
    Input: "LeetCode@LeetCode.com"
    Output: "l*****e@leetcode.com"
    Explanation: All names are converted to lowercase, and the letters between
                 the first and last letter of the first name is replaced by 5
                 asterisks. Therefore, "leetcode" -> "l*****e".

    Example 2:
    Input: "AB@qq.com"
    Output: "a*****b@qq.com"
    Explanation: There must be 5 asterisks between the first and last letter
                 of the first name "ab". Therefore, "ab" -> "a*****b".

    Example 3:
    Input: "1(234)567-890"
    Output: "***-***-7890"
    Explanation: 10 digits in the phone number, which means all digits make up
                 the local number.

    Example 4:
    Input: "86-(10)12345678"
    Output: "+**-***-***-5678"
    Explanation: 12 digits, 2 digits for country code and 10 digits for local
                 number.

    Notes:
    * S.length <= 40.
    * Emails have length at least 8.
    * Phone numbers have length at least 10."""

    def maskPII(self, S: str) -> str:
        if "@" in S: # email address
            name, domain = S.lower().split("@")
            return f"{name[0]}*****{name[-1]}@{domain}"
        else: # phone number
            d = "".join(c for c in S if c.isdigit())
            ans = f"***-***-{d[-4:]}"
            return ans if len(d) == 10 else f"+{'*'*(len(d)-10)}-" + ans


    """832. Flipping an Image (Easy)
    Given a binary matrix A, we want to flip the image horizontally, then
    invert it, and return the resulting image. To flip an image horizontally
    means that each row of the image is reversed.  For example, flipping
    [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that
    each 0 is replaced by 1, and each 1 is replaced by 0. For example,
    inverting [0, 1, 1] results in [1, 0, 0].

    Example 1:
    Input: [[1,1,0],[1,0,1],[0,0,0]]
    Output: [[1,0,0],[0,1,0],[1,1,1]]
    Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then,
                 invert the image: [[1,0,0],[0,1,0],[1,1,1]]

    Example 2:
    Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
    Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
    Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
                 Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]

    Notes:
    * 1 <= A.length = A[0].length <= 20
    * 0 <= A[i][j] <= 1"""

    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:
        m, n = len(A), len(A[0])
        for i in range(m):
            for j in range(n+1 >> 1):
                A[i][j], A[i][~j] = 1^A[i][~j], 1^A[i][j]
        return A


    """833. Find And Replace in String (Medium)
    To some string S, we will perform some replacement operations that replace
    groups of letters with new ones (not necessarily the same size). Each
    replacement operation has 3 parameters: a starting index i, a source word x
    and a target word y.  The rule is that if x starts at position i in the
    original string S, then we will replace that occurrence of x with y.  If
    not, we do nothing. For example, if we have S = "abcd" and we have some
    replacement operation i = 2, x = "cd", y = "ffff", then because "cd" starts
    at position 2 in the original string S, we will replace it with "ffff".
    Using another example on S = "abcd", if we have both the replacement
    operation i = 0, x = "ab", y = "eee", as well as another replacement
    operation i = 2, x = "ec", y = "ffff", this second operation does nothing
    because in the original string S[2] = 'c', which doesn't match x[0] = 'e'.
    All these operations occur simultaneously.

    It's guaranteed that there won't be any overlap in replacement: for example,
    S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case.

    Example 1:
    Input: S = "abcd", indexes = [0, 2], sources = ["a", "cd"], targets = ["eee", "ffff"]
    Output: "eeebffff"
    Explanation: "a" starts at index 0 in S, so it's replaced by "eee".
                 "cd" starts at index 2 in S, so it's replaced by "ffff".

    Example 2:
    Input: S = "abcd", indexes = [0, 2], sources = ["ab","ec"], targets = ["eee","ffff"]
    Output: "eeecd"
    Explanation: "ab" starts at index 0 in S, so it's replaced by "eee".
                 "ec" doesn't starts at index 2 in the original S, so we do nothing.

    Constraints:
    * 0 <= S.length <= 1000
    * S consists of only lowercase English letters.
    * 0 <= indexes.length <= 100
    * 0 <= indexes[i] < S.length
    * sources.length == indexes.length
    * targets.length == indexes.length
    * 1 <= sources[i].length, targets[i].length <= 50
    * sources[i] and targets[i] consist of only lowercase English letters."""

    def findReplaceString(self, S: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:
        for i, s, t in sorted(zip(indexes, sources, targets), reverse=True):
            if S[i:i+len(s)] == s: S = S[:i] + t + S[i+len(s):]
        return S


    """834. Sum of Distances in Tree (Hard)
    An undirected, connected tree with n nodes labelled 0...n-1 and n-1 edges
    are given. The ith edge connects nodes edges[i][0] and edges[i][1] together.
    Return a list ans, where ans[i] is the sum of the distances between node i
    and all other nodes.

    Example 1:
    Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
    Output: [8,12,6,10,10,10]
    Explanation: Here is a diagram of the given tree:
      0
     / \
    1   2
       /|\
      3 4 5
    We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
    equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.
    Note: 1 <= n <= 10000"""

    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        def fn(u, p):
            """Return size and sum of distances in sub-tree."""
            cnt = val = 0
            for v in graph[u]:
                if v != p:
                    cc, vv = fn(v, u)
                    cnt += cc
                    val += cc + vv
            size[u] = cnt + 1
            return cnt + 1, val

        ans = [0]*n
        size = [0]*n
        ans[0] = fn(0, -1)[1]
        stack = [0]
        while stack:
            u = stack.pop()
            for v in graph[u]:
                if not ans[v]:
                    ans[v] = ans[u] + n - 2*size[v]
                    stack.append(v)
        return ans


    """837. New 21 Game (Medium)
    Alice plays the following game, loosely based on the card game "21". Alice
    starts with 0 points, and draws numbers while she has less than K points.
    During each draw, she gains an integer number of points randomly from the
    range [1, W], where W is an integer.  Each draw is independent and the
    outcomes have equal probabilities. Alice stops drawing numbers when she
    gets K or more points.  What is the probability that she has N or less
    points?

    Example 1:
    Input: N = 10, K = 1, W = 10
    Output: 1.00000
    Explanation:  Alice gets a single card, then stops.

    Example 2:
    Input: N = 6, K = 1, W = 10
    Output: 0.60000
    Explanation:  Alice gets a single card, then stops.
    In 6 out of W = 10 possibilities, she is at or below N = 6 points.

    Example 3:
    Input: N = 21, K = 17, W = 10
    Output: 0.73278

    Note:
    * 0 <= K <= N <= 10000
    * 1 <= W <= 10000
    * Answers will be accepted as correct if they are within 10^-5 of the correct answer.
    * The judging time limit has been reduced for this question."""

    def new21Game(self, N: int, K: int, W: int) -> float:
        ans = [0]*K + [1]*(N-K+1) + [0]*W
        val = sum(ans[K:K+W+1])
        for i in reversed(range(K)):
            ans[i] = val/W
            val += ans[i] - ans[i+W]
        return ans[0]


    """838. Push Dominoes (Medium)
    There are n dominoes in a line, and we place each domino vertically upright.
    In the beginning, we simultaneously push some of the dominoes either to the
    left or to the right. After each second, each domino that is falling to the
    left pushes the adjacent domino on the left. Similarly, the dominoes
    falling to the right push their adjacent dominoes standing on the right.
    When a vertical domino has dominoes falling on it from both sides, it stays
    still due to the balance of the forces. For the purposes of this question,
    we will consider that a falling domino expends no additional force to a
    falling or already fallen domino. You are given a string dominoes
    representing the initial state where:
    * dominoes[i] = 'L', if the ith domino has been pushed to the left,
    * dominoes[i] = 'R', if the ith domino has been pushed to the right, and
    * dominoes[i] = '.', if the ith domino has not been pushed.
    Return a string representing the final state.

    Example 1:
    Input: dominoes = "RR.L"
    Output: "RR.L"
    Explanation: The first domino expends no additional force on the second
                 domino.

    Example 2:
    Input: dominoes = ".L.R...LR..L.."
    Output: "LL.RR.LLRRLL.."

    Constraints:
    * n == dominoes.length
    * 1 <= n <= 10^5
    * dominoes[i] is either 'L', 'R', or '.'."""

    def pushDominoes(self, dominoes: str) -> str:
        mp = [0]*len(dominoes)
        ii = len(dominoes)
        for i in reversed(range(len(dominoes))):
            if dominoes[i] != ".": ii = i
            mp[i] = ii

        ans = []
        ii = -1
        for i, x in enumerate(dominoes):
            if dominoes[i] in "LR":
                ans.append(dominoes[i])
                ii = i
            else:
                ll = "L" if ii == -1 else dominoes[ii]
                rr = "R" if mp[i] == len(dominoes) else dominoes[mp[i]]
                if ll == rr: ans.append(ll)
                elif ll == "L": ans.append(".")
                else:
                    if i - ii < mp[i] - i: ans.append("R")
                    elif i - ii > mp[i] - i: ans.append("L")
                    else: ans.append(".")
        return "".join(ans)


    """839. Similar String Groups (Hard)
    Two strings X and Y are similar if we can swap two letters (in different
    positions) of X, so that it equals Y. Also two strings X and Y are similar
    if they are equal. For example, "tars" and "rats" are similar (swapping at
    positions 0 and 2), and "rats" and "arts" are similar, but "star" is not
    similar to "tars", "rats", or "arts". Together, these form two connected
    groups by similarity: {"tars", "rats", "arts"} and {"star"}.  Notice that
    "tars" and "arts" are in the same group even though they are not similar.
    Formally, each group is such that a word is in the group if and only if it
    is similar to at least one other word in the group. We are given a list
    strs of strings where every string in strs is an anagram of every other
    string in strs. How many groups are there?

    Example 1:
    Input: strs = ["tars","rats","arts","star"]
    Output: 2

    Example 2:
    Input: strs = ["omv","ovm"]
    Output: 1

    Constraints:
    * 1 <= strs.length <= 300
    * 1 <= strs[i].length <= 300
    * strs[i] consists of lowercase letters only.
    * All words in strs have the same length and are anagrams of each other."""

    def numSimilarGroups(self, strs: List[str]) -> int:

        def fn(x, y):
            cnt = 0
            for xx, yy in zip(x, y):
                if xx != yy: cnt += 1
                if cnt > 2: return False
            return True

        n = len(strs)
        uf = UnionFind(n)
        for i in range(n):
            for ii in range(i):
                if fn(strs[i], strs[ii]) and uf.union(i, ii):
                    n -= 1
        return n


    """840. Magic Squares In Grid (Medium)
    A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to
    9 such that each row, column, and both diagonals all have the same sum.
    Given a row x col grid of integers, how many 3 x 3 "magic square" subgrids
    are there?  (Each subgrid is contiguous).

    Example 1:
    Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]
    Output: 1

    Example 2:
    Input: grid = [[8]]
    Output: 0

    Example 3:
    Input: grid = [[4,4],[3,3]]
    Output: 0

    Example 4:
    Input: grid = [[4,7,8],[9,5,1],[2,3,6]]
    Output: 0

    Constraints:
    * row == grid.length
    * col == grid[i].length
    * 1 <= row, col <= 10
    * 0 <= grid[i][j] <= 15"""

    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimension

        def fn(i, j):
            """Return True if grid[i-1:i+2][j-1:j+2] is a magic squre."""
            seen = set()
            row, col = [0]*3, [0]*3 # row sum & column sum
            diag = anti = 0
            for ii in range(i-1, i+2):
                for jj in range(j-1, j+2):
                    if not 0 <= grid[ii][jj] < 10 or grid[ii][jj] in seen: return False
                    seen.add(grid[ii][jj])
                    row[ii-i+1] += grid[ii][jj]
                    col[jj-j+1] += grid[ii][jj]
                    if ii-jj == i-j: diag += grid[ii][jj]
                    if ii+jj == i+j: anti += grid[ii][jj]
            return len(set(row)) == 1 and len(set(col)) == 1 and row[0] == col[0] == diag == anti

        ans = 0
        for i in range(1, m-1):
            for j in range(1, n-1):
                if grid[i][j] == 5 and fn(i, j): ans += 1
        return ans


    """841. Keys and Rooms (Medium)
    There are N rooms and you start in room 0. Each room has a distinct number
    in 0, 1, 2, ..., N-1, and each room may have some keys to access the next
    room. Formally, each room i has a list of keys rooms[i], and each key
    rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A
    key rooms[i][j] = v opens the room with number v. Initially, all the rooms
    start locked (except for room 0). You can walk back and forth between rooms
    freely. Return true if and only if you can enter every room.

    Example 1:
    Input: [[1],[2],[3],[]]
    Output: true
    Explanation:
    We start in room 0, and pick up key 1.
    We then go to room 1, and pick up key 2.
    We then go to room 2, and pick up key 3.
    We then go to room 3.  Since we were able to go to every room, we return true.

    Example 2:
    Input: [[1,3],[3,0,1],[2],[0]]
    Output: false
    Explanation: We can't enter the room with number 2.

    Note:
    * 1 <= rooms.length <= 1000
    * 0 <= rooms[i].length <= 1000
    * The number of keys in all rooms combined is at most 3000."""

    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        seen = [False]*len(rooms)
        stack = [0]
        while stack:
            n = stack.pop()
            if not seen[n]:
                seen[n] = True
                stack.extend(rooms[n])
        return all(seen)


    """843. Guess the Word (Hard)
    This is an interactive problem. You are given an array of unique strings
    wordlist where wordlist[i] is 6 letters long, and one word in this list is
    chosen as secret. You may call Master.guess(word) to guess a word. The
    guessed word should have type string and must be from the original list
    with 6 lowercase letters. This function returns an integer type,
    representing the number of exact matches (value and position) of your guess
    to the secret word. Also, if your guess is not in the given wordlist, it
    will return -1 instead. For each test case, you have exactly 10 guesses to
    guess the word. At the end of any number of calls, if you have made 10 or
    fewer calls to Master.guess and at least one of these guesses was secret,
    then you pass the test case.

    Example 1:
    Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"], numguesses = 10
    Output: You guessed the secret word correctly.
    Explanation: master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist.
                 master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches.
                 master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches.
                 master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches.
                 master.guess("abcczz") returns 4, because "abcczz" has 4 matches.
                 We made 5 calls to master.guess and one of them was the secret, so we pass the test case.

    Example 2:
    Input: secret = "hamada", wordlist = ["hamada","khaled"], numguesses = 10
    Output: You guessed the secret word correctly.

    Constraints:
    * 1 <= wordlist.length <= 100
    * wordlist[i].length == 6
    * wordlist[i] consist of lowercase English letters.
    * All the strings of wordlist are unique.
    * secret exists in wordlist.
    * numguesses == 10"""

    def findSecretWord(self, wordlist: List[str], master: 'Master') -> None:
        shuffle(wordlist) # statistical guarantee to pass
        for _ in range(10):
            if wordlist:
                w = wordlist.pop()
                m = master.guess(w)
                wordlist = [ww for ww in wordlist if sum(x == xx for x, xx in zip(w, ww)) == m]


    """844. Backspace String Compare (Easy)
    Given two strings s and t, return true if they are equal when both are
    typed into empty text editors. '#' means a backspace character. Note that
    after backspacing an empty text, the text will continue empty.

    Example 1:
    Input: s = "ab#c", t = "ad#c"
    Output: true
    Explanation: Both s and t become "ac".

    Example 2:
    Input: s = "ab##", t = "c#d#"
    Output: true
    Explanation: Both s and t become "".

    Example 3:
    Input: s = "a##c", t = "#a#c"
    Output: true
    Explanation: Both s and t become "c".

    Example 4:
    Input: s = "a#c", t = "b"
    Output: false
    Explanation: s becomes "c" while t becomes "b".

    Constraints:
    * 1 <= s.length, t.length <= 200
    * s and t only contain lowercase letters and '#' characters.

    Follow up: Can you solve it in O(n) time and O(1) space?"""

    def backspaceCompare(self, s: str, t: str) -> bool:
        i, j = len(s)-1, len(t)-1
        ss = tt = 0
        while 0 <= i or 0 <= j:
            while 0 <= i and (s[i] == "#" or ss):
                if s[i] == "#": ss += 1
                else: ss -= 1
                i -= 1
            while 0 <= j and (t[j] == "#" or tt):
                if t[j] == "#": tt += 1
                else: tt -= 1
                j -= 1
            if i < 0 and 0 <= j or 0 <= i and j < 0 or 0 <= i and 0 <= j and s[i] != t[j]: return False
            i, j = i-1, j-1
        return True


    """845. Longest Mountain in Array (Medium)
    Let's call any (contiguous) subarray B (of A) a mountain if the following
    properties hold:
    * B.length >= 3
    * There exists some 0 < i < B.length - 1 such that
      B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
    (Note that B could be any subarray of A, including the entire array A.)
    Given an array A of integers, return the length of the longest mountain.
    Return 0 if there is no mountain.

    Example 1:
    Input: [2,1,4,7,3,2,5]
    Output: 5
    Explanation: The largest mountain is [1,4,7,3,2] which has length 5.

    Example 2:
    Input: [2,2,2]
    Output: 0
    Explanation: There is no mountain.

    Note:
    * 0 <= A.length <= 10000
    * 0 <= A[i] <= 10000

    Follow up:
    * Can you solve it using only one pass?
    * Can you solve it in O(1) space?"""

    def longestMountain(self, A: List[int]) -> int:
        ans = 0
        for i in range(1, len(A)-1):
            if A[i-1] < A[i] > A[i+1]:
                lo = hi = i
                while 0 < lo and A[lo-1] < A[lo]: lo -= 1
                while hi < len(A)-1 and A[hi] > A[hi+1]: hi += 1
                ans = max(ans, hi - lo + 1)
        return ans


    """846. Hand of Straights (Medium)
    Alice has some number of cards and she wants to rearrange the cards into
    groups so that each group is of size groupSize, and consists of groupSize
    consecutive cards. Given an integer array hand where hand[i] is the value
    written on the ith card and an integer groupSize, return true if she can
    rearrange the cards, or false otherwise.

    Example 1:
    Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
    Output: true
    Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]

    Example 2:
    Input: hand = [1,2,3,4,5], groupSize = 4
    Output: false
    Explanation: Alice's hand can not be rearranged into groups of 4.

    Constraints:
    * 1 <= hand.length <= 10^4
    * 0 <= hand[i] <= 10^9
    * 1 <= groupSize <= hand.length

    Note: This question is the same as 1296:
          https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/"""

    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        freq = Counter(hand)
        queue = deque()
        prev, need = -1, 0
        for x, v in sorted(freq.items()):
            if need and x > prev+1 or need > v: return False
            if v > need: queue.append((x, v - need))
            prev, need = x, v
            if queue and x-queue[0][0] == groupSize-1: need -= queue.popleft()[1]
        return need == 0


    """847. Shortest Path Visiting All Nodes (Hard)
    You have an undirected, connected graph of n nodes labeled from 0 to n - 1.
    You are given an array graph where graph[i] is a list of all the nodes
    connected with node i by an edge. Return the length of the shortest path
    that visits every node. You may start and stop at any node, you may revisit
    nodes multiple times, and you may reuse edges.

    Example 1:
    Input: graph = [[1,2,3],[0],[0],[0]]
    Output: 4
    Explanation: One possible path is [1,0,2,0,3]

    Example 2:
    Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
    Output: 4
    Explanation: One possible path is [0,1,4,2,3]

    Constraints:
    * n == graph.length
    * 1 <= n <= 12
    * 0 <= graph[i].length < n
    * graph[i] does not contain i.
    * If graph[a] contains b, then graph[b] contains a.
    * The input graph is always connected."""

    def shortestPathLength(self, graph: List[List[int]]) -> int:
        queue = deque([(i, 1<<i) for i in range(len(graph))])
        seen = set(queue)
        ans = 0
        while queue:
            for _ in range(len(queue)):
                u, m = queue.popleft()
                if m == (1<<len(graph)) - 1: return ans
                for v in graph[u]:
                    if (v, m | 1<<v) not in seen:
                        queue.append((v, m | 1<<v))
                        seen.add((v, m | 1<<v))
            ans += 1


    """848. Shifting Letters (Medium)
    We have a string S of lowercase letters, and an integer array shifts. Call
    the shift of a letter, the next letter in the alphabet, (wrapping around so
    that 'z' becomes 'a'). For example, shift('a') = 'b', shift('t') = 'u', and
    shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first
    i+1 letters of S, x times. Return the final string after all such shifts to
    S are applied.

    Example 1:
    Input: S = "abc", shifts = [3,5,9]
    Output: "rpl"
    Explanation: We start with "abc".
    After shifting the first 1 letters of S by 3, we have "dbc".
    After shifting the first 2 letters of S by 5, we have "igc".
    After shifting the first 3 letters of S by 9, we have "rpl", the answer.

    Note:
    * 1 <= S.length = shifts.length <= 20000
    * 0 <= shifts[i] <= 10 ^ 9"""

    def shiftingLetters(self, S: str, shifts: List[int]) -> str:
        for i in reversed(range(1, len(shifts))): shifts[i-1] += shifts[i]
        return "".join(chr(97 + (ord(c) - 97 + x) % 26) for c, x in zip(S, shifts))


    """849. Maximize Distance to Closest Person (Medium)
    You are given an array representing a row of seats where seats[i] = 1
    represents a person sitting in the ith seat, and seats[i] = 0 represents
    that the ith seat is empty (0-indexed). There is at least one empty seat,
    and at least one person sitting. Alex wants to sit in the seat such that
    the distance between him and the closest person to him is maximized. Return
    that maximum distance to the closest person.

    Example 1:
    Input: seats = [1,0,0,0,1,0,1]
    Output: 2
    Explanation: If Alex sits in the second open seat (i.e. seats[2]), then the
                 closest person has distance 2. If Alex sits in any other open
                 seat, the closest person has distance 1. Thus, the maximum
                 distance to the closest person is 2.

    Example 2:
    Input: seats = [1,0,0,0]
    Output: 3
    Explanation: If Alex sits in the last seat (i.e. seats[3]), the closest
                 person is 3 seats away. This is the maximum distance possible,
                 so the answer is 3.

    Example 3:
    Input: seats = [0,1]
    Output: 1

    Constraints:
    * 2 <= seats.length <= 2 * 10^4
    * seats[i] is 0 or 1.
    * At least one seat is empty.
    * At least one seat is occupied."""

    def maxDistToClosest(self, seats: List[int]) -> int:
        ans = 0
        prev = -1
        for i, x in enumerate(seats):
            if x:
                ans = max(ans, i) if prev < 0 else max(ans, (i-prev)//2)
                prev = i
        return max(ans, i - prev)


    """850. Rectangle Area II (Hard)
    We are given a list of (axis-aligned) rectangles. Each
    rectangle[i] = [xi1, yi1, xi2, yi2], where (xi1, yi1) are the coordinates
    of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-
    right corner of the ith rectangle. Find the total area covered by all
    rectangles in the plane. Since the answer may be too large, return it
    modulo 10^9 + 7.

    Example 1:
    Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
    Output: 6
    Explanation: As illustrated in the picture.

    Example 2:
    Input: rectangles = [[0,0,1000000000,1000000000]]
    Output: 49
    Explanation: The answer is 1018 modulo (10^9 + 7), which is 49.

    Constraints:
    * 1 <= rectangles.length <= 200
    * rectanges[i].length = 4
    * 0 <= rectangles[i][j] <= 10^9
    * The total area covered by all rectangles will never exceed 2^63 - 1 and
      thus will fit in a 64-bit signed integer."""

    def rectangleArea(self, rectangles: List[List[int]]) -> int:
        line = []
        for x1, y1, x2, y2 in rectangles:
            line.append((y1, x1, x2, 1))
            line.append((y2, x1, x2, 0))

        ans = yy = val = 0
        seg = []
        for y, x1, x2, tf in sorted(line):
            ans += val * (y - yy)
            yy = y
            if tf: insort(seg, (x1, x2))
            else: seg.remove((x1, x2))
            val = 0
            prev = -inf
            for x1, x2 in seg:
                val += max(0, x2 - max(x1, prev))
                prev = max(prev, x2)
        return ans % 1_000_000_007


    """851. Loud and Rich (Medium)
    In a group of N people (labelled 0, 1, 2, ..., N-1), each person has
    different amounts of money, and different levels of quietness. For
    convenience, we'll call the person with label x, simply "person x". We'll
    say that richer[i] = [x, y] if person x definitely has more money than
    person y.  Note that richer may only be a subset of valid observations.
    Also, we'll say quiet[x] = q if person x has quietness q. Now, return
    answer, where answer[x] = y if y is the least quiet person (that is, the
    person y with the smallest value of quiet[y]), among all people who
    definitely have equal to or more money than person x.

    Example 1:
    Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]],
           quiet = [3,2,5,4,6,1,7,0]
    Output: [5,5,2,5,4,5,6,7]
    Explanation:
    answer[0] = 5.
    Person 5 has more money than 3, which has more money than 1, which has more
    money than 0. The only person who is quieter (has lower quiet[x]) is person
    7, but it isn't clear if they have more money than person 0.
    answer[7] = 7.
    Among all people that definitely have equal to or more money than person 7
    (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest
    (has lower quiet[x]) is person 7. The other answers can be filled out with
    similar reasoning.

    Note:
    * 1 <= quiet.length = N <= 500
    * 0 <= quiet[i] < N, all quiet[i] are different.
    * 0 <= richer.length <= N * (N-1) / 2
    * 0 <= richer[i][j] < N
    * richer[i][0] != richer[i][1]
    * richer[i]'s are all different.
    * The observations in richer are all logically consistent."""

    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        graph = [[] for _ in quiet]
        for u, v in richer: graph[v].append(u)

        @cache
        def fn(x):
            """Return richer & loudest person given person."""
            ans = x
            for xx in graph[x]: ans = min(ans, fn(xx), key=quiet.__getitem__)
            return ans

        return [fn(x) for x in range(len(quiet))]


    """853. Car Fleet (Medium)
    N cars are going to the same destination along a one lane road. The
    destination is target miles away. Each car i has a constant speed speed[i]
    (in miles per hour), and initial position position[i] miles towards the
    target along the road. A car can never pass another car ahead of it, but it
    can catch up to it, and drive bumper to bumper at the same speed. The
    distance between these two cars is ignored - they are assumed to have the
    same position. A car fleet is some non-empty set of cars driving at the
    same position and same speed.  Note that a single car is also a car fleet.
    If a car catches up to a car fleet right at the destination point, it will
    still be considered as one car fleet. How many car fleets will arrive at
    the destination?

    Example 1:
    Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
    Output: 3
    Explanation:
    The cars starting at 10 and 8 become a fleet, meeting each other at 12.
    The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself.
    The cars starting at 5 and 3 become a fleet, meeting each other at 6.
    Note that no other cars meet these fleets before the destination, so the answer is 3.

    Note:
    * 0 <= N <= 10 ^ 4
    * 0 < target <= 10 ^ 6
    * 0 < speed[i] <= 10 ^ 6
    * 0 <= position[i] < target
    * All initial positions are different."""

    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        ans = prev = 0
        for pp, ss in sorted(zip(position, speed), reverse=True):
            tt = (target - pp)/ss # time to arrive at target
            if prev < tt:
                ans += 1
                prev = tt
        return ans


    """854. K-Similar Strings (Hard)
    Strings s1 and s2 are k-similar (for some non-negative integer k) if we can
    swap the positions of two letters in s1 exactly k times so that the
    resulting string equals s2. Given two anagrams s1 and s2, return the
    smallest k for which s1 and s2 are k-similar.

    Example 1:
    Input: s1 = "ab", s2 = "ba"
    Output: 1

    Example 2:
    Input: s1 = "abc", s2 = "bca"
    Output: 2

    Example 3:
    Input: s1 = "abac", s2 = "baca"
    Output: 2

    Example 4:
    Input: s1 = "aabc", s2 = "abca"
    Output: 2

    Constraints:
    * 1 <= s1.length <= 20
    * s2.length == s1.length
    * s1 and s2 contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}.
    * s2 is an anagram of s1."""

    def kSimilarity(self, s1: str, s2: str) -> int:
        ans = 0
        seen = {s1}
        queue = deque([s1])
        while queue:
            for _ in range(len(queue)):
                s = queue.popleft()
                if s == s2: return ans
                for i in range(len(s)):
                    if s[i] != s2[i]:
                        for j in range(i+1, len(s)):
                            if s[j] != s2[j] and s[j] == s2[i]:
                                ss = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]
                                if ss not in seen:
                                    seen.add(ss)
                                    queue.append(ss)
                        break
            ans += 1


    """856. Score of Parentheses (Medium)
    Given a balanced parentheses string S, compute the score of the string
    based on the following rule:
    * () has score 1
    * AB has score A + B, where A and B are balanced parentheses strings.
    * (A) has score 2 * A, where A is a balanced parentheses string.

    Example 1:
    Input: "()"
    Output: 1

    Example 2:
    Input: "(())"
    Output: 2

    Example 3:
    Input: "()()"
    Output: 2

    Example 4:
    Input: "(()(()))"
    Output: 6

    Note:
    * S is a balanced parentheses string, containing only ( and ).
    * 2 <= S.length <= 50"""

    def scoreOfParentheses(self, S: str) -> int:
        ans, stack = 0, []
        for ch in S:
            if ch == "(":
                stack.append(ans)
                ans = 0
            else: ans = max(1, 2*ans) + stack.pop()
        return ans


    """857. Minimum Cost to Hire K Workers (Hard)
    There are n workers. The i-th worker has a quality[i] and a minimum wage
    expectation wage[i]. Now we want to hire exactly k workers to form a paid
    group. When hiring a group of k workers, we must pay them according to the
    following rules:
    * Every worker in the paid group should be paid in the ratio of their
      quality compared to other workers in the paid group.
    * Every worker in the paid group must be paid at least their minimum wage
      expectation.
    Return the least amount of money needed to form a paid group satisfying the
    above conditions.

    Example 1:
    Input: quality = [10,20,5], wage = [70,50,30], k = 2
    Output: 105.00000
    Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.

    Example 2:
    Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3
    Output: 30.66667
    Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers
                 seperately.

    Note:
    * 1 <= k <= n <= 10000, where n = quality.length = wage.length
    * 1 <= quality[i] <= 10000
    * 1 <= wage[i] <= 10000
    * Answers within 10-5 of the correct answer will be considered correct."""

    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:
        ans = inf
        prefix = 0
        pq = []
        for q, w in sorted(zip(quality, wage), key=lambda x: x[1]/x[0]):
            prefix += q
            heappush(pq, -q)
            if len(pq) > k: prefix += heappop(pq)
            if len(pq) == k: ans = min(ans, prefix * w/q)
        return ans


    """860. Lemonade Change (Easy)
    At a lemonade stand, each lemonade costs $5. Customers are standing in a
    queue to buy from you and order one at a time (in the order specified by
    bills). Each customer will only buy one lemonade and pay with either a $5,
    $10, or $20 bill. You must provide the correct change to each customer so
    that the net transaction is that the customer pays $5. Note that you do not
    have any change in hand at first. Given an integer array bills where
    bills[i] is the bill the ith customer pays, return true if you can provide
    every customer with the correct change, or false otherwise.

    Example 1:
    Input: bills = [5,5,5,10,20]
    Output: true
    Explanation: - From the first 3 customers, we collect three $5 bills in
                   order.
                 - From the fourth customer, we collect a $10 bill and give back
                   a $5.
                 - From the fifth customer, we give a $10 bill and a $5 bill.
                 Since all customers got correct change, we output true.

    Example 2:
    Input: bills = [5,5,10,10,20]
    Output: false
    Explanation: - From the first two customers in order, we collect two $5
                   bills.
                 - For the next two customers in order, we collect a $10 bill
                   and give back a $5 bill.
                 - For the last customer, we can not give the change of $15 back
                   because we only have two $10 bills.
                 Since not every customer received the correct change, the
                 answer is false.

    Constraints:
    * 1 <= bills.length <= 10^5
    * bills[i] is either 5, 10, or 20."""

    def lemonadeChange(self, bills: List[int]) -> bool:
        five = ten = 0
        for bill in bills:
            if bill == 5: five += 1
            elif bill == 10: five -= 1; ten += 1
            elif ten: five -= 1; ten -= 1
            else: five -= 3
            if five < 0: return False
        return True


    """861. Score After Flipping Matrix (Medium)
    You are given an m x n binary matrix grid. A move consists of choosing any
    row or column and toggling each value in that row or column (i.e., changing
    all 0's to 1's, and all 1's to 0's). Every row of the matrix is interpreted
    as a binary number, and the score of the matrix is the sum of these numbers.
    Return the highest possible score after making any number of moves
    (including zero moves).

    Example 1:
    Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
    Output: 39
    Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39

    Example 2:
    Input: grid = [[0]]
    Output: 1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 20
    * grid[i][j] is either 0 or 1."""

    def matrixScore(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        for j in range(n):
            cnt = sum(grid[i][j] == grid[i][0] for i in range(m))
            cnt = max(cnt, m-cnt)
            ans += cnt * (1<<n-1-j)
        return ans


    """862. Shortest Subarray with Sum at Least K (Hard)
    Given an integer array nums and an integer k, return the length of the
    shortest non-empty subarray of nums with a sum of at least k. If there is
    no such subarray, return -1. A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1], k = 1
    Output: 1

    Example 2:
    Input: nums = [1,2], k = 4
    Output: -1

    Example 3:
    Input: nums = [2,-1,2], k = 3
    Output: 3

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^5 <= nums[i] <= 10^5
    * 1 <= k <= 10^9"""

    def shortestSubarray(self, nums: List[int], k: int) -> int:
        ans = inf
        queue = deque([(-1, 0)])
        prefix = 0
        for i, x in enumerate(nums):
            prefix += x
            while queue and prefix - queue[0][1] >= k: ans = min(ans, i - queue.popleft()[0])
            while queue and queue[-1][1] >= prefix: queue.pop()
            queue.append((i, prefix))
        return ans if ans < inf else -1


    """864. Shortest Path to Get All Keys (Hard)
    You are given an m x n grid grid where:
    * '.' is an empty cell.
    * '#' is a wall.
    * '@' is the starting point.
    * Lowercase letters represent keys.
    * Uppercase letters represent locks.
    You start at the starting point and one move consists of walking one space
    in one of the four cardinal directions. You cannot walk outside the grid,
    or walk into a wall. If you walk over a key, you can pick it up and you
    cannot walk over a lock unless you have its corresponding key. For some
    1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the
    first k letters of the English alphabet in the grid. This means that there
    is exactly one key for each lock, and one lock for each key; and also that
    the letters used to represent the keys and locks were chosen in the same
    order as the English alphabet. Return the lowest number of moves to acquire
    all keys. If it is impossible, return -1.

    Example 1:
    Input: grid = ["@.a.#","###.#","b.A.B"]
    Output: 8
    Explanation: Note that the goal is to obtain all the keys not to open all
                 the locks.

    Example 2:
    Input: grid = ["@..aA","..B#.","....b"]
    Output: 6

    Example 3:
    Input: grid = ["@Aa"]
    Output: -1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 30
    * grid[i][j] is either an English letter, '.', '#', or '@'.
    * The number of keys in the grid is in the range [1, 6].
    * Each key in the grid is unique.
    * Each key in the grid has a matching lock."""

    def shortestPathAllKeys(self, grid: List[str]) -> int:
        m, n = len(grid), len(grid[0])

        ii = jj = total = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "@": ii, jj = i, j
                elif grid[i][j].islower(): total += 1

        ans = 0
        seen = {(ii, jj, 0)}
        queue = [(ii, jj, 0)]
        while queue:
            newq = []
            for i, j, keys in queue:
                if keys == (1 << total) - 1: return ans
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != "#":
                        kk = keys
                        if grid[ii][jj].islower(): kk |= 1 << ord(grid[ii][jj]) - 97
                        if (ii, jj, kk) in seen or grid[ii][jj].isupper() and not kk & (1 << ord(grid[ii][jj])-65): continue
                        newq.append((ii, jj, kk))
                        seen.add((ii, jj, kk))
            ans += 1
            queue = newq
        return -1


    """865. Smallest Subtree with all the Deepest Nodes (Medium)
    Given the root of a binary tree, the depth of each node is the shortest
    distance to the root. Return the smallest subtree such that it contains all
    the deepest nodes in the original tree. A node is called the deepest if it
    has the largest depth possible among any node in the entire tree. The
    subtree of a node is tree consisting of that node, plus the set of all
    descendants of that node.

    Example 1:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4]
    Output: [2,7,4]
    Explanation: We return the node with value 2, colored in yellow in the
                 diagram. The nodes coloured in blue are the deepest nodes of
                 the tree. Notice that nodes 5, 3 and 2 contain the deepest
                 nodes in the tree but node 2 is the smallest subtree among
                 them, so we return it.

    Example 2:
    Input: root = [1]
    Output: [1]
    Explanation: The root is the deepest node in the tree.

    Example 3:
    Input: root = [0,1,3,null,2]
    Output: [2]
    Explanation: The deepest node in the tree is 2, the valid subtrees are the
                 subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the
                 smallest.

    Constraints:
    * The number of nodes in the tree will be in the range [1, 500].
    * 0 <= Node.val <= 500
    * The values of the nodes in the tree are unique."""

    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:

        @cache
        def fn(node):
            """Return height of tree rooted at node."""
            if not node: return 0
            return 1 + max(fn(node.left), fn(node.right))

        node = root
        while node:
            left, right = fn(node.left), fn(node.right)
            if left == right: return node
            elif left > right: node = node.left
            else: node = node.right


    """866. Prime Palindrome (Medium)
    Given an integer n, return the smallest prime palindrome greater than or
    equal to n. An integer is prime if it has exactly two divisors: 1 and
    itself. Note that 1 is not a prime number. For example, 2, 3, 5, 7, 11,
    and 13 are all primes. An integer is a palindrome if it reads the same from
    left to right as it does from right to left. For example, 101 and 12321 are
    palindromes. The test cases are generated so that the answer always exists
    and is in the range [2, 2 * 10^8].

    Example 1:
    Input: n = 6
    Output: 7

    Example 2:
    Input: n = 8
    Output: 11

    Example 3:
    Input: n = 13
    Output: 101

    Constraints: 1 <= n <= 10^8"""

    def primePalindrome(self, n: int) -> int:
        if 8 <= n <= 11: return 11 # edge case

        def fn(n):
            """Return next palindromic number greater than x."""
            digits = [int(x) for x in str(n)]
            for i in reversed(range(len(digits)//2+1)):
                if digits[i] < 9: break
            else: return 10*n + 11
            digits[i] = digits[~i] = digits[i] + 1
            for ii in range(i):
                digits[~ii] = digits[ii]
            for ii in range(i+1, len(digits)//2+1):
                digits[ii] = digits[~ii] = 0
            return int("".join(map(str, digits)))

        def isprime(x):
            """Return True if x is prime."""
            if x <= 1: return False
            if x % 2 == 0: return x == 2
            for k in range(3, int(sqrt(x))+1, 2):
                if x % k == 0: return False
            return True

        nn = n
        k = 0
        while nn:
            nn //= 10
            k += 1

        if not k&1: n = 10**k + 1
        elif str(n) != str(n)[::-1]: n = fn(n)

        while True:
            if isprime(n): return n
            n = fn(n)


    """869. Reordered Power of 2 (Medium)
    Starting with a positive integer N, we reorder the digits in any order
    (including the original order) such that the leading digit is not zero.
    Return true if and only if we can do this in a way such that the resulting
    number is a power of 2.

    Example 1:
    Input: 1
    Output: true

    Example 2:
    Input: 10
    Output: false

    Example 3:
    Input: 16
    Output: true

    Example 4:
    Input: 24
    Output: false

    Example 5:
    Input: 46
    Output: true

    Note: 1 <= N <= 10^9"""

    def reorderedPowerOf2(self, N: int) -> bool:
        return any(Counter(str(N)) == Counter(str(1 << i)) for i in range(30))


    """871. Minimum Number of Refueling Stops (Hard)
    A car travels from a starting position to a destination which is target
    miles east of the starting position. Along the way, there are gas stations.
    Each station[i] represents a gas station that is station[i][0] miles east
    of the starting position, and has station[i][1] liters of gas. The car
    starts with an infinite tank of gas, which initially has startFuel liters
    of fuel in it.  It uses 1 liter of gas per 1 mile that it drives. When the
    car reaches a gas station, it may stop and refuel, transferring all the gas
    from the station into the car. What is the least number of refueling stops
    the car must make in order to reach its destination?  If it cannot reach
    the destination, return -1. Note that if the car reaches a gas station with
    0 fuel left, the car can still refuel there.  If the car reaches the
    destination with 0 fuel left, it is still considered to have arrived.

    Example 1:
    Input: target = 1, startFuel = 1, stations = []
    Output: 0
    Explanation: We can reach the target without refueling.

    Example 2:
    Input: target = 100, startFuel = 1, stations = [[10,100]]
    Output: -1
    Explanation: We can't reach the target (or even the first gas station).

    Example 3:
    Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
    Output: 2
    Explanation: We start with 10 liters of fuel. We drive to position 10,
                 expending 10 liters of fuel.  We refuel from 0 liters to 60
                 liters of gas. Then, we drive from position 10 to position 60
                 (expending 50 liters of fuel), and refuel from 10 liters to 50
                 liters of gas.  We then drive to and reach the target. We made
                 2 refueling stops along the way, so we return 2.

    Note:
    * 1 <= target, startFuel, stations[i][1] <= 10^9
    * 0 <= stations.length <= 500
    * 0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target"""

    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        ans = k = 0
        total = startFuel
        pq = []
        while total < target:
            while k < len(stations) and stations[k][0] <= total:
                heappush(pq, -stations[k][1])
                k += 1
            if not pq: return -1
            total -= heappop(pq)
            ans += 1
        return ans


    """874. Walking Robot Simulation (Medium)
    A robot on an infinite XY-plane starts at point (0, 0) facing north. The
    robot can receive a sequence of these three possible types of commands:
    * -2: Turn left 90 degrees.
    * -1: Turn right 90 degrees.
    * 1 <= k <= 9: Move forward k units, one unit at a time.
    Some of the grid squares are obstacles. The ith obstacle is at grid point
    obstacles[i] = (xi, yi). If the robot runs into an obstacle, then it will
    instead stay in its current location and move on to the next command. Return
    the maximum Euclidean distance that the robot ever gets from the origin
    squared (i.e. if the distance is 5, return 25).

    Note:
    * North means +Y direction.
    * East means +X direction.
    * South means -Y direction.
    * West means -X direction.
    * There can be obstacle in [0,0].

    Example 1:
    Input: commands = [4,-1,3], obstacles = []
    Output: 25
    Explanation: The robot starts at (0, 0):
                 1. Move north 4 units to (0, 4).
                 2. Turn right.
                 3. Move east 3 units to (3, 4).
                 The furthest point the robot ever gets from the origin is
                 (3, 4), which squared is 32 + 42 = 25 units away.

    Example 2:
    Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
    Output: 65
    Explanation: The robot starts at (0, 0):
                 1. Move north 4 units to (0, 4).
                 2. Turn right.
                 3. Move east 1 unit and get blocked by the obstacle at (2, 4),
                    robot is at (1, 4).
                 4. Turn left.
                 5. Move north 4 units to (1, 8).
                 The furthest point the robot ever gets from the origin is
                 (1, 8), which squared is 12 + 82 = 65 units away.

    Example 3:
    Input: commands = [6,-1,-1,6], obstacles = []
    Output: 36
    Explanation: The robot starts at (0, 0):
                 1. Move north 6 units to (0, 6).
                 2. Turn right.
                 3. Turn right.
                 4. Move south 6 units to (0, 0).
                 The furthest point the robot ever gets from the origin is
                 (0, 6), which squared is 62 = 36 units away.

    Constraints:
    * 1 <= commands.length <= 10^4
    * commands[i] is either -2, -1, or an integer in the range [1, 9].
    * 0 <= obstacles.length <= 10^4
    * -3 * 10^4 <= xi, yi <= 3 * 10^4
    * The answer is guaranteed to be less than 2^31."""

    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        ans = x = y = 0
        dx, dy = 0, 1
        tabu = set((x, y) for x, y in obstacles)
        for command in commands:
            if command == -2: dx, dy = -dy, dx
            elif command == -1: dx, dy = dy, -dx
            else:
                for _ in range(command):
                    if (x+dx, y+dy) in tabu: break
                    x += dx
                    y += dy
            ans = max(ans, x*x + y*y)
        return ans


    """875. Koko Eating Bananas (Medium)
    Koko loves to eat bananas. There are n piles of bananas, the ith pile has
    piles[i] bananas. The guards have gone and will come back in h hours. Koko
    can decide her bananas-per-hour eating speed of k. Each hour, she chooses
    some pile of bananas and eats k bananas from that pile. If the pile has
    less than k bananas, she eats all of them instead and will not eat any more
    bananas during this hour. Koko likes to eat slowly but still wants to
    finish eating all the bananas before the guards return. Return the minimum
    integer k such that she can eat all the bananas within h hours.

    Example 1:
    Input: piles = [3,6,7,11], h = 8
    Output: 4

    Example 2:
    Input: piles = [30,11,23,4,20], h = 5
    Output: 30

    Example 3:
    Input: piles = [30,11,23,4,20], h = 6
    Output: 23

    Constraints:
    * 1 <= piles.length <= 10^4
    * piles.length <= h <= 10^9
    * 1 <= piles[i] <= 10^9"""

    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        lo, hi = 1, max(piles)
        while lo < hi:
            mid = lo + hi >> 1
            if sum(ceil(x/mid) for x in piles) <= h: hi = mid
            else: lo = mid + 1
        return lo


    """876. Middle of the Linked List (Easy)
    Given the head of a singly linked list, return the middle node of the
    linked list. If there are two middle nodes, return the second middle node.

    Example 1:
    Input: head = [1,2,3,4,5]
    Output: [3,4,5]
    Explanation: The middle node of the list is node 3.

    Example 2:
    Input: head = [1,2,3,4,5,6]
    Output: [4,5,6]
    Explanation: Since the list has two middle nodes with values 3 and 4, we
                 return the second one.

    Constraints:
    * The number of nodes in the list is in the range [1, 100].
    * 1 <= Node.val <= 100"""

    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow


    """877. Stone Game (Medium)
    Alex and Lee play a game with piles of stones. There are an even number of
    piles arranged in a row, and each pile has a positive integer number of
    stones piles[i]. The objective of the game is to end with the most stones.
    The total number of stones is odd, so there are no ties. Alex and Lee take
    turns, with Alex starting first. Each turn, a player takes the entire pile
    of stones from either the beginning or the end of the row. This continues
    until there are no more piles left, at which point the person with the most
    stones wins. Assuming Alex and Lee play optimally, return True if and only
    if Alex wins the game.

    Example 1:
    Input: piles = [5,3,4,5]
    Output: true
    Explanation:
    Alex starts first, and can only take the first 5 or the last 5.
    Say he takes the first 5, so that the row becomes [3, 4, 5].
    If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.
    If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.
    This demonstrated that taking the first 5 was a winning move for Alex, so we return true.

    Constraints:
    * 2 <= piles.length <= 500
    * piles.length is even.
    * 1 <= piles[i] <= 500
    * sum(piles) is odd."""

    def stoneGame(self, piles: List[int]) -> bool:

        @cache
        def fn(lo, hi):
            """Return diff when picking stones from lo to hi (inclusive)."""
            if lo == hi: return piles[lo]
            return max(piles[lo] - fn(lo+1, hi), piles[hi] - fn(lo, hi-1))

        return fn(0, len(piles)-1) > 0


    """878. Nth Magical Number (Hard)
    A positive integer is magical if it is divisible by either a or b. Given
    the three integers n, a, and b, return the nth magical number. Since the
    answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 1, a = 2, b = 3
    Output: 2

    Example 2:
    Input: n = 4, a = 2, b = 3
    Output: 6

    Example 3:
    Input: n = 5, a = 2, b = 4
    Output: 10

    Example 4:
    Input: n = 3, a = 6, b = 4
    Output: 8

    Constraints:
    * 1 <= n <= 10^9
    * 2 <= a, b <= 4 * 10^4"""

    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        # inclusion-exclusion principle
        ab = lcm(a,b)
        lo, hi = 0, n*min(a, b)
        while lo < hi:
            mid = lo + hi >> 1
            if mid//a + mid//b - mid//ab < n: lo = mid + 1
            else: hi = mid
        return lo % 1_000_000_007


    """879. Profitable Schemes (Hard)
    There is a group of n members, and a list of various crimes they could
    commit. The ith crime generates a profit[i] and requires group[i] members
    to participate in it. If a member participates in one crime, that member
    can't participate in another crime. Let's call a profitable scheme any
    subset of these crimes that generates at least minProfit profit, and the
    total number of members participating in that subset of crimes is at most
    n. Return the number of schemes that can be chosen. Since the answer may
    be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3]
    Output: 2
    Explanation: To make a profit of at least 3, the group could either commit
                 crimes 0 and 1, or just crime 1. In total, there are 2 schemes.

    Example 2:
    Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
    Output: 7
    Explanation: To make a profit of at least 5, the group could commit any
                 crimes, as long as they commit one. There are 7 possible
                 schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).

    Constraints:
    * 1 <= n <= 100
    * 0 <= minProfit <= 100
    * 1 <= group.length <= 100
    * 1 <= group[i] <= 100
    * profit.length == group.length
    * 0 <= profit[i] <= 100"""

    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        dp = [[0]*(1 + n) for _ in range(1 + minProfit)]
        dp[0][0] = 1
        for p, g in zip(profit, group):
            for i in range(minProfit, -1, -1):
                for j in range(n - g, -1, -1):
                    dp[min(i+p, minProfit)][j + g] += dp[i][j]
        return sum(dp[minProfit]) % 1_000_000_007


    """881. Boats to Save People (Medium)
    The i-th person has weight people[i], and each boat can carry a maximum
    weight of limit. Each boat carries at most 2 people at the same time,
    provided the sum of the weight of those people is at most limit. Return the
    minimum number of boats to carry every given person.  (It is guaranteed
    each person can be carried by a boat.)

    Example 1:
    Input: people = [1,2], limit = 3
    Output: 1
    Explanation: 1 boat (1, 2)

    Example 2:
    Input: people = [3,2,2,1], limit = 3
    Output: 3
    Explanation: 3 boats (1, 2), (2) and (3)

    Example 3:
    Input: people = [3,5,3,4], limit = 5
    Output: 4
    Explanation: 4 boats (3), (3), (4), (5)

    Note:
    * 1 <= people.length <= 50000
    * 1 <= people[i] <= limit <= 30000"""

    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort()
        ans = 0
        lo, hi = 0, len(people)-1
        while lo <= hi:
            if lo < hi and people[lo] + people[hi] <= limit: lo += 1
            hi -= 1
            ans += 1
        return ans


    """882. Reachable Nodes In Subdivided Graph (Hard)
    You are given an undirected graph (the "original graph") with n nodes
    labeled from 0 to n - 1. You decide to subdivide each edge in the graph
    into a chain of nodes, with the number of new nodes varying between each
    edge. The graph is given as a 2D array of edges where
    edges[i] = [ui, vi, cnti] indicates that there is an edge between nodes ui
    and vi in the original graph, and cnti is the total number of new nodes
    that you will subdivide the edge into. Note that cnti == 0 means you will
    not subdivide the edge. To subdivide the edge [ui, vi], replace it with
    (cnti + 1) new edges and cnti new nodes. The new nodes are x1, x2, ...,
    xcnti, and the new edges are [ui, x1], [x1, x2], [x2, x3], ...,
    [xcnti11, xcnti], [xcnti, vi]. In this new graph, you want to know how many
    nodes are reachable from the node 0, where a node is reachable if the
    distance is maxMoves or less. Given the original graph and maxMoves, return
    the number of nodes that are reachable from node 0 in the new graph.

    Example 1:
    Input: edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
    Output: 13
    Explanation: The edge subdivisions are shown in the image above. The nodes
                 that are reachable are highlighted in yellow.

    Example 2:
    Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
    Output: 23

    Example 3:
    Input: edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
    Output: 1
    Explanation: Node 0 is disconnected from the rest of the graph, so only
                 node 0 is reachable.

    Constraints:
    * 0 <= edges.length <= min(n * (n - 1) / 2, 10^4)
    * edges[i].length == 3
    * 0 <= ui < vi < n
    * There are no multiple edges in the graph.
    * 0 <= cnti <= 10^4
    * 0 <= maxMoves <= 10^9
    * 1 <= n <= 3000"""

    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
        graph = defaultdict(dict)
        for u, v, w in edges: graph[u][v] = graph[v][u] = w

        ans = 0
        pq = [(0, 0)] # min-heap

        seen = [False] * n
        used = defaultdict(int)

        while pq:
            x, u = heappop(pq)
            if not seen[u]:
                ans += 1
                seen[u] = True
                for v, c in graph[u].items():
                    if not used[u, v]:
                        if used[v, u] < graph[v][u]:
                            used[u, v] = min(maxMoves - x, graph[v][u] - used[v, u])
                            ans += used[u, v]
                        if x + c + 1 <= maxMoves and not seen[v]: heappush(pq, (x + c + 1, v))
        return ans


    """887. Super Egg Drop (Hard)
    You are given k identical eggs and you have access to a building with n
    floors labeled from 1 to n. You know that there exists a floor f where
    0 <= f <= n such that any egg dropped at a floor higher than f will break,
    and any egg dropped at or below floor f will not break. Each move, you may
    take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If
    the egg breaks, you can no longer use it. However, if the egg does not
    break, you may reuse it in future moves. Return the minimum number of moves
    that you need to determine with certainty what the value of f is.

    Example 1:
    Input: k = 1, n = 2
    Output: 2
    Explanation: Drop the egg from floor 1. If it breaks, we know that f = 0.
                 Otherwise, drop the egg from floor 2. If it breaks, we know
                 that f = 1. If it does not break, then we know f = 2. Hence,
                 we need at minimum 2 moves to determine with certainty what
                 the value of f is.

    Example 2:
    Input: k = 2, n = 6
    Output: 3

    Example 3:
    Input: k = 3, n = 14
    Output: 4

    Constraints:
    * 1 <= k <= 100
    * 1 <= n <= 10^4"""

    def superEggDrop(self, k: int, n: int) -> int:

        @cache
        def fn(m, k):
            """Return max floor reachable with m moves and k eggs."""
            if m == 0 or k == 0: return 0
            return 1 + fn(m-1, k-1) + fn(m-1, k)

        return next(m for m in range(1, n+1) if fn(m, k) >= n)


    """889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)
    Return any binary tree that matches the given preorder and postorder
    traversals. Values in the traversals pre and post are distinct positive
    integers.

    Example 1:
    Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
    Output: [1,2,3,4,5,6,7]

    Note:
    * 1 <= pre.length == post.length <= 30
    * pre[] and post[] are both permutations of 1, 2, ..., pre.length.
    * It is guaranteed an answer exists. If there exists multiple answers, you
      can return any of them."""


    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:
        mp = {x: i for i, x in enumerate(post)}

        root = None
        stack = []
        for x in pre:
            if not root: root = node = TreeNode(x)
            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)
            else:
                while mp[stack[-1].val] < mp[x]: stack.pop() # retrace
                stack[-1].right = node = TreeNode(x)
            stack.append(node)
        return root


    """890. Find and Replace Pattern (Medium)
    You have a list of words and a pattern, and you want to know which words in
    words matches the pattern. A word matches the pattern if there exists a
    permutation of letters p so that after replacing every letter x in the
    pattern with p(x), we get the desired word. (Recall that a permutation of
    letters is a bijection from letters to letters: every letter maps to
    another letter, and no two letters map to the same letter.) Return a list
    of the words in words that match the given pattern. You may return the
    answer in any order.

    Example 1:
    Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
    Output: ["mee","aqq"]
    Explanation: "mee" matches the pattern because there is a permutation
                 {a -> m, b -> e, ...}. "ccc" does not match the pattern
                 because {a -> c, b -> c, ...} is not a permutation, since a
                 and b map to the same letter.

    Note:
    * 1 <= words.length <= 50
    * 1 <= pattern.length = words[i].length <= 20"""

    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        return [word for word in words if len(set(zip(word, pattern))) == len(set(word)) == len(set(pattern))]


    """891. Sum of Subsequence Widths (Hard)
    The width of a sequence is the difference between the maximum and minimum
    elements in the sequence. Given an array of integers nums, return the sum
    of the widths of all the non-empty subsequences of nums. Since the answer
    may be very large, return it modulo 10^9 + 7. A subsequence is a sequence
    that can be derived from an array by deleting some or no elements without
    changing the order of the remaining elements. For example, [3,6,2,7] is a
    subsequence of the array [0,3,1,6,2,2,7].

    Example 1:
    Input: nums = [2,1,3]
    Output: 6
    Explanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3],
                 [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2.
                 The sum of these widths is 6.

    Example 2:
    Input: nums = [2]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def sumSubseqWidths(self, nums: List[int]) -> int:
        MOD = 1_000_000_007
        ans = 0
        for i, x in enumerate(sorted(nums)):
            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))
        return ans % MOD


    """894. All Possible Full Binary Trees (Medium)
    A full binary tree is a binary tree where each node has exactly 0 or 2
    children. Return a list of all possible full binary trees with N nodes.
    Each element of the answer is the root node of one possible tree. Each node
    of each tree in the answer must have node.val = 0. You may return the final
    list of trees in any order.

    Example 1:
    Input: 7
    Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],
             [0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],
             [0,0,0,0,0,null,null,0,0]]

    Note: 1 <= N <= 20"""

    def allPossibleFBT(self, N: int) -> List[TreeNode]:

        @cache
        def fn(n):
            """Return all full binary trees of n nodes."""
            if n == 1: return [TreeNode()]
            ans = []
            for nn in range(1, n, 2):
                for left in fn(nn):
                    for right in fn(n-1-nn):
                        ans.append(TreeNode(left=left, right=right))
            return ans

        return fn(N)


    """897. Increasing Order Search Tree (Easy)
    Given the root of a binary search tree, rearrange the tree in in-order so
    that the leftmost node in the tree is now the root of the tree, and every
    node has no left child and only one right child.

    Example 1:
    Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
    Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

    Example 2:
    Input: root = [5,1,7]
    Output: [1,null,5,null,7]

    Constraints:
    * The number of nodes in the given tree will be in the range [1, 100].
    * 0 <= Node.val <= 1000"""

    def increasingBST(self, root: TreeNode) -> TreeNode:
        ans = temp = None
        stack = []
        node = root
        while stack or node:
            if node:
                stack.append(node)
                node = node.left
                continue
            node = stack.pop()
            if not ans: ans = temp = node
            else: temp.right = temp = node
            node.left = None
            node = node.right
        return ans


    """898. Bitwise ORs of Subarrays (Medium)
    We have an array A of non-negative integers. For every (contiguous)
    subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise
    OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j].
    Return the number of possible results.  (Results that occur more than once
    are only counted once in the final answer.)

    Example 1:
    Input: [0]
    Output: 1
    Explanation: There is only one possible result: 0.

    Example 2:
    Input: [1,1,2]
    Output: 3
    Explanation: The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].
                 These yield the results 1, 1, 2, 1, 3, 3.
                 There are 3 unique values, so the answer is 3.

    Example 3:
    Input: [1,2,4]
    Output: 6
    Explanation: The possible results are 1, 2, 3, 4, 6, and 7.

    Note:
    * 1 <= A.length <= 50000
    * 0 <= A[i] <= 10^9"""

    def subarrayBitwiseORs(self, A: List[int]) -> int:
        ans, vals = set(), set()
        for x in A:
            vals = {x | xx for xx in vals} | {x}
            ans |= vals
        return len(ans)


    """899. Orderly Queue (Hard)
    A string s of lowercase letters is given. Then, we may make any number of
    moves. In each move, we choose one of the first k letters (starting from
    the left), remove it, and place it at the end of the string. Return the
    lexicographically smallest string we could have after any number of moves.

    Example 1:
    Input: s = "cba", k = 1
    Output: "acb"
    Explanation: In the first move, we move the 1st character ("c") to the end,
                 obtaining the string "bac". In the second move, we move the
                 1st character ("b") to the end, obtaining the final result
                 "acb".

    Example 2:
    Input: s = "baaca", k = 3
    Output: "aaabc"
    Explanation: In the first move, we move the 1st character ("b") to the end,
                 obtaining the string "aacab". In the second move, we move the
                 3rd character ("c") to the end, obtaining the final result
                 "aaabc".

    Note:
    * 1 <= k <= s.length <= 1000
    * s consists of lowercase letters only."""

    def orderlyQueue(self, s: str, k: int) -> str:
        if k == 1: return min(s[i:] + s[:i] for i in range(len(s)))
        return "".join(sorted(s))


    """902. Numbers At Most N Given Digit Set (Hard)
    Given an array of digits which is sorted in non-decreasing order. You can
    write numbers using each digits[i] as many times as we want. For example,
    if digits = ['1','3','5'], we may write numbers such as '13', '551', and
    '1351315'. Return the number of positive integers that can be generated
    that are less than or equal to a given integer n.

    Example 1:
    Input: digits = ["1","3","5","7"], n = 100
    Output: 20
    Explanation: The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13,
                 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.

    Example 2:
    Input: digits = ["1","4","9"], n = 1000000000
    Output: 29523
    Explanation: We can write 3 one digit numbers, 9 two digit numbers, 27
                 three digit numbers, 81 four digit numbers, 243 five digit
                 numbers, 729 six digit numbers, 2187 seven digit numbers, 6561
                 eight digit numbers, and 19683 nine digit numbers. In total,
                 this is 29523 integers that can be written using the digits
                 array.

    Example 3:
    Input: digits = ["7"], n = 8
    Output: 1

    Constraints:
    * 1 <= digits.length <= 9
    * digits[i].length == 1
    * digits[i] is a digit from '1' to '9'.
    * All the values in digits are unique.
    * digits is sorted in non-decreasing order.
    * 1 <= n <= 10^9"""

    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        s = str(n)
        ans = sum(len(digits) ** i for i in range(1, len(s)))
        for i in range(len(s)):
            ans += sum(c < s[i] for c in digits) * (len(digits) ** (len(s) - i - 1))
            if s[i] not in digits: return ans
        return ans + 1


    """903. Valid Permutations for DI Sequence (Hard)
    We are given s, a length n string of characters from the set {'D', 'I'}.
    (These letters stand for "decreasing" and "increasing".) A valid
    permutation is a permutation p[0], p[1], ..., p[n] of integers
    {0, 1, ..., n}, such that for all i:
    * If s[i] == 'D', then p[i] > p[i+1], and;
    * If s[i] == 'I', then p[i] < p[i+1].
    How many valid permutations are there?  Since the answer may be large,
    return your answer modulo 10^9 + 7.

    Example 1:
    Input: s = "DID"
    Output: 5
    Explanation: The 5 valid permutations of (0, 1, 2, 3) are:
                 (1, 0, 3, 2)
                 (2, 0, 3, 1)
                 (2, 1, 3, 0)
                 (3, 0, 2, 1)
                 (3, 1, 2, 0)

    Note:
    * 1 <= s.length <= 200
    * s consists only of characters from the set {'D', 'I'}."""

    def numPermsDISequence(self, s: str) -> int:

        @cache
        def fn(i, x):
            """Return number of valid permutations for s[i:] given x numbers smaller than previous one."""
            if i == len(s): return 1
            if s[i] == "D":
                if x == 0: return 0 # cannot decrease
                return fn(i, x-1) + fn(i+1, x-1)
            else:
                if x == len(s)-i: return 0 # cannot increase
                return fn(i, x+1) + fn(i+1, x)

        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007


    """904. Fruit Into Baskets (Medium)
    You are visiting a farm that has a single row of fruit trees arranged from
    left to right. The trees are represented by an integer array fruits where
    fruits[i] is the type of fruit the ith tree produces. You want to collect
    as much fruit as possible. However, the owner has some strict rules that
    you must follow:
    * You only have two baskets, and each basket can only hold a single type of
      fruit. There is no limit on the amount of fruit each basket can hold.
    * Starting from any tree of your choice, you must pick exactly one fruit
      from every tree (including the start tree) while moving to the right. The
      picked fruits must fit in one of your baskets.
    * Once you reach a tree with fruit that cannot fit in your baskets, you
      must stop.
    Given the integer array fruits, return the maximum number of fruits you can
    pick.

    Example 1:
    Input: fruits = [1,2,1]
    Output: 3
    Explanation: We can pick from all 3 trees.

    Example 2:
    Input: fruits = [0,1,2,2]
    Output: 3
    Explanation: We can pick from trees [1,2,2]. If we had started at the first
                 tree, we would only pick from trees [0,1].

    Example 3:
    Input: fruits = [1,2,3,2,2]
    Output: 4
    Explanation: We can pick from trees [2,3,2,2]. If we had started at the
                 first tree, we would only pick from trees [1,2].

    Constraints:
    * 1 <= fruits.length <= 10^5
    * 0 <= fruits[i] < fruits.length"""

    def totalFruit(self, fruits: List[int]) -> int:
        ans = ii = 0
        freq = defaultdict(int)
        for i, x in enumerate(fruits):
            freq[x] += 1
            while len(freq) > 2:
                freq[fruits[ii]] -= 1
                if freq[fruits[ii]] == 0: freq.pop(fruits[ii])
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans


    """909. Snakes and Ladders (Medium)
    On an N x N board, the numbers from 1 to N*N are written boustrophedonically
    starting from the bottom left of the board, and alternating direction each
    row. You start on square 1 of the board (which is always in the last row and
    first column).  Each move, starting from square x, consists of the following:
    * You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or
      x+6, provided this number is <= N*N.
      + (This choice simulates the result of a standard 6-sided die roll: ie.,
        there are always at most 6 destinations, regardless of the size of the
        board.)
    * If S has a snake or ladder, you move to the destination of that snake or
      ladder.  Otherwise, you move to S.
    A board square on row r and column c has a "snake or ladder" if
    board[r][c] != -1.  The destination of that snake or ladder is board[r][c].
    Note that you only take a snake or ladder at most once per move: if the
    destination to a snake or ladder is the start of another snake or ladder,
    you do not continue moving.  (For example, if the board is `[[4,-1],[-1,3]]`,
    and on the first move your destination square is `2`, then you finish your
    first move at `3`, because you do not continue moving to `4`.) Return the
    least number of moves required to reach square N*N.  If it is not possible,
    return -1.

    Example 1:
    Input: [
    [-1,-1,-1,-1,-1,-1],
    [-1,-1,-1,-1,-1,-1],
    [-1,-1,-1,-1,-1,-1],
    [-1,35,-1,-1,13,-1],
    [-1,-1,-1,-1,-1,-1],
    [-1,15,-1,-1,-1,-1]]
    Output: 4
    Explanation:
    At the beginning, you start at square 1 [at row 5, column 0].
    You decide to move to square 2, and must take the ladder to square 15.
    You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.
    You then decide to move to square 14, and must take the ladder to square 35.
    You then decide to move to square 36, ending the game.
    It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.

    Note:
    * 2 <= board.length = board[0].length <= 20
    * board[i][j] is between 1 and N*N or is equal to -1.
    * The board square with number 1 has no snake or ladder.
    * The board square with number N*N has no snake or ladder."""

    def snakesAndLadders(self, board: List[List[int]]) -> int:
        n = len(board)
        ans = 0
        seen = {1}
        queue = deque([1])
        while queue:
            for _ in range(len(queue)):
                x = queue.popleft()
                if x == n*n: return ans
                for xx in range(x+1, x+7):
                    if xx <= n*n:
                        i, j = divmod(xx-1, n)
                        if board[~i][~j if i&1 else j] != -1: xx = board[~i][~j if i&1 else j]
                        if xx not in seen:
                            seen.add(xx)
                            queue.append(xx)
            ans += 1
        return -1


    """910. Smallest Range II (Medium)
    Given an array A of integers, for each integer A[i] we need to choose
    either x = -K or x = K, and add x to A[i] (only once). After this process,
    we have some array B. Return the smallest possible difference between the
    maximum value of B and the minimum value of B.

    Example 1:
    Input: A = [1], K = 0
    Output: 0
    Explanation: B = [1]

    Example 2:
    Input: A = [0,10], K = 2
    Output: 6
    Explanation: B = [2,8]

    Example 3:
    Input: A = [1,3,6], K = 3
    Output: 3
    Explanation: B = [4,6,3]

    Note:
    * 1 <= A.length <= 10000
    * 0 <= A[i] <= 10000
    * 0 <= K <= 10000"""

    def smallestRangeII(self, A: List[int], K: int) -> int:
        A.sort()
        ans = A[-1] - A[0]
        for i in range(1, len(A)):
            mn = min(A[0] + K, A[i] - K) # move up A[:i]
            mx = max(A[i-1]+K, A[-1] - K) # move down A[i:]
            ans = min(ans, mx - mn)
        return ans


    """912. Sort an Array (Medium)
    Given an array of integers nums, sort the array in ascending order.

    Example 1:
    Input: nums = [5,2,3,1]
    Output: [1,2,3,5]

    Example 2:
    Input: nums = [5,1,1,2,0,0]
    Output: [0,0,1,1,2,5]

    Constraints:
    * 1 <= nums.length <= 50000
    * -50000 <= nums[i] <= 50000"""

    def sortArray(self, nums: List[int]) -> List[int]:
        shuffle(nums)

        def sort(lo, hi):
            """Sort subarray nums[lo:hi] in place."""
            if lo + 1 >= hi: return
            i, j = lo+1, hi-1
            while i <= j:
                if nums[i] < nums[lo]: i += 1
                elif nums[j] > nums[lo]: j -= 1
                else:
                    nums[i], nums[j] = nums[j], nums[i]
                    i += 1
                    j -= 1
            nums[lo], nums[j] = nums[j], nums[lo]
            sort(lo, j)
            sort(j+1, hi)

        sort(0, len(nums))
        return nums


    """915. Partition Array into Disjoint Intervals (Medium)
    Given an array A, partition it into two (contiguous) subarrays left and
    right so that:
    * Every element in left is less than or equal to every element in right.
    * left and right are non-empty.
    * left has the smallest possible size.
    Return the length of left after such a partitioning.  It is guaranteed that
    such a partitioning exists.

    Example 1:
    Input: [5,0,3,8,6]
    Output: 3
    Explanation: left = [5,0,3], right = [8,6]

    Example 2:
    Input: [1,1,1,0,6,12]
    Output: 4
    Explanation: left = [1,1,1,0], right = [6,12]

    Note:
    * 2 <= A.length <= 30000
    * 0 <= A[i] <= 10^6
    * It is guaranteed there is at least one way to partition A as described."""

    def partitionDisjoint(self, nums: List[int]) -> int:
        ans = 0
        mx = threshold = nums[0]
        for i, x in enumerate(nums):
            mx = max(mx, x)
            if x < threshold: # threshold to partition the array
                ans = i
                threshold = mx
        return ans + 1


    """916. Word Subsets (Medium)
    We are given two arrays A and B of words. Each word is a string of
    lowercase letters. Now, say that word b is a subset of word a if every
    letter in b occurs in a, including multiplicity.  For example, "wrr" is a
    subset of "warrior", but is not a subset of "world". Now say a word a from
    A is universal if for every b in B, b is a subset of a. Return a list of
    all universal words in A.  You can return the words in any order.

    Example 1:
    Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"]
    Output: ["facebook","google","leetcode"]

    Example 2:
    Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"]
    Output: ["apple","google","leetcode"]

    Example 3:
    Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"]
    Output: ["facebook","google"]

    Example 4:
    Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"]
    Output: ["google","leetcode"]

    Example 5:
    Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"]
    Output: ["facebook","leetcode"]

    Note:
    * 1 <= A.length, B.length <= 10000
    * 1 <= A[i].length, B[i].length <= 10
    * A[i] and B[i] consist only of lowercase letters.
    * All words in A[i] are unique: there isn't i != j with A[i] == A[j]."""

    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:
        freq = Counter()
        for x in B: freq |= Counter(x)
        return [x for x in A if not freq - Counter(x)]


    """917. Reverse Only Letters (Easy)
    Given a string s, reverse the string according to the following rules:
    * All the characters that are not English letters remain in the same position.
    * All the English letters (lowercase or uppercase) should be reversed.
    Return s after reversing it.

    Example 1:
    Input: s = "ab-cd"
    Output: "dc-ba"

    Example 2:
    Input: s = "a-bC-dEf-ghIj"
    Output: "j-Ih-gfE-dCba"

    Example 3:
    Input: s = "Test1ng-Leet=code-Q!"
    Output: "Qedo1ct-eeLg=ntse-T!"

    Constraints:
    * 1 <= s.length <= 100
    * s consists of characters with ASCII values in the range [33, 122].
    * s does not contain '\"' or '\\'."""

    def reverseOnlyLetters(self, s: str) -> str:
        s = list(s)
        lo, hi = 0, len(s)-1
        while lo < hi:
            if not s[lo].isalpha(): lo += 1
            elif not s[hi].isalpha(): hi -= 1
            else:
                s[lo], s[hi] = s[hi], s[lo]
                lo += 1
                hi -= 1
        return "".join(s)


    """918. Maximum Sum Circular Subarray (Medium)
    Given a circular integer array nums of length n, return the maximum
    possible sum of a non-empty subarray of nums. A circular array means the
    end of the array connects to the beginning of the array. Formally, the
    next element of nums[i] is nums[(i + 1) % n] and the previous element of
    nums[i] is nums[(i - 1 + n) % n]. A subarray may only include each element
    of the fixed buffer nums at most once. Formally, for a subarray nums[i],
    nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with
    k1 % n == k2 % n.

    Example 1:
    Input: nums = [1,-2,3,-2]
    Output: 3
    Explanation: Subarray [3] has maximum sum 3.

    Example 2:
    Input: nums = [5,-3,5]
    Output: 10
    Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.

    Example 3:
    Input: nums = [-3,-2,-3]
    Output: -2
    Explanation: Subarray [-2] has maximum sum -2.

    Constraints:
    * n == nums.length
    * 1 <= n <= 3 * 10^4
    * -3 * 10^4 <= nums[i] <= 3 * 10^4"""

    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        large = small = total = 0
        most, least = -inf, -inf
        for x in nums:
            total += x
            large = max(0, large) + x
            most  = max(most, large)
            small = max(0, small - x)
            least = max(least, small)
        return max(most, total + least) if most >= 0 else most


    """920. Number of Music Playlists (Hard)
    Your music player contains n different songs and she wants to listen to
    goal (not necessarily different) songs during your trip.  You create a
    playlist so that:
    * Every song is played at least once
    * A song can only be played again only if k other songs have been played
    Return the number of possible playlists.  As the answer can be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, goal = 3, k = 1
    Output: 6
    Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2],
                 [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].

    Example 2:
    Input: n = 2, goal = 3, k = 0
    Output: 6
    Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1],
                 [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]

    Example 3:
    Input: n = 2, goal = 3, k = 1
    Output: 2
    Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]

    Note: 0 <= k < n <= goal <= 100"""

    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:

        @cache
        def fn(i, x):
            """Return number starting from ith position with x songs already appeared."""
            if i == goal: return x == n
            ans = 0
            if x < n: ans += (n-x) * fn(i+1, x+1) # a new song
            if k < x: ans += (x-k) * fn(i+1, x) # an old song
            return ans % 1_000_000_007

        return fn(0, 0)


    """921. Minimum Add to Make Parentheses Valid (Medium)
    Given a string S of '(' and ')' parentheses, we add the minimum number of
    parentheses ( '(' or ')', and in any positions ) so that the resulting
    parentheses string is valid. Formally, a parentheses string is valid if and
    only if:
    * It is the empty string, or
    * It can be written as AB (A concatenated with B), where A and B are valid
      strings, or
    * It can be written as (A), where A is a valid string.
    Given a parentheses string, return the minimum number of parentheses we
    must add to make the resulting string valid.

    Example 1:
    Input: "())"
    Output: 1

    Example 2:
    Input: "((("
    Output: 3

    Example 3:
    Input: "()"
    Output: 0

    Example 4:
    Input: "()))(("
    Output: 4

    Note:
    * S.length <= 1000
    * S only consists of '(' and ')' characters."""

    def minAddToMakeValid(self, S: str) -> int:
        op = cl = 0 # open and closed parenthesis needed
        for c in S:
            cl += 1 if c == "(" else -1 # need ) to balance extra (
            if cl < 0:
                cl = 0
                op += 1 # need ( to balance extra )
        return op + cl


    """922. Sort Array By Parity II (Easy)
    Given an array of integers nums, half of the integers in nums are odd, and
    the other half are even. Sort the array so that whenever nums[i] is odd, i
    is odd, and whenever nums[i] is even, i is even. Return any answer array
    that satisfies this condition.

    Example 1:
    Input: nums = [4,2,5,7]
    Output: [4,5,2,7]
    Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.

    Example 2:
    Input: nums = [2,3]
    Output: [2,3]

    Constraints:
    * 2 <= nums.length <= 2 * 10^4
    * nums.length is even.
    * Half of the integers in nums are even.
    * 0 <= nums[i] <= 1000

    Follow Up: Could you solve it in-place?"""

    def sortArrayByParityII(self, nums: List[int]) -> List[int]:
        ii, i = 0, 1
        while ii < len(nums) and i < len(nums):
            if not nums[ii] & 1: ii += 2
            elif nums[i] & 1: i += 2
            else:
                nums[ii], nums[i] = nums[i], nums[ii]
                ii += 2
                i += 2
        return nums


    """923. 3Sum With Multiplicity (Medium)
    Given an integer array A, and an integer target, return the number of
    tuples i, j, k  such that i < j < k and A[i] + A[j] + A[k] == target. As
    the answer can be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8
    Output: 20
    Explanation:
    Enumerating by the values (A[i], A[j], A[k]):
    (1, 2, 5) occurs 8 times;
    (1, 3, 4) occurs 8 times;
    (2, 2, 4) occurs 2 times;
    (2, 3, 3) occurs 2 times.

    Example 2:
    Input: A = [1,1,2,2,2,2], target = 5
    Output: 12
    Explanation:
    A[i] = 1, A[j] = A[k] = 2 occurs 12 times:
    We choose one 1 from [1,1] in 2 ways,
    and two 2s from [2,2,2,2] in 6 ways.

    Constraints:
    * 3 <= A.length <= 3000
    * 0 <= A[i] <= 100
    * 0 <= target <= 300"""

    def threeSumMulti(self, arr: List[int], target: int) -> int:
        ans = 0
        seen = {}
        for i, x in enumerate(arr):
            ans += seen.get(target - x, 0)
            for ii in range(i):
                sm = arr[ii] + arr[i]
                seen[sm] = 1 + seen.get(sm, 0)
        return ans % 1_000_000_007


    """924. Minimize Malware Spread (Hard)
    You are given a network of n nodes represented as an n x n adjacency matrix
    graph, where the ith node is directly connected to the jth node if
    graph[i][j] == 1. Some nodes initial are initially infected by malware.
    Whenever two nodes are directly connected, and at least one of those two
    nodes is infected by malware, both nodes will be infected by malware. This
    spread of malware will continue until no more nodes can be infected in this
    manner. Suppose M(initial) is the final number of nodes infected with
    malware in the entire network after the spread of malware stops. We will
    remove exactly one node from initial. Return the node that, if removed,
    would minimize M(initial). If multiple nodes could be removed to minimize
    M(initial), return such a node with the smallest index. Note that if a node
    was removed from the initial list of infected nodes, it might still be
    infected later due to the malware spread.

    Example 1:
    Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
    Output: 0

    Example 2:
    Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
    Output: 0

    Example 3:
    Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
    Output: 1

    Constraints:
    * n == graph.length
    * n == graph[i].length
    * 2 <= n <= 300
    * graph[i][j] is 0 or 1.
    * graph[i][j] == graph[j][i]
    * graph[i][i] == 1
    * 1 <= initial.length <= n
    * 0 <= initial[i] <= n - 1
    * All the integers in initial are unique."""

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        uf = UnionFind(n)
        for u in range(n):
            for v in range(u+1, n):
                if graph[u][v]: uf.union(u, v)

        freq = defaultdict(int)
        for u in initial: freq[uf.find(u)] += 1

        ans = best = -1
        for u in initial:
            uu = uf.find(u)
            cnt = uf.rank[uu] if freq[uu] == 1 else 0
            if cnt > best or cnt == best and u < ans: ans, best = u, cnt
        return ans


    """926. Flip String to Monotone Increasing (Medium)
    A string of '0's and '1's is monotone increasing if it consists of some
    number of '0's (possibly 0), followed by some number of '1's (also possibly
    0.) We are given a string S of '0's and '1's, and we may flip any '0' to a
    '1' or a '1' to a '0'. Return the minimum number of flips to make S monotone
    increasing.

    Example 1:
    Input: "00110"
    Output: 1
    Explanation: We flip the last digit to get 00111.

    Example 2:
    Input: "010110"
    Output: 2
    Explanation: We flip to get 011111, or alternatively 000111.

    Example 3:
    Input: "00011000"
    Output: 2
    Explanation: We flip to get 00000000.

    Note:
    * 1 <= S.length <= 20000
    * S only consists of '0' and '1' characters."""

    def minFlipsMonoIncr(self, S: str) -> int:
        ones = flip = 0
        for ch in S:
            if ch == "1": ones += 1
            else: flip = min(ones, flip + 1)
        return flip


    """928. Minimize Malware Spread II (Hard)
    You are given a network of n nodes represented as an n x n adjacency matrix
    graph, where the ith node is directly connected to the jth node if
    graph[i][j] == 1. Some nodes initial are initially infected by malware.
    Whenever two nodes are directly connected, and at least one of those two
    nodes is infected by malware, both nodes will be infected by malware. This
    spread of malware will continue until no more nodes can be infected in this
    manner. Suppose M(initial) is the final number of nodes infected with
    malware in the entire network after the spread of malware stops. We will
    remove exactly one node from initial, completely removing it and any
    connections from this node to any other node. Return the node that, if
    removed, would minimize M(initial). If multiple nodes could be removed to
    minimize M(initial), return such a node with the smallest index.

    Example 1:
    Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
    Output: 0

    Example 2:
    Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
    Output: 1

    Example 3:
    Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
    Output: 1

    Constraints:
    * n == graph.length
    * n == graph[i].length
    * 2 <= n <= 300
    * graph[i][j] is 0 or 1.
    * graph[i][j] == graph[j][i]
    * graph[i][i] == 1
    * 1 <= initial.length < n
    * 0 <= initial[i] <= n - 1
    * All the integers in initial are unique."""

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        uf = UnionFind(n)
        initial = set(initial)
        for u in range(n):
            if u not in initial:
                for v in range(u+1, n):
                    if graph[u][v] and v not in initial:
                        uf.union(u, v)

        mp = defaultdict(set)
        for u in initial:
            for v in range(n):
                if graph[u][v] and v not in initial:
                    mp[u].add(uf.find(v))
        freq = sum((Counter(v) for v in mp.values()), Counter())

        ans = best = -1
        for u in initial:
            cnt = 0
            for v in mp[u]:
                if freq[v] == 1: cnt += uf.rank[v]
            if cnt > best or cnt == best and u < ans: ans, best= u, cnt
        return ans


    """929. Unique Email Addresses (Easy)
    Every valid email consists of a local name and a domain name, separated by
    the '@' sign. Besides lowercase letters, the email may contain one or more
    '.' or '+'. For example, in "alice@leetcode.com", "alice" is the local name,
    and "leetcode.com" is the domain name. If you add periods '.' between some
    characters in the local name part of an email address, mail sent there will
    be forwarded to the same address without dots in the local name. Note that
    this rule does not apply to domain names. For example, "alice.z@leetcode.com"
    and "alicez@leetcode.com" forward to the same email address. If you add a
    plus '+' in the local name, everything after the first plus sign will be
    ignored. This allows certain emails to be filtered. Note that this rule
    does not apply to domain names. For example, "m.y+name@email.com" will be
    forwarded to "my@email.com". It is possible to use both of these rules at
    the same time. Given an array of strings emails where we send one email to
    each email[i], return the number of different addresses that actually
    receive mails.

    Example 1:
    Input: emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
    Output: 2
    Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails.

    Example 2:
    Input: emails = ["a@leetcode.com","b@leetcode.com","c@leetcode.com"]
    Output: 3

    Constraints:
    * 1 <= emails.length <= 100
    * 1 <= emails[i].length <= 100
    * email[i] consist of lowercase English letters, '+', '.' and '@'.
    * Each emails[i] contains exactly one '@' character.
    * All local and domain names are non-empty.
    * Local names do not start with a '+' character."""

    def numUniqueEmails(self, emails: List[str]) -> int:
        seen = set()
        for email in emails:
            local, domain = email.split("@")
            local = local.split("+")[0].replace(".", "")
            seen.add("@".join((local, domain)))
        return len(seen)


    """930. Binary Subarrays With Sum (Medium)
    In an array A of 0s and 1s, how many non-empty subarrays have sum S?

    Example 1:
    Input: A = [1,0,1,0,1], S = 2
    Output: 4
    Explanation:
    The 4 subarrays are bolded below:
    [1,0,1,0,1]
    [1,0,1,0,1]
    [1,0,1,0,1]
    [1,0,1,0,1]

    Note:
    * A.length <= 30000
    * 0 <= S <= A.length
    * A[i] is either 0 or 1."""

    def numSubarraysWithSum(self, A: List[int], S: int) -> int:
        ans = prefix = 0
        seen = {0: 1}
        for x in A:
            prefix += x
            ans += seen.get(prefix - S, 0)
            seen[prefix] = 1 + seen.get(prefix, 0)
        return ans


    """931. Minimum Falling Path Sum (Medium)
    Given a square array of integers A, we want the minimum sum of a falling
    path through A. A falling path starts at any element in the first row, and
    chooses one element from each row.  The next row's choice must be in a
    column that is different from the previous row's column by at most one.

    Example 1:
    Input: [[1,2,3],[4,5,6],[7,8,9]]
    Output: 12
    Explanation:
    The possible falling paths are:
    [1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]
    [2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]
    [3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]
    The falling path with the smallest sum is [1,4,7], so the answer is 12.

    Constraints:
    * 1 <= A.length == A[0].length <= 100
    * -100 <= A[i][j] <= 100"""

    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        for i in range(1, len(matrix)):
            for j in range(len(matrix)):
                matrix[i][j] += min(matrix[i-1][max(0, j-1):j+2])
        return min(matrix[-1])


    """932. Beautiful Array (Medium)
    For some fixed N, an array A is beautiful if it is a permutation of the
    integers 1, 2, ..., N, such that for every i < j, there is no k with
    i < k < j such that A[k] * 2 = A[i] + A[j]. Given N, return any beautiful
    array A.  (It is guaranteed that one exists.)

    Example 1:
    Input: 4
    Output: [2,1,4,3]

    Example 2:
    Input: 5
    Output: [3,1,2,5,4]

    Note: 1 <= N <= 1000"""

    def beautifulArray(self, N: int) -> List[int]:

        def fn(nums):
            """Return beautiful array by rearraning elements in nums."""
            if len(nums) == 1: return nums
            return fn(nums[::2]) + fn(nums[1::2])

        return fn(list(range(1, N+1)))


    """934. Shortest Bridge (Medium)
    In a given 2D binary array A, there are two islands.  (An island is a 4-
    directionally connected group of 1s not connected to any other 1s.) Now, we
    may change 0s to 1s so as to connect the two islands together to form 1
    island. Return the smallest number of 0s that must be flipped.  (It is
    guaranteed that the answer is at least 1.)

    Example 1:
    Input: A = [[0,1],[1,0]]
    Output: 1

    Example 2:
    Input: A = [[0,1,0],[0,0,0],[0,0,1]]
    Output: 2

    Example 3:
    Input: A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
    Output: 1

    Constraints:
    * 2 <= A.length == A[0].length <= 100
    * A[i][j] == 0 or A[i][j] == 1"""

    def shortestBridge(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        i, j = next((i, j) for i in range(m) for j in range(n) if A[i][j])

        # dfs
        stack = [(i, j)]
        seen = set(stack)
        while stack:
            i, j = stack.pop()
            seen.add((i, j)) # mark as visited
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and A[ii][jj] and (ii, jj) not in seen:
                    stack.append((ii, jj))
                    seen.add((ii, jj))

        # bfs
        ans = 0
        queue = list(seen)
        while queue:
            newq = []
            for i, j in queue:
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen:
                        if A[ii][jj] == 1: return ans
                        newq.append((ii, jj))
                        seen.add((ii, jj))
            queue = newq
            ans += 1


    """935. Knight Dialer (Medium)
    The chess knight has a unique movement, it may move two squares vertically
    and one square horizontally, or two squares horizontally and one square
    vertically (with both forming the shape of an L). We have a chess knight
    and a phone pad as shown below, the knight can only stand on a numeric cell
    (i.e. blue cell). Given an integer n, return how many distinct phone numbers
    of length n we can dial. You are allowed to place the knight on any numeric
    cell initially and then you should perform n - 1 jumps to dial a number of
    length n. All jumps should be valid knight jumps. As the answer may be very
    large, return the answer modulo 10^9 + 7.

    Example 1:
    Input: n = 1
    Output: 10
    Explanation: We need to dial a number of length 1, so placing the knight
                 over any numeric cell of the 10 cells is sufficient.

    Example 2:
    Input: n = 2
    Output: 20
    Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29,
                 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]

    Example 3:
    Input: n = 3
    Output: 46

    Example 4:
    Input: n = 4
    Output: 104

    Example 5:
    Input: n = 3131
    Output: 136006598
    Explanation: Please take care of the mod.

    Constraints: 1 <= n <= 5000"""

    def knightDialer(self, n: int) -> int:
        mp = {0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9],
              5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]}
        ans = [1]*10
        for _ in range(n-1):
            temp = [0]*10
            for i in range(10):
                for ii in mp[i]: temp[i] += ans[ii]
                temp[i] %= 1_000_000_007
            ans = temp
        return sum(ans) % 1_000_000_007


    """939. Minimum Area Rectangle (Medium)
    Given a set of points in the xy-plane, determine the minimum area of a
    rectangle formed from these points, with sides parallel to the x and y axes.
    If there isn't any rectangle, return 0.

    Example 1:
    Input: [[1,1],[1,3],[3,1],[3,3],[2,2]]
    Output: 4

    Example 2:
    Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]
    Output: 2

    Note:
    * 1 <= points.length <= 500
    * 0 <= points[i][0] <= 40000
    * 0 <= points[i][1] <= 40000
    * All points are distinct."""

    def minAreaRect(self, points: List[List[int]]) -> int:
        ans = inf
        seen = {(x, y) for x, y in points}
        for x, y in points:
            for xx, yy in points:
                if x != xx and y != yy and (x, yy) in seen and (xx, y) in seen:
                    ans = min(ans, abs((xx-x)*(yy-y)))
        return ans if ans < inf else 0


    """940. Distinct Subsequences II (Hard)
    Given a string s, return the number of distinct non-empty subsequences of s.
    Since the answer may be very large, return it modulo 10^9 + 7. A
    subsequence of a string is a new string that is formed from the original
    string by deleting some (can be none) of the characters without disturbing
    the relative positions of the remaining characters. (i.e., "ace" is a
    subsequence of "abcde" while "aec" is not.

    Example 1:
    Input: s = "abc"
    Output: 7
    Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac",
                 "bc", and "abc".

    Example 2:
    Input: s = "aba"
    Output: 6
    Explanation: The 6 distinct subsequences are "a", "b", "ab", "aa", "ba",
                 and "aba".

    Example 3:
    Input: s = "aaa"
    Output: 3
    Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".

    Constraints:
    * 1 <= s.length <= 2000
    * s consists of lowercase English letters."""

    def distinctSubseqII(self, s: str) -> int:
        freq = [0]*26
        for i in reversed(range(len(s))): freq[ord(s[i])-97] = (1 + sum(freq)) % 1_000_000_007
        return sum(freq) % 1_000_000_007


    """941. Valid Mountain Array (Easy)
    Given an array of integers arr, return true if and only if it is a valid
    mountain array. Recall that arr is a mountain array if and only if:
    * arr.length >= 3
    * There exists some i with 0 < i < arr.length - 1 such that:
      + arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
      + arr[i] > arr[i + 1] > ... > arr[arr.length - 1]

    Example 1:
    Input: arr = [2,1]
    Output: false

    Example 2:
    Input: arr = [3,5,5]
    Output: false

    Example 3:
    Input: arr = [0,3,2,1]
    Output: true

    Constraints:
    * 1 <= arr.length <= 10^4
    * 0 <= arr[i] <= 10^4"""

    def validMountainArray(self, arr: List[int]) -> bool:
        lo, hi = 0, len(arr)-1
        while lo < hi and arr[lo] < arr[lo+1]: lo += 1
        while lo < hi and arr[hi-1] > arr[hi]: hi -= 1
        return 0 < lo == hi < len(arr)-1


    """943. Find the Shortest Superstring (Hard)
    Given an array of strings words, return the smallest string that contains
    each string in words as a substring. If there are multiple valid strings of
    the smallest length, return any of them. You may assume that no string in
    words is a substring of another string in words.

    Example 1:
    Input: words = ["alex","loves","leetcode"]
    Output: "alexlovesleetcode"
    Explanation: All permutations of "alex","loves","leetcode" would also be
                 accepted.

    Example 2:
    Input: words = ["catg","ctaagt","gcta","ttca","atgcatc"]
    Output: "gctaagttcatgcatc"

    Constraints:
    * 1 <= words.length <= 12
    * 1 <= words[i].length <= 20
    * words[i] consists of lowercase English letters.
    * All the strings of words are unique."""

    def shortestSuperstring(self, words: List[str]) -> str:
        """Travelling sales person (TSP) O(n^2*2^n)"""
        n = len(words)
        graph = [[0]*n for _ in range(n)] # graph as adjacency matrix

        for i in range(n):
            for j in range(n):
                if i != j:
                    for k in range(len(words[j])):
                        if words[i].endswith(words[j][:k]):
                            graph[i][j] = len(words[j]) - k

        @cache
        def fn(prev, mask):
            """Return length of shortest superstring & current choice of word."""
            if mask == 0: return 0, None
            vv, kk = inf, None
            for k in range(n):
                if mask & 1<<k:
                    v, _ = fn(k, mask ^ 1<<k)
                    offset = len(words[k]) if prev == -1 else graph[prev][k]
                    if v + offset < vv: vv, kk = v + offset, k
            return vv, kk

        ans = []
        prev = -1
        mask = (1<<n) - 1
        while mask:
            _, k = fn(prev, mask)
            if ans: ans.append(words[k][-graph[prev][k]:])
            else: ans.append(words[k])
            prev = k
            mask ^= 1<<k
        return "".join(ans)


    """945. Minimum Increment to Make Array Unique (Medium)
    Given an array of integers A, a move consists of choosing any A[i], and
    incrementing it by 1. Return the least number of moves to make every value
    in A unique.

    Example 1:
    Input: [1,2,2]
    Output: 1
    Explanation: After 1 move, the array could be [1, 2, 3].

    Example 2:
    Input: [3,2,1,2,1,7]
    Output: 6
    Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. It can
                 be shown with 5 or less moves that it is impossible for the
                 array to have all unique values.

    Note:
    * 0 <= A.length <= 40000
    * 0 <= A[i] < 40000"""

    def minIncrementForUnique(self, A: List[int]) -> int:
        ans = cap = 0
        for x in sorted(A):
            ans += max(0, cap - x)
            cap = max(cap, x) + 1
        return ans


    """946. Validate Stack Sequences (Medium)
    Given two sequences pushed and popped with distinct values, return true if
    and only if this could have been the result of a sequence of push and pop
    operations on an initially empty stack.

    Example 1:
    Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
    Output: true
    Explanation: We might do the following sequence:
    push(1), push(2), push(3), push(4), pop() -> 4,
    push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

    Example 2:
    Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
    Output: false
    Explanation: 1 cannot be popped before 2.

    Constraints:
    * 0 <= pushed.length == popped.length <= 1000
    * 0 <= pushed[i], popped[i] < 1000
    * pushed is a permutation of popped.
    * pushed and popped have distinct values."""

    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        i = 0
        stack = []
        for x in pushed:
            stack.append(x)
            while stack and stack[-1] == popped[i]:
                stack.pop()
                i += 1
        return not stack


    """947. Most Stones Removed with Same Row or Column (Medium)
    On a 2D plane, we place n stones at some integer coordinate points. Each
    coordinate point may have at most one stone. A stone can be removed if it
    shares either the same row or the same column as another stone that has not
    been removed. Given an array stones of length n where stones[i] = [xi, yi]
    represents the location of the ith stone, return the largest possible number
    of stones that can be removed.

    Example 1:
    Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
    Output: 5
    Explanation: One way to remove 5 stones is as follows:
                 1. Remove stone [2,2] because it shares the same row as [2,1].
                 2. Remove stone [2,1] because it shares the same column as
                    [0,1].
                 3. Remove stone [1,2] because it shares the same row as [1,0].
                 4. Remove stone [1,0] because it shares the same column as
                    [0,0].
                 5. Remove stone [0,1] because it shares the same row as [0,0].
                 Stone [0,0] cannot be removed since it does not share a
                 row/column with another stone still on the plane.

    Example 2:
    Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
    Output: 3
    Explanation: One way to make 3 moves is as follows:
                 1. Remove stone [2,2] because it shares the same row as [2,0].
                 2. Remove stone [2,0] because it shares the same column as
                    [0,0].
                 3. Remove stone [0,2] because it shares the same row as [0,0].
                 Stones [0,0] and [1,1] cannot be removed since they do not
                 share a row/column with another stone still on the plane.

    Example 3:
    Input: stones = [[0,0]]
    Output: 0
    Explanation: [0,0] is the only stone on the plane, so you cannot remove it.

    Constraints:
    * 1 <= stones.length <= 1000
    * 0 <= xi, yi <= 10^4
    * No two stones are at the same coordinate point."""

    def removeStones(self, stones: List[List[int]]) -> int:
        parent = {}

        def find(p):
            if p not in parent: parent[p] = p
            if p != parent[p]:
                parent[p] = find(parent[p])
            return parent[p]

        for x, y in stones:
            parent[find(x)] = find(~y)
        group = {find(x) for x, _ in stones}
        return len(stones) - len(group)


    """948. Bag of Tokens (Medium)
    You have an initial power of P, an initial score of 0, and a bag of tokens
    where tokens[i] is the value of the ith token (0-indexed). Your goal is to
    maximize your total score by potentially playing each token in one of two
    ways:
    * If your current power is at least tokens[i], you may play the ith token
      face up, losing tokens[i] power and gaining 1 score.
    * If your current score is at least 1, you may play the ith token face down,
      gaining tokens[i] power and losing 1 score.
    Each token may be played at most once and in any order. You do not have to
    play all the tokens. Return the largest possible score you can achieve
    after playing any number of tokens.

    Example 1:
    Input: tokens = [100], P = 50
    Output: 0
    Explanation: Playing the only token in the bag is impossible because you
                 either have too little power or too little score.

    Example 2:
    Input: tokens = [100,200], P = 150
    Output: 1
    Explanation: Play the 0th token (100) face up, your power becomes 50 and
                 score becomes 1. There is no need to play the 1st token since
                 you cannot play it face up to add to your score.

    Example 3:
    Input: tokens = [100,200,300,400], P = 200
    Output: 2
    Explanation: Play the tokens in this order to get a score of 2:
    1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1.
    2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0.
    3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1.
    4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2.

    Constraints:
    * 0 <= tokens.length <= 1000
    * 0 <= tokens[i], P < 10^4"""

    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
        tokens.sort()
        ans = 0
        lo, hi = 0, len(tokens)-1
        while lo <= hi:
            if tokens[lo] <= power:
                ans += 1
                power -= tokens[lo]
                lo += 1
            elif ans and lo < hi:
                ans -= 1
                power += tokens[hi]
                hi -= 1
            else: break
        return ans


    """949. Largest Time for Given Digits (Medium)
    Given an array arr of 4 digits, find the latest 24-hour time that can be
    made using each digit exactly once. 24-hour times are formatted as "HH:MM",
    where HH is between 00 and 23, and MM is between 00 and 59. The earliest
    24-hour time is 00:00, and the latest is 23:59. Return the latest 24-hour
    time in "HH:MM" format. If no valid time can be made, return an empty string.

    Example 1:
    Input: A = [1,2,3,4]
    Output: "23:41"
    Explanation: The valid 24-hour times are "12:34", "12:43", "13:24", "13:42",
                 "14:23", "14:32", "21:34", "21:43", "23:14", and "23:41". Of
                 these times, "23:41" is the latest.

    Example 2:
    Input: A = [5,5,5,5]
    Output: ""
    Explanation: There are no valid 24-hour times as "55:55" is not valid.

    Example 3:
    Input: A = [0,0,0,0]
    Output: "00:00"

    Example 4:
    Input: A = [0,0,1,0]
    Output: "10:00"

    Constraints:
    * arr.length == 4
    * 0 <= arr[i] <= 9"""

    def largestTimeFromDigits(self, arr: List[int]) -> str:
        hh = mm = -1
        for x in permutations(arr):
            h = 10*x[0] + x[1]
            m = 10*x[2] + x[3]
            if h < 24 and m < 60 and 60*hh + mm < 60*h + m: hh, mm = h, m
        return f"{hh:02}:{mm:02}" if hh > -1 else ""


    """950. Reveal Cards In Increasing Order (Medium)
    You are given an integer array deck. There is a deck of cards where every
    card has a unique integer. The integer on the ith card is deck[i]. You can
    order the deck in any order you want. Initially, all the cards start face
    down (unrevealed) in one deck. You will do the following steps repeatedly
    until all cards are revealed:
    * Take the top card of the deck, reveal it, and take it out of the deck.
    * If there are still cards in the deck then put the next top card of the
      deck at the bottom of the deck.
    * If there are still unrevealed cards, go back to step 1. Otherwise, stop.
    Return an ordering of the deck that would reveal the cards in increasing
    order. Note that the first entry in the answer is considered to be the top
    of the deck.

    Example 1:
    Input: deck = [17,13,11,2,3,5,7]
    Output: [2,13,3,11,5,17,7]
    Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order
                 does not matter), and reorder it.
                 After reordering, the deck starts as [2,13,3,11,5,17,7], where
                 2 is the top of the deck.
                 - We reveal 2, and move 13 to the bottom.  The deck is now
                   [3,11,5,17,7,13].
                 - We reveal 3, and move 11 to the bottom.  The deck is now
                   [5,17,7,13,11].
                 - We reveal 5, and move 17 to the bottom.  The deck is now
                   [7,13,11,17].
                 - We reveal 7, and move 13 to the bottom.  The deck is now
                   [11,17,13].
                 - We reveal 11, and move 17 to the bottom.  The deck is now
                   [13,17].
                 - We reveal 13, and move 17 to the bottom.  The deck is now
                   [17].
                 - We reveal 17.
                 Since all the cards revealed are in increasing order, the
                 answer is correct.

    Example 2:
    Input: deck = [1,1000]
    Output: [1,1000]

    Constraints:
    * 1 <= deck.length <= 1000
    * 1 <= deck[i] <= 10^6
    * All the values of deck are unique."""

    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
        ans = deque()
        for x in sorted(deck, reverse=True):
            ans.rotate()
            ans.appendleft(x)
        return ans


    """951. Flip Equivalent Binary Trees (Medium)
    For a binary tree T, we can define a flip operation as follows: choose any
    node, and swap the left and right child subtrees. A binary tree X is flip
    equivalent to a binary tree Y if and only if we can make X equal to Y after
    some number of flip operations. Given the roots of two binary trees root1
    and root2, return true if the two trees are flip equivelent or false
    otherwise.

    Example 1:
    Flipped Trees Diagram
    Input: root1 = [1,2,3,4,5,6,null,null,null,7,8],
           root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
    Output: true
    Explanation: We flipped at nodes with values 1, 3, and 5.

    Example 2:
    Input: root1 = [], root2 = []
    Output: true

    Example 3:
    Input: root1 = [], root2 = [1]
    Output: false

    Example 4:
    Input: root1 = [0,null,1], root2 = []
    Output: false

    Example 5:
    Input: root1 = [0,null,1], root2 = [0,1]
    Output: true

    Constraints:
    * The number of nodes in each tree is in the range [0, 100].
    * Each tree will have unique node values in the range [0, 99]."""

    def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:

        def fn(n1, n2):
            """Return True if n1 is a flip of n2."""
            if not n1 or not n2: return n1 is n2
            return n1.val == n2.val and (fn(n1.left, n2.right) and fn(n1.right, n2.left) or fn(n1.left, n2.left) and fn(n1.right, n2.right))

        return fn(root1, root2)


    """952. Largest Component Size by Common Factor (Hard)
    You are given an integer array of unique positive integers nums. Consider
    the following graph:
    * There are nums.length nodes, labeled nums[0] to nums[nums.length - 1],
    * There is an undirected edge between nums[i] and nums[j] if nums[i] and
      nums[j] share a common factor greater than 1.
    Return the size of the largest connected component in the graph.

    Example 1:
    Input: nums = [4,6,15,35]
    Output: 4

    Example 2:
    Input: nums = [20,50,9,63]
    Output: 2

    Example 3:
    Input: nums = [2,3,6,7,4,12,21,39]
    Output: 8

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= nums[i] <= 10^5
    * All the values of nums are unique."""

    def largestComponentSize(self, A: List[int]) -> int:
        m = max(A)
        uf = UnionFind(m+1)
        seen = set(A)
        # modified sieve of eratosthenes
        sieve = [1]*(m+1)
        sieve[0] = sieve[1] = 0
        for k in range(m//2+1):
            if sieve[k]:
                prev = k if k in seen else 0
                for x in range(2*k, m+1, k):
                    sieve[x] = 0
                    if x in seen:
                        if prev: uf.union(prev, x)
                        else: prev = x
        return max(uf.rank)


    """953. Verifying an Alien Dictionary (Easy)
    In an alien language, surprisingly, they also use English lowercase letters,
    but possibly in a different order. The order of the alphabet is some
    permutation of lowercase letters. Given a sequence of words written in the
    alien language, and the order of the alphabet, return true if and only if
    the given words are sorted lexicographically in this alien language.

    Example 1:
    Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
    Output: true
    Explanation: As 'h' comes before 'l' in this language, then the sequence is
                 sorted.

    Example 2:
    Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
    Output: false
    Explanation: As 'd' comes after 'l' in this language, then
                 words[0] > words[1], hence the sequence is unsorted.

    Example 3:
    Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
    Output: false
    Explanation: The first three characters "app" match, and the second string
                 is shorter (in size.) According to lexicographical rules
                 "apple" > "app", because 'l' > '∅', where '∅' is defined as
                 the blank character which is less than any other character
                 (More info).

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 20
    * order.length == 26
    * All characters in words[i] and order are English lowercase letters."""

    def isAlienSorted(self, words: List[str], order: str) -> bool:
        mp = dict(zip(order, ascii_lowercase))
        prev = ""
        for word in words:
            word = "".join(mp[c] for c in word)
            if prev > word: return False
            prev = word
        return True


    """954. Array of Doubled Pairs (Medium)
    Given an array of integers arr of even length, return true if and only if
    it is possible to reorder it such that arr[2 * i + 1] = 2 * arr[2 * i] for
    every 0 <= i < len(arr) / 2.

    Example 1:
    Input: arr = [3,1,3,6]
    Output: false

    Example 2:
    Input: arr = [2,1,2,6]
    Output: false

    Example 3:
    Input: arr = [4,-2,2,-4]
    Output: true
    Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4]
                 or [2,4,-2,-4].

    Example 4:
    Input: arr = [1,2,4,16,8,4]
    Output: false

    Constraints:
    * 0 <= arr.length <= 3 * 10^4
    * arr.length is even.
    * -10^5 <= arr[i] <= 10^5"""

    def canReorderDoubled(self, arr: List[int]) -> bool:
        freq = Counter(arr)
        for x in sorted(freq, key=abs):
            if freq[2*x] < freq[x]: return False
            freq[2*x] -= freq[x]
        return True


    """955. Delete Columns to Make Sorted II (Medium)
    You are given an array of n strings strs, all of the same length. We may
    choose any deletion indices, and we delete all the characters in those
    indices for each string. For example, if we have strs = ["abcdef","uvwxyz"]
    and deletion indices {0, 2, 3}, then the final array after deletions is
    ["bef", "vyz"]. Suppose we chose a set of deletion indices answer such that
    after deletions, the final array has its elements in lexicographic order
    (i.e., strs[0] <= strs[1] <= strs[2] <= ... <= strs[n - 1]). Return the
    minimum possible value of answer.length.

    Example 1:
    Input: strs = ["ca","bb","ac"]
    Output: 1
    Explanation: After deleting the first column, strs = ["a", "b", "c"]. Now
                 strs is in lexicographic order (ie. strs[0] <= strs[1] <= strs[2]).
                 We require at least 1 deletion since initially strs was not in
                 lexicographic order, so the answer is 1.

    Example 2:
    Input: strs = ["xc","yb","za"]
    Output: 0
    Explanation: strs is already in lexicographic order, so we do not need to
                 delete anything. Note that the rows of strs are not
                 necessarily in lexicographic order: i.e., it is NOT
                 necessarily true that (strs[0][0] <= strs[0][1] <= ...)

    Example 3:
    Input: strs = ["zyx","wvu","tsr"]
    Output: 3
    Explanation: We have to delete every column.

    Constraints:
    * n == strs.length
    * 1 <= n <= 100
    * 1 <= strs[i].length <= 100
    * strs[i] consists of lowercase English letters."""

    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0]) # dimensions
        ans, grp = 0, [0]*m
        for j in range(n):
            for i in range(1, m):
                if grp[i-1] == grp[i] and strs[i-1][j] > strs[i][j]:
                    ans += 1
                    break
            else:
                for i in range(1, m):
                    grp[i] = max(grp[i-1], grp[i])
                    if grp[i-1] == grp[i] and strs[i-1][j] < strs[i][j]: grp[i] = i
        return ans


    """956. Tallest Billboard (Hard)
    You are installing a billboard and want it to have the largest height. The
    billboard will have two steel supports, one on each side. Each steel
    support must be an equal height. You are given a collection of rods that
    can be welded together. For example, if you have rods of lengths 1, 2, and
    3, you can weld them together to make a support of length 6. Return the
    largest possible height of your billboard installation. If you cannot
    support the billboard, return 0.

    Example 1:
    Input: rods = [1,2,3,6]
    Output: 6
    Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the
                 same sum = 6.

    Example 2:
    Input: rods = [1,2,3,4,5,6]
    Output: 10
    Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the
                 same sum = 10.

    Example 3:
    Input: rods = [1,2]
    Output: 0
    Explanation: The billboard cannot be supported, so we return 0.

    Constraints:
    * 1 <= rods.length <= 20
    * 1 <= rods[i] <= 1000
    * sum(rods[i]) <= 5000"""

    def tallestBillboard(self, rods: List[int]) -> int:
        dp = {0: 0}
        for x in rods:
            for k, v in dp.copy().items():
                dp[k+x] = max(dp.get(k+x, 0), v)
                if k >= x: dp[k-x] = max(dp.get(k-x, 0), v+x)
                else: dp[x-k] = max(dp.get(x-k, 0), v+k)
        return dp[0]


    """964. Least Operators to Express Number (Hard)
    Given a single positive integer x, we will write an expression of the form
    x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either
    addition, subtraction, multiplication, or division (+, -, *, or /). For
    example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3.
    When writing such an expression, we adhere to the following conventions:
    * The division operator (/) returns rational numbers.
    * There are no parentheses placed anywhere.
    * We use the usual order of operations: multiplication and division happen
      before addition and subtraction.
    * It is not allowed to use the unary negation operator (-). For example,
      "x - x" is a valid expression as it only uses subtraction, but "-x + x"
      is not because it uses negation.
    We would like to write an expression with the least number of operators
    such that the expression equals the given target. Return the least number
    of operators used.

    Example 1:
    Input: x = 3, target = 19
    Output: 5
    Explanation: 3 * 3 + 3 * 3 + 3 / 3. The expression contains 5 operations.

    Example 2:
    Input: x = 5, target = 501
    Output: 8
    Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5. The expression contains 8
                 operations.

    Example 3:
    Input: x = 100, target = 100000000
    Output: 3
    Explanation: 100 * 100 * 100 * 100. The expression contains 3 operations.

    Constraints:
    * 2 <= x <= 100
    * 1 <= target <= 2 * 10^8"""

    def leastOpsExpressTarget(self, x: int, target: int) -> int:

        @cache
        def fn(val):
            """Return min ops to express val."""
            if val < x: return min(2*val-1, 2*(x-val))
            k = int(log(val)//log(x))
            ans = k + fn(val - x**k)
            if x**(k+1) < 2*val:
                ans = min(ans, k + 1 + fn(x**(k+1) - val))
            return ans

        return fn(target)


    """968. Binary Tree Cameras (Hard)
    Given a binary tree, we install cameras on the nodes of the tree. Each
    camera at a node can monitor its parent, itself, and its immediate children.
    Calculate the minimum number of cameras needed to monitor all nodes of the
    tree.

    Example 1:
    Input: [0,0,null,0,0]
    Output: 1
    Explanation: One camera is enough to monitor all nodes if placed as shown.

    Example 2:
    Input: [0,0,null,0,null,0,null,null,0]
    Output: 2
    Explanation: At least two cameras are needed to monitor all nodes of the
                 tree. The above image shows one of the valid configurations of
                 camera placement.

    Note:
    * The number of nodes in the given tree will be in the range [1, 1000].
    * Every node has value 0."""

    def minCameraCover(self, root: TreeNode) -> int:

        def fn(node):
            """Return color-coding of a node.
            0 - not covered
            1 - covered w/o camera
            2 - covered w/ camera
            """
            nonlocal ans
            if not node: return 1
            left, right = fn(node.left), fn(node.right)
            if left == 0 or right == 0:
                ans += 1
                return 2 # add a camera
            if left == 2 or right == 2: return 1
            return 0

        ans = 0
        return int(fn(root) == 0) + ans


    """970. Powerful Integers (Medium)
    Given three integers x, y, and bound, return a list of all the powerful
    integers that have a value less than or equal to bound. An integer is
    powerful if it can be represented as xi + yj for some integers i >= 0 and
    j >= 0. You may return the answer in any order. In your answer, each value
    should occur at most once.

    Example 1:
    Input: x = 2, y = 3, bound = 10
    Output: [2,3,4,5,7,9,10]
    Explanation: 2 = 20 + 30
                 3 = 21 + 30
                 4 = 20 + 31
                 5 = 21 + 31
                 7 = 22 + 31
                 9 = 23 + 30
                 10 = 20 + 32

    Example 2:
    Input: x = 3, y = 5, bound = 15
    Output: [2,4,6,8,10,14]

    Constraints:
    * 1 <= x, y <= 100
    * 0 <= bound <= 10^6"""

    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        bx = int(log(bound)/log(x)) if x > 1 else 0
        by = int(log(bound)/log(y)) if y > 1 else 0

        ans = set()
        for i in range(bx+1):
            for j in range(by+1):
                if x**i + y**j <= bound:
                    ans.add(x**i + y**j)
        return ans


    """971. Flip Binary Tree To Match Preorder Traversal (Medium)
    You are given the root of a binary tree with n nodes, where each node is
    uniquely assigned a value from 1 to n. You are also given a sequence of n
    values voyage, which is the desired pre-order traversal of the binary tree.
    Any node in the binary tree can be flipped by swapping its left and right
    subtrees. Flip the smallest number of nodes so that the pre-order traversal
    of the tree matches voyage. Return a list of the values of all flipped
    nodes. You may return the answer in any order. If it is impossible to flip
    the nodes in the tree to make the pre-order traversal match voyage, return
    the list [-1].

    Example 1:
    Input: root = [1,2], voyage = [2,1]
    Output: [-1]
    Explanation: It is impossible to flip the nodes such that the pre-order
                 traversal matches voyage.

    Example 2:
    Input: root = [1,2,3], voyage = [1,3,2]
    Output: [1]
    Explanation: Flipping node 1 swaps nodes 2 and 3, so the pre-order
                 traversal matches voyage.

    Example 3:
    Input: root = [1,2,3], voyage = [1,2,3]
    Output: []
    Explanation: The tree's pre-order traversal already matches voyage, so no
                 nodes need to be flipped.

    Constraints:
    * The number of nodes in the tree is n.
    * n == voyage.length
    * 1 <= n <= 100
    * 1 <= Node.val, voyage[i] <= n
    * All the values in the tree are unique.
    * All the values in voyage are unique."""

    def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:
        ans = []
        stack = [root]
        i = 0
        while stack:
            node = stack.pop()
            if node:
                if node.val != voyage[i]: return [-1]
                i += 1
                if node.left and node.right and voyage[i] == node.right.val:
                    ans.append(node.val)
                    node.left, node.right = node.right, node.left
                stack.extend([node.right, node.left])
        return ans


    """972. Equal Rational Numbers (Hard)
    Given two strings s and t, each of which represents a non-negative rational
    number, return true if and only if they represent the same number. The
    strings may use parentheses to denote the repeating part of the rational
    number. A rational number can be represented using up to three parts:
    <IntegerPart>, <NonRepeatingPart>, and a <RepeatingPart>. The number will
    be represented in one of the following three ways:
    * <IntegerPart>
      * For example, 12, 0, and 123.
    * <IntegerPart><.><NonRepeatingPart>
      * For example, 0.5, 1., 2.12, and 123.0001.
    * <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>
      * For example, 0.1(6), 1.(9), 123.00(1212).
    The repeating portion of a decimal expansion is conventionally denoted
    within a pair of round brackets. For example:
    * 1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66).

    Example 1:
    Input: s = "0.(52)", t = "0.5(25)"
    Output: true
    Explanation: Because "0.(52)" represents 0.52525252..., and "0.5(25)"
                 represents 0.52525252525..... , the strings represent the same
                 number.

    Example 2:
    Input: s = "0.1666(6)", t = "0.166(66)"
    Output: true

    Example 3:
    Input: s = "0.9(9)", t = "1."
    Output: true
    Explanation: "0.9(9)" represents 0.999999999... repeated forever, which
                 equals 1.  [See this link for an explanation.] "1." represents
                 the number 1, which is formed correctly: (IntegerPart) = "1"
                 and (NonRepeatingPart) = "".

    Constraints:
    * Each part consists only of digits.
    * The <IntegerPart> does not have leading zeros (except for the zero
      itself).
    * 1 <= <IntegerPart>.length <= 4
    * 0 <= <NonRepeatingPart>.length <= 4
    * 1 <= <RepeatingPart>.length <= 4"""

    def isRationalEqual(self, s: str, t: str) -> bool:

        def fn(s):
            """Return normalized string."""
            if "." not in s: return s # edge case - xxx
            xxx, frac = s.split('.')
            if not frac: return xxx # edge case - xxx.
            if '(' in frac:
                nonrep, rep = frac.split('(')
                rep = rep.rstrip(')')
                while nonrep and rep and nonrep[-1] == rep[-1]: # normalize repeating part
                    nonrep = nonrep[:-1]
                    rep = rep[-1] + rep[:-1]

                if len(rep) > 1 and len(set(rep)) == 1: rep = rep[0] # edge case (11)
                if rep[:2] == rep[2:]: rep = rep[:2] # edge case (1212)

                if rep == "0": rep = "" # edge case - (0)
                if rep == "9": # edge case - (9)
                    rep = ""
                    if nonrep: nonrep = nonrep[:-1] + str(int(nonrep[-1]) + 1)
                    else: xxx = str(int(xxx) + 1)
                frac = ""
                if rep: frac = f"({rep})"
                if nonrep: frac = nonrep + frac
            if '(' not in frac: # remove trailing 0's
                while frac and frac[-1] == '0': frac = frac[:-1]
            return xxx + "." + frac if frac else xxx

        return fn(s) == fn(t)


    """973. K Closest Points to Origin (Medium)
    Given an array of points where points[i] = [xi, yi] represents a point on
    the X-Y plane and an integer k, return the k closest points to the origin
    (0, 0). The distance between two points on the X-Y plane is the Euclidean
    distance (i.e., √(x1 - x2)^2 + (y1 - y2)^2). You may return the answer in
    any order. The answer is guaranteed to be unique (except for the order that
    it is in).

    Example 1:
    Input: points = [[1,3],[-2,2]], k = 1
    Output: [[-2,2]]
    Explanation: The distance between (1, 3) and the origin is sqrt(10). The
                 distance between (-2, 2) and the origin is sqrt(8). Since
                 sqrt(8) < sqrt(10), (-2, 2) is closer to the origin. We only
                 want the closest k = 1 points from the origin, so the answer
                 is just [[-2,2]].

    Example 2:
    Input: points = [[3,3],[5,-1],[-2,4]], k = 2
    Output: [[3,3],[-2,4]]
    Explanation: The answer [[-2,4],[3,3]] would also be accepted.

    Constraints:
    * 1 <= k <= points.length <= 10^4
    * -10^4 < xi, yi < 10^4"""

    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:

        def part(lo, hi):
            """Return partition of dist[lo:hi]."""
            i, j = lo+1, hi-1
            while i <= j:
                if dist[i] < dist[lo]: i += 1
                elif dist[j] > dist[lo]: j -= 1
                else:
                    dist[i], dist[j] = dist[j], dist[i]
                    i += 1
                    j -= 1
            dist[lo], dist[j] = dist[j], dist[lo]
            return j

        dist = [x*x+y*y for x, y in points]
        shuffle(dist)
        lo, hi = 0, len(dist)
        while lo < hi:
            mid = part(lo, hi)
            if mid + 1 < k: lo = mid + 1
            elif mid + 1 == k: break
            else: hi = mid
        return [[x, y] for x, y in points if x*x + y*y <= dist[mid]]


    """974. Subarray Sums Divisible by K (Medium)
    Given an integer array nums and an integer k, return the number of non-
    empty subarrays that have a sum divisible by k. A subarray is a contiguous
    part of an array.

    Example 1:
    Input: nums = [4,5,0,-2,-3,1], k = 5
    Output: 7
    Explanation: There are 7 subarrays with a sum divisible by k = 5:
                 [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0],
                 [0, -2, -3], [-2, -3]

    Example 2:
    Input: nums = [5], k = 9
    Output: 0

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * -10^4 <= nums[i] <= 10^4
    * 2 <= k <= 10^4"""

    def subarraysDivByK(self, nums: List[int], k: int) -> int:
        ans = prefix = 0
        freq = Counter({0: 1})
        for x in nums:
            prefix = (prefix + x) % k
            ans += freq[prefix]
            freq[prefix] += 1
        return ans


    """975. Odd Even Jump (Hard)
    You are given an integer array arr. From some starting index, you can make
    a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called
    odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are
    called even-numbered jumps. Note that the jumps are numbered, not the
    indices. You may jump forward from index i to index j (with i < j) in the
    following way:
    * During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the
      index j such that arr[i] <= arr[j] and arr[j] is the smallest possible
      value. If there are multiple such indices j, you can only jump to the
      smallest such index j.
    * During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the
      index j such that arr[i] >= arr[j] and arr[j] is the largest possible
      value. If there are multiple such indices j, you can only jump to the
      smallest such index j.
    * It may be the case that for some index i, there are no legal jumps.
    A starting index is good if, starting from that index, you can reach the
    end of the array (index arr.length - 1) by jumping some number of times
    (possibly 0 or more than once). Return the number of good starting indices.

    Example 1:
    Input: arr = [10,13,12,14,15]
    Output: 2
    Explanation: From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.
                 From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.
                 From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.
                 From starting index i = 4, we have reached the end already.
                 In total, there are 2 different starting indices i = 3 and
                 i = 4, where we can reach the end with some number of jumps.

    Example 2:
    Input: arr = [2,3,1,1,4]
    Output: 3
    Explanation: From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:
                 During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].
                 During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3
                 During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].
                 We can't jump from i = 3 to i = 4, so the starting index i = 0
                 is not good. In a similar manner, we can deduce that:
                 From starting index i = 1, we jump to i = 4, so we reach the end.
                 From starting index i = 2, we jump to i = 3, and then we can't jump anymore.
                 From starting index i = 3, we jump to i = 4, so we reach the end.
                 From starting index i = 4, we are already at the end.
                 In total, there are 3 different starting indices i = 1, i = 3,
                 and i = 4, where we can reach the end with some number of jumps.

    Example 3:
    Input: arr = [5,1,3,4,2]
    Output: 3
    Explanation: We can reach the end from starting indices 1, 2, and 4.

    Constraints:
    * 1 <= arr.length <= 2 * 10^4
    * 0 <= arr[i] < 10^5"""

    def oddEvenJumps(self, arr: List[int]) -> int:
        large = [-1] * len(arr)
        small = [-1] * len(arr)

        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (x[1], x[0])):
            while stack and stack[-1] < i: large[stack.pop()] = i
            stack.append(i)

        stack = []
        for i, x in sorted(enumerate(arr), key=lambda x: (-x[1], x[0])):
            while stack and stack[-1] < i: small[stack.pop()] = i
            stack.append(i)

        odd = [0] * len(arr)
        even = [0] * len(arr)
        odd[-1] = even[-1] = 1
        for i in reversed(range(len(arr))):
            if 0 <= large[i]: odd[i] = even[large[i]]
            if 0 <= small[i]: even[i] = odd[small[i]]
        return sum(odd)


    """977. Squares of a Sorted Array (Easy)
    Given an integer array nums sorted in non-decreasing order, return an array
    of the squares of each number sorted in non-decreasing order.

    Example 1:
    Input: nums = [-4,-1,0,3,10]
    Output: [0,1,9,16,100]
    Explanation: After squaring, the array becomes [16,1,0,9,100]. After
                 sorting, it becomes [0,1,9,16,100].

    Example 2:
    Input: nums = [-7,-3,2,3,11]
    Output: [4,9,9,49,121]

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^4 <= nums[i] <= 10^4
    * nums is sorted in non-decreasing order.

    Follow up: Squaring each element and sorting the new array is very trivial,
               could you find an O(n) solution using a different approach?"""

    def sortedSquares(self, nums: List[int]) -> List[int]:
        ans = [0] * len(nums)
        lo, hi = 0, len(nums)-1
        for i in reversed(range(len(nums))):
            if abs(nums[lo]) >= abs(nums[hi]):
                ans[i] = nums[lo]**2
                lo += 1
            else:
                ans[i] = nums[hi]**2
                hi -= 1
        return ans


    """978. Longest Turbulent Subarray (Medium)
    Given an integer array arr, return the length of a maximum size turbulent
    subarray of arr. A subarray is turbulent if the comparison sign flips
    between each adjacent pair of elements in the subarray. More formally, a
    subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent
    if and only if:
    * For i <= k < j:
      + arr[k] > arr[k + 1] when k is odd, and
      + arr[k] < arr[k + 1] when k is even.
    * Or, for i <= k < j:
      + arr[k] > arr[k + 1] when k is even, and
      + arr[k] < arr[k + 1] when k is odd.

    Example 1:
    Input: arr = [9,4,2,10,7,8,8,1,9]
    Output: 5
    Explanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]

    Example 2:
    Input: arr = [4,8,12,16]
    Output: 2

    Example 3:
    Input: arr = [100]
    Output: 1

    Constraints:
    * 1 <= arr.length <= 4 * 10^4
    * 0 <= arr[i] <= 10^9"""

    def maxTurbulenceSize(self, arr: List[int]) -> int:
        ans = cnt = 0
        for i in range(len(arr)):
            if i >= 2 and (arr[i-2] > arr[i-1] < arr[i] or arr[i-2] < arr[i-1] > arr[i]): cnt += 1
            elif i >= 1 and arr[i-1] != arr[i]: cnt = 2
            else: cnt = 1
            ans = max(ans, cnt)
        return ans


    """979. Distribute Coins in Binary Tree (Medium)
    You are given the root of a binary tree with n nodes where each node in the
    tree has node.val coins. There are n coins in total throughout the whole
    tree. In one move, we may choose two adjacent nodes and move one coin from
    one node to another. A move may be from parent to child, or from child to
    parent. Return the minimum number of moves required to make every node have
    exactly one coin.

    Example 1:
    Input: root = [3,0,0]
    Output: 2
    Explanation: From the root of the tree, we move one coin to its left child,
                 and one coin to its right child.

    Example 2:
    Input: root = [0,3,0]
    Output: 3
    Explanation: From the left child of the root, we move two coins to the root
                 [taking two moves]. Then, we move one coin from the root of the
                 tree to the right child.

    Constraints:
    * The number of nodes in the tree is n.
    * 1 <= n <= 100
    * 0 <= Node.val <= n
    * The sum of all Node.val is n."""

    def distributeCoins(self, root: Optional[TreeNode]) -> int:

        def fn(node):
            """Return surplus and moves at given node."""
            if not node: return 0, 0 # surplus | move
            v0, m0 = fn(node.left)
            v1, m1 = fn(node.right)
            return node.val + v0 + v1 - 1, m0 + m1 + abs(v0) + abs(v1)

        return fn(root)[1]


    """980. Unique Paths III (Hard)
    On a 2-dimensional grid, there are 4 types of squares:
    * 1 represents the starting square.  There is exactly one starting square.
    * 2 represents the ending square.  There is exactly one ending square.
    * 0 represents empty squares we can walk over.
    * -1 represents obstacles that we cannot walk over.
    Return the number of 4-directional walks from the starting square to the
    ending square, that walk over every non-obstacle square exactly once.

    Example 1:
    Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
    Output: 2
    Explanation: We have the following two paths:
    1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
    2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)

    Example 2:
    Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
    Output: 4
    Explanation: We have the following four paths:
    1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
    2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
    3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
    4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)

    Example 3:
    Input: [[0,1],[2,0]]
    Output: 0
    Explanation: There is no path that walks over every empty square exactly
    once. Note that the starting and ending square can be anywhere in the grid.

    Note: 1 <= grid.length * grid[0].length <= 20"""

    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions
        empty = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1: start = (i, j)
                elif grid[i][j] == 0: empty += 1 # empty squares

        def fn(i, j, empty):
            """Count paths via backtracking."""
            nonlocal ans
            if grid[i][j] == 2:
                if empty == -1: ans += 1
                return
            grid[i][j] = -1 # mark as visited
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != -1:
                    fn(ii, jj, empty-1)
            grid[i][j] = 0 # backtracking

        ans = 0
        fn(*start, empty)
        return ans


    """982. Triples with Bitwise AND Equal To Zero (Hard)
    Given an array of integers nums, find the number of triples of indices
    (i, j, k) such that:
    * 0 <= i < nums.length
    * 0 <= j < nums.length
    * 0 <= k < nums.length
    * nums[i] & nums[j] & nums[k] == 0, where & represents the bitwise-AND
      operator.

    Example 1:
    Input: nums = [2,1,3]
    Output: 12
    Explanation: We could choose the following i, j, k triples:
    (i=0, j=0, k=1) : 2 & 2 & 1
    (i=0, j=1, k=0) : 2 & 1 & 2
    (i=0, j=1, k=1) : 2 & 1 & 1
    (i=0, j=1, k=2) : 2 & 1 & 3
    (i=0, j=2, k=1) : 2 & 3 & 1
    (i=1, j=0, k=0) : 1 & 2 & 2
    (i=1, j=0, k=1) : 1 & 2 & 1
    (i=1, j=0, k=2) : 1 & 2 & 3
    (i=1, j=1, k=0) : 1 & 1 & 2
    (i=1, j=2, k=0) : 1 & 3 & 2
    (i=2, j=0, k=1) : 3 & 2 & 1
    (i=2, j=1, k=0) : 3 & 1 & 2

    Note:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] < 2^16"""

    def countTriplets(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for x in nums:
            for y in nums:
                freq[x&y] += 1

        ans = 0
        for x in nums:
            mask = x = x ^ 0xffff
            while x:
                ans += freq[x]
                x = mask & (x-1)
            ans += freq[0]
        return ans


    """986. Interval List Intersections (Medium)
    You are given two lists of closed intervals, firstList and secondList,
    where firstList[i] = [starti, endi] and secondList[j] = [startj, endj].
    Each list of intervals is pairwise disjoint and in sorted order. Return the
    intersection of these two interval lists. A closed interval [a, b] (with
    a <= b) denotes the set of real numbers x with a <= x <= b. The
    intersection of two closed intervals is a set of real numbers that are
    either empty or represented as a closed interval. For example, the
    intersection of [1, 3] and [2, 4] is [2, 3].

    Example 1:
    Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
    Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]

    Example 2:
    Input: firstList = [[1,3],[5,9]], secondList = []
    Output: []

    Example 3:
    Input: firstList = [], secondList = [[4,8],[10,12]]
    Output: []

    Example 4:
    Input: firstList = [[1,7]], secondList = [[3,10]]
    Output: [[3,7]]

    Constraints:
    * 0 <= firstList.length, secondList.length <= 1000
    * firstList.length + secondList.length >= 1
    * 0 <= starti < endi <= 10^9
    * endi < starti+1
    * 0 <= startj < endj <= 10^9
    * endj < startj+1"""

    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -> List[List[int]]:
        ans = []
        i = j = 0
        while i < len(firstList) and j < len(secondList):
            if firstList[i][0] <= secondList[j][1] and secondList[j][0] <= firstList[i][1]:
                ans.append([max(firstList[i][0], secondList[j][0]), min(firstList[i][1], secondList[j][1])])
            if firstList[i][1] <= secondList[j][1]: i += 1
            else: j += 1
        return ans


    """988. Smallest String Starting From Leaf (Medium)
    You are given the root of a binary tree where each node has a value in the
    range [0, 25] representing the letters 'a' to 'z'. Return the
    lexicographically smallest string that starts at a leaf of this tree and
    ends at the root. As a reminder, any shorter prefix of a string is
    lexicographically smaller. For example, "ab" is lexicographically smaller
    than "aba". A leaf of a node is a node that has no children.

    Example 1:
    Input: root = [0,1,2,3,4,3,4]
    Output: "dba"

    Example 2:
    Input: root = [25,1,3,1,3,0,2]
    Output: "adz"

    Example 3:
    Input: root = [2,2,1,null,1,0,null,0]
    Output: "abc"

    Constraints:
    * The number of nodes in the tree is in the range [1, 8500].
    * 0 <= Node.val <= 25"""

    def smallestFromLeaf(self, root: TreeNode) -> str:
        ans = "~"
        stack = [(root, "")]
        while stack:
            node, val = stack.pop()
            val = chr(node.val + 97) + val
            if node.left is node.right: ans = min(ans, val)
            else:
                if node.left: stack.append((node.left, val))
                if node.right: stack.append((node.right, val))
        return ans


    """989. Add to Array-Form of Integer (Easy)
    The array-form of an integer num is an array representing its digits in
    left to right order. For example, for num = 1321, the array form is
    [1,3,2,1]. Given num, the array-form of an integer, and an integer k,
    return the array-form of the integer num + k.

    Example 1:
    Input: num = [1,2,0,0], k = 34
    Output: [1,2,3,4]
    Explanation: 1200 + 34 = 1234

    Example 2:
    Input: num = [2,7,4], k = 181
    Output: [4,5,5]
    Explanation: 274 + 181 = 455

    Example 3:
    Input: num = [2,1,5], k = 806
    Output: [1,0,2,1]
    Explanation: 215 + 806 = 1021

    Constraints:
    * 1 <= num.length <= 10^4
    * 0 <= num[i] <= 9
    * num does not contain any leading zeros except for the zero itself.
    * 1 <= k <= 10^4"""

    def addToArrayForm(self, num: List[int], k: int) -> List[int]:
        num.reverse()
        i = 0
        while k:
            if i == len(num): num.append(0)
            k += num[i]
            num[i] = k % 10
            k //= 10
            i += 1
        return num[::-1]


    """992. Subarrays with K Different Integers (Hard)
    Given an array nums of positive integers, call a (contiguous, not
    necessarily distinct) subarray of nums good if the number of different
    integers in that subarray is exactly k. (For example, [1,2,3,1,2] has 3
    different integers: 1, 2, and 3.) Return the number of good subarrays of
    nums.

    Example 1:
    Input: nums = [1,2,1,2,3], k = 2
    Output: 7
    Explanation: Subarrays formed with exactly 2 different integers:
                 [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].

    Example 2:
    Input: nums = [1,2,1,3,4], k = 3
    Output: 3
    Explanation: Subarrays formed with exactly 3 different integers:
                 [1,2,1,3], [2,1,3], [1,3,4].

    Note:
    * 1 <= nums.length <= 20000
    * 1 <= nums[i] <= nums.length
    * 1 <= k <= nums.length"""

    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        ans = ii = 0
        freq = defaultdict(int)
        queue = deque()
        for i, x in enumerate(nums):
            freq[x] += 1
            queue.append(i)
            if len(freq) > k:
                ii = queue[0]+1
                freq.pop(nums[queue.popleft()])
            while freq[nums[queue[0]]] > 1: freq[nums[queue.popleft()]] -= 1
            if len(freq) == k: ans += queue[0] - ii + 1
        return ans


    """993. Cousins in Binary Tree (Easy)
    Given the root of a binary tree with unique values and the values of two
    different nodes of the tree x and y, return true if the nodes corresponding
    to the values x and y in the tree are cousins, or false otherwise. Two
    nodes of a binary tree are cousins if they have the same depth with
    different parents. Note that in a binary tree, the root node is at the
    depth 0, and children of each depth k node are at the depth k + 1.

    Example 1:
    Input: root = [1,2,3,4], x = 4, y = 3
    Output: false

    Example 2:
    Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
    Output: true

    Example 3:
    Input: root = [1,2,3,null,4], x = 2, y = 3
    Output: false

    Constraints:
    * The number of nodes in the tree is in the range [2, 100].
    * 1 <= Node.val <= 100
    * Each node has a unique value.
    * x != y
    * x and y are exist in the tree."""

    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:
        queue = [(root, None)]
        while queue:
            newq = []
            seen = 0
            for n, p in queue:
                if n.val in (x, y):
                    if not seen: seen = p
                    else: return seen != p
                if n.left: newq.append((n.left, n))
                if n.right: newq.append((n.right, n))
            if seen: return False
            queue = newq


    """994. Rotting Oranges (Medium)
    You are given an m x n grid where each cell can have one of three values:
    * 0 representing an empty cell,
    * 1 representing a fresh orange, or
    * 2 representing a rotten orange.
    Every minute, any fresh orange that is 4-directionally adjacent to a rotten
    orange becomes rotten. Return the minimum number of minutes that must
    elapse until no cell has a fresh orange. If this is impossible, return -1.

    Example 1:
    Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
    Output: 4

    Example 2:
    Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
    Output: -1
    Explanation: The orange in the bottom left corner (row 2, column 0) is
                 never rotten, because rotting only happens 4-directionally.

    Example 3:
    Input: grid = [[0,2]]
    Output: 0
    Explanation: Since there are already no fresh oranges at minute 0, the
                 answer is just 0.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10
    * grid[i][j] is 0, 1, or 2."""

    def orangesRotting(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = fresh = 0
        queue = deque()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1: fresh += 1
                elif grid[i][j] == 2: queue.append((i, j))

        while queue and fresh:
            for _ in range(len(queue)):
                i, j = queue.popleft()
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == 1:
                        fresh -= 1
                        grid[ii][jj] = 2 # mark as rotten
                        queue.append((ii, jj))
            ans += 1
        return ans if fresh == 0 else -1


    """995. Minimum Number of K Consecutive Bit Flips (Hard)
    In an array nums containing only 0s and 1s, a k-bit flip consists of
    choosing a (contiguous) subarray of length k and simultaneously changing
    every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the
    minimum number of k-bit flips required so that there is no 0 in the array.
    If it is not possible, return -1.

    Example 1:
    Input: nums = [0,1,0], k = 1
    Output: 2
    Explanation: Flip nums[0], then flip nums[2].

    Example 2:
    Input: nums = [1,1,0], k = 2
    Output: -1
    Explanation: No matter how we flip subarrays of size 2, we can't make the
                 array become [1,1,1].

    Example 3:
    Input: nums = [0,0,0,1,0,1,1,0], k = 3
    Output: 3
    Explanation:
    Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]
    Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]
    Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]

    Note:
    * 1 <= nums.length <= 30000
    * 1 <= k <= nums.length"""

    def minKBitFlips(self, nums: List[int], k: int) -> int:
        ans = flip = 0
        n = len(nums)
        line = [0]*n
        for i, x in enumerate(nums):
            if x == flip:
                if n <= i+k-1: return -1
                ans += 1
                flip ^= 1
                line[i+k-1] = 1
            if line[i]: flip ^= 1
        return ans


    """997. Find the Town Judge (Easy)
    In a town, there are n people labeled from 1 to n. There is a rumor that
    one of these people is secretly the town judge. If the town judge exists,
    then:
    * The town judge trusts nobody.
    * Everybody (except for the town judge) trusts the town judge.
    * There is exactly one person that satisfies properties 1 and 2.
    You are given an array trust where trust[i] = [ai, bi] representing that
    the person labeled ai trusts the person labeled bi. Return the label of the
    town judge if the town judge exists and can be identified, or return -1
    otherwise.

    Example 1:
    Input: n = 2, trust = [[1,2]]
    Output: 2

    Example 2:
    Input: n = 3, trust = [[1,3],[2,3]]
    Output: 3

    Example 3:
    Input: n = 3, trust = [[1,3],[2,3],[3,1]]
    Output: -1

    Example 4:
    Input: n = 3, trust = [[1,2],[2,3]]
    Output: -1

    Example 5:
    Input: n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
    Output: 3

    Constraints:
    * 1 <= n <= 1000
    * 0 <= trust.length <= 10^4
    * trust[i].length == 2
    * All the pairs of trust are unique.
    * ai != bi"""

    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        degree = [0]*n
        for u, v in trust:
            degree[v-1] += 1
            degree[u-1] -= 1
        return next((i+1 for i, x in enumerate(degree) if x == n-1), -1)


    """1000. Minimum Cost to Merge Stones (Hard)
    There are n piles of stones arranged in a row. The ith pile has stones[i]
    stones. A move consists of merging exactly k consecutive piles into one
    pile, and the cost of this move is equal to the total number of stones in
    these k piles. Return the minimum cost to merge all piles of stones into
    one pile. If it is impossible, return -1.

    Example 1:
    Input: stones = [3,2,4,1], k = 2
    Output: 20
    Explanation: We start with [3, 2, 4, 1].
                 We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].
                 We merge [4, 1] for a cost of 5, and we are left with [5, 5].
                 We merge [5, 5] for a cost of 10, and we are left with [10].
                 The total cost was 20, and this is the minimum possible.

    Example 2:
    Input: stones = [3,2,4,1], k = 3
    Output: -1
    Explanation: After any merge operation, there are 2 piles left, and we
                 can't merge anymore.  So the task is impossible.

    Example 3:
    Input: stones = [3,5,1,2,6], k = 3
    Output: 25
    Explanation: We start with [3, 5, 1, 2, 6].
                 We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].
                 We merge [3, 8, 6] for a cost of 17, and we are left with [17].
                 The total cost was 25, and this is the minimum possible.

    Constraints:
    * n == stones.length
    * 1 <= n <= 30
    * 1 <= stones[i] <= 100
    * 2 <= k <= 30"""

    def mergeStones(self, stones: List[int], k: int) -> int:
        if (len(stones)-1) % (k-1): return -1 # impossible

        prefix = [0]
        for x in stones: prefix.append(prefix[-1] + x)

        @cache
        def fn(lo, hi):
            """Return min cost of merging stones[lo:hi]."""
            if hi - lo < k: return 0 # not enough stones
            ans = inf
            for mid in range(lo+1, hi, k-1):
                ans = min(ans, fn(lo, mid) + fn(mid, hi))
            if (hi-lo-1) % (k-1) == 0: ans += prefix[hi] - prefix[lo]
            return ans

        return fn(0, len(stones))


    """1001. Grid Illumination (Hard)
    There is a 2D grid of size n x n where each cell of this grid has a lamp
    that is initially turned off. You are given a 2D array of lamp positions
    lamps, where lamps[i] = [rowi, coli] indicates that the lamp at
    grid[rowi][coli] is turned on. Even if the same lamp is listed more than
    once, it is turned on. When a lamp is turned on, it illuminates its cell
    and all other cells in the same row, column, or diagonal. You are also
    given another 2D array queries, where queries[j] = [rowj, colj]. For the
    jth query, determine whether grid[rowj][colj] is illuminated or not. After
    answering the jth query, turn off the lamp at grid[rowj][colj] and its 8
    adjacent lamps if they exist. A lamp is adjacent if its cell shares either
    a side or corner with grid[rowj][colj]. Return an array of integers ans,
    where ans[j] should be 1 if the cell in the jth query was illuminated, or 0
    if the lamp was not.

    Example 1:
    Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
    Output: [1,0]
    Explanation: We have the initial grid with all lamps turned off. In the
                 above picture we see the grid after turning on the lamp at
                 grid[0][0] then turning on the lamp at grid[4][4]. The 0th
                 query asks if the lamp at grid[1][1] is illuminated or not
                 (the blue square). It is illuminated, so set ans[0] = 1. Then,
                 we turn off all lamps in the red square. The 1st query asks if
                 the lamp at grid[1][0] is illuminated or not (the blue square).
                 It is not illuminated, so set ans[1] = 0. Then, we turn off
                 all lamps in the red rectangle.

    Example 2:
    Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]
    Output: [1,1]

    Example 3:
    Input: n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]
    Output: [1,1,0]

    Constraints:
    * 1 <= n <= 10^9
    * 0 <= lamps.length <= 20000
    * 0 <= queries.length <= 20000
    * lamps[i].length == 2
    * 0 <= rowi, coli < n
    * queries[j].length == 2
    * 0 <= rowj, colj < n"""

    def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
        lamps = {(i, j) for i, j in lamps}
        rows = defaultdict(int)
        cols = defaultdict(int)
        anti = defaultdict(int)
        diag = defaultdict(int)
        for i, j in lamps:
            rows[i] += 1
            cols[j] += 1
            anti[i+j] += 1
            diag[i-j] += 1

        ans = []
        for i, j in queries:
            if rows[i] or cols[j] or anti[i+j] or diag[i-j]: ans.append(1)
            else: ans.append(0)
            for ii in range(i-1, i+2):
                for jj in range(j-1, j+2):
                    if (ii, jj) in lamps:
                        lamps.remove((ii, jj))
                        rows[ii] -= 1
                        cols[jj] -= 1
                        anti[ii+jj] -= 1
                        diag[ii-jj] -= 1
        return ans


    """1002. Find Common Characters (Easy)
    Given a string array words, return an array of all characters that show up
    in all strings within the words (including duplicates). You may return the
    answer in any order.

    Example 1:
    Input: words = ["bella","label","roller"]
    Output: ["e","l","l"]

    Example 2:
    Input: words = ["cool","lock","cook"]
    Output: ["c","o"]

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consists of lowercase English letters."""

    def commonChars(self, words: List[str]) -> List[str]:
        return reduce(and_, map(Counter, words)).elements()


    """1004. Max Consecutive Ones III (Medium)
    Given a binary array nums and an integer k, return the maximum number of
    consecutive 1's in the array if you can flip at most k 0's.

    Example 1:
    Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
    Output: 6
    Explanation: [1,1,1,0,0,1,1,1,1,1,1]
                 Bolded numbers were flipped from 0 to 1. The longest subarray
                 is underlined.

    Example 2:
    Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
    Output: 10
    Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
                 Bolded numbers were flipped from 0 to 1. The longest subarray
                 is underlined.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1.
    * 0 <= k <= nums.length"""

    def longestOnes(self, nums: List[int], k: int) -> int:
        ans = ii = 0
        for i in range(len(nums)):
            if nums[i] == 0: k -= 1
            while k < 0:
                if nums[ii] == 0: k += 1
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans


    """1005. Maximize Sum Of Array After K Negations (Easy)
    Given an integer array nums and an integer k, modify the array in the
    following way:
    * choose an index i and replace nums[i] with -nums[i].
    You should apply this process exactly k times. You may choose the same
    index i multiple times. Return the largest possible sum of the array after
    modifying it in this way.

    Example 1:
    Input: nums = [4,2,3], k = 1
    Output: 5
    Explanation: Choose index 1 and nums becomes [4,-2,3].

    Example 2:
    Input: nums = [3,-1,0,2], k = 3
    Output: 6
    Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].

    Example 3:
    Input: nums = [2,-3,-1,5,-4], k = 2
    Output: 13
    Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].

    Constraints:
    * 1 <= nums.length <= 10^4
    * -100 <= nums[i] <= 100
    * 1 <= k <= 10^4"""

    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
        heapify(nums)
        for _ in range(k): heappush(nums, -heappop(nums))
        return sum(nums)


    """1007. Minimum Domino Rotations For Equal Row (Medium)
    In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom
    halves of the ith domino. (A domino is a tile with two numbers from 1 to 6
    - one on each half of the tile.) We may rotate the ith domino, so that
    tops[i] and bottoms[i] swap values. Return the minimum number of rotations
    so that all the values in tops are the same, or all the values in bottoms
    are the same. If it cannot be done, return -1.

    Example 1:
    Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]
    Output: 2
    Explanation: The first figure represents the dominoes as given by tops and
                 bottoms: before we do any rotations. If we rotate the second
                 and fourth dominoes, we can make every value in the top row
                 equal to 2, as indicated by the second figure.

    Example 2:
    Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]
    Output: -1
    Explanation: In this case, it is not possible to rotate the dominoes to
                 make one row of values equal.

    Constraints:
    * 2 <= tops.length <= 2 * 10^4
    * bottoms.length == tops.length
    * 1 <= tops[i], bottoms[i] <= 6"""

    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:
        tt = bt = tb = bb = 0
        top = bottom = True
        for x, y in zip(tops, bottoms):
            if tops[0] not in (x, y): top = False
            if bottoms[0] not in (x, y): bottom = False
            if tops[0] != x: tt += 1
            if tops[0] != y: bt += 1
            if bottoms[0] != x: tb += 1
            if bottoms[0] != y: bb += 1
        return min(tt, bt, tb, bb) if top or bottom else -1


    """1008. Construct Binary Search Tree from Preorder Traversal (Medium)
    Given an array of integers preorder, which represents the preorder
    traversal of a BST (i.e., binary search tree), construct the tree and
    return its root. It is guaranteed that there is always possible to find a
    binary search tree with the given requirements for the given test cases.
    A binary search tree is a binary tree where for every node, any descendant
    of Node.left has a value strictly less than Node.val, and any descendant of
    Node.right has a value strictly greater than Node.val. A preorder traversal
    of a binary tree displays the value of the node first, then traverses
    Node.left, then traverses Node.right.

    Example 1:
    Input: preorder = [8,5,1,7,10,12]
    Output: [8,5,10,1,7,null,12]

    Example 2:
    Input: preorder = [1,3]
    Output: [1,null,3]

    Constraints:
    * 1 <= preorder.length <= 100
    * 1 <= preorder[i] <= 10^8
    * All the values of preorder are unique."""

    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
        root = None
        stack = []
        for x in preorder:
            if not root: root = node = TreeNode(x)
            elif x < node.val:
                stack.append(node)
                node.left = node = TreeNode(x)
            else:
                while stack and stack[-1].val < x: node = stack.pop()
                node.right = node = TreeNode(x)
        return root


    """1009. Complement of Base 10 Integer (Easy)
    The complement of an integer is the integer you get when you flip all the
    0's to 1's and all the 1's to 0's in its binary representation. For example,
    the integer 5 is "101" in binary and its complement is "010" which is the
    integer 2. Given an integer n, return its complement.

    Example 1:
    Input: n = 5
    Output: 2
    Explanation: 5 is "101" in binary, with complement "010" in binary, which
                 is 2 in base-10.

    Example 2:
    Input: n = 7
    Output: 0
    Explanation: 7 is "111" in binary, with complement "000" in binary, which
                 is 0 in base-10.

    Example 3:
    Input: n = 10
    Output: 5
    Explanation: 10 is "1010" in binary, with complement "0101" in binary,
                 which is 5 in base-10.

    Constraints: 0 <= n < 10^9

    Note: This question is the same as 476:
          https://leetcode.com/problems/number-complement/"""

    def bitwiseComplement(self, n: int) -> int:
        m = 1
        while m < n: m = m << 1 | 1
        return m ^ n


    """1010. Pairs of Songs With Total Durations Divisible by 60 (Medium)
    You are given a list of songs where the ith song has a duration of time[i]
    seconds. Return the number of pairs of songs for which their total duration
    in seconds is divisible by 60. Formally, we want the number of indices i, j
    such that i < j with (time[i] + time[j]) % 60 == 0.

    Example 1:
    Input: time = [30,20,150,100,40]
    Output: 3
    Explanation: Three pairs have a total duration divisible by 60:
                 (time[0] = 30, time[2] = 150): total duration 180
                 (time[1] = 20, time[3] = 100): total duration 120
                 (time[1] = 20, time[4] = 40): total duration 60

    Example 2:
    Input: time = [60,60,60]
    Output: 3
    Explanation: All three pairs have a total duration of 120, which is divisible by 60.

    Constraints:
    * 1 <= time.length <= 6 * 10^4
    * 1 <= time[i] <= 500"""

    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        ans = 0
        freq = Counter()
        for x in time:
            ans += freq[-x%60]
            freq[x%60] += 1
        return ans


    """1011. Capacity To Ship Packages Within D Days (Medium)
    A conveyor belt has packages that must be shipped from one port to another
    within days days. The ith package on the conveyor belt has a weight of
    weights[i]. Each day, we load the ship with packages on the conveyor belt
    (in the order given by weights). We may not load more weight than the
    maximum weight capacity of the ship. Return the least weight capacity of
    the ship that will result in all the packages on the conveyor belt being
    shipped within days days.

    Example 1:
    Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
    Output: 15
    Explanation: A ship capacity of 15 is the minimum to ship all the packages
                 in 5 days like this:
                 1st day: 1, 2, 3, 4, 5
                 2nd day: 6, 7
                 3rd day: 8
                 4th day: 9
                 5th day: 10
                 Note that the cargo must be shipped in the order given, so
                 using a ship of capacity 14 and splitting the packages into
                 parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not
                 allowed.

    Example 2:
    Input: weights = [3,2,2,4,1,4], days = 3
    Output: 6
    Explanation: A ship capacity of 6 is the minimum to ship all the packages
                 in 3 days like this:
                 1st day: 3, 2
                 2nd day: 2, 4
                 3rd day: 1, 4

    Example 3:
    Input: weights = [1,2,3,1,1], days = 4
    Output: 3
    Explanation: 1st day: 1
                 2nd day: 2
                 3rd day: 3
                 4th day: 1, 1

    Constraints:
    * 1 <= days <= weights.length <= 5 * 10^4
    * 1 <= weights[i] <= 500"""

    def shipWithinDays(self, weights: List[int], days: int) -> int:
        lo, hi = max(weights), sum(weights)
        while lo < hi:
            mid = lo + hi >> 1
            cnt, val = 0, inf
            for w in weights:
                if val + w > mid:
                    cnt += 1
                    val = 0
                val += w
            if cnt <= days: hi = mid
            else: lo = mid + 1
        return lo


    """1013. Partition Array Into Three Parts With Equal Sum (Easy)
    Given an array of integers arr, return true if we can partition the array
    into three non-empty parts with equal sums. Formally, we can partition the
    array if we can find indexes i + 1 < j with
    (arr[0] + arr[1] + ... + arr[i]
    == arr[i + 1] + arr[i + 2] + ... + arr[j - 1]
    == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])

    Example 1:
    Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]
    Output: true
    Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1

    Example 2:
    Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]
    Output: false

    Example 3:
    Input: arr = [3,3,6,5,-2,2,5,1,-9,4]
    Output: true
    Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4

    Constraints:
    * 3 <= arr.length <= 5 * 10^4
    * -10^4 <= arr[i] <= 10^4"""

    def canThreePartsEqualSum(self, A: List[int]) -> bool:
        return (lambda x, y: x in y and 2*x in y)(sum(A)//3, accumulate(A))


    """1014. Best Sightseeing Pair (Medium)
    Given an array A of positive integers, A[i] represents the value of the
    i-th sightseeing spot, and two sightseeing spots i and j have distance
    j - i between them. The score of a pair (i < j) of sightseeing spots is
    (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots,
    minus the distance between them. Return the maximum score of a pair of
    sightseeing spots.

    Example 1:
    Input: [8,1,5,2,6]
    Output: 11
    Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11

    Note:
    * 2 <= A.length <= 50000
    * 1 <= A[i] <= 1000"""

    def maxScoreSightseeingPair(self, A: List[int]) -> int:
        ans = most = 0
        for i, x in enumerate(A):
            if i: ans = max(ans, most + x - i)
            most = max(most, x + i)
        return ans


    """1015. Smallest Integer Divisible by K (Medium)
    Given a positive integer k, you need to find the length of the smallest
    positive integer n such that n is divisible by k, and n only contains the
    digit 1. Return the length of n. If there is no such n, return -1. Note:
    n may not fit in a 64-bit signed integer.

    Example 1:
    Input: k = 1
    Output: 1
    Explanation: The smallest answer is n = 1, which has length 1.

    Example 2:
    Input: k = 2
    Output: -1
    Explanation: There is no such positive integer n divisible by 2.

    Example 3:
    Input: k = 3
    Output: 3
    Explanation: The smallest answer is n = 111, which has length 3.

    Constraints: 1 <= k <= 10^5"""

    def smallestRepunitDivByK(self, K: int) -> int:
        x = 1 % K
        ans = 1
        seen = set()
        while x:
            if x in seen: return -1
            seen.add(x)
            x = (10*x + 1) % K
            ans += 1
        return ans


    """1017. Convert to Base -2 (Medium)
    Given a number N, return a string consisting of "0"s and "1"s that
    represents its value in base -2 (negative two). The returned string must
    have no leading zeroes, unless the string is "0".

    Example 1:
    Input: 2
    Output: "110"
    Explantion: (-2) ^ 2 + (-2) ^ 1 = 2

    Example 2:
    Input: 3
    Output: "111"
    Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3

    Example 3:
    Input: 4
    Output: "100"
    Explantion: (-2) ^ 2 = 4

    Note: 0 <= N <= 10^9"""

    def baseNeg2(self, N: int) -> str:
        ans = []
        while N:
            ans.append(N & 1)
            N = -(N >> 1)
        return "".join(map(str, ans[::-1] or [0]))


    """1018. Binary Prefix Divisible By 5 (Easy)
    You are given a binary array nums (0-indexed). We define xi as the number
    whose binary representation is the subarray nums[0..i] (from
    most-significant-bit to least-significant-bit).
    * For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5.
    Return an array of booleans answer where answer[i] is true if xi is
    divisible by 5.

    Example 1:
    Input: nums = [0,1,1]
    Output: [true,false,false]
    Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1,
                 and 3 in base-10. Only the first number is divisible by 5, so
                 answer[0] is true.

    Example 2:
    Input: nums = [1,1,1]
    Output: [false,false,false]

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1."""

    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:
        return [x == 0 for x in accumulate(nums, lambda x, y: (2*x+y)%5)]


    """1019. Next Greater Node In Linked List (Medium)
    We are given a linked list with head as the first node. Let's number the
    nodes in the list: node_1, node_2, node_3, ... etc. Each node may have a
    next larger value: for node_i, next_larger(node_i) is the node_j.val such
    that j > i, node_j.val > node_i.val, and j is the smallest possible choice.
    If such a j does not exist, the next larger value is 0. Return an array of
    integers answer, where answer[i] = next_larger(node_{i+1}). Note that in
    the example inputs (not outputs) below, arrays such as [2,1,5] represent
    the serialization of a linked list with a head node value of 2, second node
    value of 1, and third node value of 5.

    Example 1:
    Input: [2,1,5]
    Output: [5,5,0]

    Example 2:
    Input: [2,7,4,3,5]
    Output: [7,0,5,5,0]

    Example 3:
    Input: [1,7,5,1,9,2,5,1]
    Output: [7,9,9,9,0,5,0,0]

    Note:
    * 1 <= node.val <= 10^9 for each node in the linked list.
    * The given list has length in the range [0, 10000]."""

    def nextLargerNodes(self, head: ListNode) -> List[int]:
        ans, stack = [], []
        while head:
            while stack and stack[-1][1] < head.val: ans[stack.pop()[0]] = head.val
            stack.append((len(ans), head.val))
            ans.append(0)
            head = head.next
        return ans


    """1020. Number of Enclaves (Medium)
    Given a 2D array A, each cell is 0 (representing sea) or 1 (representing
    land). A move consists of walking from one land square 4-directionally to
    another land square, or off the boundary of the grid. Return the number of
    land squares in the grid for which we cannot walk off the boundary of the
    grid in any number of moves.

    Example 1:
    Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
    Output: 3
    Explanation: There are three 1s that are enclosed by 0s, and one 1 that
                 isn't enclosed because its on the boundary.

    Example 2:
    Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
    Output: 0
    Explanation: All 1s are either on the boundary or can reach the boundary.

    Note:
    * 1 <= A.length <= 500
    * 1 <= A[i].length <= 500
    * 0 <= A[i][j] <= 1
    * All rows have the same size."""

    def numEnclaves(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        stack = []
        for i in range(m):
            for j in range(n):
                if (i in (0, m-1) or j in (0, n-1)) and grid[i][j]:
                    stack.append((i, j))
                    grid[i][j] = 0
        while stack:
            i, j = stack.pop()
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]:
                    stack.append((ii, jj))
                    grid[ii][jj] = 0
        return sum(map(sum, grid))


    """1021. Remove Outermost Parentheses (Easy)
    A valid parentheses string is either empty "", "(" + A + ")", or A + B,
    where A and B are valid parentheses strings, and + represents string
    concatenation.
    * For example, "", "()", "(())()", and "(()(()))" are all valid parentheses
      strings.
    A valid parentheses string s is primitive if it is nonempty, and there does
    not exist a way to split it into s = A + B, with A and B nonempty valid
    parentheses strings. Given a valid parentheses string s, consider its
    primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive
    valid parentheses strings. Return s after removing the outermost
    parentheses of every primitive string in the primitive decomposition of s.

    Example 1:
    Input: s = "(()())(())"
    Output: "()()()"
    Explanation: The input string is "(()())(())", with primitive decomposition
                 "(()())" + "(())". After removing outer parentheses of each
                 part, this is "()()" + "()" = "()()()".

    Example 2:
    Input: s = "(()())(())(()(()))"
    Output: "()()()()(())"
    Explanation: The input string is "(()())(())(()(()))", with primitive
                 decomposition "(()())" + "(())" + "(()(()))". After removing
                 outer parentheses of each part, this is
                 "()()" + "()" + "()(())" = "()()()()(())".

    Example 3:
    Input: s = "()()"
    Output: ""
    Explanation: The input string is "()()", with primitive decomposition
                 "()" + "()". After removing outer parentheses of each part,
                 this is "" + "" = "".

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '(' or ')'.
    * s is a valid parentheses string."""

    def removeOuterParentheses(self, s: str) -> str:
        ans = []
        level = 0
        for i, ch in enumerate(s):
            if ch == '(':
                if level: ans.append(ch)
                level += 1
            else:
                level -= 1
                if level: ans.append(ch)
        return ''.join(ans)


    """1022. Sum of Root To Leaf Binary Numbers (Easy)
    You are given the root of a binary tree where each node has a value 0 or 1.
    Each root-to-leaf path represents a binary number starting with the most
    significant bit.
    * For example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could
      represent 01101 in binary, which is 13.
    For all leaves in the tree, consider the numbers represented by the path
    from the root to that leaf. Return the sum of these numbers. The test cases
    are generated so that the answer fits in a 32-bits integer.

    Example 1:
    Input: root = [1,0,1,0,1,0,1]
    Output: 22
    Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22

    Example 2:
    Input: root = [0]
    Output: 0

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * Node.val is 0 or 1."""

    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
        ans = 0
        stack = [(root, 0)]
        while stack:
            node, val = stack.pop()
            val = 2*val + node.val
            if node.left is node.right: ans += val
            if node.left: stack.append((node.left, val))
            if node.right: stack.append((node.right, val))
        return ans


    """1023. Camelcase Matching (Medium)
    A query word matches a given pattern if we can insert lowercase letters to
    the pattern word so that it equals the query. (We may insert each character
    at any position, and may insert 0 characters.) Given a list of queries, and
    a pattern, return an answer list of booleans, where answer[i] is true if
    and only if queries[i] matches the pattern.

    Example 1:
    Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FB"
    Output: [true,false,true,true,false]
    Explanation: "FooBar" can be generated like this "F" + "oo" + "B" + "ar".
                 "FootBall" can be generated like this "F" + "oot" + "B" + "all".
                 "FrameBuffer" can be generated like this "F" + "rame" + "B" + "uffer".

    Example 2:
    Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBa"
    Output: [true,false,true,false,false]
    Explanation: "FooBar" can be generated like this "Fo" + "o" + "Ba" + "r".
                 "FootBall" can be generated like this "Fo" + "ot" + "Ba" + "ll".

    Example 3:
    Input: queries = ["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], pattern = "FoBaT"
    Output: [false,true,false,false,false]
    Explanation: "FooBarTest" can be generated like this "Fo" + "o" + "Ba" + "r" + "T" + "est".

    Note:
    * 1 <= queries.length <= 100
    * 1 <= queries[i].length <= 100
    * 1 <= pattern.length <= 100
    * All strings consists only of lower and upper case English letters."""

    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:

        def fn(query):
            """Return true if query matches pattern."""
            i = 0
            for x in query:
                if i < len(pattern) and x == pattern[i]: i += 1
                elif x.isupper(): return False
            return i == len(pattern)

        return [fn(query) for query in queries]


    """1024. Video Stitching (Medium)
    You are given a series of video clips from a sporting event that lasted T
    seconds. These video clips can be overlapping with each other and have
    varied lengths. Each video clip clips[i] is an interval: it starts at time
    clips[i][0] and ends at time clips[i][1].  We can cut these clips into
    segments freely: for example, a clip [0, 7] can be cut into segments
    [0, 1] + [1, 3] + [3, 7]. Return the minimum number of clips needed so that
    we can cut the clips into segments that cover the entire sporting event
    ([0, T]).  If the task is impossible, return -1.

    Example 1:
    Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
    Output: 3
    Explanation:
    We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
    Then, we can reconstruct the sporting event as follows:
    We cut [1,9] into segments [1,2] + [2,8] + [8,9].
    Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].

    Example 2:
    Input: clips = [[0,1],[1,2]], T = 5
    Output: -1
    Explanation: We can't cover [0,5] with only [0,1] and [1,2].

    Example 3:
    Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
    Output: 3
    Explanation: We can take clips [0,4], [4,7], and [6,9].

    Example 4:
    Input: clips = [[0,4],[2,8]], T = 5
    Output: 2
    Explanation: Notice you can have extra video after the event ends.

    Constraints:
    * 1 <= clips.length <= 100
    * 0 <= clips[i][0] <= clips[i][1] <= 100
    * 0 <= T <= 100"""

    def videoStitching(self, clips: List[List[int]], T: int) -> int:
        if not T: return 0 # edge case

        ans = yy = mx = 0
        for x, y in sorted(clips):
            if mx < x: return -1 # gap
            if yy < x <= mx: ans, yy = ans+1, mx
            mx = max(mx, y)
            if T <= mx: return ans + 1
        return -1 # not reaching T


    """1026. Maximum Difference Between Node and Ancestor (Medium)
    Given the root of a binary tree, find the maximum value V for which there
    exist different nodes A and B where V = |A.val - B.val| and A is an
    ancestor of B. A node A is an ancestor of B if either: any child of A is
    equal to B, or any child of A is an ancestor of B.

    Example 1:
    Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]
    Output: 7
    Explanation: We have various ancestor-node differences, some of which are given below :
    |8 - 3| = 5
    |3 - 7| = 4
    |8 - 1| = 7
    |10 - 13| = 3
    Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.

    Example 2:
    Input: root = [1,null,2,null,0,3]
    Output: 3

    Constraints:
    * The number of nodes in the tree is in the range [2, 5000].
    * 0 <= Node.val <= 10^5"""

    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:
        ans = 0
        stack = [(root, inf, -inf)]
        while stack:
            node, lo, hi = stack.pop()
            lo = min(lo, node.val)
            hi = max(hi, node.val)
            ans = max(ans, node.val - lo, hi - node.val)
            if node.left: stack.append((node.left, lo, hi))
            if node.right: stack.append((node.right, lo, hi))
        return ans


    """1027. Longest Arithmetic Subsequence (Medium)
    Given an array A of integers, return the length of the longest arithmetic
    subsequence in A. Recall that a subsequence of A is a list A[i_1], A[i_2],
    ..., A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1, and that a
    sequence B is arithmetic if B[i+1] - B[i] are all the same value (for
    0 <= i < B.length - 1).

    Example 1:
    Input: A = [3,6,9,12]
    Output: 4
    Explanation:
    The whole array is an arithmetic sequence with steps of length = 3.

    Example 2:
    Input: A = [9,4,7,2,10]
    Output: 3
    Explanation:
    The longest arithmetic subsequence is [4,7,10].

    Example 3:
    Input: A = [20,1,15,3,10,5,8]
    Output: 4
    Explanation:
    The longest arithmetic subsequence is [20,15,10,5].

    Constraints:
    * 2 <= A.length <= 1000
    * 0 <= A[i] <= 500"""

    def longestArithSeqLength(self, A: List[int]) -> int:
        ans = 0
        cnt = defaultdict(lambda: 1)
        seen = set()
        for x in A:
            for xx in seen:
                cnt[x, x-xx] = 1 + cnt[xx, x-xx]
                ans = max(ans, cnt[x, x-xx])
            seen.add(x)
        return ans


    """1028. Recover a Tree From Preorder Traversal (Hard)
    We run a preorder depth-first search (DFS) on the root of a binary tree. At
    each node in this traversal, we output D dashes (where D is the depth of
    this node), then we output the value of this node.  If the depth of a node
    is D, the depth of its immediate child is D + 1.  The depth of the root
    node is 0. If a node has only one child, that child is guaranteed to be the
    left child. Given the output S of this traversal, recover the tree and
    return its root.

    Example 1:
    Input: S = "1-2--3--4-5--6--7"
    Output: [1,2,5,3,4,6,7]

    Example 2:
    Input: S = "1-2--3---4-5--6---7"
    Output: [1,2,5,3,null,6,null,4,null,7]

    Example 3:
    Input: S = "1-401--349---90--88"
    Output: [1,401,null,349,88,90]

    Constraints:
    * The number of nodes in the original tree is in the range [1, 1000].
    * 1 <= Node.val <= 10^9"""

    def recoverFromPreorder(self, S: str) -> TreeNode:
        stack = []
        depth, val = 0, ""
        for i, x in enumerate(S):
            if x == "-":
                depth += 1
                val = ""
            else:
                val += S[i]
                if i+1 == len(S) or S[i+1] == "-":
                    node = TreeNode(int(val))
                    while len(stack) > depth: stack.pop()
                    if stack:
                        if not stack[-1].left: stack[-1].left = node
                        else: stack[-1].right = node
                    stack.append(node)
                    depth = 0
        return stack[0]


    """1029. Two City Scheduling (Medium)
    A company is planning to interview 2n people. Given the array costs where
    costs[i] = [aCosti, bCosti], the cost of flying the ith person to city a is
    aCosti, and the cost of flying the ith person to city b is bCosti. Return
    the minimum cost to fly every person to a city such that exactly n people
    arrive in each city.

    Example 1:
    Input: costs = [[10,20],[30,200],[400,50],[30,20]]
    Output: 110
    Explanation: The first person goes to city A for a cost of 10.
                 The second person goes to city A for a cost of 30.
                 The third person goes to city B for a cost of 50.
                 The fourth person goes to city B for a cost of 20.
                 The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half
                 the people interviewing in each city.

    Example 2:
    Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]
    Output: 1859

    Example 3:
    Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]
    Output: 3086

    Constraints:
    * 2 * n == costs.length
    * 2 <= costs.length <= 100
    * costs.length is even.
    * 1 <= aCosti, bCosti <= 1000"""

    def twoCitySchedCost(self, costs: List[List[int]]) -> int:
        ans = 0
        for i, (a, b) in enumerate(sorted(costs, key=lambda x: x[1]-x[0])):
            if i < len(costs)//2: ans += b
            else: ans += a
        return ans


    """1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium)
    Given an array A of non-negative integers, return the maximum sum of
    elements in two non-overlapping (contiguous) subarrays, which have lengths
    L and M.  (For clarification, the L-length subarray could occur before or
    after the M-length subarray.) Formally, return the largest V for which
    V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) and
    either:
    * 0 <= i < i + L - 1 < j < j + M - 1 < A.length, or
    * 0 <= j < j + M - 1 < i < i + L - 1 < A.length.

    Example 1:
    Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
    Output: 20
    Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.

    Example 2:
    Input: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2
    Output: 29
    Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.

    Example 3:
    Input: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3
    Output: 31
    Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.

    Note:
    * L >= 1
    * M >= 1
    * L + M <= A.length <= 1000
    * 0 <= A[i] <= 1000"""

    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        prefix = [0]
        for x in A: prefix.append(prefix[-1] + x) # prefix sum w/ leading 0
        ans = lmx = mmx = -inf
        for i in range(M+L, len(A)+1):
            lmx = max(lmx, prefix[i-M] - prefix[i-L-M])
            mmx = max(mmx, prefix[i-L] - prefix[i-L-M])
            ans = max(ans, lmx + prefix[i] - prefix[i-M], mmx + prefix[i] - prefix[i-L])
        return ans


    """1034. Coloring A Border (Medium)
    Given a 2-dimensional grid of integers, each value in the grid represents
    the color of the grid square at that location. Two squares belong to the
    same connected component if and only if they have the same color and are
    next to each other in any of the 4 directions. The border of a connected
    component is all the squares in the connected component that are either
    4-directionally adjacent to a square not in the component, or on the
    boundary of the grid (the first or last row or column). Given a square at
    location (r0, c0) in the grid and a color, color the border of the
    connected component of that square with the given color, and return the
    final grid.

    Example 1:
    Input: grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3
    Output: [[3, 3], [3, 2]]

    Example 2:
    Input: grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3
    Output: [[1, 3, 3], [2, 3, 3]]

    Example 3:
    Input: grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2
    Output: [[2, 2, 2], [2, 1, 2], [2, 2, 2]]

    Note:
    * 1 <= grid.length <= 50
    * 1 <= grid[0].length <= 50
    * 1 <= grid[i][j] <= 1000
    * 0 <= r0 < grid.length
    * 0 <= c0 < grid[0].length
    * 1 <= color <= 1000"""

    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        orig = grid[r0][c0]
        seen = {(r0, c0)}
        stack = [(r0, c0)]
        while stack:
            i, j = stack.pop()
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if (ii, jj) not in seen:
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == orig:
                        stack.append((ii, jj))
                        seen.add((ii, jj))
                    else: grid[i][j] = color
        return grid


    """1035. Uncrossed Lines (Medium)
    We write the integers of A and B (in the order they are given) on two
    separate horizontal lines. Now, we may draw connecting lines: a straight
    line connecting two numbers A[i] and B[j] such that:
    * A[i] == B[j];
    * The line we draw does not intersect any other connecting (non-horizontal)
      line.
    Note that a connecting lines cannot intersect even at the endpoints: each
    number can only belong to one connecting line. Return the maximum number of
    connecting lines we can draw in this way.

    Example 1:
    Input: A = [1,4,2], B = [1,2,4]
    Output: 2
    Explanation: We can draw 2 uncrossed lines as in the diagram. We cannot draw
                 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will
                 intersect the line from A[2]=2 to B[1]=2.

    Example 2:
    Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2]
    Output: 3

    Example 3:
    Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1]
    Output: 2

    Note:
    * 1 <= A.length <= 500
    * 1 <= B.length <= 500
    * 1 <= A[i], B[i] <= 2000"""

    def maxUncrossedLines(self, A: List[int], B: List[int]) -> int:

        @cache
        def fn(i, j):
            """Return maximum uncrossed lines of A[i:] and B[j:]."""
            if i == len(A) or j == len(B): return 0
            if A[i] == B[j]: return 1 + fn(i+1, j+1)
            return max(fn(i+1, j), fn(i, j+1))

        return fn(0, 0)


    """1036. Escape a Large Maze (Hard)
    There is a 1 million by 1 million grid on an XY-plane, and the coordinates
    of each grid square are (x, y). We start at the source = [sx, sy] square
    and want to reach the target = [tx, ty] square. There is also an array of
    blocked squares, where each blocked[i] = [xi, yi] represents a blocked
    square with coordinates (xi, yi). Each move, we can walk one square north,
    east, south, or west if the square is not in the array of blocked squares.
    We are also not allowed to walk outside of the grid. Return true if and
    only if it is possible to reach the target square from the source square
    through a sequence of valid moves.

    Example 1:
    Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
    Output: false
    Explanation: The target square is inaccessible starting from the source
                 square because we cannot move. We cannot move north or east
                 because those squares are blocked. We cannot move south or
                 west because we cannot go outside of the grid.

    Example 2:
    Input: blocked = [], source = [0,0], target = [999999,999999]
    Output: true
    Explanation: Because there are no blocked cells, it is possible to reach
                 the target square.

    Constraints:
    * 0 <= blocked.length <= 200
    * blocked[i].length == 2
    * 0 <= xi, yi < 10^6
    * source.length == target.length == 2
    * 0 <= sx, sy, tx, ty < 10^6
    * source != target
    * It is guaranteed that source and target are not blocked."""

    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        blocked = set(map(tuple, blocked))

        def dfs(sx, sy, tx, ty):
            """Return True if (x, y) is not looped from (tx, ty)."""
            seen = {(sx, sy)}
            stack = [(sx, sy)]
            while stack:
                x, y = stack.pop()
                if abs(x - sx) + abs(y - sy) > 200 or (x, y) == (tx, ty): return True
                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y):
                    if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen:
                        seen.add((xx, yy))
                        stack.append((xx, yy))
            return False

        return dfs(*source, *target) and dfs(*target, *source)


    """1038. Binary Search Tree to Greater Sum Tree (Medium)
    Given the root of a Binary Search Tree (BST), convert it to a Greater Tree
    such that every key of the original BST is changed to the original key plus
    sum of all keys greater than the original key in BST. As a reminder, a
    binary search tree is a tree that satisfies these constraints:
    * The left subtree of a node contains only nodes with keys less than the node's key.
    * The right subtree of a node contains only nodes with keys greater than the node's key.
    * Both the left and right subtrees must also be binary search trees.
    Note: This question is the same as 538: https://leetcode.com/problems/convert-bst-to-greater-tree/

    Example 1:
    Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
    Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

    Example 2:
    Input: root = [0,null,1]
    Output: [1,null,1]

    Example 3:
    Input: root = [1,0,2]
    Output: [3,3,2]

    Example 4:
    Input: root = [3,2,4,1]
    Output: [7,9,4,10]

    Constraints:
    * The number of nodes in the tree is in the range [1, 100].
    * 0 <= Node.val <= 100
    * All the values in the tree are unique.
    * root is guaranteed to be a valid binary search tree."""

    def bstToGst(self, root: TreeNode) -> TreeNode:
        prefix = 0
        node = root
        stack = []
        while node or stack:
            if node:
                stack.append(node)
                node = node.right
            else:
                node = stack.pop()
                node.val = prefix = node.val + prefix
                node = node.left
        return root


    """1040. Moving Stones Until Consecutive II (Medium)
    On an infinite number line, the position of the i-th stone is given by
    stones[i]. Call a stone an endpoint stone if it has the smallest or largest
    position. Each turn, you pick up an endpoint stone and move it to an
    unoccupied position so that it is no longer an endpoint stone. In particular,
    if the stones are at say, stones = [1,2,5], you cannot move the endpoint
    stone at position 5, since moving it to any position (such as 0, or 3) will
    still keep that stone as an endpoint stone. The game ends when you cannot
    make any more moves, ie. the stones are in consecutive positions. When the
    game ends, what is the minimum and maximum number of moves that you could
    have made?  Return the answer as an length 2 array:
    answer = [minimum_moves, maximum_moves]

    Example 1:
    Input: [7,4,9]
    Output: [1,2]
    Explanation: We can move 4 -> 8 for one move to finish the game. Or, we can
                 move 9 -> 5, 4 -> 6 for two moves to finish the game.

    Example 2:
    Input: [6,5,4,3,10]
    Output: [2,3]
    Explanation: We can move 3 -> 8 then 10 -> 7 to finish the game. Or, we can
                 move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game. Notice we
                 cannot move 10 -> 2 to finish the game, because that would be
                 an illegal move.

    Example 3:
    Input: [100,101,104,102,103]
    Output: [0,0]

    Note:
    * 3 <= stones.length <= 10^4
    * 1 <= stones[i] <= 10^9
    * stones[i] have distinct values."""

    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        high = max(stones[-1] - stones[1], stones[-2] - stones[0]) - (len(stones) - 2)

        ii, low = 0, inf
        for i in range(len(stones)):
            while stones[i] - stones[ii] >= len(stones): ii += 1
            if i - ii + 1 == stones[i] - stones[ii] + 1 == len(stones) - 1: low = min(low, 2)
            else: low = min(low, len(stones) - (i - ii + 1))
        return [low, high]


    """1041. Robot Bounded In Circle (Medium)
    On an infinite plane, a robot initially stands at (0, 0) and faces north.
    The robot can receive one of three instructions:
    * "G": go straight 1 unit;
    * "L": turn 90 degrees to the left;
    * "R": turn 90 degress to the right.
    The robot performs the instructions given in order, and repeats them
    forever. Return true if and only if there exists a circle in the plane such
    that the robot never leaves the circle.

    Example 1:
    Input: "GGLLGG"
    Output: true
    Explanation: The robot moves from (0,0) to (0,2), turns 180 degrees, and
                 then returns to (0,0). When repeating these instructions, the
                 robot remains in the circle of radius 2 centered at the origin.

    Example 2:
    Input: "GG"
    Output: false
    Explanation: The robot moves north indefinitely.

    Example 3:
    Input: "GL"
    Output: true
    Explanation: The robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...

    Note:
    * 1 <= instructions.length <= 100
    * instructions[i] is in {'G', 'L', 'R'}"""

    def isRobotBounded(self, instructions: str) -> bool:
        x = y = 0
        dx, dy = 0, 1
        for ch in instructions:
            if ch == "G": x, y = x+dx, y+dy
            elif ch == "L": dx, dy = -dy, dx
            else: dx, dy = dy, -dx
        return x == y == 0 or (dx, dy) != (0, 1)


    """1042. Flower Planting With No Adjacent (Medium)
    You have n gardens, labeled from 1 to n, and an array paths where
    paths[i] = [xi, yi] describes a bidirectional path between garden xi to
    garden yi. In each garden, you want to plant one of 4 types of flowers. All
    gardens have at most 3 paths coming into or leaving it. Your task is to
    choose a flower type for each garden such that, for any two gardens
    connected by a path, they have different types of flowers. Return any such
    a choice as an array answer, where answer[i] is the type of flower planted
    in the (i+1)th garden. The flower types are denoted 1, 2, 3, or 4. It is
    guaranteed an answer exists.

    Example 1:
    Input: n = 3, paths = [[1,2],[2,3],[3,1]]
    Output: [1,2,3]
    Explanation:
    Gardens 1 and 2 have different types.
    Gardens 2 and 3 have different types.
    Gardens 3 and 1 have different types.
    Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1].

    Example 2:
    Input: n = 4, paths = [[1,2],[3,4]]
    Output: [1,2,1,2]

    Example 3:
    Input: n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
    Output: [1,2,3,4]

    Constraints:
    * 1 <= n <= 10^4
    * 0 <= paths.length <= 2 * 10^4
    * paths[i].length == 2
    * 1 <= xi, yi <= n
    * xi != yi
    * Every garden has at most 3 paths coming into or leaving it."""

    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:
        graph = {} # graph as adjacency list
        for u, v in paths:
            graph.setdefault(u-1, []).append(v-1)
            graph.setdefault(v-1, []).append(u-1)

        ans = [0]*n
        for i in range(n):
            ans[i] = ({1,2,3,4} - {ans[ii] for ii in graph.get(i, [])}).pop()
        return ans


    """1043. Partition Array for Maximum Sum (Medium)
    Given an integer array arr, you should partition the array into (contiguous)
    subarrays of length at most k. After partitioning, each subarray has their
    values changed to become the maximum value of that subarray. Return the
    largest sum of the given array after partitioning.

    Example 1:
    Input: arr = [1,15,7,9,2,5,10], k = 3
    Output: 84
    Explanation: arr becomes [15,15,15,9,10,10,10]

    Example 2:
    Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
    Output: 83

    Example 3:
    Input: arr = [1], k = 1
    Output: 1

    Constraints:
    * 1 <= arr.length <= 500
    * 0 <= arr[i] <= 10^9
    * 1 <= k <= arr.length"""

    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:

        @cache
        def fn(i):
            """Return maximum sum of arr[:i]."""
            if i == 0: return 0 # boundary condition
            ans = 0
            for kk in range(1, min(i, k)+1):
                ans = max(ans, fn(i-kk) + max(arr[ii] for ii in range(i-kk, i)) * kk)
            return ans

        return fn(len(arr))


    """1044. Longest Duplicate Substring (Hard)
    Given a string s, consider all duplicated substrings: (contiguous)
    substrings of s that occur 2 or more times. The occurrences may overlap.
    Return any duplicated substring that has the longest possible length. If s
    does not have a duplicated substring, the answer is "".

    Example 1:
    Input: s = "banana"
    Output: "ana"

    Example 2:
    Input: s = "abcd"
    Output: ""

    Constraints:
    * 2 <= s.length <= 3 * 10^4
    * s consists of lowercase English letters."""

    def longestDupSubstring(self, s: str) -> str:
        mod = 1_000_000_007

        def fn(k):
            """Return duplicated substring of length k."""
            p = pow(26, k, mod)
            hs = 0
            seen = {}
            for i, ch in enumerate(s):
                hs = (26*hs + ord(ch) - 97) % mod
                if i >= k: hs = (hs - (ord(s[i-k])-97)*p) % mod # rolling hash
                if i+1 >= k:
                    if hs in seen and s[i+1-k:i+1] in seen[hs]: return s[i+1-k:i+1] # resolve hash collision
                    seen.setdefault(hs, set()).add(s[i+1-k:i+1])
            return ""

        lo, hi = 0, len(s)-1
        while lo < hi:
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid - 1
        return fn(lo)


    """1046. Last Stone Weight (Easy)
    You are given an array of integers stones where stones[i] is the weight of
    the ith stone. We are playing a game with the stones. On each turn, we
    choose the heaviest two stones and smash them together. Suppose the
    heaviest two stones have weights x and y with x <= y. The result of this
    smash is:
    * If x == y, both stones are destroyed, and
    * If x != y, the stone of weight x is destroyed, and the stone of weight y
      has new weight y - x.
    At the end of the game, there is at most one stone left. Return the weight
    of the last remaining stone. If there are no stones left, return 0.

    Example 1:
    Input: stones = [2,7,4,1,8,1]
    Output: 1
    Explanation: - We combine 7 and 8 to get 1 so the array converts to
                   [2,4,1,1,1] then,
                 - we combine 2 and 4 to get 2 so the array converts to
                   [2,1,1,1] then,
                 - we combine 2 and 1 to get 1 so the array converts to
                   [1,1,1] then,
                 - we combine 1 and 1 to get 0 so the array converts to [1]
                   then that's the value of the last stone.

    Example 2:
    Input: stones = [1]
    Output: 1

    Constraints:
    * 1 <= stones.length <= 30
    * 1 <= stones[i] <= 1000"""

    def lastStoneWeight(self, stones: List[int]) -> int:
        pq = [-x for x in stones]
        heapify(pq)
        while len(pq) > 1:
            y = -heappop(pq)
            x = -heappop(pq)
            if x < y: heappush(pq, x-y)
        return -pq[0] if pq else 0


    """1047. Remove All Adjacent Duplicates In String (Easy)
    You are given a string s consisting of lowercase English letters. A
    duplicate removal consists of choosing two adjacent and equal letters and
    removing them. We repeatedly make duplicate removals on s until we no
    longer can. Return the final string after all such duplicate removals have
    been made. It can be proven that the answer is unique.

    Example 1:
    Input: s = "abbaca"
    Output: "ca"
    Explanation: For example, in "abbaca" we could remove "bb" since the
                 letters are adjacent and equal, and this is the only possible
                 move.  The result of this move is that the string is "aaca",
                 of which only "aa" is possible, so the final string is "ca".

    Example 2:
    Input: s = "azxxzy"
    Output: "ay"

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters."""

    def removeDuplicates(self, s: str) -> str:
        stack = []
        for ch in s:
            if stack and stack[-1] == ch: stack.pop()
            else: stack.append(ch)
        return "".join(stack)


    """1048. Longest String Chain (Medium)
    Given a list of words, each word consists of English lowercase letters.
    Let's say word1 is a predecessor of word2 if and only if we can add exactly
    one letter anywhere in word1 to make it equal to word2.  For example, "abc"
    is a predecessor of "abac". A word chain is a sequence of words
    [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of
    word_2, word_2 is a predecessor of word_3, and so on. Return the longest
    possible length of a word chain with words chosen from the given list of
    words.

    Example 1:
    Input: words = ["a","b","ba","bca","bda","bdca"]
    Output: 4
    Explanation: One of the longest word chain is "a","ba","bda","bdca".

    Example 2:
    Input: words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
    Output: 5

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 16
    * words[i] only consists of English lowercase letters."""

    def longestStrChain(self, words: List[str]) -> int:
        seen = {}
        for word in sorted(words, key=len):
            seen[word] = 1
            for i in range(len(word)):
                key = word[:i] + word[i+1:]
                if key in seen:
                    seen[word] = max(seen[word], 1 + seen[key])
        return max(seen.values())


    """1051. Height Checker (Easy)
    A school is trying to take an annual photo of all the students. The students
    are asked to stand in a single file line in non-decreasing order by height.
    Let this ordering be represented by the integer array expected where
    expected[i] is the expected height of the ith student in line. You are given
    an integer array heights representing the current order that the students
    are standing in. Each heights[i] is the height of the ith student in line
    (0-indexed). Return the number of indices where heights[i] != expected[i].

    Example 1:
    Input: heights = [1,1,4,2,1,3]
    Output: 3
    Explanation: heights:  [1,1,4,2,1,3]
                 expected: [1,1,1,2,3,4]
                 Indices 2, 4, and 5 do not match.

    Example 2:
    Input: heights = [5,1,2,3,4]
    Output: 5
    Explanation: heights:  [5,1,2,3,4]
                 expected: [1,2,3,4,5]
                 All indices do not match.

    Example 3:
    Input: heights = [1,2,3,4,5]
    Output: 0
    Explanation: heights:  [1,2,3,4,5]
                 expected: [1,2,3,4,5]
                 All indices match.

    Constraints:
    * 1 <= heights.length <= 100
    * 1 <= heights[i] <= 100"""

    def heightChecker(self, heights: List[int]) -> int:
        freq = [0]*101
        for x in heights: freq[x] += 1
        ans = v = 0
        for x in heights:
            while freq[v] == 0: v += 1
            if x != v: ans += 1
            freq[v] -= 1
        return ans


    """1052. Grumpy Bookstore Owner (Medium)
    Today, the bookstore owner has a store open for customers.length minutes.
    Every minute, some number of customers (customers[i]) enter the store, and
    all those customers leave after the end of that minute. On some minutes,
    the bookstore owner is grumpy.  If the bookstore owner is grumpy on the
    i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.  When the bookstore
    owner is grumpy, the customers of that minute are not satisfied, otherwise
    they are satisfied. The bookstore owner knows a secret technique to keep
    themselves not grumpy for X minutes straight, but can only use it once.
    Return the maximum number of customers that can be satisfied throughout the
    day.

    Example 1:
    Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
    Output: 16
    Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes.
    The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.

    Note:
    * 1 <= X <= customers.length == grumpy.length <= 20000
    * 0 <= customers[i] <= 1000
    * 0 <= grumpy[i] <= 1"""

    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
        ans = val = ii = most = 0
        for i in range(len(customers)):
            if grumpy[i]: val += customers[i]
            else: ans += customers[i]
            if ii == i-minutes:
                if grumpy[ii]: val -= customers[ii]
                ii += 1
            most = max(most, val)
        return ans + most


    """1054. Distant Barcodes (Medium)
    In a warehouse, there is a row of barcodes, where the ith barcode is
    barcodes[i]. Rearrange the barcodes so that no two adjacent barcodes are
    equal. You may return any answer, and it is guaranteed an answer exists.

    Example 1:
    Input: barcodes = [1,1,1,2,2,2]
    Output: [2,1,2,1,2,1]

    Example 2:
    Input: barcodes = [1,1,1,1,2,2,3,3]
    Output: [1,3,1,3,1,2,1,2]

    Constraints:
    * 1 <= barcodes.length <= 10000
    * 1 <= barcodes[i] <= 10000"""

    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:
        freq = {}
        for x in barcodes: freq[x] = 1 + freq.get(x, 0)

        ans, i = [None] * len(barcodes), 0
        for k, v in sorted(freq.items(), key=lambda x: x[1], reverse=True):
            for _ in range(v):
                ans[i] = k
                i = i+2 if i+2 < len(ans) else 1
        return ans


    """1055. Shortest Way to Form String (Medium)
    A subsequence of a string is a new string that is formed from the original
    string by deleting some (can be none) of the characters without disturbing
    the relative positions of the remaining characters. (i.e., "ace" is a
    subsequence of "abcde" while "aec" is not). Given two strings source and
    target, return the minimum number of subsequences of source such that their
    concatenation equals target. If the task is impossible, return -1.

    Example 1:
    Input: source = "abc", target = "abcbc"
    Output: 2
    Explanation: The target "abcbc" can be formed by "abc" and "bc", which are
                 subsequences of source "abc".

    Example 2:
    Input: source = "abc", target = "acdbc"
    Output: -1
    Explanation: The target string cannot be constructed from the subsequences
                 of source string due to the character "d" in target string.

    Example 3:
    Input: source = "xyz", target = "xzyxz"
    Output: 3
    Explanation: The target string can be constructed as follows
                 "xz" + "y" + "xz".

    Constraints:
    * 1 <= source.length, target.length <= 1000
    * source and target consist of lowercase English letters."""

    def shortestWay(self, source: str, target: str) -> int:
        locs = {}
        for i, x in enumerate(source):
            locs.setdefault(x, []).append(i)

        ans = i = 0
        for x in target:
            if x not in locs: return -1
            k = bisect_left(locs[x], i)
            if k == len(locs[x]):
                k = 0
                ans += 1
            i = locs[x][k] + 1
        return ans + 1


    """1056. Confusing Number (Easy)
    Given a number N, return true if and only if it is a confusing number,
    which satisfies the following condition:
    We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9
    are rotated 180 degrees, they become 0, 1, 9, 8, 6 respectively. When 2, 3,
    4, 5 and 7 are rotated 180 degrees, they become invalid. A confusing number
    is a number that when rotated 180 degrees becomes a different number with
    each digit valid.

    Example 1:
    Input: 6
    Output: true
    Explanation: We get 9 after rotating 6, 9 is a valid number and 9!=6.

    Example 2:
    Input: 89
    Output: true
    Explanation: We get 68 after rotating 89, 86 is a valid number and 86!=89.

    Example 3:
    Input: 11
    Output: false
    Explanation: We get 11 after rotating 11, 11 is a valid number but the
                 value remains the same, thus 11 is not a confusing number.

    Example 4:
    Input: 25
    Output: false
    Explanation: We get an invalid number after rotating 25.

    Note:
    * 0 <= N <= 10^9
    * After the rotation we can ignore leading zeros, for example if after
      rotation we have 0008 then this number is considered as just 8."""

    def confusingNumber(self, N: int) -> bool:
        mp = {0:0, 1:1, 6:9, 8:8, 9:6}
        n, nn = N, 0
        while n:
            n, r = divmod(n, 10)
            if r not in mp: return False
            nn = 10*nn + mp[r]
        return nn != N


    """1057. Campus Bikes (Medium)
    On a campus represented on the X-Y plane, there are n workers and m bikes,
    with n <= m. You are given an array workers of length n where
    workers[i] = [xi, yi] is the position of the ith worker. You are also given
    an array bikes of length m where bikes[j] = [xj, yj] is the position of the
    jth bike. All the given positions are unique. Assign a bike to each worker.
    Among the available bikes and workers, we choose the (workeri, bikej) pair
    with the shortest Manhattan distance between each other and assign the bike
    to that worker. If there are multiple (workeri, bikej) pairs with the same
    shortest Manhattan distance, we choose the pair with the smallest worker
    index. If there are multiple ways to do that, we choose the pair with the
    smallest bike index. Repeat this process until there are no available
    workers. Return an array answer of length n, where answer[i] is the index
    (0-indexed) of the bike that the ith worker is assigned to. The Manhattan
    distance between two points p1 and p2 is
    Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.

    Example 1:
    Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
    Output: [1,0]
    Explanation: Worker 1 grabs Bike 0 as they are closest (without ties), and
                 Worker 0 is assigned Bike 1. So the output is [1, 0].

    Example 2:
    Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
    Output: [0,2,1]
    Explanation: Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share
                 the same distance to Bike 2, thus Worker 1 is assigned to Bike
                 2, and Worker 2 will take Bike 1. So the output is [0,2,1].

    Constraints:
    * n == workers.length
    * m == bikes.length
    * 1 <= n <= m <= 1000
    * workers[i].length == bikes[j].length == 2
    * 0 <= xi, yi < 1000
    * 0 <= xj, yj < 1000
    * All worker and bike locations are unique."""

    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> List[int]:
        vals = []
        for i, (x, y) in enumerate(workers):
            for j, (xx, yy) in enumerate(bikes):
                vals.append((abs(x - xx) + abs(y - yy), i, j))

        ans = [-1] * len(workers)
        seen = [False] * len(bikes)
        for _, i, j in sorted(vals):
            if ans[i] == -1 and not seen[j]:
                ans[i] = j
                seen[j] = True
        return ans


    """1058. Minimize Rounding Error to Meet Target (Medium)
    Given an array of prices [p1,p2...,pn] and a target, round each price pi to
    Roundi(pi) so that the rounded array [Round1(p1),Round2(p2)...,Roundn(pn)]
    sums to the given target. Each operation Roundi(pi) could be either
    Floor(pi) or Ceil(pi). Return the string "-1" if the rounded array is
    impossible to sum to target. Otherwise, return the smallest rounding error,
    which is defined as Σ |Roundi(pi) - (pi)| for i from 1 to n, as a string
    with three places after the decimal.

    Example 1:
    Input: prices = ["0.700","2.800","4.900"], target = 8
    Output: "1.000"
    Explanation: Use Floor, Ceil and Ceil operations to get
                 (0.7 - 0) + (3 - 2.8) + (5 - 4.9) = 0.7 + 0.2 + 0.1 = 1.0 .

    Example 2:
    Input: prices = ["1.500","2.500","3.500"], target = 10
    Output: "-1"
    Explanation: It is impossible to meet the target.

    Example 3:
    Input: prices = ["1.500","2.500","3.500"], target = 9
    Output: "1.500"

    Constraints:
    * 1 <= prices.length <= 500
    * Each string prices[i] represents a real number in the range [0.0, 1000.0]
      and has exactly 3 decimal places.
    * 0 <= target <= 10^6"""

    def minimizeError(self, prices: List[str], target: int) -> str:
        err = []
        lo = hi = 0
        for x in prices:
            x = float(x)
            lo += floor(x)
            hi += ceil(x)
            if floor(x) < x < ceil(x): err.append(x - floor(x))
        if not lo <= target <= hi: return "-1" # impossible

        err.sort()
        k = hi - target
        return f"{len(err)-k+sum(err[:k])-sum(err[k:]):.3f}"


    """1059. All Paths from Source Lead to Destination (Medium)
    Given the edges of a directed graph where edges[i] = [ai, bi] indicates
    there is an edge between nodes ai and bi, and two nodes source and
    destination of this graph, determine whether or not all paths starting from
    source eventually, end at destination, that is:
    * At least one path exists from the source node to the destination node
    * If a path exists from the source node to a node with no outgoing edges,
      then that node is equal to destination.
    * The number of possible paths from source to destination is a finite number.
    Return true if and only if all roads from source lead to destination.

    Example 1:
    Input: n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2
    Output: false
    Explanation: It is possible to reach and get stuck on both node 1 and node 2.

    Example 2:
    Input: n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3
    Output: false
    Explanation: We have two possibilities: to end at node 3, or to loop over
                 node 1 and node 2 indefinitely.

    Example 3:
    Input: n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3
    Output: true

    Example 4:
    Input: n = 3, edges = [[0,1],[1,1],[1,2]], source = 0, destination = 2
    Output: false
    Explanation: All paths from the source node end at the destination node,
                 but there are an infinite number of paths, such as 0-1-2,
                 0-1-1-2, 0-1-1-1-2, 0-1-1-1-1-2, and so on.

    Example 5:
    Input: n = 2, edges = [[0,1],[1,1]], source = 0, destination = 1
    Output: false
    Explanation: There is infinite self-loop at destination node.

    Constraints:
    * 1 <= n <= 10^4
    * 0 <= edges.length <= 10^4
    * edges.length == 2
    * 0 <= ai, bi <= n - 1
    * 0 <= source <= n - 1
    * 0 <= destination <= n - 1
    * The given graph may have self-loops and parallel edges."""

    def leadsToDestination(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        graph = {}
        for u, v in edges: graph.setdefault(u, []).append(v)

        def fn(x):
            """Return True if all paths starting from x lead to destination."""
            if x not in graph: return x == destination
            if color[x]: return color[x] == 1
            color[x] = -1
            for xx in graph[x]:
                if not fn(xx): return False
            color[x] = 1
            return True

        color = [0] * n
        return fn(source)


    """1060. Missing Element in Sorted Array (Medium)
    Given an integer array nums which is sorted in ascending order and all of
    its elements are unique and given also an integer k, return the kth missing
    number starting from the leftmost number of the array.

    Example 1:
    Input: nums = [4,7,9,10], k = 1
    Output: 5
    Explanation: The first missing number is 5.

    Example 2:
    Input: nums = [4,7,9,10], k = 3
    Output: 8
    Explanation: The missing numbers are [5,6,8,...], hence the third missing
                 number is 8.

    Example 3:
    Input: nums = [1,2,4], k = 3
    Output: 6
    Explanation: The missing numbers are [3,5,6,7,...], hence the third missing
                 number is 6.

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 1 <= nums[i] <= 10^7
    * nums is sorted in ascending order, and all the elements are unique.
    * 1 <= k <= 10^8

    Follow up: Can you find a logarithmic time complexity (i.e., O(log(n)))
               solution?"""

    def missingElement(self, nums: List[int], k: int) -> int:
        lo, hi = 0, len(nums)
        while lo < hi:
            mid = lo + hi >> 1
            if nums[mid] - nums[0] - mid < k: lo = mid + 1
            else: hi = mid
        return nums[0] + k + lo - 1


    """1061. Lexicographically Smallest Equivalent String (Medium)
    You are given two strings of the same length s1 and s2 and a string baseStr.
    We say s1[i] and s2[i] are equivalent characters.
    * For example, if s1 = "abc" and s2 = "cde", then we have 'a' == 'c',
      'b' == 'd', and 'c' == 'e'.
    Equivalent characters follow the usual rules of any equivalence relation:
    * Reflexivity: 'a' == 'a'.
    * Symmetry: 'a' == 'b' implies 'b' == 'a'.
    * Transitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.
    For example, given the equivalency information from s1 = "abc" and
    s2 = "cde", "acd" and "aab" are equivalent strings of baseStr = "eed", and
    "aab" is the lexicographically smallest equivalent string of baseStr.
    Return the lexicographically smallest equivalent string of baseStr by using
    the equivalency information from s1 and s2.

    Example 1:
    Input: s1 = "parker", s2 = "morris", baseStr = "parser"
    Output: "makkek"
    Explanation: Based on the equivalency information in s1 and s2, we can
                 group their characters as [m,p], [a,o], [k,r,s], [e,i]. The
                 characters in each group are equivalent and sorted in
                 lexicographical order. So the answer is "makkek".

    Example 2:
    Input: s1 = "hello", s2 = "world", baseStr = "hold"
    Output: "hdld"
    Explanation: Based on the equivalency information in s1 and s2, we can
                 group their characters as [h,w], [d,e,o], [l,r]. So only the
                 second letter 'o' in baseStr is changed to 'd', the answer is
                 "hdld".

    Example 3:
    Input: s1 = "leetcode", s2 = "programs", baseStr = "sourcecode"
    Output: "aauaaaaada"
    Explanation: We group the equivalent characters in s1 and s2 as
                 [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in
                 baseStr except 'u' and 'd' are transformed to 'a', the answer
                 is "aauaaaaada".

    Constraints:
    * 1 <= s1.length, s2.length, baseStr <= 1000
    * s1.length == s2.length
    * s1, s2, and baseStr consist of lowercase English letters.

class UnionFind:
    def __init__(self):
        self.parent = dict(zip(ascii_lowercase, ascii_lowercase))

    def find(self, p):
        if p != self.parent[p]:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        prt, qrt = self.find(p), self.find(q)
        if prt < qrt: prt, qrt = qrt, prt
        self.parent[prt] = qrt"""

    def smallestEquivalentString(self, s1: str, s2: str, baseStr: str) -> str:
        uf = UnionFind()
        for c1, c2 in zip(s1, s2): uf.union(c1, c2)
        return "".join(uf.find(ch) for ch in baseStr)


    """1062. Longest Repeating Substring (Medium)
    Given a string s, find out the length of the longest repeating substring(s).
    Return 0 if no repeating substring exists.

    Example 1:
    Input: s = "abcd"
    Output: 0
    Explanation: There is no repeating substring.

    Example 2:
    Input: s = "abbaba"
    Output: 2
    Explanation: The longest repeating substrings are "ab" and "ba", each of
                 which occurs twice.

    Example 3:
    Input: s = "aabcaabdaab"
    Output: 3
    Explanation: The longest repeating substring is "aab", which occurs 3 times.

    Example 4:
    Input: s = "aaaaa"
    Output: 4
    Explanation: The longest repeating substring is "aaaa", which occurs twice.

    Constraints:
    * The string s consists of only lowercase English letters from 'a' - 'z'.
    * 1 <= s.length <= 1500"""

    def longestRepeatingSubstring(self, s: str) -> int:
        MOD = 1_000_000_007

        fac = [1]
        prefix = [0]
        for ch in s:
            fac.append((fac[-1] * 26 % MOD))
            prefix.append((prefix[-1]*26 + ord(ch) - 97) % MOD)

        def fn(k):
            """Return True if a repeating substring of length k is found."""
            seen = set()
            for i in range(len(s)-k+1):
                val = (prefix[i+k] - prefix[i]*fac[k]) % MOD
                if val in seen: return True # rolling hash (ver. Monte Carlo)
                seen.add(val)
            return False

        # last-true binary search
        lo, hi = -1, len(s)-1
        while lo < hi:
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid - 1
        return lo


    """1063. Number of Valid Subarrays (Hard)
    Given an integer array nums, return the number of non-empty subarrays with
    the leftmost element of the subarray not larger than other elements in the
    subarray. A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1,4,2,5,3]
    Output: 11
    Explanation: There are 11 valid subarrays: [1],[4],[2],[5],[3],[1,4],[2,5],
                 [1,4,2],[2,5,3],[1,4,2,5],[1,4,2,5,3].

    Example 2:
    Input: nums = [3,2,1]
    Output: 3
    Explanation: The 3 valid subarrays are: [3],[2],[1].

    Example 3:
    Input: nums = [2,2,2]
    Output: 6
    Explanation: There are 6 valid subarrays: [2],[2],[2],[2,2],[2,2],[2,2,2].

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 0 <= nums[i] <= 10^5"""

    def validSubarrays(self, nums: List[int]) -> int:
        ans = 0
        stack = []
        for x in nums:
            while stack and stack[-1] > x: stack.pop()
            stack.append(x)
            ans += len(stack)
        return ans


    """1064. Fixed Point (Easy)
    Given an array of distinct integers arr, where arr is sorted in ascending
    order, return the smallest index i that satisfies arr[i] == i. If there is
    no such index, return -1.

    Example 1:
    Input: arr = [-10,-5,0,3,7]
    Output: 3
    Explanation: For the given array, arr[0] = -10, arr[1] = -5, arr[2] = 0,
                 arr[3] = 3, thus the output is 3.

    Example 2:
    Input: arr = [0,2,5,8,17]
    Output: 0
    Explanation: arr[0] = 0, thus the output is 0.

    Example 3:
    Input: arr = [-10,-5,3,4,7,9]
    Output: -1
    Explanation: There is no such i that arr[i] == i, thus the output is -1.

    Constraints:
    * 1 <= arr.length < 10^4
    * -10^9 <= arr[i] <= 10^9

    Follow up: The O(n) solution is very straightforward. Can we do better?"""

    def fixedPoint(self, arr: List[int]) -> int:
        lo, hi = 0, len(arr)-1
        while lo < hi:
            mid = lo + hi >> 1
            if arr[mid] - mid < 0: lo = mid + 1
            else: hi = mid
        return lo if arr[lo] == lo else -1


    """1065. Index Pairs of a String (Easy)
    Given a text string and words (a list of strings), return all index pairs
    [i, j] so that the substring text[i]...text[j] is in the list of words.

    Example 1:
    Input: text = "thestoryofleetcodeandme", words = ["story","fleet","leetcode"]
    Output: [[3,7],[9,13],[10,17]]

    Example 2:
    Input: text = "ababa", words = ["aba","ab"]
    Output: [[0,1],[0,2],[2,3],[2,4]]
    Explanation: Notice that matches can overlap, see "aba" is found in [0,2]
                 and [2,4].

    Note:
    * All strings contains only lowercase English letters.
    * It's guaranteed that all strings in words are different.
    * 1 <= text.length <= 100
    * 1 <= words.length <= 20
    * 1 <= words[i].length <= 50
    * Return the pairs [i,j] in sorted order (i.e. sort them by their first
      coordinate in case of ties sort them by their second coordinate)."""

    def indexPairs(self, text: str, words: List[str]) -> List[List[int]]:
        ans = []
        for word in words:
            k = -1
            while True:
                k = text.find(word, k+1)
                if k == -1: break
                ans.append([k, k+len(word)-1])
        return sorted(ans)


    """1066. Campus Bikes II (Medium)
    On a campus represented as a 2D grid, there are n workers and m bikes, with
    n <= m. Each worker and bike is a 2D coordinate on this grid. We assign one
    unique bike to each worker so that the sum of the Manhattan distances
    between each worker and their assigned bike is minimized. Return the
    minimum possible sum of Manhattan distances between each worker and their
    assigned bike. The Manhattan distance between two points p1 and p2 is
    Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.

    Example 1:
    Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
    Output: 6
    Explanation: We assign bike 0 to worker 0, bike 1 to worker 1. The
                 Manhattan distance of both assignments is 3, so the output is
                 6.

    Example 2:
    Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
    Output: 4
    Explanation: We first assign bike 0 to worker 0, then assign bike 1 to
                 worker 1 or worker 2, bike 2 to worker 2 or worker 1. Both
                 assignments lead to sum of the Manhattan distances as 4.

    Example 3:
    Input: workers = [[0,0],[1,0],[2,0],[3,0],[4,0]],
           bikes = [[0,999],[1,999],[2,999],[3,999],[4,999]]
    Output: 4995

    Constraints:
    * n == workers.length
    * m == bikes.length
    * 1 <= n <= m <= 10
    * workers[i].length == 2
    * bikes[i].length == 2
    * 0 <= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] < 1000
    * All the workers and the bikes locations are unique."""

    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> int:
        n, m = len(workers), len(bikes)

        @cache
        def fn(i, mask):
            """Return min Manhattan distance of assigning workers[i:] to available bikes."""
            if i == n: return 0
            ans = inf
            for j in range(m):
                if not mask & (1<<j):
                    ans = min(ans, abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]) + fn(i+1, mask ^ (1<<j)))
            return ans

        return fn(0, 0)


    """1071. Greatest Common Divisor of Strings (Easy)
    For two strings s and t, we say "t divides s" if and only if s = t + ... + t
    (i.e., t is concatenated with itself one or more times). Given two strings
    str1 and str2, return the largest string x such that x divides both str1
    and str2.

    Example 1:
    Input: str1 = "ABCABC", str2 = "ABC"
    Output: "ABC"

    Example 2:
    Input: str1 = "ABABAB", str2 = "ABAB"
    Output: "AB"

    Example 3:
    Input: str1 = "LEET", str2 = "CODE"
    Output: ""

    Constraints:
    * 1 <= str1.length, str2.length <= 1000
    * str1 and str2 consist of English uppercase letters."""

    def gcdOfStrings(self, str1: str, str2: str) -> str:
        if str1 + str2 != str2 + str1: return ""
        g = gcd(len(str1), len(str2))
        return str1[:g]


    """1072. Flip Columns For Maximum Number of Equal Rows (Medium)
    Given a matrix consisting of 0s and 1s, we may choose any number of columns
    in the matrix and flip every cell in that column.  Flipping a cell changes
    the value of that cell from 0 to 1 or from 1 to 0. Return the maximum
    number of rows that have all values equal after some number of flips.

    Example 1:
    Input: [[0,1],[1,1]]
    Output: 1
    Explanation: After flipping no values, 1 row has all values equal.

    Example 2:
    Input: [[0,1],[1,0]]
    Output: 2
    Explanation: After flipping values in the first column, both rows have
                 equal values.

    Example 3:
    Input: [[0,0,0],[0,0,1],[1,1,0]]
    Output: 2
    Explanation: After flipping values in the first two columns, the last two
                 rows have equal values.

    Note:
    * 1 <= matrix.length <= 300
    * 1 <= matrix[i].length <= 300
    * All matrix[i].length's are equal
    * matrix[i][j] is 0 or 1"""

    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions
        score = [0]*m

        for j in range(1, n):
            for i in range(m):
                score[i] *= 2
                if matrix[i][0] != matrix[i][j]: score[i] += 1

        freq = {}
        for x in score: freq[x] = 1 + freq.get(x, 0)
        return max(freq.values())


    """1073. Adding Two Negabinary Numbers (Medium)
    Given two numbers arr1 and arr2 in base -2, return the result of adding
    them together. Each number is given in array format:  as an array of 0s and
    1s, from most significant bit to least significant bit.  For example,
    arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A
    number arr in array, format is also guaranteed to have no leading zeros:
    either arr == [0] or arr[0] == 1. Return the result of adding arr1 and arr2
    in the same format: as an array of 0s and 1s with no leading zeros.

    Example 1:
    Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]
    Output: [1,0,0,0,0]
    Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.

    Example 2:
    Input: arr1 = [0], arr2 = [0]
    Output: [0]

    Example 3:
    Input: arr1 = [0], arr2 = [1]
    Output: [1]

    Constraints:
    * 1 <= arr1.length, arr2.length <= 1000
    * arr1[i] and arr2[i] are 0 or 1
    * arr1 and arr2 have no leading zeros"""

    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:
        ans = []
        carry, i1, i2 = 0, len(arr1), len(arr2)
        while i1 or i2 or carry:
            if i1: carry += arr1[(i1 := i1 - 1)]
            if i2: carry += arr2[(i2 := i2 - 1)]
            ans.append(carry & 1)
            carry = -(carry >> 1)
        while ans and not ans[-1]: ans.pop()
        return ans[::-1] or [0]


    """1074. Number of Submatrices That Sum to Target (Hard)
    Given a matrix and a target, return the number of non-empty submatrices
    that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells
    matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2. Two submatrices
    (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some
    coordinate that is different: for example, if x1 != x1'.

    Example 1:
    Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
    Output: 4
    Explanation: The four 1x1 submatrices that only contain 0.

    Example 2:
    Input: matrix = [[1,-1],[-1,1]], target = 0
    Output: 5
    Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.

    Example 3:
    Input: matrix = [[904]], target = 0
    Output: 0

    Constraints:
    * 1 <= matrix.length <= 100
    * 1 <= matrix[0].length <= 100
    * -1000 <= matrix[i] <= 1000
    * -10^8 <= target <= 10^8"""

    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        ans = 0
        m, n = len(matrix), len(matrix[0]) # dimensions
        prefix = [[0]*(n+1) for _ in range(m+1)]

        for i in range(m):
            for j in range(n):
                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]

            for ii in range(i+1):
                freq = {0: 1}
                for j in range(n):
                    diff = prefix[i+1][j+1] - prefix[ii][j+1]
                    ans += freq.get(diff - target, 0)
                    freq[diff] = 1 + freq.get(diff, 0)
        return ans


    """1078. Occurrences After Bigram (Easy)
    Given two strings first and second, consider occurrences in some text of
    the form "first second third", where second comes immediately after first,
    and third comes immediately after second. Return an array of all the words
    third for each occurrence of "first second third".

    Example 1:
    Input: text = "alice is a good girl she is a good student", first = "a", second = "good"
    Output: ["girl","student"]

    Example 2:
    Input: text = "we will we will rock you", first = "we", second = "will"
    Output: ["we","rock"]

    Constraints:
    * 1 <= text.length <= 1000
    * text consists of lowercase English letters and spaces.
    * All the words in text a separated by a single space.
    * 1 <= first.length, second.length <= 10
    * first and second consist of lowercase English letters."""

    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        ans = []
        f0 = f1 = False
        for word in text.split():
            if f1: ans.append(word)
            f1 = f0 and word == second
            f0 = word == first
        return ans


    """1080. Insufficient Nodes in Root to Leaf Paths (Medium)
    Given the root of a binary tree, consider all root to leaf paths: paths
    from the root to any leaf.  (A leaf is a node with no children.) A node is
    insufficient if every such root to leaf path intersecting this node has sum
    strictly less than limit. Delete all insufficient nodes simultaneously, and
    return the root of the resulting binary tree.

    Example 1:
    Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1
    Output: [1,2,3,4,null,null,7,8,9,null,14]

    Example 2:
    Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22
    Output: [5,4,8,11,null,17,4,7,null,null,null,5]

    Example 3:
    Input: root = [1,2,-3,-5,null,4,null], limit = -1
    Output: [1,null,-3,4]

    Note:
    * The given tree will have between 1 and 5000 nodes.
    * -10^5 <= node.val <= 10^5
    * -10^9 <= limit <= 10^9"""

    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:

        def fn(node, x):
            """Return updated node."""
            if not node: return
            x -= node.val
            if node.left is node.right: return None if x > 0 else node # leaf
            node.left = fn(node.left, x)
            node.right = fn(node.right, x)
            return node if node.left or node.right else None

        return fn(root, limit)


    """1081. Smallest Subsequence of Distinct Characters (Medium)
    Return the lexicographically smallest subsequence of s that contains all
    the distinct characters of s exactly once. Note: This question is the same
    as 316: https://leetcode.com/problems/remove-duplicate-letters/

    Example 1:
    Input: s = "bcabc"
    Output: "abc"

    Example 2:
    Input: s = "cbacdcbc"
    Output: "acdb"

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of lowercase English letters."""

    def smallestSubsequence(self, s: str) -> str:
        loc = {x: i for i, x in enumerate(s)}
        stack = []
        for i, x in enumerate(s):
            if x not in stack:
                while stack and x < stack[-1] and i < loc[stack[-1]]: stack.pop()
                stack.append(x)
        return "".join(stack)


    """1085. Sum of Digits in the Minimum Number (Easy)
    Given an array A of positive integers, let S be the sum of the digits of
    the minimal element of A. Return 0 if S is odd, otherwise return 1.

    Example 1:
    Input: [34,23,1,24,75,33,54,8]
    Output: 0
    Explanation: The minimal element is 1, and the sum of those digits is S = 1
                 which is odd, so the answer is 0.

    Example 2:
    Input: [99,77,33,66,55]
    Output: 1
    Explanation: The minimal element is 33, and the sum of those digits is
                 S = 3 + 3 = 6 which is even, so the answer is 1.

    Constraints:
    * 1 <= A.length <= 100
    * 1 <= A[i] <= 100"""

    def sumOfDigits(self, A: List[int]) -> int:
        return 1 ^ 1&sum(int(x) for x in str(min(A)))


    """1086. High Five (Easy)
    Given a list of the scores of different students, items, where
    items[i] = [IDi, scorei] represents one score from a student with IDi,
    calculate each student's top five average. Return the answer as an array of
    pairs result, where result[j] = [IDj, topFiveAveragej] represents the
    student with IDj and their top five average. Sort result by IDj in
    increasing order. A student's top five average is calculated by taking the
    sum of their top five scores and dividing it by 5 using integer division.

    Example 1:
    Input: items = [[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]
    Output: [[1,87],[2,88]]
    Explanation:
    The student with ID = 1 got scores 91, 92, 60, 65, 87, and 100. Their top five average is (100 + 92 + 91 + 87 + 65) / 5 = 87.
    The student with ID = 2 got scores 93, 97, 77, 100, and 76. Their top five average is (100 + 97 + 93 + 77 + 76) / 5 = 88.6, but with integer division their average converts to 88.

    Example 2:
    Input: items = [[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100]]
    Output: [[1,100],[7,100]]

    Constraints:
    * 1 <= items.length <= 1000
    * items[i].length == 2
    * 1 <= IDi <= 1000
    * 0 <= scorei <= 100
    * For each IDi, there will be at least five scores."""

    def highFive(self, items: List[List[int]]) -> List[List[int]]:
        mp = {}
        for x, score in items:
            mp.setdefault(x, []).append(score)

        ans = []
        for x in mp:
            ans.append([x, sum(sorted(mp[x])[-5:])//5])
        return sorted(ans)


    """1087. Brace Expansion (Medium)
    You are given a string s representing a list of words. Each letter in the
    word has one or more options.
    * If there is one option, the letter is represented as is.
    * If there is more than one option, then curly braces delimit the options.
      For example, "{a,b,c}" represents options ["a", "b", "c"].
    For example, if s = "a{b,c}", the first character is always 'a', but the
    second character can be 'b' or 'c'. The original list is ["ab", "ac"].
    Return all words that can be formed in this manner, sorted in
    lexicographical order.

    Example 1:
    Input: s = "{a,b}c{d,e}f"
    Output: ["acdf","acef","bcdf","bcef"]

    Example 2:
    Input: s = "abcd"
    Output: ["abcd"]

    Constraints:
    * 1 <= s.length <= 50
    * s consists of curly brackets '{}', commas ',', and lowercase English
      letters.
    * s is guaranteed to be a valid input.
    * There are no nested curly brackets.
    * All characters inside a pair of consecutive opening and ending curly
      brackets are different."""

    def expand(self, s: str) -> List[str]:
        ans = [""]
        i = 0
        while i < len(s):
            if s[i] == "{":
                ii = i+1
                while s[ii] != "}": ii += 1
                ans = [xx + x for xx in ans for x in s[i+1:ii].split(",")]
                i = ii + 1
            else:
                ans = [x + s[i] for x in ans]
                i += 1
        return sorted(ans)


    """1089. Duplicate Zeros (Easy)
    Given a fixed length array arr of integers, duplicate each occurrence of
    zero, shifting the remaining elements to the right. Note that elements
    beyond the length of the original array are not written. Do the above
    modifications to the input array in place, do not return anything from your
    function.

    Example 1:
    Input: [1,0,2,3,0,4,5,0]
    Output: null
    Explanation: After calling your function, the input array is modified to:
                 [1,0,0,2,3,0,0,4]

    Example 2:
    Input: [1,2,3]
    Output: null
    Explanation: After calling your function, the input array is modified to:
                 [1,2,3]

    Note:
    * 1 <= arr.length <= 10000
    * 0 <= arr[i] <= 9"""

    def duplicateZeros(self, arr: List[int]) -> None:
        """
        Do not return anything, modify arr in-place instead.
        """
        zeros = arr.count(0)
        for i in reversed(range(len(arr))):
            if i + zeros < len(arr):
                arr[i+zeros] = arr[i]
            if arr[i] == 0:
                zeros -= 1
                if i + zeros < len(arr):
                    arr[i+zeros] = arr[i]


    """1090. Largest Values From Labels (Medium)
    We have a set of items: the i-th item has value values[i] and label labels[i].
    Then, we choose a subset S of these items, such that:
    * |S| <= num_wanted
    * For every label L, the number of items in S with label L is <= use_limit.
    Return the largest possible sum of the subset S.

    Example 1:
    Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1
    Output: 9
    Explanation: The subset chosen is the first, third, and fifth item.

    Example 2:
    Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2
    Output: 12
    Explanation: The subset chosen is the first, second, and third item.

    Example 3:
    Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1
    Output: 16
    Explanation: The subset chosen is the first and fourth item.

    Example 4:
    Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2
    Output: 24
    Explanation: The subset chosen is the first, second, and fourth item.

    Note:
    * 1 <= values.length == labels.length <= 20000
    * 0 <= values[i], labels[i] <= 20000
    * 1 <= num_wanted, use_limit <= values.length"""

    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:
        ans = 0
        freq = {}
        for value, label in sorted(zip(values, labels), reverse=True):
            if freq.get(label, 0) < use_limit:
                ans += value
                num_wanted -= 1
                if not num_wanted: break
                freq[label] = 1 + freq.get(label, 0)
        return ans


    """1091. Shortest Path in Binary Matrix (Medium)
    In an N by N square grid, each cell is either empty (0) or blocked (1). A
    clear path from top-left to bottom-right has length k if and only if it is
    composed of cells C_1, C_2, ..., C_k such that:
    * Adjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they
      are different and share an edge or corner)
    * C_1 is at location (0, 0) (ie. has value grid[0][0])
    * C_k is at location (N-1, N-1) (ie. has value grid[N-1][N-1])
    * If C_i is located at (r, c), then grid[r][c] is empty (ie. grid[r][c] == 0).
    Return the length of the shortest such clear path from top-left to bottom-
    right.  If such a path does not exist, return -1.

    Example 1:
    Input: [[0,1],[1,0]]
    Output: 2

    Example 2:
    Input: [[0,0,0],[1,1,0],[1,1,0]]
    Output: 4

    Note:
    * 1 <= grid.length == grid[0].length <= 100
    * grid[r][c] is 0 or 1"""

    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        n = len(grid)
        if grid[0][0] == 0:
            ans = 0
            grid[0][0] = 1
            queue = deque([(0, 0)])
            while queue:
                ans += 1
                for _ in range(len(queue)):
                    i, j = queue.popleft()
                    if i == j == n-1: return ans
                    for ii in range(i-1, i+2):
                        for jj in range(j-1, j+2):
                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] == 0:
                                grid[ii][jj] = 1
                                queue.append((ii, jj))
        return -1


    """1092. Shortest Common Supersequence (Hard)
    Given two strings str1 and str2, return the shortest string that has both
    str1 and str2 as subsequences.  If multiple answers exist, you may return
    any of them. (A string S is a subsequence of string T if deleting some
    number of characters from T (possibly 0, and the characters are chosen
    anywhere from T) results in the string S.)

    Example 1:
    Input: str1 = "abac", str2 = "cab"
    Output: "cabac"
    Explanation:
    str1 = "abac" is a subsequence of "cabac" because we can delete the first "c".
    str2 = "cab" is a subsequence of "cabac" because we can delete the last "ac".
    The answer provided is the shortest such string that satisfies these properties.

    Note:
    * 1 <= str1.length, str2.length <= 1000
    * str1 and str2 consist of lowercase English letters."""

    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:

        @cache
        def fn(i, j):
            """Return min length of common supersequence of str1[i:] and str2[j:]."""
            if i == len(str1): return len(str2)-j
            if j == len(str2): return len(str1)-i
            if str1[i] == str2[j]: return 1 + fn(i+1, j+1)
            return 1 + min(fn(i+1, j), fn(i, j+1))

        ans = []
        i = j = 0
        while i < len(str1) and j < len(str2):
            if str1[i] == str2[j]:
                ans.append(str1[i])
                i += 1
                j += 1
            elif fn(i+1, j) < fn(i, j+1):
                ans.append(str1[i])
                i += 1
            else:
                ans.append(str2[j])
                j += 1
        return "".join(ans) + str1[i:] + str2[j:]


    """1094. Car Pooling (Medium)
    There is a car with capacity empty seats. The vehicle only drives east (i.e.,
    it cannot turn around and drive west). You are given the integer capacity
    and an array trips where trip[i] = [numPassengersi, fromi, toi] indicates
    that the ith trip has numPassengersi passengers and the locations to pick
    them up and drop them off are fromi and toi respectively. The locations are
    given as the number of kilometers due east from the car's initial location.
    Return true if it is possible to pick up and drop off all passengers for
    all the given trips, or false otherwise.

    Example 1:
    Input: trips = [[2,1,5],[3,3,7]], capacity = 4
    Output: false

    Example 2:
    Input: trips = [[2,1,5],[3,3,7]], capacity = 5
    Output: true

    Constraints:
    * 1 <= trips.length <= 1000
    * trips[i].length == 3
    * 1 <= numPassengersi <= 100
    * 0 <= fromi < toi <= 1000
    * 1 <= capacity <= 10^5"""

    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        vals = []
        for n, start, end in trips:
            vals.append((start, n))
            vals.append((end, -n))
        for _, x in sorted(vals):
            capacity -= x
            if capacity < 0: return False
        return True


    """1095. Find in Mountain Array (Hard)
    (This problem is an interactive problem.)
    You may recall that an array A is a mountain array if and only if:
    * A.length >= 3
    * There exists some i with 0 < i < A.length - 1 such that:
      * A[0] < A[1] < ... A[i-1] < A[i]
      * A[i] > A[i+1] > ... > A[A.length - 1]
    Given a mountain array mountainArr, return the minimum index such that
    mountainArr.get(index) == target.  If such an index doesn't exist, return
    -1. You can't access the mountain array directly.  You may only access the
    array using a MountainArray interface:
    * MountainArray.get(k) returns the element of the array at index k (0-
      indexed).
    * MountainArray.length() returns the length of the array.
    Submissions making more than 100 calls to MountainArray.get will be judged
    Wrong Answer.  Also, any solutions that attempt to circumvent the judge
    will result in disqualification.

    Example 1:
    Input: array = [1,2,3,4,5,3,1], target = 3
    Output: 2
    Explanation: 3 exists in the array, at index=2 and index=5. Return the
                 minimum index, which is 2.

    Example 2:
    Input: array = [0,1,2,4,2,1], target = 3
    Output: -1
    Explanation: 3 does not exist in the array, so we return -1.

    Constraints:
    * 3 <= mountain_arr.length() <= 10000
    * 0 <= target <= 10^9
    * 0 <= mountain_arr.get(index) <= 10^9"""

    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:

        def fn(lo, hi, mult):
            """Return index of target between lo (inclusive) and hi (exlusive)."""
            while lo < hi:
                mid = lo + hi >> 1
                if mountain_arr.get(mid) == target: return mid
                elif mountain_arr.get(mid)*mult < target*mult: lo = mid + 1
                else: hi = mid
            return -1

        lo, hi = 0, mountain_arr.length()
        while lo < hi:
            mid = lo + hi >> 1
            if mid and mountain_arr.get(mid-1) < mountain_arr.get(mid): lo = mid + 1
            else: hi = mid
        if (x := fn(0, lo, 1)) != -1: return x
        if (x := fn(lo, mountain_arr.length(), -1)) != -1: return x
        return -1


    """1096. Brace Expansion II (Hard)
    Under a grammar given below, strings can represent a set of lowercase words.
    Let's use R(expr) to denote the set of words the expression represents.
    Grammar can best be understood through simple examples:
    * Single letters represent a singleton set containing that word.
      + R("a") = {"a"}
      + R("w") = {"w"}
    * When we take a comma delimited list of 2 or more expressions, we take the
      union of possibilities.
      + R("{a,b,c}") = {"a","b","c"}
      + R("{{a,b},{b,c}}") = {"a","b","c"} (notice the final set only contains
        each word at most once)
    * When we concatenate two expressions, we take the set of possible
      concatenations between two words where the first word comes from the
      first expression and the second word comes from the second expression.
      + R("{a,b}{c,d}") = {"ac","ad","bc","bd"}
      + R("a{b,c}{d,e}f{g,h}") = {"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"}
    Formally, the 3 rules for our grammar:
    * For every lowercase letter x, we have R(x) = {x}
    * For expressions e_1, e_2, ... , e_k with k >= 2, we have
      R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ...
    * For expressions e_1 and e_2, we have R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)},
      where + denotes concatenation, and × denotes the cartesian product.
    Given an expression representing a set of words under the given grammar,
    return the sorted list of words that the expression represents.

    Example 1:
    Input: "{a,b}{c,{d,e}}"
    Output: ["ac","ad","ae","bc","bd","be"]

    Example 2:
    Input: "{{a,z},a{b,c},{ab,z}}"
    Output: ["a","ab","ac","z"]
    Explanation: Each distinct word is written only once in the final answer.

    Constraints:
    * 1 <= expression.length <= 60
    * expression[i] consists of '{', '}', ','or lowercase English letters.
    * The given expression represents a set of words based on the grammar given
      in the description."""

    def braceExpansionII(self, expression: str) -> List[str]:
        mp, stack = {}, []
        for i, x in enumerate(expression):
            if x == "{": stack.append(i)
            elif x == "}": mp[stack.pop()] = i

        def fn(lo, hi):
            """Return expanded outcome of expression[lo:hi]."""
            ans = [[""]]
            if lo+1 < hi:
                i = lo
                while i < hi:
                    if expression[i] == ",": ans.append([""])
                    else:
                        if expression[i] == "{":
                            y = fn(i+1, mp[i])
                            i = mp[i]
                        else: y = expression[i]
                        ans.append([xx+yy for xx in ans.pop() for yy in y])
                    i += 1
            return sorted({xx for x in ans for xx in x})

        return fn(0, len(expression))


    """1099. Two Sum Less Than K (Easy)
    Given an array nums of integers and integer k, return the maximum sum such
    that there exists i < j with nums[i] + nums[j] = sum and sum < k. If no i,
    j exist satisfying this equation, return -1.

    Example 1:
    Input: nums = [34,23,1,24,75,33,54,8], k = 60
    Output: 58
    Explanation: We can use 34 and 24 to sum 58 which is less than 60.

    Example 2:
    Input: nums = [10,20,30], k = 15
    Output: -1
    Explanation: In this case it is not possible to get a pair sum less that 15.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 1000
    * 1 <= k <= 2000"""

    def twoSumLessThanK(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = -1
        lo, hi = 0, len(nums)-1
        while lo < hi:
            val = nums[lo] + nums[hi]
            if val >= k: hi -= 1
            else:
                ans = max(ans, val)
                lo += 1
        return ans


    """1100. Find K-Length Substrings With No Repeated Characters (Medium)
    Given a string s and an integer k, return the number of substrings in s of
    length k with no repeated characters.

    Example 1:
    Input: s = "havefunonleetcode", k = 5
    Output: 6
    Explanation: There are 6 substrings they are: 'havef','avefu','vefun',
                 'efuno','etcod','tcode'.

    Example 2:
    Input: s = "home", k = 5
    Output: 0
    Explanation: Notice k can be larger than the length of s. In this case, it
                 is not possible to find any substring.

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of lowercase English letters.
    * 1 <= k <= 10^4"""

    def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
        ans = 0
        freq = {}
        for i, c in enumerate(s):
            freq[c] = 1 + freq.get(c, 0)
            if i >= k:
                freq[s[i-k]] -= 1
                if freq[s[i-k]] == 0: freq.pop(s[i-k])
            if i+1 >= k and len(freq) == k: ans += 1
        return ans


    """1101. The Earliest Moment When Everyone Become Friends (Medium)
    There are n people in a social group labeled from 0 to n - 1. You are given
    an array logs where logs[i] = [timestampi, xi, yi] indicates that xi and yi
    will be friends at the time timestampi. Friendship is symmetric. That means
    if a is friends with b, then b is friends with a. Also, person a is
    acquainted with a person b if a is friends with b, or a is a friend of
    someone acquainted with b. Return the earliest time for which every person
    became acquainted with every other person. If there is no such earliest
    time, return -1.

    Example 1:
    Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],
                   [20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]],
                   n = 6
    Output: 20190301
    Explanation:
    The first event occurs at timestamp = 20190101 and after 0 and 1 become friends we have the following friendship groups [0,1], [2], [3], [4], [5].
    The second event occurs at timestamp = 20190104 and after 3 and 4 become friends we have the following friendship groups [0,1], [2], [3,4], [5].
    The third event occurs at timestamp = 20190107 and after 2 and 3 become friends we have the following friendship groups [0,1], [2,3,4], [5].
    The fourth event occurs at timestamp = 20190211 and after 1 and 5 become friends we have the following friendship groups [0,1,5], [2,3,4].
    The fifth event occurs at timestamp = 20190224 and as 2 and 4 are already friends anything happens.
    The sixth event occurs at timestamp = 20190301 and after 0 and 3 become friends we have that all become friends.

    Example 2:
    Input: logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4
    Output: 3

    Constraints:
    * 2 <= n <= 100
    * 1 <= logs.length <= 10^4
    * logs[i].length == 3
    * 0 <= timestampi <= 10^9
    * 0 <= xi, yi <= n - 1
    * xi != yi
    * All the values timestampi are unique.
    * All the pairs (xi, yi) occur at most one time in the input."""

    def earliestAcq(self, logs: List[List[int]], n: int) -> int:
        uf = UnionFind(n)
        for t, u, v in sorted(logs):
            if uf.union(u, v): n -= 1
            if n == 1: return t
        return -1


    """1102. Path With Maximum Minimum Value (Medium)
    Given an m x n integer matrix grid, return the maximum score of a path
    starting at (0, 0) and ending at (m - 1, n - 1) moving in the 4 cardinal
    directions. The score of a path is the minimum value in that path. For
    example, the score of the path 8 → 4 → 5 → 9 is 4.

    Example 1:
    Input: grid = [[5,4,5],
                   [1,2,6],
                   [7,4,6]]
    Output: 4
    Explanation: The path with the maximum score is highlighted in yellow.

    Example 2:
    Input: grid = [[2,2,1,2,2,2],
                   [1,2,2,2,1,2]]
    Output: 2

    Example 3:
    Input: grid = [[3,4,6,3,4],
                   [0,2,1,1,7],
                   [8,8,3,2,7],
                   [3,2,4,9,8],
                   [4,1,2,0,0],
                   [4,6,5,4,3]]
    Output: 3

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 100
    * 0 <= grid[i][j] <= 10^9"""

    def maximumMinimumPath(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        pq = [(-grid[0][0], 0, 0)]
        grid[0][0] = -1 # mark as visited
        while pq:
            v, i, j = heappop(pq)
            if i == m-1 and j == n-1: return -v
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and 0 <= grid[ii][jj]:
                    vv = min(-v, grid[ii][jj])
                    heappush(pq, (-vv, ii, jj))
                    grid[ii][jj] = -1


    """1103. Distribute Candies to People (Easy)
    We distribute some number of candies, to a row of n = num_people people in
    the following way:
    We then give 1 candy to the first person, 2 candies to the second person,
    and so on until we give n candies to the last person. Then, we go back to
    the start of the row, giving n + 1 candies to the first person, n + 2
    candies to the second person, and so on until we give 2 * n candies to the
    last person. This process repeats (with us giving one more candy each time,
    and moving to the start of the row after we reach the end) until we run out
    of candies.  The last person will receive all of our remaining candies (not
    necessarily one more than the previous gift). Return an array (of length
    num_people and sum candies) that represents the final distribution of
    candies.

    Example 1:
    Input: candies = 7, num_people = 4
    Output: [1,2,3,1]
    Explanation:
    On the first turn, ans[0] += 1, and the array is [1,0,0,0].
    On the second turn, ans[1] += 2, and the array is [1,2,0,0].
    On the third turn, ans[2] += 3, and the array is [1,2,3,0].
    On the fourth turn, ans[3] += 1 (because there is only one candy left), and
    the final array is [1,2,3,1].

    Example 2:
    Input: candies = 10, num_people = 3
    Output: [5,2,3]
    Explanation:
    On the first turn, ans[0] += 1, and the array is [1,0,0].
    On the second turn, ans[1] += 2, and the array is [1,2,0].
    On the third turn, ans[2] += 3, and the array is [1,2,3].
    On the fourth turn, ans[0] += 4, and the final array is [5,2,3].

    Constraints:
    * 1 <= candies <= 10^9
    * 1 <= num_people <= 1000"""

    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        ans = [0]*num_people
        i = 0
        while candies > 0:
            i += 1
            ans[(i-1)%num_people] += min(i, candies)
            candies -= i
        return ans


    """1104. Path In Zigzag Labelled Binary Tree (Medium)
    In an infinite binary tree where every node has two children, the nodes are
    labelled in row order. In the odd numbered rows (ie., the first, third,
    fifth,...), the labelling is left to right, while in the even numbered rows
    (second, fourth, sixth,...), the labelling is right to left. Given the
    label of a node in this tree, return the labels in the path from the root
    of the tree to the node with that label.

    Example 1:
    Input: label = 14
    Output: [1,3,4,14]

    Example 2:
    Input: label = 26
    Output: [1,2,6,10,26]

    Constraints: 1 <= label <= 10^6"""

    def pathInZigZagTree(self, label: int) -> List[int]:
        level = int(log2(label))
        compl = 3*2**level - 1 - label # complement

        ans = []
        while label:
            ans.append(label)
            label //= 2
            compl //= 2
            label, compl = compl, label
        return ans[::-1]


    """1105. Filling Bookcase Shelves (Medium)
    We have a sequence of books: the i-th book has thickness books[i][0] and
    height books[i][1]. We want to place these books in order onto bookcase
    shelves that have total width shelf_width. We choose some of the books to
    place on this shelf (such that the sum of their thickness is <= shelf_width),
    then build another level of shelf of the bookcase so that the total height
    of the bookcase has increased by the maximum height of the books we just
    put down.  We repeat this process until there are no more books to place.
    Note again that at each step of the above process, the order of the books
    we place is the same order as the given sequence of books.  For example, if
    we have an ordered list of 5 books, we might place the first and second
    book onto the first shelf, the third book on the second shelf, and the
    fourth and fifth book on the last shelf. Return the minimum possible height
    that the total bookshelf can be after placing shelves in this manner.

    Example 1:
    Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4
    Output: 6
    Explanation: The sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.
                 Notice that book number 2 does not have to be on the first
                 shelf.

    Constraints:
    * 1 <= books.length <= 1000
    * 1 <= books[i][0] <= shelf_width <= 1000
    * 1 <= books[i][1] <= 1000"""

    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:
        n = len(books)
        dp = [inf]*(n+1)
        dp[-1] = 0
        for i in range(n-1, -1, -1):
            w = h = 0
            for j in range(i, n):
                w += books[j][0]
                if w <= shelfWidth:
                    h = max(h, books[j][1])
                    dp[i] = min(dp[i], h + dp[j+1])
                else: break
        return dp[0]


    """1106. Parsing A Boolean Expression (Hard)
    Return the result of evaluating a given boolean expression, represented as
    a string. An expression can either be:
    * "t", evaluating to True;
    * "f", evaluating to False;
    * "!(expr)", evaluating to the logical NOT of the inner expression expr;
    * "&(expr1,expr2,...)", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;
    * "|(expr1,expr2,...)", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...

    Example 1:
    Input: expression = "!(f)"
    Output: true

    Example 2:
    Input: expression = "|(f,t)"
    Output: true

    Example 3:
    Input: expression = "&(t,f)"
    Output: false

    Example 4:
    Input: expression = "|(&(t,f,t),!(t))"
    Output: false

    Constraints:
    * 1 <= expression.length <= 20000
    * expression[i] consists of characters in {'(', ')', '&', '|', '!', 't', 'f', ','}.
    * expression is a valid expression representing a boolean, as given in the description."""

    def parseBoolExpr(self, expression: str) -> bool:
        t = f = 0
        operators, operands = [], []
        for x in expression:
            if x in "!&|": # operator
                operators.append(x)
                operands.append([t, f])
                t = f = 0
            elif x == "t": t += 1
            elif x == "f": f += 1
            elif x == ")":
                op = operators.pop()
                if op == "!" and t or op == "&" and f or op == "|" and not t: t, f = 0, 1
                else: t, f = 1, 0
                tt, ff = operands.pop()
                t, f = t+tt, f+ff
        return t


    """1110. Delete Nodes And Return Forest (Medium)
    Given the root of a binary tree, each node in the tree has a distinct value.
    After deleting all nodes with a value in to_delete, we are left with a
    forest (a disjoint union of trees). Return the roots of the trees in the
    remaining forest. You may return the result in any order.

    Example 1:
    Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
    Output: [[1,2,null,4],[6],[7]]

    Example 2:
    Input: root = [1,2,4,null,3], to_delete = [3]
    Output: [[1,2,4]]

    Constraints:
    * The number of nodes in the given tree is at most 1000.
    * Each node has a distinct value between 1 and 1000.
    * to_delete.length <= 1000
    * to_delete contains distinct values between 1 and 1000."""

    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:
        ans = []
        to_delete = set(to_delete)
        stack = [(root, -1)]
        while stack:
            node, p = stack.pop()
            if node.left:
                stack.append((node.left, node.val))
                if node.left.val in to_delete: node.left = None
            if node.right:
                stack.append((node.right, node.val))
                if node.right.val in to_delete: node.right = None
            if (p == -1 or p in to_delete) and node.val not in to_delete:
                ans.append(node)
        return ans


    """1111. Maximum Nesting Depth of Two Valid Parentheses Strings (Medium)
    A string is a valid parentheses string (denoted VPS) if and only if it
    consists of "(" and ")" characters only, and:
    * It is the empty string, or
    * It can be written as AB (A concatenated with B), where A and B are VPS's,
      or
    * It can be written as (A), where A is a VPS.
    We can similarly define the nesting depth depth(S) of any VPS S as follows:
    * depth("") = 0
    * depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's
    * depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
    For example,  "", "()()", and "()(()())" are VPS's (with nesting depths 0,
    1, and 2), and ")(" and "(()" are not VPS's. Given a VPS seq, split it into
    two disjoint subsequences A and B, such that A and B are VPS's (and
    A.length + B.length = seq.length). Now choose any such A and B such that
    max(depth(A), depth(B)) is the minimum possible value. Return an answer
    array (of length seq.length) that encodes such a choice of A and B:
    answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even
    though multiple answers may exist, you may return any of them.

    Example 1:
    Input: seq = "(()())"
    Output: [0,1,1,1,1,0]

    Example 2:
    Input: seq = "()(())()"
    Output: [0,0,0,1,1,0,1,1]

    Constraints: 1 <= seq.size <= 10000"""

    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        ans, depth = [], 0
        for i, x in enumerate(seq):
            if x == "(": depth += 1
            ans.append(depth & 1)
            if x == ")": depth -= 1
        return ans


    """1118. Number of Days in a Month (Easy)
    Given a year Y and a month M, return how many days there are in that month.

    Example 1:
    Input: Y = 1992, M = 7
    Output: 31

    Example 2:
    Input: Y = 2000, M = 2
    Output: 29

    Example 3:
    Input: Y = 1900, M = 2
    Output: 28

    Note:
    * 1583 <= Y <= 2100
    * 1 <= M <= 12"""

    def numberOfDays(self, Y: int, M: int) -> int:
        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        return days[M-1] + (M == 2 and (Y%4 == 0 and Y%100 != 0 or Y%400 == 0))


    """1119. Remove Vowels from a String (Easy)
    Given a string s, remove the vowels 'a', 'e', 'i', 'o', and 'u' from it,
    and return the new string.

    Example 1:
    Input: s = "leetcodeisacommunityforcoders"
    Output: "ltcdscmmntyfrcdrs"

    Example 2:
    Input: s = "aeiou"
    Output: ""

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of only lowercase English letters."""

    def removeVowels(self, S: str) -> str:
        return "".join(c for c in S if c not in "aeiou")


    """1120. Maximum Average Subtree (Medium)
    Given the root of a binary tree, find the maximum average value of any
    subtree of that tree. (A subtree of a tree is any node of that tree plus
    all its descendants. The average value of a tree is the sum of its values,
    divided by the number of nodes.)

    Example 1:
    Input: [5,6,1]
    Output: 6.00000
    Explanation:
    For the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4.
    For the node with value = 6 we have an average of 6 / 1 = 6.
    For the node with value = 1 we have an average of 1 / 1 = 1.
    So the answer is 6 which is the maximum.

    Note:
    * The number of nodes in the tree is between 1 and 5000.
    * Each node will have a value between 0 and 100000.
    * Answers will be accepted as correct if they are within 10^-5 of the
      correct answer."""

    def maximumAverageSubtree(self, root: Optional[TreeNode]) -> float:
        ans = 0
        sm, cnt = {None: 0}, {None: 0}
        node, stack = root, []
        prev = None
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack[-1]
                if node.right and node.right != prev: node = node.right
                else:
                    sm[node] = node.val + sm[node.left] + sm[node.right]
                    cnt[node] = 1 + cnt[node.left] + cnt[node.right]
                    ans = max(ans, sm[node]/cnt[node])
                    stack.pop()
                    prev = node
                    node = None
        return ans


    """1121. Divide Array Into Increasing Sequences (Hard)
    Given an integer array nums sorted in non-decreasing order and an integer k,
    return true if this array can be divided into one or more disjoint
    increasing subsequences of length at least k, or false otherwise.

    Example 1:
    Input: nums = [1,2,2,3,3,4,4], k = 3
    Output: true
    Explanation: The array can be divided into two subsequences [1,2,3,4] and
                 [2,3,4] with lengths at least 3 each.

    Example 2:
    Input: nums = [5,6,6,7,8], k = 3
    Output: false
    Explanation: There is no way to divide the array using the conditions
                 required.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * nums is sorted in non-decreasing order."""

    def canDivideIntoSubsequences(self, nums: List[int], k: int) -> bool:
        return max(Counter(nums).values()) * k <= len(nums)


    """1122. Relative Sort Array (Easy)
    Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all
    elements in arr2 are also in arr1. Sort the elements of arr1 such that the
    relative ordering of items in arr1 are the same as in arr2. Elements that do
    not appear in arr2 should be placed at the end of arr1 in ascending order.

    Example 1:
    Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
    Output: [2,2,2,1,4,3,3,9,6,7,19]

    Example 2:
    Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
    Output: [22,28,8,6,17,44]

    Constraints:
    * 1 <= arr1.length, arr2.length <= 1000
    * 0 <= arr1[i], arr2[i] <= 1000
    * All the elements of arr2 are distinct.
    * Each arr2[i] is in arr1."""

    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        mp = {x : i for i, x in enumerate(arr2)}
        return sorted(arr1, key = lambda x : (mp.get(x, len(arr2)), x))


    """1125. Smallest Sufficient Team (Hard)
    In a project, you have a list of required skills req_skills, and a list of
    people. The ith person people[i] contains a list of skills that the person
    has. Consider a sufficient team: a set of people such that for every
    required skill in req_skills, there is at least one person in the team who
    has that skill. We can represent these teams by the index of each person.
    For example, team = [0, 1, 3] represents the people with skills people[0],
    people[1], and people[3]. Return any sufficient team of the smallest
    possible size, represented by the index of each person. You may return the
    answer in any order. It is guaranteed an answer exists.

    Example 1:
    Input: req_skills = ["java","nodejs","reactjs"],
           people = [["java"],["nodejs"],["nodejs","reactjs"]]
    Output: [0,2]

    Example 2:
    Input: req_skills = ["algorithms","math","java","reactjs","csharp","aws"],
           people = [["algorithms","math","java"],
                     ["algorithms","math","reactjs"],
                     ["java","csharp","aws"],
                     ["reactjs","csharp"],
                     ["csharp","math"],
                     ["aws","java"]]
    Output: [1,2]

    Constraints:
    * 1 <= req_skills.length <= 16
    * 1 <= req_skills[i].length <= 16
    * req_skills[i] consists of lowercase English letters.
    * All the strings of req_skills are unique.
    * 1 <= people.length <= 60
    * 0 <= people[i].length <= 16
    * 1 <= people[i][j].length <= 16
    * people[i][j] consists of lowercase English letters.
    * All the strings of people[i] are unique.
    * Every skill in people[i] is a skill in req_skills.
    * It is guaranteed a sufficient team exists."""

    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        mp = {skill : i for i, skill in enumerate(req_skills)} # digitized skills

        cand = []
        for skills in people:
            val = 0
            for skill in skills:
                val |= 1 << mp[skill] # digitized skill
            cand.append(val)

        @cache
        def fn(i, mask):
            """Return smallest sufficient team of people[i:] for skills in mask."""
            if mask == 0: return []
            if i == len(people): return [0]*100 # impossible
            if not (mask & cand[i]): return fn(i+1, mask)
            return min(fn(i+1, mask), [i] + fn(i+1, mask & ~cand[i]), key=len)

        return fn(0, (1 << len(req_skills)) - 1)


    """1128. Number of Equivalent Domino Pairs (Easy)
    Given a list of dominoes, dominoes[i] = [a, b] is equivalent to
    dominoes[j] = [c, d] if and only if either (a==c and b==d), or
    (a==d and b==c) - that is, one domino can be rotated to be equal to another
    domino. Return the number of pairs (i, j) for which
    0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].

    Example 1:
    Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]
    Output: 1

    Constraints:
    * 1 <= dominoes.length <= 40000
    * 1 <= dominoes[i][j] <= 9"""

    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        ans = 0
        freq = defaultdict(int)
        for x, y in dominoes:
            ans += freq[x, y]
            if x != y: ans += freq[y, x]
            freq[x, y] += 1
        return ans


    """1129. Shortest Path with Alternating Colors (Medium)
    You are given an integer n, the number of nodes in a directed graph where
    the nodes are labeled from 0 to n - 1. Each edge is red or blue in this
    graph, and there could be self-edges and parallel edges. You are given two
    arrays redEdges and blueEdges where:
    * redEdges[i] = [ai, bi] indicates that there is a directed red edge from
      node ai to node bi in the graph, and
    * blueEdges[j] = [uj, vj] indicates that there is a directed blue edge from
      node uj to node vj in the graph.
    Return an array answer of length n, where each answer[x] is the length of
    the shortest path from node 0 to node x such that the edge colors alternate
    along the path, or -1 if such a path does not exist.

    Example 1:
    Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []
    Output: [0,1,-1]

    Example 2:
    Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]
    Output: [0,1,-1]

    Constraints:
    * 1 <= n <= 100
    * 0 <= redEdges.length, blueEdges.length <= 400
    * redEdges[i].length == blueEdges[j].length == 2
    * 0 <= ai, bi, uj, vj < n"""

    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(n)]
        for u, v in redEdges: graph[u].append((v, 0))
        for u, v in blueEdges: graph[u].append((v, 1))
        queue = deque([(0, 0), (0, 1)])
        dist = [[inf]*2 for _ in range(n)]
        k = 0
        while queue:
            for _ in range(len(queue)):
                u, c = queue.popleft()
                if dist[u][c] > k:
                    dist[u][c] = k
                    for v, cc in graph[u]:
                        if cc != c: queue.append((v, cc))
            k += 1
        return [x if x < inf else -1 for x in map(min, dist)]


    """1130. Minimum Cost Tree From Leaf Values (Medium)
    Given an array arr of positive integers, consider all binary trees such
    that:
    * Each node has either 0 or 2 children;
    * The values of arr correspond to the values of each leaf in an in-order
      traversal of the tree.  (Recall that a node is a leaf if and only if it
      has 0 children.)
    * The value of each non-leaf node is equal to the product of the largest
      leaf value in its left and right subtree respectively.
    Among all possible binary trees considered, return the smallest possible
    sum of the values of each non-leaf node.  It is guaranteed this sum fits
    into a 32-bit integer.

    Example 1:
    Input: arr = [6,2,4]
    Output: 32
    Explanation: There are two possible trees. The first has non-leaf node sum
                 36, and the second has non-leaf node sum 32.

        24            24
       /  \          /  \
      12   4        6    8
     /  \               / \
    6    2             2   4

    Constraints:
    * 2 <= arr.length <= 40
    * 1 <= arr[i] <= 15
    * It is guaranteed that the answer fits into a 32-bit signed integer (ie.
      it is less than 2^31)."""

    def mctFromLeafValues(self, arr: List[int]) -> int:
        ans = 0
        stack = []
        for x in arr:
            while stack and stack[-1] <= x:
                val = stack.pop()
                ans += val * min(stack[-1] if stack else inf, x)
            stack.append(x)
        return ans + sum(stack[i-1]*stack[i] for i in range(1, len(stack)))


    """1131. Maximum of Absolute Value Expression (Medium)
    Given two arrays of integers with equal lengths, return the maximum value
    of:
    |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|
    where the maximum is taken over all 0 <= i, j < arr1.length.

    Example 1:
    Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]
    Output: 13

    Example 2:
    Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]
    Output: 20

    Constraints:
    * 2 <= arr1.length == arr2.length <= 40000
    * -10^6 <= arr1[i], arr2[i] <= 10^6"""

    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
        ans = 0
        for p, q in (1, 1), (1, -1), (-1, 1), (-1, -1):
            val = low = inf
            for i, (x, y) in enumerate(zip(arr1, arr2)):
                ans = max(ans, p*x + q*y + i - low)
                low = min(low, p*x + q*y + i)
        return ans


    """1133. Largest Unique Number (Easy)
    Given an array of integers A, return the largest integer that only occurs
    once. If no integer occurs once, return -1.

    Example 1:
    Input: [5,7,3,9,4,9,8,3,1]
    Output: 8
    Explanation: The maximum integer in the array is 9 but it is repeated. The
                 number 8 occurs only once, so it's the answer.

    Example 2:
    Input: [9,9,8,8]
    Output: -1
    Explanation: There is no number that occurs only once.

    Note:
    * 1 <= A.length <= 2000
    * 0 <= A[i] <= 1000"""

    def largestUniqueNumber(self, A: List[int]) -> int:
        freq = {}
        for x in A: freq[x] = 1 + freq.get(x, 0)
        return max((x for x, v in freq.items() if v == 1), default=-1)


    """1134. Armstrong Number (Easy)
    The k-digit number N is an Armstrong number if and only if the k-th power
    of each digit sums to N. Given a positive integer N, return true if and
    only if it is an Armstrong number.

    Example 1:
    Input: 153
    Output: true
    Explanation: 153 is a 3-digit number, and 153 = 1^3 + 5^3 + 3^3.

    Example 2:
    Input: 123
    Output: false
    Explanation: 123 is a 3-digit number, and 123 != 1^3 + 2^3 + 3^3 = 36.

    Note: 1 <= N <= 10^8"""

    def isArmstrong(self, N: int) -> bool:
        s = str(N)
        return sum(int(x)**len(s) for x in s) == N


    """1135. Connecting Cities With Minimum Cost (Medium)
    There are n cities labeled from 1 to n. You are given the integer n and an
    array connections where connections[i] = [xi, yi, costi] indicates that the
    cost of connecting city xi and city yi (bidirectional connection) is costi.
    Return the minimum cost to connect all the n cities such that there is at
    least one path between each pair of cities. If it is impossible to connect
    all the n cities, return -1, The cost is the sum of the connections' costs
    used.

    Example 1:
    Input: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]
    Output: 6
    Explanation: Choosing any 2 edges will connect all cities so we choose the
                 minimum 2.

    Example 2:
    Input: n = 4, connections = [[1,2,3],[3,4,4]]
    Output: -1
    Explanation: There is no way to connect all cities even if all edges are
                 used.

    Constraints:
    * 1 <= n <= 10^4
    * 1 <= connections.length <= 10^4
    * connections[i].length == 3
    * 1 <= xi, yi <= n
    * xi != yi
    * 0 <= costi <= 10^5"""

    def minimumCost(self, n: int, connections: List[List[int]]) -> int:
        ans = 0
        uf = UnionFind(n)
        for x, y, cost in sorted(connections, key=lambda x: x[2]):
            if uf.union(x-1, y-1):
                ans += cost
                n -= 1
            if n == 1: break
        return ans if n == 1 else -1


    """1136. Parallel Courses (Medium)
    You are given an integer n, which indicates that there are n courses
    labeled from 1 to n. You are also given an array relations where
    relations[i] = [prevCoursei, nextCoursei], representing a prerequisite
    relationship between course prevCoursei and course nextCoursei: course
    prevCoursei has to be taken before course nextCoursei. In one semester, you
    can take any number of courses as long as you have taken all the
    prerequisites in the previous semester for the courses you are taking.
    Return the minimum number of semesters needed to take all courses. If there
    is no way to take all the courses, return -1.

    Example 1:
    Input: n = 3, relations = [[1,3],[2,3]]
    Output: 2
    Explanation: The figure above represents the given graph. In the first
                 semester, you can take courses 1 and 2. In the second semester,
                 you can take course 3.

    Example 2:
    Input: n = 3, relations = [[1,2],[2,3],[3,1]]
    Output: -1
    Explanation: No course can be studied because they are prerequisites of
                 each other.

    Constraints:
    * 1 <= n <= 5000
    * 1 <= relations.length <= 5000
    * relations[i].length == 2
    * 1 <= prevCoursei, nextCoursei <= n
    * prevCoursei != nextCoursei
    * All the pairs [prevCoursei, nextCoursei] are unique."""

    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
        graph = {}
        indeg = [0]*n
        for u, v in relations:
            graph.setdefault(u-1, []).append(v-1)
            indeg[v-1] += 1

        ans = 0
        queue = [x for x in range(n) if not indeg[x]]
        while queue:
            ans += 1
            newq = []
            for x in queue:
                for xx in graph.get(x, []):
                    indeg[xx] -= 1
                    if not indeg[xx]: newq.append(xx)
            queue = newq
        return -1 if any(indeg) else ans


    """1137. N-th Tribonacci Number (Easy)
    The Tribonacci sequence Tn is defined as follows:
    * T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.
    Given n, return the value of Tn.

    Example 1:
    Input: n = 4
    Output: 4
    Explanation: T_3 = 0 + 1 + 1 = 2
                 T_4 = 1 + 1 + 2 = 4

    Example 2:
    Input: n = 25
    Output: 1389537

    Constraints:
    * 0 <= n <= 37
    * The answer is guaranteed to fit within a 32-bit integer, ie.
      answer <= 2^31 - 1."""

    def tribonacci(self, n: int) -> int:
        dp = [0, 1, 1]
        for i in range(3, n+1):
            dp[i%3] = sum(dp)
        return dp[n%3]


    """1138. Alphabet Board Path (Medium)
    On an alphabet board, we start at position (0, 0), corresponding to
    character board[0][0]. Here,
    board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"], as shown in the
    diagram below. We may make the following moves:
    * 'U' moves our position up one row, if the position exists on the board;
    * 'D' moves our position down one row, if the position exists on the board;
    * 'L' moves our position left one column, if the position exists on the board;
    * 'R' moves our position right one column, if the position exists on the board;
    * '!' adds the character board[r][c] at our current position (r, c) to the answer.
    (Here, the only positions that exist on the board are positions with letters on them.)
    Return a sequence of moves that makes our answer equal to target in the
    minimum number of moves.  You may return any path that does so.

    Example 1:
    Input: target = "leet"
    Output: "DDR!UURRR!!DDD!"

    Example 2:
    Input: target = "code"
    Output: "RR!DDRR!UUL!R!"

    Constraints:
    * 1 <= target.length <= 100
    * target consists only of English lowercase letters."""

    def alphabetBoardPath(self, target: str) -> str:
        ans = []
        x = y = 0
        for c in target:
            xx, yy = divmod(ord(c)-97, 5)
            if x > xx: ans.append((x-xx)*"U")
            if y > yy: ans.append((y-yy)*"L")
            if x < xx: ans.append((xx-x)*"D")
            if y < yy: ans.append((yy-y)*"R")
            ans.append("!")
            x, y = xx, yy
        return "".join(ans)


    """1139. Largest 1-Bordered Square (Medium)
    Given a 2D grid of 0s and 1s, return the number of elements in the largest
    square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't
    exist in the grid.

    Example 1:
    Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
    Output: 9

    Example 2:
    Input: grid = [[1,1,0,0]]
    Output: 1

    Constraints:
    * 1 <= grid.length <= 100
    * 1 <= grid[0].length <= 100
    * grid[i][j] is 0 or 1"""

    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions

        hori = deepcopy(grid)
        vert = deepcopy(grid)
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    if j: hori[i][j] += hori[i][j-1] # horizontal precipitation
                    if i: vert[i][j] += vert[i-1][j] # vertical precipitation

        ans = 0
        for i in reversed(range(m)):
            for j in reversed(range(n)):
                val = min(hori[i][j], vert[i][j])
                while val > ans:
                    if vert[i][j-val+1] >= val and hori[i-val+1][j] >= val:
                        ans = val
                    val -= 1
        return ans*ans


    """1140. Stone Game II (Medium)
    Alice and Bob continue their games with piles of stones. There are a number
    of piles arranged in a row, and each pile has a positive integer number of
    stones piles[i].  The objective of the game is to end with the most stones.
    Alice and Bob take turns, with Alice starting first.  Initially, M = 1. On
    each player's turn, that player can take all the stones in the first X
    remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X). The game
    continues until all the stones have been taken. Assuming Alice and Bob play
    optimally, return the maximum number of stones Alice can get.

    Example 1:
    Input: piles = [2,7,9,4,4]
    Output: 10
    Explanation:  If Alice takes one pile at the beginning, Bob takes two piles,
                  then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10
                  piles in total. If Alice takes two piles at the beginning,
                  then Bob can take all three piles left. In this case, Alice
                  get 2 + 7 = 9 piles in total. So we return 10 since it's
                  larger.

    Example 2:
    Input: piles = [1,2,3,4,5,100]
    Output: 104

    Constraints:
    * 1 <= piles.length <= 100
    * 1 <= piles[i] <= 10^4"""

    def stoneGameII(self, piles: List[int]) -> int:
        n = len(piles)
        prefix = list(accumulate(piles, initial=0))
        dp = [[0]*(n+1) for _ in range(n+1)]
        for i in range(n-1, -1, -1):
            for j in range(1, n+1):
                for ii in range(i, min(n, i+2*j)):
                    jj = max(j, ii-i+1)
                    cand = prefix[n] - prefix[i] - dp[ii+1][jj]
                    dp[i][j] = max(dp[i][j], cand)
        return dp[0][1]


    """1143. Longest Common Subsequence (Medium)
    Given two strings text1 and text2, return the length of their longest
    common subsequence. If there is no common subsequence, return 0. A
    subsequence of a string is a new string generated from the original string
    with some characters (can be none) deleted without changing the relative
    order of the remaining characters. For example, "ace" is a subsequence of
    "abcde". A common subsequence of two strings is a subsequence that is
    common to both strings.

    Example 1:
    Input: text1 = "abcde", text2 = "ace"
    Output: 3
    Explanation: The longest common subsequence is "ace" and its length is 3.

    Example 2:
    Input: text1 = "abc", text2 = "abc"
    Output: 3
    Explanation: The longest common subsequence is "abc" and its length is 3.

    Example 3:
    Input: text1 = "abc", text2 = "def"
    Output: 0
    Explanation: There is no such common subsequence, so the result is 0.

    Constraints:
    * 1 <= text1.length, text2.length <= 1000
    * text1 and text2 consist of only lowercase English characters."""

    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [0]*(n+1)
        for i in reversed(range(m)):
            prev = curr = 0
            for j in reversed(range(n)):
                curr = dp[j]
                if text1[i] == text2[j]: dp[j] = 1 + prev
                else: dp[j] = max(dp[j], dp[j+1])
                prev = curr
        return dp[0]


    """1144. Decrease Elements To Make Array Zigzag (Medium)
    Given an array nums of integers, a move consists of choosing any element
    and decreasing it by 1. An array A is a zigzag array if either:
    * Every even-indexed element is greater than adjacent elements, ie.
      A[0] > A[1] < A[2] > A[3] < A[4] > ...
    * OR, every odd-indexed element is greater than adjacent elements, ie.
      A[0] < A[1] > A[2] < A[3] > A[4] < ...
    Return the minimum number of moves to transform the given array nums into a
    zigzag array.

    Example 1:
    Input: nums = [1,2,3]
    Output: 2
    Explanation: We can decrease 2 to 0 or 3 to 1.

    Example 2:
    Input: nums = [9,6,1,6,2]
    Output: 4

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000"""

    def movesToMakeZigzag(self, nums: List[int]) -> int:
        ans = [0, 0]
        for i in range(len(nums)):
            val = 0
            if i: val = max(val, nums[i] - nums[i-1] + 1)
            if i+1 < len(nums): val = max(val, nums[i] - nums[i+1] + 1)
            ans[i&1] += val
        return min(ans)


    """1145. Binary Tree Coloring Game (Medium)
    Two players play a turn based game on a binary tree.  We are given the root
    of this binary tree, and the number of nodes n in the tree.  n is odd, and
    each node has a distinct value from 1 to n. Initially, the first player
    names a value x with 1 <= x <= n, and the second player names a value y
    with 1 <= y <= n and y != x.  The first player colors the node with value x
    red, and the second player colors the node with value y blue. Then, the
    players take turns starting with the first player.  In each turn, that
    player chooses a node of their color (red if player 1, blue if player 2)
    and colors an uncolored neighbor of the chosen node (either the left child,
    right child, or parent of the chosen node.) If (and only if) a player
    cannot choose such a node in this way, they must pass their turn.  If both
    players pass their turn, the game ends, and the winner is the player that
    colored more nodes. You are the second player.  If it is possible to choose
    such a y to ensure you win the game, return true.  If it is not possible,
    return false.

    Example 1:
    Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3
    Output: true
    Explanation: The second player can choose the node with value 2.

    Constraints:
    * root is the root of a binary tree with n nodes and distinct node values
      from 1 to n.
    * n is odd.
    * 1 <= x <= n <= 100"""

    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:

        def fn(node):
            """Return size of subtree rooted at node."""
            if not node: return 0
            left, right = fn(node.left), fn(node.right)
            if node.val == x:
                cnt[0], cnt[1] = left, right
            return 1 + left + right

        cnt = [0, 0]
        fn(root)
        return max(max(cnt), n-1-sum(cnt)) > n//2


    """1147. Longest Chunked Palindrome Decomposition (Hard)
    You are given a string text. You should split it to k substrings
    (subtext1, subtext2, ..., subtextk) such that:
    * subtexti is a non-empty string.
    * The concatenation of all the substrings is equal to text (i.e.,
      subtext1 + subtext2 + ... + subtextk == text).
    * subtexti == subtextk - i + 1 for all valid values of i (i.e., 1 <= i <= k).
    Return the largest possible value of k.

    Example 1:
    Input: text = "ghiabcdefhelloadamhelloabcdefghi"
    Output: 7
    Explanation: We can split the string on "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)".

    Example 2:
    Input: text = "merchant"
    Output: 1
    Explanation: We can split the string on "(merchant)".

    Example 3:
    Input: text = "antaprezatepzapreanta"
    Output: 11
    Explanation: We can split the string on "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)".

    Example 4:
    Input: text = "aaa"
    Output: 3
    Explanation: We can split the string on "(a)(a)(a)".

    Constraints:
    * 1 <= text.length <= 1000
    * text consists only of lowercase English characters."""

    def longestDecomposition(self, text: str) -> int:
        ii = i = ans = 0
        jj = j = len(text)-1
        while i < j:
            if text[ii:i+1] == text[j:jj+1]:
                ans += 2
                ii, jj = i+1, j-1 # reset anchor ptr
            i, j = i+1, j-1
        return ans + int(ii <= jj)


    """1150. Check If a Number Is Majority Element in a Sorted Array (Easy)
    Given an array nums sorted in non-decreasing order, and a number target,
    return True if and only if target is a majority element. A majority element
    is an element that appears more than N/2 times in an array of length N.

    Example 1:
    Input: nums = [2,4,5,5,5,5,5,6,6], target = 5
    Output: true
    Explanation: The value 5 appears 5 times and the length of the array is 9.
                 Thus, 5 is a majority element because 5 > 9/2 is true.

    Example 2:
    Input: nums = [10,100,101,101], target = 101
    Output: false
    Explanation: The value 101 appears 2 times and the length of the array is 4.
                 Thus, 101 is not a majority element because 2 > 4/2 is false.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^9
    * 1 <= target <= 10^9"""

    def isMajorityElement(self, nums: List[int], target: int) -> bool:
        if nums[(len(nums)-1)//2] != target: return False
        k = bisect_left(nums, target, 0, len(nums)//2)
        return nums[k + len(nums)//2] == target


    """1151. Minimum Swaps to Group All 1's Together (Medium)
    Given a binary array data, return the minimum number of swaps required to
    group all 1’s present in the array together in any place in the array.

    Example 1:
    Input: data = [1,0,1,0,1]
    Output: 1
    Explanation: There are 3 ways to group all 1's together:
                 [1,1,1,0,0] using 1 swap.
                 [0,1,1,1,0] using 2 swaps.
                 [0,0,1,1,1] using 1 swap.
                 The minimum is 1.

    Example 2:
    Input: data = [0,0,0,1,0]
    Output: 0
    Explanation: Since there is only one 1 in the array, no swaps needed.

    Example 3:
    Input: data = [1,0,1,0,1,0,0,1,1,0,1]
    Output: 3
    Explanation: One possible solution that uses 3 swaps is
                 [0,0,0,0,0,1,1,1,1,1,1].

    Example 4:
    Input: data = [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]
    Output: 8

    Constraints:
    * 1 <= data.length <= 10^5
    * data[i] is 0 or 1."""

    def minSwaps(self, data: List[int]) -> int:
        k = sum(data) # window size
        ans = val = 0
        for i, x in enumerate(data):
            val += x
            if i >= k: val -= data[i-k]
            if i+1 >= k: ans = max(ans, val)
        return k - ans


    """1152. Analyze User Website Visit Pattern (Medium)
    You are given two string arrays username and website and an integer array
    timestamp. All the given arrays are of the same length and the tuple
    [username[i], website[i], timestamp[i]] indicates that the user username[i]
    visited the website website[i] at time timestamp[i]. A pattern is a list of
    three websites (not necessarily distinct).

    * For example, ["home", "away", "love"], ["leetcode", "love", "leetcode"],
      and ["luffy", "luffy", "luffy"] are all patterns.
    The score of a pattern is the number of users that visited all the websites
    in the pattern in the same order they appeared in the pattern.
    * For example, if the pattern is ["home", "away", "love"], the score is the
      number of users x such that x visited "home" then visited "away" and
      visited "love" after that.
    * Similarly, if the pattern is ["leetcode", "love", "leetcode"], the score
      is the number of users x such that x visited "leetcode" then visited
      "love" and visited "leetcode" one more time after that.
    * Also, if the pattern is ["luffy", "luffy", "luffy"], the score is the
      number of users x such that x visited "luffy" three different times at
      different timestamps.
    Return the pattern with the largest score. If there is more than one
    pattern with the same largest score, return the lexicographically smallest
    such pattern.

    Example 1:
    Input: username = ["joe","joe","joe","james","james","james","james","mary","mary","mary"],
           timestamp = [1,2,3,4,5,6,7,8,9,10],
           website = ["home","about","career","home","cart","maps","home","home","about","career"]
    Output: ["home","about","career"]
    Explanation: The tuples in this example are:
    ["joe","home",1],["joe","about",2],["joe","career",3],["james","home",4],["james","cart",5],["james","maps",6],["james","home",7],["mary","home",8],["mary","about",9], and ["mary","career",10].
    The pattern ("home", "about", "career") has score 2 (joe and mary).
    The pattern ("home", "cart", "maps") has score 1 (james).
    The pattern ("home", "cart", "home") has score 1 (james).
    The pattern ("home", "maps", "home") has score 1 (james).
    The pattern ("cart", "maps", "home") has score 1 (james).
    The pattern ("home", "home", "home") has score 0 (no user visited home 3 times).

    Example 2:
    Input: username = ["ua","ua","ua","ub","ub","ub"],
           timestamp = [1,2,3,4,5,6],
           website = ["a","b","a","a","b","c"]
    Output: ["a","b","a"]

    Constraints:
    * 3 <= username.length <= 50
    * 1 <= username[i].length <= 10
    * timestamp.length == username.length
    * 1 <= timestamp[i] <= 10^9
    * website.length == username.length
    * 1 <= website[i].length <= 10
    * username[i] and website[i] consist of lowercase English letters.
    * It is guaranteed that there is at least one user who visited at least three websites.
    * All the tuples [username[i], timestamp[i], website[i]] are unique."""

    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
        mp = {}
        for t, u, w in sorted(zip(timestamp, username, website)):
            mp.setdefault(u, []).append(w)

        freq = defaultdict(int)
        for key, val in mp.items():
            seen = set()
            for i in range(len(val)):
                for j in range(i+1, len(val)):
                    for k in range(j+1, len(val)):
                        seen.add((val[i], val[j], val[k]))
            for x in seen: freq[x] += 1

        return min(freq, key=lambda x: (-freq[x], x))


    """1160. Find Words That Can Be Formed by Characters (Easy)
    You are given an array of strings words and a string chars. A string is
    good if it can be formed by characters from chars (each character can only
    be used once). Return the sum of lengths of all good strings in words.

    Example 1:
    Input: words = ["cat","bt","hat","tree"], chars = "atach"
    Output: 6
    Explanation: The strings that can be formed are "cat" and "hat" so the
                 answer is 3 + 3 = 6.

    Example 2:
    Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
    Output: 10
    Explanation: The strings that can be formed are "hello" and "world" so the
                 answer is 5 + 5 = 10.

    Note:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length, chars.length <= 100
    * All strings contain lowercase English letters only."""

    def countCharacters(self, words: List[str], chars: str) -> int:
        fc = {}
        for c in chars: fc[c] = 1 + fc.get(c, 0)

        ans = 0
        for word in words:
            fw = {}
            for c in word: fw[c] = 1 + fw.get(c, 0)
            if all(fw[c] <= fc.get(c, 0) for c in fw): ans += len(word)
        return ans


    """1161. Maximum Level Sum of a Binary Tree (Medium)
    Given the root of a binary tree, the level of its root is 1, the level of
    its children is 2, and so on. Return the smallest level x such that the sum
    of all the values of nodes at level x is maximal.

    Example 1:
    Input: root = [1,7,0,7,-8,null,null]
    Output: 2
    Explanation:
    Level 1 sum = 1.
    Level 2 sum = 7 + 0 = 7.
    Level 3 sum = 7 + -8 = -1.
    So we return the level with the maximum sum which is level 2.

    Example 2:
    Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
    Output: 2

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -10^5 <= Node.val <= 10^5"""

    def maxLevelSum(self, root: TreeNode) -> int:
        ans = level = 0
        val = -inf
        queue = [root]
        while queue:
            level += 1
            newq = []
            tmp = 0
            for node in queue:
                tmp += node.val
                if node.left: newq.append(node.left)
                if node.right: newq.append(node.right)
            if tmp > val: ans, val = level, tmp
            queue = newq
        return ans


    """1162. As Far from Land as Possible (Medium)
    Given an n x n grid containing only values 0 and 1, where 0 represents
    water and 1 represents land, find a water cell such that its distance to
    the nearest land cell is maximized, and return the distance. If no land or
    water exists in the grid, return -1. The distance used in this problem is
    the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1)
    is |x0 - x1| + |y0 - y1|.

    Example 1:
    Input: grid = [[1,0,1],[0,0,0],[1,0,1]]
    Output: 2
    Explanation: The cell (1, 1) is as far as possible from all the land with distance 2.

    Example 2:
    Input: grid = [[1,0,0],[0,0,0],[0,0,0]]
    Output: 4
    Explanation: The cell (2, 2) is as far as possible from all the land with distance 4.

    Constraints:
    * n == grid.length
    * n == grid[i].length
    * 1 <= n <= 100
    * grid[i][j] is 0 or 1"""

    def maxDistance(self, grid: List[List[int]]) -> int:
        n = len(grid) # dimension

        ans = -1
        queue = [(i, j) for i in range(n) for j in range(n) if grid[i][j]]
        while queue:
            newq = []
            for i, j in queue:
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < n and 0 <= jj < n and not grid[ii][jj]:
                        newq.append((ii, jj))
                        grid[ii][jj] = 1 # mark as visited
            queue = newq
            ans += 1
        return ans or -1


    """1163. Last Substring in Lexicographical Order (Hard)
    Given a string s, return the last substring of s in lexicographical order.

    Example 1:
    Input: s = "abab"
    Output: "bab"
    Explanation: The substrings are ["a", "ab", "aba", "abab", "b", "ba", "bab"].
                 The lexicographically maximum substring is "bab".

    Example 2:
    Input: s = "leetcode"
    Output: "tcode"

    Constraints:
    * 1 <= s.length <= 4 * 10^5
    * s contains only lowercase English letters."""

    def lastSubstring(self, s: str) -> str:
        ii = k = 0 # anchor
        i = 1 # pointer
        while i + k < len(s):
            if s[ii+k] == s[i+k]: k += 1
            else:
                if s[ii+k] > s[i+k]: i += k+1
                else:
                    ii = max(ii+k+1, i)
                    i = ii+1
                k = 0
        return s[ii:]


    """1165. Single-Row Keyboard (Easy)
    There is a special keyboard with all keys in a single row. Given a string
    keyboard of length 26 indicating the layout of the keyboard (indexed from
    0 to 25), initially your finger is at index 0. To type a character, you
    have to move your finger to the index of the desired character. The time
    taken to move your finger from index i to index j is |i - j|. You want to
    type a string word. Write a function to calculate how much time it takes to
    type it with one finger.

    Example 1:
    Input: keyboard = "abcdefghijklmnopqrstuvwxyz", word = "cba"
    Output: 4
    Explanation: The index moves from 0 to 2 to write 'c' then to 1 to write
                 'b' then to 0 again to write 'a'. Total time = 2 + 1 + 1 = 4.

    Example 2:
    Input: keyboard = "pqrstuvwxyzabcdefghijklmno", word = "leetcode"
    Output: 73

    Constraints:
    * keyboard.length == 26
    * keyboard contains each English lowercase letter exactly once in some order.
    * 1 <= word.length <= 10^4
    * word[i] is an English lowercase letter."""

    def calculateTime(self, keyboard: str, word: str) -> int:
        loc = {c: i for i, c in enumerate(keyboard)}
        ans = prev = 0
        for c in word:
            ans += abs(loc[c] - prev)
            prev = loc[c]
        return ans


    """1167. Minimum Cost to Connect Sticks (Medium)
    You have some number of sticks with positive integer lengths. These lengths
    are given as an array sticks, where sticks[i] is the length of the ith
    stick. You can connect any two sticks of lengths x and y into one stick by
    paying a cost of x + y. You must connect all the sticks until there is only
    one stick remaining. Return the minimum cost of connecting all the given
    sticks into one stick in this way.

    Example 1:
    Input: sticks = [2,4,3]
    Output: 14
    Explanation: You start with sticks = [2,4,3].
    1. Combine sticks 2 and 3 for a cost of 2 + 3 = 5. Now you have sticks = [5,4].
    2. Combine sticks 5 and 4 for a cost of 5 + 4 = 9. Now you have sticks = [9].
    There is only one stick left, so you are done. The total cost is 5 + 9 = 14.

    Example 2:
    Input: sticks = [1,8,3,5]
    Output: 30
    Explanation: You start with sticks = [1,8,3,5].
    1. Combine sticks 1 and 3 for a cost of 1 + 3 = 4. Now you have sticks = [4,8,5].
    2. Combine sticks 4 and 5 for a cost of 4 + 5 = 9. Now you have sticks = [9,8].
    3. Combine sticks 9 and 8 for a cost of 9 + 8 = 17. Now you have sticks = [17].
    There is only one stick left, so you are done. The total cost is 4 + 9 + 17 = 30.

    Example 3:
    Input: sticks = [5]
    Output: 0
    Explanation: There is only one stick, so you don't need to do anything. The total cost is 0.

    Constraints:
    * 1 <= sticks.length <= 10^4
    * 1 <= sticks[i] <= 10^4"""

    def connectSticks(self, sticks: List[int]) -> int:
        heapify(sticks)
        ans = 0
        while len(sticks) > 1:
            x = heappop(sticks)
            y = heappop(sticks)
            heappush(sticks, x + y)
            ans += x + y
        return ans


    """1168. Optimize Water Distribution in a Village (Hard)
    There are n houses in a village. We want to supply water for all the houses
    by building wells and laying pipes. For each house i, we can either build a
    well inside it directly with cost wells[i - 1] (note the -1 due to 0-
    indexing), or pipe in water from another well to it. The costs to lay pipes
    between houses are given by the array pipes, where each
    pipes[j] = [house1j, house2j, costj] represents the cost to connect house1j
    and house2j together using a pipe. Connections are bidirectional. Return
    the minimum total cost to supply water to all houses.

    Example 1:
    Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]
    Output: 3
    Explanation: The image shows the costs of connecting houses using pipes.
                 The best strategy is to build a well in the first house with
                 cost 1 and connect the other houses to it with cost 2 so the
                 total cost is 3.

    Example 2:
    Input: n = 2, wells = [1,1], pipes = [[1,2,1]]
    Output: 2

    Constraints:
    * 2 <= n <= 10^4
    * wells.length == n
    * 0 <= wells[i] <= 10^5
    * 1 <= pipes.length <= 10^4
    * pipes[j].length == 3
    * 1 <= house1j, house2j <= n
    * 0 <= costj <= 10^5
    * house1j != house2j"""

    def minCostToSupplyWater(self, n: int, wells: List[int], pipes: List[List[int]]) -> int:
        pq = [(cost, p-1, q-1) for p, q, cost in pipes] # min-heap
        heapify(pq)

        parent = list(range(n))

        def find(p):
            if p != parent[p]: parent[p] = find(parent[p])
            return parent[p]

        def union(p, q, cost):
            prt, qrt = find(p), find(q)
            if wells[prt] < wells[qrt]: prt, qrt = qrt, prt
            if prt == qrt or cost >= wells[prt]: return False
            parent[prt] = qrt
            return True

        ans = 0
        while pq:
            cost, p, q = heappop(pq)
            if union(p, q, cost): ans += cost
        return ans + sum(wells[i] for i in set(map(find, range(n))))


    """1176. Diet Plan Performance (Easy)
    A dieter consumes calories[i] calories on the i-th day. Given an integer k,
    for every consecutive sequence of k days (calories[i], calories[i+1], ...,
    calories[i+k-1] for all 0 <= i <= n-k), they look at T, the total calories
    consumed during that sequence of k days (calories[i] + calories[i+1] + ...
    + calories[i+k-1]):
    * If T < lower, they performed poorly on their diet and lose 1 point;
    * If T > upper, they performed well on their diet and gain 1 point;
    * Otherwise, they performed normally and there is no change in points.
    Initially, the dieter has zero points. Return the total number of points
    the dieter has after dieting for calories.length days. Note that the total
    points can be negative.

    Example 1:
    Input: calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3
    Output: 0
    Explanation: Since k = 1, we consider each element of the array separately and compare it to lower and upper.
    calories[0] and calories[1] are less than lower so 2 points are lost.
    calories[3] and calories[4] are greater than upper so 2 points are gained.

    Example 2:
    Input: calories = [3,2], k = 2, lower = 0, upper = 1
    Output: 1
    Explanation: Since k = 2, we consider subarrays of length 2.
    calories[0] + calories[1] > upper so 1 point is gained.

    Example 3:
    Input: calories = [6,5,0,0], k = 2, lower = 1, upper = 5
    Output: 0
    Explanation:
    calories[0] + calories[1] > upper so 1 point is gained.
    lower <= calories[1] + calories[2] <= upper so no change in points.
    calories[2] + calories[3] < lower so 1 point is lost.

    Constraints:
    * 1 <= k <= calories.length <= 10^5
    * 0 <= calories[i] <= 20000
    * 0 <= lower <= upper"""

    def dietPlanPerformance(self, calories: List[int], k: int, lower: int, upper: int) -> int:
        ans = val = 0
        for i, x in enumerate(calories):
            val += x
            if i+1 >= k:
                if val < lower: ans -= 1
                elif val > upper: ans += 1
                val -= calories[i-k+1]
        return ans


    """1177. Can Make Palindrome from Substring (Medium)
    Given a string s, we make queries on substrings of s. For each query
    queries[i] = [left, right, k], we may rearrange the substring s[left], ...,
    s[right], and then choose up to k of them to replace with any lowercase
    English letter. If the substring is possible to be a palindrome string
    after the operations above, the result of the query is true. Otherwise,
    the result is false. Return an array answer[], where answer[i] is the
    result of the i-th query queries[i]. Note that: Each letter is counted
    individually for replacement so if for example s[left..right] = "aaa",
    and k = 2, we can only replace two of the letters.  (Also, note that the
    initial string s is never modified by any query.)

    Example :
    Input: s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
    Output: [true,false,false,true,true]
    Explanation:
    queries[0] : substring = "d", is palidrome.
    queries[1] : substring = "bc", is not palidrome.
    queries[2] : substring = "abcd", is not palidrome after replacing only 1 character.
    queries[3] : substring = "abcd", could be changed to "abba" which is palidrome. Also this can be changed to "baab" first rearrange it "bacd" then replace "cd" with "ab".
    queries[4] : substring = "abcda", could be changed to "abcba" which is palidrome.

    Constraints:
    * 1 <= s.length, queries.length <= 10^5
    * 0 <= queries[i][0] <= queries[i][1] < s.length
    * 0 <= queries[i][2] <= s.length
    * s only contains lowercase English letters."""

    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for c in s:
            prefix.append(prefix[-1] ^ (1 << (ord(c)-97)))

        ans = []
        for left, right, k in queries:
            cnt = bin(prefix[right+1] ^ prefix[left]).count("1")
            ans.append(cnt <= 2*k+1)
        return ans


    """1178. Number of Valid Words for Each Puzzle (Hard)
    With respect to a given puzzle string, a word is valid if both the
    following conditions are satisfied:
    * word contains the first letter of puzzle.
    * For each letter in word, that letter is in puzzle. For example, if the
      puzzle is "abcdefg", then valid words are "faced", "cabbage", and
      "baggage"; while invalid words are "beefed" (doesn't include "a") and
      "based" (includes "s" which isn't in the puzzle).
    Return an array answer, where answer[i] is the number of words in the given
    word list words that are valid with respect to the puzzle puzzles[i].

    Example :
    Input: words = ["aaaa","asas","able","ability","actt","actor","access"],
           puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
    Output: [1,1,3,2,4,0]
    Explanation:
    1 valid word for "aboveyz" : "aaaa"
    1 valid word for "abrodyz" : "aaaa"
    3 valid words for "abslute" : "aaaa", "asas", "able"
    2 valid words for "absoryz" : "aaaa", "asas"
    4 valid words for "actresz" : "aaaa", "asas", "actt", "access"
    There're no valid words for "gaswxyz" cause none of the words in the list
    contains letter 'g'.

    Constraints:
    * 1 <= words.length <= 10^5
    * 4 <= words[i].length <= 50
    * 1 <= puzzles.length <= 10^4
    * puzzles[i].length == 7
    * words[i][j], puzzles[i][j] are English lowercase letters.
    * Each puzzles[i] doesn't contain repeated characters."""

    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:
        freq = defaultdict(int)
        for word in words:
            mask = 0
            for c in word: mask |= 1 << (ord(c) - 97)
            freq[mask] += 1

        ans = []
        for puzzle in puzzles:
            mask = val = 0
            for c in puzzle: mask |= 1 << (ord(c) - 97)
            mask0 = mask # loop through sub-masks
            while mask:
                if mask & (1 << ord(puzzle[0])-97): val += freq[mask]
                mask = mask0 & (mask - 1)
            ans.append(val)
        return ans


    """1180. Count Substrings with Only One Distinct Letter (Easy)
    Given a string S, return the number of substrings that have only one
    distinct letter.

    Example 1:
    Input: S = "aaaba"
    Output: 8
    Explanation: The substrings with one distinct letter are "aaa", "aa", "a", "b".
                 "aaa" occurs 1 time.
                 "aa" occurs 2 times.
                 "a" occurs 4 times.
                 "b" occurs 1 time.
                 So the answer is 1 + 2 + 4 + 1 = 8.

    Example 2:
    Input: S = "aaaaaaaaaa"
    Output: 55

    Constraints:
    * 1 <= S.length <= 1000
    * S[i] consists of only lowercase English letters."""

    def countLetters(self, S: str) -> int:
        ans = ii = 0
        for i in range(len(S)):
            if S[ii] != S[i]: ii = i
            ans += i - ii + 1
        return ans


    """1181. Before and After Puzzle (Medium)
    Given a list of phrases, generate a list of Before and After puzzles. A
    phrase is a string that consists of lowercase English letters and spaces
    only. No space appears in the start or the end of a phrase. There are no
    consecutive spaces in a phrase. Before and After puzzles are phrases that
    are formed by merging two phrases where the last word of the first phrase
    is the same as the first word of the second phrase. Return the Before and
    After puzzles that can be formed by every two phrases phrases[i] and
    phrases[j] where i != j. Note that the order of matching two phrases
    matters, we want to consider both orders. You should return a list of
    distinct strings sorted lexicographically.

    Example 1:
    Input: phrases = ["writing code","code rocks"]
    Output: ["writing code rocks"]

    Example 2:
    Input: phrases = ["mission statement",
                      "a quick bite to eat",
                      "a chip off the old block",
                      "chocolate bar",
                      "mission impossible",
                      "a man on a mission",
                      "block party",
                      "eat my words",
                      "bar of soap"]
    Output: ["a chip off the old block party",
             "a man on a mission impossible",
             "a man on a mission statement",
             "a quick bite to eat my words",
             "chocolate bar of soap"]

    Example 3:
    Input: phrases = ["a","b","a"]
    Output: ["a"]

    Constraints:
    * 1 <= phrases.length <= 100
    * 1 <= phrases[i].length <= 100"""

    def beforeAndAfterPuzzles(self, phrases: List[str]) -> List[str]:
        ans = set()
        prefix = {}
        suffix = {}
        for i, x in enumerate(phrases):
            words = x.split()
            for j in prefix.get(words[-1], []):
                ans.add(x[:-len(words[-1])] + phrases[j])
            for j in suffix.get(words[0], []):
                ans.add(phrases[j] + x[len(words[0]):])
            prefix.setdefault(words[0], []).append(i)
            suffix.setdefault(words[-1], []).append(i)
        return sorted(ans)


    """1182. Shortest Distance to Target Color (Medium)
    You are given an array colors, in which there are three colors: 1, 2 and 3.
    You are also given some queries. Each query consists of two integers i and
    c, return the shortest distance between the given index i and the target
    color c. If there is no solution return -1.

    Example 1:
    Input: colors = [1,1,2,1,3,2,2,3,3], queries = [[1,3],[2,2],[6,1]]
    Output: [3,0,3]
    Explanation: The nearest 3 from index 1 is at index 4 (3 steps away).
                 The nearest 2 from index 2 is at index 2 itself (0 steps away).
                 The nearest 1 from index 6 is at index 3 (3 steps away).

    Example 2:
    Input: colors = [1,2], queries = [[0,3]]
    Output: [-1]
    Explanation: There is no 3 in the array.

    Constraints:
    * 1 <= colors.length <= 5*10^4
    * 1 <= colors[i] <= 3
    * 1 <= queries.length <= 5*10^4
    * queries[i].length == 2
    * 0 <= queries[i][0] < colors.length
    * 1 <= queries[i][1] <= 3"""

    def shortestDistanceColor(self, colors: List[int], queries: List[List[int]]) -> List[int]:
        locs = defaultdict(list)
        for i, x in enumerate(colors): locs[x].append(i)

        ans = []
        for i, c in queries:
            k = bisect_left(locs[c], i)
            val = inf
            if k < len(locs[c]): val = locs[c][k] - i
            if k: val = min(val, i - locs[c][k-1])
            ans.append(val if val < inf else -1)
        return ans


    """1183. Maximum Number of Ones (Hard)
    Consider a matrix M with dimensions width * height, such that every cell
    has value 0 or 1, and any square sub-matrix of M of size
    sideLength * sideLength has at most maxOnes ones. Return the maximum
    possible number of ones that the matrix M can have.

    Example 1:
    Input: width = 3, height = 3, sideLength = 2, maxOnes = 1
    Output: 4
    Explanation: In a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.
                 The best solution that has 4 ones is:
                 [1,0,1]
                 [0,0,0]
                 [1,0,1]

    Example 2:
    Input: width = 3, height = 3, sideLength = 2, maxOnes = 2
    Output: 6
    Explanation: [1,0,1]
                 [1,0,1]
                 [1,0,1]

    Constraints:
    * 1 <= width, height <= 100
    * 1 <= sideLength <= width, height
    * 0 <= maxOnes <= sideLength * sideLength"""

    def maximumNumberOfOnes(self, width: int, height: int, sideLength: int, maxOnes: int) -> int:
        if width < height: width, height = height, width
        nw, rw = divmod(width, sideLength)
        nh, rh = divmod(height, sideLength)
        ans = nw * nh * maxOnes + (nw + nh + 1) * min(maxOnes, rw * rh)
        maxOnes -= rw * rh
        if maxOnes > 0:
            ans += nw * min(maxOnes, (sideLength - rw) * rh)
            maxOnes -= (sideLength - rw) * rh
            if maxOnes > 0: ans += nh * min(maxOnes, rw * (sideLength - rh))
        return ans


    """1184. Distance Between Bus Stops (Easy)
    A bus has n stops numbered from 0 to n - 1 that form a circle. We know the
    distance between all pairs of neighboring stops where distance[i] is the
    distance between the stops number i and (i + 1) % n. The bus goes along
    both directions i.e. clockwise and counterclockwise. Return the shortest
    distance between the given start and destination stops.

    Example 1:
    Input: distance = [1,2,3,4], start = 0, destination = 1
    Output: 1
    Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.

    Example 2:
    Input: distance = [1,2,3,4], start = 0, destination = 2
    Output: 3
    Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.

    Example 3:
    Input: distance = [1,2,3,4], start = 0, destination = 3
    Output: 4
    Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.

    Constraints:
    * 1 <= n <= 10^4
    * distance.length == n
    * 0 <= start, destination < n
    * 0 <= distance[i] <= 10^4"""

    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        ans = 0
        i = start
        while i != destination:
            ans += distance[i]
            i = (i+1) % len(distance)
        return min(ans, sum(distance) - ans)


    """1185. Day of the Week (Easy)
    Given a date, return the corresponding day of the week for that date. The
    input is given as three integers representing the day, month and year
    respectively. Return the answer as one of the following values
    {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}.

    Example 1:
    Input: day = 31, month = 8, year = 2019
    Output: "Saturday"

    Example 2:
    Input: day = 18, month = 7, year = 1999
    Output: "Sunday"

    Example 3:
    Input: day = 15, month = 8, year = 1993
    Output: "Sunday"

    Constraints: The given dates are valid dates between the years 1971 and 2100."""

    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:

        def fn(y, m, d):
            """Return year-month-day in number format."""
            if m < 3:
                y -= 1
                m += 12
            return 365*y + y//4 + y//400 - y//100 + (153*m+8)//5 + d

        import calendar
        return calendar.day_name[(fn(year, month, day)-fn(1971, 1, 1)+4) % 7]


    """1186. Maximum Subarray Sum with One Deletion (Medium)
    Given an array of integers, return the maximum sum for a non-empty subarray
    (contiguous elements) with at most one element deletion. In other words,
    you want to choose a subarray and optionally delete one element from it so
    that there is still at least one element left and the sum of the remaining
    elements is maximum possible. Note that the subarray needs to be non-empty
    after deleting one element.

    Example 1:
    Input: arr = [1,-2,0,3]
    Output: 4
    Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the
                 subarray [1, 0, 3] becomes the maximum value.

    Example 2:
    Input: arr = [1,-2,-2,3]
    Output: 3
    Explanation: We just choose [3] and it's the maximum sum.

    Example 3:
    Input: arr = [-1,-1,-1,-1]
    Output: -1
    Explanation: The final subarray needs to be non-empty. You can't choose [-1]
                 and delete -1 from it, then get an empty subarray to make the
                 sum equals to 0.

    Constraints:
    * 1 <= arr.length <= 10^5
    * -10^4 <= arr[i] <= 10^4"""

    def maximumSum(self, arr: List[int]) -> int:
        ans = d0 = d1 = -inf
        for x in arr:
            d0, d1 = max(x, x + d0), max(d0, x + d1)
            ans = max(ans, d0, d1)
        return ans


    """1187. Make Array Strictly Increasing (Hard)
    Given two integer arrays arr1 and arr2, return the minimum number of
    operations (possibly zero) needed to make arr1 strictly increasing. In one
    operation, you can choose two indices 0 <= i < arr1.length and
    0 <= j < arr2.length and do the assignment arr1[i] = arr2[j]. If there is
    no way to make arr1 strictly increasing, return -1.

    Example 1:
    Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
    Output: 1
    Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].

    Example 2:
    Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]
    Output: 2
    Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].

    Example 3:
    Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
    Output: -1
    Explanation: You can't make arr1 strictly increasing.

    Constraints:
    * 1 <= arr1.length, arr2.length <= 2000
    * 0 <= arr1[i], arr2[i] <= 10^9"""

    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
        arr2.sort()

        @cache
        def fn(i, prev):
            """Return min ops to make arr1[i:] increasing w/ given previous element."""
            if i == len(arr1): return 0
            ans = inf
            if (prev < arr1[i]): ans = fn(i+1, arr1[i])
            k = bisect_right(arr2, prev)
            if k < len(arr2): ans = min(ans, 1 + fn(i+1, arr2[k]))
            return ans

        ans = fn(0, -inf)
        return ans if ans < inf else -1


    """1189. Maximum Number of Balloons (Easy)
    Given a string text, you want to use the characters of text to form as many
    instances of the word "balloon" as possible. You can use each character in
    text at most once. Return the maximum number of instances that can be formed.

    Example 1:
    Input: text = "nlaebolko"
    Output: 1

    Example 2:
    Input: text = "loonbalxballpoon"
    Output: 2

    Example 3:
    Input: text = "leetcode"
    Output: 0

    Constraints:
    * 1 <= text.length <= 10^4
    * text consists of lower case English letters only."""

    def maxNumberOfBalloons(self, text: str) -> int:
        ref = {"a":1, "b":1, "l":2, "n":1, "o":2}
        freq = defaultdict(int)
        for c in text:
            if c in "balloon": freq[c] += 1
        return min(freq[c]//ref[c] for c in ref)


    """1190. Reverse Substrings Between Each Pair of Parentheses (Medium)
    You are given a string s that consists of lower case English letters and
    brackets. Reverse the strings in each pair of matching parentheses,
    starting from the innermost one. Your result should not contain any
    brackets.

    Example 1:
    Input: s = "(abcd)"
    Output: "dcba"

    Example 2:
    Input: s = "(u(love)i)"
    Output: "iloveu"
    Explanation: The substring "love" is reversed first, then the whole string
                 is reversed.

    Example 3:
    Input: s = "(ed(et(oc))el)"
    Output: "leetcode"
    Explanation: First, we reverse the substring "oc", then "etco", and finally,
                 the whole string.

    Example 4:
    Input: s = "a(bcdefghijkl(mno)p)q"
    Output: "apmnolkjihgfedcbq"

    Constraints:
    * 0 <= s.length <= 2000
    * s only contains lower case English characters and parentheses.
    * It's guaranteed that all parentheses are balanced."""

    def reverseParentheses(self, s: str) -> str:
        stack = []
        mp = {}
        for i, c in enumerate(s):
            if c == "(": stack.append(i)
            elif c == ")":
                k = stack.pop()
                mp[i], mp[k] = k, i

        ans = []
        i, ii = 0, 1
        while i < len(s):
            if s[i] in "()":
                i = mp[i]
                ii *= -1
            else: ans.append(s[i])
            i += ii
        return "".join(ans)


    """1191. K-Concatenation Maximum Sum (Medium)
    Given an integer array arr and an integer k, modify the array by repeating
    it k times. For example, if arr = [1, 2] and k = 3 then the modified array
    will be [1, 2, 1, 2, 1, 2]. Return the maximum sub-array sum in the
    modified array. Note that the length of the sub-array can be 0 and its sum
    in that case is 0. As the answer can be very large, return the answer
    modulo 10^9 + 7.

    Example 1:
    Input: arr = [1,2], k = 3
    Output: 9

    Example 2:
    Input: arr = [1,-2,1], k = 5
    Output: 2

    Example 3:
    Input: arr = [-1,-2], k = 7
    Output: 0

    Constraints:
    * 1 <= arr.length <= 10^5
    * 1 <= k <= 10^5
    * -10^4 <= arr[i] <= 10^4"""

    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
        rsm = val = 0
        sm = sum(arr)
        if k > 1: arr *= 2
        for x in arr:
            val = max(0, val + x)
            rsm = max(rsm, val)
        return max(rsm, rsm + max(0, k-2)*sm) % 1_000_000_007


    """1192. Critical Connections in a Network (Hard)
    There are n servers numbered from 0 to n-1 connected by undirected server-
    to-server connections forming a network where connections[i] = [a, b]
    represents a connection between servers a and b. Any server can reach any
    other server directly or indirectly through the network. A critical
    connection is a connection that, if removed, will make some server unable
    to reach some other server. Return all critical connections in the network
    in any order.

    Example 1:
    Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
    Output: [[1,3]]
    Explanation: [[3,1]] is also accepted.

    Constraints:
    * 1 <= n <= 10^5
    * n-1 <= connections.length <= 10^5
    * connections[i][0] != connections[i][1]
    * There are no repeated connections."""

    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        graph = {} # graph as adjacency list
        for u, v in connections:
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)

        def dfs(x, p, step):
            """Traverse the graph and collect bridges using Tarjan's algo."""
            disc[x] = low[x] = step
            for xx in graph.get(x, []):
                if disc[xx] == inf:
                    step += 1
                    dfs(xx, x, step)
                    low[x] = min(low[x], low[xx])
                    if low[xx] > disc[x]: ans.append([x, xx]) # bridge
                elif xx != p: low[x] = min(low[x], disc[xx])

        ans = []
        low = [inf]*n
        disc = [inf]*n

        dfs(0, -1, 0)
        return ans


    """1196. How Many Apples Can You Put into the Basket (Easy)
    You have some apples, where arr[i] is the weight of the i-th apple. You
    also have a basket that can carry up to 5000 units of weight. Return the
    maximum number of apples you can put in the basket.

    Example 1:
    Input: arr = [100,200,150,1000]
    Output: 4
    Explanation: All 4 apples can be carried by the basket since their sum of
                 weights is 1450.

    Example 2:
    Input: arr = [900,950,800,1000,700,800]
    Output: 5
    Explanation: The sum of weights of the 6 apples exceeds 5000 so we choose
                 any 5 of them.

    Constraints:
    * 1 <= arr.length <= 10^3
    * 1 <= arr[i] <= 10^3"""

    def maxNumberOfApples(self, arr: List[int]) -> int:
        ans = wt = 0
        for x in sorted(arr):
            wt += x
            if wt <= 5000: ans += 1
        return ans


    """1197. Minimum Knight Moves (Medium)
    In an infinite chess board with coordinates from -infinity to +infinity,
    you have a knight at square [0, 0]. A knight has 8 possible moves it can
    make, as illustrated below. Each move is two squares in a cardinal
    direction, then one square in an orthogonal direction. Return the minimum
    number of steps needed to move the knight to the square [x, y].  It is
    guaranteed the answer exists.

    Example 1:
    Input: x = 2, y = 1
    Output: 1
    Explanation: [0, 0] → [2, 1]

    Example 2:
    Input: x = 5, y = 5
    Output: 4
    Explanation: [0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]

    Constraints: |x| + |y| <= 300"""

    def minKnightMoves(self, x: int, y: int) -> int:

        @cache
        def fn(x, y):
            """Return minimum moves from (x, y) to (0, 0)."""
            x, y = abs(x), abs(y) # symmetry
            if x == y == 0: return 0
            if x + y == 2: return 2
            return 1 + min(fn(x-2, y-1), fn(x-1, y-2))

        return fn(x, y)


    """1198. Find Smallest Common Element in All Rows (Medium)
    Given a matrix mat where every row is sorted in strictly increasing order,
    return the smallest common element in all rows. If there is no common
    element, return -1.

    Example 1:
    Input: mat = [[1,2,3,4,5],[2,4,5,8,10],[3,5,7,9,11],[1,3,5,7,9]]
    Output: 5

    Constraints:
    * 1 <= mat.length, mat[i].length <= 500
    * 1 <= mat[i][j] <= 10^4
    * mat[i] is sorted in strictly increasing order."""

    def smallestCommonElement(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0]) # dimensions
        freq = {}
        for j in range(n):
            for i in range(m):
                freq[mat[i][j]] = 1 + freq.get(mat[i][j], 0)
                if freq[mat[i][j]] == m: return mat[i][j]
        return -1


    """1199. Minimum Time to Build Blocks (Hard)
    You are given a list of blocks, where blocks[i] = t means that the i-th
    block needs t units of time to be built. A block can only be built by
    exactly one worker. A worker can either split into two workers (number of
    workers increases by one) or build a block then go home. Both decisions
    cost some time. The time cost of spliting one worker into two workers is
    given as an integer split. Note that if two workers split at the same time,
    they split in parallel so the cost would be split. Output the minimum time
    needed to build all blocks. Initially, there is only one worker.

    Example 1:
    Input: blocks = [1], split = 1
    Output: 1
    Explanation: We use 1 worker to build 1 block in 1 time unit.

    Example 2:
    Input: blocks = [1,2], split = 5
    Output: 7
    Explanation: We split the worker into 2 workers in 5 time units then assign
                 each of them to a block so the cost is 5 + max(1, 2) = 7.

    Example 3:
    Input: blocks = [1,2,3], split = 1
    Output: 4
    Explanation: Split 1 worker into 2, then assign the first worker to the
                 last block and split the second worker into 2. Then, use the
                 two unassigned workers to build the first two blocks. The cost
                 is 1 + max(3, 1 + max(1, 2)) = 4.

    Constraints:
    * 1 <= blocks.length <= 1000
    * 1 <= blocks[i] <= 10^5
    * 1 <= split <= 100"""

    def minBuildTime(self, blocks: List[int], split: int) -> int:
        pq = blocks.copy()
        heapify(pq)
        while len(pq) > 1:
            heappop(pq)
            v = heappop(pq)
            heappush(pq, v+split)
        return pq[0]


    """1200. Minimum Absolute Difference (Easy)
    Given an array of distinct integers arr, find all pairs of elements with
    the minimum absolute difference of any two elements. Return a list of pairs
    in ascending order(with respect to pairs), each pair [a, b] follows
    * a, b are from arr
    * a < b
    * b - a equals to the minimum absolute difference of any two elements in arr

    Example 1:
    Input: arr = [4,2,1,3]
    Output: [[1,2],[2,3],[3,4]]
    Explanation: The minimum absolute difference is 1. List all pairs with
                 difference equal to 1 in ascending order.

    Example 2:
    Input: arr = [1,3,6,10,15]
    Output: [[1,3]]

    Example 3:
    Input: arr = [3,8,-10,23,19,-4,-14,27]
    Output: [[-14,-10],[19,23],[23,27]]

    Constraints:
    * 2 <= arr.length <= 10^5
    * -10^6 <= arr[i] <= 10^6"""

    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        ans = []
        diff = inf
        for i in range(1, len(arr)):
            if arr[i] - arr[i-1] <= diff:
                if arr[i] - arr[i-1] < diff:
                    ans = []
                    diff = arr[i] - arr[i-1]
                ans.append([arr[i-1], arr[i]])
        return ans


    """1201. Ugly Number III (Medium)
    Given four integers n, a, b, and c, return the nth ugly number. Ugly
    numbers are positive integers that are divisible by a, b, or c.

    Example 1:
    Input: n = 3, a = 2, b = 3, c = 5
    Output: 4
    Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.

    Example 2:
    Input: n = 4, a = 2, b = 3, c = 4
    Output: 6
    Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.

    Example 3:
    Input: n = 5, a = 2, b = 11, c = 13
    Output: 10
    Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.

    Example 4:
    Input: n = 1000000000, a = 2, b = 217983653, c = 336916467
    Output: 1999999984

    Constraints:
    * 1 <= n, a, b, c <= 10^9
    * 1 <= a * b * c <= 1018
    * It is guaranteed that the result will be in range [1, 2 * 10^9]."""

    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        # inclusion-exclusion principle
        ab = a*b//gcd(a, b)
        bc = b*c//gcd(b, c)
        ca = c*a//gcd(c, a)
        abc = ab*c//gcd(ab, c)

        lo, hi = 1, n*min(a, b, c)
        while lo < hi:
            mid = lo + hi >> 1
            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1
            else: hi = mid
        return lo


    """1202. Smallest String With Swaps (Medium)
    You are given a string s, and an array of pairs of indices in the string
    pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string.
    You can swap the characters at any pair of indices in the given pairs any
    number of times. Return the lexicographically smallest string that s can be
    changed to after using the swaps.

    Example 1:
    Input: s = "dcab", pairs = [[0,3],[1,2]]
    Output: "bacd"
    Explaination:
    Swap s[0] and s[3], s = "bcad"
    Swap s[1] and s[2], s = "bacd"

    Example 2:
    Input: s = "dcab", pairs = [[0,3],[1,2],[0,2]]
    Output: "abcd"
    Explaination:
    Swap s[0] and s[3], s = "bcad"
    Swap s[0] and s[2], s = "acbd"
    Swap s[1] and s[2], s = "abcd"

    Example 3:
    Input: s = "cba", pairs = [[0,1],[1,2]]
    Output: "abc"
    Explaination:
    Swap s[0] and s[1], s = "bca"
    Swap s[1] and s[2], s = "bac"
    Swap s[0] and s[1], s = "abc"

    Constraints:
    * 1 <= s.length <= 10^5
    * 0 <= pairs.length <= 10^5
    * 0 <= pairs[i][0], pairs[i][1] < s.length
    * s only contains lower case English letters."""

    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        s = list(s)

        uf = UnionFind(len(s))
        for u, v in pairs:
            uf.union(u, v)

        mp = {}
        for n in range(len(s)):
            mp.setdefault(uf.find(n), []).append(n)

        for v in mp.values():
            vals = [s[vv] for vv in v]
            for vv, xx in zip(v, sorted(vals)):
                s[vv] = xx
        return "".join(s)


    """1203. Sort Items by Groups Respecting Dependencies (Hard)
    There are n items each belonging to zero or one of m groups where group[i]
    is the group that the i-th item belongs to and it's equal to -1 if the i-th
    item belongs to no group. The items and the groups are zero indexed. A
    group can have no item belonging to it. Return a sorted list of the items
    such that:
    * The items that belong to the same group are next to each other in the
      sorted list.
    * There are some relations between these items where beforeItems[i] is a
      list containing all the items that should come before the i-th item in
      the sorted array (to the left of the i-th item).
    Return any solution if there is more than one solution and return an empty
    list if there is no solution.

    Example 1:
    Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
    Output: [6,3,4,1,5,2,0,7]

    Example 2:
    Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
    Output: []
    Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.

    Constraints:
    * 1 <= m <= n <= 3 * 10^4
    * group.length == beforeItems.length == n
    * -1 <= group[i] <= m - 1
    * 0 <= beforeItems[i].length <= n - 1
    * 0 <= beforeItems[i][j] <= n - 1
    * i != beforeItems[i][j]
    * beforeItems[i] does not contain duplicates elements."""

    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:
        for i in range(n):
            if group[i] == -1: group[i] = i + m # re-group

        graph0 = {} # digraph of groups
        indeg0 = [0]*(m+n) # indegree of groups

        graph1 = {} # digrpah of items
        indeg1 = [0]*n # indegree of items

        for i, x in enumerate(beforeItems):
            for xx in x:
                if group[xx] != group[i]:
                    graph0.setdefault(group[xx], []).append(group[i])
                    indeg0[group[i]] += 1
                graph1.setdefault(xx, []).append(i)
                indeg1[i] += 1

        def fn(graph, indeg):
            """Return topological sort of graph using Kahn's algo."""
            ans = []
            stack = [k for k in range(len(indeg)) if indeg[k] == 0]
            while stack:
                n = stack.pop()
                ans.append(n)
                for nn in graph.get(n, []):
                    indeg[nn] -= 1
                    if indeg[nn] == 0: stack.append(nn)
            return ans

        tp0 = fn(graph0, indeg0)
        if len(tp0) != len(indeg0): return []

        tp1 = fn(graph1, indeg1)
        if len(tp1) != len(indeg1): return []

        mp0 = {x: i for i, x in enumerate(tp0)}
        mp1 = {x: i for i, x in enumerate(tp1)}

        return sorted(range(n), key=lambda x: (mp0[group[x]], mp1[x]))


    """1207. Unique Number of Occurrences (Easy)
    Given an array of integers arr, write a function that returns true if and
    only if the number of occurrences of each value in the array is unique.

    Example 1:
    Input: arr = [1,2,2,1,1,3]
    Output: true
    Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two
                 values have the same number of occurrences.

    Example 2:
    Input: arr = [1,2]
    Output: false

    Example 3:
    Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
    Output: true

    Constraints:
    * 1 <= arr.length <= 1000
    * -1000 <= arr[i] <= 1000"""

    def uniqueOccurrences(self, arr: List[int]) -> bool:
        freq = {}
        for x in arr:
            freq[x] = 1 + freq.get(x, 0)
        return len(freq) == len(set(freq.values()))


    """1208. Get Equal Substrings Within Budget (Medium)
    You are given two strings s and t of the same length. You want to change s
    to t. Changing the i-th character of s to i-th character of t costs
    |s[i] - t[i]| that is, the absolute difference between the ASCII values of
    the characters. You are also given an integer maxCost. Return the maximum
    length of a substring of s that can be changed to be the same as the
    corresponding substring of twith a cost less than or equal to maxCost. If
    there is no substring from s that can be changed to its corresponding
    substring from t, return 0.

    Example 1:
    Input: s = "abcd", t = "bcdf", maxCost = 3
    Output: 3
    Explanation: "abc" of s can change to "bcd". That costs 3, so the maximum
                 length is 3.

    Example 2:
    Input: s = "abcd", t = "cdef", maxCost = 3
    Output: 1
    Explanation: Each character in s costs 2 to change to charactor in t, so
                 the maximum length is 1.

    Example 3:
    Input: s = "abcd", t = "acde", maxCost = 0
    Output: 1
    Explanation: You can't make any change, so the maximum length is 1.

    Constraints:
    * 1 <= s.length, t.length <= 10^5
    * 0 <= maxCost <= 10^6
    * s and t only contain lower case English letters."""

    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        ans = ii = val = 0
        for i in range(len(s)):
            val += abs(ord(s[i]) - ord(t[i]))
            while val > maxCost:
                val -= abs(ord(s[ii]) - ord(t[ii]))
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans


    """1209. Remove All Adjacent Duplicates in String II (Medium)
    Given a string s, a k duplicate removal consists of choosing k adjacent and
    equal letters from s and removing them causing the left and the right side
    of the deleted substring to concatenate together. We repeatedly make k
    duplicate removals on s until we no longer can. Return the final string
    after all such duplicate removals have been made. It is guaranteed that the
    answer is unique.

    Example 1:
    Input: s = "abcd", k = 2
    Output: "abcd"
    Explanation: There's nothing to delete.

    Example 2:
    Input: s = "deeedbbcccbdaa", k = 3
    Output: "aa"
    Explanation: First delete "eee" and "ccc", get "ddbbbdaa"
                 Then delete "bbb", get "dddaa"
                 Finally delete "ddd", get "aa"

    Example 3:
    Input: s = "pbbcggttciiippooaais", k = 2
    Output: "ps"

    Constraints:
    * 1 <= s.length <= 10^5
    * 2 <= k <= 10^4
    * s only contains lower case English letters."""

    def removeDuplicates(self, s: str, k: int) -> str:
        stack = []
        for i, c in enumerate(s):
            if stack and stack[-1][0] == c:
                stack[-1][1] += 1
            else: stack.append([c, 1])
            if stack[-1][1] == k: stack.pop()
        return "".join(c*x for c, x in stack)


    """1210. Minimum Moves to Reach Target with Rotations
    In an n*n grid, there is a snake that spans 2 cells and starts moving from
    the top left corner at (0, 0) and (0, 1). The grid has empty cells
    represented by zeros and blocked cells represented by ones. The snake wants
    to reach the lower right corner at (n-1, n-2) and (n-1, n-1). In one move
    the snake can:
    * Move one cell to the right if there are no blocked cells there. This move
      keeps the horizontal/vertical position of the snake as it is.
    * Move down one cell if there are no blocked cells there. This move keeps
      the horizontal/vertical position of the snake as it is.
    * Rotate clockwise if it's in a horizontal position and the two cells under
      it are both empty. In that case the snake moves from (r, c) and (r, c+1)
      to (r, c) and (r+1, c).
    * Rotate counterclockwise if it's in a vertical position and the two cells
      to its right are both empty. In that case the snake moves from (r, c) and
      (r+1, c) to (r, c) and (r, c+1).
    Return the minimum number of moves to reach the target. If there is no way
    to reach the target, return -1.

    Example 1:
    Input: grid = [[0,0,0,0,0,1],
                   [1,1,0,0,1,0],
                   [0,0,0,0,1,1],
                   [0,0,1,0,1,0],
                   [0,1,1,0,0,0],
                   [0,1,1,0,0,0]]
    Output: 11
    Explanation: One possible solution is [right, right, rotate clockwise,
                 right, down, down, down, down, rotate counterclockwise, right,
                 down].

    Example 2:
    Input: grid = [[0,0,1,1,1,1],
                   [0,0,0,0,1,1],
                   [1,1,0,0,0,1],
                   [1,1,1,0,0,1],
                   [1,1,1,0,0,1],
                   [1,1,1,0,0,0]]
    Output: 9

    Constraints:
    * 2 <= n <= 100
    * 0 <= grid[i][j] <= 1
    * It is guaranteed that the snake starts at empty cells."""

    def minimumMoves(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dist = {(0, 0, 0, 1): 0}
        pq = [(0, 0, 0, 0, 1)]
        while pq:
            x, i, j, ii, jj = heappop(pq)
            if i == n-1 and j == n-2 and ii == n-1 and jj == n-1: return x
            if ii+1 < n and grid[i+1][j] == grid[ii+1][jj] == 0 and x+1 < dist.get((i+1, j, ii+1, jj), inf):
                heappush(pq, (x+1, i+1, j, ii+1, jj))
                dist[i+1, j, ii+1, jj] = x + 1
            if jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and x+1 < dist.get((i, j+1, ii, jj+1), inf):
                heappush(pq, (x+1, i, j+1, ii, jj+1))
                dist[i, j+1, ii, jj+1] = x + 1
            if i == ii and ii+1 < n and grid[i+1][j] == grid[i+1][jj] == 0 and x+1 < dist.get((i, j, i+1, j), inf):
                heappush(pq, (x+1, i, j, i+1, j))
                dist[i, j, i+1, j] = x + 1
            if j == jj and jj+1 < n and grid[i][j+1] == grid[ii][j+1] == 0 and x+1 < dist.get((i, j, i, j+1), inf):
                heappush(pq, (x+1, i, j, i, j+1))
                dist[i, j, i, j+1] = x + 1
        return -1


    """1213. Intersection of Three Sorted Arrays (Easy)
    Given three integer arrays arr1, arr2 and arr3 sorted in strictly
    increasing order, return a sorted array of only the integers that
    appeared in all three arrays.

    Example 1:
    Input: arr1 = [1,2,3,4,5],
           arr2 = [1,2,5,7,9],
           arr3 = [1,3,4,5,8]
    Output: [1,5]
    Explanation: Only 1 and 5 appeared in the three arrays.

    Example 2:
    Input: arr1 = [197,418,523,876,1356],
           arr2 = [501,880,1593,1710,1870],
           arr3 = [521,682,1337,1395,1764]
    Output: []

    Constraints:
    * 1 <= arr1.length, arr2.length, arr3.length <= 1000
    * 1 <= arr1[i], arr2[i], arr3[i] <= 2000"""

    def arraysIntersection(self, arr1: List[int], arr2: List[int], arr3: List[int]) -> List[int]:
        ans = []
        i1 = i2 = i3 = 0
        while i1 < len(arr1) and i2 < len(arr2) and i3 < len(arr3):
            if arr1[i1] == arr2[i2] == arr3[i3]: ans.append(arr1[i1])
            mn = min(arr1[i1], arr2[i2], arr3[i3])
            if arr1[i1] == mn: i1 += 1
            if arr2[i2] == mn: i2 += 1
            if arr3[i3] == mn: i3 += 1
        return ans


    """1214. Two Sum BSTs (Medium)
    Given the roots of two binary search trees, root1 and root2, return true if
    and only if there is a node in the first tree and a node in the second tree
    whose values sum up to a given integer target.

    Example 1:
    Input: root1 = [2,1,4], root2 = [1,0,3], target = 5
    Output: true
    Explanation: 2 and 3 sum up to 5.

    Example 2:
    Input: root1 = [0,-10,10], root2 = [5,1,7,0,2], target = 18
    Output: false

    Constraints:
    * The number of nodes in each tree is in the range [1, 5000].
    * -10^9 <= Node.val, target <= 10^9"""

    def twoSumBSTs(self, root1: TreeNode, root2: TreeNode, target: int) -> bool:

        def fn(node):
            """Return inorder traversal of binary tree."""
            ans, stack = [], []
            while stack or node:
                if node:
                    stack.append(node)
                    node = node.left
                else:
                    node = stack.pop()
                    ans.append(node.val)
                    node = node.right
            return ans

        val1, val2 = fn(root1), fn(root2)
        lo, hi = 0, len(val2)-1
        while lo < len(val1) and 0 <= hi:
            if val1[lo] + val2[hi] < target: lo += 1
            elif val1[lo] + val2[hi] == target: return True
            else: hi -= 1
        return False


    """1215. Stepping Numbers (Medium)
    A stepping number is an integer such that all of its adjacent digits have
    an absolute difference of exactly 1. For example, 321 is a stepping number
    while 421 is not. Given two integers low and high, return a sorted list of
    all the stepping numbers in the inclusive range [low, high].

    Example 1:
    Input: low = 0, high = 21
    Output: [0,1,2,3,4,5,6,7,8,9,10,12,21]

    Example 2:
    Input: low = 10, high = 15
    Output: [10,12]

    Constraints: 0 <= low <= high <= 2 * 10^9"""

    def countSteppingNumbers(self, low: int, high: int) -> List[int]:
        ans = [0]
        queue = deque([1, 2, 3, 4, 5, 6, 7, 8, 9])
        while queue:
            x = queue.popleft()
            if x <= high:
                ans.append(x)
                for dd in x%10-1, x%10+1:
                    if 0 <= dd < 10: queue.append(10*x+dd)
        return [x for x in ans if low <= x]


    """1216. Valid Palindrome III (Hard)
    Given a string s and an integer k, return true if s is a k-palindrome. A
    string is k-palindrome if it can be transformed into a palindrome by
    removing at most k characters from it.

    Example 1:
    Input: s = "abcdeca", k = 2
    Output: true
    Explanation: Remove 'b' and 'e' characters.

    Example 2:
    Input: s = "abbababa", k = 1
    Output: true

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of only lowercase English letters.
    * 1 <= k <= s.length"""

    def isValidPalindrome(self, s: str, k: int) -> bool:
        n = len(s)
        dp = [[0]*n for _ in range(n+1)]
        for i in range(n-1, -1, -1):
            dp[i][i] = 1
            for j in range(i+1, n):
                if s[i] == s[j]: dp[i][j] = 2 + dp[i+1][j-1]
                else: dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return dp[0][-1] >= n - k


    """1217. Minimum Cost to Move Chips to The Same Position (Easy)
    We have n chips, where the position of the ith chip is position[i]. We need
    to move all the chips to the same position. In one step, we can change the
    position of the ith chip from position[i] to:
    * position[i] + 2 or position[i] - 2 with cost = 0.
    * position[i] + 1 or position[i] - 1 with cost = 1.
    Return the minimum cost needed to move all the chips to the same position.

    Example 1:
    Input: position = [1,2,3]
    Output: 1
    Explanation: First step: Move the chip at position 3 to position 1 with cost = 0.
                 Second step: Move the chip at position 2 to position 1 with cost = 1.
                 Total cost is 1.

    Example 2:
    Input: position = [2,2,2,3,3]
    Output: 2
    Explanation: We can move the two chips at position  3 to position 2. Each
                 move has cost = 1. The total cost = 2.

    Example 3:
    Input: position = [1,1000000000]
    Output: 1

    Constraints:
    * 1 <= position.length <= 100
    * 1 <= position[i] <= 10^9"""

    def minCostToMoveChips(self, position: List[int]) -> int:
        odd = even = 0
        for x in position:
            if x&1: odd += 1
            else: even += 1
        return min(odd, even)


    """1218. Longest Arithmetic Subsequence of Given Difference (Medium)
    Given an integer array arr and an integer difference, return the length of
    the longest subsequence in arr which is an arithmetic sequence such that
    the difference between adjacent elements in the subsequence equals
    difference. A subsequence is a sequence that can be derived from arr by
    deleting some or no elements without changing the order of the remaining
    elements.

    Example 1:
    Input: arr = [1,2,3,4], difference = 1
    Output: 4
    Explanation: The longest arithmetic subsequence is [1,2,3,4].

    Example 2:
    Input: arr = [1,3,5,7], difference = 1
    Output: 1
    Explanation: The longest arithmetic subsequence is any single element.

    Example 3:
    Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
    Output: 4
    Explanation: The longest arithmetic subsequence is [7,5,3,1].

    Constraints:
    * 1 <= arr.length <= 10^5
    * -10^4 <= arr[i], difference <= 10^4"""

    def longestSubsequence(self, arr: List[int], difference: int) -> int:
        ans = 0
        seen = {}
        for x in arr:
            seen[x] = 1 + seen.get(x-difference, 0)
            ans = max(ans, seen[x])
        return ans


    """1219. Path with Maximum Gold (Medium)
    In a gold mine grid of size m * n, each cell in this mine has an integer
    representing the amount of gold in that cell, 0 if it is empty. Return the
    maximum amount of gold you can collect under the conditions:
    * Every time you are located in a cell you will collect all the gold in
      that cell.
    * From your position you can walk one step to the left, right, up or down.
    * You can't visit the same cell more than once.
    * Never visit a cell with 0 gold.
    * You can start and stop collecting gold from any position in the grid that
      has some gold.

    Example 1:
    Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
    Output: 24
    Explanation:
    [[0,6,0],
     [5,8,7],
     [0,9,0]]
    Path to get the maximum gold, 9 -> 8 -> 7.

    Example 2:
    Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
    Output: 28
    Explanation:
    [[1,0,7],
     [2,0,6],
     [3,4,5],
     [0,3,0],
     [9,0,20]]
    Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 15
    * 0 <= grid[i][j] <= 100
    * There are at most 25 cells containing gold."""

    def getMaximumGold(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        def fn(i, j):
            """Return max gold mine starting from (i, j)."""
            v = grid[i][j]
            ans = grid[i][j] = 0
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]:
                    ans = max(ans, fn(ii, jj))
            grid[i][j] = v
            return grid[i][j] + ans

        return max((fn(i, j) for i, j in product(range(m), range(n)) if grid[i][j]), default=0)


    """1220. Count Vowels Permutation (Hard)
    Given an integer n, your task is to count how many strings of length n can
    be formed under the following rules:
    * Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
    * Each vowel 'a' may only be followed by an 'e'.
    * Each vowel 'e' may only be followed by an 'a' or an 'i'.
    * Each vowel 'i' may not be followed by another 'i'.
    * Each vowel 'o' may only be followed by an 'i' or a 'u'.
    * Each vowel 'u' may only be followed by an 'a'.
    Since the answer may be too large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 1
    Output: 5
    Explanation: All possible strings are: "a", "e", "i" , "o" and "u".

    Example 2:
    Input: n = 2
    Output: 10
    Explanation: All possible strings are: "ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" and "ua".

    Example 3:
    Input: n = 5
    Output: 68

    Constraints: 1 <= n <= 2 * 10^4"""

    def countVowelPermutation(self, n: int) -> int:
        a = e = i = o = u = 1
        for _ in range(n-1):
            a, e, i, o, u = e, a+i, a+e+o+u, i+u, a
        return (a+e+i+o+u) % 1_000_000_007


    """1221. Split a String in Balanced Strings (Easy)
    Balanced strings are those that have an equal quantity of 'L' and 'R'
    characters. Given a balanced string s, split it in the maximum amount of
    balanced strings. Return the maximum amount of split balanced strings.

    Example 1:
    Input: s = "RLRRLLRLRL"
    Output: 4
    Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring
                 contains same number of 'L' and 'R'.

    Example 2:
    Input: s = "RLLLLRRRLR"
    Output: 3
    Explanation: s can be split into "RL", "LLLRRR", "LR", each substring
                 contains same number of 'L' and 'R'.

    Example 3:
    Input: s = "LLLLRRRR"
    Output: 1
    Explanation: s can be split into "LLLLRRRR".

    Example 4:
    Input: s = "RLRRRLLRLL"
    Output: 2
    Explanation: s can be split into "RL", "RRRLLRLL", since each substring
                 contains an equal number of 'L' and 'R'

    Constraints:
    * 1 <= s.length <= 1000
    * s[i] is either 'L' or 'R'.
    * s is a balanced string."""

    def balancedStringSplit(self, s: str) -> int:
        ans = prefix = 0
        for c in s:
            prefix += 1 if c == "R" else -1
            if not prefix: ans += 1
        return ans


    """1221. Split a String in Balanced Strings (Easy)
    Balanced strings are those that have an equal quantity of 'L' and 'R'
    characters. Given a balanced string s, split it in the maximum amount of
    balanced strings. Return the maximum amount of split balanced strings.

    Example 1:
    Input: s = "RLRRLLRLRL"
    Output: 4
    Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring
                 contains same number of 'L' and 'R'.

    Example 2:
    Input: s = "RLLLLRRRLR"
    Output: 3
    Explanation: s can be split into "RL", "LLLRRR", "LR", each substring
                 contains same number of 'L' and 'R'.

    Example 3:
    Input: s = "LLLLRRRR"
    Output: 1
    Explanation: s can be split into "LLLLRRRR".

    Example 4:
    Input: s = "RLRRRLLRLL"
    Output: 2
    Explanation: s can be split into "RL", "RRRLLRLL", since each substring
                 contains an equal number of 'L' and 'R'

    Constraints:
    * 1 <= s.length <= 1000
    * s[i] is either 'L' or 'R'.
    * s is a balanced string."""

    def balancedStringSplit(self, s: str) -> int:
        ans = prefix = 0
        for c in s:
            prefix += 1 if c == "R" else -1
            if not prefix: ans += 1
        return ans


    """1222. Queens That Can Attack the King (Medium)
    On an 8x8 chessboard, there can be multiple Black Queens and one White King.
    Given an array of integer coordinates queens that represents the positions
    of the Black Queens, and a pair of coordinates king that represent the
    position of the White King, return the coordinates of all the queens (in any
    order) that can attack the King.

    Example 1:
    Input: queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
    Output: [[0,1],[1,0],[3,3]]
    Explanation:
    The queen at [0,1] can attack the king cause they're in the same row.
    The queen at [1,0] can attack the king cause they're in the same column.
    The queen at [3,3] can attack the king cause they're in the same diagnal.
    The queen at [0,4] can't attack the king cause it's blocked by the queen at [0,1].
    The queen at [4,0] can't attack the king cause it's blocked by the queen at [1,0].
    The queen at [2,4] can't attack the king cause it's not in the same row/column/diagnal as the king.

    Example 2:
    Input: queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
    Output: [[2,2],[3,4],[4,4]]

    Example 3:
    Input: queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],
                     [1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],
                     [2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],
                     [2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]
    Output: [[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]

    Constraints:
    * 1 <= queens.length <= 63
    * queens[i].length == 2
    * 0 <= queens[i][j] < 8
    * king.length == 2
    * 0 <= king[0], king[1] < 8
    * At most one piece is allowed in a cell."""

    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:
        ans = []
        x, y = king
        queens = {(x, y) for x, y in queens}
        for dx in (-1, 0, 1):
            for dy in (-1, 0, 1):
                for k in range(1, 8):
                    xx, yy = x+k*dx, y+k*dy
                    if (xx, yy) in queens:
                        ans.append([xx, yy])
                        break
        return ans


    """1223. Dice Roll Simulation (Hard)
    A die simulator generates a random number from 1 to 6 for each roll. You
    introduced a constraint to the generator such that it cannot roll the
    number i more than rollMax[i] (1-indexed) consecutive times.  Given an
    array of integers rollMax and an integer n, return the number of distinct
    sequences that can be obtained with exact n rolls. Two sequences are
    considered different if at least one element differs from each other. Since
    the answer may be too large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 2, rollMax = [1,1,2,2,2,3]
    Output: 34
    Explanation: There will be 2 rolls of die, if there are no constraints on
                 the die, there are 6 * 6 = 36 possible combinations. In this
                 case, looking at rollMax array, the numbers 1 and 2 appear at
                 most once consecutively, therefore sequences (1,1) and (2,2)
                 cannot occur, so the final answer is 36-2 = 34.

    Example 2:
    Input: n = 2, rollMax = [1,1,1,1,1,1]
    Output: 30

    Example 3:
    Input: n = 3, rollMax = [1,1,1,2,2,3]
    Output: 181

    Constraints:
    * 1 <= n <= 5000
    * rollMax.length == 6
    * 1 <= rollMax[i] <= 15"""

    def dieSimulator(self, n: int, rollMax: List[int]) -> int:

        @cache
        def fn(n, x, r):
            """Return number of sequences with n rolls left with r occurrences of x."""
            if n == 0: return 1
            ans = 0
            for xx in range(6):
                if xx != x: ans += fn(n-1, xx, 1)
                elif xx == x and r < rollMax[x]: ans += fn(n-1, x, r+1)
            return ans

        return sum(fn(n-1, x, 1) for x in range(6)) % 1_000_000_007


    """1224. Maximum Equal Frequency (Hard)
    Given an array nums of positive integers, return the longest possible
    length of an array prefix of nums, such that it is possible to remove
    exactly one element from this prefix so that every number that has appeared
    in it will have the same number of occurrences. If after removing one
    element there are no remaining elements, it's still considered that every
    appeared number has the same number of ocurrences (0).

    Example 1:
    Input: nums = [2,2,1,1,5,3,3,5]
    Output: 7
    Explanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove
                 nums[4]=5, we will get [2,2,1,1,3,3], so that each number
                 will appear exactly twice.

    Example 2:
    Input: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
    Output: 13

    Example 3:
    Input: nums = [1,1,1,2,2,2]
    Output: 5

    Example 4:
    Input: nums = [10,2,8,9,3,8,1,5,2,3,7,6]
    Output: 8

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def maxEqualFreq(self, nums: List[int]) -> int:
        ans = most = 0
        cnt = defaultdict(int)
        freq = defaultdict(int)
        for i, x in enumerate(nums):
            cnt[x] += 1
            freq[cnt[x]-1] -= 1
            freq[cnt[x]] += 1
            most = max(most, cnt[x])
            if most == 1 or most * freq[most] == i or (most-1)*freq[most-1] + most == i+1: ans = i+1
        return ans


    """1228. Missing Number In Arithmetic Progression (Easy)
    In some array arr, the values were in arithmetic progression: the values
    arr[i+1] - arr[i] are all equal for every 0 <= i < arr.length - 1. Then, a
    value from arr was removed that was not the first or last value in the
    array. Return the removed value.

    Example 1:
    Input: arr = [5,7,11,13]
    Output: 9
    Explanation: The previous array was [5,7,9,11,13].

    Example 2:
    Input: arr = [15,13,12]
    Output: 14
    Explanation: The previous array was [15,14,13,12].

    Constraints:
    * 3 <= arr.length <= 1000
    * 0 <= arr[i] <= 10^5"""

    def missingNumber(self, arr: List[int]) -> int:
        chg = (arr[-1] - arr[0])//len(arr)
        lo, hi = 0, len(arr)
        while lo < hi:
            mid = lo + hi >> 1
            if arr[mid] == arr[0] + mid * chg: lo = mid + 1
            else: hi = mid
        return arr[0] + lo * chg


    """1229. Meeting Scheduler (Medium)
    Given the availability time slots arrays slots1 and slots2 of two people
    and a meeting duration duration, return the earliest time slot that works
    for both of them and is of duration duration. If there is no common time
    slot that satisfies the requirements, return an empty array. The format of
    a time slot is an array of two elements [start, end] representing an
    inclusive time range from start to end. It is guaranteed that no two
    availability slots of the same person intersect with each other. That is,
    for any two time slots [start1, end1] and [start2, end2] of the same person,
    either start1 > end2 or start2 > end1.

    Example 1:
    Input: slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8
    Output: [60,68]

    Example 2:
    Input: slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 12
    Output: []

    Constraints:
    * 1 <= slots1.length, slots2.length <= 10^4
    * slots1[i].length, slots2[i].length == 2
    * slots1[i][0] < slots1[i][1]
    * slots2[i][0] < slots2[i][1]
    * 0 <= slots1[i][j], slots2[i][j] <= 10^9
    * 1 <= duration <= 10^6"""

    def minAvailableDuration(self, slots1: List[List[int]], slots2: List[List[int]], duration: int) -> List[int]:
        slots1.sort()
        slots2.sort()
        i = j = 0
        while i < len(slots1) and j < len(slots2):
            start = max(slots1[i][0], slots2[j][0])
            end = min(slots1[i][1], slots2[j][1])
            if start + duration <= end: return [start, start + duration]
            if slots1[i][1] <= slots2[j][1]: i += 1
            else: j += 1
        return []


    """1230. Toss Strange Coins (Medium)
    You have some coins. The i-th coin has a probability prob[i] of facing
    heads when tossed. Return the probability that the number of coins facing
    heads equals target if you toss every coin exactly once.

    Example 1:
    Input: prob = [0.4], target = 1
    Output: 0.40000

    Example 2:
    Input: prob = [0.5,0.5,0.5,0.5,0.5], target = 0
    Output: 0.03125

    Constraints:
    * 1 <= prob.length <= 1000
    * 0 <= prob[i] <= 1
    * 0 <= target <= prob.length
    * Answers will be accepted as correct if they are within 10^-5 of the
      correct answer."""

    def probabilityOfHeads(self, prob: List[float], target: int) -> float:
        dp = [[0]*(1 + target) for _ in range(1 + len(prob))]
        dp[-1][0] = 1
        for i in reversed(range(len(prob))):
            for j in range(target+1):
                if j: dp[i][j] = prob[i]*dp[i+1][j-1]
                dp[i][j] += (1-prob[i])*dp[i+1][j]
        return dp[0][-1]


    """1231. Divide Chocolate (Hard)
    You have one chocolate bar that consists of some chunks. Each chunk has its
    own sweetness given by the array sweetness. You want to share the chocolate
    with your k friends so you start cutting the chocolate bar into k + 1
    pieces using k cuts, each piece consists of some consecutive chunks. Being
    generous, you will eat the piece with the minimum total sweetness and give
    the other pieces to your friends. Find the maximum total sweetness of the
    piece you can get by cutting the chocolate bar optimally.

    Example 1:
    Input: sweetness = [1,2,3,4,5,6,7,8,9], k = 5
    Output: 6
    Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]

    Example 2:
    Input: sweetness = [5,6,7,8,9,1,2,3,4], k = 8
    Output: 1
    Explanation: There is only one way to cut the bar into 9 pieces.

    Example 3:
    Input: sweetness = [1,2,2,1,2,2,1,2,2], k = 2
    Output: 5
    Explanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]

    Constraints:
    * 0 <= k < sweetness.length <= 10^4
    * 1 <= sweetness[i] <= 10^5"""

    def maximizeSweetness(self, sweetness: List[int], k: int) -> int:
        lo, hi = 0, 1_000_000_000
        while lo < hi:
            mid = lo + hi + 1 >> 1
            cnt = prefix = 0
            for x in sweetness:
                prefix += x
                if prefix >= mid:
                    cnt += 1
                    prefix = 0
            if cnt < k+1: hi = mid - 1
            else: lo = mid
        return lo


    """1232. Check If It Is a Straight Line (Easy)
    You are given an array coordinates, coordinates[i] = [x, y], where [x, y]
    represents the coordinate of a point. Check if these points make a straight
    line in the XY plane.

    Example 1:
    Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
    Output: true

    Example 2:
    Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
    Output: false

    Constraints:
    * 2 <= coordinates.length <= 1000
    * coordinates[i].length == 2
    * -10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4
    * coordinates contains no duplicate point."""

    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
        x0, y0 = coordinates[0]
        x1, y1 = coordinates[1]
        for x, y in coordinates[2:]:
            if (y1-y0)*(x-x0) != (y-y0)*(x1-x0): return False
        return True


    """1233. Remove Sub-Folders from the Filesystem (Medium)
    Given a list of folders, remove all sub-folders in those folders and return
    in any order the folders after removing. If a folder[i] is located within
    another folder[j], it is called a sub-folder of it. The format of a path is
    one or more concatenated strings of the form: / followed by one or more
    lowercase English letters. For example, /leetcode and /leetcode/problems
    are valid paths while an empty string and / are not.

    Example 1:
    Input: folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
    Output: ["/a","/c/d","/c/f"]
    Explanation: Folders "/a/b/" is a subfolder of "/a" and "/c/d/e" is inside
                 of folder "/c/d" in our filesystem.

    Example 2:
    Input: folder = ["/a","/a/b/c","/a/b/d"]
    Output: ["/a"]
    Explanation: Folders "/a/b/c" and "/a/b/d/" will be removed because they
                 are subfolders of "/a".

    Example 3:
    Input: folder = ["/a/b/c","/a/b/ca","/a/b/d"]
    Output: ["/a/b/c","/a/b/ca","/a/b/d"]

    Constraints:
    * 1 <= folder.length <= 4 * 10^4
    * 2 <= folder[i].length <= 100
    * folder[i] contains only lowercase letters and '/'
    * folder[i] always starts with character '/'
    * Each folder name is unique."""

    def removeSubfolders(self, folder: List[str]) -> List[str]:
        ans = []
        for x in sorted(folder):
            if not ans or not x.startswith(ans[-1]+"/"):
                ans.append(x)
        return ans


    """1234. Replace the Substring for Balanced String (Medium)
    You are given a string containing only 4 kinds of characters 'Q', 'W', 'E'
    and 'R'. A string is said to be balanced if each of its characters appears
    n/4 times where n is the length of the string. Return the minimum length of
    the substring that can be replaced with any other string of the same length
    to make the original string s balanced. Return 0 if the string is already
    balanced.

    Example 1:
    Input: s = "QWER"
    Output: 0
    Explanation: s is already balanced.

    Example 2:
    Input: s = "QQWE"
    Output: 1
    Explanation: We need to replace a 'Q' to 'R', so that "RQWE" (or "QRWE") is balanced.

    Example 3:
    Input: s = "QQQW"
    Output: 2
    Explanation: We can replace the first "QQ" to "ER".

    Example 4:
    Input: s = "QQQQ"
    Output: 3
    Explanation: We can replace the last 3 'Q' to make s = "QWER".

    Constraints:
    * 1 <= s.length <= 10^5
    * s.length is a multiple of 4
    * s contains only 'Q', 'W', 'E' and 'R'."""

    def balancedString(self, s: str) -> int:
        freq = {}
        for c in s: freq[c] = 1 + freq.get(c, 0)

        ans = len(s)
        ii = 0
        for i, c in enumerate(s):
            freq[c] -= 1
            while ii < len(s) and all(freq[x] <= len(s)//4 for x in freq):
                ans = min(ans, i-ii+1)
                freq[s[ii]] += 1
                ii += 1
        return ans


    """1235. Maximum Profit in Job Scheduling (Hard)
    We have n jobs, where every job is scheduled to be done from startTime[i]
    to endTime[i], obtaining a profit of profit[i]. You're given the startTime,
    endTime and profit arrays, return the maximum profit you can take such that
    there are no two jobs in the subset with overlapping time range. If you
    choose a job that ends at time X you will be able to start another job that
    starts at time X.

    Example 1:
    Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
    Output: 120
    Explanation: The subset chosen is the first and fourth job. Time range
                 [1-3]+[3-6] , we get profit of 120 = 50 + 70.

    Example 2:
    Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
    Output: 150
    Explanation: The subset chosen is the first, fourth and fifth job. Profit
                 obtained 150 = 20 + 70 + 60.

    Example 3:
    Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
    Output: 6

    Constraints:
    * 1 <= startTime.length == endTime.length == profit.length <= 5 * 10^4
    * 1 <= startTime[i] < endTime[i] <= 10^9
    * 1 <= profit[i] <= 10^4"""

    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        startTime, endTime, profit = zip(*sorted(zip(startTime, endTime, profit)))

        @cache
        def fn(i):
            """Return max profit starting from index i."""
            if i == len(startTime): return 0
            ii = bisect_left(startTime, endTime[i])
            return max(fn(i+1), profit[i] + fn(ii))

        return fn(0)


    """1236. Web Crawler (Medium)
    Given a url startUrl and an interface HtmlParser, implement a web crawler
    to crawl all links that are under the same hostname as startUrl. Return all
    urls obtained by your web crawler in any order. Your crawler should:
    * Start from the page: startUrl
    * Call HtmlParser.getUrls(url) to get all urls from a webpage of given url.
    * Do not crawl the same link twice.
    * Explore only the links that are under the same hostname as startUrl.

    As shown in the example url above, the hostname is example.org. For
    simplicity sake, you may assume all urls use http protocol without any port
    specified. For example, the urls http://leetcode.com/problems and
    http://leetcode.com/contest are under the same hostname, while urls
    http://example.org/test and http://example.com/abc are not under the same
    hostname.

    The HtmlParser interface is defined as such:
    interface HtmlParser {
      // Return a list of all urls from a webpage of given url.
      public List<String> getUrls(String url);
    }
    Below are two examples explaining the functionality of the problem, for
    custom testing purposes you'll have three variables urls, edges and
    startUrl. Notice that you will only have access to startUrl in your code,
    while urls and edges are not directly accessible to you in code.

    Example 1:
    Input:
    urls = [
      "http://news.yahoo.com",
      "http://news.yahoo.com/news",
      "http://news.yahoo.com/news/topics/",
      "http://news.google.com",
      "http://news.yahoo.com/us"
    ]
    edges = [[2,0],[2,1],[3,2],[3,1],[0,4]]
    startUrl = "http://news.yahoo.com/news/topics/"
    Output: [
      "http://news.yahoo.com",
      "http://news.yahoo.com/news",
      "http://news.yahoo.com/news/topics/",
      "http://news.yahoo.com/us"
    ]

    Example 2:
    Input:
    urls = [
      "http://news.yahoo.com",
      "http://news.yahoo.com/news",
      "http://news.yahoo.com/news/topics/",
      "http://news.google.com"
    ]
    edges = [[0,2],[2,1],[3,2],[3,1],[3,0]]
    startUrl = "http://news.google.com"
    Output: ["http://news.google.com"]
    Explanation: The startUrl links to all other pages that do not share the
                 same hostname.

    Constraints:
    * 1 <= urls.length <= 1000
    * 1 <= urls[i].length <= 300
    * startUrl is one of the urls.
    * Hostname label must be from 1 to 63 characters long, including the dots,
      may contain only the ASCII letters from 'a' to 'z', digits  from '0' to
      '9' and the hyphen-minus character ('-').
    * The hostname may not start or end with the hyphen-minus character ('-').
    * See: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames
    * You may assume there're no duplicates in url library."""

    def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> List[str]:
        hostname = startUrl.split("/")[2]
        queue = [startUrl]
        seen = {startUrl}

        for url in queue:
            urls = htmlParser.getUrls(url)
            for x in urls:
                if x.split("/")[2] == hostname and x not in seen:
                    queue.append(x)
                    seen.add(x)
        return queue


    """1239. Maximum Length of a Concatenated String with Unique Characters (Medium)
    Given an array of strings arr. String s is a concatenation of a sub-
    sequence of arr which have unique characters. Return the maximum possible
    length of s.

    Example 1:
    Input: arr = ["un","iq","ue"]
    Output: 4
    Explanation: All possible concatenations are "","un","iq","ue","uniq" and
                 "ique". Maximum length is 4.

    Example 2:
    Input: arr = ["cha","r","act","ers"]
    Output: 6
    Explanation: Possible solutions are "chaers" and "acters".

    Example 3:
    Input: arr = ["abcdefghijklmnopqrstuvwxyz"]
    Output: 26

    Constraints:
    * 1 <= arr.length <= 16
    * 1 <= arr[i].length <= 26
    * arr[i] contains only lower case English letters."""

    def maxLength(self, arr: List[str]) -> int:
        ans = [""]
        for x in arr:
            for i in range(len(ans)):
                xx = x + ans[i]
                if len(xx) == len(set(xx)): ans.append(xx)
        return max(len(x) for x in ans)


    """1240. Tiling a Rectangle with the Fewest Squares (Hard)
    Given a rectangle of size n x m, find the minimum number of integer-sided
    squares that tile the rectangle.

    Example 1:
    Input: n = 2, m = 3
    Output: 3
    Explanation: 3 squares are necessary to cover the rectangle.
                 2 (squares of 1x1)
                 1 (square of 2x2)

    Example 2:
    Input: n = 5, m = 8
    Output: 5

    Example 3:
    Input: n = 11, m = 13
    Output: 6

    Constraints:
    * 1 <= n <= 13
    * 1 <= m <= 13"""

    def tilingRectangle(self, n: int, m: int) -> int:
        if n == m: return 1
        depth = [0]*m

        def fn(x):
            """Explore tiling rectangle area via backtracking."""
            nonlocal ans
            if x < ans:
                if min(depth) == n: ans = x # all tiled
                else:
                    i = min(depth)
                    j = jj = depth.index(i) # (i, j)
                    while jj < m and depth[jj] == depth[j]: jj += 1
                    k = min(n - i, jj - j)
                    for kk in reversed(range(1, k+1)):
                        for jj in range(j, j+kk): depth[jj] += kk
                        fn(x+1)
                        for jj in range(j, j+kk): depth[jj] -= kk

        ans = max(n, m)
        fn(0)
        return ans


    """1243. Array Transformation (Easy)
    Given an initial array arr, every day you produce a new array using the
    array of the previous day. On the i-th day, you do the following operations
    on the array of day i-1 to produce the array of day i:
    * If an element is smaller than both its left neighbor and its right
      neighbor, then this element is incremented.
    * If an element is bigger than both its left neighbor and its right
      neighbor, then this element is decremented.
    * The first and last elements never change.
    After some days, the array does not change. Return that final array.

    Example 1:
    Input: arr = [6,2,3,4]
    Output: [6,3,3,4]
    Explanation: On the first day, the array is changed from [6,2,3,4] to
                 [6,3,3,4]. No more operations can be done to this array.

    Example 2:
    Input: arr = [1,6,3,4,3,5]
    Output: [1,4,4,4,4,5]
    Explanation:
    On the first day, the array is changed from [1,6,3,4,3,5] to [1,5,4,3,4,5].
    On the second day, the array is changed from [1,5,4,3,4,5] to [1,4,4,4,4,5].
    No more operations can be done to this array.

    Constraints:
    * 3 <= arr.length <= 100
    * 1 <= arr[i] <= 100"""

    def transformArray(self, arr: List[int]) -> List[int]:
        prev = [0]*len(arr)
        while prev != arr:
            prev = arr[:]
            for i in range(1, len(arr)-1):
                if prev[i-1] < prev[i] > prev[i+1]: arr[i] -= 1
                elif prev[i-1] > prev[i] < prev[i+1]: arr[i] += 1
        return arr


    """1246. Palindrome Removal (Hard)
    You are given an integer array arr. In one move, you can select a
    palindromic subarray arr[i], arr[i + 1], ..., arr[j] where i <= j, and
    remove that subarray from the given array. Note that after removing a
    subarray, the elements on the left and on the right of that subarray move
    to fill the gap left by the removal. Return the minimum number of moves
    needed to remove all numbers from the array.

    Example 1:
    Input: arr = [1,2]
    Output: 2

    Example 2:
    Input: arr = [1,3,4,1,5]
    Output: 3
    Explanation: Remove [4] then remove [1,3,1] then remove [5].

    Constraints:
    * 1 <= arr.length <= 100
    * 1 <= arr[i] <= 20"""

    def minimumMoves(self, arr: List[int]) -> int:
        n = len(arr)
        dp = [[inf] * (n+1) for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n+1):
                if i+1 >= j: dp[i][j] = 1
                else:
                    dp[i][j] = j-i
                    if arr[i] == arr[j-1]: dp[i][j] = min(dp[i][j], dp[i+1][j-1])
                    for k in range(i+1, j):
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
        return dp[0][n]


    """1249. Minimum Remove to Make Valid Parentheses (Medium)
    Given a string s of '(' , ')' and lowercase English characters. Your task
    is to remove the minimum number of parentheses ( '(' or ')', in any
    positions ) so that the resulting parentheses string is valid and return
    any valid string. Formally, a parentheses string is valid if and only if:
    * It is the empty string, contains only lowercase characters, or
    * It can be written as AB (A concatenated with B), where A and B are valid strings, or
    * It can be written as (A), where A is a valid string.

    Example 1:
    Input: s = "lee(t(c)o)de)"
    Output: "lee(t(c)o)de"
    Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.

    Example 2:
    Input: s = "a)b(c)d"
    Output: "ab(c)d"

    Example 3:
    Input: s = "))(("
    Output: ""
    Explanation: An empty string is also valid.

    Example 4:
    Input: s = "(a(b(c)d)"
    Output: "a(b(c)d)"

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is one of  '(' , ')' and lowercase English letters."""

    def minRemoveToMakeValid(self, s: str) -> str:
        s = list(s)
        stack = []
        for i, x in enumerate(s):
            if x == '(': stack.append(i)
            elif x == ')':
                if stack: stack.pop()
                else: s[i] = ''
        while stack: s[stack.pop()] = ''
        return "".join(s)


    """1255. Maximum Score Words Formed by Letters (Hard)
    Given a list of words, list of  single letters (might be repeating) and
    score of every character. Return the maximum score of any valid set of words
    formed by using the given letters (words[i] cannot be used two or more
    times). It is not necessary to use all characters in letters and each letter
    can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by
    score[0], score[1], ... , score[25] respectively.

    Example 1:
    Input: words = ["dog","cat","dad","good"],
           letters = ["a","a","c","d","d","d","g","o","o"],
           score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
    Output: 23
    Explanation: Score  a=1, c=9, d=5, g=3, o=2
                 Given letters, we can form the words "dad" (5+1+5) and "good"
                 (3+2+2+5) with a score of 23. Words "dad" and "dog" only get a
                 score of 21.

    Example 2:
    Input: words = ["xxxz","ax","bx","cx"],
           letters = ["z","a","b","c","x","x","x"],
           score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
    Output: 27
    Explanation: Score  a=4, b=4, c=4, x=5, z=10
                 Given letters, we can form the words "ax" (4+5), "bx" (4+5) and
                 "cx" (4+5) with a score of 27. Word "xxxz" only get a score of
                 25.

    Example 3:
    Input: words = ["leetcode"],
           letters = ["l","e","t","c","o","d"],
           score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
    Output: 0
    Explanation: Letter "e" can only be used once.

    Constraints:
    * 1 <= words.length <= 14
    * 1 <= words[i].length <= 15
    * 1 <= letters.length <= 100
    * letters[i].length == 1
    * score.length == 26
    * 0 <= score[i] <= 10
    * words[i], letters[i] contains only lower case English letters."""

    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:
        n = len(words)

        def fn(i, v, f):
            """Backtrack """
            if i == n: return v
            ans = fn(i+1, v, f)
            freq = Counter(words[i])
            if all(x <= f[k] for k, x in freq.items()):
                val = sum(score[ord(ch)-97] for ch in words[i])
                ans = max(ans, fn(i+1, v+val, f-freq))
            return ans

        return fn(0, 0, Counter(letters))


    """1259. Handshakes That Don't Cross (Hard)
    You are given an even number of people numPeople that stand around a circle
    and each person shakes hands with someone else so that there are
    numPeople / 2 handshakes total. Return the number of ways these handshakes
    could occur such that none of the handshakes cross. Since the answer could
    be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: numPeople = 4
    Output: 2
    Explanation: There are two ways to do it, the first way is [(1,2),(3,4)]
                 and the second one is [(2,3),(4,1)].

    Example 2:
    Input: numPeople = 6
    Output: 5

    Constraints:
    * 2 <= numPeople <= 1000
    * numPeople is even."""

    def numberOfWays(self, numPeople: int) -> int:
        n = numPeople//2
        return comb(2*n, n)//(n+1) % 1_000_000_007


    """1268. Search Suggestions System (Medium)
    Given an array of strings products and a string searchWord. We want to
    design a system that suggests at most three product names from products
    after each character of searchWord is typed. Suggested products should have
    common prefix with the searchWord. If there are more than three products
    with a common prefix return the three lexicographically minimums products.
    Return list of lists of the suggested products after each character of
    searchWord is typed.

    Example 1:
    Input: products = ["mobile","mouse","moneypot","monitor","mousepad"],
           searchWord = "mouse"
    Output: [["mobile","moneypot","monitor"],
             ["mobile","moneypot","monitor"],
             ["mouse","mousepad"],
             ["mouse","mousepad"],
             ["mouse","mousepad"]]
    Explanation: products sorted lexicographically = ["mobile","moneypot","monitor","mouse","mousepad"]
                 After typing m and mo all products match and we show user ["mobile","moneypot","monitor"]
                 After typing mou, mous and mouse the system suggests ["mouse","mousepad"]

    Example 2:
    Input: products = ["havana"],
           searchWord = "havana"
    Output: [["havana"],["havana"],["havana"],["havana"],["havana"],["havana"]]

    Example 3:
    Input: products = ["bags","baggage","banner","box","cloths"],
           searchWord = "bags"
    Output: [["baggage","bags","banner"],
             ["baggage","bags","banner"],
             ["baggage","bags"],
             ["bags"]]

    Example 4:
    Input: products = ["havana"], searchWord = "tatiana"
    Output: [[],[],[],[],[],[],[]]

    Constraints:
    * 1 <= products.length <= 1000
    * There are no repeated elements in products.
    * 1 <= Σ products[i].length <= 2 * 10^4
    * All characters of products[i] are lower-case English letters.
    * 1 <= searchWord.length <= 1000
    * All characters of searchWord are lower-case English letters."""

    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()
        ans = []
        lo, hi = 0, len(products)-1
        for i, ch in enumerate(searchWord):
            while lo < len(products) and (len(products[lo]) <= i or products[lo][i] < ch): lo += 1
            while hi >= 0 and (len(products[hi]) <= i or ch < products[hi][i]): hi -= 1
            ans.append(products[lo: min(lo+3, hi+1)])
        return ans


    """1271. Hexspeak (Easy)
    A decimal number can be converted to its Hexspeak representation by first
    converting it to an uppercase hexadecimal string, then replacing all
    occurrences of the digit 0 with the letter O, and the digit 1 with the
    letter I.  Such a representation is valid if and only if it consists only
    of the letters in the set {"A", "B", "C", "D", "E", "F", "I", "O"}. Given
    a string num representing a decimal integer N, return the Hexspeak
    representation of N if it is valid, otherwise return "ERROR".

    Example 1:
    Input: num = "257"
    Output: "IOI"
    Explanation:  257 is 101 in hexadecimal.

    Example 2:
    Input: num = "3"
    Output: "ERROR"

    Constraints:
    * 1 <= N <= 10^12
    * There are no leading zeros in the given string.
    * All answers must be in uppercase letters."""

    def toHexspeak(self, num: str) -> str:
        s = hex(int(num))[2:].upper().translate(str.maketrans("01", "OI"))
        return s if all(c.isalpha() for c in s) else "ERROR"


    """1272. Remove Interval (Medium)
    A set of real numbers can be represented as the union of several disjoint
    intervals, where each interval is in the form [a, b). A real number x is in
    the set if one of its intervals [a, b) contains x (i.e. a <= x < b). You
    are given a sorted list of disjoint intervals intervals representing a set
    of real numbers as described above, where intervals[i] = [ai, bi] represents
    the interval [ai, bi). You are also given another interval toBeRemoved.
    Return the set of real numbers with the interval toBeRemoved removed from
    intervals. In other words, return the set of real numbers such that every x
    in the set is in intervals but not in toBeRemoved. Your answer should be a
    sorted list of disjoint intervals as described above.

    Example 1:
    Input: intervals = [[0,2],[3,4],[5,7]], toBeRemoved = [1,6]
    Output: [[0,1],[6,7]]

    Example 2:
    Input: intervals = [[0,5]], toBeRemoved = [2,3]
    Output: [[0,2],[3,5]]

    Example 3:
    Input: intervals = [[-5,-4],[-3,-2],[1,2],[3,5],[8,9]], toBeRemoved = [-1,4]
    Output: [[-5,-4],[-3,-2],[4,5],[8,9]]

    Constraints:
    * 1 <= intervals.length <= 10^4
    * -10^9 <= ai < bi <= 10^9"""

    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
        ans = []
        for x, y in intervals:
            if x < toBeRemoved[0]: ans.append([x, min(toBeRemoved[0], y)])
            if toBeRemoved[1] < y: ans.append([max(x, toBeRemoved[1]), y])
        return ans


    """1273. Delete Tree Nodes (Medium)
    A tree rooted at node 0 is given as follows:
    * The number of nodes is nodes;
    * The value of the i-th node is value[i];
    * The parent of the i-th node is parent[i].
    Remove every subtree whose sum of values of nodes is zero. After doing so,
    return the number of nodes remaining in the tree.

    Example 1:
    Input: nodes = 7, parent = [-1,0,0,1,2,2,2], value = [1,-2,4,0,-2,-1,-1]
    Output: 2

    Example 2:
    Input: nodes = 7, parent = [-1,0,0,1,2,2,2], value = [1,-2,4,0,-2,-1,-2]
    Output: 6

    Example 3:
    Input: nodes = 5, parent = [-1,0,1,0,0], value = [-672,441,18,728,378]
    Output: 5

    Example 4:
    Input: nodes = 5, parent = [-1,0,0,1,1], value = [-686,-842,616,-739,-746]
    Output: 5

    Constraints:
    * 1 <= nodes <= 10^4
    * parent.length == nodes
    * 0 <= parent[i] <= nodes - 1
    * parent[0] == -1 which indicates that 0 is the root.
    * value.length == nodes
    * -10^5 <= value[i] <= 10^5
    * The given input is guaranteed to represent a valid tree."""

    def deleteTreeNodes(self, nodes: int, parent: List[int], value: List[int]) -> int:
        tree = {} # tree as adjacency list
        for i, x in enumerate(parent):
            tree.setdefault(x, []).append(i)

        def fn(n):
            """Return sum and count of sub-tree rooted at n."""
            s, c = value[n], 1
            for nn in tree.get(n, []):
                ss, cc = fn(nn)
                s += ss
                c += cc
            return (s, c) if s != 0 else (0, 0)

        return fn(0)[1]


    """1274. Number of Ships in a Rectangle (Hard)
    (This problem is an interactive problem.) Each ship is located at an
    integer point on the sea represented by a cartesian plane, and each integer
    point may contain at most 1 ship. You have a function
    Sea.hasShips(topRight, bottomLeft) which takes two points as arguments and
    returns true If there is at least one ship in the rectangle represented by
    the two points, including on the boundary. Given two points: the top right
    and bottom left corners of a rectangle, return the number of ships present
    in that rectangle. It is guaranteed that there are at most 10 ships in that
    rectangle. Submissions making more than 400 calls to hasShips will be
    judged Wrong Answer. Also, any solutions that attempt to circumvent the
    judge will result in disqualification.

    Example :
    Input: ships = [[1,1],[2,2],[3,3],[5,5]], topRight = [4,4], bottomLeft = [0,0]
    Output: 3
    Explanation: From [0,0] to [4,4] we can count 3 ships within the range.

    Example 2:
    Input: ans = [[1,1],[2,2],[3,3]], topRight = [1000,1000], bottomLeft = [0,0]
    Output: 3

    Constraints:
    * On the input ships is only given to initialize the map internally. You
      must solve this problem "blindfolded". In other words, you must find the
      answer using the given hasShips API, without knowing the ships position.
    * 0 <= bottomLeft[0] <= topRight[0] <= 1000
    * 0 <= bottomLeft[1] <= topRight[1] <= 1000
    * topRight != bottomLeft"""

    def countShips(self, sea: 'Sea', topRight: 'Point', bottomLeft: 'Point') -> int:
        if not sea.hasShips(topRight, bottomLeft): return 0
        x0, x1 = bottomLeft.x, topRight.x
        y0, y1 = bottomLeft.y, topRight.y
        if x0 == x1 and y0 == y1: return 1
        if x0 < x1:
            mid = (x0 + x1)//2
            return self.countShips(sea, topRight, Point(mid+1, y0)) + self.countShips(sea, Point(mid, y1), bottomLeft)
        mid = (y0 + y1)//2
        return self.countShips(sea, topRight, Point(x0, mid+1)) + self.countShips(sea, Point(x1, mid), bottomLeft)


    """1275. Find Winner on a Tic Tac Toe Game (Easy)
    Tic-tac-toe is played by two players A and B on a 3 x 3 grid. Here are the
    rules of Tic-Tac-Toe:
    * Players take turns placing characters into empty squares (" ").
    * The first player A always places "X" characters, while the second player
      B always places "O" characters.
    * "X" and "O" characters are always placed into empty squares, never on
      filled ones.
    * The game ends when there are 3 of the same (non-empty) character filling
      any row, column, or diagonal.
    * The game also ends if all squares are non-empty.
    * No more moves can be played if the game is over.
    Given an array moves where each element is another array of size 2
    corresponding to the row and column of the grid where they mark their
    respective character in the order in which A and B play. Return the winner
    of the game if it exists (A or B), in case the game ends in a draw return
    "Draw", if there are still movements to play return "Pending". You can
    assume that moves is valid (It follows the rules of Tic-Tac-Toe), the grid
    is initially empty and A will play first.

    Example 1:
    Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
    Output: "A"
    Explanation: "A" wins, he always plays first.
                 "X  "    "X  "    "X  "    "X  "    "X  "
                 "   " -> "   " -> " X " -> " X " -> " X "
                 "   "    "O  "    "O  "    "OO "    "OOX"

    Example 2:
    Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
    Output: "B"
    Explanation: "B" wins.
                 "X  "    "X  "    "XX "    "XXO"    "XXO"    "XXO"
                 "   " -> " O " -> " O " -> " O " -> "XO " -> "XO "
                 "   "    "   "    "   "    "   "    "   "    "O  "

    Example 3:
    Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
    Output: "Draw"
    Explanation: The game ends in a draw since there are no moves to make.
                 "XXO"
                 "OOX"
                 "XOX"

    Example 4:
    Input: moves = [[0,0],[1,1]]
    Output: "Pending"
    Explanation: The game has not finished yet.
                 "X  "
                 " O "
                 "   "

    Constraints:
    * 1 <= moves.length <= 9
    * moves[i].length == 2
    * 0 <= moves[i][j] <= 2
    * There are no repeated elements on moves.
    * moves follow the rules of tic tac toe."""

    def tictactoe(self, moves: List[List[int]]) -> str:
        score = [[0]*8 for _ in range(2)]

        for p, (i, j) in enumerate(moves):
            p %= 2
            score[p][i] += 1
            score[p][3+j] += 1
            if i == j: score[p][6] += 1
            if i+j == 2: score[p][7] += 1
            if any(x == 3 for x in score[p]): return "AB"[p]

        return "Pending" if len(moves) < 9 else "Draw"


    """1288. Remove Covered Intervals (Medium)
    Given an array intervals where intervals[i] = [li, ri] represent the
    interval [li, ri), remove all intervals that are covered by another
    interval in the list. The interval [a, b) is covered by the interval
    [c, d) if and only if c <= a and b <= d. Return the number of remaining
    intervals.

    Example 1:
    Input: intervals = [[1,4],[3,6],[2,8]]
    Output: 2
    Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.

    Example 2:
    Input: intervals = [[1,4],[2,3]]
    Output: 1

    Constraints:
    * 1 <= intervals.length <= 1000
    * intervals[i].length == 2
    * 0 <= li <= ri <= 10^5
    * All the given intervals are unique."""

    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        ans = 0
        prev = -inf
        for _, y in sorted(intervals, key=lambda x: (x[0], -x[1])):
            if y > prev:
                ans += 1
                prev = y
        return ans


    """1289. Minimum Falling Path Sum II (Hard)
    Given an n x n integer matrix grid, return the minimum sum of a falling path
    with non-zero shifts. A falling path with non-zero shifts is a choice of
    exactly one element from each row of grid such that no two elements chosen
    in adjacent rows are in the same column.

    Example 1:
    Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 13
    Explanation: The possible falling paths are:
                 [1,5,9], [1,5,7], [1,6,7], [1,6,8],
                 [2,4,8], [2,4,9], [2,6,7], [2,6,8],
                 [3,4,8], [3,4,9], [3,5,7], [3,5,9]
                 The falling path with the smallest sum is [1,5,7], so the
                 answer is 13.

    Example 2:
    Input: grid = [[7]]
    Output: 7

    Constraints:
    * n == grid.length == grid[i].length
    * 1 <= n <= 200
    * -99 <= grid[i][j] <= 99"""

    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        for i in range(1, n):
            m0, m1 = nsmallest(2, grid[i-1])
            for j in range(n):
                if grid[i-1][j] != m0: grid[i][j] += m0
                else: grid[i][j] += m1
        return min(grid[-1])


    """1290. Convert Binary Number in a Linked List to Integer (Easy)
    Given head which is a reference node to a singly-linked list. The value of
    each node in the linked list is either 0 or 1. The linked list holds the
    binary representation of a number. Return the decimal value of the number
    in the linked list.

    Example 1:
    Input: head = [1,0,1]
    Output: 5
    Explanation: (101) in base 2 = (5) in base 10

    Example 2:
    Input: head = [0]
    Output: 0

    Example 3:
    Input: head = [1]
    Output: 1

    Example 4:
    Input: head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]
    Output: 18880

    Example 5:
    Input: head = [0,0]
    Output: 0

    Constraints:
    * The Linked List is not empty.
    * Number of nodes will not exceed 30.
    * Each node's value is either 0 or 1."""

    def getDecimalValue(self, head: ListNode) -> int:
        ans = 0
        while head:
            ans = 2*ans + head.val
            head = head.next
        return ans


    """1291. Sequential Digits (Medium)
    An integer has sequential digits if and only if each digit in the number is
    one more than the previous digit. Return a sorted list of all the integers
    in the range [low, high] inclusive that have sequential digits.

    Example 1:
    Input: low = 100, high = 300
    Output: [123,234]

    Example 2:
    Input: low = 1000, high = 13000
    Output: [1234,2345,3456,4567,5678,6789,12345]

    Constraints: 10 <= low <= high <= 10^9"""

    def sequentialDigits(self, low: int, high: int) -> List[int]:
        ans = []
        for x in range(1, 10):
            val = 0
            for d in range(x, 10):
                val = 10*val + d
                if low <= val <= high: ans.append(val)
        return sorted(ans)


    """1305. All Elements in Two Binary Search Trees (Medium)
    Given two binary search trees root1 and root2, return a list containing all
    the integers from both trees sorted in ascending order.

    Example 1:
    Input: root1 = [2,1,4], root2 = [1,0,3]
    Output: [0,1,1,2,3,4]

    Example 2:
    Input: root1 = [1,null,8], root2 = [8,1]
    Output: [1,1,8,8]

    Constraints:
    * The number of nodes in each tree is in the range [0, 5000].
    * -10^5 <= Node.val <= 10^5"""

    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:

        def fn(node):
            ans, stack = [], []
            while node or stack:
                if node:
                    stack.append(node)
                    node = node.left
                else:
                    node = stack.pop()
                    ans.append(node.val)
                    node = node.right
            return ans

        vals1 = fn(root1)
        vals2 = fn(root2)
        ans = []
        i = j = 0
        while i < len(vals1) or j < len(vals2):
            if j == len(vals2) or i < len(vals1) and vals1[i] < vals2[j]:
                ans.append(vals1[i])
                i += 1
            else:
                ans.append(vals2[j])
                j += 1
        return ans


    """1306. Jump Game III (Medium)
    Given an array of non-negative integers arr, you are initially positioned
    at start index of the array. When you are at index i, you can jump to
    i + arr[i] or i - arr[i], check if you can reach to any index with value 0.
    Notice that you can not jump outside of the array at any time.

    Example 1:
    Input: arr = [4,2,3,0,3,1,2], start = 5
    Output: true
    Explanation: All possible ways to reach at index 3 with value 0 are:
                 index 5 -> index 4 -> index 1 -> index 3
                 index 5 -> index 6 -> index 4 -> index 1 -> index 3

    Example 2:
    Input: arr = [4,2,3,0,3,1,2], start = 0
    Output: true
    Explanation: One possible way to reach at index 3 with value 0 is:
                 index 0 -> index 4 -> index 1 -> index 3

    Example 3:
    Input: arr = [3,0,2,1,2], start = 2
    Output: false
    Explanation: There is no way to reach at index 1 with value 0.

    Constraints:
    * 1 <= arr.length <= 5 * 10^4
    * 0 <= arr[i] < arr.length
    * 0 <= start < arr.length"""

    def canReach(self, arr: List[int], start: int) -> bool:
        stack = [start]
        arr[start] *= -1 # mark "visited"
        while stack:
            i = stack.pop()
            if arr[i] == 0: return True
            for ii in i - arr[i], i + arr[i]:
                if 0 <= ii < len(arr) and arr[ii] >= 0:
                    stack.append(ii)
                    arr[ii] *= -1
        return False


    """1307. Verbal Arithmetic Puzzle (Hard)
    Given an equation, represented by words on left side and the result on
    right side. You need to check if the equation is solvable under the
    following rules:
    * Each character is decoded as one digit (0 - 9).
    * Every pair of different characters they must map to different digits.
    * Each words[i] and result are decoded as one number without leading zeros.
    * Sum of numbers on left side (words) will equal to the number on right
      side (result).
    Return True if the equation is solvable otherwise return False.

    Example 1:
    Input: words = ["SEND","MORE"], result = "MONEY"
    Output: true
    Explanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'
                 Such that: "SEND" + "MORE" = "MONEY" ,  9567 + 1085 = 10652

    Example 2:
    Input: words = ["SIX","SEVEN","SEVEN"], result = "TWENTY"
    Output: true
    Explanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4
                 Such that: "SIX" + "SEVEN" + "SEVEN" = "TWENTY" ,  650 + 68782 + 68782 = 138214

    Example 3:
    Input: words = ["THIS","IS","TOO"], result = "FUNNY"
    Output: true

    Example 4:
    Input: words = ["LEET","CODE"], result = "POINT"
    Output: false

    Constraints:
    * 2 <= words.length <= 5
    * 1 <= words[i].length, result.length <= 7
    * words[i], result contain only uppercase English letters.
    * The number of different characters used in the expression is at most 10."""

    def isSolvable(self, words: List[str], result: str) -> bool:
        if max(map(len, words)) > len(result): return False # edge case

        words.append(result)
        digits = [0]*10
        mp = {} # mapping from letter to digit

        def fn(i, j, val):
            """Find proper mapping for words[i][~j] and result[~j] via backtracking."""
            if j == len(result): return val == 0 # base condition
            if i == len(words): return val % 10 == 0 and fn(0, j+1, val//10)

            if j >= len(words[i]): return fn(i+1, j, val)
            if words[i][~j] in mp:
                if j and j+1 == len(words[i]) and mp[words[i][~j]] == 0: return # backtrack (no leading 0 unless single digit)
                if i+1 == len(words): return fn(i+1, j, val - mp[words[i][~j]])
                else: return fn(i+1, j, val + mp[words[i][~j]])
            else:
                for k, x in enumerate(digits):
                    if not x and (k or j == 0 or j+1 < len(words[i])): # (no leading 0 unless single digit)
                        mp[words[i][~j]] = k
                        digits[k] = 1
                        if i+1 == len(words) and fn(i+1, j, val-k): return True
                        if i+1 < len(words) and fn(i+1, j, val+k): return True
                        digits[k] = 0
                        mp.pop(words[i][~j])

        return fn(0, 0, 0)


    """1314. Matrix Block Sum (Medium)
    Given a m x n matrix mat and an integer k, return a matrix answer where
    each answer[i][j] is the sum of all elements mat[r][c] for:
    * i - k <= r <= i + k,
    * j - k <= c <= j + k, and
    * (r, c) is a valid position in the matrix.

    Example 1:
    Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
    Output: [[12,21,16],[27,45,33],[24,39,28]]

    Example 2:
    Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
    Output: [[45,45,45],[45,45,45],[45,45,45]]

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n, k <= 100
    * 1 <= mat[i][j] <= 100"""

    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m):
            for j in range(n):
                prefix[i+1][j+1] = mat[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]
        ans = [[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                r0, r1 = max(0, i-k), min(m-1, i+k)
                c0, c1 = max(0, j-k), min(n-1, j+k)
                ans[i][j] = prefix[r1+1][c1+1] - prefix[r0][c1+1] - prefix[r1+1][c0] + prefix[r0][c0]
        return ans


    """1317. Convert Integer to the Sum of Two No-Zero Integers (Easy)
    Given an integer n. No-Zero integer is a positive integer which doesn't
    contain any 0 in its decimal representation. Return a list of two integers
    [A, B] where:
    * A and B are No-Zero integers.
    * A + B = n
    It's guarateed that there is at least one valid solution. If there are many
    valid solutions you can return any of them.

    Example 1:
    Input: n = 2
    Output: [1,1]
    Explanation: A = 1, B = 1. A + B = n and both A and B don't contain any 0
                 in their decimal representation.

    Example 2:
    Input: n = 11
    Output: [2,9]

    Example 3:
    Input: n = 10000
    Output: [1,9999]

    Example 4:
    Input: n = 69
    Output: [1,68]

    Example 5:
    Input: n = 1010
    Output: [11,999]

    Constraints: 2 <= n <= 10^4"""

    def getNoZeroIntegers(self, n: int) -> List[int]:
        for x in range(1, n//2+1):
            if "0" not in str(x) and "0" not in str(n-x):
                return [x, n-x]


    """1318. Minimum Flips to Make a OR b Equal to c (Medium)
    Given 3 positives numbers a, b and c. Return the minimum flips required in
    some bits of a and b to make ( a OR b == c ). (bitwise OR operation). Flip
    operation consists of change any single bit 1 to 0 or change the bit 0 to 1
    in their binary representation.

    Example 1:
    Input: a = 2, b = 6, c = 5
    Output: 3
    Explanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)

    Example 2:
    Input: a = 4, b = 2, c = 7
    Output: 1

    Example 3:
    Input: a = 1, b = 2, c = 3
    Output: 0

    Constraints:
    * 1 <= a <= 10^9
    * 1 <= b <= 10^9
    * 1 <= c <= 10^9"""

    def minFlips(self, a: int, b: int, c: int) -> int:
        return bin((a | b) ^ c).count("1") + bin(a & b & ((a | b) ^ c)).count("1")


    """1319. Number of Operations to Make Network Connected (Medium)
    There are n computers numbered from 0 to n-1 connected by ethernet cables
    connections forming a network where connections[i] = [a, b] represents a
    connection between computers a and b. Any computer can reach any other
    computer directly or indirectly through the network. Given an initial
    computer network connections. You can extract certain cables between two
    directly connected computers, and place them between any pair of
    disconnected computers to make them directly connected. Return the minimum
    number of times you need to do this in order to make all the computers
    connected. If it's not possible, return -1.

    Example 1:
    Input: n = 4, connections = [[0,1],[0,2],[1,2]]
    Output: 1
    Explanation: Remove cable between computer 1 and 2 and place between
                 computers 1 and 3.

    Example 2:
    Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
    Output: 2

    Example 3:
    Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
    Output: -1
    Explanation: There are not enough cables.

    Example 4:
    Input: n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]
    Output: 0

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= connections.length <= min(n*(n-1)/2, 10^5)
    * connections[i].length == 2
    * 0 <= connections[i][0], connections[i][1] < n
    * connections[i][0] != connections[i][1]
    * There are no repeated connections.
    * No two computers are connected by more than one cable."""

    def makeConnected(self, n: int, connections: List[List[int]]) -> int:
        if len(connections) < n-1: return -1 # not enough cables
        uf = UnionFind(n)
        for u, v in connections:
            uf.union(u, v)
        grp = {uf.find(i) for i in range(n)}
        return len(grp) - 1


    """1320. Minimum Distance to Type a Word Using Two Fingers (Hard)
    You have a keyboard layout as shown above in the XY plane, where each
    English uppercase letter is located at some coordinate, for example, the
    letter A is located at coordinate (0,0), the letter B is located at
    coordinate (0,1), the letter P is located at coordinate (2,3) and the
    letter Z is located at coordinate (4,1). Given the string word, return the
    minimum total distance to type such string using only two fingers. The
    distance between coordinates (x1,y1) and (x2,y2) is |x1 - x2| + |y1 - y2|.
    Note that the initial positions of your two fingers are considered free so
    don't count towards your total distance, also your two fingers do not have
    to start at the first letter or the first two letters.

    Example 1:
    Input: word = "CAKE"
    Output: 3
    Explanation:
    Using two fingers, one optimal way to type "CAKE" is:
    Finger 1 on letter 'C' -> cost = 0
    Finger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2
    Finger 2 on letter 'K' -> cost = 0
    Finger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1
    Total distance = 3

    Example 2:
    Input: word = "HAPPY"
    Output: 6
    Explanation:
    Using two fingers, one optimal way to type "HAPPY" is:
    Finger 1 on letter 'H' -> cost = 0
    Finger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2
    Finger 2 on letter 'P' -> cost = 0
    Finger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0
    Finger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4
    Total distance = 6

    Example 3:
    Input: word = "NEW"
    Output: 3

    Example 4:
    Input: word = "YEAR"
    Output: 7

    Constraints:
    * 2 <= word.length <= 300
    * Each word[i] is an English uppercase letter."""

    def minimumDistance(self, word: str) -> int:
        word = [ord(c)-65 for c in word]
        dist = lambda x, y: 0 if -1 in (x, y) else abs(x//6-y//6) + abs(x%6-y%6)

        @cache
        def fn(i, f1=-1, f2=-1):
            """Return minimum distance to type word[i:] with fingers at f1 and f2."""
            if i == len(word): return 0
            return min(dist(f1, word[i]) + fn(i+1, word[i], f2), dist(f2, word[i]) + fn(i+1, f1, word[i]))

        return fn(0)


    """1325. Delete Leaves With a Given Value (Medium)
    Given a binary tree root and an integer target, delete all the leaf nodes
    with value target. Note that once you delete a leaf node with value target,
    if its parent node becomes a leaf node and has the value target, it should
    also be deleted (you need to continue doing that until you cannot).

    Example 1:
    Input: root = [1,2,3,2,null,2,4], target = 2
    Output: [1,null,3,null,4]
    Explanation: Leaf nodes in green with value (target = 2) are removed
                 (Picture in left). After removing, new nodes become leaf nodes
                 with value (target = 2) (Picture in center).

    Example 2:
    Input: root = [1,3,3,3,2], target = 3
    Output: [1,3,null,null,2]

    Example 3:
    Input: root = [1,2,null,2,null,2], target = 2
    Output: [1]
    Explanation: Leaf nodes in green with value (target = 2) are removed at each
                 step.

    Constraints:
    * The number of nodes in the tree is in the range [1, 3000].
    * 1 <= Node.val, target <= 1000"""

    def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
        if root:
            root.left = self.removeLeafNodes(root.left, target)
            root.right = self.removeLeafNodes(root.right, target)
            if root.left or root.right or root.val != target: return root


    """1328. Break a Palindrome (Medium)
    Given a palindromic string of lowercase English letters palindrome, replace
    exactly one character with any lowercase English letter so that the
    resulting string is not a palindrome and that it is the lexicographically
    smallest one possible. Return the resulting string. If there is no way to
    replace a character to make it not a palindrome, return an empty string. A
    string a is lexicographically smaller than a string b (of the same length)
    if in the first position where a and b differ, a has a character strictly
    smaller than the corresponding character in b. For example, "abcc" is
    lexicographically smaller than "abcd" because the first position they
    differ is at the fourth character, and 'c' is smaller than 'd'.

    Example 1:
    Input: palindrome = "abccba"
    Output: "aaccba"
    Explanation: There are many ways to make "abccba" not a palindrome, such as
                 "zbccba", "aaccba", and "abacba". Of all the ways, "aaccba" is
                 the lexicographically smallest.

    Example 2:
    Input: palindrome = "a"
    Output: ""
    Explanation: There is no way to replace a single character to make "a" not
                 a palindrome, so return an empty string.

    Example 3:
    Input: palindrome = "aa"
    Output: "ab"

    Example 4:
    Input: palindrome = "aba"
    Output: "abb"

    Constraints:
    * 1 <= palindrome.length <= 1000
    * palindrome consists of only lowercase English letters."""

    def breakPalindrome(self, palindrome: str) -> str:
        if len(palindrome) == 1: return "" # edge case
        palindrome = list(palindrome)
        for i in range(len(palindrome)//2):
            if palindrome[i] != "a":
                palindrome[i] = "a"
                break
        else: palindrome[-1] = "b"
        return "".join(palindrome)


    """1329. Sort the Matrix Diagonally (Medium)
    A matrix diagonal is a diagonal line of cells starting from some cell in
    either the topmost row or leftmost column and going in the bottom-right
    direction until reaching the matrix's end. For example, the matrix diagonal
    starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells
    mat[2][0], mat[3][1], and mat[4][2]. Given an m x n matrix mat of integers,
    sort each matrix diagonal in ascending order and return the resulting matrix.

    Example 1:
    Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
    Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 100
    * 1 <= mat[i][j] <= 100"""

    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0]) # dimensions

        for k in range(-m+1, n):
            i, j = (-k, 0) if k < 0 else (0, k)
            vals = []
            while i < m and j < n:
                vals.append(mat[i][j])
                i, j = i+1, j+1
            vals.sort()
            while vals:
                i, j = i-1, j-1
                mat[i][j] = vals.pop()
        return mat


    """1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (Medium)
    There are n cities numbered from 0 to n-1. Given the array edges where
    edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted
    edge between cities fromi and toi, and given the integer distanceThreshold.
    Return the city with the smallest number of cities that are reachable
    through some path and whose distance is at most distanceThreshold, If there
    are multiple such cities, return the city with the greatest number. Notice
    that the distance of a path connecting cities i and j is equal to the sum of
    the edges' weights along that path.

    Example 1:
    Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
    Output: 3
    Explanation: The figure above describes the graph. The neighboring cities at
                 a distanceThreshold = 4 for each city are:
                 City 0 -> [City 1, City 2]
                 City 1 -> [City 0, City 2, City 3]
                 City 2 -> [City 0, City 1, City 3]
                 City 3 -> [City 1, City 2]
                 Cities 0 and 3 have 2 neighboring cities at a
                 distanceThreshold = 4, but we have to return city 3 since it
                 has the greatest number.

    Example 2:
    Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
    Output: 0
    Explanation: The figure above describes the graph. The neighboring cities at
                 a distanceThreshold = 2 for each city are:
                 City 0 -> [City 1]
                 City 1 -> [City 0, City 4]
                 City 2 -> [City 3, City 4]
                 City 3 -> [City 2, City 4]
                 City 4 -> [City 1, City 2, City 3]
                 The city 0 has 1 neighboring city at a distanceThreshold = 2.

    Constraints:
    * 2 <= n <= 100
    * 1 <= edges.length <= n * (n - 1) / 2
    * edges[i].length == 3
    * 0 <= fromi < toi < n
    * 1 <= weighti, distanceThreshold <= 10^4
    * All pairs (fromi, toi) are distinct."""

    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        """Floyd-Warshall algorithm"""
        dist = [[float("inf")]*n for _ in range(n)]
        for i in range(n): dist[i][i] = 0
        for i, j, w in edges: dist[i][j] = dist[j][i] = w
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
        ans, ref = 0, inf
        for i in range(n):
            cnt = sum(d <= distanceThreshold for d in dist[i])
            if cnt <= ref: ans, ref = i, cnt
        return ans


    """1337. The K Weakest Rows in a Matrix (Easy)
    You are given an m x n binary matrix mat of 1's (representing soldiers) and
    0's (representing civilians). The soldiers are positioned in front of the
    civilians. That is, all the 1's will appear to the left of all the 0's in
    each row. A row i is weaker than a row j if one of the following is true:
    * The number of soldiers in row i is less than the number of soldiers in
      row j.
    * Both rows have the same number of soldiers and i < j.
    Return the indices of the k weakest rows in the matrix ordered from weakest
    to strongest.

    Example 1:
    Input: mat = [[1,1,0,0,0],
                  [1,1,1,1,0],
                  [1,0,0,0,0],
                  [1,1,0,0,0],
                  [1,1,1,1,1]],
           k = 3
    Output: [2,0,3]
    Explanation: The number of soldiers in each row is:
                 - Row 0: 2
                 - Row 1: 4
                 - Row 2: 1
                 - Row 3: 2
                 - Row 4: 5
                 The rows ordered from weakest to strongest are [2,0,3,1,4].

    Example 2:
    Input: mat = [[1,0,0,0],
                  [1,1,1,1],
                  [1,0,0,0],
                  [1,0,0,0]],
           k = 2
    Output: [0,2]
    Explanation: The number of soldiers in each row is:
                 - Row 0: 1
                 - Row 1: 4
                 - Row 2: 1
                 - Row 3: 1
                 The rows ordered from weakest to strongest are [0,2,3,1].

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 2 <= n, m <= 100
    * 1 <= k <= m
    * matrix[i][j] is either 0 or 1."""

    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        m, n = len(mat), len(mat[0])
        vals = []
        for i in range(m):
            lo, hi = 0, n
            while lo < hi:
                mid = lo + hi >> 1
                if mat[i][mid]: lo = mid + 1
                else: hi = mid
            vals.append((lo, i))
        return [i for _, i in sorted(vals)[:k]]


    """1338. Reduce Array Size to The Half (Medium)
    Given an array arr.  You can choose a set of integers and remove all the
    occurrences of these integers in the array. Return the minimum size of the
    set so that at least half of the integers of the array are removed.

    Example 1:
    Input: arr = [3,3,3,3,5,5,5,2,2,7]
    Output: 2
    Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has
                 size 5 (i.e equal to half of the size of the old array).
                 Possible sets of size 2 are {3,5},{3,2},{5,2}. Choosing set
                 {2,7} is not possible as it will make the new array
                 [3,3,3,3,5,5,5] which has size greater than half of the size
                 of the old array.

    Example 2:
    Input: arr = [7,7,7,7,7,7]
    Output: 1
    Explanation: The only possible set you can choose is {7}. This will make
                 the new array empty.

    Example 3:
    Input: arr = [1,9]
    Output: 1

    Example 4:
    Input: arr = [1000,1000,3,7]
    Output: 1

    Example 5:
    Input: arr = [1,2,3,4,5,6,7,8,9,10]
    Output: 5

    Constraints:
    * 1 <= arr.length <= 10^5
    * arr.length is even.
    * 1 <= arr[i] <= 10^5"""

    def minSetSize(self, arr: List[int]) -> int:
        freq = {}
        for x in arr: freq[x] = 1 + freq.get(x, 0)

        ans = 0
        for i, x in enumerate(sorted(freq.values(), reverse=True)):
            ans += x
            if ans >= len(arr)//2: return i + 1


    """1339. Maximum Product of Splitted Binary Tree (Medium)
    Given the root of a binary tree, split the binary tree into two subtrees by
    removing one edge such that the product of the sums of the subtrees is
    maximized. Return the maximum product of the sums of the two subtrees.
    Since the answer may be too large, return it modulo 10^9 + 7. Note that you
    need to maximize the answer before taking the mod and not after taking it.

    Example 1:
    Input: root = [1,2,3,4,5,6]
    Output: 110
    Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10.
                 Their product is 110 (11*10)

    Example 2:
    Input: root = [1,null,2,3,4,null,null,5,6]
    Output: 90
    Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.
                 Their product is 90 (15*6)

    Example 3:
    Input: root = [2,3,9,10,7,8,6,5,4,11,1]
    Output: 1025

    Example 4:
    Input: root = [1,1]
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [2, 5 * 10^4].
    * 1 <= Node.val <= 10^4"""

    def maxProduct(self, root: Optional[TreeNode]) -> int:
        vals = []

        def fn(node):
            """Return sum of sub-tree."""
            if not node: return 0
            ans = node.val + fn(node.left) + fn(node.right)
            vals.append(ans)
            return ans

        total = fn(root)
        return max((total-x)*x for x in vals) % 1_000_000_007


    """1345. Jump Game IV (Hard)
    Given an array of integers arr, you are initially positioned at the first
    index of the array. In one step you can jump from index i to index:
    * i + 1 where: i + 1 < arr.length.
    * i - 1 where: i - 1 >= 0.
    * j where: arr[i] == arr[j] and i != j.
    Return the minimum number of steps to reach the last index of the array.
    Notice that you can not jump outside of the array at any time.

    Example 1:
    Input: arr = [100,-23,-23,404,100,23,23,23,3,404]
    Output: 3
    Explanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that
                 index 9 is the last index of the array.

    Example 2:
    Input: arr = [7]
    Output: 0
    Explanation: Start index is the last index. You do not need to jump.

    Example 3:
    Input: arr = [7,6,9,6,9,6,9,7]
    Output: 1
    Explanation: You can jump directly from index 0 to index 7 which is last
                 index of the array.

    Constraints:
    * 1 <= arr.length <= 5 * 10^4
    * -10^8 <= arr[i] <= 10^8"""

    def minJumps(self, arr: List[int]) -> int:
        loc = defaultdict(list)
        for i, x in enumerate(arr): loc[x].append(i)
        ans = 0
        seen = {0}
        queue = deque([0])
        while queue:
            for _ in range(len(queue)):
                i = queue.popleft()
                if i+1 == len(arr): return ans
                for ii in [i-1, i+1] + loc[arr[i]]:
                    if 0 <= ii < len(arr) and ii not in seen:
                        seen.add(ii)
                        queue.append(ii)
                loc.pop(arr[i])
            ans += 1


    """1349. Maximum Students Taking Exam (Hard)
    Given a m * n matrix seats  that represent seats distributions in a
    classroom. If a seat is broken, it is denoted by '#' character otherwise it
    is denoted by a '.' character. Students can see the answers of those sitting
    next to the left, right, upper left and upper right, but he cannot see the
    answers of the student sitting directly in front or behind him. Return the
    maximum number of students that can take the exam together without any
    cheating being possible. Students must be placed in seats in good condition.

    Example 1:
    Input: seats = [["#",".","#","#",".","#"],
                    [".","#","#","#","#","."],
                    ["#",".","#","#",".","#"]]
    Output: 4
    Explanation: Teacher can place 4 students in available seats so they don't
                 cheat on the exam.

    Example 2:
    Input: seats = [[".","#"],
                    ["#","#"],
                    ["#","."],
                    ["#","#"],
                    [".","#"]]
    Output: 3
    Explanation: Place all students in available seats.

    Example 3:
    Input: seats = [["#",".",".",".","#"],
                    [".","#",".","#","."],
                    [".",".","#",".","."],
                    [".","#",".","#","."],
                    ["#",".",".",".","#"]]
    Output: 10
    Explanation: Place students in available seats in column 1, 3 and 5.

    Constraints:
    * seats contains only characters '.' and'#'.
    * m == seats.length
    * n == seats[i].length
    * 1 <= m <= 8
    * 1 <= n <= 8"""

    def maxStudents(self, seats: List[List[str]]) -> int:
        m, n = len(seats), len(seats[0]) # dimensions

        valid = []
        for i in range(m):
            val = 0
            for j in range(n):
                if seats[i][j] == ".": val |= 1 << j
            valid.append(val)

        @cache
        def fn(i, mask):
            """Return max students taking seats[i:] given previous row as mask."""
            if i == len(seats): return 0
            ans = fn(i+1, 0)
            for x in range(1 << n):
                if x & valid[i] == x and (x >> 1) & x == 0 and (mask >> 1) & x == 0 and (mask << 1) & x == 0:
                    ans = max(ans, bin(x).count("1") + fn(i+1, x))
            return ans

        return fn(0, 0)


    """1354. Construct Target Array With Multiple Sums (Hard)
    Given an array of integers target. From a starting array, A consisting of
    all 1's, you may perform the following procedure :
    * let x be the sum of all elements currently in your array.
    * choose index i, such that 0 <= i < target.size and set the value of A at
      index i to x.
    * You may repeat this procedure as many times as needed.
    Return True if it is possible to construct the target array from A
    otherwise return False.

    Example 1:
    Input: target = [9,3,5]
    Output: true
    Explanation: Start with [1, 1, 1]
    [1, 1, 1], sum = 3 choose index 1
    [1, 3, 1], sum = 5 choose index 2
    [1, 3, 5], sum = 9 choose index 0
    [9, 3, 5] Done

    Example 2:
    Input: target = [1,1,1,2]
    Output: false
    Explanation: Impossible to create target array from [1,1,1,1].

    Example 3:
    Input: target = [8,5]
    Output: true

    Constraints:
    * N == target.length
    * 1 <= target.length <= 5 * 10^4
    * 1 <= target[i] <= 10^9"""

    def isPossible(self, target: List[int]) -> bool:
        if len(target) == 1: return target[0] == 1 # edge case

        total = sum(target)
        pq = [-x for x in target] # max heap
        heapify(pq)

        while -pq[0] > 1:
            x = -heappop(pq)
            total -= x
            if x <= total: return False
            x = (x-1) % total + 1
            heappush(pq, -x)
            total += x
        return True


    """1356. Sort Integers by The Number of 1 Bits (Easy)
    Given an integer array arr. You have to sort the integers in the array in
    ascending order by the number of 1's in their binary representation and in
    case of two or more integers have the same number of 1's you have to sort
    them in ascending order. Return the sorted array.

    Example 1:
    Input: arr = [0,1,2,3,4,5,6,7,8]
    Output: [0,1,2,4,8,3,5,6,7]
    Explantion: [0] is the only integer with 0 bits.
    [1,2,4,8] all have 1 bit.
    [3,5,6] have 2 bits.
    [7] has 3 bits.
    The sorted array by bits is [0,1,2,4,8,3,5,6,7]

    Example 2:
    Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
    Output: [1,2,4,8,16,32,64,128,256,512,1024]
    Explantion: All integers have 1 bit in the binary representation, you should
                just sort them in ascending order.

    Example 3:
    Input: arr = [10000,10000]
    Output: [10000,10000]

    Example 4:
    Input: arr = [2,3,5,7,11,13,17,19]
    Output: [2,3,5,17,7,11,13,19]

    Example 5:
    Input: arr = [10,100,1000,10000]
    Output: [10,100,10000,1000]

    Constraints:
    * 1 <= arr.length <= 500
    * 0 <= arr[i] <= 10^4"""

    def sortByBits(self, arr: List[int]) -> List[int]:
        return sorted(arr, key=lambda x: (bin(x).count("1"), x))


    """1358. Number of Substrings Containing All Three Characters (Medium)
    Given a string s consisting only of characters a, b and c. Return the
    number of substrings containing at least one occurrence of all these
    characters a, b and c.

    Example 1:
    Input: s = "abcabc"
    Output: 10
    Explanation: The substrings containing at least one occurrence of the
                 characters a, b and c are "abc", "abca", "abcab", "abcabc",
                 "bca", "bcab", "bcabc", "cab", "cabc" and "abc" (again).

    Example 2:
    Input: s = "aaacb"
    Output: 3
    Explanation: The substrings containing at least one occurrence of the
                 characters a, b and c are "aaacb", "aacb" and "acb".

    Example 3:
    Input: s = "abc"
    Output: 1

    Constraints:
    * 3 <= s.length <= 5 x 10^4
    * s only consists of a, b or c characters."""

    def numberOfSubstrings(self, s: str) -> int:
        ans = 0
        loc = [-1]*3
        for i, c in enumerate(s):
            loc[ord(c)-97] = i
            ans += max(0, min(loc)+1)
        return ans


    """1359. Count All Valid Pickup and Delivery Options (Hard)
    Given n orders, each order consist in pickup and delivery services. Count
    all valid pickup/delivery possible sequences such that delivery(i) is
    always after of pickup(i). Since the answer may be too large, return it
    modulo 10^9 + 7.

    Example 1:
    Input: n = 1
    Output: 1
    Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.

    Example 2:
    Input: n = 2
    Output: 6
    Explanation: All possible orders:
    (P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).
    This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.

    Example 3:
    Input: n = 3
    Output: 90

    Constraints: 1 <= n <= 500"""

    def countOrders(self, n: int) -> int:
        ans = 1
        for x in range(2, n+1):
            ans = ans*x*(2*x-1) % 1_000_000_007
        return ans


    """1367. Linked List in Binary Tree (Medium)
    Given a binary tree root and a linked list with head as the first node.
    Return True if all the elements in the linked list starting from the head
    correspond to some downward path connected in the binary tree otherwise
    return False. In this context downward path means a path that starts at some
    node and goes downwards.

    Example 1:
    Input: head = [4,2,8],
           root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    Output: true
    Explanation: Nodes in blue form a subpath in the binary Tree.

    Example 2:
    Input: head = [1,4,2,6],
           root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    Output: true

    Example 3:
    Input: head = [1,4,2,6,8],
           root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    Output: false
    Explanation: There is no path in the binary tree that contains all the
                 elements of the linked list from head.

    Constraints:
    * The number of nodes in the tree will be in the range [1, 2500].
    * The number of nodes in the list will be in the range [1, 100].
    * 1 <= Node.val <= 100 for each node in the linked list and binary tree."""

    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
        pattern = []
        while head:
            pattern.append(head.val)
            head = head.next
        lps = [0]
        k = 0
        for i in range(1, len(pattern)):
            while k and pattern[k] != pattern[i]: k = lps[k-1]
            if pattern[k] == pattern[i]: k += 1
            lps.append(k)

        def dfs(node, k):
            """Return True of tree rooted at "node" match pattern"""
            if k == len(pattern): return True
            if node:
                while k and pattern[k] != node.val: k = lps[k-1]
                if pattern[k] == node.val: k += 1
                return dfs(node.left, k) or dfs(node.right, k)

        return dfs(root, 0)


    """1372. Longest ZigZag Path in a Binary Tree (Medium)
    You are given the root of a binary tree. A ZigZag path for a binary tree is
    defined as follow:
    * Choose any node in the binary tree and a direction (right or left).
    * If the current direction is right, move to the right child of the current
      node; otherwise, move to the left child.
    * Change the direction from right to left or from left to right.
    * Repeat the second and third steps until you can't move in the tree.
    Zigzag length is defined as the number of nodes visited - 1. (A single node
    has a length of 0). Return the longest ZigZag path contained in that tree.

    Example 1:
    Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
    Output: 3
    Explanation: Longest ZigZag path in blue nodes (right -> left -> right).

    Example 2:
    Input: root = [1,1,1,null,1,null,null,1,1,null,1]
    Output: 4
    Explanation: Longest ZigZag path in blue nodes (left -> right -> left ->
                 right).

    Example 3:
    Input: root = [1]
    Output: 0

    Constraints:
    * The number of nodes in the tree is in the range [1, 5 * 10^4].
    * 1 <= Node.val <= 100"""

    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        ans = 0
        stack = [(root, True, 0), (root, False, 0)]
        while stack:
            node, left, val = stack.pop()
            ans = max(ans, val)
            if node.left: stack.append((node.left, True, 1 if left else val+1))
            if node.right: stack.append((node.right, False, val+1 if left else 1))
        return ans


    """1373. Maximum Sum BST in Binary Tree (Hard)
    Given a binary tree root, the task is to return the maximum sum of all keys
    of any sub-tree which is also a Binary Search Tree (BST). Assume a BST is
    defined as follows:
    * The left subtree of a node contains only nodes with keys less than the node's key.
    * The right subtree of a node contains only nodes with keys greater than the node's key.
    * Both the left and right subtrees must also be binary search trees.

    Example 1:
    Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
    Output: 20
    Explanation: Maximum sum in a valid Binary search tree is obtained in root
                 node with key equal to 3.

    Example 2:
    Input: root = [4,3,null,1,2]
    Output: 2
    Explanation: Maximum sum in a valid Binary search tree is obtained in a
                 single root node with key equal to 2.

    Example 3:
    Input: root = [-4,-2,-5]
    Output: 0
    Explanation: All values are negatives. Return an empty BST.

    Example 4:
    Input: root = [2,1,3]
    Output: 6

    Example 5:
    Input: root = [5,4,8,3,null,6,3]
    Output: 7

    Constraints:
    * The given binary tree will have between 1 and 40000 nodes.
    * Each node's value is between [-4 * 10^4 , 4 * 10^4]."""

    def maxSumBST(self, root: TreeNode) -> int:

        def fn(node):
            """Collect info while traversing the tree in post-order."""
            if not node: return True, inf, -inf, 0, 0 # bst flag | min | max | sum
            ltf, lmn, lmx, lsm, lval = fn(node.left)
            rtf, rmn, rmx, rsm, rval = fn(node.right)
            lmn = min(lmn, node.val)
            rmx = max(rmx, node.val)
            sm = lsm + rsm + node.val
            if ltf and rtf and lmx < node.val < rmn:
                return True, lmn, rmx, sm, max(lval, rval, sm)
            return False, lmn, rmx, sm, max(lval, rval)

        return fn(root)[-1]


    """1380. Lucky Numbers in a Matrix (Easy)
    Given an m x n matrix of distinct numbers, return all lucky numbers in the
    matrix in any order. A lucky number is an element of the matrix such that
    it is the minimum element in its row and maximum in its column.

    Example 1:
    Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
    Output: [15]
    Explanation: 15 is the only lucky number since it is the minimum in its row
                 and the maximum in its column.

    Example 2:
    Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
    Output: [12]
    Explanation: 12 is the only lucky number since it is the minimum in its row
                 and the maximum in its column.

    Example 3:
    Input: matrix = [[7,8],[1,2]]
    Output: [7]
    Explanation: 7 is the only lucky number since it is the minimum in its row
                 and the maximum in its column.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= n, m <= 50
    * 1 <= matrix[i][j] <= 10^5.
    * All elements in the matrix are distinct."""

    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        return set(map(min, matrix)) & set(map(max, zip(*matrix)))


    """1383. Maximum Performance of a Team (Hard)
    You are given two integers n and k and two integer arrays speed and
    efficiency both of length n. There are n engineers numbered from 1 to n.
    speed[i] and efficiency[i] represent the speed and efficiency of the ith
    engineer respectively. Choose at most k different engineers out of the n
    engineers to form a team with the maximum performance. The performance of
    a team is the sum of their engineers' speeds multiplied by the minimum
    efficiency among their engineers. Return the maximum performance of this
    team. Since the answer can be a huge number, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
    Output: 60
    Explanation: We have the maximum performance of the team by selecting
                 engineer 2 (with speed=10 and efficiency=4) and engineer 5
                 (with speed=5 and efficiency=7). That is,
                 performance = (10 + 5) * min(4, 7) = 60.

    Example 2:
    Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
    Output: 68
    Explanation: This is the same example as the first but k = 3. We can select
                 engineer 1, engineer 2 and engineer 5 to get the maximum
                 performance of the team. That is,
                 performance = (2 + 10 + 5) * min(5, 4, 7) = 68.

    Example 3:
    Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
    Output: 72

    Constraints:
    * 1 <= <= k <= n <= 10^5
    * speed.length == n
    * efficiency.length == n
    * 1 <= speed[i] <= 10^5
    * 1 <= efficiency[i] <= 10^8"""

    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        ans = rsm = 0
        pq = []
        for x, y in sorted(zip(efficiency, speed), reverse=True):
            rsm += y
            heappush(pq, y)
            if len(pq) > k: rsm -= heappop(pq)
            ans = max(ans, rsm * x)
        return ans % 1_000_000_007


    """1385. Find the Distance Value Between Two Arrays (Easy)
    Given two integer arrays arr1 and arr2, and the integer d, return the
    distance value between the two arrays. The distance value is defined as the
    number of elements arr1[i] such that there is not any element arr2[j] where
    |arr1[i]-arr2[j]| <= d.

    Example 1:
    Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
    Output: 2
    Explanation: For arr1[0]=4 we have:
                 |4-10|=6 > d=2
                 |4-9|=5 > d=2
                 |4-1|=3 > d=2
                 |4-8|=4 > d=2
                 For arr1[1]=5 we have:
                 |5-10|=5 > d=2
                 |5-9|=4 > d=2
                 |5-1|=4 > d=2
                 |5-8|=3 > d=2
                 For arr1[2]=8 we have:
                 |8-10|=2 <= d=2
                 |8-9|=1 <= d=2
                 |8-1|=7 > d=2
                 |8-8|=0 <= d=2

    Example 2:
    Input: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
    Output: 2

    Example 3:
    Input: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
    Output: 1

    Constraints:
    * 1 <= arr1.length, arr2.length <= 500
    * -10^3 <= arr1[i], arr2[j] <= 10^3
    * 0 <= d <= 100"""

    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        arr2.sort()
        ans = 0
        for x in arr1:
            lo = bisect_left(arr2, x - d)
            hi = bisect_right(arr2, x + d)
            if lo == hi: ans += 1
        return ans


    """1386. Cinema Seat Allocation (Medium)
    A cinema has n rows of seats, numbered from 1 to n and there are ten seats
    in each row, labelled from 1 to 10 as shown in the figure above. Given the
    array reservedSeats containing the numbers of seats already reserved, for
    example, reservedSeats[i] = [3,8] means the seat located in row 3 and
    labelled with 8 is already reserved. Return the maximum number of four-
    person groups you can assign on the cinema seats. A four-person group
    occupies four adjacent seats in one single row. Seats across an aisle (such
    as [3,3] and [3,4]) are not considered to be adjacent, but there is an
    exceptional case on which an aisle split a four-person group, in that case,
    the aisle split a four-person group in the middle, which means to have two
    people on each side.

    Example 1:
    Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]
    Output: 4
    Explanation: The figure above shows the optimal allocation for four groups,
                 where seats mark with blue are already reserved and contiguous
                 seats mark with orange are for one group.

    Example 2:
    Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]
    Output: 2

    Example 3:
    Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]
    Output: 4

    Constraints:
    * 1 <= n <= 10^9
    * 1 <= reservedSeats.length <= min(10*n, 10^4)
    * reservedSeats[i].length == 2
    * 1 <= reservedSeats[i][0] <= n
    * 1 <= reservedSeats[i][1] <= 10
    * All reservedSeats[i] are distinct."""

    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
        seats = {}
        for i, j in reservedSeats:
            if i not in seats: seats[i] = 0
            seats[i] |= 1 << j-1

        ans = 2 * (n - len(seats))
        for v in seats.values():
            if not int("0111111110", 2) & v: ans += 2
            elif not int("0111100000", 2) & v: ans += 1
            elif not int("0001111000", 2) & v: ans += 1
            elif not int("0000011110", 2) & v: ans += 1
        return ans


    """1387. Sort Integers by The Power Value (Medium)
    The power of an integer x is defined as the number of steps needed to
    transform x into 1 using the following steps:
    * if x is even then x = x / 2
    * if x is odd then x = 3 * x + 1
    For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1
    (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1). Given three integers lo,
    hi and k. The task is to sort all integers in the interval [lo, hi] by the
    power value in ascending order, if two or more integers have the same power
    value sort them by ascending order. Return the k-th integer in the range
    [lo, hi] sorted by the power value. Notice that for any integer x
    (lo <= x <= hi) it is guaranteed that x will transform into 1 using these
    steps and that the power of x is will fit in 32 bit signed integer.

    Example 1:
    Input: lo = 12, hi = 15, k = 2
    Output: 13
    Explanation: The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1)
                 The power of 13 is 9
                 The power of 14 is 17
                 The power of 15 is 17
                 The interval sorted by the power value [12,13,14,15]. For
                 k = 2 answer is the second element which is 13. Notice that 12
                 and 13 have the same power value and we sorted them in
                 ascending order. Same for 14 and 15.

    Example 2:
    Input: lo = 1, hi = 1, k = 1
    Output: 1

    Example 3:
    Input: lo = 7, hi = 11, k = 4
    Output: 7
    Explanation: The power array corresponding to the interval [7, 8, 9, 10, 11]
                 is [16, 3, 19, 6, 14]. The interval sorted by power is
                 [8, 10, 11, 7, 9]. The fourth number in the sorted array is 7.

    Example 4:
    Input: lo = 10, hi = 20, k = 5
    Output: 13

    Example 5:
    Input: lo = 1, hi = 1000, k = 777
    Output: 570

    Constraints:
    * 1 <= lo <= hi <= 1000
    * 1 <= k <= hi - lo + 1"""

    def getKth(self, lo: int, hi: int, k: int) -> int:
        pq = [] # min heap (size hi - lo - k + 2)
        for x in range(lo, hi+1):
            cnt, xx = 0, x
            while xx > 1:
                xx = 3*xx + 1 if xx&1 else xx//2
                cnt += 1
            heappush(pq, (cnt, x))
            if len(pq) > hi - lo - k + 2: heappop(pq)
        return pq[0][1]


    """1388. Pizza With 3n Slices (Hard)
    There is a pizza with 3n slices of varying size, you and your friends will
    take slices of pizza as follows:
    * You will pick any pizza slice.
    * Your friend Alice will pick next slice in anti clockwise direction of
      your pick.
    * Your friend Bob will pick next slice in clockwise direction of your pick.
    * Repeat until there are no more slices of pizzas.
    Sizes of Pizza slices is represented by circular array slices in clockwise
    direction. Return the maximum possible sum of slice sizes which you can
    have.

    Example 1:
    Input: slices = [1,2,3,4,5,6]
    Output: 10
    Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices
                 with size 3 and 5 respectively. Then Pick slices with size 6,
                 finally Alice and Bob will pick slice of size 2 and 1
                 respectively. Total = 4 + 6.

    Example 2:
    Input: slices = [8,9,8,6,1,1]
    Output: 16
    Output: Pick pizza slice of size 8 in each turn. If you pick slice with
            size 9 your partners will pick slices of size 8.

    Example 3:
    Input: slices = [4,1,2,5,8,3,1,9,7]
    Output: 21

    Example 4:
    Input: slices = [3,1,2]
    Output: 3

    Constraints:
    * 1 <= slices.length <= 500
    * slices.length % 3 == 0
    * 1 <= slices[i] <= 1000"""

    def maxSizeSlices(self, slices: List[int]) -> int:

        @cache
        def fn(i, k, first):
            """Return max sum of k pieces from slices[i:]."""
            if k == 0: return 0
            if i >= len(slices) or first and i == len(slices)-1: return -inf
            if i == 0: return max(fn(i+1, k, False), slices[i] + fn(i+2, k-1, True))
            return max(fn(i+1, k, first), slices[i] + fn(i+2, k-1, first))

        return fn(0, len(slices)//3, None)


    """1394. Find Lucky Integer in an Array (Easy)
    Given an array of integers arr, a lucky integer is an integer which has a
    frequency in the array equal to its value. Return a lucky integer in the
    array. If there are multiple lucky integers return the largest of them. If
    there is no lucky integer return -1.

    Example 1:
    Input: arr = [2,2,3,4]
    Output: 2
    Explanation: The only lucky number in the array is 2 because frequency[2] == 2.

    Example 2:
    Input: arr = [1,2,2,3,3,3]
    Output: 3
    Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.

    Example 3:
    Input: arr = [2,2,2,3,3]
    Output: -1
    Explanation: There are no lucky numbers in the array.

    Example 4:
    Input: arr = [5]
    Output: -1

    Example 5:
    Input: arr = [7,7,7,7,7,7,7]
    Output: 7

    Constraints:
    * 1 <= arr.length <= 500
    * 1 <= arr[i] <= 500"""

    def findLucky(self, arr: List[int]) -> int:
        freq = {}
        for x in arr:
            freq[x] = 1 + freq.get(x, 0)
        return max((x for x in arr if x == freq[x]), default=-1)


    """1395. Count Number of Teams (Medium)
    There are n soldiers standing in a line. Each soldier is assigned a unique
    rating value. You have to form a team of 3 soldiers amongst them under the
    following rules:
    * Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).
    * A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
    Return the number of teams you can form given the conditions. (soldiers can
    be part of multiple teams).

    Example 1:
    Input: rating = [2,5,3,4,1]
    Output: 3
    Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1).

    Example 2:
    Input: rating = [2,1,3]
    Output: 0
    Explanation: We can't form any team given the conditions.

    Example 3:
    Input: rating = [1,2,3,4]
    Output: 4

    Constraints:
    * n == rating.length
    * 3 <= n <= 1000
    * 1 <= rating[i] <= 10^5
    * All the integers in rating are unique."""

    def numTeams(self, rating: List[int]) -> int:
        n = len(rating)
        mp = dict(zip(sorted(rating), range(n)))
        vals = [mp[x] for x in rating]

        def fn(vals):
            """Return """
            ans = 0
            mark = Fenwick(n)
            pair = Fenwick(n)
            for x in vals:
                ans += pair.query(x-1)
                mark.add(x, 1)
                pair.add(x, mark.query(x-1))
            return ans

        return fn(vals) + fn(vals[::-1])


    """1397. Find All Good Strings (Hard)
    Given the strings s1 and s2 of size n, and the string evil. Return the
    number of good strings. A good string has size n, it is alphabetically
    greater than or equal to s1, it is alphabetically smaller than or equal to
    s2, and it does not contain the string evil as a substring. Since the
    answer can be a huge number, return this modulo 10^9 + 7.

    Example 1:
    Input: n = 2, s1 = "aa", s2 = "da", evil = "b"
    Output: 51
    Explanation: There are 25 good strings starting with 'a': "aa","ac","ad",
                 ...,"az". Then there are 25 good strings starting with 'c':
                 "ca","cc","cd",...,"cz" and finally there is one good string
                 starting with 'd': "da".

    Example 2:
    Input: n = 8, s1 = "leetcode", s2 = "leetgoes", evil = "leet"
    Output: 0
    Explanation: All strings greater than or equal to s1 and smaller than or
                 equal to s2 start with the prefix "leet", therefore, there is
                 not any good string.

    Example 3:
    Input: n = 2, s1 = "gx", s2 = "gz", evil = "x"
    Output: 2

    Constraints:
    * s1.length == n
    * s2.length == n
    * s1 <= s2
    * 1 <= n <= 500
    * 1 <= evil.length <= 50
    * All strings consist of lowercase English letters."""

    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
        lps = [0]
        k = 0
        for i in range(1, len(evil)):
            while k and evil[k] != evil[i]: k = lps[k-1]
            if evil[k] == evil[i]: k += 1
            lps.append(k)

        @cache
        def fn(i, k, lower, upper):
            """Return number of good strings at position i and k prefix match."""
            if k == len(evil): return 0 # boundary condition
            if i == n: return 1
            lo = ascii_lowercase.index(s1[i]) if lower else 0
            hi = ascii_lowercase.index(s2[i]) if upper else 25

            ans = 0
            for x in range(lo, hi+1):
                kk = k
                while kk and evil[kk] != ascii_lowercase[x]:
                    kk = lps[kk-1]
                if evil[kk] == ascii_lowercase[x]: kk += 1
                ans += fn(i+1, kk, lower and x == lo, upper and x == hi)
            return ans

        return fn(0, 0, True, True) % 1_000_000_007


    """1399. Count Largest Group (Easy)
    Given an integer n. Each number from 1 to n is grouped according to the sum
    of its digits. Return how many groups have the largest size.

    Example 1:
    Input: n = 13
    Output: 4
    Explanation: There are 9 groups in total, they are grouped according sum of
                 its digits of numbers from 1 to 13: [1,10], [2,11], [3,12],
                 [4,13], [5], [6], [7], [8], [9]. There are 4 groups with
                 largest size.

    Example 2:
    Input: n = 2
    Output: 2
    Explanation: There are 2 groups [1], [2] of size 1.

    Example 3:
    Input: n = 15
    Output: 6

    Example 4:
    Input: n = 24
    Output: 5

    Constraints: 1 <= n <= 10^4"""

    def countLargestGroup(self, n: int) -> int:
        freq = {}
        for x in range(1, n+1):
            key = sum(int(d) for d in str(x))
            freq[key] = 1 + freq.get(key, 0)
        vals = list(freq.values())
        return vals.count(max(vals))


    """1400. Construct K Palindrome Strings (Medium)
    Given a string s and an integer k. You should construct k non-empty
    palindrome strings using all the characters in s. Return True if you can
    use all the characters in s to construct k palindrome strings or False
    otherwise.

    Example 1:
    Input: s = "annabelle", k = 2
    Output: true
    Explanation: You can construct two palindromes using all characters in s.
                 Some possible constructions "anna" + "elble", "anbna" + "elle",
                 "anellena" + "b"

    Example 2:
    Input: s = "leetcode", k = 3
    Output: false
    Explanation: It is impossible to construct 3 palindromes using all the
                 characters of s.

    Example 3:
    Input: s = "true", k = 4
    Output: true
    Explanation: The only possible solution is to put each character in a
                 separate string.

    Example 4:
    Input: s = "yzyzyzyzyzyzyzy", k = 2
    Output: true
    Explanation: Simply you can put all z's in one string and all y's in the
                 other string. Both strings will be palindrome.

    Example 5:
    Input: s = "cr", k = 7
    Output: false
    Explanation: We don't have enough characters in s to construct 7 palindromes.

    Constraints:
    * 1 <= s.length <= 10^5
    * All characters in s are lower-case English letters.
    * 1 <= k <= 10^5"""

    def canConstruct(self, s: str, k: int) -> bool:
        freq = {}
        for c in s: freq[c] = 1 + freq.get(c, 0)
        return sum(freq[c]&1 for c in freq) <= k <= len(s)


    """1401. Circle and Rectangle Overlapping (Medium)
    Given a circle represented as (radius, x_center, y_center) and an axis-
    aligned rectangle represented as (x1, y1, x2, y2), where (x1, y1) are the
    coordinates of the bottom-left corner, and (x2, y2) are the coordinates of
    the top-right corner of the rectangle. Return True if the circle and
    rectangle are overlapped otherwise return False. In other words, check if
    there are any point (xi, yi) such that belongs to the circle and the
    rectangle at the same time.

    Example 1:
    Input: radius = 1, x_center = 0, y_center = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1
    Output: true
    Explanation: Circle and rectangle share the point (1,0)

    Example 2:
    Input: radius = 1, x_center = 0, y_center = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1
    Output: true

    Example 3:
    Input: radius = 1, x_center = 1, y_center = 1, x1 = -3, y1 = -3, x2 = 3, y2 = 3
    Output: true

    Example 4:
    Input: radius = 1, x_center = 1, y_center = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1
    Output: false

    Constraints:
    * 1 <= radius <= 2000
    * -10^4 <= x_center, y_center, x1, y1, x2, y2 <= 10^4
    * x1 < x2
    * y1 < y2"""

    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:
        if x1 <= x_center <= x2 and y1 <= y_center <= y2: return True # circle inside rectangle

        for x, y in (x1, y1), (x1, y2), (x2, y1), (x2, y2):
            if (x - x_center)**2 + (y - y_center)**2 <= radius**2: return True

        # check edge
        for x in [x1, x2]:
            if x_center - radius <= x <= x_center + radius and y1 <= y_center <= y2: return True

        for y in [y1, y2]:
            if y_center - radius <= y <= y_center + radius and x1 <= x_center <= x2: return True

        return False


    """1402. Reducing Dishes (Hard)
    A chef has collected data on the satisfaction level of his n dishes. Chef
    can cook any dish in 1 unit of time. Like-time coefficient of a dish is
    defined as the time taken to cook that dish including previous dishes
    multiplied by its satisfaction level i.e. time[i]*satisfaction[i]. Return
    the maximum sum of Like-time coefficient that the chef can obtain after
    dishes preparation. Dishes can be prepared in any order and the chef can
    discard some dishes to get this maximum value.

    Example 1:
    Input: satisfaction = [-1,-8,0,5,-9]
    Output: 14
    Explanation: After Removing the second and last dish, the maximum total
                 Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14).
                 Each dish is prepared in one unit of time.

    Example 2:
    Input: satisfaction = [4,3,2]
    Output: 20
    Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)

    Example 3:
    Input: satisfaction = [-1,-4,-5]
    Output: 0
    Explanation: People don't like the dishes. No dish is prepared.

    Example 4:
    Input: satisfaction = [-2,5,-1,0,3,-3]
    Output: 35

    Constraints:
    * n == satisfaction.length
    * 1 <= n <= 500
    * -10^3 <= satisfaction[i] <= 10^3"""

    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        satisfaction.sort() # ascending order

        @cache
        def fn(i, k):
            """Return max sum of like-time coefficient of satisfation[i:]."""
            if i == len(satisfaction): return 0
            return max(satisfaction[i]*k + fn(i+1, k+1), fn(i+1, k))

        return fn(0, 1)


    """1403. Minimum Subsequence in Non-Increasing Order (Easy)
    Given the array nums, obtain a subsequence of the array whose sum of
    elements is strictly greater than the sum of the non included elements in
    such subsequence.  If there are multiple solutions, return the subsequence
    with minimum size and if there still exist multiple solutions, return the
    subsequence with the maximum total sum of all its elements. A subsequence
    of an array can be obtained by erasing some (possibly zero) elements from
    the array. Note that the solution with the given constraints is guaranteed
    to be unique. Also return the answer sorted in non-increasing order.

    Example 1:
    Input: nums = [4,3,10,9,8]
    Output: [10,9]
    Explanation: The subsequences [10,9] and [10,8] are minimal such that the
                 sum of their elements is strictly greater than the sum of
                 elements not included, however, the subsequence [10,9] has
                 the maximum total sum of its elements.

    Example 2:
    Input: nums = [4,4,7,6,7]
    Output: [7,7,6]
    Explanation: The subsequence [7,7] has the sum of its elements equal to 14
                 which is not strictly greater than the sum of elements not
                 included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7]
                 is the minimal satisfying the conditions. Note the subsequence
                 has to returned in non-decreasing order.

    Example 3:
    Input: nums = [6]
    Output: [6]

    Constraints:
    * 1 <= nums.length <= 500
    * 1 <= nums[i] <= 100"""

    def minSubsequence(self, nums: List[int]) -> List[int]:
        ans = []
        total, sm = sum(nums), 0
        for x in sorted(nums, reverse=True):
            ans.append(x)
            sm += x
            if sm > total - sm: return ans


    """1404. Number of Steps to Reduce a Number in Binary Representation to One(Medium)
    Given a number s in their binary representation. Return the number of steps
    to reduce it to 1 under the following rules:
    * If the current number is even, you have to divide it by 2.
    * If the current number is odd, you have to add 1 to it.
    It's guaranteed that you can always reach to one for all testcases.

    Example 1:
    Input: s = "1101"
    Output: 6
    Explanation: "1101" corressponds to number 13 in their decimal representation.
    Step 1) 13 is odd, add 1 and obtain 14.
    Step 2) 14 is even, divide by 2 and obtain 7.
    Step 3) 7 is odd, add 1 and obtain 8.
    Step 4) 8 is even, divide by 2 and obtain 4.
    Step 5) 4 is even, divide by 2 and obtain 2.
    Step 6) 2 is even, divide by 2 and obtain 1.

    Example 2:
    Input: s = "10"
    Output: 1
    Explanation: "10" corressponds to number 2 in their decimal representation.
    Step 1) 2 is even, divide by 2 and obtain 1.

    Example 3:
    Input: s = "1"
    Output: 0

    Constraints:
    * 1 <= s.length <= 500
    * s consists of characters '0' or '1'
    * s[0] == '1'"""

    def numSteps(self, s: str) -> int:
        ans = one = 0
        for i in range(len(s)-1, 0, -1):
            if s[i] == '1':
                ans += 2 - one
                one = 1
            else: ans += 1 + one
        return ans + one


    """1405. Longest Happy String (Medium)
    A string is called happy if it does not have any of the strings 'aaa', 'bbb'
    or 'ccc' as a substring. Given three integers a, b and c, return any string
    s, which satisfies following conditions:
    * s is happy and longest possible.
    * s contains at most a occurrences of the letter 'a', at most b occurrences
      of the letter 'b' and at most c occurrences of the letter 'c'.
    * s will only contain 'a', 'b' and 'c' letters.
    If there is no such string s return the empty string "".

    Example 1:
    Input: a = 1, b = 1, c = 7
    Output: "ccaccbcc"
    Explanation: "ccbccacc" would also be a correct answer.

    Example 2:
    Input: a = 2, b = 2, c = 1
    Output: "aabbc"

    Example 3:
    Input: a = 7, b = 1, c = 0
    Output: "aabaa"
    Explanation: It's the only correct answer in this case.

    Constraints:
    * 0 <= a, b, c <= 100
    * a + b + c > 0"""

    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        pq = []
        for x, c in zip((a, b, c), "abc"):
            if x: heappush(pq, (-x, c))
        ans = []
        while pq:
            x, c = heappop(pq)
            if ans[-2:] == [c, c]:
                if not pq: break
                xx, cc = heappop(pq)
                ans.append(cc)
                if xx+1: heappush(pq, (xx+1, cc))
                heappush(pq, (x, c))
            else:
                ans.append(c)
                if x+1: heappush(pq, (x+1, c))
        return "".join(ans)


    """1406. Stone Game III (Hard)
    Alice and Bob continue their games with piles of stones. There are several
    stones arranged in a row, and each stone has an associated value which is
    an integer given in the array stoneValue. Alice and Bob take turns, with
    Alice starting first. On each player's turn, that player can take 1, 2 or 3
    stones from the first remaining stones in the row. The score of each player
    is the sum of values of the stones taken. The score of each player is 0
    initially. The objective of the game is to end with the highest score, and
    the winner is the player with the highest score and there could be a tie.
    The game continues until all the stones have been taken. Assume Alice and
    Bob play optimally. Return "Alice" if Alice will win, "Bob" if Bob will win
    or "Tie" if they end the game with the same score.

    Example 1:
    Input: values = [1,2,3,7]
    Output: "Bob"
    Explanation: Alice will always lose. Her best move will be to take three
                 piles and the score become 6. Now the score of Bob is 7 and
                 Bob wins.

    Example 2:
    Input: values = [1,2,3,-9]
    Output: "Alice"
    Explanation: Alice must choose all the three piles at the first move to win
                 and leave Bob with negative score. If Alice chooses one pile
                 her score will be 1 and the next move Bob's score becomes 5.
                 The next move Alice will take the pile with value = -9 and
                 lose. If Alice chooses two piles her score will be 3 and the
                 next move Bob's score becomes 3. The next move Alice will take
                 the pile with value = -9 and also lose. Remember that both
                 play optimally so here Alice will choose the scenario that
                 makes her win.

    Example 3:
    Input: values = [1,2,3,6]
    Output: "Tie"
    Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.

    Example 4:
    Input: values = [1,2,3,-1,-2,-3,7]
    Output: "Alice"

    Example 5:
    Input: values = [-1,-2,-3]
    Output: "Tie"

    Constraints:
    * 1 <= values.length <= 50000
    * -1000 <= values[i] <= 1000"""

    def stoneGameIII(self, stoneValue: List[int]) -> str:

        @cache
        def fn(i):
            """Return max value obtained from stoneValue[i:]."""
            if i >= len(stoneValue): return 0
            ans = -inf
            for ii in range(i, i+3):
                ans = max(ans, sum(stoneValue[i:ii+1]) - fn(ii+1))
            return ans

        ans = fn(0)
        if ans > 0: return "Alice"
        if ans == 0: return "Tie"
        return "Bob"


    """1413. Minimum Value to Get Positive Step by Step Sum (Easy)
    Given an array of integers nums, you start with an initial positive value
    startValue. In each iteration, you calculate the step by step sum of
    startValue plus elements in nums (from left to right). Return the minimum
    positive value of startValue such that the step by step sum is never less
    than 1.

    Example 1:
    Input: nums = [-3,2,-3,4,2]
    Output: 5
    Explanation: If you choose startValue = 4, in the third iteration your step
                 by step sum is less than 1.
                 step by step sum
                 startValue = 4 | startValue = 5 | nums
                   (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
                   (1 +2 ) = 3  | (2 +2 ) = 4    |   2
                   (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
                   (0 +4 ) = 4  | (1 +4 ) = 5    |   4
                   (4 +2 ) = 6  | (5 +2 ) = 7    |   2

    Example 2:
    Input: nums = [1,2]
    Output: 1
    Explanation: Minimum start value should be positive.

    Example 3:
    Input: nums = [1,-2,-3]
    Output: 5

    Constraints:
    * 1 <= nums.length <= 100
    * -100 <= nums[i] <= 100"""

    def minStartValue(self, nums: List[int]) -> int:
        ans = prefix = 0
        for x in nums:
            prefix += x
            ans = min(ans, prefix)
        return 1 - ans


    """1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (Medium)
    Given an integer k, return the minimum number of Fibonacci numbers whose
    sum is equal to k. The same Fibonacci number can be used multiple times.
    The Fibonacci numbers are defined as:
    F1 = 1
    F2 = 1
    Fn = Fn-1 + Fn-2 for n > 2.
    It is guaranteed that for the given constraints we can always find such
    Fibonacci numbers that sum up to k.

    Example 1:
    Input: k = 7
    Output: 2
    Explanation: The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... For k = 7
                 we can use 2 + 5 = 7.

    Example 2:
    Input: k = 10
    Output: 2
    Explanation: For k = 10 we can use 2 + 8 = 10.

    Example 3:
    Input: k = 19
    Output: 3
    Explanation: For k = 19 we can use 1 + 5 + 13 = 19.

    Constraints: 1 <= k <= 10^9"""

    def findMinFibonacciNumbers(self, k: int) -> int:
        vals = []
        f0 = f1 = 1
        while f1 <= k:
            vals.append(f1)
            f0, f1 = f1, f0+f1
        ans = 0
        while k:
            ans += 1
            i = bisect_right(vals, k)
            k -= vals[i-1]
        return ans


    """1415. The k-th Lexicographical String of All Happy Strings of Length n (Medium)
    A happy string is a string that:
    * consists only of letters of the set ['a', 'b', 'c'].
    * s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).
    For example, strings "abc", "ac", "b" and "abcbabcbcb" are all happy strings
    and strings "aa", "baa" and "ababbc" are not happy strings. Given two
    integers n and k, consider a list of all happy strings of length n sorted
    in lexicographical order. Return the kth string of this list or return an
    empty string if there are less than k happy strings of length n.

    Example 1:
    Input: n = 1, k = 3
    Output: "c"
    Explanation: The list ["a", "b", "c"] contains all happy strings of length
                 1. The third string is "c".

    Example 2:
    Input: n = 1, k = 4
    Output: ""
    Explanation: There are only 3 happy strings of length 1.

    Example 3:
    Input: n = 3, k = 9
    Output: "cab"
    Explanation: There are 12 different happy string of length 3
                 ["aba", "abc", "aca", "acb", "bab", "bac",
                  "bca", "bcb", "cab", "cac", "cba", "cbc"].
                  You will find the 9th string = "cab"

    Example 4:
    Input: n = 2, k = 7
    Output: ""

    Example 5:
    Input: n = 10, k = 100
    Output: "abacbabacb"

    Constraints:
    * 1 <= n <= 10
    * 1 <= k <= 100"""

    def getHappyString(self, n: int, k: int) -> str:
        k -= 1
        if 3*2**(n-1) <= k: return "" # impossible

        mp = {"": "abc", "a": "bc", "b": "ac", "c": "ab"}
        ans = [""]
        for i in range(n):
            q, k = divmod(k, 2**(n-i-1))
            ans.append(mp[ans[-1]][q])
        return "".join(ans)


    """1416. Restore The Array (Hard)
    A program was supposed to print an array of integers. The program forgot to
    print whitespaces and the array is printed as a string of digits and all we
    know is that all integers in the array were in the range [1, k] and there
    are no leading zeros in the array. Given the string s and the integer k.
    There can be multiple ways to restore the array. Return the number of
    possible array that can be printed as a string s using the mentioned
    program. The number of ways could be very large so return it modulo
    10^9 + 7.

    Example 1:
    Input: s = "1000", k = 10000
    Output: 1
    Explanation: The only possible array is [1000]

    Example 2:
    Input: s = "1000", k = 10
    Output: 0
    Explanation: There cannot be an array that was printed this way and has all
                 integer >= 1 and <= 10.

    Example 3:
    Input: s = "1317", k = 2000
    Output: 8
    Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]

    Example 4:
    Input: s = "2020", k = 30
    Output: 1
    Explanation: The only possible array is [20,20]. [2020] is invalid because
                 2020 > 30. [2,020] is ivalid because 020 contains leading zeros.

    Example 5:
    Input: s = "1234567890", k = 90
    Output: 34

    Constraints:
    * 1 <= s.length <= 10^5.
    * s consists of only digits and doesn't contain leading zeros.
    * 1 <= k <= 10^9."""

    def numberOfArrays(self, s: str, k: int) -> int:
        dp = [0]*(len(s)+1)
        dp[-1] = sm = 1

        ii = len(s)
        for i in reversed(range(len(s))):
            if s[i] != "0":
                while ii - i - 1 > log10(k) or int(s[i:ii]) > k:
                    sm = (sm - dp[ii]) % 1_000_000_007
                    ii -= 1
                dp[i] = sm
                sm = (sm + dp[i]) % 1_000_000_007
        return dp[0]


    """1417. Reformat The String (Easy)
    Given alphanumeric string s. (Alphanumeric string is a string consisting of
    lowercase English letters and digits). You have to find a permutation of
    the string where no letter is followed by another letter and no digit is
    followed by another digit. That is, no two adjacent characters have the
    same type. Return the reformatted string or return an empty string if it is
    impossible to reformat the string.

    Example 1:
    Input: s = "a0b1c2"
    Output: "0a1b2c"
    Explanation: No two adjacent characters have the same type in "0a1b2c".
                 "a0b1c2", "0a1b2c", "0c2a1b" are also valid permutations.

    Example 2:
    Input: s = "leetcode"
    Output: ""
    Explanation: "leetcode" has only characters so we cannot separate them by
                 digits.

    Example 3:
    Input: s = "1229857369"
    Output: ""
    Explanation: "1229857369" has only digits so we cannot separate them by
                 characters.

    Example 4:
    Input: s = "covid2019"
    Output: "c2o0v1i9d"

    Example 5:
    Input: s = "ab123"
    Output: "1a2b3"

    Constraints:
    * 1 <= s.length <= 500
    * s consists of only lowercase English letters and/or digits."""

    def reformat(self, s: str) -> str:
        alpha, digit = [], []
        for c in s:
            if c.isalpha(): alpha.append(c)
            else: digit.append(c)
        if len(alpha) < len(digit): alpha, digit = digit, alpha
        if len(alpha) - len(digit) > 1: return "" # impossible
        return "".join(x+y for x, y in zip_longest(alpha, digit, fillvalue=""))


    """1418. Display Table of Food Orders in a Restaurant (Medium)
    Given the array orders, which represents the orders that customers have
    done in a restaurant. More specifically
    orders[i]=[customerNamei,tableNumberi,foodItemi] where customerNamei is the
    name of the customer, tableNumberi is the table customer sit at, and
    foodItemi is the item customer orders. Return the restaurant's “display
    table”. The “display table” is a table whose row entries denote how many of
    each food item each table ordered. The first column is the table number and
    the remaining columns correspond to each food item in alphabetical order.
    The first row should be a header whose first column is “Table”, followed by
    the names of the food items. Note that the customer names are not part of
    the table. Additionally, the rows should be sorted in numerically
    increasing order.

    Example 1:
    Input: orders = [["David", "3", "Ceviche"      ],
                     ["Corina","10","Beef Burrito" ],
                     ["David", "3", "Fried Chicken"],
                     ["Carla", "5", "Water"        ],
                     ["Carla", "5", "Ceviche"      ],
                     ["Rous",  "3", "Ceviche"      ]]
    Output: [["Table","Beef Burrito","Ceviche","Fried Chicken","Water"],["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]]
    Explanation:
    The displaying table looks like:
    Table,Beef Burrito,Ceviche,Fried Chicken,Water
    3    ,0           ,2      ,1            ,0
    5    ,0           ,1      ,0            ,1
    10   ,1           ,0      ,0            ,0
    For the table 3: David orders "Ceviche" and "Fried Chicken", and Rous orders "Ceviche".
    For the table 5: Carla orders "Water" and "Ceviche".
    For the table 10: Corina orders "Beef Burrito".

    Example 2:
    Input: orders = [["James",  "12","Fried Chicken"   ],
                     ["Ratesh", "12","Fried Chicken"   ],
                     ["Amadeus","12","Fried Chicken"   ],
                     ["Adam",   "1", "Canadian Waffles"],
                     ["Brianna","1", "Canadian Waffles"]]
    Output: [["Table","Canadian Waffles","Fried Chicken"],["1","2","0"],["12","0","3"]]
    Explanation:
    For the table 1: Adam and Brianna order "Canadian Waffles".
    For the table 12: James, Ratesh and Amadeus order "Fried Chicken".

    Example 3:
    Input: orders = [["Laura",  "2","Bean Burrito"],
                     ["Jhon",   "2","Beef Burrito"],
                     ["Melissa","2","Soda"        ]]
    Output: [["Table","Bean Burrito","Beef Burrito","Soda"],["2","1","1","1"]]

    Constraints:
    * 1 <= orders.length <= 5 * 10^4
    * orders[i].length == 3
    * 1 <= customerNamei.length, foodItemi.length <= 20
    * customerNamei and foodItemi consist of lowercase and uppercase English letters and the space character.
    * tableNumberi is a valid integer between 1 and 500."""

    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        freq = {}
        foods = set()

        for _, table, food in orders:
            freq.setdefault(table, defaultdict(int))[food] += 1
            foods.add(food)

        foods = sorted(foods)
        ans = [["Table"] + foods]
        for k in sorted(freq, key=int):
            row = [k]
            for food in foods:
                row.append(str(freq[k][food]))
            ans.append(row)
        return ans


    """1419. Minimum Number of Frogs Croaking (Medium)
    Given the string croakOfFrogs, which represents a combination of the string
    "croak" from different frogs, that is, multiple frogs can croak at the same
    time, so multiple “croak” are mixed. Return the minimum number of different
    frogs to finish all the croak in the given string. A valid "croak" means a
    frog is printing 5 letters ‘c’, ’r’, ’o’, ’a’, ’k’ sequentially. The frogs
    have to print all five letters to finish a croak. If the given string is
    not a combination of valid "croak" return -1.

    Example 1:
    Input: croakOfFrogs = "croakcroak"
    Output: 1
    Explanation: One frog yelling "croak" twice.

    Example 2:
    Input: croakOfFrogs = "crcoakroak"
    Output: 2
    Explanation: The minimum number of frogs is two. The first frog could yell
                 "crcoakroak". The second frog could yell later "crcoakroak".

    Example 3:
    Input: croakOfFrogs = "croakcrook"
    Output: -1
    Explanation: The given string is an invalid combination of "croak" from
                 different frogs.

    Example 4:
    Input: croakOfFrogs = "croakcroa"
    Output: -1

    Constraints:
    * 1 <= croakOfFrogs.length <= 10^5
    * All characters in the string are: 'c', 'r', 'o', 'a' or 'k'."""

    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
        ans = 0
        freq = [0]*5 # freq array
        for c in croakOfFrogs:
            i = "croak".index(c)
            freq[i] += 1
            if i and freq[i-1] < freq[i]: return -1
            if c == "k":
                ans = max(ans, freq[0])
                for i in range(5): freq[i] -= 1
        if max(freq) == 0: return ans
        return -1


    """1420. Build Array Where You Can Find The Maximum Exactly K Comparisons (Hard)
    Given three integers n, m and k. Consider the following algorithm to find
    the maximum element of an array of positive integers:

    maximum_value = -1
    maximum_index = -1
    seach_cost = 0
    n = arr.length
    for (i = 0; i < n; i++) {
        if (maximum_value < arr[i]) {
            maximum_value = arr[i]
            maximum_index = i
            search_cost = search_cost + 1
        }
    }
    return search_cost

    You should build the array arr which has the following properties:
    * arr has exactly n integers.
    * 1 <= arr[i] <= m where (0 <= i < n).
    * After applying the mentioned algorithm to arr, the value search_cost is
      equal to k.
    Return the number of ways to build the array arr under the mentioned
    conditions. As the answer may grow large, the answer must be computed
    modulo 10^9 + 7.

    Example 1:
    Input: n = 2, m = 3, k = 1
    Output: 6
    Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]

    Example 2:
    Input: n = 5, m = 2, k = 3
    Output: 0
    Explanation: There are no possible arrays that satisify the mentioned conditions.

    Example 3:
    Input: n = 9, m = 1, k = 1
    Output: 1
    Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]

    Example 4:
    Input: n = 50, m = 100, k = 25
    Output: 34549172
    Explanation: Don't forget to compute the answer modulo 1000000007

    Example 5:
    Input: n = 37, m = 17, k = 7
    Output: 418930126

    Constraints:
    * 1 <= n <= 50
    * 1 <= m <= 100
    * 0 <= k <= n"""

    def numOfArrays(self, n: int, m: int, k: int) -> int:

        @cache
        def fn(i, x, k):
            """Return number of ways to build arr[i:] with current max at x and remaining cost at k."""
            if n - i < k: return 0 # impossible
            if m - x < k: return 0 # impossible
            if k == 0: return x**(n-i)
            return x*fn(i+1, x, k) + fn(i+1, x+1, k-1) + fn(i, x+1, k) - (x+1)*fn(i+1, x+1, k)

        return fn(0, 0, k) % 1_000_000_007


    """1423. Maximum Points You Can Obtain from Cards (Medium)
    There are several cards arranged in a row, and each card has an associated
    number of points The points are given in the integer array cardPoints. In
    one step, you can take one card from the beginning or from the end of the
    row. You have to take exactly k cards. Your score is the sum of the points
    of the cards you have taken. Given the integer array cardPoints and the
    integer k, return the maximum score you can obtain.

    Example 1:
    Input: cardPoints = [1,2,3,4,5,6,1], k = 3
    Output: 12
    Explanation: After the first step, your score will always be 1. However,
                 choosing the rightmost card first will maximize your total
                 score. The optimal strategy is to take the three cards on the
                 right, giving a final score of 1 + 6 + 5 = 12.

    Example 2:
    Input: cardPoints = [2,2,2], k = 2
    Output: 4
    Explanation: Regardless of which two cards you take, your score will always
                 be 4.

    Example 3:
    Input: cardPoints = [9,7,7,9,7,7,9], k = 7
    Output: 55
    Explanation: You have to take all the cards. Your score is the sum of
                 points of all cards.

    Example 4:
    Input: cardPoints = [1,1000,1], k = 1
    Output: 1
    Explanation: You cannot take the card in the middle. Your best score is 1.

    Example 5:
    Input: cardPoints = [1,79,80,1,1,1,200,1], k = 3
    Output: 202

    Constraints:
    * 1 <= cardPoints.length <= 10^5
    * 1 <= cardPoints[i] <= 10^4
    * 1 <= k <= cardPoints.length"""

    def maxScore(self, cardPoints: List[int], k: int) -> int:
        ans = val = sum(cardPoints[:k])
        for i in range(k):
            val += cardPoints[~i] - cardPoints[k-i-1]
            ans = max(ans, val)
        return ans


    """1426. Counting Elements (Easy)
    Given an integer array arr, count how many elements x there are, such that
    x + 1 is also in arr. If there're duplicates in arr, count them seperately.

    Example 1:
    Input: arr = [1,2,3]
    Output: 2
    Explanation: 1 and 2 are counted cause 2 and 3 are in arr.

    Example 2:
    Input: arr = [1,1,3,3,5,5,7,7]
    Output: 0
    Explanation: No numbers are counted, cause there's no 2, 4, 6, or 8 in arr.

    Example 3:
    Input: arr = [1,3,2,3,5,0]
    Output: 3
    Explanation: 0, 1 and 2 are counted cause 1, 2 and 3 are in arr.

    Example 4:
    Input: arr = [1,1,2,2]
    Output: 2
    Explanation: Two 1s are counted cause 2 is in arr.

    Example 5:
    Input: arr = [1,1,2]
    Output: 2
    Explanation: Both 1s are counted because 2 is in the array.

    Constraints:
    * 1 <= arr.length <= 1000
    * 0 <= arr[i] <= 1000"""

    def countElements(self, arr: List[int]) -> int:
        freq = {}
        for x in arr: freq[x] = freq.get(x, 0) + 1
        return sum(v for k, v in freq.items() if k + 1 in freq)


    """1427. Perform String Shifts (Easy)
    You are given a string s containing lowercase English letters, and a matrix
    shift, where shift[i] = [direction, amount]:
    * direction can be 0 (for left shift) or 1 (for right shift).
    * amount is the amount by which string s is to be shifted.
    * A left shift by 1 means remove the first character of s and append it to
      the end.
    * Similarly, a right shift by 1 means remove the last character of s and
      add it to the beginning.
    Return the final string after all operations.

    Example 1:
    Input: s = "abc", shift = [[0,1],[1,2]]
    Output: "cab"
    Explanation: [0,1] means shift to left by 1. "abc" -> "bca"
                 [1,2] means shift to right by 2. "bca" -> "cab"

    Example 2:
    Input: s = "abcdefg", shift = [[1,1],[1,1],[0,2],[1,3]]
    Output: "efgabcd"
    Explanation: [1,1] means shift to right by 1. "abcdefg" -> "gabcdef"
                 [1,1] means shift to right by 1. "gabcdef" -> "fgabcde"
                 [0,2] means shift to left by 2. "fgabcde" -> "abcdefg"
                 [1,3] means shift to right by 3. "abcdefg" -> "efgabcd"

    Constraints:
    * 1 <= s.length <= 100
    * s only contains lower case English letters.
    * 1 <= shift.length <= 100
    * shift[i].length == 2
    * 0 <= shift[i][0] <= 1
    * 0 <= shift[i][1] <= 100"""

    def stringShift(self, s: str, shift: List[List[int]]) -> str:
        amount = 0
        for d, x in shift:
            amount += x if d == 0 else -x
        amount %= len(s)
        return s[amount:] + s[:amount]


    """1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)
    Given an array of integers arr. We want to select three indices i, j and k
    where (0 <= i < j <= k < arr.length). Let's define a and b as follows:
    * a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
    * b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
    Note that ^ denotes the bitwise-xor operation. Return the number of triplets
    (i, j and k) Where a == b.

    Example 1:
    Input: arr = [2,3,1,6,7]
    Output: 4
    Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)

    Example 2:
    Input: arr = [1,1,1,1,1]
    Output: 10

    Constraints:
    * 1 <= arr.length <= 300
    * 1 <= arr[i] <= 10^8"""

    def countTriplets(self, arr: List[int]) -> int:
        ans = prefix = 0
        mp = defaultdict(lambda: [0, 0], {0: [0, 1]})
        for i, x in enumerate(arr):
            prefix ^= x
            s, c = mp[prefix]
            ans += c*i - s
            mp[prefix] = [s+i+1, c+1]
        return ans


    """1443. Minimum Time to Collect All Apples in a Tree (Medium)
    Given an undirected tree consisting of n vertices numbered from 0 to n-1,
    which has some apples in their vertices. You spend 1 second to walk over
    one edge of the tree. Return the minimum time in seconds you have to spend
    to collect all apples in the tree, starting at vertex 0 and coming back to
    this vertex. The edges of the undirected tree are given in the array edges,
    where edges[i] = [ai, bi] means that exists an edge connecting the vertices
    ai and bi. Additionally, there is a boolean array hasApple, where
    hasApple[i] = true means that vertex i has an apple; otherwise, it does not
    have any apple.

    Example 1:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]],
           hasApple = [false,false,true,false,true,true,false]
    Output: 8
    Explanation: The figure above represents the given tree where red vertices
                 have an apple. One optimal path to collect all apples is shown
                 by the green arrows.

    Example 2:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]],
           hasApple = [false,false,true,false,false,true,false]
    Output: 6
    Explanation: The figure above represents the given tree where red vertices
                 have an apple. One optimal path to collect all apples is shown
                 by the green arrows.

    Example 3:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]],
           hasApple = [false,false,false,false,false,false,false]
    Output: 0

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai < bi <= n - 1
    * fromi < toi
    * hasApple.length == n"""

    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        ans = [0]*n
        seen = [False]*n
        stack = [(0, -1)]
        while stack:
            u, p = stack[-1]
            if seen[u]:
                for v in tree[u]:
                    if v != p: ans[u] += ans[v]
                if u and (ans[u] or hasApple[u]): ans[u] += 1
                stack.pop()
            else:
                for v in tree[u]:
                    if v != p: stack.append((v, u))
                seen[u] = True
        return ans[0]*2


    """1444. Number of Ways of Cutting a Pizza (Hard)
    Given a rectangular pizza represented as a rows x cols matrix containing
    the following characters: 'A' (an apple) and '.' (empty cell) and given the
    integer k. You have to cut the pizza into k pieces using k-1 cuts. For each
    cut you choose the direction: vertical or horizontal, then you choose a cut
    position at the cell boundary and cut the pizza into two pieces. If you cut
    the pizza vertically, give the left part of the pizza to a person. If you
    cut the pizza horizontally, give the upper part of the pizza to a person.
    Give the last piece of pizza to the last person. Return the number of ways
    of cutting the pizza such that each piece contains at least one apple.
    Since the answer can be a huge number, return this modulo 10^9 + 7.

    Example 1:
    Input: pizza = ["A..","AAA","..."], k = 3
    Output: 3
    Explanation: The figure above shows the three ways to cut the pizza. Note
                 that pieces must contain at least one apple.

    Example 2:
    Input: pizza = ["A..","AA.","..."], k = 3
    Output: 1

    Example 3:
    Input: pizza = ["A..","A..","..."], k = 1
    Output: 1

    Constraints:
    * 1 <= rows, cols <= 50
    * rows == pizza.length
    * cols == pizza[i].length
    * 1 <= k <= 10
    * pizza consists of characters 'A' and '.' only."""

    def ways(self, pizza: List[str], k: int) -> int:
        m, n = len(pizza), len(pizza[0])

        prefix = [[0]*(n+1) for _ in range(m+1)] # prefix array
        for i in range(m):
            for j in range(n):
                prefix[i+1][j+1] = prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]
                if pizza[i][j] == "A": prefix[i+1][j+1] += 1

        @cache
        def fn(i, j, k):
            """Return number of ways of cutting pizza[i:][j:] for k people."""
            if i == m or j == n: return 0 # out of pizza
            apples = prefix[-1][-1] - prefix[-1][j] - prefix[i][-1] + prefix[i][j]
            if apples < k+1: return 0 # not enough apple
            if k == 0: return 1

            ans = 0
            for ii in range(i, m):
                if prefix[ii+1][-1] - prefix[ii+1][j] - prefix[i][-1] + prefix[i][j]:
                    ans += fn(ii+1, j, k-1)
            for jj in range(j, n):
                if prefix[-1][jj+1] - prefix[-1][j] - prefix[i][jj+1] + prefix[i][j]:
                    ans += fn(i, jj+1, k-1)
            return ans % 1_000_000_007

        return fn(0, 0, k-1)


    """1446. Consecutive Characters (Easy)
    Given a string s, the power of the string is the maximum length of a non-
    empty substring that contains only one unique character. Return the power
    of the string.

    Example 1:
    Input: s = "leetcode"
    Output: 2
    Explanation: The substring "ee" is of length 2 with the character 'e' only.

    Example 2:
    Input: s = "abbcccddddeeeeedcba"
    Output: 5
    Explanation: The substring "eeeee" is of length 5 with the character 'e' only.

    Example 3:
    Input: s = "triplepillooooow"
    Output: 5

    Example 4:
    Input: s = "hooraaaaaaaaaaay"
    Output: 11

    Example 5:
    Input: s = "tourist"
    Output: 1

    Constraints:
    * 1 <= s.length <= 500
    * s contains only lowercase English letters."""

    def maxPower(self, s: str) -> int:
        ans = 0
        for i in range(len(s)):
            if not i or s[i-1] != s[i]: cnt = 0
            cnt += 1
            ans = max(ans, cnt)
        return ans


    """1447. Simplified Fractions (Medium)
    Given an integer n, return a list of all simplified fractions between 0 and
    1 (exclusive) such that the denominator is less-than-or-equal-to n. The
    fractions can be in any order.

    Example 1:
    Input: n = 2
    Output: ["1/2"]
    Explanation: "1/2" is the only unique fraction with a denominator less-than-
                 or-equal-to 2.

    Example 2:
    Input: n = 3
    Output: ["1/2","1/3","2/3"]

    Example 3:
    Input: n = 4
    Output: ["1/2","1/3","1/4","2/3","3/4"]
    Explanation: "2/4" is not a simplified fraction because it can be
                 simplified to "1/2".

    Example 4:
    Input: n = 1
    Output: []

    Constraints: 1 <= n <= 100"""

    def simplifiedFractions(self, n: int) -> List[str]:
        ans = []
        stack = [(0, 1, 1, 1)] # Stern-Brocot tree
        while stack:
            px, pd, x, d = stack.pop()
            cx = px + x # mediant
            cd = pd + d
            if cd <= n:
                stack.append((cx, cd, x, d))
                stack.append((px, pd, cx, cd))
                ans.append(f"{cx}/{cd}")
        return ans


    """1448. Count Good Nodes in Binary Tree (Medium)
    Given a binary tree root, a node X in the tree is named good if in the path
    from root to X there are no nodes with a value greater than X. Return the
    number of good nodes in the binary tree.

    Example 1:
    Input: root = [3,1,4,3,null,1,5]
    Output: 4
    Explanation: Nodes in blue are good.
    Root Node (3) is always a good node.
    Node 4 -> (3,4) is the maximum value in the path starting from the root.
    Node 5 -> (3,4,5) is the maximum value in the path
    Node 3 -> (3,1,3) is the maximum value in the path.

    Example 2:
    Input: root = [3,3,null,4,2]
    Output: 3
    Explanation: Node 2 -> (3, 3, 2) is not good, because "3" is higher than it.

    Example 3:
    Input: root = [1]
    Output: 1
    Explanation: Root is considered as good.

    Constraints:
    * The number of nodes in the binary tree is in the range [1, 10^5].
    * Each node's value is between [-10^4, 10^4]."""

    def goodNodes(self, root: TreeNode) -> int:
        ans = 0
        stack = [(root, -inf)]
        while stack:
            node, val = stack.pop()
            if node:
                if node.val >= val: ans += 1
                val = max(val, node.val)
                stack.append((node.left, val))
                stack.append((node.right, val))
        return ans


    """1449. Form Largest Integer With Digits That Add up to Target (Hard)
    Given an array of integers cost and an integer target. Return the maximum
    integer you can paint under the following rules:
    * The cost of painting a digit (i+1) is given by cost[i] (0 indexed).
    * The total cost used must be equal to target.
    * Integer does not have digits 0.
    Since the answer may be too large, return it as string. If there is no way
    to paint any integer given the condition, return "0".

    Example 1:
    Input: cost = [4,3,2,5,6,7,2,5,5], target = 9
    Output: "7772"
    Explanation:  The cost to paint the digit '7' is 2, and the digit '2' is 3.
                  Then cost("7772") = 2*3+ 3*1 = 9. You could also paint "977",
                  but "7772" is the largest number.
    Digit    cost
      1  ->   4
      2  ->   3
      3  ->   2
      4  ->   5
      5  ->   6
      6  ->   7
      7  ->   2
      8  ->   5
      9  ->   5

    Example 2:
    Input: cost = [7,6,5,5,5,6,8,7,8], target = 12
    Output: "85"
    Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5.
                 Then cost("85") = 7 + 5 = 12.

    Example 3:
    Input: cost = [2,4,6,2,4,6,4,4,4], target = 5
    Output: "0"
    Explanation: It's not possible to paint any integer with total cost equal to target.

    Example 4:
    Input: cost = [6,10,15,40,40,40,40,40,40], target = 47
    Output: "32211"

    Constraints:
    * cost.length == 9
    * 1 <= cost[i] <= 5000
    * 1 <= target <= 5000"""

    def largestNumber(self, cost: List[int], target: int) -> str:

        @cache
        def fn(x):
            """Return max integer given target x."""
            if x == 0: return 0
            if x < 0: return -inf
            return max(fn(x - c) * 10 + i + 1 for i, c in enumerate(cost))

        return str(max(0, fn(target)))


    """1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence (Easy)
    Given a sentence that consists of some words separated by a single space,
    and a searchWord. You have to check if searchWord is a prefix of any word
    in sentence. Return the index of the word in sentence where searchWord is a
    prefix of this word (1-indexed). If searchWord is a prefix of more than one
    word, return the index of the first word (minimum index). If there is no
    such word return -1. A prefix of a string S is any leading contiguous
    substring of S.

    Example 1:
    Input: sentence = "i love eating burger", searchWord = "burg"
    Output: 4
    Explanation: "burg" is prefix of "burger" which is the 4th word in the sentence.

    Example 2:
    Input: sentence = "this problem is an easy problem", searchWord = "pro"
    Output: 2
    Explanation: "pro" is prefix of "problem" which is the 2nd and the 6th word
                 in the sentence, but we return 2 as it's the minimal index.

    Example 3:
    Input: sentence = "i am tired", searchWord = "you"
    Output: -1
    Explanation: "you" is not a prefix of any word in the sentence.

    Example 4:
    Input: sentence = "i use triple pillow", searchWord = "pill"
    Output: 4

    Example 5:
    Input: sentence = "hello from the other side", searchWord = "they"
    Output: -1

    Constraints:
    * 1 <= sentence.length <= 100
    * 1 <= searchWord.length <= 10
    * sentence consists of lowercase English letters and spaces.
    * searchWord consists of lowercase English letters."""

    def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
        for i, word in enumerate(sentence.split()):
            if word.startswith(searchWord): return i+1
        return -1


    """1456. Maximum Number of Vowels in a Substring of Given Length (Medium)
    Given a string s and an integer k. Return the maximum number of vowel
    letters in any substring of s with length k. Vowel letters in English are
    (a, e, i, o, u).

    Example 1:
    Input: s = "abciiidef", k = 3
    Output: 3
    Explanation: The substring "iii" contains 3 vowel letters.

    Example 2:
    Input: s = "aeiou", k = 2
    Output: 2
    Explanation: Any substring of length 2 contains 2 vowels.

    Example 3:
    Input: s = "leetcode", k = 3
    Output: 2
    Explanation: "lee", "eet" and "ode" contain 2 vowels.

    Example 4:
    Input: s = "rhythms", k = 4
    Output: 0
    Explanation: We can see that s doesn't have any vowel letters.

    Example 5:
    Input: s = "tryhard", k = 4
    Output: 1

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters.
    * 1 <= k <= s.length"""

    def maxVowels(self, s: str, k: int) -> int:
        ans = cnt = 0
        for i in range(len(s)):
            if s[i] in "aeiou": cnt += 1
            if i >= k and s[i-k] in "aeiou": cnt -= 1
            ans = max(ans, cnt)
        return ans


    """1457. Pseudo-Palindromic Paths in a Binary Tree (Medium)
    Given a binary tree where node values are digits from 1 to 9. A path in the
    binary tree is said to be pseudo-palindromic if at least one permutation of
    the node values in the path is a palindrome. Return the number of pseudo-
    palindromic paths going from the root node to leaf nodes.

    Example 1:
    Input: root = [2,3,1,3,1,null,1]
    Output: 2
    Explanation: The figure above represents the given binary tree. There are
                 three paths going from the root node to leaf nodes: the red
                 path [2,3,3], the green path [2,1,1], and the path [2,3,1].
                 Among these paths only red path and green path are pseudo-
                 palindromic paths since the red path [2,3,3] can be rearranged
                 in [3,2,3] (palindrome) and the green path [2,1,1] can be
                 rearranged in [1,2,1] (palindrome).

    Example 2:
    Input: root = [2,1,1,1,3,null,null,null,null,null,1]
    Output: 1
    Explanation: The figure above represents the given binary tree. There are
                 three paths going from the root node to leaf nodes: the green
                 path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among
                 these paths only the green path is pseudo-palindromic since
                 [2,1,1] can be rearranged in [1,2,1] (palindrome).

    Example 3:
    Input: root = [9]
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 9"""

    def pseudoPalindromicPaths (self, root: TreeNode) -> int:

        def fn(node, mask):
            """Post-order traverse the tree and update ans."""
            if not node: return 0
            mask ^= 1 << node.val
            if not node.left and not node.right: # leaf node
                return 1 if mask & (mask-1) == 0 else 0
            return fn(node.left, mask) + fn(node.right, mask)

        return fn(root, 0)


    """1458. Max Dot Product of Two Subsequences (Hard)
    Given two arrays nums1 and nums2. Return the maximum dot product between
    non-empty subsequences of nums1 and nums2 with the same length. A
    subsequence of a array is a new array which is formed from the original
    array by deleting some (can be none) of the characters without disturbing
    the relative positions of the remaining characters. (ie, [2,3,5] is a
    subsequence of [1,2,3,4,5] while [1,5,3] is not).

    Example 1:
    Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]
    Output: 18
    Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from
                 nums2. Their dot product is (2*3 + (-2)*(-6)) = 18.

    Example 2:
    Input: nums1 = [3,-2], nums2 = [2,-6,7]
    Output: 21
    Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.
                 Their dot product is (3*7) = 21.

    Example 3:
    Input: nums1 = [-1,-1], nums2 = [1,1]
    Output: -1
    Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.
                 Their dot product is -1.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 500
    * -1000 <= nums1[i], nums2[i] <= 1000"""

    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:

        @cache
        def fn(i, j):
            """Return max dot product of nums1[i:] and nums2[j:]."""
            if i == len(nums1) or j == len(nums2): return -inf
            return max(nums1[i]*nums2[j] + fn(i+1, j+1), nums1[i]*nums2[j], fn(i+1, j), fn(i, j+1))

        return fn(0, 0)


    """1460. Make Two Arrays Equal by Reversing Subarrays (Easy)
    You are given two integer arrays of equal length target and arr. In one
    step, you can select any non-empty subarray of arr and reverse it. You are
    allowed to make any number of steps. Return true if you can make arr equal
    to target or false otherwise.

    Example 1:
    Input: target = [1,2,3,4], arr = [2,4,1,3]
    Output: true
    Explanation: You can follow the next steps to convert arr to target:
                 1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]
                 2- Reverse subarray [4,2], arr becomes [1,2,4,3]
                 3- Reverse subarray [4,3], arr becomes [1,2,3,4]
                 There are multiple ways to convert arr to target, this is not
                 the only way to do so.

    Example 2:
    Input: target = [7], arr = [7]
    Output: true
    Explanation: arr is equal to target without any reverses.

    Example 3:
    Input: target = [3,7,9], arr = [3,7,11]
    Output: false
    Explanation: arr does not have value 9 and it can never be converted to
                 target.

    Constraints:
    * target.length == arr.length
    * 1 <= target.length <= 1000
    * 1 <= target[i] <= 1000
    * 1 <= arr[i] <= 1000"""

    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:
        return Counter(target) == Counter(arr)


    """1463. Cherry Pickup II (Hard)
    You are given a rows x cols matrix grid representing a field of cherries
    where grid[i][j] represents the number of cherries that you can collect
    from the (i, j) cell. You have two robots that can collect cherries for you:
    * Robot #1 is located at the top-left corner (0, 0), and
    * Robot #2 is located at the top-right corner (0, cols - 1).
    Return the maximum number of cherries collection using both robots by
    following the rules below:
    * From a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j),
      or (i + 1, j + 1).
    * When any robot passes through a cell, It picks up all cherries, and the
      cell becomes an empty cell.
    * When both robots stay in the same cell, only one takes the cherries.
    * Both robots cannot move outside of the grid at any moment.
    * Both robots should reach the bottom row in grid.

    Example 1:
    Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
    Output: 24
    Explanation: Path of robot #1 and #2 are described in color green and blue
                 respectively. Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.
                 Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12. Total of
                 cherries: 12 + 12 = 24.

    Example 2:
    Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
    Output: 28
    Explanation: Path of robot #1 and #2 are described in color green and blue
                 respectively. Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.
                 Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11. Total of
                 cherries: 17 + 11 = 28.

    Constraints:
    * rows == grid.length
    * cols == grid[i].length
    * 2 <= rows, cols <= 70
    * 0 <= grid[i][j] <= 100"""

    def cherryPickup(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        @cache
        def fn(i, j, k):
            """Return max cherries collectable from (i, j) and (i, k)."""
            if i == len(grid): return 0
            ans = grid[i][j]
            if j != k: ans += grid[i][k]
            val = 0
            for jj in range(j-1, j+2):
                for kk in range(k-1, k+2):
                    if 0 <= jj <= kk < n: val = max(val, fn(i+1, jj, kk))
            return ans + val

        return fn(0, 0, n-1)


    """1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts (Medium)
    Given a rectangular cake with height h and width w, and two arrays of
    integers horizontalCuts and verticalCuts where horizontalCuts[i] is the
    distance from the top of the rectangular cake to the ith horizontal cut and
    similarly, verticalCuts[j] is the distance from the left of the rectangular
    cake to the jth vertical cut. Return the maximum area of a piece of cake
    after you cut at each horizontal and vertical position provided in the
    arrays horizontalCuts and verticalCuts. Since the answer can be a huge
    number, return this modulo 10^9 + 7.

    Example 1:
    Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]
    Output: 4
    Explanation: The figure above represents the given rectangular cake. Red
                 lines are the horizontal and vertical cuts. After you cut the
                 cake, the green piece of cake has the maximum area.

    Example 2:
    Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]
    Output: 6
    Explanation: The figure above represents the given rectangular cake. Red
                 lines are the horizontal and vertical cuts. After you cut the
                 cake, the green and yellow pieces of cake have the maximum
                 area.

    Example 3:
    Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]
    Output: 9

    Constraints:
    * 2 <= h, w <= 10^9
    * 1 <= horizontalCuts.length < min(h, 10^5)
    * 1 <= verticalCuts.length < min(w, 10^5)
    * 1 <= horizontalCuts[i] < h
    * 1 <= verticalCuts[i] < w
    * It is guaranteed that all elements in horizontalCuts are distinct.
    * It is guaranteed that all elements in verticalCuts are distinct."""

    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:
        horizontalCuts = [0] + sorted(horizontalCuts) + [h]
        verticalCuts = [0] + sorted(verticalCuts) + [w]
        m = max(horizontalCuts[i] - horizontalCuts[i-1] for i in range(1, len(horizontalCuts)))
        n = max(verticalCuts[j] - verticalCuts[j-1] for j in range(1, len(verticalCuts)))
        return m*n % 1_000_000_007


    """1467. Probability of a Two Boxes Having The Same Number of Distinct Balls (Hard)
    Given 2n balls of k distinct colors. You will be given an integer array
    balls of size k where balls[i] is the number of balls of color i. All the
    balls will be shuffled uniformly at random, then we will distribute the
    first n balls to the first box and the remaining n balls to the other box
    (Please read the explanation of the second example carefully). Please note
    that the two boxes are considered different. For example, if we have two
    balls of colors a and b, and two boxes [] and (), then the distribution
    [a] (b) is considered different than the distribution [b] (a) (Please read
    the explanation of the first example carefully). We want to calculate the
    probability that the two boxes have the same number of distinct balls.

    Example 1:
    Input: balls = [1,1]
    Output: 1.00000
    Explanation: Only 2 ways to divide the balls equally:
    - A ball of color 1 to box 1 and a ball of color 2 to box 2
    - A ball of color 2 to box 1 and a ball of color 1 to box 2
    In both ways, the number of distinct colors in each box is equal. The
    probability is 2/2 = 1

    Example 2:
    Input: balls = [2,1,1]
    Output: 0.66667
    Explanation: We have the set of balls [1, 1, 2, 3]. This set of balls will
                 be shuffled randomly and we may have one of the 12 distinct
                 shuffles with equale probability (i.e. 1/12):
                 [1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1],
                 [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]
                 After that we add the first two balls to the first box and the
                 second two balls to the second box. We can see that 8 of these
                 12 possible random distributions have the same number of
                 distinct colors of balls in each box. Probability is 8/12 = 0.66667

    Example 3:
    Input: balls = [1,2,1,2]
    Output: 0.60000
    Explanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display
                 all the 180 possible random shuffles of this set but it is
                 easy to check that 108 of them will have the same number of
                 distinct colors in each box. Probability = 108 / 180 = 0.6.

    Example 4:
    Input: balls = [3,2,1]
    Output: 0.30000
    Explanation: The set of balls is [1, 1, 1, 2, 2, 3]. It is hard to display
                 all the 60 possible random shuffles of this set but it is easy
                 to check that 18 of them will have the same number of distinct
                 colors in each box. Probability = 18 / 60 = 0.3.

    Example 5:
    Input: balls = [6,6,6,6,6,6]
    Output: 0.90327

    Constraints:
    * 1 <= balls.length <= 8
    * 1 <= balls[i] <= 6
    * sum(balls) is even.
    * Answers within 10^-5 of the actual value will be accepted as correct."""

    def getProbability(self, balls: List[int]) -> float:
        n = sum(balls)//2

        @cache
        def fn(i, s0, s1, c0, c1):
            """Return number of ways to distribute boxes successfully (w/o considering relative order)."""
            if s0 > n or s1 > n: return 0 # impossible
            if i == len(balls): return int(c0 == c1)
            ans = 0
            for x in range(balls[i]+1):
                ans += fn(i+1, s0+x, s1+balls[i]-x, c0+(x > 0), c1+(x < balls[i])) * comb(balls[i], x)
            return ans

        return fn(0, 0, 0, 0, 0) / comb(2*n, n)


    """1469. Find All The Lonely Nodes (Easy)
    In a binary tree, a lonely node is a node that is the only child of its
    parent node. The root of the tree is not lonely because it does not have a
    parent node. Given the root of a binary tree, return an array containing
    the values of all lonely nodes in the tree. Return the list in any order.

    Example 1:
    Input: root = [1,2,3,null,4]
    Output: [4]
    Explanation: Light blue node is the only lonely node. Node 1 is the root
                 and is not lonely. Nodes 2 and 3 have the same parent and are
                 not lonely.

    Example 2:
    Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2]
    Output: [6,2]
    Explanation: Light blue nodes are lonely nodes. Please remember that order
                 doesn't matter, [2,6] is also an acceptable answer.

    Example 3:
    Input: root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]
    Output: [77,55,33,66,44,22]
    Explanation: Nodes 99 and 88 share the same parent. Node 11 is the root.
                 All other nodes are lonely.

    Example 4:
    Input: root = [197]
    Output: []

    Example 5:
    Input: root = [31,null,78,null,28]
    Output: [78,28]

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * Each node's value is between [1, 10^6]."""

    def getLonelyNodes(self, root: TreeNode) -> List[int]:
        ans = []
        stack = [root]
        while stack:
            node = stack.pop()
            if node.left:
                stack.append(node.left)
                if not node.right: ans.append(node.left.val)
            if node.right:
                stack.append(node.right)
                if not node.left: ans.append(node.right.val)
        return ans


    """1470. Shuffle the Array (Easy)
    Given the array nums consisting of 2n elements in the form
    [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form
    [x1,y1,x2,y2,...,xn,yn].

    Example 1:
    Input: nums = [2,5,1,3,4,7], n = 3
    Output: [2,3,5,4,1,7]
    Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is
                 [2,3,5,4,1,7].

    Example 2:
    Input: nums = [1,2,3,4,4,3,2,1], n = 4
    Output: [1,4,2,3,3,2,4,1]

    Example 3:
    Input: nums = [1,1,2,2], n = 2
    Output: [1,2,1,2]

    Constraints:
    * 1 <= n <= 500
    * nums.length == 2n
    * 1 <= nums[i] <= 10^3"""

    def shuffle(self, nums: List[int], n: int) -> List[int]:
        ans = []
        for i in range(n):
            ans.append(nums[i])
            ans.append(nums[i+n])
        return ans


    """1474. Delete N Nodes After M Nodes of a Linked List (Easy)
    Given the head of a linked list and two integers m and n. Traverse the
    linked list and remove some nodes in the following way:
    * Start with the head as the current node.
    * Keep the first m nodes starting with the current node.
    * Remove the next n nodes
    * Keep repeating steps 2 and 3 until you reach the end of the list.
    Return the head of the modified list after removing the mentioned nodes.
    Follow up question: How can you solve this problem by modifying the list
    in-place?

    Example 1:
    Input: head = [1,2,3,4,5,6,7,8,9,10,11,12,13], m = 2, n = 3
    Output: [1,2,6,7,11,12]
    Explanation: Keep the first (m = 2) nodes starting from the head of the
                 linked List  (1 ->2) show in black nodes. Delete the next
                 (n = 3) nodes (3 -> 4 -> 5) show in read nodes. Continue with
                 the same procedure until reaching the tail of the Linked List.
                 Head of linked list after removing nodes is returned.

    Example 2:
    Input: head = [1,2,3,4,5,6,7,8,9,10,11], m = 1, n = 3
    Output: [1,5,9]
    Explanation: Head of linked list after removing nodes is returned.

    Example 3:
    Input: head = [1,2,3,4,5,6,7,8,9,10,11], m = 3, n = 1
    Output: [1,2,3,5,6,7,9,10,11]

    Example 4:
    Input: head = [9,3,7,7,9,10,8,2], m = 1, n = 2
    Output: [9,7,8]

    Constraints:
    * The given linked list will contain between 1 and 10^4 nodes.
    * The value of each node in the linked list will be in the range [1, 10^6].
    * 1 <= m,n <= 1000"""

    def deleteNodes(self, head: ListNode, m: int, n: int) -> ListNode:
        prev, node, i = None, head, 0
        while node:
            if i%(m+n) < m: prev = node
            else: prev.next = node.next
            node, i = node.next, i+1
        return head


    """1475. Final Prices With a Special Discount in a Shop (Easy)
    Given the array prices where prices[i] is the price of the ith item in a
    shop. There is a special discount for items in the shop, if you buy the ith
    item, then you will receive a discount equivalent to prices[j] where j is
    the minimum index such that j > i and prices[j] <= prices[i], otherwise,
    you will not receive any discount at all. Return an array where the ith
    element is the final price you will pay for the ith item of the shop
    considering the special discount.

    Example 1:
    Input: prices = [8,4,6,2,3]
    Output: [4,2,4,2,3]
    Explanation:
    For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.
    For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.
    For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.
    For items 3 and 4 you will not receive any discount at all.

    Example 2:
    Input: prices = [1,2,3,4,5]
    Output: [1,2,3,4,5]
    Explanation: In this case, for all items, you will not receive any discount
                 at all.

    Example 3:
    Input: prices = [10,1,1,6]
    Output: [9,0,1,6]

    Constraints:
    * 1 <= prices.length <= 500
    * 1 <= prices[i] <= 10^3"""

    def finalPrices(self, prices: List[int]) -> List[int]:
        stack = []
        for i, x in enumerate(prices):
            while stack and prices[stack[-1]] >= x:
                prices[stack.pop()] -= x
            stack.append(i)
        return prices


    """1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (Medium)
    Given an array of integers arr and an integer target. You have to find two
    non-overlapping sub-arrays of arr each with sum equal target. There can be
    multiple answers so you have to find an answer where the sum of the lengths
    of the two sub-arrays is minimum. Return the minimum sum of the lengths of
    the two required sub-arrays, or return -1 if you cannot find such two sub-
    arrays.

    Example 1:
    Input: arr = [3,2,2,4,3], target = 3
    Output: 2
    Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of
                 their lengths is 2.

    Example 2:
    Input: arr = [7,3,4,7], target = 7
    Output: 2
    Explanation: Although we have three non-overlapping sub-arrays of
                 sum = 7 ([7], [3,4] and [7]), but we will choose the first and
                 third sub-arrays as the sum of their lengths is 2.

    Example 3:
    Input: arr = [4,3,2,6,2,3,4], target = 6
    Output: -1
    Explanation: We have only one sub-array of sum = 6.

    Example 4:
    Input: arr = [5,5,4,4,5], target = 3
    Output: -1
    Explanation: We cannot find a sub-array of sum = 3.

    Example 5:
    Input: arr = [3,1,1,1,5,1,2,1], target = 3
    Output: 3
    Explanation: Note that sub-arrays [1,2] and [2,1] cannot be an answer
                 because they overlap.

    Constraints:
    * 1 <= arr.length <= 10^5
    * 1 <= arr[i] <= 1000
    * 1 <= target <= 10^8"""

    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        ans = inf
        best = [inf]*len(arr) # shortest subarray ending at i
        prefix = 0
        latest = {0: -1}
        for i, x in enumerate(arr):
            prefix += x
            if prefix - target in latest:
                ii = latest[prefix - target]
                if ii >= 0:
                    ans = min(ans, i - ii + best[ii])
                best[i] = i - ii
            if i: best[i] = min(best[i-1], best[i])
            latest[prefix] = i
        return ans if ans < inf else -1


    """1478. Allocate Mailboxes (Hard)
    Given the array houses and an integer k. where houses[i] is the location of
    the ith house along a street, your task is to allocate k mailboxes in the
    street. Return the minimum total distance between each house and its
    nearest mailbox. The answer is guaranteed to fit in a 32-bit signed integer.

    Example 1:
    Input: houses = [1,4,8,10,20], k = 3
    Output: 5
    Explanation: Allocate mailboxes in position 3, 9 and 20. Minimum total
                 distance from each houses to nearest mailboxes is
                 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5

    Example 2:
    Input: houses = [2,3,5,12,18], k = 2
    Output: 9
    Explanation: Allocate mailboxes in position 3 and 14. Minimum total
                 distance from each houses to nearest mailboxes is
                 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.

    Example 3:
    Input: houses = [7,4,6,1], k = 1
    Output: 8

    Example 4:
    Input: houses = [3,6,14,10], k = 4
    Output: 0

    Constraints:
    * n == houses.length
    * 1 <= n <= 100
    * 1 <= houses[i] <= 10^4
    * 1 <= k <= n
    * Array houses contain unique integers."""

    def minDistance(self, houses: List[int], k: int) -> int:
        houses.sort() # ascending order
        n = len(houses)

        mdist = [[0]*n for _ in range(n)] # mdist[i][j] median distance of houses[i:j+1]
        for i in range(n):
            for j in range(i+1, n):
                mdist[i][j] = mdist[i][j-1] + houses[j] - houses[i+j >> 1]

        @cache
        def fn(n, k):
            """Return min distance of allocating k mailboxes to n houses."""
            if n <= k: return 0 # one mailbox for each house
            if k == 1: return mdist[0][n-1]
            ans = inf
            for nn in range(k-1, n):
                ans = min(ans, fn(nn, k-1) + mdist[nn][n-1])
            return ans

        return fn(n, k)


    """1480. Running Sum of 1d Array (Easy)
    Given an array nums. We define a running sum of an array as
    runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: [1,3,6,10]
    Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].

    Example 2:
    Input: nums = [1,1,1,1,1]
    Output: [1,2,3,4,5]
    Explanation: Running sum is obtained as follows:
                 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].

    Example 3:
    Input: nums = [3,1,2,10,1]
    Output: [3,4,6,16,17]

    Constraints:
    * 1 <= nums.length <= 1000
    * -10^6 <= nums[i] <= 10^6"""

    def runningSum(self, nums: List[int]) -> List[int]:
        prefix = []
        for x in nums:
            if prefix: x += prefix[-1]
            prefix.append(x)
        return prefix


    """1482. Minimum Number of Days to Make m Bouquets (Medium)
    You are given an integer array bloomDay, an integer m and an integer k. You
    want to make m bouquets. To make a bouquet, you need to use k adjacent
    flowers from the garden. The garden consists of n flowers, the ith flower
    will bloom in the bloomDay[i] and then can be used in exactly one bouquet.
    Return the minimum number of days you need to wait to be able to make m
    bouquets from the garden. If it is impossible to make m bouquets return -1.

    Example 1:
    Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
    Output: 3
    Explanation: Let us see what happened in the first three days. x means
                 flower bloomed and _ means flower did not bloom in the garden.
                 We need 3 bouquets each should contain 1 flower.
                 After day 1: [x, _, _, _, _]   // we can only make one bouquet.
                 After day 2: [x, _, _, _, x]   // we can only make two bouquets.
                 After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The
                                                // answer is 3.

    Example 2:
    Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
    Output: -1
    Explanation: We need 3 bouquets each has 2 flowers, that means we need 6
                 flowers. We only have 5 flowers so it is impossible to get the
                 needed bouquets and we return -1.

    Example 3:
    Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
    Output: 12
    Explanation: We need 2 bouquets each should have 3 flowers. Here is the
                 garden after the 7 and 12 days:
                 After day 7: [x, x, x, x, _, x, x]
                 We can make one bouquet of the first three flowers that
                 bloomed. We cannot make another bouquet from the last three
                 flowers that bloomed because they are not adjacent.
                 After day 12: [x, x, x, x, x, x, x]
                 It is obvious that we can make two bouquets in different ways.

    Constraints:
    * bloomDay.length == n
    * 1 <= n <= 10^5
    * 1 <= bloomDay[i] <= 10^9
    * 1 <= m <= 10^6
    * 1 <= k <= n"""

    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
        if len(bloomDay) < m*k: return -1
        lo, hi = 0, max(bloomDay)
        while lo < hi:
            mid = lo + hi >> 1
            bouquet = flower = 0
            for x in bloomDay:
                if x <= mid: flower += 1
                else: flower = 0
                if flower == k:
                    flower = 0
                    bouquet += 1
            if bouquet >= m: hi = mid
            else: lo = mid + 1
        return lo


    """1485. Clone Binary Tree With Random Pointer (Medium)
    A binary tree is given such that each node contains an additional random
    pointer which could point to any node in the tree or null. Return a deep
    copy of the tree. The tree is represented in the same input/output way as
    normal binary trees where each node is represented as a pair of
    [val, random_index] where:
    * val: an integer representing Node.val
    * random_index: the index of the node (in the input) where the random
      pointer points to, or null if it does not point to any node.
    You will be given the tree in class Node and you should return the cloned
    tree in class NodeCopy. NodeCopy class is just a clone of Node class with
    the same attributes and constructors.

    Example 1:
    Input: root = [[1,null],null,[4,3],[7,0]]
    Output: [[1,null],null,[4,3],[7,0]]
    Explanation: The original binary tree is [1,null,4,7]. The random pointer
                 of node one is null, so it is represented as [1, null]. The
                 random pointer of node 4 is node 7, so it is represented as
                 [4, 3] where 3 is the index of node 7 in the array
                 representing the tree. The random pointer of node 7 is node 1,
                 so it is represented as [7, 0] where 0 is the index of node 1
                 in the array representing the tree.

    Example 2:
    Input: root = [[1,4],null,[1,0],null,[1,5],[1,5]]
    Output: [[1,4],null,[1,0],null,[1,5],[1,5]]
    Explanation: The random pointer of a node can be the node itself.

    Example 3:
    Input: root = [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]
    Output: [[1,6],[2,5],[3,4],[4,3],[5,2],[6,1],[7,0]]

    Example 4:
    Input: root = []
    Output: []

    Example 5:
    Input: root = [[1,null],null,[2,null],null,[1,null]]
    Output: [[1,null],null,[2,null],null,[1,null]]

    Constraints:
    * The number of nodes in the tree is in the range [0, 1000].
    * Each node's value is between [1, 10^6]."""

    def copyRandomBinaryTree(self, root: 'Node') -> 'NodeCopy':
        if not root: return
        mp = defaultdict(NodeCopy)
        stack = [root]
        while stack:
            node = stack.pop()
            mp[node].val = node.val
            if node.left:
                mp[node].left = mp[node.left]
                stack.append(node.left)
            if node.right:
                mp[node].right = mp[node.right]
                stack.append(node.right)
            if node.random: mp[node].random = mp[node.random]
        return mp[root]


    """1490. Clone N-ary Tree (Medium)
    Given a root of an N-ary tree, return a deep copy (clone) of the tree. Each
    node in the n-ary tree contains a val (int) and a list (List[Node]) of its
    children.

    class Node {
        public int val;
        public List<Node> children;
    }

    Nary-Tree input serialization is represented in their level order traversal,
    each group of children is separated by the null value (See examples).

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: [1,null,3,2,4,null,5,6]

    Example 2:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]

    Constraints:
    * The depth of the n-ary tree is less than or equal to 1000.
    * The total number of nodes is between [0, 10^4].

    Follow up: Can your solution work for the graph problem?"""

    def cloneTree(self, root: 'Node') -> 'Node':
        if not root: return
        return Node(root.val, [self.cloneTree(x) for x in root.children])


    """1491. Average Salary Excluding the Minimum and Maximum Salary (Easy)
    Given an array of unique integers salary where salary[i] is the salary of
    the employee i. Return the average salary of employees excluding the
    minimum and maximum salary.

    Example 1:
    Input: salary = [4000,3000,1000,2000]
    Output: 2500.00000
    Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
    Average salary excluding minimum and maximum salary is (2000+3000)/2= 2500

    Example 2:
    Input: salary = [1000,2000,3000]
    Output: 2000.00000
    Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.
    Average salary excluding minimum and maximum salary is (2000)/1= 2000

    Example 3:
    Input: salary = [6000,5000,4000,3000,2000,1000]
    Output: 3500.00000

    Example 4:
    Input: salary = [8000,9000,2000,3000,6000,1000]
    Output: 4750.00000

    Constraints:
    * 3 <= salary.length <= 100
    * 10^3 <= salary[i] <= 10^6
    * salary[i] is unique.
    * Answers within 10^-5 of the actual value will be accepted as correct."""

    def average(self, salary: List[int]) -> float:
        return (sum(salary)-max(salary)-min(salary)) / (len(salary)-2)


    """1492. The kth Factor of n (Medium)
    Given two positive integers n and k. A factor of an integer n is defined as
    an integer i where n % i == 0. Consider a list of all factors of n sorted
    in ascending order, return the kth factor in this list or return -1 if n
    has less than k factors.

    Example 1:
    Input: n = 12, k = 3
    Output: 3
    Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.

    Example 2:
    Input: n = 7, k = 2
    Output: 7
    Explanation: Factors list is [1, 7], the 2nd factor is 7.

    Example 3:
    Input: n = 4, k = 4
    Output: -1
    Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.

    Example 4:
    Input: n = 1, k = 1
    Output: 1
    Explanation: Factors list is [1], the 1st factor is 1.

    Example 5:
    Input: n = 1000, k = 3
    Output: 4
    Explanation: Factors list is [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000].

    Constraints: 1 <= k <= n <= 1000"""

    def kthFactor(self, n: int, k: int) -> int:
        for i in range(1, int(sqrt(n))+1): # forward pass
            if not n%i: k -= 1
            if not k: return i

        while i > 0: # backward pass
            if i * i < n:
                if not n%i: k -= 1
                if not k: return n//i
            i -= 1

        return -1


    """1493. Longest Subarray of 1's After Deleting One Element (Medium)
    Given a binary array nums, you should delete one element from it. Return
    the size of the longest non-empty subarray containing only 1's in the
    resulting array. Return 0 if there is no such subarray.

    Example 1:
    Input: nums = [1,1,0,1]
    Output: 3
    Explanation: After deleting the number in position 2, [1,1,1] contains 3
                 numbers with value of 1's.

    Example 2:
    Input: nums = [0,1,1,1,0,1,1,0,1]
    Output: 5
    Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1]
                 longest subarray with value of 1's is [1,1,1,1,1].

    Example 3:
    Input: nums = [1,1,1]
    Output: 2
    Explanation: You must delete one element.

    Example 4:
    Input: nums = [1,1,0,0,1,1,1,0,1]
    Output: 4

    Example 5:
    Input: nums = [0,0,0]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1."""

    def longestSubarray(self, nums: List[int]) -> int:
        ans = 0
        queue = deque([-1])
        for i, x in enumerate(nums):
            if not x: queue.append(i)
            if len(queue) > 2: queue.popleft()
            ans = max(ans, i - queue[0] - 1)
        return ans


    """1494. Parallel Courses II (Hard)
    Given the integer n representing the number of courses at some university
    labeled from 1 to n, and the array dependencies where
    dependencies[i] = [xi, yi] represents a prerequisite relationship, that is,
    the course xi must be taken before the course yi. Also, you are given the
    integer k. In one semester you can take at most k courses as long as you
    have taken all the prerequisites for the courses you are taking. Return the
    minimum number of semesters to take all courses. It is guaranteed that you
    can take all courses in some way.

    Example 1:
    Input: n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2
    Output: 3
    Explanation: The figure above represents the given graph. In this case we
                 can take courses 2 and 3 in the first semester, then take
                 course 1 in the second semester and finally take course 4 in
                 the third semester.

    Example 2:
    Input: n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2
    Output: 4
    Explanation: The figure above represents the given graph. In this case one
                 optimal way to take all courses is: take courses 2 and 3 in
                 the first semester and take course 4 in the second semester,
                 then take course 1 in the third semester and finally take
                 course 5 in the fourth semester.

    Example 3:
    Input: n = 11, dependencies = [], k = 2
    Output: 6

    Constraints:
    * 1 <= n <= 15
    * 1 <= k <= n
    * 0 <= dependencies.length <= n * (n-1) / 2
    * dependencies[i].length == 2
    * 1 <= xi, yi <= n
    * xi != yi
    * All prerequisite relationships are distinct, that is, dependencies[i] != dependencies[j].
    * The given graph is a directed acyclic graph."""

    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:
        pre = [0]*n # prerequisites
        for u, v in dependencies:
            pre[v-1] |= 1 << (u-1)

        @cache
        def fn(mask):
            """Return min semesters to take remaining courses."""
            if mask == (1 << n) - 1: return 0 # all courses taken
            can = [] # available courses
            for i in range(n):
                if not mask & 1 << i and mask & pre[i] == pre[i]:
                    can.append(i)

            ans = inf
            for courses in combinations(can, min(k, len(can))):
                temp = mask
                for c in courses:
                    temp |= 1 << c
                ans = min(ans, 1 + fn(temp))
            return ans

        return fn(0)


    """1506. Find Root of N-Ary Tree (Medium)
    You are given all the nodes of an N-ary tree as an array of Node objects,
    where each node has a unique value. Return the root of the N-ary tree.

    Custom testing: An N-ary tree can be serialized as represented in its level
    order traversal where each group of children is separated by the null value
    (see examples). For example, the above tree is serialized as
    [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].

    The testing will be done in the following way:
    * The input data should be provided as a serialization of the tree.
    * The driver code will construct the tree from the serialized input data
      and put each Node object into an array in an arbitrary order.
    * The driver code will pass the array to findRoot, and your function should
      find and return the root Node object in the array.
    * The driver code will take the returned Node object and serialize it. If
      the serialized value and the input data are the same, the test passes.

    Example 1:
    Input: tree = [1,null,3,2,4,null,5,6]
    Output: [1,null,3,2,4,null,5,6]
    Explanation: The tree from the input data is shown above. The driver code
                 creates the tree and gives findRoot the Node objects in an
                 arbitrary order. For example, the passed array could be
                 [Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)] or
                 [Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)]. The
                 findRoot function should return the root Node(1), and the
                 driver code will serialize it and compare with the input data.
                 The input data and serialized Node(1) are the same, so the
                 test passes.

    Example 2:
    Input: tree = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]

    Constraints:
    * The total number of nodes is between [1, 5 * 10^4].
    * Each node has a unique value.

    Follow up: Could you solve this problem in constant space complexity with a
               linear time algorithm?"""

    def findRoot(self, tree: List['Node']) -> 'Node':
        val = 0
        for node in tree:
            val ^= node.val
            for child in node.children:
                val ^= child.val
        return next(node for node in tree if node.val == val)


    """1508. Range Sum of Sorted Subarray Sums (Medium)
    You are given the array nums consisting of n positive integers. You computed
    the sum of all non-empty continuous subarrays from the array and then sorted
    them in non-decreasing order, creating a new array of n * (n + 1) / 2
    numbers. Return the sum of the numbers from index left to index right
    (indexed from 1), inclusive, in the new array. Since the answer can be a
    huge number return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
    Output: 13
    Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After
                 sorting them in non-decreasing order we have the new array
                 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from
                 index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13.

    Example 2:
    Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
    Output: 6
    Explanation: The given array is the same as example 1. We have the new array
                 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from
                 index le = 3 to ri = 4 is 3 + 3 = 6.

    Example 3:
    Input: nums = [1,2,3,4], n = 4, left = 1, right = 10
    Output: 50

    Constraints:
    * n == nums.length
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 100
    * 1 <= left <= right <= n * (n + 1) / 2"""

    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        pq = [(x, i) for i, x in enumerate(nums)]
        heapify(pq)
        ans = 0
        for k in range(1, right+1):
            x, i = heappop(pq)
            if k >= left: ans = (ans + x) % 1_000_000_007
            if i+1 < n:
                heappush(pq, (x + nums[i+1], i+1))
        return ans


    """1509. Minimum Difference Between Largest and Smallest Value in Three Moves (Medium)
    You are given an integer array nums. In one move, you can choose one element
    of nums and change it to any value. Return the minimum difference between
    the largest and smallest value of nums after performing at most three moves.

    Example 1:
    Input: nums = [5,3,2,4]
    Output: 0
    Explanation: We can make at most 3 moves.
                 In the first move, change 2 to 3. nums becomes [5,3,3,4].
                 In the second move, change 4 to 3. nums becomes [5,3,3,3].
                 In the third move, change 5 to 3. nums becomes [3,3,3,3].
                 After performing 3 moves, the difference between the minimum
                 and maximum is 3 - 3 = 0.

    Example 2:
    Input: nums = [1,5,0,10,14]
    Output: 1
    Explanation: We can make at most 3 moves.
                 In the first move, change 5 to 0. nums becomes [1,0,0,10,14].
                 In the second move, change 10 to 0. nums becomes [1,0,0,0,14].
                 In the third move, change 14 to 1. nums becomes [1,0,0,0,1].
                 After performing 3 moves, the difference between the minimum
                 and maximum is 1 - 0 = 1. It can be shown that there is no way
                 to make the difference 0 in 3 moves.

    Example 3:
    Input: nums = [3,100,20]
    Output: 0
    Explanation: We can make at most 3 moves.
                 In the first move, change 100 to 7. nums becomes [3,7,20].
                 In the second move, change 20 to 7. nums becomes [3,7,7].
                 In the third move, change 3 to 7. nums becomes [7,7,7].
                 After performing 3 moves, the difference between the minimum
                 and maximum is 7 - 7 = 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9"""

    def minDifference(self, nums: List[int]) -> int:
        ans = inf
        nums.sort()
        for i in range(min(4, len(nums))):
            j = max(i, len(nums)-4+i)
            ans = min(ans, nums[j]-nums[i])
        return ans


    """1510. Stone Game IV (Hard)
    Alice and Bob take turns playing a game, with Alice starting first.
    Initially, there are n stones in a pile. On each player's turn, that player
    makes a move consisting of removing any non-zero square number of stones in
    the pile. Also, if a player cannot make a move, he/she loses the game.
    Given a positive integer n, return true if and only if Alice wins the game
    otherwise return false, assuming both players play optimally.

    Example 1:
    Input: n = 1
    Output: true
    Explanation: Alice can remove 1 stone winning the game because Bob doesn't
                 have any moves.

    Example 2:
    Input: n = 2
    Output: false
    Explanation: Alice can only remove 1 stone, after that Bob removes the last
                 one winning the game (2 -> 1 -> 0).

    Example 3:
    Input: n = 4
    Output: true
    Explanation: n is already a perfect square, Alice can win with one move,
                 removing 4 stones (4 -> 0).

    Constraints: 1 <= n <= 10^5"""

    def winnerSquareGame(self, n: int) -> bool:
        dp = [False] * (n+1)
        for x in range(1, n+1):
            for k in range(1, int(sqrt(x))+1):
                if not dp[x-k*k]:
                    dp[x] = True
                    break
        return dp[-1]


    """1514. Path with Maximum Probability (Medium)
    You are given an undirected weighted graph of n nodes (0-indexed),
    represented by an edge list where edges[i] = [a, b] is an undirected edge
    connecting the nodes a and b with a probability of success of traversing
    that edge succProb[i]. Given two nodes start and end, find the path with the
    maximum probability of success to go from start to end and return its
    success probability. If there is no path from start to end, return 0. Your
    answer will be accepted if it differs from the correct answer by at most
    1e-5.

    Example 1:
    Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
    Output: 0.25000
    Explanation: There are two paths from start to end, one having a probability
                 of success = 0.2 and the other has 0.5 * 0.5 = 0.25.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
    Output: 0.30000

    Example 3:
    Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
    Output: 0.00000
    Explanation: There is no path between 0 and 2.

    Constraints:
    * 2 <= n <= 10^4
    * 0 <= start, end < n
    * start != end
    * 0 <= a, b < n
    * a != b
    * 0 <= succProb.length == edges.length <= 2*10^4
    * 0 <= succProb[i] <= 1
    * There is at most one edge between every two nodes."""

    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start_node: int, end_node: int) -> float:
        graph = [[] for _ in range(n)]
        for (u, v), p in zip(edges, succProb):
            graph[u].append((v, p))
            graph[v].append((u, p))
        pq = [(-1, start_node)]
        dist = [0]*n
        dist[start_node] = -1
        while pq:
            p, u = heappop(pq)
            if u == end_node: return -p
            for v, x in graph[u]:
                if dist[v] > p*x:
                    dist[v] = p*x
                    heappush(pq, (p*x, v))
        return 0


    """1516. Move Sub-Tree of N-Ary Tree (Hard)
    Given the root of an N-ary tree of unique values, and two nodes of the tree
    p and q. You should move the subtree of the node p to become a direct child
    of node q. If p is already a direct child of q, do not change anything.
    Node p must be the last child in the children list of node q. Return the
    root of the tree after adjusting it. There are 3 cases for nodes p and q:
    * Node q is in the sub-tree of node p.
    * Node p is in the sub-tree of node q.
    * Neither node p is in the sub-tree of node q nor node q is in the sub-tree
      of node p.
    In cases 2 and 3, you just need to move p (with its sub-tree) to be a child
    of q, but in case 1 the tree may be disconnected, thus you need to
    reconnect the tree again. Please read the examples carefully before solving
    this problem. Nary-Tree input serialization is represented in their level
    order traversal, each group of children is separated by the null value (See
    examples). For example, the above tree is serialized as
    [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].

    Example 1:
    Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 4, q = 1
    Output: [1,null,2,3,4,null,5,null,6,null,7,8]
    Explanation: This example follows the second case as node p is in the sub-
                 tree of node q. We move node p with its sub-tree to be a
                 direct child of node q. Notice that node 4 is the last child
                 of node 1.

    Example 2:
    Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 7, q = 4
    Output: [1,null,2,3,null,4,5,null,6,null,7,8]
    Explanation: Node 7 is already a direct child of node 4. We don't change
                 anything.

    Example 3:
    Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 3, q = 8
    Output: [1,null,2,null,4,5,null,7,8,null,null,null,3,null,6]
    Explanation: This example follows case 3 because node p is not in the sub-
                 tree of node q and vice-versa. We can move node 3 with its
                 sub-tree and make it as node 8's child.

    Constraints:
    * The total number of nodes is between [2, 1000].
    * Each node has a unique value.
    * p != null
    * q != null
    * p and q are two different nodes (i.e. p != q)."""

    def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':
        if p not in q.children:
            parent = {root : None}
            stack = [root]
            while stack:
                u = stack.pop()
                for v in u.children:
                    parent[v] = u
                    stack.append(v)
            anc = set()
            n = q
            while n:
                anc.add(n)
                n = parent[n]
            if p in anc:
                parent[q].children.remove(q)
                if p == root: root = q
                else:
                    i = parent[p].children.index(p)
                    parent[p].children[i] = q
            else: parent[p].children.remove(p)
            q.children.append(p)
        return root


    """1518. Water Bottles (Easy)
    Given numBottles full water bottles, you can exchange numExchange empty
    water bottles for one full water bottle. The operation of drinking a full
    water bottle turns it into an empty bottle. Return the maximum number of
    water bottles you can drink.

    Example 1:
    Input: numBottles = 9, numExchange = 3
    Output: 13
    Explanation: You can exchange 3 empty bottles to get 1 full water bottle.
                 Number of water bottles you can drink: 9 + 3 + 1 = 13.

    Example 2:
    Input: numBottles = 15, numExchange = 4
    Output: 19
    Explanation: You can exchange 4 empty bottles to get 1 full water bottle.
                 Number of water bottles you can drink: 15 + 3 + 1 = 19.

    Example 3:
    Input: numBottles = 5, numExchange = 5
    Output: 6

    Example 4:
    Input: numBottles = 2, numExchange = 3
    Output: 2

    Constraints:
    * 1 <= numBottles <= 100
    * 2 <= numExchange <= 100"""

    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        ans = empty = 0
        while numBottles:
            ans += numBottles
            numBottles, empty = divmod(numBottles + empty, numExchange)
        return ans


    """1519. Number of Nodes in the Sub-Tree With the Same Label (Medium)
    You are given a tree (i.e. a connected, undirected graph that has no cycles)
    consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The
    root of the tree is the node 0, and each node of the tree has a label which
    is a lower-case character given in the string labels (i.e. The node with
    the number i has the label labels[i]). The edges array is given on the form
    edges[i] = [ai, bi], which means there is an edge between nodes ai and bi
    in the tree. Return an array of size n where ans[i] is the number of nodes
    in the subtree of the ith node which have the same label as node i. A
    subtree of a tree T is the tree consisting of a node in T and all of its
    descendant nodes.

    Example 1:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = "abaedcd"
    Output: [2,1,1,1,1,1,1]
    Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label
                 'a' as well, thus the answer is 2. Notice that any node is
                 part of its sub-tree. Node 1 has a label 'b'. The sub-tree of
                 node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have
                 different labels than node 1, the answer is just 1 (the node
                 itself).

    Example 2:
    Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = "bbbb"
    Output: [4,2,1,1]
    Explanation: The sub-tree of node 2 contains only node 2, so the answer is
                 1. The sub-tree of node 3 contains only node 3, so the answer
                 is 1. The sub-tree of node 1 contains nodes 1 and 2, both have
                 label 'b', thus the answer is 2. The sub-tree of node 0
                 contains nodes 0, 1, 2 and 3, all with label 'b', thus the
                 answer is 4.

    Example 3:
    Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = "aabab"
    Output: [3,2,1,1,1]

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * labels.length == n
    * labels is consisting of only of lowercase English letters."""

    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        ans = [0]*n
        freq = [[0]*26 for _ in range(n)]
        seen = [False]*n
        stack = [(0, -1)]
        while stack:
            u, p = stack[-1]
            if seen[u]:
                freq[u][ord(labels[u]) - 97] += 1
                for v in tree[u]:
                    if v != p:
                        for i, x in enumerate(freq[v]):
                            freq[u][i] += x
                ans[u] = freq[u][ord(labels[u]) - 97]
                stack.pop()
            else:
                for v in tree[u]:
                    if v != p: stack.append((v, u))
                seen[u] = True
        return ans


    """1520. Maximum Number of Non-Overlapping Substrings (Hard)
    Given a string s of lowercase letters, you need to find the maximum number
    of non-empty substrings of s that meet the following conditions:
    * The substrings do not overlap, that is for any two substrings s[i..j] and
      s[k..l], either j < k or i > l is true.
    * A substring that contains a certain character c must also contain all
      occurrences of c.
    Find the maximum number of substrings that meet the above conditions. If
    there are multiple solutions with the same number of substrings, return the
    one with minimum total length. It can be shown that there exists a unique
    solution of minimum total length. Notice that you can return the substrings
    in any order.

    Example 1:
    Input: s = "adefaddaccc"
    Output: ["e","f","ccc"]
    Explanation: The following are all the possible substrings that meet the
                 conditions: ["adefaddaccc"
                              "adefadda",
                              "ef",
                              "e",
                              "f",
                              "ccc",]
                 If we choose the first string, we cannot choose anything else
                 and we'd get only 1. If we choose "adefadda", we are left with
                 "ccc" which is the only one that doesn't overlap, thus
                 obtaining 2 substrings. Notice also, that it's not optimal to
                 choose "ef" since it can be split into two. Therefore, the
                 optimal way is to choose ["e","f","ccc"] which gives us 3
                 substrings. No other solution of the same number of substrings
                 exist.

    Example 2:
    Input: s = "abbaccd"
    Output: ["d","bb","cc"]
    Explanation: Notice that while the set of substrings ["d","abba","cc"] also
                 has length 3, it's considered incorrect since it has larger
                 total length.

    Constraints:
    * 1 <= s.length <= 10^5
    * s contains only lowercase English letters."""

    def maxNumOfSubstrings(self, s: str) -> List[str]:
        locs = {}
        for i, x in enumerate(s):
            locs.setdefault(x, []).append(i)

        def fn(lo, hi):
            """Return expanded range covering all chars in s[lo:hi+1]."""
            for xx in locs:
                k0 = bisect_left(locs[xx], lo)
                k1 = bisect_left(locs[xx], hi)
                if k0 < k1 and (locs[xx][0] < lo or hi < locs[xx][-1]):
                    lo = min(lo, locs[xx][0])
                    hi = max(hi, locs[xx][-1])
                    lo, hi = fn(lo, hi)
            return lo, hi

        group = set()
        for x in locs:
            group.add(fn(locs[x][0], locs[x][-1]))

        ans = [] # ISMP (interval scheduling maximization problem)
        prev = -1
        for lo, hi in sorted(group, key=lambda x: x[1]):
            if prev < lo:
                ans.append(s[lo:hi+1])
                prev = hi
        return ans


    """1522. Diameter of N-Ary Tree (Medium)
    Given a root of an N-ary tree, you need to compute the length of the
    diameter of the tree. The diameter of an N-ary tree is the length of the
    longest path between any two nodes in the tree. This path may or may not
    pass through the root. (Nary-Tree input serialization is represented in
    their level order traversal, each group of children is separated by the
    null value.)

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: 3
    Explanation: Diameter is shown in red color.

    Example 2:
    Input: root = [1,null,2,null,3,4,null,5,null,6]
    Output: 4

    Example 3:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,
                   null,12,null,13,null,null,14]
    Output: 7

    Constraints:
    * The depth of the n-ary tree is less than or equal to 1000.
    * The total number of nodes is between [1, 10^4]."""

    def diameter(self, root: 'Node') -> int:

        def fn(node):
            """Return node's height."""
            nonlocal ans
            if not node: return 0
            mx1 = mx2 = 0
            for child in node.children:
                val = fn(child)
                if val >= mx1: mx1, mx2 = val, mx1
                elif val > mx2: mx2 = val
            ans = max(ans, mx1 + mx2)
            return mx1 + 1

        ans = 0
        fn(root)
        return ans


    """1523. Count Odd Numbers in an Interval Range (Easy)
    Given two non-negative integers low and high. Return the count of odd
    numbers between low and high (inclusive).

    Example 1:
    Input: low = 3, high = 7
    Output: 3
    Explanation: The odd numbers between 3 and 7 are [3,5,7].

    Example 2:
    Input: low = 8, high = 10
    Output: 1
    Explanation: The odd numbers between 8 and 10 are [9].

    Constraints: 0 <= low <= high <= 10^9"""

    def countOdds(self, low: int, high: int) -> int:
        return (high+1)//2 - low//2


    """1524. Number of Sub-arrays With Odd Sum (Medium)
    Given an array of integers arr. Return the number of sub-arrays with odd
    sum. As the answer may grow large, the answer must be computed modulo
    10^9 + 7.

    Example 1:
    Input: arr = [1,3,5]
    Output: 4
    Explanation: All sub-arrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]
    All sub-arrays sum are [1,4,9,3,8,5].
    Odd sums are [1,9,3,5] so the answer is 4.

    Example 2:
    Input: arr = [2,4,6]
    Output: 0
    Explanation: All sub-arrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]
    All sub-arrays sum are [2,6,12,4,10,6].
    All sub-arrays have even sum and the answer is 0.

    Example 3:
    Input: arr = [1,2,3,4,5,6,7]
    Output: 16

    Example 4:
    Input: arr = [100,100,99,99]
    Output: 4

    Example 5:
    Input: arr = [7]
    Output: 1

    Constraints:
    * 1 <= arr.length <= 10^5
    * 1 <= arr[i] <= 100"""

    def numOfSubarrays(self, arr: List[int]) -> int:
        freq = [1, 0]
        ans = prefix = 0
        for x in arr:
            prefix += x
            ans += freq[1 ^ prefix&1]
            freq[prefix&1] += 1
        return ans % 1_000_000_007


    """1525. Number of Good Ways to Split a String (Medium)
    You are given a string s, a split is called good if you can split s into 2
    non-empty strings p and q where its concatenation is equal to s and the
    number of distinct letters in p and q are the same. Return the number of
    good splits you can make in s.

    Example 1:
    Input: s = "aacaba"
    Output: 2
    Explanation: There are 5 ways to split "aacaba" and 2 of them are good.
    ("a", "acaba") Left string and right string contains 1 and 3 different letters respectively.
    ("aa", "caba") Left string and right string contains 1 and 3 different letters respectively.
    ("aac", "aba") Left string and right string contains 2 and 2 different letters respectively (good split).
    ("aaca", "ba") Left string and right string contains 2 and 2 different letters respectively (good split).
    ("aacab", "a") Left string and right string contains 3 and 1 different letters respectively.

    Example 2:
    Input: s = "abcd"
    Output: 1
    Explanation: Split the string as follows ("ab", "cd").

    Example 3:
    Input: s = "aaaaa"
    Output: 4
    Explanation: All possible splits are good.

    Example 4:
    Input: s = "acbadbaada"
    Output: 2

    Constraints:
    * s contains only lowercase English letters.
    * 1 <= s.length <= 10^5"""

    def numSplits(self, s: str) -> int:
        freq = {}
        for c in s: freq[c] = 1 + freq.get(c, 0)

        ans = 0
        seen = set()
        for i, c in enumerate(s):
            seen.add(c)
            freq[c] -= 1
            if not freq[c]: freq.pop(c)
            if len(seen) == len(freq): ans += 1
        return ans


    """1526. Minimum Number of Increments on Subarrays to Form a Target Array (Hard)
    Given an array of positive integers target and an array initial of same
    size with all zeros. Return the minimum number of operations to form a
    target array from initial if you are allowed to do the following operation:
    * Choose any subarray from initial and increment each value by one.
    The answer is guaranteed to fit within the range of a 32-bit signed integer.

    Example 1:
    Input: target = [1,2,3,2,1]
    Output: 3
    Explanation: We need at least 3 operations to form the target array from the initial array.
    [0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).
    [1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).
    [1,2,2,2,1] increment 1 at index 2.
    [1,2,3,2,1] target array is formed.

    Example 2:
    Input: target = [3,1,1,2]
    Output: 4
    Explanation: (initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target).

    Example 3:
    Input: target = [3,1,5,4,2]
    Output: 7
    Explanation: (initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1]
                                      -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target).

    Example 4:
    Input: target = [1,1,1,1]
    Output: 1

    Constraints:
    * 1 <= target.length <= 10^5
    * 1 <= target[i] <= 10^5"""

    def minNumberOperations(self, target: List[int]) -> int:
        ans = prev = 0
        for x in target:
            ans += max(x - prev, 0)
            prev = x
        return ans


    """1528. Shuffle String (Easy)
    Given a string s and an integer array indices of the same length. The
    string s will be shuffled such that the character at the ith position moves
    to indices[i] in the shuffled string. Return the shuffled string.

    Example 1:
    Input: s = "codeleet", indices = [4,5,6,7,0,2,1,3]
    Output: "leetcode"
    Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.

    Example 2:
    Input: s = "abc", indices = [0,1,2]
    Output: "abc"
    Explanation: After shuffling, each character remains in its position.

    Example 3:
    Input: s = "aiohn", indices = [3,1,4,2,0]
    Output: "nihao"

    Example 4:
    Input: s = "aaiougrt", indices = [4,0,2,6,7,3,1,5]
    Output: "arigatou"

    Example 5:
    Input: s = "art", indices = [1,0,2]
    Output: "rat"

    Constraints:
    * s.length == indices.length == n
    * 1 <= n <= 100
    * s contains only lower-case English letters.
    * 0 <= indices[i] < n
    * All values of indices are unique (i.e. indices is a permutation of the integers from 0 to n - 1)."""

    def restoreString(self, s: str, indices: List[int]) -> str:
        ans = [""]*len(s)
        for i, x in zip(indices, s):
            ans[i] = x
        return "".join(ans)


    """1529. Bulb Switcher IV (Medium)
    There is a room with n bulbs, numbered from 0 to n - 1, arranged in a row
    from left to right. Initially, all the bulbs are turned off. Your task is
    to obtain the configuration represented by target where target[i] is '1'
    if the ith bulb is turned on and is '0' if it is turned off. You have a
    switch to flip the state of the bulb, a flip operation is defined as
    follows:
    * Choose any bulb (index i) of your current configuration.
    * Flip each bulb from index i to index n - 1.
    When any bulb is flipped it means that if it is '0' it changes to '1' and
    if it is '1' it changes to '0'. Return the minimum number of flips
    required to form target.

    Example 1:
    Input: target = "10111"
    Output: 3
    Explanation: Initial configuration "00000".
    flip from the third bulb:  "00000" -> "00111"
    flip from the first bulb:  "00111" -> "11000"
    flip from the second bulb:  "11000" -> "10111"
    We need at least 3 flip operations to form target.

    Example 2:
    Input: target = "101"
    Output: 3
    Explanation: "000" -> "111" -> "100" -> "101".

    Example 3:
    Input: target = "00000"
    Output: 0

    Example 4:
    Input: target = "001011101"
    Output: 5

    Constraints:
    * 1 <= target.length <= 10^5
    * target[i] is either '0' or '1'."""

    def minFlips(self, target: str) -> int:
        ans, prev = 0,"0"
        for c in target:
            if prev != c: ans += 1
            prev = c
        return ans


    """1530. Number of Good Leaf Nodes Pairs (Medium)
    Given the root of a binary tree and an integer distance. A pair of two
    different leaf nodes of a binary tree is said to be good if the length of
    the shortest path between them is less than or equal to distance. Return
    the number of good leaf node pairs in the tree.

    Example 1:
    Input: root = [1,2,3,null,4], distance = 3
    Output: 1
    Explanation: The leaf nodes of the tree are 3 and 4 and the length of the
                 shortest path between them is 3. This is the only good pair.

    Example 2:
    Input: root = [1,2,3,4,5,6,7], distance = 3
    Output: 2
    Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The
                 pair [4,6] is not good because the length of ther shortest path
                 between them is 4.

    Example 3:
    Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
    Output: 1
    Explanation: The only good pair is [2,5].

    Example 4:
    Input: root = [100], distance = 1
    Output: 0

    Example 5:
    Input: root = [1,1,1], distance = 2
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [1, 2^10].
    * Each node's value is between [1, 100].
    * 1 <= distance <= 10"""

    def countPairs(self, root: TreeNode, distance: int) -> int:
        ans = 0

        def fn(node):
            """Return distances of leaves of sub-tree rooted at node."""
            nonlocal ans
            if not node: return []
            if node.left is node.right is None: return [0]
            left, right = fn(node.left), fn(node.right)
            j = len(right)-1
            for x in left:
                while 0 <= j and x + right[j] + 2 > distance:
                    j -= 1
                ans += j+1
            out = []
            i = j = 0
            while i < len(left) or j < len(right):
                if j == len(right) or i < len(left) and left[i] < right[j]:
                    out.append(1 + left[i])
                    i += 1
                else:
                    out.append(1 + right[j])
                    j += 1
            return out

        fn(root)
        return ans


    """1531. String Compression II (Hard)
    Run-length encoding is a string compression method that works by replacing
    consecutive identical characters (repeated 2 or more times) with the
    concatenation of the character and the number marking the count of the
    characters (length of the run). For example, to compress the string
    "aabccc" we replace "aa" by "a2" and replace "ccc" by "c3". Thus the
    compressed string becomes "a2bc3". Notice that in this problem, we are not
    adding '1' after single characters. Given a string s and an integer k. You
    need to delete at most k characters from s such that the run-length encoded
    version of s has minimum length. Find the minimum length of the run-length
    encoded version of s after deleting at most k characters.

    Example 1:
    Input: s = "aaabcccd", k = 2
    Output: 4
    Explanation: Compressing s without deleting anything will give us "a3bc3d"
                 of length 6. Deleting any of the characters 'a' or 'c' would
                 at most decrease the length of the compressed string to 5, for
                 instance delete 2 'a' then we will have s = "abcccd" which
                 compressed is abc3d. Therefore, the optimal way is to delete
                 'b' and 'd', then the compressed version of s will be "a3c3"
                 of length 4.

    Example 2:
    Input: s = "aabbaa", k = 2
    Output: 2
    Explanation: If we delete both 'b' characters, the resulting compressed
                 string would be "a4" of length 2.

    Example 3:
    Input: s = "aaaaaaaaaaa", k = 0
    Output: 3
    Explanation: Since k is zero, we cannot delete anything. The compressed
                 string is "a11" of length 3.

    Constraints:
    * 1 <= s.length <= 100
    * 0 <= k <= s.length
    * s contains only lowercase English letters."""

    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        rle = lambda x: x if x <= 1 else int(log10(x)) + 2 # rle length of a char repeated x times

        @cache
        def fn(i, k, prev, cnt):
            """Return length of rle of s[i:] with k chars to be deleted."""
            if k < 0: return inf
            if i == len(s): return 0
            ans = fn(i+1, k-1, prev, cnt) # delete current character
            if prev == s[i]:
                ans = min(ans, fn(i+1, k, s[i], cnt+1) + rle(cnt+1) - rle(cnt))
            else:
                ans = min(ans, fn(i+1, k, s[i], 1) + 1)
            return ans

        return fn(0, k, "", 0)


    """1533. Find the Index of the Large Integer (Medium)
    We have an integer array arr, where all the integers in arr are equal
    except for one integer which is larger than the rest of the integers. You
    will not be given direct access to the array, instead, you will have an API
    ArrayReader which have the following functions:
    * int compareSub(int l, int r, int x, int y): where
      0 <= l, r, x, y < ArrayReader.length(), l <= r and x <= y. The function
      compares the sum of sub-array arr[l..r] with the sum of the sub-array
      arr[x..y] and returns:
      - 1 if arr[l]+arr[l+1]+...+arr[r] > arr[x]+arr[x+1]+...+arr[y].
      - 0 if arr[l]+arr[l+1]+...+arr[r] == arr[x]+arr[x+1]+...+arr[y].
      - -1 if arr[l]+arr[l+1]+...+arr[r] < arr[x]+arr[x+1]+...+arr[y].
    * int length(): Returns the size of the array.
    You are allowed to call compareSub() 20 times at most. You can assume both
    functions work in O(1) time. Return the index of the array arr which has
    the largest integer.

    Follow-up:
    * What if there are two numbers in arr that are bigger than all other
      numbers?
    * What if there is one number that is bigger than other numbers and one
      number that is smaller than other numbers?

    Example 1:
    Input: arr = [7,7,7,7,10,7,7,7]
    Output: 4
    Explanation: The following calls to the API
    reader.compareSub(0, 0, 1, 1) // returns 0 this is a query comparing the
                                  // sub-array (0, 0) with the sub array (1, 1),
                                  // (i.e. compares arr[0] with arr[1]).
    Thus we know that arr[0] and arr[1] doesn't contain the largest element.
    reader.compareSub(2, 2, 3, 3) // returns 0, we can exclude arr[2] and arr[3].
    reader.compareSub(4, 4, 5, 5) // returns 1, thus for sure arr[4] is the
                                  // largest element in the array.
    Notice that we made only 3 calls, so the answer is valid.

    Example 2:
    Input: nums = [6,6,12]
    Output: 2

    Constraints:
    * 2 <= arr.length <= 5 * 10^5
    * 1 <= arr[i] <= 100
    * All elements of arr are equal except for one element which is larger than
      all other elements."""

    def getIndex(self, reader: 'ArrayReader') -> int:
        lo, hi = 0, reader.length()-1
        while lo <= hi:
            mid = lo + hi >> 1
            if (hi - lo) & 1:
                res = reader.compareSub(lo, mid, mid+1, hi)
                if res == 1: hi = mid
                else: lo = mid + 1
            else:
                res = reader.compareSub(lo, mid, mid, hi)
                if res == 1: hi = mid-1
                elif res == 0: return mid
                else: lo = mid+1


    """1538. Guess the Majority in a Hidden Array (Medium)
    We have an integer array nums, where all the integers in nums are 0 or 1.
    You will not be given direct access to the array, instead, you will have an
    API ArrayReader which have the following functions:
    * int query(int a, int b, int c, int d): where
      0 <= a < b < c < d < ArrayReader.length(). The function returns the
      distribution of the value of the 4 elements and returns:
      + 4 : if the values of the 4 elements are the same (0 or 1).
      + 2 : if three elements have a value equal to 0 and one element has value
            equal to 1 or vice versa.
      + 0 : if two element have a value equal to 0 and two elements have a
            value equal to 1.
    * int length(): Returns the size of the array.
    You are allowed to call query() 2 * n times at most where n is equal to
    ArrayReader.length(). Return any index of the most frequent value in nums,
    in case of tie, return -1.

    Example 1:
    Input: nums = [0,0,1,0,1,1,1,1]
    Output: 5
    Explanation: The following calls to the API
                 reader.length() // returns 8 because there are 8 elements in
                                 // the hidden array.
                 reader.query(0,1,2,3) // returns 2 this is a query that
                                       // compares the elements nums[0],
                                       // nums[1], nums[2], nums[3]
                                       // Three elements have a value equal to 0
                                       // and one element has value equal to 1
                                       // or viceversa.
                 reader.query(4,5,6,7) // returns 4 because nums[4], nums[5],
                                       // nums[6], nums[7] have the same value.
                 we can infer that the most frequent value is found in the last
                 4 elements. Index 2, 4, 6, 7 is also a correct answer.

    Example 2:
    Input: nums = [0,0,1,1,0]
    Output: 0

    Example 3:
    Input: nums = [1,0,1,0,1,0,1,0]
    Output: -1

    Constraints:
    * 5 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1

    Follow up: What is the minimum number of calls needed to find the majority
               element?"""

    def guessMajority(self, reader: 'ArrayReader') -> int:
        freq = [0, 0]
        idx = [-1, -1]
        for i in range(3, reader.length()):
            k = reader.query(0, 1, 2, i) == reader.query(0, 1, 2, 3)
            freq[k] += 1
            idx[k] = i
        for i in range(3):
            args = [x for x in range(5) if x != i]
            k = reader.query(*args) == reader.query(0, 1, 2, 4)
            freq[k] += 1
            idx[k] = i
        return idx[0] if freq[0] > freq[1] else (idx[1] if freq[0] < freq[1] else -1)


    """1539. Kth Missing Positive Number (Easy)
    Given an array arr of positive integers sorted in a strictly increasing
    order, and an integer k. Return the kth positive integer that is missing
    from this array.

    Example 1:
    Input: arr = [2,3,4,7,11], k = 5
    Output: 9
    Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...].
                 The 5th missing positive integer is 9.

    Example 2:
    Input: arr = [1,2,3,4], k = 2
    Output: 6
    Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing
                 positive integer is 6.

    Constraints:
    * 1 <= arr.length <= 1000
    * 1 <= arr[i] <= 1000
    * 1 <= k <= 1000
    * arr[i] < arr[j] for 1 <= i < j <= arr.length

    Follow up: Could you solve this problem in less than O(n) complexity?"""

    def findKthPositive(self, arr: List[int], k: int) -> int:
        lo, hi = 0, len(arr)
        while lo < hi:
            mid = (lo + hi)//2
            if arr[mid] - (mid + 1) < k: lo = mid + 1
            else: hi = mid
        return lo + k


    """1544. Make The String Great (Easy)
    Given a string s of lower and upper case English letters. A good string is a
    string which doesn't have two adjacent characters s[i] and s[i + 1] where:
    * 0 <= i <= s.length - 2
    * s[i] is a lower-case letter and s[i + 1] is the same letter but in
      upper-case or vice-versa.
    To make the string good, you can choose two adjacent characters that make
    the string bad and remove them. You can keep doing this until the string
    becomes good. Return the string after making it good. The answer is
    guaranteed to be unique under the given constraints. Notice that an empty
    string is also good.

    Example 1:
    Input: s = "leEeetcode"
    Output: "leetcode"
    Explanation: In the first step, either you choose i = 1 or i = 2, both will
                 result "leEeetcode" to be reduced to "leetcode".

    Example 2:
    Input: s = "abBAcC"
    Output: ""
    Explanation: We have many possible scenarios, and all lead to the same
                 answer. For example:
                 "abBAcC" --> "aAcC" --> "cC" --> ""
                 "abBAcC" --> "abBA" --> "aA" --> ""

    Example 3:
    Input: s = "s"
    Output: "s"

    Constraints:
    * 1 <= s.length <= 100
    * s contains only lower and upper case English letters."""

    def makeGood(self, s: str) -> str:
        stack = []
        for c in s:
            if stack and ord(stack[-1]) ^ ord(c) == 32: stack.pop() #pop "bad"
            else: stack.append(c) #push "good"
        return "".join(stack)


    """1548. The Most Similar Path in a Graph (Hard)
    We have n cities and m bi-directional roads where roads[i] = [ai, bi]
    connects city ai with city bi. Each city has a name consisting of exactly
    three upper-case English letters given in the string array names. Starting
    at any city x, you can reach any city y where y != x (i.e., the cities and
    the roads are forming an undirected connected graph). You will be given a
    string array targetPath. You should find a path in the graph of the same
    length and with the minimum edit distance to targetPath. You need to return
    the order of the nodes in the path with the minimum edit distance. The path
    should be of the same length of targetPath and should be valid (i.e., there
    should be a direct road between ans[i] and ans[i + 1]). If there are
    multiple answers return any one of them.

    Example 1:
    Input: n = 5, roads = [[0,2],[0,3],[1,2],[1,3],[1,4],[2,4]], names = ["ATL","PEK","LAX","DXB","HND"], targetPath = ["ATL","DXB","HND","LAX"]
    Output: [0,2,4,2]
    Explanation: [0,2,4,2], [0,3,0,2] and [0,3,1,2] are accepted answers.
                 [0,2,4,2] is equivalent to ["ATL","LAX","HND","LAX"] which has
                           edit distance = 1 with targetPath.
                 [0,3,0,2] is equivalent to ["ATL","DXB","ATL","LAX"] which has
                           edit distance = 1 with targetPath.
                 [0,3,1,2] is equivalent to ["ATL","DXB","PEK","LAX"] which has
                           edit distance = 1 with targetPath.

    Example 2:
    Input: n = 4, roads = [[1,0],[2,0],[3,0],[2,1],[3,1],[3,2]], names = ["ATL","PEK","LAX","DXB"], targetPath = ["ABC","DEF","GHI","JKL","MNO","PQR","STU","VWX"]
    Output: [0,1,0,1,0,1,0,1]
    Explanation: Any path in this graph has edit distance = 8 with targetPath.

    Example 3:
    Input: n = 6, roads = [[0,1],[1,2],[2,3],[3,4],[4,5]], names = ["ATL","PEK","LAX","ATL","DXB","HND"], targetPath = ["ATL","DXB","HND","DXB","ATL","LAX","PEK"]
    Output: [3,4,5,4,3,2,1]
    Explanation: [3,4,5,4,3,2,1] is the only path with edit distance = 0 with
                 targetPath. It's equivalent to
                 ["ATL","DXB","HND","DXB","ATL","LAX","PEK"]

    Constraints:
    * 2 <= n <= 100
    * m == roads.length
    * n - 1 <= m <= (n * (n - 1) / 2)
    * 0 <= ai, bi <= n - 1
    * ai != bi
    * The graph is guaranteed to be connected and each pair of nodes may have
      at most one direct road.
    * names.length == n
    * names[i].length == 3
    * names[i] consists of upper-case English letters.
    * There can be two cities with the same name.
    * 1 <= targetPath.length <= 100
    * targetPath[i].length == 3
    * targetPath[i] consists of upper-case English letters.

    Follow up: If each node can be visited only once in the path, What should
               you change in your solution?"""

    def mostSimilar(self, n: int, roads: List[List[int]], names: List[str], targetPath: List[str]) -> List[int]:
        graph = [[] for _ in range(n)]
        for u, v in roads:
            graph[u].append(v)
            graph[v].append(u)
        m = len(targetPath)
        mp = [[-1] * n for _ in range(m)]
        dp = [[inf] * n for _ in range(m+1)]
        for j in range(n): dp[m][j] = 0
        for i in range(m-1, -1, -1):
            for j in range(n):
                for k in graph[j]:
                    if dp[i+1][k] < dp[i][j]:
                        dp[i][j] = dp[i+1][k]
                        mp[i][j] = k
                if targetPath[i] != names[j]: dp[i][j] += 1
        jj, vv = -1, inf
        for j in range(n):
            if dp[0][j] < vv: jj, vv = j, dp[0][j]
        ans = []
        for i in range(m):
            ans.append(jj)
            jj = mp[i][jj]
        return ans


    """1550. Three Consecutive Odds (Easy)
    Given an integer array arr, return true if there are three consecutive odd
    numbers in the array. Otherwise, return false.

    Example 1:
    Input: arr = [2,6,4,1]
    Output: false
    Explanation: There are no three consecutive odds.

    Example 2:
    Input: arr = [1,2,34,3,4,5,7,23,12]
    Output: true
    Explanation: [5,7,23] are three consecutive odds.

    Constraints:
    * 1 <= arr.length <= 1000
    * 1 <= arr[i] <= 1000"""

    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        cnt = 0
        for x in arr:
            if x & 1: cnt += 1
            else: cnt = 0
            if cnt == 3: return True
        return False


    """1552. Magnetic Force Between Two Balls (Medium)
    In the universe Earth C-137, Rick discovered a special form of magnetic
    force between two balls if they are put in his new invented basket. Rick has
    n empty baskets, the ith basket is at position[i], Morty has m balls and
    needs to distribute the balls into the baskets such that the minimum
    magnetic force between any two balls is maximum. Rick stated that magnetic
    force between two different balls at positions x and y is |x - y|. Given the
    integer array position and the integer m. Return the required force.

    Example 1:
    Input: position = [1,2,3,4,7], m = 3
    Output: 3
    Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the
                 magnetic force between ball pairs [3, 3, 6]. The minimum
                 magnetic force is 3. We cannot achieve a larger minimum
                 magnetic force than 3.

    Example 2:
    Input: position = [5,4,3,2,1,1000000000], m = 2
    Output: 999999999
    Explanation: We can use baskets 1 and 1000000000.

    Constraints:
    * n == position.length
    * 2 <= n <= 10^5
    * 1 <= position[i] <= 10^9
    * All integers in position are distinct.
    * 2 <= m <= position.length"""

    def maxDistance(self, position: List[int], m: int) -> int:
        position.sort()
        lo, hi = 1, position[-1] - position[0]
        while lo < hi:
            mid = lo + hi + 1 >> 1
            cnt = 0
            prev = -inf
            for x in position:
                if x - prev >= mid:
                    cnt += 1
                    prev = x
            if cnt >= m: lo = mid
            else: hi = mid - 1
        return lo


    """1554. Strings Differ by One Character (Medium)
    Given a list of strings dict where all the strings are of the same length.
    Return True if there are 2 strings that only differ by 1 character in the
    same index, otherwise return False.

    Follow up: Could you solve this problem in O(n*m) where n is the length of
               dict and m is the length of each string.

    Example 1:
    Input: dict = ["abcd","acbd", "aacd"]
    Output: true
    Explanation: Strings "abcd" and "aacd" differ only by one character in the
                 index 1.

    Example 2:
    Input: dict = ["ab","cd","yz"]
    Output: false

    Example 3:
    Input: dict = ["abcd","cccc","abyd","abab"]
    Output: true

    Constraints:
    * Number of characters in dict <= 10^5
    * dict[i].length == dict[j].length
    * dict[i] should be unique.
    * dict[i] contains only lowercase English letters."""

    def differByOne(self, dict: List[str]) -> bool:
        MOD = 1_000_000_007
        hs = []
        for word in dict:
            val = 0
            for ch in word: val = (26*val + ord(ch) - 97) % MOD
            hs.append(val)

        mult = 1
        for j in reversed(range(len(dict[0]))):
            seen = {}
            for i, w in enumerate(dict):
                val = (hs[i] - (ord(w[j]) - 97) * mult) % MOD
                if val in seen:
                    for ww in seen[val]:
                        if sum(x != xx for x, xx in zip(w, ww)) == 1: return True
                seen.setdefault(val, []).append(w)
            mult = 26 * mult % MOD
        return False


    """1557. Minimum Number of Vertices to Reach All Nodes (Medium)
    Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and
    an array edges where edges[i] = [fromi, toi] represents a directed edge
    from node fromi to node toi. Find the smallest set of vertices from which
    all nodes in the graph are reachable. It's guaranteed that a unique
    solution exists. Notice that you can return the vertices in any order.

    Example 1:
    Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
    Output: [0,3]
    Explanation: It's not possible to reach all the nodes from a single vertex.
                 From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5].
                 So we output [0,3].

    Example 2:
    Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]
    Output: [0,2,3]
    Explanation: Notice that vertices 0, 3 and 2 are not reachable from any
                 other node, so we must include them. Also any of these
                 vertices can reach nodes 1 and 4.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= edges.length <= min(10^5, n * (n - 1) / 2)
    * edges[i].length == 2
    * 0 <= fromi, toi < n
    * All pairs (fromi, toi) are distinct."""

    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        indeg = [0]*n
        for _, v in edges: indeg[v] += 1
        return [i for i, x in enumerate(indeg) if x == 0]


    """1564. Put Boxes Into the Warehouse I (Medium)
    You are given two arrays of positive integers, boxes and warehouse,
    representing the heights of some boxes of unit width and the heights of n
    rooms in a warehouse respectively. The warehouse's rooms are labelled from
    0 to n - 1 from left to right where warehouse[i] (0-indexed) is the height
    of the ith room. Boxes are put into the warehouse by the following rules:
    * Boxes cannot be stacked.
    * You can rearrange the insertion order of the boxes.
    * Boxes can only be pushed into the warehouse from left to right only.
    * If the height of some room in the warehouse is less than the height of a
      box, then that box and all other boxes behind it will be stopped before
      that room.
    Return the maximum number of boxes you can put into the warehouse.

    Example 1:
    Input: boxes = [4,3,4,1], warehouse = [5,3,3,4,1]
    Output: 3
    Explanation: We can first put the box of height 1 in room 4. Then we can
                 put the box of height 3 in either of the 3 rooms 1, 2, or 3.
                 Lastly, we can put one box of height 4 in room 0. There is no
                 way we can fit all 4 boxes in the warehouse.

    Example 2:
    Input: boxes = [1,2,2,3,4], warehouse = [3,4,1,2]
    Output: 3
    Explanation: Notice that it's not possible to put the box of height 4 into
                 the warehouse since it cannot pass the first room of height 3.
                 Also, for the last two rooms, 2 and 3, only boxes of height 1
                 can fit. We can fit 3 boxes maximum as shown above. The yellow
                 box can also be put in room 2 instead. Swapping the orange and
                 green boxes is also valid, or swapping one of them with the
                 red box.

    Example 3:
    Input: boxes = [1,2,3], warehouse = [1,2,3,4]
    Output: 1
    Explanation: Since the first room in the warehouse is of height 1, we can only put boxes of height 1.

    Example 4:
    Input: boxes = [4,5,6], warehouse = [3,3,3,3,3]
    Output: 0

    Constraints:
    * n == warehouse.length
    * 1 <= boxes.length, warehouse.length <= 10^5
    * 1 <= boxes[i], warehouse[i] <= 10^9"""

    def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -> int:
        k = 0
        for box in sorted(boxes, reverse=True):
            if k < len(warehouse) and box <= warehouse[k]:
                k += 1
        return k


    """1567. Maximum Length of Subarray With Positive Product (Medium)
    Given an array of integers nums, find the maximum length of a subarray
    where the product of all its elements is positive. A subarray of an array
    is a consecutive sequence of zero or more values taken out of that array.
    Return the maximum length of a subarray with positive product.

    Example 1:
    Input: nums = [1,-2,-3,4]
    Output: 4
    Explanation: The array nums already has a positive product of 24.

    Example 2:
    Input: nums = [0,1,-2,-3,-4]
    Output: 3
    Explanation: The longest subarray with positive product is [1,-2,-3] which
                 has a product of 6. Notice that we cannot include 0 in the
                 subarray since that'll make the product 0 which is not
                 positive.

    Example 3:
    Input: nums = [-1,-2,-3,0,1]
    Output: 2
    Explanation: The longest subarray with positive product is [-1,-2] or
                 [-2,-3].

    Example 4:
    Input: nums = [-1,2]
    Output: 1

    Example 5:
    Input: nums = [1,2,3,5,-6,4,0,10]
    Output: 4

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9"""

    def getMaxLen(self, nums: List[int]) -> int:
        ans = pos = neg = 0
        for x in nums:
            if x > 0: pos, neg = 1 + pos, 1 + neg if neg else 0
            elif x < 0: pos, neg = 1 + neg if neg else 0, 1 + pos
            else: pos = neg = 0 # reset
            ans = max(ans, pos)
        return ans


    """1568. Minimum Number of Days to Disconnect Island (Hard)
    You are given an m x n binary grid grid where 1 represents land and 0
    represents water. An island is a maximal 4-directionally (horizontal or
    vertical) connected group of 1's. The grid is said to be connected if we
    have exactly one island, otherwise is said disconnected. In one day, we are
    allowed to change any single land cell (1) into a water cell (0). Return the
    minimum number of days to disconnect the grid.

    Example 1:
    Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
    Output: 2
    Explanation: We need at least 2 days to get a disconnected grid. Change land
                 grid[1][1] and grid[0][2] to water and get 2 disconnected
                 island.

    Example 2:
    Input: grid = [[1,1]]
    Output: 2
    Explanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0
                 islands.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 30
    * grid[i][j] is either 0 or 1."""

    def minDays(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        def fn(grid):
            """Return number of connected components."""
            ans = 0
            seen = set()
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == 1 and (i, j) not in seen:
                        ans += 1
                        seen.add((i, j))
                        stack = [(i, j)]
                        while stack:
                            i, j = stack.pop()
                            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == 1 and (ii, jj) not in seen:
                                    seen.add((ii, jj))
                                    stack.append((ii, jj))
            return ans

        if fn(grid) != 1: return 0
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    grid[i][j] = 0
                    if fn(grid) != 1: return 1
                    grid[i][j] = 1
        return 2


    """1580. Put Boxes Into the Warehouse II (Medium)
    You are given two arrays of positive integers, boxes and warehouse,
    representing the heights of some boxes of unit width and the heights of n
    rooms in a warehouse respectively. The warehouse's rooms are labeled from
    0 to n - 1 from left to right where warehouse[i] (0-indexed) is the height
    of the ith room. Boxes are put into the warehouse by the following rules:
    * Boxes cannot be stacked.
    * You can rearrange the insertion order of the boxes.
    * Boxes can be pushed into the warehouse from either side (left or right)
    * If the height of some room in the warehouse is less than the height of a
      box, then that box and all other boxes behind it will be stopped before
      that room.
    Return the maximum number of boxes you can put into the warehouse.

    Example 1:
    Input: boxes = [1,2,2,3,4], warehouse = [3,4,1,2]
    Output: 4
    Explanation:
    We can store the boxes in the following order:
    1- Put the yellow box in room 2 from either the left or right side.
    2- Put the orange box in room 3 from the right side.
    3- Put the green box in room 1 from the left side.
    4- Put the red box in room 0 from the left side.
    Notice that there are other valid ways to put 4 boxes such as swapping the
    red and green boxes or the red and orange boxes.

    Example 2:
    Input: boxes = [3,5,5,2], warehouse = [2,1,3,4,5]
    Output: 3
    Explanation: It's not possible to put the two boxes of height 5 in the
                 warehouse since there's only 1 room of height >= 5. Other
                 valid solutions are to put the green box in room 2 or to put
                 the orange box first in room 2 before putting the green and
                 red boxes.

    Example 3:
    Input: boxes = [1,2,3], warehouse = [1,2,3,4]
    Output: 3

    Example 4:
    Input: boxes = [4,5,6], warehouse = [3,3,3,3,3]
    Output: 0

    Constraints:
    * n == warehouse.length
    * 1 <= boxes.length, warehouse.length <= 10^5
    * 1 <= boxes[i], warehouse[i] <= 10^9"""

    def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -> int:
        ans = lo = 0
        hi = len(warehouse) - 1
        for box in sorted(boxes, reverse=True):
            if lo <= hi:
                if box <= warehouse[lo]:
                    ans += 1
                    lo += 1
                elif box <= warehouse[hi]:
                    ans += 1
                    hi -= 1
        return ans


    """1588. Sum of All Odd Length Subarrays (Easy)
    Given an array of positive integers arr, calculate the sum of all possible
    odd-length subarrays. A subarray is a contiguous subsequence of the array.
    Return the sum of all odd-length subarrays of arr.

    Example 1:
    Input: arr = [1,4,2,5,3]
    Output: 58
    Explanation: The odd-length subarrays of arr and their sums are:
    [1] = 1
    [4] = 4
    [2] = 2
    [5] = 5
    [3] = 3
    [1,4,2] = 7
    [4,2,5] = 11
    [2,5,3] = 10
    [1,4,2,5,3] = 15
    If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58

    Example 2:
    Input: arr = [1,2]
    Output: 3
    Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.

    Example 3:
    Input: arr = [10,11,12]
    Output: 66

    Constraints:
    * 1 <= arr.length <= 100
    * 1 <= arr[i] <= 1000"""

    def sumOddLengthSubarrays(self, arr: List[int]) -> int:
        return sum(((i+1)*(len(arr)-i) + 1)//2 * x for i, x in enumerate(arr))


    """1589. Maximum Sum Obtained of Any Permutation (Medium)
    We have an array of integers, nums, and an array of requests where
    requests[i] = [starti, endi]. The ith request asks for the sum of
    nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. Both
    starti and endi are 0-indexed. Return the maximum total sum of all requests
    among all permutations of nums. Since the answer may be too large, return
    it modulo 10^9 + 7.

    Example 1:
    Input: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]
    Output: 19
    Explanation: One permutation of nums is [2,1,3,4,5] with the following result:
    requests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8
    requests[1] -> nums[0] + nums[1] = 2 + 1 = 3
    Total sum: 8 + 3 = 11.
    A permutation with a higher total sum is [3,5,4,2,1] with the following result:
    requests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11
    requests[1] -> nums[0] + nums[1] = 3 + 5  = 8
    Total sum: 11 + 8 = 19, which is the best that you can do.

    Example 2:
    Input: nums = [1,2,3,4,5,6], requests = [[0,1]]
    Output: 11
    Explanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].

    Example 3:
    Input: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]
    Output: 47
    Explanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 0 <= nums[i] <= 10^5
    * 1 <= requests.length <= 10^5
    * requests[i].length == 2
    * 0 <= starti <= endi < n"""

    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:
        chg = [0]*len(nums) # change
        for i, j in requests:
            chg[i] += 1
            if j+1 < len(nums): chg[j+1] -= 1
        for i in range(1, len(nums)): chg[i] += chg[i-1] # cumulated change
        return sum(n*c for n, c in zip(sorted(nums), sorted(chg))) % 1_000_000_007


    """1590. Make Sum Divisible by P (Medium)
    Given an array of positive integers nums, remove the smallest subarray
    (possibly empty) such that the sum of the remaining elements is divisible
    by p. It is not allowed to remove the whole array. Return the length of the
    smallest subarray that you need to remove, or -1 if it's impossible. A
    subarray is defined as a contiguous block of elements in the array.

    Example 1:
    Input: nums = [3,1,4,2], p = 6
    Output: 1
    Explanation: The sum of the elements in nums is 10, which is not divisible
                 by 6. We can remove the subarray [4], and the sum of the
                 remaining elements is 6, which is divisible by 6.

    Example 2:
    Input: nums = [6,3,5,2], p = 9
    Output: 2
    Explanation: We cannot remove a single element to get a sum divisible by 9.
                 The best way is to remove the subarray [5,2], leaving us with
                 [6,3] with sum 9.

    Example 3:
    Input: nums = [1,2,3], p = 3
    Output: 0
    Explanation: Here the sum is 6. which is already divisible by 3. Thus we do
                 not need to remove anything.

    Example 4:
    Input: nums = [1,2,3], p = 7
    Output: -1
    Explanation: There is no way to remove a subarray in order to get a sum
                 divisible by 7.

    Example 5:
    Input: nums = [1000000000,1000000000,1000000000], p = 3
    Output: 0

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= p <= 10^9"""

    def minSubarray(self, nums: List[int], p: int) -> int:
        target = sum(nums) % p # targetted remainder
        ans = inf
        seen = {(prefix := 0): -1}
        for i, x in enumerate(nums):
            seen[(prefix := (prefix+x)%p)] = i # update seen before check
            if (prefix-target) % p in seen:
                ans = min(ans, i - seen[(prefix-target) % p])
        return ans if ans < len(nums) else -1 # not allowed to remove whole array


    """1591. Strange Printer II (Hard)
    There is a strange printer with the following two special requirements:
    1) On each turn, the printer will print a solid rectangular pattern of a
       single color on the grid. This will cover up the existing colors in the
       rectangle.
    2) Once the printer has used a color for the above operation, the same
       color cannot be used again.

    You are given a m x n matrix targetGrid, where targetGrid[row][col] is the
    color in the position (row, col) of the grid. Return true if it is possible
    to print the matrix targetGrid, otherwise, return false.

    Example 1:
    Input: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
    Output: true

    Example 2:
    Input: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]
    Output: true

    Example 3:
    Input: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]
    Output: false
    Explanation: It is impossible to form targetGrid because it is not allowed
                 to print the same color in different turns.

    Example 4:
    Input: targetGrid = [[1,1,1],[3,1,3]]
    Output: false

    Constraints:
    * m == targetGrid.length
    * n == targetGrid[i].length
    * 1 <= m, n <= 60
    * 1 <= targetGrid[row][col] <= 60"""

    def isPrintable(self, targetGrid: List[List[int]]) -> bool:
        m, n = len(targetGrid), len(targetGrid[0]) # dimensions

        # build directed graph (adjacency list)
        digraph = {}
        for c in range(1, 61):
            imn = jmn = 60
            imx = jmx = 0
            for i in range(m):
                for j in range(n):
                    if targetGrid[i][j] == c:
                        imn = min(imn, i)
                        imx = max(imx, i)
                        jmn = min(jmn, j)
                        jmx = max(jmx, j)
            for i in range(imn, imx+1):
                for j in range(jmn, jmx+1):
                    if targetGrid[i][j] != c:
                        digraph.setdefault(c, set()).add(targetGrid[i][j])

        # check for cycle in digraph (tri-color)
        def dfs(n):
            """Return True if a cycle is detected."""
            if seen[n]: return seen[n] == 1
            seen[n] = 1
            if any(dfs(nn) for nn in digraph.get(n, set())): return True
            seen[n] = 2
            return False

        seen = [0]*61
        return not any(dfs(i) for i in range(61)) # cycle, i.e. impossible to print


    """1592. Rearrange Spaces Between Words (Easy)
    You are given a string text of words that are placed among some number of
    spaces. Each word consists of one or more lowercase English letters and are
    separated by at least one space. It's guaranteed that text contains at
    least one word. Rearrange the spaces so that there is an equal number of
    spaces between every pair of adjacent words and that number is maximized.
    If you cannot redistribute all the spaces equally, place the extra spaces
    at the end, meaning the returned string should be the same length as text.
    Return the string after rearranging the spaces.

    Example 1:
    Input: text = "  this   is  a sentence "
    Output: "this   is   a   sentence"
    Explanation: There are a total of 9 spaces and 4 words. We can evenly
                 divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.

    Example 2:
    Input: text = " practice   makes   perfect"
    Output: "practice   makes   perfect "
    Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3
                 spaces plus 1 extra space. We place this extra space at the
                 end of the string.

    Example 3:
    Input: text = "hello   world"
    Output: "hello   world"

    Example 4:
    Input: text = "  walks  udp package   into  bar a"
    Output: "walks  udp  package  into  bar  a "

    Example 5:
    Input: text = "a"
    Output: "a"

    Constraints:
    * 1 <= text.length <= 100
    * text consists of lowercase English letters and ' '.
    * text contains at least one word."""

    def reorderSpaces(self, text: str) -> str:
        ns = text.count(" ") # count of spaces
        nw = len(text := text.split()) # count of words
        if nw > 1: nw, ns = divmod(ns, nw-1) # nw - between word spaces / ns - trailing spaces
        return (" "*nw).join(text) + " "*ns


    """1593. Split a String Into the Max Number of Unique Substrings (Medium)
    Given a string s, return the maximum number of unique substrings that the
    given string can be split into. You can split string s into any list of
    non-empty substrings, where the concatenation of the substrings forms the
    original string. However, you must split the substrings such that all of
    them are unique. A substring is a contiguous sequence of characters within
    a string.

    Example 1:
    Input: s = "ababccc"
    Output: 5
    Explanation: One way to split maximally is ['a', 'b', 'ab', 'c', 'cc'].
                 Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as
                 you have 'a' and 'b' multiple times.

    Example 2:
    Input: s = "aba"
    Output: 2
    Explanation: One way to split maximally is ['a', 'ba'].

    Example 3:
    Input: s = "aa"
    Output: 1
    Explanation: It is impossible to split the string any further.

    Constraints:
    * 1 <= s.length <= 16
    * s contains only lower case English letters."""

    def maxUniqueSplit(self, s: str) -> int:

        def fn(i, seen=set()):
            """Find max length via backtracking (not dp)."""
            ans = 0
            if i < len(s): # boundary condition when i == len(s)
                for ii in range(i+1, len(s)+1):
                    if s[i:ii] not in seen:
                        seen.add(s[i:ii])
                        ans = max(ans, 1 + fn(ii, seen))
                        seen.remove(s[i:ii])
            return ans

        return fn(0)


    """1594. Maximum Non Negative Product in a Matrix (Medium)
    You are given a rows x cols matrix grid. Initially, you are located at the
    top-left corner (0, 0), and in each step, you can only move right or down
    in the matrix. Among all possible paths starting from the top-left corner
    (0, 0) and ending in the bottom-right corner (rows - 1, cols - 1), find the
    path with the maximum non-negative product. The product of a path is the
    product of all integers in the grid cells visited along the path. Return
    the maximum non-negative product modulo 10^9 + 7. If the maximum product is
    negative return -1. Notice that the modulo is performed after getting the
    maximum product.

    Example 1:
    Input: grid = [[-1,-2,-3],
                   [-2,-3,-3],
                   [-3,-3,-2]]
    Output: -1
    Explanation: It's not possible to get non-negative product in the path from
                 (0, 0) to (2, 2), so return -1.

    Example 2:
    Input: grid = [[1,-2,1],
                   [1,-2,1],
                   [3,-4,1]]
    Output: 8
    Explanation: Maximum non-negative product is in bold (1 * 1 * -2 * -4 * 1 = 8).

    Example 3:
    Input: grid = [[1, 3],
                   [0,-4]]
    Output: 0
    Explanation: Maximum non-negative product is in bold (1 * 0 * -4 = 0).

    Example 4:
    Input: grid = [[ 1, 4,4,0],
                   [-2, 0,0,1],
                   [ 1,-1,1,1]]
    Output: 2
    Explanation: Maximum non-negative product is in bold (1 * -2 * 1 * -1 * 1 * 1 = 2).

    Constraints:
    * 1 <= rows, cols <= 15
    * -4 <= grid[i][j] <= 4"""

    def maxProductPath(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        @cache
        def fn(i, j):
            """Return maximum & minimum products ending at (i, j)."""
            if i == 0 and j == 0: return grid[0][0], grid[0][0]
            if i < 0 or j < 0: return -inf, inf
            if grid[i][j] == 0: return 0, 0
            mx1, mn1 = fn(i-1, j) # from top
            mx2, mn2 = fn(i, j-1) # from left
            mx, mn = max(mx1, mx2)*grid[i][j], min(mn1, mn2)*grid[i][j]
            return (mx, mn) if grid[i][j] > 0 else (mn, mx)

        mx, _ = fn(m-1, n-1)
        return -1 if mx < 0 else mx % 1_000_000_007


    """1595. Minimum Cost to Connect Two Groups of Points (Hard)
    You are given two groups of points where the first group has size1 points,
    the second group has size2 points, and size1 >= size2. The cost of the
    connection between any two points are given in an size1 x size2 matrix
    where cost[i][j] is the cost of connecting point i of the first group and
    point j of the second group. The groups are connected if each point in both
    groups is connected to one or more points in the opposite group. In other
    words, each point in the first group must be connected to at least one
    point in the second group, and each point in the second group must be
    connected to at least one point in the first group. Return the minimum cost
    it takes to connect the two groups.

    Example 1:
    Input: cost = [[15, 96], [36, 2]]
    Output: 17
    Explanation: The optimal way of connecting the groups is:
    1--A
    2--B
    This results in a total cost of 17.

    Example 2:
    Input: cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
    Output: 4
    Explanation: The optimal way of connecting the groups is:
    1--A
    2--B
    2--C
    3--A
    This results in a total cost of 4.
    Note that there are multiple points connected to point 2 in the first group
    and point A in the second group. This does not matter as there is no limit
    to the number of points that can be connected. We only care about the
    minimum total cost.

    Example 3:
    Input: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
    Output: 10

    Constraints:
    * size1 == cost.length
    * size2 == cost[i].length
    * 1 <= size1, size2 <= 12
    * size1 >= size2
    * 0 <= cost[i][j] <= 100"""

    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        m, n = len(cost), len(cost[0])
        mn = [min(x) for x in zip(*cost)] # min cost of connecting points in 2nd group

        @cache
        def fn(i, mask):
            """Return min cost of connecting group1[i:] and group2 represented as mask."""
            if i == m: return sum(mn[j] for j in range(n) if not (mask & (1<<j)))
            return min(cost[i][j] + fn(i+1, mask | 1<<j) for j in range(n))

        return fn(0, 0)


    """1597. Build Binary Expression Tree From Infix Expression (Hard)
    A binary expression tree is a kind of binary tree used to represent
    arithmetic expressions. Each node of a binary expression tree has either
    zero or two children. Leaf nodes (nodes with 0 children) correspond to
    operands (numbers), and internal nodes (nodes with 2 children) correspond
    to the operators '+' (addition), '-' (subtraction), '*' (multiplication),
    and '/' (division). For each internal node with operator o, the infix
    expression it represents is (A o B), where A is the expression the left
    subtree represents and B is the expression the right subtree represents.
    You are given a string s, an infix expression containing operands, the
    operators described above, and parentheses '(' and ')'. Return any valid
    binary expression tree, whose in-order traversal reproduces s after
    omitting the parenthesis from it. Please note that order of operations
    applies in s. That is, expressions in parentheses are evaluated first, and
    multiplication and division happen before addition and subtraction.
    Operands must also appear in the same order in both s and the in-order
    traversal of the tree.

    Example 1:
    Input: s = "3*4-2*5"
    Output: [-,*,*,3,4,2,5]
    Explanation: The tree above is the only valid tree whose inorder traversal
                 produces s.

    Example 2:
    Input: s = "2-3/(5*2)+1"
    Output: [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2]
    Explanation: The inorder traversal of the tree above is 2-3/5*2+1 which is
                 the same as s without the parenthesis. The tree also produces
                 the correct result and its operands are in the same order as
                 they appear in s. The tree below is also a valid binary
                 expression tree with the same inorder traversal as s, but it
                 not a valid answer because it does not evaluate to the same
                 value. The third tree below is also not valid. Although it
                 produces the same result and is equivalent to the above trees,
                 its inorder traversal does not produce s and its operands are
                 not in the same order as s.

    Example 3:
    Input: s = "1+2+3+4+5"
    Output: [+,+,5,+,4,null,null,+,3,null,null,1,2]
    Explanation: The tree [+,+,5,+,+,null,null,1,2,3,4] is also one of many
                 other valid trees.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of digits and the characters '+', '-', '*', and '/'.
    * Operands in s are exactly 1 digit.
    * It is guaranteed that s is a valid expression."""

    def expTree(self, s: str) -> 'Node':
        s = f"({s})"
        precedence = {'(' : 0, ')' : 1, '+' : 1, '-' : 1, '*' : 2, '/' : 2}
        ops = []
        postfix = [] # postfix expression
        for ch in s:
            if ch.isdigit(): postfix.append(ch)
            elif ch == '(': ops.append(ch)
            else:
                while ops and precedence[ops[-1]] >= precedence[ch]: postfix.append(ops.pop())
                if ch == ')': ops.pop()
                else: ops.append(ch)
        stack = []
        for ch in postfix:
            node = Node(ch)
            if not ch.isdigit():
                node.right = stack.pop()
                node.left = stack.pop()
            stack.append(node)
        return stack.pop()


    """1598. Crawler Log Folder (Easy)
    The Leetcode file system keeps a log each time some user performs a change
    folder operation. The operations are described below:
    * "../" : Move to the parent folder of the current folder. (If you are
      already in the main folder, remain in the same folder).
    * "./" : Remain in the same folder.
    * "x/" : Move to the child folder named x (This folder is guaranteed to
      always exist).
    You are given a list of strings logs where logs[i] is the operation
    performed by the user at the ith step. The file system starts in the main
    folder, then the operations in logs are performed. Return the minimum number
    of operations needed to go back to the main folder after the change folder
    operations.

    Example 1:
    Input: logs = ["d1/","d2/","../","d21/","./"]
    Output: 2
    Explanation: Use this change folder operation "../" 2 times and go back to
                 the main folder.

    Example 2:
    Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
    Output: 3

    Example 3:
    Input: logs = ["d1/","../","../","../"]
    Output: 0

    Constraints:
    * 1 <= logs.length <= 10^3
    * 2 <= logs[i].length <= 10
    * logs[i] contains lowercase English letters, digits, '.', and '/'.
    * logs[i] follows the format described in the statement.
    * Folder names consist of lowercase English letters and digits."""

    def minOperations(self, logs: List[str]) -> int:
        ans = 0
        for log in logs:
            if log == "./": continue
            elif log == "../": ans = max(0, ans-1)
            else: ans += 1
        return ans


    """1602. Find Nearest Right Node in Binary Tree (Medium)
    Given the root of a binary tree and a node u in the tree, return the
    nearest node on the same level that is to the right of u, or return null
    if u is the rightmost node in its level.

    Example 1:
    Input: root = [1,2,3,null,4,5,6], u = 4
    Output: 5
    Explanation: The nearest node on the same level to the right of node 4 is
                 node 5.

    Example 2:
    Input: root = [3,null,4,2], u = 2
    Output: null
    Explanation: There are no nodes to the right of 2.

    Example 3:
    Input: root = [1], u = 1
    Output: null

    Example 4:
    Input: root = [3,4,2,null,null,null,1], u = 4
    Output: 2

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5
    * All values in the tree are distinct.
    * u is a node in the binary tree rooted at root."""

    def findNearestRightNode(self, root: TreeNode, u: TreeNode) -> TreeNode:
        queue = [root]
        while queue:
            prev = None
            newq = []
            for node in queue:
                if node == u: return prev
                prev = node
                if node.right: newq.append(node.right)
                if node.left: newq.append(node.left)
            queue = newq


    """1604. Alert Using Same Key-Card Three or More Times in a One Hour Period (Medium)
    LeetCode company workers use key-cards to unlock office doors. Each time a
    worker uses their key-card, the security system saves the worker's name and
    the time when it was used. The system emits an alert if any worker uses the
    key-card three or more times in a one-hour period. You are given a list of
    strings keyName and keyTime where [keyName[i], keyTime[i]] corresponds to a
    person's name and the time when their key-card was used in a single day.
    Access times are given in the 24-hour time format "HH:MM", such as "23:51"
    and "09:49". Return a list of unique worker names who received an alert for
    frequent keycard use. Sort the names in ascending order alphabetically.
    Notice that "10:00" - "11:00" is considered to be within a one-hour period,
    while "22:51" - "23:52" is not considered to be within a one-hour period.

    Example 1:
    Input: keyName = ["daniel","daniel","daniel","luis","luis","luis","luis"],
           keyTime = ["10:00","10:40","11:00","09:00","11:00","13:00","15:00"]
    Output: ["daniel"]
    Explanation: "daniel" used the keycard 3 times in a one-hour period ("10:00","10:40", "11:00").

    Example 2:
    Input: keyName = ["alice","alice","alice","bob","bob","bob","bob"],
           keyTime = ["12:01","12:00","18:00","21:00","21:20","21:30","23:00"]
    Output: ["bob"]
    Explanation: "bob" used the keycard 3 times in a one-hour period ("21:00","21:20", "21:30").

    Example 3:
    Input: keyName = ["john","john","john"], keyTime = ["23:58","23:59","00:01"]
    Output: []

    Example 4:
    Input: keyName = ["leslie","leslie","leslie","clare","clare","clare","clare"],
           keyTime = ["13:00","13:20","14:00","18:00","18:51","19:30","19:49"]
    Output: ["clare","leslie"]

    Constraints:
    * 1 <= keyName.length, keyTime.length <= 10^5
    * keyName.length == keyTime.length
    * keyTime[i] is in the format "HH:MM".
    * [keyName[i], keyTime[i]] is unique.
    * 1 <= keyName[i].length <= 10
    * keyName[i] contains only lowercase English letters."""

    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
        ans = set()
        seen = {}
        for key, time in sorted(zip(keyName, keyTime)):
            if key not in ans:
                h, m = time.split(":")
                time = int(h) * 60 + int(m)
                seen.setdefault(key, deque()).append(time)
                if len(seen[key]) == 3:
                    if seen[key][-1] <= seen[key][0] + 60: ans.add(key)
                    seen[key].popleft()
        return sorted(ans)


    """1605. Find Valid Matrix Given Row and Column Sums (Medium)
    You are given two arrays rowSum and colSum of non-negative integers where
    rowSum[i] is the sum of the elements in the ith row and colSum[j] is the
    sum of the elements of the jth column of a 2D matrix. In other words, you
    do not know the elements of the matrix, but you do know the sums of each
    row and column. Find any matrix of non-negative integers of size
    rowSum.length x colSum.length that satisfies the rowSum and colSum
    requirements. Return a 2D array representing any matrix that fulfills the
    requirements. It's guaranteed that at least one matrix that fulfills the
    requirements exists.

    Example 1:
    Input: rowSum = [3,8], colSum = [4,7]
    Output: [[3,0],
             [1,7]]
    Explanation:
    0th row: 3 + 0 = 3 == rowSum[0]
    1st row: 1 + 7 = 8 == rowSum[1]
    0th column: 3 + 1 = 4 == colSum[0]
    1st column: 0 + 7 = 7 == colSum[1]
    The row and column sums match, and all matrix elements are non-negative.
    Another possible matrix is: [[1,2],
                                 [3,5]]

    Example 2:
    Input: rowSum = [5,7,10], colSum = [8,6,8]
    Output: [[0,5,0],
             [6,1,0],
             [2,0,8]]

    Example 3:
    Input: rowSum = [14,9], colSum = [6,9,8]
    Output: [[0,9,5],
             [6,0,3]]

    Example 4:
    Input: rowSum = [1,0], colSum = [1]
    Output: [[1],
             [0]]

    Example 5:
    Input: rowSum = [0], colSum = [0]
    Output: [[0]]

    Constraints:
    * 1 <= rowSum.length, colSum.length <= 500
    * 0 <= rowSum[i], colSum[i] <= 10^8
    * sum(rows) == sum(columns)"""

    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
        m, n = len(rowSum), len(colSum) # dimensions
        ans = [[0]*n for _ in range(m)]

        i = j = 0
        while i < len(rowSum) and j < len(colSum):
            ans[i][j] = min(rowSum[i], colSum[j])
            rowSum[i] -= ans[i][j]
            colSum[j] -= ans[i][j]
            if rowSum[i] == 0: i += 1
            if colSum[j] == 0: j += 1
        return ans


    """1606. Find Servers That Handled Most Number of Requests (Hard)
    You have k servers numbered from 0 to k-1 that are being used to handle
    multiple requests simultaneously. Each server has infinite computational
    capacity but cannot handle more than one request at a time. The requests
    are assigned to servers according to a specific algorithm:
    * The ith (0-indexed) request arrives.
    * If all servers are busy, the request is dropped (not handled at all).
    * If the (i % k)th server is available, assign the request to that server.
    * Otherwise, assign the request to the next available server (wrapping
      around the list of servers and starting from 0 if necessary). For example,
      if the ith server is busy, try to assign the request to the (i+1)th
      server, then the (i+2)th server, and so on.
    You are given a strictly increasing array arrival of positive integers,
    where arrival[i] represents the arrival time of the ith request, and
    another array load, where load[i] represents the load of the ith request
    (the time it takes to complete). Your goal is to find the busiest server(s).
    A server is considered busiest if it handled the most number of requests
    successfully among all the servers. Return a list containing the IDs
    (0-indexed) of the busiest server(s). You may return the IDs in any order.

    Example 1:
    Input: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3]
    Output: [1]
    Explanation:
    All of the servers start out available.
    The first 3 requests are handled by the first 3 servers in order.
    Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.
    Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped.
    Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.

    Example 2:
    Input: k = 3, arrival = [1,2,3,4], load = [1,2,1,2]
    Output: [0]
    Explanation:
    The first 3 requests are handled by first 3 servers.
    Request 3 comes in. It is handled by server 0 since the server is available.
    Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.

    Example 3:
    Input: k = 3, arrival = [1,2,3], load = [10,12,11]
    Output: [0,1,2]
    Explanation: Each server handles a single request, so they are all considered the busiest.

    Example 4:
    Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]
    Output: [1]

    Example 5:
    Input: k = 1, arrival = [1], load = [1]
    Output: [0]

    Constraints:
    * 1 <= k <= 10^5
    * 1 <= arrival.length, load.length <= 10^5
    * arrival.length == load.length
    * 1 <= arrival[i], load[i] <= 10^9
    * arrival is strictly increasing."""

    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        busy = [] # min-heap
        free = list(range(k)) # min-heap
        freq = [0]*k

        for i, (ta, tl) in enumerate(zip(arrival, load)):
            while busy and busy[0][0] <= ta:
                _, ii = heappop(busy)
                heappush(free, i + (ii - i) % k) # circularly relocate it
            if free:
                ii = heappop(free) % k
                freq[ii] += 1
                heappush(busy, (ta+tl, ii))

        mx = max(freq)
        return [i for i, x in enumerate(freq) if x == mx]


    """1608. Special Array With X Elements Greater Than or Equal X (Easy)
    You are given an array nums of non-negative integers. nums is considered
    special if there exists a number x such that there are exactly x numbers in
    nums that are greater than or equal to x. Notice that x does not have to be
    an element in nums. Return x if the array is special, otherwise, return -1.
    It can be proven that if nums is special, the value for x is unique.

    Example 1:
    Input: nums = [3,5]
    Output: 2
    Explanation: There are 2 values (3 and 5) that are greater than or equal to 2.

    Example 2:
    Input: nums = [0,0]
    Output: -1
    Explanation: No numbers fit the criteria for x.
    If x = 0, there should be 0 numbers >= x, but there are 2.
    If x = 1, there should be 1 number >= x, but there are 0.
    If x = 2, there should be 2 numbers >= x, but there are 0.
    x cannot be greater since there are only 2 numbers in nums.

    Example 3:
    Input: nums = [0,4,3,0,4]
    Output: 3
    Explanation: There are 3 values that are greater than or equal to 3.

    Example 4:
    Input: nums = [3,6,7,7,0]
    Output: -1

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 1000"""

    def specialArray(self, nums: List[int]) -> int:
        nums.sort()
        if len(nums) <= nums[0]: return len(nums) # edge case
        for i in range(1, len(nums)):
            if nums[i-1] < len(nums)-i <= nums[i]: return len(nums)-i
        return -1


    """1609. Even Odd Tree (Medium)
    A binary tree is named Even-Odd if it meets the following conditions:
    * The root of the binary tree is at level index 0, its children are at
      level index 1, their children are at level index 2, etc.
    * For every even-indexed level, all nodes at the level have odd integer
      values in strictly increasing order (from left to right).
    * For every odd-indexed level, all nodes at the level have even integer
      values in strictly decreasing order (from left to right).
    Given the root of a binary tree, return true if the binary tree is Even-
    Odd, otherwise return false.

    Example 1:
    Input: root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
    Output: true
    Explanation: The node values on each level are:
    Level 0: [1]
    Level 1: [10,4]
    Level 2: [3,7,9]
    Level 3: [12,8,6,2]
    Since levels 0 and 2 are all odd and increasing, and levels 1 and 3 are all
    even and decreasing, the tree is Even-Odd.

    Example 2:
    Input: root = [5,4,2,3,3,7]
    Output: false
    Explanation: The node values on each level are:
    Level 0: [5]
    Level 1: [4,2]
    Level 2: [3,3,7]
    Node values in the level 2 must be in strictly increasing order, so the
    tree is not Even-Odd.

    Example 3:
    Input: root = [5,9,1,3,5,7]
    Output: false
    Explanation: Node values in the level 1 should be even integers.

    Example 4:
    Input: root = [1]
    Output: true

    Example 5:
    Input: root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]
    Output: true

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 10^6"""

    def isEvenOddTree(self, root: TreeNode) -> bool:
        level = 0
        queue = deque([root])
        while queue:
            prev = [-inf, inf][level]
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.val & 1 == level or not level and prev >= node.val or level and prev <= node.val: return False
                prev = node.val
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            level ^= 1
        return True


    """1610. Maximum Number of Visible Points (Hard)
    You are given an array points, an integer angle, and your location, where
    location = [posx, posy] and points[i] = [xi, yi] both denote integral
    coordinates on the X-Y plane. Initially, you are facing directly east from
    your position. You cannot move from your position, but you can rotate. In
    other words, posx and posy cannot be changed. Your field of view in degrees
    is represented by angle, determining how wide you can see from any given
    view direction. Let d be the amount in degrees that you rotate
    counterclockwise. Then, your field of view is the inclusive range of angles
    [d - angle/2, d + angle/2]. You can see some set of points if, for each
    point, the angle formed by the point, your position, and the immediate east
    direction from your position is in your field of view. There can be
    multiple points at one coordinate. There may be points at your location,
    and you can always see these points regardless of your rotation. Points do
    not obstruct your vision to other points. Return the maximum number of
    points you can see.

    Example 1:
    Input: points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]
    Output: 3
    Explanation: The shaded region represents your field of view. All points
                 can be made visible in your field of view, including [3,3]
                 even though [2,2] is in front and in the same line of sight.

    Example 2:
    Input: points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]
    Output: 4
    Explanation: All points can be made visible in your field of view,
                 including the one at your location.

    Example 3:
    Input: points = [[1,0],[2,1]], angle = 13, location = [1,1]
    Output: 1
    Explanation: You can only see one of the two points, as shown above.

    Constraints:
    * 1 <= points.length <= 10^5
    * points[i].length == 2
    * location.length == 2
    * 0 <= angle < 360
    * 0 <= posx, posy, xi, yi <= 10^9"""

    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:
        x0, y0 = location

        ans = ovlp = 0
        theta = []
        for x, y in points:
            if x == x0 and y == y0: ovlp += 1
            else: theta.append(atan2(y-y0, x-x0)) # (x, y) wrt (x0, y0)

        theta.sort()
        theta += [x+2*pi for x in theta]
        ii = 0
        for i in range(len(theta)):
            while theta[i] - theta[ii] > angle*pi/180: ii += 1
            ans = max(ans, i-ii+1)
        return ans + ovlp


    """1611. Minimum One Bit Operations to Make Integers Zero (Hard)
    Given an integer n, you must transform it into 0 using the following
    operations any number of times:
    * Change the rightmost (0th) bit in the binary representation of n.
    * Change the ith bit in the binary representation of n if the (i-1)th bit
      is set to 1 and the (i-2)th through 0th bits are set to 0.
    Return the minimum number of operations to transform n into 0.

    Example 1:
    Input: n = 0
    Output: 0

    Example 2:
    Input: n = 3
    Output: 2
    Explanation: The binary representation of 3 is "11".
    "11" -> "01" with the 2nd operation since the 0th bit is 1.
    "01" -> "00" with the 1st operation.

    Example 3:
    Input: n = 6
    Output: 4
    Explanation: The binary representation of 6 is "110".
    "110" -> "010" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.
    "010" -> "011" with the 1st operation.
    "011" -> "001" with the 2nd operation since the 0th bit is 1.
    "001" -> "000" with the 1st operation.

    Example 4:
    Input: n = 9
    Output: 14

    Example 5:
    Input: n = 333
    Output: 393

    Constraints: 0 <= n <= 10^9"""

    def minimumOneBitOperations(self, n: int) -> int:
        if not n: return 0 # edge case
        if not (n & (n-1)): return 2*n-1
        b = 1 << n.bit_length()-1 # most significant set bit
        return self.minimumOneBitOperations((b>>1)^b^n) + b


    """1612. Check If Two Expression Trees are Equivalent (Medium)
    A binary expression tree is a kind of binary tree used to represent
    arithmetic expressions. Each node of a binary expression tree has either
    zero or two children. Leaf nodes (nodes with 0 children) correspond to
    operands (variables), and internal nodes (nodes with two children)
    correspond to the operators. In this problem, we only consider the '+'
    operator (i.e. addition). You are given the roots of two binary expression
    trees, root1 and root2. Return true if the two binary expression trees are
    equivalent. Otherwise, return false. Two binary expression trees are
    equivalent if they evaluate to the same value regardless of what the
    variables are set to.

    Follow up: What will you change in your solution if the tree also supports
               the '-' operator (i.e. subtraction)?

    Example 1:
    Input: root1 = [x], root2 = [x]
    Output: true

    Example 2:
    Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c]
    Output: true
    Explaination: a + (b + c) == (b + c) + a

    Example 3:
    Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d]
    Output: false
    Explaination: a + (b + c) != (b + d) + a

    Constraints:
    * The number of nodes in both trees are equal, odd and, in the range [1, 4999].
    * Node.val is '+' or a lower-case English letter.
    * It's guaranteed that the tree given is a valid binary expression tree."""

    def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:
        freq = defaultdict(int)

        def fn(x, k):
            if not x: return
            freq[x.val] += k
            if freq[x.val] == 0: freq.pop(x.val)
            fn(x.left, k)
            fn(x.right, k)

        fn(root1, 1)
        fn(root2, -1)
        return not freq


    """1614. Maximum Nesting Depth of the Parentheses (Easy)
    A string is a valid parentheses string (denoted VPS) if it meets one of the
    following:
    * It is an empty string "", or a single character not equal to "(" or ")",
    * It can be written as AB (A concatenated with B), where A and B are VPS's,
      or
    * It can be written as (A), where A is a VPS.
    We can similarly define the nesting depth depth(S) of any VPS S as follows:
    * depth("") = 0
    * depth(C) = 0, where C is a string with a single character not equal to "("
      or ")".
    * depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
    * depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
    For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1,
    and 2), and ")(" and "(()" are not VPS's. Given a VPS represented as string
    s, return the nesting depth of s.

    Example 1:
    Input: s = "(1+(2*3)+((8)/4))+1"
    Output: 3
    Explanation: Digit 8 is inside of 3 nested parentheses in the string.

    Example 2:
    Input: s = "(1)+((2))+(((3)))"
    Output: 3

    Constraints:
    * 1 <= s.length <= 100
    * s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
    * It is guaranteed that parentheses expression s is a VPS."""

    def maxDepth(self, s: str) -> int:
        ans = val = 0
        for ch in s:
            if ch == '(':
                val += 1
                ans = max(ans, val)
            elif ch == ')': val -= 1
        return ans


    """1618. Maximum Font to Fit a Sentence in a Screen (Medium)
    You are given a string text. We want to display text on a screen of width w
    and height h. You can choose any font size from array fonts, which contains
    the available font sizes in ascending order. You can use the FontInfo
    interface to get the width and height of any character at any available
    font size.

    The FontInfo interface is defined as such:

    interface FontInfo {
      // Returns the width of character ch on the screen using font size fontSize.
      // O(1) per call
      public int getWidth(int fontSize, char ch);

      // Returns the height of any character on the screen using font size fontSize.
      // O(1) per call
      public int getHeight(int fontSize);
    }
    The calculated width of text for some fontSize is the sum of every
    getWidth(fontSize, text[i]) call for each 0 <= i < text.length (0-indexed).
    The calculated height of text for some fontSize is getHeight(fontSize).
    Note that text is displayed on a single line. It is guaranteed that
    FontInfo will return the same value if you call getHeight or getWidth with
    the same parameters. It is also guaranteed that for any font size fontSize
    and any character ch:
    * getHeight(fontSize) <= getHeight(fontSize+1)
    * getWidth(fontSize, ch) <= getWidth(fontSize+1, ch)
    Return the maximum font size you can use to display text on the screen. If
    text cannot fit on the display with any font size, return -1.

    Example 1:
    Input: text = "helloworld", w = 80, h = 20, fonts = [6,8,10,12,14,16,18,24,36]
    Output: 6

    Example 2:
    Input: text = "leetcode", w = 1000, h = 50, fonts = [1,2,4]
    Output: 4

    Example 3:
    Input: text = "easyquestion", w = 100, h = 100, fonts = [10,15,20,25]
    Output: -1

    Constraints:
    * 1 <= text.length <= 50000
    * text contains only lowercase English letters.
    * 1 <= w <= 10^7
    * 1 <= h <= 10^4
    * 1 <= fonts.length <= 10^5
    * 1 <= fonts[i] <= 10^5
    * fonts is sorted in ascending order and does not contain duplicates."""

    def maxFont(self, text: str, w: int, h: int, fonts: List[int], fontInfo : 'FontInfo') -> int:
        # last True binary search
        lo, hi = -1, len(fonts)-1
        while lo < hi:
            mid = lo + hi + 1 >> 1
            hh = fontInfo.getHeight(fonts[mid])
            ww = sum(fontInfo.getWidth(fonts[mid], c) for c in text)
            if hh <= h and ww <= w : lo = mid
            else: hi = mid - 1
        return fonts[lo] if lo >= 0 else -1


    """1619. Mean of Array After Removing Some Elements (Easy)
    Given an integer array arr, return the mean of the remaining integers after
    removing the smallest 5% and the largest 5% of the elements. Answers within
    10-5 of the actual answer will be considered accepted.

    Example 1:
    Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]
    Output: 2.00000
    Explanation: After erasing the minimum and the maximum values of this array,
                 all elements are equal to 2, so the mean is 2.

    Example 2:
    Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]
    Output: 4.00000

    Example 3:
    Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]
    Output: 4.77778

    Example 4:
    Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]
    Output: 5.27778

    Example 5:
    Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]
    Output: 5.29167

    Constraints:
    * 20 <= arr.length <= 1000
    * arr.length is a multiple of 20.
    * 0 <= arr[i] <= 10^5"""

    def trimMean(self, arr: List[int]) -> float:
        return sum(sorted(arr)[len(arr)//20:-len(arr)//20])/(len(arr)*0.9)


    """1620. Coordinate With Maximum Network Quality (Medium)
    You are given an array of network towers towers and an integer radius,
    where towers[i] = [xi, yi, qi] denotes the ith network tower with location
    (xi, yi) and quality factor qi. All the coordinates are integral
    coordinates on the X-Y plane, and the distance between two coordinates is
    the Euclidean distance. The integer radius denotes the maximum distance in
    which the tower is reachable. The tower is reachable if the distance is
    less than or equal to radius. Outside that distance, the signal becomes
    garbled, and the tower is not reachable. The signal quality of the ith
    tower at a coordinate (x, y) is calculated with the formula ⌊qi / (1 + d)⌋,
    where d is the distance between the tower and the coordinate. The network
    quality at a coordinate is the sum of the signal qualities from all the
    reachable towers. Return the integral coordinate where the network quality
    is maximum. If there are multiple coordinates with the same network quality,
    return the lexicographically minimum coordinate.

    Note:
    A coordinate (x1, y1) is lexicographically smaller than (x2, y2) if either
    x1 < x2 or x1 == x2 and y1 < y2. ⌊val⌋ is the greatest integer less than or
    equal to val (the floor function).

    Example 1:
    Input: towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2
    Output: [2,1]
    Explanation:
    At coordinate (2, 1) the total quality is 13
    - Quality of 7 from (2, 1) results in ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7
    - Quality of 5 from (1, 2) results in ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2
    - Quality of 9 from (3, 1) results in ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4
    No other coordinate has higher quality.

    Example 2:
    Input: towers = [[23,11,21]], radius = 9
    Output: [23,11]

    Example 3:
    Input: towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2
    Output: [1,2]

    Example 4:
    Input: towers = [[2,1,9],[0,1,9]], radius = 2
    Output: [0,1]
    Explanation: Both (0, 1) and (2, 1) are optimal in terms of quality but
                 (0, 1) is lexicograpically minimal.

    Constraints:
    * 1 <= towers.length <= 50
    * towers[i].length == 3
    * 0 <= xi, yi, qi <= 50
    * 1 <= radius <= 50"""

    def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:
        mx = -inf
        for x in range(51):
            for y in range(51):
                val = 0
                for xi, yi, qi in towers:
                    d = sqrt((x-xi)**2 + (y-yi)**2)
                    if d <= radius: val += int(qi/(1 + d))
                if val > mx:
                    ans = [x, y]
                    mx = val
        return ans


    """1621. Number of Sets of K Non-Overlapping Line Segments (Medium)
    Given n points on a 1-D plane, where the ith point (from 0 to n-1) is at
    x = i, find the number of ways we can draw exactly k non-overlapping line
    segments such that each segment covers two or more points. The endpoints of
    each segment must have integral coordinates. The k line segments do not
    have to cover all n points, and they are allowed to share endpoints. Return
    the number of ways we can draw k non-overlapping line segments. Since this
    number can be huge, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 4, k = 2
    Output: 5
    Explanation: The two line segments are shown in red and blue. The image
                 above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)},
                 {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}.

    Example 2:
    Input: n = 3, k = 1
    Output: 3
    Explanation: The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}.

    Example 3:
    Input: n = 30, k = 7
    Output: 796297179
    Explanation: The total number of possible ways to draw 7 line segments is
                 3796297200. Taking this number modulo 10^9 + 7 gives us
                 796297179.

    Example 4:
    Input: n = 5, k = 3
    Output: 7

    Example 5:
    Input: n = 3, k = 2
    Output: 1

    Constraints:
    * 2 <= n <= 1000
    * 1 <= k <= n-1"""

    def numberOfSets(self, n: int, k: int) -> int:
        return comb(n+k-1, 2*k) % 1_000_000_007


    """1624. Largest Substring Between Two Equal Characters (Easy)
    Given a string s, return the length of the longest substring between two
    equal characters, excluding the two characters. If there is no such
    substring return -1. A substring is a contiguous sequence of characters
    within a string.

    Example 1:
    Input: s = "aa"
    Output: 0
    Explanation: The optimal substring here is an empty substring between the
                 two 'a's.

    Example 2:
    Input: s = "abca"
    Output: 2
    Explanation: The optimal substring here is "bc".

    Example 3:
    Input: s = "cbzxy"
    Output: -1
    Explanation: There are no characters that appear twice in s.

    Example 4:
    Input: s = "cabbac"
    Output: 4
    Explanation: The optimal substring here is "abba". Other non-optimal
                 substrings include "bb" and "".

    Constraints:
    * 1 <= s.length <= 300
    * s contains only lowercase English letters."""

    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        ans, seen = -1, {}
        for i, c in enumerate(s):
            ans = max(ans, i - seen.setdefault(c, i) - 1)
        return ans


    """1625. Lexicographically Smallest String After Applying Operations (Medium)
    You are given a string s of even length consisting of digits from 0 to 9,
    and two integers a and b. You can apply either of the following two
    operations any number of times and in any order on s:
    1) Add a to all odd indices of s (0-indexed). Digits post 9 are cycled back
       to 0. For example, if s = "3456" and a = 5, s becomes "3951".
    2) Rotate s to the right by b positions. For example, if s = "3456" and
       b = 1, s becomes "6345".
    Return the lexicographically smallest string you can obtain by applying the
    above operations any number of times on s. A string a is lexicographically
    smaller than a string b (of the same length) if in the first position where
    a and b differ, string a has a letter that appears earlier in the alphabet
    than the corresponding letter in b. For example, "0158" is lexicographically
    smaller than "0190" because the first position they differ is at the third
    letter, and '5' comes before '9'.

    Example 1:
    Input: s = "5525", a = 9, b = 2
    Output: "2050"
    Explanation: We can apply the following operations:
    Start:  "5525"
    Rotate: "2555"
    Add:    "2454"
    Add:    "2353"
    Rotate: "5323"
    Add:    "5222"
    Add:    "5121"
    Rotate: "2151"
    Add:    "2050"
    There is no way to obtain a string that is lexicographically smaller then
    "2050".

    Example 2:
    Input: s = "74", a = 5, b = 1
    Output: "24"
    Explanation: We can apply the following operations:
    Start:  "74"
    Rotate: "47"
    Add:    "42"
    Rotate: "24"
    There is no way to obtain a string that is lexicographically smaller then
    "24".

    Example 3:
    Input: s = "0011", a = 4, b = 2
    Output: "0011"
    Explanation: There are no sequence of operations that will give us a
                 lexicographically smaller string than "0011".

    Example 4:
    Input: s = "43987654", a = 7, b = 3
    Output: "00553311"

    Constraints:
    * 2 <= s.length <= 100
    * s.length is even.
    * s consists of digits from 0 to 9 only.
    * 1 <= a <= 9
    * 1 <= b <= s.length - 1"""

    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        op1 = lambda s: "".join(str((int(c)+a)%10) if i&1 else c for i, c in enumerate(s))
        op2 = lambda s: s[-b:] + s[:-b]

        seen = set()
        stack = [s]
        while stack:
            s = stack.pop()
            seen.add(s)
            if (ss := op1(s)) not in seen: stack.append(ss)
            if (ss := op2(s)) not in seen: stack.append(ss)
        return min(seen)


    """1626. Best Team With No Conflicts (Medium)
    You are the manager of a basketball team. For the upcoming tournament, you
    want to choose the team with the highest overall score. The score of the
    team is the sum of scores of all the players in the team. However, the
    basketball team is not allowed to have conflicts. A conflict exists if a
    younger player has a strictly higher score than an older player. A conflict
    does not occur between players of the same age. Given two lists, scores and
    ages, where each scores[i] and ages[i] represents the score and age of the
    ith player, respectively, return the highest overall score of all possible
    basketball teams.

    Example 1:
    Input: scores = [1,3,5,10,15], ages = [1,2,3,4,5]
    Output: 34
    Explanation: You can choose all the players.

    Example 2:
    Input: scores = [4,5,6,5], ages = [2,1,2,1]
    Output: 16
    Explanation: It is best to choose the last 3 players. Notice that you are
                 allowed to choose multiple people of the same age.

    Example 3:
    Input: scores = [1,2,3,5], ages = [8,9,10,1]
    Output: 6
    Explanation: It is best to choose the first 3 players.

    Constraints:
    * 1 <= scores.length, ages.length <= 1000
    * scores.length == ages.length
    * 1 <= scores[i] <= 10^6
    * 1 <= ages[i] <= 1000"""

    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:
        ages, scores = zip(*sorted(zip(ages, scores)))

        @cache
        def fn(i):
            """Return max score up to ith player included."""
            if i < 0: return 0 # boundary condition
            return scores[i] + max((fn(ii) for ii in range(i) if ages[ii] == ages[i] or scores[ii] <= scores[i]), default=0)

        return max(fn(i) for i in range(len(scores)))


    """1627. Graph Connectivity With Threshold (Hard)
    We have n cities labeled from 1 to n. Two different cities with labels x
    and y are directly connected by a bidirectional road if and only if x and y
    share a common divisor strictly greater than some threshold. More formally,
    cities with labels x and y have a road between them if there exists an
    integer z such that all of the following are true:
    x % z == 0,
    y % z == 0, and
    z > threshold.
    Given the two integers, n and threshold, and an array of queries, you must
    determine for each queries[i] = [ai, bi] if cities ai and bi are connected
    (i.e. there is some path between them). Return an array answer, where
    answer.length == queries.length and answer[i] is true if for the ith query,
    there is a path between ai and bi, or answer[i] is false if there is no
    path.

    Example 1:
    Input: n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]
    Output: [false,false,true]
    Explanation: The divisors for each number:
    1:   1
    2:   1, 2
    3:   1, 3
    4:   1, 2, 4
    5:   1, 5
    6:   1, 2, 3, 6
    Using the underlined divisors above the threshold, only cities 3 and 6
    share a common divisor, so they are the only ones directly connected. The
    result of each query:
    [1,4]   1 is not connected to 4
    [2,5]   2 is not connected to 5
    [3,6]   3 is connected to 6 through path 3--6

    Example 2:
    Input: n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]
    Output: [true,true,true,true,true]
    Explanation: The divisors for each number are the same as the previous
                 example. However, since the threshold is 0, all divisors can
                 be used. Since all numbers share 1 as a divisor, all cities
                 are connected.

    Example 3:
    Input: n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]
    Output: [false,false,false,false,false]
    Explanation: Only cities 2 and 4 share a common divisor 2 which is strictly
                 greater than the threshold 1, so they are the only ones
                 directly connected.
    Please notice that there can be multiple queries for the same pair of nodes
    [x, y], and that the query [x, y] is equivalent to the query [y, x].

    Constraints:
    * 2 <= n <= 10^4
    * 0 <= threshold <= n
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 1 <= ai, bi <= cities
    * ai != bi"""

    def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:
        uf = UnionFind(n)

        for u in range(threshold+1, n+1):
            for v in range(u*2, n+1, u):
                uf.union(u-1, v-1)

        return [uf.find(u-1) == uf.find(v-1) for u, v in queries]


    """1629. Slowest Key (Easy)
    A newly designed keypad was tested, where a tester pressed a sequence of n
    keys, one at a time. You are given a string keysPressed of length n, where
    keysPressed[i] was the ith key pressed in the testing sequence, and a
    sorted list releaseTimes, where releaseTimes[i] was the time the ith key
    was released. Both arrays are 0-indexed. The 0th key was pressed at the
    time 0, and every subsequent key was pressed at the exact time the previous
    key was released. The tester wants to know the key of the keypress that had
    the longest duration. The ith keypress had a duration of
    releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration
    of releaseTimes[0]. Note that the same key could have been pressed multiple
    times during the test, and these multiple presses of the same key may not
    have had the same duration. Return the key of the keypress that had the
    longest duration. If there are multiple such keypresses, return the
    lexicographically largest key of the keypresses.

    Example 1:
    Input: releaseTimes = [9,29,49,50], keysPressed = "cbcd"
    Output: "c"
    Explanation: The keypresses were as follows:
    1) Keypress for 'c' had a duration of 9 (pressed at time 0 and released at
       time 9).
    2) Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right
       after the release of the previous character and released at time 29).
    3) Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29
       right after the release of the previous character and released at time
       49).
    4) Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right
       after the release of the previous character and released at time 50).
    The longest of these was the keypress for 'b' and the second keypress for
    'c', both with duration 20. 'c' is lexicographically larger than 'b', so
    the answer is 'c'.

    Example 2:
    Input: releaseTimes = [12,23,36,46,62], keysPressed = "spuda"
    Output: "a"
    Explanation: The keypresses were as follows:
    Keypress for 's' had a duration of 12.
    Keypress for 'p' had a duration of 23 - 12 = 11.
    Keypress for 'u' had a duration of 36 - 23 = 13.
    Keypress for 'd' had a duration of 46 - 36 = 10.
    Keypress for 'a' had a duration of 62 - 46 = 16.
    The longest of these was the keypress for 'a' with duration 16.

    Constraints:
    * releaseTimes.length == n
    * keysPressed.length == n
    * 2 <= n <= 1000
    * 0 <= releaseTimes[i] <= 10^9
    * releaseTimes[i] < releaseTimes[i+1]
    * keysPressed contains only lowercase English letters."""

    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        ans, most = "", 0
        for i, (t, k) in enumerate(zip(releaseTimes, keysPressed)):
            if i: t -= releaseTimes[i-1]
            if (t, k) > (most, ans): most, ans = t, k # update
        return ans


    """1630. Arithmetic Subarrays (Medium)
    A sequence of numbers is called arithmetic if it consists of at least two
    elements, and the difference between every two consecutive elements is the
    same. More formally, a sequence s is arithmetic if and only if
    s[i+1] - s[i] == s[1] - s[0] for all valid i.

    For example, these are arithmetic sequences:
    1, 3, 5, 7, 9
    7, 7, 7, 7
    3, -1, -5, -9
    The following sequence is not arithmetic: 1, 1, 2, 5, 7
    You are given an array of n integers, nums, and two arrays of m integers
    each, l and r, representing the m range queries, where the ith query is the
    range [l[i], r[i]]. All the arrays are 0-indexed. Return a list of boolean
    elements answer, where answer[i] is true if the subarray nums[l[i]],
    nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic
    sequence, and false otherwise.

    Example 1:
    Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
    Output: [true,false,true]
    Explanation:
    In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.
    In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.
    In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.

    Example 2:
    Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
    Output: [false,true,false,false,true,true]

    Constraints:
    * n == nums.length
    * m == l.length
    * m == r.length
    * 2 <= n <= 500
    * 1 <= m <= 500
    * 0 <= l[i] < r[i] < n
    * -10^5 <= nums[i] <= 10^5"""

    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:
        ans = []
        for ll, rr in zip(l, r):
            seq = sorted(nums[ll:rr+1])
            ans.append(len(set(seq[i] - seq[i-1] for i in range(1, len(seq)))) == 1)
        return ans


    """1631. Path With Minimum Effort (Medium)
    You are a hiker preparing for an upcoming hike. You are given heights, a 2D
    array of size rows x columns, where heights[row][col] represents the height
    of cell (row, col). You are situated in the top-left cell, (0, 0), and you
    hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e.,
    0-indexed). You can move up, down, left, or right, and you wish to find a
    route that requires the minimum effort. A route's effort is the maximum
    absolute difference in heights between two consecutive cells of the route.
    Return the minimum effort required to travel from the top-left cell to the
    bottom-right cell.

    Example 1:
    Input: heights = [[1,2,2],[3,8,2],[5,3,5]]
    Output: 2
    Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of
                 2 in consecutive cells. This is better than the route of
                 [1,2,2,2,5], where the maximum absolute difference is 3.

    Example 2:
    Input: heights = [[1,2,3],[3,8,4],[5,3,5]]
    Output: 1
    Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of
                 1 in consecutive cells, which is better than route [1,3,5,3,5].

    Example 3:
    Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
    Output: 0

    Explanation: This route does not require any effort.

    Constraints:
    * rows == heights.length
    * columns == heights[i].length
    * 1 <= rows, columns <= 100
    * 1 <= heights[i][j] <= 10^6"""

    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        seen = [[inf]*n for _ in heights] # lowest height seen
        hp = [(0, 0, 0)] # height|row|column
        while hp:
            h, i, j = heappop(hp)
            if i == m-1 and j == n-1: return h # end condition
            if h < seen[i][j]:
                seen[i][j] = h
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n:
                        hh = max(h, abs(heights[ii][jj] - heights[i][j]))
                        if hh < seen[ii][jj]: heappush(hp, (hh, ii, jj))


    """1632. Rank Transform of a Matrix (Hard)
    Given an m x n matrix, return a new matrix answer where answer[row][col] is
    the rank of matrix[row][col]. The rank is an integer that represents how
    large an element is compared to other elements. It is calculated using the
    following rules:
    * The rank is an integer starting from 1.
    * If two elements p and q are in the same row or column, then:
        - If p < q then rank(p) < rank(q)
        - If p == q then rank(p) == rank(q)
        - If p > q then rank(p) > rank(q)
    * The rank should be as small as possible.
    It is guaranteed that answer is unique under the given rules.

    Example 1:
    Input: matrix = [[1,2],[3,4]]
    Output: [[1,2],[2,3]]
    Explanation:
    The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.
    The rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.
    The rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.
    The rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.

    Example 2:
    Input: matrix = [[7,7],[7,7]]
    Output: [[1,1],[1,1]]

    Example 3:
    Input: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
    Output: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]

    Example 4:
    Input: matrix = [[7,3,6],[1,4,5],[9,8,2]]
    Output: [[5,1,4],[1,2,3],[6,3,1]]

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 500
    * -10^9 <= matrix[row][col] <= 10^9"""

    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0]) # dimension
        # mapping from value to index
        mp = {}
        for i in range(m):
            for j in range(n):
                mp.setdefault(matrix[i][j], []).append((i, j))

        def find(p):
            """Find root of p."""
            if p != parent[p]:
                parent[p] = find(parent[p])
            return parent[p]

        rank = [0]*(m+n)
        ans = [[0]*n for _ in range(m)]

        for k in sorted(mp): # from minimum to maximum
            parent = list(range(m+n))
            for i, j in mp[k]:
                ii, jj = find(i), find(m+j) # find
                parent[ii] = jj # union
                rank[jj] = max(rank[ii], rank[jj]) # max rank

            seen = set()
            for i, j in mp[k]:
                ii = find(i)
                if ii not in seen: rank[ii] += 1
                seen.add(ii)
                rank[i] = rank[m+j] = ans[i][j] = rank[ii]
        return ans


    """1634. Add Two Polynomials Represented as Linked Lists (Medium)
    A polynomial linked list is a special type of linked list where every node
    represents a term in a polynomial expression. Each node has three attributes:
    * coefficient: an integer representing the number multiplier of the term.
      The coefficient of the term 9x4 is 9.
    * power: an integer representing the exponent. The power of the term 9x4 is
      4.
    * next: a pointer to the next node in the list, or null if it is the last
      node of the list.
    The polynomial linked list must be in its standard form: the polynomial
    must be in strictly descending order by its power value. Also, terms with a
    coefficient of 0 are omitted. Given two polynomial linked list heads, poly1
    and poly2, add the polynomials together and return the head of the sum of
    the polynomials.

    PolyNode format: The input/output format is as a list of n nodes, where
                     each node is represented as its [coefficient, power]. For
                     example, the polynomial 5x3 + 4x - 7 would be represented
                     as: [[5,3],[4,1],[-7,0]].

    Example 1:
    Input: poly1 = [[1,1]], poly2 = [[1,0]]
    Output: [[1,1],[1,0]]
    Explanation: poly1 = x. poly2 = 1. The sum is x + 1.

    Example 2:
    Input: poly1 = [[2,2],[4,1],[3,0]], poly2 = [[3,2],[-4,1],[-1,0]]
    Output: [[5,2],[2,0]]
    Explanation: poly1 = 2x2 + 4x + 3.
                 poly2 = 3x2 - 4x - 1.
                 The sum is 5x2 + 2. Notice that we omit the "0x" term.

    Example 3:
    Input: poly1 = [[1,2]], poly2 = [[-1,2]]
    Output: []
    Explanation: The sum is 0. We return an empty list.

    Constraints:
    * 0 <= n <= 10^4
    * -10^9 <= PolyNode.coefficient <= 10^9
    * PolyNode.coefficient != 0
    * 0 <= PolyNode.power <= 10^9
    * PolyNode.power > PolyNode.next.power"""

    def addPoly(self, poly1: 'PolyNode', poly2: 'PolyNode') -> 'PolyNode':
        dummy = node = PolyNode()
        while poly1 and poly2:
            if poly1.power > poly2.power:
                node.next = node = poly1
                poly1 = poly1.next
            elif poly1.power < poly2.power:
                node.next = node = poly2
                poly2 = poly2.next
            else:
                coef = poly1.coefficient + poly2.coefficient
                if coef: node.next = node = PolyNode(coef, poly1.power)
                poly1 = poly1.next
                poly2 = poly2.next
        node.next = poly1 or poly2
        return dummy.next


    """1636. Sort Array by Increasing Frequency (Easy)
    Given an array of integers nums, sort the array in increasing order based
    on the frequency of the values. If multiple values have the same frequency,
    sort them in decreasing order. Return the sorted array.

    Example 1:
    Input: nums = [1,1,2,2,2,3]
    Output: [3,1,1,2,2,2]
    Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2'
                 has a frequency of 3.

    Example 2:
    Input: nums = [2,3,1,3,2]
    Output: [1,3,3,2,2]
    Explanation: '2' and '3' both have a frequency of 2, so they are sorted in
                 decreasing order.

    Example 3:
    Input: nums = [-1,1,-6,4,5,-6,1,4,1]
    Output: [5,-1,4,4,-6,-6,1,1,1]

    Constraints:
    * 1 <= nums.length <= 100
    * -100 <= nums[i] <= 100"""

    def frequencySort(self, nums: List[int]) -> List[int]:
        freq = Counter(nums)
        return sorted(nums, key = lambda x: (freq[x], -x))


    """1637. Widest Vertical Area Between Two Points Containing No Points (Medium)
    Given n points on a 2D plane where points[i] = [xi, yi], Return the widest
    vertical area between two points such that no points are inside the area. A
    vertical area is an area of fixed-width extending infinitely along the y-axis
    (i.e., infinite height). The widest vertical area is the one with the maximum
    width. Note that points on the edge of a vertical area are not considered
    included in the area.

    Example 1:
    Input: points = [[8,7],[9,9],[7,4],[9,7]]
    Output: 1
    Explanation: Both the red and the blue area are optimal.

    Example 2:
    Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]
    Output: 3

    Constraints:
    * n == points.length
    * 2 <= n <= 10^5
    * points[i].length == 2
    * 0 <= xi, yi <= 10^9"""

    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        vals = sorted(x for x, _ in points)
        return max(vals[i] - vals[i-1] for i in range(1, len(vals)))


    """1638. Count Substrings That Differ by One Character (Medium)
    Given two strings s and t, find the number of ways you can choose a non-
    empty substring of s and replace a single character by a different
    character such that the resulting substring is a substring of t. In other
    words, find the number of substrings in s that differ from some substring
    in t by exactly one character. For example, the underlined substrings in
    "computer" and "computation" only differ by the 'e'/'a', so this is a valid
    way. Return the number of substrings that satisfy the condition above. A
    substring is a contiguous sequence of characters within a string.

    Example 1:
    Input: s = "aba", t = "baba"
    Output: 6
    Explanation: The following are the pairs of substrings from s and t that differ by exactly 1 character:
    ("aba", "baba")
    ("aba", "baba")
    ("aba", "baba")
    ("aba", "baba")
    ("aba", "baba")
    ("aba", "baba")
    The underlined portions are the substrings that are chosen from s and t.

    ​​Example 2:
    Input: s = "ab", t = "bb"
    Output: 3
    Explanation: The following are the pairs of substrings from s and t that differ by 1 character:
    ("ab", "bb")
    ("ab", "bb")
    ("ab", "bb")
    ​​​​The underlined portions are the substrings that are chosen from s and t.

    Example 3:
    Input: s = "a", t = "a"
    Output: 0

    Example 4:
    Input: s = "abe", t = "bbc"
    Output: 10

    Constraints:
    * 1 <= s.length, t.length <= 100
    * s and t consist of lowercase English letters only."""

    def countSubstrings(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp0 = [[0]*(n+1) for _ in range(m+1)] # 0-mismatch
        dp1 = [[0]*(n+1) for _ in range(m+1)] # 1-mismatch

        ans = 0
        for i in range(m):
            for j in range(n):
                if s[i] == t[j]:
                    dp0[i+1][j+1] = 1 + dp0[i][j]
                    dp1[i+1][j+1] = dp1[i][j]
                else:
                    dp0[i+1][j+1] = 0
                    dp1[i+1][j+1] = 1 + dp0[i][j]
                ans += dp1[i+1][j+1]
        return ans


    """1639. Number of Ways to Form a Target String Given a Dictionary (Hard)
    You are given a list of strings of the same length words and a string
    target. Your task is to form target using the given words under the
    following rules:
    * target should be formed from left to right.
    * To form the ith character (0-indexed) of target, you can choose the kth
      character of the jth string in words if target[i] = words[j][k].
    * Once you use the kth character of the jth string of words, you can no
      longer use the xth character of any string in words where x <= k. In
      other words, all characters to the left of or at index k become unusuable
      for every string.
    * Repeat the process until you form the string target.
    Notice that you can use multiple characters from the same string in words
    provided the conditions above are met. Return the number of ways to form
    target from words. Since the answer may be too large, return it modulo
    10^9 + 7.

    Example 1:
    Input: words = ["acca","bbbb","caca"], target = "aba"
    Output: 6
    Explanation: There are 6 ways to form target.
    "aba" -> index 0 ("acca"), index 1 ("bbbb"), index 3 ("caca")
    "aba" -> index 0 ("acca"), index 2 ("bbbb"), index 3 ("caca")
    "aba" -> index 0 ("acca"), index 1 ("bbbb"), index 3 ("acca")
    "aba" -> index 0 ("acca"), index 2 ("bbbb"), index 3 ("acca")
    "aba" -> index 1 ("caca"), index 2 ("bbbb"), index 3 ("acca")
    "aba" -> index 1 ("caca"), index 2 ("bbbb"), index 3 ("caca")

    Example 2:
    Input: words = ["abba","baab"], target = "bab"
    Output: 4
    Explanation: There are 4 ways to form target.
    "bab" -> index 0 ("baab"), index 1 ("baab"), index 2 ("abba")
    "bab" -> index 0 ("baab"), index 1 ("baab"), index 3 ("baab")
    "bab" -> index 0 ("baab"), index 2 ("baab"), index 3 ("baab")
    "bab" -> index 1 ("abba"), index 2 ("baab"), index 3 ("baab")

    Example 3:
    Input: words = ["abcd"], target = "abcd"
    Output: 1

    Example 4:
    Input: words = ["abab","baba","abba","baab"], target = "abba"
    Output: 16

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 1000
    * All strings in words have the same length.
    * 1 <= target.length <= 1000
    * words[i] and target contain only lowercase English letters."""

    def numWays(self, words: List[str], target: str) -> int:
        freq = [defaultdict(int) for _ in range(len(words[0]))]
        for word in words:
            for i, c in enumerate(word):
                freq[i][c] += 1

        @cache
        def fn(i, k):
            """Return number of ways to form target[i:] w/ col k."""
            if i == len(target): return 1
            if k == len(words[0]): return 0
            return freq[k][target[i]]*fn(i+1, k+1) + fn(i, k+1)

        return fn(0, 0) % 1_000_000_007


    """1640. Check Array Formation Through Concatenation (Easy)
    You are given an array of distinct integers arr and an array of integer
    arrays pieces, where the integers in pieces are distinct. Your goal is to
    form arr by concatenating the arrays in pieces in any order. However, you
    are not allowed to reorder the integers in each array pieces[i]. Return
    true if it is possible to form the array arr from pieces. Otherwise, return
    false.

    Example 1:
    Input: arr = [85], pieces = [[85]]
    Output: true

    Example 2:
    Input: arr = [15,88], pieces = [[88],[15]]
    Output: true
    Explanation: Concatenate [15] then [88]

    Example 3:
    Input: arr = [49,18,16], pieces = [[16,18,49]]
    Output: false
    Explanation: Even though the numbers match, we cannot reorder pieces[0].

    Example 4:
    Input: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
    Output: true
    Explanation: Concatenate [91] then [4,64] then [78]

    Example 5:
    Input: arr = [1,3,5,7], pieces = [[2,4,6,8]]
    Output: false

    Constraints:
    * 1 <= pieces.length <= arr.length <= 100
    * sum(pieces[i].length) == arr.length
    * 1 <= pieces[i].length <= arr.length
    * 1 <= arr[i], pieces[i][j] <= 100
    * The integers in arr are distinct.
    * The integers in pieces are distinct (i.e., If we flatten pieces in a 1D
      array, all the integers in this array are distinct)."""

    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        mp = {x[0]: x for x in pieces}
        return sum((mp.get(x, []) for x in arr), []) == arr


    """1641. Count Sorted Vowel Strings (Medium)
    Given an integer n, return the number of strings of length n that consist
    only of vowels (a, e, i, o, u) and are lexicographically sorted. A string s
    is lexicographically sorted if for all valid i, s[i] is the same as or
    comes before s[i+1] in the alphabet.

    Example 1:
    Input: n = 1
    Output: 5
    Explanation: The 5 sorted strings that consist of vowels only are ["a","e","i","o","u"].

    Example 2:
    Input: n = 2
    Output: 15
    Explanation: The 15 sorted strings that consist of vowels only are
    ["aa","ae","ai","ao","au","ee","ei","eo","eu","ii","io","iu","oo","ou","uu"].
    Note that "ea" is not a valid string since 'e' comes after 'a' in the alphabet.

    Example 3:
    Input: n = 33
    Output: 66045

    Constraints: 1 <= n <= 50 """

    def countVowelStrings(self, n: int) -> int:

        @cache
        def fn(n, k):
            """Return number of sorted strings of length n consisting of k vowels."""
            if n == 1: return k # base case
            return sum(fn(n-1, kk) for kk in range(1, k+1))

        return fn(n, 5)


    """1642. Furthest Building You Can Reach (Medium)
    You are given an integer array heights representing the heights of
    buildings, some bricks, and some ladders. You start your journey from
    building 0 and move to the next building by possibly using bricks or
    ladders. While moving from building i to building i+1 (0-indexed),
    * If the current building's height is greater than or equal to the next
      building's height, you do not need a ladder or bricks.
    * If the current building's height is less than the next building's height,
      you can either use one ladder or (h[i+1] - h[i]) bricks.
    Return the furthest building index (0-indexed) you can reach if you use the
    given ladders and bricks optimally.

    Example 1:
    Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
    Output: 4
    Explanation: Starting at building 0, you can follow these steps:
    - Go to building 1 without using ladders nor bricks since 4 >= 2.
    - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.
    - Go to building 3 without using ladders nor bricks since 7 >= 6.
    - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.
    It is impossible to go beyond building 4 because you do not have any more bricks or ladders.

    Example 2:
    Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2
    Output: 7

    Example 3:
    Input: heights = [14,3,19,3], bricks = 17, ladders = 0
    Output: 3

    Constraints:
    * 1 <= heights.length <= 10^5
    * 1 <= heights[i] <= 10^6
    * 0 <= bricks <= 10^9
    * 0 <= ladders <= heights.length"""

    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        pq = [] # min heap
        for i in range(1, len(heights)):
            diff = heights[i] - heights[i-1]
            if diff > 0:
                heappush(pq, diff)
                if len(pq) > ladders: # not enough ladders
                    bricks -= heappop(pq)
                    if bricks < 0: return i-1
        return len(heights) - 1


    """1643. Kth Smallest Instructions (Hard)
    Bob is standing at cell (0, 0), and he wants to reach destination:
    (row, column). He can only travel right and down. You are going to help Bob
    by providing instructions for him to reach destination. The instructions
    are represented as a string, where each character is either:
    * 'H', meaning move horizontally (go right), or
    * 'V', meaning move vertically (go down).
    Multiple instructions will lead Bob to destination. For example, if
    destination is (2, 3), both "HHHVV" and "HVHVH" are valid instructions.
    However, Bob is very picky. Bob has a lucky number k, and he wants the kth
    lexicographically smallest instructions that will lead him to destination.
    k is 1-indexed. Given an integer array destination and an integer k, return
    the kth lexicographically smallest instructions that will take Bob to destination.

    Example 1:
    Input: destination = [2,3], k = 1
    Output: "HHHVV"
    Explanation: All the instructions that reach (2, 3) in lexicographic order are as follows:
    ["HHHVV", "HHVHV", "HHVVH", "HVHHV", "HVHVH", "HVVHH", "VHHHV", "VHHVH", "VHVHH", "VVHHH"].

    Example 2:
    Input: destination = [2,3], k = 2
    Output: "HHVHV"

    Example 3:
    Input: destination = [2,3], k = 3
    Output: "HHVVH"

    Constraints:
    * destination.length == 2
    * 1 <= row, column <= 15
    * 1 <= k <= nCr(row + column, row), where nCr(a, b) denotes a choose b​​​​​."""

    def kthSmallestPath(self, destination: List[int], k: int) -> str:
        m, n = destination # m "V" & n "H" in total
        ans = ""
        while n:
            kk = comb(m+n-1, n-1) # (m+n-1 choose n-1) instructions starting with "H"
            if kk >= k:
                ans += "H"
                n -= 1
            else:
                ans += "V"
                m -= 1
                k -= kk
        return ans + m*"V"


    """1644. Lowest Common Ancestor of a Binary Tree II (Medium)
    Given the root of a binary tree, return the lowest common ancestor (LCA)
    of two given nodes, p and q. If either node p or q does not exist in the
    tree, return null. All values of the nodes in the tree are unique.
    According to the definition of LCA on Wikipedia: "The lowest common
    ancestor of two nodes p and q in a binary tree T is the lowest node that
    has both p and q as descendants (where we allow a node to be a descendant
    of itself)". A descendant of a node x is a node y that is on the path from
    node x to some leaf node.

    Example 1:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    Output: 3
    Explanation: The LCA of nodes 5 and 1 is 3.

    Example 2:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    Output: 5
    Explanation: The LCA of nodes 5 and 4 is 5. A node can be a descendant of
                 itself according to the definition of LCA.

    Example 3:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 10
    Output: null
    Explanation: Node 10 does not exist in the tree, so return null.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -10^9 <= Node.val <= 10^9
    * All Node.val are unique.
    * p != q

    Follow up: Can you find the LCA traversing the tree, without checking nodes
               existence?"""

    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        def fn(node):
            """Return LCA of p and q in sub-tree rooted at node (if found)."""
            if node:
                (ln, lx), (rn, rx) = fn(node.left), fn(node.right)
                if node in (p, q): return node, 1 + lx + rx
                if ln and rn: return node, lx + rx
                return (ln, lx) if ln else (rn, rx)
            return None, 0

        ans, x = fn(root)
        return ans if x == 2 else None


    """1646. Get Maximum in Generated Array (Easy)
    You are given an integer n. An array nums of length n + 1 is generated in
    the following way:
    * nums[0] = 0
    * nums[1] = 1
    * nums[2 * i] = nums[i] when 2 <= 2 * i <= n
    * nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n
    Return the maximum integer in the array nums​​​.

    Example 1:
    Input: n = 7
    Output: 3
    Explanation: According to the given rules:
      nums[0] = 0
      nums[1] = 1
      nums[(1 * 2) = 2] = nums[1] = 1
      nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
      nums[(2 * 2) = 4] = nums[2] = 1
      nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
      nums[(3 * 2) = 6] = nums[3] = 2
      nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
    Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is 3.

    Example 2:
    Input: n = 2
    Output: 1
    Explanation: According to the given rules, the maximum between nums[0],
                 nums[1], and nums[2] is 1.

    Example 3:
    Input: n = 3
    Output: 2
    Explanation: According to the given rules, the maximum between nums[0],
                 nums[1], nums[2], and nums[3] is 2.

    Constraints:
    * 0 <= n <= 100"""

    def getMaximumGenerated(self, n: int) -> int:
        if not n: return 0 # edge case
        nums = [0, 1]
        for i in range(2, n+1):
            if i&1: nums.append(nums[i//2] + nums[i//2+1])
            else: nums.append(nums[i//2])
        return max(nums)


    """1647. Minimum Deletions to Make Character Frequencies Unique (Medium)
    A string s is called good if there are no two different characters in s
    that have the same frequency. Given a string s, return the minimum number
    of characters you need to delete to make s good. The frequency of a
    character in a string is the number of times it appears in the string. For
    example, in the string "aab", the frequency of 'a' is 2, while the
    frequency of 'b' is 1.

    Example 1:
    Input: s = "aab"
    Output: 0
    Explanation: s is already good.

    Example 2:
    Input: s = "aaabbbcc"
    Output: 2
    Explanation: You can delete two 'b's resulting in the good string "aaabcc".
                 Another way it to delete one 'b' and one 'c' resulting in the
                 good string "aaabbc".

    Example 3:
    Input: s = "ceabaacb"
    Output: 2
    Explanation: You can delete both 'c's resulting in the good string "eabaab".
                 Note that we only care about characters that are still in the
                 string at the end (i.e. frequency of 0 is ignored).

    Constraints:
    * 1 <= s.length <= 10^5
    * s contains only lowercase English letters."""

    def minDeletions(self, s: str) -> int:
        freq = {} # frequency table
        for c in s: freq[c] = 1 + freq.get(c, 0)

        ans = 0
        seen = set()
        for k in freq.values():
            while k in seen:
                k -= 1
                ans += 1
            if k: seen.add(k)
        return ans


    """1648. Sell Diminishing-Valued Colored Balls (Medium)
    You have an inventory of different colored balls, and there is a customer
    that wants orders balls of any color. The customer weirdly values the
    colored balls. Each colored ball's value is the number of balls of that
    color you currently have in your inventory. For example, if you own 6
    yellow balls, the customer would pay 6 for the first yellow ball. After the
    transaction, there are only 5 yellow balls left, so the next yellow ball is
    then valued at 5 (i.e., the value of the balls decreases as you sell more
    to the customer). You are given an integer array, inventory, where
    inventory[i] represents the number of balls of the ith color that you
    initially own. You are also given an integer orders, which represents the
    total number of balls that the customer wants. You can sell the balls in
    any order. Return the maximum total value that you can attain after selling
    orders colored balls. As the answer may be too large, return it modulo
    10^9 + 7.

    Example 1:
    Input: inventory = [2,5], orders = 4
    Output: 14
    Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times
                 (5 + 4 + 3). The maximum total value is 2 + 5 + 4 + 3 = 14.

    Example 2:
    Input: inventory = [3,5], orders = 6
    Output: 19
    Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times
                 (5 + 4 + 3 + 2). The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.

    Example 3:
    Input: inventory = [2,8,4,10,6], orders = 20
    Output: 110

    Example 4:
    Input: inventory = [1000000000], orders = 1000000000
    Output: 21
    Explanation: Sell the 1st color 1000000000 times for a total value of
                 500000000500000000. 500000000500000000 modulo 10^9 + 7 = 21.

    Constraints:
    * 1 <= inventory.length <= 10^5
    * 1 <= inventory[i] <= 10^9
    * 1 <= orders <= min(sum(inventory[i]), 10^9)"""

    def maxProfit(self, inventory: List[int], orders: int) -> int:
        inventory.sort(reverse=True) # inventory high to low
        inventory.append(0)
        ans = i = 0
        while orders:
            sell = min(orders, (i+1)*(inventory[i] - inventory[i+1]))
            q, r = divmod(sell, i+1)
            ans += (i+1)*(2*inventory[i] - q + 1)*q//2 + r*(inventory[i] - q)
            orders -= sell
            i += 1
        return ans % 1_000_000_007


    """1649. Create Sorted Array through Instructions (Hard)
    Given an integer array instructions, you are asked to create a sorted array
    from the elements in instructions. You start with an empty container nums.
    For each element from left to right in instructions, insert it into nums.
    The cost of each insertion is the minimum of the following:
    * The number of elements currently in nums that are strictly less than
      instructions[i].
    * The number of elements currently in nums that are strictly greater than
      instructions[i].
    For example, if inserting element 3 into nums = [1,2,3,5], the cost of
    insertion is min(2, 1) (elements 1 and 2 are less than 3, element 5 is
    greater than 3) and nums will become [1,2,3,3,5]. Return the total cost to
    insert all elements from instructions into nums. Since the answer may be
    large, return it modulo 10^9 + 7

    Example 1:
    Input: instructions = [1,5,6,2]
    Output: 1
    Explanation: Begin with nums = [].
    Insert 1 with cost min(0, 0) = 0, now nums = [1].
    Insert 5 with cost min(1, 0) = 0, now nums = [1,5].
    Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6].
    Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6].
    The total cost is 0 + 0 + 0 + 1 = 1.

    Example 2:
    Input: instructions = [1,2,3,6,5,4]
    Output: 3
    Explanation: Begin with nums = [].
    Insert 1 with cost min(0, 0) = 0, now nums = [1].
    Insert 2 with cost min(1, 0) = 0, now nums = [1,2].
    Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3].
    Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6].
    Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6].
    Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6].
    The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.

    Example 3:
    Input: instructions = [1,3,3,3,2,4,2,1,2]
    Output: 4
    Explanation: Begin with nums = [].
    Insert 1 with cost min(0, 0) = 0, now nums = [1].
    Insert 3 with cost min(1, 0) = 0, now nums = [1,3].
    Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3].
    Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3].
    Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3].
    Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4].
    Insert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4].
    Insert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4].
    Insert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4].
    The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4.

    Constraints:
    * 1 <= instructions.length <= 10^5
    * 1 <= instructions[i] <= 10^5

class Fenwick:
    def __init__(self, n):
        self.nums = [0]*(n+1)

    def sum(self, k):
        ans = 0
        while k:
            ans += self.nums[k]
            k &= k-1
        return ans

    def add(self, i, x):
        i += 1
        while i < len(self.nums):
            self.nums[i] += x
            i += i & -i
    """

    def createSortedArray(self, instructions: List[int]) -> int:
        ans = 0
        fen = Fenwick(10**5)
        freq = {} # frequency of each instructions
        for i, x in enumerate(instructions):
            less = fen.sum(x)
            more = i - freq.get(x, 0) - less
            ans += min(less, more)
            fen.add(x, 1)
            freq[x] = 1 + freq.get(x, 0)
        return ans % 1_000_000_007


    """1650. Lowest Common Ancestor of a Binary Tree III (Medium)
    Given two nodes of a binary tree p and q, return their lowest common
    ancestor (LCA). Each node will have a reference to its parent node. The
    definition for Node is below:
    class Node {
        public int val;
        public Node left;
        public Node right;
        public Node parent;
    }
    According to the definition of LCA on Wikipedia: "The lowest common
    ancestor of two nodes p and q in a tree T is the lowest node that has both
    p and q as descendants (where we allow a node to be a descendant of itself)."

    Example 1:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    Output: 3
    Explanation: The LCA of nodes 5 and 1 is 3.

    Example 2:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    Output: 5
    Explanation: The LCA of nodes 5 and 4 is 5 since a node can be a descendant
                 of itself according to the LCA definition.

    Example 3:
    Input: root = [1,2], p = 1, q = 2
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [2, 10^5].
    * -10^9 <= Node.val <= 10^9
    * All Node.val are unique.
    * p != q
    * p and q exist in the tree."""

    def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':
        n0, n1 = p, q
        while n0 != n1:
            n0 = n0.parent if n0 else q
            n1 = n1.parent if n1 else p
        return n0


    """1652. Defuse the Bomb (Easy)
    You have a bomb to defuse, and your time is running out! Your informer will
    provide you with a circular array code of length of n and a key k. To
    decrypt the code, you must replace every number. All the numbers are
    replaced simultaneously.
    * If k > 0, replace the ith number with the sum of the next k numbers.
    * If k < 0, replace the ith number with the sum of the previous k numbers.
    * If k == 0, replace the ith number with 0.
    As code is circular, the next element of code[n-1] is code[0], and the
    previous element of code[0] is code[n-1]. Given the circular array code and
    an integer key k, return the decrypted code to defuse the bomb!

    Example 1:
    Input: code = [5,7,1,4], k = 3
    Output: [12,10,16,13]
    Explanation: Each number is replaced by the sum of the next 3 numbers. The
                 decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that
                 the numbers wrap around.

    Example 2:
    Input: code = [1,2,3,4], k = 0
    Output: [0,0,0,0]
    Explanation: When k is zero, the numbers are replaced by 0.

    Example 3:
    Input: code = [2,4,9,3], k = -2
    Output: [12,5,6,13]
    Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the
                 numbers wrap around again. If k is negative, the sum is of the
                 previous numbers.

    Constraints:
    * n == code.length
    * 1 <= n <= 100
    * 1 <= code[i] <= 100
    * -(n - 1) <= k <= n - 1"""

    def decrypt(self, code: List[int], k: int) -> List[int]:
        if k < 0: return self.decrypt(code[::-1], -k)[::-1]

        prefix = [0] # prefix sum (w/ leading 0)
        for x in code*2: prefix.append(prefix[-1] + x)

        ans = []
        for i in range(len(code)):
            ans.append(prefix[i+k+1] - prefix[i+1])
        return ans


    """1653. Minimum Deletions to Make String Balanced (Medium)
    You are given a string s consisting only of characters 'a' and 'b'. You
    can delete any number of characters in s to make s balanced. s is balanced
    if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and
    s[j]= 'a'. Return the minimum number of deletions needed to make s balanced.

    Example 1:
    Input: s = "aababbab"
    Output: 2
    Explanation: You can either delete the characters at 0-indexed positions 2
                 and 6 ("aababbab" -> "aaabbb"), or delete the characters at
                 0-indexed positions 3 and 6 ("aababbab" -> "aabbbb").

    Example 2:
    Input: s = "bbaaaaabb"
    Output: 2
    Explanation: The only solution is to delete the first two characters.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is 'a' or 'b'."""

    def minimumDeletions(self, s: str) -> int:
        ans = prefix = 0
        for ch in s:
            if ch == 'b': prefix += 1
            else: ans = min(1 + ans, prefix)
        return ans


    """1654. Minimum Jumps to Reach Home (Medium)
    A certain bug's home is on the x-axis at position x. Help them get there
    from position 0. The bug jumps according to the following rules:
    * It can jump exactly a positions forward (to the right).
    * It can jump exactly b positions backward (to the left).
    * It cannot jump backward twice in a row.
    * It cannot jump to any forbidden positions.
    The bug may jump forward beyond its home, but it cannot jump to positions
    numbered with negative integers. Given an array of integers forbidden,
    where forbidden[i] means that the bug cannot jump to the position
    forbidden[i], and integers a, b, and x, return the minimum number of jumps
    needed for the bug to reach its home. If there is no possible sequence of
    jumps that lands the bug on position x, return -1.

    Example 1:
    Input: forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9
    Output: 3
    Explanation: 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.

    Example 2:
    Input: forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11
    Output: -1

    Example 3:
    Input: forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7
    Output: 2
    Explanation: One jump forward (0 -> 16) then one jump backward (16 -> 7)
                 will get the bug home.

    Constraints:
    * 1 <= forbidden.length <= 1000
    * 1 <= a, b, forbidden[i] <= 2000
    * 0 <= x <= 2000
    * All the elements in forbidden are distinct.
    * Position x is not forbidden."""

    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
        forbidden = set(forbidden)
        upper = max(forbidden | {x}) + a + b

        ans = 0
        queue = [(0, 0)]
        forbidden.add(0)
        while queue:
            newq = []
            for n, k in queue:
                if n == x: return ans
                if n+a <= upper and n+a not in forbidden:
                    newq.append((n+a, 0))
                    forbidden.add(n+a)
                if k == 0 and 0 <= n-b and n-b not in forbidden:
                    newq.append((n-b, 1))
            ans += 1
            queue = newq
        return -1


    """1655. Distribute Repeating Integers (Hard)
    You are given an array of n integers, nums, where there are at most 50
    unique values in the array. You are also given an array of m customer order
    quantities, quantity, where quantity[i] is the amount of integers the ith
    customer ordered. Determine if it is possible to distribute nums such that:
    * The ith customer gets exactly quantity[i] integers,
    * The integers the ith customer gets are all equal, and
    * Every customer is satisfied.
    Return true if it is possible to distribute nums according to the above
    conditions.

    Example 1:
    Input: nums = [1,2,3,4], quantity = [2]
    Output: false
    Explanation: The 0th customer cannot be given two different integers.

    Example 2:
    Input: nums = [1,2,3,3], quantity = [2]
    Output: true
    Explanation: The 0th customer is given [3,3]. The integers [1,2] are not
                 used.

    Example 3:
    Input: nums = [1,1,2,2], quantity = [2,2]
    Output: true
    Explanation: The 0th customer is given [1,1], and the 1st customer is given
                 [2,2].

    Example 4:
    Input: nums = [1,1,2,3], quantity = [2,2]
    Output: false
    Explanation: Although the 0th customer could be given [1,1], the 1st
                 customer cannot be satisfied.

    Example 5:
    Input: nums = [1,1,1,1,1], quantity = [2,3]
    Output: true
    Explanation: The 0th customer is given [1,1], and the 1st customer is given
                 [1,1,1].

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= 1000
    * m == quantity.length
    * 1 <= m <= 10
    * 1 <= quantity[i] <= 10^5
    * There are at most 50 unique values in nums."""

    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        freq = {}
        for x in nums: freq[x] = 1 + freq.get(x, 0)

        vals = sorted(freq.values(), reverse=True)
        quantity.sort(reverse=True) # handling large values first

        def fn(i):
            """Return True if possible to distribute quantity[i:] to remaining."""
            if i == len(quantity): return True
            seen = set()
            for k in range(len(vals)):
                if vals[k] >= quantity[i] and vals[k] not in seen:
                    seen.add(vals[k])
                    vals[k] -= quantity[i]
                    if fn(i+1): return True
                    vals[k] += quantity[i] # backtracking

        return fn(0)


    """1657. Determine if Two Strings Are Close (Medium)
    Two strings are considered close if you can attain one from the other using
    the following operations:
    * Operation 1: Swap any two existing characters.
      + For example, abcde -> aecdb
    * Operation 2: Transform every occurrence of one existing character into
      another existing character, and do the same with the other character.
      + For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn
        into a's)
    You can use the operations on either string as many times as necessary.
    Given two strings, word1 and word2, return true if word1 and word2 are
    close, and false otherwise.

    Example 1:
    Input: word1 = "abc", word2 = "bca"
    Output: true
    Explanation: You can attain word2 from word1 in 2 operations.
                 Apply Operation 1: "abc" -> "acb"
                 Apply Operation 1: "acb" -> "bca"

    Example 2:
    Input: word1 = "a", word2 = "aa"
    Output: false
    Explanation: It is impossible to attain word2 from word1, or vice versa, in
                 any number of operations.

    Example 3:
    Input: word1 = "cabbba", word2 = "abbccc"
    Output: true
    Explanation: You can attain word2 from word1 in 3 operations.
                 Apply Operation 1: "cabbba" -> "caabbb"
                 Apply Operation 2: "caabbb" -> "baaccc"
                 Apply Operation 2: "baaccc" -> "abbccc"

    Example 4:
    Input: word1 = "cabbba", word2 = "aabbss"
    Output: false
    Explanation: It is impossible to attain word2 from word1, or vice versa, in
                 any amount of operations.

    Constraints:
    * 1 <= word1.length, word2.length <= 10^5
    * word1 and word2 contain only lowercase English letters."""

    def closeStrings(self, word1: str, word2: str) -> bool:
        cnt1, cnt2 = Counter(word1), Counter(word2)
        return cnt1.keys() == cnt2.keys() and sorted(cnt1.values()) == sorted(cnt2.values())


    """1660. Correct a Binary Tree (Medium)
    You have a binary tree with a small defect. There is exactly one invalid
    node where its right child incorrectly points to another node at the same
    depth but to the invalid node's right. Given the root of the binary tree
    with this defect, root, return the root of the binary tree after removing
    this invalid node and every node underneath it (minus the node it
    incorrectly points to).

    Custom testing:
    The test input is read as 3 lines:
    * TreeNode root
    * int fromNode (not available to correctBinaryTree)
    * int toNode (not available to correctBinaryTree)
    After the binary tree rooted at root is parsed, the TreeNode with value of
    fromNode will have its right child pointer pointing to the TreeNode with a
    value of toNode. Then, root is passed to correctBinaryTree.

    Example 1:
    Input: root = [1,2,3], fromNode = 2, toNode = 3
    Output: [1,null,3]
    Explanation: The node with value 2 is invalid, so remove it.

    Example 2:
    Input: root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4
    Output: [8,3,1,null,null,9,4,null,null,5,6]
    Explanation: The node with value 7 is invalid, so remove it and the node underneath it, node 2.

    Constraints:
    * The number of nodes in the tree is in the range [3, 10^4].
    * -10^9 <= Node.val <= 10^9
    * All Node.val are unique.
    * fromNode != toNode
    * fromNode and toNode will exist in the tree and will be on the same depth.
    * toNode is to the right of fromNode.
    * fromNode.right is null in the initial tree from the test data."""

    def correctBinaryTree(self, root: TreeNode) -> TreeNode:
        queue = [(root, None)]
        seen = set()
        for node, prev in queue:
            if node.right and node.right.val in seen:
                if node == prev.left: prev.left = None
                if node == prev.right: prev.right = None
                return root
            seen.add(node.val)
            if node.right: queue.append((node.right, node))
            if node.left: queue.append((node.left, node))


    """1662. Check If Two String Arrays are Equivalent (Easy)
    Given two string arrays word1 and word2, return true if the two arrays
    represent the same string, and false otherwise. A string is represented by
    an array if the array elements concatenated in order forms the string.

    Example 1:
    Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
    Output: true
    Explanation: word1 represents string "ab" + "c" -> "abc"
                 word2 represents string "a" + "bc" -> "abc"
                 The strings are the same, so return true.

    Example 2:
    Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
    Output: false

    Example 3:
    Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
    Output: true

    Constraints:
    * 1 <= word1.length, word2.length <= 10^3
    * 1 <= word1[i].length, word2[i].length <= 10^3
    * 1 <= sum(word1[i].length), sum(word2[i].length) <= 10^3
    * word1[i] and word2[i] consist of lowercase letters."""

    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        return "".join(word1) == "".join(word2)


    """1663. Smallest String With A Given Numeric Value (Medium)
    The numeric value of a lowercase character is defined as its position
    (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric
    value of b is 2, the numeric value of c is 3, and so on. The numeric value
    of a string consisting of lowercase characters is defined as the sum of its
    characters' numeric values. For example, the numeric value of the string
    "abe" is equal to 1 + 2 + 5 = 8. You are given two integers n and k. Return
    the lexicographically smallest string with length equal to n and numeric
    value equal to k. Note that a string x is lexicographically smaller than
    string y if x comes before y in dictionary order, that is, either x is a
    prefix of y, or if i is the first position such that x[i] != y[i], then
    x[i] comes before y[i] in alphabetic order.

    Example 1:
    Input: n = 3, k = 27
    Output: "aay"
    Explanation: The numeric value of the string is 1 + 1 + 25 = 27, and it is
                 the smallest string with such a value and length equal to 3.

    Example 2:
    Input: n = 5, k = 73
    Output: "aaszz"

    Constraints:
    * 1 <= n <= 10^5
    * n <= k <= 26 * n"""

    def getSmallestString(self, n: int, k: int) -> str:
        ans = []
        for i in range(n):
            val = max(1, k - (n-i-1)*26)
            ans.append(chr(val + 96))
            k -= val
        return "".join(ans)


    """1664. Ways to Make a Fair Array (Medium)
    You are given an integer array nums. You can choose exactly one index
    (0-indexed) and remove the element. Notice that the index of the elements
    may change after the removal. For example, if nums = [6,1,7,4,1]:
    * Choosing to remove index 1 results in nums = [6,7,4,1].
    * Choosing to remove index 2 results in nums = [6,1,4,1].
    * Choosing to remove index 4 results in nums = [6,1,7,4].
    An array is fair if the sum of the odd-indexed values equals the sum of the
    even-indexed values. Return the number of indices that you could choose
    such that after the removal, nums is fair.

    Example 1:
    Input: nums = [2,1,6,4]
    Output: 1
    Explanation:
    Remove index 0: [1,6,4] -> Even sum: 1 + 4 = 5. Odd sum: 6. Not fair.
    Remove index 1: [2,6,4] -> Even sum: 2 + 4 = 6. Odd sum: 6. Fair.
    Remove index 2: [2,1,4] -> Even sum: 2 + 4 = 6. Odd sum: 1. Not fair.
    Remove index 3: [2,1,6] -> Even sum: 2 + 6 = 8. Odd sum: 1. Not fair.
    There is 1 index that you can remove to make nums fair.

    Example 2:
    Input: nums = [1,1,1]
    Output: 3
    Explanation: You can remove any index and the remaining array is fair.

    Example 3:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: You cannot make a fair array after removing any index.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^4"""

    def waysToMakeFair(self, nums: List[int]) -> int:
        prefix = [0]*2
        suffix = [sum(nums[::2]), sum(nums[1::2])]

        ans = 0
        for i, x in enumerate(nums):
            suffix[i%2] -= x
            if prefix[0] + suffix[1] == prefix[1] + suffix[0]: ans += 1
            prefix[i%2] += x
        return ans


    """1665. Minimum Initial Energy to Finish Tasks (Hard)
    You are given an array tasks where tasks[i] = [actuali, minimumi]:
    * actuali is the actual amount of energy you spend to finish the ith task.
    * minimumi is the minimum amount of energy you require to begin the ith
      task.
    For example, if the task is [10, 12] and your current energy is 11, you
    cannot start this task. However, if your current energy is 13, you can
    complete this task, and your energy will be 3 after finishing it. You can
    finish the tasks in any order you like. Return the minimum initial amount
    of energy you will need to finish all the tasks.

    Example 1:
    Input: tasks = [[1,2],[2,4],[4,8]]
    Output: 8
    Explanation:
    Starting with 8 energy, we finish the tasks in the following order:
        - 3rd task. Now energy = 8 - 4 = 4.
        - 2nd task. Now energy = 4 - 2 = 2.
        - 1st task. Now energy = 2 - 1 = 1.
    Notice that even though we have leftover energy, starting with 7 energy
    does not work because we cannot do the 3rd task.

    Example 2:
    Input: tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]
    Output: 32
    Explanation:
    Starting with 32 energy, we finish the tasks in the following order:
        - 1st task. Now energy = 32 - 1 = 31.
        - 2nd task. Now energy = 31 - 2 = 29.
        - 3rd task. Now energy = 29 - 10 = 19.
        - 4th task. Now energy = 19 - 10 = 9.
        - 5th task. Now energy = 9 - 8 = 1.

    Example 3:
    Input: tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]
    Output: 27
    Explanation:
    Starting with 27 energy, we finish the tasks in the following order:
        - 5th task. Now energy = 27 - 5 = 22.
        - 2nd task. Now energy = 22 - 2 = 20.
        - 3rd task. Now energy = 20 - 3 = 17.
        - 1st task. Now energy = 17 - 1 = 16.
        - 4th task. Now energy = 16 - 4 = 12.
        - 6th task. Now energy = 12 - 6 = 6.

    Constraints:
    * 1 <= tasks.length <= 10^5
    * 1 <= actuali <= minimumi <= 10^4"""

    def minimumEffort(self, tasks: List[List[int]]) -> int:
        ans = val = 0
        for x, y in sorted(tasks, key=lambda x: x[0]-x[1]):
            if val < y:
                ans += y - val
                val = y
            val -= x
        return ans


    """1666. Change the Root of a Binary Tree (Medium)
    Given the root of a binary tree and a leaf node, reroot the tree so that
    the leaf is the new root. You can reroot the tree with the following steps
    for each node cur on the path starting from the leaf up to the root​​​
    excluding the root:
    * If cur has a left child, then that child becomes cur's right child.
    * cur's original parent becomes cur's left child. Note that in this process
      the original parent's pointer to cur becomes null, making it have at most
      one child.
    Return the new root of the rerooted tree.

    Note: Ensure that your solution sets the Node.parent pointers correctly
          after rerooting or you will receive "Wrong Answer".

    Example 1:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], leaf = 7
    Output: [7,2,null,5,4,3,6,null,null,null,1,null,null,0,8]

    Example 2:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], leaf = 0
    Output: [0,1,null,3,8,5,null,null,null,6,2,null,null,7,4]

    Constraints:
    * The number of nodes in the tree is in the range [2, 100].
    * -10^9 <= Node.val <= 10^9
    * All Node.val are unique.
    * leaf exist in the tree."""

    def flipBinaryTree(self, root: 'Node', leaf: 'Node') -> 'Node':
        prev, node = None, leaf
        while node:
            if node == root:
                if prev == node.right: node.right = None
                else: node.left = None
            else:
                if prev == node.right: node.right = node.left
                node.left = node.parent
            node.parent, node, prev = prev, node.parent, node
        return leaf


    """1668. Maximum Repeating Substring (Easy)
    For a string sequence, a string word is k-repeating if word concatenated k
    times is a substring of sequence. The word's maximum k-repeating value is
    the highest value k where word is k-repeating in sequence. If word is not a
    substring of sequence, word's maximum k-repeating value is 0. Given strings
    sequence and word, return the maximum k-repeating value of word in sequence.

    Example 1:
    Input: sequence = "ababc", word = "ab"
    Output: 2
    Explanation: "abab" is a substring in "ababc".

    Example 2:
    Input: sequence = "ababc", word = "ba"
    Output: 1
    Explanation: "ba" is a substring in "ababc". "baba" is not a substring in
                 "ababc".

    Example 3:
    Input: sequence = "ababc", word = "ac"
    Output: 0
    Explanation: "ac" is not a substring in "ababc".

    Constraints:
    * 1 <= sequence.length <= 100
    * 1 <= word.length <= 100
    * sequence and word contains only lowercase English letters."""

    def maxRepeating(self, sequence: str, word: str) -> int:
        if len(sequence) < len(word): return 0 # edge case

        pattern = word * (len(sequence)//len(word))
        lps = [0] # longest proper prefix also suffix (KMP)
        k = 0
        for i in range(1, len(pattern)):
            while k and pattern[k] != pattern[i]: k = lps[k-1]
            if pattern[i] == pattern[k]: k += 1
            lps.append(k)

        ans = k = 0
        for i in range(len(sequence)):
            while k and pattern[k] != sequence[i]: k = lps[k-1]
            if pattern[k] == sequence[i]: k += 1
            ans = max(ans, k//len(word))
            if k == len(pattern): return ans
        return ans


    """1669. Merge In Between Linked Lists (Medium)
    You are given two linked lists: list1 and list2 of sizes n and m
    respectively. Remove list1's nodes from the ath node to the bth node, and
    put list2 in their place. Build the result list and return its head.

    Example 1:
    Input: list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
    Output: [0,1,2,1000000,1000001,1000002,5]
    Explanation: We remove the nodes 3 and 4 and put the entire list2 in their
                 place. The blue edges and nodes in the above figure indicate
                 the result.

    Example 2:
    Input: list1 = [0,1,2,3,4,5,6], a = 2, b = 5,
           list2 = [1000000,1000001,1000002,1000003,1000004]
    Output: [0,1,1000000,1000001,1000002,1000003,1000004,6]
    Explanation: The blue edges and nodes in the above figure indicate the result.

    Constraints:
    * 3 <= list1.length <= 10^4
    * 1 <= a <= b < list1.length - 1
    * 1 <= list2.length <= 10^4"""

    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:
        node = list1
        for k in range(b+1):
            if k == a-1: start = node
            node = node.next
        end = node

        start.next = node = list2
        while node.next: node = node.next
        node.next = end
        return list1


    """1671. Minimum Number of Removals to Make Mountain Array (Hard)
    You may recall that an array arr is a mountain array if and only if:
    * arr.length >= 3
    * There exists some index i (0-indexed) with 0 < i < arr.length - 1 such
      that:
      + arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
      + arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
    Given an integer array nums, return the minimum number of elements to
    remove to make nums a mountain array.

    Example 1:
    Input: nums = [1,3,1]
    Output: 0
    Explanation: The array itself is a mountain array so we do not need to
                 remove any elements.

    Example 2:
    Input: nums = [2,1,1,5,6,2,3,1]
    Output: 3
    Explanation: One solution is to remove the elements at indices 0, 1, and 5,
                 making the array nums = [1,5,6,3,1].

    Example 3:
    Input: nums = [4,3,2,1,1,2,3,1]
    Output: 4

    Example 4:
    Input: nums = [1,2,3,4,4,3,2,1]
    Output: 1

    Constraints:
    * 3 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^9
    * It is guaranteed that you can make a mountain array out of nums."""

    def minimumMountainRemovals(self, nums: List[int]) -> int:

        def fn(nums):
            """Return length of LIS (excluding x) ending at x."""
            ans, vals = [], []
            for i, x in enumerate(nums):
                k = bisect_left(vals, x)
                if k == len(vals): vals.append(x)
                else: vals[k] = x
                ans.append(k)
            return ans

        left, right = fn(nums), fn(nums[::-1])[::-1]

        ans = inf
        for i in range(1, len(nums)-1):
            if left[i] and right[i]:
                ans = min(ans, len(nums) - left[i] - right[i] - 1)
        return ans


    """1672. Richest Customer Wealth (Easy)
    You are given an m x n integer grid accounts where accounts[i][j] is the
    amount of money the ith customer has in the jth bank. Return the wealth
    that the richest customer has. A customer's wealth is the amount of money
    they have in all their bank accounts. The richest customer is the customer
    that has the maximum wealth.

    Example 1:
    Input: accounts = [[1,2,3],[3,2,1]]
    Output: 6
    Explanation:
    1st customer has wealth = 1 + 2 + 3 = 6
    2nd customer has wealth = 3 + 2 + 1 = 6
    Both customers are considered the richest with a wealth of 6 each, so return 6.

    Example 2:
    Input: accounts = [[1,5],[7,3],[3,5]]
    Output: 10
    Explanation:
    1st customer has wealth = 6
    2nd customer has wealth = 10
    3rd customer has wealth = 8
    The 2nd customer is the richest with a wealth of 10.

    Example 3:
    Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]
    Output: 17

    Constraints:
    * m == accounts.length
    * n == accounts[i].length
    * 1 <= m, n <= 50
    * 1 <= accounts[i][j] <= 100"""

    def maximumWealth(self, accounts: List[List[int]]) -> int:
        return max(map(sum, accounts))


    """1673. Find the Most Competitive Subsequence (Medium)
    Given an integer array nums and a positive integer k, return the most
    competitive subsequence of nums of size k. An array's subsequence is a
    resulting sequence obtained by erasing some (possibly zero) elements from
    the array. We define that a subsequence a is more competitive than a
    subsequence b (of the same length) if in the first position where a and b
    differ, subsequence a has a number less than the corresponding number in b.
    For example, [1,3,4] is more competitive than [1,3,5] because the first
    position they differ is at the final number, and 4 is less than 5.

    Example 1:
    Input: nums = [3,5,2,6], k = 2
    Output: [2,6]
    Explanation: Among the set of every possible subsequence:
                 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most
                 competitive.

    Example 2:
    Input: nums = [2,4,3,3,5,4,9,6], k = 4
    Output: [2,3,3,4]

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 1 <= k <= nums.length"""

    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:
        stack = [] # (increasing) mono-stack
        for i, x in enumerate(nums):
            while stack and stack[-1] > x and len(stack) + len(nums) - i > k: stack.pop()
            if len(stack) < k: stack.append(x)
        return stack


    """1674. Minimum Moves to Make Array Complementary (Medium)
    You are given an integer array nums of even length n and an integer limit.
    In one move, you can replace any integer from nums with another integer
    between 1 and limit, inclusive. The array nums is complementary if for all
    indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number.
    For example, the array [1,2,3,4] is complementary because for all indices i,
    nums[i] + nums[n - 1 - i] = 5. Return the minimum number of moves required
    to make nums complementary.

    Example 1:
    Input: nums = [1,2,4,3], limit = 4
    Output: 1
    Explanation: In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed).
    nums[0] + nums[3] = 1 + 3 = 4.
    nums[1] + nums[2] = 2 + 2 = 4.
    nums[2] + nums[1] = 2 + 2 = 4.
    nums[3] + nums[0] = 3 + 1 = 4.
    Therefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary.

    Example 2:
    Input: nums = [1,2,2,1], limit = 2
    Output: 2
    Explanation: In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit.

    Example 3:
    Input: nums = [1,2,1,2], limit = 2
    Output: 0
    Explanation: nums is already complementary.

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^5
    * 1 <= nums[i] <= limit <= 10^5
    * n is even."""

    def minMoves(self, nums: List[int], limit: int) -> int:
        diff = [0]*(2*limit+2) # difference array

        for i in range(len(nums)//2):
            m = min(nums[i], nums[~i]) + 1 # lower bound
            diff[m] += -1
            x = nums[i] + nums[~i]
            diff[x] += -1
            diff[x+1] += 1
            M = max(nums[i], nums[~i]) + 1 + limit # upper bound
            diff[M] += 1

        for i in range(1, len(diff)): diff[i] += diff[i-1] # prefix sum
        return len(nums) + min(diff)


    """1675. Minimize Deviation in Array (Hard)
    You are given an array nums of n positive integers. You can perform two
    types of operations on any element of the array any number of times:

    * If the element is even, divide it by 2.
      + For example, if the array is [1,2,3,4], then you can do this operation
        on the last element, and the array will be [1,2,3,2].
    * If the element is odd, multiply it by 2.
      + For example, if the array is [1,2,3,4], then you can do this operation
        on the first element, and the array will be [2,2,3,4].
    The deviation of the array is the maximum difference between any two
    elements in the array. Return the minimum deviation the array can have
    after performing some number of operations.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 1
    Explanation: You can transform the array to [1,2,3,2], then to [2,2,3,2],
                 then the deviation will be 3 - 2 = 1.

    Example 2:
    Input: nums = [4,1,5,20,3]
    Output: 3
    Explanation: You can transform the array after two operations to [4,2,5,5,3],
                 then the deviation will be 5 - 2 = 3.

    Example 3:
    Input: nums = [2,10,8]
    Output: 3

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def minimumDeviation(self, nums: List[int]) -> int:
        pq = [-2*x if x&1 else -x for x in nums]
        heapify(pq)
        most = max(pq)
        ans = most - pq[0]
        while pq[0] & 1 == 0:
            x = heappop(pq)//2
            heappush(pq, x)
            most = max(most, x)
            ans = min(ans, most - pq[0])
        return ans


    """1676. Lowest Common Ancestor of a Binary Tree IV (Medium)
    Given the root of a binary tree and an array of TreeNode objects nodes,
    return the lowest common ancestor (LCA) of all the nodes in nodes. All the
    nodes will exist in the tree, and all values of the tree's nodes are unique.
    Extending the definition of LCA on Wikipedia: "The lowest common ancestor
    of n nodes p1, p2, ..., pn in a binary tree T is the lowest node that has
    every pi as a descendant (where we allow a node to be a descendant of
    itself) for every valid i". A descendant of a node x is a node y that is on
    the path from node x to some leaf node.

    Example 1:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [4,7]
    Output: 2
    Explanation: The lowest common ancestor of nodes 4 and 7 is node 2.

    Example 2:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [1]
    Output: 1
    Explanation: The lowest common ancestor of a single node is the node itself.

    Example 3:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [7,6,2,4]
    Output: 5
    Explanation: The lowest common ancestor of the nodes 7, 6, 2, and 4 is node 5.

    Example 4:
    Input: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [0,1,2,3,4,5,6,7,8]
    Output: 3
    Explanation: The lowest common ancestor of all the nodes is the root node.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -10^9 <= Node.val <= 10^9
    * All Node.val are unique.
    * All nodes[i] will exist in the tree.
    * All nodes[i] are distinct."""

    def lowestCommonAncestor(self, root: 'TreeNode', nodes: 'List[TreeNode]') -> 'TreeNode':
        nodes = set(nodes)

        @cache
        def fn(node):
            if not node: return # edge case
            if node in nodes or fn(node.left) and fn(node.right): return node
            return fn(node.left) or fn(node.right)

        return fn(root)


    """1678. Goal Parser Interpretation (Easy)
    You own a Goal Parser that can interpret a string command. The command
    consists of an alphabet of "G", "()" and/or "(al)" in some order. The Goal
    Parser will interpret "G" as the string "G", "()" as the string "o", and
    "(al)" as the string "al". The interpreted strings are then concatenated in
    the original order. Given the string command, return the Goal Parser's
    interpretation of command.

    Example 1:
    Input: command = "G()(al)"
    Output: "Goal"
    Explanation: The Goal Parser interprets the command as follows:
    G -> G
    () -> o
    (al) -> al
    The final concatenated result is "Goal".

    Example 2:
    Input: command = "G()()()()(al)"
    Output: "Gooooal"

    Example 3:
    Input: command = "(al)G(al)()()G"
    Output: "alGalooG"

    Constraints:
    * 1 <= command.length <= 100
    * command consists of "G", "()", and/or "(al)" in some order."""

    def interpret(self, command: str) -> str:
        return command.replace("()", "o").replace("(al)", "al")


    """1679. Max Number of K-Sum Pairs (Medium)
    You are given an integer array nums and an integer k. In one operation, you
    can pick two numbers from the array whose sum equals k and remove them from
    the array. Return the maximum number of operations you can perform on the
    array.

    Example 1:
    Input: nums = [1,2,3,4], k = 5
    Output: 2
    Explanation: Starting with nums = [1,2,3,4]:
    - Remove numbers 1 and 4, then nums = [2,3]
    - Remove numbers 2 and 3, then nums = []
    There are no more pairs that sum up to 5, hence a total of 2 operations.

    Example 2:
    Input: nums = [3,1,3,4,3], k = 6
    Output: 1
    Explanation: Starting with nums = [3,1,3,4,3]:
    - Remove the first two 3's, then nums = [1,4,3]
    There are no more pairs that sum up to 6, hence a total of 1 operation.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9"""

    def maxOperations(self, nums: List[int], k: int) -> int:
        freq = {}
        for x in nums: freq[x] = 1 + freq.get(x, 0)

        ans = 0
        for x, v in freq.items():
            if k - x in freq:
                if x == k - x: ans += freq[x]//2
                elif x < k - x: ans += min(freq[x], freq[k-x])
        return ans


    """1680. Concatenation of Consecutive Binary Numbers (Medium)
    Given an integer n, return the decimal value of the binary string formed by
    concatenating the binary representations of 1 to n in order, modulo 10^9 + 7.

    Example 1:
    Input: n = 1
    Output: 1
    Explanation: "1" in binary corresponds to the decimal value 1.

    Example 2:
    Input: n = 3
    Output: 27
    Explanation: In binary, 1, 2, and 3 corresponds to "1", "10", and "11".
                 After concatenating them, we have "11011", which corresponds
                 to the decimal value 27.

    Example 3:
    Input: n = 12
    Output: 505379714
    Explanation: The concatenation results in "1101110010111011110001001101010111100".
                 The decimal value of that is 118505380540. After modulo 10^9 + 7,
                 the result is 505379714.

    Constraints: 1 <= n <= 10^5"""

    def concatenatedBinary(self, n: int) -> int:
        ans = k = 0
        for x in range(1, n+1):
            if not x & x-1: k += 1
            ans = ((ans << k) + x) % 1_000_000_007
        return ans


    """1682. Longest Palindromic Subsequence II (Medium)
    A subsequence of a string s is considered a good palindromic subsequence if:
    * It is a subsequence of s.
    * It is a palindrome (has the same value if reversed).
    * It has an even length.
    * No two consecutive characters are equal, except the two middle ones.
    For example, if s = "abcabcabb", then "abba" is considered a good palindromic
    subsequence, while "bcb" (not even length) and "bbbb" (has equal consecutive
    characters) are not. Given a string s, return the length of the longest good
    palindromic subsequence in s.

    Example 1:
    Input: s = "bbabab"
    Output: 4
    Explanation: The longest good palindromic subsequence of s is "baab".

    Example 2:
    Input: s = "dcbccacdb"
    Output: 4
    Explanation: The longest good palindromic subsequence of s is "dccd".

    Constraints:
    * 1 <= s.length <= 250
    * s consists of lowercase English letters."""

    def longestPalindromeSubseq(self, s: str) -> int:
        dp = [[[0]*27 for _ in s] for _ in s] # n x n x 27

        for i in reversed(range(len(s))):
            for j in range(i+1, len(s)):
                for k in range(27):
                    if s[i] == s[j] != chr(k+96):
                        dp[i][j][k] = 2 + dp[i+1][j-1][ord(s[i])-96]
                    else:
                        dp[i][j][k] = max(dp[i+1][j][k], dp[i][j-1][k])
        return dp[0][-1][0]


    """1684. Count the Number of Consistent Strings (Easy)
    You are given a string allowed consisting of distinct characters and an
    array of strings words. A string is consistent if all characters in the
    string appear in the string allowed. Return the number of consistent
    strings in the array words.

    Example 1:
    Input: allowed = "ab", words = ["ad","bd","aaab","baa","badab"]
    Output: 2
    Explanation: Strings "aaab" and "baa" are consistent since they only
                 contain characters 'a' and 'b'.

    Example 2:
    Input: allowed = "abc", words = ["a","b","c","ab","ac","bc","abc"]
    Output: 7
    Explanation: All strings are consistent.

    Example 3:
    Input: allowed = "cad", words = ["cc","acd","b","ba","bac","bad","ac","d"]
    Output: 4
    Explanation: Strings "cc", "acd", "ac", and "d" are consistent.

    Constraints:
    * 1 <= words.length <= 10^4
    * 1 <= allowed.length <= 26
    * 1 <= words[i].length <= 10
    * The characters in allowed are distinct.
    * words[i] and allowed contain only lowercase English letters."""

    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        return sum(all(c in allowed for c in word) for word in words)


    """1687. Delivering Boxes from Storage to Ports (Hard)
    You have the task of delivering some boxes from storage to their ports
    using only one ship. However, this ship has a limit on the number of boxes
    and the total weight that it can carry. You are given an array boxes, where
    boxes[i] = [portsi, weighti], and three integers portsCount, maxBoxes, and
    maxWeight.
    * portsi is the port where you need to deliver the ith box and weightsi is
      the weight of the ith box.
    * portsCount is the number of ports.
    * maxBoxes and maxWeight are the respective box and weight limits of the
      ship.
    The boxes need to be delivered in the order they are given. The ship will
    follow these steps:
    * The ship will take some number of boxes from the boxes queue, not
      violating the maxBoxes and maxWeight constraints.
    * For each loaded box in order, the ship will make a trip to the port the
      box needs to be delivered to and deliver it. If the ship is already at
      the correct port, no trip is needed, and the box can immediately be
      delivered.
    * The ship then makes a return trip to storage to take more boxes from the
      queue.
    The ship must end at storage after all the boxes have been delivered.
    Return the minimum number of trips the ship needs to make to deliver all
    boxes to their respective ports.

    Example 1:
    Input: boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
    Output: 4
    Explanation: The optimal strategy is as follows:
                 - The ship takes all the boxes in the queue, goes to port 1,
                   then port 2, then port 1 again, then returns to storage. 4
                   trips.
                 So the total number of trips is 4. Note that the first and
                 third boxes cannot be delivered together because the boxes
                 need to be delivered in order (i.e. the second box needs to be
                 delivered at port 2 before the third box).

    Example 2:
    Input: boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
    Output: 6
    Explanation: The optimal strategy is as follows:
                 - The ship takes the first box, goes to port 1, then returns
                   to storage. 2 trips.
                 - The ship takes the second, third and fourth boxes, goes to
                   port 3, then returns to storage. 2 trips.
                 - The ship takes the fifth box, goes to port 3, then returns
                   to storage. 2 trips.
                 So the total number of trips is 2 + 2 + 2 = 6.

    Example 3:
    Input: boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
    Output: 6
    Explanation: The optimal strategy is as follows:
                 - The ship takes the first and second boxes, goes to port 1,
                   then returns to storage. 2 trips.
                 - The ship takes the third and fourth boxes, goes to port 2,
                   then returns to storage. 2 trips.
                 - The ship takes the fifth and sixth boxes, goes to port 3,
                   then returns to storage. 2 trips.
                 So the total number of trips is 2 + 2 + 2 = 6.

    Example 4:
    Input: boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7
    Output: 14
    Explanation: The optimal strategy is as follows:
                 - The ship takes the first box, goes to port 2, then storage.
                   2 trips.
                 - The ship takes the second box, goes to port 2, then storage.
                   2 trips.
                 - The ship takes the third and fourth boxes, goes to port 3,
                   then storage. 2 trips.
                 - The ship takes the fifth box, goes to port 3, then storage.
                   2 trips.
                 - The ship takes the sixth and seventh boxes, goes to port 3,
                   then port 4, then storage. 3 trips.
                 - The ship takes the eighth and ninth boxes, goes to port 1,
                   then port 5, then storage. 3 trips.
                 So the total number of trips is 2 + 2 + 2 + 2 + 3 + 3 = 14.

    Constraints:
    * 1 <= boxes.length <= 10^5
    * 1 <= portsCount, maxBoxes, maxWeight <= 10^5
    * 1 <= portsi <= portsCount
    * 1 <= weightsi <= maxWeight"""

    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:
        dp = [0] + [inf]*len(boxes)
        trips = 2
        ii = 0
        for i in range(len(boxes)):
            maxWeight -= boxes[i][1]
            if i and boxes[i-1][0] != boxes[i][0]: trips += 1
            while maxBoxes < i - ii + 1 or maxWeight < 0 or ii < i and dp[ii] == dp[ii+1]:
                maxWeight += boxes[ii][1]
                if boxes[ii][0] != boxes[ii+1][0]: trips-=1
                ii += 1
            dp[i+1] = dp[ii] + trips
        return dp[-1]


    """1688. Count of Matches in Tournament (Easy)
    You are given an integer n, the number of teams in a tournament that has
    strange rules:
    * If the current number of teams is even, each team gets paired with another
      team. A total of n / 2 matches are played, and n / 2 teams advance to the
      next round.
    * If the current number of teams is odd, one team randomly advances in the
      tournament, and the rest gets paired. A total of (n - 1) / 2 matches are
      played, and (n - 1) / 2 + 1 teams advance to the next round.
    Return the number of matches played in the tournament until a winner is
    decided.

    Example 1:
    Input: n = 7
    Output: 6
    Explanation: Details of the tournament:
    - 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
    - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
    - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
    Total number of matches = 3 + 2 + 1 = 6.

    Example 2:
    Input: n = 14
    Output: 13
    Explanation: Details of the tournament:
    - 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
    - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
    - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
    - 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
    Total number of matches = 7 + 3 + 2 + 1 = 13.

    Constraints: 1 <= n <= 200"""

    def numberOfMatches(self, n: int) -> int:
        return n-1


    """1689. Partitioning Into Minimum Number Of Deci-Binary Numbers (Medium)
    A decimal number is called deci-binary if each of its digits is either 0 or
    1 without any leading zeros. For example, 101 and 1100 are deci-binary,
    while 112 and 3001 are not. Given a string n that represents a positive
    decimal integer, return the minimum number of positive deci-binary numbers
    needed so that they sum up to n.

    Example 1:
    Input: n = "32"
    Output: 3
    Explanation: 10 + 11 + 11 = 32

    Example 2:
    Input: n = "82734"
    Output: 8

    Example 3:
    Input: n = "27346209830709182346"
    Output: 9

    Constraints:
    * 1 <= n.length <= 10^5
    * n consists of only digits.
    * n does not contain any leading zeros and represents a positive integer."""

    def minPartitions(self, n: str) -> int:
        return int(max(n))


    """1690. Stone Game VII (Medium)
    Alice and Bob take turns playing a game, with Alice starting first. There
    are n stones arranged in a row. On each player's turn, they can remove
    either the leftmost stone or the rightmost stone from the row and receive
    points equal to the sum of the remaining stones' values in the row. The
    winner is the one with the higher score when there are no stones left to
    remove. Bob found that he will always lose this game (poor Bob, he always
    loses), so he decided to minimize the score's difference. Alice's goal is
    to maximize the difference in the score. Given an array of integers stones
    where stones[i] represents the value of the ith stone from the left, return
    the difference in Alice and Bob's score if they both play optimally.

    Example 1:
    Input: stones = [5,3,1,4,2]
    Output: 6
    Explanation:
    - Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = [5,3,1,4].
    - Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = [3,1,4].
    - Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = [1,4].
    - Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = [4].
    - Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = [].
    The score difference is 18 - 12 = 6.

    Example 2:
    Input: stones = [7,90,5,1,100,10,10,2]
    Output: 122

    Constraints:
    * n == stones.length
    * 2 <= n <= 1000
    * 1 <= stones[i] <= 1000"""

    def stoneGameVII(self, stones: List[int]) -> int:
        prefix = [0]
        for x in stones: prefix.append(prefix[-1] + x)

        n = len(stones)
        dp = [[0]*n for _ in range(n)]
        for i in reversed(range(n)):
            for j in range(i+1, n):
                dp[i][j] = max(prefix[j+1] - prefix[i+1] - dp[i+1][j], prefix[j] - prefix[i] - dp[i][j-1])
        return dp[0][-1]


    """1691. Maximum Height by Stacking Cuboids (Hard)
    Given n cuboids where the dimensions of the ith cuboid is
    cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of
    cuboids and place them on each other. You can place cuboid i on cuboid j if
    widthi <= widthj and lengthi <= lengthj and heighti <= heightj. You can
    rearrange any cuboid's dimensions by rotating it to put it on another
    cuboid. Return the maximum height of the stacked cuboids.

    Example 1:
    Input: cuboids = [[50,45,20],[95,37,53],[45,23,12]]
    Output: 190
    Explanation:
    Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.
    Cuboid 0 is placed next with the 45x20 side facing down with height 50.
    Cuboid 2 is placed next with the 23x12 side facing down with height 45.
    The total height is 95 + 50 + 45 = 190.

    Example 2:
    Input: cuboids = [[38,25,45],[76,35,3]]
    Output: 76
    Explanation:
    You can't place any of the cuboids on the other.
    We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.

    Example 3:
    Input: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
    Output: 102
    Explanation:
    After rearranging the cuboids, you can see that all cuboids have the same dimension.
    You can place the 11x7 side down on all cuboids so their heights are 17.
    The maximum height of stacked cuboids is 6 * 17 = 102.

    Constraints:
    * n == cuboids.length
    * 1 <= n <= 100
    * 1 <= widthi, lengthi, heighti <= 100"""

    def maxHeight(self, cuboids: List[List[int]]) -> int:
        cuboids = sorted((sorted(x, reverse=True) for x in cuboids), reverse=True)

        @cache
        def fn(i, h, l, w):
            """Return max heights of stacking cuboids[i:]."""
            if i == len(cuboids): return 0 # no cuboids left
            hi, li, wi = cuboids[i]
            if hi <= h and li <= l and wi <= w:
                return max(hi + fn(i+1, hi, li, wi), fn(i+1, h, l, w))
            else:
                return fn(i+1, h, l, w)

        return fn(0, inf, inf, inf)


    """1692. Count Ways to Distribute Candies (Hard)
    There are n unique candies (labeled 1 through n) and k bags. You are asked
    to distribute all the candies into the bags such that every bag has at
    least one candy. There can be multiple ways to distribute the candies. Two
    ways are considered different if the candies in one bag in the first way
    are not all in the same bag in the second way. The order of the bags and
    the order of the candies within each bag do not matter. For example, (1),
    (2,3) and (2), (1,3) are considered different because candies 2 and 3 in
    the bag (2,3) in the first way are not in the same bag in the second way
    (they are split between the bags (2) and (1,3)). However, (1), (2,3) and
    (3,2), (1) are considered the same because the candies in each bag are all
    in the same bags in both ways. Given two integers, n and k, return the
    number of different ways to distribute the candies. As the answer may be
    too large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, k = 2
    Output: 3
    Explanation: You can distribute 3 candies into 2 bags in 3 ways:
                 (1), (2,3)
                 (1,2), (3)
                 (1,3), (2)

    Example 2:
    Input: n = 4, k = 2
    Output: 7
    Explanation: You can distribute 4 candies into 2 bags in 7 ways:
                 (1), (2,3,4)
                 (1,2), (3,4)
                 (1,3), (2,4)
                 (1,4), (2,3)
                 (1,2,3), (4)
                 (1,2,4), (3)
                 (1,3,4), (2)

    Example 3:
    Input: n = 20, k = 5
    Output: 206085257
    Explanation: You can distribute 20 candies into 5 bags in 1881780996 ways.
                 1881780996 modulo 10^9 + 7 = 206085257.

    Constraints: 1 <= k <= n <= 1000"""

    def waysToDistribute(self, n: int, k: int) -> int:
        dp = [[0]*(k+2) for _ in range(n+1)]
        dp[n][k] = 1
        for i in range(n-1, -1, -1):
            for j in range(k, max(0, k-n+i)-1, -1):
                dp[i][j] = (j*dp[i+1][j] + dp[i+1][j+1]) % 1_000_000_007
        return dp[0][0]


    """1694. Reformat Phone Number (Easy)
    You are given a phone number as a string number. number consists of digits,
    spaces ' ', and/or dashes '-'. You would like to reformat the phone number
    in a certain manner. Firstly, remove all spaces and dashes. Then, group the
    digits from left to right into blocks of length 3 until there are 4 or fewer
    digits. The final digits are then grouped as follows:
    * 2 digits: A single block of length 2.
    * 3 digits: A single block of length 3.
    * 4 digits: Two blocks of length 2 each.
    The blocks are then joined by dashes. Notice that the reformatting process
    should never produce any blocks of length 1 and produce at most two blocks
    of length 2. Return the phone number after formatting.

    Example 1:
    Input: number = "1-23-45 6"
    Output: "123-456"
    Explanation: The digits are "123456".
    Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is "123".
    Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is "456".
    Joining the blocks gives "123-456".

    Example 2:
    Input: number = "123 4-567"
    Output: "123-45-67"
    Explanation: The digits are "1234567".
    Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is "123".
    Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are "45" and "67".
    Joining the blocks gives "123-45-67".

    Example 3:
    Input: number = "123 4-5678"
    Output: "123-456-78"
    Explanation: The digits are "12345678".
    Step 1: The 1st block is "123".
    Step 2: The 2nd block is "456".
    Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is "78".
    Joining the blocks gives "123-456-78".

    Example 4:
    Input: number = "12"
    Output: "12"

    Example 5:
    Input: number = "--17-5 229 35-39475 "
    Output: "175-229-353-94-75"

    Constraints:
    * 2 <= number.length <= 100
    * number consists of digits and the characters '-' and ' '.
    * There are at least two digits in number."""

    def reformatNumber(self, number: str) -> str:
        number = number.replace("-", "").replace(" ", "") # replacing - and space
        ans = []
        for i in range(0, len(number), 3):
            if len(number) - i != 4: ans.append(number[i:i+3])
            else:
                ans.extend([number[i:i+2], number[i+2:]])
                break
        return "-".join(ans)


    """1695. Maximum Erasure Value (Medium)
    You are given an array of positive integers nums and want to erase a
    subarray containing unique elements. The score you get by erasing the
    subarray is equal to the sum of its elements. Return the maximum score you
    can get by erasing exactly one subarray. An array b is called to be a
    subarray of a if it forms a contiguous subsequence of a, that is, if it is
    equal to a[l],a[l+1],...,a[r] for some (l,r).

    Example 1:
    Input: nums = [4,2,4,5,6]
    Output: 17
    Explanation: The optimal subarray here is [2,4,5,6].

    Example 2:
    Input: nums = [5,2,1,2,5,2,1,2,5]
    Output: 8
    Explanation: The optimal subarray here is [5,2,1] or [1,2,5].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^4"""

    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        ans = ii = val = 0
        for x in nums:
            val += x
            freq[x] += 1
            while freq[x] > 1:
                val -= nums[ii]
                freq[nums[ii]] -= 1
                ii += 1
            ans = max(ans, val)
        return ans


    """1696. Jump Game VI (Medium)
    You are given a 0-indexed integer array nums and an integer k. You are
    initially standing at index 0. In one move, you can jump at most k steps
    forward without going outside the boundaries of the array. That is, you can
    jump from index i to any index in the range [i + 1, min(n - 1, i + k)]
    inclusive. You want to reach the last index of the array (index n - 1).
    Your score is the sum of all nums[j] for each index j you visited in the
    array. Return the maximum score you can get.

    Example 1:
    Input: nums = [1,-1,-2,4,-7,3], k = 2
    Output: 7
    Explanation: You can choose your jumps forming the subsequence [1,-1,4,3]
                 (underlined above). The sum is 7.

    Example 2:
    Input: nums = [10,-5,-2,4,0,3], k = 3
    Output: 17
    Explanation: You can choose your jumps forming the subsequence [10,4,3]
                 (underlined above). The sum is 17.

    Example 3:
    Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2
    Output: 0

    Constraints:
    * 1 <= nums.length, k <= 10^5
    * -10^4 <= nums[i] <= 10^4"""

    def maxResult(self, nums: List[int], k: int) -> int:
        queue = deque()
        for i in reversed(range(len(nums))):
            while queue and queue[0][1] - i > k: queue.popleft()
            ans = nums[i]
            if queue: ans += queue[0][0]
            while queue and queue[-1][0] <= ans: queue.pop()
            queue.append((ans, i))
        return ans


    """1697. Checking Existence of Edge Length Limited Paths (Hard)
    An undirected graph of n nodes is defined by edgeList, where
    edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with
    distance disi. Note that there may be multiple edges between two nodes.
    Given an array queries, where queries[j] = [pj, qj, limitj], your task is
    to determine for each queries[j] whether there is a path between pj and qj
    such that each edge on the path has a distance strictly less than limitj.
    Return a boolean array answer, where answer.length == queries.length and
    the jth value of answer is true if there is a path for queries[j] is true,
    and false otherwise.

    Example 1:
    Input: n = 3,
           edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]],
           queries = [[0,1,2],[0,2,5]]
    Output: [false,true]
    Explanation: The above figure shows the given graph. Note that there are
                 two overlapping edges between 0 and 1 with distances 2 and 16.
                 For the first query, between 0 and 1 there is no path where
                 each distance is less than 2, thus we return false for this
                 query. For the second query, there is a path (0 -> 1 -> 2) of
                 two edges with distances less than 5, thus we return true for
                 this query.

    Example 2:
    Input: n = 5,
           edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]],
           queries = [[0,4,14],[1,4,13]]
    Output: [true,false]
    Exaplanation: The above figure shows the given graph.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= edgeList.length, queries.length <= 10^5
    * edgeList[i].length == 3
    * queries[j].length == 3
    * 0 <= ui, vi, pj, qj <= n - 1
    * ui != vi
    * pj != qj
    * 1 <= disi, limitj <= 10^9
    * There may be multiple edges between two nodes."""

    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:
        parent = list(range(n))

        def find(p):
            if p != parent[p]:
                parent[p] = find(parent[p])
            return parent[p]

        ans = [False] * len(queries)
        ii = 0
        edgeList.sort(key = lambda x: x[2])
        for i, (p, q, w) in sorted(enumerate(queries), key = lambda x: x[1][2]):
            while ii < len(edgeList) and edgeList[ii][2] < w:
                u, v, _ = edgeList[ii]
                uu, vv = find(u), find(v)
                if uu != vv: parent[uu] = vv
                ii += 1
            if find(p) == find(q): ans[i] = True
        return ans


    """1700. Number of Students Unable to Eat Lunch (Easy)
    The school cafeteria offers circular and square sandwiches at lunch break,
    referred to by numbers 0 and 1 respectively. All students stand in a queue.
    Each student either prefers square or circular sandwiches. The number of
    sandwiches in the cafeteria is equal to the number of students. The
    sandwiches are placed in a stack. At each step:
    * If the student at the front of the queue prefers the sandwich on the top
      of the stack, they will take it and leave the queue.
    * Otherwise, they will leave it and go to the queue's end.
    This continues until none of the queue students want to take the top
    sandwich and are thus unable to eat. You are given two integer arrays
    students and sandwiches where sandwiches[i] is the type of the ith
    sandwich in the stack (i = 0 is the top of the stack) and students[j] is
    the preference of the jth student in the initial queue (j = 0 is the front
    of the queue). Return the number of students that are unable to eat.

    Example 1:
    Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
    Output: 0
    Explanation:
    - Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
    - Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
    - Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
    - Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
    - Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
    - Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
    - Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
    - Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
    Hence all students are able to eat.

    Example 2:
    Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
    Output: 3

    Constraints:
    * 1 <= students.length, sandwiches.length <= 100
    * students.length == sandwiches.length
    * sandwiches[i] is 0 or 1.
    * students[i] is 0 or 1."""

    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        prefix = sum(students)
        for i, x in enumerate(sandwiches):
            if x and not prefix or not x and prefix == len(sandwiches)-i: return len(sandwiches)-i
            prefix -= x
        return 0


    """1701. Average Waiting Time (Medium)
    There is a restaurant with a single chef. You are given an array customers,
    where customers[i] = [arrivali, timei]:
    * arrivali is the arrival time of the ith customer. The arrival times are
      sorted in non-decreasing order.
    * timei is the time needed to prepare the order of the ith customer.
    When a customer arrives, he gives the chef his order, and the chef starts
    preparing it once he is idle. The customer waits till the chef finishes
    preparing his order. The chef does not prepare food for more than one
    customer at a time. The chef prepares food for customers in the order they
    were given in the input. Return the average waiting time of all customers.
    Solutions within 10-5 from the actual answer are considered accepted.

    Example 1:
    Input: customers = [[1,2],[2,5],[4,3]]
    Output: 5.00000
    Explanation:
    1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.
    2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.
    3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.
    So the average waiting time = (2 + 6 + 7) / 3 = 5.

    Example 2:
    Input: customers = [[5,2],[5,4],[10,3],[20,1]]
    Output: 3.25000
    Explanation:
    1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.
    2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.
    3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.
    4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.
    So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.

    Constraints:
    * 1 <= customers.length <= 10^5
    * 1 <= arrivali, timei <= 10^4
    * arrivali <= arrivali+1"""

    def averageWaitingTime(self, customers: List[List[int]]) -> float:
        ans = t = 0
        for arrival, time in customers:
            t = max(t, arrival) + time
            ans += t - arrival
        return ans/len(customers)


    """1702. Maximum Binary String After Change (Medium)
    You are given a binary string binary consisting of only 0's or 1's. You can
    apply each of the following operations any number of times:
    * Operation 1: If the number contains the substring "00", you can replace it with "10".
      - For example, "00010" -> "10010"
    * Operation 2: If the number contains the substring "10", you can replace it with "01".
      - For example, "00010" -> "00001"
    Return the maximum binary string you can obtain after any number of
    operations. Binary string x is greater than binary string y if x's decimal
    representation is greater than y's decimal representation.

    Example 1:
    Input: binary = "000110"
    Output: "111011"
    Explanation: A valid transformation sequence can be:
    "000110" -> "000101"
    "000101" -> "100101"
    "100101" -> "110101"
    "110101" -> "110011"
    "110011" -> "111011"

    Example 2:
    Input: binary = "01"
    Output: "01"
    Explanation: "01" cannot be transformed any further.

    Constraints:
    * 1 <= binary.length <= 10^5
    * binary consist of '0' and '1'."""

    def maximumBinaryString(self, binary: str) -> str:
        if binary.count("0") <= 1: return binary
        ones = binary.count("1", binary.index("0"))
        return (len(binary)-ones-1)*"1" + "0" + ones*"1"


    """1703. Minimum Adjacent Swaps for K Consecutive Ones (Hard)
    You are given an integer array, nums, and an integer k. nums comprises of
    only 0's and 1's. In one move, you can choose two adjacent indices and swap
    their values. Return the minimum number of moves required so that nums has
    k consecutive 1's.

    Example 1:
    Input: nums = [1,0,0,1,0,1], k = 2
    Output: 1
    Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's.

    Example 2:
    Input: nums = [1,0,0,0,0,0,1,1], k = 3
    Output: 5
    Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1].

    Example 3:
    Input: nums = [1,1,0,1], k = 2
    Output: 0
    Explanation: nums already has 2 consecutive 1's.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is 0 or 1.
    * 1 <= k <= sum(nums)"""

    def minMoves(self, nums: List[int], k: int) -> int:
        loc = [i for i, x in enumerate(nums) if x]
        prefix = [0]
        for x in loc: prefix.append(prefix[-1] + x)

        ans = inf
        for i in range(len(loc)-k+1):
            ans = min(ans, (prefix[i+k] - prefix[i+(k+1)//2]) - (prefix[i+k//2] - prefix[i]))
        return ans - (k//2)*((k+1)//2)


    """1704. Determine if String Halves Are Alike (Easy)
    You are given a string s of even length. Split this string into two halves
    of equal lengths, and let a be the first half and b be the second half. Two
    strings are alike if they have the same number of vowels ('a', 'e', 'i',
    'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and
    lowercase letters. Return true if a and b are alike. Otherwise, return
    false.

    Example 1:
    Input: s = "book"
    Output: true
    Explanation: a = "bo" and b = "ok". a has 1 vowel and b has 1 vowel.
                 Therefore, they are alike.

    Example 2:
    Input: s = "textbook"
    Output: false
    Explanation: a = "text" and b = "book". a has 1 vowel whereas b has 2.
                 Therefore, they are not alike. Notice that the vowel o is
                 counted twice.

    Example 3:
    Input: s = "MerryChristmas"
    Output: false

    Example 4:
    Input: s = "AbCdEfGh"
    Output: true

    Constraints:
    * 2 <= s.length <= 1000
    * s.length is even.
    * s consists of uppercase and lowercase letters."""

    def halvesAreAlike(self, s: str) -> bool:
        cnt = 0
        for i, c in enumerate(s):
            if c in "aeiouAEIOU": cnt += 1 if i < len(s)//2 else -1
        return cnt == 0


    """1705. Maximum Number of Eaten Apples (Medium)
    There is a special kind of apple tree that grows apples every day for n
    days. On the ith day, the tree grows apples[i] apples that will rot after
    days[i] days, that is on day i + days[i] the apples will be rotten and
    cannot be eaten. On some days, the apple tree does not grow any apples,
    which are denoted by apples[i] == 0 and days[i] == 0. You decided to eat at
    most one apple a day (to keep the doctors away). Note that you can keep
    eating after the first n days. Given two integer arrays days and apples of
    length n, return the maximum number of apples you can eat.

    Example 1:
    Input: apples = [1,2,3,5,2], days = [3,2,1,4,2]
    Output: 7
    Explanation: You can eat 7 apples:
    - On the first day, you eat an apple that grew on the first day.
    - On the second day, you eat an apple that grew on the second day.
    - On the third day, you eat an apple that grew on the second day. After
      this day, the apples that grew on the third day rot.
    - On the fourth to the seventh days, you eat apples that grew on the fourth
      day.

    Example 2:
    Input: apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]
    Output: 5
    Explanation: You can eat 5 apples:
    - On the first to the third day you eat apples that grew on the first day.
    - Do nothing on the fouth and fifth days.
    - On the sixth and seventh days you eat apples that grew on the sixth day.

    Constraints:
    * apples.length == n
    * days.length == n
    * 1 <= n <= 2 * 10^4
    * 0 <= apples[i], days[i] <= 2 * 10^4
    * days[i] = 0 if and only if apples[i] = 0."""

    def eatenApples(self, apples: List[int], days: List[int]) -> int:
        ans = 0

        pq = [] # min-heap
        for i, (x, d) in enumerate(zip(apples, days)):
            while pq and pq[0][0] <= i: heappop(pq) # rotten
            if x: heappush(pq, (i+d, x))
            if pq:
                ii, x = heappop(pq)
                if x-1: heappush(pq, (ii, x-1))
                ans += 1

        i += 1
        while pq:
            ii, x = heappop(pq)
            x = min(x, ii-i)
            ans += x
            i += x
        return ans


    """1706. Where Will the Ball Fall (Medium)
    You have a 2-D grid of size m x n representing a box, and you have n balls.
    The box is open on the top and bottom sides. Each cell in the box has a
    diagonal board spanning two corners of the cell that can redirect a ball to
    the right or to the left.
    * A board that redirects the ball to the right spans the top-left corner to
      the bottom-right corner and is represented in the grid as 1.
    * A board that redirects the ball to the left spans the top-right corner to
      the bottom-left corner and is represented in the grid as -1.
    We drop one ball at the top of each column of the box. Each ball can get
    stuck in the box or fall out of the bottom. A ball gets stuck if it hits a
    "V" shaped pattern between two boards or if a board redirects the ball into
    either wall of the box. Return an array answer of size n where answer[i] is
    the column that the ball falls out of at the bottom after dropping the ball
    from the ith column at the top, or -1 if the ball gets stuck in the box.

    Example 1:
    Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
    Output: [1,-1,-1,-1,-1]
    Explanation: This example is shown in the photo. Ball b0 is dropped at
                 column 0 and falls out of the box at column 1. Ball b1 is
                 dropped at column 1 and will get stuck in the box between
                 column 2 and 3 and row 1. Ball b2 is dropped at column 2 and
                 will get stuck on the box between column 2 and 3 and row 0.
                 Ball b3 is dropped at column 3 and will get stuck on the box
                 between column 2 and 3 and row 0. Ball b4 is dropped at column
                 4 and will get stuck on the box between column 2 and 3 and row
                 1.

    Example 2:
    Input: grid = [[-1]]
    Output: [-1]
    Explanation: The ball gets stuck against the left wall.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 100
    * grid[i][j] is 1 or -1."""

    def findBall(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0])
        ans = [-1] * n
        for j in range(n):
            k = j
            for i in range(m):
                kk = k + grid[i][k]
                if not 0 <= kk < n or grid[i][k] * grid[i][kk] < 0: break
                k = kk
            else: ans[j] = k
        return ans


    """1707. Maximum XOR With an Element From Array (Hard)
    You are given an array nums consisting of non-negative integers. You are
    also given a queries array, where queries[i] = [xi, mi]. The answer to the
    ith query is the maximum bitwise XOR value of xi and any element of nums
    that does not exceed mi. In other words, the answer is max(nums[j] XOR xi)
    for all j such that nums[j] <= mi. If all elements in nums are larger than
    mi, then the answer is -1. Return an integer array answer where
    answer.length == queries.length and answer[i] is the answer to the ith
    query.

    Example 1:
    Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
    Output: [3,3,7]
    Explanation:
    1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and
       1 XOR 3 = 2. The larger of the two is 3.
    2) 1 XOR 2 = 3.
    3) 5 XOR 2 = 7.

    Example 2:
    Input: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
    Output: [15,-1,5]

    Constraints:
    * 1 <= nums.length, queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= nums[j], xi, mi <= 10^9"""

    # class Trie:
    #     def __init__(self):
    #         self.root = {}

    #     def __bool__(self):
    #         return bool(self.root)

    #     def insert(self, num):
    #         node = self.root
    #         for x in bin(num)[2:].zfill(32):
    #             node = node.setdefault(int(x), {})
    #         node["#"] = num

    #     def query(self, num):
    #         node = self.root
    #         for x in bin(num)[2:].zfill(32):
    #             node = node.get(1 - int(x)) or node.get(int(x))
    #         return num ^ node["#"]

    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        nums.sort()
        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))

        ans = [-1]*len(queries)
        k = 0
        trie = Trie()
        for m, x, i in queries:
            while k < len(nums) and nums[k] <= m:
                trie.insert(nums[k])
                k += 1
            if trie: ans[i] = trie.query(x)
        return ans


    """1708. Largest Subarray Length K (Easy)
    An array A is larger than some array B if for the first index i where
    A[i] != B[i], A[i] > B[i]. For example, consider 0-indexing:
    * [1,3,2,4] > [1,2,2,4], since at index 1, 3 > 2.
    * [1,4,4,4] < [2,1,1,1], since at index 0, 1 < 2.
    A subarray is a contiguous subsequence of the array. Given an integer array
    nums of distinct integers, return the largest subarray of nums of length k.

    Example 1:
    Input: nums = [1,4,5,2,3], k = 3
    Output: [5,2,3]
    Explanation: The subarrays of size 3 are: [1,4,5], [4,5,2], and [5,2,3]. Of
                 these, [5,2,3] is the largest.

    Example 2:
    Input: nums = [1,4,5,2,3], k = 4
    Output: [4,5,2,3]
    Explanation: The subarrays of size 4 are: [1,4,5,2], and [4,5,2,3]. Of
                 these, [4,5,2,3] is the largest.

    Example 3:
    Input: nums = [1,4,5,2,3], k = 1
    Output: [5]

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * All the integers of nums are unique.

    Follow up: What if the integers in nums are not distinct?"""

    def largestSubarray(self, nums: List[int], k: int) -> List[int]:
        ii = 0
        for i in range(len(nums)-k+1):
            if nums[i] > nums[ii]: ii = i
        return nums[ii:ii+k]


    """1710. Maximum Units on a Truck (Easy)
    You are assigned to put some amount of boxes onto one truck. You are given
    a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:
    * numberOfBoxesi is the number of boxes of type i.
    * numberOfUnitsPerBoxi is the number of units in each box of the type i.
    You are also given an integer truckSize, which is the maximum number of
    boxes that can be put on the truck. You can choose any boxes to put on the
    truck as long as the number of boxes does not exceed truckSize. Return the
    maximum total number of units that can be put on the truck.

    Example 1:
    Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
    Output: 8
    Explanation: There are:
    - 1 box of the first type that contains 3 units.
    - 2 boxes of the second type that contain 2 units each.
    - 3 boxes of the third type that contain 1 unit each.
    You can take all the boxes of the first and second types, and one box of the third type.
    The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.

    Example 2:
    Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
    Output: 91

    Constraints:
    * 1 <= boxTypes.length <= 1000
    * 1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000
    * 1 <= truckSize <= 10^6"""

    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        ans = 0
        for boxes, units in sorted(boxTypes, key=lambda x: x[1], reverse=True):
            boxes = min(boxes, truckSize)
            ans += boxes * units
            truckSize -= boxes
        return ans


    """1711. Count Good Meals (Medium)
    A good meal is a meal that contains exactly two different food items with a
    sum of deliciousness equal to a power of two. You can pick any two different
    foods to make a good meal. Given an array of integers deliciousness where
    deliciousness[i] is the deliciousness of the i​​​​​​th​​​​​​​​ item of food, return the
    number of different good meals you can make from this list modulo 10^9 + 7.
    Note that items with different indices are considered different even if they
    have the same deliciousness value.

    Example 1:
    Input: deliciousness = [1,3,5,7,9]
    Output: 4
    Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).
    Their respective sums are 4, 8, 8, and 16, all of which are powers of 2.

    Example 2:
    Input: deliciousness = [1,1,1,3,3,3,7]
    Output: 15
    Explanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.

    Constraints:
    * 1 <= deliciousness.length <= 10^5
    * 0 <= deliciousness[i] <= 2^20"""

    def countPairs(self, deliciousness: List[int]) -> int:
        ans = 0
        freq = defaultdict(int)
        for x in deliciousness:
            for k in range(22): ans += freq[2**k - x]
            freq[x] += 1
        return ans % 1_000_000_007


    """1712. Ways to Split Array Into Three Subarrays (Medium)
    A split of an integer array is good if:
    * The array is split into three non-empty contiguous subarrays - named left,
      mid, right respectively from left to right.
    * The sum of the elements in left is less than or equal to the sum of the
      elements in mid, and the sum of the elements in mid is less than or equal
      to the sum of the elements in right.
    Given nums, an array of non-negative integers, return the number of good
    ways to split nums. As the number may be too large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [1,1,1]
    Output: 1
    Explanation: The only good way to split nums is [1] [1] [1].

    Example 2:
    Input: nums = [1,2,2,2,5,0]
    Output: 3
    Explanation: There are three good ways of splitting nums:
    [1] [2] [2,2,5,0]
    [1] [2,2] [2,5,0]
    [1,2] [2,2] [5,0]

    Example 3:
    Input: nums = [3,2,1]
    Output: 0
    Explanation: There is no good way to split nums.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^4"""

    def waysToSplit(self, nums: List[int]) -> int:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)

        ans = j = k = 0
        for i in range(1, len(nums)):
            j = max(j, i+1)
            while j < len(nums) and 2*prefix[i] > prefix[j]: j += 1
            k = max(k, j)
            while k < len(nums) and 2*prefix[k] <= prefix[i] + prefix[-1]: k += 1
            ans += k - j
        return ans % 1_000_000_007


    """1713. Minimum Operations to Make a Subsequence (Hard)
    You are given an array target that consists of distinct integers and
    another integer array arr that can have duplicates. In one operation, you
    can insert any integer at any position in arr. For example, if arr = [1,4,1,2],
    you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can
    insert the integer at the very beginning or end of the array. Return the
    minimum number of operations needed to make target a subsequence of arr. A
    subsequence of an array is a new array generated from the original array by
    deleting some elements (possibly none) without changing the remaining
    elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4]
    (the underlined elements), while [2,4,2] is not.

    Example 1:
    Input: target = [5,1,3], arr = [9,4,2,3,4]
    Output: 2
    Explanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.

    Example 2:
    Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]
    Output: 3

    Constraints:
    * 1 <= target.length, arr.length <= 10^5
    * 1 <= target[i], arr[i] <= 10^9
    * target contains no duplicates."""

    def minOperations(self, target: List[int], arr: List[int]) -> int:
        mp = {x: i for i, x in enumerate(target)}
        stack = []
        for x in arr:
            if x in mp:
                i = bisect_left(stack, mp[x])
                if i < len(stack): stack[i] = mp[x]
                else: stack.append(mp[x])
        return len(target) - len(stack)


    """1714. Sum Of Special Evenly-Spaced Elements In Array (Hard)
    You are given a 0-indexed integer array nums consisting of n non-negative
    integers. You are also given an array queries, where queries[i] = [xi, yi].
    The answer to the ith query is the sum of all nums[j] where xi <= j < n
    and (j - xi) is divisible by yi. Return an array answer where
    answer.length == queries.length and answer[i] is the answer to the ith
    query modulo 10^9 + 7.

    Example 1:
    Input: nums = [0,1,2,3,4,5,6,7], queries = [[0,3],[5,1],[4,2]]
    Output: [9,18,10]
    Explanation: The answers of the queries are as follows:
                 1) The j indices that satisfy this query are 0, 3, and 6.
                    nums[0] + nums[3] + nums[6] = 9
                 2) The j indices that satisfy this query are 5, 6, and 7.
                    nums[5] + nums[6] + nums[7] = 18
                 3) The j indices that satisfy this query are 4 and 6.
                    nums[4] + nums[6] = 10

    Example 2:
    Input: nums = [100,200,101,201,102,202,103,203], queries = [[0,7]]
    Output: [303]

    Constraints:
    * n == nums.length
    * 1 <= n <= 5 * 10^4
    * 0 <= nums[i] <= 10^9
    * 1 <= queries.length <= 1.5 * 10^5
    * 0 <= xi < n
    * 1 <= yi <= 5 * 10^4"""

    def solve(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        mod = 1_000_000_007
        n = len(nums)
        r = isqrt(n)
        dp = [[0]*r for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(r):
                dp[i][j] = nums[i]
                if i+j < n: dp[i][j] = (dp[i][j] + dp[i+j][j]) % mod
        ans = []
        for x, y in queries:
            if y < r: ans.append(dp[x][y])
            else:
                val = 0
                for j in range(x, n, y):
                    val = (val + nums[j]) % mod
                ans.append(val)
        return ans


    """1716. Calculate Money in Leetcode Bank (Easy)
    Hercy wants to save money for his first car. He puts money in the Leetcode
    bank every day. He starts by putting in $1 on Monday, the first day. Every
    day from Tuesday to Sunday, he will put in $1 more than the day before. On
    every subsequent Monday, he will put in $1 more than the previous Monday.
    Given n, return the total amount of money he will have in the Leetcode bank
    at the end of the nth day.

    Example 1:
    Input: n = 4
    Output: 10
    Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.

    Example 2:
    Input: n = 10
    Output: 37
    Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) +
                 (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only
                 puts in $2.

    Example 3:
    Input: n = 20
    Output: 96
    Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) +
                 (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.

    Constraints: 1 <= n <= 1000"""

    def totalMoney(self, n: int) -> int:
        q, r = divmod(n, 7)
        return ((7*q + (49+2*r))*q + r*(r+1))//2


    """1716. Calculate Money in Leetcode Bank (Easy)
    Hercy wants to save money for his first car. He puts money in the Leetcode
    bank every day. He starts by putting in $1 on Monday, the first day. Every
    day from Tuesday to Sunday, he will put in $1 more than the day before. On
    every subsequent Monday, he will put in $1 more than the previous Monday.
    Given n, return the total amount of money he will have in the Leetcode bank
    at the end of the nth day.

    Example 1:
    Input: n = 4
    Output: 10
    Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.

    Example 2:
    Input: n = 10
    Output: 37
    Explanation: After the 10th day, the total is
                 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on
                 the 2nd Monday, Hercy only puts in $2.

    Example 3:
    Input: n = 20
    Output: 96
    Explanation: After the 20th day, the total is
                (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.

    Constraints: 1 <= n <= 1000"""

    def totalMoney(self, n: int) -> int:
        ans = val = 0
        for x in range(n):
            if x % 7 == 0: val = x//7 # reset
            val += 1
            ans += val
        return ans


    """1717. Maximum Score From Removing Substrings (Medium)
    You are given a string s and two integers x and y. You can perform two
    types of operations any number of times.
    * Remove substring "ab" and gain x points.
      + For example, when removing "ab" from "cabxbae" it becomes "cxbae".
    * Remove substring "ba" and gain y points.
      + For example, when removing "ba" from "cabxbae" it becomes "cabxe".
    Return the maximum points you can gain after applying the above operations
    on s.

    Example 1:
    Input: s = "cdbcbbaaabab", x = 4, y = 5
    Output: 19
    Explanation:
    - Remove the "ba" underlined in "cdbcbbaaabab". Now, s = "cdbcbbaaab" and 5 points are added to the score.
    - Remove the "ab" underlined in "cdbcbbaaab". Now, s = "cdbcbbaa" and 4 points are added to the score.
    - Remove the "ba" underlined in "cdbcbbaa". Now, s = "cdbcba" and 5 points are added to the score.
    - Remove the "ba" underlined in "cdbcba". Now, s = "cdbc" and 5 points are added to the score.
    Total score = 5 + 4 + 5 + 5 = 19.

    Example 2:
    Input: s = "aabbaaxybbaabb", x = 5, y = 4
    Output: 20

    Constraints:
    * 1 <= s.length <= 10^5
    * 1 <= x, y <= 10^4
    * s consists of lowercase English letters."""

    def maximumGain(self, s: str, x: int, y: int) -> int:
        a, b = "a", "b"
        if x < y: a, b, x, y = b, a, y, x
        ans = ca = cb = 0
        for c in s:
            if c not in "ab":
                ans += min(ca, cb) * y
                ca = cb = 0
            elif c == b:
                if ca:
                    ca -= 1
                    ans += x
                else: cb += 1
            else: ca += 1
        return ans + min(ca, cb) * y


    """1718. Construct the Lexicographically Largest Valid Sequence (Medium)
    Given an integer n, find a sequence that satisfies all of the following:
    * The integer 1 occurs once in the sequence.
    * Each integer between 2 and n occurs twice in the sequence.
    * For every integer i between 2 and n, the distance between the two
      occurrences of i is exactly i.
    The distance between two numbers on the sequence, a[i] and a[j], is the
    absolute difference of their indices, |j - i|. Return the lexicographically
    largest sequence. It is guaranteed that under the given constraints, there
    is always a solution. A sequence a is lexicographically larger than a
    sequence b (of the same length) if in the first position where a and b
    differ, sequence a has a number greater than the corresponding number in b.
    For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because
    the first position they differ is at the third number, and 9 is greater
    than 5.

    Example 1:
    Input: n = 3
    Output: [3,1,2,3,2]
    Explanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the
                 lexicographically largest valid sequence.

    Example 2:
    Input: n = 5
    Output: [5,3,1,4,3,5,2,4,2]

    Constraints: 1 <= n <= 20"""

    def constructDistancedSequence(self, n: int) -> List[int]:
        ans = [0]*(2*n-1)

        def fn(i):
            """Return largest sequence after filling in ith position."""
            if i == 2*n-1 or ans[i] and fn(i+1): return True
            for x in reversed(range(1, n+1)):
                if x not in ans:
                    ii = x if x > 1 else 0
                    if i+ii < 2*n-1 and ans[i] == ans[i+ii] == 0:
                        ans[i] = ans[i+ii] = x
                        if fn(i+1): return True
                        ans[i] = ans[i+ii] = 0

        fn(0)
        return ans


    """1719. Number Of Ways To Reconstruct A Tree (Hard)
    You are given an array pairs, where pairs[i] = [xi, yi], and:
    * There are no duplicates.
    * xi < yi
    Let ways be the number of rooted trees that satisfy the following
    conditions:
    * The tree consists of nodes whose values appeared in pairs.
    * A pair [xi, yi] exists in pairs if and only if xi is an ancestor of yi or
      yi is an ancestor of xi.
    * Note: the tree does not have to be a binary tree.
    Two ways are considered to be different if there is at least one node that
    has different parents in both ways.

    Return:
    * 0 if ways == 0
    * 1 if ways == 1
    * 2 if ways > 1
    A rooted tree is a tree that has a single root node, and all edges are
    oriented to be outgoing from the root. An ancestor of a node is any node on
    the path from the root to that node (excluding the node itself). The root
    has no ancestors.

    Example 1:
    Input: pairs = [[1,2],[2,3]]
    Output: 1
    Explanation: There is exactly one valid rooted tree, which is shown in the
                 above figure.

    Example 2:
    Input: pairs = [[1,2],[2,3],[1,3]]
    Output: 2
    Explanation: There are multiple valid rooted trees. Three of them are shown
                 in the above figures.

    Example 3:
    Input: pairs = [[1,2],[2,3],[2,4],[1,5]]
    Output: 0
    Explanation: There are no valid rooted trees.

    Constraints:
    * 1 <= pairs.length <= 10^5
    * 1 <= xi < yi <= 500
    * The elements in pairs are unique."""

    def checkWays(self, pairs: List[List[int]]) -> int:
        graph = {}
        for x, y in pairs:
            graph.setdefault(x, set()).add(y)
            graph.setdefault(y, set()).add(x)

        ans = 1
        ancestors = set()
        for n in sorted(graph, key=lambda x: len(graph[x]), reverse=True):
            p = min(ancestors & graph[n], key=lambda x: len(graph[x]), default=None) # immediate ancestor
            ancestors.add(n)
            if p:
                if graph[n] - (graph[p] | {p}): return 0 # impossible to have more than ancestor
                if len(graph[n]) == len(graph[p]): ans = 2
            elif len(graph[n]) != len(graph)-1: return 0
        return ans


    """1721. Swapping Nodes in a Linked List (Medium)
    You are given the head of a linked list, and an integer k. Return the head
    of the linked list after swapping the values of the kth node from the
    beginning and the kth node from the end (the list is 1-indexed).

    Example 1:
    Input: head = [1,2,3,4,5], k = 2
    Output: [1,4,3,2,5]

    Example 2:
    Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
    Output: [7,9,6,6,8,7,3,0,9,5]

    Example 3:
    Input: head = [1], k = 1
    Output: [1]

    Example 4:
    Input: head = [1,2], k = 1
    Output: [2,1]

    Example 5:
    Input: head = [1,2,3], k = 2
    Output: [1,2,3]

    Constraints:
    * The number of nodes in the list is n.
    * 1 <= k <= n <= 10^5
    * 0 <= Node.val <= 100"""

    def swapNodes(self, head: ListNode, k: int) -> ListNode:
        node = n1 = n2 = head
        while node:
            k -= 1
            if not k: n1 = node
            if k < 0: n2 = n2.next
            node = node.next
        n1.val, n2.val = n2.val, n1.val
        return head


    """1730. Shortest Path to Get Food (Medium)
    You are starving and you want to eat food as quickly as possible. You want
    to find the shortest path to arrive at any food cell. You are given an m x n
    character matrix, grid, of these different types of cells:
    * '*' is your location. There is exactly one '*' cell.
    * '#' is a food cell. There may be multiple food cells.
    * 'O' is free space, and you can travel through these cells.
    * 'X' is an obstacle, and you cannot travel through these cells.
    You can travel to any adjacent cell north, east, south, or west of your
    current location if there is not an obstacle. Return the length of the
    shortest path for you to reach any food cell. If there is no path for you
    to reach food, return -1.

    Example 1:
    Input: grid = [["X","X","X","X","X","X"],
                   ["X","*","O","O","O","X"],
                   ["X","O","O","#","O","X"],
                   ["X","X","X","X","X","X"]]
    Output: 3
    Explanation: It takes 3 steps to reach the food.

    Example 2:
    Input: grid = [["X","X","X","X","X"],
                   ["X","*","X","O","X"],
                   ["X","O","X","#","X"],
                   ["X","X","X","X","X"]]
    Output: -1
    Explanation: It is not possible to reach the food.

    Example 3:
    Input: grid = [["X","X","X","X","X","X","X","X"],
                   ["X","*","O","X","O","#","O","X"],
                   ["X","O","O","X","O","O","X","X"],
                   ["X","O","O","O","O","#","O","X"],
                   ["X","X","X","X","X","X","X","X"]]
    Output: 6
    Explanation: There can be multiple food cells. It only takes 6 steps to reach the bottom food.

    Example 4:
    Input: grid = [["O","*"],
                   ["#","O"]]
    Output: 2

    Example 5:
    Input: grid = [["X","*"],
                   ["#","X"]]
    Output: -1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 200
    * grid[row][col] is '*', 'X', 'O', or '#'.
    * The grid contains exactly one '*'."""

    def getFood(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions

        for i in range(m):
            for j in range(n):
                if grid[i][j] == "*": break
            else: continue
            break

        ans = 0
        queue = [(i, j)]
        grid[i][j] = "X" # mark visited (upon pushing)

        while queue:
            ans += 1
            newq = []
            for i, j in queue:
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != "X":
                        if grid[ii][jj] == "#": return ans
                        newq.append((ii, jj))
                        grid[ii][jj] = "X" # mark visited
            queue = newq
        return -1


    """1732. Find the Highest Altitude (Easy)
    There is a biker going on a road trip. The road trip consists of n + 1
    points at different altitudes. The biker starts his trip on point 0 with
    altitude equal 0. You are given an integer array gain of length n where
    gain[i] is the net gain in altitude between points i and i + 1 for all
    (0 <= i < n). Return the highest altitude of a point.

    Example 1:
    Input: gain = [-5,1,5,0,-7]
    Output: 1
    Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.

    Example 2:
    Input: gain = [-4,-3,-2,-1,4,3,2]
    Output: 0
    Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.

    Constraints:
    * n == gain.length
    * 1 <= n <= 100
    * -100 <= gain[i] <= 100"""

    def largestAltitude(self, gain: List[int]) -> int:
        ans = prefix = 0
        for x in gain:
            prefix += x
            ans = max(ans, prefix)
        return ans


    """1732. Find the Highest Altitude (Easy)
    There is a biker going on a road trip. The road trip consists of n + 1
    points at different altitudes. The biker starts his trip on point 0 with
    altitude equal 0. You are given an integer array gain of length n where
    gain[i] is the net gain in altitude between points i and i + 1 for all
    (0 <= i < n). Return the highest altitude of a point.

    Example 1:
    Input: gain = [-5,1,5,0,-7]
    Output: 1
    Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.

    Example 2:
    Input: gain = [-4,-3,-2,-1,4,3,2]
    Output: 0
    Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.

    Constraints:
    * n == gain.length
    * 1 <= n <= 100
    * -100 <= gain[i] <= 100"""

    def largestAltitude(self, gain: List[int]) -> int:
        ans = prefix = 0
        for x in gain:
            prefix += x
            ans = max(ans, prefix)
        return ans


    """1733. Minimum Number of People to Teach (Medium)
    On a social network consisting of m users and some friendships between
    users, two users can communicate with each other if they know a common
    language. You are given an integer n, an array languages, and an array
    friendships where:
    * There are n languages numbered 1 through n,
    * languages[i] is the set of languages the ith user knows, and
    * friendships[i] = [ui, vi] denotes a friendship between the users ui and vi.
    You can choose one language and teach it to some users so that all friends
    can communicate with each other. Return the minimum number of users you
    need to teach. Note that friendships are not transitive, meaning if x is a
    friend of y and y is a friend of z, this doesn't guarantee that x is a
    friend of z.

    Example 1:
    Input: n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]
    Output: 1
    Explanation: You can either teach user 1 the second language or user 2 the first language.

    Example 2:
    Input: n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]
    Output: 2
    Explanation: Teach the third language to users 1 and 3, yielding two users to teach.

    Constraints:
    * 2 <= n <= 500
    * languages.length == m
    * 1 <= m <= 500
    * 1 <= languages[i].length <= n
    * 1 <= languages[i][j] <= n
    * 1 <= ui < vi <= languages.length
    * 1 <= friendships.length <= 500
    * All tuples (ui, vi) are unique
    * languages[i] contains only unique values"""

    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
        languages = [set(x) for x in languages]

        users = set()
        for u, v in friendships:
            if not languages[u-1] & languages[v-1]:
                users.add(u-1)
                users.add(v-1)

        freq = {}
        for i in users:
            for k in languages[i]:
                freq[k] = 1 + freq.get(k, 0)
        return len(users) - max(freq.values(), default=0)


    """1734. Decode XORed Permutation (Medium)
    There is an integer array perm that is a permutation of the first n
    positive integers, where n is always odd. It was encoded into another
    integer array encoded of length n - 1, such that
    encoded[i] = perm[i] XOR perm[i + 1].
    For example, if perm = [1,3,2], then encoded = [2,1]. Given the encoded
    array, return the original array perm. It is guaranteed that the answer
    exists and is unique.

    Example 1:
    Input: encoded = [3,1]
    Output: [1,2,3]
    Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1]

    Example 2:
    Input: encoded = [6,5,4,6]
    Output: [2,4,1,5,3]

    Constraints:
    * 3 <= n < 10^5
    * n is odd.
    * encoded.length == n - 1"""

    def decode(self, encoded: List[int]) -> List[int]:
        x = reduce(xor, list(range(1, len(encoded) + 2)))
        for i in range(1, len(encoded), 2): x ^= encoded[i]
        ans = [x]
        for x in encoded: ans.append(ans[-1] ^ x)
        return ans


    """1735. Count Ways to Make Array With Product (Hard)
    You are given a 2D integer array, queries. For each queries[i], where
    queries[i] = [ni, ki], find the number of different ways you can place
    positive integers into an array of size ni such that the product of the
    integers is ki. As the number of ways may be too large, the answer to the
    ith query is the number of ways modulo 10^9 + 7. Return an integer array
    answer where answer.length == queries.length, and answer[i] is the answer
    to the ith query.

    Example 1:
    Input: queries = [[2,6],[5,1],[73,660]]
    Output: [4,1,50734910]
    Explanation: Each query is independent.
    [2,6]: There are 4 ways to fill an array of size 2 that multiply to 6: [1,6], [2,3], [3,2], [6,1].
    [5,1]: There is 1 way to fill an array of size 5 that multiply to 1: [1,1,1,1,1].
    [73,660]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 10^9 + 7 = 50734910.

    Example 2:
    Input: queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]
    Output: [1,2,3,10,5]

    Constraints:
    * 1 <= queries.length <= 10^4
    * 1 <= ni, ki <= 10^4"""

    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
        spf = list(range(10001)) # spf = smallest prime factor
        for x in range(4, 10001, 2): spf[x] = 2
        for x in range(3, isqrt(10000)+1, 2):
            if spf[x] == x:
                for xx in range(x*x, 10001, x):
                    spf[xx] = min(spf[xx], x)

        ans = []
        for n, k in queries:
            freq = {} # prime factorization via sieve
            while k != 1:
                freq[spf[k]] = 1 + freq.get(spf[k], 0)
                k //= spf[k]
            val = 1
            for x in freq.values():
                val *= comb(n+x-1, x)
            ans.append(val % 1_000_000_007)
        return ans


    """1736. Latest Time by Replacing Hidden Digits (Easy)
    You are given a string time in the form of hh:mm, where some of the digits
    in the string are hidden (represented by ?). The valid times are those
    inclusively between 00:00 and 23:59. Return the latest valid time you can
    get from time by replacing the hidden digits.

    Example 1:
    Input: time = "2?:?0"
    Output: "23:50"
    Explanation: The latest hour beginning with the digit '2' is 23 and the
                 latest minute ending with the digit '0' is 50.

    Example 2:
    Input: time = "0?:3?"
    Output: "09:39"

    Example 3:
    Input: time = "1?:22"
    Output: "19:22"

    Constraints:
    * time is in the format hh:mm.
    * It is guaranteed that you can produce a valid time from the given string."""

    def maximumTime(self, time: str) -> str:
        time = list(time)
        for i in range(len(time)):
            if time[i] == "?":
                if i == 0: time[i] = "2" if time[i+1] in "?0123" else "1"
                elif i == 1: time[i] = "3" if time[0] == "2" else "9"
                elif i == 3: time[i] = "5"
                else: time[i] = "9"
        return "".join(time)


    """1737. Change Minimum Characters to Satisfy One of Three Conditions (Medium)
    You are given two strings a and b that consist of lowercase letters. In one
    operation, you can change any character in a or b to any lowercase letter.
    Your goal is to satisfy one of the following three conditions:
    * Every letter in a is strictly less than every letter in b in the alphabet.
    * Every letter in b is strictly less than every letter in a in the alphabet.
    * Both a and b consist of only one distinct letter.
    Return the minimum number of operations needed to achieve your goal.

    Example 1:
    Input: a = "aba", b = "caa"
    Output: 2
    Explanation: Consider the best way to make each condition true:
    1) Change b to "ccc" in 2 operations, then every letter in a is less than
       every letter in b.
    2) Change a to "bbb" and b to "aaa" in 3 operations, then every letter in b
       is less than every letter in a.
    3) Change a to "aaa" and b to "aaa" in 2 operations, then a and b consist
       of one distinct letter.
    The best way was done in 2 operations (either condition 1 or condition 3).

    Example 2:
    Input: a = "dabadd", b = "cda"
    Output: 3
    Explanation: The best way is to make condition 1 true by changing b to "eee".

    Constraints:
    * 1 <= a.length, b.length <= 10^5
    * a and b consist only of lowercase letters."""

    def minCharacters(self, a: str, b: str) -> int:
        pa, pb = [0]*26, [0]*26
        for x in a: pa[ord(x)-97] += 1
        for x in b: pb[ord(x)-97] += 1

        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3
        for i in range(25):
            pa[i+1] += pa[i]
            pb[i+1] += pb[i]
            ans = min(ans, pa[i] + len(b) - pb[i]) # condition 2
            ans = min(ans, len(a) - pa[i] + pb[i]) # condition 1
        return ans


    """1738. Find Kth Largest XOR Coordinate Value (Medium)
    You are given a 2D matrix of size m x n, consisting of non-negative
    integers. You are also given an integer k. The value of coordinate (a, b)
    of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and
    0 <= j <= b < n (0-indexed). Find the kth largest value (1-indexed) of all
    the coordinates of matrix.

    Example 1:
    Input: matrix = [[5,2],[1,6]], k = 1
    Output: 7
    Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.

    Example 2:
    Input: matrix = [[5,2],[1,6]], k = 2
    Output: 5
    Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.

    Example 3:
    Input: matrix = [[5,2],[1,6]], k = 3
    Output: 4
    Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.

    Example 4:
    Input: matrix = [[5,2],[1,6]], k = 4
    Output: 0
    Explanation: The value of coordinate (1,1) is 5 XOR 2 XOR 1 XOR 6 = 0, which is the 4th largest value.

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 1 <= m, n <= 1000
    * 0 <= matrix[i][j] <= 10^6
    * 1 <= k <= m * n"""

    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:
        m, n = len(matrix), len(matrix[0]) # dimensions

        pq = []
        for i in range(m):
            for j in range(n):
                if i: matrix[i][j] ^= matrix[i-1][j]
                if j: matrix[i][j] ^= matrix[i][j-1]
                if i and j: matrix[i][j] ^= matrix[i-1][j-1]
                heappush(pq, matrix[i][j])
                if len(pq) > k: heappop(pq)
        return pq[0]


    """1739. Building Boxes (Hard)
    You have a cubic storeroom where the width, length, and height of the room
    are all equal to n units. You are asked to place n boxes in this room where
    each box is a cube of unit side length. There are however some rules to
    placing the boxes:
    * You can place the boxes anywhere on the floor.
    * If box x is placed on top of the box y, then each side of the four
      vertical sides of the box y must either be adjacent to another box or to
      a wall.
    Given an integer n, return the minimum possible number of boxes touching
    the floor.

    Example 1:
    Input: n = 3
    Output: 3
    Explanation: The figure above is for the placement of the three boxes.
                 These boxes are placed in the corner of the room, where the
                 corner is on the left side.

    Example 2:
    Input: n = 4
    Output: 3
    Explanation: The figure above is for the placement of the four boxes. These
                 boxes are placed in the corner of the room, where the corner
                 is on the left side.

    Example 3:
    Input: n = 10
    Output: 6
    Explanation: The figure above is for the placement of the ten boxes. These
                 boxes are placed in the corner of the room, where the corner
                 is on the back side.

    Constraints: 1 <= n <= 10^9"""

    def minimumBoxes(self, n: int) -> int:
        x = int((6*n)**(1/3))
        if x*(x+1)*(x+2) > 6*n: x -= 1
        n -= x*(x+1)*(x+2)//6
        return x*(x+1)//2 + ceil((sqrt(1+8*n)-1)/2)


    """1742. Maximum Number of Balls in a Box (Easy)
    You are working in a ball factory where you have n balls numbered from
    lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1),
    and an infinite number of boxes numbered from 1 to infinity. Your job at
    this factory is to put each ball in the box with a number equal to the sum
    of digits of the ball's number. For example, the ball number 321 will be
    put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in
    the box number 1 + 0 = 1. Given two integers lowLimit and highLimit, return
    the number of balls in the box with the most balls.

    Example 1:
    Input: lowLimit = 1, highLimit = 10
    Output: 2
    Explanation:
    Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
    Ball Count:  2 1 1 1 1 1 1 1 1 0  0  ...
    Box 1 has the most number of balls with 2 balls.

    Example 2:
    Input: lowLimit = 5, highLimit = 15
    Output: 2
    Explanation:
    Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
    Ball Count:  1 1 1 1 2 2 1 1 1 0  0  ...
    Boxes 5 and 6 have the most number of balls with 2 balls in each.

    Example 3:
    Input: lowLimit = 19, highLimit = 28
    Output: 2
    Explanation:
    Box Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...
    Ball Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...
    Box 10 has the most number of balls with 2 balls.

    Constraints: 1 <= lowLimit <= highLimit <= 10^5"""

    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        freq = {}
        for x in range(lowLimit, highLimit+1):
            key = sum(int(xx) for xx in str(x))
            freq[key] = 1 + freq.get(key, 0)
        return max(freq.values())


    """1743. Restore the Array From Adjacent Pairs (Medium)
    There is an integer array nums that consists of n unique elements, but you
    have forgotten it. However, you do remember every pair of adjacent elements
    in nums. You are given a 2D integer array adjacentPairs of size n - 1 where
    each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are
    adjacent in nums. It is guaranteed that every adjacent pair of elements
    nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i],
    nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.
    Return the original array nums. If there are multiple solutions, return any
    of them.

    Example 1:
    Input: adjacentPairs = [[2,1],[3,4],[3,2]]
    Output: [1,2,3,4]
    Explanation: This array has all its adjacent pairs in adjacentPairs. Notice
                 that adjacentPairs[i] may not be in left-to-right order.

    Example 2:
    Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]
    Output: [-2,4,1,-3]
    Explanation: There can be negative numbers. Another solution is [-3,1,4,-2],
                 which would also be accepted.

    Example 3:
    Input: adjacentPairs = [[100000,-100000]]
    Output: [100000,-100000]

    Constraints:
    * nums.length == n
    * adjacentPairs.length == n - 1
    * adjacentPairs[i].length == 2
    * 2 <= n <= 10^5
    * -10^5 <= nums[i], ui, vi <= 10^5
    * There exists some nums that has adjacentPairs as its pairs."""

    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        graph = {}
        for u, v in adjacentPairs:
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)

        ans = []
        seen = set()
        stack = [next(x for x in graph if len(graph[x]) == 1)]
        while stack:
            n = stack.pop()
            ans.append(n)
            seen.add(n)
            for nn in graph[n]:
                if nn not in seen: stack.append(nn)
        return ans


    """1744. Can You Eat Your Favorite Candy on Your Favorite Day? (Medium)
    You are given a (0-indexed) array of positive integers candiesCount where
    candiesCount[i] represents the number of candies of the ith type you have.
    You are also given a 2D array queries where
    queries[i] = [favoriteTypei, favoriteDayi, dailyCapi].

    You play a game with the following rules:
    * You start eating candies on day 0.
    * You cannot eat any candy of type i unless you have eaten all candies of
      type i - 1.
    * You must eat at least one candy per day until you have eaten all the
      candies.
    Construct a boolean array answer such that answer.length == queries.length
    and answer[i] is true if you can eat a candy of type favoriteTypei on day
    favoriteDayi without eating more than dailyCapi candies on any day, and
    false otherwise. Note that you can eat different types of candy on the same
    day, provided that you follow rule 2. Return the constructed array answer.

    Example 1:
    Input: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]
    Output: [true,false,true]
    Explanation:
    1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.
    2- You can eat at most 4 candies each day.
       If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.
       On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.
    3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.

    Example 2:
    Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]
    Output: [false,true,true,false,false]

    Constraints:
    * 1 <= candiesCount.length <= 10^5
    * 1 <= candiesCount[i] <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 3
    * 0 <= favoriteTypei < candiesCount.length
    * 0 <= favoriteDayi <= 10^9
    * 1 <= dailyCapi <= 10^9"""

    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:
        prefix = [0]
        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum
        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]


    """1745. Palindrome Partitioning IV (Hard)
    Given a string s, return true if it is possible to split the string s into
    three non-empty palindromic substrings. Otherwise, return false. A string
    is said to be palindrome if it the same string when reversed.

    Example 1:
    Input: s = "abcbdd"
    Output: true
    Explanation: "abcbdd" = "a" + "bcb" + "dd", and all three substrings are
                 palindromes.

    Example 2:
    Input: s = "bcbddxy"
    Output: false
    Explanation: s cannot be split into 3 palindromes.

    Constraints:
    * 3 <= s.length <= 2000
    * s​​​​​​ consists only of lowercase English letters."""

    def checkPartitioning(self, s: str) -> bool:
        mp = defaultdict(set)
        for i in range(2*len(s)-1):
            lo, hi = i//2, (i+1)//2
            while 0 <= lo <= hi < len(s) and s[lo] == s[hi]:
                mp[lo].add(hi)
                lo, hi = lo-1, hi+1

        for i in range(len(s)):
            for j in range(i+1, len(s)):
                if i-1 in mp[0] and j-1 in mp[i] and len(s)-1 in mp[j]: return True
        return False


    """1746. Maximum Subarray Sum After One Operation (Medium)
    You are given an integer array nums. You must perform exactly one operation
    where you can replace one element nums[i] with nums[i] * nums[i]. Return
    the maximum possible subarray sum after exactly one operation. The subarray
    must be non-empty.

    Example 1:
    Input: nums = [2,-1,-4,-3]
    Output: 17
    Explanation: You can perform the operation on index 2 (0-indexed) to make
                 nums = [2,-1,16,-3]. Now, the maximum subarray sum is
                 2 + -1 + 16 = 17.

    Example 2:
    Input: nums = [1,-1,1,1,-1,-1,1]
    Output: 4
    Explanation: You can perform the operation on index 1 (0-indexed) to make
                 nums = [1,1,1,1,-1,-1,1]. Now, the maximum subarray sum is
                 1 + 1 + 1 + 1 = 4.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^4 <= nums[i] <= 10^4"""

    def maxSumAfterOperation(self, nums: List[int]) -> int:
        ans = f0 = f1 = 0
        for x in nums:
            f1 = max(max(0, f0) + x*x, f1 + x)
            f0 = max(0, f0) + x
            ans = max(ans, f1)
        return ans


    """1748. Sum of Unique Elements (Easy)
    You are given an integer array nums. The unique elements of an array are
    the elements that appear exactly once in the array. Return the sum of all
    the unique elements of nums.

    Example 1:
    Input: nums = [1,2,3,2]
    Output: 4
    Explanation: The unique elements are [1,3], and the sum is 4.

    Example 2:
    Input: nums = [1,1,1,1,1]
    Output: 0
    Explanation: There are no unique elements, and the sum is 0.

    Example 3:
    Input: nums = [1,2,3,4,5]
    Output: 15
    Explanation: The unique elements are [1,2,3,4,5], and the sum is 15.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100"""

    def sumOfUnique(self, nums: List[int]) -> int:
        freq = Counter(nums)
        return sum(k for k, v in freq.items() if v == 1)


    """1749. Maximum Absolute Sum of Any Subarray (Medium)
    You are given an integer array nums. The absolute sum of a subarray
    [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr).
    Return the maximum absolute sum of any (possibly empty) subarray of nums.
    Note that abs(x) is defined as follows:
    * If x is a negative integer, then abs(x) = -x.
    * If x is a non-negative integer, then abs(x) = x.

    Example 1:
    Input: nums = [1,-3,2,3,-4]
    Output: 5
    Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.

    Example 2:
    Input: nums = [2,-5,1,-4,3,-2]
    Output: 8
    Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^4 <= nums[i] <= 10^4"""

    def maxAbsoluteSum(self, nums: List[int]) -> int:
        ans = mx = mn = 0
        for x in nums:
            mx = max(mx + x, 0)
            mn = min(mn + x, 0)
            ans = max(ans, mx, -mn)
        return ans


    """1750. Minimum Length of String After Deleting Similar Ends (Medium)
    Given a string s consisting only of characters 'a', 'b', and 'c'. You are
    asked to apply the following algorithm on the string any number of times:
    * Pick a non-empty prefix from the string s where all the characters in the
      prefix are equal.
    * Pick a non-empty suffix from the string s where all the characters in
      this suffix are equal.
    * The prefix and the suffix should not intersect at any index.
    * The characters from the prefix and suffix must be the same.
    * Delete both the prefix and the suffix.
    Return the minimum length of s after performing the above operation any
    number of times (possibly zero times).

    Example 1:
    Input: s = "ca"
    Output: 2
    Explanation: You can't remove any characters, so the string stays as is.

    Example 2:
    Input: s = "cabaabac"
    Output: 0
    Explanation: An optimal sequence of operations is:
    - Take prefix = "c" and suffix = "c" and remove them, s = "abaaba".
    - Take prefix = "a" and suffix = "a" and remove them, s = "baab".
    - Take prefix = "b" and suffix = "b" and remove them, s = "aa".
    - Take prefix = "a" and suffix = "a" and remove them, s = "".

    Example 3:
    Input: s = "aabccabba"
    Output: 3
    Explanation: An optimal sequence of operations is:
    - Take prefix = "aa" and suffix = "a" and remove them, s = "bccabb".
    - Take prefix = "b" and suffix = "bb" and remove them, s = "cca".

    Constraints:
    * 1 <= s.length <= 10^5
    * s only consists of characters 'a', 'b', and 'c'."""

    def minimumLength(self, s: str) -> int:
        lo, hi = 0, len(s)-1
        while lo < hi and s[lo] == s[hi]:
            ch = s[lo]
            while lo <= hi and s[lo] == ch: lo += 1
            while lo <= hi and s[hi] == ch: hi -= 1
        return hi - lo + 1


    """1751. Maximum Number of Events That Can Be Attended II (Hard)
    You are given an array of events where events[i] = [startDayi, endDayi, valuei].
    The ith event starts at startDayi and ends at endDayi, and if you attend
    this event, you will receive a value of valuei. You are also given an
    integer k which represents the maximum number of events you can attend. You
    can only attend one event at a time. If you choose to attend an event, you
    must attend the entire event. Note that the end day is inclusive: that is,
    you cannot attend two events where one of them starts and the other ends on
    the same day. Return the maximum sum of values that you can receive by
    attending events.

    Example 1:
    Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
    Output: 7
    Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value
                 of 4 + 3 = 7.

    Example 2:
    Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
    Output: 10
    Explanation: Choose event 2 for a total value of 10. Notice that you cannot
                 attend any other event as they overlap, and that you do not
                 have to attend k events.

    Example 3:
    Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
    Output: 9
    Explanation: Although the events do not overlap, you can only attend 3
                 events. Pick the highest valued three.

    Constraints:
    * 1 <= k <= events.length
    * 1 <= k * events.length <= 10^6
    * 1 <= startDayi <= endDayi <= 10^9
    * 1 <= valuei <= 10^6"""

    def maxValue(self, events: List[List[int]], k: int) -> int:
        events.sort()
        starts = [i for i, _, _ in events]

        @cache
        def fn(i, k):
            """Return """
            if i == len(events) or k == 0: return 0
            ii = bisect_left(starts, events[i][1]+1)
            return max(fn(i+1, k), events[i][2] + fn(ii, k-1))

        return fn(0, k)


    """1752. Check if Array Is Sorted and Rotated (Easy)
    Given an array nums, return true if the array was originally sorted in non-
    decreasing order, then rotated some number of positions (including zero).
    Otherwise, return false. There may be duplicates in the original array.
    Note: An array A rotated by x positions results in an array B of the same
    length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.

    Example 1:
    Input: nums = [3,4,5,1,2]
    Output: true
    Explanation: [1,2,3,4,5] is the original sorted array. You can rotate the
                 array by x = 3 positions to begin on the the element of value
                 3: [3,4,5,1,2].

    Example 2:
    Input: nums = [2,1,3,4]
    Output: false
    Explanation: There is no sorted array once rotated that can make nums.

    Example 3:
    Input: nums = [1,2,3]
    Output: true
    Explanation: [1,2,3] is the original sorted array. You can rotate the array
                 by x = 0 positions (i.e. no rotation) to make nums.

    Example 4:
    Input: nums = [1,1,1]
    Output: true
    Explanation: [1,1,1] is the original sorted array. You can rotate any
                 number of positions to make nums.

    Example 5:
    Input: nums = [2,1]
    Output: true
    Explanation: [1,2] is the original sorted array. You can rotate the array
                 by x = 5 positions to begin on the element of value 2: [2,1].

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100"""

    def check(self, nums: List[int]) -> bool:
        cnt = 0
        for i in range(len(nums)):
            if nums[i-1] > nums[i]: cnt += 1
        return cnt <= 1


    """1753. Maximum Score From Removing Stones (Medium)
    You are playing a solitaire game with three piles of stones of sizes
    a​​​​​​, b,​​​​​​ and c​​​​​​ respectively. Each turn you choose two different non-empty
    piles, take one stone from each, and add 1 point to your score. The game
    stops when there are fewer than two non-empty piles (meaning there are no
    more available moves). Given three integers a​​​​​, b,​​​​​ and c​​​​​, return the
    maximum score you can get.

    Example 1:
    Input: a = 2, b = 4, c = 6
    Output: 6
    Explanation: The starting state is (2, 4, 6). One optimal set of moves is:
    - Take from 1st and 3rd piles, state is now (1, 4, 5)
    - Take from 1st and 3rd piles, state is now (0, 4, 4)
    - Take from 2nd and 3rd piles, state is now (0, 3, 3)
    - Take from 2nd and 3rd piles, state is now (0, 2, 2)
    - Take from 2nd and 3rd piles, state is now (0, 1, 1)
    - Take from 2nd and 3rd piles, state is now (0, 0, 0)
    There are fewer than two non-empty piles, so the game ends. Total: 6 points.

    Example 2:
    Input: a = 4, b = 4, c = 6
    Output: 7
    Explanation: The starting state is (4, 4, 6). One optimal set of moves is:
    - Take from 1st and 2nd piles, state is now (3, 3, 6)
    - Take from 1st and 3rd piles, state is now (2, 3, 5)
    - Take from 1st and 3rd piles, state is now (1, 3, 4)
    - Take from 1st and 3rd piles, state is now (0, 3, 3)
    - Take from 2nd and 3rd piles, state is now (0, 2, 2)
    - Take from 2nd and 3rd piles, state is now (0, 1, 1)
    - Take from 2nd and 3rd piles, state is now (0, 0, 0)
    There are fewer than two non-empty piles, so the game ends. Total: 7 points.

    Example 3:
    Input: a = 1, b = 8, c = 8
    Output: 8
    Explanation: One optimal set of moves is to take from the 2nd and 3rd piles
                 for 8 turns until they are empty. After that, there are fewer
                 than two non-empty piles, so the game ends.

    Constraints: 1 <= a, b, c <= 10^5"""

    def maximumScore(self, a: int, b: int, c: int) -> int:
        a, b, c = sorted((a, b, c))
        if a + b < c: return a + b
        return (a + b + c)//2


    """1754. Largest Merge Of Two Strings (Medium)
    You are given two strings word1 and word2. You want to construct a string
    merge in the following way: while either word1 or word2 are non-empty,
    choose one of the following options:
    * If word1 is non-empty, append the first character in word1 to merge and
      delete it from word1.
      + For example, if word1 = "abc" and merge = "dv", then after choosing
        this operation, word1 = "bc" and merge = "dva".
    * If word2 is non-empty, append the first character in word2 to merge and
      delete it from word2.
      + For example, if word2 = "abc" and merge = "", then after choosing this
        operation, word2 = "bc" and merge = "a".
    Return the lexicographically largest merge you can construct. A string a is
    lexicographically larger than a string b (of the same length) if in the
    first position where a and b differ, a has a character strictly larger than
    the corresponding character in b. For example, "abcd" is lexicographically
    larger than "abcc" because the first position they differ is at the fourth
    character, and d is greater than c.

    Example 1:
    Input: word1 = "cabaa", word2 = "bcaaa"
    Output: "cbcabaaaaa"
    Explanation: One way to get the lexicographically largest merge is:
    - Take from word1: merge = "c", word1 = "abaa", word2 = "bcaaa"
    - Take from word2: merge = "cb", word1 = "abaa", word2 = "caaa"
    - Take from word2: merge = "cbc", word1 = "abaa", word2 = "aaa"
    - Take from word1: merge = "cbca", word1 = "baa", word2 = "aaa"
    - Take from word1: merge = "cbcab", word1 = "aa", word2 = "aaa"
    - Append the remaining 5 a's from word1 and word2 at the end of merge.

    Example 2:
    Input: word1 = "abcabc", word2 = "abdcaba"
    Output: "abdcabcabcaba"

    Constraints:
    * 1 <= word1.length, word2.length <= 3000
    * word1 and word2 consist only of lowercase English letters."""

    def largestMerge(self, word1: str, word2: str) -> str:
        ans = []
        i1 = i2 = 0
        while i1 < len(word1) and i2 < len(word2):
            if word1[i1:] > word2[i2:]:
                ans.append(word1[i1])
                i1 += 1
            else:
                ans.append(word2[i2])
                i2 += 1
        return "".join(ans) + word1[i1:] + word2[i2:]


    """1755. Closest Subsequence Sum (Hard)
    You are given an integer array nums and an integer goal. You want to choose
    a subsequence of nums such that the sum of its elements is the closest
    possible to goal. That is, if the sum of the subsequence's elements is sum,
    then you want to minimize the absolute difference abs(sum - goal). Return
    the minimum possible value of abs(sum - goal). Note that a subsequence of
    an array is an array formed by removing some elements (possibly all or none)
    of the original array.

    Example 1:
    Input: nums = [5,-7,3,5], goal = 6
    Output: 0
    Explanation: Choose the whole array as a subsequence, with a sum of 6. This
                 is equal to the goal, so the absolute difference is 0.

    Example 2:
    Input: nums = [7,-9,15,-2], goal = -5
    Output: 1
    Explanation: Choose the subsequence [7,-9,-2], with a sum of -4. The
                 absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is
                 the minimum.

    Example 3:
    Input: nums = [1,2,3], goal = -7
    Output: 7

    Constraints:
    * 1 <= nums.length <= 40
    * -10^7 <= nums[i] <= 10^7
    * -10^9 <= goal <= 10^9"""

    def minAbsDifference(self, nums: List[int], goal: int) -> int:

        def fn(nums):
            ans = {0}
            for x in nums:
                ans |= {x + y for y in ans}
            return ans

        nums0 = sorted(fn(nums[:len(nums)//2]))
        nums1 = sorted(fn(nums[len(nums)//2:]))

        ans = inf
        k = len(nums1)-1
        for x in nums0:
            while 0 <= k and x + nums1[k] > goal: k -= 1
            if 0 <= k: ans = min(ans, goal - x - nums1[k])
            if k+1 < len(nums1): ans = min(ans, nums1[k+1] + x - goal)
        return ans


    """1758. Minimum Changes To Make Alternating Binary String (Easy)
    You are given a string s consisting only of the characters '0' and '1'. In
    one operation, you can change any '0' to '1' or vice versa. The string is
    called alternating if no two adjacent characters are equal. For example,
    the string "010" is alternating, while the string "0100" is not. Return the
    minimum number of operations needed to make s alternating.

    Example 1:
    Input: s = "0100"
    Output: 1
    Explanation: If you change the last character to '1', s will be "0101", which is alternating.

    Example 2:
    Input: s = "10"
    Output: 0
    Explanation: s is already alternating.

    Example 3:
    Input: s = "1111"
    Output: 2
    Explanation: You need two operations to reach "0101" or "1010".

    Constraints:
    * 1 <= s.length <= 10^4
    * s[i] is either '0' or '1'."""

    def minOperations(self, s: str) -> int:
        cnt = 0 # "010101..."
        for i, c in enumerate(s):
            if i&1 == int(c): cnt += 1
        return min(cnt, len(s) - cnt)


    """1759. Count Number of Homogenous Substrings (Medium)
    Given a string s, return the number of homogenous substrings of s. Since
    the answer may be too large, return it modulo 10^9 + 7.  string is
    homogenous if all the characters of the string are the same. A substring
    is a contiguous sequence of characters within a string.

    Example 1:
    Input: s = "abbcccaa"
    Output: 13
    Explanation: The homogenous substrings are listed as below:
    "a"   appears 3 times.
    "aa"  appears 1 time.
    "b"   appears 2 times.
    "bb"  appears 1 time.
    "c"   appears 3 times.
    "cc"  appears 2 times.
    "ccc" appears 1 time.
    3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.

    Example 2:
    Input: s = "xy"
    Output: 2
    Explanation: The homogenous substrings are "x" and "y".

    Example 3:
    Input: s = "zzzzz"
    Output: 15

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase letters."""

    def countHomogenous(self, s: str) -> int:
        ans = ii = 0
        for i in range(len(s)):
            if s[ii] != s[i]: ii = i
            ans += i - ii + 1
        return ans % 1_000_000_007


    """1760. Minimum Limit of Balls in a Bag (Medium)
    You are given an integer array nums where the ith bag contains nums[i]
    balls. You are also given an integer maxOperations. You can perform the
    following operation at most maxOperations times:
    * Take any bag of balls and divide it into two new bags with a positive
      number of balls.
      + For example, a bag of 5 balls can become two new bags of 1 and 4 balls,
        or two new bags of 2 and 3 balls.
    Your penalty is the maximum number of balls in a bag. You want to minimize
    your penalty after the operations. Return the minimum possible penalty
    after performing the operations.

    Example 1:
    Input: nums = [9], maxOperations = 2
    Output: 3
    Explanation:
    - Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -> [6,3].
    - Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -> [3,3,3].
    The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.

    Example 2:
    Input: nums = [2,4,8,2], maxOperations = 4
    Output: 2
    Explanation:
    - Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -> [2,4,4,4,2].
    - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -> [2,2,2,4,4,2].
    - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -> [2,2,2,2,2,4,2].
    - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2].
    The bag with the most number of balls has 2 balls, so your penalty is 2 an you should return 2.

    Example 3:
    Input: nums = [7,17], maxOperations = 2
    Output: 7

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= maxOperations, nums[i] <= 10^9"""

    def minimumSize(self, nums: List[int], maxOperations: int) -> int:
        lo, hi = 1, 1_000_000_000
        while lo < hi:
            mid = lo + hi >> 1
            if sum((x-1)//mid for x in nums) <= maxOperations: hi = mid
            else: lo = mid + 1
        return lo


    """1761. Minimum Degree of a Connected Trio in a Graph (Hard)
    You are given an undirected graph. You are given an integer n which is the
    number of nodes in the graph and an array edges, where each edges[i] = [ui, vi]
    indicates that there is an undirected edge between ui and vi. A connected
    trio is a set of three nodes where there is an edge between every pair of
    them. The degree of a connected trio is the number of edges where one
    endpoint is in the trio, and the other is not. Return the minimum degree of
    a connected trio in the graph, or -1 if the graph has no connected trios.

    Example 1:
    Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]
    Output: 3
    Explanation: There is exactly one trio, which is [1,2,3]. The edges that
                 form its degree are bolded in the figure above.

    Example 2:
    Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]
    Output: 0
    Explanation: There are exactly three trios:
    1) [1,4,3] with degree 0.
    2) [2,5,6] with degree 2.
    3) [5,6,7] with degree 2.

    Constraints:
    * 2 <= n <= 400
    * edges[i].length == 2
    * 1 <= edges.length <= n * (n-1) / 2
    * 1 <= ui, vi <= n
    * ui != vi
    * There are no repeated edges."""

    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        graph = [[False]*n for _ in range(n)]
        degree = [0]*n

        for u, v in edges:
            graph[u-1][v-1] = graph[v-1][u-1] = True
            degree[u-1] += 1
            degree[v-1] += 1

        ans = inf
        for i in range(n):
            for j in range(i+1, n):
                if graph[i][j]:
                    for k in range(j+1, n):
                        if graph[j][k] and graph[k][i]:
                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6)
        return ans if ans < inf else -1


    """1762. Buildings With an Ocean View (Medium)
    There are n buildings in a line. You are given an integer array heights of
    size n that represents the heights of the buildings in the line. The ocean
    is to the right of the buildings. A building has an ocean view if the
    building can see the ocean without obstructions. Formally, a building has
    an ocean view if all the buildings to its right have a smaller height.
    Return a list of indices (0-indexed) of buildings that have an ocean view,
    sorted in increasing order.

    Example 1:
    Input: heights = [4,2,3,1]
    Output: [0,2,3]
    Explanation: Building 1 (0-indexed) does not have an ocean view because building 2 is taller.

    Example 2:
    Input: heights = [4,3,2,1]
    Output: [0,1,2,3]
    Explanation: All the buildings have an ocean view.

    Example 3:
    Input: heights = [1,3,2,4]
    Output: [3]
    Explanation: Only building 3 has an ocean view.

    Example 4:
    Input: heights = [2,2,2,2]
    Output: [3]
    Explanation: Buildings cannot see the ocean if there are buildings of the same height to its right.

    Constraints:
    * 1 <= heights.length <= 10^5
    * 1 <= heights[i] <= 10^9"""

    def findBuildings(self, heights: List[int]) -> List[int]:
        stack = []
        for i, x in enumerate(heights):
            while stack and heights[stack[-1]] <= x: stack.pop()
            stack.append(i)
        return stack


    """1763. Longest Nice Substring (Easy)
    A string s is nice if, for every letter of the alphabet that s contains, it
    appears both in uppercase and lowercase. For example, "abABB" is nice
    because 'A' and 'a' appear, and 'B' and 'b' appear. However, "abA" is not
    because 'b' appears, but 'B' does not. Given a string s, return the longest
    substring of s that is nice. If there are multiple, return the substring of
    the earliest occurrence. If there are none, return an empty string.

    Example 1:
    Input: s = "YazaAay"
    Output: "aAa"
    Explanation: "aAa" is a nice string because 'A/a' is the only letter of the
                 alphabet in s, and both 'A' and 'a' appear. "aAa" is the
                 longest nice substring.

    Example 2:
    Input: s = "Bb"
    Output: "Bb"
    Explanation: "Bb" is a nice string because both 'B' and 'b' appear. The
                 whole string is a substring.

    Example 3:
    Input: s = "c"
    Output: ""
    Explanation: There are no nice substrings.

    Example 4:
    Input: s = "dDzeE"
    Output: "dD"
    Explanation: Both "dD" and "eE" are the longest nice substrings. As there
                 are multiple longest nice substrings, return "dD" since it
                 occurs earlier.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of uppercase and lowercase English letters."""

    def longestNiceSubstring(self, s: str) -> str:
        if s:
            ss = set(s)
            for i, ch in enumerate(s):
                if ch.swapcase() not in ss:
                    s0 = self.longestNiceSubstring(s[:i])
                    s1 = self.longestNiceSubstring(s[i+1:])
                    return max(s0, s1, key=len)
        return s


    """1764. Form Array by Concatenating Subarrays of Another Array (Medium)
    You are given a 2D integer array groups of length n. You are also given an
    integer array nums. You are asked if you can choose n disjoint subarrays
    from the array nums such that the ith subarray is equal to groups[i]
    (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith
    subarray in nums (i.e. the subarrays must be in the same order as groups).
    Return true if you can do this task, and false otherwise. Note that the
    subarrays are disjoint if and only if there is no index k such that nums[k]
    belongs to more than one subarray. A subarray is a contiguous sequence of
    elements within an array.

    Example 1:
    Input: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]
    Output: true
    Explanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and
                 the 1st one as [1,-1,0,1,-1,-1,3,-2,0]. These subarrays are
                 disjoint as they share no common nums[k] element.

    Example 2:
    Input: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]
    Output: false
    Explanation: Note that choosing the subarrays [1,2,3,4,10,-2] and
                 [1,2,3,4,10,-2] is incorrect because they are not in the same
                 order as in groups. [10,-2] must come before [1,2,3,4].

    Example 3:
    Input: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]
    Output: false
    Explanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and
                 [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.
                 They share a common elements nums[4] (0-indexed).

    Constraints:
    * groups.length == n
    * 1 <= n <= 10^3
    * 1 <= groups[i].length, sum(groups[i].length) <= 10^3
    * 1 <= nums.length <= 10^3
    * -10^7 <= groups[i][j], nums[k] <= 10^7"""

    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:
        i = 0
        for grp in groups:
            for ii in range(i, len(nums)):
                if nums[ii:ii+len(grp)] == grp:
                    i = ii + len(grp)
                    break
            else: return False
        return True


    """1765. Map of Highest Peak (Medium)
    You are given an integer matrix isWater of size m x n that represents a map
    of land and water cells.
    * If isWater[i][j] == 0, cell (i, j) is a land cell.
    * If isWater[i][j] == 1, cell (i, j) is a water cell.
    You must assign each cell a height in a way that follows these rules:
    * The height of each cell must be non-negative.
    * If the cell is a water cell, its height must be 0.
    * Any two adjacent cells must have an absolute height difference of at most
      1. A cell is adjacent to another cell if the former is directly north,
      east, south, or west of the latter (i.e., their sides are touching).
    Find an assignment of heights such that the maximum height in the matrix is
    maximized. Return an integer matrix height of size m x n where height[i][j]
    is cell (i, j)'s height. If there are multiple solutions, return any of them.

    Example 1:
    Input: isWater = [[0,1],[0,0]]
    Output: [[1,0],[2,1]]
    Explanation: The image shows the assigned heights of each cell. The blue
                 cell is the water cell, and the green cells are the land cells.

    Example 2:
    Input: isWater = [[0,0,1],[1,0,0],[0,0,0]]
    Output: [[1,1,0],[0,1,1],[1,2,2]]
    Explanation: A height of 2 is the maximum possible height of any assignment.
                 Any height assignment that has a maximum height of 2 while
                 still meeting the rules will also be accepted.

    Constraints:
    * m == isWater.length
    * n == isWater[i].length
    * 1 <= m, n <= 1000
    * isWater[i][j] is 0 or 1.
    * There is at least one water cell."""

    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:
        m, n = len(isWater), len(isWater[0]) # dimensions

        ans = [[-1]*n for _ in range(m)]
        queue = deque()
        for i in range(m):
            for j in range(n):
                if isWater[i][j]:
                    queue.append((i, j))
                    ans[i][j] = 0

        while queue:
            i, j = queue.popleft()
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and ans[ii][jj] == -1:
                    ans[ii][jj] = 1 + ans[i][j]
                    queue.append((ii, jj))
        return ans


    """1766. Tree of Coprimes (Hard)
    There is a tree (i.e., a connected, undirected graph that has no cycles)
    consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges.
    Each node has a value associated with it, and the root of the tree is node
    0. To represent this tree, you are given an integer array nums and a 2D
    array edges. Each nums[i] represents the ith node's value, and each
    edges[j] = [uj, vj] represents an edge between nodes uj and vj in the tree.
    Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the
    greatest common divisor of x and y. An ancestor of a node i is any other
    node on the shortest path from node i to the root. A node is not considered
    an ancestor of itself. Return an array ans of size n, where ans[i] is the
    closest ancestor to node i such that nums[i] and nums[ans[i]] are coprime,
    or -1 if there is no such ancestor.

    Example 1:
    Input: nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]
    Output: [-1,0,0,1]
    Explanation: In the above figure, each node's value is in parentheses.
    - Node 0 has no coprime ancestors.
    - Node 1 has only one ancestor, node 0. Their values are coprime
      (gcd(2,3) == 1).
    - Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime
      (gcd(3,3) == 3), but node 0's value is (gcd(2,3) == 1), so node 0 is the
      closest valid ancestor.
    - Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1
      (gcd(3,2) == 1), so node 1 is its closest valid ancestor.

    Example 2:
    Input: nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
    Output: [-1,0,-1,0,0,0,-1]

    Constraints:
    * nums.length == n
    * 1 <= nums[i] <= 50
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[j].length == 2
    * 0 <= uj, vj < n
    * uj != vj"""

    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        tree = {} # tree as adjacency list
        for u, v in edges:
            tree.setdefault(u, []).append(v)
            tree.setdefault(v, []).append(u)

        ans = [-1]*len(nums)
        path = {} # val -> list of position & depth
        seen = {0}

        def fn(k, i):
            """Populate ans via dfs."""
            ii = -1
            for x in path:
                if gcd(nums[k], x) == 1: # coprime
                    if path[x] and path[x][-1][1] > ii:
                        ans[k] = path[x][-1][0]
                        ii = path[x][-1][1]

            path.setdefault(nums[k], []).append((k, i))
            for kk in tree.get(k, []):
                if kk not in seen:
                    seen.add(kk)
                    fn(kk, i+1)
            path[nums[k]].pop()

        fn(0, 0)
        return ans


    """1768. Merge Strings Alternately (Easy)
    You are given two strings word1 and word2. Merge the strings by adding
    letters in alternating order, starting with word1. If a string is longer
    than the other, append the additional letters onto the end of the merged
    string. Return the merged string.

    Example 1:
    Input: word1 = "abc", word2 = "pqr"
    Output: "apbqcr"
    Explanation: The merged string will be merged as so:
                 word1:  a   b   c
                 word2:    p   q   r
                 merged: a p b q c r

    Example 2:
    Input: word1 = "ab", word2 = "pqrs"
    Output: "apbqrs"
    Explanation: Notice that as word2 is longer, "rs" is appended to the end.
                 word1:  a   b
                 word2:    p   q   r   s
                 merged: a p b q   r   s

    Example 3:
    Input: word1 = "abcd", word2 = "pq"
    Output: "apbqcd"
    Explanation: Notice that as word1 is longer, "cd" is appended to the end.
                 word1:  a   b   c   d
                 word2:    p   q
                 merged: a p b q c   d

    Constraints:
    * 1 <= word1.length, word2.length <= 100
    * word1 and word2 consist of lowercase English letters."""

    def mergeAlternately(self, word1: str, word2: str) -> str:
        return "".join(x+y for x, y in zip_longest(word1, word2, fillvalue=""))


    """1769. Minimum Number of Operations to Move All Balls to Each Box (Medium)
    You have n boxes. You are given a binary string boxes of length n, where
    boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball.
    In one operation, you can move one ball from a box to an adjacent box. Box
    i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there
    may be more than one ball in some boxes. Return an array answer of size n,
    where answer[i] is the minimum number of operations needed to move all the
    balls to the ith box. Each answer[i] is calculated considering the initial
    state of the boxes.

    Example 1:
    Input: boxes = "110"
    Output: [1,1,3]
    Explanation: The answer for each box is as follows:
                 1) First box: you will have to move one ball from the second box to the first box in one operation.
                 2) Second box: you will have to move one ball from the first box to the second box in one operation.
                 3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.

    Example 2:
    Input: boxes = "001011"
    Output: [11,8,5,4,3,4]

    Constraints:
    * n == boxes.length
    * 1 <= n <= 2000
    * boxes[i] is either '0' or '1'."""

    def minOperations(self, boxes: str) -> List[int]:
        ans = []
        ops = cnt = 0 # count of remaining "1"s
        for i, x in enumerate(boxes):
            if x == "1":
                ops += i
                cnt += 1

        for i, x in enumerate(boxes):
            ans.append(ops)
            if x == "1": cnt -= 2
            ops -= cnt
        return ans


    """1770. Maximum Score from Performing Multiplication Operations (Medium)
    You are given two integer arrays nums and multipliers of size n and m
    respectively, where n >= m. The arrays are 1-indexed. You begin with a
    score of 0. You want to perform exactly m operations. On the ith operation
    (1-indexed), you will:
    * Choose one integer x from either the start or the end of the array nums.
    * Add multipliers[i] * x to your score.
    * Remove x from the array nums.
    Return the maximum score after performing m operations.

    Example 1:
    Input: nums = [1,2,3], multipliers = [3,2,1]
    Output: 14
    Explanation: An optimal solution is as follows:
    - Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.
    - Choose from the end, [1,2], adding 2 * 2 = 4 to the score.
    - Choose from the end, [1], adding 1 * 1 = 1 to the score.
    The total score is 9 + 4 + 1 = 14.

    Example 2:
    Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
    Output: 102
    Explanation: An optimal solution is as follows:
    - Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.
    - Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.
    - Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.
    - Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.
    - Choose from the end, [-2,7], adding 7 * 6 = 42 to the score.
    The total score is 50 + 15 - 9 + 4 + 42 = 102.

    Constraints:
    * n == nums.length
    * m == multipliers.length
    * 1 <= m <= 10^3
    * m <= n <= 10^5
    * -1000 <= nums[i], multipliers[i] <= 1000"""

    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
        n, m = len(nums), len(multipliers)
        dp = [[0]*m for _ in range(m+1)]

        for i in reversed(range(m)):
            for j in range(i, m):
                k = i + m - j - 1
                dp[i][j] = max(nums[i] * multipliers[k] + dp[i+1][j], nums[j-m+n] * multipliers[k] + dp[i][j-1])

        return dp[0][-1]


    """1771. Maximize Palindrome Length From Subsequences (Hard)
    You are given two strings, word1 and word2. You want to construct a string
    in the following manner:
    * Choose some non-empty subsequence subsequence1 from word1.
    * Choose some non-empty subsequence subsequence2 from word2.
    * Concatenate the subsequences: subsequence1 + subsequence2, to make the
      string.
    Return the length of the longest palindrome that can be constructed in the
    described manner. If no palindromes can be constructed, return 0. A
    subsequence of a string s is a string that can be made by deleting some
    (possibly none) characters from s without changing the order of the
    remaining characters. A palindrome is a string that reads the same forward
    as well as backward.

    Example 1:
    Input: word1 = "cacb", word2 = "cbba"
    Output: 5
    Explanation: Choose "ab" from word1 and "cba" from word2 to make "abcba",
                 which is a palindrome.

    Example 2:
    Input: word1 = "ab", word2 = "ab"
    Output: 3
    Explanation: Choose "ab" from word1 and "a" from word2 to make "aba", which
                 is a palindrome.

    Example 3:
    Input: word1 = "aa", word2 = "bb"
    Output: 0
    Explanation: You cannot construct a palindrome from the described method,
                 so return 0.

    Constraints:
    * 1 <= word1.length, word2.length <= 1000
    * word1 and word2 consist of lowercase English letters."""

    def longestPalindrome(self, word1: str, word2: str) -> int:

        @cache
        def fn(lo, hi):
            """Return length of longest palindromic subsequence."""
            if lo >= hi: return int(lo == hi)
            if word[lo] == word[hi]: return 2 + fn(lo+1, hi-1)
            return max(fn(lo+1, hi), fn(lo, hi-1))

        ans = 0
        word = word1 + word2
        for x in ascii_lowercase:
            i = word1.find(x)
            j = word2.rfind(x)
            if i != -1 and j != -1: ans = max(ans, fn(i, j+len(word1)))
        return ans


    """1772. Sort Features by Popularity (Medium)
    You are given a string array features where features[i] is a single word
    that represents the name of a feature of the latest product you are working
    on. You have made a survey where users have reported which features they
    like. You are given a string array responses, where each responses[i] is a
    string containing space-separated words. The popularity of a feature is the
    number of responses[i] that contain the feature. You want to sort the
    features in non-increasing order by their popularity. If two features have
    the same popularity, order them by their original index in features. Notice
    that one response could contain the same feature multiple times; this
    feature is only counted once in its popularity. Return the features in
    sorted order.

    Example 1:
    Input: features = ["cooler","lock","touch"],
           responses = ["i like cooler cooler","lock touch cool","locker like touch"]
    Output: ["touch","cooler","lock"]
    Explanation: appearances("cooler") = 1, appearances("lock") = 1,
                 appearances("touch") = 2. Since "cooler" and "lock" both had 1
                 appearance, "cooler" comes first because "cooler" came first
                 in the features array.

    Example 2:
    Input: features = ["a","aa","b","c"], responses = ["a","a aa","a a a a a","b a"]
    Output: ["a","aa","b","c"]

    Constraints:
    * 1 <= features.length <= 10^4
    * 1 <= features[i].length <= 10
    * features contains no duplicates.
    * features[i] consists of lowercase letters.
    * 1 <= responses.length <= 10^2
    * 1 <= responses[i].length <= 10^3
    * responses[i] consists of lowercase letters and spaces.
    * responses[i] contains no two consecutive spaces.
    * responses[i] has no leading or trailing spaces."""

    def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:
        freq = defaultdict(int)
        for response in responses:
            words = set(response.split())
            for feature in features:
                if feature in words: freq[feature] += 1
        return sorted(features, key=lambda x: freq.get(x, 0), reverse=True)


    """1773. Count Items Matching a Rule (Easy)
    You are given an array items, where each items[i] = [typei, colori, namei]
    describes the type, color, and name of the ith item. You are also given a
    rule represented by two strings, ruleKey and ruleValue. The ith item is
    said to match the rule if one of the following is true:
    * ruleKey == "type" and ruleValue == typei.
    * ruleKey == "color" and ruleValue == colori.
    * ruleKey == "name" and ruleValue == namei.
    Return the number of items that match the given rule.

    Example 1:
    Input: items = [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], ruleKey = "color", ruleValue = "silver"
    Output: 1
    Explanation: There is only one item matching the given rule, which is ["computer","silver","lenovo"].

    Example 2:
    Input: items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], ruleKey = "type", ruleValue = "phone"
    Output: 2
    Explanation: There are only two items matching the given rule, which are ["phone","blue","pixel"] and ["phone","gold","iphone"]. Note that the item ["computer","silver","phone"] does not match.

    Constraints:
    * 1 <= items.length <= 10^4
    * 1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10
    * ruleKey is equal to either "type", "color", or "name".
    * All strings consist only of lowercase letters."""

    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        return sum(1 for t, c, n in items if (ruleKey, ruleValue) in (("type", t), ("color", c), ("name", n)))


    """1774. Closest Dessert Cost (Medium)
    You would like to make dessert and are preparing to buy the ingredients.
    You have n ice cream base flavors and m types of toppings to choose from.
    You must follow these rules when making your dessert:
    * There must be exactly one ice cream base.
    * You can add one or more types of topping or have no toppings at all.
    * There are at most two of each type of topping.
    You are given three inputs:
    * baseCosts, an integer array of length n, where each baseCosts[i]
      represents the price of the ith ice cream base flavor.
    * toppingCosts, an integer array of length m, where each toppingCosts[i] is
      the price of one of the ith topping.
    * target, an integer representing your target price for dessert.
    You want to make a dessert with a total cost as close to target as possible.
    Return the closest possible cost of the dessert to target. If there are
    multiple, return the lower one.

    Example 1:
    Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10
    Output: 10
    Explanation: Consider the following combination (all 0-indexed):
    - Choose base 1: cost 7
    - Take 1 of topping 0: cost 1 x 3 = 3
    - Take 0 of topping 1: cost 0 x 4 = 0
    Total: 7 + 3 + 0 = 10.

    Example 2:
    Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18
    Output: 17
    Explanation: Consider the following combination (all 0-indexed):
    - Choose base 1: cost 3
    - Take 1 of topping 0: cost 1 x 4 = 4
    - Take 2 of topping 1: cost 2 x 5 = 10
    - Take 0 of topping 2: cost 0 x 100 = 0
    Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.

    Example 3:
    Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9
    Output: 8
    Explanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.

    Example 4:
    Input: baseCosts = [10], toppingCosts = [1], target = 1
    Output: 10
    Explanation: Notice that you don't have to have any toppings, but you must have exactly one base.

    Constraints:
    * n == baseCosts.length
    * m == toppingCosts.length
    * 1 <= n, m <= 10
    * 1 <= baseCosts[i], toppingCosts[i] <= 10^4
    * 1 <= target <= 10^4"""

    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:

        @cache
        def fn(i, cost):
            """Return sum of subsequence closest to target."""
            if cost >= target or i == len(toppingCosts): return cost
            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))

        ans = inf
        toppingCosts *= 2
        for cost in baseCosts:
            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))
        return ans


    """1775. Equal Sum Arrays With Minimum Number of Operations (Medium)
    You are given two arrays of integers nums1 and nums2, possibly of different
    lengths. The values in the arrays are between 1 and 6, inclusive. In one
    operation, you can change any integer's value in any of the arrays to any
    value between 1 and 6, inclusive. Return the minimum number of operations
    required to make the sum of values in nums1 equal to the sum of values in
    nums2. Return -1​​​​​ if it is not possible to make the sum of the two arrays
    equal.

    Example 1:
    Input: nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]
    Output: 3
    Explanation: You can make the sums of nums1 and nums2 equal with 3
    operations. All indices are 0-indexed.
    - Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2].
    - Change nums1[5] to 1. nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2].
    - Change nums1[2] to 2. nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2].

    Example 2:
    Input: nums1 = [1,1,1,1,1,1,1], nums2 = [6]
    Output: -1
    Explanation: There is no way to decrease the sum of nums1 or to increase
    the sum of nums2 to make them equal.

    Example 3:
    Input: nums1 = [6,6], nums2 = [1]
    Output: 3
    Explanation: You can make the sums of nums1 and nums2 equal with 3
    operations. All indices are 0-indexed.
    - Change nums1[0] to 2. nums1 = [2,6], nums2 = [1].
    - Change nums1[1] to 2. nums1 = [2,2], nums2 = [1].
    - Change nums2[0] to 4. nums1 = [2,2], nums2 = [4].

    Constraints:
    * 1 <= nums1.length, nums2.length <= 10^5
    * 1 <= nums1[i], nums2[i] <= 6"""

    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
        if 6*len(nums1) < len(nums2) or 6*len(nums2) < len(nums1): return -1 # impossible

        if sum(nums1) < sum(nums2): nums1, nums2 = nums2, nums1
        s1, s2 = sum(nums1), sum(nums2) # s1 >= s2

        nums1.sort()
        nums2.sort()

        ans = j = 0
        i = len(nums1)-1

        while s1 > s2:
            if j >= len(nums2) or 0 <= i and nums1[i] - 1 > 6 - nums2[j]:
                s1 += 1 - nums1[i]
                i -= 1
            else:
                s2 += 6 - nums2[j]
                j += 1
            ans += 1
        return ans


    """1776. Car Fleet II (Hard)
    There are n cars traveling at different speeds in the same direction along
    a one-lane road. You are given an array cars of length n, where
    cars[i] = [position_i, speed_i] represents:
    * positioni is the distance between the ith car and the beginning of the
      road in meters. It is guaranteed that position_i < position_{i+1}.
    * speedi is the initial speed of the ith car in meters per second.
    For simplicity, cars can be considered as points moving along the number
    line. Two cars collide when they occupy the same position. Once a car
    collides with another car, they unite and form a single car fleet. The cars
    in the formed fleet will have the same position and the same speed, which
    is the initial speed of the slowest car in the fleet. Return an array
    answer, where answer[i] is the time, in seconds, at which the ith car
    collides with the next car, or -1 if the car does not collide with the next
    car. Answers within 10^-5 of the actual answers are accepted.

    Example 1:
    Input: cars = [[1,2],[2,1],[4,3],[7,2]]
    Output: [1.00000,-1.00000,3.00000,-1.00000]
    Explanation: After exactly one second, the first car will collide with the
                 second car, and form a car fleet with speed 1 m/s. After
                 exactly 3 seconds, the third car will collide with the fourth
                 car, and form a car fleet with speed 2 m/s.

    Example 2:
    Input: cars = [[3,4],[5,4],[6,3],[9,1]]
    Output: [2.00000,1.00000,1.50000,-1.00000]

    Constraints:
    * 1 <= cars.length <= 10^5
    * 1 <= position_i, speedi <= 10^6
    * position_i < position_{i+1}"""

    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        ans = [-1]*len(cars)
        stack = []
        for i, (x, v) in enumerate(reversed(cars)):
            while stack and (v <= stack[-1][1] or (stack[-1][0] - x)/(v - stack[-1][1]) >= stack[-1][2]): stack.pop()
            if stack:
                t = (stack[-1][0] - x)/(v - stack[-1][1])
                stack.append((x, v, t))
                ans[~i] = t
            else:
                stack.append((x, v, inf))
        return ans


    """1778. Shortest Path in a Hidden Grid (Medium)
    This is an interactive problem. There is a robot in a hidden grid, and you
    are trying to get it from its starting cell to the target cell in this grid.
    The grid is of size m x n, and each cell in the grid is either empty or
    blocked. It is guaranteed that the starting cell and the target cell are
    different, and neither of them is blocked. You want to find the minimum
    distance to the target cell. However, you do not know the grid's dimensions,
    the starting cell, nor the target cell. You are only allowed to ask queries
    to the GridMaster object. Thr GridMaster class has the following functions:
    * boolean canMove(char direction) Returns true if the robot can move in
      that direction. Otherwise, it returns false.
    * void move(char direction) Moves the robot in that direction. If this move
      would move the robot to a blocked cell or off the grid, the move will be
      ignored, and the robot will remain in the same position.
    * boolean isTarget() Returns true if the robot is currently on the target
      cell. Otherwise, it returns false.
    Note that direction in the above functions should be a character from
    {'U','D','L','R'}, representing the directions up, down, left, and right,
    respectively. Return the minimum distance between the robot's initial
    starting cell and the target cell. If there is no valid path between the
    cells, return -1.

    Custom testing:
    The test input is read as a 2D matrix grid of size m x n where:
    * grid[i][j] == -1 indicates that the robot is in cell (i, j) (the starting
      cell).
    * grid[i][j] == 0 indicates that the cell (i, j) is blocked.
    * grid[i][j] == 1 indicates that the cell (i, j) is empty.
    * grid[i][j] == 2 indicates that the cell (i, j) is the target cell.
    There is exactly one -1 and 2 in grid. Remember that you will not have this
    information in your code.

    Example 1:
    Input: grid = [[1,2],[-1,0]]
    Output: 2
    Explanation: One possible interaction is described below:
                 The robot is initially standing on cell (1, 0), denoted by the
                 -1.
                 - master.canMove('U') returns true.
                 - master.canMove('D') returns false.
                 - master.canMove('L') returns false.
                 - master.canMove('R') returns false.
                 - master.move('U') moves the robot to the cell (0, 0).
                 - master.isTarget() returns false.
                 - master.canMove('U') returns false.
                 - master.canMove('D') returns true.
                 - master.canMove('L') returns false.
                 - master.canMove('R') returns true.
                 - master.move('R') moves the robot to the cell (0, 1).
                 - master.isTarget() returns true.
                 We now know that the target is the cell (0, 1), and the
                 shortest path to the target cell is 2.

    Example 2:
    Input: grid = [[0,0,-1],[1,1,1],[2,0,0]]
    Output: 4
    Explanation: The minimum distance between the robot and the target cell is
                 4.

    Example 3:
    Input: grid = [[-1,0],[0,2]]
    Output: -1
    Explanation: There is no path from the robot to the target cell.

    Constraints:
    * 1 <= n, m <= 500
    * m == grid.length
    * n == grid[i].length
    * grid[i][j] is either -1, 0, 1, or 2.
    * There is exactly one -1 in grid.
    * There is exactly one 2 in grid."""

    def findShortestPath(self, master: 'GridMaster') -> int:
        diff = {'U' : (0, 1), 'D' : (0, -1), 'L' : (-1, 0), 'R' : (1, 0)}
        oppo = {'U' : 'D', 'D' : 'U', 'L' : 'R', 'R' : 'L'}
        graph = {}

        def dfs(x, y):
            graph[x, y] = master.isTarget()
            for ch in "UDLR":
                if master.canMove(ch):
                    dx, dy = diff[ch]
                    xx, yy = x+dx, y+dy
                    if (xx, yy) not in graph:
                        master.move(ch)
                        dfs(xx, yy)
                        master.move(oppo[ch])

        dfs(0, 0)
        ans = 0
        seen = {(0, 0)}
        queue = deque([(0, 0)])
        while queue:
            for _ in range(len(queue)):
                x, y = queue.popleft()
                if graph[x, y]: return ans
                for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y):
                    if (xx, yy) in graph and (xx, yy) not in seen:
                        seen.add((xx, yy))
                        queue.append((xx, yy))
            ans += 1
        return -1


    """1779. Find Nearest Point That Has the Same X or Y Coordinate (Easy)
    You are given two integers, x and y, which represent your current location
    on a Cartesian grid: (x, y). You are also given an array points where each
    points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is
    valid if it shares the same x-coordinate or the same y-coordinate as your
    location. Return the index (0-indexed) of the valid point with the smallest
    Manhattan distance from your current location. If there are multiple,
    return the valid point with the smallest index. If there are no valid
    points, return -1. The Manhattan distance between two points (x1, y1) and
    (x2, y2) is abs(x1 - x2) + abs(y1 - y2).

    Example 1:
    Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]
    Output: 2
    Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of
                 the valid points, [2,4] and [4,4] have the smallest Manhattan
                 distance from your current location, with a distance of 1.
                 [2,4] has the smallest index, so return 2.

    Example 2:
    Input: x = 3, y = 4, points = [[3,4]]
    Output: 0
    Explanation: The answer is allowed to be on the same location as your
                 current location.

    Example 3:
    Input: x = 3, y = 4, points = [[2,3]]
    Output: -1
    Explanation: There are no valid points.

    Constraints:
    * 1 <= points.length <= 10^4
    * points[i].length == 2
    * 1 <= x, y, ai, bi <= 10^4"""

    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        ans = -1
        dist = inf
        for i, (xx, yy) in enumerate(points):
            if (x == xx or y == yy) and abs(x-xx) + abs(y-yy) < dist:
                ans = i
                dist = abs(x-xx) + abs(y-yy)
        return ans


    """1780. Check if Number is a Sum of Powers of Three (Medium)
    Given an integer n, return true if it is possible to represent n as the sum
    of distinct powers of three. Otherwise, return false. An integer y is a
    power of three if there exists an integer x such that y == 3x.

    Example 1:
    Input: n = 12
    Output: true
    Explanation: 12 = 31 + 32

    Example 2:
    Input: n = 91
    Output: true
    Explanation: 91 = 30 + 32 + 34

    Example 3:
    Input: n = 21
    Output: false

    Constraints: 1 <= n <= 10^7"""

    def checkPowersOfThree(self, n: int) -> bool:
        while n:
            n, r = divmod(n, 3)
            if r == 2: return False
        return True


    """1781. Sum of Beauty of All Substrings (Medium)
    The beauty of a string is the difference in frequencies between the most
    frequent and least frequent characters. For example, the beauty of "abaacc"
    is 3 - 1 = 2. Given a string s, return the sum of beauty of all of its
    substrings.

    Example 1:
    Input: s = "aabcb"
    Output: 5
    Explanation: The substrings with non-zero beauty are
                 ["aab","aabc","aabcb","abcb","bcb"], each with beauty equal to 1.

    Example 2:
    Input: s = "aabcbaa"
    Output: 17

    Constraints:
    * 1 <= s.length <= 500
    * s consists of only lowercase English letters."""

    def beautySum(self, s: str) -> int:
        ans = 0
        for i in range(len(s)):
            freq = [0]*26
            for ii in range(i, len(s)):
                freq[ord(s[ii])-97] += 1
                ans += max(freq) - min(x for x in freq if x)
        return ans


    """1782. Count Pairs Of Nodes (Hard)
    You are given an undirected graph represented by an integer n, which is the
    number of nodes, and edges, where edges[i] = [ui, vi] which indicates that
    there is an undirected edge between ui and vi. You are also given an integer
    array queries. The answer to the jth query is the number of pairs of nodes
    (a, b) that satisfy the following conditions:
    * a < b
    * cnt is strictly greater than queries[j], where cnt is the number of edges
      incident to a or b.
    Return an array answers such that answers.length == queries.length and
    answers[j] is the answer of the jth query. Note that there can be repeated
    edges.

    Example 1:
    Input: n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
    Output: [6,5]
    Explanation: The number of edges incident to at least one of each pair is
                 shown above.

    Example 2:
    Input: n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
    Output: [10,10,9,8,6]

    Constraints:
    * 2 <= n <= 2 * 10^4
    * 1 <= edges.length <= 10^5
    * 1 <= ui, vi <= n
    * ui != vi
    * 1 <= queries.length <= 20
    * 0 <= queries[j] < edges.length"""

    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        degree = [0]*n
        freq = defaultdict(int)
        for u, v in edges:
            degree[u-1] += 1
            degree[v-1] += 1
            freq[min(u-1, v-1), max(u-1, v-1)] += 1

        vals = sorted(degree)

        ans = []
        for query in queries:
            cnt = 0
            lo, hi = 0, n-1
            while lo < hi:
                if query < vals[lo] + vals[hi]:
                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid
                    hi -= 1
                else: lo += 1
            for u, v in freq:
                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1
            ans.append(cnt)
        return ans


    """1784. Check if Binary String Has at Most One Segment of Ones (Easy)
    Given a binary string s without leading zeros, return true if s contains
    at most one contiguous segment of ones. Otherwise, return false.

    Example 1:
    Input: s = "1001"
    Output: false
    Explanation: The ones do not form a contiguous segment.

    Example 2:
    Input: s = "110"
    Output: true

    Constraints:
    * 1 <= s.length <= 100
    * s[i] is either '0' or '1'.
    * s[0] is '1'."""

    def checkOnesSegment(self, s: str) -> bool:
        return "01" not in s


    """1785. Minimum Elements to Add to Form a Given Sum (Medium)
    You are given an integer array nums and two integers limit and goal. The
    array nums has an interesting property that abs(nums[i]) <= limit. Return
    the minimum number of elements you need to add to make the sum of the array
    equal to goal. The array must maintain its property that
    abs(nums[i]) <= limit. Note that abs(x) equals x if x >= 0, and -x
    otherwise.

    Example 1:
    Input: nums = [1,-1,1], limit = 3, goal = -4
    Output: 2
    Explanation: You can add -2 and -3, then the sum of the array will be
                 1 - 1 + 1 - 2 - 3 = -4.

    Example 2:
    Input: nums = [1,-10,9,1], limit = 100, goal = 0
    Output: 1

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= limit <= 10^6
    * -limit <= nums[i] <= limit
    * -10^9 <= goal <= 10^9"""

    def minElements(self, nums: List[int], limit: int, goal: int) -> int:
        return ceil(abs(goal - sum(nums))/limit)


    """1786. Number of Restricted Paths From First to Last Node (Medium)
    There is an undirected weighted connected graph. You are given a positive
    integer n which denotes that the graph has n nodes labeled from 1 to n, and
    an array edges where each edges[i] = [ui, vi, weighti] denotes that there
    is an edge between nodes ui and vi with weight equal to weighti. A path
    from node start to node end is a sequence of nodes [z0, z1, z2, ..., zk]
    such that z0 = start and zk = end and there is an edge between zi and zi+1
    where 0 <= i <= k-1. The distance of a path is the sum of the weights on
    the edges of the path. Let distanceToLastNode(x) denote the shortest
    distance of a path between node n and node x. A restricted path is a path
    that also satisfies that distanceToLastNode(zi) > distanceToLastNode(zi+1)
    where 0 <= i <= k-1. Return the number of restricted paths from node 1 to
    node n. Since that number may be too large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
    Output: 3
    Explanation: Each circle contains the node number in black and its
                 distanceToLastNode value in blue. The three restricted paths
                 are:
                 1) 1 --> 2 --> 5
                 2) 1 --> 2 --> 3 --> 5
                 3) 1 --> 3 --> 5

    Example 2:
    Input: n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
    Output: 1
    Explanation: Each circle contains the node number in black and its
                 distanceToLastNode value in blue. The only restricted path is
                 1 --> 3 --> 7.

    Constraints:
    * 1 <= n <= 2 * 10^4
    * n - 1 <= edges.length <= 4 * 10^4
    * edges[i].length == 3
    * 1 <= ui, vi <= n
    * ui != vi
    * 1 <= weighti <= 10^5
    * There is at most one edge between any two nodes.
    * There is at least one path between any two nodes."""

    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        graph = {} # graph as adjacency list
        for u, v, w in edges:
            graph.setdefault(u-1, []).append((v-1, w))
            graph.setdefault(v-1, []).append((u-1, w))

        # dijkstra's algo
        pq = [(0, n-1)]
        dist = [inf]*(n-1) + [0]
        while pq:
            d, u = heappop(pq)
            for v, w in graph[u]:
                if dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
                    heappush(pq, (dist[v], v))

        @cache
        def fn(u):
            """Return number of restricted paths from u to n."""
            if u == n-1: return 1 # boundary condition
            ans = 0
            for v, _ in graph[u]:
                if dist[u] > dist[v]: ans += fn(v)
            return ans

        return fn(0) % 1_000_000_007


    """1787. Make the XOR of All Segments Equal to Zero (Hard)
    You are given an array nums and an integer k. The XOR of a segment [left, right]
    where left <= right is the XOR of all the elements with indices between
    left and right, inclusive: nums[left] XOR nums[left+1] XOR ... XOR nums[right].
    Return the minimum number of elements to change in the array such that the
    XOR of all segments of size k is equal to zero.

    Example 1:
    Input: nums = [1,2,0,3,0], k = 1
    Output: 3
    Explanation: Modify the array from [1,2,0,3,0] to from [0,0,0,0,0].

    Example 2:
    Input: nums = [3,4,5,2,1,7,3,4,7], k = 3
    Output: 3
    Explanation: Modify the array from [3,4,5,2,1,7,3,4,7] to [3,4,7,3,4,7,3,4,7].

    Example 3:
    Input: nums = [1,2,4,1,2,5,1,2,6], k = 3
    Output: 3
    Explanation: Modify the array from [1,2,4,1,2,5,1,2,6] to [1,2,3,1,2,3,1,2,3].

    Constraints:
    * 1 <= k <= nums.length <= 2000
    * 0 <= nums[i] < 2^10"""

    def minChanges(self, nums: List[int], k: int) -> int:
        freq = defaultdict(lambda: defaultdict(int))
        for i, x in enumerate(nums): freq[i%k][x] += 1 # freq by row

        n = 1 << 10
        dp = [0] + [-inf]*(n-1)
        for i in range(k):
            mx = max(dp)
            tmp = [0]*n
            for x, c in enumerate(dp):
                for xx, cc in freq[i].items():
                    tmp[x^xx] = max(tmp[x^xx], c + cc, mx)
            dp = tmp
        return len(nums) - dp[0]


    """1788. Maximize the Beauty of the Garden (Hard)
    There is a garden of n flowers, and each flower has an integer beauty value.
    The flowers are arranged in a line. You are given an integer array flowers
    of size n and each flowers[i] represents the beauty of the ith flower. A
    garden is valid if it meets these conditions:
    * The garden has at least two flowers.
    * The first and the last flower of the garden have the same beauty value.
    As the appointed gardener, you have the ability to remove any (possibly
    none) flowers from the garden. You want to remove flowers in a way that
    makes the remaining garden valid. The beauty of the garden is the sum of
    the beauty of all the remaining flowers. Return the maximum possible beauty
    of some valid garden after you have removed any (possibly none) flowers.

    Example 1:
    Input: flowers = [1,2,3,1,2]
    Output: 8
    Explanation: You can produce the valid garden [2,3,1,2] to have a total
                 beauty of 2 + 3 + 1 + 2 = 8.

    Example 2:
    Input: flowers = [100,1,1,-3,1]
    Output: 3
    Explanation: You can produce the valid garden [1,1,1] to have a total
                 beauty of 1 + 1 + 1 = 3.

    Example 3:
    Input: flowers = [-1,-2,0,-1]
    Output: -2
    Explanation: You can produce the valid garden [-1,-1] to have a total
                 beauty of -1 + -1 = -2.

    Constraints:
    * 2 <= flowers.length <= 10^5
    * -10^4 <= flowers[i] <= 10^4
    * It is possible to create a valid garden by removing some (possibly none)
      flowers."""

    def maximumBeauty(self, flowers: List[int]) -> int:
        ans = -inf
        seen = {}
        prefix = 0
        for x in flowers:
            prefix += max(0, x)
            if x in seen:
                cand = prefix - seen[x]
                if x < 0: cand += 2*x
                ans = max(ans, cand)
            else: seen[x] = prefix - max(0, x)
        return ans


    """1790. Check if One String Swap Can Make Strings Equal (Easy)
    You are given two strings s1 and s2 of equal length. A string swap is an
    operation where you choose two indices in a string (not necessarily
    different) and swap the characters at these indices. Return true if it is
    possible to make both strings equal by performing at most one string swap
    on exactly one of the strings. Otherwise, return false.

    Example 1:
    Input: s1 = "bank", s2 = "kanb"
    Output: true
    Explanation: For example, swap the first character with the last character
                 of s2 to make "bank".

    Example 2:
    Input: s1 = "attack", s2 = "defend"
    Output: false
    Explanation: It is impossible to make them equal with one string swap.

    Example 3:
    Input: s1 = "kelb", s2 = "kelb"
    Output: true
    Explanation: The two strings are already equal, so no string swap operation
                 is required.

    Example 4:
    Input: s1 = "abcd", s2 = "dcba"
    Output: false

    Constraints:
    * 1 <= s1.length, s2.length <= 100
    * s1.length == s2.length
    * s1 and s2 consist of only lowercase English letters."""

    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        diff = [[x, y] for x, y in zip(s1, s2) if x != y]
        return not diff or len(diff) == 2 and diff[0][::-1] == diff[1]


    """1791. Find Center of Star Graph (Medium)
    There is an undirected star graph consisting of n nodes labeled from 1 to n.
    A star graph is a graph where there is one center node and exactly n - 1
    edges that connect the center node with every other node. You are given a
    2D integer array edges where each edges[i] = [ui, vi] indicates that there
    is an edge between the nodes ui and vi. Return the center of the given star
    graph.

    Example 1:
    Input: edges = [[1,2],[2,3],[4,2]]
    Output: 2
    Explanation: As shown in the figure above, node 2 is connected to every
                 other node, so 2 is the center.

    Example 2:
    Input: edges = [[1,2],[5,1],[1,3],[1,4]]
    Output: 1

    Constraints:
    * 3 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 1 <= ui, vi <= n
    * ui != vi
    * The given edges represent a valid star graph."""

    def findCenter(self, edges: List[List[int]]) -> int:
        return edges[0][0] if edges[0][0] in edges[1] else edges[0][1]


    """1792. Maximum Average Pass Ratio (Medium)
    There is a school that has classes of students and each class will be
    having a final exam. You are given a 2D integer array classes, where
    classes[i] = [passi, totali]. You know beforehand that in the ith class,
    there are totali total students, but only passi number of students will
    pass the exam. You are also given an integer extraStudents. There are
    another extraStudents brilliant students that are guaranteed to pass the
    exam of any class they are assigned to. You want to assign each of the
    extraStudents students to a class in a way that maximizes the average pass
    ratio across all the classes. The pass ratio of a class is equal to the
    number of students of the class that will pass the exam divided by the
    total number of students of the class. The average pass ratio is the sum of
    pass ratios of all the classes divided by the number of the classes. Return
    the maximum possible average pass ratio after assigning the extraStudents
    students. Answers within 10-5 of the actual answer will be accepted.

    Example 1:
    Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2
    Output: 0.78333
    Explanation: You can assign the two extra students to the first class. The
                 average pass ratio will be equal to
                 (3/4 + 3/5 + 2/2) / 3 = 0.78333.

    Example 2:
    Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4
    Output: 0.53485

    Constraints:
    * 1 <= classes.length <= 10^5
    * classes[i].length == 2
    * 1 <= passi <= totali <= 10^5
    * 1 <= extraStudents <= 10^5"""

    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
        pq = [(p/t - (p+1)/(t+1), p, t) for p, t in classes] # max-heap
        heapify(pq)

        for _ in range(extraStudents):
            _, p, t = heappop(pq)
            heappush(pq, ((p+1)/(t+1) - (p+2)/(t+2), p+1, t+1))

        return sum(p/t for _, p, t in pq)/len(pq)


    """1793. Maximum Score of a Good Subarray (Hard)
    You are given an array of integers nums (0-indexed) and an integer k. The
    score of a subarray (i, j) is defined as
    min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1).
    A good subarray is a subarray where i <= k <= j. Return the maximum
    possible score of a good subarray.

    Example 1:
    Input: nums = [1,4,3,7,4,5], k = 3
    Output: 15
    Explanation: The optimal subarray is (1, 5) with a score of
                 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15.

    Example 2:
    Input: nums = [5,5,4,5,4,1,1,1], k = 0
    Output: 20
    Explanation: The optimal subarray is (0, 4) with a score of
                 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 2 * 10^4
    * 0 <= k < nums.length"""

    def maximumScore(self, nums: List[int], k: int) -> int:
        ans = mn0 = mn1 = nums[k]
        lo = hi = k
        while 0 <= lo-1 or hi+1 < len(nums):
            if lo == 0 or hi+1 < len(nums) and nums[lo-1] < nums[hi+1]: hi += 1
            else: lo -= 1
            mn0 = min(mn0, nums[lo])
            mn1 = min(mn1, nums[hi])
            ans = max(ans, min(mn0, mn1)*(hi-lo+1))
        return ans


    """1794. Count Pairs of Equal Substrings With Minimum Difference (Medium)
    You are given two strings firstString and secondString that are 0-indexed
    and consist only of lowercase English letters. Count the number of index
    quadruples (i,j,a,b) that satisfy the following conditions:
    * 0 <= i <= j < firstString.length
    * 0 <= a <= b < secondString.length
    * The substring of firstString that starts at the ith character and ends at
      the jth character (inclusive) is equal to the substring of secondString
      that starts at the ath character and ends at the bth character (inclusive).
    * j - a is the minimum possible value among all quadruples that satisfy the
      previous conditions.
    Return the number of such quadruples.

    Example 1:
    Input: firstString = "abcd", secondString = "bccda"
    Output: 1
    Explanation: The quadruple (0,0,4,4) is the only one that satisfies all the
                 conditions and minimizes j - a.

    Example 2:
    Input: firstString = "ab", secondString = "cd"
    Output: 0
    Explanation: There are no quadruples satisfying all the conditions.

    Constraints:
    * 1 <= firstString.length, secondString.length <= 2 * 10^5
    * Both strings consist only of lowercase English letters."""

    def countQuadruples(self, firstString: str, secondString: str) -> int:
        prefix = {}
        suffix = {}
        for i, x in enumerate(firstString): prefix.setdefault(x, i)
        for i, x in enumerate(secondString): suffix[x] = i

        ans = 0
        most = -inf
        for x in ascii_lowercase:
            if x in prefix and x in suffix:
                val = suffix[x] - prefix[x]
                if val > most: ans, most = 1, val
                elif val == most: ans += 1
        return ans


    """1796. Second Largest Digit in a String (Easy)
    Given an alphanumeric string s, return the second largest numerical digit
    that appears in s, or -1 if it does not exist. An alphanumeric string is a
    string consisting of lowercase English letters and digits.

    Example 1:
    Input: s = "dfa12321afd"
    Output: 2
    Explanation: The digits that appear in s are [1, 2, 3]. The second largest
                 digit is 2.

    Example 2:
    Input: s = "abc1111"
    Output: -1
    Explanation: The digits that appear in s are [1]. There is no second
                 largest digit.

    Constraints:
    * 1 <= s.length <= 500
    * s consists of only lowercase English letters and/or digits."""

    def secondHighest(self, s: str) -> int:
        seen = set()
        for c in s:
            if c.isdigit():
                seen.add(int(c))
        return -1 if len(seen) < 2 else sorted(seen)[-2]


    """1798. Maximum Number of Consecutive Values You Can Make (Medium)
    You are given an integer array coins of length n which represents the n
    coins that you own. The value of the ith coin is coins[i]. You can make
    some value x if you can choose some of your n coins such that their values
    sum up to x. Return the maximum number of consecutive integer values that
    you can make with your coins starting from and including 0. Note that you
    may have multiple coins of the same value.

    Example 1:
    Input: coins = [1,3]
    Output: 2
    Explanation: You can make the following values:
    - 0: take []
    - 1: take [1]
    You can make 2 consecutive integer values starting from 0.

    Example 2:
    Input: coins = [1,1,1,4]
    Output: 8
    Explanation: You can make the following values:
    - 0: take []
    - 1: take [1]
    - 2: take [1,1]
    - 3: take [1,1,1]
    - 4: take [4]
    - 5: take [4,1]
    - 6: take [4,1,1]
    - 7: take [4,1,1,1]
    You can make 8 consecutive integer values starting from 0.

    Example 3:
    Input: nums = [1,4,10,3,1]
    Output: 20

    Constraints:
    * coins.length == n
    * 1 <= n <= 4 * 10^4
    * 1 <= coins[i] <= 4 * 10^4"""

    def getMaximumConsecutive(self, coins: List[int]) -> int:
        ans = 1
        for x in sorted(coins):
            if ans < x: break
            ans += x
        return ans


    """1799. Maximize Score After N Operations (Hard)
    You are given nums, an array of positive integers of size 2 * n. You must
    perform n operations on this array. In the ith operation (1-indexed), you
    will:
    * Choose two elements, x and y.
    * Receive a score of i * gcd(x, y).
    * Remove x and y from nums.
    Return the maximum score you can receive after performing n operations. The
    function gcd(x, y) is the greatest common divisor of x and y.

    Example 1:
    Input: nums = [1,2]
    Output: 1
    Explanation: The optimal choice of operations is: (1 * gcd(1, 2)) = 1

    Example 2:
    Input: nums = [3,4,6,8]
    Output: 11
    Explanation: The optimal choice of operations is:
                 (1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11

    Example 3:
    Input: nums = [1,2,3,4,5,6]
    Output: 14
    Explanation: The optimal choice of operations is:
                 (1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14

    Constraints:
    * 1 <= n <= 7
    * nums.length == 2 * n
    * 1 <= nums[i] <= 10^6"""

    def maxScore(self, nums: List[int]) -> int:
        n = len(nums)

        @cache
        def fn(mask, k):
            """Return maximum score at kth operation with available numbers by mask."""
            if mask == 0: return 0 # no more numbers
            ans = 0
            for i in range(n):
                if mask & 1 << i:
                    for j in range(i+1, n):
                        if mask & 1 << j:
                            mask0 = mask & ~(1<<i) & ~(1<<j) # unset ith & jth bit
                            ans = max(ans, k*gcd(nums[i], nums[j]) + fn(mask0, k+1))
            return ans

        return fn((1<<n) - 1, 1)


    """1800. Maximum Ascending Subarray Sum (Easy)
    Given an array of positive integers nums, return the maximum possible sum
    of an ascending subarray in nums. A subarray is defined as a contiguous
    sequence of numbers in an array. A subarray [numsl, numsl+1, ..., numsr-1,
    numsr] is ascending if for all i where l <= i < r, numsi < numsi+1. Note
    that a subarray of size 1 is ascending.

    Example 1:
    Input: nums = [10,20,30,5,10,50]
    Output: 65
    Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.

    Example 2:
    Input: nums = [10,20,30,40,50]
    Output: 150
    Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.

    Example 3:
    Input: nums = [12,17,15,13,10,11,12]
    Output: 33
    Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.

    Example 4:
    Input: nums = [100,10,1]
    Output: 100

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100"""

    def maxAscendingSum(self, nums: List[int]) -> int:
        ans = val = 0
        for i, x in enumerate(nums):
            if not i or nums[i-1] >= nums[i]: val = 0 # reset val
            val += nums[i]
            ans = max(ans, val)
        return ans


    """1801. Number of Orders in the Backlog (Medium)
    You are given a 2D integer array orders, where each
    orders[i] = [pricei, amounti, orderTypei] denotes that amounti orders have
    been placed of type orderTypei at the price pricei. The orderTypei is:
    * 0 if it is a batch of buy orders, or
    * 1 if it is a batch of sell orders.
    Note that orders[i] represents a batch of amounti independent orders with
    the same price and order type. All orders represented by orders[i] will be
    placed before all orders represented by orders[i+1] for all valid i. There
    is a backlog that consists of orders that have not been executed. The
    backlog is initially empty. When an order is placed, the following happens:
    * If the order is a buy order, you look at the sell order with the smallest
      price in the backlog. If that sell order's price is smaller than or equal
      to the current buy order's price, they will match and be executed, and
      that sell order will be removed from the backlog. Else, the buy order is
      added to the backlog.
    * Vice versa, if the order is a sell order, you look at the buy order with
      the largest price in the backlog. If that buy order's price is larger
      than or equal to the current sell order's price, they will match and be
      executed, and that buy order will be removed from the backlog. Else, the
      sell order is added to the backlog.
    Return the total amount of orders in the backlog after placing all the
    orders from the input. Since this number can be large, return it modulo
    10^9 + 7.

    Example 1:
    Input: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]
    Output: 6
    Explanation: Here is what happens with the orders:
    - 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.
    - 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.
    - 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.
    - 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.
    Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.

    Example 2:
    Input: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]
    Output: 999999984
    Explanation: Here is what happens with the orders:
    - 10^9 orders of type sell with price 7 are placed. There are no buy orders, so the 10^9 orders are added to the backlog.
    - 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.
    - 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.
    - 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.
    Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (10^9 + 7).

    Constraints:
    * 1 <= orders.length <= 10^5
    * orders[i].length == 3
    * 1 <= pricei, amounti <= 10^9
    * orderTypei is either 0 or 1."""

    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:
        buy, sell = [], [] # max-heap & min-heap
        for p, q, t in orders:
            if t: heappush(sell, [p, q])
            else: heappush(buy, [-p, q])

            while buy and sell and -buy[0][0] >= sell[0][0]:
                qty = min(buy[0][1], sell[0][1])
                buy[0][1] -= qty
                sell[0][1] -= qty
                if not buy[0][1]: heappop(buy)
                if not sell[0][1]: heappop(sell)
        return (sum(q for _, q in sell) + sum(q for _, q in buy)) % 1_000_000_007


    """1802. Maximum Value at a Given Index in a Bounded Array (Medium)
    You are given three positive integers n, index and maxSum. You want to
    construct an array nums (0-indexed) that satisfies the following conditions:
    * nums.length == n
    * nums[i] is a positive integer where 0 <= i < n.
    * abs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.
    * The sum of all the elements of nums does not exceed maxSum.
    * nums[index] is maximized.
    Return nums[index] of the constructed array. ote that abs(x) equals x if
    x >= 0, and -x otherwise.

    Example 1:
    Input: n = 4, index = 2,  maxSum = 6
    Output: 2
    Explanation: The arrays [1,1,2,1] and [1,2,2,1] satisfy all the conditions.
                 There are no other valid arrays with a larger value at the
                 given index.

    Example 2:
    Input: n = 6, index = 1,  maxSum = 10
    Output: 3

    Constraints:
    * 1 <= n <= maxSum <= 10^9
    * 0 <= index < n"""

    def maxValue(self, n: int, index: int, maxSum: int) -> int:

        def fn(n, x):
            if n < x: return n*(2*x-n+1)//2
            return x*(1+x)//2 + n - x

        lo, hi = 0, 10**9
        while lo < hi:
            mid = lo + hi + 1 >> 1
            sm = fn(index, mid-1) + fn(n-index, mid)
            if sm <= maxSum: lo = mid
            else: hi = mid - 1
        return lo


    """1803. Count Pairs With XOR in a Range (Hard)
    Given a (0-indexed) integer array nums and two integers low and high,
    return the number of nice pairs. A nice pair is a pair (i, j) where
    0 <= i < j < nums.length and low <= (nums[i] XOR nums[j]) <= high.

    Example 1:
    Input: nums = [1,4,2,7], low = 2, high = 6
    Output: 6
    Explanation: All nice pairs (i, j) are as follows:
                 - (0, 1): nums[0] XOR nums[1] = 5
                 - (0, 2): nums[0] XOR nums[2] = 3
                 - (0, 3): nums[0] XOR nums[3] = 6
                 - (1, 2): nums[1] XOR nums[2] = 6
                 - (1, 3): nums[1] XOR nums[3] = 3
                 - (2, 3): nums[2] XOR nums[3] = 5

    Example 2:
    Input: nums = [9,8,4,2,1], low = 5, high = 14
    Output: 8
    Explanation: All nice pairs (i, j) are as follows:
                 - (0, 2): nums[0] XOR nums[2] = 13
                 - (0, 3): nums[0] XOR nums[3] = 11
                 - (0, 4): nums[0] XOR nums[4] = 8
                 - (1, 2): nums[1] XOR nums[2] = 12
                 - (1, 3): nums[1] XOR nums[3] = 10
                 - (1, 4): nums[1] XOR nums[4] = 9
                 - (2, 3): nums[2] XOR nums[3] = 6
                 - (2, 4): nums[2] XOR nums[4] = 5

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= nums[i] <= 2 * 10^4
    * 1 <= low <= high <= 2 * 10^4

    class Trie:
        def __init__(self):
            self.root = {}

        def insert(self, val):
            node = self.root
            for i in reversed(range(15)):
                bit = (val >> i) & 1
                if bit not in node: node[bit] = {"cnt": 0}
                node = node[bit]
                node["cnt"] += 1

        def count(self, val, high):
            ans = 0
            node = self.root
            for i in reversed(range(15)):
                if not node: break
                bit = (val >> i) & 1
                cmp = (high >> i) & 1
                if cmp:
                    if node.get(bit, {}): ans += node[bit]["cnt"]
                    node = node.get(1^bit, {})
                else: node = node.get(bit, {})
            return ans"""

    def countPairs(self, nums: List[int], low: int, high: int) -> int:
        trie = Trie()

        ans = 0
        for x in nums:
            ans += trie.count(x, high+1) - trie.count(x, low)
            trie.insert(x)
        return ans


    """1805. Number of Different Integers in a String (Easy)
    You are given a string word that consists of digits and lowercase English
    letters. You will replace every non-digit character with a space. For
    example, "a123bc34d8ef34" will become " 123  34 8  34". Notice that you are
    left with some integers that are separated by at least one space: "123",
    "34", "8", and "34". Return the number of different integers after
    performing the replacement operations on word. Two integers are considered
    different if their decimal representations without any leading zeros are
    different.

    Example 1:
    Input: word = "a123bc34d8ef34"
    Output: 3
    Explanation: The three different integers are "123", "34", and "8". Notice
                 that "34" is only counted once.

    Example 2:
    Input: word = "leet1234code234"
    Output: 2

    Example 3:
    Input: word = "a1b01c001"
    Output: 1
    Explanation: The three integers "1", "01", and "001" all represent the same
                 integer because the leading zeros are ignored when comparing
                 their decimal values.

    Constraints:
    * 1 <= word.length <= 1000
    * word consists of digits and lowercase English letters."""

    def numDifferentIntegers(self, word: str) -> int:
        seen = set()
        for key, grp in groupby(word, str.isdigit):
            if key: seen.add(int("".join(grp)))
        return len(seen)


    """1806. Minimum Number of Operations to Reinitialize a Permutation (Medium)
    You are given an even integer n. You initially have a permutation
    perm of size n where perm[i] == i (0-indexed). In one operation, you
    will create a new array arr, and for each i:
    * If i % 2 == 0, then arr[i] = perm[i / 2].
    * If i % 2 == 1, then arr[i] = perm[n / 2 + (i - 1) / 2].
    You will then assign arr to perm. Return the minimum non-zero number of
    operations you need to perform on perm to return the permutation to its
    initial value.

    Example 1:
    Input: n = 2
    Output: 1
    Explanation: prem = [0,1] initially.
                 After the 1st operation, prem = [0,1]
                 So it takes only 1 operation.

    Example 2:
    Input: n = 4
    Output: 2
    Explanation: prem = [0,1,2,3] initially.
                 After the 1st operation, prem = [0,2,1,3]
                 After the 2nd operation, prem = [0,1,2,3]
                 So it takes only 2 operations.

    Example 3:
    Input: n = 6
    Output: 4

    Constraints:
    * 2 <= n <= 1000
    * n is even."""

    def reinitializePermutation(self, n: int) -> int:
        ans = 0
        perm = list(range(n))
        while True:
            ans += 1
            perm = [perm[n//2+(i-1)//2] if i&1 else perm[i//2] for i in range(n)]
            if all(perm[i] == i for i in range(n)): return ans


    """1807. Evaluate the Bracket Pairs of a String (Medium)
    You are given a string s that contains some bracket pairs, with each pair
    containing a non-empty key.
    * For example, in the string "(name)is(age)yearsold", there are two bracket
      pairs that contain the keys "name" and "age".
    You know the values of a wide range of keys. This is represented by a 2D
    string array knowledge where each knowledge[i] = [keyi, valuei] indicates
    that key keyi has a value of valuei. You are tasked to evaluate all of the
    bracket pairs. When you evaluate a bracket pair that contains some key keyi,
    you will:
    * Replace keyi and the bracket pair with the key's corresponding valuei.
    * If you do not know the value of the key, you will replace keyi and the
      bracket pair with a question mark "?" (without the quotation marks).
    Each key will appear at most once in your knowledge. There will not be any
    nested brackets in s. Return the resulting string after evaluating all of
    the bracket pairs.

    Example 1:
    Input: s = "(name)is(age)yearsold", knowledge = [["name","bob"],["age","two"]]
    Output: "bobistwoyearsold"
    Explanation: The key "name" has a value of "bob", so replace "(name)" with "bob".
                 The key "age" has a value of "two", so replace "(age)" with "two".

    Example 2:
    Input: s = "hi(name)", knowledge = [["a","b"]]
    Output: "hi?"
    Explanation: As you do not know the value of the key "name", replace
                 "(name)" with "?".

    Example 3:
    Input: s = "(a)(a)(a)aaa", knowledge = [["a","yes"]]
    Output: "yesyesyesaaa"
    Explanation: The same key can appear multiple times.
    The key "a" has a value of "yes", so replace all occurrences of "(a)" with "yes".
    Notice that the "a"s not in a bracket pair are not evaluated.

    Example 4:
    Input: s = "(a)(b)", knowledge = [["a","b"],["b","a"]]
    Output: "ba"

    Constraints:
    * 1 <= s.length <= 10^5
    * 0 <= knowledge.length <= 10^5
    * knowledge[i].length == 2
    * 1 <= keyi.length, valuei.length <= 10
    * s consists of lowercase English letters and round brackets '(' and ')'.
    * Every open bracket '(' in s will have a corresponding close bracket ')'.
    * The key in each bracket pair of s will be non-empty.
    * There will not be any nested bracket pairs in s.
    * keyi and valuei consist of lowercase English letters.
    * Each keyi in knowledge is unique."""

    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
        mp = dict(knowledge)
        i = 0
        ans = []
        while i < len(s):
            if s[i] == "(":
                ii = i
                while ii < len(s) and s[ii] != ")":
                    ii += 1
                ans.append(mp.get(s[i+1:ii], "?"))
                i = ii+1
            else:
                ans.append(s[i])
                i += 1
        return "".join(ans)


    """1810. Minimum Path Cost in a Hidden Grid (Medium)
    This is an interactive problem. There is a robot in a hidden grid, and you
    are trying to get it from its starting cell to the target cell in this grid.
    The grid is of size m x n, and each cell in the grid is either empty or
    blocked. It is guaranteed that the starting cell and the target cell are
    different, and neither of them is blocked. Each cell has a cost that you
    need to pay each time you move to the cell. The starting cell's cost is not
    applied before the robot moves. You want to find the minimum total cost to
    move the robot to the target cell. However, you do not know the grid's
    dimensions, the starting cell, nor the target cell. You are only allowed to
    ask queries to the GridMaster object. The GridMaster class has the
    following functions:
    * boolean canMove(char direction) Returns true if the robot can move in
      that direction. Otherwise, it returns false.
    * int move(char direction) Moves the robot in that direction and returns
      the cost of moving to that cell. If this move would move the robot to a
      blocked cell or off the grid, the move will be ignored, the robot will
      remain in the same position, and the function will return -1.
    * boolean isTarget() Returns true if the robot is currently on the target
      cell. Otherwise, it returns false.
    Note that direction in the above functions should be a character from
    {'U','D','L','R'}, representing the directions up, down, left, and right,
    respectively. Return the minimum total cost to get the robot from its
    initial starting cell to the target cell. If there is no valid path between
    the cells, return -1.

    Custom testing:
    The test input is read as a 2D matrix grid of size m x n and four integers
    r1, c1, r2, and c2 where:
    * grid[i][j] == 0 indicates that the cell (i, j) is blocked.
    * grid[i][j] >= 1 indicates that the cell (i, j) is empty and grid[i][j] is
      the cost to move to that cell.
    * (r1, c1) is the starting cell of the robot.
    * (r2, c2) is the target cell of the robot.
    Remember that you will not have this information in your code.

    Example 1:
    Input: grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0
    Output: 2
    Explanation: One possible interaction is described below:
                 The robot is initially standing on cell (0, 1), denoted by the
                 3.
                 - master.canMove('U') returns false.
                 - master.canMove('D') returns true.
                 - master.canMove('L') returns true.
                 - master.canMove('R') returns false.
                 - master.move('L') moves the robot to the cell (0, 0) and
                   returns 2.
                 - master.isTarget() returns false.
                 - master.canMove('U') returns false.
                 - master.canMove('D') returns true.
                 - master.canMove('L') returns false.
                 - master.canMove('R') returns true.
                 - master.move('D') moves the robot to the cell (1, 0) and
                   returns 1.
                 - master.isTarget() returns true.
                 - master.move('L') doesn't move the robot and returns -1.
                 - master.move('R') moves the robot to the cell (1, 1) and
                   returns 1.
                 We now know that the target is the cell (1, 0), and the
                 minimum total cost to reach it is 2.

    Example 2:
    Input: grid = [[0,3,1],[3,4,2],[1,2,0]], r1 = 2, c1 = 0, r2 = 0, c2 = 2
    Output: 9
    Explanation: The minimum cost path is (2,0) -> (2,1) -> (1,1) -> (1,2) ->
                 (0,2).

    Example 3:
    Input: grid = [[1,0],[0,1]], r1 = 0, c1 = 0, r2 = 1, c2 = 1
    Output: -1
    Explanation: There is no path from the robot to the target cell.

    Constraints:
    * 1 <= n, m <= 100
    * m == grid.length
    * n == grid[i].length
    * 0 <= grid[i][j] <= 100"""

    def findShortestPath(self, master: 'GridMaster') -> int:
        graph = {(0, 0) : 0}
        oppo = {'U' : 'D', 'D' : 'U', 'L' : 'R', 'R' : 'L'}
        step = {'U' : (0, 1), 'D' : (0, -1), 'L' : (-1, 0), 'R' : (1, 0)}
        target = None

        def dfs(i, j):
            """Explore the graph"""
            nonlocal target
            if master.isTarget(): target = (i, j)
            for ch in "UDLR":
                if master.canMove(ch):
                    di, dj = step[ch]
                    ii, jj = i+di, j+dj
                    if (ii, jj) not in graph:
                        graph[ii, jj] = master.move(ch)
                        dfs(ii, jj)
                        master.move(oppo[ch])

        dfs(0, 0)
        pq = [(0, 0, 0)]
        dist = defaultdict(lambda : inf, {(0, 0) : 0})
        while pq:
            v, i, j = heappop(pq)
            if (i, j) == target: return v
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if (ii, jj) in graph:
                    vv = v + graph[ii, jj]
                    if vv < dist[ii, jj]:
                        dist[ii, jj] = vv
                        heappush(pq, (vv, ii, jj))
        return -1


    """1812. Determine Color of a Chessboard Square (Easy)
    You are given coordinates, a string that represents the coordinates of a
    square of the chessboard. Below is a chessboard for your reference. Return
    true if the square is white, and false if the square is black. The
    coordinate will always represent a valid chessboard square. The coordinate
    will always have the letter first, and the number second.

    Example 1:
    Input: coordinates = "a1"
    Output: false
    Explanation: From the chessboard above, the square with coordinates "a1" is
                 black, so return false.

    Example 2:
    Input: coordinates = "h3"
    Output: true
    Explanation: From the chessboard above, the square with coordinates "h3" is
                 white, so return true.

    Example 3:
    Input: coordinates = "c7"
    Output: false

    Constraints:
    * coordinates.length == 2
    * 'a' <= coordinates[0] <= 'h'
    * '1' <= coordinates[1] <= '8'"""

    def squareIsWhite(self, coordinates: str) -> bool:
        return (ord(coordinates[0])-97)&1 == int(coordinates[1])&1


    """1813. Sentence Similarity III (Medium)
    A sentence is a list of words that are separated by a single space with no
    leading or trailing spaces. For example, "Hello World", "HELLO", "hello
    world hello world" are all sentences. Words consist of only uppercase and
    lowercase English letters. Two sentences sentence1 and sentence2 are
    similar if it is possible to insert an arbitrary sentence (possibly empty)
    inside one of these sentences such that the two sentences become equal. For
    example, sentence1 = "Hello my name is Jane" and sentence2 = "Hello Jane"
    can be made equal by inserting "my name is" between "Hello" and "Jane" in
    sentence2. Given two sentences sentence1 and sentence2, return true if
    sentence1 and sentence2 are similar. Otherwise, return false.

    Example 1:
    Input: sentence1 = "My name is Haley", sentence2 = "My Haley"
    Output: true
    Explanation: sentence2 can be turned to sentence1 by inserting "name is"
                 between "My" and "Haley".

    Example 2:
    Input: sentence1 = "of", sentence2 = "A lot of words"
    Output: false
    Explanation: No single sentence can be inserted inside one of the sentences
                 to make it equal to the other.

    Example 3:
    Input: sentence1 = "Eating right now", sentence2 = "Eating"
    Output: true
    Explanation: sentence2 can be turned to sentence1 by inserting "right now"
                 at the end of the sentence.

    Example 4:
    Input: sentence1 = "Luky", sentence2 = "Lucccky"
    Output: false

    Constraints:
    * 1 <= sentence1.length, sentence2.length <= 100
    * sentence1 and sentence2 consist of lowercase and uppercase English letters
      and spaces.
    * The words in sentence1 and sentence2 are separated by a single space."""

    def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
        if len(sentence1) < len(sentence2):
            sentence1, sentence2 = sentence2, sentence1
        words1 = sentence1.split()
        words2 = sentence2.split()

        lo = 0
        while lo < len(words2) and words1[lo] == words2[lo]: lo += 1

        hi = -1
        while -len(words2) <= hi and words1[hi] == words2[hi]: hi -= 1

        return lo - hi -1 >= len(words2)


    """1814. Count Nice Pairs in an Array (Medium)
    You are given an array nums that consists of non-negative integers. Let us
    define rev(x) as the reverse of the non-negative integer x. For example,
    rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it
    satisfies all of the following conditions:
    * 0 <= i < j < nums.length
    * nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
    Return the number of nice pairs of indices. Since that number can be too
    large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [42,11,1,97]
    Output: 2
    Explanation: The two pairs are:
     - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
     - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.

    Example 2:
    Input: nums = [13,10,35,24,76]
    Output: 4

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9"""

    def countNicePairs(self, nums: List[int]) -> int:
        ans = 0
        freq = defaultdict(int)
        for x in nums:
            x -= int(str(x)[::-1])
            ans += freq[x]
            freq[x] += 1
        return ans % 1_000_000_007


    """1815. Maximum Number of Groups Getting Fresh Donuts (Hard)
    There is a donuts shop that bakes donuts in batches of batchSize. They have
    a rule where they must serve all of the donuts of a batch before serving
    any donuts of the next batch. You are given an integer batchSize and an
    integer array groups, where groups[i] denotes that there is a group of
    groups[i] customers that will visit the shop. Each customer will get
    exactly one donut. When a group visits the shop, all customers of the group
    must be served before serving any of the following groups. A group will be
    happy if they all get fresh donuts. That is, the first customer of the
    group does not receive a donut that was left over from the previous group.
    You can freely rearrange the ordering of the groups. Return the maximum
    possible number of happy groups after rearranging the groups.

    Example 1:
    Input: batchSize = 3, groups = [1,2,3,4,5,6]
    Output: 4
    Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd,
                 4th, and 6th groups will be happy.

    Example 2:
    Input: batchSize = 4, groups = [1,3,2,5,2,2,1,6]
    Output: 4

    Constraints:
    * 1 <= batchSize <= 9
    * 1 <= groups.length <= 30
    * 1 <= groups[i] <= 10^9"""

    def maxHappyGroups(self, batchSize: int, groups: List[int]) -> int:
        ans = 0
        freq = [0]*batchSize
        for x in groups:
            x %= batchSize
            if x == 0: ans += 1
            elif freq[batchSize-x]:
                ans += 1
                freq[batchSize-x] -= 1
            else: freq[x] += 1

        @cache
        def fn(freq, r):
            """Return max group getting fresh donuts."""
            ans = 0
            if any(freq):
                for i, x in enumerate(freq):
                    if x: ans = max(ans, fn(freq[:i] + (x-1,) + freq[i+1:], (r+i)%batchSize))
                if r == 0: ans += 1
            return ans

        return fn(tuple(freq), 0) + ans


    """1816. Truncate Sentence (Easy)
    A sentence is a list of words that are separated by a single space with no
    leading or trailing spaces. Each of the words consists of only uppercase
    and lowercase English letters (no punctuation). For example, "Hello World",
    "HELLO", and "hello world hello world" are all sentences. You are given a
    sentence s and an integer k. You want to truncate s such that it contains
    only the first k words. Return s after truncating it.

    Example 1:
    Input: s = "Hello how are you Contestant", k = 4
    Output: "Hello how are you"
    Explanation:
    The words in s are ["Hello", "how" "are", "you", "Contestant"].
    The first 4 words are ["Hello", "how", "are", "you"].
    Hence, you should return "Hello how are you".

    Example 2:
    Input: s = "What is the solution to this problem", k = 4
    Output: "What is the solution"
    Explanation:
    The words in s are ["What", "is" "the", "solution", "to", "this", "problem"].
    The first 4 words are ["What", "is", "the", "solution"].
    Hence, you should return "What is the solution".

    Example 3:
    Input: s = "chopper is not a tanuki", k = 5
    Output: "chopper is not a tanuki"

    Constraints:
    * 1 <= s.length <= 500
    * k is in the range [1, the number of words in s].
    * s consist of only lowercase and uppercase English letters and spaces.
    * The words in s are separated by a single space.
    * There are no leading or trailing spaces."""

    def truncateSentence(self, s: str, k: int) -> str:
        return " ".join(s.split()[:k])


    """1817. Finding the Users Active Minutes (Medium)
    You are given the logs for users' actions on LeetCode, and an integer k.
    The logs are represented by a 2D integer array logs where each
    logs[i] = [IDi, timei] indicates that the user with IDi performed an
    action at the minute timei. Multiple users can perform actions
    simultaneously, and a single user can perform multiple actions in the same
    minute. The user active minutes (UAM) for a given user is defined as the
    number of unique minutes in which the user performed an action on LeetCode.
    A minute can only be counted once, even if multiple actions occur during it.
    You are to calculate a 1-indexed array answer of size k such that, for each
    j (1 <= j <= k), answer[j] is the number of users whose UAM equals j.
    Return the array answer as described above.

    Example 1:
    Input: logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5
    Output: [0,2,0,0,0]
    Explanation:
    The user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once).
    The user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.
    Since both users have a UAM of 2, answer[2] is 2, and the remaining answer[j] values are 0.

    Example 2:
    Input: logs = [[1,1],[2,2],[2,3]], k = 4
    Output: [1,1,0,0]
    Explanation:
    The user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1.
    The user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.
    There is one user with a UAM of 1 and one with a UAM of 2.
    Hence, answer[1] = 1, answer[2] = 1, and the remaining values are 0.

    Constraints:
    * 1 <= logs.length <= 10^4
    * 0 <= IDi <= 10^9
    * 1 <= timei <= 10^5
    * k is in the range [The maximum UAM for a user, 10^5]."""

    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
        mp = {}
        for i, t in logs:
            mp.setdefault(i, set()).add(t)

        ans = [0]*k
        for v in mp.values():
            if len(v) <= k:
                ans[len(v)-1] += 1
        return ans


    """1818. Minimum Absolute Sum Difference (Medium)
    You are given two positive integer arrays nums1 and nums2, both of length n.
    The absolute sum difference of arrays nums1 and nums2 is defined as the sum
    of |nums1[i] - nums2[i]| for each 0 <= i < n (0-indexed). You can replace
    at most one element of nums1 with any other element in nums1 to minimize
    the absolute sum difference. Return the minimum absolute sum difference
    after replacing at most one element in the array nums1. Since the answer
    may be large, return it modulo 10^9 + 7. |x| is defined as:
    * x if x >= 0, or
    * -x if x < 0.

    Example 1:
    Input: nums1 = [1,7,5], nums2 = [2,3,5]
    Output: 3
    Explanation: There are two possible optimal solutions:
    - Replace the second element with the first: [1,7,5] => [1,1,5], or
    - Replace the second element with the third: [1,7,5] => [1,5,5].
    Both will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3.

    Example 2:
    Input: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
    Output: 0
    Explanation: nums1 is equal to nums2 so no replacement is needed. This will result in an
    absolute sum difference of 0.

    Example 3:
    Input: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
    Output: 20
    Explanation: Replace the first element with the second: [1,10,4,4,2,7] => [10,10,4,4,2,7].
    This yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20

    Constraints:
    * n == nums1.length
    * n == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^5"""

    def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:
        s1 = sorted(nums1)
        ans = bnft = 0
        for x, y in zip(nums1, nums2):
            ans += abs(x - y)
            k = bisect_left(s1, y)
            if k < len(s1): bnft = max(bnft, abs(x - y) - (s1[k] - y)) # benefit of replacing x to s1[k]
            if 0 < k: bnft = max(bnft, abs(x - y) - (y - s1[k-1])) # benefit of replacing x to s1[k-1]
        return (ans - bnft) % 1_000_000_007


    """1819. Number of Different Subsequences GCDs (Hard)
    You are given an array nums that consists of positive integers. The GCD of
    a sequence of numbers is defined as the greatest integer that divides all
    the numbers in the sequence evenly. For example, the GCD of the sequence
    [4,6,16] is 2. A subsequence of an array is a sequence that can be formed
    by removing some elements (possibly none) of the array. For example,
    [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10]. Return the number of
    different GCDs among all non-empty subsequences of nums.

    Example 1:
    Input: nums = [6,10,3]
    Output: 5
    Explanation: The figure shows all the non-empty subsequences and their GCDs.
                 The different GCDs are 6, 10, 3, 2, and 1.

    Example 2:
    Input: nums = [5,15,40,5,6]
    Output: 7

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 2 * 10^5"""

    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        nums = set(nums)

        ans = 0
        m = max(nums)
        for x in range(1, m+1):
            g = 0
            for xx in range(x, m+1, x):
                if xx in nums: g = gcd(g, xx)
            if g == x: ans += 1
        return ans


    """1820. Maximum Number of Accepted Invitations (Medium)
    There are m boys and n girls in a class attending an upcoming party. You
    are given an m x n integer matrix grid, where grid[i][j] equals 0 or 1. If
    grid[i][j] == 1, then that means the ith boy can invite the jth girl to the
    party. A boy can invite at most one girl, and a girl can accept at most one
    invitation from a boy. Return the maximum possible number of accepted
    invitations.

    Example 1:
    Input: grid = [[1,1,1],
                   [1,0,1],
                   [0,0,1]]
    Output: 3
    Explanation: The invitations are sent as follows:
                 - The 1st boy invites the 2nd girl.
                 - The 2nd boy invites the 1st girl.
                 - The 3rd boy invites the 3rd girl.

    Example 2:
    Input: grid = [[1,0,1,0],
                   [1,0,0,0],
                   [0,0,1,0],
                   [1,1,1,0]]
    Output: 3
    Explanation: The invitations are sent as follows:
                 -The 1st boy invites the 3rd girl.
                 -The 2nd boy invites the 1st girl.
                 -The 3rd boy invites no one.
                 -The 4th boy invites the 2nd girl.

    Constraints:
    * grid.length == m
    * grid[i].length == n
    * 1 <= m, n <= 200
    * grid[i][j] is either 0 or 1."""

    def maximumInvitations(self, grid: List[List[int]]) -> int:
        # maximum bipartite matching
        m, n = len(grid), len(grid[0])
        ans = 0
        match = [-1] * n

        def fn(i):
            """Look up match for ith boy."""
            for j in range(n):
                if grid[i][j] and not seen[j]:
                    seen[j] = True
                    if match[j] == -1 or fn(match[j]):
                        match[j] = i
                        return True
            return False

        for i in range(m):
            seen = [False] * n
            if fn(i): ans += 1
        return ans


    """1822. Sign of the Product of an Array (Easy)
    There is a function signFunc(x) that returns:
    * 1 if x is positive.
    * -1 if x is negative.
    * 0 if x is equal to 0.
    You are given an integer array nums. Let product be the product of all
    values in the array nums. Return signFunc(product).

    Example 1:
    Input: nums = [-1,-2,-3,-4,3,2,1]
    Output: 1
    Explanation: The product of all values in the array is 144, and signFunc(144) = 1

    Example 2:
    Input: nums = [1,5,0,2,-3]
    Output: 0
    Explanation: The product of all values in the array is 0, and signFunc(0) = 0

    Example 3:
    Input: nums = [-1,1,-1,1,-1]
    Output: -1
    Explanation: The product of all values in the array is -1, and signFunc(-1) = -1

    Constraints:
    * 1 <= nums.length <= 1000
    * -100 <= nums[i] <= 100"""

    def arraySign(self, nums: List[int]) -> int:
        ans = 1
        for x in nums:
            if x == 0: return 0
            if x < 0: ans *= -1
        return ans


    """1823. Find the Winner of the Circular Game (Medium)
    There are n friends that are playing a game. The friends are sitting in a
    circle and are numbered from 1 to n in clockwise order. More formally,
    moving clockwise from the ith friend brings you to the (i+1)th friend for
    1 <= i < n, and moving clockwise from the nth friend brings you to the 1st
    friend. The rules of the game are as follows:
    * Start at the 1st friend.
    * Count the next k friends in the clockwise direction including the friend
      you started at. The counting wraps around the circle and may count some
      friends more than once.
    * The last friend you counted leaves the circle and loses the game.
    * If there is still more than one friend in the circle, go back to step 2
      starting from the friend immediately clockwise of the friend who just
      lost and repeat.
    * Else, the last friend in the circle wins the game.
    Given the number of friends, n, and an integer k, return the winner of the
    game.

    Example 1:
    Input: n = 5, k = 2
    Output: 3
    Explanation: Here are the steps of the game:
    1) Start at friend 1.
    2) Count 2 friends clockwise, which are friends 1 and 2.
    3) Friend 2 leaves the circle. Next start is friend 3.
    4) Count 2 friends clockwise, which are friends 3 and 4.
    5) Friend 4 leaves the circle. Next start is friend 5.
    6) Count 2 friends clockwise, which are friends 5 and 1.
    7) Friend 1 leaves the circle. Next start is friend 3.
    8) Count 2 friends clockwise, which are friends 3 and 5.
    9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.

    Example 2:
    Input: n = 6, k = 5
    Output: 1
    Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is
                 friend 1.

    Constraints: 1 <= k <= n <= 500"""

    def findTheWinner(self, n: int, k: int) -> int:
        """Josephus Problem"""
        ans = 0
        for x in range(2, n+1):
            ans = (ans + k) % x
        return ans + 1


    """1824. Minimum Sideway Jumps (Medium)
    There is a 3 lane road of length n that consists of n + 1 points labeled
    from 0 to n. A frog starts at point 0 in the second lane and wants to jump
    to point n. However, there could be obstacles along the way. You are given
    an array obstacles of length n + 1 where each obstacles[i] (ranging from 0
    to 3) describes an obstacle on the lane obstacles[i] at point i. If
    obstacles[i] == 0, there are no obstacles at point i. There will be at most
    one obstacle in the 3 lanes at each point. For example, if obstacles[2] == 1,
    then there is an obstacle on lane 1 at point 2. The frog can only travel
    from point i to point i + 1 on the same lane if there is not an obstacle on
    the lane at point i + 1. To avoid obstacles, the frog can also perform a
    side jump to jump to another lane (even if they are not adjacent) at the
    same point if there is no obstacle on the new lane. For example, the frog
    can jump from lane 3 at point 3 to lane 1 at point 3. Return the minimum
    number of side jumps the frog needs to reach any lane at point n starting
    from lane 2 at point 0. Note: There will be no obstacles on points 0 and n.

    Example 1:
    Input: obstacles = [0,1,2,3,0]
    Output: 2
    Explanation: The optimal solution is shown by the arrows above. There are 2
                 side jumps (red arrows). Note that the frog can jump over
                 obstacles only when making side jumps (as shown at point 2).

    Example 2:
    Input: obstacles = [0,1,1,3,3,0]
    Output: 0
    Explanation: There are no obstacles on lane 2. No side jumps are required.

    Example 3:
    Input: obstacles = [0,2,1,0,3,0]
    Output: 2
    Explanation: The optimal solution is shown by the arrows above. There are 2
                 side jumps.

    Constraints:
    * obstacles.length == n + 1
    * 1 <= n <= 5 * 10^5
    * 0 <= obstacles[i] <= 3
    * obstacles[0] == obstacles[n] == 0"""

    def minSideJumps(self, obstacles: List[int]) -> int:
        dp = [0]*3
        for i in reversed(range(len(obstacles) - 1)):
            tmp = [inf]*3
            for k in range(3):
                if obstacles[i]-1 != k:
                    tmp[k] = dp[k]
                    if obstacles[i]-1 != (k+1)%3: tmp[k] = min(tmp[k], 1 + dp[(k+1)%3])
                    if obstacles[i]-1 != (k+2)%3: tmp[k] = min(tmp[k], 1 + dp[(k+2)%3])
            dp = tmp
        return dp[1]


    """1827. Minimum Operations to Make the Array Increasing (Easy)
    You are given an integer array nums (0-indexed). In one operation, you can
    choose an element of the array and increment it by 1. For example, if
    nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].
    Return the minimum number of operations needed to make nums strictly
    increasing. An array nums is strictly increasing if nums[i] < nums[i+1] for
    all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly
    increasing.

    Example 1:
    Input: nums = [1,1,1]
    Output: 3
    Explanation: You can do the following operations:
    1) Increment nums[2], so nums becomes [1,1,2].
    2) Increment nums[1], so nums becomes [1,2,2].
    3) Increment nums[2], so nums becomes [1,2,3].

    Example 2:
    Input: nums = [1,5,2,4,1]
    Output: 14

    Example 3:
    Input: nums = [8]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 5000
    * 1 <= nums[i] <= 10^4"""

    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for i in range(1, len(nums)):
            if nums[i-1] >= nums[i]:
                ans += 1 + nums[i-1] - nums[i]
                nums[i] = 1 + nums[i-1]
        return ans


    """1828. Queries on Number of Points Inside a Circle (Medium)
    You are given an array points where points[i] = [xi, yi] is the coordinates
    of the ith point on a 2D plane. Multiple points can have the same coordinates.
    You are also given an array queries where queries[j] = [xj, yj, rj] describes
    a circle centered at (xj, yj) with a radius of rj. For each query queries[j],
    compute the number of points inside the jth circle. Points on the border of
    the circle are considered inside. Return an array answer, where answer[j] is
    the answer to the jth query.

    Example 1:
    Input: points = [[1,3],[3,3],[5,3],[2,2]],
           queries = [[2,3,1],[4,3,1],[1,1,2]]
    Output: [3,2,2]
    Explanation: The points and circles are shown above. queries[0] is the green
                 circle, queries[1] is the red circle, and queries[2] is the blue
                 circle.

    Example 2:
    Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]],
           queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]
    Output: [2,3,2,4]
    Explanation: The points and circles are shown above. queries[0] is green,
                 queries[1] is red, queries[2] is blue, and queries[3] is purple.

    Constraints:
    * 1 <= points.length <= 500
    * points[i].length == 2
    * 0 <= xi, yi <= 500
    * 1 <= queries.length <= 500
    * queries[j].length == 3
    * 0 <= xj, yj <= 500
    * 1 <= rj <= 500
    * All coordinates are integers.

    Follow up: Could you find the answer for each query in better complexity than
               O(n)?"""

    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        ans = []
        for x, y, r in queries:
            val = 0
            for xx, yy in points:
                if (x-xx)**2 + (y-yy)**2 <= r**2:
                    val += 1
            ans.append(val)
        return ans


    """1829. Maximum XOR for Each Query (Medium)
    You are given a sorted array nums of n non-negative integers and an integer
    maximumBit. You want to perform the following query n times:
    * Find a non-negative integer k < 2maximumBit such that nums[0] XOR nums[1]
      XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the answer to
      the ith query.
    * Remove the last element from the current array nums.
    Return an array answer, where answer[i] is the answer to the ith query.

    Example 1:
    Input: nums = [0,1,1,3], maximumBit = 2
    Output: [0,3,2,3]
    Explanation: The queries are answered as follows:
    1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.
    2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.
    3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.
    4th query: nums = [0], k = 3 since 0 XOR 3 = 3.

    Example 2:
    Input: nums = [2,3,4,7], maximumBit = 3
    Output: [5,2,6,5]
    Explanation: The queries are answered as follows:
    1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.
    2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.
    3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.
    4th query: nums = [2], k = 5 since 2 XOR 5 = 7.

    Example 3:
    Input: nums = [0,1,2,2,5,7], maximumBit = 3
    Output: [4,3,6,4,6,7]

    Constraints:
    * nums.length == n
    * 1 <= n <= 10^5
    * 1 <= maximumBit <= 20
    * 0 <= nums[i] < 2maximumBit
    * nums is sorted in ascending order."""

    def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:
        ans = [0]*len(nums)
        prefix = 0
        for i, x in enumerate(nums):
            prefix ^= x
            ans[~i] = prefix ^ ((1 << maximumBit) -1)
        return ans


    """1830. Minimum Number of Operations to Make String Sorted (Hard)
    You are given a string s (0-indexed). You are asked to perform the
    following operation on s until you get a sorted string:
    * Find the largest index i such that 1 <= i < s.length and s[i] < s[i - 1].
    * Find the largest index j such that i <= j < s.length and s[k] < s[i - 1]
      for all the possible values of k in the range [i, j] inclusive.
    * Swap the two characters at indices i - 1 and j.
    * Reverse the suffix starting at index i.
    Return the number of operations needed to make the string sorted. Since the
    answer can be too large, return it modulo 10^9 + 7.

    Example 1:
    Input: s = "cba"
    Output: 5
    Explanation: The simulation goes as follows:
    Operation 1: i=2, j=2. Swap s[1] and s[2] to get s="cab", then reverse the suffix starting at 2. Now, s="cab".
    Operation 2: i=1, j=2. Swap s[0] and s[2] to get s="bac", then reverse the suffix starting at 1. Now, s="bca".
    Operation 3: i=2, j=2. Swap s[1] and s[2] to get s="bac", then reverse the suffix starting at 2. Now, s="bac".
    Operation 4: i=1, j=1. Swap s[0] and s[1] to get s="abc", then reverse the suffix starting at 1. Now, s="acb".
    Operation 5: i=2, j=2. Swap s[1] and s[2] to get s="abc", then reverse the suffix starting at 2. Now, s="abc".

    Example 2:
    Input: s = "aabaa"
    Output: 2
    Explanation: The simulation goes as follows:
    Operation 1: i=3, j=4. Swap s[2] and s[4] to get s="aaaab", then reverse the substring starting at 3. Now, s="aaaba".
    Operation 2: i=4, j=4. Swap s[3] and s[4] to get s="aaaab", then reverse the substring starting at 4. Now, s="aaaab".

    Example 3:
    Input: s = "cdbea"
    Output: 63

    Example 4:
    Input: s = "leetcodeleetcodeleetcode"
    Output: 982157772

    Constraints:
    * 1 <= s.length <= 3000
    * s consists only of lowercase English letters."""

    def makeStringSorted(self, s: str) -> int:
        freq = [0]*26
        for c in s: freq[ord(c) - 97] += 1

        MOD = 1_000_000_007
        fac = cache(lambda x: x*fac(x-1)%MOD if x else 1)
        ifac = cache(lambda x: pow(fac(x), MOD-2, MOD)) # Fermat's little theorem (a**(p-1) = 1 (mod p))

        ans, n = 0, len(s)
        for c in s:
            val = ord(c) - 97
            mult = fac(n-1)
            for k in range(26): mult *= ifac(freq[k])
            for k in range(val): ans += freq[k] * mult
            n -= 1
            freq[val] -= 1
        return ans % MOD


    """1832. Check if the Sentence Is Pangram (Easy)
    A pangram is a sentence where every letter of the English alphabet appears
    at least once. Given a string sentence containing only lowercase English
    letters, return true if sentence is a pangram, or false otherwise.

    Example 1:
    Input: sentence = "thequickbrownfoxjumpsoverthelazydog"
    Output: true
    Explanation: sentence contains at least one of every letter of the English alphabet.

    Example 2:
    Input: sentence = "leetcode"
    Output: false

    Constraints:
    * 1 <= sentence.length <= 1000
    * sentence consists of lowercase English letters."""

    def checkIfPangram(self, sentence: str) -> bool:
        freq = [0]*26
        for x in sentence:
            freq[ord(x) - 97] += 1
        return min(freq) > 0


    """1833. Maximum Ice Cream Bars (Medium)
    It is a sweltering summer day, and a boy wants to buy some ice cream bars.
    At the store, there are n ice cream bars. You are given an array costs of
    length n, where costs[i] is the price of the ith ice cream bar in coins.
    The boy initially has coins coins to spend, and he wants to buy as many ice
    cream bars as possible. Return the maximum number of ice cream bars the boy
    can buy with coins coins. Note: The boy can buy the ice cream bars in any
    order.

    Example 1:
    Input: costs = [1,3,2,4,1], coins = 7
    Output: 4
    Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total
                 price of 1 + 3 + 2 + 1 = 7.

    Example 2:
    Input: costs = [10,6,8,7,7,8], coins = 5
    Output: 0
    Explanation: The boy cannot afford any of the ice cream bars.

    Example 3:
    Input: costs = [1,6,3,1,2,5], coins = 20
    Output: 6
    Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.

    Constraints:
    * costs.length == n
    * 1 <= n <= 10^5
    * 1 <= costs[i] <= 10^5
    * 1 <= coins <= 10^8"""

    def maxIceCream(self, costs: List[int], coins: int) -> int:
        ans = 0
        for x in sorted(costs):
            if x <= coins:
                ans += 1
                coins -= x
            else: break
        return ans


    """1834. Single-Threaded CPU (Medium)
    You are given n tasks labeled from 0 to n - 1 represented by a 2D
    integer array tasks, where tasks[i] = [enqueueTimei, processingTimei]
    means that the ith task will be available to process at enqueueTimei
    and will take processingTimei to finish processing. You have a single-
    threaded CPU that can process at most one task at a time and will act in
    the following way:
    * If the CPU is idle and there are no available tasks to process, the CPU
      remains idle.
    * If the CPU is idle and there are available tasks, the CPU will choose the
      one with the shortest processing time. If multiple tasks have the same
      shortest processing time, it will choose the task with the smallest index.
    * Once a task is started, the CPU will process the entire task without
      stopping.
    * The CPU can finish a task then start a new one instantly.
    Return the order in which the CPU will process the tasks.

    Example 1:
    Input: tasks = [[1,2],[2,4],[3,2],[4,1]]
    Output: [0,2,3,1]
    Explanation: The events go as follows:
    - At time = 1, task 0 is available to process. Available tasks = {0}.
    - Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.
    - At time = 2, task 1 is available to process. Available tasks = {1}.
    - At time = 3, task 2 is available to process. Available tasks = {1, 2}.
    - Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.
    - At time = 4, task 3 is available to process. Available tasks = {1, 3}.
    - At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.
    - At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.
    - At time = 10, the CPU finishes task 1 and becomes idle.

    Example 2:
    Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
    Output: [4,3,2,0,1]
    Explanation: The events go as follows:
    - At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.
    - Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.
    - At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.
    - At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.
    - At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.
    - At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.
    - At time = 40, the CPU finishes task 1 and becomes idle.

    Constraints:
    * tasks.length == n
    * 1 <= n <= 10^5
    * 1 <= enqueueTimei, processingTimei <= 10^9"""

    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        ans = []
        pq = [] # min-heap
        t = 0 # end of prev task

        tasks.append([inf, inf])
        for (enq, prc), i in sorted(zip(tasks, range(len(tasks)))): # adding a sentinel
            while pq and t < enq:
                tp, ii, te = heappop(pq)
                ans.append(ii)
                t = max(t, te) + tp # time finish processing this task
            heappush(pq, (prc, i, enq))
        return ans


    """1835. Find XOR Sum of All Pairs Bitwise AND (Hard)
    The XOR sum of a list is the bitwise XOR of all its elements. If the list
    only contains one element, then its XOR sum will be equal to this element.
    For example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 4 = 4,
    and the XOR sum of [3] is equal to 3. You are given two 0-indexed arrays
    arr1 and arr2 that consist only of non-negative integers. Consider the list
    containing the result of arr1[i] AND arr2[j] (bitwise AND) for every (i, j)
    pair where 0 <= i < arr1.length and 0 <= j < arr2.length. Return the XOR
    sum of the aforementioned list.

    Example 1:
    Input: arr1 = [1,2,3], arr2 = [6,5]
    Output: 0
    Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1].
                 The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.

    Example 2:
    Input: arr1 = [12], arr2 = [4]
    Output: 4
    Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4.

    Constraints:
    * 1 <= arr1.length, arr2.length <= 10^5
    * 0 <= arr1[i], arr2[j] <= 10^9"""

    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        return reduce(xor, arr1) & reduce(xor, arr2)


    """1836. Remove Duplicates From an Unsorted Linked List (Medium)
    Given the head of a linked list, find all the values that appear more than
    once in the list and delete the nodes that have any of those values. Return
    the linked list after the deletions.

    Example 1:
    Input: head = [1,2,3,2]
    Output: [1,3]
    Explanation: 2 appears twice in the linked list, so all 2's should be
                 deleted. After deleting all 2's, we are left with [1,3].

    Example 2:
    Input: head = [2,1,1,2]
    Output: []
    Explanation: 2 and 1 both appear twice. All the elements should be deleted.

    Example 3:
    Input: head = [3,2,2,1,3,2,4]
    Output: [1,4]
    Explanation: 3 appears twice and 2 appears three times. After deleting all
                 3's and 2's, we are left with [1,4].

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5]
    * 1 <= Node.val <= 10^5"""

    def deleteDuplicatesUnsorted(self, head: ListNode) -> ListNode:
        freq = defaultdict(int)
        node = head
        while node:
            freq[node.val] += 1
            node = node.next

        dummy = node = ListNode(next=head)
        while node.next:
            if freq[node.next.val] > 1: node.next = node.next.next
            else: node = node.next
        return dummy.next


    """1837. Sum of Digits in Base K (Easy)
    Given an integer n (in base 10) and a base k, return the sum of the digits
    of n after converting n from base 10 to base k. After converting, each
    digit should be interpreted as a base 10 number, and the sum should be
    returned in base 10.

    Example 1:
    Input: n = 34, k = 6
    Output: 9
    Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.

    Example 2:
    Input: n = 10, k = 10
    Output: 1
    Explanation: n is already in base 10. 1 + 0 = 1.

    Constraints:
    * 1 <= n <= 100
    * 2 <= k <= 10"""

    def sumBase(self, n: int, k: int) -> int:
        ans = 0
        while n:
            n, x = divmod(n, k)
            ans += x
        return ans


    """1838. Frequency of the Most Frequent Element (Medium)
    The frequency of an element is the number of times it occurs in an array.
    You are given an integer array nums and an integer k. In one operation, you
    can choose an index of nums and increment the element at that index by 1.
    Return the maximum possible frequency of an element after performing at
    most k operations.

    Example 1:
    Input: nums = [1,2,4], k = 5
    Output: 3
    Explanation: Increment the first element three times and the second element
                 two times to make nums = [4,4,4]. 4 has a frequency of 3.

    Example 2:
    Input: nums = [1,4,8,13], k = 5
    Output: 2
    Explanation: There are multiple optimal solutions:
    - Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
    - Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
    - Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.

    Example 3:
    Input: nums = [3,9,6], k = 2
    Output: 1

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= 10^5"""

    def maxFrequency(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = ii = sm = 0
        for i in range(len(nums)):
            sm += nums[i]
            while k < nums[i]*(i-ii+1) - sm:
                sm -= nums[ii]
                ii += 1
            ans = max(ans, i - ii + 1)
        return ans


    """1839. Longest Substring Of All Vowels in Order (Medium)
    A string is considered beautiful if it satisfies the following conditions:
    * Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at
      least once in it.
    * The letters must be sorted in alphabetical order (i.e. all 'a's before
      'e's, all 'e's before 'i's, etc.).
    For example, strings "aeiou" and "aaaaaaeiiiioou" are considered beautiful,
    but "uaeio", "aeoiu", and "aaaeeeooo" are not beautiful. Given a string
    word consisting of English vowels, return the length of the longest
    beautiful substring of word. If no such substring exists, return 0. A
    substring is a contiguous sequence of characters in a string.

    Example 1:
    Input: word = "aeiaaioaaaaeiiiiouuuooaauuaeiu"
    Output: 13
    Explanation: The longest beautiful substring in word is "aaaaeiiiiouuu" of
                 length 13.

    Example 2:
    Input: word = "aeeeiiiioooauuuaeiou"
    Output: 5
    Explanation: The longest beautiful substring in word is "aeiou" of length 5.

    Example 3:
    Input: word = "a"
    Output: 0
    Explanation: There is no beautiful substring, so return 0.

    Constraints:
    * 1 <= word.length <= 5 * 10^5
    * word consists of characters 'a', 'e', 'i', 'o', and 'u'."""

    def longestBeautifulSubstring(self, word: str) -> int:
        ans = 0
        cnt = unique = 1
        for i in range(1, len(word)):
            if word[i-1] <= word[i]:
                cnt += 1
                if word[i-1] < word[i]: unique += 1
            else: cnt = unique = 1
            if unique == 5: ans = max(ans, cnt)
        return ans


    """1840. Maximum Building Height (Hard)
    You want to build n new buildings in a city. The new buildings will be
    built in a line and are labeled from 1 to n. However, there are city
    restrictions on the heights of the new buildings:
    * The height of each building must be a non-negative integer.
    * The height of the first building must be 0.
    * The height difference between any two adjacent buildings cannot exceed 1.
    Additionally, there are city restrictions on the maximum height of specific
    buildings. These restrictions are given as a 2D integer array restrictions
    where restrictions[i] = [idi, maxHeighti] indicates that building idi must
    have a height less than or equal to maxHeighti. It is guaranteed that each
    building will appear at most once in restrictions, and building 1 will not
    be in restrictions. Return the maximum possible height of the tallest
    building.

    Example 1:
    Input: n = 5, restrictions = [[2,1],[4,1]]
    Output: 2
    Explanation: The green area in the image indicates the maximum allowed
                 height for each building. We can build the buildings with
                 heights [0,1,2,1,2], and the tallest building has a height of
                 2.

    Example 2:
    Input: n = 6, restrictions = []
    Output: 5
    Explanation: The green area in the image indicates the maximum allowed
                 height for each building. We can build the buildings with
                 heights [0,1,2,3,4,5], and the tallest building has a height
                 of 5.

    Example 3:
    Input: n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]
    Output: 5
    Explanation: The green area in the image indicates the maximum allowed
                 height for each building. We can build the buildings with
                 heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a
                 height of 5.

    Constraints:
    * 2 <= n <= 10^9
    * 0 <= restrictions.length <= min(n - 1, 10^5)
    * 2 <= idi <= n
    * idi is unique.
    * 0 <= maxHeighti <= 10^9"""

    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
        restrictions.extend([[1, 0], [n, n-1]])
        restrictions.sort()

        for i in reversed(range(len(restrictions)-1)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1] + restrictions[i+1][0] - restrictions[i][0])

        ans = 0
        for i in range(1, len(restrictions)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0])
            ans = max(ans, (restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0] + restrictions[i][1])//2)
        return ans


    """1842. Next Palindrome Using Same Digits (Hard)
    You are given a numeric string num, representing a very large palindrome.
    Return the smallest palindrome larger than num that can be created by
    rearranging its digits. If no such palindrome exists, return an empty
    string "". A palindrome is a number that reads the same backward as
    forward.

    Example 1:
    Input: num = "1221"
    Output: "2112"
    Explanation: The next palindrome larger than "1221" is "2112".

    Example 2:
    Input: num = "32123"
    Output: ""
    Explanation: No palindromes larger than "32123" can be made by rearranging the digits.

    Example 3:
    Input: num = "45544554"
    Output: "54455445"
    Explanation: The next palindrome larger than "45544554" is "54455445".

    Constraints:
    * 1 <= num.length <= 10^5
    * num is a palindrome."""

    def nextPalindrome(self, num: str) -> str:
        num = list(num)
        n = len(num)
        for i in range(n//2-2, -1, -1):
            if num[i] < num[i+1]:
                ii = i+1
                for j in range(i+1, n//2):
                    if num[i] < num[j]: ii = j
                num[i], num[ii] = num[ii], num[i]
                for j in range(i+1, (i+1+n//2)//2):
                    num[j], num[n//2+i-j] = num[n//2+i-j], num[j]
                for i in range((n+1)//2, n): num[i] = num[n-1-i]
                return "".join(num)
        return ""


    """1844. Replace All Digits with Characters (Easy)
    You are given a 0-indexed string s that has lowercase English letters in
    its even indices and digits in its odd indices. There is a function
    shift(c, x), where c is a character and x is a digit, that returns the xth
    character after c.
    * For example, shift('a', 5) = 'f' and shift('x', 0) = 'x'.
    For every odd index i, you want to replace the digit s[i] with
    shift(s[i-1], s[i]). Return s after replacing all digits. It is guaranteed
    that shift(s[i-1], s[i]) will never exceed 'z'.

    Example 1:
    Input: s = "a1c1e1"
    Output: "abcdef"
    Explanation: The digits are replaced as follows:
                 - s[1] -> shift('a',1) = 'b'
                 - s[3] -> shift('c',1) = 'd'
                 - s[5] -> shift('e',1) = 'f'

    Example 2:
    Input: s = "a1b2c3d4e"
    Output: "abbdcfdhe"
    Explanation: The digits are replaced as follows:
                 - s[1] -> shift('a',1) = 'b'
                 - s[3] -> shift('b',2) = 'd'
                 - s[5] -> shift('c',3) = 'f'
                 - s[7] -> shift('d',4) = 'h'

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of lowercase English letters and digits.
    * shift(s[i-1], s[i]) <= 'z' for all odd indices i."""

    def replaceDigits(self, s: str) -> str:
        s = list(s)
        for i in range(1, len(s), 2):
            s[i] = chr(ord(s[i-1]) + int(s[i]))
        return "".join(s)


    """1846. Maximum Element After Decreasing and Rearranging (Medium)
    You are given an array of positive integers arr. Perform some operations
    (possibly none) on arr so that it satisfies these conditions:
    * The value of the first element in arr must be 1.
    * The absolute difference between any 2 adjacent elements must be less than
      or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i
      where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
    There are 2 types of operations that you can perform any number of times:
    * Decrease the value of any element of arr to a smaller positive integer.
    * Rearrange the elements of arr to be in any order.
    Return the maximum possible value of an element in arr after performing the
    operations to satisfy the conditions.

    Example 1:
    Input: arr = [2,2,1,2,1]
    Output: 2
    Explanation: We can satisfy the conditions by rearranging arr so it becomes
                 [1,2,2,2,1]. The largest element in arr is 2.

    Example 2:
    Input: arr = [100,1,1000]
    Output: 3
    Explanation: One possible way to satisfy the conditions is by doing the
                 following:
                 1. Rearrange arr so it becomes [1,100,1000].
                 2. Decrease the value of the second element to 2.
                 3. Decrease the value of the third element to 3.
                 Now arr = [1,2,3], which satisfies the conditions. The largest
                 element in arr is 3.

    Example 3:
    Input: arr = [1,2,3,4,5]
    Output: 5
    Explanation: The array already satisfies the conditions, and the largest
                 element is 5.

    Constraints:
    * 1 <= arr.length <= 10^5
    * 1 <= arr[i] <= 10^9"""

    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
        arr.sort()
        ans = 0
        for x in arr:
            ans = min(ans+1, x)
        return ans


    """1847. Closest Room (Hard)
    There is a hotel with n rooms. The rooms are represented by a 2D integer
    array rooms where rooms[i] = [roomIdi, sizei] denotes that there is a room
    with room number roomIdi and size equal to sizei. Each roomIdi is
    guaranteed to be unique. You are also given k queries in a 2D array queries
    where queries[j] = [preferredj, minSizej]. The answer to the jth query is
    the room number id of a room such that:
    * The room has a size of at least minSizej, and
    * abs(id - preferredj) is minimized, where abs(x) is the absolute value of
      x.
    If there is a tie in the absolute difference, then use the room with the
    smallest such id. If there is no such room, the answer is -1. Return an
    array answer of length k where answer[j] contains the answer to the jth
    query.

    Example 1:
    Input: rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]
    Output: [3,-1,3]
    Explanation: The answers to the queries are as follows:
    Query = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.
    Query = [3,3]: There are no rooms with a size of at least 3, so the answer is -1.
    Query = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3.

    Example 2:
    Input: rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]
    Output: [2,1,3]
    Explanation: The answers to the queries are as follows:
    Query = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.
    Query = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.
    Query = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3.

    Constraints:
    * n == rooms.length
    * 1 <= n <= 10^5
    * k == queries.length
    * 1 <= k <= 10^4
    * 1 <= roomIdi, preferredj <= 10^7
    * 1 <= sizei, minSizej <= 10^7"""

    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        rooms.sort(key=lambda x: (-x[1], x[0])) # descending order

        ans = [-1] * len(queries)
        sl = SortedList()
        k = 0

        for (preferred, msz), i in sorted(zip(queries, range(len(queries))), key=lambda x: (-x[0][1], x[0][0])): # descending order
            while k < len(rooms) and rooms[k][1] >= msz:
                sl.add(rooms[k][0])
                k += 1
            v = sl.bisect_left(preferred)
            if sl:
                if v == len(sl) or v > 0 and preferred - sl[v-1] <= sl[v] - preferred: ans[i] = sl[v-1]
                else: ans[i] = sl[v]
        return ans


    """1848. Minimum Distance to the Target Element (Easy)
    Given an integer array nums (0-indexed) and two integers target and start,
    find an index i such that nums[i] == target and abs(i - start) is minimized.
    Note that abs(x) is the absolute value of x. Return abs(i - start). It is
    guaranteed that target exists in nums.

    Example 1:
    Input: nums = [1,2,3,4,5], target = 5, start = 3
    Output: 1
    Explanation: nums[4] = 5 is the only value equal to target, so the answer
                 is abs(4 - 3) = 1.

    Example 2:
    Input: nums = [1], target = 1, start = 0
    Output: 0
    Explanation: nums[0] = 1 is the only value equal to target, so the answer
                 is abs(0 - 0) = 0.

    Example 3:
    Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
    Output: 0
    Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start),
                 which is abs(0 - 0) = 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^4
    * 0 <= start < nums.length
    * target is in nums."""

    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        ans = inf
        for i, x in enumerate(nums):
            if x == target:
                ans = min(ans, abs(i - start))
        return ans


    """1849. Splitting a String Into Descending Consecutive Values (Medium)
    You are given a string s that consists of only digits. Check if we can
    split s into two or more non-empty substrings such that the numerical
    values of the substrings are in descending order and the difference between
    numerical values of every two adjacent substrings is equal to 1.

    * For example, the string s = "0090089" can be split into ["0090", "089"]
      with numerical values [90,89]. The values are in descending order and
      adjacent values differ by 1, so this way is valid.
    * Another example, the string s = "001" can be split into ["0", "01"],
      ["00", "1"], or ["0", "0", "1"]. However all the ways are invalid because
      they have numerical values [0,1], [0,1], and [0,0,1] respectively, all of
      which are not in descending order.
    Return true if it is possible to split s as described above, or false
    otherwise. A substring is a contiguous sequence of characters in a string.

    Example 1:
    Input: s = "1234"
    Output: false
    Explanation: There is no valid way to split s.

    Example 2:
    Input: s = "050043"
    Output: true
    Explanation: s can be split into ["05", "004", "3"] with numerical values
                 [5,4,3]. The values are in descending order with adjacent
                 values differing by 1.

    Example 3:
    Input: s = "9080701"
    Output: false
    Explanation: There is no valid way to split s.

    Example 4:
    Input: s = "10009998"
    Output: true
    Explanation: s can be split into ["100", "099", "98"] with numerical values
                 [100,99,98]. The values are in descending order with adjacent
                 values differing by 1.

    Constraints:
    * 1 <= s.length <= 20
    * s only consists of digits."""

    def splitString(self, s: str) -> bool:

        def fn(i, x):
            """Return True if s[i:] can be split following x."""
            if i == len(s): return True
            if x == 0: return False
            ans = False
            for ii in range(i, len(s) - int(i == 0)):
                if x is None or int(s[i:ii+1]) == x - 1:
                    ans = ans or fn(ii+1, int(s[i:ii+1]))
            return ans

        return fn(0, None)


    """1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number (Medium)
    You are given a string num, representing a large integer, and an integer k.
    We call some integer wonderful if it is a permutation of the digits in num
    and is greater in value than num. There can be many wonderful integers.
    However, we only care about the smallest-valued ones.

    For example, when num = "5489355142":
    * The 1st smallest wonderful integer is "5489355214".
    * The 2nd smallest wonderful integer is "5489355241".
    * The 3rd smallest wonderful integer is "5489355412".
    * The 4th smallest wonderful integer is "5489355421".
    Return the minimum number of adjacent digit swaps that needs to be applied
    to num to reach the kth smallest wonderful integer. The tests are generated
    in such a way that kth smallest wonderful integer exists.

    Example 1:
    Input: num = "5489355142", k = 4
    Output: 2
    Explanation: The 4th smallest wonderful number is "5489355421". To get this
                 number:
                 - Swap index 7 with index 8: "5489355142" -> "5489355412"
                 - Swap index 8 with index 9: "5489355412" -> "5489355421"

    Example 2:
    Input: num = "11112", k = 4
    Output: 4
    Explanation: The 4th smallest wonderful number is "21111". To get this
                 number:
                 - Swap index 3 with index 4: "11112" -> "11121"
                 - Swap index 2 with index 3: "11121" -> "11211"
                 - Swap index 1 with index 2: "11211" -> "12111"
                 - Swap index 0 with index 1: "12111" -> "21111"

    Example 3:
    Input: num = "00123", k = 1
    Output: 1
    Explanation: The 1st smallest wonderful number is "00132". To get this number:
                 - Swap index 3 with index 4: "00123" -> "00132"

    Constraints:
    * 2 <= num.length <= 1000
    * 1 <= k <= 1000
    * num only consists of digits."""

    def getMinSwaps(self, num: str, k: int) -> int:
        num = list(num)
        orig = num.copy()

        for _ in range(k):
            for i in reversed(range(len(num)-1)):
                if num[i] < num[i+1]:
                    ii = i+1
                    while ii < len(num) and num[i] < num[ii]: ii += 1
                    num[i], num[ii-1] = num[ii-1], num[i]
                    lo, hi = i+1, len(num)-1
                    while lo < hi:
                        num[lo], num[hi] = num[hi], num[lo]
                        lo += 1
                        hi -= 1
                    break

        ans = 0
        for i in range(len(num)):
            ii = i
            while orig[i] != num[i]:
                ans += 1
                ii += 1
                num[i], num[ii] = num[ii], num[i]
        return ans


    """1851. Minimum Interval to Include Each Query (Hard)
    You are given a 2D integer array intervals, where
    intervals[i] = [lefti, righti] describes the ith interval starting at lefti
    and ending at righti (inclusive). The size of an interval is defined as the
    number of integers it contains, or more formally righti - lefti + 1. You
    are also given an integer array queries. The answer to the jth query is the
    size of the smallest interval i such that lefti <= queries[j] <= righti. If
    no such interval exists, the answer is -1. Return an array containing the
    answers to the queries.

    Example 1:
    Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
    Output: [3,3,1,4]
    Explanation: The queries are processed as follows:
    - Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.
    - Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.
    - Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.
    - Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.

    Example 2:
    Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
    Output: [2,-1,4,6]
    Explanation: The queries are processed as follows:
    - Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.
    - Query = 19: None of the intervals contain 19. The answer is -1.
    - Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.
    - Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.

    Constraints:
    * 1 <= intervals.length <= 10^5
    * 1 <= queries.length <= 10^5
    * intervals[i].length == 2
    * 1 <= lefti <= righti <= 10^7
    * 1 <= queries[j] <= 10^7"""

    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        intervals.sort()
        pq = []
        k = 0
        ans = [-1] * len(queries)
        for query, i in sorted(zip(queries, range(len(queries)))):
            while k < len(intervals) and intervals[k][0] <= query:
                heappush(pq, (intervals[k][1] - intervals[k][0] + 1, *intervals[k]))
                k += 1
            while pq and pq[0][2] < query:
                heappop(pq)
            if pq: ans[i] = pq[0][0]
        return ans


    """1852. Distinct Numbers in Each Subarray (Medium)
    Given an integer array nums and an integer k, you are asked to construct
    the array ans of size n-k+1 where ans[i] is the number of distinct numbers
    in the subarray nums[i:i+k-1] = [nums[i], nums[i+1], ..., nums[i+k-1]].
    Return the array ans.

    Example 1:
    Input: nums = [1,2,3,2,2,1,3], k = 3
    Output: [3,2,2,2,3]
    Explanation: The number of distinct elements in each subarray goes as follows:
                 - nums[0:2] = [1,2,3] so ans[0] = 3
                 - nums[1:3] = [2,3,2] so ans[1] = 2
                 - nums[2:4] = [3,2,2] so ans[2] = 2
                 - nums[3:5] = [2,2,1] so ans[3] = 2
                 - nums[4:6] = [2,1,3] so ans[4] = 3

    Example 2:
    Input: nums = [1,1,1,1,2,3,4], k = 4
    Output: [1,2,3,4]
    Explanation: The number of distinct elements in each subarray goes as follows:
                 - nums[0:3] = [1,1,1,1] so ans[0] = 1
                 - nums[1:4] = [1,1,1,2] so ans[1] = 2
                 - nums[2:5] = [1,1,2,3] so ans[2] = 3
                 - nums[3:6] = [1,2,3,4] so ans[3] = 4

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def distinctNumbers(self, nums: List[int], k: int) -> List[int]:
        ans = []
        freq = defaultdict(int)
        for i, x in enumerate(nums):
            freq[x] += 1
            if i >= k:
                freq[nums[i-k]] -= 1
                if freq[nums[i-k]] == 0: freq.pop(nums[i-k])
            if i+1 >= k: ans.append(len(freq))
        return ans


    """1854. Maximum Population Year (Easy)
    You are given a 2D integer array logs where each logs[i] = [birthi, deathi]
    indicates the birth and death years of the ith person. The population of
    some year x is the number of people alive during that year. The ith person
    is counted in year x's population if x is in the inclusive range
    [birthi, deathi - 1]. Note that the person is not counted in the year that
    they die. Return the earliest year with the maximum population.

    Example 1:
    Input: logs = [[1993,1999],[2000,2010]]
    Output: 1993
    Explanation: The maximum population is 1, and 1993 is the earliest year
                 with this population.

    Example 2:
    Input: logs = [[1950,1961],[1960,1971],[1970,1981]]
    Output: 1960
    Explanation: The maximum population is 2, and it had happened in years 1960
                 and 1970. The earlier year between them is 1960.

    Constraints:
    * 1 <= logs.length <= 100
    * 1950 <= birthi < deathi <= 2050"""

    def maximumPopulation(self, logs: List[List[int]]) -> int:
        vals = []
        for x, y in logs:
            vals.append((x, 1))
            vals.append((y, -1))
        ans = prefix = most = 0
        for x, k in sorted(vals):
            prefix += k
            if prefix > most:
                ans = x
                most = prefix
        return ans


    """1855. Maximum Distance Between a Pair of Values (Medium)
    You are given two non-increasing 0-indexed integer arrays nums1​​​​​​ and
    nums2​​​​​​. A pair of indices (i, j), where 0 <= i < nums1.length and
    0 <= j < nums2.length, is valid if both i <= j and nums1[i] <= nums2[j].
    The distance of the pair is j - i​​​​. Return the maximum distance of any
    valid pair (i, j). If there are no valid pairs, return 0. An array arr is
    non-increasing if arr[i-1] >= arr[i] for every 1 <= i < arr.length.

    Example 1:
    Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
    Output: 2
    Explanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4),
                 and (4,4). The maximum distance is 2 with pair (2,4).

    Example 2:
    Input: nums1 = [2,2,2], nums2 = [10,10,1]
    Output: 1
    Explanation: The valid pairs are (0,0), (0,1), and (1,1). The maximum
                 distance is 1 with pair (0,1).

    Example 3:
    Input: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
    Output: 2
    Explanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).
                 The maximum distance is 2 with pair (2,4).

    Example 4:
    Input: nums1 = [5,4], nums2 = [3,2]
    Output: 0
    Explanation: There are no valid pairs, so return 0.

    Constraints:
    * 1 <= nums1.length <= 10^5
    * 1 <= nums2.length <= 10^5
    * 1 <= nums1[i], nums2[j] <= 10^5
    * Both nums1 and nums2 are non-increasing."""

    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
        ans = ii = 0
        for i, x in enumerate(nums2):
            while ii < len(nums1) and nums1[ii] > nums2[i]: ii += 1
            if ii < len(nums1): ans = max(ans, i - ii)
        return ans


    """1856. Maximum Subarray Min-Product (Medium)
    The min-product of an array is equal to the minimum value in the array
    multiplied by the array's sum. For example, the array [3,2,5] (minimum
    value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20. Given an array
    of integers nums, return the maximum min-product of any non-empty subarray
    of nums. Since the answer may be large, return it modulo 10^9 + 7. Note
    that the min-product should be maximized before performing the modulo
    operation. Testcases are generated such that the maximum min-product
    without modulo will fit in a 64-bit signed integer. A subarray is a
    contiguous part of an array.

    Example 1:
    Input: nums = [1,2,3,2]
    Output: 14
    Explanation: The maximum min-product is achieved with the subarray [2,3,2]
                 (minimum value is 2). 2 * (2+3+2) = 2 * 7 = 14.

    Example 2:
    Input: nums = [2,3,3,1,2]
    Output: 18
    Explanation: The maximum min-product is achieved with the subarray [3,3]
                 (minimum value is 3). 3 * (3+3) = 3 * 6 = 18.

    Example 3:
    Input: nums = [3,1,5,6,4,2]
    Output: 60
    Explanation: The maximum min-product is achieved with the subarray [5,6,4]
                 (minimum value is 4). 4 * (5+6+4) = 4 * 15 = 60.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^7"""

    def maxSumMinProduct(self, nums: List[int]) -> int:
        prefix = [0]
        for x in nums: prefix.append(prefix[-1] + x)

        ans = 0
        stack = []
        for i, x in enumerate(nums + [-inf]): # append "-inf" to force flush all elements
            while stack and stack[-1][1] >= x:
                _, xx = stack.pop()
                ii = stack[-1][0] if stack else -1
                ans = max(ans, xx*(prefix[i] - prefix[ii+1]))
            stack.append((i, x))
        return ans % 1_000_000_007


    """1857. Largest Color Value in a Directed Graph (Hard)
    There is a directed graph of n colored nodes and m edges. The nodes are
    numbered from 0 to n - 1. You are given a string colors where colors[i] is
    a lowercase English letter representing the color of the ith node in this
    graph (0-indexed). You are also given a 2D array edges where
    edges[j] = [aj, bj] indicates that there is a directed edge from node aj to
    node bj. A valid path in the graph is a sequence of nodes
    x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to
    xi+1 for every 1 <= i < k. The color value of the path is the number of
    nodes that are colored the most frequently occurring color along that path.
    Return the largest color value of any valid path in the given graph, or -1
    if the graph contains a cycle.

    Example 1:
    Input: colors = "abaca", edges = [[0,1],[0,2],[2,3],[3,4]]
    Output: 3
    Explanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored "a"
                 (red in the above image).

    Example 2:
    Input: colors = "a", edges = [[0,0]]
    Output: -1
    Explanation: There is a cycle from 0 to 0.

    Constraints:
    * n == colors.length
    * m == edges.length
    * 1 <= n <= 10^5
    * 0 <= m <= 10^5
    * colors consists of lowercase English letters.
    * 0 <= aj, bj < n"""

    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
        graph = {}
        indeg = [0] * len(colors)
        for u, v in edges:
            indeg[v] += 1
            graph.setdefault(u, []).append(v)

        roots = [x for x in range(len(colors)) if indeg[x] == 0]

        # Kahn's algo
        stack = roots.copy()
        nodes = []
        while stack:
            x = stack.pop()
            nodes.append(x)
            for xx in graph.get(x, []):
                indeg[xx] -= 1
                if indeg[xx] == 0: stack.append(xx)
        if len(nodes) < len(colors): return -1 # cycle detected

        @cache
        def fn(x):
            """Return distribution of (maximized) colors at given node."""
            ans = [0]*26
            ans[ord(colors[x]) - 97] = 1
            for xx in graph.get(x, []):
                val = fn(xx)
                for i in range(26):
                    if i == ord(colors[x]) - 97: ans[i] = max(ans[i], 1 + val[i])
                    else: ans[i] = max(ans[i], val[i])
            return ans

        ans = [0]*26
        for root in roots:
            val = fn(root)
            for i in range(26): ans[i] = max(ans[i], val[i])
        return max(ans)


    """1858. Longest Word With All Prefixes (Medium)
    Given an array of strings words, find the longest string in words such that
    every prefix of it is also in words. For example, let
    words = ["a", "app", "ap"]. The string "app" has prefixes "ap" and "a", all
    of which are in words. Return the string described above. If there is more
    than one string with the same length, return the lexicographically smallest
    one, and if no string exists, return "".

    Example 1:
    Input: words = ["k","ki","kir","kira", "kiran"]
    Output: "kiran"
    Explanation: "kiran" has prefixes "kira", "kir", "ki", and "k", and all of
                 them appear in words.

    Example 2:
    Input: words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
    Output: "apple"
    Explanation: Both "apple" and "apply" have all their prefixes in words.
                 However, "apple" is lexicographically smaller, so we return
                 that.

    Example 3:
    Input: words = ["abc", "bc", "ab", "qwe"]
    Output: ""

    Constraints:
    * 1 <= words.length <= 10^5
    * 1 <= words[i].length <= 10^5
    * 1 <= sum(words[i].length) <= 10^5"""

    def longestWord(self, words: List[str]) -> str:
        ans = ""
        seen = {""}
        for word in sorted(words, key=lambda x: (len(x), x)):
            if word[:-1] in seen:
                seen.add(word)
                ans = max(ans, word, key=len)
        return ans


    """1859. Sorting the Sentence (Easy)
    A sentence is a list of words that are separated by a single space with no
    leading or trailing spaces. Each word consists of lowercase and uppercase
    English letters. A sentence can be shuffled by appending the 1-indexed word
    position to each word then rearranging the words in the sentence. For
    example, the sentence "This is a sentence" can be shuffled as
    "sentence4 a3 is2 This1" or "is2 sentence4 This1 a3". Given a shuffled
    sentence s containing no more than 9 words, reconstruct and return the
    original sentence.

    Example 1:
    Input: s = "is2 sentence4 This1 a3"
    Output: "This is a sentence"
    Explanation: Sort the words in s to their original positions
                 "This1 is2 a3 sentence4", then remove the numbers.

    Example 2:
    Input: s = "Myself2 Me1 I4 and3"
    Output: "Me Myself and I"
    Explanation: Sort the words in s to their original positions
                 "Me1 Myself2 and3 I4", then remove the numbers.

    Constraints:
    * 2 <= s.length <= 200
    * s consists of lowercase and uppercase English letters, spaces, and digits
      from 1 to 9.
    * The number of words in s is between 1 and 9.
    * The words in s are separated by a single space.
    * s contains no leading or trailing spaces."""

    def sortSentence(self, s: str) -> str:
        words = s.split()
        ans = [""]*len(words)
        for word in words:
            ans[int(word[-1])-1] = word[:-1]
        return " ".join(ans)


    """1860. Incremental Memory Leak (Medium)
    You are given two integers memory1 and memory2 representing the available
    memory in bits on two memory sticks. There is currently a faulty program
    running that consumes an increasing amount of memory every second. At the
    ith second (starting from 1), i bits of memory are allocated to the stick
    with more available memory (or from the first memory stick if both have the
    same available memory). If neither stick has at least i bits of available
    memory, the program crashes. Return an array containing
    [crashTime, memory1crash, memory2crash], where crashTime is the time (in
    seconds) when the program crashed and memory1crash and memory2crash are the
    available bits of memory in the first and second sticks respectively.

    Example 1:
    Input: memory1 = 2, memory2 = 2
    Output: [3,1,0]
    Explanation: The memory is allocated as follows:
    - At the 1st second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory.
    - At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory.
    - At the 3rd second, the program crashes. The sticks have 1 and 0 bits available respectively.

    Example 2:
    Input: memory1 = 8, memory2 = 11
    Output: [6,0,4]
    Explanation: The memory is allocated as follows:
    - At the 1st second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory.
    - At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory.
    - At the 3rd second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory.
    - At the 4th second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory.
    - At the 5th second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory.
    - At the 6th second, the program crashes. The sticks have 0 and 4 bits available respectively.

    Constraints: 0 <= memory1, memory2 <= 2^31 - 1"""

    def memLeak(self, memory1: int, memory2: int) -> List[int]:
        k = 1
        while k <= memory1 or k <= memory2:
            if memory1 < memory2: memory2 -= k
            else: memory1 -= k
            k += 1
        return [k, memory1, memory2]


    """1861. Rotating the Box (Medium)
    You are given an m x n matrix of characters box representing a side-view of
    a box. Each cell of the box is one of the following:
    * A stone '#'
    * A stationary obstacle '*'
    * Empty '.'
    The box is rotated 90 degrees clockwise, causing some of the stones to fall
    due to gravity. Each stone falls down until it lands on an obstacle, another
    stone, or the bottom of the box. Gravity does not affect the obstacles'
    positions, and the inertia from the box's rotation does not affect the
    stones' horizontal positions. It is guaranteed that each stone in box rests
    on an obstacle, another stone, or the bottom of the box. Return an n x m
    matrix representing the box after the rotation described above.

    Example 1:
    Input: box = [["#",".","#"]]
    Output: [["."],
             ["#"],
             ["#"]]

    Example 2:
    Input: box = [["#",".","*","."],
                  ["#","#","*","."]]
    Output: [["#","."],
             ["#","#"],
             ["*","*"],
             [".","."]]

    Example 3:
    Input: box = [["#","#","*",".","*","."],
                  ["#","#","#","*",".","."],
                  ["#","#","#",".","#","."]]
    Output: [[".","#","#"],
             [".","#","#"],
             ["#","#","*"],
             ["#","*","."],
             ["#",".","*"],
             ["#",".","."]]

    Constraints:
    * m == box.length
    * n == box[i].length
    * 1 <= m, n <= 500
    * box[i][j] is either '#', '*', or '.'."""

    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        m, n = len(box), len(box[0]) # dimensions

        for i in range(m//2): box[i], box[~i] = box[~i], box[i]
        box = [list(x) for x in zip(*box)]

        for j in range(m):
            count = 0
            for i in range(n):
                if box[i][j] == "#":
                    count += 1
                    box[i][j] = "."
                if i+1 == n or box[i+1][j] == "*":
                    for ii in range(count): box[i-ii][j] = "#"
                    count = 0
        return box


    """1862. Sum of Floored Pairs (Hard)
    Given an integer array nums, return the sum of floor(nums[i] / nums[j]) for
    all pairs of indices 0 <= i, j < nums.length in the array. Since the answer
    may be too large, return it modulo 10^9 + 7. The floor() function returns
    the integer part of the division.

    Example 1:
    Input: nums = [2,5,9]
    Output: 10
    Explanation:
    floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0
    floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1
    floor(5 / 2) = 2
    floor(9 / 2) = 4
    floor(9 / 5) = 1
    We calculate the floor of the division for every pair of indices in the
    array then sum them up.

    Example 2:
    Input: nums = [7,7,7,7,7,7,7]
    Output: 49

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def sumOfFlooredPairs(self, nums: List[int]) -> int:
        m = 2*max(nums)

        freq = [0]*(m+1)
        for x in nums: freq[x] += 1
        prefix = [0]
        for x in freq: prefix.append(prefix[-1] + x)

        ans = 0
        for i in range(1, m+1):
            if freq[i]:
                for ii in range(i, m+1, i):
                    count = prefix[ii] - prefix[ii-i]
                    ans += count * freq[i] * (ii//i-1)
        return ans % 1_000_000_007


    """1863. Sum of All Subset XOR Totals (Easy)
    The XOR total of an array is defined as the bitwise XOR of all its elements,
    or 0 if the array is empty.
    * For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
    Given an array nums, return the sum of all XOR totals for every subset of
    nums. Note that subsets with the same elements should be counted multiple
    times. An array a is a subset of an array b if a can be obtained from b by
    deleting some (possibly zero) elements of b.

    Example 1:
    Input: nums = [1,3]
    Output: 6
    Explanation: The 4 subsets of [1,3] are:
    - The empty subset has an XOR total of 0.
    - [1] has an XOR total of 1.
    - [3] has an XOR total of 3.
    - [1,3] has an XOR total of 1 XOR 3 = 2.
    0 + 1 + 3 + 2 = 6

    Example 2:
    Input: nums = [5,1,6]
    Output: 28
    Explanation: The 8 subsets of [5,1,6] are:
    - The empty subset has an XOR total of 0.
    - [5] has an XOR total of 5.
    - [1] has an XOR total of 1.
    - [6] has an XOR total of 6.
    - [5,1] has an XOR total of 5 XOR 1 = 4.
    - [5,6] has an XOR total of 5 XOR 6 = 3.
    - [1,6] has an XOR total of 1 XOR 6 = 7.
    - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
    0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

    Example 3:
    Input: nums = [3,4,5,6,7,8]
    Output: 480
    Explanation: The sum of all XOR totals for every subset is 480.

    Constraints:
    * 1 <= nums.length <= 12
    * 1 <= nums[i] <= 20"""

    def subsetXORSum(self, nums: List[int]) -> int:
        return reduce(or_, nums) << len(nums)-1


    """1864. Minimum Number of Swaps to Make the Binary String Alternating (Medium)
    Given a binary string s, return the minimum number of character swaps to
    make it alternating, or -1 if it is impossible. The string is called
    alternating if no two adjacent characters are equal. For example, the
    strings "010" and "1010" are alternating, while the string "0100" is not.
    Any two characters may be swapped, even if they are not adjacent.

    Example 1:
    Input: s = "111000"
    Output: 1
    Explanation: Swap positions 1 and 4: "111000" -> "101010". The string is
                 now alternating.

    Example 2:
    Input: s = "010"
    Output: 0
    Explanation: The string is already alternating, no swaps are needed.

    Example 3:
    Input: s = "1110"
    Output: -1

    Constraints:
    * 1 <= s.length <= 1000
    * s[i] is either '0' or '1'."""

    def minSwaps(self, s: str) -> int:
        ones = s.count("1")
        zeros = len(s) - ones
        if abs(ones - zeros) > 1: return -1 # impossible

        def fn(x):
            """Return number of swaps if string starts with x."""
            ans = 0
            for c in s:
                if c != x: ans += 1
                x = "1" if x == "0" else "0"
            return ans//2

        if ones > zeros: return fn("1")
        elif ones < zeros: return fn("0")
        else: return min(fn("0"), fn("1"))


    """1866. Number of Ways to Rearrange Sticks With K Sticks Visible (Hard)
    There are n uniquely-sized sticks whose lengths are integers from 1 to n.
    You want to arrange the sticks such that exactly k sticks are visible from
    the left. A stick is visible from the left if there are no longer sticks to
    the left of it. For example, if the sticks are arranged [1,3,2,5,4], then
    the sticks with lengths 1, 3, and 5 are visible from the left. Given n and
    k, return the number of such arrangements. Since the answer may be large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, k = 2
    Output: 3
    Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such
                 that exactly 2 sticks are visible. The visible sticks are
                 underlined.

    Example 2:
    Input: n = 5, k = 5
    Output: 1
    Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are
                 visible. The visible sticks are underlined.

    Example 3:
    Input: n = 20, k = 11
    Output: 647427950
    Explanation: There are 647427950 (mod 10^9 + 7) ways to rearrange the sticks
                 such that exactly 11 sticks are visible.

    Constraints:
    * 1 <= n <= 1000
    * 1 <= k <= n"""

    def rearrangeSticks(self, n: int, k: int) -> int:

        @cache
        def fn(n, k):
            """Return number of ways to rearrange n sticks to that k are visible."""
            if n == k: return 1
            if k == 0: return 0
            return ((n-1)*fn(n-1, k) + fn(n-1, k-1)) % 1_000_000_007

        return fn(n, k)


    """1868. Product of Two Run-Length Encoded Arrays (Medium)
    Run-length encoding is a compression algorithm that allows for an integer
    array nums with many segments of consecutive repeated numbers to be
    represented by a (generally smaller) 2D array encoded. Each
    encoded[i] = [vali, freqi] describes the ith segment of repeated numbers in
    nums where vali is the value that is repeated freqi times. For example,
    nums = [1,1,1,2,2,2,2,2] is represented by the run-length encoded array
    encoded = [[1,3],[2,5]]. Another way to read this is "three 1's followed by
    five 2's". The product of two run-length encoded arrays encoded1 and
    encoded2 can be calculated using the following steps:
    * Expand both encoded1 and encoded2 into the full arrays nums1 and nums2
      respectively.
    * Create a new array prodNums of length nums1.length and set
      prodNums[i] = nums1[i] * nums2[i].
    * Compress prodNums into a run-length encoded array and return it.
    You are given two run-length encoded arrays encoded1 and encoded2
    representing full arrays nums1 and nums2 respectively. Both nums1 and nums2
    have the same length. Each encoded1[i] = [vali, freqi] describes the ith
    segment of nums1, and each encoded2[j] = [valj, freqj] describes the jth
    segment of nums2. Return the product of encoded1 and encoded2.

    Note: Compression should be done such that the run-length encoded array has
          the minimum possible length.

    Example 1:
    Input: encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]]
    Output: [[6,6]]
    Explanation: encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to
                 [6,6,6,3,3,3]. prodNums = [6,6,6,6,6,6], which is compressed
                 into the run-length encoded array [[6,6]].

    Example 2:
    Input: encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]]
    Output: [[2,3],[6,1],[9,2]]
    Explanation: encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to
                 [2,2,2,3,3,3]. prodNums = [2,2,2,6,9,9], which is compressed
                 into the run-length encoded array [[2,3],[6,1],[9,2]].

    Constraints:
    * 1 <= encoded1.length, encoded2.length <= 10^5
    * encoded1[i].length == 2
    * encoded2[j].length == 2
    * 1 <= vali, freqi <= 10^4 for each encoded1[i].
    * 1 <= valj, freqj <= 10^4 for each encoded2[j].
    * The full arrays that encoded1 and encoded2 represent are the same length."""

    def findRLEArray(self, encoded1: List[List[int]], encoded2: List[List[int]]) -> List[List[int]]:
        ans = []
        i = j = 0
        while i < len(encoded1) and j < len(encoded2):
            val = encoded1[i][0] * encoded2[j][0]
            freq = min(encoded1[i][1], encoded2[j][1])
            if ans and ans[-1][0] == val: ans[-1][1] += freq
            else: ans.append([val, freq])
            encoded1[i][1] -= freq
            encoded2[j][1] -= freq
            if encoded1[i][1] == 0: i += 1
            if encoded2[j][1] == 0: j += 1
        return ans


    """1869. Longer Contiguous Segments of Ones than Zeros (Easy)
    Given a binary string s, return true if the longest contiguous segment of
    1s is strictly longer than the longest contiguous segment of 0s in s.
    Return false otherwise. For example, in s = "110100010" the longest
    contiguous segment of 1s has length 2, and the longest contiguous segment
    of 0s has length 3. Note that if there are no 0s, then the longest
    contiguous segment of 0s is considered to have length 0. The same applies
    if there are no 1s.

    Example 1:
    Input: s = "1101"
    Output: true
    Explanation:
    The longest contiguous segment of 1s has length 2: "1101"
    The longest contiguous segment of 0s has length 1: "1101"
    The segment of 1s is longer, so return true.

    Example 2:
    Input: s = "111000"
    Output: false
    Explanation:
    The longest contiguous segment of 1s has length 3: "111000"
    The longest contiguous segment of 0s has length 3: "111000"
    The segment of 1s is not longer, so return false.

    Example 3:
    Input: s = "110100010"
    Output: false
    Explanation:
    The longest contiguous segment of 1s has length 2: "110100010"
    The longest contiguous segment of 0s has length 3: "110100010"
    The segment of 1s is not longer, so return false.

    Constraints:
    * 1 <= s.length <= 100
    * s[i] is either '0' or '1'."""

    def checkZeroOnes(self, s: str) -> bool:
        ones = zeros = 0
        for i in range(len(s)):
            if i == 0 or s[i-1] != s[i]: cnt = 0
            cnt += 1
            if s[i] == "0": zeros = max(zeros, cnt)
            else: ones = max(ones, cnt)
        return ones > zeros


    """1870. Minimum Speed to Arrive on Time (Medium)
    You are given a floating-point number hour, representing the amount of time
    you have to reach the office. To commute to the office, you must take n
    trains in sequential order. You are also given an integer array dist of
    length n, where dist[i] describes the distance (in kilometers) of the ith
    train ride. Each train can only depart at an integer hour, so you may need
    to wait in between each train ride. For example, if the 1st train ride
    takes 1.5 hours, you must wait for an additional 0.5 hours before you can
    depart on the 2nd train ride at the 2 hour mark. Return the minimum
    positive integer speed (in kilometers per hour) that all the trains must
    travel at for you to reach the office on time, or -1 if it is impossible to
    be on time. Tests are generated such that the answer will not exceed 10^7
    and hour will have at most two digits after the decimal point.

    Example 1:
    Input: dist = [1,3,2], hour = 6
    Output: 1
    Explanation: At speed 1:
    - The first train ride takes 1/1 = 1 hour.
    - Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
    - Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
    - You will arrive at exactly the 6 hour mark.

    Example 2:
    Input: dist = [1,3,2], hour = 2.7
    Output: 3
    Explanation: At speed 3:
    - The first train ride takes 1/3 = 0.33333 hours.
    - Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
    - Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
    - You will arrive at the 2.66667 hour mark.

    Example 3:
    Input: dist = [1,3,2], hour = 1.9
    Output: -1
    Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.

    Constraints:
    * n == dist.length
    * 1 <= n <= 10^5
    * 1 <= dist[i] <= 10^5
    * 1 <= hour <= 10^9
    * There will be at most two digits after the decimal point in hour."""

    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
        lo, hi = 1, 10_000_001
        while lo < hi:
            mid = lo + hi >> 1
            tm = sum((dist[i]+mid-1)//mid for i in range(0, len(dist)-1)) + dist[-1]/mid
            if tm <= hour: hi = mid
            else: lo = mid + 1
        return lo if lo < 10_000_001 else -1


    """1871. Jump Game VII (Medium)
    You are given a 0-indexed binary string s and two integers minJump and
    maxJump. In the beginning, you are standing at index 0, which is equal to
    '0'. You can move from index i to index j if the following conditions are
    fulfilled:
    * i + minJump <= j <= min(i + maxJump, s.length - 1), and
    * s[j] == '0'.
    Return true if you can reach index s.length - 1 in s, or false otherwise.

    Example 1:
    Input: s = "011010", minJump = 2, maxJump = 3
    Output: true
    Explanation: In the first step, move from index 0 to index 3.
                 In the second step, move from index 3 to index 5.

    Example 2:
    Input: s = "01101110", minJump = 2, maxJump = 3
    Output: false

    Constraints:
    * 2 <= s.length <= 10^5
    * s[i] is either '0' or '1'.
    * s[0] == '0'
    * 1 <= minJump <= maxJump < s.length"""

    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        prefix = [0, 1]
        for i in range(1, len(s)):
            prefix.append(prefix[-1])
            lo = max(0, i-maxJump)
            hi = max(0, i-minJump+1)
            if s[i] == "0" and prefix[hi] - prefix[lo] > 0: prefix[-1] += 1
        return prefix[-1] > prefix[-2]


    """1872. Stone Game VIII (Hard)
    Alice and Bob take turns playing a game, with Alice starting first. There
    are n stones arranged in a row. On each player's turn, while the number of
    stones is more than one, they will do the following:
    * Choose an integer x > 1, and remove the leftmost x stones from the row.
    * Add the sum of the removed stones' values to the player's score.
    * Place a new stone, whose value is equal to that sum, on the left side of
    the row.
    The game stops when only one stone is left in the row. The score difference
    between Alice and Bob is (Alice's score - Bob's score). Alice's goal is to
    maximize the score difference, and Bob's goal is the minimize the score
    difference. Given an integer array stones of length n where stones[i]
    represents the value of the ith stone from the left, return the score
    difference between Alice and Bob if they both play optimally.

    Example 1:
    Input: stones = [-1,2,-3,4,-5]
    Output: 5
    Explanation:
    - Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of
      value 2 on the left. stones = [2,-5].
    - Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on
      the left. stones = [-3].
    The difference between their scores is 2 - (-3) = 5.

    Example 2:
    Input: stones = [7,-6,5,10,5,-2,-6]
    Output: 13
    Explanation:
    - Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a
      stone of value 13 on the left. stones = [13].
    The difference between their scores is 13 - 0 = 13.

    Example 3:
    Input: stones = [-10,-12]
    Output: -22
    Explanation:
    - Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her
      score and places a stone of value -22 on the left. stones = [-22].
    The difference between their scores is (-22) - 0 = -22.

    Constraints:
    * n == stones.length
    * 2 <= n <= 10^5
    * -10^4 <= stones[i] <= 10^4"""

    def stoneGameVIII(self, stones: List[int]) -> int:
        prefix = [0]
        for x in stones: prefix.append(prefix[-1] + x)

        @cache
        def fn(i):
            """Return max score difference."""
            if i+1 == len(stones): return prefix[-1]
            return max(fn(i+1), prefix[i+1] - fn(i+1))

        return fn(1)


    """1874. Minimize Product Sum of Two Arrays (Medium)
    The product sum of two equal-length arrays a and b is equal to the sum of
    a[i] * b[i] for all 0 <= i < a.length (0-indexed). For example, if
    a = [1,2,3,4] and b = [5,2,3,1], the product sum would be
    1*5 + 2*2 + 3*3 + 4*1 = 22. Given two arrays nums1 and nums2 of length n,
    return the minimum product sum if you are allowed to rearrange the order
    of the elements in nums1.

    Example 1:
    Input: nums1 = [5,3,4,2], nums2 = [4,2,2,5]
    Output: 40
    Explanation: We can rearrange nums1 to become [3,5,4,2]. The product sum of
                 [3,5,4,2] and [4,2,2,5] is 3*4 + 5*2 + 4*2 + 2*5 = 40.

    Example 2:
    Input: nums1 = [2,1,4,5,7], nums2 = [3,2,4,8,6]
    Output: 65
    Explanation: We can rearrange nums1 to become [5,7,4,1,2]. The product sum
                 of [5,7,4,1,2] and [3,2,4,8,6] is
                 5*3 + 7*2 + 4*4 + 1*8 + 2*6 = 65.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 100"""

    def minProductSum(self, nums1: List[int], nums2: List[int]) -> int:
        return sum(x1*x2 for x1, x2 in zip(sorted(nums1), sorted(nums2, reverse=True)))


    """1876. Substrings of Size Three with Distinct Characters (Easy)
    A string is good if there are no repeated characters. Given a string s,
    return the number of good substrings of length three in s. Note that if
    there are multiple occurrences of the same substring, every occurrence
    should be counted. A substring is a contiguous sequence of characters in a
    string.

    Example 1:
    Input: s = "xyzzaz"
    Output: 1
    Explanation: There are 4 substrings of size 3: "xyz", "yzz", "zza", and
                 "zaz". The only good substring of length 3 is "xyz".

    Example 2:
    Input: s = "aababcabc"
    Output: 4
    Explanation: There are 7 substrings of size 3: "aab", "aba", "bab", "abc",
                 "bca", "cab", and "abc". The good substrings are "abc", "bca",
                 "cab", and "abc".

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters."""

    def countGoodSubstrings(self, s: str) -> int:
        ans = 0
        for i in range(3, len(s)+1):
            if len(set(s[i-3:i])) == 3: ans += 1
        return ans


    """1877. Minimize Maximum Pair Sum in Array (Medium)
    The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the
    largest pair sum in a list of pairs. For example, if we have pairs (1,5),
    (2,3), and (4,4), the maximum pair sum would be
    max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8. Given an array nums of even length n,
    pair up the elements of nums into n / 2 pairs such that:
    * Each element of nums is in exactly one pair, and
    * The maximum pair sum is minimized.
    Return the minimized maximum pair sum after optimally pairing up the
    elements.

    Example 1:
    Input: nums = [3,5,2,3]
    Output: 7
    Explanation: The elements can be paired up into pairs (3,3) and (5,2). The
                 maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.

    Example 2:
    Input: nums = [3,5,4,2,4,6]
    Output: 8
    Explanation: The elements can be paired up into pairs (3,5), (4,4), and
                 (6,2). The maximum pair sum is
                 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^5
    * n is even.
    * 1 <= nums[i] <= 10^5"""

    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        return max(nums[i] + nums[~i] for i in range(len(nums)//2))


    """1878. Get Biggest Three Rhombus Sums in a Grid (Medium)
    You are given an m x n integer matrix grid. A rhombus sum is the sum of the
    elements that form the border of a regular rhombus shape in grid. The
    rhombus must have the shape of a square rotated 45 degrees with each of the
    corners centered in a grid cell. Below is an image of four valid rhombus
    shapes with the corresponding colored cells that should be included in each
    rhombus sum. Note that the rhombus can have an area of 0, which is depicted
    by the purple rhombus in the bottom right corner. Return the biggest three
    distinct rhombus sums in the grid in descending order. If there are less
    than three distinct values, return all of them.

    Example 1:
    Input: grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]
    Output: [228,216,211]
    Explanation: The rhombus shapes for the three biggest distinct rhombus sums
                 are depicted above.
                 - Blue: 20 + 3 + 200 + 5 = 228
                 - Red: 200 + 2 + 10 + 4 = 216
                 - Green: 5 + 200 + 4 + 2 = 211

    Example 2:
    Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
    Output: [20,9,8]
    Explanation: The rhombus shapes for the three biggest distinct rhombus sums
                 are depicted above.
                 - Blue: 4 + 2 + 6 + 8 = 20
                 - Red: 9 (area 0 rhombus in the bottom right corner)
                 - Green: 8 (area 0 rhombus in the bottom middle)

    Example 3:
    Input: grid = [[7,7,7]]
    Output: [7]
    Explanation: All three possible rhombus sums are the same, so return [7].

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * 1 <= grid[i][j] <= 10^5"""

    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0]) # dimensions
        anti, diag = {}, {}
        for i in range(m):
            for j in range(n):
                key = i+j
                if key not in anti: anti[key] = [0]
                anti[key].append(anti[key][-1] + grid[i][j])

                key = i-j
                if key not in diag: diag[key] = [0]
                diag[key].append(diag[key][-1] + grid[i][j])

        def fn(i, j, k):
            """Return sum of k diagonal elements starting from (i, j)"""
            if i >= j: return diag[i-j][j+k] - diag[i-j][j]
            return diag[i-j][i+k] - diag[i-j][i]

        def gn(i, j, k):
            """Return sum of k anti-diagonal elements starting from (i, j)"""
            if i+j < n: return anti[i+j][i+k] - anti[i+j][i]
            return anti[i+j][n-1-j+k] - anti[i+j][n-1-j]

        ans = set()
        for i in range(m):
            for j in range(n):
                ans.add(grid[i][j])
                for ii in range(i+2, m, 2):
                    r = (ii-i)//2
                    if j-r < 0 or j+r >= n: break
                    val = 0
                    val += fn(i, j, r+1)
                    val += gn(i, j, r+1)
                    val += fn((ii+i)//2, j-r, r+1)
                    val += gn((ii+i)//2, j+r, r+1)
                    val -= grid[i][j] + grid[(ii+i)//2][j-r] + grid[(ii+i)//2][j+r] + grid[ii][j]
                    ans.add(val)
        return sorted(ans, reverse=True)[:3]


    """1879. Minimum XOR Sum of Two Arrays (Hard)
    You are given two integer arrays nums1 and nums2 of length n. The XOR sum
    of the two integer arrays is
    (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) (0-indexed).
    For example, the XOR sum of [1,2,3] and [3,2,1] is equal to
    (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4. Rearrange the elements
    of nums2 such that the resulting XOR sum is minimized. Return the XOR sum
    after the rearrangement.

    Example 1:
    Input: nums1 = [1,2], nums2 = [2,3]
    Output: 2
    Explanation: Rearrange nums2 so that it becomes [3,2]. The XOR sum is
                 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.

    Example 2:
    Input: nums1 = [1,0,3], nums2 = [5,3,4]
    Output: 8
    Explanation: Rearrange nums2 so that it becomes [5,4,3]. The XOR sum is
                 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.

    Constraints:
    * n == nums1.length
    * n == nums2.length
    * 1 <= n <= 14
    * 0 <= nums1[i], nums2[i] <= 10^7"""

    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)

        @cache
        def fn(mask, k):
            """Return min xor sum."""
            if not mask: return 0
            ans = inf
            for i in range(n):
                if mask & (1<<i):
                    ans = min(ans, (nums1[i]^nums2[k]) + fn(mask^(1<<i), k+1))
            return ans

        return fn((1<<n)-1, 0)


    """1880. Check if Word Equals Summation of Two Words (Easy)
    The letter value of a letter is its position in the alphabet starting from
    0 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, etc.). The numerical value of some
    string of lowercase English letters s is the concatenation of the letter
    values of each letter in s, which is then converted into an integer.
    * For example, if s = "acb", we concatenate each letter's letter value,
      resulting in "021". After converting it, we get 21.

    You are given three strings firstWord, secondWord, and targetWord, each
    consisting of lowercase English letters 'a' through 'j' inclusive. Return
    true if the summation of the numerical values of firstWord and secondWord
    equals the numerical value of targetWord, or false otherwise.

    Example 1:
    Input: firstWord = "acb", secondWord = "cba", targetWord = "cdb"
    Output: true
    Explanation:
    The numerical value of firstWord is "acb" -> "021" -> 21.
    The numerical value of secondWord is "cba" -> "210" -> 210.
    The numerical value of targetWord is "cdb" -> "231" -> 231.
    We return true because 21 + 210 == 231.

    Example 2:
    Input: firstWord = "aaa", secondWord = "a", targetWord = "aab"
    Output: false
    Explanation:
    The numerical value of firstWord is "aaa" -> "000" -> 0.
    The numerical value of secondWord is "a" -> "0" -> 0.
    The numerical value of targetWord is "aab" -> "001" -> 1.
    We return false because 0 + 0 != 1.

    Example 3:
    Input: firstWord = "aaa", secondWord = "a", targetWord = "aaaa"
    Output: true
    Explanation:
    The numerical value of firstWord is "aaa" -> "000" -> 0.
    The numerical value of secondWord is "a" -> "0" -> 0.
    The numerical value of targetWord is "aaaa" -> "0000" -> 0.
    We return true because 0 + 0 == 0.

    Constraints:
    * 1 <= firstWord.length, secondWord.length, targetWord.length <= 8
    * firstWord, secondWord, and targetWord consist of lowercase English
      letters from 'a' to 'j' inclusive."""

    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:
        fn = lambda w: int("".join(str(ord(c)-97) for c in w))
        return fn(firstWord) + fn(secondWord) == fn(targetWord)


    """1881. Maximum Value after Insertion (Medium)
    You are given a very large integer n, represented as a string, and an
    integer digit x. The digits in n and the digit x are in the inclusive range
    [1, 9], and n may represent a negative number. You want to maximize n's
    numerical value by inserting x anywhere in the decimal representation of n.
    You cannot insert x to the left of the negative sign.

    * For example, if n = 73 and x = 6, it would be best to insert it between 7
      and 3, making n = 763.
    * If n = -55 and x = 2, it would be best to insert it before the first 5,
      making n = -255.
    Return a string representing the maximum value of n after the insertion.

    Example 1:
    Input: n = "99", x = 9
    Output: "999"
    Explanation: The result is the same regardless of where you insert 9.

    Example 2:
    Input: n = "-13", x = 2
    Output: "-123"
    Explanation: You can make n one of {-213, -123, -132}, and the largest of
                 those three is -123.

    Constraints:
    * 1 <= n.length <= 10^5
    * 1 <= x <= 9
    * The digits in n are in the range [1, 9].
    * n is a valid representation of an integer.
    * In the case of a negative n, it will begin with '-'."""

    def maxValue(self, n: str, x: int) -> str:
        x = str(x)
        if n[0] == "-":
            for i in range(1, len(n)):
                if x < n[i]: return n[:i] + x + n[i:]
        else:
            for i in range(0, len(n)):
                if x > n[i]: return n[:i] + x + n[i:]
        return n + x


    """1882. Process Tasks Using Servers (Medium)
    You are given two 0-indexed integer arrays servers and tasks of lengths n
    and m respectively. servers[i] is the weight of the ith server, and tasks[j]
    is the time needed to process the jth task in seconds. You are running a
    simulation system that will shut down after all tasks are processed. Each
    server can only process one task at a time. You will be able to process the
    jth task starting from the jth second beginning with the 0th task at second
    0. To process task j, you assign it to the server with the smallest weight
    that is free, and in case of a tie, choose the server with the smallest
    index. If a free server gets assigned task j at second t, it will be free
    again at the second t + tasks[j]. If there are no free servers, you must
    wait until one is free and execute the free tasks as soon as possible. If
    multiple tasks need to be assigned, assign them in order of increasing index.
    You may assign multiple tasks at the same second if there are multiple free
    servers. Build an array ans of length m, where ans[j] is the index of the
    server the jth task will be assigned to. Return the array ans.

    Example 1:
    Input: servers = [3,3,2], tasks = [1,2,3,2,1,2]
    Output: [2,2,0,2,1,2]
    Explanation: Events in chronological order go as follows:
    - At second 0, task 0 is added and processed using server 2 until second 1.
    - At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.
    - At second 2, task 2 is added and processed using server 0 until second 5.
    - At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.
    - At second 4, task 4 is added and processed using server 1 until second 5.
    - At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.

    Example 2:
    Input: servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]
    Output: [1,4,1,4,1,3,2]
    Explanation: Events in chronological order go as follows:
    - At second 0, task 0 is added and processed using server 1 until second 2.
    - At second 1, task 1 is added and processed using server 4 until second 2.
    - At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4.
    - At second 3, task 3 is added and processed using server 4 until second 7.
    - At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9.
    - At second 5, task 5 is added and processed using server 3 until second 7.
    - At second 6, task 6 is added and processed using server 2 until second 7.

    Constraints:
    * servers.length == n
    * tasks.length == m
    * 1 <= n, m <= 2 * 10^5
    * 1 <= servers[i], tasks[j] <= 2 * 10^5"""

    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:
        busy = []
        free = [(wt, i) for i, wt in enumerate(servers)]
        heapify(free)

        ans = []
        for t, task in enumerate(tasks):
            while busy and busy[0][0] == t:
                _, wt, i = heappop(busy)
                heappush(free, (wt, i))
            if free: wt, i = heappop(free)
            else: t, wt, i = heappop(busy)
            ans.append(i)
            heappush(busy, (t+task, wt, i))
        return ans


    """1883. Minimum Skips to Arrive at Meeting On Time (Hard)
    You are given an integer hoursBefore, the number of hours you have to
    travel to your meeting. To arrive at your meeting, you have to travel
    through n roads. The road lengths are given as an integer array dist of
    length n, where dist[i] describes the length of the ith road in kilometers.
    In addition, you are given an integer speed, which is the speed (in km/h)
    you will travel at. After you travel road i, you must rest and wait for the
    next integer hour before you can begin traveling on the next road. Note
    that you do not have to rest after traveling the last road because you are
    already at the meeting.

    * For example, if traveling a road takes 1.4 hours, you must wait until the
      2 hour mark before traveling the next road. If traveling a road takes
      exactly 2 hours, you do not need to wait.
    However, you are allowed to skip some rests to be able to arrive on time,
    meaning you do not need to wait for the next integer hour. Note that this
    means you may finish traveling future roads at different hour marks.

    * For example, suppose traveling the first road takes 1.4 hours and
      traveling the second road takes 0.6 hours. Skipping the rest after the
      first road will mean you finish traveling the second road right at the 2
      hour mark, letting you start traveling the third road immediately.
    Return the minimum number of skips required to arrive at the meeting on
    time, or -1 if it is impossible.

    Example 1:
    Input: dist = [1,3,2], speed = 4, hoursBefore = 2
    Output: 1
    Explanation: Without skipping any rests, you will arrive in
                 (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours. You can skip
                 the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5
                 hours. Note that the second rest is shortened because you finish
                 traveling the second road at an integer hour due to skipping the
                 first rest.

    Example 2:
    Input: dist = [7,3,5,5], speed = 2, hoursBefore = 10
    Output: 2
    Explanation: Without skipping any rests, you will arrive in
                 (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.
                 You can skip the first and third rest to arrive in
                 ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.

    Example 3:
    Input: dist = [7,3,5,5], speed = 1, hoursBefore = 10
    Output: -1
    Explanation: It is impossible to arrive at the meeting on time even if you
                 skip all the rests.

    Constraints:
    * n == dist.length
    * 1 <= n <= 1000
    * 1 <= dist[i] <= 10^5
    * 1 <= speed <= 10^6
    * 1 <= hoursBefore <= 10^7"""

    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        if sum(dist)/speed > hoursBefore: return -1 # impossible

        @cache
        def fn(i, k):
            """Return min time (in distance) of traveling first i roads with k skips."""
            if k < 0: return inf # impossible
            if i == 0: return 0
            return min(ceil((fn(i-1, k) + dist[i-1])/speed) * speed, dist[i-1] + fn(i-1, k-1))

        for k in range(len(dist)):
            if fn(len(dist)-1, k) + dist[-1] <= hoursBefore*speed: return k


    """1884. Egg Drop With 2 Eggs and N Floors (Medium)
    You are given two identical eggs and you have access to a building with n
    floors labeled from 1 to n. You know that there exists a floor f where
    0 <= f <= n such that any egg dropped at a floor higher than f will break,
    and any egg dropped at or below floor f will not break. In each move, you
    may take an unbroken egg and drop it from any floor x (where 1 <= x <= n).
    If the egg breaks, you can no longer use it. However, if the egg does not
    break, you may reuse it in future moves. Return the minimum number of moves
    that you need to determine with certainty what the value of f is.

    Example 1:
    Input: n = 2
    Output: 2
    Explanation: We can drop the first egg from floor 1 and the second egg from floor 2.
                 If the first egg breaks, we know that f = 0.
                 If the second egg breaks but the first egg didn't, we know that f = 1.
                 Otherwise, if both eggs survive, we know that f = 2.

    Example 2:
    Input: n = 100
    Output: 14
    Explanation: One optimal strategy is:
    - Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8.
      Drop the 2nd egg starting from floor 1 and going up one at a time to find
      f within 7 more drops. Total drops is 1 + 7 = 8.
    - If the 1st egg does not break, drop the 1st egg again at floor 22. If it
      breaks, we know f is between 9 and 21. Drop the 2nd egg starting from
      floor 10 and going up one at a time to find f within 12 more drops. Total
      drops is 2 + 12 = 14.
    - If the 1st egg does not break again, follow a similar process dropping
      the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and
      100.
    Regardless of the outcome, it takes at most 14 drops to determine f.

    Constraints: 1 <= n <= 1000"""

    def twoEggDrop(self, n: int) -> int:

        @cache
        def fn(n, k):
            """Return min moves for n floors and k eggs."""
            if k == 1: return n
            if n == 0: return 0
            ans = inf
            for x in range(1, n+1):
                ans = min(ans, 1 + max(fn(x-1, k-1), fn(n-x, k)))
            return ans

        return fn(n, 2)


    """1885. Count Pairs in Two Arrays (Medium)
    Given two integer arrays nums1 and nums2 of length n, count the pairs of
    indices (i, j) such that i < j and nums1[i] + nums1[j] > nums2[i] + nums2[j].
    Return the number of pairs satisfying the condition.

    Example 1:
    Input: nums1 = [2,1,2,1], nums2 = [1,2,1,2]
    Output: 1
    Explanation: The pairs satisfying the condition are:
                 - (0, 2) where 2 + 2 > 1 + 1.

    Example 2:
    Input: nums1 = [1,10,6,2], nums2 = [1,4,1,5]
    Output: 5
    Explanation: The pairs satisfying the condition are:
                 - (0, 1) where 1 + 10 > 1 + 4.
                 - (0, 2) where 1 + 6 > 1 + 1.
                 - (1, 2) where 10 + 6 > 4 + 1.
                 - (1, 3) where 10 + 2 > 4 + 5.
                 - (2, 3) where 6 + 2 > 1 + 5.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^5"""

    def countPairs(self, nums1: List[int], nums2: List[int]) -> int:
        diff = sorted(x - y for x, y in zip(nums1, nums2))
        ans = 0
        for i, x in enumerate(diff):
            ans += len(diff) - bisect_right(diff, -x, i+1)
        return ans


    """1886. Determine Whether Matrix Can Be Obtained By Rotation (Easy)
    Given two n x n binary matrices mat and target, return true if it is
    possible to make mat equal to target by rotating mat in 90-degree
    increments, or false otherwise.

    Example 1:
    Input: mat = [[0,1],[1,0]], target = [[1,0],[0,1]]
    Output: true
    Explanation: We can rotate mat 90 degrees clockwise to make mat equal
                 target.

    Example 2:
    Input: mat = [[0,1],[1,1]], target = [[1,0],[0,1]]
    Output: false
    Explanation: It is impossible to make mat equal to target by rotating mat.

    Example 3:
    Input: mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]
    Output: true
    Explanation: We can rotate mat 90 degrees clockwise two times to make mat
                 equal target.

    Constraints:
    * n == mat.length == target.length
    * n == mat[i].length == target[i].length
    * 1 <= n <= 10
    * mat[i][j] and target[i][j] are either 0 or 1."""

    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:
        for _ in range(4):
            if mat == target: return True
            mat = [list(x) for x in zip(*mat[::-1])]
        return False


    """1887. Reduction Operations to Make the Array Elements Equal (Medium)
    Given an integer array nums, your goal is to make all elements in nums
    equal. To complete one operation, follow these steps:
    * Find the largest value in nums. Let its index be i (0-indexed) and its
      value be largest. If there are multiple elements with the largest value,
      pick the smallest i.
    * Find the next largest value in nums strictly smaller than largest. Let
      its value be nextLargest.
    Reduce nums[i] to nextLargest. Return the number of operations to make all
    elements in nums equal.

    Example 1:
    Input: nums = [5,1,3]
    Output: 3
    Explanation: It takes 3 operations to make all elements in nums equal:
    1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
    2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
    3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].

    Example 2:
    Input: nums = [1,1,1]
    Output: 0
    Explanation: All elements in nums are already equal.

    Example 3:
    Input: nums = [1,1,2,2,3]
    Output: 4
    Explanation: It takes 4 operations to make all elements in nums equal:
    1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].
    2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].
    3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].
    4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 1 <= nums[i] <= 5 * 10^4"""

    def reductionOperations(self, nums: List[int]) -> int:
        ans = val = 0
        nums.sort()
        for i in range(1, len(nums)):
            if nums[i-1] < nums[i]: val += 1
            ans += val
        return ans


    """1888. Minimum Number of Flips to Make the Binary String Alternating (Medium)
    You are given a binary string s. You are allowed to perform two types of
    operations on the string in any sequence:
    * Type-1: Remove the character at the start of the string s and append it
      to the end of the string.
    * Type-2: Pick any character in s and flip its value, i.e., if its value is
      '0' it becomes '1' and vice-versa.
    Return the minimum number of type-2 operations you need to perform such
    that s becomes alternating. The string is called alternating if no two
    adjacent characters are equal. For example, the strings "010" and "1010"
    are alternating, while the string "0100" is not.

    Example 1:
    Input: s = "111000"
    Output: 2
    Explanation: Use the first operation two times to make s = "100011". Then,
                 use the second operation on the third and sixth elements to
                 make s = "101010".

    Example 2:
    Input: s = "010"
    Output: 0
    Explanation: The string is already alternating.

    Example 3:
    Input: s = "1110"
    Output: 1
    Explanation: Use the second operation on the second element to make
                 s = "1010".

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'."""

    def minFlips(self, s: str) -> int:
        s = [int(x) for x in s]
        ans = inf
        x01 = x10 = 0
        for i in range(2*len(s)):
            x01 += s[i%len(s)]^i&1
            x10 += s[i%len(s)]^(i+1)&1
            if i+1 >= len(s):
                if i >= len(s):
                    x01 -= s[i-len(s)]^(i-len(s))&1
                    x10 -= s[i-len(s)]^(i-len(s)+1)&1
                ans = min(ans, x01, x10)
        return ans


    """1889. Minimum Space Wasted From Packaging (Hard)
    You have n packages that you are trying to place in boxes, one package in
    each box. There are m suppliers that each produce boxes of different sizes
    (with infinite supply). A package can be placed in a box if the size of the
    package is less than or equal to the size of the box. The package sizes are
    given as an integer array packages, where packages[i] is the size of the
    ith package. The suppliers are given as a 2D integer array boxes, where
    boxes[j] is an array of box sizes that the jth supplier produces. You want
    to choose a single supplier and use boxes from them such that the total
    wasted space is minimized. For each package in a box, we define the space
    wasted to be size of the box - size of the package. The total wasted space
    is the sum of the space wasted in all the boxes. For example, if you have
    to fit packages with sizes [2,3,5] and the supplier offers boxes of sizes
    [4,8], you can fit the packages of size-2 and size-3 into two boxes of
    size-4 and the package with size-5 into a box of size-8. This would result
    in a waste of (4-2) + (4-3) + (8-5) = 6. Return the minimum total wasted
    space by choosing the box supplier optimally, or -1 if it is impossible to
    fit all the packages inside boxes. Since the answer may be large, return
    it modulo 10^9 + 7.

    Example 1:
    Input: packages = [2,3,5], boxes = [[4,8],[2,8]]
    Output: 6
    Explanation: It is optimal to choose the first supplier, using two size-4
                 boxes and one size-8 box. The total waste is
                 (4-2) + (4-3) + (8-5) = 6.

    Example 2:
    Input: packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]
    Output: -1
    Explanation: There is no box that the package of size 5 can fit in.

    Example 3:
    Input: packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]
    Output: 9
    Explanation: It is optimal to choose the third supplier, using two size-5
                 boxes, two size-10 boxes, and two size-14 boxes. The total
                 waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.

    Constraints:
    * n == packages.length
    * m == boxes.length
    * 1 <= n <= 10^5
    * 1 <= m <= 10^5
    * 1 <= packages[i] <= 10^5
    * 1 <= boxes[j].length <= 10^5
    * 1 <= boxes[j][k] <= 10^5
    * sum(boxes[j].length) <= 10^5
    * The elements in boxes[j] are distinct."""

    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        packages.sort()

        ans = inf
        for box in boxes:
            box.sort()
            if packages[-1] <= box[-1]:
                kk = val = 0
                for x in box:
                    k = bisect_right(packages, x)
                    val += (k - kk) * x
                    kk = k
                ans = min(ans, val)
        return (ans - sum(packages)) % 1_000_000_007 if ans < inf else -1


    """1891. Cutting Ribbons (Medium)
    You are given an integer array ribbons, where ribbons[i] represents the
    length of the ith ribbon, and an integer k. You may cut any of the ribbons
    into any number of segments of positive integer lengths, or perform no cuts
    at all. For example, if you have a ribbon of length 4, you can:
    * Keep the ribbon of length 4,
    * Cut it into one ribbon of length 3 and one ribbon of length 1,
    * Cut it into two ribbons of length 2,
    * Cut it into one ribbon of length 2 and two ribbons of length 1, or
    * Cut it into four ribbons of length 1.
    Your goal is to obtain k ribbons of all the same positive integer length.
    You are allowed to throw away any excess ribbon as a result of cutting.
    Return the maximum possible positive integer length that you can obtain k
    ribbons of, or 0 if you cannot obtain k ribbons of the same length.

    Example 1:
    Input: ribbons = [9,7,5], k = 3
    Output: 5
    Explanation:
    - Cut the first ribbon to two ribbons, one of length 5 and one of length 4.
    - Cut the second ribbon to two ribbons, one of length 5 and one of length 2.
    - Keep the third ribbon as it is.
    Now you have 3 ribbons of length 5.

    Example 2:
    Input: ribbons = [7,5,9], k = 4
    Output: 4
    Explanation:
    - Cut the first ribbon to two ribbons, one of length 4 and one of length 3.
    - Cut the second ribbon to two ribbons, one of length 4 and one of length 1.
    - Cut the third ribbon to three ribbons, two of length 4 and one of length 1.
    Now you have 4 ribbons of length 4.

    Example 3:
    Input: ribbons = [5,7,9], k = 22
    Output: 0
    Explanation: You cannot obtain k ribbons of the same positive integer length.

    Constraints:
    * 1 <= ribbons.length <= 10^5
    * 1 <= ribbons[i] <= 10^5
    * 1 <= k <= 10^9"""

    def maxLength(self, ribbons: List[int], k: int) -> int:
        # last-true binary search
        lo, hi = 0, 100_000
        while lo < hi:
            mid = lo + hi + 1 >> 1
            if sum(ribbon//mid for ribbon in ribbons) < k: hi = mid - 1
            else: lo = mid
        return lo


    """1893. Check if All the Integers in a Range Are Covered (Easy)
    You are given a 2D integer array ranges and two integers left and right.
    Each ranges[i] = [starti, endi] represents an inclusive interval between
    starti and endi. Return true if each integer in the inclusive range
    [left, right] is covered by at least one interval in ranges. Return false
    otherwise. An integer x is covered by an interval ranges[i] = [starti, endi]
    if starti <= x <= endi.

    Example 1:
    Input: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
    Output: true
    Explanation: Every integer between 2 and 5 is covered:
                 - 2 is covered by the first range.
                 - 3 and 4 are covered by the second range.
                 - 5 is covered by the third range.

    Example 2:
    Input: ranges = [[1,10],[10,20]], left = 21, right = 21
    Output: false
    Explanation: 21 is not covered by any range.

    Constraints:
    * 1 <= ranges.length <= 50
    * 1 <= starti <= endi <= 50
    * 1 <= left <= right <= 50"""

    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        vals = [0]*52
        for x, y in ranges:
            vals[x] += 1
            vals[y+1] -= 1
        prefix = 0
        for i, x in enumerate(vals):
            prefix += x
            if left <= i <= right and prefix == 0: return False
        return True


    """1894. Find the Student that Will Replace the Chalk (Medium)
    There are n students in a class numbered from 0 to n - 1. The teacher will
    give each student a problem starting with the student number 0, then the
    student number 1, and so on until the teacher reaches the student number
    n - 1. After that, the teacher will restart the process, starting with the
    student number 0 again. You are given a 0-indexed integer array chalk and
    an integer k. There are initially k pieces of chalk. When the student
    number i is given a problem to solve, they will use chalk[i] pieces of
    chalk to solve that problem. However, if the current number of chalk pieces
    is strictly less than chalk[i], then the student number i will be asked to
    replace the chalk. Return the index of the student that will replace the
    chalk.

    Example 1:
    Input: chalk = [5,1,5], k = 22
    Output: 0
    Explanation: The students go in turns as follows:
                 - Student number 0 uses 5 chalk, so k = 17.
                 - Student number 1 uses 1 chalk, so k = 16.
                 - Student number 2 uses 5 chalk, so k = 11.
                 - Student number 0 uses 5 chalk, so k = 6.
                 - Student number 1 uses 1 chalk, so k = 5.
                 - Student number 2 uses 5 chalk, so k = 0.
                 Student number 0 does not have enough chalk, so they will have
                 to replace it.

    Example 2:
    Input: chalk = [3,4,1,2], k = 25
    Output: 1
    Explanation: The students go in turns as follows:
                 - Student number 0 uses 3 chalk so k = 22.
                 - Student number 1 uses 4 chalk so k = 18.
                 - Student number 2 uses 1 chalk so k = 17.
                 - Student number 3 uses 2 chalk so k = 15.
                 - Student number 0 uses 3 chalk so k = 12.
                 - Student number 1 uses 4 chalk so k = 8.
                 - Student number 2 uses 1 chalk so k = 7.
                 - Student number 3 uses 2 chalk so k = 5.
                 - Student number 0 uses 3 chalk so k = 2.
                 Student number 1 does not have enough chalk, so they will have
                 to replace it.

    Constraints:
    * chalk.length == n
    * 1 <= n <= 10^5
    * 1 <= chalk[i] <= 10^5
    * 1 <= k <= 10^9"""

    def chalkReplacer(self, chalk: List[int], k: int) -> int:
        k %= sum(chalk)
        for i, x in enumerate(chalk):
            k -= x
            if k < 0: return i


    """1895. Largest Magic Square (Medium)
    A k x k magic square is a k x k grid filled with integers such that every
    row sum, every column sum, and both diagonal sums are all equal. The
    integers in the magic square do not have to be distinct. Every 1 x 1 grid
    is trivially a magic square. Given an m x n integer grid, return the size
    (i.e., the side length k) of the largest magic square that can be found
    within this grid.

    Example 1:
    Input: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]
    Output: 3
    Explanation: The largest magic square has a size of 3. Every row sum,
                 column sum, and diagonal sum of this magic square is equal to
                 12.
                 - Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
                 - Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
                 - Diagonal sums: 5+4+3 = 6+4+2 = 12

    Example 2:
    Input: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]
    Output: 2

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * 1 <= grid[i][j] <= 10^6"""

    def largestMagicSquare(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0]) # dimensions
        rows = [[0]*(n+1) for _ in range(m)]
        cols = [[0]*n for _ in range(m+1)]
        diag = [[0]*(n+1) for _ in range(m+1)]
        anti = [[0]*(n+1) for _ in range(m+1)]

        for i in range(m):
            for j in range(n):
                rows[i][j+1] = grid[i][j] + rows[i][j]
                cols[i+1][j] = grid[i][j] + cols[i][j]
                diag[i+1][j+1] = grid[i][j] + diag[i][j]
                anti[i+1][j] = grid[i][j] + anti[i][j+1]

        ans = 1
        for i in range(m):
            for j in range(n):
                for k in range(1, min(i, j)+1):
                    ii, jj = i-k, j-k
                    val = diag[i+1][j+1] - diag[ii][jj]
                    match = (val == anti[i+1][jj] - anti[ii][j+1])
                    for r in range(ii, i+1): match &= (val == rows[r][j+1] - rows[r][jj])
                    for c in range(jj, j+1): match &= (val == cols[i+1][c] - cols[ii][c])
                    if match: ans = max(ans, k+1)
        return ans


    """1896. Minimum Cost to Change the Final Value of Expression (Hard)
    You are given a valid boolean expression as a string expression consisting
    of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR
    operator),'(', and ')'. For example, "()1|1" and "(1)&()" are not valid
    while "1", "(((1))|(0))", and "1|(0&(1))" are valid expressions. Return the
    minimum cost to change the final value of the expression. For example, if
    expression = "1|1|(0&0)&1", its value is 1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1.
    We want to apply operations so that the new expression evaluates to 0. The
    cost of changing the final value of an expression is the number of
    operations performed on the expression. The types of operations are
    described as follows:
    * Turn a '1' into a '0'.
    * Turn a '0' into a '1'.
    * Turn a '&' into a '|'.
    * Turn a '|' into a '&'.
    Note: '&' does not take precedence over '|' in the order of calculation.
    Evaluate parentheses first, then in left-to-right order.

    Example 1:
    Input: expression = "1&(0|1)"
    Output: 1
    Explanation: We can turn "1&(0|1)" into "1&(0&1)" by changing the '|' to a
                 '&' using 1 operation. The new expression evaluates to 0.

    Example 2:
    Input: expression = "(0&0)&(0&0&0)"
    Output: 3
    Explanation: We can turn "(0&0)&(0&0&0)" into "(0|1)|(0&0&0)" using 3
                 operations. The new expression evaluates to 1.

    Example 3:
    Input: expression = "(0|(1|0&1))"
    Output: 1
    Explanation: We can turn "(0|(1|0&1))" into "(0|(0|0&1))" using 1 operation.
                 The new expression evaluates to 0.

    Constraints:
    * 1 <= expression.length <= 10^5
    * expression only contains '1','0','&','|','(', and ')'
    * All parentheses are properly matched.
    * There will be no empty parentheses (i.e: "()" is not a substring of
      expression)."""

    def minOperationsToFlip(self, expression: str) -> int:
        loc = {}
        stack = []
        for i in reversed(range(len(expression))):
            if expression[i] == ")": stack.append(i)
            elif expression[i] == "(": loc[stack.pop()] = i

        def fn(lo, hi):
            """Return value and min op to change value."""
            if lo == hi: return int(expression[lo]), 1
            if expression[hi] == ")" and loc[hi] == lo: return fn(lo+1, hi-1) # strip parenthesis
            mid = loc.get(hi, hi) - 1
            v, c = fn(mid+1, hi)
            vv, cc = fn(lo, mid-1)
            if expression[mid] == "|":
                val = v | vv
                if v == vv == 0: chg = min(c, cc)
                elif v == vv == 1: chg = 1 + min(c, cc)
                else: chg = 1
            else: # expression[k] == "&"
                val = v & vv
                if v == vv == 0: chg = 1 + min(c, cc)
                elif v == vv == 1: chg = min(c, cc)
                else: chg = 1
            return val, chg

        return fn(0, len(expression)-1)[1]


    """1897. Redistribute Characters to Make All Strings Equal (Easy)
    You are given an array of strings words (0-indexed). In one operation, pick
    two distinct indices i and j, where words[i] is a non-empty string, and
    move any character from words[i] to any position in words[j]. Return true
    if you can make every string in words equal using any number of operations,
    and false otherwise.

    Example 1:
    Input: words = ["abc","aabc","bc"]
    Output: true
    Explanation: Move the first 'a' in words[1] to the front of words[2], to
                 make words[1] = "abc" and words[2] = "abc". All the strings
                 are now equal to "abc", so return true.

    Example 2:
    Input: words = ["ab","a"]
    Output: false
    Explanation: It is impossible to make all the strings equal using the
                 operation.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consists of lowercase English letters."""

    def makeEqual(self, words: List[str]) -> bool:
        freq = defaultdict(int)
        for word in words:
            for ch in word: freq[ord(ch)-97] += 1
        return all(x % len(words) == 0 for x in freq.values())


    """1898. Maximum Number of Removable Characters (Medium)
    You are given two strings s and p where p is a subsequence of s. You are
    also given a distinct 0-indexed integer array removable containing a subset
    of indices of s (s is also 0-indexed). You want to choose an integer k
    (0 <= k <= removable.length) such that, after removing k characters from s
    using the first k indices in removable, p is still a subsequence of s. More
    formally, you will mark the character at s[removable[i]] for each 0 <= i < k,
    then remove all marked characters and check if p is still a subsequence.
    Return the maximum k you can choose such that p is still a subsequence of s
    after the removals. A subsequence of a string is a new string generated
    from the original string with some characters (can be none) deleted without
    changing the relative order of the remaining characters.

    Example 1:
    Input: s = "abcacb", p = "ab", removable = [3,1,0]
    Output: 2
    Explanation: After removing the characters at indices 3 and 1, "abcacb"
                 becomes "accb". "ab" is a subsequence of "accb". If we remove
                 the characters at indices 3, 1, and 0, "abcacb" becomes "ccb",
                 and "ab" is no longer a subsequence. Hence, the maximum k is 2.

    Example 2:
    Input: s = "abcbddddd", p = "abcd", removable = [3,2,1,4,5,6]
    Output: 1
    Explanation: After removing the character at index 3, "abcbddddd" becomes
                 "abcddddd". "abcd" is a subsequence of "abcddddd".

    Example 3:
    Input: s = "abcab", p = "abc", removable = [0,1,2,3,4]
    Output: 0
    Explanation: If you remove the first index in the array removable, "abc" is
                 no longer a subsequence.

    Constraints:
    * 1 <= p.length <= s.length <= 10^5
    * 0 <= removable.length < s.length
    * 0 <= removable[i] < s.length
    * p is a subsequence of s.
    * s and p both consist of lowercase English letters.
    * The elements in removable are distinct."""

    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:
        mp = {x: i for i, x in enumerate(removable)}

        def fn(x):
            """Return True if p is a subseq of s after x removals."""
            k = 0
            for i, ch in enumerate(s):
                if mp.get(i, inf) < x: continue
                if k < len(p) and ch == p[k]: k += 1
            return k == len(p)

        lo, hi = -1, len(removable)
        while lo < hi:
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid - 1
        return lo


    """1899. Merge Triplets to Form Target Triplet (Medium)
    A triplet is an array of three integers. You are given a 2D integer array
    triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You
    are also given an integer array target = [x, y, z] that describes the
    triplet you want to obtain. To obtain target, you may apply the following
    operation on triplets any number of times (possibly zero):
    * Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to
      become [max(ai, aj), max(bi, bj), max(ci, cj)].
    * For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5],
      triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5].
    Return true if it is possible to obtain the target triplet [x, y, z] as an
    element of triplets, or false otherwise.

    Example 1:
    Input: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]
    Output: true
    Explanation: Perform the following operations:
                 - Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]].
                   Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5].
                   triplets = [[2,5,3],[1,8,4],[2,7,5]].
                 The target triplet [2,7,5] is now an element of triplets.

    Example 2:
    Input: triplets = [[1,3,4],[2,5,8]], target = [2,5,8]
    Output: true
    Explanation: The target triplet [2,5,8] is already an element of triplets.

    Example 3:
    Input: triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]
    Output: true
    Explanation: Perform the following operations:
                 - Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]].
                   Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5].
                   triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]].
                 - Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]].
                   Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5].
                   triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]].
                 The target triplet [5,5,5] is now an element of triplets.

    Example 4:
    Input: triplets = [[3,4,5],[4,5,6]], target = [3,2,5]
    Output: false
    Explanation: It is impossible to have [3,2,5] as an element because there
                 is no 2 in any of the triplets.

    Constraints:
    * 1 <= triplets.length <= 10^5
    * triplets[i].length == target.length == 3
    * 1 <= ai, bi, ci, x, y, z <= 1000"""

    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        x = y = z = -inf
        for a, b, c in triplets:
            if a <= target[0] and b <= target[1] and c <= target[2]:
                x, y, z = max(x, a), max(y, b), max(z, c)
        return [x, y, z] == target


    """1900. The Earliest and Latest Rounds Where Players Compete (Hard)
    There is a tournament where n players are participating. The players are
    standing in a single row and are numbered from 1 to n based on their
    initial standing position (player 1 is the first player in the row, player
    2 is the second player in the row, etc.). The tournament consists of
    multiple rounds (starting from round number 1). In each round, the ith
    player from the front of the row competes against the ith player from the
    end of the row, and the winner advances to the next round. When the number
    of players is odd for the current round, the player in the middle
    automatically advances to the next round.

    * For example, if the row consists of players 1, 2, 4, 6, 7
      - Player 1 competes against player 7.
      - Player 2 competes against player 6.
      - Player 4 automatically advances to the next round.
    After each round is over, the winners are lined back up in the row based on
    the original ordering assigned to them initially (ascending order). The
    players numbered firstPlayer and secondPlayer are the best in the
    tournament. They can win against any other player before they compete
    against each other. If any two other players compete against each other,
    either of them might win, and thus you may choose the outcome of this round.
    Given the integers n, firstPlayer, and secondPlayer, return an integer array
    containing two values, the earliest possible round number and the latest
    possible round number in which these two players will compete against each
    other, respectively.

    Example 1:
    Input: n = 11, firstPlayer = 2, secondPlayer = 4
    Output: [3,4]
    Explanation: One possible scenario which leads to the earliest round number:
                 - First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
                 - Second round: 2, 3, 4, 5, 6, 11
                 - Third round: 2, 3, 4
                 One possible scenario which leads to the latest round number:
                 - First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
                 - Second round: 1, 2, 3, 4, 5, 6
                 - Third round: 1, 2, 4
                 - Fourth round: 2, 4

    Example 2:
    Input: n = 5, firstPlayer = 1, secondPlayer = 5
    Output: [1,1]
    Explanation: The players numbered 1 and 5 compete in the first round. There
                 is no way to make them compete in any other round.

    Constraints:
    * 2 <= n <= 28
    * 1 <= firstPlayer < secondPlayer <= n"""

    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:
        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed

        @cache
        def fn(k, mask):
            """Return earliest and latest rounds."""
            can = [i for i in range(n) if mask & (1 << i)]
            cand = [] # eliminated player
            for i in range(len(can)//2):
                p1, p2 = can[i], can[~i]
                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest
                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated
                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated
                else: cand.append([p1, p2]) # both could be elimited

            minn, maxx = inf, -inf
            for x in product(*cand):
                mask0 = mask
                for i in x: mask0 ^= 1 << i
                mn, mx = fn(k+1, mask0)
                minn, maxx = min(minn, mn), max(maxx, mx)
            return minn, maxx

        return fn(1, (1<<n)-1)


    """1901. Find a Peak Element II (Medium)
    A peak element in a 2D grid is an element that is strictly greater than all
    of its adjacent neighbors to the left, right, top, and bottom. Given a
    0-indexed m x n matrix mat where no two adjacent cells are equal, find any
    peak element mat[i][j] and return the length 2 array [i,j]. You may assume
    that the entire matrix is surrounded by an outer perimeter with the value
    -1 in each cell. You must write an algorithm that runs in O(m log(n)) or
    O(n log(m)) time.

    Example 1:
    Input: mat = [[1,4],[3,2]]
    Output: [0,1]
    Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both
                 acceptable answers.

    Example 2:
    Input: mat = [[10,20,15],[21,30,14],[7,16,32]]
    Output: [1,1]
    Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both
                 acceptable answers.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 500
    * 1 <= mat[i][j] <= 10^5
    * No two adjacent cells are equal."""

    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        m, n = len(mat), len(mat[0]) # dimensions

        def fn(lo, hi):
            """Return a peak element between column lo (inclusive) and hi (exlusive)."""
            if lo == hi: return
            mid = lo + hi >> 1
            if left := fn(lo, mid): return left
            if right := fn(mid+1, hi): return right
            for i in range(m):
                if (i == 0 or mat[i-1][mid] < mat[i][mid]) and (i+1 == m or mat[i][mid] > mat[i+1][mid]) and (mid == 0 or mat[i][mid-1] < mat[i][mid]) and (mid+1 == n or mat[i][mid] > mat[i][mid+1]):
                    return [i, mid]

        return fn(0, n)


    """1902. Depth of BST Given Insertion Order (Medium)
    You are given a 0-indexed integer array order of length n, a permutation of
    integers from 1 to n representing the order of insertion into a binary
    search tree. A binary search tree is defined as follows:
    * The left subtree of a node contains only nodes with keys less than the
      node's key.
    * The right subtree of a node contains only nodes with keys greater than
      the node's key.
    * Both the left and right subtrees must also be binary search trees.
    The binary search tree is constructed as follows:
    * order[0] will be the root of the binary search tree.
    * All subsequent elements are inserted as the child of any existing node
      such that the binary search tree properties hold.
    Return the depth of the binary search tree. A binary tree's depth is the
    number of nodes along the longest path from the root node down to the
    farthest leaf node.

    Example 1:
    Input: order = [2,1,4,3]
    Output: 3
    Explanation: The binary search tree has a depth of 3 with path 2->3->4.

    Example 2:
    Input: order = [2,1,3,4]
    Output: 3
    Explanation: The binary search tree has a depth of 3 with path 2->3->4.

    Example 3:
    Input: order = [1,2,3,4]
    Output: 4
    Explanation: The binary search tree has a depth of 4 with path 1->2->3->4.

    Constraints:
    * n == order.length
    * 1 <= n <= 10^5
    * order is a permutation of integers between 1 and n."""

    def maxDepthBST(self, order: List[int]) -> int:
        sd = SortedDict()
        for x in order:
            k = sd.bisect_left(x)
            val = 1
            if k: val = 1 + sd.values()[k-1]
            if k < len(sd): val = max(val, 1 + sd.values()[k])
            sd[x] = val
        return max(sd.values())


    """1903. Largest Odd Number in String (Easy)
    You are given a string num, representing a large integer. Return the
    largest-valued odd integer (as a string) that is a non-empty substring of
    num, or an empty string "" if no odd integer exists. A substring is a
    contiguous sequence of characters within a string.

    Example 1:
    Input: num = "52"
    Output: "5"
    Explanation: The only non-empty substrings are "5", "2", and "52". "5" is
                 the only odd number.

    Example 2:
    Input: num = "4206"Output: ""
    Explanation: There are no odd numbers in "4206".

    Example 3:
    Input: num = "35427"
    Output: "35427"
    Explanation: "35427" is already an odd number.

    Constraints:
    * 1 <= num.length <= 10^5
    * num only consists of digits and does not contain any leading zeros."""

    def largestOddNumber(self, num: str) -> str:
        for i in reversed(range(len(num))):
            if int(num[i]) & 1: return num[:i+1]
        return ""


    """1904. The Number of Full Rounds You Have Played (Medium)
    A new online video game has been released, and in this video game, there
    are 15-minute rounds scheduled every quarter-hour period. This means that
    at HH:00, HH:15, HH:30 and HH:45, a new round starts, where HH represents
    an integer number from 00 to 23. A 24-hour clock is used, so the earliest
    time in the day is 00:00 and the latest is 23:59. Given two strings
    startTime and finishTime in the format "HH:MM" representing the exact time
    you started and finished playing the game, respectively, calculate the
    number of full rounds that you played during your game session. For example,
    if startTime = "05:20" and finishTime = "05:59" this means you played only
    one full round from 05:30 to 05:45. You did not play the full round from
    05:15 to 05:30 because you started after the round began, and you did not
    play the full round from 05:45 to 06:00 because you stopped before the
    round ended. If finishTime is earlier than startTime, this means you have
    played overnight (from startTime to the midnight and from midnight to
    finishTime). Return the number of full rounds that you have played if you
    had started playing at startTime and finished at finishTime.

    Example 1:
    Input: startTime = "12:01", finishTime = "12:44"
    Output: 1
    Explanation: You played one full round from 12:15 to 12:30. You did not
                 play the full round from 12:00 to 12:15 because you started
                 playing at 12:01 after it began. You did not play the full
                 round from 12:30 to 12:45 because you stopped playing at
                 12:44 before it ended.

    Example 2:
    Input: startTime = "20:00", finishTime = "06:00"
    Output: 40
    Explanation: You played 16 full rounds from 20:00 to 00:00 and 24 full
                 rounds from 00:00 to 06:00. 16 + 24 = 40.

    Example 3:
    Input: startTime = "00:00", finishTime = "23:59"
    Output: 95
    Explanation: You played 4 full rounds each hour except for the last hour
                 where you played 3 full rounds.

    Constraints:
    * startTime and finishTime are in the format HH:MM.
    * 00 <= HH <= 23
    * 00 <= MM <= 59
    * startTime and finishTime are not equal."""

    def numberOfRounds(self, startTime: str, finishTime: str) -> int:
        ts = 60 * int(startTime[:2]) + int(startTime[-2:])
        tf = 60 * int(finishTime[:2]) + int(finishTime[-2:])
        if 0 <= tf - ts < 15: return 0 # edge case
        return tf//15 - (ts+14)//15 + (ts>tf)*96


    """1905. Count Sub Islands (Medium)
    You are given two m x n binary matrices grid1 and grid2 containing only 0's
    (representing water) and 1's (representing land). An island is a group of
    1's connected 4-directionally (horizontal or vertical). Any cells outside
    of the grid are considered water cells. An island in grid2 is considered a
    sub-island if there is an island in grid1 that contains all the cells that
    make up this island in grid2. Return the number of islands in grid2 that
    are considered sub-islands.

    Example 1:
    Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]],
           grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
    Output: 3
    Explanation: In the picture above, the grid on the left is grid1 and the
                 grid on the right is grid2. The 1s colored red in grid2 are
                 those considered to be part of a sub-island. There are three
                 sub-islands.

    Example 2:
    Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]],
           grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
    Output: 2
    Explanation: In the picture above, the grid on the left is grid1 and the
                 grid on the right is grid2. The 1s colored red in grid2 are
                 those considered to be part of a sub-island. There are two
                 sub-islands.

    Constraints:
    * m == grid1.length == grid2.length
    * n == grid1[i].length == grid2[i].length
    * 1 <= m, n <= 500
    * grid1[i][j] and grid2[i][j] are either 0 or 1."""

    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
        m, n = len(grid2), len(grid2[0])
        ans = 0
        for x in range(m):
            for y in range(n):
                if grid2[x][y]:
                    val = 1
                    grid2[x][y] = 0
                    stack = [(x, y)]
                    while stack:
                        i, j = stack.pop()
                        val &= grid1[i][j]
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                            if 0 <= ii < m and 0 <= jj < n and grid2[ii][jj]:
                                grid2[ii][jj] = 0
                                stack.append((ii, jj))
                    ans += val
        return ans


    """1906. Minimum Absolute Difference Queries (Medium)
    The minimum absolute difference of an array a is defined as the minimum
    value of |a[i] - a[j]|, where 0 <= i < j < a.length and a[i] != a[j]. If
    all elements of a are the same, the minimum absolute difference is -1.
    For example, the minimum absolute difference of the array [5,2,3,7,2] is
    |2 - 3| = 1. Note that it is not 0 because a[i] and a[j] must be different.
    You are given an integer array nums and the array queries where
    queries[i] = [li, ri]. For each query i, compute the minimum absolute
    difference of the subarray nums[li...ri] containing the elements of nums
    between the 0-based indices li and ri (inclusive). Return an array ans
    where ans[i] is the answer to the ith query. A subarray is a contiguous
    sequence of elements in an array. The value of |x| is defined as:
    * x if x >= 0.
    * -x if x < 0.

    Example 1:
    Input: nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]
    Output: [2,1,4,1]
    Explanation: The queries are processed as follows:
                 - queries[0] = [0,1]: The subarray is [1,3] and the minimum absolute difference is |1-3| = 2.
                 - queries[1] = [1,2]: The subarray is [3,4] and the minimum absolute difference is |3-4| = 1.
                 - queries[2] = [2,3]: The subarray is [4,8] and the minimum absolute difference is |4-8| = 4.
                 - queries[3] = [0,3]: The subarray is [1,3,4,8] and the minimum absolute difference is |3-4| = 1.

    Example 2:
    Input: nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]
    Output: [-1,1,1,3]
    Explanation: The queries are processed as follows:
                 - queries[0] = [2,3]: The subarray is [2,2] and the minimum absolute difference is -1 because all the elements are the same.
                 - queries[1] = [0,2]: The subarray is [4,5,2] and the minimum absolute difference is |4-5| = 1.
                 - queries[2] = [0,5]: The subarray is [4,5,2,2,7,10] and the minimum absolute difference is |4-5| = 1.
                 - queries[3] = [3,5]: The subarray is [2,7,10] and the minimum absolute difference is |7-10| = 3.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 100
    * 1 <= queries.length <= 2 * 10^4
    * 0 <= li < ri < nums.length"""

    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        loc = {}
        for i, x in enumerate(nums): loc.setdefault(x, []).append(i)
        keys = sorted(loc)

        ans = []
        for l, r in queries:
            prev, val = 0, inf
            for x in keys:
                i = bisect_left(loc[x], l)
                if i < len(loc[x]) and loc[x][i] <= r:
                    if prev: val = min(val, x - prev)
                    prev = x
            ans.append(val if val < inf else -1)
        return ans


    """1908. Game of Nim (Medium)
    Alice and Bob take turns playing a game with Alice starting first. In this
    game, there are n piles of stones. On each player's turn, the player should
    remove any positive number of stones from a non-empty pile of his or her
    choice. The first player who cannot make a move loses, and the other player
    wins. Given an integer array piles, where piles[i] is the number of stones
    in the ith pile, return true if Alice wins, or false if Bob wins. Both
    Alice and Bob play optimally.

    Example 1:
    Input: piles = [1]
    Output: true
    Explanation: There is only one possible scenario:
    - On the first turn, Alice removes one stone from the first pile. piles = [0].
    - On the second turn, there are no stones left for Bob to remove. Alice wins.

    Example 2:
    Input: piles = [1,1]
    Output: false
    Explanation: It can be proven that Bob will always win. One possible scenario is:
    - On the first turn, Alice removes one stone from the first pile. piles = [0,1].
    - On the second turn, Bob removes one stone from the second pile. piles = [0,0].
    - On the third turn, there are no stones left for Alice to remove. Bob wins.

    Example 3:
    Input: piles = [1,2,3]
    Output: false
    Explanation: It can be proven that Bob will always win. One possible scenario is:
    - On the first turn, Alice removes three stones from the third pile. piles = [1,2,0].
    - On the second turn, Bob removes one stone from the second pile. piles = [1,1,0].
    - On the third turn, Alice removes one stone from the first pile. piles = [0,1,0].
    - On the fourth turn, Bob removes one stone from the second pile. piles = [0,0,0].
    - On the fifth turn, there are no stones left for Alice to remove. Bob wins.

    Constraints:
    * n == piles.length
    * 1 <= n <= 7
    * 1 <= piles[i] <= 7


    Follow-up: Could you find a linear time solution? Although the linear time
               solution may be beyond the scope of an interview, it could be
               interesting to know."""

    def nimGame(self, piles: List[int]) -> bool:
        mask = 0
        for i, x in enumerate(piles): mask |= x << 3*i

        @cache
        def fn(mask):
            """Return True if current player can win by playing optimally."""
            for i in range(len(piles)):
                val = (mask >> 3*i) & 7
                for k in range(1, val+1):
                    mask0 = mask - (k << 3*i)
                    if not fn(mask0): return True
            return False

        return fn(mask)


    """1909. Remove One Element to Make the Array Strictly Increasing (Easy)
    Given a 0-indexed integer array nums, return true if it can be made
    strictly increasing after removing exactly one element, or false otherwise.
    If the array is already strictly increasing, return true. The array nums is
    strictly increasing if nums[i - 1] < nums[i] for each index
    (1 <= i < nums.length).

    Example 1:
    Input: nums = [1,2,10,5,7]
    Output: true
    Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].
                 [1,2,5,7] is strictly increasing, so return true.

    Example 2:
    Input: nums = [2,3,1,2]
    Output: false
    Explanation: [3,1,2] is the result of removing the element at index 0.
                 [2,1,2] is the result of removing the element at index 1.
                 [2,3,2] is the result of removing the element at index 2.
                 [2,3,1] is the result of removing the element at index 3.
                 No resulting array is strictly increasing, so return false.

    Example 3:
    Input: nums = [1,1,1]
    Output: false
    Explanation: The result of removing any element is [1,1]. [1,1] is not
                 strictly increasing, so return false.

    Example 4:
    Input: nums = [1,2,3]
    Output: true
    Explanation: [1,2,3] is already strictly increasing, so return true.

    Constraints:
    * 2 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000"""

    def canBeIncreasing(self, nums: List[int]) -> bool:
        prev, seen = -inf, False
        for i, x in enumerate(nums):
            if prev < x: prev = x
            else:
                if seen: return False
                seen = True
                if i == 1 or nums[i-2] < x: prev = x
        return True


    """1910. Remove All Occurrences of a Substring (Medium)
    Given two strings s and part, perform the following operation on s until
    all occurrences of the substring part are removed:
    * Find the leftmost occurrence of the substring part and remove it from s.
    Return s after removing all occurrences of part. A substring is a
    contiguous sequence of characters in a string.

    Example 1:
    Input: s = "daabcbaabcbc", part = "abc"
    Output: "dab"
    Explanation: The following operations are done:
                 - s = "daabcbaabcbc", remove "abc" starting at index 2, so s = "dabaabcbc".
                 - s = "dabaabcbc", remove "abc" starting at index 4, so s = "dababc".
                 - s = "dababc", remove "abc" starting at index 3, so s = "dab".
                 Now s has no occurrences of "abc".

    Example 2:
    Input: s = "axxxxyyyyb", part = "xy"
    Output: "ab"
    Explanation: The following operations are done:
                 - s = "axxxxyyyyb", remove "xy" starting at index 4 so s = "axxxyyyb".
                 - s = "axxxyyyb", remove "xy" starting at index 3 so s = "axxyyb".
                 - s = "axxyyb", remove "xy" starting at index 2 so s = "axyb".
                 - s = "axyb", remove "xy" starting at index 1 so s = "ab".
                 Now s has no occurrences of "xy".

    Constraints:
    * 1 <= s.length <= 1000
    * 1 <= part.length <= 1000
    * s and part consists of lowercase English letters."""

    def removeOccurrences(self, s: str, part: str) -> str:
        lps = [0]
        k = 0
        for i in range(1, len(part)):
            while k and part[k] != part[i]: k = lps[k-1]
            if part[k] == part[i]: k += 1
            lps.append(k)

        stack = [("", 0)]
        for ch in s:
            k = stack[-1][1]
            while k and part[k] != ch: k = lps[k-1]
            if part[k] == ch: k += 1
            stack.append((ch, k))
            if k == len(part):
                for _ in range(len(part)): stack.pop()
        return "".join(x for x, _ in stack)


    """1911. Maximum Alternating Subsequence Sum (Medium)
    The alternating sum of a 0-indexed array is defined as the sum of the
    elements at even indices minus the sum of the elements at odd indices.
    For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4.
    Given an array nums, return the maximum alternating sum of any subsequence
    of nums (after reindexing the elements of the subsequence). A subsequence
    of an array is a new array generated from the original array by deleting
    some elements (possibly none) without changing the remaining elements'
    relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4]
    (the underlined elements), while [2,4,2] is not.

    Example 1:
    Input: nums = [4,2,5,3]
    Output: 7
    Explanation: It is optimal to choose the subsequence [4,2,5] with
                 alternating sum (4 + 5) - 2 = 7.

    Example 2:
    Input: nums = [5,6,7,8]
    Output: 8
    Explanation: It is optimal to choose the subsequence [8] with alternating
                 sum 8.

    Example 3:
    Input: nums = [6,2,1,2,4,5]
    Output: 10
    Explanation: It is optimal to choose the subsequence [6,1,5] with
                 alternating sum (6 + 5) - 1 = 10.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def maxAlternatingSum(self, nums: List[int]) -> int:
        return sum(max(0, nums[i-1] - nums[i]) for i in range(1, len(nums))) + nums[-1]


    """1915. Number of Wonderful Substrings (Medium)
    A wonderful string is a string where at most one letter appears an odd
    number of times. For example, "ccjjc" and "abab" are wonderful, but "ab" is
    not. Given a string word that consists of the first ten lowercase English
    letters ('a' through 'j'), return the number of wonderful non-empty
    substrings in word. If the same substring appears multiple times in word,
    then count each occurrence separately. A substring is a contiguous sequence
    of characters in a string.

    Example 1:
    Input: word = "aba"
    Output: 4
    Explanation: The four wonderful substrings are underlined below:
                 - "aba" -> "a"
                 - "aba" -> "b"
                 - "aba" -> "a"
                 - "aba" -> "aba"

    Example 2:
    Input: word = "aabb"
    Output: 9
    Explanation: The nine wonderful substrings are underlined below:
                 - "aabb" -> "a"
                 - "aabb" -> "aa"
                 - "aabb" -> "aab"
                 - "aabb" -> "aabb"
                 - "aabb" -> "a"
                 - "aabb" -> "abb"
                 - "aabb" -> "b"
                 - "aabb" -> "bb"
                 - "aabb" -> "b"

    Example 3:
    Input: word = "he"
    Output: 2
    Explanation: The two wonderful substrings are underlined below:
                 - "he" -> "h"
                 - "he" -> "e"

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists of lowercase English letters from 'a' to 'j'."""

    def wonderfulSubstrings(self, word: str) -> int:
        ans = mask = 0
        freq = defaultdict(int, {0: 1})
        for ch in word:
            mask ^= 1 << ord(ch)-97
            ans += freq[mask]
            for i in range(10): ans += freq[mask ^ 1 << i]
            freq[mask] += 1
        return ans


    """1916. Count Ways to Build Rooms in an Ant Colony (Hard)
    You are an ant tasked with adding n new rooms numbered 0 to n-1 to your
    colony. You are given the expansion plan as a 0-indexed integer array of
    length n, prevRoom, where prevRoom[i] indicates that you must build room
    prevRoom[i] before building room i, and these two rooms must be connected
    directly. Room 0 is already built, so prevRoom[0] = -1. The expansion plan
    is given such that once all the rooms are built, every room will be
    reachable from room 0. You can only build one room at a time, and you can
    travel freely between rooms you have already built only if they are
    connected. You can choose to build any room as long as its previous room is
    already built. Return the number of different orders you can build all the
    rooms in. Since the answer may be large, return it modulo 10^9 + 7.

    Example 1:
    Input: prevRoom = [-1,0,1]
    Output: 1
    Explanation: There is only one way to build the additional rooms: 0 → 1 → 2

    Example 2:
    Input: prevRoom = [-1,0,0,1,2]
    Output: 6
    Explanation: The 6 ways are:
                 0 → 1 → 3 → 2 → 4
                 0 → 2 → 4 → 1 → 3
                 0 → 1 → 2 → 3 → 4
                 0 → 1 → 2 → 4 → 3
                 0 → 2 → 1 → 3 → 4
                 0 → 2 → 1 → 4 → 3

    Constraints:
    * n == prevRoom.length
    * 2 <= n <= 10^5
    * prevRoom[0] == -1
    * 0 <= prevRoom[i] < n for all 1 <= i < n
    * Every room is reachable from room 0 once all the rooms are built."""

    def waysToBuildRooms(self, prevRoom: List[int]) -> int:
        tree = [[] for _ in prevRoom]
        for i, x in enumerate(prevRoom):
            if x >= 0: tree[x].append(i)

        N = 100_001
        MOD = 1_000_000_007
        fact, ifact, inv = [1] * N, [1] * N, [1] * N
        for x in range(1, N):
            if x >= 2: inv[x] = MOD - MOD//x * inv[MOD % x] % MOD # modular inverse
            fact[x] = fact[x-1] * x % MOD
            ifact[x] = ifact[x-1] * inv[x] % MOD

        def fn(n):
            """Return number of nodes and ways to build sub-tree."""
            if not tree[n]: return 1, 1 # leaf
            c, m = 0, 1
            for nn in tree[n]:
                cc, mm = fn(nn)
                c += cc
                m = m * mm * ifact[cc] % MOD
            return c+1, m * fact[c] % MOD

        return fn(0)[1]


    """1918. Kth Smallest Subarray Sum (Medium)
    Given an integer array nums of length n and an integer k, return the kth
    smallest subarray sum. A subarray is defined as a non-empty contiguous
    sequence of elements in an array. A subarray sum is the sum of all elements
    in the subarray.

    Example 1:
    Input: nums = [2,1,3], k = 4
    Output: 3
    Explanation: The subarrays of [2,1,3] are:
                 - [2] with sum 2
                 - [1] with sum 1
                 - [3] with sum 3
                 - [2,1] with sum 3
                 - [1,3] with sum 4
                 - [2,1,3] with sum 6
                 Ordering the sums from smallest to largest gives 1, 2, 3, 3,
                 4, 6. The 4th smallest is 3.

    Example 2:
    Input: nums = [3,3,5,5], k = 7
    Output: 10
    Explanation: The subarrays of [3,3,5,5] are:
                 - [3] with sum 3
                 - [3] with sum 3
                 - [5] with sum 5
                 - [5] with sum 5
                 - [3,3] with sum 6
                 - [3,5] with sum 8
                 - [5,5] with sum 10
                 - [3,3,5], with sum 11
                 - [3,5,5] with sum 13
                 - [3,3,5,5] with sum 16
                 Ordering the sums from smallest to largest gives 3, 3, 5, 5,
                 6, 8, 10, 11, 13, 16. The 7th smallest is 10.

    Constraints:
    * n == nums.length
    * 1 <= n <= 2 * 10^4
    * 1 <= nums[i] <= 5 * 10^4
    * 1 <= k <= n * (n + 1) / 2"""

    def kthSmallestSubarraySum(self, nums: List[int], k: int) -> int:

        def fn(x):
            """Return number of subarrays sums <= x."""
            ans = rsm = ii = 0
            for i in range(len(nums)):
                rsm += nums[i]
                while rsm > x: # sliding window
                    rsm -= nums[ii]
                    ii += 1
                ans += i - ii + 1
            return ans

        lo, hi = 0, sum(nums)
        while lo < hi:
            mid = lo + hi >> 1
            if fn(mid) < k: lo = mid + 1
            else: hi = mid
        return lo


    """1925. Count Square Sum Triples (Easy)
    A square triple (a,b,c) is a triple where a, b, and c are integers and
    a^2 + b^2 = c^2. Given an integer n, return the number of square triples
    such that 1 <= a, b, c <= n.

    Example 1:
    Input: n = 5
    Output: 2
    Explanation: The square triples are (3,4,5) and (4,3,5).

    Example 2:
    Input: n = 10
    Output: 4
    Explanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).

    Constraints: 1 <= n <= 250"""

    def countTriples(self, n: int) -> int:
        ans = 0
        for a in range(1, n):
            for b in range(a+1, n):
                cc = a*a + b*b
                if int(sqrt(cc))**2 == cc and cc <= n*n: ans += 2
        return ans


    """1926. Nearest Exit from Entrance in Maze (Medium)
    You are given an m x n matrix maze (0-indexed) with empty cells
    (represented as '.') and walls (represented as '+'). You are also given the
    entrance of the maze, where entrance = [entrancerow, entrancecol] denotes
    the row and column of the cell you are initially standing at. In one step,
    you can move one cell up, down, left, or right. You cannot step into a cell
    with a wall, and you cannot step outside the maze. Your goal is to find the
    nearest exit from the entrance. An exit is defined as an empty cell that is
    at the border of the maze. The entrance does not count as an exit. Return
    the number of steps in the shortest path from the entrance to the nearest
    exit, or -1 if no such path exists.

    Example 1:
    Input: maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
    Output: 1
    Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].
                 Initially, you are at the entrance cell [1,2].
                 - You can reach [1,0] by moving 2 steps left.
                 - You can reach [0,2] by moving 1 step up.
                 It is impossible to reach [2,3] from the entrance. Thus, the
                 nearest exit is [0,2], which is 1 step away.

    Example 2:
    Input: maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
    Output: 2
    Explanation: There is 1 exit in this maze at [1,2]. [1,0] does not count as
                 an exit since it is the entrance cell. Initially, you are at
                 the entrance cell [1,0].
                 - You can reach [1,2] by moving 2 steps right.
                 Thus, the nearest exit is [1,2], which is 2 steps away.

    Example 3:
    Input: maze = [[".","+"]], entrance = [0,0]
    Output: -1
    Explanation: There are no exits in this maze.

    Constraints:
    * maze.length == m
    * maze[i].length == n
    * 1 <= m, n <= 100
    * maze[i][j] is either '.' or '+'.
    * entrance.length == 2
    * 0 <= entrancerow < m
    * 0 <= entrancecol < n
    * entrance will always be an empty cell."""

    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        m, n = len(maze), len(maze[0])

        ans = 0
        queue = [entrance]
        while queue:
            newq = []
            for i, j in queue:
                if (i in (0, m-1) or j in (0, n-1)) and [i, j] != entrance: return ans
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n and maze[ii][jj] == ".":
                        maze[ii][jj] = "+"
                        newq.append((ii, jj))
            ans += 1
            queue = newq
        return -1


    """1927. Sum Game (Medium)
    Alice and Bob take turns playing a game, with Alice starting first. You are
    given a string num of even length consisting of digits and '?' characters.
    On each turn, a player will do the following if there is still at least one
    '?' in num:
    * Choose an index i where num[i] == '?'.
    * Replace num[i] with any digit between '0' and '9'.
    The game ends when there are no more '?' characters in num. For Bob to win,
    the sum of the digits in the first half of num must be equal to the sum of
    the digits in the second half. For Alice to win, the sums must not be equal.
    * For example, if the game ended with num = "243801", then Bob wins because
      2+4+3 = 8+0+1. If the game ended with num = "243803", then Alice wins
      because 2+4+3 != 8+0+3.
    Assuming Alice and Bob play optimally, return true if Alice will win and
    false if Bob will win.

    Example 1:
    Input: num = "5023"
    Output: false
    Explanation: There are no moves to be made. The sum of the first half is
                 equal to the sum of the second half: 5 + 0 = 2 + 3.

    Example 2:
    Input: num = "25??"
    Output: true
    Explanation: Alice can replace one of the '?'s with '9' and it will be
                 impossible for Bob to make the sums equal.

    Example 3:
    Input: num = "?3295???"
    Output: false
    Explanation: It can be proven that Bob will always win. One possible outcome is:
                 - Alice replaces the first '?' with '9'. num = "93295???".
                 - Bob replaces one of the '?' in the right half with '9'. num = "932959??".
                 - Alice replaces one of the '?' in the right half with '2'. num = "9329592?".
                 - Bob replaces the last '?' in the right half with '7'. num = "93295927".
                 Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.

    Constraints:
    * 2 <= num.length <= 10^5
    * num.length is even.
    * num consists of only digits and '?'."""

    def sumGame(self, num: str) -> bool:
        diff = qm = 0
        for i, ch in enumerate(num):
            if ch == "?": qm += 1 if i < len(num)//2 else -1
            else: diff += int(ch) if i < len(num)//2 else -int(ch)
        return diff * 2 + qm * 9 != 0


    """1928. Minimum Cost to Reach Destination in Time (Hard)
    There is a country of n cities numbered from 0 to n - 1 where all the
    cities are connected by bi-directional roads. The roads are represented as
    a 2D integer array edges where edges[i] = [xi, yi, timei] denotes a road
    between cities xi and yi that takes timei minutes to travel. There may be
    multiple roads of differing travel times connecting the same two cities,
    but no road connects a city to itself. Each time you pass through a city,
    you must pay a passing fee. This is represented as a 0-indexed integer
    array passingFees of length n where passingFees[j] is the amount of dollars
    you must pay when you pass through city j. In the beginning, you are at
    city 0 and want to reach city n - 1 in maxTime minutes or less. The cost
    of your journey is the summation of passing fees for each city that you
    passed through at some moment of your journey (including the source and
    destination cities). Given maxTime, edges, and passingFees, return the
    minimum cost to complete your journey, or -1 if you cannot complete it
    within maxTime minutes.

    Example 1:
    Input: maxTime = 30,
           edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]],
           passingFees = [5,1,2,20,20,3]
    Output: 11
    Explanation: The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes
                 and has $11 worth of passing fees.

    Example 2:
    Input: maxTime = 29,
           edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]],
           passingFees = [5,1,2,20,20,3]
    Output: 48
    Explanation: The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes
                 and has $48 worth of passing fees. You cannot take path
                 0 -> 1 -> 2 -> 5 since it would take too long.

    Example 3:
    Input: maxTime = 25,
           edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]],
           passingFees = [5,1,2,20,20,3]
    Output: -1
    Explanation: There is no way to reach city 5 from city 0 within 25 minutes.

    Constraints:
    * 1 <= maxTime <= 1000
    * n == passingFees.length
    * 2 <= n <= 1000
    * n - 1 <= edges.length <= 1000
    * 0 <= xi, yi <= n - 1
    * 1 <= timei <= 1000
    * 1 <= passingFees[j] <= 1000
    * The graph may contain multiple edges between two nodes.
    * The graph does not contain self loops."""

    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:
        graph = {}
        for u, v, t in edges:
            graph.setdefault(u, []).append((v, t))
            graph.setdefault(v, []).append((u, t))

        pq = [(passingFees[0], 0, 0)]
        dist = {0: 0}
        while pq:
            cost, k, t = heappop(pq)
            if k == len(passingFees)-1: return cost
            for kk, tt in graph.get(k, []):
                if t + tt <= maxTime and t + tt < dist.get(kk, inf):
                    dist[kk] = t + tt
                    heappush(pq, (cost + passingFees[kk], kk, t + tt))
        return -1


    """1929. Concatenation of Array (Easy)
    Given an integer array nums of length n, you want to create an array ans of
    length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n
    (0-indexed). Specifically, ans is the concatenation of two nums arrays.
    Return the array ans.

    Example 1:
    Input: nums = [1,2,1]
    Output: [1,2,1,1,2,1]
    Explanation: The array ans is formed as follows:
                 - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
                 - ans = [1,2,1,1,2,1]

    Example 2:
    Input: nums = [1,3,2,1]
    Output: [1,3,2,1,1,3,2,1]
    Explanation: The array ans is formed as follows:
                 - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
                 - ans = [1,3,2,1,1,3,2,1]

    Constraints:
    * n == nums.length
    * 1 <= n <= 1000
    * 1 <= nums[i] <= 1000"""

    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums * 2


    """1930. Unique Length-3 Palindromic Subsequences (Medium)
    Given a string s, return the number of unique palindromes of length three
    that are a subsequence of s. Note that even if there are multiple ways to
    obtain the same subsequence, it is still only counted once. A palindrome is
    a string that reads the same forwards and backwards. A subsequence of a
    string is a new string generated from the original string with some
    characters (can be none) deleted without changing the relative order of the
    remaining characters. For example, "ace" is a subsequence of "abcde".

    Example 1:
    Input: s = "aabca"
    Output: 3
    Explanation: The 3 palindromic subsequences of length 3 are:
                 - "aba" (subsequence of "aabca")
                 - "aaa" (subsequence of "aabca")
                 - "aca" (subsequence of "aabca")

    Example 2:
    Input: s = "adc"
    Output: 0
    Explanation: There are no palindromic subsequences of length 3 in "adc".

    Example 3:
    Input: s = "bbcbaba"
    Output: 4
    Explanation: The 4 palindromic subsequences of length 3 are:
                 - "bbb" (subsequence of "bbcbaba")
                 - "bcb" (subsequence of "bbcbaba")
                 - "bab" (subsequence of "bbcbaba")
                 - "aba" (subsequence of "bbcbaba")

    Constraints:
    * 3 <= s.length <= 10^5
    * s consists of only lowercase English letters."""

    def countPalindromicSubsequence(self, s: str) -> int:
        locs = defaultdict(list)
        for i, ch in enumerate(s): locs[ch].append(i)

        ans = 0
        for x in ascii_lowercase:
            if len(locs[x]) > 1:
                if len(locs[x]) > 2: ans += 1
                for xx in ascii_lowercase:
                    if x != xx and bisect_left(locs[xx], locs[x][0]) != bisect_left(locs[xx], locs[x][-1]): ans += 1
        return ans


    """1931. Painting a Grid With Three Different Colors (Hard)
    You are given two integers m and n. Consider an m x n grid where each cell
    is initially white. You can paint each cell red, green, or blue. All cells
    must be painted. Return the number of ways to color the grid with no two
    adjacent cells having the same color. Since the answer can be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: m = 1, n = 1
    Output: 3
    Explanation: The three possible colorings are shown in the image above.

    Example 2:
    Input: m = 1, n = 2
    Output: 6
    Explanation: The six possible colorings are shown in the image above.

    Example 3:
    Input: m = 5, n = 5
    Output: 580986

    Constraints:
    * 1 <= m <= 5
    * 1 <= n <= 1000"""

    def colorTheGrid(self, m: int, n: int) -> int:

        @cache
        def fn(i, j, mask):
            """Return number of ways to color grid."""
            if j == n: return 1
            if i == m: return fn(0, j+1, mask)
            ans = 0
            for x in 1<<2*i, 1<<2*i+1, 0b11<<2*i:
                mask0 = mask ^ x
                if mask0 & 0b11<<2*i and (i == 0 or (mask0 >> 2*i) & 0b11 != (mask0 >> 2*i-2) & 0b11):
                    ans += fn(i+1, j, mask0)
            return ans % 1_000_000_007

        return fn(0, 0, 0)


    """1932. Merge BSTs to Create Single BST (Hard)
    You are given n BST (binary search tree) root nodes for n separate BSTs
    stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes,
    and no two roots have the same value. In one operation, you can:
    * Select two distinct indices i and j such that the value stored at one of
      the leaves of trees[i] is equal to the root value of trees[j].
    * Replace the leaf node in trees[i] with trees[j].
    * Remove trees[j] from trees.
    Return the root of the resulting BST if it is possible to form a valid BST
    after performing n - 1 operations, or null if it is impossible to create a
    valid BST. A BST (binary search tree) is a binary tree where each node
    satisfies the following property:
    * Every node in the node's left subtree has a value strictly less than the
      node's value.
    * Every node in the node's right subtree has a value strictly greater than
      the node's value.
    A leaf is a node that has no children.

    Example 1:
    Input: trees = [[2,1],[3,2,5],[5,4]]
    Output: [3,2,5,1,null,4]
    Explanation: In the first operation, pick i=1 and j=0, and merge trees[0]
                 into trees[1]. Delete trees[0], so trees = [[3,2,5,1],[5,4]].
                 In the second operation, pick i=0 and j=1, and merge trees[1]
                 into trees[0]. Delete trees[1], so trees = [[3,2,5,1,null,4]].
                 The resulting tree is a valid BST, so return its root.

    Example 2:
    Input: trees = [[5,3,8],[3,2,6]]
    Output: []
    Explanation: Pick i=0 and j=1 and merge trees[1] into trees[0]. Delete
                 trees[1], so trees = [[5,3,8,2,6]]. This is the only valid
                 operation that can be performed, but the resulting tree is not
                 a valid BST, so return null.

    Example 3:
    Input: trees = [[5,4],[3]]
    Output: []
    Explanation: It is impossible to perform any operations.

    Example 4:
    Input: trees = [[2,1,3]]
    Output: [2,1,3]
    Explanation: There is only one tree, and it is already a valid BST, so
                 return its root.

    Constraints:
    * n == trees.length
    * 1 <= n <= 5 * 10^4
    * The number of nodes in each tree is in the range [1, 3].
    * Each node in the input may have children but no grandchildren.
    * No two roots of trees have the same value.
    * All the trees in the input are valid BSTs.
    * 1 <= TreeNode.val <= 5 * 10^4."""

    def canMerge(self, trees: List[TreeNode]) -> TreeNode:
        freq = defaultdict(int)
        for tree in trees:
            stack = [tree]
            while stack:
                x = stack.pop()
                if x:
                    freq[x.val] += 1
                    stack.append(x.left)
                    stack.append(x.right)

        cnt, root = 0, None
        mp = {}
        for tree in trees:
            if freq[tree.val] & 1: cnt, root = cnt+1, tree
            mp[tree.val] = tree
        if cnt != 1: return None

        stack = [(root, None, 0)]
        total = len(trees)
        while stack:
            node, parent, left = stack.pop()
            if not node.left and not node.right and node.val in mp:
                total -= 1
                if not parent:
                    if len(trees) > 1: return None
                    return root
                if left: parent.left = node = mp[node.val]
                else: parent.right = node = mp[node.val]
            if node.left: stack.append((node.left, node, 1))
            if node.right: stack.append((node.right, node, 0))

        if total > 1: return None

        # in-order traversal
        prev = -inf
        node = root
        stack = []
        while stack or node:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                if prev >= node.val: return None
                prev = node.val
                node = node.right
        return root


    """1933. Check if String Is Decomposable Into Value-Equal Substrings (Easy)
    A value-equal string is a string where all characters are the same.
    * For example, "1111" and "33" are value-equal strings.
    * In contrast, "123" is not a value-equal string.
    Given a digit string s, decompose the string into some number of
    consecutive value-equal substrings where exactly one substring has a length
    of 2 and the remaining substrings have a length of 3. Return true if you
    can decompose s according to the above rules. Otherwise, return false. A
    substring is a contiguous sequence of characters in a string.

    Example 1:
    Input: s = "000111000"
    Output: false
    Explanation: s cannot be decomposed according to the rules because
                 ["000", "111", "000"] does not have a substring of length 2.

    Example 2:
    Input: s = "00011111222"
    Output: true
    Explanation: s can be decomposed into ["000", "111", "11", "222"].

    Example 3:
    Input: s = "011100022233"
    Output: false
    Explanation: s cannot be decomposed according to the rules because of the
                 first '0'.

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of only digits '0' through '9'."""

    def isDecomposable(self, s: str) -> bool:
        found = False
        for _, grp in groupby(s):
            r = len(list(grp)) % 3
            if r == 2 and not found: found = True
            elif r != 0: return False
        return found


    """1935. Maximum Number of Words You Can Type (Easy)
    There is a malfunctioning keyboard where some letter keys do not work. All
    other keys on the keyboard work properly. Given a string text of words
    separated by a single space (no leading or trailing spaces) and a string
    brokenLetters of all distinct letter keys that are broken, return the
    number of words in text you can fully type using this keyboard.

    Example 1:
    Input: text = "hello world", brokenLetters = "ad"
    Output: 1
    Explanation: We cannot type "world" because the 'd' key is broken.

    Example 2:
    Input: text = "leet code", brokenLetters = "lt"
    Output: 1
    Explanation: We cannot type "leet" because the 'l' and 't' keys are broken.

    Example 3:
    Input: text = "leet code", brokenLetters = "e"
    Output: 0
    Explanation: We cannot type either word because the 'e' key is broken.

    Constraints:
    * 1 <= text.length <= 10^4
    * 0 <= brokenLetters.length <= 26
    * text consists of words separated by a single space without any leading or
      trailing spaces.
    * Each word only consists of lowercase English letters.
    * brokenLetters consists of distinct lowercase English letters."""

    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        ans = 0
        brokenLetters = set(brokenLetters)
        for word in text.split():
            if not set(word) & brokenLetters: ans += 1
        return ans


    """1936. Add Minimum Number of Rungs (Medium)
    You are given a strictly increasing integer array rungs that represents the
    height of rungs on a ladder. You are currently on the floor at height 0,
    and you want to reach the last rung. You are also given an integer dist.
    You can only climb to the next highest rung if the distance between where
    you are currently at (the floor or on a rung) and the next rung is at most
    dist. You are able to insert rungs at any positive integer height if a rung
    is not already there. Return the minimum number of rungs that must be added
    to the ladder in order for you to climb to the last rung.

    Example 1:
    Input: rungs = [1,3,5,10], dist = 2
    Output: 2
    Explanation: You currently cannot reach the last rung. Add rungs at heights
                 7 and 8 to climb this ladder. The ladder will now have rungs
                 at [1,3,5,7,8,10].

    Example 2:
    Input: rungs = [3,6,8,10], dist = 3
    Output: 0
    Explanation: This ladder can be climbed without adding additional rungs.

    Example 3:
    Input: rungs = [3,4,6,7], dist = 2
    Output: 1
    Explanation: You currently cannot reach the first rung from the ground. Add
                 a rung at height 1 to climb this ladder. The ladder will now
                 have rungs at [1,3,4,6,7].

    Example 4:
    Input: rungs = [5], dist = 10
    Output: 0
    Explanation: This ladder can be climbed without adding additional rungs.

    Constraints:
    * 1 <= rungs.length <= 10^5
    * 1 <= rungs[i] <= 10^9
    * 1 <= dist <= 10^9
    * rungs is strictly increasing."""

    def addRungs(self, rungs: List[int], dist: int) -> int:
        ans = prev = 0
        for x in rungs:
            ans += (x - prev - 1) // dist
            prev = x
        return ans


    """1937. Maximum Number of Points with Cost (Medium)
    You are given an m x n integer matrix points (0-indexed). Starting with 0
    points, you want to maximize the number of points you can get from the
    matrix. To gain points, you must pick one cell in each row. Picking the
    cell at coordinates (r, c) will add points[r][c] to your score. However,
    you will lose points if you pick a cell too far from the cell that you
    picked in the previous row. For every two adjacent rows r and r + 1 (where
    0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will
    subtract abs(c1 - c2) from your score. Return the maximum number of points
    you can achieve.

    abs(x) is defined as:
    * x for x >= 0.
    * -x for x < 0.

    Example 1:
    Input: points = [[1,2,3],[1,5,1],[3,1,1]]
    Output: 9
    Explanation: The blue cells denote the optimal cells to pick, which have
                 coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11
                 to your score. However, you must subtract abs(2 - 1) + abs(1 - 0) = 2
                 from your score. Your final score is 11 - 2 = 9.

    Example 2:
    Input: points = [[1,5],[2,3],[4,2]]
    Output: 11
    Explanation: The blue cells denote the optimal cells to pick, which have
                 coordinates (0, 1), (1, 1), and (2, 0). You add 5 + 3 + 4 = 12
                 to your score. However, you must subtract abs(1 - 1) + abs(1 - 0) = 1
                 from your score. Your final score is 12 - 1 = 11.

    Constraints:
    * m == points.length
    * n == points[r].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 0 <= points[r][c] <= 10^5"""

    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])
        dp = [[0]*n for _ in range(m)]
        dp[0] = points[0]
        for i in range(1, m):
            for j in range(n-2, -1, -1):
                dp[i-1][j] = max(dp[i-1][j], dp[i-1][j+1]-1)
            prefix = 0
            for j in range(n):
                dp[i][j] = points[i][j] + max(prefix, dp[i-1][j])
                prefix = max(prefix, dp[i-1][j]) - 1
        return max(dp[-1])


    """1938. Maximum Genetic Difference Query (Hard)
    There is a rooted tree consisting of n nodes numbered 0 to n - 1. Each node's
    number denotes its unique genetic value (i.e. the genetic value of node x
    is x). The genetic difference between two genetic values is defined as the
    bitwise-XOR of their values. You are given the integer array parents, where
    parents[i] is the parent for node i. If node x is the root of the tree, then
    parents[x] == -1. You are also given the array queries where
    queries[i] = [nodei, vali]. For each query i, find the maximum genetic
    difference between vali and pi, where pi is the genetic value of any node
    that is on the path between nodei and the root (including nodei and the root).
    More formally, you want to maximize vali XOR pi. Return an array ans where
    ans[i] is the answer to the ith query.

    Example 1:
    Input: parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
    Output: [2,3,7]
    Explanation: The queries are processed as follows:
    - [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.
    - [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.
    - [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.

    Example 2:
    Input: parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
    Output: [6,14,7]
    Explanation: The queries are processed as follows:
    - [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.
    - [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.
    - [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.

    Constraints:
    * 2 <= parents.length <= 10^5
    * 0 <= parents[i] <= parents.length - 1 for every node i that is not the root.
    * parents[root] == -1
    * 1 <= queries.length <= 3 * 10^4
    * 0 <= nodei <= parents.length - 1
    * 0 <= vali <= 2 * 10^5

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, x):
        node = self.root
        for i in range(18, -1, -1):
            bit = (x >> i) & 1
            node = node.setdefault(bit, {})
            node["mult"] = 1 + node.get("mult", 0)
        node["#"] = x # sentinel

    def search(self, x):
        node = self.root
        for i in range(18, -1, -1):
            bit = (x >> i) & 1
            if 1^bit in node: node = node[1^bit]
            else: node = node[bit]
        return x ^ node["#"]

    def remove(self, x):
        node = self.root
        for i in range(18, -1, -1):
            bit = (x >> i) & 1
            node[bit]["mult"] -= 1
            if node[bit]["mult"] == 0:
                node.pop(bit)
                break
            node = node[bit]"""

    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:
        mp = {}
        for i, (node, val) in enumerate(queries):
            mp.setdefault(node, []).append([val, i])

        tree, root = {}, -1
        for i, x in enumerate(parents):
            if x == -1: root = i
            else: tree.setdefault(x, []).append(i)

        ans = [0]*len(queries)
        trie = Trie()

        def fn(x):
            """Collect query results while traversing the tree."""
            trie.insert(x)
            for v, i in mp.get(x, []): ans[i] = trie.search(v)
            for xx in tree.get(x, []): fn(xx)
            trie.remove(x)

        fn(root)
        return ans


    """1940. Longest Common Subsequence Between Sorted Arrays (Medium)
    Given an array of integer arrays arrays where each arrays[i] is sorted in
    strictly increasing order, return an integer array representing the longest
    common subsequence between all the arrays. A subsequence is a sequence that
    can be derived from another sequence by deleting some elements (possibly
    none) without changing the order of the remaining elements.

    Example 1:
    Input: arrays = [[1,3,4],
                     [1,4,7,9]]
    Output: [1,4]
    Explanation: The longest common subsequence in the two arrays is [1,4].

    Example 2:
    Input: arrays = [[2,3,6,8],
                     [1,2,3,5,6,7,10],
                     [2,3,4,6,9]]
    Output: [2,3,6]
    Explanation: The longest common subsequence in all three arrays is [2,3,6].

    Example 3:
    Input: arrays = [[1,2,3,4,5],
                     [6,7,8]]
    Output: []
    Explanation: There is no common subsequence between the two arrays.

    Constraints:
    * 2 <= arrays.length <= 100
    * 1 <= arrays[i].length <= 100
    * 1 <= arrays[i][j] <= 100
    * arrays[i] is sorted in strictly increasing order."""

    def longestCommomSubsequence(self, arrays: List[List[int]]) -> List[int]:
        ans = set(arrays[0])
        for i in range(1, len(arrays)): ans &= set(arrays[i])
        return sorted(ans)


    """1941. Check if All Characters Have Equal Number of Occurrences (Easy)
    Given a string s, return true if s is a good string, or false otherwise. A
    string s is good if all the characters that appear in s have the same
    number of occurrences (i.e., the same frequency).

    Example 1:
    Input: s = "abacbc"
    Output: true
    Explanation: The characters that appear in s are 'a', 'b', and 'c'. All
                 characters occur 2 times in s.

    Example 2:
    Input: s = "aaabb"
    Output: false
    Explanation: The characters that appear in s are 'a' and 'b'. 'a' occurs 3
                 times while 'b' occurs 2 times, which is not the same number
                 of times.

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of lowercase English letters."""

    def areOccurrencesEqual(self, s: str) -> bool:
        return len(set(Counter(s).values())) == 1


    """1942. The Number of the Smallest Unoccupied Chair (Medium)
    There is a party where n friends numbered from 0 to n - 1 are attending.
    There is an infinite number of chairs in this party that are numbered from
    0 to infinity. When a friend arrives at the party, they sit on the
    unoccupied chair with the smallest number. For example, if chairs 0, 1, and
    5 are occupied when a friend comes, they will sit on chair number 2. When a
    friend leaves the party, their chair becomes unoccupied at the moment they
    leave. If another friend arrives at that same moment, they can sit in that
    chair. You are given a 0-indexed 2D integer array times where
    times[i] = [arrivali, leavingi], indicating the arrival and leaving times
    of the ith friend respectively, and an integer targetFriend. All arrival
    times are distinct. Return the chair number that the friend numbered
    targetFriend will sit on.

    Example 1:
    Input: times = [[1,4],[2,3],[4,6]], targetFriend = 1
    Output: 1
    Explanation: - Friend 0 arrives at time 1 and sits on chair 0.
                 - Friend 1 arrives at time 2 and sits on chair 1.
                 - Friend 1 leaves at time 3 and chair 1 becomes empty.
                 - Friend 0 leaves at time 4 and chair 0 becomes empty.
                 - Friend 2 arrives at time 4 and sits on chair 0.
                 Since friend 1 sat on chair 1, we return 1.

    Example 2:
    Input: times = [[3,10],[1,5],[2,6]], targetFriend = 0
    Output: 2
    Explanation: - Friend 1 arrives at time 1 and sits on chair 0.
                 - Friend 2 arrives at time 2 and sits on chair 1.
                 - Friend 0 arrives at time 3 and sits on chair 2.
                 - Friend 1 leaves at time 5 and chair 0 becomes empty.
                 - Friend 2 leaves at time 6 and chair 1 becomes empty.
                 - Friend 0 leaves at time 10 and chair 2 becomes empty.
                 Since friend 0 sat on chair 2, we return 2.

    Constraints:
    * n == times.length
    * 2 <= n <= 10^4
    * times[i].length == 2
    * 1 <= arrivali < leavingi <= 10^5
    * 0 <= targetFriend <= n - 1
    * Each arrivali time is distinct."""

    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:
        vals = []
        for i, (arrival, leaving) in enumerate(times):
            vals.append((arrival, 1, i))
            vals.append((leaving, 0, i))

        k = 0
        pq = [] # available seats
        mp = {} # player-to-seat mapping
        for _, arrival, i in sorted(vals):
            if arrival:
                if pq: s = heappop(pq)
                else:
                    s = k
                    k += 1
                if i == targetFriend: return s
                mp[i] = s
            else: heappush(pq, mp[i]) # new seat available


    """1943. Describe the Painting (Medium)
    There is a long and thin painting that can be represented by a number line.
    The painting was painted with multiple overlapping segments where each
    segment was painted with a unique color. You are given a 2D integer array
    segments, where segments[i] = [starti, endi, colori] represents the half-
    closed segment [starti, endi) with colori as the color. The colors in the
    overlapping segments of the painting were mixed when it was painted. When
    two or more colors mix, they form a new color that can be represented as a
    set of mixed colors.

    * For example, if colors 2, 4, and 6 are mixed, then the resulting mixed
      color is {2,4,6}.
    For the sake of simplicity, you should only output the sum of the elements
    in the set rather than the full set. You want to describe the painting with
    the minimum number of non-overlapping half-closed segments of these mixed
    colors. These segments can be represented by the 2D array painting where
    painting[j] = [leftj, rightj, mixj] describes a half-closed segment
    [leftj, rightj) with the mixed color sum of mixj.

    * For example, the painting created with segments = [[1,4,5],[1,7,7]] can
      be described by painting = [[1,4,12],[4,7,7]] because:
      + [1,4) is colored {5,7} (with a sum of 12) from both the first and
        second segments.
      + [4,7) is colored {7} from only the second segment.
    Return the 2D array painting describing the finished painting (excluding
    any parts that are not painted). You may return the segments in any order.
    A half-closed segment [a, b) is the section of the number line between
    points a and b including point a and not including point b.

    Example 1:
    Input: segments = [[1,4,5],[4,7,7],[1,7,9]]
    Output: [[1,4,14],[4,7,16]]
    Explanation: The painting can be described as follows:
                 - [1,4) is colored {5,9} (with a sum of 14) from the first and third segments.
                 - [4,7) is colored {7,9} (with a sum of 16) from the second and third segments.

    Example 2:
    Input: segments = [[1,7,9],[6,8,15],[8,10,7]]
    Output: [[1,6,9],[6,7,24],[7,8,15],[8,10,7]]
    Explanation: The painting can be described as follows:
                 - [1,6) is colored 9 from the first segment.
                 - [6,7) is colored {9,15} (with a sum of 24) from the first and second segments.
                 - [7,8) is colored 15 from the second segment.
                 - [8,10) is colored 7 from the third segment.

    Example 3:
    Input: segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]
    Output: [[1,4,12],[4,7,12]]
    Explanation: The painting can be described as follows:
                 - [1,4) is colored {5,7} (with a sum of 12) from the first and second segments.
                 - [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.
                 Note that returning a single segment [1,7) is incorrect
                 because the mixed color sets are different.

    Constraints:
    * 1 <= segments.length <= 2 * 10^4
    * segments[i].length == 3
    * 1 <= starti < endi <= 10^5
    * 1 <= colori <= 10^9
    * Each colori is distinct."""

    def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:
        vals = []
        for start, end, color in segments:
            vals.append((start, +color))
            vals.append((end, -color))

        ans = []
        prefix = prev = 0
        for x, c in sorted(vals):
            if prev < x and prefix: ans.append([prev, x, prefix])
            prev = x
            prefix += c
        return ans


    """1944. Number of Visible People in a Queue (Hard)
    There are n people standing in a queue, and they numbered from 0 to n - 1
    in left to right order. You are given an array heights of distinct integers
    where heights[i] represents the height of the ith person. A person can see
    another person to their right in the queue if everybody in between is
    shorter than both of them. More formally, the ith person can see the jth
    person if
    * i < j and
    * min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]).
    Return an array answer of length n where answer[i] is the number of people
    the ith person can see to their right in the queue.

    Example 1:
    Input: heights = [10,6,8,5,11,9]
    Output: [3,1,2,1,1,0]
    Explanation: Person 0 can see person 1, 2, and 4.
                 Person 1 can see person 2.
                 Person 2 can see person 3 and 4.
                 Person 3 can see person 4.
                 Person 4 can see person 5.
                 Person 5 can see no one since nobody is to the right of them.

    Example 2:
    Input: heights = [5,1,2,3,10]
    Output: [4,1,1,1,0]

    Constraints:
    * n == heights.length
    * 1 <= n <= 10^5
    * 1 <= heights[i] <= 10^5
    * All the values of heights are unique."""

    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        ans = [0]*len(heights)
        stack = [] # mono-stack
        for i in reversed(range(len(heights))):
            while stack and stack[-1] <= heights[i]:
                ans[i] += 1
                stack.pop()
            if stack: ans[i] += 1
            stack.append(heights[i])
        return ans


    """1945. Sum of Digits of String After Convert (Easy)
    You are given a string s consisting of lowercase English letters, and an
    integer k. First, convert s into an integer by replacing each letter with
    its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ...,
    'z' with 26). Then, transform the integer by replacing it with the sum of
    its digits. Repeat the transform operation k times in total. For example,
    if s = "zbax" and k = 2, then the resulting integer would be 8 by the
    following operations:
    * Convert: "zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124
    * Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
    * Transform #2: 17 ➝ 1 + 7 ➝ 8
    Return the resulting integer after performing the operations described
    above.

    Example 1:
    Input: s = "iiii", k = 1
    Output: 36
    Explanation: The operations are as follows:
                 - Convert: "iiii" ➝ "(9)(9)(9)(9)" ➝ "9999" ➝ 9999
                 - Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36
                 Thus the resulting integer is 36.

    Example 2:
    Input: s = "leetcode", k = 2
    Output: 6
    Explanation: The operations are as follows:
                 - Convert: "leetcode" ➝ "(12)(5)(5)(20)(3)(15)(4)(5)" ➝ "12552031545" ➝ 12552031545
                 - Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33
                 - Transform #2: 33 ➝ 3 + 3 ➝ 6
                 Thus the resulting integer is 6.

    Example 3:
    Input: s = "zbax", k = 2
    Output: 8

    Constraints:
    * 1 <= s.length <= 100
    * 1 <= k <= 10
    * s consists of lowercase English letters."""

    def getLucky(self, s: str, k: int) -> int:
        ans = 0
        for ch in s:
            q, r = divmod(ord(ch)-96, 10)
            ans += q + r
        for _ in range(k-1):
            ans = sum(map(int, str(ans)))
        return ans


    """1946. Largest Number After Mutating Substring (Medium)
    You are given a string num, which represents a large integer. You are also
    given a 0-indexed integer array change of length 10 that maps each digit
    0-9 to another digit. More formally, digit d maps to digit change[d]. You
    may choose to mutate any substring of num. To mutate a substring, replace
    each digit num[i] with the digit it maps to in change (i.e. replace num[i]
    with change[num[i]]). Return a string representing the largest possible
    integer after mutating (or choosing not to) any substring of num. A
    substring is a contiguous sequence of characters within the string.

    Example 1:
    Input: num = "132", change = [9,8,5,0,3,6,4,2,6,8]
    Output: "832"
    Explanation: Replace the substring "1":
                 - 1 maps to change[1] = 8.
                 Thus, "132" becomes "832". "832" is the largest number that
                 can be created, so return it.

    Example 2:
    Input: num = "021", change = [9,4,3,5,7,2,1,9,0,6]
    Output: "934"
    Explanation: Replace the substring "021":
                 - 0 maps to change[0] = 9.
                 - 2 maps to change[2] = 3.
                 - 1 maps to change[1] = 4.
                 Thus, "021" becomes "934". "934" is the largest number that
                 can be created, so return it.

    Example 3:
    Input: num = "5", change = [1,4,7,5,3,2,5,6,9,4]
    Output: "5"
    Explanation: "5" is already the largest number that can be created, so
                 return it.

    Constraints:
    * 1 <= num.length <= 10^5
    * num consists of only digits 0-9.
    * change.length == 10
    * 0 <= change[d] <= 9"""

    def maximumNumber(self, num: str, change: List[int]) -> str:
        num = list(num)
        on = False
        for i, ch in enumerate(num):
            x = int(ch)
            if x < change[x]:
                on = True
                num[i] = str(change[x])
            elif x > change[x] and on: break
        return "".join(num)


    """1947. Maximum Compatibility Score Sum (Medium)
    There is a survey that consists of n questions where each question's answer
    is either 0 (no) or 1 (yes). The survey was given to m students numbered
    from 0 to m - 1 and m mentors numbered from 0 to m - 1. The answers of the
    students are represented by a 2D integer array students where students[i]
    is an integer array that contains the answers of the ith student (0-indexed).
    The answers of the mentors are represented by a 2D integer array mentors
    where mentors[j] is an integer array that contains the answers of the jth
    mentor (0-indexed). Each student will be assigned to one mentor, and each
    mentor will have one student assigned to them. The compatibility score of a
    student-mentor pair is the number of answers that are the same for both the
    student and the mentor.

    * For example, if the student's answers were [1, 0, 1] and the mentor's
      answers were [0, 0, 1], then their compatibility score is 2 because only
      the second and the third answers are the same.
    You are tasked with finding the optimal student-mentor pairings to maximize
    the sum of the compatibility scores. Given students and mentors, return the
    maximum compatibility score sum that can be achieved.

    Example 1:
    Input: students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]
    Output: 8
    Explanation: We assign students to mentors in the following way:
                 - student 0 to mentor 2 with a compatibility score of 3.
                 - student 1 to mentor 0 with a compatibility score of 2.
                 - student 2 to mentor 1 with a compatibility score of 3.
                 The compatibility score sum is 3 + 2 + 3 = 8.

    Example 2:
    Input: students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]
    Output: 0
    Explanation: The compatibility score of any student-mentor pair is 0.

    Constraints:
    * m == students.length == mentors.length
    * n == students[i].length == mentors[j].length
    * 1 <= m, n <= 8
    * students[i][k] is either 0 or 1.
    * mentors[j][k] is either 0 or 1."""

    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
        m = len(students)

        score = [[0]*m for _ in range(m)]
        for i in range(m):
            for j in range(m):
                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))

        @cache
        def fn(mask, j):
            """Return max score of assigning students in mask to first j mentors."""
            ans = 0
            for i in range(m):
                if not mask & (1<<i):
                    ans = max(ans, fn(mask^(1<<i), j-1) + score[i][j])
            return ans

        return fn(1<<m, m-1)


    """1948. Delete Duplicate Folders in System (Hard)
    Due to a bug, there are many duplicate folders in a file system. You are
    given a 2D array paths, where paths[i] is an array representing an absolute
    path to the ith folder in the file system.

    * For example, ["one", "two", "three"] represents the path "/one/two/three".
    Two folders (not necessarily on the same level) are identical if they
    contain the same non-empty set of identical subfolders and underlying
    subfolder structure. The folders do not need to be at the root level to be
    identical. If two or more folders are identical, then mark the folders as
    well as all their subfolders.

    * For example, folders "/a" and "/b" in the file structure below are
      identical. They (as well as their subfolders) should all be marked:
      - /a
      - /a/x
      - /a/x/y
      - /a/z
      - /b
      - /b/x
      - /b/x/y
      - /b/z
    * However, if the file structure also included the path "/b/w", then the
      folders "/a" and "/b" would not be identical. Note that "/a/x" and "/b/x"
      would still be considered identical even with the added folder.
    Once all the identical folders and their subfolders have been marked, the
    file system will delete all of them. The file system only runs the deletion
    once, so any folders that become identical after the initial deletion are
    not deleted. Return the 2D array ans containing the paths of the remaining
    folders after deleting all the marked folders. The paths may be returned in
    any order.

    Example 1:
    Input: paths = [["a"],["c"],["d"],["a","b"],["c","b"],["d","a"]]
    Output: [["d"],["d","a"]]
    Explanation: Folders "/a" and "/c" (and their subfolders) are marked for
                 deletion because they both contain an empty folder named "b".

    Example 2:
    Input: paths = [["a"],["c"],["a","b"],["c","b"],["a","b","x"],["a","b","x","y"],["w"],["w","y"]]
    Output: [["c"],["c","b"],["a"],["a","b"]]
    Explanation: Folders "/a/b/x" and "/w" (and their subfolders) are marked
                 for deletion because they both contain an empty folder named
                 "y". Note that folders "/a" and "/c" are identical after the
                 deletion, but they are not deleted because they were not
                 marked beforehand.

    Example 3:
    Input: paths = [["a","b"],["c","d"],["c"],["a"]]
    Output: [["c"],["c","d"],["a"],["a","b"]]
    Explanation: All folders are unique in the file system. Note that the
                 returned array can be in a different order as the order does
                 not matter.

    Example 4:
    Input: paths = [["a"],["a","x"],["a","x","y"],["a","z"],["b"],["b","x"],["b","x","y"],["b","z"]]
    Output: []
    Explanation: Folders "/a/x" and "/b/x" (and their subfolders) are marked
                 for deletion because they both contain an empty folder named
                 "y". Folders "/a" and "/b" (and their subfolders) are marked
                 for deletion because they both contain an empty folder "z" and
                 the folder "x" described above.

    Example 5:
    Input: paths = [["a"],["a","x"],["a","x","y"],["a","z"],["b"],["b","x"],["b","x","y"],["b","z"],["b","w"]]
    Output: [["b"],["b","w"],["b","z"],["a"],["a","z"]]
    Explanation: This has the same structure as the previous example, except
                 with the added "/b/w". Folders "/a/x" and "/b/x" are still
                 marked, but "/a" and "/b" are no longer marked because "/b"
                 has the empty folder named "w" and "/a" does not. Note that
                 "/a/z" and "/b/z" are not marked because the set of identical
                 subfolders must be non-empty, but these folders are empty.

    Constraints:
    * 1 <= paths.length <= 2 * 10^4
    * 1 <= paths[i].length <= 500
    * 1 <= paths[i][j].length <= 10
    * 1 <= sum(paths[i][j].length) <= 2 * 10^5
    * path[i][j] consists of lowercase English letters.
    * No two paths lead to the same folder.
    * For any folder not at the root level, its parent folder will also be in the input."""

    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        paths.sort()

        tree = {"#": -1}
        for i, path in enumerate(paths):
            node = tree
            for x in path: node = node.setdefault(x, {})
            node["#"] = i

        seen = {}
        mark = set()

        def fn(n):
            """Return serialized value of sub-tree rooted at n."""
            if len(n) == 1: return "$" # leaf node
            vals = []
            for k in n:
                if k != "#": vals.append(f"${k}${fn(n[k])}")
            hs = "".join(vals)
            if hs in seen:
                mark.add(n["#"])
                mark.add(seen[hs])
            if hs != "$": seen[hs] = n["#"]
            return hs

        fn(tree)

        ans = []
        stack = [tree]
        while stack:
            n = stack.pop()
            if n["#"] >= 0: ans.append(paths[n["#"]])
            for k in n:
                if k != "#" and n[k]["#"] not in mark: stack.append(n[k])
        return ans


    """1950. Maximum of Minimum Values in All Subarrays (Medium)
    You are given an integer array nums of size n. You are asked to solve n
    queries for each integer i in the range 0 <= i < n. To solve the ith query:
    * Find the minimum value in each possible subarray of size i + 1 of the
      array nums.
    * Find the maximum of those minimum values. This maximum is the answer to
      the query.
    Return a 0-indexed integer array ans of size n such that ans[i] is the
    answer to the ith query. A subarray is a contiguous sequence of elements in
    an array.

    Example 1:
    Input: nums = [0,1,2,4]
    Output: [4,2,1,0]
    Explanation: i=0:
                 - The subarrays of size 1 are [0], [1], [2], [4]. The minimum values are 0, 1, 2, 4.
                 - The maximum of the minimum values is 4.
                 i=1:
                 - The subarrays of size 2 are [0,1], [1,2], [2,4]. The minimum values are 0, 1, 2.
                 - The maximum of the minimum values is 2.
                 i=2:
                 - The subarrays of size 3 are [0,1,2], [1,2,4]. The minimum values are 0, 1.
                 - The maximum of the minimum values is 1.
                 i=3:
                 - There is one subarray of size 4, which is [0,1,2,4]. The minimum value is 0.
                 - There is only one value, so the maximum is 0.

    Example 2:
    Input: nums = [10,20,50,10]
    Output: [50,20,10,10]
    Explanation: i=0:
                 - The subarrays of size 1 are [10], [20], [50], [10]. The minimum values are 10, 20, 50, 10.
                 - The maximum of the minimum values is 50.
                 i=1:
                 - The subarrays of size 2 are [10,20], [20,50], [50,10]. The minimum values are 10, 20, 10.
                 - The maximum of the minimum values is 20.
                 i=2:
                 - The subarrays of size 3 are [10,20,50], [20,50,10]. The minimum values are 10, 10.
                 - The maximum of the minimum values is 10.
                 i=3:
                 - There is one subarray of size 4, which is [10,20,50,10]. The minimum value is 10.
                 - There is only one value, so the maximum is 10.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 0 <= nums[i] <= 10^9"""

    def findMaximums(self, nums: List[int]) -> List[int]:
        ans = [0]*len(nums)
        stack = []
        for i, x in enumerate(nums + [0]):
            while stack and stack[-1][1] >= x:
                _, xx = stack.pop()
                k = i-stack[-1][0]-2 if stack else i-1
                ans[k] = max(ans[k], xx)
            stack.append((i, x))

        for i in reversed(range(len(nums)-1)):
            ans[i] = max(ans[i], ans[i+1])
        return ans


    """1952. Three Divisors (Easy)
    Given an integer n, return true if n has exactly three positive divisors.
    Otherwise, return false. An integer m is a divisor of n if there exists an
    integer k such that n = k * m.

    Example 1:
    Input: n = 2
    Output: false
    Explantion: 2 has only two divisors: 1 and 2.

    Example 2:
    Input: n = 4
    Output: true
    Explantion: 4 has three divisors: 1, 2, and 4.

    Constraints: 1 <= n <= 10^4"""

    def isThree(self, n: int) -> bool:
        if n == 1: return False # edge case

        x = int(sqrt(n))
        if x*x != n: return False

        for i in range(2, int(sqrt(x))+1):
            if x % i == 0: return False
        return True


    """1953. Maximum Number of Weeks for Which You Can Work (Medium)
    There are n projects numbered from 0 to n - 1. You are given an integer
    array milestones where each milestones[i] denotes the number of milestones
    the ith project has. You can work on the projects following these two rules:
    * Every week, you will finish exactly one milestone of one project. You
      must work every week.
    * You cannot work on two milestones from the same project for two
      consecutive weeks.
    Once all the milestones of all the projects are finished, or if the only
    milestones that you can work on will cause you to violate the above rules,
    you will stop working. Note that you may not be able to finish every
    project's milestones due to these constraints. Return the maximum number of
    weeks you would be able to work on the projects without violating the rules
    mentioned above.

    Example 1:
    Input: milestones = [1,2,3]
    Output: 6
    Explanation: One possible scenario is:
                 - During the 1st week, you will work on a milestone of project 0.
                 - During the 2nd week, you will work on a milestone of project 2.
                 - During the 3rd week, you will work on a milestone of project 1.
                 - During the 4th week, you will work on a milestone of project 2.
                 - During the 5th week, you will work on a milestone of project 1.
                 - During the 6th week, you will work on a milestone of project 2.
                 The total number of weeks is 6.

    Example 2:
    Input: milestones = [5,2,1]
    Output: 7
    Explanation: One possible scenario is:
                 - During the 1st week, you will work on a milestone of project 0.
                 - During the 2nd week, you will work on a milestone of project 1.
                 - During the 3rd week, you will work on a milestone of project 0.
                 - During the 4th week, you will work on a milestone of project 1.
                 - During the 5th week, you will work on a milestone of project 0.
                 - During the 6th week, you will work on a milestone of project 2.
                 - During the 7th week, you will work on a milestone of project 0.
                 The total number of weeks is 7. Note that you cannot work on
                 the last milestone of project 0 on 8th week because it would
                 violate the rules. Thus, one milestone in project 0 will
                 remain unfinished.

    Constraints:
    * n == milestones.length
    * 1 <= n <= 10^5
    * 1 <= milestones[i] <= 10^9"""

    def numberOfWeeks(self, milestones: List[int]) -> int:
        m, s = max(milestones), sum(milestones)
        return s - max(0, 2*m - s - 1)


    """1954. Minimum Garden Perimeter to Collect Enough Apples (Medium)
    In a garden represented as an infinite 2D grid, there is an apple tree
    planted at every integer coordinate. The apple tree planted at an integer
    coordinate (i, j) has |i| + |j| apples growing on it. You will buy an axis-
    aligned square plot of land that is centered at (0, 0). Given an integer
    neededApples, return the minimum perimeter of a plot such that at least
    neededApples apples are inside or on the perimeter of that plot.

    The value of |x| is defined as:
    * x if x >= 0
    * -x if x < 0

    Example 1:
    Input: neededApples = 1
    Output: 8
    Explanation: A square plot of side length 1 does not contain any apples.
                 However, a square plot of side length 2 has 12 apples inside
                 (as depicted in the image above). The perimeter is 2 * 4 = 8.

    Example 2:
    Input: neededApples = 13
    Output: 16

    Example 3:
    Input: neededApples = 1000000000
    Output: 5040

    Constraints: 1 <= neededApples <= 10^15"""

    def minimumPerimeter(self, neededApples: int) -> int:
        lo, hi = 0, 10**5
        while lo < hi:
            mid = lo + hi >> 1
            if 2*mid*(mid+1)*(2*mid+1) < neededApples: lo = mid + 1
            else: hi = mid
        return 8*lo


    """1955. Count Number of Special Subsequences (Hard)
    A sequence is special if it consists of a positive number of 0s, followed
    by a positive number of 1s, then a positive number of 2s.
    * For example, [0,1,2] and [0,0,1,1,1,2] are special.
    * In contrast, [2,1,0], [1], and [0,1,2,0] are not special.
    Given an array nums (consisting of only integers 0, 1, and 2), return the
    number of different subsequences that are special. Since the answer may be
    very large, return it modulo 10^9 + 7. A subsequence of an array is a
    sequence that can be derived from the array by deleting some or no elements
    without changing the order of the remaining elements. Two subsequences are
    different if the set of indices chosen are different.

    Example 1:
    Input: nums = [0,1,2,2]
    Output: 3
    Explanation: The special subsequences are [0,1,2,2], [0,1,2,2], and
                 [0,1,2,2].

    Example 2:
    Input: nums = [2,2,0,0]
    Output: 0
    Explanation: There are no special subsequences in [2,2,0,0].

    Example 3:
    Input: nums = [0,1,2,0,1,2]
    Output: 7
    Explanation: The special subsequences are:
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]
                 - [0,1,2,0,1,2]

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 2"""

    def countSpecialSubsequences(self, nums: List[int]) -> int:
        MOD = 1_000_000_007
        s0 = s1 = s2 = 0
        for x in nums:
            if x == 0: s0 = (1 + 2*s0) % MOD
            elif x == 1: s1 = (s0 + 2*s1) % MOD
            else: s2 = (s1 + 2*s2) % MOD
        return s2


    """1956. Minimum Time For K Virus Variants to Spread (Hard)
    There are n unique virus variants in an infinite 2D grid. You are given a
    2D array points, where points[i] = [xi, yi] represents a virus originating
    at (xi, yi) on day 0. Note that it is possible for multiple virus variants
    to originate at the same point. Every day, each cell infected with a virus
    variant will spread the virus to all neighboring points in the four
    cardinal directions (i.e. up, down, left, and right). If a cell has
    multiple variants, all the variants will spread without interfering with
    each other. Given an integer k, return the minimum integer number of days
    for any point to contain at least k of the unique virus variants.

    Example 1:
    Input: points = [[1,1],[6,1]], k = 2
    Output: 3
    Explanation: On day 3, points (3,1) and (4,1) will contain both virus
                 variants. Note that these are not the only points that will
                 contain both virus variants.

    Example 2:
    Input: points = [[3,3],[1,2],[9,2]], k = 2
    Output: 2
    Explanation: On day 2, points (1,3), (2,3), (2,2), and (3,2) will contain
                 the first two viruses. Note that these are not the only points
                 that will contain both virus variants.

    Example 3:
    Input: points = [[3,3],[1,2],[9,2]], k = 3
    Output: 4
    Explanation: On day 4, the point (5,2) will contain all 3 viruses. Note
                 that this is not the only point that will contain all 3 virus
                 variants.

    Constraints:
    * n == points.length
    * 2 <= n <= 50
    * points[i].length == 2
    * 1 <= xi, yi <= 100
    * 2 <= k <= n"""

    def minDayskVariants(self, points: List[List[int]], k: int) -> int:

        def fn(day):
            lines = defaultdict(lambda : defaultdict(int))
            for x, y in points:
                lines[x+y-day][y-x+day] += 0
                lines[x+y+day][y-x-day] += 0
                lines[x+y+day][y-x+day] += 0
                lines[x+y-day][y-x-day] += 1
                lines[x+y-day][y-x+day+1] -= 1
                lines[x+y+day+1][y-x-day] -= 1
                lines[x+y+day+1][y-x+day+1] += 1
            line = defaultdict(int)
            for xx in sorted(lines):
                for yy, vv in lines[xx].items():
                    line[yy] += vv
                prefix = 0
                for yy in sorted(line):
                    prefix += line[yy]
                    if prefix >= k and ((xx - yy)%2 == 0 or xx+1 not in lines or prefix+line[yy+1] >= k): return True
            return False

        lo, hi = 0, 1_000_000_000
        while lo < hi:
            mid = (lo + hi) // 2
            if fn(mid): hi = mid
            else: lo = mid + 1
        return lo


    """1957. Delete Characters to Make Fancy String (Easy)
    A fancy string is a string where no three consecutive characters are equal.
    Given a string s, delete the minimum possible number of characters from s
    to make it fancy. Return the final string after the deletion. It can be
    shown that the answer will always be unique.

    Example 1:
    Input: s = "leeetcode"
    Output: "leetcode"
    Explanation: Remove an 'e' from the first group of 'e's to create
                 "leetcode". No three consecutive characters are equal, so
                 return "leetcode".

    Example 2:
    Input: s = "aaabaaaa"
    Output: "aabaa"
    Explanation: Remove an 'a' from the first group of 'a's to create "aabaaaa".
                 Remove two 'a's from the second group of 'a's to create "aabaa".
                 No three consecutive characters are equal, so return "aabaa".

    Example 3:
    Input: s = "aab"
    Output: "aab"
    Explanation: No three consecutive characters are equal, so return "aab".

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters."""

    def makeFancyString(self, s: str) -> str:
        stack = []
        for ch in s:
            if len(stack) > 1 and stack[-2] == stack[-1] == ch: continue
            stack.append(ch)
        return "".join(stack)


    """1958. Check if Move is Legal (Medium)
    You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents
    the cell (r, c) on a game board. On the board, free cells are represented
    by '.', white cells are represented by 'W', and black cells are represented
    by 'B'. Each move in this game consists of choosing a free cell and
    changing it to the color you are playing as (either white or black).
    However, a move is only legal if, after changing it, the cell becomes the
    endpoint of a good line (horizontal, vertical, or diagonal). A good line is
    a line of three or more cells (including the endpoints) where the endpoints
    of the line are one color, and the remaining cells in the middle are the
    opposite color (no cells in the line are free). Given two integers rMove
    and cMove and a character color representing the color you are playing as
    (white or black), return true if changing cell (rMove, cMove) to color
    color is a legal move, or false if it is not legal.

    Example 1:
    Input: board = [[".",".",".","B",".",".",".","."],
                    [".",".",".","W",".",".",".","."],
                    [".",".",".","W",".",".",".","."],
                    [".",".",".","W",".",".",".","."],
                    ["W","B","B",".","W","W","W","B"],
                    [".",".",".","B",".",".",".","."],
                    [".",".",".","B",".",".",".","."],
                    [".",".",".","W",".",".",".","."]],
           rMove = 4, cMove = 3, color = "B"
    Output: true
    Explanation: '.', 'W', and 'B' are represented by the colors blue, white,
                 and black respectively, and cell (rMove, cMove) is marked with
                 an 'X'. The two good lines with the chosen cell as an endpoint
                 are annotated above with the red rectangles.

    Example 2:
    Input: board = [[".",".",".",".",".",".",".","."],
                    [".","B",".",".","W",".",".","."],
                    [".",".","W",".",".",".",".","."],
                    [".",".",".","W","B",".",".","."],
                    [".",".",".",".",".",".",".","."],
                    [".",".",".",".","B","W",".","."],
                    [".",".",".",".",".",".","W","."],
                    [".",".",".",".",".",".",".","B"]],
           rMove = 4, cMove = 4, color = "W"
    Output: false
    Explanation: While there are good lines with the chosen cell as a middle
                 cell, there are no good lines with the chosen cell as an
                 endpoint.

    Constraints:
    * board.length == board[r].length == 8
    * 0 <= rMove, cMove < 8
    * board[rMove][cMove] == '.'
    * color is either 'B' or 'W'."""

    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:
        for di, dj in (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1):
            i, j = rMove+di, cMove+dj
            step = 0
            while 0 <= i < 8 and 0 <= j < 8:
                if board[i][j] == color and step: return True
                if board[i][j] == "." or board[i][j] == color and not step: break
                i, j = i+di, j+dj
                step += 1
        return False


    """1959. Minimum Total Space Wasted With K Resizing Operations (Medium)
    You are currently designing a dynamic array. You are given a 0-indexed
    integer array nums, where nums[i] is the number of elements that will be in
    the array at time i. In addition, you are given an integer k, the maximum
    number of times you can resize the array (to any size). The size of the
    array at time t, sizet, must be at least nums[t] because there needs to be
    enough space in the array to hold all the elements. The space wasted at
    time t is defined as sizet - nums[t], and the total space wasted is the sum
    of the space wasted across every time t where 0 <= t < nums.length. Return
    the minimum total space wasted if you can resize the array at most k times.
    Note: The array can have any size at the start and does not count towards
    the number of resizing operations.

    Example 1:
    Input: nums = [10,20], k = 0
    Output: 10
    Explanation: size = [20,20]. We can set the initial size to be 20. The
                 total wasted space is (20 - 10) + (20 - 20) = 10.

    Example 2:
    Input: nums = [10,20,30], k = 1
    Output: 10
    Explanation: size = [20,20,30]. We can set the initial size to be 20 and
                 resize to 30 at time 2. The total wasted space is
                 (20 - 10) + (20 - 20) + (30 - 30) = 10.

    Example 3:
    Input: nums = [10,20,15,30,20], k = 2
    Output: 15
    Explanation: size = [10,20,20,30,30]. We can set the initial size to 10,
                 resize to 20 at time 1, and resize to 30 at time 3. The total
                 wasted space is
                 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15.

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= 10^6
    * 0 <= k <= nums.length - 1"""

    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:

        @cache
        def fn(i, k):
            """Return min waste from i with k ops."""
            if i == len(nums): return 0
            if k < 0: return inf
            ans = inf
            rmx = -inf # range max
            rsm = 0 # range sum
            for j in range(i, len(nums)):
                rmx = max(rmx, nums[j])
                rsm += nums[j]
                ans = min(ans, rmx*(j-i+1) - rsm + fn(j+1, k-1))
            return ans

        return fn(0, k)


    """1960. Maximum Product of the Length of Two Palindromic Substrings (Hard)
    You are given a 0-indexed string s and are tasked with finding two non-
    intersecting palindromic substrings of odd length such that the product of
    their lengths is maximized. More formally, you want to choose four integers
    i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the
    substrings s[i...j] and s[k...l] are palindromes and have odd lengths.
    s[i...j] denotes a substring from index i to index j inclusive. Return the
    maximum possible product of the lengths of the two non-intersecting
    palindromic substrings. A palindrome is a string that is the same forward
    and backward. A substring is a contiguous sequence of characters in a
    string.

    Example 1:
    Input: s = "ababbb"
    Output: 9
    Explanation: Substrings "aba" and "bbb" are palindromes with odd length.
                 product = 3 * 3 = 9.

    Example 2:
    Input: s = "zaaaxbbby"
    Output: 9
    Explanation: Substrings "aaa" and "bbb" are palindromes with odd length.
                 product = 3 * 3 = 9.

    Constraints:
    * 2 <= s.length <= 10^5
    * s consists of lowercase English letters."""

    def maxProduct(self, s: str) -> int:
        n = len(s)

        # Manacher's algo
        hlen = [0]*n # half-length
        center = right = 0
        for i in range(n):
            if i < right: hlen[i] = min(right - i, hlen[2*center - i])
            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]:
                hlen[i] += 1
            if right < i+hlen[i]: center, right = i, i+hlen[i]

        prefix = [0]*n
        suffix = [0]*n
        for i in range(n):
            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)
            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)

        for i in range(1, n):
            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)
            suffix[i] = max(suffix[i], suffix[i-1]-2)

        for i in range(1, n):
            prefix[i] = max(prefix[i-1], prefix[i])
            suffix[~i] = max(suffix[~i], suffix[~i+1])

        return max(prefix[i-1]*suffix[i] for i in range(1, n))


    """1961. Check If String Is a Prefix of Array (Easy)
    Given a string s and an array of strings words, determine whether s is a
    prefix string of words. A string s is a prefix string of words if s can be
    made by concatenating the first k strings in words for some positive k no
    larger than words.length. Return true if s is a prefix string of words, or
    false otherwise.

    Example 1:
    Input: s = "iloveleetcode", words = ["i","love","leetcode","apples"]
    Output: true
    Explanation: s can be made by concatenating "i", "love", and "leetcode"
                 together.

    Example 2:
    Input: s = "iloveleetcode", words = ["apples","i","love","leetcode"]
    Output: false
    Explanation: It is impossible to make s using a prefix of arr.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 20
    * 1 <= s.length <= 1000
    * words[i] and s consist of only lowercase English letters."""

    def isPrefixString(self, s: str, words: List[str]) -> bool:
        i = 0
        for word in words:
            if s[i:i+len(word)] != word: return False
            i += len(word)
            if i == len(s): return True
        return False


    """1962. Remove Stones to Minimize the Total (Medium)
    You are given a 0-indexed integer array piles, where piles[i] represents
    the number of stones in the ith pile, and an integer k. You should apply
    the following operation exactly k times:
    * Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
    Notice that you can apply the operation on the same pile more than once.
    Return the minimum possible total number of stones remaining after applying
    the k operations. floor(x) is the greatest integer that is smaller than or
    equal to x (i.e., rounds x down).

    Example 1:
    Input: piles = [5,4,9], k = 2
    Output: 12
    Explanation: Steps of a possible scenario are:
                 - Apply the operation on pile 2. The resulting piles are [5,4,5].
                 - Apply the operation on pile 0. The resulting piles are [3,4,5].
                 The total number of stones in [3,4,5] is 12.

    Example 2:
    Input: piles = [4,3,6,7], k = 3
    Output: 12
    Explanation: Steps of a possible scenario are:
                 - Apply the operation on pile 3. The resulting piles are [4,3,3,7].
                 - Apply the operation on pile 4. The resulting piles are [4,3,3,4].
                 - Apply the operation on pile 0. The resulting piles are [2,3,3,4].
                 The total number of stones in [2,3,3,4] is 12.

    Constraints:
    * 1 <= piles.length <= 10^5
    * 1 <= piles[i] <= 10^4
    * 1 <= k <= 10^5"""

    def minStoneSum(self, piles: List[int], k: int) -> int:
        pq = [-x for x in piles]
        heapify(pq)
        for _ in range(k): heapreplace(pq, pq[0]//2)
        return -sum(pq)


    """1963. Minimum Number of Swaps to Make the String Balanced (Medium)
    You are given a 0-indexed string s of even length n. The string consists of
    exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'. A string
    is called balanced if and only if:
    * It is the empty string, or
    * It can be written as AB, where both A and B are balanced strings, or
    * It can be written as [C], where C is a balanced string.
    You may swap the brackets at any two indices any number of times. Return
    the minimum number of swaps to make s balanced.

    Example 1:
    Input: s = "][]["
    Output: 1
    Explanation: You can make the string balanced by swapping index 0 with
                 index 3. The resulting string is "[[]]".

    Example 2:
    Input: s = "]]][[["
    Output: 2
    Explanation: You can do the following to make the string balanced:
                 - Swap index 0 with index 4. s = "[]][[]".
                 - Swap index 1 with index 5. s = "[[][]]".
                 The resulting string is "[[][]]".

    Example 3:
    Input: s = "[]"
    Output: 0
    Explanation: The string is already balanced.

    Constraints:
    * n == s.length
    * 2 <= n <= 10^6
    * n is even.
    * s[i] is either '[' or ']'.
    * The number of opening brackets '[' equals n / 2, and the number of
      closing brackets ']' equals n / 2."""

    def minSwaps(self, s: str) -> int:
        ans = prefix = 0
        for ch in s:
            if ch == "[": prefix += 1
            else: prefix -= 1
            if prefix == -1:
                ans += 1
                prefix = 1
        return ans


    """1964. Find the Longest Valid Obstacle Course at Each Position (Hard)
    You want to build some obstacle courses. You are given a 0-indexed integer
    array obstacles of length n, where obstacles[i] describes the height of the
    ith obstacle. For every index i between 0 and n - 1 (inclusive), find the
    length of the longest obstacle course in obstacles such that:
    * You choose any number of obstacles between 0 and i inclusive.
    * You must include the ith obstacle in the course.
    * You must put the chosen obstacles in the same order as they appear in
      obstacles.
    * Every obstacle (except the first) is taller than or the same height as
      the obstacle immediately before it.
    Return an array ans of length n, where ans[i] is the length of the longest
    obstacle course for index i as described above.

    Example 1:
    Input: obstacles = [1,2,3,2]
    Output: [1,2,3,3]
    Explanation: The longest valid obstacle course at each position is:
                 - i = 0: [1], [1] has length 1.
                 - i = 1: [1,2], [1,2] has length 2.
                 - i = 2: [1,2,3], [1,2,3] has length 3.
                 - i = 3: [1,2,3,2], [1,2,2] has length 3.

    Example 2:
    Input: obstacles = [2,2,1]
    Output: [1,2,1]
    Explanation: The longest valid obstacle course at each position is:
                 - i = 0: [2], [2] has length 1.
                 - i = 1: [2,2], [2,2] has length 2.
                 - i = 2: [2,2,1], [1] has length 1.

    Example 3:
    Input: obstacles = [3,1,5,6,4,2]
    Output: [1,1,2,3,2,2]
    Explanation: The longest valid obstacle course at each position is:
                 - i = 0: [3], [3] has length 1.
                 - i = 1: [3,1], [1] has length 1.
                 - i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.
                 - i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.
                 - i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.
                 - i = 5: [3,1,5,6,4,2], [1,2] has length 2.

    Constraints:
    * n == obstacles.length
    * 1 <= n <= 10^5
    * 1 <= obstacles[i] <= 10^7"""

    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        ans, vals = [], []
        for i, x in enumerate(obstacles):
            k = bisect_right(vals, x)
            ans.append(k+1)
            if k == len(vals): vals.append(x)
            else: vals[k] = x
        return ans


    """1966. Binary Searchable Numbers in an Unsorted Array (Medium)
    Consider a function that implements an algorithm similar to Binary Search.
    The function has two input parameters: sequence is a sequence of integers,
    and target is an integer value. The purpose of the function is to find if
    the target exists in the sequence. The pseudocode of the function is as
    follows:

    func(sequence, target)
      while sequence is not empty
        randomly choose an element from sequence as the pivot
        if pivot = target, return true
        else if pivot < target, remove pivot and all elements to its left from the sequence
        else, remove pivot and all elements to its right from the sequence
      end while
      return false

    When the sequence is sorted, the function works correctly for all values.
    When the sequence is not sorted, the function does not work for all values,
    but may still work for some values. Given an integer array nums,
    representing the sequence, that contains unique numbers and may or may not
    be sorted, return the number of values that are guaranteed to be found
    using the function, for every possible pivot selection.

    Example 1:
    Input: nums = [7]
    Output: 1
    Explanation: Searching for value 7 is guaranteed to be found. Since the
                 sequence has only one element, 7 will be chosen as the pivot.
                 Because the pivot equals the target, the function will return
                 true.

    Example 2:
    Input: nums = [-1,5,2]
    Output: 1
    Explanation: Searching for value -1 is guaranteed to be found. If -1 was
                 chosen as the pivot, the function would return true. If 5 was
                 chosen as the pivot, 5 and 2 would be removed. In the next
                 loop, the sequence would have only -1 and the function would
                 return true. If 2 was chosen as the pivot, 2 would be removed.
                 In the next loop, the sequence would have -1 and 5. No matter
                 which number was chosen as the next pivot, the function would
                 find -1 and return true. Searching for value 5 is NOT
                 guaranteed to be found. If 2 was chosen as the pivot, -1, 5
                 and 2 would be removed. The sequence would be empty and the
                 function would return false. Searching for value 2 is NOT
                 guaranteed to be found. If 5 was chosen as the pivot, 5 and 2
                 would be removed. In the next loop, the sequence would have
                 only -1 and the function would return false. Because only -1
                 is guaranteed to be found, you should return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^5 <= nums[i] <= 10^5
    * All the values of nums are unique.

    Follow-up: If nums has duplicates, would you modify your algorithm? If so,
               how?"""

    def binarySearchableNumbers(self, nums: List[int]) -> int:
        suffix = [inf]
        for x in reversed(nums): suffix.append(min(suffix[-1], x))
        suffix = suffix[::-1]

        ans = 0
        prefix = -inf
        for i, x in enumerate(nums):
            prefix = max(prefix, x)
            if prefix == x == suffix[i]: ans += 1
        return ans


    """1967. Number of Strings That Appear as Substrings in Word (Easy)
    Given an array of strings patterns and a string word, return the number of
    strings in patterns that exist as a substring in word. A substring is a
    contiguous sequence of characters within a string.

    Example 1:
    Input: patterns = ["a","abc","bc","d"], word = "abc"
    Output: 3
    Explanation: - "a" appears as a substring in "abc".
                 - "abc" appears as a substring in "abc".
                 - "bc" appears as a substring in "abc".
                 - "d" does not appear as a substring in "abc".
                 3 of the strings in patterns appear as a substring in word.

    Example 2:
    Input: patterns = ["a","b","c"], word = "aaaaabbbbb"
    Output: 2
    Explanation: - "a" appears as a substring in "aaaaabbbbb".
                 - "b" appears as a substring in "aaaaabbbbb".
                 - "c" does not appear as a substring in "aaaaabbbbb".
                 2 of the strings in patterns appear as a substring in word.

    Example 3:
    Input: patterns = ["a","a","a"], word = "ab"
    Output: 3
    Explanation: Each of the patterns appears as a substring in word "ab".

    Constraints:
    * 1 <= patterns.length <= 100
    * 1 <= patterns[i].length <= 100
    * 1 <= word.length <= 100
    * patterns[i] and word consist of lowercase English letters."""

    def numOfStrings(self, patterns: List[str], word: str) -> int:
        return sum(x in word for x in patterns)


    """1968. Array With Elements Not Equal to Average of Neighbors (Medium)
    You are given a 0-indexed array nums of distinct integers. You want to
    rearrange the elements in the array such that every element in the
    rearranged array is not equal to the average of its neighbors. More
    formally, the rearranged array should have the property such that for every
    i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not
    equal to nums[i]. Return any rearrangement of nums that meets the
    requirements.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: [1,2,4,5,3]
    Explanation:
    When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.
    When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.
    When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.

    Example 2:
    Input: nums = [6,2,0,9,7]
    Output: [9,7,6,2,0]
    Explanation:
    When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.
    When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.
    When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5"""

    def rearrangeArray(self, nums: List[int]) -> List[int]:
        for i in range(1, len(nums)-1):
            if nums[i-1] < nums[i] < nums[i+1] or nums[i-1] > nums[i] > nums[i+1]:
                nums[i], nums[i+1] = nums[i+1], nums[i]
        return nums


    """1969. Minimum Non-Zero Product of the Array Elements (Medium)
    You are given a positive integer p. Consider an array nums (1-indexed) that
    consists of the integers in the inclusive range [1, 2p - 1] in their binary
    representations. You are allowed to do the following operation any number
    of times:
    * Choose two elements x and y from nums.
    * Choose a bit in x and swap it with its corresponding bit in y.
      Corresponding bit refers to the bit that is in the same position in the
      other integer.
    For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the
    right, we have x = 1111 and y = 0001. Find the minimum non-zero product of
    nums after performing the above operation any number of times. Return this
    product modulo 10^9 + 7. Note: The answer should be the minimum product
    before the modulo operation is done.

    Example 1:
    Input: p = 1
    Output: 1
    Explanation: nums = [1]. There is only one element, so the product equals
                 that element.

    Example 2:
    Input: p = 2
    Output: 6
    Explanation: nums = [01, 10, 11]. Any swap would either make the product 0
                 or stay the same. Thus, the array product of 1 * 2 * 3 = 6 is
                 already minimized.

    Example 3:
    Input: p = 3
    Output: 1512
    Explanation: nums = [001, 010, 011, 100, 101, 110, 111]
                 - In the first operation we can swap the leftmost bit of the second and fifth elements.
                     - The resulting array is [001, 110, 011, 100, 001, 110, 111].
                 - In the second operation we can swap the middle bit of the third and fourth elements.
                     - The resulting array is [001, 110, 001, 110, 001, 110, 111].
                 The array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512, which is the minimum possible product.

    Constraints: 1 <= p <= 60"""

    def minNonZeroProduct(self, p: int) -> int:
        x = (1 << p) - 1
        return pow(x-1, (x-1)//2, 1_000_000_007) * x % 1_000_000_007


    """1970. Last Day Where You Can Still Cross (Hard)
    There is a 1-based binary matrix where 0 represents land and 1 represents
    water. You are given integers row and col representing the number of rows
    and columns in the matrix, respectively. Initially on day 0, the entire
    matrix is land. However, each day a new cell becomes flooded with water.
    You are given a 1-based 2D array cells, where cells[i] = [ri, ci]
    represents that on the ith day, the cell on the rith row and cith column
    (1-based coordinates) will be covered with water (i.e., changed to 1).You
    want to find the last day that it is possible to walk from the top to the
    bottom by only walking on land cells. You can start from any cell in the
    top row and end at any cell in the bottom row. You can only travel in the
    four cardinal directions (left, right, up, and down). Return the last day
    where it is possible to walk from the top to the bottom by only walking on
    land cells.

    Example 1:
    Input: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
    Output: 2
    Explanation: The above image depicts how the matrix changes each day
                 starting from day 0. The last day where it is possible to
                 cross from top to bottom is on day 2.

    Example 2:
    Input: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
    Output: 1
    Explanation: The above image depicts how the matrix changes each day
                 starting from day 0. The last day where it is possible to
                 cross from top to bottom is on day 1.

    Example 3:
    Input: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
    Output: 3
    Explanation: The above image depicts how the matrix changes each day
                 starting from day 0. The last day where it is possible to
                 cross from top to bottom is on day 3.

    Constraints:
    * 2 <= row, col <= 2 * 10^4
    * 4 <= row * col <= 2 * 10^4
    * cells.length == row * col
    * 1 <= ri <= row
    * 1 <= ci <= col
    * All the values of cells are unique."""

    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        grid = [[0]*col for _ in range(row)]

        n = row * col
        uf = UnionFind(n)
        span = [[n, 0] for _ in range(n)]

        for step, (i, j) in enumerate(cells):
            i, j = i-1, j-1
            grid[i][j] = 1
            x = i*col + j
            for ii, jj in (i-1, j-1), (i-1, j), (i-1, j+1), (i, j-1), (i, j+1), (i+1, j-1), (i+1, j), (i+1, j+1):
                if 0 <= ii < row and 0 <= jj < col and grid[ii][jj]:
                    xx = ii*col + jj
                    r, rr = uf.find(x), uf.find(xx)
                    span[r][0] = span[rr][0] = min(span[r][0], span[rr][0], j, jj)
                    span[r][1] = span[rr][1] = max(span[r][1], span[rr][1], j, jj)
                    if span[r] == [0, col-1]: return step
                    uf.union(x, xx)


    """1971. Find if Path Exists in Graph (Easy)
    There is a bi-directional graph with n vertices, where each vertex is
    labeled from 0 to n - 1 (inclusive). The edges in the graph are represented
    as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a
    bi-directional edge between vertex ui and vertex vi. Every vertex pair is
    connected by at most one edge, and no vertex has an edge to itself. You
    want to determine if there is a valid path that exists from vertex start to
    vertex end. Given edges and the integers n, start, and end, return true if
    there is a valid path from start to end, or false otherwise.

    Example 1:
    Input: n = 3, edges = [[0,1],[1,2],[2,0]], start = 0, end = 2
    Output: true
    Explanation: There are two paths from vertex 0 to vertex 2:
                 - 0 → 1 → 2
                 - 0 → 2

    Example 2:
    Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], start = 0, end = 5
    Output: false
    Explanation: There is no path from vertex 0 to vertex 5.

    Constraints:
    * 1 <= n <= 2 * 10^5
    * 0 <= edges.length <= 2 * 10^5
    * edges[i].length == 2
    * 1 <= ui, vi <= n - 1
    * ui != vi
    * 1 <= start, end <= n - 1
    * There are no duplicate edges.
    * There are no self edges."""

    class Solution:
        def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
            graph = [[] for _ in range(n)]
            for u, v in edges:
                graph[u].append(v)
                graph[v].append(u)
            seen = [False]*n
            seen[source] = True
            stack = [source]
            while stack:
                u = stack.pop()
                if u == destination: return True
                for v in graph[u]:
                    if not seen[v]:
                        seen[v] = True
                        stack.append(v)
            return False


    """1973. Count Nodes Equal to Sum of Descendants (Medium)
    Given the root of a binary tree, return the number of nodes where the value
    of the node is equal to the sum of the values of its descendants. A
    descendant of a node x is any node that is on the path from node x to some
    leaf node. The sum is considered to be 0 if the node has no descendants.

    Example 1:
    Input: root = [10,3,4,2,1]
    Output: 2
    Explanation: For the node with value 10: The sum of its descendants is
                 3+4+2+1 = 10. For the node with value 3: The sum of its
                 descendants is 2+1 = 3.

    Example 2:
    Input: root = [2,3,null,2,null]
    Output: 0
    Explanation: No node has a value that is equal to the sum of its descendants.

    Example 3:
    Input: root = [0]
    Output: 1
    Explanation: For the node with value 0: The sum of its descendants is 0
                 since it has no descendants.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 0 <= Node.val <= 10^5"""

    def equalToDescendants(self, root: Optional[TreeNode]) -> int:

        def fn(node):
            """Return sum of nodes' value on sub-tree."""
            nonlocal ans
            if not node: return 0
            sm = fn(node.left) + fn(node.right)
            if sm == node.val: ans += 1
            return sm + node.val

        ans = 0
        fn(root)
        return ans


    """1974. Minimum Time to Type Word Using Special Typewriter (Easy)
    There is a special typewriter with lowercase English letters 'a' to 'z'
    arranged in a circle with a pointer. A character can only be typed if the
    pointer is pointing to that character. The pointer is initially pointing to
    the character 'a'. Each second, you may perform one of the following
    operations:
    * Move the pointer one character counterclockwise or clockwise.
    * Type the character the pointer is currently on.
    Given a string word, return the minimum number of seconds to type out the
    characters in word.

    Example 1:
    Input: word = "abc"
    Output: 5
    Explanation: The characters are printed as follows:
                 - Type the character 'a' in 1 second since the pointer is
                   initially on 'a'.
                 - Move the pointer clockwise to 'b' in 1 second.
                 - Type the character 'b' in 1 second.
                 - Move the pointer clockwise to 'c' in 1 second.
                 - Type the character 'c' in 1 second.

    Example 2:
    Input: word = "bza"
    Output: 7
    Explanation: The characters are printed as follows:
                 - Move the pointer clockwise to 'b' in 1 second.
                 - Type the character 'b' in 1 second.
                 - Move the pointer counterclockwise to 'z' in 2 seconds.
                 - Type the character 'z' in 1 second.
                 - Move the pointer clockwise to 'a' in 1 second.
                 - Type the character 'a' in 1 second.

    Example 3:
    Input: word = "zjpc"
    Output: 34
    Explanation: The characters are printed as follows:
                 - Move the pointer counterclockwise to 'z' in 1 second.
                 - Type the character 'z' in 1 second.
                 - Move the pointer clockwise to 'j' in 10 seconds.
                 - Type the character 'j' in 1 second.
                 - Move the pointer clockwise to 'p' in 6 seconds.
                 - Type the character 'p' in 1 second.
                 - Move the pointer counterclockwise to 'c' in 13 seconds.
                 - Type the character 'c' in 1 second.

    Constraints:
    * 1 <= word.length <= 100
    * word consists of lowercase English letters."""

    def minTimeToType(self, word: str) -> int:
        ans = len(word)
        prev = "a"
        for ch in word:
            val = (ord(ch) - ord(prev)) % 26
            ans += min(val, 26 - val)
            prev = ch
        return ans


    """1975. Maximum Matrix Sum (Medium)
    You are given an n x n integer matrix. You can do the following operation
    any number of times:
    * Choose any two adjacent elements of matrix and multiply each of them by
      -1.
    Two elements are considered adjacent if and only if they share a border.
    Your goal is to maximize the summation of the matrix's elements. Return the
    maximum sum of the matrix's elements using the operation mentioned above.

    Example 1:
    Input: matrix = [[1,-1],[-1,1]]
    Output: 4
    Explanation: We can follow the following steps to reach sum equals 4:
                 - Multiply the 2 elements in the first row by -1.
                 - Multiply the 2 elements in the first column by -1.

    Example 2:
    Input: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
    Output: 16
    Explanation: We can follow the following step to reach sum equals 16:
                 - Multiply the 2 last elements in the second row by -1.

    Constraints:
    * n == matrix.length == matrix[i].length
    * 2 <= n <= 250
    * -10^5 <= matrix[i][j] <= 10^5"""

    def maxMatrixSum(self, matrix: List[List[int]]) -> int:
        ans = mult = 0
        val = inf
        for i in range(len(matrix)):
            for j in range(len(matrix)):
                ans += abs(matrix[i][j])
                val = min(val, abs(matrix[i][j]))
                if matrix[i][j] < 0: mult ^= 1
        return ans - 2*mult*val


    """1976. Number of Ways to Arrive at Destination (Medium)
    You are in a city that consists of n intersections numbered from 0 to n - 1
    with bi-directional roads between some intersections. The inputs are
    generated such that you can reach any intersection from any other
    intersection and that there is at most one road between any two
    intersections. You are given an integer n and a 2D integer array roads
    where roads[i] = [ui, vi, timei] means that there is a road between
    intersections ui and vi that takes timei minutes to travel. You want to
    know in how many ways you can travel from intersection 0 to intersection
    n - 1 in the shortest amount of time. Return the number of ways you can
    arrive at your destination in the shortest amount of time. Since the answer
    may be large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
    Output: 4
    Explanation: The shortest amount of time it takes to go from intersection 0
                 to intersection 6 is 7 minutes. The four ways to get there in
                 7 minutes are:
                 - 0 ➝ 6
                 - 0 ➝ 4 ➝ 6
                 - 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
                 - 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6

    Example 2:
    Input: n = 2, roads = [[1,0,10]]
    Output: 1
    Explanation: There is only one way to go from intersection 0 to
                 intersection 1, and it takes 10 minutes.

    Constraints:
    * 1 <= n <= 200
    * n - 1 <= roads.length <= n * (n - 1) / 2
    * roads[i].length == 3
    * 0 <= ui, vi <= n - 1
    * 1 <= timei <= 10^9
    * ui != vi
    * There is at most one road connecting any two intersections.
    * You can reach any intersection from any other intersection."""

    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        graph = {}
        for u, v, time in roads:
            graph.setdefault(u, []).append((v, time))
            graph.setdefault(v, []).append((u, time))

        # modified Dijkstra's algo
        dist = [inf] * n
        dist[0] = 0
        ways = [0] * n
        ways[0] = 1

        pq = [(0, 0)]
        while pq:
            d, u = heappop(pq)
            if d > dist[-1]: break
            if d == dist[u]:
                for v, time in graph.get(u, []):
                    if dist[u] + time < dist[v]:
                        dist[v] = dist[u] + time
                        ways[v] = ways[u]
                        heappush(pq, (dist[v], v))
                    elif dist[u] + time == dist[v]: ways[v] += ways[u]
        return ways[-1] % 1_000_000_007


    """1977. Number of Ways to Separate Numbers (Hard)
    You wrote down many positive integers in a string called num. However, you
    realized that you forgot to add commas to seperate the different numbers.
    You remember that the list of integers was non-decreasing and that no
    integer had leading zeros. Return the number of possible lists of integers
    that you could have written down to get the string num. Since the answer
    may be large, return it modulo 10^9 + 7.

    Example 1:
    Input: num = "327"
    Output: 2
    Explanation: You could have written down the numbers:
                 3, 27
                 327

    Example 2:
    Input: num = "094"
    Output: 0
    Explanation: No numbers can have leading zeros and all numbers must be
                 positive.

    Example 3:
    Input: num = "0"
    Output: 0
    Explanation: No numbers can have leading zeros and all numbers must be
                 positive.

    Example 4:
    Input: num = "9999999999999"
    Output: 101

    Constraints:
    * 1 <= num.length <= 3500
    * num consists of digits '0' through '9'."""

    def numberOfCombinations(self, num: str) -> int:
        n = len(num)
        lcs = [[0]*(n+1) for _ in range(n)]
        for i in reversed(range(n)):
            for j in reversed(range(i+1, n)):
                if num[i] == num[j]: lcs[i][j] = 1 + lcs[i+1][j+1]

        def cmp(i, j, d):
            """Return True if """
            m = lcs[i][j]
            if m >= d: return True
            return num[i+m] <= num[j+m]

        dp = [[0]*(n+1) for _ in range(n)]
        for i in range(n):
            if num[i] != "0":
                for j in range(i+1, n+1):
                    if i == 0: dp[i][j] = 1
                    else:
                        dp[i][j] = dp[i][j-1]
                        if 2*i-j >= 0 and cmp(2*i-j, i, j-i): dp[i][j] += dp[2*i-j][i]
                        if 2*i-j+1 >= 0 and not cmp(2*i-j+1, i, j-i-1): dp[i][j] += dp[2*i-j+1][i]
        return sum(dp[i][n] for i in range(n)) % 1_000_000_007


    """1979. Find Greatest Common Divisor of Array (Easy)
    Given an integer array nums, return the greatest common divisor of the
    smallest number and largest number in nums. The greatest common divisor of
    two numbers is the largest positive integer that evenly divides both
    numbers.

    Example 1:
    Input: nums = [2,5,6,9,10]
    Output: 2
    Explanation: The smallest number in nums is 2. The largest number in nums
                 is 10. The greatest common divisor of 2 and 10 is 2.

    Example 2:
    Input: nums = [7,5,6,8,3]
    Output: 1
    Explanation: The smallest number in nums is 3. The largest number in nums
                 is 8. The greatest common divisor of 3 and 8 is 1.

    Example 3:
    Input: nums = [3,3]
    Output: 3
    Explanation: The smallest number in nums is 3. The largest number in nums
                 is 3. The greatest common divisor of 3 and 3 is 3.

    Constraints:
    * 2 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000"""

    def findGCD(self, nums: List[int]) -> int:
        return gcd(min(nums), max(nums))


    """1980. Find Unique Binary String (Medium)
    Given an array of strings nums containing n unique binary strings each of
    length n, return a binary string of length n that does not appear in nums.
    If there are multiple answers, you may return any of them.

    Example 1:
    Input: nums = ["01","10"]
    Output: "11"
    Explanation: "11" does not appear in nums. "00" would also be correct.

    Example 2:
    Input: nums = ["00","01"]
    Output: "11"
    Explanation: "11" does not appear in nums. "10" would also be correct.

    Example 3:
    Input: nums = ["111","011","001"]
    Output: "101"
    Explanation: "101" does not appear in nums. "000", "010", "100", and "110"
                 would also be correct.

    Constraints:
    * n == nums.length
    * 1 <= n <= 16
    * nums[i].length == n
    * nums[i] is either '0' or '1'.
    * All the strings of nums are unique."""

    def findDifferentBinaryString(self, nums: List[str]) -> str:
        ans = []
        for i, x in enumerate(nums):
            if x[i] == "1": ans.append("0")
            else: ans.append("1")
        return "".join(ans)


    """1981. Minimize the Difference Between Target and Chosen Elements (Medium)
    You are given an m x n integer matrix mat and an integer target. Choose one
    integer from each row in the matrix such that the absolute difference
    between target and the sum of the chosen elements is minimized. Return the
    minimum absolute difference. The absolute difference between two numbers a
    and b is the absolute value of a - b.

    Example 1:
    Input: mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13
    Output: 0
    Explanation: One possible choice is to:
                 - Choose 1 from the first row.
                 - Choose 5 from the second row.
                 - Choose 7 from the third row.
                 The sum of the chosen elements is 13, which equals the target,
                 so the absolute difference is 0.

    Example 2:
    Input: mat = [[1],[2],[3]], target = 100
    Output: 94
    Explanation: The best possible choice is to:
                 - Choose 1 from the first row.
                 - Choose 2 from the second row.
                 - Choose 3 from the third row.
                 The sum of the chosen elements is 6, and the absolute
                 difference is 94.

    Example 3:
    Input: mat = [[1,2,9,8,7]], target = 6
    Output: 1
    Explanation: The best choice is to choose 7 from the first row. The
                 absolute difference is 1.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 70
    * 1 <= mat[i][j] <= 70
    * 1 <= target <= 800"""

    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
        bits = 0b1
        for row in mat:
            temp = 0
            for x in row: temp |= bits << x
            bits = temp

        for x in range(5000):
            if bits >> (target+x) & 1 or x <= target and bits >> (target-x) & 1: return x


    """1982. Find Array Given Subset Sums (Hard)
    You are given an integer n representing the length of an unknown array that
    you are trying to recover. You are also given an array sums containing the
    values of all 2n subset sums of the unknown array (in no particular order).
    Return the array ans of length n representing the unknown array. If
    multiple answers exist, return any of them. An array sub is a subset of an
    array arr if sub can be obtained from arr by deleting some (possibly zero
    or all) elements of arr. The sum of the elements in sub is one possible
    subset sum of arr. The sum of an empty array is considered to be 0. Note
    that test cases are generated such that there will always be at least one
    correct answer.

    Example 1:
    Input: n = 3, sums = [-3,-2,-1,0,0,1,2,3]
    Output: [1,2,-3]
    Explanation: [1,2,-3] is able to achieve the given subset sums:
                 - []: sum is 0
                 - [1]: sum is 1
                 - [2]: sum is 2
                 - [1,2]: sum is 3
                 - [-3]: sum is -3
                 - [1,-3]: sum is -2
                 - [2,-3]: sum is -1
                 - [1,2,-3]: sum is 0
                 Note that any permutation of [1,2,-3] and also any permutation
                 of [-1,-2,3] will also be accepted.

    Example 2:
    Input: n = 2, sums = [0,0,0,0]
    Output: [0,0]
    Explanation: The only correct answer is [0,0].

    Example 3:
    Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]
    Output: [0,-1,4,5]
    Explanation: [0,-1,4,5] is able to achieve the given subset sums.

    Constraints:
    * 1 <= n <= 15
    * sums.length == 2n
    * -10^4 <= sums[i] <= 10^4"""

    def recoverArray(self, n: int, sums: List[int]) -> List[int]:
        sums.sort()
        ans = []
        for _ in range(n):
            diff = sums[1] - sums[0]
            ss0, ss1 = [], []
            freq = defaultdict(int)
            on = False
            for i, x in enumerate(sums):
                if not freq[x]:
                    ss0.append(x)
                    freq[x+diff] += 1
                    if x == 0: on = True
                else:
                    ss1.append(x)
                    freq[x] -= 1
            if on:
                ans.append(diff)
                sums = ss0
            else:
                ans.append(-diff)
                sums = ss1
        return ans


    """1983. Widest Pair of Indices With Equal Range Sum (Medium)
    You are given two 0-indexed binary arrays nums1 and nums2. Find the widest
    pair of indices (i, j) such that i <= j and
    nums1[i] + nums1[i+1] + ... + nums1[j] == nums2[i] + nums2[i+1] + ... + nums2[j].
    The widest pair of indices is the pair with the largest distance between i
    and j. The distance between a pair of indices is defined as j - i + 1.
    Return the distance of the widest pair of indices. If no pair of indices
    meets the conditions, return 0.

    Example 1:
    Input: nums1 = [1,1,0,1], nums2 = [0,1,1,0]
    Output: 3
    Explanation: If i = 1 and j = 3:
                 nums1[1] + nums1[2] + nums1[3] = 1 + 0 + 1 = 2.
                 nums2[1] + nums2[2] + nums2[3] = 1 + 1 + 0 = 2.
                 The distance between i and j is j - i + 1 = 3 - 1 + 1 = 3.

    Example 2:
    Input: nums1 = [0,1], nums2 = [1,1]
    Output: 1
    Explanation: If i = 1 and j = 1:
                 nums1[1] = 1.
                 nums2[1] = 1.
                 The distance between i and j is j - i + 1 = 1 - 1 + 1 = 1.

    Example 3:
    Input: nums1 = [0], nums2 = [1]
    Output: 0
    Explanation: There are no pairs of indices that meet the requirements.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * nums1[i] is either 0 or 1.
    * nums2[i] is either 0 or 1."""

    def widestPairOfIndices(self, nums1: List[int], nums2: List[int]) -> int:
        ans = prefix = 0
        seen = {0: -1}
        for i in range(len(nums1)):
            prefix += nums1[i] - nums2[i]
            if prefix in seen: ans = max(ans, i - seen[prefix])
            seen.setdefault(prefix, i)
        return ans


    """1984. Minimum Difference Between Highest and Lowest of K Scores (Easy)
    You are given a 0-indexed integer array nums, where nums[i] represents the
    score of the ith student. You are also given an integer k. Pick the scores
    of any k students from the array so that the difference between the highest
    and the lowest of the k scores is minimized. Return the minimum possible
    difference.

    Example 1:
    Input: nums = [90], k = 1
    Output: 0
    Explanation: There is one way to pick score(s) of one student:
                 - [90]. The difference between the highest and lowest score is 90 - 90 = 0.
                 The minimum possible difference is 0.

    Example 2:
    Input: nums = [9,4,1,7], k = 2
    Output: 2
    Explanation: There are six ways to pick score(s) of two students:
                 - [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.
                 - [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.
                 - [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.
                 - [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.
                 - [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.
                 - [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.
                 The minimum possible difference is 2.

    Constraints:
    * 1 <= k <= nums.length <= 1000
    * 0 <= nums[i] <= 10^5"""

    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        return min(nums[i]-nums[i-k+1] for i in range(k-1, len(nums)))


    """1985. Find the Kth Largest Integer in the Array (Medium)
    You are given an array of strings nums and an integer k. Each string in
    nums represents an integer without leading zeros. Return the string that
    represents the kth largest integer in nums. Note: Duplicate numbers should
    be counted distinctly. For example, if nums is ["1","2","2"], "2" is the
    first largest integer, "2" is the second-largest integer, and "1" is the
    third-largest integer.

    Example 1:
    Input: nums = ["3","6","7","10"], k = 4
    Output: "3"
    Explanation: The numbers in nums sorted in non-decreasing order are
                 ["3","6","7","10"]. The 4th largest integer in nums is "3".

    Example 2:
    Input: nums = ["2","21","12","1"], k = 3
    Output: "2"
    Explanation: The numbers in nums sorted in non-decreasing order are
                 ["1","2","12","21"]. The 3rd largest integer in nums is "2".

    Example 3:
    Input: nums = ["0","0"], k = 2
    Output: "0"
    Explanation: The numbers in nums sorted in non-decreasing order are
                 ["0","0"]. The 2nd largest integer in nums is "0".

    Constraints:
    * 1 <= k <= nums.length <= 10^4
    * 1 <= nums[i].length <= 100
    * nums[i] consists of only digits.
    * nums[i] will not have any leading zeros."""

    def kthLargestNumber(self, nums: List[str], k: int) -> str:
        nums = [int(x) for x in nums]
        shuffle(nums)

        def part(lo, hi):
            """Return partition of nums[lo:hi]."""
            i, j = lo+1, hi-1
            while i <= j:
                if nums[i] < nums[lo]: i += 1
                elif nums[lo] < nums[j]: j -= 1
                else:
                    nums[i], nums[j] = nums[j], nums[i]
                    i += 1
                    j -= 1
            nums[lo], nums[j] = nums[j], nums[lo]
            return j

        lo, hi = 0, len(nums)
        while lo < hi:
            mid = part(lo, hi)
            if mid == len(nums)-k: return str(nums[mid])
            elif mid < len(nums)-k: lo = mid + 1
            else: hi = mid


    """1986. Minimum Number of Work Sessions to Finish the Tasks (Medium)
    There are n tasks assigned to you. The task times are represented as an
    integer array tasks of length n, where the ith task takes tasks[i] hours to
    finish. A work session is when you work for at most sessionTime consecutive
    hours and then take a break. You should finish the given tasks in a way
    that satisfies the following conditions:
    * If you start a task in a work session, you must complete it in the same
      work session.
    * You can start a new task immediately after finishing the previous one.
    * You may complete the tasks in any order.
    Given tasks and sessionTime, return the minimum number of work sessions
    needed to finish all the tasks following the conditions above. The tests
    are generated such that sessionTime is greater than or equal to the maximum
    element in tasks[i].

    Example 1:
    Input: tasks = [1,2,3], sessionTime = 3
    Output: 2
    Explanation: You can finish the tasks in two work sessions.
                 - First work session: finish the first and the second tasks in
                   1 + 2 = 3 hours.
                 - Second work session: finish the third task in 3 hours.

    Example 2:
    Input: tasks = [3,1,3,1,1], sessionTime = 8
    Output: 2
    Explanation: You can finish the tasks in two work sessions.
                 - First work session: finish all the tasks except the last one
                   in 3 + 1 + 3 + 1 = 8 hours.
                 - Second work session: finish the last task in 1 hour.

    Example 3:
    Input: tasks = [1,2,3,4,5], sessionTime = 15
    Output: 1
    Explanation: You can finish all the tasks in one work session.

    Constraints:
    * n == tasks.length
    * 1 <= n <= 14
    * 1 <= tasks[i] <= 10
    * max(tasks[i]) <= sessionTime <= 15"""

    def minSessions(self, tasks: List[int], sessionTime: int) -> int:

        @cache
        def fn(mask, rem):
            """Return minimum work sessions to finish tasks indicated by set bits in mask."""
            if not mask: return 0 # done
            ans = inf
            for i, x in enumerate(tasks):
                if mask & (1<<i):
                    if x <= rem: ans = min(ans, fn(mask ^ (1<<i), rem - x))
                    else: ans = min(ans, 1 + fn(mask ^ (1<<i), sessionTime - x))
            return ans

        return fn((1<<len(tasks))-1, 0)


    """1987. Number of Unique Good Subsequences (Hard)
    You are given a binary string binary. A subsequence of binary is considered
    good if it is not empty and has no leading zeros (with the exception of "0").
    Find the number of unique good subsequences of binary. For example, if
    binary = "001", then all the good subsequences are ["0", "0", "1"], so the
    unique good subsequences are "0" and "1". Note that subsequences "00", "01",
    and "001" are not good because they have leading zeros. Return the number
    of unique good subsequences of binary. Since the answer may be very large,
    return it modulo 10^9 + 7. A subsequence is a sequence that can be derived
    from another sequence by deleting some or no elements without changing the
    order of the remaining elements.

    Example 1:
    Input: binary = "001"
    Output: 2
    Explanation: The good subsequences of binary are ["0", "0", "1"]. The
                 unique good subsequences are "0" and "1".

    Example 2:
    Input: binary = "11"
    Output: 2
    Explanation: The good subsequences of binary are ["1", "1", "11"]. The
                 unique good subsequences are "1" and "11".

    Example 3:
    Input: binary = "101"
    Output: 5
    Explanation: The good subsequences of binary are ["1", "0", "1", "10", "11",
                 "101"]. The unique good subsequences are "0", "1", "10", "11",
                 and "101".

    Constraints:
    * 1 <= binary.length <= 10^5
    * binary consists of only '0's and '1's."""

    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        f0 = f1 = 0
        for ch in binary:
            if ch == "0": f0 += f1
            else: f1 += f0 + 1
        return (f0 + f1 + int("0" in binary)) % 1_000_000_007


    """1989. Maximum Number of People That Can Be Caught in Tag (Medium)
    You are playing a game of tag with your friends. In tag, people are divided
    into two teams: people who are "it", and people who are not "it". The
    people who are "it" want to catch as many people as possible who are not
    "it". You are given a 0-indexed integer array team containing only zeros
    (denoting people who are not "it") and ones (denoting people who are "it"),
    and an integer dist. A person who is "it" at index i can catch any one
    person whose index is in the range [i - dist, i + dist] (inclusive) and is
    not "it". Return the maximum number of people that the people who are "it"
    can catch.

    Example 1:
    Input: team = [0,1,0,1,0], dist = 3
    Output: 2
    Explanation: The person who is "it" at index 1 can catch people in the
                 range [i-dist, i+dist] = [1-3, 1+3] = [-2, 4]. They can catch
                 the person who is not "it" at index 2. The person who is "it"
                 at index 3 can catch people in the range [i-dist, i+dist] =
                 [3-3, 3+3] = [0, 6]. They can catch the person who is not "it"
                 at index 0. The person who is not "it" at index 4 will not be
                 caught because the people at indices 1 and 3 are already
                 catching one person.

    Example 2:
    Input: team = [1], dist = 1
    Output: 0
    Explanation: There are no people who are not "it" to catch.

    Example 3:
    Input: team = [0], dist = 1
    Output: 0
    Explanation: There are no people who are "it" to catch people.

    Constraints:
    * 1 <= team.length <= 10^5
    * 0 <= team[i] <= 1
    * 1 <= dist <= team.length"""

    def catchMaximumAmountofPeople(self, team: List[int], dist: int) -> int:
        ans = 0
        q0, q1 = deque(), deque()
        for i, x in enumerate(team):
            if q0 and q0[0] < i-dist: q0.popleft()
            if q1 and q1[0] < i-dist: q1.popleft()
            if x == 0:
                if q1:
                    ans += 1
                    q1.popleft()
                else: q0.append(i)
            else:
                if q0:
                    ans += 1
                    q0.popleft()
                else: q1.append(i)
        return ans


    """1991. Find the Middle Index in Array (Easy)
    Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e.,
    the smallest amongst all the possible ones). A middleIndex is an index
    where
    nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].
    If middleIndex == 0, the left side sum is considered to be 0. Similarly, if
    middleIndex == nums.length - 1, the right side sum is considered to be 0.
    Return the leftmost middleIndex that satisfies the condition, or -1 if
    there is no such index.

    Example 1:
    Input: nums = [2,3,-1,8,4]
    Output: 3
    Explanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4
                 The sum of the numbers after index 3 is: 4 = 4

    Example 2:
    Input: nums = [1,-1,4]
    Output: 2
    Explanation: The sum of the numbers before index 2 is: 1 + -1 = 0
                 The sum of the numbers after index 2 is: 0

    Example 3:
    Input: nums = [2,5]
    Output: -1
    Explanation: There is no valid middleIndex.

    Example 4:
    Input: nums = [1]
    Output: 0
    Explantion: The sum of the numbers before index 0 is: 0
                The sum of the numbers after index 0 is: 0

    Constraints:
    * 1 <= nums.length <= 100
    * -1000 <= nums[i] <= 1000"""

    def findMiddleIndex(self, nums: List[int]) -> int:
        total = sum(nums)
        prefix = 0
        for i, x in enumerate(nums):
            if prefix == total - preifx - x: return i
            prefix += x
        return -1


    """1992. Find All Groups of Farmland (Medium)
    You are given a 0-indexed m x n binary matrix land where a 0 represents a
    hectare of forested land and a 1 represents a hectare of farmland. To keep
    the land organized, there are designated rectangular areas of hectares that
    consist entirely of farmland. These rectangular areas are called groups. No
    two groups are adjacent, meaning farmland in one group is not four-
    directionally adjacent to another farmland in a different group. land can
    be represented by a coordinate system where the top left corner of land is
    (0, 0) and the bottom right corner of land is (m-1, n-1). Find the
    coordinates of the top left and bottom right corner of each group of
    farmland. A group of farmland with a top left corner at (r1, c1) and a
    bottom right corner at (r2, c2) is represented by the 4-length array
    [r1, c1, r2, c2]. Return a 2D array containing the 4-length arrays
    described above for each group of farmland in land. If there are no groups
    of farmland, return an empty array. You may return the answer in any order.

    Example 1:
    Input: land = [[1,0,0],[0,1,1],[0,1,1]]
    Output: [[0,0,0,0],[1,1,2,2]]
    Explanation: The first group has a top left corner at land[0][0] and a
                 bottom right corner at land[0][0]. The second group has a top
                 left corner at land[1][1] and a bottom right corner at
                 land[2][2].

    Example 2:
    Input: land = [[1,1],[1,1]]
    Output: [[0,0,1,1]]
    Explanation: The first group has a top left corner at land[0][0] and a
                 bottom right corner at land[1][1].

    Example 3:
    Input: land = [[0]]
    Output: []
    Explanation: There are no groups of farmland.

    Constraints:
    * m == land.length
    * n == land[i].length
    * 1 <= m, n <= 300
    * land consists of only 0's and 1's.
    * Groups of farmland are rectangular in shape."""

    def findFarmland(self, land: List[List[int]]) -> List[List[int]]:
        m, n = len(land), len(land[0])
        ans = []
        for i in range(m):
            j = 0
            while j < n:
                if land[i][j] == 1:
                    jj = j
                    while jj < n and land[i][jj]: jj += 1
                    for ii in range(i, m):
                        if land[ii][j] == 1: land[ii][j] = -jj
                        else:
                            ii -= 1
                            break
                    ans.append([i, j, ii, jj-1])
                if land[i][j] < 0: j = -land[i][j]
                else: j += 1
        return ans


    """1994. The Number of Good Subsets (Hard)
    You are given an integer array nums. We call a subset of nums good if its
    product can be represented as a product of one or more distinct prime
    numbers.
    * For example, if nums = [1, 2, 3, 4]:
      + [2, 3], [1, 2, 3], and [1, 3] are good subsets with products 6 = 2*3,
        6 = 2*3, and 3 = 3 respectively.
      + [1, 4] and [4] are not good subsets with products 4 = 2*2 and 4 = 2*2
        respectively.
    Return the number of different good subsets in nums modulo 10^9 + 7. A
    subset of nums is any array that can be obtained by deleting some (possibly
    none or all) elements from nums. Two subsets are different if and only if
    the chosen indices to delete are different.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 6
    Explanation: The good subsets are:
                 - [1,2]: product is 2, which is the product of distinct prime 2.
                 - [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.
                 - [1,3]: product is 3, which is the product of distinct prime 3.
                 - [2]: product is 2, which is the product of distinct prime 2.
                 - [2,3]: product is 6, which is the product of distinct primes 2 and 3.
                 - [3]: product is 3, which is the product of distinct prime 3.

    Example 2:
    Input: nums = [4,2,3,15]
    Output: 5
    Explanation: The good subsets are:
                 - [2]: product is 2, which is the product of distinct prime 2.
                 - [2,3]: product is 6, which is the product of distinct primes 2 and 3.
                 - [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.
                 - [3]: product is 3, which is the product of distinct prime 3.
                 - [15]: product is 15, which is the product of distinct primes 3 and 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 30"""

    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        freq = [0] * 31
        for x in nums: freq[x] += 1

        masks = [0] * 31
        for x in range(1, 31):
            if x == 1: masks[x] = 0b10
            else:
                bits = 0
                xx = x
                for k in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29):
                    while xx % k == 0:
                        if (bits >> k) & 1: break # repeated factors
                        bits ^= 1 << k
                        xx //= k
                    else: continue
                    break
                else: masks[x] = bits

        @cache
        def fn(x, m):
            """Return number of good subsets."""
            if x == 31: return int(m > 2)
            ans = fn(x+1, m)
            if freq[x] and masks[x]:
                if x == 1: ans *= 2**freq[x]
                elif not m & masks[x]: ans += freq[x] * fn(x+1, m | masks[x])
            return ans % 1_000_000_007

        return fn(1, 0)


    """1995. Count Special Quadruplets (Easy)
    Given a 0-indexed integer array nums, return the number of distinct
    quadruplets (a, b, c, d) such that:
    * nums[a] + nums[b] + nums[c] == nums[d], and
    * a < b < c < d

    Example 1:
    Input: nums = [1,2,3,6]
    Output: 1
    Explanation: The only quadruplet that satisfies the requirement is
                 (0, 1, 2, 3) because 1 + 2 + 3 == 6.

    Example 2:
    Input: nums = [3,3,6,4,5]
    Output: 0
    Explanation: There are no such quadruplets in [3,3,6,4,5].

    Example 3:
    Input: nums = [1,1,1,3,5]
    Output: 4
    Explanation: The 4 quadruplets that satisfy the requirement are:
                 - (0, 1, 2, 3): 1 + 1 + 1 == 3
                 - (0, 1, 3, 4): 1 + 1 + 3 == 5
                 - (0, 2, 3, 4): 1 + 1 + 3 == 5
                 - (1, 2, 3, 4): 1 + 1 + 3 == 5

    Constraints:
    * 4 <= nums.length <= 50
    * 1 <= nums[i] <= 100"""

    def countQuadruplets(self, nums: List[int]) -> int:
        ans = 0
        freq = Counter()
        for i in range(len(nums)):
            for j in range(i+1, len(nums)): ans += freq[nums[j] - nums[i]]
            for ii in range(i): freq[nums[ii] + nums[i]] += 1
        return ans


    """1996. The Number of Weak Characters in the Game (Medium)
    You are playing a game that contains multiple characters, and each of the
    characters has two main properties: attack and defense. You are given a 2D
    integer array properties where properties[i] = [attacki, defensei]
    represents the properties of the ith character in the game. A character is
    said to be weak if any other character has both attack and defense levels
    strictly greater than this character's attack and defense levels. More
    formally, a character i is said to be weak if there exists another
    character j where attackj > attacki and defensej > defensei. Return the
    number of weak characters.

    Example 1:
    Input: properties = [[5,5],[6,3],[3,6]]
    Output: 0
    Explanation: No character has strictly greater attack and defense than the
                 other.

    Example 2:
    Input: properties = [[2,2],[3,3]]
    Output: 1
    Explanation: The first character is weak because the second character has a
                 strictly greater attack and defense.

    Example 3:
    Input: properties = [[1,5],[10,4],[4,3]]
    Output: 1
    Explanation: The third character is weak because the second character has a
                 strictly greater attack and defense.

    Constraints:
    * 2 <= properties.length <= 10^5
    * properties[i].length == 2
    * 1 <= attacki, defensei <= 10^5"""

    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
        ans = prefix = 0
        for _, d in sorted(properties, key=lambda x: (-x[0], x[1])):
            if d < prefix: ans += 1
            prefix = max(prefix, d)
        return ans


    """1997. First Day Where You Have Been in All the Rooms (Medium)
    There are n rooms you need to visit, labeled from 0 to n - 1. Each day is
    labeled, starting from 0. You will go in and visit one room a day.
    Initially on day 0, you visit room 0. The order you visit the rooms for the
    coming days is determined by the following rules and a given 0-indexed
    array nextVisit of length n:
    * Assuming that on a day, you visit room i,
    * if you have been in room i an odd number of times (including the current
      visit), on the next day you will visit the room specified by nextVisit[i]
      where 0 <= nextVisit[i] <= i;
    * if you have been in room i an even number of times (including the current
      visit), on the next day you will visit room (i + 1) mod n.
    Return the label of the first day where you have been in all the rooms. It
    can be shown that such a day exists. Since the answer may be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: nextVisit = [0,0]
    Output: 2
    Explanation:
    - On day 0, you visit room 0. The total times you have been in room 0 is 1,
      which is odd. On the next day you will visit room nextVisit[0] = 0
    - On day 1, you visit room 0, The total times you have been in room 0 is 2,
      which is even. On the next day you will visit room (0 + 1) mod 2 = 1
    - On day 2, you visit room 1. This is the first day where you have been in
      all the rooms.

    Example 2:
    Input: nextVisit = [0,0,2]
    Output: 6
    Explanation: Your room visiting order for each day is: [0,0,1,0,0,1,2,...].
                 Day 6 is the first day where you have been in all the rooms.

    Example 3:
    Input: nextVisit = [0,1,2,0]
    Output: 6
    Explanation: Your room visiting order for each day is: [0,0,1,1,2,2,3,...].
                 Day 6 is the first day where you have been in all the rooms.

    Constraints:
    * n == nextVisit.length
    * 2 <= n <= 10^5
    * 0 <= nextVisit[i] <= i"""

    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:
        odd = [0]
        even = [1]
        for i in range(1, len(nextVisit)):
            odd.append((even[-1] + 1) % 1_000_000_007)
            even.append((2*odd[-1] - odd[nextVisit[i]] + 1) % 1_000_000_007)
        return odd[-1]


    """1998. GCD Sort of an Array (Hard)
    You are given an integer array nums, and you can perform the following
    operation any number of times on nums:
    * Swap the positions of two elements nums[i] and nums[j] if
      gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest
      common divisor of nums[i] and nums[j].
    Return true if it is possible to sort nums in non-decreasing order using
    the above swap method, or false otherwise.

    Example 1:
    Input: nums = [7,21,3]
    Output: true
    Explanation: We can sort [7,21,3] by performing the following operations:
                 - Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3]
                 - Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21]

    Example 2:
    Input: nums = [5,2,6,2]
    Output: false
    Explanation: It is impossible to sort the array because 5 cannot be swapped
                 with any other element.

    Example 3:
    Input: nums = [10,5,9,3,15]
    Output: true
    We can sort [10,5,9,3,15] by performing the following operations:
    - Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10]
    - Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10]
    - Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15]

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * 2 <= nums[i] <= 10^5"""

    def gcdSort(self, nums: List[int]) -> bool:
        m = max(nums)
        uf = UnionFind(m+1)

        seen = set(nums)

        # modified sieve of eratosthenes
        sieve = [1]*(m+1)
        sieve[0] = sieve[1] = 0
        for k in range(m//2 + 1):
            if sieve[k]:
                for x in range(2*k, m+1, k):
                    sieve[x] = 0
                    if x in seen: uf.union(k, x)
        return all(uf.find(x) == uf.find(y) for x, y in zip(nums, sorted(nums)))


    """1999. Smallest Greater Multiple Made of Two Digits (Medium)
    Given three integers, k, digit1, and digit2, you want to find the smallest
    integer that is:
    * Larger than k,
    * A multiple of k, and
    * Comprised of only the digits digit1 and/or digit2.
    Return the smallest such integer. If no such integer exists or the integer
    exceeds the limit of a signed 32-bit integer (2^31 - 1), return -1.

    Example 1:
    Input: k = 2, digit1 = 0, digit2 = 2
    Output: 20
    Explanation: 20 is the first integer larger than 2, a multiple of 2, and
                 comprised of only the digits 0 and/or 2.

    Example 2:
    Input: k = 3, digit1 = 4, digit2 = 2
    Output: 24
    Explanation: 24 is the first integer larger than 3, a multiple of 3, and
                 comprised of only the digits 4 and/or 2.

    Example 3:
    Input: k = 2, digit1 = 0, digit2 = 0
    Output: -1
    Explanation: No integer meets the requirements so return -1.

    Constraints:
    * 1 <= k <= 1000
    * 0 <= digit1 <= 9
    * 0 <= digit2 <= 9"""

    def findInteger(self, k: int, digit1: int, digit2: int) -> int:
        if digit1 > digit2: digit1, digit2 = digit2, digit1
        queue = deque([0])
        while queue:
            val = queue.popleft()
            if k < val and val % k == 0: return val
            if val+digit1 and 10*val+digit1 < 2**31: queue.append(10*val+digit1)
            if digit1 < digit2 and 10*val+digit2 < 2**31: queue.append(10*val+digit2)
        return -1


    """2000. Reverse Prefix of Word (Easy)
    Given a 0-indexed string word and a character ch, reverse the segment of
    word that starts at index 0 and ends at the index of the first occurrence
    of ch (inclusive). If the character ch does not exist in word, do nothing.
    For example, if word = "abcdefd" and ch = "d", then you should reverse the
    segment that starts at 0 and ends at 3 (inclusive). The resulting string
    will be "dcbaefd". Return the resulting string.

    Example 1:
    Input: word = "abcdefd", ch = "d"
    Output: "dcbaefd"
    Explanation: The first occurrence of "d" is at index 3. Reverse the part of
                 word from 0 to 3 (inclusive), the resulting string is "dcbaefd".

    Example 2:
    Input: word = "xyxzxe", ch = "z"
    Output: "zxyxxe"
    Explanation: The first and only occurrence of "z" is at index 3. Reverse
                 the part of word from 0 to 3 (inclusive), the resulting string
                 is "zxyxxe".

    Example 3:
    Input: word = "abcd", ch = "z"
    Output: "abcd"
    Explanation: "z" does not exist in word. You should not do any reverse
                 operation, the resulting string is "abcd".

    Constraints:
    * 1 <= word.length <= 250
    * word consists of lowercase English letters.
    * ch is a lowercase English letter."""

    def reversePrefix(self, word: str, ch: str) -> str:
        k = word.find(ch)
        return word[:k+1][::-1] + word[k+1:]


    """2001. Number of Pairs of Interchangeable Rectangles (Medium)
    You are given n rectangles represented by a 0-indexed 2D integer array
    rectangles, where rectangles[i] = [widthi, heighti] denotes the width and
    height of the ith rectangle. Two rectangles i and j (i < j) are considered
    interchangeable if they have the same width-to-height ratio. More formally,
    two rectangles are interchangeable if widthi/heighti == widthj/heightj
    (using decimal division, not integer division). Return the number of pairs
    of interchangeable rectangles in rectangles.

    Example 1:
    Input: rectangles = [[4,8],[3,6],[10,20],[15,30]]
    Output: 6
    Explanation: The following are the interchangeable pairs of rectangles by
                 index (0-indexed):
                 - Rectangle 0 with rectangle 1: 4/8 == 3/6.
                 - Rectangle 0 with rectangle 2: 4/8 == 10/20.
                 - Rectangle 0 with rectangle 3: 4/8 == 15/30.
                 - Rectangle 1 with rectangle 2: 3/6 == 10/20.
                 - Rectangle 1 with rectangle 3: 3/6 == 15/30.
                 - Rectangle 2 with rectangle 3: 10/20 == 15/30.
    Example 2:
    Input: rectangles = [[4,5],[7,8]]
    Output: 0
    Explanation: There are no interchangeable pairs of rectangles.

    Constraints:
    * n == rectangles.length
    * 1 <= n <= 10^5
    * rectangles[i].length == 2
    * 1 <= widthi, heighti <= 10^5"""

    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
        ans = 0
        freq = defaultdict(int)
        for w, h in rectangles:
            ans += freq[w/h]
            freq[w/h] += 1
        return ans


    """2002. Maximum Product of the Length of Two Palindromic Subsequences (Medium)
    Given a string s, find two disjoint palindromic subsequences of s such that
    the product of their lengths is maximized. The two subsequences are
    disjoint if they do not both pick a character at the same index. Return the
    maximum possible product of the lengths of the two palindromic subsequences.
    A subsequence is a string that can be derived from another string by
    deleting some or no characters without changing the order of the remaining
    characters. A string is palindromic if it reads the same forward and
    backward.

    Example 1:
    example-1
    Input: s = "leetcodecom"
    Output: 9
    Explanation: An optimal solution is to choose "ete" for the 1st subsequence
                 and "cdc" for the 2nd subsequence. The product of their
                 lengths is: 3 * 3 = 9.

    Example 2:
    Input: s = "bb"
    Output: 1
    Explanation: An optimal solution is to choose "b" (the first character) for
                 the 1st subsequence and "b" (the second character) for the 2nd
                 subsequence. The product of their lengths is: 1 * 1 = 1.

    Example 3:
    Input: s = "accbcaxxcxx"
    Output: 25
    Explanation: An optimal solution is to choose "accca" for the 1st
                 subsequence and "xxcxx" for the 2nd subsequence. The product
                 of their lengths is: 5 * 5 = 25.

    Constraints:
    * 2 <= s.length <= 12
    * s consists of lowercase English letters only."""

    def maxProduct(self, s: str) -> int:

        @cache
        def lps(mask):
            """Return length of longest palindromic sequence."""
            if not mask: return 0
            if not mask & (mask-1): return 1
            lo = int(log2(mask & ~(mask-1))) # least significant set bi
            hi = int(log2(mask)) # most significant set bit
            if s[lo] == s[hi]: return 2 + lps(mask^(1<<lo)^(1<<hi))
            return max(lps(mask^(1<<lo)), lps(mask^(1<<hi)))

        ans = 0
        for mask in range(1 << len(s)):
            comp = (1 << len(s)) - 1 ^ mask
            ans = max(ans, lps(mask) * lps(comp))
        return ans


    """2003. Smallest Missing Genetic Value in Each Subtree (Hard)
    There is a family tree rooted at 0 consisting of n nodes numbered 0 to
    n - 1. You are given a 0-indexed integer array parents, where parents[i] is
    the parent for node i. Since node 0 is the root, parents[0] == -1. There
    are 10^5 genetic values, each represented by an integer in the inclusive
    range [1, 10^5]. You are given a 0-indexed integer array nums, where nums[i]
    is a distinct genetic value for node i. Return an array ans of length n
    where ans[i] is the smallest genetic value that is missing from the subtree
    rooted at node i. The subtree rooted at a node x contains node x and all of
    its descendant nodes.

    Example 1:
    Input: parents = [-1,0,0,2], nums = [1,2,3,4]
    Output: [5,1,1,1]
    Explanation: The answer for each subtree is calculated as follows:
                 - 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value.
                 - 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.
                 - 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value.
                 - 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value.

    Example 2:
    Input: parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]
    Output: [7,1,1,4,2,1]
    Explanation: The answer for each subtree is calculated as follows:
                 - 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value.
                 - 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value.
                 - 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.
                 - 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value.
                 - 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.
                 - 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value.

    Example 3:
    Input: parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]
    Output: [1,1,1,1,1,1,1]
    Explanation: The value 1 is missing from all the subtrees.

    Constraints:
    * n == parents.length == nums.length
    * 2 <= n <= 10^5
    * 0 <= parents[i] <= n - 1 for i != 0
    * parents[0] == -1
    * parents represents a valid tree.
    * 1 <= nums[i] <= 10^5
    * Each nums[i] is distinct."""

    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        ans = [1] * len(parents)
        if 1 in nums:
            tree = {}
            for i, x in enumerate(parents):
                tree.setdefault(x, []).append(i)

            k = nums.index(1)
            val = 1
            seen = set()

            while k != -1:
                stack = [k]
                while stack:
                    x = stack.pop()
                    seen.add(nums[x])
                    for xx in tree.get(x, []):
                        if nums[xx] not in seen:
                            stack.append(xx)
                            seen.add(nums[xx])
                while val in seen: val += 1
                ans[k] = val
                k = parents[k]
        return ans


    """2005. Subtree Removal Game with Fibonacci Tree (Hard)
    A Fibonacci tree is a binary tree created using the order function order(n):
    * order(0) is the empty tree.
    * order(1) is a binary tree with only one node.
    * order(n) is a binary tree that consists of a root node with the left
      subtree as order(n - 2) and the right subtree as order(n - 1).
    Alice and Bob are playing a game with a Fibonacci tree with Alice staring
    first. On each turn, a player selects a node and removes that node and its
    subtree. The player that is forced to delete root loses. Given the integer
    n, return true if Alice wins the game or false if Bob wins, assuming both
    players play optimally. A subtree of a binary tree tree is a tree that
    consists of a node in tree and all of this node's descendants. The tree
    tree could also be considered as a subtree of itself.

    Example 1:
    Input: n = 3
    Output: true
    Explanation: Alice takes the node 1 in the right subtree. Bob takes either
                 the 1 in the left subtree or the 2 in the right subtree. Alice
                 takes whichever node Bob doesn't take. Bob is forced to take
                 the root node 3, so Bob will lose. Return true because Alice
                 wins.

    Example 2:
    Input: n = 1
    Output: false
    Explanation: Alice is forced to take the root node 1, so Alice will lose.
                 Return false because Alice loses.

    Example 3:
    Input: n = 2
    Output: true
    Explanation: Alice takes the node 1. Bob is forced to take the root node 2,
                 so Bob will lose. Return true because Alice wins.

    Constraints: 1 <= n <= 100"""

    def findGameWinner(self, n: int) -> bool:
        return (n-1) % 6


    """2006. Count Number of Pairs With Absolute Difference K (Easy)
    Given an integer array nums and an integer k, return the number of pairs
    (i, j) where i < j such that |nums[i] - nums[j]| == k. The value of |x| is
    defined as:
    * x if x >= 0.
    * -x if x < 0.

    Example 1:
    Input: nums = [1,2,2,1], k = 1
    Output: 4
    Explanation: The pairs with an absolute difference of 1 are:
                 - [1,2,2,1]
                 - [1,2,2,1]
                 - [1,2,2,1]
                 - [1,2,2,1]

    Example 2:
    Input: nums = [1,3], k = 3
    Output: 0
    Explanation: There are no pairs with an absolute difference of 3.

    Example 3:
    Input: nums = [3,2,1,5,4], k = 2
    Output: 3
    Explanation: The pairs with an absolute difference of 2 are:
                 - [3,2,1,5,4]
                 - [3,2,1,5,4]
                 - [3,2,1,5,4]

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= 100
    * 1 <= k <= 99"""

    def countKDifference(self, nums: List[int], k: int) -> int:
        ans = 0
        freq = defaultdict(int)
        for x in nums:
            ans += freq[x - k] + freq[x + k]
            freq[x] += 1
        return ans


    """2007. Find Original Array From Doubled Array (Medium)
    An integer array original is transformed into a doubled array changed by
    appending twice the value of every element in original, and then randomly
    shuffling the resulting array. Given an array changed, return original if
    changed is a doubled array. If changed is not a doubled array, return an
    empty array. The elements in original may be returned in any order.

    Example 1:
    Input: changed = [1,3,4,2,6,8]
    Output: [1,3,4]
    Explanation: One possible original array could be [1,3,4]:
                 - Twice the value of 1 is 1 * 2 = 2.
                 - Twice the value of 3 is 3 * 2 = 6.
                 - Twice the value of 4 is 4 * 2 = 8.
                 Other original arrays could be [4,3,1] or [3,1,4].

    Example 2:
    Input: changed = [6,3,0,1]
    Output: []
    Explanation: changed is not a doubled array.

    Example 3:
    Input: changed = [1]
    Output: []
    Explanation: changed is not a doubled array.

    Constraints:
    * 1 <= changed.length <= 10^5
    * 0 <= changed[i] <= 10^5"""

    def findOriginalArray(self, changed: List[int]) -> List[int]:
        freq = Counter(changed)
        ans = []
        for x in sorted(freq):
            if freq[x]:
                if x and freq[x] <= freq[2*x]:
                    ans.extend([x] * freq[x])
                    freq[2*x] -= freq[x]
                elif x == 0 and freq[x] % 2 == 0:
                    ans.extend([0] * (freq[x]//2))
                else: return []
        return ans


    """2008. Maximum Earnings From Taxi (Medium)
    There are n points on a road you are driving your taxi on. The n points on
    the road are labeled from 1 to n in the direction you are going, and you
    want to drive from point 1 to point n to make money by picking up
    passengers. You cannot change the direction of the taxi. The passengers are
    represented by a 0-indexed 2D integer array rides, where
    rides[i] = [starti, endi, tipi] denotes the ith passenger requesting a ride
    from point starti to point endi who is willing to give a tipi dollar tip.
    For each passenger i you pick up, you earn endi - starti + tipi dollars.
    You may only drive at most one passenger at a time. Given n and rides,
    return the maximum number of dollars you can earn by picking up the
    passengers optimally. Note: You may drop off a passenger and pick up a
    different passenger at the same point.

    Example 1:
    Input: n = 5, rides = [[2,5,4],[1,5,1]]
    Output: 7
    Explanation: We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.

    Example 2:
    Input: n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]
    Output: 20
    Explanation: We will pick up the following passengers:
                 - Drive passenger 1 from point 3 to point 10 for a profit of
                   10 - 3 + 2 = 9 dollars.
                 - Drive passenger 2 from point 10 to point 12 for a profit of
                   12 - 10 + 3 = 5 dollars.
                 - Drive passenger 5 from point 13 to point 18 for a profit of
                   18 - 13 + 1 = 6 dollars.
                 We earn 9 + 5 + 6 = 20 dollars in total.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= rides.length <= 3 * 10^4
    * rides[i].length == 3
    * 1 <= starti < endi <= n
    * 1 <= tipi <= 10^5"""

    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:
        mp = {}
        for start, end, tip in rides:
            mp.setdefault(start, []).append((end, tip))

        dp = [0]*(n+1)
        for x in range(n-1, 0, -1):
            dp[x] = dp[x+1]
            for xx, tip in mp.get(x, []):
                dp[x] = max(dp[x], xx - x + tip + dp[xx])
        return dp[1]


    """2009. Minimum Number of Operations to Make Array Continuous (Hard)
    You are given an integer array nums. In one operation, you can replace any
    element in nums with any integer. nums is considered continuous if both of
    the following conditions are fulfilled:
    * All elements in nums are unique.
    * The difference between the maximum element and the minimum element in
      nums equals nums.length - 1.
    For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6]
    is not continuous. Return the minimum number of operations to make nums
    continuous.

    Example 1:
    Input: nums = [4,2,5,3]
    Output: 0
    Explanation: nums is already continuous.

    Example 2:
    Input: nums = [1,2,3,5,6]
    Output: 1
    Explanation: One possible solution is to change the last element to 4. The
                 resulting array is [1,2,3,5,4], which is continuous.

    Example 3:
    Input: nums = [1,10,100,1000]
    Output: 3
    Explanation: One possible solution is to:
                 - Change the second element to 2.
                 - Change the third element to 3.
                 - Change the fourth element to 4.
                 The resulting array is [1,2,3,4], which is continuous.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        nums = sorted(set(nums))

        ans = ii = 0
        for i, x in enumerate(nums):
            if x - nums[ii] >= n: ii += 1
            ans = max(ans, i - ii + 1)
        return n - ans


    """2011. Final Value of Variable After Performing Operations (Easy)
    There is a programming language with only four operations and one variable
    X:
    * ++X and X++ increments the value of the variable X by 1.
    * --X and X-- decrements the value of the variable X by 1.
    Initially, the value of X is 0. Given an array of strings operations
    containing a list of operations, return the final value of X after
    performing all the operations.

    Example 1:
    Input: operations = ["--X","X++","X++"]
    Output: 1
    Explanation: The operations are performed as follows:
                 Initially, X = 0.
                 --X: X is decremented by 1, X =  0 - 1 = -1.
                 X++: X is incremented by 1, X = -1 + 1 =  0.
                 X++: X is incremented by 1, X =  0 + 1 =  1.

    Example 2:
    Input: operations = ["++X","++X","X++"]
    Output: 3
    Explanation: The operations are performed as follows:
                 Initially, X = 0.
                 ++X: X is incremented by 1, X = 0 + 1 = 1.
                 ++X: X is incremented by 1, X = 1 + 1 = 2.
                 X++: X is incremented by 1, X = 2 + 1 = 3.

    Example 3:
    Input: operations = ["X++","++X","--X","X--"]
    Output: 0
    Explanation: The operations are performed as follows:
                 Initially, X = 0.
                 X++: X is incremented by 1, X = 0 + 1 = 1.
                 ++X: X is incremented by 1, X = 1 + 1 = 2.
                 --X: X is decremented by 1, X = 2 - 1 = 1.
                 X--: X is decremented by 1, X = 1 - 1 = 0.

    Constraints:
    * 1 <= operations.length <= 100
    * operations[i] will be either "++X", "X++", "--X", or "X--"."""

    def finalValueAfterOperations(self, operations: List[str]) -> int:
        ans = 0
        for op in operations:
            if op in ("++X", "X++"): ans += 1
            else: ans -= 1
        return ans


    """2012. Sum of Beauty in the Array (Medium)
    You are given a 0-indexed integer array nums. For each index i
    (1 <= i <= nums.length - 2) the beauty of nums[i] equals:
    * 2, if nums[j] < nums[i] < nums[k], for all 0 <= j < i and for all
      i < k <= nums.length - 1.
    * 1, if nums[i - 1] < nums[i] < nums[i + 1], and the previous condition is
      not satisfied.
    * 0, if none of the previous conditions holds.
    Return the sum of beauty of all nums[i] where 1 <= i <= nums.length - 2.

    Example 1:
    Input: nums = [1,2,3]
    Output: 2
    Explanation: For each index i in the range 1 <= i <= 1:
                 - The beauty of nums[1] equals 2.

    Example 2:
    Input: nums = [2,4,6,4]
    Output: 1
    Explanation: For each index i in the range 1 <= i <= 2:
                 - The beauty of nums[1] equals 1.
                 - The beauty of nums[2] equals 0.

    Example 3:
    Input: nums = [3,2,1]
    Output: 0
    Explanation: For each index i in the range 1 <= i <= 1:
                 - The beauty of nums[1] equals 0.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def sumOfBeauties(self, nums: List[int]) -> int:
        suffix = [inf] * len(nums) # suffix of min
        for i in range(len(nums)-2, 0, -1):
            suffix[i] = min(suffix[i+1], nums[i+1])

        ans = prefix = 0
        for i in range(1, len(nums)-1):
            prefix = max(prefix, nums[i-1])
            if prefix < nums[i] < suffix[i]: ans += 2
            elif nums[i-1] < nums[i] < nums[i+1]: ans += 1
        return ans


    """2014. Longest Subsequence Repeated k Times (Hard)
    You are given a string s of length n, and an integer k. You are tasked to
    find the longest subsequence repeated k times in string s. A subsequence is
    a string that can be derived from another string by deleting some or no
    characters without changing the order of the remaining characters. A
    subsequence seq is repeated k times in the string s if seq * k is a
    subsequence of s, where seq * k represents a string constructed by
    concatenating seq k times. For example, "bba" is repeated 2 times in the
    string "bababcba", because the string "bbabba", constructed by
    concatenating "bba" 2 times, is a subsequence of the string "bababcba".
    Return the longest subsequence repeated k times in string s. If multiple
    such subsequences are found, return the lexicographically largest one. If
    there is no such subsequence, return an empty string.

    Example 1:
    example 1
    Input: s = "letsleetcode", k = 2
    Output: "let"
    Explanation: There are two longest subsequences repeated 2 times: "let" and
                 "ete". "let" is the lexicographically largest one.

    Example 2:
    Input: s = "bb", k = 2
    Output: "b"
    Explanation: The longest subsequence repeated 2 times is "b".

    Example 3:
    Input: s = "ab", k = 2
    Output: ""
    Explanation: There is no subsequence repeated 2 times. Empty string is
                 returned.

    Example 4:
    Input: s = "bbabbabbbbabaababab", k = 3
    Output: "bbbb"
    Explanation: The longest subsequence "bbbb" is repeated 3 times in
                 "bbabbabbbbabaababab".

    Constraints:
    * n == s.length
    * 2 <= n, k <= 2000
    * 2 <= n < k * 8
    * s consists of lowercase English letters."""

    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        freq = [0] * 26
        for ch in s: freq[ord(ch)-97] += 1

        cand = [chr(i+97) for i, x in enumerate(freq) if x >= k] # valid candidates

        def fn(ss):
            """Return True if ss is a k-repeated sub-sequence of s."""
            i = cnt = 0
            for ch in s:
                if ss[i] == ch:
                    i += 1
                    if i == len(ss):
                        if (cnt := cnt + 1) == k: return True
                        i = 0
            return False

        ans = ""
        queue = deque([""])
        while queue:
            x = queue.popleft()
            for ch in cand:
                xx = x + ch
                if fn(xx):
                    ans = xx
                    queue.append(xx)
        return ans


    """2015. Average Height of Buildings in Each Segment (Medium)
    A perfectly straight street is represented by a number line. The street has
    building(s) on it and is represented by a 2D integer array buildings, where
    buildings[i] = [starti, endi, heighti]. This means that there is a building
    with heighti in the half-closed segment [starti, endi). You want to
    describe the heights of the buildings on the street with the minimum number
    of non-overlapping segments. The street can be represented by the 2D
    integer array street where street[j] = [leftj, rightj, averagej] describes
    a half-closed segment [leftj, rightj) of the road where the average heights
    of the buildings in the segment is averagej.
    * For example, if buildings = [[1,5,2],[3,10,4]], the street could be
      represented by street = [[1,3,2],[3,5,3],[5,10,4]] because:
      + From 1 to 3, there is only the first building with an average height of
        2 / 1 = 2.
      + From 3 to 5, both the first and the second building are there with an
        average height of (2+4) / 2 = 3.
      + From 5 to 10, there is only the second building with an average height
        of 4 / 1 = 4.
    Given buildings, return the 2D integer array street as described above
    (excluding any areas of the street where there are no buldings). You may
    return the array in any order. The average of n elements is the sum of the
    n elements divided (integer division) by n. A half-closed segment [a, b) is
    the section of the number line between points a and b including point a and
    not including point b.

    Example 1:
    Input: buildings = [[1,4,2],[3,9,4]]
    Output: [[1,3,2],[3,4,3],[4,9,4]]
    Explanation: From 1 to 3, there is only the first building with an average
                 height of 2 / 1 = 2. From 3 to 4, both the first and the
                 second building are there with an average height of
                 (2+4) / 2 = 3. From 4 to 9, there is only the second building
                 with an average height of 4 / 1 = 4.

    Example 2:
    Input: buildings = [[1,3,2],[2,5,3],[2,8,3]]
    Output: [[1,3,2],[3,8,3]]
    Explanation: From 1 to 2, there is only the first building with an average
                 height of 2 / 1 = 2. From 2 to 3, all three buildings are
                 there with an average height of (2+3+3) / 3 = 2. From 3 to 5,
                 both the second and the third building are there with an
                 average height of (3+3) / 2 = 3. From 5 to 8, there is only
                 the last building with an average height of 3 / 1 = 3. The
                 average height from 1 to 3 is the same so we can group them
                 into one segment. The average height from 3 to 8 is the same
                 so we can group them into one segment.

    Example 3:
    Input: buildings = [[1,2,1],[5,6,1]]
    Output: [[1,2,1],[5,6,1]]
    Explanation: From 1 to 2, there is only the first building with an average
                 height of 1 / 1 = 1. From 2 to 5, there are no buildings, so
                 it is not included in the output. From 5 to 6, there is only
                 the second building with an average height of 1 / 1 = 1. We
                 cannot group the segments together because an empty space with
                 no buildings seperates the segments.

    Constraints:
    * 1 <= buildings.length <= 10^5
    * buildings[i].length == 3
    * 0 <= starti < endi <= 10^8
    * 1 <= heighti <= 10^5"""

    def averageHeightOfBuildings(self, buildings: List[List[int]]) -> List[List[int]]:
        street = defaultdict(list)
        for left, right, height in buildings:
            street[left].append((height, 1))
            street[right].append((-height, -1))
        ans = []
        prev = -inf
        count = value = 0
        for k, v in sorted(street.items()):
            if prev > -inf and count:
                avg = value//count
                if ans and ans[-1][1] == prev and ans[-1][2] == avg: ans[-1][1] = k
                else: ans.append([prev, k, value//count])
            for h, c in v:
                count += c
                value += h
            prev = k
        return ans


    """2016. Maximum Difference Between Increasing Elements (Easy)
    Given a 0-indexed integer array nums of size n, find the maximum difference
    between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that
    0 <= i < j < n and nums[i] < nums[j]. Return the maximum difference. If no
    such i and j exists, return -1.

    Example 1:
    Input: nums = [7,1,5,4]
    Output: 4
    Explanation: The maximum difference occurs with i = 1 and j = 2,
                 nums[j] - nums[i] = 5 - 1 = 4. Note that with i = 1 and j = 0,
                 the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it
                 is not valid.

    Example 2:
    Input: nums = [9,4,3,2]
    Output: -1
    Explanation: There is no i and j such that i < j and nums[i] < nums[j].

    Example 3:
    Input: nums = [1,5,2,10]
    Output: 9
    Explanation: The maximum difference occurs with i = 0 and j = 3,
                 nums[j] - nums[i] = 10 - 1 = 9.

    Constraints:
    * n == nums.length
    * 2 <= n <= 1000
    * 1 <= nums[i] <= 10^9"""

    def maximumDifference(self, nums: List[int]) -> int:
        ans = -1
        prefix = inf
        for x in nums:
            if x > prefix: ans = max(ans, x - prefix)
            prefix = min(prefix, x)
        return ans


    """2017. Grid Game (Medium)
    You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c]
    represents the number of points at position (r, c) on the matrix. Two
    robots are playing a game on this matrix. Both robots initially start at
    (0, 0) and want to reach (1, n-1). Each robot may only move to the right
    ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)). At the start of the
    game, the first robot moves from (0, 0) to (1, n-1), collecting all the
    points from the cells on its path. For all cells (r, c) traversed on the
    path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to
    (1, n-1), collecting the points on its path. Note that their paths may
    intersect with one another. The first robot wants to minimize the number of
    points collected by the second robot. In contrast, the second robot wants
    to maximize the number of points it collects. If both robots play optimally,
    return the number of points collected by the second robot.

    Example 1:
    Input: grid = [[2,5,4],[1,5,1]]
    Output: 4
    Explanation: The optimal path taken by the first robot is shown in red, and
                 the optimal path taken by the second robot is shown in blue.
                 The cells visited by the first robot are set to 0. The second
                 robot will collect 0 + 0 + 4 + 0 = 4 points.

    Example 2:
    Input: grid = [[3,3,1],[8,5,2]]
    Output: 4
    Explanation: The optimal path taken by the first robot is shown in red, and
                 the optimal path taken by the second robot is shown in blue.
                 The cells visited by the first robot are set to 0. The second
                 robot will collect 0 + 3 + 1 + 0 = 4 points.

    Example 3:
    Input: grid = [[1,3,1,15],[1,3,3,1]]
    Output: 7
    Explanation: The optimal path taken by the first robot is shown in red, and
                 the optimal path taken by the second robot is shown in blue.
                 The cells visited by the first robot are set to 0. The second
                 robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.

    Constraints:
    * grid.length == 2
    * n == grid[r].length
    * 1 <= n <= 5 * 10^4
    * 1 <= grid[r][c] <= 10^5"""

    def gridGame(self, grid: List[List[int]]) -> int:
        ans = inf
        prefix = 0
        suffix = sum(grid[0])
        for i in range(len(grid[0])):
            suffix -= grid[0][i]
            ans = min(ans, max(prefix, suffix))
            prefix += grid[1][i]
        return ans


    """2018. Check if Word Can Be Placed In Crossword (Medium)
    You are given an m x n matrix board, representing the current state of a
    crossword puzzle. The crossword contains lowercase English letters (from
    solved words), ' ' to represent any empty cells, and '#' to represent any
    blocked cells. A word can be placed horizontally (left to right or right to
    left) or vertically (top to bottom or bottom to top) in the board if:
    * It does not occupy a cell containing the character '#'.
    * The cell each letter is placed in must either be ' ' (empty) or match the
      letter already on the board.
    * There must not be any empty cells ' ' or other lowercase letters directly
      left or right of the word if the word was placed horizontally.
    * There must not be any empty cells ' ' or other lowercase letters directly
      above or below the word if the word was placed vertically.
    Given a string word, return true if word can be placed in board, or false
    otherwise.

    Example 1:
    Input: board = [["#", " ", "#"], [" ", " ", "#"], ["#", "c", " "]], word = "abc"
    Output: true
    Explanation: The word "abc" can be placed as shown above (top to bottom).

    Example 2:
    Input: board = [[" ", "#", "a"], [" ", "#", "c"], [" ", "#", "a"]], word = "ac"
    Output: false
    Explanation: It is impossible to place the word because there will always
                 be a space/letter above or below it.

    Example 3:
    Input: board = [["#", " ", "#"], [" ", " ", "#"], ["#", " ", "c"]], word = "ca"
    Output: true
    Explanation: The word "ca" can be placed as shown above (right to left).

    Constraints:
    * m == board.length
    * n == board[i].length
    * 1 <= m * n <= 2 * 10^5
    * board[i][j] will be ' ', '#', or a lowercase English letter.
    * 1 <= word.length <= max(m, n)
    * word will contain only lowercase English letters."""

    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:
        for x in board, zip(*board):
            for row in x:
                for s in "".join(row).split("#"):
                    for w in word, word[::-1]:
                        if len(s) == len(w) and all(ss in (" ", ww) for ss, ww in zip(s, w)): return True
        return False


    """2019. The Score of Students Solving Math Expression (Hard)
    You are given a string s that contains digits 0-9, addition symbols '+',
    and multiplication symbols '*' only, representing a valid math expression
    of single digit numbers (e.g., 3+5*2). This expression was given to n
    elementary school students. The students were instructed to get the answer
    of the expression by following this order of operations:
    * Compute multiplication, reading from left to right; Then,
    * Compute addition, reading from left to right.
    You are given an integer array answers of length n, which are the submitted
    answers of the students in no particular order. You are asked to grade the
    answers, by following these rules:
    * If an answer equals the correct answer of the expression, this student
      will be rewarded 5 points;
    * Otherwise, if the answer could be interpreted as if the student used the
      incorrect order of operations, once or multiple times, this student will
      be rewarded 2 points;
    * Otherwise, this student will be rewarded 0 points.
    Return the sum of the points of the students.

    Example 1:
    Input: s = "7+3*1*2", answers = [20,13,42]
    Output: 7
    Explanation: As illustrated above, the correct answer of the expression is
                 13, therefore one student is rewarded 5 points: [20,13,42]. A
                 student might have used this incorrect order of operations:
                 7+3=10, 10*1=10, 10*2=20. Therefore one student is rewarded 2
                 points: [20,13,42]. The points for the students are: [2,5,0].
                 The sum of the points is 2+5+0=7.

    Example 2:
    Input: s = "3+5*2", answers = [13,0,10,13,13,16,16]
    Output: 19
    Explanation: The correct answer of the expression is 13, therefore three
                 students are rewarded 5 points each: [13,0,10,13,13,16,16].
                 A student might have used this incorrect order of operations:
                 3+5=8, 8*2=16. Therefore two students are rewarded 2 points:
                 [13,0,10,13,13,16,16]. The points for the students are:
                 [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19.

    Example 3:
    Input: s = "6+0*1", answers = [12,9,6,4,8,6]
    Output: 10
    Explanation: The correct answer of the expression is 6. If a student had
                 used some incorrect order of operations, the answer would also
                 be 6. By the rules of grading, the students will still be
                 rewarded 5 points (as they got the correct answer), not 2
                 points. The points for the students are: [0,0,5,0,0,5]. The
                 sum of the points is 10.

    Constraints:
    * 3 <= s.length <= 31
    * s represents a valid expression that contains only digits 0-9, '+', and '*' only.
    * All the integer operands in the expression are in the inclusive range [0, 9].
    * 1 <= The count of all operators ('+' and '*') in the math expression <= 15
    * Test data are generated such that the correct answer of the expression is in the range of [0, 1000].
    * n == answers.length
    * 1 <= n <= 10^4
    * 0 <= answers[i] <= 1000"""

    def scoreOfStudents(self, s: str, answers: List[int]) -> int:

        @cache
        def fn(lo, hi):
            """Return possible answers of s[lo:hi]."""
            if lo+1 == hi: return {int(s[lo])}
            ans = set()
            for mid in range(lo+1, hi, 2):
                for x in fn(lo, mid):
                    for y in fn(mid+1, hi):
                        if s[mid] == "+" and x + y <= 1000: ans.add(x + y)
                        elif s[mid] == "*" and x * y <= 1000: ans.add(x * y)
            return ans

        target = eval(s)
        cand = fn(0, len(s))
        ans = 0
        for x in answers:
            if x == target: ans += 5
            elif x in cand: ans += 2
        return ans


    """2021. Brightest Position on Street (Medium)
    A perfectly straight street is represented by a number line. The street has
    street lamp(s) on it and is represented by a 2D integer array lights. Each
    lights[i] = [positioni, rangei] indicates that there is a street lamp at
    position positioni that lights up the area from
    [positioni - rangei, positioni + rangei] (inclusive). The brightness of a
    position p is defined as the number of street lamp that light up the
    position p. Given lights, return the brightest position on the street. If
    there are multiple brightest positions, return the smallest one.

    Example 1:
    Input: lights = [[-3,2],[1,2],[3,3]]
    Output: -1
    Explanation: The first street lamp lights up the area from
                 [(-3) - 2, (-3) + 2] = [-5, -1]. The second street lamp lights
                 up the area from [1 - 2, 1 + 2] = [-1, 3]. The third street
                 lamp lights up the area from [3 - 3, 3 + 3] = [0, 6]. Position
                 -1 has a brightness of 2, illuminated by the first and second
                 street light. Positions 0, 1, 2, and 3 have a brightness of 2,
                 illuminated by the second and third street light. Out of all
                 these positions, -1 is the smallest, so return it.

    Example 2:
    Input: lights = [[1,0],[0,1]]
    Output: 1
    Explanation: The first street lamp lights up the area from [1 - 0, 1 + 0] =
                 [1, 1]. The second street lamp lights up the area from
                 [0 - 1, 0 + 1] = [-1, 1]. Position 1 has a brightness of 2,
                 illuminated by the first and second street light. Return 1
                 because it is the brightest position on the street.

    Example 3:
    Input: lights = [[1,2]]
    Output: -1
    Explanation: The first street lamp lights up the area from [1 - 2, 1 + 2] =
                 [-1, 3]. Positions -1, 0, 1, 2, and 3 have a brightness of 1,
                 illuminated by the first street light. Out of all these
                 positions, -1 is the smallest, so return it.

    Constraints:
    * 1 <= lights.length <= 10^5
    * lights[i].length == 2
    * -10^8 <= positioni <= 10^8
    * 0 <= rangei <= 10^8"""

    def brightestPosition(self, lights: List[List[int]]) -> int:
        line = []
        for pos, rng in lights:
            line.append((pos-rng, 1))
            line.append((pos+rng+1, -1))
        ans = most = prefix = 0
        for x, v in sorted(line):
            prefix += v
            if prefix > most:
                ans = x
                most = prefix
        return ans


    """2022. Convert 1D Array Into 2D Array (Easy)
    You are given a 0-indexed 1-dimensional (1D) integer array original, and
    two integers, m and n. You are tasked with creating a 2-dimensional (2D)
    array with m rows and n columns using all the elements from original. The
    elements from indices 0 to n - 1 (inclusive) of original should form the
    first row of the constructed 2D array, the elements from indices n to
    2 * n - 1 (inclusive) should form the second row of the constructed 2D
    array, and so on. Return an m x n 2D array constructed according to the
    above procedure, or an empty 2D array if it is impossible.

    Example 1:
    Input: original = [1,2,3,4], m = 2, n = 2
    Output: [[1,2],[3,4]]
    Explanation: The constructed 2D array should contain 2 rows and 2 columns.
                 The first group of n=2 elements in original, [1,2], becomes
                 the first row in the constructed 2D array. The second group of
                 n=2 elements in original, [3,4], becomes the second row in the
                 constructed 2D array.

    Example 2:
    Input: original = [1,2,3], m = 1, n = 3
    Output: [[1,2,3]]
    Explanation: The constructed 2D array should contain 1 row and 3 columns.
                 Put all three elements in original into the first row of the
                 constructed 2D array.

    Example 3:
    Input: original = [1,2], m = 1, n = 1
    Output: []
    Explanation: There are 2 elements in original. It is impossible to fit 2
                 elements in a 1x1 2D array, so return an empty 2D array.

    Example 4:
    Input: original = [3], m = 1, n = 2
    Output: []
    Explanation: There is 1 element in original. It is impossible to make 1
                 element fill all the spots in a 1x2 2D array, so return an
                 empty 2D array.

    Constraints:
    * 1 <= original.length <= 5 * 10^4
    * 1 <= original[i] <= 10^5
    * 1 <= m, n <= 4 * 10^4"""

    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        ans = []
        if len(original) == m*n:
            for i in range(0, len(original), n):
                ans.append(original[i:i+n])
        return ans


    """2023. Number of Pairs of Strings With Concatenation Equal to Target (Medium)
    Given an array of digit strings nums and a digit string target, return the
    number of pairs of indices (i, j) (where i != j) such that the
    concatenation of nums[i] + nums[j] equals target.

    Example 1:
    Input: nums = ["777","7","77","77"], target = "7777"
    Output: 4
    Explanation: Valid pairs are:
                 - (0, 1): "777" + "7"
                 - (1, 0): "7" + "777"
                 - (2, 3): "77" + "77"
                 - (3, 2): "77" + "77"

    Example 2:
    Input: nums = ["123","4","12","34"], target = "1234"
    Output: 2
    Explanation: Valid pairs are:
                 - (0, 1): "123" + "4"
                 - (2, 3): "12" + "34"

    Example 3:
    Input: nums = ["1","1","1"], target = "11"
    Output: 6
    Explanation: Valid pairs are:
                 - (0, 1): "1" + "1"
                 - (1, 0): "1" + "1"
                 - (0, 2): "1" + "1"
                 - (2, 0): "1" + "1"
                 - (1, 2): "1" + "1"
                 - (2, 1): "1" + "1"

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i].length <= 100
    * 2 <= target.length <= 100
    * nums[i] and target consist of digits.
    * nums[i] and target do not have leading zeros."""

    def numOfPairs(self, nums: List[str], target: str) -> int:
        freq = Counter(nums)
        ans = 0
        for k, v in freq.items():
            if target.startswith(k):
                suffix = target[len(k):]
                ans += v * freq[suffix]
                if k == suffix: ans -= freq[suffix]
        return ans


    """2024. Maximize the Confusion of an Exam (Medium)
    A teacher is writing a test with n true/false questions, with 'T' denoting
    true and 'F' denoting false. He wants to confuse the students by maximizing
    the number of consecutive questions with the same answer (multiple trues or
    multiple falses in a row). You are given a string answerKey, where
    answerKey[i] is the original answer to the ith question. In addition, you
    are given an integer k, the maximum number of times you may perform the
    following operation:
    * Change the answer key for any question to 'T' or 'F' (i.e., set
      answerKey[i] to 'T' or 'F').
    Return the maximum number of consecutive 'T's or 'F's in the answer key
    after performing the operation at most k times.

    Example 1:
    Input: answerKey = "TTFF", k = 2
    Output: 4
    Explanation: We can replace both the 'F's with 'T's to make
                 answerKey = "TTTT". There are four consecutive 'T's.

    Example 2:
    Input: answerKey = "TFFT", k = 1
    Output: 3
    Explanation: We can replace the first 'T' with an 'F' to make
                 answerKey = "FFFT". Alternatively, we can replace the second
                 'T' with an 'F' to make answerKey = "TFFF". In both cases,
                 there are three consecutive 'F's.

    Example 3:
    Input: answerKey = "TTFTTFTT", k = 1
    Output: 5
    Explanation: We can replace the first 'F' to make answerKey = "TTTTTFTT"
                 Alternatively, we can replace the second 'F' to make
                 answerKey = "TTFTTTTT". In both cases, there are five
                 consecutive 'T's.

    Constraints:
    * n == answerKey.length
    * 1 <= n <= 5 * 10^4
    * answerKey[i] is either 'T' or 'F'
    * 1 <= k <= n"""

    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:

        def fn(target):
            """Return max consecutive target."""
            ans = cnt = ii = 0
            for i, x in enumerate(answerKey):
                if x == target: cnt += 1
                while cnt > k:
                    if answerKey[ii] == target: cnt -= 1
                    ii += 1
                ans = max(ans, i - ii + 1)
            return ans

        return max(fn("T"), fn("F"))


    """2025. Maximum Number of Ways to Partition an Array (Hard)
    You are given a 0-indexed integer array nums of length n. The number of
    ways to partition nums is the number of pivot indices that satisfy both
    conditions:
    * 1 <= pivot < n
    * nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]
    You are also given an integer k. You can choose to change the value of one
    element of nums to k, or to leave the array unchanged. Return the maximum
    possible number of ways to partition nums to satisfy both conditions after
    changing at most one element.

    Example 1:
    Input: nums = [2,-1,2], k = 3
    Output: 1
    Explanation: One optimal approach is to change nums[0] to k. The array
                 becomes [3,-1,2]. There is one way to partition the array:
                 - For pivot = 2, we have the partition [3,-1 | 2]:
                   3 + -1 == 2.

    Example 2:
    Input: nums = [0,0,0], k = 1
    Output: 2
    Explanation: The optimal approach is to leave the array unchanged. There
                 are two ways to partition the array:
                 - For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.
                 - For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.

    Example 3:
    Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33
    Output: 4
    Explanation: One optimal approach is to change nums[2] to k. The array
                 becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14]. There
                 are four ways to partition the array.

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^5
    * -10^5 <= k, nums[i] <= 10^5"""

    def waysToPartition(self, nums: List[int], k: int) -> int:
        prefix = [0]
        loc = defaultdict(list)
        for i, x in enumerate(nums):
            prefix.append(prefix[-1] + x)
            if i < len(nums)-1: loc[prefix[-1]].append(i)

        ans = 0
        if prefix[-1] % 2 == 0: ans = len(loc[prefix[-1]//2]) # unchanged

        total = prefix[-1]
        for i, x in enumerate(nums):
            cnt = 0
            diff = k - x
            target = total + diff
            if target % 2 == 0:
                target //= 2
                cnt += bisect_left(loc[target], i)
                cnt += len(loc[target-diff]) - bisect_left(loc[target-diff], i)
            ans = max(ans, cnt)
        return ans


    """2027. Minimum Moves to Convert String (Easy)
    You are given a string s consisting of n characters which are either 'X' or
    'O'. A move is defined as selecting three consecutive characters of s and
    converting them to 'O'. Note that if a move is applied to the character 'O',
    it will stay the same. Return the minimum number of moves required so that
    all the characters of s are converted to 'O'.

    Example 1:
    Input: s = "XXX"
    Output: 1
    Explanation: XXX -> OOO. We select all the 3 characters and convert them in
                 one move.

    Example 2:
    Input: s = "XXOX"
    Output: 2
    Explanation: XXOX -> OOOX -> OOOO. We select the first 3 characters in the
                 first move, and convert them to 'O'. Then we select the last 3
                 characters and convert them so that the final string contains
                 all 'O's.

    Example 3:
    Input: s = "OOOO"
    Output: 0
    Explanation: There are no 'X's in s to convert.

    Constraints:
    * 3 <= s.length <= 1000
    * s[i] is either 'X' or 'O'."""

    def minimumMoves(self, s: str) -> int:
        ans = i = 0
        while i < len(s):
            if s[i] == "X":
                ans += 1
                i += 3
            else: i += 1
        return ans


    """2028. Find Missing Observations (Medium)
    You have observations of n + m 6-sided dice rolls with each face numbered
    from 1 to 6. n of the observations went missing, and you only have the
    observations of m rolls. Fortunately, you have also calculated the average
    value of the n + m rolls. You are given an integer array rolls of length m
    where rolls[i] is the value of the ith observation. You are also given the
    two integers mean and n. Return an array of length n containing the missing
    observations such that the average value of the n + m rolls is exactly mean.
    If there are multiple valid answers, return any of them. If no such array
    exists, return an empty array. The average value of a set of k numbers is
    the sum of the numbers divided by k. Note that mean is an integer, so the
    sum of the n + m rolls should be divisible by n + m.

    Example 1:
    Input: rolls = [3,2,4,3], mean = 4, n = 2
    Output: [6,6]
    Explanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.

    Example 2:
    Input: rolls = [1,5,6], mean = 3, n = 4
    Output: [2,3,2,2]
    Explanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.

    Example 3:
    Input: rolls = [1,2,3,4], mean = 6, n = 4
    Output: []
    Explanation: It is impossible for the mean to be 6 no matter what the 4
                 missing rolls are.

    Example 4:
    Input: rolls = [1], mean = 3, n = 1
    Output: [5]
    Explanation: The mean of all n + m rolls is (1 + 5) / 2 = 3.

    Constraints:
    * m == rolls.length
    * 1 <= n, m <= 10^5
    * 1 <= rolls[i], mean <= 6"""

    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
        m = len(rolls)
        total = mean*(m+n) - sum(rolls)
        if n <= total <= 6*n:
            q, r = divmod(total, n)
            return [q+1]*r + [q]*(n-r)
        return []


    """2029. Stone Game IX (Medium)
    Alice and Bob continue their games with stones. There is a row of n stones,
    and each stone has an associated value. You are given an integer array
    stones, where stones[i] is the value of the ith stone. Alice and Bob take
    turns, with Alice starting first. On each turn, the player may remove any
    stone from stones. The player who removes a stone loses if the sum of the
    values of all removed stones is divisible by 3. Bob will win automatically
    if there are no remaining stones (even if it is Alice's turn). Assuming
    both players play optimally, return true if Alice wins and false if Bob
    wins.

    Example 1:
    Input: stones = [2,1]
    Output: true
    Explanation: The game will be played as follows:
                 - Turn 1: Alice can remove either stone.
                 - Turn 2: Bob removes the remaining stone.
                 The sum of the removed stones is 1 + 2 = 3 and is divisible by
                 3. Therefore, Bob loses and Alice wins the game.

    Example 2:
    Input: stones = [2]
    Output: false
    Explanation: Alice will remove the only stone, and the sum of the values on
                 the removed stones is 2. Since all the stones are removed and
                 the sum of values is not divisible by 3, Bob wins the game.

    Example 3:
    Input: stones = [5,1,2,4,3]
    Output: false
    Explanation: Bob will always win. One possible way for Bob to win is shown
                 below:
                 - Turn 1: Alice can remove the second stone with value 1. Sum
                   of removed stones = 1.
                 - Turn 2: Bob removes the fifth stone with value 3. Sum of
                   removed stones = 1 + 3 = 4.
                 - Turn 3: Alices removes the fourth stone with value 4. Sum of
                   removed stones = 1 + 3 + 4 = 8.
                 - Turn 4: Bob removes the third stone with value 2. Sum of
                   removed stones = 1 + 3 + 4 + 2 = 10.
                 - Turn 5: Alice removes the first stone with value 5. Sum of
                   removed stones = 1 + 3 + 4 + 2 + 5 = 15.
                 Alice loses the game because the sum of the removed stones (15)
                 is divisible by 3. Bob wins the game.

    Constraints:
    * 1 <= stones.length <= 10^5
    * 1 <= stones[i] <= 10^4"""

    def stoneGameIX(self, stones: List[int]) -> bool:
        freq = defaultdict(int)
        for x in stones: freq[x % 3] += 1
        if freq[0]%2 == 0: return freq[1] and freq[2]
        return abs(freq[1] - freq[2]) >= 3


    """2030. Smallest K-Length Subsequence With Occurrences of a Letter (Hard)
    You are given a string s, an integer k, a letter letter, and an integer
    repetition. Return the lexicographically smallest subsequence of s of
    length k that has the letter letter appear at least repetition times. The
    test cases are generated so that the letter appears in s at least
    repetition times. A subsequence is a string that can be derived from
    another string by deleting some or no characters without changing the order
    of the remaining characters. A string a is lexicographically smaller than a
    string b if in the first position where a and b differ, string a has a
    letter that appears earlier in the alphabet than the corresponding letter
    in b.

    Example 1:
    Input: s = "leet", k = 3, letter = "e", repetition = 1
    Output: "eet"
    Explanation: There are four subsequences of length 3 that have the letter
                 'e' appear at least 1 time:
                 - "lee" (from "leet")
                 - "let" (from "leet")
                 - "let" (from "leet")
                 - "eet" (from "leet")
                 The lexicographically smallest subsequence among them is "eet".

    Example 2:
    example-2
    Input: s = "leetcode", k = 4, letter = "e", repetition = 2
    Output: "ecde"
    Explanation: "ecde" is the lexicographically smallest subsequence of length
                 4 that has the letter "e" appear at least 2 times.

    Example 3:
    Input: s = "bb", k = 2, letter = "b", repetition = 2
    Output: "bb"
    Explanation: "bb" is the only subsequence of length 2 that has the letter
                 "b" appear at least 2 times.

    Constraints:
    * 1 <= repetition <= k <= s.length <= 5 * 10^4
    * s consists of lowercase English letters.
    * letter is a lowercase English letter, and appears in s at least
      repetition times."""

    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        rest = sum(x == letter for x in s)
        stack = []
        for i, x in enumerate(s):
            while stack and stack[-1] > x and len(stack) + len(s) - i > k and (stack[-1] != letter or repetition < rest):
                if stack.pop() == letter: repetition += 1
            if len(stack) < k and (x == letter or len(stack) + repetition < k):
                stack.append(x)
                if x == letter: repetition -= 1
            if x == letter: rest -= 1
        return "".join(stack)


    """2031. Count Subarrays With More Ones Than Zeros (Medium)
    You are given a binary array nums containing only the integers 0 and 1.
    Return the number of subarrays in nums that have more 1's than 0's. Since
    the answer may be very large, return it modulo 10^9 + 7. A subarray is a
    contiguous sequence of elements within an array.

    Example 1:
    Input: nums = [0,1,1,0,1]
    Output: 9
    Explanation: The subarrays of size 1 that have more ones than zeros are:
                 [1], [1], [1]. The subarrays of size 2 that have more ones
                 than zeros are: [1,1]. The subarrays of size 3 that have more
                 ones than zeros are: [0,1,1], [1,1,0], [1,0,1]. The subarrays
                 of size 4 that have more ones than zeros are: [1,1,0,1]. The
                 subarrays of size 5 that have more ones than zeros are:
                 [0,1,1,0,1].

    Example 2:
    Input: nums = [0]
    Output: 0
    Explanation: No subarrays have more ones than zeros.

    Example 3:
    Input: nums = [1]
    Output: 1
    Explanation: The subarrays of size 1 that have more ones than zeros are: [1].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1"""

    def subarraysWithMoreZerosThanOnes(self, nums: List[int]) -> int:
        ans = dp = prefix = 0
        freq = Counter({0 : 1})
        for x in nums:
            if x: dp += freq[prefix]
            else: dp -= freq[prefix-1]
            ans = (ans + dp) % 1_000_000_007
            prefix += 2*x-1
            freq[prefix] += 1
        return ans


    """2032. Two Out of Three (Easy)
    Given three integer arrays nums1, nums2, and nums3, return a distinct array
    containing all the values that are present in at least two out of the three
    arrays. You may return the values in any order.

    Example 1:
    Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]
    Output: [3,2]
    Explanation: The values that are present in at least two arrays are:
                 - 3, in all three arrays.
                 - 2, in nums1 and nums2.

    Example 2:
    Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]
    Output: [2,3,1]
    Explanation: The values that are present in at least two arrays are:
                 - 2, in nums2 and nums3.
                 - 3, in nums1 and nums2.
                 - 1, in nums1 and nums3.

    Example 3:
    Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]
    Output: []
    Explanation: No value is present in at least two arrays.

    Constraints:
    * 1 <= nums1.length, nums2.length, nums3.length <= 100
    * 1 <= nums1[i], nums2[j], nums3[k] <= 100"""

    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        s1, s2, s3 = set(nums1), set(nums2), set(nums3)
        return (s1&s2) | (s2&s3) | (s1&s3)


    """2033. Minimum Operations to Make a Uni-Value Grid (Medium)
    You are given a 2D integer grid of size m x n and an integer x. In one
    operation, you can add x to or subtract x from any element in the grid. A
    uni-value grid is a grid where all the elements of it are equal. Return the
    minimum number of operations to make the grid uni-value. If it is not
    possible, return -1.

    Example 1:
    Input: grid = [[2,4],[6,8]], x = 2
    Output: 4
    Explanation: We can make every element equal to 4 by doing the following:
                 - Add x to 2 once.
                 - Subtract x from 6 once.
                 - Subtract x from 8 twice.
                 A total of 4 operations were used.

    Example 2:
    Input: grid = [[1,5],[2,3]], x = 1
    Output: 5
    Explanation: We can make every element equal to 3.

    Example 3:
    Input: grid = [[1,2],[3,4]], x = 2
    Output: -1
    Explanation: It is impossible to make every element equal.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 1 <= x, grid[i][j] <= 10^4"""

    def minOperations(self, grid: List[List[int]], x: int) -> int:
        vals = [x for row in grid for x in row]
        if len(set(val%x for val in vals)) > 1: return -1 # impossible
        median = sorted(vals)[len(vals)//2] # O(N) possible via "quick select"
        return sum(abs(val - median)//x for val in vals)


    """2035. Partition Array Into Two Arrays to Minimize Sum Difference (Hard)
    You are given an integer array nums of 2 * n integers. You need to
    partition nums into two arrays of length n to minimize the absolute
    difference of the sums of the arrays. To partition nums, put each element
    of nums into one of the two arrays. Return the minimum possible absolute
    difference.

    Example 1:
    Input: nums = [3,9,7,3]
    Output: 2
    Explanation: One optimal partition is: [3,9] and [7,3]. The absolute
                 difference between the sums of the arrays is
                 abs((3 + 9) - (7 + 3)) = 2.

    Example 2:
    Input: nums = [-36,36]
    Output: 72
    Explanation: One optimal partition is: [-36] and [36]. The absolute
                 difference between the sums of the arrays is
                 abs((-36) - (36)) = 72.

    Example 3:
    Input: nums = [2,-1,0,4,-2,-9]
    Output: 0
    Explanation: One optimal partition is: [2,4,-9] and [-1,0,-2]. The absolute
                 difference between the sums of the arrays is
                 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.

    Constraints:
    * 1 <= n <= 15
    * nums.length == 2 * n
    * -10^7 <= nums[i] <= 10^7"""

    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums)//2
        left, right = nums[:n], nums[n:]
        lsum, rsum = sum(left), sum(right)

        ans = inf
        for i in range(n+1):
            vals = sorted(2*sum(combo)-lsum for combo in combinations(left, i))
            for combo in combinations(right, n-i):
                diff = 2*sum(combo) - rsum
                k = bisect_left(vals, -diff)
                if k: ans = min(ans, abs(vals[k-1] + diff))
                if k < len(vals): ans = min(ans, abs(vals[k] + diff))
        return ans


    """2036. Maximum Alternating Subarray Sum (Medium)
    A subarray of a 0-indexed integer array is a contiguous non-empty sequence
    of elements within an array. The alternating subarray sum of a subarray
    that ranges from index i to j (inclusive, 0 <= i <= j < nums.length) is
    nums[i] - nums[i+1] + nums[i+2] - ... +/- nums[j]. Given a 0-indexed
    integer array nums, return the maximum alternating subarray sum of any
    subarray of nums.

    Example 1:
    Input: nums = [3,-1,1,2]
    Output: 5
    Explanation: The subarray [3,-1,1] has the largest alternating subarray
                 sum. The alternating subarray sum is 3 - (-1) + 1 = 5.

    Example 2:
    Input: nums = [2,2,2,2,2]
    Output: 2
    Explanation: The subarrays [2], [2,2,2], and [2,2,2,2,2] have the largest
                 alternating subarray sum. The alternating subarray sum of [2]
                 is 2. The alternating subarray sum of [2,2,2] is 2 - 2 + 2 = 2.
                 The alternating subarray sum of [2,2,2,2,2] is
                 2 - 2 + 2 - 2 + 2 = 2.

    Example 3:
    Input: nums = [1]
    Output: 1
    Explanation: There is only one non-empty subarray, which is [1]. The
                 alternating subarray sum is 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^5 <= nums[i] <= 10^5"""

    def maximumAlternatingSubarraySum(self, nums: List[int]) -> int:
        ans = pos = neg = -inf
        for x in nums:
            pos, neg = max(x, neg+x), pos-x
            ans = max(ans, pos, neg)
        return ans


    """2037. Minimum Number of Moves to Seat Everyone (Easy)
    There are n seats and n students in a room. You are given an array seats of
    length n, where seats[i] is the position of the ith seat. You are also
    given the array students of length n, where students[j] is the position of
    the jth student. You may perform the following move any number of times:
    * Increase or decrease the position of the ith student by 1 (i.e., moving
      the ith student from position x to x + 1 or x - 1)
    * Return the minimum number of moves required to move each student to a
      seat such that no two students are in the same seat.
    Note that there may be multiple seats or students in the same position at
    the beginning.

    Example 1:
    Input: seats = [3,1,5], students = [2,7,4]
    Output: 4
    Explanation: The students are moved as follows:
                 - The first student is moved from from position 2 to position 1 using 1 move.
                 - The second student is moved from from position 7 to position 5 using 2 moves.
                 - The third student is moved from from position 4 to position 3 using 1 move.
                 In total, 1 + 2 + 1 = 4 moves were used.

    Example 2:
    Input: seats = [4,1,5,9], students = [1,3,2,6]
    Output: 7
    Explanation: The students are moved as follows:
                 - The first student is not moved.
                 - The second student is moved from from position 3 to position 4 using 1 move.
                 - The third student is moved from from position 2 to position 5 using 3 moves.
                 - The fourth student is moved from from position 6 to position 9 using 3 moves.
                 In total, 0 + 1 + 3 + 3 = 7 moves were used.

    Example 3:
    Input: seats = [2,2,6,6], students = [1,3,2,6]
    Output: 4
    Explanation: The students are moved as follows:
                 - The first student is moved from from position 1 to position 2 using 1 move.
                 - The second student is moved from from position 3 to position 6 using 3 moves.
                 - The third student is not moved.
                 - The fourth student is not moved.
                 In total, 1 + 3 + 0 + 0 = 4 moves were used.

    Constraints:
    * n == seats.length == students.length
    * 1 <= n <= 100
    * 1 <= seats[i], students[j] <= 100"""

    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        return sum(abs(x-y) for x, y in zip(*map(sorted, (seats, students))))


    """2038. Remove Colored Pieces if Both Neighbors are the Same Color (Medium)
    There are n pieces arranged in a line, and each piece is colored either by
    'A' or by 'B'. You are given a string colors of length n where colors[i] is
    the color of the ith piece. Alice and Bob are playing a game where they
    take alternating turns removing pieces from the line. In this game, Alice
    moves first.
    * Alice is only allowed to remove a piece colored 'A' if both its neighbors
      are also colored 'A'. She is not allowed to remove pieces that are
      colored 'B'.
    * Bob is only allowed to remove a piece colored 'B' if both its neighbors
      are also colored 'B'. He is not allowed to remove pieces that are colored
      'A'.
    * Alice and Bob cannot remove pieces from the edge of the line.
    * If a player cannot make a move on their turn, that player loses and the
      other player wins.
    Assuming Alice and Bob play optimally, return true if Alice wins, or return
    false if Bob wins.

    Example 1:
    Input: colors = "AAABABB"
    Output: true
    Explanation: AAABABB -> AABABB
                 Alice moves first. She removes the second 'A' from the left
                 since that is the only 'A' whose neighbors are both 'A'. Now
                 it's Bob's turn. Bob cannot make a move on his turn since
                 there are no 'B's whose neighbors are both 'B'. Thus, Alice
                 wins, so return true.

    Example 2:
    Input: colors = "AA"
    Output: false
    Explanation: Alice has her turn first. There are only two 'A's and both are
                 on the edge of the line, so she cannot move on her turn. Thus,
                 Bob wins, so return false.

    Example 3:
    Input: colors = "ABBBBBBBAAA"
    Output: false
    Explanation: ABBBBBBBAAA -> ABBBBBBBAA
                 Alice moves first. Her only option is to remove the second to
                 last 'A' from the right.
                 ABBBBBBBAA -> ABBBBBBAA
                 Next is Bob's turn. He has many options for which 'B' piece to
                 remove. He can pick any. On Alice's second turn, she has no
                 more pieces that she can remove. Thus, Bob wins, so return
                 false.

    Constraints:
    * 1 <= colors.length <= 10^5
    * colors consists of only the letters 'A' and 'B'"""

    def winnerOfGame(self, colors: str) -> bool:
        diff = 0
        for k, grp in groupby(colors):
            if k == "A": diff += max(0, len(list(grp)) - 2)
            else: diff -= max(0, len(list(grp)) - 2)
        return diff > 0


    """2039. The Time When the Network Becomes Idle (Medium)
    There is a network of n servers, labeled from 0 to n - 1. You are given a
    2D integer array edges, where edges[i] = [ui, vi] indicates there is a
    message channel between servers ui and vi, and they can pass any number of
    messages to each other directly in one second. You are also given a
    0-indexed integer array patience of length n. All servers are connected,
    i.e., a message can be passed from one server to any other server(s)
    directly or indirectly through the message channels. The server labeled 0
    is the master server. The rest are data servers. Each data server needs to
    send its message to the master server for processing and wait for a reply.
    Messages move between servers optimally, so every message takes the least
    amount of time to arrive at the master server. The master server will
    process all newly arrived messages instantly and send a reply to the
    originating server via the reversed path the message had gone through. At
    the beginning of second 0, each data server sends its message to be
    processed. Starting from second 1, at the beginning of every second, each
    data server will check if it has received a reply to the message it sent
    (including any newly arrived replies) from the master server:
    * If it has not, it will resend the message periodically. The data server
      i will resend the message every patience[i] second(s), i.e., the data
      server i will resend the message if patience[i] second(s) have elapsed
      since the last time the message was sent from this server.
    * Otherwise, no more resending will occur from this server.
    The network becomes idle when there are no messages passing between servers
    or arriving at servers. Return the earliest second starting from which the
    network becomes idle.

    Example 1:
    Input: edges = [[0,1],[1,2]], patience = [0,2,1]
    Output: 8
    Explanation: At (the beginning of) second 0,
                 - Data server 1 sends its message (denoted 1A) to the master server.
                 - Data server 2 sends its message (denoted 2A) to the master server.
                 At second 1,
                 - Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.
                 - Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.
                 - Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).
                 At second 2,
                 - The reply 1A arrives at server 1. No more resending will occur from server 1.
                 - Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.
                 - Server 2 resends the message (denoted 2C).
                 ...
                 At second 4,
                 - The reply 2A arrives at server 2. No more resending will occur from server 2.
                 ...
                 At second 7, reply 2D arrives at server 2.
                 Starting from the beginning of the second 8, there are no
                 messages passing between servers or arriving at servers. This
                 is the time when the network becomes idle.

    Example 2:
    Input: edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]
    Output: 3
    Explanation: Data servers 1 and 2 receive a reply back at the beginning of
                 second 2. From the beginning of the second 3, the network
                 becomes idle.

    Constraints:
    * n == patience.length
    * 2 <= n <= 10^5
    * patience[0] == 0
    * 1 <= patience[i] <= 10^5 for 1 <= i < n
    * 1 <= edges.length <= min(10^5, n * (n - 1) / 2)
    * edges[i].length == 2
    * 0 <= ui, vi < n
    * ui != vi
    * There are no duplicate edges.
    * Each server can directly or indirectly reach another server."""

    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:
        graph = {}
        for u, v in edges:
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)

        dist = [-1]*len(graph)
        dist[0] = 0
        val = 0
        queue = [0]
        while queue:
            val += 2
            newq = []
            for u in queue:
                for v in graph[u]:
                    if dist[v] == -1:
                        dist[v] = val
                        newq.append(v)
            queue = newq

        ans = 0
        for d, p in zip(dist, patience):
            if p:
                k = d//p - int(d%p == 0)
                ans = max(ans, d + k*p)
        return ans + 1


    """2040. Kth Smallest Product of Two Sorted Arrays (Hard)
    Given two sorted 0-indexed integer arrays nums1 and nums2 as well as an
    integer k, return the kth (1-based) smallest product of nums1[i] * nums2[j]
    where 0 <= i < nums1.length and 0 <= j < nums2.length.

    Example 1:
    Input: nums1 = [2,5], nums2 = [3,4], k = 2
    Output: 8
    Explanation: The 2 smallest products are:
                 - nums1[0] * nums2[0] = 2 * 3 = 6
                 - nums1[0] * nums2[1] = 2 * 4 = 8
                 The 2nd smallest product is 8.

    Example 2:
    Input: nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6
    Output: 0
    Explanation: The 6 smallest products are:
                 - nums1[0] * nums2[1] = (-4) * 4 = -16
                 - nums1[0] * nums2[0] = (-4) * 2 = -8
                 - nums1[1] * nums2[1] = (-2) * 4 = -8
                 - nums1[1] * nums2[0] = (-2) * 2 = -4
                 - nums1[2] * nums2[0] = 0 * 2 = 0
                 - nums1[2] * nums2[1] = 0 * 4 = 0
                 The 6th smallest product is 0.

    Example 3:
    Input: nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3
    Output: -6
    Explanation: The 3 smallest products are:
                 - nums1[0] * nums2[4] = (-2) * 5 = -10
                 - nums1[0] * nums2[3] = (-2) * 4 = -8
                 - nums1[4] * nums2[0] = 2 * (-3) = -6
                 The 3rd smallest product is -6.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 5 * 10^4
    * -10^5 <= nums1[i], nums2[j] <= 10^5
    * 1 <= k <= nums1.length * nums2.length
    * nums1 and nums2 are sorted."""

    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        neg = [x for x in nums1 if x < 0]
        pos = [x for x in nums1 if x >= 0]

        def fn(val):
            """Return count of products <= val."""
            ans = 0
            lo, hi = 0, len(nums2)-1
            for x in neg[::-1] + pos if val >= 0 else neg + pos[::-1]:
                if x < 0:
                    while lo < len(nums2) and x*nums2[lo] > val: lo += 1
                    ans += len(nums2) - lo
                elif x == 0:
                    if 0 <= val: ans += len(nums2)
                else:
                    while 0 <= hi and x*nums2[hi] > val: hi -= 1
                    ans += hi+1
            return ans

        lo, hi = -10**10, 10**10 + 1
        while lo < hi:
            mid = lo + hi >> 1
            if fn(mid) < k: lo = mid + 1
            else: hi = mid
        return lo


    """2042. Check if Numbers Are Ascending in a Sentence (Easy)
    A sentence is a list of tokens separated by a single space with no leading
    or trailing spaces. Every token is either a positive number consisting of
    digits 0-9 with no leading zeros, or a word consisting of lowercase English
    letters. For example, "a puppy has 2 eyes 4 legs" is a sentence with seven
    tokens: "2" and "4" are numbers and the other tokens such as "puppy" are
    words. Given a string s representing a sentence, you need to check if all
    the numbers in s are strictly increasing from left to right (i.e., other
    than the last number, each number is strictly smaller than the number on
    its right in s). Return true if so, or false otherwise.

    Example 1:
    Input: s = "1 box has 3 blue 4 red 6 green and 12 yellow marbles"
    Output: true
    Explanation: The numbers in s are: 1, 3, 4, 6, 12. They are strictly
                 increasing from left to right: 1 < 3 < 4 < 6 < 12.

    Example 2:
    Input: s = "hello world 5 x 5"
    Output: false
    Explanation: The numbers in s are: 5, 5. They are not strictly increasing.

    Example 3:
    Input: s = "sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s"
    Output: false
    Explanation: The numbers in s are: 7, 51, 50, 60. They are not strictly increasing.

    Example 4:
    Input: s = "4 5 11 26"
    Output: true
    Explanation: The numbers in s are: 4, 5, 11, 26. They are strictly
                 increasing from left to right: 4 < 5 < 11 < 26.

    Constraints:
    * 3 <= s.length <= 200
    * s consists of lowercase English letters, spaces, and digits from 0 to 9,
      inclusive.
    * The number of tokens in s is between 2 and 100, inclusive.
    * The tokens in s are separated by a single space.
    * There are at least two numbers in s.
    * Each number in s is a positive number less than 100, with no leading
      zeros.
    * s contains no leading or trailing spaces."""

    def areNumbersAscending(self, s: str) -> bool:
        nums = [int(w) for w in s.split() if w.isdigit()]
        return all(nums[i-1] < nums[i] for i in range(1, len(nums)))


    """2044. Count Number of Maximum Bitwise-OR Subsets (Medium)
    Given an integer array nums, find the maximum possible bitwise OR of a
    subset of nums and return the number of different non-empty subsets with
    the maximum bitwise OR. An array a is a subset of an array b if a can be
    obtained from b by deleting some (possibly zero) elements of b. Two subsets
    are considered different if the indices of the elements chosen are
    different. The bitwise OR of an array a is equal to
    a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).

    Example 1:
    Input: nums = [3,1]
    Output: 2
    Explanation: The maximum possible bitwise OR of a subset is 3. There are 2
                 subsets with a bitwise OR of 3:
                 - [3]
                 - [3,1]

    Example 2:
    Input: nums = [2,2,2]
    Output: 7
    Explanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There
                 are 2^3 - 1 = 7 total subsets.

    Example 3:
    Input: nums = [3,2,1,5]
    Output: 6
    Explanation: The maximum possible bitwise OR of a subset is 7. There are 6
                 subsets with a bitwise OR of 7:
                 - [3,5]
                 - [3,1,5]
                 - [3,2,5]
                 - [3,2,1,5]
                 - [2,5]
                 - [2,1,5]

    Constraints:
    * 1 <= nums.length <= 16
    * 1 <= nums[i] <= 10^5"""

    def countMaxOrSubsets(self, nums: List[int]) -> int:
        target = reduce(or_, nums)

        @cache
        def fn(i, mask):
            """Return number of subsets to get target."""
            if mask == target: return 2**(len(nums)-i)
            if i == len(nums): return 0
            return fn(i+1, mask | nums[i]) + fn(i+1, mask)

        return fn(0, 0)


    """2045. Second Minimum Time to Reach Destination (Hard)
    A city is represented as a bi-directional connected graph with n vertices
    where each vertex is labeled from 1 to n (inclusive). The edges in the
    graph are represented as a 2D integer array edges, where each
    edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and
    vertex vi. Every vertex pair is connected by at most one edge, and no
    vertex has an edge to itself. The time taken to traverse any edge is time
    minutes. Each vertex has a traffic signal which changes its color from
    green to red and vice versa every change minutes. All signals change at the
    same time. You can enter a vertex at any time, but can leave a vertex only
    when the signal is green. You cannot wait at a vertex if the signal is
    green. The second minimum value is defined as the smallest value strictly
    larger than the minimum value. For example the second minimum value of
    [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4. Given n,
    edges, time, and change, return the second minimum time it will take to go
    from vertex 1 to vertex n.

    Notes:
    * You can go through any vertex any number of times, including 1 and n.
    * You can assume that when the journey starts, all signals have just turned
      green.

    Example 1:
    Input: n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
    Output: 13
    Explanation: The figure on the left shows the given graph. The blue path in
                 the figure on the right is the minimum time path. The time
                 taken is:
                 - Start at 1, time elapsed=0
                 - 1 -> 4: 3 minutes, time elapsed=3
                 - 4 -> 5: 3 minutes, time elapsed=6
                 Hence the minimum time needed is 6 minutes. The red path shows
                 the path to get the second minimum time.
                 - Start at 1, time elapsed=0
                 - 1 -> 3: 3 minutes, time elapsed=3
                 - 3 -> 4: 3 minutes, time elapsed=6
                 - Wait at 4 for 4 minutes, time elapsed=10
                 - 4 -> 5: 3 minutes, time elapsed=13
                 Hence the second minimum time is 13 minutes.

    Example 2:
    Input: n = 2, edges = [[1,2]], time = 3, change = 2
    Output: 11
    Explanation: The minimum time path is 1 -> 2 with time = 3 minutes. The
                 second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11
                 minutes.

    Constraints:
    * 2 <= n <= 10^4
    * n - 1 <= edges.length <= min(2 * 10^4, n * (n - 1) / 2)
    * edges[i].length == 2
    * 1 <= ui, vi <= n
    * ui != vi
    * There are no duplicate edges.
    * Each vertex can be reached directly or indirectly from every other vertex.
    * 1 <= time, change <= 10^3"""

    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u-1].append(v-1)
            graph[v-1].append(u-1)

        least = None
        queue = deque([(0, 0)])
        seen = [[] for _ in range(n)]
        while queue:
            t, u = queue.popleft()
            if u == n-1:
                if least is None: least = t
                elif least < t: return t
            if (t//change) & 1: t = (t//change+1)*change # waiting for green
            t += time
            for v in graph[u]:
                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t:
                    seen[v].append(t)
                    queue.append((t, v))


    """2046. Sort Linked List Already Sorted Using Absolute Values (Medium)
    Given the head of a singly linked list that is sorted in non-decreasing
    order using the absolute values of its nodes, return the list sorted in
    non-decreasing order using the actual values of its nodes.

    Example 1:
    Input: head = [0,2,-5,5,10,-10]
    Output: [-10,-5,0,2,5,10]
    Explanation: The list sorted in non-descending order using the absolute
                 values of the nodes is [0,2,-5,5,10,-10]. The list sorted in
                 non-descending order using the actual values is
                 [-10,-5,0,2,5,10].

    Example 2:
    Input: head = [0,1,2]
    Output: [0,1,2]
    Explanation: The linked list is already sorted in non-decreasing order.

    Example 3:
    Input: head = [1]
    Output: [1]
    Explanation: The linked list is already sorted in non-decreasing order.

    Constraints:
    * The number of nodes in the list is the range [1, 10^5].
    * -5000 <= Node.val <= 5000
    * head is sorted in non-decreasing order using the absolute value of its
      nodes.

    Follow up: Can you think of a solution with O(n) time complexity?"""

    def sortLinkedList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = head
        node = head.next
        while node:
            if node.val < 0:
                prev.next = node.next
                node.next = head
                head = node
                node = prev.next
            else:
                prev = node
                node = node.next
        return head


    """2047. Number of Valid Words in a Sentence (Easy)
    A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'),
    hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only.
    Each sentence can be broken down into one or more tokens separated by one
    or more spaces ' '. A token is a valid word if:
    * It only contains lowercase letters, hyphens, and/or punctuation (no
      digits).
    * There is at most one hyphen '-'. If present, it should be surrounded by
      lowercase characters ("a-b" is valid, but "-ab" and "ab-" are not valid).
    * There is at most one punctuation mark. If present, it should be at the
      end of the token.
    Examples of valid words include "a-b.", "afad", "ba-c", "a!", and "!".
    Given a string sentence, return the number of valid words in sentence.

    Example 1:
    Input: sentence = "cat and  dog"
    Output: 3
    Explanation: The valid words in the sentence are "cat", "and", and "dog".

    Example 2:
    Input: sentence = "!this  1-s b8d!"
    Output: 0
    Explanation: There are no valid words in the sentence. "!this" is invalid
                 because it starts with a punctuation mark. "1-s" and "b8d" are
                 invalid because they contain digits.

    Example 3:
    Input: sentence = "alice and  bob are playing stone-game10"
    Output: 5
    Explanation: The valid words in the sentence are "alice", "and", "bob",
                 "are", and "playing". "stone-game10" is invalid because it
                 contains digits.

    Example 4:
    Input: sentence = "he bought 2 pencils, 3 erasers, and 1  pencil-sharpener."
    Output: 6
    Explanation: The valid words in the sentence are "he", "bought", "pencils,",
                 "erasers,", "and", and "pencil-sharpener.".

    Constraints:
    * 1 <= sentence.length <= 1000
    * sentence only contains lowercase English letters, digits, ' ', '-', '!',
      '.', and ','.
    * There will be at least 1 token."""

    def countValidWords(self, sentence: str) -> int:
        pattern = re.compile('(^[a-z]+(-[a-z]+)?)?[,.!]?$')
        return sum(bool(pattern.match(word)) for word in sentence.split())


    """2048. Next Greater Numerically Balanced Number (Medium)
    An integer x is numerically balanced if for every digit d in the number x,
    there are exactly d occurrences of that digit in x. Given an integer n,
    return the smallest numerically balanced number strictly greater than n.

    Example 1:
    Input: n = 1
    Output: 22
    Explanation: 22 is numerically balanced since:
                 - The digit 2 occurs 2 times.
                 It is also the smallest numerically balanced number strictly
                 greater than 1.

    Example 2:
    Input: n = 1000
    Output: 1333
    Explanation: 1333 is numerically balanced since:
                 - The digit 1 occurs 1 time.
                 - The digit 3 occurs 3 times.
                 It is also the smallest numerically balanced number strictly
                 greater than 1000. Note that 1022 cannot be the answer because
                 0 appeared more than 0 times.

    Example 3:
    Input: n = 3000
    Output: 3133
    Explanation: 3133 is numerically balanced since:
                 - The digit 1 occurs 1 time.
                 - The digit 3 occurs 3 times.
                 It is also the smallest numerically balanced number strictly
                 greater than 3000.

    Constraints: 0 <= n <= 10^6"""

    def nextBeautifulNumber(self, n: int) -> int:

        def fn(i, x):
            if i == k:
                if all(d == v for d, v in freq.items() if v): yield x
            else:
                for d in range(1, k+1):
                    if freq[d] < d <= freq[d] + k - i:
                        freq[d] += 1
                        yield from fn(i+1, 10*x+d)
                        freq[d] -= 1

        for k in (len(str(n)), len(str(n))+1):
            freq = Counter()
            for val in fn(0, 0):
                if val > n: return val


    """2049. Count Nodes With the Highest Score (Medium)
    There is a binary tree rooted at 0 consisting of n nodes. The nodes are
    labeled from 0 to n - 1. You are given a 0-indexed integer array parents
    representing the tree, where parents[i] is the parent of node i. Since node
    0 is the root, parents[0] == -1. Each node has a score. To find the score
    of a node, consider if the node and the edges connected to it were removed.
    The tree would become one or more non-empty subtrees. The size of a subtree
    is the number of the nodes in it. The score of the node is the product of
    the sizes of all those subtrees. Return the number of nodes that have the
    highest score.

    Example 1:
    Input: parents = [-1,2,0,2,0]
    Output: 3
    Explanation: - The score of node 0 is: 3 * 1 = 3
                 - The score of node 1 is: 4 = 4
                 - The score of node 2 is: 1 * 1 * 2 = 2
                 - The score of node 3 is: 4 = 4
                 - The score of node 4 is: 4 = 4
                 The highest score is 4, and three nodes (node 1, node 3, and
                 ode 4) have the highest score.

    Example 2:
    Input: parents = [-1,2,0]
    Output: 2
    Explanation: - The score of node 0 is: 2 = 2
                 - The score of node 1 is: 2 = 2
                 - The score of node 2 is: 1 * 1 = 1
                 The highest score is 2, and two nodes (node 0 and node 1) have
                 the highest score.

    Constraints:
    * n == parents.length
    * 2 <= n <= 10^5
    * parents[0] == -1
    * 0 <= parents[i] <= n - 1 for i != 0
    * parents represents a valid binary tree."""

    def countHighestScoreNodes(self, parents: List[int]) -> int:
        tree = [[] for _ in parents]
        for i, x in enumerate(parents):
            if x >= 0: tree[x].append(i)

        def fn(x):
            """Return count of tree nodes."""
            count = score = 1
            for xx in tree[x]:
                cc = fn(xx)
                count += cc
                score *= cc
            score *= len(parents) - count or 1
            freq[score] += 1
            return count

        freq = defaultdict(int)
        fn(0)
        return freq[max(freq)]


    """2050. Parallel Courses III (Hard)
    You are given an integer n, which indicates that there are n courses
    labeled from 1 to n. You are also given a 2D integer array relations where
    relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej
    has to be completed before course nextCoursej (prerequisite relationship).
    Furthermore, you are given a 0-indexed integer array time where time[i]
    denotes how many months it takes to complete the (i+1)th course. You must
    find the minimum number of months needed to complete all the courses
    following these rules:
    * You may start taking a course at any time if the prerequisites are met.
    * Any number of courses can be taken at the same time.
    Return the minimum number of months needed to complete all the courses.
    Note: The test cases are generated such that it is possible to complete
    every course (i.e., the graph is a directed acyclic graph).

    Example 1:
    Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]
    Output: 8
    Explanation: The figure above represents the given graph and the time
                 required to complete each course. We start course 1 and course
                 2 simultaneously at month 0. Course 1 takes 3 months and
                 course 2 takes 2 months to complete respectively. Thus, the
                 earliest time we can start course 3 is at month 3, and the
                 total time required is 3 + 5 = 8 months.

    Example 2:
    Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]
    Output: 12
    Explanation: The figure above represents the given graph and the time
                 required to complete each course. You can start courses 1, 2,
                 and 3 at month 0. You can complete them after 1, 2, and 3
                 months respectively. Course 4 can be taken only after course 3
                 is completed, i.e., after 3 months. It is completed after
                 3 + 4 = 7 months. Course 5 can be taken only after courses 1,
                 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7
                 months. Thus, the minimum time needed to complete all the
                 courses is 7 + 5 = 12 months.

    Constraints:
    * 1 <= n <= 5 * 10^4
    * 0 <= relations.length <= min(n * (n - 1) / 2, 5 * 10^4)
    * relations[j].length == 2
    * 1 <= prevCoursej, nextCoursej <= n
    * prevCoursej != nextCoursej
    * All the pairs [prevCoursej, nextCoursej] are unique.
    * time.length == n
    * 1 <= time[i] <= 10^4
    * The given graph is a directed acyclic graph."""

    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        graph = [[] for _ in range(n)]
        indeg = [0]*n
        for u, v in relations:
            graph[u-1].append(v-1)
            indeg[v-1] += 1

        start = [0]*n
        queue = deque((i, time[i]) for i, x in enumerate(indeg) if x == 0)

        while queue:
            u, t = queue.popleft() # earlist to finish course u
            for v in graph[u]:
                start[v] = max(start[v], t) # earlist to start course v
                indeg[v] -= 1
                if indeg[v] == 0: queue.append((v, start[v] + time[v]))
        return max(s+t for s, t in zip(start, time))


    """2052. Minimum Cost to Separate Sentence Into Rows (Medium)
    You are given a string sentence containing words separated by spaces, and
    an integer k. Your task is to separate sentence into rows where the number
    of characters in each row is at most k. You may assume that sentence does
    not begin or end with a space, and the words in sentence are separated by a
    single space. You can split sentence into rows by inserting line breaks
    between words in sentence. A word cannot be split between two rows. Each
    word must be used exactly once, and the word order cannot be rearranged.
    Adjacent words in a row should be separated by a single space, and rows
    should not begin or end with spaces. The cost of a row with length n is
    (k - n)2, and the total cost is the sum of the costs for all rows except
    the last one.
    * For example if sentence = "i love leetcode" and k = 12:
      + Separating sentence into "i", "love", and "leetcode" has a cost of
        (12 - 1)2 + (12 - 4)2 = 185.
      + Separating sentence into "i love", and "leetcode" has a cost of
        (12 - 6)2 = 36.
      + Separating sentence into "i", and "love leetcode" is not possible
        because the length of "love leetcode" is greater than k.
    Return the minimum possible total cost of separating sentence into rows.

    Example 1:
    Input: sentence = "i love leetcode", k = 12
    Output: 36
    Explanation: Separating sentence into "i", "love", and "leetcode" has a
                 cost of (12 - 1)^2 + (12 - 4)^2 = 185. Separating sentence
                 into "i love", and "leetcode" has a cost of (12 - 6)^2 = 36.
                 Separating sentence into "i", "love leetcode" is not possible
                 because "love leetcode" has length 13. 36 is the minimum
                 possible total cost so return it.

    Example 2:
    Input: sentence = "apples and bananas taste great", k = 7
    Output: 21
    Explanation: Separating sentence into "apples", "and", "bananas", "taste",
                 and "great" has a cost of
                 (7 - 6)^2 + (7 - 3)^2 + (7 - 7)^2 + (7 - 5)^2 = 21. 21 is the
                 minimum possible total cost so return it.

    Example 3:
    Input: sentence = "a", k = 5
    Output: 0
    Explanation: The cost of the last row is not included in the total cost,
                 and since there is only one row, return 0.

    Constraints:
    * 1 <= sentence.length <= 5000
    * 1 <= k <= 5000
    * The length of each word in sentence is at most k.
    * sentence consists of only lowercase English letters and spaces.
    * sentence does not begin or end with a space.
    * Words in sentence are separated by a single space."""

    def minimumCost(self, sentence: str, k: int) -> int:
        if len(sentence) <= k: return 0
        words = sentence.split()
        n = len(words)
        dp = [inf]*n
        dp[-1] = 0
        for i in range(n-2, -1, -1):
            val = -1
            for j in range(i, n):
                val += 1 + len(words[j])
                if val <= k: dp[i] = 0 if j == n-1 else min(dp[i], (k-val)**2 + dp[j+1])
                else: break
        return dp[0]


    """2053. Kth Distinct String in an Array (Easy)
    A distinct string is a string that is present only once in an array. Given
    an array of strings arr, and an integer k, return the kth distinct string
    present in arr. If there are fewer than k distinct strings, return an empty
    string "". Note that the strings are considered in the order in which they
    appear in the array.

    Example 1:
    Input: arr = ["d","b","c","b","c","a"], k = 2
    Output: "a"
    Explanation: The only distinct strings in arr are "d" and "a". "d" appears
                 1st, so it is the 1st distinct string. "a" appears 2nd, so it
                 is the 2nd distinct string. Since k == 2, "a" is returned.

    Example 2:
    Input: arr = ["aaa","aa","a"], k = 1
    Output: "aaa"
    Explanation: All strings in arr are distinct, so the 1st string "aaa" is
                 returned.

    Example 3:
    Input: arr = ["a","b","a"], k = 3
    Output: ""
    Explanation: The only distinct string is "b". Since there are fewer than 3
                 distinct strings, we return an empty string "".

    Constraints:
    * 1 <= k <= arr.length <= 1000
    * 1 <= arr[i].length <= 5
    * arr[i] consists of lowercase English letters."""

    def kthDistinct(self, arr: List[str], k: int) -> str:
        freq = Counter(arr)
        for s in arr:
            if freq[s] == 1:
                k -= 1
                if k == 0: return s
        return ""


    """2054. Two Best Non-Overlapping Events (Medium)
    You are given a 0-indexed 2D integer array of events where
    events[i] = [startTimei, endTimei, valuei]. The ith event starts at
    startTimei and ends at endTimei, and if you attend this event, you will
    receive a value of valuei. You can choose at most two non-overlapping
    events to attend such that the sum of their values is maximized. Return
    this maximum sum. Note that the start time and end time is inclusive: that
    is, you cannot attend two events where one of them starts and the other
    ends at the same time. More specifically, if you attend an event with end
    time t, the next event must start at or after t + 1.

    Example 1:
    Input: events = [[1,3,2],[4,5,2],[2,4,3]]
    Output: 4
    Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.

    Example 2:
    Example 1 Diagram
    Input: events = [[1,3,2],[4,5,2],[1,5,5]]
    Output: 5
    Explanation: Choose event 2 for a sum of 5.

    Example 3:
    Input: events = [[1,5,3],[1,5,1],[6,6,5]]
    Output: 8
    Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.

    Constraints:
    * 2 <= events.length <= 10^5
    * events[i].length == 3
    * 1 <= startTimei <= endTimei <= 10^9
    * 1 <= valuei <= 10^6"""

    def maxTwoEvents(self, events: List[List[int]]) -> int:
        ans = most = 0
        pq = []
        for st, et, val in sorted(events):
            heappush(pq, (et, val))
            while pq and pq[0][0] < st:
                _, vv = heappop(pq)
                most = max(most, vv)
            ans = max(ans, most + val)
        return ans


    """2055. Plates Between Candles (Medium)
    There is a long table with a line of plates and candles arranged on top of
    it. You are given a 0-indexed string s consisting of characters '*' and '|'
    only, where a '*' represents a plate and a '|' represents a candle. You are
    also given a 0-indexed 2D integer array queries where
    queries[i] = [lefti, righti] denotes the substring s[lefti...righti]
    (inclusive). For each query, you need to find the number of plates between
    candles that are in the substring. A plate is considered between candles if
    there is at least one candle to its left and at least one candle to its
    right in the substring. For example, s = "||**||**|*", and a query [3, 8]
    denotes the substring "*||**|". The number of plates between candles in
    this substring is 2, as each of the two plates has at least one candle in
    the substring to its left and right. Return an integer array answer where
    answer[i] is the answer to the ith query.

    Example 1:
    Input: s = "**|**|***|", queries = [[2,5],[5,9]]
    Output: [2,3]
    Explanation: - queries[0] has two plates between candles.
                 - queries[1] has three plates between candles.

    Example 2:
    Input: s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
    Output: [9,0,0,0,0]
    Explanation: - queries[0] has nine plates between candles.
                 - The other queries have zero plates between candles.

    Constraints:
    * 3 <= s.length <= 10^5
    * s consists of '*' and '|' characters.
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= lefti <= righti < s.length"""

    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        prefix = [0]
        stack = []
        upper = [-1]*len(s)
        lower = [-1]*len(s)
        lo = -1
        for i, ch in enumerate(s):
            prefix.append(prefix[-1] + (ch == '*'))
            stack.append(i)
            if ch == '|':
                while stack: upper[stack.pop()] = i
                lo = i
            lower[i] = lo

        ans = []
        for x, y in queries:
            lo = upper[x]
            hi = lower[y]
            if hi != -1 and lo != -1 and lo <= hi: ans.append(prefix[hi+1] - prefix[lo])
            else: ans.append(0)
        return ans


    """2056. Number of Valid Move Combinations On Chessboard (Hard)
    There is an 8 x 8 chessboard containing n pieces (rooks, queens, or
    bishops). You are given a string array pieces of length n, where pieces[i]
    describes the type (rook, queen, or bishop) of the ith piece. In addition,
    you are given a 2D integer array positions also of length n, where
    positions[i] = [ri, ci] indicates that the ith piece is currently at the
    1-based coordinate (ri, ci) on the chessboard. When making a move for a
    piece, you choose a destination square that the piece will travel toward
    and stop on.
    * A rook can only travel horizontally or vertically from (r, c) to the
      direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1).
    * A queen can only travel horizontally, vertically, or diagonally from
      (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1),
      (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).
    * A bishop can only travel diagonally from (r, c) to the direction of
      (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).
    You must make a move for every piece on the board simultaneously. A move
    combination consists of all the moves performed on all the given pieces.
    Every second, each piece will instantaneously travel one square towards
    their destination if they are not already at it. All pieces start
    traveling at the 0th second. A move combination is invalid if, at a given
    time, two or more pieces occupy the same square. Return the number of valid
    move combinations.

    Notes:
    * No two pieces will start in the same square.
    * You may choose the square a piece is already on as its destination.
    * If two pieces are directly adjacent to each other, it is valid for them
      to move past each other and swap positions in one second.

    Example 1:
    Input: pieces = ["rook"], positions = [[1,1]]
    Output: 15
    Explanation: The image above shows the possible squares the piece can move to.

    Example 2:
    Input: pieces = ["queen"], positions = [[1,1]]
    Output: 22
    Explanation: The image above shows the possible squares the piece can move to.

    Example 3:
    Input: pieces = ["bishop"], positions = [[4,3]]
    Output: 12
    Explanation: The image above shows the possible squares the piece can move to.

    Example 4:
    Input: pieces = ["rook","rook"], positions = [[1,1],[8,8]]
    Output: 223
    Explanation: There are 15 moves for each rook which results in 15 * 15 = 225
                 move combinations. However, there are two invalid move
                 combinations:
                 - Move both rooks to (8, 1), where they collide.
                 - Move both rooks to (1, 8), where they collide.
                 Thus there are 225 - 2 = 223 valid move combinations. Note that
                 there are two valid move combinations that would result in one
                 rook at (1, 8) and the other at (8, 1). Even though the board
                 state is the same, these two move combinations are considered
                 different since the moves themselves are different.

    Example 5:
    Input: pieces = ["queen","bishop"], positions = [[5,7],[3,4]]
    Output: 281
    Explanation: There are 12 * 24 = 288 move combinations. However, there are
                 several invalid move combinations:
                 - If the queen stops at (6, 7), it blocks the bishop from
                   moving to (6, 7) or (7, 8).
                 - If the queen stops at (5, 6), it blocks the bishop from
                   moving to (5, 6), (6, 7), or (7, 8).
                 - If the bishop stops at (5, 2), it blocks the queen from
                   moving to (5, 2) or (5, 1).
                 Of the 288 move combinations, 281 are valid.

    Constraints:
    * n == pieces.length
    * n == positions.length
    * 1 <= n <= 4
    * pieces only contains the strings "rook", "queen", and "bishop".
    * There will be at most one queen on the chessboard.
    * 1 <= xi, yi <= 8
    * Each positions[i] is distinct."""

    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        n = len(pieces)
        mp = {"bishop": ((-1, -1), (-1, 1), (1, -1), (1, 1)),
              "queen" : ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)),
              "rook"  : ((-1, 0), (0, -1), (0, 1), (1, 0))}

        dirs = [[]] # directions
        for piece in pieces: dirs = [x+[xx] for x in dirs for xx in mp[piece]]

        positions = tuple(map(tuple, positions))

        def fn(*args):
            """Return possible moves along given direction."""
            stack = [((1<<n)-1, positions)]
            while stack:
                mask, pos = stack.pop()
                ans.add(pos)
                m = mask
                while m:
                    p = []
                    for i in range(n):
                        if m & (1 << i):
                            p.append((pos[i][0] + args[i][0], pos[i][1] + args[i][1]))
                            if not (1 <= p[i][0] <= 8 and 1 <= p[i][1] <= 8): break
                        else: p.append(pos[i])
                    else:
                        cand = tuple(p)
                        if len(set(cand)) == len(cand) and m: stack.append((m, cand))
                    m = mask & (m-1)

        ans = set()
        for d in dirs: fn(*d)
        return len(ans)


    """2057. Smallest Index With Equal Value (Easy)
    Given a 0-indexed integer array nums, return the smallest index i of nums
    such that i mod 10 == nums[i], or -1 if such index does not exist. x mod y
    denotes the remainder when x is divided by y.

    Example 1:
    Input: nums = [0,1,2]
    Output: 0
    Explanation: i=0: 0 mod 10 = 0 == nums[0].
                 i=1: 1 mod 10 = 1 == nums[1].
                 i=2: 2 mod 10 = 2 == nums[2].
                 All indices have i mod 10 == nums[i], so we return the
                 smallest index 0.

    Example 2:
    Input: nums = [4,3,2,1]
    Output: 2
    Explanation: i=0: 0 mod 10 = 0 != nums[0].
                 i=1: 1 mod 10 = 1 != nums[1].
                 i=2: 2 mod 10 = 2 == nums[2].
                 i=3: 3 mod 10 = 3 != nums[3].
                 2 is the only index which has i mod 10 == nums[i].

    Example 3:
    Input: nums = [1,2,3,4,5,6,7,8,9,0]
    Output: -1
    Explanation: No index satisfies i mod 10 == nums[i].

    Example 4:
    Input: nums = [2,1,3,5,2]
    Output: 1
    Explanation: 1 is the only index with i mod 10 == nums[i].

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 9"""

    def smallestEqual(self, nums: List[int]) -> int:
        return next((i for i, x in enumerate(nums) if i%10 == x), -1)


    """2058. Find the Minimum and Maximum Number of Nodes Between Critical Points (Medium)
    A critical point in a linked list is defined as either a local maxima or a
    local minima. A node is a local maxima if the current node has a value
    strictly greater than the previous node and the next node. A node is a
    local minima if the current node has a value strictly smaller than the
    previous node and the next node. Note that a node can only be a local
    maxima/minima if there exists both a previous node and a next node. Given a
    linked list head, return an array of length 2 containing
    [minDistance, maxDistance] where minDistance is the minimum distance
    between any two distinct critical points and maxDistance is the maximum
    distance between any two distinct critical points. If there are fewer than
    two critical points, return [-1, -1].

    Example 1:
    Input: head = [3,1]
    Output: [-1,-1]
    Explanation: There are no critical points in [3,1].

    Example 2:
    Input: head = [5,3,1,2,5,1,2]
    Output: [1,3]
    Explanation: There are three critical points:
                 - [5,3,1,2,5,1,2]: The third node is a local minima because 1
                   is less than 3 and 2.
                 - [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5
                   is greater than 2 and 1.
                 - [5,3,1,2,5,1,2]: The sixth node is a local minima because 1
                   is less than 5 and 2.
                 The minimum distance is between the fifth and the sixth node.
                 minDistance = 6 - 5 = 1. The maximum distance is between the
                 third and the sixth node. maxDistance = 6 - 3 = 3.

    Example 3:
    Input: head = [1,3,2,2,3,2,2,2,7]
    Output: [3,3]
    Explanation: There are two critical points:
                 - [1,3,2,2,3,2,2,2,7]: The second node is a local maxima
                   because 3 is greater than 1 and 2.
                 - [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima
                   because 3 is greater than 2 and 2.
                 Both the minimum and maximum distances are between the second
                 and the fifth node. Thus, minDistance and maxDistance is
                 5 - 2 = 3. Note that the last node is not considered a local
                 maxima because it does not have a next node.

    Example 4:
    Input: head = [2,3,3,2]
    Output: [-1,-1]
    Explanation: There are no critical points in [2,3,3,2].

    Constraints:
    * The number of nodes in the list is in the range [2, 10^5].
    * 1 <= Node.val <= 10^5"""

    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:
        prev = head.val
        node = head.next
        dmin = inf
        first = i = last = 0
        while node and node.next:
            i += 1
            if prev < node.val > node.next.val or prev > node.val < node.next.val:
                if last : dmin = min(dmin, i - last)
                last = i # last critical point
                if not first: first = i # first critical point
            prev = node.val
            node = node.next
        return [dmin, last - first] if dmin < inf else [-1, -1]


    """2059. Minimum Operations to Convert Number (Medium)
    You are given a 0-indexed integer array nums containing distinct numbers,
    an integer start, and an integer goal. There is an integer x that is
    initially set to start, and you want to perform operations on x such that
    it is converted to goal. You can perform the following operation repeatedly
    on the number x:

    If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length),
    you can set x to any of the following:
    * x + nums[i]
    * x - nums[i]
    * x ^ nums[i] (bitwise-XOR)
    Note that you can use each nums[i] any number of times in any order.
    Operations that set x to be out of the range 0 <= x <= 1000 are valid, but
    no more operations can be done afterward. Return the minimum number of
    operations needed to convert x = start into goal, and -1 if it is not
    possible.

    Example 1:
    Input: nums = [1,3], start = 6, goal = 4
    Output: 2
    Explanation: We can go from 6 → 7 → 4 with the following 2 operations.
                 - 6 ^ 1 = 7
                 - 7 ^ 3 = 4

    Example 2:
    Input: nums = [2,4,12], start = 2, goal = 12
    Output: 2
    Explanation: We can go from 2 → 14 → 12 with the following 2 operations.
                 - 2 + 12 = 14
                 - 14 - 2 = 12

    Example 3:
    Input: nums = [3,5,7], start = 0, goal = -4
    Output: 2
    Explanation: We can go from 0 → 3 → -4 with the following 2 operations.
                 - 0 + 3 = 3
                 - 3 - 7 = -4
                 Note that the last operation sets x out of the range
                 0 <= x <= 1000, which is valid.

    Example 4:
    Input: nums = [2,8,16], start = 0, goal = 1
    Output: -1
    Explanation: There is no way to convert 0 into 1.

    Example 5:
    Input: nums = [1], start = 0, goal = 3
    Output: 3
    Explanation: We can go from 0 → 1 → 2 → 3 with the following 3 operations.
                 - 0 + 1 = 1
                 - 1 + 1 = 2
                 - 2 + 1 = 3

    Constraints:
    * 1 <= nums.length <= 1000
    * -10^9 <= nums[i], goal <= 10^9
    * 0 <= start <= 1000
    * start != goal
    * All the integers in nums are distinct."""

    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
        ans = 0
        queue = deque([start])
        visited = [False]*1001
        while queue:
            for _ in range(len(queue)):
                val = queue.popleft()
                if val == goal: return ans
                if 0 <= val <= 1000 and not visited[val]:
                    visited[val] = True
                    for x in nums:
                        for xx in (val+x, val-x, val^x):
                            queue.append(xx)
            ans += 1
        return -1


    """2060. Check if an Original String Exists Given Two Encoded Strings (Hard)
    An original string, consisting of lowercase English letters, can be encoded
    by the following steps:
    * Arbitrarily split it into a sequence of some number of non-empty substrings.
    * Arbitrarily choose some elements (possibly none) of the sequence, and
      replace each with its length (as a numeric string).
    * Concatenate the sequence as the encoded string.
    For example, one way to encode an original string "abcdefghijklmnop" might
    be:
    * Split it as a sequence: ["ab", "cdefghijklmn", "o", "p"].
    * Choose the second and third elements to be replaced by their lengths,
      respectively. The sequence becomes ["ab", "12", "1", "p"].
    * Concatenate the elements of the sequence to get the encoded string:
      "ab121p".
    Given two encoded strings s1 and s2, consisting of lowercase English
    letters and digits 1-9 (inclusive), return true if there exists an original
    string that could be encoded as both s1 and s2. Otherwise, return false.
    Note: The test cases are generated such that the number of consecutive
    digits in s1 and s2 does not exceed 3.

    Example 1:
    Input: s1 = "internationalization", s2 = "i18n"
    Output: true
    Explanation: It is possible that "internationalization" was the original
                 string.
                 - "internationalization"
                   -> Split:       ["internationalization"]
                   -> Do not replace any element
                   -> Concatenate:  "internationalization", which is s1.
                 - "internationalization"
                   -> Split:       ["i", "nternationalizatio", "n"]
                   -> Replace:     ["i", "18",                 "n"]
                   -> Concatenate:  "i18n", which is s2

    Example 2:
    Input: s1 = "l123e", s2 = "44"
    Output: true
    Explanation: It is possible that "leetcode" was the original string.
                 - "leetcode"
                   -> Split:      ["l", "e", "et", "cod", "e"]
                   -> Replace:    ["l", "1", "2",  "3",   "e"]
                   -> Concatenate: "l123e", which is s1.
                 - "leetcode"
                   -> Split:      ["leet", "code"]
                   -> Replace:    ["4",    "4"]
                   -> Concatenate: "44", which is s2.

    Example 3:
    Input: s1 = "a5b", s2 = "c5b"
    Output: false
    Explanation: It is impossible.
                 - The original string encoded as s1 must start with the letter 'a'.
                 - The original string encoded as s2 must start with the letter 'c'.

    Example 4:
    Input: s1 = "112s", s2 = "g841"
    Output: true
    Explanation: It is possible that "gaaaaaaaaaaaas" was the original string
                 - "gaaaaaaaaaaaas"
                   -> Split:      ["g", "aaaaaaaaaaaa", "s"]
                   -> Replace:    ["1", "12",           "s"]
                   -> Concatenate: "112s", which is s1.
                 - "gaaaaaaaaaaaas"
                   -> Split:      ["g", "aaaaaaaa", "aaaa", "s"]
                   -> Replace:    ["g", "8",        "4",    "1"]
                   -> Concatenate: "g841", which is s2.

    Example 5:
    Input: s1 = "ab", s2 = "a2"
    Output: false
    Explanation: It is impossible.
                 - The original string encoded as s1 has two letters.
                 - The original string encoded as s2 has three letters.

    Constraints:
    * 1 <= s1.length, s2.length <= 40
    * s1 and s2 consist of digits 1-9 (inclusive), and lowercase English
     l etters only.
    * The number of consecutive digits in s1 and s2 does not exceed 3."""

    def possiblyEquals(self, s1: str, s2: str) -> bool:

        def gg(s):
            """Return possible length."""
            ans = {int(s)}
            for i in range(1, len(s)):
                ans |= {x+y for x in gg(s[:i]) for y in gg(s[i:])}
            return ans

        @cache
        def fn(i, j, diff):
            """Return True if s1[i:] matches s2[j:] with given differences."""
            if i == len(s1) and j == len(s2): return diff == 0
            if i < len(s1) and s1[i].isdigit():
                ii = i
                while ii < len(s1) and s1[ii].isdigit(): ii += 1
                for x in gg(s1[i:ii]):
                    if fn(ii, j, diff-x): return True
            elif j < len(s2) and s2[j].isdigit():
                jj = j
                while jj < len(s2) and s2[jj].isdigit(): jj += 1
                for x in gg(s2[j:jj]):
                    if fn(i, jj, diff+x): return True
            elif diff == 0:
                if i < len(s1) and j < len(s2) and s1[i] == s2[j]: return fn(i+1, j+1, 0)
            elif diff > 0:
                if i < len(s1): return fn(i+1, j, diff-1)
            else:
                if j < len(s2): return fn(i, j+1, diff+1)
            return False

        return fn(0, 0, 0)


    """2061. Number of Spaces Cleaning Robot Cleaned (Medium)
    A room is represented by a 0-indexed 2D binary matrix room where a 0
    represents an empty space and a 1 represents a space with an object. The
    top left corner of the room will be empty in all test cases. A cleaning
    robot starts at the top left corner of the room and is facing right. The
    robot will continue heading straight until it reaches the edge of the room
    or it hits an object, after which it will turn 90 degrees clockwise and
    repeat this process. The starting space and all spaces that the robot
    visits are cleaned by it. Return the number of clean spaces in the room if
    the robot runs indefinetely.

    Example 1:
    Input: room = [[0,0,0],[1,1,0],[0,0,0]]
    Output: 7
    Explanation: The robot cleans the spaces at (0, 0), (0, 1), and (0, 2). The
                 robot is at the edge of the room, so it turns 90 degrees
                 clockwise and now faces down. The robot cleans the spaces at
                 (1, 2), and (2, 2). The robot is at the edge of the room, so
                 it turns 90 degrees clockwise and now faces left. The robot
                 cleans the spaces at (2, 1), and (2, 0). The robot has cleaned
                 all 7 empty spaces, so return 7.

    Example 2:
    Input: room = [[0,1,0],[1,0,0],[0,0,0]]
    Output: 1
    Explanation: The robot cleans the space at (0, 0). The robot hits an object,
                 so it turns 90 degrees clockwise and now faces down. The robot
                 hits an object, so it turns 90 degrees clockwise and now faces
                 left. The robot is at the edge of the room, so it turns 90
                 degrees clockwise and now faces up. The robot is at the edge
                 of the room, so it turns 90 degrees clockwise and now faces
                 right. The robot is back at its starting position. The robot
                 has cleaned 1 space, so return 1.

    Constraints:
    * m == room.length
    * n == room[r].length
    * 1 <= m, n <= 300
    * room[r][c] is either 0 or 1.
    * room[0][0] == 0"""

    def numberOfCleanRooms(self, room: List[List[int]]) -> int:
        m, n = len(room), len(room[0])
        ans = i = j = k = 0
        dirs = (0, 1, 0, -1, 0)
        seen = defaultdict(int)
        while not seen[i, j] & 1<<k:
            if room[i][j] == 0:
                ans += 1
                room[i][j] = -1
            seen[i, j] |= 1<<k
            ii = i + dirs[k]
            jj = j + dirs[k+1]
            if 0 <= ii < m and 0 <= jj < n and room[ii][jj] != 1: i, j = ii, jj
            else: k = (k+1)%4
        return ans


    """2062. Count Vowel Substrings of a String (Easy)
    A substring is a contiguous (non-empty) sequence of characters within a
    string. A vowel substring is a substring that only consists of vowels
    ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it. Given
    a string word, return the number of vowel substrings in word.

    Example 1:
    Input: word = "aeiouu"
    Output: 2
    Explanation: The vowel substrings of word are as follows (underlined):
                 - "aeiouu"
                 - "aeiouu"

    Example 2:
    Input: word = "unicornarihan"
    Output: 0
    Explanation: Not all 5 vowels are present, so there are no vowel substrings.

    Example 3:
    Input: word = "cuaieuouac"
    Output: 7
    Explanation: The vowel substrings of word are as follows (underlined):
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"
                 - "cuaieuouac"

    Example 4:
    Input: word = "bbaeixoubb"
    Output: 0
    Explanation: The only substrings that contain all five vowels also contain
                 consonants, so there are no vowel substrings.

    Constraints:
    * 1 <= word.length <= 100
    * word consists of lowercase English letters only."""

    def countVowelSubstrings(self, word: str) -> int:
        ans = 0
        freq = defaultdict(int)
        for i, x in enumerate(word):
            if x in "aeiou":
                if not i or word[i-1] not in "aeiou":
                    jj = j = i # set anchor
                    freq.clear()
                freq[x] += 1
                while len(freq) == 5 and all(freq.values()):
                    freq[word[j]] -= 1
                    j += 1
                ans += j - jj
        return ans


    """2063. Vowels of All Substrings (Medium)
    Given a string word, return the sum of the number of vowels ('a', 'e', 'i',
    'o', and 'u') in every substring of word. A substring is a contiguous (non-
    empty) sequence of characters within a string. Note: Due to the large
    constraints, the answer may not fit in a signed 32-bit integer. Please be
    careful during the calculations.

    Example 1:
    Input: word = "aba"
    Output: 6
    Explanation: All possible substrings are: "a", "ab", "aba", "b", "ba", and
                 "a".
                 - "b" has 0 vowels in it
                 - "a", "ab", "ba", and "a" have 1 vowel each
                 - "aba" has 2 vowels in it
                 Hence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6.

    Example 2:
    Input: word = "abc"
    Output: 3
    Explanation: All possible substrings are: "a", "ab", "abc", "b", "bc", and
                 "c".
                 - "a", "ab", and "abc" have 1 vowel each
                 - "b", "bc", and "c" have 0 vowels each
                 Hence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3.

    Example 3:
    Input: word = "ltcd"
    Output: 0
    Explanation: There are no vowels in any substring of "ltcd".

    Example 4:
    Input: word = "noosabasboosa"
    Output: 237
    Explanation: There are a total of 237 vowels in all the substrings.

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists of lowercase English letters."""

    def countVowels(self, word: str) -> int:
        return sum((i+1)*(len(word)-i) for i, x in enumerate(word) if x in "aeiou")


    """2064. Minimized Maximum of Products Distributed to Any Store (Medium)
    You are given an integer n indicating there are n specialty retail stores.
    There are m product types of varying amounts, which are given as a 0-
    indexed integer array quantities, where quantities[i] represents the number
    of products of the ith product type. You need to distribute all products to
    the retail stores following these rules:
    * A store can only be given at most one product type but can be given any
      amount of it.
    * After distribution, each store will be given some number of products
      (possibly 0). Let x represent the maximum number of products given to any
      store. You want x to be as small as possible, i.e., you want to minimize
      the maximum number of products that are given to any store.
    Return the minimum possible x.

    Example 1:
    Input: n = 6, quantities = [11,6]
    Output: 3
    Explanation: One optimal way is:
                 - The 11 products of type 0 are distributed to the first four
                   stores in these amounts: 2, 3, 3, 3
                 - The 6 products of type 1 are distributed to the other two
                   stores in these amounts: 3, 3
                 The maximum number of products given to any store is
                 max(2, 3, 3, 3, 3, 3) = 3.

    Example 2:
    Input: n = 7, quantities = [15,10,10]
    Output: 5
    Explanation: One optimal way is:
                 - The 15 products of type 0 are distributed to the first three
                   stores in these amounts: 5, 5, 5
                 - The 10 products of type 1 are distributed to the next two
                   stores in these amounts: 5, 5
                 - The 10 products of type 2 are distributed to the last two
                   stores in these amounts: 5, 5
                 The maximum number of products given to any store is
                 max(5, 5, 5, 5, 5, 5, 5) = 5.

    Example 3:
    Input: n = 1, quantities = [100000]
    Output: 100000
    Explanation: The only optimal way is:
                 - The 100000 products of type 0 are distributed to the only
                   store.
                 The maximum number of products given to any store is
                 max(100000) = 100000.

    Constraints:
    * m == quantities.length
    * 1 <= m <= n <= 10^5
    * 1 <= quantities[i] <= 10^5"""

    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:
        lo, hi = 1, max(quantities)
        while lo < hi:
            mid = lo + hi >> 1
            if sum(ceil(qty/mid) for qty in quantities) <= n: hi = mid
            else: lo = mid + 1
        return lo


    """2065. Maximum Path Quality of a Graph (Hard)
    There is an undirected graph with n nodes numbered from 0 to n - 1
    (inclusive). You are given a 0-indexed integer array values where values[i]
    is the value of the ith node. You are also given a 0-indexed 2D integer
    array edges, where each edges[j] = [uj, vj, timej] indicates that there is
    an undirected edge between the nodes uj and vj, and it takes timej seconds
    to travel between the two nodes. Finally, you are given an integer maxTime.
    A valid path in the graph is any path that starts at node 0, ends at node 0,
    and takes at most maxTime seconds to complete. You may visit the same node
    multiple times. The quality of a valid path is the sum of the values of the
    unique nodes visited in the path (each node's value is added at most once
    to the sum). Return the maximum quality of a valid path. Note: There are at
    most four edges connected to each node.

    Example 1:
    Input: values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49
    Output: 75
    Explanation: One possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time
                 taken is 10 + 10 + 10 + 10 = 40 <= 49. The nodes visited are
                 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.

    Example 2:
    Input: values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30
    Output: 25
    Explanation: One possible path is 0 -> 3 -> 0. The total time taken is
                 10 + 10 = 20 <= 30. The nodes visited are 0 and 3, giving a
                 maximal path quality of 5 + 20 = 25.

    Example 3:
    Input: values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50
    Output: 7
    Explanation: One possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time
                 taken is 10 + 13 + 13 + 10 = 46 <= 50. The nodes visited are
                 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.

    Example 4:
    Input: values = [0,1,2], edges = [[1,2,10]], maxTime = 10
    Output: 0
    Explanation: The only path is 0. The total time taken is 0. The only node
                 visited is 0, giving a maximal path quality of 0.

    Constraints:
    * n == values.length
    * 1 <= n <= 1000
    * 0 <= values[i] <= 10^8
    * 0 <= edges.length <= 2000
    * edges[j].length == 3
    * 0 <= uj < vj <= n - 1
    * 10 <= timej, maxTime <= 100
    * All the pairs [uj, vj] are unique.
    * There are at most four edges connected to each node.
    * The graph may not be connected."""

    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:
        graph = [[] for _ in values]
        for u, v, t in edges:
            graph[u].append((v, t))
            graph[v].append((u, t))

        ans = 0
        stack = [(0, values[0], 0, 1)]
        while stack:
            time, val, u, mask = stack.pop()
            if u == 0: ans = max(ans, val)
            for v, t in graph[u]:
                if time + t <= maxTime:
                    if not mask & 1<<v: stack.append((time+t, val+values[v], v, mask ^ 1<<v))
                    else: stack.append((time+t, val, v, mask))
        return ans


    """2067. Number of Equal Count Substrings (Medium)
    You are given a 0-indexed string s consisting of only lowercase English
    letters, and an integer count. A substring of s is said to be an equal
    count substring if, for each unique letter in the substring, it appears
    exactly count times in the substring. Return the number of equal count
    substrings in s. A substring is a contiguous non-empty sequence of
    characters within a string.

    Example 1:
    Input: s = "aaabcbbcc", count = 3
    Output: 3
    Explanation: The substring that starts at index 0 and ends at index 2 is
                 "aaa". The letter 'a' in the substring appears exactly 3
                 times. The substring that starts at index 3 and ends at index
                 8 is "bcbbcc". The letters 'b' and 'c' in the substring appear
                 exactly 3 times. The substring that starts at index 0 and ends
                 at index 8 is "aaabcbbcc". The letters 'a', 'b', and 'c' in
                 the substring appear exactly 3 times.

    Example 2:
    Input: s = "abcd", count = 2
    Output: 0
    Explanation: The number of times each letter appears in s is less than
                 count. Therefore, no substrings in s are equal count
                 substrings, so return 0.

    Example 3:
    Input: s = "a", count = 5
    Output: 0
    Explanation: The number of times each letter appears in s is less than
                 count. Therefore, no substrings in s are equal count
                 substrings, so return 0

    Constraints:
    * 1 <= s.length <= 3 * 10^4
    * 1 <= count <= 3 * 10^4
    * s consists only of lowercase English letters."""

    def equalCountSubstrings(self, s: str, count: int) -> int:
        ans = 0
        for k in range(1, 27):
            freq = Counter()
            uniq = 0
            for i, ch in enumerate(s):
                freq[ch] += 1
                if freq[ch] == count: uniq += 1
                if i >= k*count:
                    if freq[s[i-k*count]] == count: uniq -= 1
                    freq[s[i-k*count]] -= 1
                if uniq == k: ans += 1
        return ans


    """2068. Check Whether Two Strings are Almost Equivalent (Easy)
    Two strings word1 and word2 are considered almost equivalent if the
    differences between the frequencies of each letter from 'a' to 'z' between
    word1 and word2 is at most 3. Given two strings word1 and word2, each of
    length n, return true if word1 and word2 are almost equivalent, or false
    otherwise. The frequency of a letter x is the number of times it occurs in
    the string.

    Example 1:
    Input: word1 = "aaaa", word2 = "bccb"
    Output: false
    Explanation: There are 4 'a's in "aaaa" but 0 'a's in "bccb". The
                 difference is 4, which is more than the allowed 3.

    Example 2:
    Input: word1 = "abcdeef", word2 = "abaaacc"
    Output: true
    Explanation: The differences between the frequencies of each letter in
                 word1 and word2 are at most 3:
                 - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.
                 - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.
                 - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.
                 - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.
                 - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.
                 - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.

    Example 3:
    Input: word1 = "cccddabba", word2 = "babababab"
    Output: true
    Explanation: The differences between the frequencies of each letter in
                 word1 and word2 are at most 3:
                 - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.
                 - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.
                 - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.
                 - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.

    Constraints:
    * n == word1.length == word2.length
    * 1 <= n <= 100
    * word1 and word2 consist only of lowercase English letters."""

    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        freq = [0]*26
        for x in word1: freq[ord(x)-97] += 1
        for x in word2: freq[ord(x)-97] -= 1
        return all(abs(x) <= 3 for x in freq)


    """2070. Most Beautiful Item for Each Query (Medium)
    You are given a 2D integer array items where items[i] = [pricei, beautyi]
    denotes the price and beauty of an item respectively. You are also given a
    0-indexed integer array queries. For each queries[j], you want to determine
    the maximum beauty of an item whose price is less than or equal to
    queries[j]. If no such item exists, then the answer to this query is 0.
    Return an array answer of the same length as queries where answer[j] is the
    answer to the jth query.

    Example 1:
    Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]
    Output: [2,4,5,5,6,6]
    Explanation: - For queries[0]=1, [1,2] is the only item which has price <= 1.
                   Hence, the answer for this query is 2.
                 - For queries[1]=2, the items which can be considered are [1,2]
                   and [2,4]. The maximum beauty among them is 4.
                 - For queries[2]=3 and queries[3]=4, the items which can be
                   considered are [1,2], [3,2], [2,4], and [3,5]. The maximum
                   beauty among them is 5.
                 - For queries[4]=5 and queries[5]=6, all items can be considered.
                   Hence, the answer for them is the maximum beauty of all items,
                   i.e., 6.

    Example 2:
    Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]
    Output: [4]
    Explanation: The price of every item is equal to 1, so we choose the item
                 with the maximum beauty 4. Note that multiple items can have
                 the same price and/or beauty.

    Example 3:
    Input: items = [[10,1000]], queries = [5]
    Output: [0]
    Explanation: No item has a price less than or equal to 5, so no item can be
                 chosen. Hence, the answer to the query is 0.

    Constraints:
    * 1 <= items.length, queries.length <= 10^5
    * items[i].length == 2
    * 1 <= pricei, beautyi, queries[j] <= 10^9"""

    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:
        items.sort()
        ans = [0]*len(queries)
        prefix = ii = 0
        for x, i in sorted((x, i) for i, x in enumerate(queries)):
            while ii < len(items) and items[ii][0] <= x:
                prefix = max(prefix, items[ii][1])
                ii += 1
            ans[i] = prefix
        return ans


    """2071. Maximum Number of Tasks You Can Assign (Hard)
    You have n tasks and m workers. Each task has a strength requirement stored
    in a 0-indexed integer array tasks, with the ith task requiring tasks[i]
    strength to complete. The strength of each worker is stored in a 0-indexed
    integer array workers, with the jth worker having workers[j] strength. Each
    worker can only be assigned to a single task and must have a strength
    greater than or equal to the task's strength requirement (i.e.,
    workers[j] >= tasks[i]). Additionally, you have pills magical pills that
    will increase a worker's strength by strength. You can decide which workers
    receive the magical pills, however, you may only give each worker at most
    one magical pill. Given the 0-indexed integer arrays tasks and workers and
    the integers pills and strength, return the maximum number of tasks that
    can be completed.

    Example 1:
    Input: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1
    Output: 3
    Explanation: We can assign the magical pill and tasks as follows:
                 - Give the magical pill to worker 0.
                 - Assign worker 0 to task 2 (0 + 1 >= 1)
                 - Assign worker 1 to task 1 (3 >= 2)
                 - Assign worker 2 to task 0 (3 >= 3)

    Example 2:
    Input: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5
    Output: 1
    Explanation: We can assign the magical pill and tasks as follows:
                 - Give the magical pill to worker 0.
                 - Assign worker 0 to task 0 (0 + 5 >= 5)

    Example 3:
    Input: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10
    Output: 2
    Explanation: We can assign the magical pills and tasks as follows:
                 - Give the magical pill to worker 0 and worker 1.
                 - Assign worker 0 to task 0 (0 + 10 >= 10)
                 - Assign worker 1 to task 1 (10 + 10 >= 15)

    Example 4:
    Input: tasks = [5,9,8,5,9], workers = [1,6,4,2,6], pills = 1, strength = 5
    Output: 3
    Explanation: We can assign the magical pill and tasks as follows:
                 - Give the magical pill to worker 2.
                 - Assign worker 1 to task 0 (6 >= 5)
                 - Assign worker 2 to task 2 (4 + 5 >= 8)
                 - Assign worker 4 to task 3 (6 >= 5)

    Constraints:
    * n == tasks.length
    * m == workers.length
    * 1 <= n, m <= 5 * 10^4
    * 0 <= pills <= m
    * 0 <= tasks[i], workers[j], strength <= 10^9"""

    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
        tasks.sort()
        workers.sort()

        def fn(k, p=pills):
            """Return True if k tasks can be completed."""
            ww = workers[-k:]
            for t in reversed(tasks[:k]):
                if t <= ww[-1]: ww.pop()
                elif t <= ww[-1] + strength and p:
                    p -= 1
                    i = bisect_left(ww, t - strength)
                    ww.pop(i)
                else: return False
            return True

        lo, hi = 0, min(len(tasks), len(workers))
        while lo < hi:
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid - 1
        return lo


    """2073. Time Needed to Buy Tickets (Easy)
    There are n people in a line queuing to buy tickets, where the 0th person
    is at the front of the line and the (n - 1)th person is at the back of the
    line. You are given a 0-indexed integer array tickets of length n where the
    number of tickets that the ith person would like to buy is tickets[i]. Each
    person takes exactly 1 second to buy a ticket. A person can only buy 1
    ticket at a time and has to go back to the end of the line (which happens
    instantaneously) in order to buy more tickets. If a person does not have
    any tickets left to buy, the person will leave the line. Return the time
    taken for the person at position k (0-indexed) to finish buying tickets.

    Example 1:
    Input: tickets = [2,3,2], k = 2
    Output: 6
    Explanation: - In the first pass, everyone in the line buys a ticket and
                   the line becomes [1, 2, 1].
                 - In the second pass, everyone in the line buys a ticket and
                   the line becomes [0, 1, 0].
                 The person at position 2 has successfully bought 2 tickets and
                 it took 3 + 3 = 6 seconds.

    Example 2:
    Input: tickets = [5,1,1,1], k = 0
    Output: 8
    Explanation: - In the first pass, everyone in the line buys a ticket and
                   the line becomes [4, 0, 0, 0].
                 - In the next 4 passes, only the person in position 0 is
                   buying tickets.
                 The person at position 0 has successfully bought 5 tickets and
                 it took 4 + 1 + 1 + 1 + 1 = 8 seconds.

    Constraints:
    * n == tickets.length
    * 1 <= n <= 100
    * 1 <= tickets[i] <= 100
    * 0 <= k < n"""

    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        ans = behind = 0
        for i, x in enumerate(tickets):
            if i > k: behind = 1
            if x < tickets[k] - behind: ans += x
            else: ans += tickets[k] - behind
        return ans


    """2074. Reverse Nodes in Even Length Groups (Medium)
    You are given the head of a linked list. The nodes in the linked list are
    sequentially assigned to non-empty groups whose lengths form the sequence
    of the natural numbers (1, 2, 3, 4, ...). The length of a group is the
    number of nodes assigned to it. In other words,
    * The 1st node is assigned to the first group.
    * The 2nd and the 3rd nodes are assigned to the second group.
    * The 4th, 5th, and 6th nodes are assigned to the third group, and so on.
    Note that the length of the last group may be less than or equal to
    1 + the length of the second to last group. Reverse the nodes in each group
    with an even length, and return the head of the modified linked list.

    Example 1:
    Input: head = [5,2,6,3,9,1,7,3,8,4]
    Output: [5,6,2,3,9,1,4,8,3,7]
    Explanation:
    - The length of the first group is 1, which is odd, hence no reversal occurrs.
    - The length of the second group is 2, which is even, hence the nodes are reversed.
    - The length of the third group is 3, which is odd, hence no reversal occurrs.
    - The length of the last group is 4, which is even, hence the nodes are reversed.

    Example 2:
    Input: head = [1,1,0,6]
    Output: [1,0,1,6]
    Explanation:
    - The length of the first group is 1. No reversal occurrs.
    - The length of the second group is 2. The nodes are reversed.
    - The length of the last group is 1. No reversal occurrs.

    Example 3:
    Input: head = [2,1]
    Output: [2,1]
    Explanation:
    - The length of the first group is 1. No reversal occurrs.
    - The length of the last group is 1. No reversal occurrs.

    Example 4:
    Input: head = [8]
    Output: [8]
    Explanation: There is only one group whose length is 1. No reversal occurrs.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5].
    * 0 <= Node.val <= 10^5"""

    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:
        n, node = 0, head
        while node: n, node = n+1, node.next

        node = head
        k = 0
        while n:
            k += 1
            size = min(k, n)
            stack = []
            if not size & 1:
                temp = node
                for _ in range(size):
                    stack.append(temp.val)
                    temp = temp.next
            for _ in range(size):
                if stack: node.val = stack.pop()
                node = node.next
            n -= size
        return head


    """2075. Decode the Slanted Ciphertext (Medium)
    A string originalText is encoded using a slanted transposition cipher to a
    string encodedText with the help of a matrix having a fixed number of rows
    rows. originalText is placed first in a top-left to bottom-right manner.
    The blue cells are filled first, followed by the red cells, then the yellow
    cells, and so on, until we reach the end of originalText. The arrow
    indicates the order in which the cells are filled. All empty cells are
    filled with ' '. The number of columns is chosen such that the rightmost
    column will not be empty after filling in originalText. encodedText is then
    formed by appending all characters of the matrix in a row-wise fashion. The
    characters in the blue cells are appended first to encodedText, then the
    red cells, and so on, and finally the yellow cells. The arrow indicates the
    order in which the cells are accessed. For example, if
    originalText = "cipher" and rows = 3, then we encode it in the following
    manner:
    The blue arrows depict how originalText is placed in the matrix, and the
    red arrows denote the order in which encodedText is formed. In the above
    example, encodedText = "ch ie pr". Given the encoded string encodedText and
    number of rows rows, return the original string originalText. Note:
    originalText does not have any trailing spaces ' '. The test cases are
    generated such that there is only one possible originalText.

    Example 1:
    Input: encodedText = "ch   ie   pr", rows = 3
    Output: "cipher"
    Explanation: This is the same example described in the problem description.

    Example 2:
    Input: encodedText = "iveo    eed   l te   olc", rows = 4
    Output: "i love leetcode"
    Explanation: The figure above denotes the matrix that was used to encode
                 originalText. The blue arrows show how we can find
                 originalText from encodedText.

    Example 3:
    Input: encodedText = "coding", rows = 1
    Output: "coding"
    Explanation: Since there is only 1 row, both originalText and encodedText
                 are the same.

    Example 4:
    Input: encodedText = " b  ac", rows = 2
    Output: " abc"
    Explanation: originalText cannot have trailing spaces, but it may be
                 preceded by one or more spaces.

    Constraints:
    * 0 <= encodedText.length <= 10^6
    * encodedText consists of lowercase English letters and ' ' only.
    * encodedText is a valid encoding of some originalText that does not have
      trailing spaces.
    * 1 <= rows <= 1000
    * The testcases are generated such that there is only one possible
      originalText."""

    def decodeCiphertext(self, encodedText: str, rows: int) -> str:
        cols = len(encodedText)//rows
        mat = [[""]*cols for _ in range(rows)]
        k = 0
        for i in range(rows):
            for j in range(cols):
                mat[i][j] = encodedText[k]
                k += 1
        ans = []
        for offset in range(cols):
            i, j = 0, offset
            while i < rows and j < cols:
                ans.append(mat[i][j])
                i, j = i+1, j+1
        return "".join(ans).rstrip()


    """2076. Process Restricted Friend Requests (Hard)
    You are given an integer n indicating the number of people in a network.
    Each person is labeled from 0 to n - 1. You are also given a 0-indexed 2D
    integer array restrictions, where restrictions[i] = [xi, yi] means that
    person xi and person yi cannot become friends, either directly or
    indirectly through other people. Initially, no one is friends with each
    other. You are given a list of friend requests as a 0-indexed 2D integer
    array requests, where requests[j] = [uj, vj] is a friend request between
    person uj and person vj. A friend request is successful if uj and vj can be
    friends. Each friend request is processed in the given order (i.e.,
    requests[j] occurs before requests[j + 1]), and upon a successful request,
    uj and vj become direct friends for all future friend requests. Return a
    boolean array result, where each result[j] is true if the jth friend
    request is successful or false if it is not. Note: If uj and vj are already
    direct friends, the request is still successful.

    Example 1:
    Input: n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]
    Output: [true,false]
    Explanation: Request 0: Person 0 and person 2 can be friends, so they
                 become direct friends. Request 1: Person 2 and person 1 cannot
                 be friends since person 0 and person 1 would be indirect
                 friends (1--2--0).

    Example 2:
    Input: n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]
    Output: [true,false]
    Explanation: Request 0: Person 1 and person 2 can be friends, so they
                 become direct friends. Request 1: Person 0 and person 2 cannot
                 be friends since person 0 and person 1 would be indirect
                 friends (0--2--1).

    Example 3:
    Input: n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]
    Output: [true,false,true,false]
    Explanation: Request 0: Person 0 and person 4 can be friends, so they
                 become direct friends. Request 1: Person 1 and person 2 cannot
                 be friends since they are directly restricted. Request 2:
                 Person 3 and person 1 can be friends, so they become direct
                 friends. Request 3: Person 3 and person 4 cannot be friends
                 since person 0 and person 1 would be indirect friends
                 (0--4--3--1).

    Constraints:
    * 2 <= n <= 1000
    * 0 <= restrictions.length <= 1000
    * restrictions[i].length == 2
    * 0 <= xi, yi <= n - 1
    * xi != yi
    * 1 <= requests.length <= 1000
    * requests[j].length == 2
    * 0 <= uj, vj <= n - 1
    * uj != vj"""

    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:
        ans = []
        uf = UnionFind(n)
        for u, v in requests:
            uu = uf.find(u)
            vv = uf.find(v)
            for x, y in restrictions:
                xx = uf.find(x)
                yy = uf.find(y)
                if uu == xx and vv == yy or uu == yy and vv == xx:
                    ans.append(False)
                    break
            else:
                ans.append(True)
                uf.union(u, v)
        return ans


    """2077. Paths in Maze That Lead to Same Room (Medium)
    A maze consists of n rooms numbered from 1 to n, and some rooms are
    connected by corridors. You are given a 2D integer array corridors where
    corridors[i] = [room1i, room2i] indicates that there is a corridor
    connecting room1i and room2i, allowing a person in the maze to go from
    room1i to room2i and vice versa. The designer of the maze wants to know how
    confusing the maze is. The confusion score of the maze is the number of
    different cycles of length 3.
    * For example, 1 → 2 → 3 → 1 is a cycle of length 3, but 1 → 2 → 3 → 4 and
      1 → 2 → 3 → 2 → 1 are not.
    Two cycles are considered to be different if one or more of the rooms
    visited in the first cycle is not in the second cycle. Return the confusion
    score of the maze.

    Example 1:
    Input: n = 5, corridors = [[1,2],[5,2],[4,1],[2,4],[3,1],[3,4]]
    Output: 2
    Explanation: One cycle of length 3 is 4 → 1 → 3 → 4, denoted in red. Note
                 that this is the same cycle as 3 → 4 → 1 → 3 or 1 → 3 → 4 → 1
                 because the rooms are the same. Another cycle of length 3 is
                 1 → 2 → 4 → 1, denoted in blue. Thus, there are two different
                 cycles of length 3.

    Example 2:
    Input: n = 4, corridors = [[1,2],[3,4]]
    Output: 0
    Explanation: There are no cycles of length 3.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= corridors.length <= 5 * 10^4
    * corridors[i].length == 2
    * 1 <= room1i, room2i <= n
    * room1i != room2i
    * There are no duplicate corridors."""

    def numberOfPaths(self, n: int, corridors: List[List[int]]) -> int:
        graph = [set() for _ in range(n)]
        for u, v in corridors:
            graph[u-1].add(v-1)
            graph[v-1].add(u-1)
        ans = 0
        for u, v in corridors:
            ans += len(graph[u-1] & graph[v-1])
        return ans // 3


    """2078. Two Furthest Houses With Different Colors (Easy)
    There are n houses evenly lined up on the street, and each house is
    beautifully painted. You are given a 0-indexed integer array colors of
    length n, where colors[i] represents the color of the ith house. Return the
    maximum distance between two houses with different colors. The distance
    between the ith and jth houses is abs(i - j), where abs(x) is the absolute
    value of x.

    Example 1:
    Input: colors = [1,1,1,6,1,1,1]
    Output: 3
    Explanation: In the above image, color 1 is blue, and color 6 is red. The
                 furthest two houses with different colors are house 0 and
                 house 3. House 0 has color 1, and house 3 has color 6. The
                 distance between them is abs(0 - 3) = 3. Note that houses 3
                 and 6 can also produce the optimal answer.

    Example 2:
    Input: colors = [1,8,3,8,3]
    Output: 4
    Explanation: In the above image, color 1 is blue, color 8 is yellow, and
                 color 3 is green. The furthest two houses with different
                 colors are house 0 and house 4. House 0 has color 1, and house
                 4 has color 3. The distance between them is abs(0 - 4) = 4.

    Example 3:
    Input: colors = [0,1]
    Output: 1
    Explanation: The furthest two houses with different colors are house 0 and
                 house 1. House 0 has color 0, and house 1 has color 1. The
                 distance between them is abs(0 - 1) = 1.

    Constraints:
    * n == colors.length
    * 2 <= n <= 100
    * 0 <= colors[i] <= 100
    * Test data are generated such that at least two houses have different
      colors."""

    def maxDistance(self, colors: List[int]) -> int:
        ans = 0
        for i, x in enumerate(colors):
            if x != colors[0]: ans = max(ans, i)
            if x != colors[-1]: ans = max(ans, len(colors)-1-i)
        return ans


    """2079. Watering Plants (Medium)
    You want to water n plants in your garden with a watering can. The plants
    are arranged in a row and are labeled from 0 to n - 1 from left to right
    where the ith plant is located at x = i. There is a river at x = -1 that
    you can refill your watering can at. Each plant needs a specific amount of
    water. You will water the plants in the following way:
    * Water the plants in order from left to right.
    * After watering the current plant, if you do not have enough water to
      completely water the next plant, return to the river to fully refill the
      watering can.
    * You cannot refill the watering can early.
    You are initially at the river (i.e., x = -1). It takes one step to move
    one unit on the x-axis. Given a 0-indexed integer array plants of n
    integers, where plants[i] is the amount of water the ith plant needs, and
    an integer capacity representing the watering can capacity, return the
    number of steps needed to water all the plants.

    Example 1:
    Input: plants = [2,2,3,3], capacity = 5
    Output: 14
    Explanation: Start at the river with a full watering can:
    - Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.
    - Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.
    - Since you cannot completely water plant 2, walk back to the river to refill (2 steps).
    - Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.
    - Since you cannot completely water plant 3, walk back to the river to refill (3 steps).
    - Walk to plant 3 (4 steps) and water it.
    Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.

    Example 2:
    Input: plants = [1,1,1,4,2,3], capacity = 4
    Output: 30
    Explanation: Start at the river with a full watering can:
    - Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).
    - Water plant 3 (4 steps). Return to river (4 steps).
    - Water plant 4 (5 steps). Return to river (5 steps).
    - Water plant 5 (6 steps).
    Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.

    Example 3:
    Input: plants = [7,7,7,7,7,7,7], capacity = 8
    Output: 49
    Explanation: You have to refill before watering each plant. Steps needed
                 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.

    Constraints:
    * n == plants.length
    * 1 <= n <= 1000
    * 1 <= plants[i] <= 10^6
    * max(plants[i]) <= capacity <= 10^9"""

    def wateringPlants(self, plants: List[int], capacity: int) -> int:
        ans = 0
        can = capacity
        for i, x in enumerate(plants):
            if can < x:
                ans += 2*i
                can = capacity
            ans += 1
            can -= x
        return ans


    """2081. Sum of k-Mirror Numbers (Hard)
    A k-mirror number is a positive integer without leading zeros that reads
    the same both forward and backward in base-10 as well as in base-k. For
    example, 9 is a 2-mirror number. The representation of 9 in base-10 and
    base-2 are 9 and 1001 respectively, which read the same both forward and
    backward. On the contrary, 4 is not a 2-mirror number. The representation
    of 4 in base-2 is 100, which does not read the same both forward and
    backward. Given the base k and the number n, return the sum of the n
    smallest k-mirror numbers.

    Example 1:
    Input: k = 2, n = 5
    Output: 25
    Explanation: The 5 smallest 2-mirror numbers and their representations in
                 base-2 are listed as follows:
                   base-10    base-2
                     1          1
                     3          11
                     5          101
                     7          111
                     9          1001
                 Their sum = 1 + 3 + 5 + 7 + 9 = 25.

    Example 2:
    Input: k = 3, n = 7
    Output: 499
    Explanation: The 7 smallest 3-mirror numbers are and their representations
                 in base-3 are listed as follows:
                   base-10    base-3
                     1          1
                     2          2
                     4          11
                     8          22
                     121        11111
                     151        12121
                     212        21212
                 Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.

    Example 3:
    Input: k = 7, n = 17
    Output: 20379000
    Explanation: The 17 smallest 7-mirror numbers are: 1, 2, 3, 4, 5, 6, 8, 121,
                 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596

    Constraints:
    * 2 <= k <= 9
    * 1 <= n <= 30"""

    def kMirror(self, k: int, n: int) -> int:

        def fn(x):
            """Return next k-symmetric number."""
            n = len(x)//2
            for i in range(n, len(x)):
                if int(x[i])+1 < k:
                    x[i] = x[~i] = str(int(x[i])+1)
                    for ii in range(n, i): x[ii] = x[~ii] = '0'
                    return x
            return ["1"] + ["0"]*(len(x)-1) + ["1"]

        x = ["0"]
        ans = 0
        for _ in range(n):
            while True:
                x = fn(x)
                val = int("".join(x), k)
                if str(val)[::-1] == str(val): break
            ans += val
        return ans


    """2083. Substrings That Begin and End With the Same Letter (Medium)
    You are given a 0-indexed string s consisting of only lowercase English
    letters. Return the number of substrings in s that begin and end with the
    same character. A substring is a contiguous non-empty sequence of
    characters within a string.

    Example 1:
    Input: s = "abcba"
    Output: 7
    Explanation: The substrings of length 1 that start and end with the same
                 letter are: "a", "b", "c", "b", and "a". The substring of
                 length 3 that starts and ends with the same letter is: "bcb".
                 The substring of length 5 that starts and ends with the same
                 letter is: "abcba".

    Example 2:
    Input: s = "abacad"
    Output: 9
    Explanation: The substrings of length 1 that start and end with the same
                 letter are: "a", "b", "a", "c", "a", and "d". The substrings
                 of length 3 that start and end with the same letter are: "aba"
                 and "aca". The substring of length 5 that starts and ends with
                 the same letter is: "abaca".

    Example 3:
    Input: s = "a"
    Output: 1
    Explanation: The substring of length 1 that starts and ends with the same
                 letter is: "a".

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters."""

    def numberOfSubstrings(self, s: str) -> int:
        return sum(v*(v+1)//2 for v in Counter(s).values())


    """2085. Count Common Words With One Occurrence (Easy)
    Given two string arrays words1 and words2, return the number of strings
    that appear exactly once in each of the two arrays.

    Example 1:
    Input: words1 = ["leetcode","is","amazing","as","is"], words2 = ["amazing","leetcode","is"]
    Output: 2
    Explanation:
    - "leetcode" appears exactly once in each of the two arrays. We count this
      string.
    - "amazing" appears exactly once in each of the two arrays. We count this
      string.
    - "is" appears in each of the two arrays, but there are 2 occurrences of it
      in words1. We do not count this string.
    - "as" appears once in words1, but does not appear in words2. We do not
      count this string.
    Thus, there are 2 strings that appear exactly once in each of the two
    arrays.

    Example 2:
    Input: words1 = ["b","bb","bbb"], words2 = ["a","aa","aaa"]
    Output: 0
    Explanation: There are no strings that appear in each of the two arrays.

    Example 3:
    Input: words1 = ["a","ab"], words2 = ["a","a","a","ab"]
    Output: 1
    Explanation: The only string that appears exactly once in each of the two arrays is "ab".

    Constraints:
    * 1 <= words1.length, words2.length <= 1000
    * 1 <= words1[i].length, words2[j].length <= 30
    * words1[i] and words2[j] consists only of lowercase English letters."""

    def countWords(self, words1: List[str], words2: List[str]) -> int:
        freq1, freq2 = Counter(words1), Counter(words2)
        return len({w for w, v in freq1.items() if v == 1} & {w for w, v in freq2.items() if v == 1})


    """2086. Minimum Number of Buckets Required to Collect Rainwater from Houses (Medium)
    You are given a 0-indexed string street. Each character in street is either
    'H' representing a house or '.' representing an empty space. You can place
    buckets on the empty spaces to collect rainwater that falls from the
    adjacent houses. The rainwater from a house at index i is collected if a
    bucket is placed at index i - 1 and/or index i + 1. A single bucket, if
    placed adjacent to two houses, can collect the rainwater from both houses.
    Return the minimum number of buckets needed so that for every house, there
    is at least one bucket collecting rainwater from it, or -1 if it is
    impossible.

    Example 1:
    Input: street = "H..H"
    Output: 2
    Explanation: We can put buckets at index 1 and index 2. "H..H" -> "HBBH"
                 ('B' denotes where a bucket is placed). The house at index 0
                 has a bucket to its right, and the house at index 3 has a
                 bucket to its left. Thus, for every house, there is at least
                 one bucket collecting rainwater from it.

    Example 2:
    Input: street = ".H.H."
    Output: 1
    Explanation: We can put a bucket at index 2. ".H.H." -> ".HBH." ('B'
                 denotes where a bucket is placed). The house at index 1 has a
                 bucket to its right, and the house at index 3 has a bucket to
                 its left. Thus, for every house, there is at least one bucket
                 collecting rainwater from it.

    Example 3:
    Input: street = ".HHH."
    Output: -1
    Explanation: There is no empty space to place a bucket to collect the
                 rainwater from the house at index 2. Thus, it is impossible to
                 collect the rainwater from all the houses.

    Example 4:
    Input: street = "H"
    Output: -1
    Explanation: There is no empty space to place a bucket. Thus, it is
                 impossible to collect the rainwater from the house.

    Example 5:
    Input: street = "."
    Output: 0
    Explanation: There is no house to collect water from. Thus, 0 buckets are
                 needed.

    Constraints:
    * 1 <= street.length <= 10^5
    * street[i] is either'H' or '.'."""

    def minimumBuckets(self, street: str) -> int:
        street = list(street)
        ans = 0
        for i, ch in enumerate(street):
            if ch == 'H' and (i == 0 or street[i-1] != '#'):
                if i+1 < len(street) and street[i+1] == '.': street[i+1] = '#'
                elif i and street[i-1] == '.': street[i-1] = '#'
                else: return -1
                ans += 1
        return ans


    """2087. Minimum Cost Homecoming of a Robot in a Grid (Medium)
    There is an m x n grid, where (0, 0) is the top-left cell and (m - 1, n - 1)
    is the bottom-right cell. You are given an integer array startPos where
    startPos = [startrow, startcol] indicates that initially, a robot is at the
    cell (startrow, startcol). You are also given an integer array homePos
    where homePos = [homerow, homecol] indicates that its home is at the cell
    (homerow, homecol). The robot needs to go to its home. It can move one cell
    in four directions: left, right, up, or down, and it can not move outside
    the boundary. Every move incurs some cost. You are further given two 0-
    indexed integer arrays: rowCosts of length m and colCosts of length n.
    * If the robot moves up or down into a cell whose row is r, then this move
      costs rowCosts[r].
    * If the robot moves left or right into a cell whose column is c, then this
      move costs colCosts[c].
    Return the minimum total cost for this robot to return home.

    Example 1:
    Input: startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]
    Output: 18
    Explanation: One optimal path is that: Starting from (1, 0)
    -> It goes down to (2, 0). This move costs rowCosts[2] = 3.
    -> It goes right to (2, 1). This move costs colCosts[1] = 2.
    -> It goes right to (2, 2). This move costs colCosts[2] = 6.
    -> It goes right to (2, 3). This move costs colCosts[3] = 7.
    The total cost is 3 + 2 + 6 + 7 = 18

    Example 2:
    Input: startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]
    Output: 0
    Explanation: The robot is already at its home. Since no moves occur, the
                 total cost is 0.

    Constraints:
    * m == rowCosts.length
    * n == colCosts.length
    * 1 <= m, n <= 10^5
    * 0 <= rowCosts[r], colCosts[c] <= 10^4
    * startPos.length == 2
    * homePos.length == 2
    * 0 <= startrow, homerow < m
    * 0 <= startcol, homecol < n"""

    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:
        ans = 0
        if startPos[0] < homePos[0]: ans = sum(rowCosts[startPos[0]+1:homePos[0]+1])
        elif startPos[0] > homePos[0]: ans = sum(rowCosts[homePos[0]:startPos[0]])
        if startPos[1] < homePos[1]: ans += sum(colCosts[startPos[1]+1:homePos[1]+1])
        elif startPos[1] > homePos[1]: ans += sum(colCosts[homePos[1]:startPos[1]])
        return ans


    """2088. Count Fertile Pyramids in a Land (Hard)
    A farmer has a rectangular grid of land with m rows and n columns that can
    be divided into unit cells. Each cell is either fertile (represented by a 1)
    or barren (represented by a 0). All cells outside the grid are considered
    barren. A pyramidal plot of land can be defined as a set of cells with the
    following criteria:
    * The number of cells in the set has to be greater than 1 and all cells
      must be fertile.
    * The apex of a pyramid is the topmost cell of the pyramid. The height of a
      pyramid is the number of rows it covers. Let (r, c) be the apex of the
      pyramid, and its height be h. Then, the plot comprises of cells (i, j)
      where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).
    An inverse pyramidal plot of land can be defined as a set of cells with
    similar criteria:
    * The number of cells in the set has to be greater than 1 and all cells
      must be fertile.
    * The apex of an inverse pyramid is the bottommost cell of the inverse
      pyramid. The height of an inverse pyramid is the number of rows it covers.
      Let (r, c) be the apex of the pyramid, and its height be h. Then, the
      plot comprises of cells (i, j) where r - h + 1 <= i <= r and
      c - (r - i) <= j <= c + (r - i).
    Some examples of valid and invalid pyramidal (and inverse pyramidal) plots
    are shown below. Black cells indicate fertile cells. Given a 0-indexed
    m x n binary matrix grid representing the farmland, return the total number
    of pyramidal and inverse pyramidal plots that can be found in grid.

    Example 1:
    Input: grid = [[0,1,1,0],[1,1,1,1]]
    Output: 2
    Explanation: The 2 possible pyramidal plots are shown in blue and red
                 respectively. There are no inverse pyramidal plots in this
                 grid. Hence total number of pyramidal and inverse pyramidal
                 plots is 2 + 0 = 2.

    Example 2:
    Input: grid = [[1,1,1],[1,1,1]]
    Output: 2
    Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal
                 plot is shown in red. Hence the total number of plots is
                 1 + 1 = 2.

    Example 3:
    Input: grid = [[1,0,1],[0,0,0],[1,0,1]]
    Output: 0
    Explanation: There are no pyramidal or inverse pyramidal plots in the grid.

    Example 4:
    Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]
    Output: 13
    Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd
                 and 3rd figures. There are 6 inverse pyramidal plots, 2 of
                 which are shown in the last figure. The total number of plots
                 is 7 + 6 = 13.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 1000
    * 1 <= m * n <= 10^5
    * grid[i][j] is either 0 or 1."""

    def countPyramids(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        vals = [[inf]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0: vals[i][j] = 0
                elif j == 0: vals[i][j] = 1
                else: vals[i][j] = min(vals[i][j], 1 + vals[i][j-1])
                if grid[i][~j] == 0: vals[i][~j] = 0
                elif j == 0: vals[i][~j] = 1
                else: vals[i][~j] = min(vals[i][~j], 1 + vals[i][~j+1])

        def fn(vals):
            """Return count of pyramid in given grid."""
            ans = 0
            for j in range(n):
                width = 0
                for i in range(m):
                    if vals[i][j]: width = min(width+1, vals[i][j])
                    else: width = 0
                    ans += max(0, width-1)
            return ans

        return fn(vals) + fn(vals[::-1])


    """2089. Find Target Indices After Sorting Array (Easy)
    You are given a 0-indexed integer array nums and a target element target.
    A target index is an index i such that nums[i] == target. Return a list of
    the target indices of nums after sorting nums in non-decreasing order. If
    there are no target indices, return an empty list. The returned list must
    be sorted in increasing order.

    Example 1:
    Input: nums = [1,2,5,2,3], target = 2
    Output: [1,2]
    Explanation: After sorting, nums is [1,2,2,3,5]. The indices where
                 nums[i] == 2 are 1 and 2.

    Example 2:
    Input: nums = [1,2,5,2,3], target = 3
    Output: [3]
    Explanation: After sorting, nums is [1,2,2,3,5]. The index where
                 nums[i] == 3 is 3.

    Example 3:
    Input: nums = [1,2,5,2,3], target = 5
    Output: [4]
    Explanation: After sorting, nums is [1,2,2,3,5]. The index where
                 nums[i] == 5 is 4.

    Example 4:
    Input: nums = [1,2,5,2,3], target = 4
    Output: []
    Explanation: There are no elements in nums with value 4.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i], target <= 100"""

    def targetIndices(self, nums: List[int], target: int) -> List[int]:
        lo, mid, hi = 0, 0, len(nums)-1
        while mid <= hi:
            if nums[mid] < target:
                nums[lo], nums[mid] = nums[mid], nums[lo]
                lo += 1
                mid += 1
            elif nums[mid] == target: mid += 1
            else:
                nums[mid], nums[hi] = nums[hi], nums[mid]
                hi -= 1
        return range(lo, hi+1)


    """2090. K Radius Subarray Averages (Medium)
    You are given a 0-indexed array nums of n integers, and an integer k. The
    k-radius average for a subarray of nums centered at some index i with the
    radius k is the average of all elements in nums between the indices i - k
    and i + k (inclusive). If there are less than k elements before or after
    the index i, then the k-radius average is -1. Build and return an array
    avgs of length n where avgs[i] is the k-radius average for the subarray
    centered at index i. The average of x elements is the sum of the x elements
    divided by x, using integer division. The integer division truncates toward
    zero, which means losing its fractional part. For example, the average of
    four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which
    truncates to 2.

    Example 1:
    Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
    Output: [-1,-1,-1,5,4,4,-1,-1,-1]
    Explanation:
    - avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.
    - The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.
      Using integer division, avg[3] = 37 / 7 = 5.
    - For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.
    - For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.
    - avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.

    Example 2:
    Input: nums = [100000], k = 0
    Output: [100000]
    Explanation:
    - The sum of the subarray centered at index 0 with radius 0 is: 100000.
      avg[0] = 100000 / 1 = 100000.

    Example 3:
    Input: nums = [8], k = 100000
    Output: [-1]
    Explanation:
    - avg[0] is -1 because there are less than k elements before and after index 0.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 0 <= nums[i], k <= 10^5"""

    def getAverages(self, nums: List[int], k: int) -> List[int]:
        ans = [-1]*len(nums)
        rsm = 0 # range sum
        for i, x in enumerate(nums):
            rsm += x
            if i >= 2*k+1: rsm -= nums[i-(2*k+1)]
            if i+1 >= 2*k+1: ans[i-k] = rsm//(2*k+1)
        return ans


    """2091. Removing Minimum and Maximum From Array (Medium)
    You are given a 0-indexed array of distinct integers nums. There is an
    element in nums that has the lowest value and an element that has the
    highest value. We call them the minimum and maximum respectively. Your goal
    is to remove both these elements from the array. A deletion is defined as
    either removing an element from the front of the array or removing an
    element from the back of the array. Return the minimum number of deletions
    it would take to remove both the minimum and maximum element from the array.

    Example 1:
    Input: nums = [2,10,7,5,4,1,8,6]
    Output: 5
    Explanation: The minimum element in the array is nums[5], which is 1. The
                 maximum element in the array is nums[1], which is 10. We can
                 remove both the minimum and maximum by removing 2 elements
                 from the front and 3 elements from the back. This results in
                 2 + 3 = 5 deletions, which is the minimum number possible.

    Example 2:
    Input: nums = [0,-4,19,1,8,-2,-3,5]
    Output: 3
    Explanation: The minimum element in the array is nums[1], which is -4. The
                 maximum element in the array is nums[2], which is 19. We can
                 remove both the minimum and maximum by removing 3 elements
                 from the front. This results in only 3 deletions, which is the
                 minimum number possible.

    Example 3:
    Input: nums = [101]
    Output: 1
    Explanation: There is only one element in the array, which makes it both
                 the minimum and maximum element. We can remove it with 1
                 deletion.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^5 <= nums[i] <= 10^5
    * The integers in nums are distinct."""

    def minimumDeletions(self, nums: List[int]) -> int:
        imin = nums.index(min(nums))
        imax = nums.index(max(nums))
        k, kk = min(imin, imax), max(imin, imax)
        return min(kk+1, len(nums)-k, len(nums)+1+k-kk)


    """2092. Find All People With Secret (Hard)
    You are given an integer n indicating there are n people numbered from 0 to
    n - 1. You are also given a 0-indexed 2D integer array meetings where
    meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a
    meeting at timei. A person may attend multiple meetings at the same time.
    Finally, you are given an integer firstPerson. Person 0 has a secret and
    initially shares the secret with a person firstPerson at time 0. This
    secret is then shared every time a meeting takes place with a person that
    has the secret. More formally, for every meeting, if a person xi has the
    secret at timei, then they will share the secret with person yi, and vice
    versa. The secrets are shared instantaneously. That is, a person may
    receive the secret and share it with people in other meetings within the
    same time frame. Return a list of all the people that have the secret after
    all the meetings have taken place. You may return the answer in any order.

    Example 1:
    Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
    Output: [0,1,2,3,5]
    Explanation: At time 0, person 0 shares the secret with person 1.
                 At time 5, person 1 shares the secret with person 2.
                 At time 8, person 2 shares the secret with person 3.
                 At time 10, person 1 shares the secret with person 5.
                 Thus, people 0, 1, 2, 3, and 5 know the secret after all the
                 meetings.

    Example 2:
    Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
    Output: [0,1,3]
    Explanation: At time 0, person 0 shares the secret with person 3.
                 At time 2, neither person 1 nor person 2 know the secret.
                 At time 3, person 3 shares the secret with person 0 and person 1.
                 Thus, people 0, 1, and 3 know the secret after all the meetings.

    Example 3:
    Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
    Output: [0,1,2,3,4]
    Explanation: At time 0, person 0 shares the secret with person 1.
                 At time 1, person 1 shares the secret with person 2, and
                 person 2 shares the secret with person 3. Note that person 2
                 can share the secret at the same time as receiving it.
                 At time 2, person 3 shares the secret with person 4.
                 Thus, people 0, 1, 2, 3, and 4 know the secret after all the
                 meetings.

    Example 4:
    Input: n = 6, meetings = [[0,2,1],[1,3,1],[4,5,1]], firstPerson = 1
    Output: [0,1,2,3]
    Explanation: At time 0, person 0 shares the secret with person 1.
                 At time 1, person 0 shares the secret with person 2, and person 1 shares the secret with person 3.
                 Thus, people 0, 1, 2, and 3 know the secret after all the meetings.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= meetings.length <= 10^5
    * meetings[i].length == 3
    * 0 <= xi, yi <= n - 1
    * xi != yi
    * 1 <= timei <= 10^5
    * 1 <= firstPerson <= n - 1"""

    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        can = {0, firstPerson}
        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]):
            queue = set()
            graph = defaultdict(list)
            for x, y, _ in grp:
                graph[x].append(y)
                graph[y].append(x)
                if x in can: queue.add(x)
                if y in can: queue.add(y)

            queue = deque(queue)
            while queue:
                x = queue.popleft()
                for y in graph[x]:
                    if y not in can:
                        can.add(y)
                        queue.append(y)
        return can


    """2093. Minimum Cost to Reach City With Discounts (Medium)
    A series of highways connect n cities numbered from 0 to n - 1. You are
    given a 2D integer array highways where highways[i] = [city1i, city2i, tolli]
    indicates that there is a highway that connects city1i and city2i, allowing
    a car to go from city1i to city2i and vice versa for a cost of tolli. You
    are also given an integer discounts which represents the number of
    discounts you have. You can use a discount to travel across the ith highway
    for a cost of tolli / 2 (integer division). Each discount may only be used
    once, and you can only use at most one discount per highway. Return the
    minimum total cost to go from city 0 to city n - 1, or -1 if it is not
    possible to go from city 0 to city n - 1.

    Example 1:
    Input: n = 5, highways = [[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]], discounts = 1
    Output: 9
    Explanation: Go from 0 to 1 for a cost of 4. Go from 1 to 4 and use a
                 discount for a cost of 11 / 2 = 5. The minimum cost to go from
                 0 to 4 is 4 + 5 = 9.

    Example 2:
    Input: n = 4, highways = [[1,3,17],[1,2,7],[3,2,5],[0,1,6],[3,0,20]], discounts = 20
    Output: 8
    Explanation: Go from 0 to 1 and use a discount for a cost of 6 / 2 = 3.
                 Go from 1 to 2 and use a discount for a cost of 7 / 2 = 3.
                 Go from 2 to 3 and use a discount for a cost of 5 / 2 = 2.
                 The minimum cost to go from 0 to 3 is 3 + 3 + 2 = 8.

    Example 3:
    Input: n = 4, highways = [[0,1,3],[2,3,2]], discounts = 0
    Output: -1
    Explanation: It is impossible to go from 0 to 3 so return -1.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= highways.length <= 1000
    * highways[i].length == 3
    * 0 <= city1i, city2i <= n - 1
    * city1i != city2i
    * 0 <= tolli <= 105
    * 0 <= discounts <= 500
    * There are no duplicate highways."""

    def minimumCost(self, n: int, highways: List[List[int]], discounts: int) -> int:
        graph = [[] for _ in range(n)]
        for u, v, cost in highways:
            graph[u].append((v, cost))
            graph[v].append((u, cost))
        dist = defaultdict(lambda : inf, {(0, discounts) : 0})
        pq = [(0, discounts, 0)]
        while pq:
            x, d, u = heappop(pq)
            if u == n-1: return x
            for v, cost in graph[u]:
                if x+cost < dist[v, d]:
                    heappush(pq, (x+cost, d, v))
                    dist[v, d] = x+cost
                if d and x+cost//2 < dist[v, d-1]:
                    heappush(pq, (x+cost//2, d-1, v))
                    dist[v, d-1] = x+cost//2
        return -1


    """2094. Finding 3-Digit Even Numbers (Easy)
    You are given an integer array digits, where each element is a digit. The
    array may contain duplicates. You need to find all the unique integers that
    follow the given requirements:
    * The integer consists of the concatenation of three elements from digits
      in any arbitrary order.
    * The integer does not have leading zeros.
    * The integer is even.
    For example, if the given digits were [1, 2, 3], integers 132 and 312
    follow the requirements. Return a sorted array of the unique integers.

    Example 1:
    Input: digits = [2,1,3,0]
    Output: [102,120,130,132,210,230,302,310,312,320]
    Explanation: All the possible integers that follow the requirements are in
                 the output array. Notice that there are no odd integers or
                 integers with leading zeros.

    Example 2:
    Input: digits = [2,2,8,8,2]
    Output: [222,228,282,288,822,828,882]
    Explanation: The same digit can be used as many times as it appears in
                 digits. In this example, the digit 8 is used twice each time
                 in 288, 828, and 882.

    Example 3:
    Input: digits = [3,7,5]
    Output: []
    Explanation: No even integers can be formed using the given digits.

    Example 4:
    Input: digits = [0,2,0,0]
    Output: [200]
    Explanation: The only valid integer that can be formed with three digits
                 and no leading zeros is 200.

    Example 5:
    Input: digits = [0,0,0]
    Output: []
    Explanation: All the integers that can be formed have leading zeros. Thus,
                 there are no valid integers.

    Constraints:
    * 3 <= digits.length <= 100
    * 0 <= digits[i] <= 9"""

    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        ans = []
        freq = Counter(digits)
        for x in range(100, 1000, 2):
            if not Counter(int(d) for d in str(x)) - freq: ans.append(x)
        return ans


    """2095. Delete the Middle Node of a Linked List (Medium)
    You are given the head of a linked list. Delete the middle node, and return
    the head of the modified linked list. The middle node of a linked list of
    size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where
    ⌊x⌋ denotes the largest integer less than or equal to x. For n = 1, 2, 3, 4,
    and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.

    Example 1:
    Input: head = [1,3,4,7,1,2,6]
    Output: [1,3,4,1,2,6]
    Explanation: The above figure represents the given linked list. The indices
                 of the nodes are written below. Since n = 7, node 3 with value
                 7 is the middle node, which is marked in red. We return the
                 new list after removing this node.

    Example 2:
    Input: head = [1,2,3,4]
    Output: [1,2,4]
    Explanation: The above figure represents the given linked list. For n = 4,
                 node 2 with value 3 is the middle node, which is marked in red.

    Example 3:
    Input: head = [2,1]
    Output: [2]
    Explanation: The above figure represents the given linked list. For n = 2,
                 node 1 with value 1 is the middle node, which is marked in red.
                 Node 0 with value 2 is the only node remaining after removing
                 node 1.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5"""

    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            prev = slow
            slow = slow.next
        if not prev: return None
        prev.next = prev.next.next
        return head


    """2096. Step-By-Step Directions From a Binary Tree Node to Another (Medium)
    You are given the root of a binary tree with n nodes. Each node is uniquely
    assigned a value from 1 to n. You are also given an integer startValue
    representing the value of the start node s, and a different integer
    destValue representing the value of the destination node t. Find the
    shortest path starting from node s and ending at node t. Generate step-by-
    step directions of such path as a string consisting of only the uppercase
    letters 'L', 'R', and 'U'. Each letter indicates a specific direction:
    * 'L' means to go from a node to its left child node.
    * 'R' means to go from a node to its right child node.
    * 'U' means to go from a node to its parent node.
    Return the step-by-step directions of the shortest path from node s to node
    t.

    Example 1:
    Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
    Output: "UURL"
    Explanation: The shortest path is: 3 → 1 → 5 → 2 → 6.

    Example 2:
    Input: root = [2,1], startValue = 2, destValue = 1
    Output: "L"
    Explanation: The shortest path is: 2 → 1.

    Constraints:
    * The number of nodes in the tree is n.
    * 2 <= n <= 10^5
    * 1 <= Node.val <= n
    * All the values in the tree are unique.
    * 1 <= startValue, destValue <= n
    * startValue != destValue"""

    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:

        def lca(node):
            """Return lowest common ancestor of start and dest nodes."""
            if not node or node.val in (startValue , destValue): return node
            left, right = lca(node.left), lca(node.right)
            return node if left and right else left or right

        root = lca(root) # only this sub-tree matters

        ps = pd = ""
        stack = [(root, "")]
        while stack:
            node, path = stack.pop()
            if node.val == startValue: ps = path
            if node.val == destValue: pd = path
            if node.left: stack.append((node.left, path + "L"))
            if node.right: stack.append((node.right, path + "R"))
        return "U"*len(ps) + pd


    """2097. Valid Arrangement of Pairs (Hard)
    You are given a 0-indexed 2D integer array pairs where
    pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every
    index i where 1 <= i < pairs.length, we have endi-1 == starti. Return any
    valid arrangement of pairs. Note: The inputs will be generated such that
    there exists a valid arrangement of pairs.

    Example 1:
    Input: pairs = [[5,1],[4,5],[11,9],[9,4]]
    Output: [[11,9],[9,4],[4,5],[5,1]]
    Explanation: This is a valid arrangement since endi-1 always equals starti.
                 end0 = 9 == 9 = start1
                 end1 = 4 == 4 = start2
                 end2 = 5 == 5 = start3

    Example 2:
    Input: pairs = [[1,3],[3,2],[2,1]]
    Output: [[1,3],[3,2],[2,1]]
    Explanation: This is a valid arrangement since endi-1 always equals starti.
                 end0 = 3 == 3 = start1
                 end1 = 2 == 2 = start2
                 The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]]
                 are also valid.

    Example 3:
    Input: pairs = [[1,2],[1,3],[2,1]]
    Output: [[1,2],[2,1],[1,3]]
    Explanation: This is a valid arrangement since endi-1 always equals starti.
                 end0 = 2 == 2 = start1
                 end1 = 1 == 1 = start2

    Constraints:
    * 1 <= pairs.length <= 10^5
    * pairs[i].length == 2
    * 0 <= starti, endi <= 10^9
    * starti != endi
    * No two pairs are exactly the same.
    * There exists a valid arrangement of pairs."""

    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(list)
        degree = defaultdict(int) # net out degree
        for x, y in pairs:
            graph[x].append(y)
            degree[x] += 1
            degree[y] -= 1

        for k in degree:
            if degree[k] == 1:
                x = k
                break

        ans = []
        stack = [x]
        while stack:
            while graph[stack[-1]]:
                stack.append(graph[stack[-1]].pop())
            ans.append(stack.pop())
        ans.reverse()
        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]


    """2098. Subsequence of Size K With the Largest Even Sum (Medium)
    You are given an integer array nums and an integer k. Find the largest even
    sum of any subsequence of nums that has a length of k. Return this sum, or
    -1 if such a sum does not exist. A subsequence is an array that can be
    derived from another array by deleting some or no elements without changing
    the order of the remaining elements.

    Example 1:
    Input: nums = [4,1,5,3,1], k = 3
    Output: 12
    Explanation: The subsequence with the largest possible even sum is [4,5,3].
                 It has a sum of 4 + 5 + 3 = 12.

    Example 2:
    Input: nums = [4,6,2], k = 3
    Output: 12
    Explanation: The subsequence with the largest possible even sum is [4,6,2].
                 It has a sum of 4 + 6 + 2 = 12.

    Example 3:
    Input: nums = [1,3,5], k = 1
    Output: -1
    Explanation: No subsequence of nums with length 1 has an even sum.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5
    * 1 <= k <= nums.length"""

    def largestEvenSum(self, nums: List[int], k: int) -> int:
        ans = -1
        least = [inf, inf]
        prefix = 0
        for i, x in enumerate(sorted(nums, reverse=True)):
            if i < k:
                prefix += x
                least[x&1] = min(least[x&1], x)
                if i == k-1 and not prefix&1: return prefix
            else: ans = max(ans, prefix - least[not x&1] + x)
        return ans


    """2099. Find Subsequence of Length K With the Largest Sum (Easy)
    You are given an integer array nums and an integer k. You want to find a
    subsequence of nums of length k that has the largest sum. Return any such
    subsequence as an integer array of length k. A subsequence is an array that
    can be derived from another array by deleting some or no elements without
    changing the order of the remaining elements.

    Example 1:
    Input: nums = [2,1,3,3], k = 2
    Output: [3,3]
    Explanation: The subsequence has the largest sum of 3 + 3 = 6.

    Example 2:
    Input: nums = [-1,-2,3,4], k = 3
    Output: [-1,3,4]
    Explanation: The subsequence has the largest sum of -1 + 3 + 4 = 6.

    Example 3:
    Input: nums = [3,4,3,3], k = 2
    Output: [3,4]
    Explanation: The subsequence has the largest sum of 3 + 4 = 7. Another
                 possible subsequence is [4, 3].

    Constraints:
    * 1 <= nums.length <= 1000
    * -10^5 <= nums[i] <= 10^5
    * 1 <= k <= nums.length"""

    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        temp = nums[:]
        shuffle(temp)

        def part(lo, hi):
            """Return partition of nums[lo:hi]."""
            i, j = lo+1, hi-1
            while i <= j:
                if temp[i] < temp[lo]: i += 1
                elif temp[j] > temp[lo]: j -= 1
                else:
                    temp[i], temp[j] = temp[j], temp[i]
                    i += 1
                    j -= 1
            temp[lo], temp[j] = temp[j], temp[lo]
            return j

        lo, hi = 0, len(temp)
        while lo <= hi:
            mid = part(lo, hi)
            if mid < len(temp)-k: lo += 1
            elif mid == len(temp)-k: break
            else: hi = mid
        threshold = temp[mid]

        larger = sum(x > threshold for x in nums)
        equal = k - larger

        ans = []
        for x in nums:
            if x > threshold: ans.append(x)
            elif x == threshold:
                if equal:
                    equal -= 1
                    ans.append(x)
        return ans


    """2100. Find Good Days to Rob the Bank (Medium)
    You and a gang of thieves are planning on robbing a bank. You are given a
    0-indexed integer array security, where security[i] is the number of guards
    on duty on the ith day. The days are numbered starting from 0. You are also
    given an integer time. The ith day is a good day to rob the bank if:
    * There are at least time days before and after the ith day,
    * The number of guards at the bank for the time days before i are non-
      increasing, and
    * The number of guards at the bank for the time days after i are non-
      decreasing.
    More formally, this means day i is a good day to rob the bank if and only
    if security[i - time] >= security[i - time + 1] >= ... >= security[i]
    <= ... <= security[i + time - 1] <= security[i + time]. Return a list of
    all days (0-indexed) that are good days to rob the bank. The order that the
    days are returned in does not matter.

    Example 1:
    Input: security = [5,3,3,3,5,6,2], time = 2
    Output: [2,3]
    Explanation: On day 2, we have security[0] >= security[1] >= security[2]
                 <= security[3] <= security[4]. On day 3, we have security[1]
                 >= security[2] >= security[3] <= security[4] <= security[5].
                 No other days satisfy this condition, so days 2 and 3 are the
                 only good days to rob the bank.

    Example 2:
    Input: security = [1,1,1,1,1], time = 0
    Output: [0,1,2,3,4]
    Explanation: Since time equals 0, every day is a good day to rob the bank,
                 so return every day.

    Example 3:
    Input: security = [1,2,3,4,5,6], time = 2
    Output: []
    Explanation: No day has 2 days before it that have a non-increasing number
                 of guards. Thus, no day is a good day to rob the bank, so
                 return an empty list.

    Example 4:
    Input: security = [1], time = 5
    Output: []
    Explanation: No day has 5 days before and after it. Thus, no day is a good
                 day to rob the bank, so return an empty list.

    Constraints:
    * 1 <= security.length <= 10^5
    * 0 <= security[i], time <= 10^5"""

    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:
        suffix = [0]*len(security)
        for i in range(len(security)-2, 0, -1):
            if security[i] <= security[i+1]: suffix[i] = suffix[i+1] + 1

        ans = []
        prefix = 0
        for i in range(len(security)-time):
            if i and security[i-1] >= security[i]: prefix += 1
            else: prefix = 0
            if prefix >= time and suffix[i] >= time: ans.append(i)
        return ans


    """2101. Detonate the Maximum Bombs (Medium)
    You are given a list of bombs. The range of a bomb is defined as the area
    where its effect can be felt. This area is in the shape of a circle with
    the center as the location of the bomb. The bombs are represented by a 0-
    indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi
    denote the X-coordinate and Y-coordinate of the location of the ith bomb,
    whereas ri denotes the radius of its range. You may choose to detonate a
    single bomb. When a bomb is detonated, it will detonate all bombs that lie
    in its range. These bombs will further detonate the bombs that lie in their
    ranges. Given the list of bombs, return the maximum number of bombs that
    can be detonated if you are allowed to detonate only one bomb.

    Example 1:
    Input: bombs = [[2,1,3],[6,1,4]]
    Output: 2
    Explanation: The above figure shows the positions and ranges of the 2 bombs.
                 If we detonate the left bomb, the right bomb will not be
                 affected. But if we detonate the right bomb, both bombs will
                 be detonated. So the maximum bombs that can be detonated is
                 max(1, 2) = 2.

    Example 2:
    Input: bombs = [[1,1,5],[10,10,5]]
    Output: 1
    Explanation: Detonating either bomb will not detonate the other bomb, so
                 the maximum number of bombs that can be detonated is 1.

    Example 3:
    Input: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
    Output: 5
    Explanation: The best bomb to detonate is bomb 0 because:
                 - Bomb 0 detonates bombs 1 and 2. The red circle denotes the
                   range of bomb 0.
                 - Bomb 2 detonates bomb 3. The blue circle denotes the range
                   of bomb 2.
                 - Bomb 3 detonates bomb 4. The green circle denotes the range
                   of bomb 3.
                 Thus all 5 bombs are detonated.

    Constraints:
    * 1 <= bombs.length <= 100
    * bombs[i].length == 3
    * 1 <= xi, yi, ri <= 10^5"""

    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        graph = [[] for _ in bombs]
        for i, (xi, yi, ri) in enumerate(bombs):
            for j, (xj, yj, rj) in enumerate(bombs):
                if i < j:
                    dist2 = (xi-xj)**2 + (yi-yj)**2
                    if dist2 <= ri**2: graph[i].append(j)
                    if dist2 <= rj**2: graph[j].append(i)

        def fn(x):
            """Return number of nodes connected to x."""
            ans = 1
            seen = {x}
            stack = [x]
            while stack:
                u = stack.pop()
                for v in graph[u]:
                    if v not in seen:
                        ans += 1
                        seen.add(v)
                        stack.append(v)
            return ans

        return max(fn(x) for x in range(len(bombs)))


    """2103. Rings and Rods (Easy)
    There are n rings and each ring is either red, green, or blue. The rings
    are distributed across ten rods labeled from 0 to 9. You are given a string
    rings of length 2n that describes the n rings that are placed onto the rods.
    Every two characters in rings forms a color-position pair that is used to
    describe each ring where:
    * The first character of the ith pair denotes the ith ring's color
      ('R', 'G', 'B').
    * The second character of the ith pair denotes the rod that the ith ring is
      placed on ('0' to '9').
    For example, "R3G2B1" describes n == 3 rings: a red ring placed onto the
    rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring
    placed onto the rod labeled 1. Return the number of rods that have all
    three colors of rings on them.

    Example 1:
    Input: rings = "B0B6G0R6R0R6G9"
    Output: 1
    Explanation:
    - The rod labeled 0 holds 3 rings with all colors: red, green, and blue.
    - The rod labeled 6 holds 3 rings, but it only has red and blue.
    - The rod labeled 9 holds only a green ring.
    Thus, the number of rods with all three colors is 1.

    Example 2:
    Input: rings = "B0R0G0R9R0B0G0"
    Output: 1
    Explanation:
    - The rod labeled 0 holds 6 rings with all colors: red, green, and blue.
    - The rod labeled 9 holds only a red ring.
    Thus, the number of rods with all three colors is 1.

    Example 3:
    Input: rings = "G4"
    Output: 0
    Explanation: Only one ring is given. Thus, no rods have all three colors.

    Constraints:
    * rings.length == 2 * n
    * 1 <= n <= 100
    * rings[i] where i is even is either 'R', 'G', or 'B' (0-indexed).
    * rings[i] where i is odd is a digit from '0' to '9' (0-indexed)."""

    def countPoints(self, rings: str) -> int:
        mp = dict(zip("RGB", range(3)))
        mask = [0]*10
        for i in range(0, len(rings), 2):
            mask[int(rings[i+1])] |= 1 << mp[rings[i]]
        return sum(x == 7 for x in mask)


    """2104. Sum of Subarray Ranges (Medium)
    You are given an integer array nums. The range of a subarray of nums is the
    difference between the largest and smallest element in the subarray. Return
    the sum of all subarray ranges of nums. A subarray is a contiguous non-
    empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,3]
    Output: 4
    Explanation: The 6 subarrays of nums are the following:
                 [1], range = largest - smallest = 1 - 1 = 0
                 [2], range = 2 - 2 = 0
                 [3], range = 3 - 3 = 0
                 [1,2], range = 2 - 1 = 1
                 [2,3], range = 3 - 2 = 1
                 [1,2,3], range = 3 - 1 = 2
                 So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.

    Example 2:
    Input: nums = [1,3,3]
    Output: 4
    Explanation: The 6 subarrays of nums are the following:
                 [1], range = largest - smallest = 1 - 1 = 0
                 [3], range = 3 - 3 = 0
                 [3], range = 3 - 3 = 0
                 [1,3], range = 3 - 1 = 2
                 [3,3], range = 3 - 3 = 0
                 [1,3,3], range = 3 - 1 = 2
                 So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.

    Example 3:
    Input: nums = [4,-2,-3,4,1]
    Output: 59
    Explanation: The sum of all subarray ranges of nums is 59.

    Constraints:
    * 1 <= nums.length <= 1000
    * -10^9 <= nums[i] <= 10^9"""

    def subArrayRanges(self, nums: List[int]) -> int:

        def fn(op):
            """Return min sum (if given gt) or max sum (if given lt)."""
            ans = 0
            stack = []
            for i in range(len(nums) + 1):
                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])):
                    mid = stack.pop()
                    ii = stack[-1] if stack else -1
                    ans += nums[mid] * (i - mid) * (mid - ii)
                stack.append(i)
            return ans

        return fn(lt) - fn(gt)


    """2105. Watering Plants II (Medium)
    Alice and Bob want to water n plants in their garden. The plants are
    arranged in a row and are labeled from 0 to n - 1 from left to right where
    the ith plant is located at x = i. Each plant needs a specific amount of
    water. Alice and Bob have a watering can each, initially full. They water
    the plants in the following way:
    * Alice waters the plants in order from left to right, starting from the
      0th plant. Bob waters the plants in order from right to left, starting
      from the (n - 1)th plant. They begin watering the plants simultaneously.
    * If one does not have enough water to completely water the current plant,
      he/she refills the watering can instantaneously.
    * It takes the same amount of time to water each plant regardless of how
      much water it needs.
    * One cannot refill the watering can early.
    * Each plant can be watered either by Alice or by Bob.
    * In case both Alice and Bob reach the same plant, the one with more water
      currently in his/her watering can should water this plant. If they have
      the same amount of water, then Alice should water this plant.
    Given a 0-indexed integer array plants of n integers, where plants[i] is
    the amount of water the ith plant needs, and two integers capacityA and
    capacityB representing the capacities of Alice's and Bob's watering cans
    respectively, return the number of times they have to refill to water all
    the plants.

    Example 1:
    Input: plants = [2,2,3,3], capacityA = 5, capacityB = 5
    Output: 1
    Explanation:
    - Initially, Alice and Bob have 5 units of water each in their watering
      cans.
    - Alice waters plant 0, Bob waters plant 3.
    - Alice and Bob now have 3 units and 2 units of water respectively.
    - Alice has enough water for plant 1, so she waters it. Bob does not have
      enough water for plant 2, so he refills his can then waters it.
    So, the total number of times they have to refill to water all the plants
    is 0 + 0 + 1 + 0 = 1.

    Example 2:
    Input: plants = [2,2,3,3], capacityA = 3, capacityB = 4
    Output: 2
    Explanation:
    - Initially, Alice and Bob have 3 units and 4 units of water in their
      watering cans respectively.
    - Alice waters plant 0, Bob waters plant 3.
    - Alice and Bob now have 1 unit of water each, and need to water plants 1
      and 2 respectively.
    - Since neither of them have enough water for their current plants, they
      refill their cans and then water the plants.
    So, the total number of times they have to refill to water all the plants
    is 0 + 1 + 1 + 0 = 2.

    Example 3:
    Input: plants = [5], capacityA = 10, capacityB = 8
    Output: 0
    Explanation:
    - There is only one plant.
    - Alice's watering can has 10 units of water, whereas Bob's can has 8 units.
      Since Alice has more water in her can, she waters this plant.
    So, the total number of times they have to refill is 0.

    Example 4:
    Input: plants = [1,2,4,4,5], capacityA = 6, capacityB = 5
    Output: 2
    Explanation:
    - Initially, Alice and Bob have 6 units and 5 units of water in their
      watering cans respectively.
    - Alice waters plant 0, Bob waters plant 4.
    - Alice and Bob now have 5 units and 0 units of water respectively.
    - Alice has enough water for plant 1, so she waters it. Bob does not have
      enough water for plant 3, so he refills his can then waters it.
    - Alice and Bob now have 3 units and 1 unit of water respectively.
    - Since Alice has more water, she waters plant 2. However, she does not
      have enough water to completely water this plant. Hence she refills her
      can then waters it.
    So, the total number of times they have to refill to water all the plants
    is 0 + 0 + 1 + 1 + 0 = 2.

    Example 5:
    Input: plants = [2,2,5,2,2], capacityA = 5, capacityB = 5
    Output: 1
    Explanation: Both Alice and Bob will reach the middle plant with the same
                 amount of water, so Alice will water it. She will have 1 unit
                 of water when she reaches it, so she will refill her can. This
                 is the only refill needed.

    Constraints:
    * n == plants.length
    * 1 <= n <= 10^5
    * 1 <= plants[i] <= 10^6
    * max(plants[i]) <= capacityA, capacityB <= 10^9"""

    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:
        ans = 0
        lo, hi = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while lo < hi:
            if canA < plants[lo]: ans += 1; canA = capacityA
            canA -= plants[lo]
            if canB < plants[hi]: ans += 1; canB = capacityB
            canB -= plants[hi]
            lo, hi = lo+1, hi-1
        if lo == hi and max(canA, canB) < plants[lo]: ans += 1
        return ans


    """2106. Maximum Fruits Harvested After at Most K Steps (Hard)
    Fruits are available at some positions on an infinite x-axis. You are given
    a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts
    amounti fruits at the position positioni. fruits is already sorted by
    positioni in ascending order, and each positioni is unique. You are also
    given an integer startPos and an integer k. Initially, you are at the
    position startPos. From any position, you can either walk to the left or
    right. It takes one step to move one unit on the x-axis, and you can walk
    at most k steps in total. For every position you reach, you harvest all the
    fruits at that position, and the fruits will disappear from that position.
    Return the maximum total number of fruits you can harvest.

    Example 1:
    Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
    Output: 9
    Explanation: The optimal way is to:
                 - Move right to position 6 and harvest 3 fruits
                 - Move right to position 8 and harvest 6 fruits
                 You moved 3 steps and harvested 3 + 6 = 9 fruits in total.

    Example 2:
    Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4
    Output: 14
    Explanation: You can move at most k = 4 steps, so you cannot reach position
                 0 nor 10. The optimal way is to:
                 - Harvest the 7 fruits at the starting position 5
                 - Move left to position 4 and harvest 1 fruit
                 - Move right to position 6 and harvest 2 fruits
                 - Move right to position 7 and harvest 4 fruits
                 You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14
                 fruits in total.

    Example 3:
    Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2
    Output: 0
    Explanation: You can move at most k = 2 steps and cannot reach any position
                 with fruits.

    Constraints:
    * 1 <= fruits.length <= 10^5
    * fruits[i].length == 2
    * 0 <= startPos, positioni <= 2 * 10^5
    * positioni-1 < positioni for any i > 0 (0-indexed)
    * 1 <= amounti <= 10^4
    * 0 <= k <= 2 * 10^5"""

    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        ans = rsm = ii = 0
        for i, (p, x) in enumerate(fruits):
            if p > startPos + k: break
            rsm += x
            if p <= startPos: fn = lambda ii: startPos - fruits[ii][0]
            else: fn = lambda ii: min(2*(p-startPos) + (startPos-fruits[ii][0]), (p-startPos) + 2*(startPos-fruits[ii][0]))
            while ii <= i and fn(ii) > k:
                rsm -= fruits[ii][1]
                ii += 1
            ans = max(ans, rsm)
        return ans


    """2107. Number of Unique Flavors After Sharing K Candies (Medium)
    You are given a 0-indexed integer array candies, where candies[i]
    represents the flavor of the ith candy. Your mom wants you to share these
    candies with your little sister by giving her k consecutive candies, but
    you want to keep as many flavors of candies as possible. Return the maximum
    number of unique flavors of candy you can keep after sharing with your
    sister.

    Example 1:
    Input: candies = [1,2,2,3,4,3], k = 3
    Output: 3
    Explanation: Give the candies in the range [1, 3] (inclusive) with flavors
                 [2,2,3]. You can eat candies with flavors [1,4,3]. There are 3
                 unique flavors, so return 3.

    Example 2:
    Input: candies = [2,2,2,2,3,3], k = 2
    Output: 2
    Explanation: Give the candies in the range [3, 4] (inclusive) with flavors
                 [2,3]. You can eat candies with flavors [2,2,2,3]. There are 2
                 unique flavors, so return 2. Note that you can also share the
                 candies with flavors [2,2] and eat the candies with flavors
                 [2,2,3,3].

    Example 3:
    Input: candies = [2,4,5], k = 0
    Output: 3
    Explanation: You do not have to give any candies. You can eat the candies
                 with flavors [2,4,5]. There are 3 unique flavors, so return 3.

    Constraints:
    * 1 <= candies.length <= 10^5
    * 1 <= candies[i] <= 10^5
    * 0 <= k <= candies.length"""

    def shareCandies(self, candies: List[int], k: int) -> int:
        ans = 0
        freq = Counter(candies)
        for i, x in enumerate(candies):
            freq[x] -= 1
            if freq[x] == 0: freq.pop(x)
            if i >= k: freq[candies[i-k]] += 1
            if i >= k-1: ans = max(ans, len(freq))
        return ans


    """2108. Find First Palindromic String in the Array (Easy)
    Given an array of strings words, return the first palindromic string in the
    array. If there is no such string, return an empty string "". A string is
    palindromic if it reads the same forward and backward.

    Example 1:
    Input: words = ["abc","car","ada","racecar","cool"]
    Output: "ada"
    Explanation: The first string that is palindromic is "ada". Note that
                 "racecar" is also palindromic, but it is not the first.

    Example 2:
    Input: words = ["notapalindrome","racecar"]
    Output: "racecar"
    Explanation: The first and only string that is palindromic is "racecar".

    Example 3:
    Input: words = ["def","ghi"]
    Output: ""
    Explanation: There are no palindromic strings, so the empty string is returned.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consists only of lowercase English letters."""

    def firstPalindrome(self, words: List[str]) -> str:
        return next((word for word in words if word == word[::-1]), "")


    """2109. Adding Spaces to a String (Medium)
    You are given a 0-indexed string s and a 0-indexed integer array spaces
    that describes the indices in the original string where spaces will be
    added. Each space should be inserted before the character at the given
    index. For example, given s = "EnjoyYourCoffee" and spaces = [5, 9], we
    place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively.
    Thus, we obtain "Enjoy Your Coffee". Return the modified string after the
    spaces have been added.

    Example 1:
    Input: s = "LeetcodeHelpsMeLearn", spaces = [8,13,15]
    Output: "Leetcode Helps Me Learn"
    Explanation: The indices 8, 13, and 15 correspond to the underlined
                 characters in "LeetcodeHelpsMeLearn". We then place spaces
                 before those characters.

    Example 2:
    Input: s = "icodeinpython", spaces = [1,5,7,9]
    Output: "i code in py thon"
    Explanation: The indices 1, 5, 7, and 9 correspond to the underlined
                 characters in "icodeinpython". We then place spaces before
                 those characters.

    Example 3:
    Input: s = "spacing", spaces = [0,1,2,3,4,5,6]
    Output: " s p a c i n g"
    Explanation: We are also able to place spaces before the first character
                 of the string.

    Constraints:
    * 1 <= s.length <= 3 * 10^5
    * s consists only of lowercase and uppercase English letters.
    * 1 <= spaces.length <= 3 * 10^5
    * 0 <= spaces[i] <= s.length - 1
    * All the values of spaces are strictly increasing."""

    def addSpaces(self, s: str, spaces: List[int]) -> str:
        ans = []
        for i in reversed(range(len(s))):
            ans.append(s[i])
            if spaces and spaces[-1] == i:
                ans.append(' ')
                spaces.pop()
        return "".join(reversed(ans))


    """2110. Number of Smooth Descent Periods of a Stock (Medium)
    You are given an integer array prices representing the daily price history
    of a stock, where prices[i] is the stock price on the ith day. A smooth
    descent period of a stock consists of one or more contiguous days such that
    the price on each day is lower than the price on the preceding day by
    exactly 1. The first day of the period is exempted from this rule. Return
    the number of smooth descent periods.

    Example 1:
    Input: prices = [3,2,1,4]
    Output: 7
    Explanation: There are 7 smooth descent periods: [3], [2], [1], [4], [3,2],
                 [2,1], and [3,2,1]. Note that a period with one day is a
                 smooth descent period by the definition.

    Example 2:
    Input: prices = [8,6,7,7]
    Output: 4
    Explanation: There are 4 smooth descent periods: [8], [6], [7], and [7].
                 Note that [8,6] is not a smooth descent period as 8 - 6 ≠ 1.

    Example 3:
    Input: prices = [1]
    Output: 1
    Explanation: There is 1 smooth descent period: [1]

    Constraints:
    * 1 <= prices.length <= 10^5
    * 1 <= prices[i] <= 10^5"""

    def getDescentPeriods(self, prices: List[int]) -> int:
        ans = 0
        for i, x in enumerate(prices):
            if i == 0 or prices[i-1] != x + 1: cnt = 0
            cnt += 1
            ans += cnt
        return ans


    """2111. Minimum Operations to Make the Array K-Increasing (Hard)
    You are given a 0-indexed array arr consisting of n positive integers, and
    a positive integer k. The array arr is called K-increasing if
    arr[i-k] <= arr[i] holds for every index i, where k <= i <= n-1.
    * For example, arr = [4, 1, 5, 2, 6, 2] is K-increasing for k = 2 because:
      o arr[0] <= arr[2] (4 <= 5)
      o arr[1] <= arr[3] (1 <= 2)
      o arr[2] <= arr[4] (5 <= 6)
      o arr[3] <= arr[5] (2 <= 2)
    * However, the same arr is not K-increasing for k = 1 (because
      arr[0] > arr[1]) or k = 3 (because arr[0] > arr[3]).
    In one operation, you can choose an index i and change arr[i] into any
    positive integer. Return the minimum number of operations required to make
    the array K-increasing for the given k.

    Example 1:
    Input: arr = [5,4,3,2,1], k = 1
    Output: 4
    Explanation: For k = 1, the resultant array has to be non-decreasing. Some
                 of the K-increasing arrays that can be formed are [5,6,7,8,9],
                 [1,1,1,1,1], [2,2,3,4,4]. All of them require 4 operations. It
                 is suboptimal to change the array to, for example, [6,7,8,9,10]
                 because it would take 5 operations. It can be shown that we
                 cannot make the array K-increasing in less than 4 operations.

    Example 2:
    Input: arr = [4,1,5,2,6,2], k = 2
    Output: 0
    Explanation: This is the same example as the one in the problem description.
                 Here, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i].
                 Since the given array is already K-increasing, we do not need
                 to perform any operations.

    Example 3:
    Input: arr = [4,1,5,2,6,2], k = 3
    Output: 2
    Explanation: Indices 3 and 5 are the only ones not satisfying
                 arr[i-3] <= arr[i] for 3 <= i <= 5. One of the ways we can
                 make the array K-increasing is by changing arr[3] to 4 and
                 arr[5] to 5. The array will now be [4,1,5,4,6,5]. Note that
                 there can be other ways to make the array K-increasing, but
                 none of them require less than 2 operations.

    Constraints:
    * 1 <= arr.length <= 10^5
    * 1 <= arr[i], k <= arr.length"""

    def kIncreasing(self, arr: List[int], k: int) -> int:
        ans = 0
        for _ in range(k):
            vals = []
            for i in range(_, len(arr), k):
                if not vals or vals[-1] <= arr[i]: vals.append(arr[i])
                else: vals[bisect_right(vals, arr[i])] = arr[i]
            ans += len(vals)
        return len(arr) - ans


    """2113. Elements in Array After Removing and Replacing Elements (Medium)
    You are given a 0-indexed integer array nums. Initially on minute 0, the
    array is unchanged. Every minute, the leftmost element in nums is removed
    until no elements remain. Then, every minute, one element is appended to
    the end of nums, in the order they were removed in, until the original
    array is restored. This process repeats indefinitely.
    * For example, the array [0,1,2] would change as follows:
      [0,1,2] → [1,2] → [2] → [] → [0] → [0,1] → [0,1,2] → [1,2] → [2] → [] →
      [0] → [0,1] → [0,1,2] → ...
    You are also given a 2D integer array queries of size n where
    queries[j] = [timej, indexj]. The answer to the jth query is:
    * nums[indexj] if indexj < nums.length at minute timej
    * -1 if indexj >= nums.length at minute timej
    Return an integer array ans of size n where ans[j] is the answer to the jth
    query.

    Example 1:
    Input: nums = [0,1,2], queries = [[0,2],[2,0],[3,2],[5,0]]
    Output: [2,2,-1,0]
    Explanation: Minute 0: [0,1,2] - All elements are in the nums.
                 Minute 1: [1,2]   - The leftmost element, 0, is removed.
                 Minute 2: [2]     - The leftmost element, 1, is removed.
                 Minute 3: []      - The leftmost element, 2, is removed.
                 Minute 4: [0]     - 0 is added to the end of nums.
                 Minute 5: [0,1]   - 1 is added to the end of nums.
                 At minute 0, nums[2] is 2.
                 At minute 2, nums[0] is 2.
                 At minute 3, nums[2] does not exist.
                 At minute 5, nums[0] is 0.

    Example 2:
    Input: nums = [2], queries = [[0,0],[1,0],[2,0],[3,0]]
    Output: [2,-1,2,-1]
    Explanation: Minute 0: [2] - All elements are in the nums.
                 Minute 1: []  - The leftmost element, 2, is removed.
                 Minute 2: [2] - 2 is added to the end of nums.
                 Minute 3: []  - The leftmost element, 2, is removed.
                 At minute 0, nums[0] is 2.
                 At minute 1, nums[0] does not exist.
                 At minute 2, nums[0] is 2.
                 At minute 3, nums[0] does not exist.

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 100
    * n == queries.length
    * 1 <= n <= 10^5
    * queries[j].length == 2
    * 0 <= timej <= 10^5
    * 0 <= indexj < nums.length"""

    def elementInNums(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        ans = []
        for t, i in queries:
            t %= 2*len(nums)
            if t < len(nums)-i: ans.append(nums[i+t])
            elif t <= len(nums)+i: ans.append(-1)
            else: ans.append(nums[i])
        return ans


    """2114. Maximum Number of Words Found in Sentences (Easy)
    A sentence is a list of words that are separated by a single space with no
    leading or trailing spaces. You are given an array of strings sentences,
    where each sentences[i] represents a single sentence. Return the maximum
    number of words that appear in a single sentence.

    Example 1:
    Input: sentences = ["alice and bob love leetcode", "i think so too", "this is great thanks very much"]
    Output: 6
    Explanation:
    - The first sentence, "alice and bob love leetcode", has 5 words in total.
    - The second sentence, "i think so too", has 4 words in total.
    - The third sentence, "this is great thanks very much", has 6 words in total.
    Thus, the maximum number of words in a single sentence comes from the third
    sentence, which has 6 words.

    Example 2:
    Input: sentences = ["please wait", "continue to fight", "continue to win"]
    Output: 3
    Explanation: It is possible that multiple sentences contain the same number
                 of words. In this example, the second and third sentences
                 (underlined) have the same number of words.

    Constraints:
    * 1 <= sentences.length <= 100
    * 1 <= sentences[i].length <= 100
    * sentences[i] consists only of lowercase English letters and ' ' only.
    * sentences[i] does not have leading or trailing spaces.
    * All the words in sentences[i] are separated by a single space."""

    def mostWordsFound(self, sentences: List[str]) -> int:
        return max(len(x.split()) for x in sentences)


    """2115. Find All Possible Recipes from Given Supplies (Medium)
    You have information about n different recipes. You are given a string
    array recipes and a 2D string array ingredients. The ith recipe has the
    name recipes[i], and you can create it if you have all the needed
    ingredients from ingredients[i]. Ingredients to a recipe may need to be
    created from other recipes, i.e., ingredients[i] may contain a string that
    is in recipes. You are also given a string array supplies containing all
    the ingredients that you initially have, and you have an infinite supply of
    all of them. Return a list of all the recipes that you can create. You may
    return the answer in any order. Note that two recipes may contain each
    other in their ingredients.

    Example 1:
    Input: recipes = ["bread"], ingredients = [["yeast","flour"]], supplies = ["yeast","flour","corn"]
    Output: ["bread"]
    Explanation: We can create "bread" since we have the ingredients "yeast"
                 and "flour".

    Example 2:
    Input: recipes = ["bread","sandwich"], ingredients = [["yeast","flour"],["bread","meat"]], supplies = ["yeast","flour","meat"]
    Output: ["bread","sandwich"]
    Explanation: We can create "bread" since we have the ingredients "yeast"
                 and "flour". We can create "sandwich" since we have the
                 ingredient "meat" and can create the ingredient "bread".

    Example 3:
    Input: recipes = ["bread","sandwich","burger"], ingredients = [["yeast","flour"],["bread","meat"],["sandwich","meat","bread"]], supplies = ["yeast","flour","meat"]
    Output: ["bread","sandwich","burger"]
    Explanation: We can create "bread" since we have the ingredients "yeast"
                 and "flour". We can create "sandwich" since we have the
                 ingredient "meat" and can create the ingredient "bread". We
                 can create "burger" since we have the ingredient "meat" and
                 can create the ingredients "bread" and "sandwich".

    Constraints:
    * n == recipes.length == ingredients.length
    * 1 <= n <= 100
    * 1 <= ingredients[i].length, supplies.length <= 100
    * 1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10
    * recipes[i], ingredients[i][j], and supplies[k] consist only of lowercase
      English letters.
    * All the values of recipes and supplies combined are unique.
    * Each ingredients[i] does not contain any duplicate values."""

    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        indeg = defaultdict(int)
        graph = defaultdict(list)
        for r, ing in zip(recipes, ingredients):
            indeg[r] = len(ing)
            for i in ing: graph[i].append(r)

        ans = []
        queue = deque(supplies)
        recipes = set(recipes)
        while queue:
            x = queue.popleft()
            if x in recipes: ans.append(x)
            for xx in graph[x]:
                indeg[xx] -= 1
                if indeg[xx] == 0: queue.append(xx)
        return ans


    """2116. Check if a Parentheses String Can Be Valid (Medium)
    A parentheses string is a non-empty string consisting only of '(' and ')'.
    It is valid if any of the following conditions is true:
    * It is ().
    * It can be written as AB (A concatenated with B), where A and B are valid
      parentheses strings.
    * It can be written as (A), where A is a valid parentheses string.
    You are given a parentheses string s and a string locked, both of length n.
    locked is a binary string consisting only of '0's and '1's. For each index
    i of locked,
    * If locked[i] is '1', you cannot change s[i].
    * But if locked[i] is '0', you can change s[i] to either '(' or ')'.
    Return true if you can make s a valid parentheses string. Otherwise, return
    false.

    Example 1:
    Input: s = "))()))", locked = "010100"
    Output: true
    Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1]
                 or s[3]. We change s[0] and s[4] to '(' while leaving s[2] and
                 s[5] unchanged to make s valid.

    Example 2:
    Input: s = "()()", locked = "0000"
    Output: true
    Explanation: We do not need to make any changes because s is already valid.

    Example 3:
    Input: s = ")", locked = "0"
    Output: false
    Explanation: locked permits us to change s[0]. Changing s[0] to either '('
                 or ')' will not make s valid.

    Constraints:
    * n == s.length == locked.length
    * 1 <= n <= 10^5
    * s[i] is either '(' or ')'.
    * locked[i] is either '0' or '1'."""

    def canBeValid(self, s: str, locked: str) -> bool:
        if len(s)&1: return False
        bal = 0
        for ch, lock in zip(s, locked):
            if lock == '0' or ch == '(': bal += 1
            elif ch == ')': bal -= 1
            if bal < 0: return False
        bal = 0
        for ch, lock in zip(reversed(s), reversed(locked)):
            if lock == '0' or ch == ')': bal += 1
            elif ch == '(': bal -= 1
            if bal < 0: return False
        return True


    """2117. Abbreviating the Product of a Range (Hard)
    You are given two positive integers left and right with left <= right.
    Calculate the product of all integers in the inclusive range [left, right].
    Since the product may be very large, you will abbreviate it following these
    steps:
    * Count all trailing zeros in the product and remove them. Let us denote
      this count as C.
      For example, there are 3 trailing zeros in 1000, and there are 0 trailing
      zeros in 546.
    * Denote the remaining number of digits in the product as d. If d > 10,
      then express the product as <pre>...<suf> where <pre> denotes the first 5
      digits of the product, and <suf> denotes the last 5 digits of the product
      after removing all trailing zeros. If d <= 10, we keep it unchanged.
      For example, we express 1234567654321 as 12345...54321, but 1234567 is
      represented as 1234567.
    * Finally, represent the product as a string "<pre>...<suf>eC".
      For example, 12345678987600000 will be represented as "12345...89876e5".
    Return a string denoting the abbreviated product of all integers in the
    inclusive range [left, right].

    Example 1:
    Input: left = 1, right = 4
    Output: "24e0"
    Explanation: The product is 1 × 2 × 3 × 4 = 24. There are no trailing zeros,
                 so 24 remains the same. The abbreviation will end with "e0".
                 Since the number of digits is 2, which is less than 10, we do
                 not have to abbreviate it further. Thus, the final
                 representation is "24e0".

    Example 2:
    Input: left = 2, right = 11
    Output: "399168e2"
    Explanation: The product is 39916800. There are 2 trailing zeros, which we
                 remove to get 399168. The abbreviation will end with "e2". The
                 number of digits after removing the trailing zeros is 6, so we
                 do not abbreviate it further. Hence, the abbreviated product
                 is "399168e2".

    Example 3:
    Input: left = 999998, right = 1000000
    Output: "99999...00002e6"
    Explanation: The above diagram shows how we abbreviate the product to
                 "99999...00002e6".
                 - It has 6 trailing zeros. The abbreviation will end with "e6".
                 - The first 5 digits are 99999.
                 - The last 5 digits after removing trailing zeros is 00002.

    Constraints: 1 <= left <= right <= 10^6"""

    def abbreviateProduct(self, left: int, right: int) -> str:
        ans = prefix = suffix = 1
        trailing = 0
        flag = False
        for x in range(left, right+1):
            if not flag:
                ans *= x
                while ans % 10 == 0: ans //= 10
                if ans >= 1e10: flag = True
            prefix *= x
            suffix *= x
            while prefix >= 1e12: prefix //= 10
            while suffix % 10 == 0:
                trailing += 1
                suffix //= 10
            if suffix >= 1e10: suffix %= 10_000_000_000
        while prefix >= 100000: prefix //= 10
        suffix %= 100000
        if flag: return f"{prefix:<05}...{suffix:>05}e{trailing}"
        return f"{ans}e{trailing}"


    """2119. A Number After a Double Reversal (Easy)
    Reversing an integer means to reverse all its digits. For example,
    reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros
    are not retained. Given an integer num, reverse num to get reversed1, then
    reverse reversed1 to get reversed2. Return true if reversed2 equals num.
    Otherwise return false.

    Example 1:
    Input: num = 526
    Output: true
    Explanation: Reverse num to get 625, then reverse 625 to get 526, which
                 equals num.

    Example 2:
    Input: num = 1800
    Output: false
    Explanation: Reverse num to get 81, then reverse 81 to get 18, which does
                 not equal num.

    Example 3:
    Input: num = 0
    Output: true
    Explanation: Reverse num to get 0, then reverse 0 to get 0, which equals
                 num.

    Constraints: 0 <= num <= 10^6"""

    def isSameAfterReversals(self, num: int) -> bool:
        return num == 0 or num % 10


    """2120. Execution of All Suffix Instructions Staying in a Grid (Medium)
    There is an n x n grid, with the top-left cell at (0, 0) and the bottom-
    right cell at (n - 1, n - 1). You are given the integer n and an integer
    array startPos where startPos = [startrow, startcol] indicates that a robot
    is initially at cell (startrow, startcol). You are also given a 0-indexed
    string s of length m where s[i] is the ith instruction for the robot:
    'L' (move left), 'R' (move right), 'U' (move up), and 'D' (move down).
    The robot can begin executing from any ith instruction in s. It executes
    the instructions one by one towards the end of s but it stops if either of
    these conditions is met:
    * The next instruction will move the robot off the grid.
    * There are no more instructions left to execute.
    Return an array answer of length m where answer[i] is the number of
    instructions the robot can execute if the robot begins executing from the
    ith instruction in s.

    Example 1:
    Input: n = 3, startPos = [0,1], s = "RRDDLU"
    Output: [1,5,4,3,1,0]
    Explanation: Starting from startPos and beginning execution from the ith instruction:
    - 0th: "RRDDLU". Only one instruction "R" can be executed before it moves off the grid.
    - 1st:  "RDDLU". All five instructions can be executed while it stays in the grid and ends at (1, 1).
    - 2nd:   "DDLU". All four instructions can be executed while it stays in the grid and ends at (1, 0).
    - 3rd:    "DLU". All three instructions can be executed while it stays in the grid and ends at (0, 0).
    - 4th:     "LU". Only one instruction "L" can be executed before it moves off the grid.
    - 5th:      "U". If moving up, it would move off the grid.

    Example 2:
    Input: n = 2, startPos = [1,1], s = "LURD"
    Output: [4,1,0,0]
    Explanation: - 0th: "LURD".
                 - 1st:  "URD".
                 - 2nd:   "RD".
                 - 3rd:    "D".

    Example 3:
    Input: n = 1, startPos = [0,0], s = "LRUD"
    Output: [0,0,0,0]
    Explanation: No matter which instruction the robot begins execution from,
                 it would move off the grid.

    Constraints:
    * m == s.length
    * 1 <= n, m <= 500
    * startPos.length == 2
    * 0 <= startrow, startcol < n
    * s consists of 'L', 'R', 'U', and 'D'."""

    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:
        ans = []
        for k in range(len(s)):
            i, j = startPos
            val = 0
            for kk in range(k, len(s)):
                if s[kk] == 'L': j -= 1
                elif s[kk] == 'R': j += 1
                elif s[kk] == 'U': i -= 1
                else: i += 1
                if 0 <= i < n and 0 <= j < n: val += 1
                else: break
            ans.append(val)
        return ans


    """2121. Intervals Between Identical Elements (Medium)
    You are given a 0-indexed array of n integers arr. The interval between two
    elements in arr is defined as the absolute difference between their indices.
    More formally, the interval between arr[i] and arr[j] is |i - j|. Return an
    array intervals of length n where intervals[i] is the sum of intervals
    between arr[i] and each element in arr with the same value as arr[i]. Note:
    |x| is the absolute value of x.

    Example 1:
    Input: arr = [2,1,3,1,2,3,3]
    Output: [4,2,7,2,4,4,5]
    Explanation:
    - Index 0: Another 2 is found at index 4. |0 - 4| = 4
    - Index 1: Another 1 is found at index 3. |1 - 3| = 2
    - Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7
    - Index 3: Another 1 is found at index 1. |3 - 1| = 2
    - Index 4: Another 2 is found at index 0. |4 - 0| = 4
    - Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4
    - Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5

    Example 2:
    Input: arr = [10,5,10,10]
    Output: [5,0,3,4]
    Explanation:
    - Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5
    - Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.
    - Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3
    - Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4

    Constraints:
    * n == arr.length
    * 1 <= n <= 10^5
    * 1 <= arr[i] <= 10^5"""

    def getDistances(self, arr: List[int]) -> List[int]:
        loc = defaultdict(list)
        for i, x in enumerate(arr): loc[x].append(i)

        for k, idx in loc.items():
            prefix = list(accumulate(idx, initial=0))
            vals = []
            for i, x in enumerate(idx):
                vals.append(prefix[-1] - prefix[i] - prefix[i+1] - (len(idx)-2*i-1)*x)
            loc[k] = deque(vals)

        return [loc[x].popleft() for x in arr]


    """2122. Recover the Original Array (Hard)
    Alice had a 0-indexed array arr consisting of n positive integers. She
    chose an arbitrary positive integer k and created two new 0-indexed integer
    arrays lower and higher in the following manner:
    * lower[i] = arr[i] - k, for every index i where 0 <= i < n
    * higher[i] = arr[i] + k, for every index i where 0 <= i < n
    Unfortunately, Alice lost all three arrays. However, she remembers the
    integers that were present in the arrays lower and higher, but not the
    array each integer belonged to. Help Alice and recover the original array.
    Given an array nums consisting of 2n integers, where exactly n of the
    integers were present in lower and the remaining in higher, return the
    original array arr. In case the answer is not unique, return any valid
    array. Note: The test cases are generated such that there exists at least
    one valid array arr.

    Example 1:
    Input: nums = [2,10,6,4,8,12]
    Output: [3,7,11]
    Explanation: If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and
                 higher = [4,8,12]. Combining lower and higher gives us
                 [2,6,10,4,8,12], which is a permutation of nums. Another valid
                 possibility is that arr = [5,7,9] and k = 3. In that case,
                 lower = [2,4,6] and higher = [8,10,12].

    Example 2:
    Input: nums = [1,1,3,3]
    Output: [2,2]
    Explanation: If arr = [2,2] and k = 1, we get lower = [1,1] and
                 higher = [3,3]. Combining lower and higher gives us [1,1,3,3],
                 which is equal to nums. Note that arr cannot be [1,3] because
                 in that case, the only possible way to obtain [1,1,3,3] is
                 with k = 0. This is invalid since k must be positive.

    Example 3:
    Input: nums = [5,435]
    Output: [220]
    Explanation: The only possible combination is arr = [220] and k = 215.
                 Using them, we get lower = [5] and higher = [435].

    Constraints:
    * 2 * n == nums.length
    * 1 <= n <= 1000
    * 1 <= nums[i] <= 10^9
    * The test cases are generated such that there exists at least one valid
      array arr."""

    def recoverArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        for i in range(1, len(nums)):
            diff = nums[i] - nums[0]
            if diff > 0 and diff&1 == 0:
                ans = []
                freq = Counter(nums)
                for k, v in freq.items():
                    if v:
                        if freq[k+diff] < v: break
                        ans.extend([k+diff//2]*v)
                        freq[k+diff] -= v
                else: return ans


    """2123. Minimum Operations to Remove Adjacent Ones in Matrix (Hard)
    You are given a 0-indexed binary matrix grid. In one operation, you can
    flip any 1 in grid to be 0. A binary matrix is well-isolated if there is no
    1 in the matrix that is 4-directionally connected (i.e., horizontal and
    vertical) to another 1. Return the minimum number of operations to make
    grid well-isolated.

    Example 1:
    Input: grid = [[1,1,0],[0,1,1],[1,1,1]]
    Output: 3
    Explanation: Use 3 operations to change grid[0][1], grid[1][2], and
                 grid[2][1] to 0. After, no more 1's are 4-directionally
                 connected and grid is well-isolated.

    Example 2:
    Input: grid = [[0,0,0],[0,0,0],[0,0,0]]
    Output: 0
    Explanation: There are no 1's in grid and it is well-isolated. No
                 operations were done so return 0.

    Example 3:
    Input: grid = [[0,1],[1,0]]
    Output: 0
    Explanation: None of the 1's are 4-directionally connected and grid is
                 well-isolated. No operations were done so return 0.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 300
    * grid[i][j] is either 0 or 1."""

    def minimumOperations(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        match = defaultdict(lambda : None)

        def dfs(i, j, seen):
            """Return True if an augmenting path is found via Hungarian algo."""
            for ii, jj in (i+1, j), (i-1, j), (i, j+1), (i, j-1):
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] and (ii, jj) not in seen:
                    seen.add((ii, jj))
                    if not match[ii, jj] or dfs(*match[ii, jj], seen):
                        match[i, j] = (ii, jj)
                        match[ii, jj] = (i, j)
                        return True
            return False

        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] and (i+j)&1 and dfs(i, j, {(i, j)}): ans += 1
        return ans


    """2124. Check if All A's Appears Before All B's (Easy)
    Given a string s consisting of only the characters 'a' and 'b', return true
    if every 'a' appears before every 'b' in the string. Otherwise, return
    false.

    Example 1:
    Input: s = "aaabbb"
    Output: true
    Explanation: The 'a's are at indices 0, 1, and 2, while the 'b's are at
                 indices 3, 4, and 5. Hence, every 'a' appears before every 'b'
                 and we return true.

    Example 2:
    Input: s = "abab"
    Output: false
    Explanation: There is an 'a' at index 2 and a 'b' at index 1. Hence, not
                 every 'a' appears before every 'b' and we return false.

    Example 3:
    Input: s = "bbb"
    Output: true
    Explanation: There are no 'a's, hence, every 'a' appears before every 'b'
                 and we return true.

    Constraints:
    * 1 <= s.length <= 100
    * s[i] is either 'a' or 'b'."""

    def checkString(self, s: str) -> bool:
        return "ba" not in s


    """2125. Number of Laser Beams in a Bank (Medium)
    Anti-theft security devices are activated inside a bank. You are given a 0-
    indexed binary string array bank representing the floor plan of the bank,
    which is an m x n 2D matrix. bank[i] represents the ith row, consisting of
    '0's and '1's. '0' means the cell is empty, while'1' means the cell has a
    security device. There is one laser beam between any two security devices
    if both conditions are met:
    * The two devices are located on two different rows: r1 and r2, where
      r1 < r2.
    * For each row i where r1 < i < r2, there are no security devices in the
      ith row.
    Laser beams are independent, i.e., one beam does not interfere nor join
    with another. Return the total number of laser beams in the bank.

    Example 1:
    Input: bank = ["011001","000000","010100","001000"]
    Output: 8
    Explanation: Between each of the following device pairs, there is one beam.
                 In total, there are 8 beams:
                  * bank[0][1] -- bank[2][1]
                  * bank[0][1] -- bank[2][3]
                  * bank[0][2] -- bank[2][1]
                  * bank[0][2] -- bank[2][3]
                  * bank[0][5] -- bank[2][1]
                  * bank[0][5] -- bank[2][3]
                  * bank[2][1] -- bank[3][2]
                  * bank[2][3] -- bank[3][2]
                 Note that there is no beam between any device on the 0th row
                 with any on the 3rd row. This is because the 2nd row contains
                 security devices, which breaks the second condition.

    Example 2:
    Input: bank = ["000","111","000"]
    Output: 0
    Explanation: There does not exist two devices located on two different rows.

    Constraints:
    * m == bank.length
    * n == bank[i].length
    * 1 <= m, n <= 500
    * bank[i][j] is either '0' or '1'."""

    def numberOfBeams(self, bank: List[str]) -> int:
        ans = prev = 0
        for row in bank:
            curr = row.count('1')
            if curr:
                ans += prev * curr
                prev = curr
        return ans


    """2126. Destroying Asteroids (Medium)
    You are given an integer mass, which represents the original mass of a
    planet. You are further given an integer array asteroids, where asteroids[i]
    is the mass of the ith asteroid. You can arrange for the planet to collide
    with the asteroids in any arbitrary order. If the mass of the planet is
    greater than or equal to the mass of the asteroid, the asteroid is
    destroyed and the planet gains the mass of the asteroid. Otherwise, the
    planet is destroyed. Return true if all asteroids can be destroyed.
    Otherwise, return false.

    Example 1:
    Input: mass = 10, asteroids = [3,9,19,5,21]
    Output: true
    Explanation: One way to order the asteroids is [9,19,5,3,21]:
    - The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19
    - The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38
    - The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43
    - The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46
    - The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67
    All asteroids are destroyed.

    Example 2:
    Input: mass = 5, asteroids = [4,9,23,4]
    Output: false
    Explanation: The planet cannot ever gain enough mass to destroy the
                 asteroid with a mass of 23. After the planet destroys the
                 other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22.
                 This is less than 23, so a collision would not destroy the
                 last asteroid.

    Constraints:
    * 1 <= mass <= 10^5
    * 1 <= asteroids.length <= 10^5
    * 1 <= asteroids[i] <= 10^5"""

    def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:
        for x in sorted(asteroids):
            if mass < x: return False
            mass += x
        return True


    """2127. Maximum Employees to Be Invited to a Meeting (Hard)
    A company is organizing a meeting and has a list of n employees, waiting
    to be invited. They have arranged for a large circular table, capable of
    seating any number of employees. The employees are numbered from 0 to n - 1.
    Each employee has a favorite person and they will attend the meeting only
    if they can sit next to their favorite person at the table. The favorite
    person of an employee is not themself. Given a 0-indexed integer array
    favorite, where favorite[i] denotes the favorite person of the ith employee,
    return the maximum number of employees that can be invited to the meeting.

    Example 1:
    Input: favorite = [2,2,1,2]
    Output: 3
    Explanation: The above figure shows how the company can invite employees 0,
                 1, and 2, and seat them at the round table. All employees
                 cannot be invited because employee 2 cannot sit beside
                 employees 0, 1, and 3, simultaneously. Note that the company
                 can also invite employees 1, 2, and 3, and give them their
                 desired seats. The maximum number of employees that can be
                 invited to the meeting is 3.

    Example 2:
    Input: favorite = [1,2,0]
    Output: 3
    Explanation: Each employee is the favorite person of at least one other
                 employee, and the only way the company can invite them is if
                 they invite every employee. The seating arrangement will be
                 the same as that in the figure given in example 1:
                 - Employee 0 will sit between employees 2 and 1.
                 - Employee 1 will sit between employees 0 and 2.
                 - Employee 2 will sit between employees 1 and 0.
                 The maximum number of employees that can be invited to the
                 meeting is 3.

    Example 3:
    Input: favorite = [3,0,1,4,1]
    Output: 4
    Explanation: The above figure shows how the company will invite employees
                 0, 1, 3, and 4, and seat them at the round table. Employee 2
                 cannot be invited because the two spots next to their favorite
                 employee 0 are taken. So the company leaves them out of the
                 meeting. The maximum number of employees that can be invited
                 to the meeting is 4.

    Constraints:
    * n == favorite.length
    * 2 <= n <= 10^5
    * 0 <= favorite[i] <= n - 1
    * favorite[i] != i"""

    def maximumInvitations(self, favorite: List[int]) -> int:
        n = len(favorite)
        graph = [[] for _ in range(n)]
        for i, x in enumerate(favorite): graph[x].append(i)

        def bfs(x, seen):
            """Return longest arm of x."""
            ans = 0
            queue = deque([x])
            while queue:
                for _ in range(len(queue)):
                    u = queue.popleft()
                    for v in graph[u]:
                        if v not in seen:
                            seen.add(v)
                            queue.append(v)
                ans += 1
            return ans

        ans = 0
        seen = [False]*n
        for i, x in enumerate(favorite):
            if favorite[x] == i and not seen[i]:
                seen[i] = seen[x] = True
                ans += bfs(i, {i, x}) + bfs(x, {i, x})

        dp = [0]*n
        for i, x in enumerate(favorite):
            if dp[i] == 0:
                ii, val = i, 0
                memo = {}
                while ii not in memo:
                    if dp[ii]:
                        cycle = dp[ii]
                        break
                    memo[ii] = val
                    val += 1
                    ii = favorite[ii]
                else: cycle = val - memo[ii]
                for k in memo: dp[k] = cycle
        return max(ans, max(dp))


    """2128. Remove All Ones With Row and Column Flips (Medium)
    You are given an m x n binary matrix grid. In one operation, you can choose
    any row or column and flip each value in that row or column (i.e., changing
    all 0's to 1's, and all 1's to 0's). Return true if it is possible to
    remove all 1's from grid using any number of operations or false otherwise.

    Example 1:
    Input: grid = [[0,1,0],[1,0,1],[0,1,0]]
    Output: true
    Explanation: One possible way to remove all 1's from grid is to:
                 - Flip the middle row
                 - Flip the middle column

    Example 2:
    Input: grid = [[1,1,0],[0,0,0],[0,0,0]]
    Output: false
    Explanation: It is impossible to remove all 1's from grid.

    Example 3:
    Input: grid = [[0]]
    Output: true
    Explanation: There are no 1's in grid.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 300
    * grid[i][j] is either 0 or 1."""

    def removeOnes(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        flip = [x^1 for x in grid[0]]
        for i in range(1, m):
            if grid[i] != grid[0] and grid[i] != flip: return False
        return True


    """2133. Check if Every Row and Column Contains All Numbers (Easy)
    An n x n matrix is valid if every row and every column contains all the
    integers from 1 to n (inclusive). Given an n x n integer matrix matrix,
    return true if the matrix is valid. Otherwise, return false.

    Example 1:
    Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]
    Output: true
    Explanation: In this case, n = 3, and every row and column contains the
                 numbers 1, 2, and 3. Hence, we return true.

    Example 2:
    Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]
    Output: false
    Explanation: In this case, n = 3, but the first row and the first column do
                 not contain the numbers 2 or 3. Hence, we return false.

    Constraints:
    * n == matrix.length == matrix[i].length
    * 1 <= n <= 100
    * 1 <= matrix[i][j] <= n"""

    def checkValid(self, matrix: List[List[int]]) -> bool:
        return all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(col)) == len(matrix) for col in zip(*matrix))


    """2134. Minimum Swaps to Group All 1's Together II (Medium)
    A swap is defined as taking two distinct positions in an array and swapping
    the values in them. A circular array is defined as an array where we
    consider the first element and the last element to be adjacent. Given a
    binary circular array nums, return the minimum number of swaps required to
    group all 1's present in the array together at any location.

    Example 1:
    Input: nums = [0,1,0,1,1,0,0]
    Output: 1
    Explanation: Here are a few of the ways to group all the 1's together:
                 [0,0,1,1,1,0,0] using 1 swap. [0,1,1,1,0,0,0] using 1 swap.
                 [1,1,0,0,0,0,1] using 2 swaps (using the circular property of
                 the array). There is no way to group all 1's together with 0
                 swaps. Thus, the minimum number of swaps required is 1.

    Example 2:
    Input: nums = [0,1,1,1,0,0,1,1,0]
    Output: 2
    Explanation: Here are a few of the ways to group all the 1's together:
                 [1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property
                 of the array). [1,1,1,1,1,0,0,0,0] using 2 swaps. There is no
                 way to group all 1's together with 0 or 1 swaps. Thus, the
                 minimum number of swaps required is 2.

    Example 3:
    Input: nums = [1,1,0,0,1]
    Output: 0
    Explanation: All the 1's are already grouped together due to the circular
                 property of the array. Thus, the minimum number of swaps
                 required is 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1."""

    def minSwaps(self, nums: List[int]) -> int:
        ans = inf
        ones = nums.count(1)
        prefix = 0
        for i in range(len(nums)+ones):
            prefix += nums[i % len(nums)]
            if i >= ones: prefix -= nums[(i-ones) % len(nums)]
            ans = min(ans, ones - prefix)
        return ans


    """2135. Count Words Obtained After Adding a Letter (Medium)
    You are given two 0-indexed arrays of strings startWords and targetWords.
    Each string consists of lowercase English letters only. For each string in
    targetWords, check if it is possible to choose a string from startWords and
    perform a conversion operation on it to be equal to that from targetWords.

    The conversion operation is described in the following two steps:
    * Append any lowercase letter that is not present in the string to its end.
      + For example, if the string is "abc", the letters 'd', 'e', or 'y' can
        be added to it, but not 'a'. If 'd' is added, the resulting string will
        be "abcd".
    * Rearrange the letters of the new string in any arbitrary order.
      + For example, "abcd" can be rearranged to "acbd", "bacd", "cbda", and so
        on. Note that it can also be rearranged to "abcd" itself.
    Return the number of strings in targetWords that can be obtained by
    performing the operations on any string of startWords. Note that you will
    only be verifying if the string in targetWords can be obtained from a
    string in startWords by performing the operations. The strings in
    startWords do not actually change during this process.

    Example 1:
    Input: startWords = ["ant","act","tack"], targetWords = ["tack","act","acti"]
    Output: 2
    Explanation: - In order to form targetWords[0] = "tack", we use
                   startWords[1] = "act", append 'k' to it, and rearrange "actk"
                   to "tack".
                 - There is no string in startWords that can be used to obtain
                   targetWords[1] = "act". Note that "act" does exist in
                   startWords, but we must append one letter to the string
                   before rearranging it.
                 - In order to form targetWords[2] = "acti", we use
                   startWords[1] = "act", append 'i' to it, and rearrange "acti"
                   to "acti" itself.

    Example 2:
    Input: startWords = ["ab","a"], targetWords = ["abc","abcd"]
    Output: 1
    Explanation: - In order to form targetWords[0] = "abc", we use
                   startWords[0] = "ab", add 'c' to it, and rearrange it to
                   "abc".
                 - There is no string in startWords that can be used to obtain
                   targetWords[1] = "abcd".

    Constraints:
    * 1 <= startWords.length, targetWords.length <= 5 * 10^4
    * 1 <= startWords[i].length, targetWords[j].length <= 26
    * Each string of startWords and targetWords consists of lowercase English
      letters only.
    * No letter occurs more than once in any string of startWords or
      targetWords."""

    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:
        seen = set()
        for word in startWords:
            m = 0
            for ch in word: m ^= 1 << ord(ch)-97
            seen.add(m)

        ans = 0
        for word in targetWords:
            m = 0
            for ch in word: m ^= 1 << ord(ch) - 97
            for ch in word:
                if m ^ (1 << ord(ch)-97) in seen:
                    ans += 1
                    break
        return ans


    """2136. Earliest Possible Day of Full Bloom (Hard)
    You have n flower seeds. Every seed must be planted first before it can
    begin to grow, then bloom. Planting a seed takes time and so does the
    growth of a seed. You are given two 0-indexed integer arrays plantTime and
    growTime, of length n each:
    * plantTime[i] is the number of full days it takes you to plant the ith
      seed. Every day, you can work on planting exactly one seed. You do not
      have to work on planting the same seed on consecutive days, but the
      planting of a seed is not complete until you have worked plantTime[i]
      days on planting it in total.
    * growTime[i] is the number of full days it takes the ith seed to grow
      after being completely planted. After the last day of its growth, the
      flower blooms and stays bloomed forever.
    From the beginning of day 0, you can plant the seeds in any order. Return
    the earliest possible day where all seeds are blooming.

    Example 1:
    Input: plantTime = [1,4,3], growTime = [2,3,1]
    Output: 9
    Explanation: The grayed out pots represent planting days, colored pots
                 represent growing days, and the flower represents the day it
                 blooms.
                 One optimal way is:
                 - On day 0, plant the 0th seed. The seed grows for 2 full days
                   and blooms on day 3.
                 - On days 1, 2, 3, and 4, plant the 1st seed. The seed grows
                   for 3 full days and blooms on day 8.
                 - On days 5, 6, and 7, plant the 2nd seed. The seed grows for
                   1 full day and blooms on day 9.
                 Thus, on day 9, all the seeds are blooming.

    Example 2:
    Input: plantTime = [1,2,3,2], growTime = [2,1,2,1]
    Output: 9
    Explanation: The grayed out pots represent planting days, colored pots
                 represent growing days, and the flower represents the day it
                 blooms.
                 One optimal way is:
                 - On day 1, plant the 0th seed. The seed grows for 2 full days
                   and blooms on day 4.
                 - On days 0 and 3, plant the 1st seed. The seed grows for 1
                   full day and blooms on day 5.
                 - On days 2, 4, and 5, plant the 2nd seed. The seed grows for
                   2 full days and blooms on day 8.
                 - On days 6 and 7, plant the 3rd seed. The seed grows for 1
                   full day and blooms on day 9.
                 Thus, on day 9, all the seeds are blooming.

    Example 3:
    Input: plantTime = [1], growTime = [1]
    Output: 2
    Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day
                 and blooms on day 2. Thus, on day 2, all the seeds are
                 blooming.

    Constraints:
    * n == plantTime.length == growTime.length
    * 1 <= n <= 10^5
    * 1 <= plantTime[i], growTime[i] <= 10^4"""

    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:
        ans = prefix = 0
        for p, g in sorted(zip(plantTime, growTime), key=lambda x: x[1], reverse=True):
            prefix += p
            ans = max(ans, prefix + g)
        return ans


    """2137. Pour Water Between Buckets to Make Water Levels Equal (Medium)
    You have n buckets each containing some gallons of water in it, represented
    by a 0-indexed integer array buckets, where the ith bucket contains
    buckets[i] gallons of water. You are also given an integer loss. You want
    to make the amount of water in each bucket equal. You can pour any amount
    of water from one bucket to another bucket (not necessarily an integer).
    However, every time you pour k gallons of water, you spill loss percent of
    k. Return the maximum amount of water in each bucket after making the
    amount of water equal. Answers within 10-5 of the actual answer will be
    accepted.

    Example 1:
    Input: buckets = [1,2,7], loss = 80
    Output: 2.00000
    Explanation: Pour 5 gallons of water from buckets[2] to buckets[0].
                 5 * 80% = 4 gallons are spilled and buckets[0] only receives
                 5 - 4 = 1 gallon of water. All buckets have 2 gallons of water
                 in them so return 2.

    Example 2:
    Input: buckets = [2,4,6], loss = 50
    Output: 3.50000
    Explanation: Pour 0.5 gallons of water from buckets[1] to buckets[0].
                 0.5 * 50% = 0.25 gallons are spilled and buckets[0] only
                 receives 0.5 - 0.25 = 0.25 gallons of water. Now,
                 buckets = [2.25, 3.5, 6]. Pour 2.5 gallons of water from
                 buckets[2] to buckets[0]. 2.5 * 50% = 1.25 gallons are spilled
                 and buckets[0] only receives 2.5 - 1.25 = 1.25 gallons of
                 water. All buckets have 3.5 gallons of water in them so return
                 3.5.

    Example 3:
    Input: buckets = [3,3,3,3], loss = 40
    Output: 3.00000
    Explanation: All buckets already have the same amount of water in them.

    Constraints:
    * 1 <= buckets.length <= 10^5
    * 0 <= buckets[i] <= 10^5
    * 0 <= loss <= 99"""

    def equalizeWater(self, buckets: List[int], loss: int) -> float:
        buckets.sort()
        ans = prefix = 0
        loss /= 100
        total = sum(buckets)
        for i, x in enumerate(buckets):
            cand = (prefix + (1-loss)*(total - prefix))/(i + (1-loss)*(len(buckets)-i))
            if (i == 0 or buckets[i-1] <= cand) and cand <= x: ans = max(ans, cand)
            prefix += x
        return ans


    """2138. Divide a String Into Groups of Size k (Easy)
    A string s can be partitioned into groups of size k using the following
    procedure:
    * The first group consists of the first k characters of the string, the
      second group consists of the next k characters of the string, and so on.
      Each character can be a part of exactly one group.
    * For the last group, if the string does not have k characters remaining, a
      character fill is used to complete the group.
    Note that the partition is done so that after removing the fill character
    from the last group (if it exists) and concatenating all the groups in
    order, the resultant string should be s. Given the string s, the size of
    each group k and the character fill, return a string array denoting the
    composition of every group s has been divided into, using the above
    procedure.

    Example 1:
    Input: s = "abcdefghi", k = 3, fill = "x"
    Output: ["abc","def","ghi"]
    Explanation: The first 3 characters "abc" form the first group. The next 3
                 characters "def" form the second group. The last 3 characters
                 "ghi" form the third group. Since all groups can be completely
                 filled by characters from the string, we do not need to use
                 fill. Thus, the groups formed are "abc", "def", and "ghi".

    Example 2:
    Input: s = "abcdefghij", k = 3, fill = "x"
    Output: ["abc","def","ghi","jxx"]
    Explanation: Similar to the previous example, we are forming the first
                 three groups "abc", "def", and "ghi". For the last group, we
                 can only use the character 'j' from the string. To complete
                 this group, we add 'x' twice. Thus, the 4 groups formed are
                 "abc", "def", "ghi", and "jxx".

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters only.
    * 1 <= k <= 100
    * fill is a lowercase English letter."""

    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        ans = []
        for i in range(0, len(s), k):
            ss = s[i:i+k]
            ans.append(ss + (k-len(ss))*fill)
        return ans


    """2139. Minimum Moves to Reach Target Score (Medium)
    You are playing a game with integers. You start with the integer 1 and you
    want to reach the integer target. In one move, you can either:
    * Increment the current integer by one (i.e., x = x + 1).
    * Double the current integer (i.e., x = 2 * x).
    You can use the increment operation any number of times, however, you can
    only use the double operation at most maxDoubles times. Given the two
    integers target and maxDoubles, return the minimum number of moves needed
    to reach target starting with 1.

    Example 1:
    Input: target = 5, maxDoubles = 0
    Output: 4
    Explanation: Keep incrementing by 1 until you reach target.

    Example 2:
    Input: target = 19, maxDoubles = 2
    Output: 7
    Explanation: Initially, x = 1
                 Increment 3 times so x = 4
                 Double once so x = 8
                 Increment once so x = 9
                 Double again so x = 18
                 Increment once so x = 19

    Example 3:
    Input: target = 10, maxDoubles = 4
    Output: 4
    Explanation: Initially, x = 1
                 Increment once so x = 2
                 Double once so x = 4
                 Increment once so x = 5
                 Double again so x = 10

    Constraints:
    * 1 <= target <= 10^9
    * 0 <= maxDoubles <= 100"""

    def minMoves(self, target: int, maxDoubles: int) -> int:
        ans = 0
        while target > 1 and maxDoubles:
            ans += 1
            if target&1: target -= 1
            else:
                target //= 2
                maxDoubles -= 1
        return ans + target - 1


    """2140. Solving Questions With Brainpower (Medium)
    You are given a 0-indexed 2D integer array questions where
    questions[i] = [pointsi, brainpoweri]. The array describes the questions of
    an exam, where you have to process the questions in order (i.e., starting
    from question 0) and make a decision whether to solve or skip each question.
    Solving question i will earn you pointsi points but you will be unable to
    solve each of the next brainpoweri questions. If you skip question i, you
    get to make the decision on the next question.
    * For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:
      + If question 0 is solved, you will earn 3 points but you will be unable
        to solve questions 1 and 2.
      + If instead, question 0 is skipped and question 1 is solved, you will
        earn 4 points but you will be unable to solve questions 2 and 3.
    Return the maximum points you can earn for the exam.

    Example 1:
    Input: questions = [[3,2],[4,3],[4,4],[2,5]]
    Output: 5
    Explanation: The maximum points can be earned by solving questions 0 and 3.
                 - Solve question 0: Earn 3 points, will be unable to solve the
                   next 2 questions
                 - Unable to solve questions 1 and 2
                 - Solve question 3: Earn 2 points
                 Total points earned: 3 + 2 = 5. There is no other way to earn
                 5 or more points.

    Example 2:
    Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
    Output: 7
    Explanation: The maximum points can be earned by solving questions 1 and 4.
                 - Skip question 0
                 - Solve question 1: Earn 2 points, will be unable to solve the
                   next 2 questions
                 - Unable to solve questions 2 and 3
                 - Solve question 4: Earn 5 points
                 Total points earned: 2 + 5 = 7. There is no other way to earn
                 7 or more points.

    Constraints:
    * 1 <= questions.length <= 10^5
    * questions[i].length == 2
    * 1 <= pointsi, brainpoweri <= 10^5"""

    def mostPoints(self, questions: List[List[int]]) -> int:
        n = len(questions)
        dp = [0]*(n+1)
        for i in range(n-1, -1, -1):
            dp[i] = dp[i+1]
            cand = questions[i][0]
            if i+questions[i][1]+1 <= n: cand += dp[i+questions[i][1]+1]
            dp[i] = max(dp[i], cand)
        return dp[0]


    """2141. Maximum Running Time of N Computers (Hard)
    You have n computers. You are given the integer n and a 0-indexed integer
    array batteries where the ith battery can run a computer for batteries[i]
    minutes. You are interested in running all n computers simultaneously using
    the given batteries. Initially, you can insert at most one battery into
    each computer. After that and at any integer time moment, you can remove a
    battery from a computer and insert another battery any number of times. The
    inserted battery can be a totally new battery or a battery from another
    computer. You may assume that the removing and inserting processes take no
    time. Note that the batteries cannot be recharged. Return the maximum
    number of minutes you can run all the n computers simultaneously.

    Example 1:
    Input: n = 2, batteries = [3,3,3]
    Output: 4
    Explanation: Initially, insert battery 0 into the first computer and
                 battery 1 into the second computer. After two minutes, remove
                 battery 1 from the second computer and insert battery 2
                 instead. Note that battery 1 can still run for one minute. At
                 the end of the third minute, battery 0 is drained, and you
                 need to remove it from the first computer and insert battery 1
                 instead. By the end of the fourth minute, battery 1 is also
                 drained, and the first computer is no longer running. We can
                 run the two computers simultaneously for at most 4 minutes, so
                 we return 4.

    Example 2:
    Input: n = 2, batteries = [1,1,1,1]
    Output: 2
    Explanation: Initially, insert battery 0 into the first computer and
                 battery 2 into the second computer. After one minute, battery
                 0 and battery 2 are drained so you need to remove them and
                 insert battery 1 into the first computer and battery 3 into
                 the second computer. After another minute, battery 1 and
                 battery 3 are also drained so the first and second computers
                 are no longer running. We can run the two computers
                 simultaneously for at most 2 minutes, so we return 2.

    Constraints:
    * 1 <= n <= batteries.length <= 10^5
    * 1 <= batteries[i] <= 10^9"""

    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        batteries.sort()
        extra = sum(batteries[:-n])
        batteries = batteries[-n:]

        ans = prefix = 0
        for i, x in enumerate(batteries):
            prefix += x
            if i+1 < len(batteries) and batteries[i+1]*(i+1) - prefix > extra: return (prefix + extra) // (i+1)
        return (prefix + extra) // n


    """2143. Choose Numbers From Two Arrays in Range (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2 of length n. A
    range [l, r] (inclusive) where 0 <= l <= r < n is balanced if:
    * For every i in the range [l, r], you pick either nums1[i] or nums2[i].
    * The sum of the numbers you pick from nums1 equals to the sum of the
      numbers you pick from nums2 (the sum is considered to be 0 if you pick no
      numbers from an array).
    Two balanced ranges from [l1, r1] and [l2, r2] are considered to be
    different if at least one of the following is true:
    * l1 != l2
    * r1 != r2
    * nums1[i] is picked in the first range, and nums2[i] is picked in the
      second range or vice versa for at least one i.
    Return the number of different ranges that are balanced. Since the answer
    may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums1 = [1,2,5], nums2 = [2,6,3]
    Output: 3
    Explanation: The balanced ranges are:
                 - [0, 1] where we choose nums2[0], and nums1[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 2 = 2.
                 - [0, 2] where we choose nums1[0], nums2[1], and nums1[2].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 1 + 5 = 6.
                 - [0, 2] where we choose nums1[0], nums1[1], and nums2[2].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 1 + 2 = 3.
                 Note that the second and third balanced ranges are different.
                 In the second balanced range, we choose nums2[1] and in the
                 third balanced range, we choose nums1[1].

    Example 2:
    Input: nums1 = [0,1], nums2 = [1,0]
    Output: 4
    Explanation: The balanced ranges are:
                 - [0, 0] where we choose nums1[0].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 0 = 0.
                 - [1, 1] where we choose nums2[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 0 = 0.
                 - [0, 1] where we choose nums1[0] and nums2[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 0 = 0.
                 - [0, 1] where we choose nums2[0] and nums1[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 1 = 1.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 100
    * 0 <= nums1[i], nums2[i] <= 100"""

    def countSubranges(self, nums1: List[int], nums2: List[int]) -> int:
        ans = 0
        mod = 1_000_000_007
        freq = defaultdict(int)
        for x, y in zip(nums1, nums2):
            ff = defaultdict(int)
            ff[x] += 1
            ff[-y] += 1
            for k, v in freq.items():
                ff[k+x] += v
                ff[k-y] += v
            freq = ff
            ans = (ans + freq[0]) % mod
        return ans


    """2144. Minimum Cost of Buying Candies With Discount (Easy)
    A shop is selling candies at a discount. For every two candies sold, the
    shop gives a third candy for free. The customer can choose any candy to
    take away for free as long as the cost of the chosen candy is less than or
    equal to the minimum cost of the two candies bought. For example, if there
    are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with
    costs 2 and 3, they can take the candy with cost 1 for free, but not the
    candy with cost 4. Given a 0-indexed integer array cost, where cost[i]
    denotes the cost of the ith candy, return the minimum cost of buying all
    the candies.

    Example 1:
    Input: cost = [1,2,3]
    Output: 5
    Explanation: We buy the candies with costs 2 and 3, and take the candy with
                 cost 1 for free. The total cost of buying all candies is
                 2 + 3 = 5. This is the only way we can buy the candies. Note
                 that we cannot buy candies with costs 1 and 3, and then take
                 the candy with cost 2 for free. The cost of the free candy has
                 to be less than or equal to the minimum cost of the purchased
                 candies.

    Example 2:
    Input: cost = [6,5,7,9,2,2]
    Output: 23
    Explanation: The way in which we can get the minimum cost is described below:
                 - Buy candies with costs 9 and 7
                 - Take the candy with cost 6 for free
                 - We buy candies with costs 5 and 2
                 - Take the last remaining candy with cost 2 for free
                 Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.

    Example 3:
    Input: cost = [5,5]
    Output: 10
    Explanation: Since there are only 2 candies, we buy both of them. There is
                 not a third candy we can take for free. Hence, the minimum
                 cost to buy all candies is 5 + 5 = 10.

    Constraints:
    * 1 <= cost.length <= 100
    * 1 <= cost[i] <= 100"""

    def minimumCost(self, cost: List[int]) -> int:
        return sum(x for i, x in enumerate(sorted(cost, reverse=True)) if (i+1)%3)


    """2145. Count the Hidden Sequences (Medium)
    You are given a 0-indexed array of n integers differences, which describes
    the differences between each pair of consecutive integers of a hidden
    sequence of length (n + 1). More formally, call the hidden sequence hidden,
    then we have that differences[i] = hidden[i + 1] - hidden[i]. You are
    further given two integers lower and upper that describe the inclusive
    range of values [lower, upper] that the hidden sequence can contain.
    * For example, given differences = [1, -3, 4], lower = 1, upper = 6, the
      hidden sequence is a sequence of length 4 whose elements are in between 1
      and 6 (inclusive).
      [3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences.
      [5, 6, 3, 7] is not possible since it contains an element greater than 6.
      [1, 2, 3, 4] is not possible since the differences are not correct.
    Return the number of possible hidden sequences there are. If there are no
    possible sequences, return 0.

    Example 1:
    Input: differences = [1,-3,4], lower = 1, upper = 6
    Output: 2
    Explanation: The possible hidden sequences are:
                 - [3, 4, 1, 5]
                 - [4, 5, 2, 6]
                 Thus, we return 2.

    Example 2:
    Input: differences = [3,-4,5,1,-2], lower = -4, upper = 5
    Output: 4
    Explanation: The possible hidden sequences are:
                 - [-3, 0, -4, 1, 2, 0]
                 - [-2, 1, -3, 2, 3, 1]
                 - [-1, 2, -2, 3, 4, 2]
                 - [0, 3, -1, 4, 5, 3]
                 Thus, we return 4.

    Example 3:
    Input: differences = [4,-7,2], lower = 3, upper = 6
    Output: 0
    Explanation: There are no possible hidden sequences. Thus, we return 0.

    Constraints:
    * n == differences.length
    * 1 <= n <= 10^5
    * -10^5 <= differences[i] <= 10^5
    * -10^5 <= lower <= upper <= 10^5"""

    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:
        prefix = mn = mx = 0
        for x in differences:
            prefix += x
            mn = min(mn, prefix)
            mx = max(mx, prefix)
        return max(0, (upper-lower) - (mx-mn) + 1)


    """2146. K Highest Ranked Items Within a Price Range (Medium)
    You are given a 0-indexed 2D integer array grid of size m x n that
    represents a map of the items in a shop. The integers in the grid represent
    the following:
    * 0 represents a wall that you cannot pass through.
    * 1 represents an empty cell that you can freely move to and from.
    * All other positive integers represent the price of an item in that cell.
      You may also freely move to and from these item cells.
    It takes 1 step to travel between adjacent grid cells. You are also given
    integer arrays pricing and start where pricing = [low, high] and
    start = [row, col] indicates that you start at the position (row, col) and
    are interested only in items with a price in the range of [low, high]
    (inclusive). You are further given an integer k. You are interested in the
    positions of the k highest-ranked items whose prices are within the given
    price range. The rank is determined by the first of these criteria that is
    different:
    * Distance, defined as the length of the shortest path from the start
      (shorter distance has a higher rank).
    * Price (lower price has a higher rank, but it must be in the price range).
    * The row number (smaller row number has a higher rank).
    * The column number (smaller column number has a higher rank).
    Return the k highest-ranked items within the price range sorted by their
    rank (highest to lowest). If there are fewer than k reachable items within
    the price range, return all of them.

    Example 1:
    Input: grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3
    Output: [[0,1],[1,1],[2,1]]
    Explanation: You start at (0,0). With a price range of [2,5], we can take
                 items from (0,1), (1,1), (2,1) and (2,2). The ranks of these
                 items are:
                 - (0,1) with distance 1
                 - (1,1) with distance 2
                 - (2,1) with distance 3
                 - (2,2) with distance 4
                 Thus, the 3 highest ranked items in the price range are (0,1),
                 (1,1), and (2,1).

    Example 2:
    Input: grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2
    Output: [[2,1],[1,2]]
    Explanation: You start at (2,3). With a price range of [2,3], we can take
                 items from (0,1), (1,1), (1,2) and (2,1). The ranks of these
                 items are:
                 - (2,1) with distance 2, price 2
                 - (1,2) with distance 2, price 3
                 - (1,1) with distance 3
                 - (0,1) with distance 4
                 Thus, the 2 highest ranked items in the price range are (2,1)
                 and (1,2).

    Example 3:
    Input: grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3
    Output: [[2,1],[2,0]]
    Explanation: You start at (0,0). With a price range of [2,3], we can take
                 items from (2,0) and (2,1). The ranks of these items are:
                 - (2,1) with distance 5
                 - (2,0) with distance 6
                 Thus, the 2 highest ranked items in the price range are (2,1)
                 and (2,0). Note that k = 3 but there are only 2 reachable
                 items within the price range.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 0 <= grid[i][j] <= 10^5
    * pricing.length == 2
    * 2 <= low <= high <= 10^5
    * start.length == 2
    * 0 <= row <= m - 1
    * 0 <= col <= n - 1
    * grid[row][col] > 0
    * 1 <= k <= m * n"""

    def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        ans = []
        queue = deque([(0, *start)])
        grid[start[0]][start[1]] *= -1
        while queue:
            x, i, j = queue.popleft()
            if pricing[0] <= -grid[i][j] <= pricing[1]: ans.append((x, -grid[i][j], i, j))
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] > 0:
                    queue.append((x+1, ii, jj))
                    grid[ii][jj] *= -1
        return [[i, j] for _, _, i, j in sorted(ans)[:k]]


    """2147. Number of Ways to Divide a Long Corridor (Hard)
    Along a long library corridor, there is a line of seats and decorative
    plants. You are given a 0-indexed string corridor of length n consisting of
    letters 'S' and 'P' where each 'S' represents a seat and each 'P'
    represents a plant. One room divider has already been installed to the left
    of index 0, and another to the right of index n - 1. Additional room
    dividers can be installed. For each position between indices i - 1 and i
    (1 <= i <= n - 1), at most one divider can be installed. Divide the
    corridor into non-overlapping sections, where each section has exactly two
    seats with any number of plants. There may be multiple ways to perform the
    division. Two ways are different if there is a position with a room divider
    installed in the first way but not in the second way. Return the number of
    ways to divide the corridor. Since the answer may be very large, return it
    modulo 10^9 + 7. If there is no way, return 0.

    Example 1:
    Input: corridor = "SSPPSPS"
    Output: 3
    Explanation: There are 3 different ways to divide the corridor. The black
                 bars in the above image indicate the two room dividers already
                 installed. Note that in each of the ways, each section has
                 exactly two seats.

    Example 2:
    Input: corridor = "PPSPSP"
    Output: 1
    Explanation: There is only 1 way to divide the corridor, by not installing
                 any additional dividers. Installing any would create some
                 section that does not have exactly two seats.

    Example 3:
    Input: corridor = "S"
    Output: 0
    Explanation: There is no way to divide the corridor because there will
                 always be a section that does not have exactly two seats.

    Constraints:
    * n == corridor.length
    * 1 <= n <= 10^5
    * corridor[i] is either 'S' or 'P'."""

    def numberOfWays(self, corridor: str) -> int:
        ans = 1
        seats = ii = 0
        for i, x in enumerate(corridor):
            if x == 'S':
                if seats and seats % 2 == 0: ans = ans * (i-ii) % 1_000_000_007
                seats += 1
                ii = i
        return ans if seats and seats % 2 == 0 else 0


    """2148. Count Elements With Strictly Smaller and Greater Elements (Easy)
    Given an integer array nums, return the number of elements that have both a
    strictly smaller and a strictly greater element appear in nums.

    Example 1:
    Input: nums = [11,7,2,15]
    Output: 2
    Explanation: The element 7 has the element 2 strictly smaller than it and
                 the element 11 strictly greater than it. Element 11 has
                 element 7 strictly smaller than it and element 15 strictly
                 greater than it. In total there are 2 elements having both a
                 strictly smaller and a strictly greater element appear in nums.

    Example 2:
    Input: nums = [-3,3,3,90]
    Output: 2
    Explanation: The element 3 has the element -3 strictly smaller than it and
                 the element 90 strictly greater than it. Since there are two
                 elements with the value 3, in total there are 2 elements
                 having both a strictly smaller and a strictly greater element
                 appear in nums.

    Constraints:
    * 1 <= nums.length <= 100
    * -10^5 <= nums[i] <= 10^5"""

    def countElements(self, nums: List[int]) -> int:
        mn, mx = min(nums), max(nums)
        return sum(mn < x < mx for x in nums)


    """2149. Rearrange Array Elements by Sign (Medium)
    You are given a 0-indexed integer array nums of even length consisting of
    an equal number of positive and negative integers. You should rearrange the
    elements of nums such that the modified array follows the given conditions:
    * Every consecutive pair of integers have opposite signs.
    * For all integers with the same sign, the order in which they were present
      in nums is preserved.
    * The rearranged array begins with a positive integer.
    Return the modified array after rearranging the elements to satisfy the
    aforementioned conditions.

    Example 1:
    Input: nums = [3,1,-2,-5,2,-4]
    Output: [3,-2,1,-5,2,-4]
    Explanation: The positive integers in nums are [3,1,2]. The negative
                 integers are [-2,-5,-4]. The only possible way to rearrange
                 them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
                 Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4],
                 [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one
                 or more conditions.

    Example 2:
    Input: nums = [-1,1]
    Output: [1,-1]
    Explanation: 1 is the only positive integer and -1 the only negative
                 integer in nums. So nums is rearranged to [1,-1].

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * nums.length is even
    * 1 <= |nums[i]| <= 10^5
    * nums consists of equal number of positive and negative integers."""

    def rearrangeArray(self, nums: List[int]) -> List[int]:
        ans = [0]*len(nums)
        p, n = 0, 1
        for x in nums:
            if x > 0:
                ans[p] = x
                p += 2
            else:
                ans[n] = x
                n += 2
        return ans


    """2150. Find All Lonely Numbers in the Array (Medium)
    You are given an integer array nums. A number x is lonely when it appears
    only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the
    array. Return all lonely numbers in nums. You may return the answer in any
    order.

    Example 1:
    Input: nums = [10,6,5,8]
    Output: [10,8]
    Explanation: - 10 is a lonely number since it appears exactly once and 9
                   and 11 does not appear in nums.
                 - 8 is a lonely number since it appears exactly once and 7 and
                   9 does not appear in nums.
                 - 5 is not a lonely number since 6 appears in nums and vice
                   versa.
                 Hence, the lonely numbers in nums are [10, 8]. Note that
                 [8, 10] may also be returned.

    Example 2:
    Input: nums = [1,3,5,3]
    Output: [1,5]
    Explanation: - 1 is a lonely number since it appears exactly once and 0 and
                   2 does not appear in nums.
                 - 5 is a lonely number since it appears exactly once and 4 and
                   6 does not appear in nums.
                 - 3 is not a lonely number since it appears twice.
                 Hence, the lonely numbers in nums are [1, 5]. Note that [5, 1]
                 may also be returned.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6"""

    def findLonely(self, nums: List[int]) -> List[int]:
        freq = Counter(nums)
        ans = []
        for k, v in freq.items():
            if v == 1 and freq[k-1] == freq[k+1] == 0: ans.append(k)
        return ans


    """2151. Maximum Good People Based on Statements (Hard)
    There are two types of persons:
    * The good person: The person who always tells the truth.
    * The bad person: The person who might tell the truth and might lie.
    You are given a 0-indexed 2D integer array statements of size n x n that
    represents the statements made by n people about each other. More
    specifically, statements[i][j] could be one of the following:
    * 0 which represents a statement made by person i that person j is a bad
      person.
    * 1 which represents a statement made by person i that person j is a good
      person.
    * 2 represents that no statement is made by person i about person j.
    Additionally, no person ever makes a statement about themselves. Formally,
    we have that statements[i][i] = 2 for all 0 <= i < n. Return the maximum
    number of people who can be good based on the statements made by the n people.

    Example 1:
    Input: statements = [[2,1,2],[1,2,2],[2,0,2]]
    Output: 2
    Explanation: Each person makes a single statement.
                 - Person 0 states that person 1 is good.
                 - Person 1 states that person 0 is good.
                 - Person 2 states that person 1 is bad.
                 Let's take person 2 as the key.
                 - Assuming that person 2 is a good person:
                     - Based on the statement made by person 2, person 1 is a bad person.
                     - Now we know for sure that person 1 is bad and person 2 is good.
                     - Based on the statement made by person 1, and since person 1 is bad, they could be:
                         - telling the truth. There will be a contradiction in this case and this assumption is invalid.
                         - lying. In this case, person 0 is also a bad person and lied in their statement.
                     - Following that person 2 is a good person, there will be only one good person in the group.
                 - Assuming that person 2 is a bad person:
                     - Based on the statement made by person 2, and since person 2 is bad, they could be:
                         - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.
                             - Following that person 2 is bad but told the truth, there will be no good persons in the group.
                         - lying. In this case person 1 is a good person.
                             - Since person 1 is a good person, person 0 is also a good person.
                             - Following that person 2 is bad and lied, there will be two good persons in the group.
                 We can see that at most 2 persons are good in the best case, so we return 2.
                 Note that there is more than one way to arrive at this conclusion.

    Example 2:
    Input: statements = [[2,0],[0,2]]
    Output: 1
    Explanation: Each person makes a single statement.
                 - Person 0 states that person 1 is bad.
                 - Person 1 states that person 0 is bad.
                 Let's take person 0 as the key.
                 - Assuming that person 0 is a good person:
                     - Based on the statement made by person 0, person 1 is a bad person and was lying.
                     - Following that person 0 is a good person, there will be only one good person in the group.
                 - Assuming that person 0 is a bad person:
                     - Based on the statement made by person 0, and since person 0 is bad, they could be:
                         - telling the truth. Following this scenario, person 0 and 1 are both bad.
                             - Following that person 0 is bad but told the truth, there will be no good persons in the group.
                         - lying. In this case person 1 is a good person.
                             - Following that person 0 is bad and lied, there will be only one good person in the group.
                 We can see that at most, one person is good in the best case, so we return 1.
                 Note that there is more than one way to arrive at this conclusion.

    Constraints:
    * n == statements.length == statements[i].length
    * 2 <= n <= 15
    * statements[i][j] is either 0, 1, or 2.
    * statements[i][i] == 2"""

    def maximumGood(self, statements: List[List[int]]) -> int:
        n = len(statements)
        ans = 0
        for k in range(n, -1, -1):
            for good in combinations(list(range(n)), k):
                cand = True
                for i in good:
                    if cand:
                        for j in range(n):
                            if i != j and (statements[i][j] == 0 and j in good or statements[i][j] == 1 and j not in good):
                                cand = False
                                break
                if cand: return k


    """2152. Minimum Number of Lines to Cover Points (Medium)
    You are given an array points where points[i] = [xi, yi] represents a point
    on an X-Y plane. Straight lines are going to be added to the X-Y plane,
    such that every point is covered by at least one line. Return the minimum
    number of straight lines needed to cover all the points.

    Example 1:
    Input: points = [[0,1],[2,3],[4,5],[4,3]]
    Output: 2
    Explanation: The minimum number of straight lines needed is two. One
                 possible solution is to add:
                 - One line connecting the point at (0, 1) to the point at
                   (4, 5).
                 - Another line connecting the point at (2, 3) to the point at
                   (4, 3).

    Example 2:
    Input: points = [[0,2],[-2,-2],[1,4]]
    Output: 1
    Explanation: The minimum number of straight lines needed is one. The only
                 solution is to add:
                 - One line connecting the point at (-2, -2) to the point at
                   (1, 4).

    Constraints:
    * 1 <= points.length <= 10
    * points[i].length == 2
    * -100 <= xi, yi <= 100
    * All the points are unique."""

    def minimumLines(self, points: List[List[int]]) -> int:
        n = len(points)
        mask = defaultdict(int)
        for i in range(n):
            for j in range(i+1, n):
                mask[i, j] ^= 1<<i ^ 1<<j
                for k in range(j+1, n):
                    if (points[i][0]-points[j][0]) * (points[i][1]-points[k][1]) == (points[i][1]-points[j][1]) * (points[i][0]-points[k][0]): mask[i, j] ^= 1<<k

        dp = [inf]*(1<<n)
        dp[0] = 0
        for m in range(1, 1<<n):
            if  bin(m).count('1') <= 2: dp[m] = 1
            else:
                for i in range(n):
                    if m & 1<<i: break
                for j in range(i+1, n):
                    if m & 1<<j: dp[m] = min(dp[m], 1 + dp[m ^ mask[i, j]])
        return dp[-1]


    """2154. Keep Multiplying Found Values by Two (Easy)
    You are given an array of integers nums. You are also given an integer
    original which is the first number that needs to be searched for in nums.
    You then do the following steps:
    * If original is found in nums, multiply it by two (i.e., set
      original = 2 * original).
    * Otherwise, stop the process.
    * Repeat this process with the new number as long as you keep finding the
      number.
    Return the final value of original.

    Example 1:
    Input: nums = [5,3,6,1,12], original = 3
    Output: 24
    Explanation: - 3 is found in nums. 3 is multiplied by 2 to obtain 6.
                 - 6 is found in nums. 6 is multiplied by 2 to obtain 12.
                 - 12 is found in nums. 12 is multiplied by 2 to obtain 24.
                 - 24 is not found in nums. Thus, 24 is returned.

    Example 2:
    Input: nums = [2,7,9], original = 4
    Output: 4
    Explanation: - 4 is not found in nums. Thus, 4 is returned.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i], original <= 1000"""

    def findFinalValue(self, nums: List[int], original: int) -> int:
        seen = set(nums)
        while original in seen: original *= 2
        return original


    """2155. All Divisions With the Highest Score of a Binary Array (Medium)
    You are given a 0-indexed binary array nums of length n. nums can be
    divided at index i (where 0 <= i <= n) into two arrays (possibly empty)
    numsleft and numsright:
    * numsleft has all the elements of nums between index 0 and i - 1
      (inclusive), while numsright has all the elements of nums between index i
      and n - 1 (inclusive).
    * If i == 0, numsleft is empty, while numsright has all the elements of nums.
    * If i == n, numsleft has all the elements of nums, while numsright is empty.
    The division score of an index i is the sum of the number of 0's in numsleft
    and the number of 1's in numsright. Return all distinct indices that have
    the highest possible division score. You may return the answer in any order.

    Example 1:
    Input: nums = [0,0,1,0]
    Output: [2,4]
    Explanation: Division at index
                 - 0: numsleft is []. numsright is [0,0,1,0]. The score is 0 + 1 = 1.
                 - 1: numsleft is [0]. numsright is [0,1,0]. The score is 1 + 1 = 2.
                 - 2: numsleft is [0,0]. numsright is [1,0]. The score is 2 + 1 = 3.
                 - 3: numsleft is [0,0,1]. numsright is [0]. The score is 2 + 0 = 2.
                 - 4: numsleft is [0,0,1,0]. numsright is []. The score is 3 + 0 = 3.
                 Indices 2 and 4 both have the highest possible division score 3.
                 Note the answer [4,2] would also be accepted.

    Example 2:
    Input: nums = [0,0,0]
    Output: [3]
    Explanation: Division at index
                 - 0: numsleft is []. numsright is [0,0,0]. The score is 0 + 0 = 0.
                 - 1: numsleft is [0]. numsright is [0,0]. The score is 1 + 0 = 1.
                 - 2: numsleft is [0,0]. numsright is [0]. The score is 2 + 0 = 2.
                 - 3: numsleft is [0,0,0]. numsright is []. The score is 3 + 0 = 3.
                 Only index 3 has the highest possible division score 3.

    Example 3:
    Input: nums = [1,1]
    Output: [0]
    Explanation: Division at index
                 - 0: numsleft is []. numsright is [1,1]. The score is 0 + 2 = 2.
                 - 1: numsleft is [1]. numsright is [1]. The score is 0 + 1 = 1.
                 - 2: numsleft is [1,1]. numsright is []. The score is 0 + 0 = 0.
                 Only index 0 has the highest possible division score 2.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * nums[i] is either 0 or 1."""

    def maxScoreIndices(self, nums: List[int]) -> List[int]:
        ans = [0]
        cand = most = nums.count(1)
        for i, x in enumerate(nums):
            if x == 0: cand += 1
            elif x == 1: cand -= 1
            if cand > most: ans, most = [i+1], cand
            elif cand == most: ans.append(i+1)
        return ans


    """2156. Find Substring With Given Hash Value (Medium)
    The hash of a 0-indexed string s of length k, given integers p and m, is
    computed using the following function:
    * hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.
    Where val(s[i]) represents the index of s[i] in the alphabet from
    val('a') = 1 to val('z') = 26. You are given a string s and the integers
    power, modulo, k, and hashValue. Return sub, the first substring of s of
    length k such that hash(sub, power, modulo) == hashValue. The test cases
    will be generated such that an answer always exists. A substring is a
    contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: s = "leetcode", power = 7, modulo = 20, k = 2, hashValue = 0
    Output: "ee"
    Explanation: The hash of "ee" can be computed to be
                 hash("ee", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0.
                 "ee" is the first substring of length 2 with hashValue 0.
                 Hence, we return "ee".

    Example 2:
    Input: s = "fbxzaad", power = 31, modulo = 100, k = 3, hashValue = 32
    Output: "fbx"
    Explanation: The hash of "fbx" can be computed to be
                 hash("fbx", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32.
                 The hash of "bxz" can be computed to be
                 hash("bxz", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32.
                 "fbx" is the first substring of length 3 with hashValue 32.
                 Hence, we return "fbx". Note that "bxz" also has a hash of 32
                 but it appears later than "fbx".

    Constraints:
    * 1 <= k <= s.length <= 2 * 10^4
    * 1 <= power, modulo <= 10^9
    * 0 <= hashValue < modulo
    * s consists of lowercase English letters only.
    * The test cases are generated such that an answer always exists."""

    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        pp = pow(power, k-1, modulo)
        hs = ii = 0
        for i, ch in enumerate(reversed(s)):
            if i >= k: hs -= (ord(s[~(i-k)]) - 96)*pp
            hs = (hs * power + (ord(ch) - 96)) % modulo
            if i >= k-1 and hs == hashValue: ii = i
        return s[~ii:~ii+k or None]


    """2157. Groups of Strings (Hard)
    You are given a 0-indexed array of strings words. Each string consists of
    lowercase English letters only. No letter occurs more than once in any
    string of words. Two strings s1 and s2 are said to be connected if the set
    of letters of s2 can be obtained from the set of letters of s1 by any one
    of the following operations:
    * Adding exactly one letter to the set of the letters of s1.
    * Deleting exactly one letter from the set of the letters of s1.
    * Replacing exactly one letter from the set of the letters of s1 with any
      letter, including itself.
    The array words can be divided into one or more non-intersecting groups. A
    string belongs to a group if any one of the following is true:
    * It is connected to at least one other string of the group.
    * It is the only string present in the group.
    Note that the strings in words should be grouped in such a manner that a
    string belonging to a group cannot be connected to a string present in any
    other group. It can be proved that such an arrangement is always unique.
    Return an array ans of size 2 where:
    * ans[0] is the total number of groups words can be divided into, and
    * ans[1] is the size of the largest group.

    Example 1:
    Input: words = ["a","b","ab","cde"]
    Output: [2,3]
    Explanation: - words[0] can be used to obtain words[1] (by replacing 'a'
                   with 'b'), and words[2] (by adding 'b'). So words[0] is
                   connected to words[1] and words[2].
                 - words[1] can be used to obtain words[0] (by replacing 'b'
                   with 'a'), and words[2] (by adding 'a'). So words[1] is
                   connected to words[0] and words[2].
                 - words[2] can be used to obtain words[0] (by deleting 'b'),
                   and words[1] (by deleting 'a'). So words[2] is connected to
                   words[0] and words[1].
                 - words[3] is not connected to any string in words.
                 Thus, words can be divided into 2 groups ["a","b","ab"] and
                 ["cde"]. The size of the largest group is 3.

    Example 2:
    Input: words = ["a","ab","abc"]
    Output: [1,3]
    Explanation: - words[0] is connected to words[1].
                 - words[1] is connected to words[0] and words[2].
                 - words[2] is connected to words[1].
                 Since all strings are connected to each other, they should be
                 grouped together. Thus, the size of the largest group is 3.

    Constraints:
    * 1 <= words.length <= 2 * 10^4
    * 1 <= words[i].length <= 26
    * words[i] consists of lowercase English letters only.
    * No letter occurs more than once in words[i]."""

    def groupStrings(self, words: List[str]) -> List[int]:
        n = len(words)
        uf = UnionFind(n)
        seen = {}
        for i, word in enumerate(words):
            m = reduce(or_, (1<<ord(ch)-97 for ch in word))
            if m in seen: uf.union(i, seen[m])
            for k in range(26):
                if m ^ 1<<k in seen: uf.union(i, seen[m ^ 1<<k])
                if m & 1<<k:
                    mm = m ^ 1<<k ^ 1<<26
                    if mm in seen: uf.union(i, seen[mm])
                    seen[mm] = i
            seen[m] = i
        freq = Counter(uf.find(i) for i in range(n))
        return [len(freq), max(freq.values())]


    """2158. Amount of New Area Painted Each Day (Hard)
    There is a long and thin painting that can be represented by a number line.
    You are given a 0-indexed 2D integer array paint of length n, where
    paint[i] = [starti, endi]. This means that on the ith day you need to paint
    the area between starti and endi. Painting the same area multiple times
    will create an uneven painting so you only want to paint each area of the
    painting at most once. Return an integer array worklog of length n, where
    worklog[i] is the amount of new area that you painted on the ith day.

    Example 1:
    Input: paint = [[1,4],[4,7],[5,8]]
    Output: [3,3,1]
    Explanation: On day 0, paint everything between 1 and 4. The amount of new
                 area painted on day 0 is 4 - 1 = 3. On day 1, paint everything
                 between 4 and 7. The amount of new area painted on day 1 is
                 7 - 4 = 3. On day 2, paint everything between 7 and 8.
                 Everything between 5 and 7 was already painted on day 1. The
                 amount of new area painted on day 2 is 8 - 7 = 1.

    Example 2:
    Input: paint = [[1,4],[5,8],[4,7]]
    Output: [3,3,1]
    Explanation: On day 0, paint everything between 1 and 4. The amount of new
                 area painted on day 0 is 4 - 1 = 3. On day 1, paint everything
                 between 5 and 8. The amount of new area painted on day 1 is
                 8 - 5 = 3. On day 2, paint everything between 4 and 5.
                 Everything between 5 and 7 was already painted on day 1. The
                 amount of new area painted on day 2 is 5 - 4 = 1.

    Example 3:
    Input: paint = [[1,5],[2,4]]
    Output: [4,0]
    Explanation: On day 0, paint everything between 1 and 5. The amount of new
                 area painted on day 0 is 5 - 1 = 4. On day 1, paint nothing
                 because everything between 2 and 4 was already painted on day
                 0. The amount of new area painted on day 1 is 0.

    Constraints:
    * 1 <= paint.length <= 10^5
    * paint[i].length == 2
    * 0 <= starti < endi <= 5 * 10^4"""

    def amountPainted(self, paint: List[List[int]]) -> List[int]:
        ans = []
        intervals = SortedList()
        for x, y in paint:
            diff = 0
            k = intervals.bisect_left((x, y))
            if 0 < k and x < intervals[k-1][1]:
                [xx, yy] = intervals.pop(k-1)
                x = min(x, xx)
                y = max(y, yy)
                diff -= yy - xx
                k -= 1
            while k < len(intervals) and intervals[k][0] < y:
                [xx, yy] = intervals.pop(k)
                y = max(y, yy)
                diff -= yy - xx
            ans.append(y - x + diff)
            intervals.add((x, y))
        return ans


    """2160. Minimum Sum of Four Digit Number After Splitting Digits (Easy)
    You are given a positive integer num consisting of exactly four digits.
    Split num into two new integers new1 and new2 by using the digits found in
    num. Leading zeros are allowed in new1 and new2, and all the digits found
    in num must be used. For example, given num = 2932, you have the following
    digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2]
    are [22, 93], [23, 92], [223, 9] and [2, 329]. Return the minimum possible
    sum of new1 and new2.

    Example 1:
    Input: num = 2932
    Output: 52
    Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.
                 The minimum sum can be obtained by the pair [29, 23]:
                 29 + 23 = 52.

    Example 2:
    Input: num = 4009
    Output: 13
    Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc.
                 The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.

    Constraints: 1000 <= num <= 9999"""

    def minimumSum(self, num: int) -> int:
        new1 = new2 = 0
        for i, x in enumerate(sorted(map(int, str(num)))):
            if i&1: new1 = 10*new1 + x
            else: new2 = 10*new2 + x
        return new1 + new2


    """2161. Partition Array According to Given Pivot (Medium)
    You are given a 0-indexed integer array nums and an integer pivot.
    Rearrange nums such that the following conditions are satisfied:
    * Every element less than pivot appears before every element greater than
      pivot.
    * Every element equal to pivot appears in between the elements less than
      and greater than pivot.
    * The relative order of the elements less than pivot and the elements
      greater than pivot is maintained.
    More formally, consider every pi, pj where pi is the new position of the
    ith element and pj is the new position of the jth element. For elements
    less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then
    pi < pj. Similarly for elements greater than pivot, if i < j and
    nums[i] > pivot and nums[j] > pivot, then pi < pj. Return nums after the
    rearrangement.

    Example 1:
    Input: nums = [9,12,5,10,14,3,10], pivot = 10
    Output: [9,5,3,10,10,12,14]
    Explanation: The elements 9, 5, and 3 are less than the pivot so they are
                 on the left side of the array. The elements 12 and 14 are
                 greater than the pivot so they are on the right side of the
                 array. The relative ordering of the elements less than and
                 greater than pivot is also maintained. [9, 5, 3] and [12, 14]
                 are the respective orderings.

    Example 2:
    Input: nums = [-3,4,3,2], pivot = 2
    Output: [-3,2,4,3]
    Explanation: The element -3 is less than the pivot so it is on the left
                 side of the array. The elements 4 and 3 are greater than the
                 pivot so they are on the right side of the array. The relative
                 ordering of the elements less than and greater than pivot is
                 also maintained. [-3] and [4, 3] are the respective orderings.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^6 <= nums[i] <= 10^6
    * pivot equals to an element of nums."""

    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        small, equal, large = [], [], []
        for x in nums:
            if x < pivot: small.append(x)
            elif x == pivot: equal.append(x)
            else: large.append(x)
        return small + equal + large


    """2162. Minimum Cost to Set Cooking Time (Medium)
    A generic microwave supports cooking times for:
    * at least 1 second.
    * at most 99 minutes and 99 seconds.
    To set the cooking time, you push at most four digits. The microwave
    normalizes what you push as four digits by prepending zeroes. It interprets
    the first two digits as the minutes and the last two digits as the seconds.
    It then adds them up as the cooking time. For example,
    * You push 9 5 4 (three digits). It is normalized as 0954 and interpreted
      as 9 minutes and 54 seconds.
    * You push 0 0 0 8 (four digits). It is interpreted as 0 minutes and 8
      seconds.
    * You push 8 0 9 0. It is interpreted as 80 minutes and 90 seconds.
    * You push 8 1 3 0. It is interpreted as 81 minutes and 30 seconds.
    You are given integers startAt, moveCost, pushCost, and targetSeconds.
    Initially, your finger is on the digit startAt. Moving the finger above any
    specific digit costs moveCost units of fatigue. Pushing the digit below the
    finger once costs pushCost units of fatigue. There can be multiple ways to
    set the microwave to cook for targetSeconds seconds but you are interested
    in the way with the minimum cost. Return the minimum cost to set
    targetSeconds seconds of cooking time. Remember that one minute consists of
    60 seconds.

    Example 1:
    Input: startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600
    Output: 6
    Explanation: The following are the possible ways to set the cooking time.
                 - 1 0 0 0, interpreted as 10 minutes and 0 seconds. The finger
                   is already on digit 1, pushes 1 (with cost 1), moves to 0
                   (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost
                   1), and pushes 0 (with cost 1). The cost is:
                   1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.
                 - 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is
                   also 600 seconds. The finger moves to 0 (with cost 2),
                   pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9
                   (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost
                   1), moves to 0 (with cost 2), and pushes 0 (with cost 1).
                   The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.
                 - 9 6 0, normalized as 0960 and interpreted as 9 minutes and
                   60 seconds. The finger moves to 9 (with cost 2), pushes 9
                   (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost
                   1), moves to 0 (with cost 2), and pushes 0 (with cost 1).
                   The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.

    Example 2:
    Input: startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76
    Output: 6
    Explanation: The optimal way is to push two digits: 7 6, interpreted as 76
                 seconds. The finger moves to 7 (with cost 1), pushes 7 (with
                 cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2).
                 The total cost is: 1 + 2 + 1 + 2 = 6. Note other possible ways
                 are 0076, 076, 0116, and 116, but none of them produces the
                 minimum cost.

    Constraints:
    * 0 <= startAt <= 9
    * 1 <= moveCost, pushCost <= 10^5
    * 1 <= targetSeconds <= 6039"""

    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:
        m, s = divmod(targetSeconds, 60)
        cands = []
        if m < 100: cands.append((str(m) + str(s).zfill(2)).lstrip('0'))
        if m and s < 40: cands.append((str(m-1) + str(s+60).zfill(2)).lstrip('0'))
        ans = inf
        for cand in cands:
            cost = 0
            prev = str(startAt)
            for ch in cand:
                if prev != ch: cost += moveCost
                prev = ch
                cost += pushCost
            ans = min(ans, cost)
        return ans


    """2163. Minimum Difference in Sums After Removal of Elements (Hard)
    You are given a 0-indexed integer array nums consisting of 3 * n elements.
    You are allowed to remove any subsequence of elements of size exactly n
    from nums. The remaining 2 * n elements will be divided into two equal
    parts:
    * The first n elements belonging to the first part and their sum is
      sumfirst.
    * The next n elements belonging to the second part and their sum is
      sumsecond.
    The difference in sums of the two parts is denoted as sumfirst - sumsecond.
    * For example, if sumfirst = 3 and sumsecond = 2, their difference is 1.
    * Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.
    Return the minimum difference possible between the sums of the two parts
    after the removal of n elements.

    Example 1:
    Input: nums = [3,1,2]
    Output: -1
    Explanation: Here, nums has 3 elements, so n = 1. Thus we have to remove 1
                 element from nums and divide the array into two equal parts.
                 - If we remove nums[0] = 3, the array will be [1,2]. The
                   difference in sums of the two parts will be 1 - 2 = -1.
                 - If we remove nums[1] = 1, the array will be [3,2]. The
                   difference in sums of the two parts will be 3 - 2 = 1.
                 - If we remove nums[2] = 2, the array will be [3,1]. The
                   difference in sums of the two parts will be 3 - 1 = 2.
                 The minimum difference between sums of the two parts is
                 min(-1,1,2) = -1.

    Example 2:
    Input: nums = [7,9,5,8,1,3]
    Output: 1
    Explanation: Here n = 2. So we must remove 2 elements and divide the
                 remaining array into two parts containing two elements each.
                 If we remove nums[2] = 5 and nums[3] = 8, the resultant array
                 will be [7,9,1,3]. The difference in sums will be
                 (7+9) - (1+3) = 12. To obtain the minimum difference, we
                 should remove nums[1] = 9 and nums[4] = 1. The resultant array
                 becomes [7,5,8,3]. The difference in sums of the two parts is
                 (7+5) - (8+3) = 1. It can be shown that it is not possible to
                 obtain a difference smaller than 1.

    Constraints:
    * nums.length == 3 * n
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums)//3
        pq0 = [-x for x in nums[:n]]
        pq1 = nums[-n:]
        heapify(pq0)
        heapify(pq1)
        ans = -sum(pq0) - sum(pq1)
        prefix = [0]
        mid = nums[n:2*n]
        for x in mid:
            if x < -pq0[0]:
                prefix.append(prefix[-1]+x+pq0[0])
                heapreplace(pq0, -x)
            else: prefix.append(prefix[-1])
        diff = prefix[-1]
        suffix = 0
        for i in reversed(range(n)):
            if mid[i] > pq1[0]:
                suffix += pq1[0] - mid[i]
                heappop(pq1)
                heappush(pq1, mid[i])
            diff = min(diff, prefix[i] + suffix)
        return ans + diff


    """2167. Minimum Time to Remove All Cars Containing Illegal Goods (Hard)
    You are given a 0-indexed binary string s which represents a sequence of
    train cars. s[i] = '0' denotes that the ith car does not contain illegal
    goods and s[i] = '1' denotes that the ith car does contain illegal goods.
    As the train conductor, you would like to get rid of all the cars
    containing illegal goods. You can do any of the following three operations
    any number of times:
    * Remove a train car from the left end (i.e., remove s[0]) which takes 1
      unit of time.
    * Remove a train car from the right end (i.e., remove s[s.length - 1])
      which takes 1 unit of time.
    * Remove a train car from anywhere in the sequence which takes 2 units of
      time.
    Return the minimum time to remove all the cars containing illegal goods.
    Note that an empty sequence of cars is considered to have no cars
    containing illegal goods.

    Example 1:
    Input: s = "1100101"
    Output: 5
    Explanation: One way to remove all the cars containing illegal goods from
                 the sequence is to
                 - remove a car from the left end 2 times. Time taken is
                   2 * 1 = 2.
                 - remove a car from the right end. Time taken is 1.
                 - remove the car containing illegal goods found in the middle.
                   Time taken is 2.
                 This obtains a total time of 2 + 1 + 2 = 5. An alternative way
                 is to
                 - remove a car from the left end 2 times. Time taken is
                   2 * 1 = 2.
                 - remove a car from the right end 3 times. Time taken is
                   3 * 1 = 3.
                 This also obtains a total time of 2 + 3 = 5. 5 is the minimum
                 time taken to remove all the cars containing illegal goods.
                 There are no other ways to remove them with less time.

    Example 2:
    Input: s = "0010"
    Output: 2
    Explanation: One way to remove all the cars containing illegal goods from
                 the sequence is to
                 - remove a car from the left end 3 times. Time taken is
                   3 * 1 = 3.
                 This obtains a total time of 3. Another way to remove all the
                 cars containing illegal goods from the sequence is to
                 - remove the car containing illegal goods found in the middle.
                   Time taken is 2.
                 This obtains a total time of 2. Another way to remove all the
                 cars containing illegal goods from the sequence is to
                 - remove a car from the right end 2 times. Time taken is
                   2 * 1 = 2.
                 This obtains a total time of 2. 2 is the minimum time taken to
                 remove all the cars containing illegal goods. There are no
                 other ways to remove them with less time.

    Constraints:
    * 1 <= s.length <= 2 * 10^5
    * s[i] is either '0' or '1'."""

    def minimumTime(self, s: str) -> int:
        ans = inf
        prefix = 0
        for i, ch in enumerate(s):
            if ch == '1': prefix = min(2 + prefix, i+1)
            ans = min(ans, prefix + len(s)-1-i)
        return ans


    """2168. Unique Substrings With Equal Digit Frequency (Medium)
    Given a digit string s, return the number of unique substrings of s where
    every digit appears the same number of times.

    Example 1:
    Input: s = "1212"
    Output: 5
    Explanation: The substrings that meet the requirements are "1", "2", "12",
                 "21", "1212". Note that although the substring "12" appears
                 twice, it is only counted once.

    Example 2:
    Input: s = "12321"
    Output: 9
    Explanation: The substrings that meet the requirements are "1", "2", "3",
                 "12", "23", "32", "21", "123", "321".

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of digits."""

    def equalDigitFrequency(self, s: str) -> int:
        seen = set()
        for i in range(len(s)):
            freq = Counter()
            hs = most = 0
            for j in range(i, len(s)):
                freq[s[j]] += 1
                most = max(most, freq[s[j]])
                hs = (11*hs + ord(s[j]) - 47) % 1_000_000_007
                if most*len(freq) == j-i+1: seen.add(hs)
        return len(seen)


    """2169. Count Operations to Obtain Zero (Easy)
    You are given two non-negative integers num1 and num2. In one operation, if
    num1 >= num2, you must subtract num2 from num1, otherwise subtract num1
    from num2.
    * For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus
      obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after
      one operation, num1 = 4 and num2 = 1.
    Return the number of operations required to make either num1 = 0 or
    num2 = 0.

    Example 1:
    Input: num1 = 2, num2 = 3
    Output: 3
    Explanation: - Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we
                   subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.
                 - Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we
                   subtract num2 from num1.
                 - Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we
                   subtract num2 from num1.
                 Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to
                 perform any further operations. So the total number of
                 operations required is 3.

    Example 2:
    Input: num1 = 10, num2 = 10
    Output: 1
    Explanation: - Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we
                   subtract num2 from num1 and get num1 = 10 - 10 = 0.
                 Now num1 = 0 and num2 = 10. Since num1 == 0, we are done. So
                 the total number of operations required is 1.

    Constraints: 0 <= num1, num2 <= 10^5"""

    def countOperations(self, num1: int, num2: int) -> int:
        ans = 0
        while num1 and num2:
            ans += num1//num2
            num1, num2 = num2, num1%num2
        return ans


    """2170. Minimum Operations to Make the Array Alternating (Medium)
    You are given a 0-indexed array nums consisting of n positive integers. The
    array nums is called alternating if:
    * nums[i - 2] == nums[i], where 2 <= i <= n - 1.
    * nums[i - 1] != nums[i], where 1 <= i <= n - 1.
    In one operation, you can choose an index i and change nums[i] into any
    positive integer. Return the minimum number of operations required to make
    the array alternating.

    Example 1:
    Input: nums = [3,1,3,2,4,3]
    Output: 3
    Explanation: One way to make the array alternating is by converting it to
                 [3,1,3,1,3,1]. The number of operations required in this case
                 is 3. It can be proven that it is not possible to make the
                 array alternating in less than 3 operations.

    Example 2:
    Input: nums = [1,2,2,2,2]
    Output: 2
    Explanation: One way to make the array alternating is by converting it to
                 [1,2,1,2,1]. The number of operations required in this case is
                 2. Note that the array cannot be converted to [2,2,2,2,2]
                 because in this case nums[0] == nums[1] which violates the
                 conditions of an alternating array.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def minimumOperations(self, nums: List[int]) -> int:
        pad = lambda x: x + [(None, 0)]*(2-len(x))
        even = pad(Counter(nums[::2]).most_common(2))
        odd = pad(Counter(nums[1::2]).most_common(2))
        return len(nums) - (max(even[0][1] + odd[1][1], even[1][1] + odd[0][1]) if even[0][0] == odd[0][0] else even[0][1] + odd[0][1])


    """2171. Removing Minimum Number of Magic Beans (Medium)
    You are given an array of positive integers beans, where each integer
    represents the number of magic beans found in a particular magic bag.
    Remove any number of beans (possibly none) from each bag such that the
    number of beans in each remaining non-empty bag (still containing at least
    one bean) is equal. Once a bean has been removed from a bag, you are not
    allowed to return it to any of the bags. Return the minimum number of magic
    beans that you have to remove.

    Example 1:
    Input: beans = [4,1,6,5]
    Output: 4
    Explanation: - We remove 1 bean from the bag with only 1 bean. This results
                   in the remaining bags: [4,0,6,5]
                 - Then we remove 2 beans from the bag with 6 beans. This
                   results in the remaining bags: [4,0,4,5]
                 - Then we remove 1 bean from the bag with 5 beans. This
                   results in the remaining bags: [4,0,4,4]
                 We removed a total of 1 + 2 + 1 = 4 beans to make the
                 remaining non-empty bags have an equal number of beans. There
                 are no other solutions that remove 4 beans or fewer.

    Example 2:
    Input: beans = [2,10,3,2]
    Output: 7
    Explanation: - We remove 2 beans from one of the bags with 2 beans. This
                   results in the remaining bags: [0,10,3,2]
                 - Then we remove 2 beans from the other bag with 2 beans. This
                   results in the remaining bags: [0,10,3,0]
                 - Then we remove 3 beans from the bag with 3 beans. This
                   results in the remaining bags: [0,10,0,0]
                 We removed a total of 2 + 2 + 3 = 7 beans to make the
                 remaining non-empty bags have an equal number of beans. There
                 are no other solutions that removes 7 beans or fewer.

    Constraints:
    * 1 <= beans.length <= 10^5
    * 1 <= beans[i] <= 10^5"""

    def minimumRemoval(self, beans: List[int]) -> int:
        beans.sort()
        return sum(beans) - max((len(beans)-i)*x for i, x in enumerate(beans))


    """2172. Maximum AND Sum of Array (Hard)
    You are given an integer array nums of length n and an integer numSlots
    such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to
    numSlots. You have to place all n integers into the slots such that each
    slot contains at most two numbers. The AND sum of a given placement is the
    sum of the bitwise AND of every number with its respective slot number.
    * For example, the AND sum of placing the numbers [1, 3] into slot 1 and
      [4, 6] into slot 2 is equal to
      (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4.
    Return the maximum possible AND sum of nums given numSlots slots.

    Example 1:
    Input: nums = [1,2,3,4,5,6], numSlots = 3
    Output: 9
    Explanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot
                 2, and [3, 5] into slot 3. This gives the maximum AND sum of
                 (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) +
                 (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.

    Example 2:
    Input: nums = [1,3,10,4,7,1], numSlots = 9
    Output: 24
    Explanation: One possible placement is [1, 1] into slot 1, [3] into slot 3,
                 [4] into slot 4, [7] into slot 7, and [10] into slot 9. This
                 gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3)
                 + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.
                 Note that slots 2, 5, 6, and 8 are empty which is permitted.

    Constraints:
    * n == nums.length
    * 1 <= numSlots <= 9
    * 1 <= n <= 2 * numSlots
    * 1 <= nums[i] <= 15"""

    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:

        @cache
        def fn(k, m):
            """Return max AND sum."""
            if k == len(nums): return 0
            ans = 0
            for i in range(numSlots):
                if m & 1<<2*i == 0 or m & 1<<2*i+1 == 0:
                    if m & 1<<2*i == 0: mm = m ^ 1<<2*i
                    else: mm = m ^ 1<<2*i+1
                    ans = max(ans, (nums[k] & i+1) + fn(k+1, mm))
            return ans

        return fn(0, 0)


    """2174. Remove All Ones With Row and Column Flips II (Medium)
    You are given a 0-indexed m x n binary matrix grid. In one operation, you
    can choose any i and j that meet the following conditions:
    * 0 <= i < m
    * 0 <= j < n
    * grid[i][j] == 1
    and change the values of all cells in row i and column j to zero. Return
    the minimum number of operations needed to remove all 1's from grid.

    Example 1:
    Input: grid = [[1,1,1],[1,1,1],[0,1,0]]
    Output: 2
    Explanation: In the first operation, change all cell values of row 1 and
                 column 1 to zero. In the second operation, change all cell
                 values of row 0 and column 0 to zero.

    Example 2:
    Input: grid = [[0,1,0],[1,0,1],[0,1,0]]
    Output: 2
    Explanation: In the first operation, change all cell values of row 1 and
                 column 0 to zero. In the second operation, change all cell
                 values of row 2 and column 1 to zero. Note that we cannot
                 perform an operation using row 1 and column 1 because
                 grid[1][1] != 1.

    Example 3:
    Input: grid = [[0,0],[0,0]]
    Output: 0
    Explanation: There are no 1's to remove so return 0.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 15
    * 1 <= m * n <= 15
    * grid[i][j] is either 0 or 1."""

    def removeOnes(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        mask = [[(1<<m*n)-1] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                for ii in range(m):
                    if mask[i][j] & 1<<ii*n+j: mask[i][j] ^= 1<<ii*n+j
                for jj in range(n):
                    if mask[i][j] & 1<<i*n+jj: mask[i][j] ^= 1<<i*n+jj
        v = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j]: v ^= 1<<i*n+j
        ans = 0
        seen = {v}
        queue = deque([v])
        while queue:
            for _ in range(len(queue)):
                v = queue.popleft()
                if v == 0: return ans
                for i in range(m):
                    for j in range(n):
                        if v & 1<<i*n+j:
                            vv = v & mask[i][j]
                            if vv not in seen:
                                seen.add(vv)
                                queue.append(vv)
            ans += 1


    """2176. Count Equal and Divisible Pairs in an Array (Easy)
    Given a 0-indexed integer array nums of length n and an integer k, return
    the number of pairs (i, j) where 0 <= i < j < n, such that
    nums[i] == nums[j] and (i * j) is divisible by k.

    Example 1:
    Input: nums = [3,1,2,2,2,1,3], k = 2
    Output: 4
    Explanation: There are 4 pairs that meet all the requirements:
                 - nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
                 - nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
                 - nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
                 - nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.

    Example 2:
    Input: nums = [1,2,3,4], k = 1
    Output: 0
    Explanation: Since no value in nums is repeated, there are no pairs (i,j)
                 that meet all the requirements.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i], k <= 100"""

    def countPairs(self, nums: List[int], k: int) -> int:
        ans = 0
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] == nums[j] and i*j % k == 0: ans += 1
        return ans


    """2177. Find Three Consecutive Integers That Sum to a Given Number (Medium)
    Given an integer num, return three consecutive integers (as a sorted array)
    that sum to num. If num cannot be expressed as the sum of three consecutive
    integers, return an empty array.

    Example 1:
    Input: num = 33
    Output: [10,11,12]
    Explanation: 33 can be expressed as 10 + 11 + 12 = 33. 10, 11, 12 are 3
                 consecutive integers, so we return [10, 11, 12].

    Example 2:
    Input: num = 4
    Output: []
    Explanation: There is no way to express 4 as the sum of 3 consecutive
                 integers.

    Constraints: 0 <= num <= 10^15"""

    def sumOfThree(self, num: int) -> List[int]:
        return [] if num % 3 else [num//3-1, num//3, num//3+1]


    """2178. Maximum Split of Positive Even Integers (Medium)
    You are given an integer finalSum. Split it into a sum of a maximum number
    of unique positive even integers.
    * For example, given finalSum = 12, the following splits are valid (unique
      positive even integers summing up to finalSum): (2 + 10), (2 + 4 + 6),
      and (4 + 8). Among them, (2 + 4 + 6) contains the maximum number of
      integers. Note that finalSum cannot be split into (2 + 2 + 4 + 4) as all
      the numbers should be unique.
    Return a list of integers that represent a valid split containing a maximum
    number of integers. If no valid split exists for finalSum, return an empty
    list. You may return the integers in any order.

    Example 1:
    Input: finalSum = 12
    Output: [2,4,6]
    Explanation: The following are some valid splits: (2 + 10), (2 + 4 + 6),
                 and (4 + 8). (2 + 4 + 6) has the maximum number of integers,
                 which is 3. Thus, we return [2,4,6]. Note that [2,6,4], [6,2,4],
                 etc. are also accepted.

    Example 2:
    Input: finalSum = 7
    Output: []
    Explanation: There are no valid splits for the given finalSum. Thus, we
                 return an empty array.

    Example 3:
    Input: finalSum = 28
    Output: [6,8,2,12]
    Explanation: The following are some valid splits: (2 + 26), (6 + 8 + 2 + 12),
                 and (4 + 24). (6 + 8 + 2 + 12) has the maximum number of
                 integers, which is 4. Thus, we return [6,8,2,12]. Note that
                 [10,2,4,12], [6,2,4,16], etc. are also accepted.

    Constraints: 1 <= finalSum <= 10^10"""

    def maximumEvenSplit(self, finalSum: int) -> List[int]:
        if finalSum&1: return []
        ans = []
        x = 2
        while x <= finalSum:
            ans.append(x)
            finalSum -= x
            x += 2
        ans[-1] += finalSum
        return ans


    """2179. Count Good Triplets in an Array (Hard)
    You are given two 0-indexed arrays nums1 and nums2 of length n, both of
    which are permutations of [0, 1, ..., n - 1]. A good triplet is a set of 3
    distinct values which are present in increasing order by position both in
    nums1 and nums2. In other words, if we consider pos1v as the index of the
    value v in nums1 and pos2v as the index of the value v in nums2, then a
    good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that
    pos1x < pos1y < pos1z and pos2x < pos2y < pos2z. Return the total number of
    good triplets.

    Example 1:
    Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3]
    Output: 1
    Explanation: There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z.
                 They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). Out of those
                 triplets, only the triplet (0,1,3) satisfies
                 pos2x < pos2y < pos2z. Hence, there is only 1 good triplet.

    Example 2:
    Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
    Output: 4
    Explanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2).

    Constraints:
    * n == nums1.length == nums2.length
    * 3 <= n <= 10^5
    * 0 <= nums1[i], nums2[i] <= n - 1
    * nums1 and nums2 are permutations of [0, 1, ..., n - 1]."""

    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        mp = {x : i for i, x in enumerate(nums1)}
        sl = SortedList()
        ans = 0
        for i, x in enumerate(nums2):
            x = mp[x]
            left = sl.bisect_left(x)
            right = (len(nums2)-1-x) - (len(sl)-left)
            ans += left * right
            sl.add(x)
        return ans


    """2180. Count Integers With Even Digit Sum (Easy)
    Given a positive integer num, return the number of positive integers less
    than or equal to num whose digit sums are even. The digit sum of a positive
    integer is the sum of all its digits.

    Example 1:
    Input: num = 4
    Output: 2
    Explanation: The only integers less than or equal to 4 whose digit sums are
                 even are 2 and 4.

    Example 2:
    Input: num = 30
    Output: 14
    Explanation: The 14 integers less than or equal to 30 whose digit sums are
                 even are 2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and
                 28.

    Constraints: 1 <= num <= 1000"""

    def countEven(self, num: int) -> int:
        ans = 0
        for x in range(1, num+1):
            sm = sum(map(int, str(x)))
            if not sm&1: ans += 1
        return ans


    """2181. Merge Nodes in Between Zeros (Medium)
    You are given the head of a linked list, which contains a series of
    integers separated by 0's. The beginning and end of the linked list will
    have Node.val == 0. For every two consecutive 0's, merge all the nodes
    lying in between them into a single node whose value is the sum of all the
    merged nodes. The modified list should not contain any 0's. Return the head
    of the modified linked list.

    Example 1:
    Input: head = [0,3,1,0,4,5,2,0]
    Output: [4,11]
    Explanation: The above figure represents the given linked list. The
                 modified list contains
                 - The sum of the nodes marked in green: 3 + 1 = 4.
                 - The sum of the nodes marked in red: 4 + 5 + 2 = 11.

    Example 2:
    Input: head = [0,1,0,3,0,2,2,0]
    Output: [1,3,4]
    Explanation: The above figure represents the given linked list. The
                 modified list contains
                 - The sum of the nodes marked in green: 1 = 1.
                 - The sum of the nodes marked in red: 3 = 3.
                 - The sum of the nodes marked in yellow: 2 + 2 = 4.

    Constraints:
    * The number of nodes in the list is in the range [3, 2 * 10^5].
    * 0 <= Node.val <= 1000
    * There are no two consecutive nodes with Node.val == 0.
    * The beginning and end of the linked list have Node.val == 0."""

    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = node = ListNode()
        chunk = head
        while chunk:
            chunk = chunk.next
            sm = 0
            while chunk and chunk.val:
                sm += chunk.val
                chunk = chunk.next
            if sm: node.next = node = ListNode(sm)
        return dummy.next


    """2182. Construct String With Repeat Limit (Medium)
    You are given a string s and an integer repeatLimit. Construct a new string
    repeatLimitedString using the characters of s such that no letter appears
    more than repeatLimit times in a row. You do not have to use all characters
    from s. Return the lexicographically largest repeatLimitedString possible.
    A string a is lexicographically larger than a string b if in the first
    position where a and b differ, string a has a letter that appears later in
    the alphabet than the corresponding letter in b. If the first
    min(a.length, b.length) characters do not differ, then the longer string is
    the lexicographically larger one.

    Example 1:
    Input: s = "cczazcc", repeatLimit = 3
    Output: "zzcccac"
    Explanation: We use all of the characters from s to construct the
                 repeatLimitedString "zzcccac". The letter 'a' appears at most
                 1 time in a row. The letter 'c' appears at most 3 times in a
                 row. The letter 'z' appears at most 2 times in a row. Hence,
                 no letter appears more than repeatLimit times in a row and the
                 string is a valid repeatLimitedString. The string is the
                 lexicographically largest repeatLimitedString possible so we
                 return "zzcccac". Note that the string "zzcccca" is
                 lexicographically larger but the letter 'c' appears more than
                 3 times in a row, so it is not a valid repeatLimitedString.

    Example 2:
    Input: s = "aababab", repeatLimit = 2
    Output: "bbabaa"
    Explanation: We use only some of the characters from s to construct the
                 repeatLimitedString "bbabaa". The letter 'a' appears at most 2
                 times in a row. The letter 'b' appears at most 2 times in a
                 row. Hence, no letter appears more than repeatLimit times in a
                 row and the string is a valid repeatLimitedString. The string
                 is the lexicographically largest repeatLimitedString possible
                 so we return "bbabaa". Note that the string "bbabaaa" is
                 lexicographically larger but the letter 'a' appears more than
                 2 times in a row, so it is not a valid repeatLimitedString.

    Constraints:
    * 1 <= repeatLimit <= s.length <= 10^5
    * s consists of lowercase English letters."""

    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
        pq = [(-ord(k), v) for k, v in Counter(s).items()]
        heapify(pq)
        ans = []
        while pq:
            k, v = heappop(pq)
            if ans and ans[-1] == k:
                if not pq: break
                kk, vv = heappop(pq)
                ans.append(kk)
                if vv-1: heappush(pq, (kk, vv-1))
                heappush(pq, (k, v))
            else:
                m = min(v, repeatLimit)
                ans.extend([k]*m)
                if v-m: heappush(pq, (k, v-m))
        return "".join(chr(-x) for x in ans)


    """2183. Count Array Pairs Divisible by K (Hard)
    Given a 0-indexed integer array nums of length n and an integer k, return
    the number of pairs (i, j) such that:
    * 0 <= i < j <= n - 1 and
    * nums[i] * nums[j] is divisible by k.

    Example 1:
    Input: nums = [1,2,3,4,5], k = 2
    Output: 7
    Explanation: The 7 pairs of indices whose corresponding products are
                 divisible by 2 are (0, 1), (0, 3), (1, 2), (1, 3), (1, 4),
                 (2, 3), and (3, 4). Their products are 2, 4, 6, 8, 10, 12, and
                 20 respectively. Other pairs such as (0, 2) and (2, 4) have
                 products 3 and 15 respectively, which are not divisible by 2.

    Example 2:
    Input: nums = [1,2,3,4], k = 5
    Output: 0
    Explanation: There does not exist any pair of indices whose corresponding
                 product is divisible by 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= 10^5"""

    def coutPairs(self, nums: List[int], k: int) -> int:
        factors = []
        for x in range(1, int(sqrt(k))+1):
            if k % x == 0: factors.append(x)
        ans = 0
        freq = Counter()
        for x in nums:
            x = gcd(x, k)
            ans += freq[k//x]
            for f in factors:
                if x % f == 0 and f <= x//f:
                    freq[f] += 1
                    if f < x//f: freq[x//f] += 1
        return ans


    """2185. Counting Words With a Given Prefix (Easy)
    You are given an array of strings words and a string pref. Return the
    number of strings in words that contain pref as a prefix. A prefix of a
    string s is any leading contiguous substring of s.

    Example 1:
    Input: words = ["pay","attention","practice","attend"], pref = "at"
    Output: 2
    Explanation: The 2 strings that contain "at" as a prefix are: "attention"
                 and "attend".

    Example 2:
    Input: words = ["leetcode","win","loops","success"], pref = "code"
    Output: 0
    Explanation: There are no strings that contain "code" as a prefix.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length, pref.length <= 100
    * words[i] and pref consist of lowercase English letters."""

    def prefixCount(self, words: List[str], pref: str) -> int:
        return sum(word.startswith(pref) for word in words)


    """2186. Minimum Number of Steps to Make Two Strings Anagram II (Medium)
    You are given two strings s and t. In one step, you can append any
    character to either s or t. Return the minimum number of steps to make s
    and t anagrams of each other. An anagram of a string is a string that
    contains the same characters with a different (or the same) ordering.

    Example 1:
    Input: s = "leetcode", t = "coats"
    Output: 7
    Explanation: - In 2 steps, we can append the letters in "as" onto
                   s = "leetcode", forming s = "leetcodeas".
                 - In 5 steps, we can append the letters in "leede" onto
                   t = "coats", forming t = "coatsleede".
                 "leetcodeas" and "coatsleede" are now anagrams of each other.
                 We used a total of 2 + 5 = 7 steps. It can be shown that there
                 is no way to make them anagrams of each other with less than 7
                 steps.

    Example 2:
    Input: s = "night", t = "thing"
    Output: 0
    Explanation: The given strings are already anagrams of each other. Thus, we
                 do not need any further steps.

    Constraints:
    * 1 <= s.length, t.length <= 2 * 10^5
    * s and t consist of lowercase English letters."""

    def minSteps(self, s: str, t: str) -> int:
        fs, ft = Counter(s), Counter(t)
        return sum((fs-ft).values()) + sum((ft-fs).values())


    """2187. Minimum Time to Complete Trips (Medium)
    You are given an array time where time[i] denotes the time taken by the ith
    bus to complete one trip. Each bus can make multiple trips successively;
    that is, the next trip can start immediately after completing the current
    trip. Also, each bus operates independently; that is, the trips of one bus
    do not influence the trips of any other bus. You are also given an integer
    totalTrips, which denotes the number of trips all buses should make in
    total. Return the minimum time required for all buses to complete at least
    totalTrips trips.

    Example 1:
    Input: time = [1,2,3], totalTrips = 5
    Output: 3
    Explanation: - At time t = 1, the number of trips completed by each bus are
                   [1,0,0]. The total number of trips completed is 1 + 0 + 0 = 1.
                 - At time t = 2, the number of trips completed by each bus are
                   [2,1,0]. The total number of trips completed is 2 + 1 + 0 = 3.
                 - At time t = 3, the number of trips completed by each bus are
                   [3,1,1]. The total number of trips completed is 3 + 1 + 1 = 5.
                 So the minimum time needed for all buses to complete at least
                 5 trips is 3.

    Example 2:
    Input: time = [2], totalTrips = 1
    Output: 2
    Explanation: There is only one bus, and it will complete its first trip at
                 t = 2. So the minimum time needed to complete 1 trip is 2.

    Constraints:
    1 <= time.length <= 10^5
    1 <= time[i], totalTrips <= 10^7"""

    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        lo, hi = 0, max(time) * totalTrips
        while lo < hi:
            mid = lo + hi >> 1
            if sum(mid//x for x in time) < totalTrips: lo = mid + 1
            else: hi = mid
        return lo


    """2188. Minimum Time to Finish the Race (Hard)
    You are given a 0-indexed 2D integer array tires where tires[i] = [fi, ri]
    indicates that the ith tire can finish its xth successive lap in
    fi * ri^(x-1) seconds. For example, if fi = 3 and ri = 2, then the tire
    would finish its 1st lap in 3 seconds, its 2nd lap in 3 * 2 = 6 seconds,
    its 3rd lap in 3 * 22 = 12 seconds, etc. You are also given an integer
    changeTime and an integer numLaps. The race consists of numLaps laps and
    you may start the race with any tire. You have an unlimited supply of each
    tire and after every lap, you may change to any given tire (including the
    current tire type) if you wait changeTime seconds. Return the minimum time
    to finish the race.

    Example 1:
    Input: tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4
    Output: 21
    Explanation: Lap 1: Start with tire 0 and finish the lap in 2 seconds.
                 Lap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6
                        seconds.
                 Lap 3: Change tires to a new tire 0 for 5 seconds and then
                        finish the lap in another 2 seconds.
                 Lap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6
                        seconds.
                 Total time = 2 + 6 + 5 + 2 + 6 = 21 seconds. The minimum time
                 to complete the race is 21 seconds.

    Example 2:
    Input: tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5
    Output: 25
    Explanation: Lap 1: Start with tire 1 and finish the lap in 2 seconds.
                 Lap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4
                        seconds.
                 Lap 3: Change tires to a new tire 1 for 6 seconds and then
                        finish the lap in another 2 seconds.
                 Lap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4
                        seconds.
                 Lap 5: Change tires to tire 0 for 6 seconds then finish the
                        lap in another 1 second.
                 Total time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds. The
                 minimum time to complete the race is 25 seconds.

    Constraints:
    * 1 <= tires.length <= 10^5
    * tires[i].length == 2
    * 1 <= fi, changeTime <= 10^5
    * 2 <= ri <= 10^5
    * 1 <= numLaps <= 1000"""

    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        init = [inf] * 20
        for f, r in tires:
            prefix = term = f
            for i in range(20):
                init[i] = min(init[i], prefix)
                term *= r
                if term >= f+changeTime: break
                prefix += term

        @cache
        def fn(n):
            """Return min time to finish n laps."""
            ans = init[n-1] if n <= 20 else inf
            for nn in range(1, min(20, n//2)+1):
                ans = min(ans, fn(nn) + fn(n-nn) + changeTime)
            return ans

        return fn(numLaps)


    """2189. Number of Ways to Build House of Cards (Medium)
    You are given an integer n representing the number of playing cards you
    have. A house of cards meets the following conditions:
    * A house of cards consists of one or more rows of triangles and horizontal
      cards.
    * Triangles are created by leaning two cards against each other.
    * One card must be placed horizontally between all adjacent triangles in a
      row.
    * Any triangle on a row higher than the first must be placed on a
      horizontal card from the previous row.
    * Each triangle is placed in the leftmost available spot in the row.
    Return the number of distinct house of cards you can build using all n
    cards. Two houses of cards are considered distinct if there exists a row
    where the two houses contain a different number of cards.

    Example 1:
    Input: n = 16
    Output: 2
    Explanation: The two valid houses of cards are shown. The third house of
                 cards in the diagram is not valid because the rightmost
                 triangle on the top row is not placed on top of a horizontal
                 card.

    Example 2:
    Input: n = 2
    Output: 1
    Explanation: The one valid house of cards is shown.

    Example 3:
    Input: n = 4
    Output: 0
    Explanation: The three houses of cards in the diagram are not valid. The
                 first house of cards needs a horizontal card placed between
                 the two triangles. The second house of cards uses 5 cards. The
                 third house of cards uses 2 cards.

    Constraints: 1 <= n <= 500"""

    def houseOfCards(self, n: int) -> int:
        dp = [0]*(n+1)
        dp[0] = 1
        for x in range(2, n+1, 3):
            for i in range(n, x-1, -1):
                dp[i] += dp[i-x]
        return dp[-1]


    """2190. Most Frequent Number Following Key In an Array (Easy)
    You are given a 0-indexed integer array nums. You are also given an integer
    key, which is present in nums. For every unique integer target in nums,
    count the number of times target immediately follows an occurrence of key
    in nums. In other words, count the number of indices i such that:
    * 0 <= i <= nums.length - 2,
    * nums[i] == key and,
    * nums[i + 1] == target.
    Return the target with the maximum count. The test cases will be generated
    such that the target with maximum count is unique.

    Example 1:
    Input: nums = [1,100,200,1,100], key = 1
    Output: 100
    Explanation: For target = 100, there are 2 occurrences at indices 1 and 4
                 which follow an occurrence of key. No other integers follow an
                 occurrence of key, so we return 100.

    Example 2:
    Input: nums = [2,2,2,2,3], key = 2
    Output: 2
    Explanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3
                 which follow an occurrence of key. For target = 3, there is
                 only one occurrence at index 4 which follows an occurrence of
                 key. target = 2 has the maximum number of occurrences
                 following an occurrence of key, so we return 2.

    Constraints:
    * 2 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000
    * The test cases will be generated such that the answer is unique."""

    def mostFrequent(self, nums: List[int], key: int) -> int:
        freq = Counter(x for i, x in enumerate(nums) if i and nums[i-1] == key)
        return max(freq, key=freq.get)


    """2191. Sort the Jumbled Numbers (Medium)
    You are given a 0-indexed integer array mapping which represents the
    mapping rule of a shuffled decimal system. mapping[i] = j means digit i
    should be mapped to digit j in this system. The mapped value of an integer
    is the new integer obtained by replacing each occurrence of digit i in the
    integer with mapping[i] for all 0 <= i <= 9. You are also given another
    integer array nums. Return the array nums sorted in non-decreasing order
    based on the mapped values of its elements.

    Notes:
    * Elements with the same mapped values should appear in the same relative
      order as in the input.
    * The elements of nums should only be sorted based on their mapped values
      and not be replaced by them.

    Example 1:
    Input: mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]
    Output: [338,38,991]
    Explanation: Map the number 991 as follows:
                 1. mapping[9] = 6, so all occurrences of the digit 9 will
                    become 6.
                 2. mapping[1] = 9, so all occurrences of the digit 1 will
                    become 9.
                 Therefore, the mapped value of 991 is 669. 338 maps to 007, or
                 7 after removing the leading zeros. 38 maps to 07, which is
                 also 7 after removing leading zeros. Since 338 and 38 share
                 the same mapped value, they should remain in the same relative
                 order, so 338 comes before 38. Thus, the sorted array is
                 [338,38,991].

    Example 2:
    Input: mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]
    Output: [123,456,789]
    Explanation: 789 maps to 789, 456 maps to 456, and 123 maps to 123. Thus,
                 the sorted array is [123,456,789].

    Constraints:
    * mapping.length == 10
    * 0 <= mapping[i] <= 9
    * All the values of mapping[i] are unique.
    * 1 <= nums.length <= 3 * 10^4
    * 0 <= nums[i] < 10^9"""

    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
        return sorted(nums, key=lambda x: int(''.join(str(mapping[int(d)]) for d in str(x))))


    """2192. All Ancestors of a Node in a Directed Acyclic Graph (Medium)
    You are given a positive integer n representing the number of nodes of a
    Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1
    (inclusive). You are also given a 2D integer array edges, where
    edges[i] = [fromi, toi] denotes that there is a unidirectional edge from
    fromi to toi in the graph. Return a list answer, where answer[i] is the
    list of ancestors of the ith node, sorted in ascending order. A node u is
    an ancestor of another node v if u can reach v via a set of edges.

    Example 1:
    Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]
    Output: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]
    Explanation: The above diagram represents the input graph.
                 - Nodes 0, 1, and 2 do not have any ancestors.
                 - Node 3 has two ancestors 0 and 1.
                 - Node 4 has two ancestors 0 and 2.
                 - Node 5 has three ancestors 0, 1, and 3.
                 - Node 6 has five ancestors 0, 1, 2, 3, and 4.
                 - Node 7 has four ancestors 0, 1, 2, and 3.

    Example 2:
    Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
    Output: [[],[0],[0,1],[0,1,2],[0,1,2,3]]
    Explanation: The above diagram represents the input graph.
                 - Node 0 does not have any ancestor.
                 - Node 1 has one ancestor 0.
                 - Node 2 has two ancestors 0 and 1.
                 - Node 3 has three ancestors 0, 1, and 2.
                 - Node 4 has four ancestors 0, 1, 2, and 3.

    Constraints:
    * 1 <= n <= 1000
    * 0 <= edges.length <= min(2000, n * (n - 1) / 2)
    * edges[i].length == 2
    * 0 <= fromi, toi <= n - 1
    * fromi != toi
    * There are no duplicate edges.
    * The graph is directed and acyclic."""

    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        graph = [[] for _ in range(n)]
        rev = [[] for _ in range(n)]
        indeg = [0]*n
        for u, v in edges:
            graph[u].append(v)
            rev[v].append(u)
            indeg[v] += 1
        ans = [set() for _ in range(n)]
        queue = deque([u for u in range(n) if not indeg[u]])
        while queue:
            u = queue.popleft()
            for v in graph[u]:
                indeg[v] -= 1
                if indeg[v] == 0: queue.append(v)
            for v in rev[u]: ans[u] |= ans[v] | {v}
        return [sorted(x) for x in ans]


    """2193. Minimum Number of Moves to Make Palindrome (Hard)
    You are given a string s consisting only of lowercase English letters. In
    one move, you can select any two adjacent characters of s and swap them.
    Return the minimum number of moves needed to make s a palindrome. Note that
    the input will be generated such that s can always be converted to a
    palindrome.

    Example 1:
    Input: s = "aabb"
    Output: 2
    Explanation: We can obtain two palindromes from s, "abba" and "baab".
                 - We can obtain "abba" from s in 2 moves: "aabb" -> "abab" ->
                   "abba".
                 - We can obtain "baab" from s in 2 moves: "aabb" -> "abab" ->
                   "baab".
                 Thus, the minimum number of moves needed to make s a
                 palindrome is 2.

    Example 2:
    Input: s = "letelt"
    Output: 2
    Explanation: One of the palindromes we can obtain from s in 2 moves is
                 "lettel". One of the ways we can obtain it is "letelt" ->
                 "letetl" -> "lettel". Other palindromes such as "tleelt" can
                 also be obtained in 2 moves. It can be shown that it is not
                 possible to obtain a palindrome in less than 2 moves.

    Constraints:
    * 1 <= s.length <= 2000
    * s consists only of lowercase English letters.
    * s can be converted to a palindrome using a finite number of moves."""

    def minMovesToMakePalindrome(self, s: str) -> int:
        ans = 0
        while len(s) > 2:
            lo = s.find(s[-1])
            hi = s.rfind(s[0])
            if lo < len(s)-hi-1:
                ans += lo
                s = s[:lo] + s[lo+1:-1]
            else:
                ans += len(s)-hi-1
                s = s[1:hi] + s[hi+1:]
        return ans


    """2194. Cells in a Range on an Excel Sheet (Easy)
    A cell (r, c) of an excel sheet is represented as a string "<col><row>"
    where:
    * <col> denotes the column number c of the cell. It is represented by
      alphabetical letters.
      + For example, the 1st column is denoted by 'A', the 2nd by 'B', the 3rd
        by 'C', and so on.
    * <row> is the row number r of the cell. The rth row is represented by the
      integer r.
    You are given a string s in the format "<col1><row1>:<col2><row2>", where
    <col1> represents the column c1, <row1> represents the row r1, <col2>
    represents the column c2, and <row2> represents the row r2, such that
    r1 <= r2 and c1 <= c2. Return the list of cells (x, y) such that
    r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as strings
    in the format mentioned above and be sorted in non-decreasing order first
    by columns and then by rows.

    Example 1:
    Input: s = "K1:L2"
    Output: ["K1","K2","L1","L2"]
    Explanation: The above diagram shows the cells which should be present in
                 the list. The red arrows denote the order in which the cells
                 should be presented.

    Example 2:
    Input: s = "A1:F1"
    Output: ["A1","B1","C1","D1","E1","F1"]
    Explanation: The above diagram shows the cells which should be present in
                 the list. The red arrow denotes the order in which the cells
                 should be presented.

    Constraints:
    * s.length == 5
    * 'A' <= s[0] <= s[3] <= 'Z'
    * '1' <= s[1] <= s[4] <= '9'
    * s consists of uppercase English letters, digits and ':'."""

    def cellsInRange(self, s: str) -> List[str]:
        return [chr(c)+str(r) for c in range(ord(s[0]), ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]


    """2195. Append K Integers With Minimal Sum (Medium)
    You are given an integer array nums and an integer k. Append k unique
    positive integers that do not appear in nums to nums such that the
    resulting total sum is minimum. Return the sum of the k integers appended
    to nums.

    Example 1:
    Input: nums = [1,4,25,10,25], k = 2
    Output: 5
    Explanation: The two unique positive integers that do not appear in nums
                 which we append are 2 and 3. The resulting sum of nums is
                 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum. The
                 sum of the two integers appended is 2 + 3 = 5, so we return 5.

    Example 2:
    Input: nums = [5,6], k = 6
    Output: 25
    Explanation: The six unique positive integers that do not appear in nums
                 which we append are 1, 2, 3, 4, 7, and 8. The resulting sum of
                 nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the
                 minimum. The sum of the six integers appended is
                 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= 10^9"""

    def minimalKSum(self, nums: List[int], k: int) -> int:
        ans = k*(k+1)//2
        prev = -inf
        for x in sorted(nums):
            if prev < x:
                if x <= k:
                    k += 1
                    ans += k - x
                else: break
                prev = x
        return ans


    """2196. Create Binary Tree From Descriptions (Medium)
    You are given a 2D integer array descriptions where
    descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the
    parent of childi in a binary tree of unique values. Furthermore,
    * If isLefti == 1, then childi is the left child of parenti.
    * If isLefti == 0, then childi is the right child of parenti.
    Construct the binary tree described by descriptions and return its root.
    The test cases will be generated such that the binary tree is valid.

    Example 1:
    Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]
    Output: [50,20,80,15,17,19]
    Explanation: The root node is the node with value 50 since it has no parent.
                 The resulting binary tree is shown in the diagram.

    Example 2:
    Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]]
    Output: [1,2,null,null,3,4]
    Explanation: The root node is the node with value 1 since it has no parent.
                 The resulting binary tree is shown in the diagram.

    Constraints:
    * 1 <= descriptions.length <= 10^4
    * descriptions[i].length == 3
    * 1 <= parenti, childi <= 10^5
    * 0 <= isLefti <= 1
    * The binary tree described by descriptions is valid."""

    def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
        mp = {}
        child = set()
        for p, c, left in descriptions:
            mp.setdefault(p, TreeNode(p))
            mp.setdefault(c, TreeNode(c))
            if left: mp[p].left = mp[c]
            else: mp[p].right = mp[c]
            child.add(c)
        return mp[(set(mp) - child).pop()]


    """2197. Replace Non-Coprime Numbers in Array (Hard)
    You are given an array of integers nums. Perform the following steps:
    * Find any two adjacent numbers in nums that are non-coprime.
    * If no such numbers are found, stop the process.
    * Otherwise, delete the two numbers and replace them with their LCM (Least
      Common Multiple).
    * Repeat this process as long as you keep finding two adjacent non-coprime
      numbers.
    Return the final modified array. It can be shown that replacing adjacent
    non-coprime numbers in any arbitrary order will lead to the same result.
    The test cases are generated such that the values in the final array are
    less than or equal to 10^8. Two values x and y are non-coprime if
    GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y.

    Example 1:
    Input: nums = [6,4,3,2,7,6,2]
    Output: [12,7,6]
    Explanation: - (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [12,3,2,7,6,2].
                 - (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [12,2,7,6,2].
                 - (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [12,7,6,2].
                 - (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,6].
                 There are no more adjacent non-coprime numbers in nums. Thus,
                 the final modified array is [12,7,6]. Note that there are
                 other ways to obtain the same resultant array.

    Example 2:
    Input: nums = [2,2,1,1,3,3,3]
    Output: [2,1,1,3]
    Explanation: - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3,3].
                 - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3].
                 - (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [2,1,1,3].
                 There are no more adjacent non-coprime numbers in nums. Thus,
                 the final modified array is [2,1,1,3]. Note that there are
                 other ways to obtain the same resultant array.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * The test cases are generated such that the values in the final array are
      less than or equal to 10^8."""

    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        stack = []
        for x in nums:
            while stack and gcd(stack[-1], x) > 1: x = lcm(x, stack.pop())
            stack.append(x)
        return stack


    """2198. Number of Single Divisor Triplets (Medium)
    You are given a 0-indexed array of positive integers nums. A triplet of
    three distinct indices (i, j, k) is called a single divisor triplet of nums
    if nums[i] + nums[j] + nums[k] is divisible by exactly one of nums[i],
    nums[j], or nums[k]. Return the number of single divisor triplets of nums.

    Example 1:
    Input: nums = [4,6,7,3,2]
    Output: 12
    Explanation: The triplets (0, 3, 4), (0, 4, 3), (3, 0, 4), (3, 4, 0),
                 (4, 0, 3), and (4, 3, 0) have the values of [4, 3, 2] (or a
                 permutation of [4, 3, 2]). 4 + 3 + 2 = 9 which is only
                 divisible by 3, so all such triplets are single divisor
                 triplets. The triplets (0, 2, 3), (0, 3, 2), (2, 0, 3),
                 (2, 3, 0), (3, 0, 2), and (3, 2, 0) have the values of
                 [4, 7, 3] (or a permutation of [4, 7, 3]). 4 + 7 + 3 = 14
                 which is only divisible by 7, so all such triplets are single
                 divisor triplets. There are 12 single divisor triplets in
                 total.

    Example 2:
    Input: nums = [1,2,2]
    Output: 6
    Explanation: The triplets (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0),
                 (2, 0, 1), and (2, 1, 0) have the values of [1, 2, 2] (or a
                 permutation of [1, 2, 2]). 1 + 2 + 2 = 5 which is only
                 divisible by 1, so all such triplets are single divisor
                 triplets. There are 6 single divisor triplets in total.

    Example 3:
    Input: nums = [1,1,1]
    Output: 0
    Explanation: There are no single divisor triplets. Note that (0, 1, 2) is
                 not a single divisor triplet because
                 nums[0] + nums[1] + nums[2] = 3 and 3 is divisible by nums[0],
                 nums[1], and nums[2].

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 100"""

    def singleDivisorTriplet(self, nums: List[int]) -> int:
        freq = [0]*101
        for x in nums: freq[x] += 1
        ans = 0
        for i in range(1, 101):
            for j in range(i, 101):
                for k in range(j, 101):
                    if freq[i] and freq[j] and freq[k]:
                        sm = i + j + k
                        if bool(sm%i) + bool(sm%j) + bool(sm%k) == 2:
                            if i == j: ans += freq[i]*(freq[j]-1)//2*freq[k]
                            elif j == k: ans += freq[i]*freq[j]*(freq[k]-1)//2
                            else: ans += freq[i]*freq[j]*freq[k]
        return ans*6


    """2200. Find All K-Distant Indices in an Array (Easy)
    You are given a 0-indexed integer array nums and two integers key and k. A
    k-distant index is an index i of nums for which there exists at least one
    index j such that |i - j| <= k and nums[j] == key. Return a list of all
    k-distant indices sorted in increasing order.

    Example 1:
    Input: nums = [3,4,9,1,3,9,5], key = 9, k = 1
    Output: [1,2,3,4,5,6]
    Explanation: Here, nums[2] == key and nums[5] == key.
                 - For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j
                   where |0 - j| <= k and nums[j] == key. Thus, 0 is not a
                   k-distant index.
                 - For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a
                   k-distant index.
                 - For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a
                   k-distant index.
                 - For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a
                   k-distant index.
                 - For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a
                   k-distant index.
                 - For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a
                   k-distant index.
                 - For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a
                   k-distant index.
                 Thus, we return [1,2,3,4,5,6] which is sorted in increasing
                 order.

    Example 2:
    Input: nums = [2,2,2,2,2], key = 2, k = 2
    Output: [0,1,2,3,4]
    Explanation: For all indices i in nums, there exists some index j such that
                 |i - j| <= k and nums[j] == key, so every index is a k-distant
                 index. Hence, we return [0,1,2,3,4].

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000
    * key is an integer from the array nums.
    * 1 <= k <= nums.length"""

    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        ans = []
        ii = 0
        for i, x in enumerate(nums):
            if x == key:
                lo, hi = max(ii, i-k), min(i+k+1, len(nums))
                ans.extend(list(range(lo, hi)))
                ii = hi
        return ans


    """2201. Count Artifacts That Can Be Extracted (Medium)
    There is an n x n 0-indexed grid with some artifacts buried in it. You are
    given the integer n and a 0-indexed 2D integer array artifacts describing
    the positions of the rectangular artifacts where
    artifacts[i] = [r1i, c1i, r2i, c2i] denotes that the ith artifact is buried
    in the subgrid where:
    * (r1i, c1i) is the coordinate of the top-left cell of the ith artifact and
    * (r2i, c2i) is the coordinate of the bottom-right cell of the ith artifact.
    You will excavate some cells of the grid and remove all the mud from them.
    If the cell has a part of an artifact buried underneath, it will be
    uncovered. If all the parts of an artifact are uncovered, you can extract
    it. Given a 0-indexed 2D integer array dig where dig[i] = [ri, ci]
    indicates that you will excavate the cell (ri, ci), return the number of
    artifacts that you can extract. The test cases are generated such that:
    * No two artifacts overlap.
    * Each artifact only covers at most 4 cells.
    * The entries of dig are unique.

    Example 1:
    Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]
    Output: 1
    Explanation: The different colors represent different artifacts. Excavated
                 cells are labeled with a 'D' in the grid. There is 1 artifact
                 that can be extracted, namely the red artifact. The blue
                 artifact has one part in cell (1,1) which remains uncovered,
                 so we cannot extract it. Thus, we return 1.

    Example 2:
    Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]
    Output: 2
    Explanation: Both the red and blue artifacts have all parts uncovered
                 (labeled with a 'D') and can be extracted, so we return 2.

    Constraints:
    * 1 <= n <= 1000
    * 1 <= artifacts.length, dig.length <= min(n2, 105)
    * artifacts[i].length == 4
    * dig[i].length == 2
    * 0 <= r1i, c1i, r2i, c2i, ri, ci <= n - 1
    * r1i <= r2i
    * c1i <= c2i
    * No two artifacts will overlap.
    * The number of cells covered by an artifact is at most 4.
    * The entries of dig are unique."""

    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:
        dig = {(x, y) for x, y in dig}
        ans = 0
        for i1, j1, i2, j2 in artifacts:
            for i in range(i1, i2+1):
                for j in range(j1, j2+1):
                    if (i, j) not in dig: break
                else: continue
                break
            else: ans += 1
        return ans


    """2202. Maximize the Topmost Element After K Moves (Medium)
    You are given a 0-indexed integer array nums representing the contents of a
    pile, where nums[0] is the topmost element of the pile. In one move, you
    can perform either of the following:
    * If the pile is not empty, remove the topmost element of the pile.
    * If there are one or more removed elements, add any one of them back onto
      the pile. This element becomes the new topmost element.
    You are also given an integer k, which denotes the total number of moves to
    be made. Return the maximum value of the topmost element of the pile
    possible after exactly k moves. In case it is not possible to obtain a non-
    empty pile after k moves, return -1.

    Example 1:
    Input: nums = [5,2,2,4,0,6], k = 4
    Output: 5
    Explanation: One of the ways we can end with 5 at the top of the pile after
                 4 moves is as follows:
                 - Step 1: Remove the topmost element = 5. The pile becomes
                   [2,2,4,0,6].
                 - Step 2: Remove the topmost element = 2. The pile becomes
                   [2,4,0,6].
                 - Step 3: Remove the topmost element = 2. The pile becomes
                   [4,0,6].
                 - Step 4: Add 5 back onto the pile. The pile becomes [5,4,0,6].
                 Note that this is not the only way to end with 5 at the top of
                 the pile. It can be shown that 5 is the largest answer
                 possible after 4 moves.

    Example 2:
    Input: nums = [2], k = 1
    Output: -1
    Explanation: In the first move, our only option is to pop the topmost
                 element of the pile. Since it is not possible to obtain a non-
                 empty pile after one move, we return -1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i], k <= 10^9"""

    def maximumTop(self, nums: List[int], k: int) -> int:
        if len(nums) == 1 and k&1: return -1
        ans = 0
        for i in range(min(k-1, len(nums))): ans = max(ans, nums[i])
        if k < len(nums): ans = max(ans, nums[k])
        return ans


    """2203. Minimum Weighted Subgraph With the Required Paths (Hard)
    You are given an integer n denoting the number of nodes of a weighted
    directed graph. The nodes are numbered from 0 to n - 1. You are also given
    a 2D integer array edges where edges[i] = [fromi, toi, weighti] denotes
    that there exists a directed edge from fromi to toi with weight weighti.
    Lastly, you are given three distinct integers src1, src2, and dest denoting
    three distinct nodes of the graph. Return the minimum weight of a subgraph
    of the graph such that it is possible to reach dest from both src1 and src2
    via a set of edges of this subgraph. In case such a subgraph does not exist,
    return -1. A subgraph is a graph whose vertices and edges are subsets of
    the original graph. The weight of a subgraph is the sum of weights of its
    constituent edges.

    Example 1:
    Input: n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5
    Output: 9
    Explanation: The above figure represents the input graph. The blue edges
                 represent one of the subgraphs that yield the optimal answer.
                 Note that the subgraph [[1,0,3],[0,5,6]] also yields the
                 optimal answer. It is not possible to get a subgraph with less
                 weight satisfying all the constraints.

    Example 2:
    Input: n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2
    Output: -1
    Explanation: The above figure represents the input graph. It can be seen
                 that there does not exist any path from node 1 to node 2,
                 hence there are no subgraphs satisfying all the constraints.
    Constraints:
    * 3 <= n <= 10^5
    * 0 <= edges.length <= 10^5
    * edges[i].length == 3
    * 0 <= fromi, toi, src1, src2, dest <= n - 1
    * fromi != toi
    * src1, src2, and dest are pairwise distinct.
    * 1 <= weight[i] <= 10^5"""

    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:
        graph = [[] for _ in range(n)]
        trans = [[] for _ in range(n)]
        for u, v, w in edges:
            graph[u].append((v, w))
            trans[v].append((u, w))

        def bfs(x, graph):
            dist = [inf] * n
            dist[x] = 0
            queue = deque([(x, 0)])
            while queue:
                u, w = queue.popleft()
                if dist[u] == w:
                    for v, ww in graph[u]:
                        if w+ww < dist[v]:
                            dist[v] = w+ww
                            queue.append((v, w+ww))
            return dist

        ds1 = bfs(src1, graph)
        ds2 = bfs(src2, graph)
        dd = bfs(dest, trans)

        ans = min(x+y+z for x, y, z in zip(ds1, ds2, dd))
        return ans if ans < inf else -1


    """2204. Distance to a Cycle in Undirected Graph (Hard)
    You are given a positive integer n representing the number of nodes in a
    connected undirected graph containing exactly one cycle. The nodes are
    numbered from 0 to n - 1 (inclusive). You are also given a 2D integer array
    edges, where edges[i] = [node1i, node2i] denotes that there is a
    bidirectional edge connecting node1i and node2i in the graph. The distance
    between two nodes a and b is defined to be the minimum number of edges that
    are needed to go from a to b. Return an integer array answer of size n,
    where answer[i] is the minimum distance between the ith node and any node
    in the cycle.

    Example 1:
    Input: n = 7, edges = [[1,2],[2,4],[4,3],[3,1],[0,1],[5,2],[6,5]]
    Output: [1,0,0,0,0,1,2]
    Explanation: The nodes 1, 2, 3, and 4 form the cycle.
                 The distance from 0 to 1 is 1.
                 The distance from 1 to 1 is 0.
                 The distance from 2 to 2 is 0.
                 The distance from 3 to 3 is 0.
                 The distance from 4 to 4 is 0.
                 The distance from 5 to 2 is 1.
                 The distance from 6 to 2 is 2.

    Example 2:
    Input: n = 9, edges = [[0,1],[1,2],[0,2],[2,6],[6,7],[6,8],[0,3],[3,4],[3,5]]
    Output: [0,0,0,1,2,2,1,2,2]
    Explanation: The nodes 0, 1, and 2 form the cycle.
                 The distance from 0 to 0 is 0.
                 The distance from 1 to 1 is 0.
                 The distance from 2 to 2 is 0.
                 The distance from 3 to 1 is 1.
                 The distance from 4 to 1 is 2.
                 The distance from 5 to 1 is 2.
                 The distance from 6 to 2 is 1.
                 The distance from 7 to 2 is 2.
                 The distance from 8 to 2 is 2.

    Constraints:
    * 3 <= n <= 10^5
    * edges.length == n
    * edges[i].length == 2
    * 0 <= node1i, node2i <= n - 1
    * node1i != node2i
    * The graph is connected.
    * The graph has exactly one cycle.
    * There is at most one edge between any pair of vertices."""

    def distanceToCycle(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        stack = []
        degree = [0]*n
        for u in range(n):
            degree[u] = len(graph[u])
            if degree[u] == 1: stack.append(u)
        while stack:
            u = stack.pop()
            for v in graph[u]:
                if degree[v] > 1:
                    degree[v] -= 1
                    if degree[v] == 1: stack.append(v)
        ans = [-1]*n
        queue = deque()
        for u in range(n):
            if degree[u] > 1:
                queue.append(u)
                ans[u] = 0
        val = 0
        while queue:
            val += 1
            for _ in range(len(queue)):
                u = queue.popleft()
                for v in graph[u]:
                    if ans[v] == -1:
                        ans[v] = val
                        queue.append(v)
        return ans


    """2206. Divide Array Into Equal Pairs (Easy)
    You are given an integer array nums consisting of 2 * n integers. You need
    to divide nums into n pairs such that:
    * Each element belongs to exactly one pair.
    * The elements present in a pair are equal.
    Return true if nums can be divided into n pairs, otherwise return false.

    Example 1:
    Input: nums = [3,2,3,2,2,2]
    Output: true
    Explanation: There are 6 elements in nums, so they should be divided into
                 6 / 2 = 3 pairs. If nums is divided into the pairs (2, 2),
                 (3, 3), and (2, 2), it will satisfy all the conditions.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: false
    Explanation: There is no way to divide nums into 4 / 2 = 2 pairs such that
                 the pairs satisfy every condition.

    Constraints:
    * nums.length == 2 * n
    * 1 <= n <= 500
    * 1 <= nums[i] <= 500"""

    def divideArray(self, nums: List[int]) -> bool:
        return all(x & 1 == 0 for x in Counter(nums).values())


    """2207. Maximize Number of Subsequences in a String (Medium)
    You are given a 0-indexed string text and another 0-indexed string pattern
    of length 2, both of which consist of only lowercase English letters. You
    can add either pattern[0] or pattern[1] anywhere in text exactly once. Note
    that the character can be added even at the beginning or at the end of text.
    Return the maximum number of times pattern can occur as a subsequence of
    the modified text. A subsequence is a string that can be derived from
    another string by deleting some or no characters without changing the order
    of the remaining characters.

    Example 1:
    Input: text = "abdcdbc", pattern = "ac"
    Output: 4
    Explanation: If we add pattern[0] = 'a' in between text[1] and text[2], we
                 get "abadcdbc". Now, the number of times "ac" occurs as a
                 subsequence is 4. Some other strings which have 4 subsequences
                 "ac" after adding a character to text are "aabdcdbc" and
                 "abdacdbc". However, strings such as "abdcadbc", "abdccdbc",
                 and "abdcdbcc", although obtainable, have only 3 subsequences
                 "ac" and are thus suboptimal. It can be shown that it is not
                 possible to get more than 4 subsequences "ac" by adding only
                 one character.

    Example 2:
    Input: text = "aabb", pattern = "ab"
    Output: 6
    Explanation: Some of the strings which can be obtained from text and have 6
                 subsequences "ab" are "aaabb", "aaabb", and "aabbb".

    Constraints:
    * 1 <= text.length <= 10^5
    * pattern.length == 2
    * text and pattern consist only of lowercase English letters."""

    def maximumSubsequenceCount(self, text: str, pattern: str) -> int:
        ans = cnt0 = cnt1 = 0
        for ch in text:
            if ch == pattern[1]:
                ans += cnt0
                cnt1 += 1
            if ch == pattern[0]: cnt0 += 1
        return ans + max(cnt0, cnt1)


    """2208. Minimum Operations to Halve Array Sum (Medium)
    You are given an array nums of positive integers. In one operation, you can
    choose any number from nums and reduce it to exactly half the number. (Note
    that you may choose this reduced number in future operations.) Return the
    minimum number of operations to reduce the sum of nums by at least half.

    Example 1:
    Input: nums = [5,19,8,1]
    Output: 3
    Explanation: The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33. The
                 following is one of the ways to reduce the sum by at least
                 half:
                 * Pick the number 19 and reduce it to 9.5.
                 * Pick the number 9.5 and reduce it to 4.75.
                 * Pick the number 8 and reduce it to 4.
                 The final array is [5, 4.75, 4, 1] with a total sum of
                 5 + 4.75 + 4 + 1 = 14.75. The sum of nums has been reduced by
                 33 - 14.75 = 18.25, which is at least half of the initial sum,
                 18.25 >= 33/2 = 16.5. Overall, 3 operations were used so we
                 return 3. It can be shown that we cannot reduce the sum by at
                 least half in less than 3 operations.

    Example 2:
    Input: nums = [3,8,20]
    Output: 3
    Explanation: The initial sum of nums is equal to 3 + 8 + 20 = 31. The
                 following is one of the ways to reduce the sum by at least
                 half:
                 * Pick the number 20 and reduce it to 10.
                 * Pick the number 10 and reduce it to 5.
                 * Pick the number 3 and reduce it to 1.5.
                 The final array is [1.5, 8, 5] with a total sum of
                 1.5 + 8 + 5 = 14.5. The sum of nums has been reduced by
                 31 - 14.5 = 16.5, which is at least half of the initial sum,
                 16.5 >= 31/2 = 16.5. Overall, 3 operations were used so we
                 return 3. It can be shown that we cannot reduce the sum by at
                 least half in less than 3 operations.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^7"""

    def halveArray(self, nums: List[int]) -> int:
        pq = [-x for x in nums]
        heapify(pq)
        sm = ss = sum(nums)
        ans = 0
        while sm > ss/2:
            ans += 1
            x = heappop(pq)
            sm -= -x/2
            heappush(pq, x/2)
        return ans


    """2209. Minimum White Tiles After Covering With Carpets (Hard)
    You are given a 0-indexed binary string floor, which represents the colors
    of tiles on a floor:
    * floor[i] = '0' denotes that the ith tile of the floor is colored black.
    * On the other hand, floor[i] = '1' denotes that the ith tile of the floor
      is colored white.
    You are also given numCarpets and carpetLen. You have numCarpets black
    carpets, each of length carpetLen tiles. Cover the tiles with the given
    carpets such that the number of white tiles still visible is minimum.
    Carpets may overlap one another. Return the minimum number of white tiles
    still visible.

    Example 1:
    Input: floor = "10110101", numCarpets = 2, carpetLen = 2
    Output: 2
    Explanation: The figure above shows one way of covering the tiles with the
                 carpets such that only 2 white tiles are visible. No other way
                 of covering the tiles with the carpets can leave less than 2
                 white tiles visible.

    Example 2:
    Input: floor = "11111", numCarpets = 2, carpetLen = 3
    Output: 0
    Explanation: The figure above shows one way of covering the tiles with the
                 carpets such that no white tiles are visible. Note that the
                 carpets are able to overlap one another.

    Constraints:
    * 1 <= carpetLen <= floor.length <= 1000
    * floor[i] is either '0' or '1'.
    * 1 <= numCarpets <= 1000"""

    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:

        @cache
        def fn(i, n):
            """Return min while tiles at k with n carpets left."""
            if n < 0: return inf
            if i >= len(floor): return 0
            if floor[i] == '1': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))
            return fn(i+1, n)

        return fn(0, numCarpets)


    """2214. Minimum Health to Beat Game (Medium)
    You are playing a game that has n levels numbered from 0 to n - 1. You are
    given a 0-indexed integer array damage where damage[i] is the amount of
    health you will lose to complete the ith level. You are also given an
    integer armor. You may use your armor ability at most once during the game
    on any level which will protect you from at most armor damage. You must
    complete the levels in order and your health must be greater than 0 at all
    times to beat the game. Return the minimum health you need to start with to
    beat the game.

    Example 1:
    Input: damage = [2,7,4,3], armor = 4
    Output: 13
    Explanation: One optimal way to beat the game starting at 13 health is:
                 On round 1, take 2 damage. You have 13 - 2 = 11 health.
                 On round 2, take 7 damage. You have 11 - 7 = 4 health.
                 On round 3, use your armor to protect you from 4 damage. You
                             have 4 - 0 = 4 health.
                 On round 4, take 3 damage. You have 4 - 3 = 1 health.
                 Note that 13 is the minimum health you need to start with to
                 beat the game.

    Example 2:
    Input: damage = [2,5,3,4], armor = 7
    Output: 10
    Explanation: One optimal way to beat the game starting at 10 health is:
                 On round 1, take 2 damage. You have 10 - 2 = 8 health.
                 On round 2, use your armor to protect you from 5 damage. You
                             have 8 - 0 = 8 health.
                 On round 3, take 3 damage. You have 8 - 3 = 5 health.
                 On round 4, take 4 damage. You have 5 - 4 = 1 health.
                 Note that 10 is the minimum health you need to start with to
                 beat the game.

    Example 3:
    Input: damage = [3,3,3], armor = 0
    Output: 10
    Explanation: One optimal way to beat the game starting at 10 health is:
                 On round 1, take 3 damage. You have 10 - 3 = 7 health.
                 On round 2, take 3 damage. You have 7 - 3 = 4 health.
                 On round 3, take 3 damage. You have 4 - 3 = 1 health.
                 Note that you did not use your armor ability.

    Constraints:
    * n == damage.length
    * 1 <= n <= 10^5
    * 0 <= damage[i] <= 10^5
    * 0 <= armor <= 10^5"""

    def minimumHealth(self, damage: List[int], armor: int) -> int:
        return 1 + sum(damage) - min(max(damage), armor)


    """2215. Find the Difference of Two Arrays (Easy)
    Given two 0-indexed integer arrays nums1 and nums2, return a list answer of
    size 2 where:
    * answer[0] is a list of all distinct integers in nums1 which are not
      present in nums2.
    * answer[1] is a list of all distinct integers in nums2 which are not
      present in nums1.
    Note that the integers in the lists may be returned in any order.

    Example 1:
    Input: nums1 = [1,2,3], nums2 = [2,4,6]
    Output: [[1,3],[4,6]]
    Explanation: For nums1, nums1[1] = 2 is present at index 0 of nums2,
                 whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2.
                 Therefore, answer[0] = [1,3]. For nums2, nums2[0] = 2 is
                 present at index 1 of nums1, whereas nums2[1] = 4 and
                 nums2[2] = 6 are not present in nums2. Therefore,
                 answer[1] = [4,6].

    Example 2:
    Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2]
    Output: [[3],[]]
    Explanation: For nums1, nums1[2] and nums1[3] are not present in nums2.
                 Since nums1[2] == nums1[3], their value is only included once
                 and answer[0] = [3]. Every integer in nums2 is present in
                 nums1. Therefore, answer[1] = [].

    Constraints:
    * 1 <= nums1.length, nums2.length <= 1000
    * -1000 <= nums1[i], nums2[i] <= 1000"""

    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        s1, s2 = set(nums1), set(nums2)
        return [s1-s2, s2-s1]


    """2216. Minimum Deletions to Make Array Beautiful (Medium)
    You are given a 0-indexed integer array nums. The array nums is beautiful
    if:
    * nums.length is even.
    * nums[i] != nums[i + 1] for all i % 2 == 0.
    Note that an empty array is considered beautiful. You can delete any number
    of elements from nums. When you delete an element, all the elements to the
    right of the deleted element will be shifted one unit to the left to fill
    the gap created and all the elements to the left of the deleted element
    will remain unchanged. Return the minimum number of elements to delete from
    nums to make it beautiful.

    Example 1:
    Input: nums = [1,1,2,3,5]
    Output: 1
    Explanation: You can delete either nums[0] or nums[1] to make
                 nums = [1,2,3,5] which is beautiful. It can be proven you need
                 at least 1 deletion to make nums beautiful.

    Example 2:
    Input: nums = [1,1,2,2,3,3]
    Output: 2
    Explanation: You can delete nums[0] and nums[5] to make nums = [1,2,2,3]
                 which is beautiful. It can be proven you need at least 2
                 deletions to make nums beautiful.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5"""

    def minDeletion(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums)-1):
            if nums[i] == nums[i+1] and (i-ans) % 2 == 0: ans += 1
        return ans + (len(nums)-ans) % 2


    """2217. Find Palindrome With Fixed Length (Medium)
    Given an integer array queries and a positive integer intLength, return an
    array answer where answer[i] is either the queries[i]th smallest positive
    palindrome of length intLength or -1 if no such palindrome exists. A
    palindrome is a number that reads the same backwards and forwards.
    Palindromes cannot have leading zeros.

    Example 1:
    Input: queries = [1,2,3,4,5,90], intLength = 3
    Output: [101,111,121,131,141,999]
    Explanation: The first few palindromes of length 3 are:
                 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...
                 The 90th palindrome of length 3 is 999.

    Example 2:
    Input: queries = [2,4,6], intLength = 4
    Output: [1111,1331,1551]
    Explanation: The first six palindromes of length 4 are:
                 1001, 1111, 1221, 1331, 1441, and 1551.

    Constraints:
    * 1 <= queries.length <= 5 * 10^4
    * 1 <= queries[i] <= 10^9
    * 1 <= intLength <= 15"""

    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:
        ans = []
        end = -1 if intLength&1 else None
        lo, hi = 10**((intLength-1)//2), 10**((intLength+1)//2)
        for q in queries:
            if lo + q - 1 < hi:
                x = lo + q - 1
                ans.append(int(str(x) + str(x)[:end][::-1]))
            else: ans.append(-1)
        return ans


    """2218. Maximum Value of K Coins From Piles (Hard)
    There are n piles of coins on a table. Each pile consists of a positive
    number of coins of assorted denominations. In one move, you can choose any
    coin on top of any pile, remove it, and add it to your wallet. Given a list
    piles, where piles[i] is a list of integers denoting the composition of the
    ith pile from top to bottom, and a positive integer k, return the maximum
    total value of coins you can have in your wallet if you choose exactly k
    coins optimally.

    Example 1:
    Input: piles = [[1,100,3],[7,8,9]], k = 2
    Output: 101
    Explanation: The above diagram shows the different ways we can choose k
                 coins. The maximum total we can obtain is 101.

    Example 2:
    Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7
    Output: 706
    Explanation: The maximum total can be obtained if we choose all coins from
                 the last pile.

    Constraints:
    * n == piles.length
    * 1 <= n <= 1000
    * 1 <= piles[i][j] <= 10^5
    * 1 <= k <= sum(piles[i].length) <= 2000"""

    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:

        @cache
        def fn(i, k):
            """Return max value to pick k coins from piles[i:]."""
            if i == len(piles) or k == 0: return 0
            ans = fn(i+1, k)
            prefix = 0
            for j in range(min(k, len(piles[i]))):
                prefix += piles[i][j]
                ans = max(ans, prefix + fn(i+1, k-j-1))
            return ans

        return fn(0, k)


    """2219. Maximum Sum Score of Array (Medium)
    You are given a 0-indexed integer array nums of length n. The sum score of
    nums at an index i where 0 <= i < n is the maximum of:
    * The sum of the first i + 1 elements of nums.
    * The sum of the last n - i elements of nums.
    Return the maximum sum score of nums at any index.

    Example 1:
    Input: nums = [4,3,-2,5]
    Output: 10
    Explanation: The sum score at index 0 is max(4, 4 + 3 + -2 + 5) = max(4, 10) = 10.
                 The sum score at index 1 is max(4 + 3, 3 + -2 + 5) = max(7, 6) = 7.
                 The sum score at index 2 is max(4 + 3 + -2, -2 + 5) = max(5, 3) = 5.
                 The sum score at index 3 is max(4 + 3 + -2 + 5, 5) = max(10, 5) = 10.
                 The maximum sum score of nums is 10.

    Example 2:
    Input: nums = [-3,-5]
    Output: -3
    Explanation: The sum score at index 0 is max(-3, -3 + -5) = max(-3, -8) = -3.
                 The sum score at index 1 is max(-3 + -5, -5) = max(-8, -5) = -5.
                 The maximum sum score of nums is -3.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * -10^5 <= nums[i] <= 10^5"""

    def maximumSumScore(self, nums: List[int]) -> int:
        prefix = 0
        suffix = sum(nums)
        ans = -inf
        for i, x in enumerate(nums):
            prefix += x
            ans = max(ans, prefix, suffix)
            suffix -= x
        return ans


    """2220. Minimum Bit Flips to Convert Number (Easy)
    A bit flip of a number x is choosing a bit in the binary representation of
    x and flipping it from either 0 to 1 or 1 to 0.
    * For example, for x = 7, the binary representation is 111 and we may
      choose any bit (including any leading zeros not shown) and flip it. We
      can flip the first bit from the right to get 110, flip the second bit
      from the right to get 101, flip the fifth bit from the right (a leading
      zero) to get 10111, etc.
    Given two integers start and goal, return the minimum number of bit flips
    to convert start to goal.

    Example 1:
    Input: start = 10, goal = 7
    Output: 3
    Explanation: The binary representation of 10 and 7 are 1010 and 0111
                 respectively. We can convert 10 to 7 in 3 steps:
                 - Flip the first bit from the right: 1010 -> 1011.
                 - Flip the third bit from the right: 1011 -> 1111.
                 - Flip the fourth bit from the right: 1111 -> 0111.
                 It can be shown we cannot convert 10 to 7 in less than 3 steps.
                 Hence, we return 3.

    Example 2:
    Input: start = 3, goal = 4
    Output: 3
    Explanation: The binary representation of 3 and 4 are 011 and 100
                 respectively. We can convert 3 to 4 in 3 steps:
                 - Flip the first bit from the right: 011 -> 010.
                 - Flip the second bit from the right: 010 -> 000.
                 - Flip the third bit from the right: 000 -> 100.
                 It can be shown we cannot convert 3 to 4 in less than 3 steps.
                 Hence, we return 3.

    Constraints: 0 <= start, goal <= 10^9"""

    def minBitFlips(self, start: int, goal: int) -> int:
        return (start ^ goal).bit_count()


    """2221. Find Triangular Sum of an Array (Medium)
    You are given a 0-indexed integer array nums, where nums[i] is a digit
    between 0 and 9 (inclusive). The triangular sum of nums is the value of the
    only element present in nums after the following process terminates:
    * Let nums comprise of n elements. If n == 1, end the process. Otherwise,
      create a new 0-indexed integer array newNums of length n - 1.
    * For each index i, where 0 <= i < n - 1, assign the value of newNums[i] as
      (nums[i] + nums[i+1]) % 10, where % denotes modulo operator.
    * Replace the array nums with newNums.
    * Repeat the entire process starting from step 1.
    Return the triangular sum of nums.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 8
    Explanation: The above diagram depicts the process from which we obtain the
                 triangular sum of the array.

    Example 2:
    Input: nums = [5]
    Output: 5
    Explanation: Since there is only one element in nums, the triangular sum is
                 the value of that element itself.

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 9"""

    def triangularSum(self, nums: List[int]) -> int:
        comb = [1]
        for i in range(len(nums)-1):
            comb.append(comb[-1]*(len(nums)-1-i)//(i+1))
        return sum(x*y for x, y in zip(nums, comb)) % 10


    """2222. Number of Ways to Select Buildings (Medium)
    You are given a 0-indexed binary string s which represents the types of
    buildings along a street where:
    * s[i] = '0' denotes that the ith building is an office and
    * s[i] = '1' denotes that the ith building is a restaurant.
    As a city official, you would like to select 3 buildings for random
    inspection. However, to ensure variety, no two consecutive buildings out of
    the selected buildings can be of the same type.
    * For example, given s = "001101", we cannot select the 1st, 3rd, and 5th
      buildings as that would form "011" which is not allowed due to having two
      consecutive buildings of the same type.
    Return the number of valid ways to select 3 buildings.

    Example 1:
    Input: s = "001101"
    Output: 6
    Explanation: The following sets of indices selected are valid:
                 - [0,2,4] from "001101" forms "010"
                 - [0,3,4] from "001101" forms "010"
                 - [1,2,4] from "001101" forms "010"
                 - [1,3,4] from "001101" forms "010"
                 - [2,4,5] from "001101" forms "101"
                 - [3,4,5] from "001101" forms "101"
                 No other selection is valid. Thus, there are 6 total ways.

    Example 2:
    Input: s = "11100"
    Output: 0
    Explanation: It can be shown that there are no valid selections.

    Constraints:
    * 3 <= s.length <= 10^5
    * s[i] is either '0' or '1'."""

    def numberOfWays(self, s: str) -> int:
        ans = n0 = n1 = n01 = n10 = 0
        for ch in s:
            if ch == '0':
                ans += n01
                n10 += n1
                n0 += 1
            else:
                ans += n10
                n01 += n0
                n1 += 1
        return ans


    """2223. Sum of Scores of Built Strings (Hard)
    You are building a string s of length n one character at a time, prepending
    each new character to the front of the string. The strings are labeled from
    1 to n, where the string with length i is labeled si.
    * For example, for s = "abaca", s1 == "a", s2 == "ca", s3 == "aca", etc.
    The score of si is the length of the longest common prefix between si and
    sn (Note that s == sn). Given the final string s, return the sum of the
    score of every si.

    Example 1:
    Input: s = "babab"
    Output: 9
    Explanation: For s1 == "b", the longest common prefix is "b" which has a
                 score of 1. For s2 == "ab", there is no common prefix so the
                 score is 0. For s3 == "bab", the longest common prefix is "bab"
                 which has a score of 3. For s4 == "abab", there is no common
                 prefix so the score is 0. For s5 == "babab", the longest
                 common prefix is "babab" which has a score of 5. The sum of
                 the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9.

    Example 2:
    Input: s = "azbazbzaz"
    Output: 14
    Explanation: For s2 == "az", the longest common prefix is "az" which has a
                 score of 2. For s6 == "azbzaz", the longest common prefix is
                 "azb" which has a score of 3. For s9 == "azbazbzaz", the
                 longest common prefix is "azbazbzaz" which has a score of 9.
                 For all other si, the score is 0. The sum of the scores is
                 2 + 3 + 9 = 14, so we return 14.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters."""

    def sumScores(self, s: str) -> int:
        ans = [0] * len(s)
        lo = hi = ii = 0
        for i in range(1, len(s)):
            if i <= hi: ii = i - lo
            if i + ans[ii] <= hi: ans[i] = ans[ii]
            else:
                lo, hi = i, max(hi, i)
                while hi < len(s) and s[hi] == s[hi - lo]: hi += 1
                ans[i] = hi - lo
                hi -= 1
        return sum(ans) + len(s)


    """2224. Minimum Number of Operations to Convert Time (Easy)
    You are given two strings current and correct representing two 24-hour
    times. 24-hour times are formatted as "HH:MM", where HH is between 00 and
    23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and
    the latest is 23:59. In one operation you can increase the time current by
    1, 5, 15, or 60 minutes. You can perform this operation any number of times.
    Return the minimum number of operations needed to convert current to
    correct.

    Example 1:
    Input: current = "02:30", correct = "04:35"
    Output: 3
    Explanation: We can convert current to correct in 3 operations as follows:
                 - Add 60 minutes to current. current becomes "03:30".
                 - Add 60 minutes to current. current becomes "04:30".
                 - Add 5 minutes to current. current becomes "04:35".
                 It can be proven that it is not possible to convert current to
                 correct in fewer than 3 operations.

    Example 2:
    Input: current = "11:00", correct = "11:01"
    Output: 1
    Explanation: We only have to add one minute to current, so the minimum
                 number of operations needed is 1.

    Constraints:
    * current and correct are in the format "HH:MM"
    * current <= correct"""

    def convertTime(self, current: str, correct: str) -> int:
        fn = lambda x, y: 60*x + y
        m0 = fn(*map(int, current.split(':')))
        m1 = fn(*map(int, correct.split(':')))
        ans = 0
        diff = m1 - m0
        for x in 60, 15, 5, 1:
            ans += diff // x
            diff %= x
        return ans


    """2225. Find Players With Zero or One Losses (Medium)
    You are given an integer array matches where matches[i] = [winneri, loseri]
    indicates that the player winneri defeated player loseri in a match. Return
    a list answer of size 2 where:
    * answer[0] is a list of all players that have not lost any matches.
    * answer[1] is a list of all players that have lost exactly one match.
    The values in the two lists should be returned in increasing order.

    Note:
    * You should only consider the players that have played at least one match.
    * The testcases will be generated such that no two matches will have the
      same outcome.

    Example 1:
    Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]
    Output: [[1,2,10],[4,5,7,8]]
    Explanation: Players 1, 2, and 10 have not lost any matches.
                 Players 4, 5, 7, and 8 each have lost one match.
                 Players 3, 6, and 9 each have lost two matches.
                 Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].

    Example 2:
    Input: matches = [[2,3],[1,3],[5,4],[6,4]]
    Output: [[1,2,5,6],[]]
    Explanation: Players 1, 2, 5, and 6 have not lost any matches.
                 Players 3 and 4 each have lost two matches.
                 Thus, answer[0] = [1,2,5,6] and answer[1] = [].

    Constraints:
    * 1 <= matches.length <= 10^5
    * matches[i].length == 2
    * 1 <= winneri, loseri <= 10^5
    * winneri != loseri
    * All matches[i] are unique."""

    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        freq = Counter()
        for x, y in matches:
            if x not in freq: freq[x] = 0
            freq[y] += 1
        return [sorted(k for k, v in freq.items() if v == 0), sorted(k for k, v in freq.items() if v == 1)]


    """2226. Maximum Candies Allocated to K Children (Medium)
    You are given a 0-indexed integer array candies. Each element in the array
    denotes a pile of candies of size candies[i]. You can divide each pile into
    any number of sub piles, but you cannot merge two piles together. You are
    also given an integer k. You should allocate piles of candies to k children
    such that each child gets the same number of candies. Each child can take
    at most one pile of candies and some piles of candies may go unused. Return
    the maximum number of candies each child can get.

    Example 1:
    Input: candies = [5,8,6], k = 3
    Output: 5
    Explanation: We can divide candies[1] into 2 piles of size 5 and 3, and
                 candies[2] into 2 piles of size 5 and 1. We now have five
                 piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate
                 the 3 piles of size 5 to 3 children. It can be proven that
                 each child cannot receive more than 5 candies.

    Example 2:
    Input: candies = [2,5], k = 11
    Output: 0
    Explanation: There are 11 children but only 7 candies in total, so it is
                 impossible to ensure each child receives at least one candy.
                 Thus, each child gets no candy and the answer is 0.

    Constraints:
    * 1 <= candies.length <= 10^5
    * 1 <= candies[i] <= 10^7
    * 1 <= k <= 10^12"""

    def maximumCandies(self, candies: List[int], k: int) -> int:
        lo, hi = 0, sum(candies)//k
        while lo < hi:
            mid = lo + hi + 1 >> 1
            if sum(x//mid for x in candies) >= k: lo = mid
            else: hi = mid - 1
        return lo


    """2229. Check if an Array Is Consecutive (Easy)
    Given an integer array nums, return true if nums is consecutive, otherwise
    return false. An array is consecutive if it contains every number in the
    range [x, x + n - 1] (inclusive), where x is the minimum number in the
    array and n is the length of the array.

    Example 1:
    Input: nums = [1,3,4,2]
    Output: true
    Explanation: The minimum value is 1 and the length of nums is 4. All of the
                 values in the range [x, x + n - 1] = [1, 1 + 4 - 1] = [1, 4]
                 = (1, 2, 3, 4) occur in nums. Therefore, nums is consecutive.

    Example 2:
    Input: nums = [1,3]
    Output: false
    Explanation: The minimum value is 1 and the length of nums is 2. The value
                 2 in the range [x, x + n - 1] = [1, 1 + 2 - 1], = [1, 2]
                 = (1, 2) does not occur in nums. Therefore, nums is not
                 consecutive.

    Example 3:
    Input: nums = [3,5,4]
    Output: true
    Explanation: The minimum value is 3 and the length of nums is 3. All of the
                 values in the range [x, x + n - 1] = [3, 3 + 3 - 1] = [3, 5]
                 = (3, 4, 5) occur in nums. Therefore, nums is consecutive.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5"""

    def isConsecutive(self, nums: List[int]) -> bool:
        return max(nums)-min(nums)+1 == len(nums) == len(set(nums))


    """2231. Largest Number After Digit Swaps by Parity (Easy)
    You are given a positive integer num. You may swap any two digits of num
    that have the same parity (i.e. both odd digits or both even digits).
    Return the largest possible value of num after any number of swaps.

    Example 1:
    Input: num = 1234
    Output: 3412
    Explanation: Swap the digit 3 with the digit 1, this results in the number
                 3214. Swap the digit 2 with the digit 4, this results in the
                 number 3412. Note that there may be other sequences of swaps
                 but it can be shown that 3412 is the largest possible number.
                 Also note that we may not swap the digit 4 with the digit 1
                 since they are of different parities.

    Example 2:
    Input: num = 65875
    Output: 87655
    Explanation: Swap the digit 8 with the digit 6, this results in the number
                 85675. Swap the first digit 5 with the digit 7, this results
                 in the number 87655. Note that there may be other sequences of
                 swaps but it can be shown that 87655 is the largest possible
                 number.

    Constraints: 1 <= num <= 10^9"""

    def largestInteger(self, num: int) -> int:
        odd = []
        even = []
        for x in map(int, str(num)):
            if x & 1: odd.append(x)
            else: even.append(x)
        odd.sort()
        even.sort()
        ans = 0
        for x in map(int, str(num)):
            if x & 1: ans = 10*ans + odd.pop()
            else: ans = 10*ans + even.pop()
        return ans


    """2232. Minimize Result by Adding Parentheses to Expression (Medium)
    You are given a 0-indexed string expression of the form "<num1>+<num2>"
    where <num1> and <num2> represent positive integers. Add a pair of
    parentheses to expression such that after the addition of parentheses,
    expression is a valid mathematical expression and evaluates to the smallest
    possible value. The left parenthesis must be added to the left of '+' and
    the right parenthesis must be added to the right of '+'. Return expression
    after adding a pair of parentheses such that expression evaluates to the
    smallest possible value. If there are multiple answers that yield the same
    result, return any of them. The input has been generated such that the
    original value of expression, and the value of expression after adding any
    pair of parentheses that meets the requirements fits within a signed 32-bit
    integer.

    Example 1:
    Input: expression = "247+38"
    Output: "2(47+38)"
    Explanation: The expression evaluates to 2 * (47 + 38) = 2 * 85 = 170. Note
                 that "2(4)7+38" is invalid because the right parenthesis must
                 be to the right of the '+'. It can be shown that 170 is the
                 smallest possible value.

    Example 2:
    Input: expression = "12+34"
    Output: "1(2+3)4"
    Explanation: The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20.

    Example 3:
    Input: expression = "999+999"
    Output: "(999+999)"
    Explanation: The expression evaluates to 999 + 999 = 1998.

    Constraints:
    * 3 <= expression.length <= 10
    * expression consists of digits from '1' to '9' and '+'.
    * expression starts and ends with digits.
    * expression contains exactly one '+'.
    * The original value of expression, and the value of expression after
      adding any pair of parentheses that meets the requirements fits within a
      signed 32-bit integer."""

    def minimizeResult(self, expression: str) -> str:
        k = expression.find('+')
        ans = "inf"
        for i in range(k):
            for j in range(k+1, len(expression)):
                cand = f'{expression[:i]}({expression[i:k]}+{expression[k+1:j+1]}){expression[j+1:]}'
                ans = min(ans, cand, key=lambda x: eval(x.replace('(', '*(').replace(')', ')*').strip('*')))
        return ans


    """2233. Maximum Product After K Increments (Medium)
    You are given an array of non-negative integers nums and an integer k. In
    one operation, you may choose any element from nums and increment it by 1.
    Return the maximum product of nums after at most k operations. Since the
    answer may be very large, return it modulo 10^9 + 7. Note that you should
    maximize the product before taking the modulo.

    Example 1:
    Input: nums = [0,4], k = 5
    Output: 20
    Explanation: Increment the first number 5 times. Now nums = [5, 4], with a
                 product of 5 * 4 = 20. It can be shown that 20 is maximum
                 product possible, so we return 20. Note that there may be
                 other ways to increment nums to have the maximum product.

    Example 2:
    Input: nums = [6,3,3,2], k = 2
    Output: 216
    Explanation: Increment the second number 1 time and increment the fourth
                 number 1 time. Now nums = [6, 4, 3, 3], with a product of
                 6 * 4 * 3 * 3 = 216. It can be shown that 216 is maximum
                 product possible, so we return 216. Note that there may be
                 other ways to increment nums to have the maximum product.

    Constraints:
    * 1 <= nums.length, k <= 10^5
    * 0 <= nums[i] <= 10^6"""

    def maximumProduct(self, nums: List[int], k: int) -> int:
        mod = 1_000_000_007
        nums.sort()
        for i, x in enumerate(nums):
            target = nums[i+1] if i+1 < len(nums) else inf
            diff = (target-x) * (i+1)
            if diff <= k: k -= diff
            else: break
        q, r = divmod(k, i+1)
        ans = pow(x+q+1, r, mod) * pow(x+q, i+1-r, mod) % mod
        for ii in range(i+1, len(nums)):
            ans = ans * nums[ii] % mod
        return ans


    """2234. Maximum Total Beauty of the Gardens (Hard)
    Alice is a caretaker of n gardens and she wants to plant flowers to
    maximize the total beauty of all her gardens. You are given a 0-indexed
    integer array flowers of size n, where flowers[i] is the number of flowers
    already planted in the ith garden. Flowers that are already planted cannot
    be removed. You are then given another integer newFlowers, which is the
    maximum number of flowers that Alice can additionally plant. You are also
    given the integers target, full, and partial. A garden is considered
    complete if it has at least target flowers. The total beauty of the gardens
    is then determined as the sum of the following:
    * The number of complete gardens multiplied by full.
    * The minimum number of flowers in any of the incomplete gardens multiplied
      by partial. If there are no incomplete gardens, then this value will be 0.
    Return the maximum total beauty that Alice can obtain after planting at
    most newFlowers flowers.

    Example 1:
    Input: flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1
    Output: 14
    Explanation: Alice can plant
                 - 2 flowers in the 0th garden
                 - 3 flowers in the 1st garden
                 - 1 flower in the 2nd garden
                 - 1 flower in the 3rd garden
                 The gardens will then be [3,6,2,2]. She planted a total of
                 2 + 3 + 1 + 1 = 7 flowers. There is 1 garden that is complete.
                 The minimum number of flowers in the incomplete gardens is 2.
                 Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14. No
                 other way of planting flowers can obtain a total beauty higher
                 than 14.

    Example 2:
    Input: flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6
    Output: 30
    Explanation: Alice can plant
                 - 3 flowers in the 0th garden
                 - 0 flowers in the 1st garden
                 - 0 flowers in the 2nd garden
                 - 2 flowers in the 3rd garden
                 The gardens will then be [5,4,5,5]. She planted a total of
                 3 + 0 + 0 + 2 = 5 flowers. There are 3 gardens that are
                 complete. The minimum number of flowers in the incomplete
                 gardens is 4. Thus, the total beauty is
                 3 * 2 + 4 * 6 = 6 + 24 = 30. No other way of planting flowers
                 can obtain a total beauty higher than 30. Note that Alice
                 could make all the gardens complete but in this case, she
                 would obtain a lower total beauty.

    Constraints:
    * 1 <= flowers.length <= 10^5
    * 1 <= flowers[i], target <= 10^5
    * 1 <= newFlowers <= 10^10
    * 1 <= full, partial <= 10^5"""

    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        flowers = sorted(min(target, x) for x in flowers)
        prefix = [0]
        ii = -1
        for i in range(len(flowers)):
            if flowers[i] < target: ii = i
            if i: prefix.append(prefix[-1] + (flowers[i]-flowers[i-1])*i)
        ans = 0
        for k in range(len(flowers)+1):
            if k: newFlowers -= target - flowers[-k]
            if newFlowers >= 0:
                while 0 <= ii and (ii+k >= len(flowers) or prefix[ii] > newFlowers): ii -= 1
                if 0 <= ii: kk = min(target-1, flowers[ii] + (newFlowers - prefix[ii])//(ii+1))
                else: kk = 0
                ans = max(ans, k*full + kk*partial)
        return ans


    """2235. Add Two Integers (Easy)
    Given two integers num1 and num2, return the sum of the two integers.

    Example 1:
    Input: num1 = 12, num2 = 5
    Output: 17
    Explanation: num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is
                 returned.

    Example 2:
    Input: num1 = -10, num2 = 4
    Output: -6
    Explanation: num1 + num2 = -6, so -6 is returned.

    Constraints:
    * -100 <= num1, num2 <= 100"""

    def sum(self, num1: int, num2: int) -> int:
        return num1 + num2


    """2236. Root Equals Sum of Children (Easy)
    You are given the root of a binary tree that consists of exactly 3 nodes:
    the root, its left child, and its right child. Return true if the value of
    the root is equal to the sum of the values of its two children, or false
    otherwise.

    Example 1:
    Input: root = [10,4,6]
    Output: true
    Explanation: The values of the root, its left child, and its right child
                 are 10, 4, and 6, respectively. 10 is equal to 4 + 6, so we
                 return true.

    Example 2:
    Input: root = [5,3,1]
    Output: false
    Explanation: The values of the root, its left child, and its right child
                 are 5, 3, and 1, respectively. 5 is not equal to 3 + 1, so we
                 return false.

    Constraints:
    * The tree consists only of the root, its left child, and its right child.
    * -100 <= Node.val <= 100"""

    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return root.val == root.left.val + root.right.val


    """2237. Count Positions on Street With Required Brightness (Medium)
    You are given an integer n. A perfectly straight street is represented by a
    number line ranging from 0 to n - 1. You are given a 2D integer array
    lights representing the street lamp(s) on the street. Each
    lights[i] = [positioni, rangei] indicates that there is a street lamp at
    position positioni that lights up the area from
    [max(0, positioni - rangei), min(n - 1, positioni + rangei)] (inclusive).
    The brightness of a position p is defined as the number of street lamps
    that light up the position p. You are given a 0-indexed integer array
    requirement of size n where requirement[i] is the minimum brightness of the
    ith position on the street. Return the number of positions i on the street
    between 0 and n - 1 that have a brightness of at least requirement[i].

    Example 1:
    Input: n = 5, lights = [[0,1],[2,1],[3,2]], requirement = [0,2,1,4,1]
    Output: 4
    Explanation: - The first street lamp lights up the area from
                   [max(0, 0 - 1), min(n - 1, 0 + 1)] = [0, 1] (inclusive).
                 - The second street lamp lights up the area from
                   [max(0, 2 - 1), min(n - 1, 2 + 1)] = [1, 3] (inclusive).
                 - The third street lamp lights up the area from
                   [max(0, 3 - 2), min(n - 1, 3 + 2)] = [1, 4] (inclusive).
                 - Position 0 is covered by the first street lamp. It is
                   covered by 1 street lamp which is greater than requirement[0].
                 - Position 1 is covered by the first, second, and third street
                   lamps. It is covered by 3 street lamps which is greater than
                   requirement[1].
                 - Position 2 is covered by the second and third street lamps.
                   It is covered by 2 street lamps which is greater than
                   requirement[2].
                 - Position 3 is covered by the second and third street lamps.
                   It is covered by 2 street lamps which is less than
                   requirement[3].
                 - Position 4 is covered by the third street lamp. It is
                   covered by 1 street lamp which is equal to requirement[4].
                 Positions 0, 1, 2, and 4 meet the requirement so we return 4.

    Example 2:
    Input: n = 1, lights = [[0,1]], requirement = [2]
    Output: 0
    Explanation: - The first street lamp lights up the area from
                   [max(0, 0 - 1), min(n - 1, 0 + 1)] = [0, 0] (inclusive).
                 - Position 0 is covered by the first street lamp. It is
                   covered by 1 street lamp which is less than requirement[0].
                 - We return 0 because no position meets their brightness
                   requirement.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= lights.length <= 10^5
    * 0 <= positioni < n
    * 0 <= rangei <= 10^5
    * requirement.length == n
    * 0 <= requirement[i] <= 10^5"""

    def meetRequirement(self, n: int, lights: List[List[int]], requirement: List[int]) -> int:
        line = [0]*(n+1)
        for x, d in lights:
            line[max(0, x-d)] += 1
            line[min(n, x+d+1)] -= 1
        prefix = list(accumulate(line))
        return sum(p >= r for p, r in zip(prefix, requirement))


    """2243. Calculate Digit Sum of a String (Easy)
    You are given a string s consisting of digits and an integer k. A round can
    be completed if the length of s is greater than k. In one round, do the
    following:
    * Divide s into consecutive groups of size k such that the first k
      characters are in the first group, the next k characters are in the
      second group, and so on. Note that the size of the last group can be
      smaller than k.
    * Replace each group of s with a string representing the sum of all its
      digits. For example, "346" is replaced with "13" because 3 + 4 + 6 = 13.
    * Merge consecutive groups together to form a new string. If the length of
      the string is greater than k, repeat from step 1.
    Return s after all rounds have been completed.

    Example 1:
    Input: s = "11111222223", k = 3
    Output: "135"
    Explanation:
    - For the first round, we divide s into groups of size 3: "111", "112",
      "222", and "23". Then we calculate the digit sum of each group:
      1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. So, s becomes
      "3" + "4" + "6" + "5" = "3465" after the first round.
    - For the second round, we divide s into "346" and "5". Then we calculate
      the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. So, s becomes
      "13" + "5" = "135" after second round.
    Now, s.length <= k, so we return "135" as the answer.

    Example 2:
    Input: s = "00000000", k = 3
    Output: "000"
    Explanation: We divide s into "000", "000", and "00". Then we calculate the
                 digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and
                 0 + 0 = 0. s becomes "0" + "0" + "0" = "000", whose length is
                 equal to k, so we return "000".

    Constraints:
    * 1 <= s.length <= 100
    * 2 <= k <= 100
    * s consists of digits only."""

    def digitSum(self, s: str, k: int) -> str:
        while len(s) > k:
            ss = []
            for i in range(0, len(s), k): ss.append(sum(map(int, s[i:i+k])))
            s = "".join(map(str, ss))
        return s


    """2244. Minimum Rounds to Complete All Tasks (Medium)
    You are given a 0-indexed integer array tasks, where tasks[i] represents
    the difficulty level of a task. In each round, you can complete either 2 or
    3 tasks of the same difficulty level. Return the minimum rounds required to
    complete all the tasks, or -1 if it is not possible to complete all the
    tasks.

    Example 1:
    Input: tasks = [2,2,3,3,2,4,4,4,4,4]
    Output: 4
    Explanation: To complete all the tasks, a possible plan is:
    - In the first round, you complete 3 tasks of difficulty level 2.
    - In the second round, you complete 2 tasks of difficulty level 3.
    - In the third round, you complete 3 tasks of difficulty level 4.
    - In the fourth round, you complete 2 tasks of difficulty level 4.
    It can be shown that all the tasks cannot be completed in fewer than 4
    rounds, so the answer is 4.

    Example 2:
    Input: tasks = [2,3,3]
    Output: -1
    Explanation: There is only 1 task of difficulty level 2, but in each round,
                 you can only complete either 2 or 3 tasks of the same
                 difficulty level. Hence, you cannot complete all the tasks,
                 and the answer is -1.

    Constraints:
    * 1 <= tasks.length <= 10^5
    * 1 <= tasks[i] <= 10^9"""

    def minimumRounds(self, nums: List[int]) -> int:
        ans = 0
        for v in Counter(nums).values():
            if v == 1: return -1
            ans += (v + 2)//3
        return ans


    """2245. Maximum Trailing Zeros in a Cornered Path (Medium)
    You are given a 2D integer array grid of size m x n, where each cell
    contains a positive integer. A cornered path is defined as a set of
    adjacent cells with at most one turn. More specifically, the path should
    exclusively move either horizontally or vertically up to the turn (if there
    is one), without returning to a previously visited cell. After the turn,
    the path will then move exclusively in the alternate direction: move
    vertically if it moved horizontally, and vice versa, also without returning
    to a previously visited cell. The product of a path is defined as the
    product of all the values in the path. Return the maximum number of
    trailing zeros in the product of a cornered path found in grid.

    Note:
    * Horizontal movement means moving in either the left or right direction.
    * Vertical movement means moving in either the up or down direction.

    Example 1:
    Input: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]
    Output: 3
    Explanation: The grid on the left shows a valid cornered path. It has a
                 product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing
                 zeros. It can be shown that this is the maximum trailing zeros
                 in the product of a cornered path. The grid in the middle is
                 not a cornered path as it has more than one turn. The grid on
                 the right is not a cornered path as it requires a return to a
                 previously visited cell.

    Example 2:
    Input: grid = [[4,3,2],[7,6,1],[8,8,8]]
    Output: 0
    Explanation: The grid is shown in the figure above. There are no cornered
                 paths in the grid that result in a product with a trailing
                 zero.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 1 <= grid[i][j] <= 1000"""

    def maxTrailingZeros(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        f2 = [[0]*n for _ in range(m)]
        f5 = [[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                x = grid[i][j]
                while x % 2 == 0:
                    f2[i][j] += 1
                    x //= 2
                x = grid[i][j]
                while x % 5 == 0:
                    f5[i][j] += 1
                    x //= 5

        h = [[[0, 0] for j in range(n+1)] for i in range(m+1)]
        v = [[[0, 0] for j in range(n+1)] for i in range(m+1)]

        for i in range(m):
            for j in range(n):
                h[i][j+1][0] = h[i][j][0] + f2[i][j]
                h[i][j+1][1] = h[i][j][1] + f5[i][j]
                v[i+1][j][0] = v[i][j][0] + f2[i][j]
                v[i+1][j][1] = v[i][j][1] + f5[i][j]

        ans = 0
        for i in range(m):
            for j in range(n):
                hh = [h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]]
                vv = [v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]]
                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j]))
                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1]))
                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1]))
                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j]))
        return ans


    """2246. Longest Path With Different Adjacent Characters (Hard)
    You are given a tree (i.e. a connected, undirected graph that has no cycles)
    rooted at node 0 consisting of n nodes numbered from 0 to n - 1. The tree
    is represented by a 0-indexed array parent of size n, where parent[i] is
    the parent of node i. Since node 0 is the root, parent[0] == -1. You are
    also given a string s of length n, where s[i] is the character assigned to
    node i. Return the length of the longest path in the tree such that no pair
    of adjacent nodes on the path have the same character assigned to them.

    Example 1:
    Input: parent = [-1,0,0,1,1,2], s = "abacbe"
    Output: 3
    Explanation: The longest path where each two adjacent nodes have different
                 characters in the tree is the path: 0 -> 1 -> 3. The length of
                 this path is 3, so 3 is returned. It can be proven that there
                 is no longer path that satisfies the conditions.

    Example 2:
    Input: parent = [-1,0,0,0], s = "aabc"
    Output: 3
    Explanation: The longest path where each two adjacent nodes have different
                 characters is the path: 2 -> 0 -> 3. The length of this path
                 is 3, so 3 is returned.

    Constraints:
    * n == parent.length == s.length
    * 1 <= n <= 105
    * 0 <= parent[i] <= n - 1 for all i >= 1
    * parent[0] == -1
    * parent represents a valid tree.
    * s consists of only lowercase English letters."""

    def longestPath(self, parent: List[int], s: str) -> int:
        tree = [[] for _ in parent]
        for i, x in enumerate(parent):
            if x != -1: tree[x].append(i)

        def fn(u):
            """Return longest depth."""
            nonlocal ans
            m0 = m1 = 0
            for v in tree[u]:
                val = fn(v)
                if s[u] != s[v]:
                    if val >= m0: m0, m1 = val, m0
                    elif val > m1: m1 = val
            ans = max(ans, 1 + m0 + m1)
            return 1 + m0

        ans = 0
        fn(0)
        return ans


    """2247. Maximum Cost of Trip With K Highways (Hard)
    A series of highways connect n cities numbered from 0 to n - 1. You are
    given a 2D integer array highways where highways[i] = [city1i, city2i, tolli]
    indicates that there is a highway that connects city1i and city2i, allowing
    a car to go from city1i to city2i and vice versa for a cost of tolli. You
    are also given an integer k. You are going on a trip that crosses exactly k
    highways. You may start at any city, but you may only visit each city at
    most once during your trip. Return the maximum cost of your trip. If there
    is no trip that meets the requirements, return -1.

    Example 1:
    Input: n = 5, highways = [[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]], k = 3
    Output: 17
    Explanation: One possible trip is to go from 0 -> 1 -> 4 -> 3. The cost of
                 this trip is 4 + 11 + 2 = 17. Another possible trip is to go
                 from 4 -> 1 -> 2 -> 3. The cost of this trip is
                 11 + 3 + 3 = 17. It can be proven that 17 is the maximum
                 possible cost of any valid trip. Note that the trip
                 4 -> 1 -> 0 -> 1 is not allowed because you visit the city 1
                 twice.

    Example 2:
    Input: n = 4, highways = [[0,1,3],[2,3,2]], k = 2
    Output: -1
    Explanation: There are no valid trips of length 2, so return -1.

    Constraints:
    * 2 <= n <= 15
    * 1 <= highways.length <= 50
    * highways[i].length == 3
    * 0 <= city1i, city2i <= n - 1
    * city1i != city2i
    * 0 <= tolli <= 100
    * 1 <= k <= 50
    * There are no duplicate highways."""

    def maximumCost(self, n: int, highways: List[List[int]], k: int) -> int:
        graph = [[] for _ in range(n)]
        for u, v, w in highways:
            graph[u].append((v, w))
            graph[v].append((u, w))
        dp = [[-inf]*(1<<n) for _ in range(n)]
        for m in range((1<<n)-1, -1, -1):
            for u in range(n):
                if m & 1<<u:
                    cnt = m.bit_count()
                    if cnt == k+1: dp[u][m] = 0
                    elif cnt < k+1:
                        for v, w in graph[u]:
                            if not m & 1<<v: dp[u][m] = max(dp[u][m], w + dp[v][m ^ 1<<v])
        return max(-1, max(dp[u][1<<u] for u in range(n)))


    """2248. Intersection of Multiple Arrays (Easy)
    Given a 2D integer array nums where nums[i] is a non-empty array of
    distinct positive integers, return the list of integers that are present in
    each array of nums sorted in ascending order.

    Example 1:
    Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
    Output: [3,4]
    Explanation: The only integers present in each of nums[0] = [3,1,2,4,5],
                 nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so
                 we return [3,4].

    Example 2:
    Input: nums = [[1,2,3],[4,5,6]]
    Output: []
    Explanation: There does not exist any integer present both in nums[0] and
                 nums[1], so we return an empty list [].

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= sum(nums[i].length) <= 1000
    * 1 <= nums[i][j] <= 1000
    * All the values of nums[i] are unique."""

    def intersection(self, nums: List[List[int]]) -> List[int]:
        return sorted(reduce(set.intersection, map(set, nums)))


    """2249. Count Lattice Points Inside a Circle (Medium)
    Given a 2D integer array circles where circles[i] = [xi, yi, ri] represents
    the center (xi, yi) and radius ri of the ith circle drawn on a grid, return
    the number of lattice points that are present inside at least one circle.

    Note:
    * A lattice point is a point with integer coordinates.
    * Points that lie on the circumference of a circle are also considered to
      be inside it.

    Example 1:
    Input: circles = [[2,2,1]]
    Output: 5
    Explanation: The figure above shows the given circle. The lattice points
                 present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3),
                 and (3, 2) and are shown in green. Other points such as (1, 1)
                 and (1, 3), which are shown in red, are not considered inside
                 the circle. Hence, the number of lattice points present inside
                 at least one circle is 5.

    Example 2:
    Input: circles = [[2,2,2],[3,4,1]]
    Output: 16
    Explanation: The figure above shows the given circles. There are exactly 16
                 lattice points which are present inside at least one circle.
                 Some of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).

    Constraints:
    * 1 <= circles.length <= 200
    * circles[i].length == 3
    * 1 <= xi, yi <= 100
    * 1 <= ri <= min(xi, yi)"""

    def countLatticePoints(self, circles: List[List[int]]) -> int:
        intervals = [[] for _ in range(201)]
        for x, y, r in circles:
            intervals[x].append((y-r, y+r))
            for dx in range(1, r+1):
                dy = int(sqrt(r**2 - dx**2))
                intervals[x+dx].append((y-dy, y+dy))
                intervals[x-dx].append((y-dy, y+dy))

        ans = 0
        for interval in intervals:
            if interval:
                end = -inf
                for i, (lo, hi) in enumerate(sorted(interval)):
                    if end < lo:
                        if i: ans += end - start + 1
                        start, end = lo, hi
                    else: end = max(end, hi)
                ans += end - start + 1
        return ans


    """2250. Count Number of Rectangles Containing Each Point (Medium)
    You are given a 2D integer array rectangles where rectangles[i] = [li, hi]
    indicates that ith rectangle has a length of li and a height of hi. You are
    also given a 2D integer array points where points[j] = [xj, yj] is a point
    with coordinates (xj, yj). The ith rectangle has its bottom-left corner
    point at the coordinates (0, 0) and its top-right corner point at (li, hi).
    Return an integer array count of length points.length where count[j] is the
    number of rectangles that contain the jth point. The ith rectangle contains
    the jth point if 0 <= xj <= li and 0 <= yj <= hi. Note that points that lie
    on the edges of a rectangle are also considered to be contained by that
    rectangle.

    Example 1:
    Input: rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]
    Output: [2,1]
    Explanation: The first rectangle contains no points. The second rectangle
                 contains only the point (2, 1). The third rectangle contains
                 the points (2, 1) and (1, 4). The number of rectangles that
                 contain the point (2, 1) is 2. The number of rectangles that
                 contain the point (1, 4) is 1. Therefore, we return [2, 1].

    Example 2:
    Input: rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]
    Output: [1,3]
    Explanation: The first rectangle contains only the point (1, 1). The second
                 rectangle contains only the point (1, 1). The third rectangle
                 contains the points (1, 3) and (1, 1). The number of
                 rectangles that contain the point (1, 3) is 1. The number of
                 rectangles that contain the point (1, 1) is 3. Therefore, we
                 return [1, 3].

    Constraints:
    * 1 <= rectangles.length, points.length <= 5 * 10^4
    * rectangles[i].length == points[j].length == 2
    * 1 <= li, xj <= 10^9
    * 1 <= hi, yj <= 100
    * All the rectangles are unique.
    * All the points are unique."""

    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
        mp = defaultdict(list)
        for l, h in rectangles: mp[h].append(l)
        for v in mp.values(): v.sort()
        ans = []
        for x, y in points:
            cnt = 0
            for yy in range(y, 101):
                if yy in mp: cnt += len(mp[yy]) - bisect_left(mp[yy], x)
            ans.append(cnt)
        return ans


    """2251. Number of Flowers in Full Bloom (Hard)
    You are given a 0-indexed 2D integer array flowers, where
    flowers[i] = [starti, endi] means the ith flower will be in full bloom from
    starti to endi (inclusive). You are also given a 0-indexed integer array
    persons of size n, where persons[i] is the time that the ith person will
    arrive to see the flowers. Return an integer array answer of size n, where
    answer[i] is the number of flowers that are in full bloom when the ith
    person arrives.

    Example 1:
    Input: flowers = [[1,6],[3,7],[9,12],[4,13]], persons = [2,3,7,11]
    Output: [1,2,2,2]
    Explanation: The figure above shows the times when the flowers are in full
                 bloom and when the people arrive. For each person, we return
                 the number of flowers in full bloom during their arrival.

    Example 2:
    Input: flowers = [[1,10],[3,3]], persons = [3,3,2]
    Output: [2,2,1]
    Explanation: The figure above shows the times when the flowers are in full
                 bloom and when the people arrive. For each person, we return
                 the number of flowers in full bloom during their arrival.

    Constraints:
    * 1 <= flowers.length <= 5 * 10^4
    * flowers[i].length == 2
    * 1 <= starti <= endi <= 10^9
    * 1 <= persons.length <= 5 * 10^4
    * 1 <= persons[i] <= 10^9"""

    def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:
        line = []
        for start, end in flowers:
            line.append((start, +1))
            line.append((end+1, -1))
        vals = []
        prefix = 0
        for x, y in sorted(line):
            prefix += y
            vals.append((x, prefix))
        ans = []
        for p in persons:
            i = bisect_right(vals, p, key=lambda x: x[0])
            if i: ans.append(vals[i-1][1])
            else: ans.append(0)
        return ans


    """2263. Make Array Non-decreasing or Non-increasing (Hard)
    You are given a 0-indexed integer array nums. In one operation, you can:
    * Choose an index i in the range 0 <= i < nums.length
    * Set nums[i] to nums[i] + 1 or nums[i] - 1
    Return the minimum number of operations to make nums non-decreasing or non-
    increasing.

    Example 1:
    Input: nums = [3,2,4,5,0]
    Output: 4
    Explanation: One possible way to turn nums into non-increasing order is to:
                 - Add 1 to nums[1] once so that it becomes 3.
                 - Subtract 1 from nums[2] once so it becomes 3.
                 - Subtract 1 from nums[3] twice so it becomes 3.
                 After doing the 4 operations, nums becomes [3,3,3,3,0] which
                 is in non-increasing order. Note that it is also possible to
                 turn nums into [4,4,4,4,0] in 4 operations. It can be proven
                 that 4 is the minimum number of operations needed.

    Example 2:
    Input: nums = [2,2,3,4]
    Output: 0
    Explanation: nums is already in non-decreasing order, so no operations are
                 needed and we return 0.

    Example 3:
    Input: nums = [0]
    Output: 0
    Explanation: nums is already in non-decreasing order, so no operations are
                 needed and we return 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 1000

    Follow up: Can you solve it in O(n*log(n)) time complexity?"""

    def convertArray(self, nums: List[int]) -> int:

        def fn(nums):
            """Return of the cost of making nums non-decreasing."""
            pq = []
            ans = 0
            for x in nums:
                if pq and x < -pq[0]:
                    ans += -heappop(pq) - x
                    heappush(pq, -x)
                heappush(pq, -x)
            return ans

        return min(fn(nums), fn(nums[::-1]))


    """2264. Largest 3-Same-Digit Number in String (Easy)
    You are given a string num representing a large integer. An integer is good
    if it meets the following conditions:
    * It is a substring of num with length 3.
    * It consists of only one unique digit.
    Return the maximum good integer as a string or an empty string "" if no
    such integer exists.

    Note:
    * A substring is a contiguous sequence of characters within a string.
    * There may be leading zeroes in num or a good integer.

    Example 1:
    Input: num = "6777133339"
    Output: "777"
    Explanation: There are two distinct good integers: "777" and "333". "777"
                 is the largest, so we return "777".

    Example 2:
    Input: num = "2300019"
    Output: "000"
    Explanation: "000" is the only good integer.

    Example 3:
    Input: num = "42352338"
    Output: ""
    Explanation: No substring of length 3 consists of only one unique digit.
                 Therefore, there are no good integers.

    Constraints:
    * 3 <= num.length <= 1000
    * num only consists of digits."""

    def largestGoodInteger(self, num: str) -> str:
        return next((x*3 for x in "9876543210" if x*3 in num), "")


    """2265. Count Nodes Equal to Average of Subtree (Medium)
    Given the root of a binary tree, return the number of nodes where the value
    of the node is equal to the average of the values in its subtree.

    Note:
    * The average of n elements is the sum of the n elements divided by n and
      rounded down to the nearest integer.
    * A subtree of root is a tree consisting of root and all of its descendants.

    Example 1:
    Input: root = [4,8,5,0,1,null,6]
    Output: 5
    Explanation: For the node with value 4: The average of its subtree is
                 (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4. For the node with
                 value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.
                 For the node with value 0: The average of its subtree is 0 / 1 = 0.
                 For the node with value 1: The average of its subtree is 1 / 1 = 1.
                 For the node with value 6: The average of its subtree is 6 / 1 = 6.

    Example 2:
    Input: root = [1]
    Output: 1
    Explanation: For the node with value 1: The average of its subtree is 1 / 1 = 1.

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * 0 <= Node.val <= 1000"""

    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
        ans = 0
        mp = {None: (0, 0)}
        node, stack = root, []
        prev = None
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack[-1]
                if node.right and node.right != prev: node = node.right
                else:
                    stack.pop()
                    ls, lc = mp[node.left]
                    rs, rc = mp[node.right]
                    sm, cnt = ls + node.val + rs, lc + 1 + rc
                    mp[node] = (sm, cnt)
                    if sm//cnt == node.val: ans += 1
                    prev = node
                    node = None
        return ans


    """2266. Count Number of Texts (Medium)
    Alice is texting Bob using her phone. The mapping of digits to letters is
    shown in the figure below. In order to add a letter, Alice has to press the
    key of the corresponding digit i times, where i is the position of the
    letter in the key.
    * For example, to add the letter 's', Alice has to press '7' four times.
      Similarly, to add the letter 'k', Alice has to press '5' twice.
    * Note that the digits '0' and '1' do not map to any letters, so Alice does
      not use them.
    However, due to an error in transmission, Bob did not receive Alice's text
    message but received a string of pressed keys instead.
    * For example, when Alice sent the message "bob", Bob received the string
      "2266622".
    Given a string pressedKeys representing the string received by Bob, return
    the total number of possible text messages Alice could have sent. Since the
    answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: pressedKeys = "22233"
    Output: 8
    Explanation: The possible text messages Alice could have sent are: "aaadd",
                 "abdd", "badd", "cdd", "aaae", "abe", "bae", and "ce". Since
                 there are 8 possible messages, we return 8.

    Example 2:
    Input: pressedKeys = "222222222222222222222222222222222222"
    Output: 82876089
    Explanation: There are 2082876103 possible text messages Alice could have
                 sent. Since we need to return the answer modulo 10^9 + 7, we
                 return 2082876103 % (10^9 + 7) = 82876089.

    Constraints:
    * 1 <= pressedKeys.length <= 10^5
    * pressedKeys only consists of digits from '2' - '9'."""

    def countTexts(self, pressedKeys: str) -> int:
        dp = [0] * (len(pressedKeys)+1)
        dp[0] = 1
        for i, ch in enumerate(pressedKeys):
            dp[i+1] = dp[i]
            if i and pressedKeys[i-1] == ch:
                dp[i+1] += dp[i-1]
                if i >= 2 and pressedKeys[i-2] == ch:
                    dp[i+1] += dp[i-2]
                    if i >= 3 and pressedKeys[i-3] == ch and ch in "79": dp[i+1] += dp[i-3]
            dp[i+1] %= 1_000_000_007
        return dp[-1]


    """2267. Check if There Is a Valid Parentheses String Path (Hard)
    A parentheses string is a non-empty string consisting only of '(' and ')'.
    It is valid if any of the following conditions is true:
    * It is ().
    * It can be written as AB (A concatenated with B), where A and B are valid
      parentheses strings.
    * It can be written as (A), where A is a valid parentheses string.
    You are given an m x n matrix of parentheses grid. A valid parentheses
    string path in the grid is a path satisfying all of the following
    conditions:
    * The path starts from the upper left cell (0, 0).
    * The path ends at the bottom-right cell (m - 1, n - 1).
    * The path only ever moves down or right.
    * The resulting parentheses string formed by the path is valid.
    Return true if there exists a valid parentheses string path in the grid.
    Otherwise, return false.

    Example 1:
    Input: grid = [["(","(","("],[")","(",")"],["(","(",")"],["(","(",")"]]
    Output: true
    Explanation: The above diagram shows two possible paths that form valid
                 parentheses strings. The first path shown results in the valid
                 parentheses string "()(())". The second path shown results in
                 the valid parentheses string "((()))". Note that there may be
                 other valid parentheses string paths.

    Example 2:
    Input: grid = [[")",")"],["(","("]]
    Output: false
    Explanation: The two possible paths form the parentheses strings "))(" and
                 ")((". Since neither of them are valid parentheses strings, we
                 return false.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 100
    * grid[i][j] is either '(' or ')'."""

    def hasValidPath(self, grid: List[List[str]]) -> bool:
        m, n = len(grid), len(grid[0])

        @cache
        def fn(i, j, v):
            """Return True if value of v at (i, j) is possible."""
            if i == m-1 and j == n-1: return v == 0
            for ii, jj in (i+1, j), (i, j+1):
                if 0 <= ii < m and 0 <= jj < n:
                    if grid[ii][jj] == '(': vv = v+1
                    else: vv = v-1
                    if 0 <= vv <= min(ii+jj+1, m+n-ii-jj) and fn(ii, jj, vv): return True
            return False

        return fn(0, 0, 1)


    """2268. Minimum Number of Keypresses (Medium)
    You have a keypad with 9 buttons, numbered from 1 to 9, each mapped to
    lowercase English letters. You can choose which characters each button is
    matched to as long as:
    * All 26 lowercase English letters are mapped to.
    * Each character is mapped to by exactly 1 button.
    * Each button maps to at most 3 characters.
    To type the first character matched to a button, you press the button once.
    To type the second character, you press the button twice, and so on. Given
    a string s, return the minimum number of keypresses needed to type s using
    your keypad. Note that the characters mapped to by each button, and the
    order they are mapped in cannot be changed.

    Example 1:
    Input: s = "apple"
    Output: 5
    Explanation: One optimal way to setup your keypad is shown above.
                 Type 'a' by pressing button 1 once.
                 Type 'p' by pressing button 6 once.
                 Type 'p' by pressing button 6 once.
                 Type 'l' by pressing button 5 once.
                 Type 'e' by pressing button 3 once.
                 A total of 5 button presses are needed, so return 5.

    Example 2:
    Input: s = "abcdefghijkl"
    Output: 15
    Explanation: One optimal way to setup your keypad is shown above.
                 The letters 'a' to 'i' can each be typed by pressing a button
                 once.
                 Type 'j' by pressing button 1 twice.
                 Type 'k' by pressing button 2 twice.
                 Type 'l' by pressing button 3 twice.
                 A total of 15 button presses are needed, so return 15.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters."""

    def minimumKeypresses(self, s: str) -> int:
        ans = press = 0
        freq = Counter(s)
        for i, v in enumerate(sorted(freq.values(), reverse=True)):
            if i % 9 == 0: press += 1
            ans += press * v
        return ans


    """2269. Find the K-Beauty of a Number (Easy)
    The k-beauty of an integer num is defined as the number of substrings of
    num when it is read as a string that meet the following conditions:
    * It has a length of k.
    * It is a divisor of num.
    Given integers num and k, return the k-beauty of num.

    Note:
    * Leading zeros are allowed.
    * 0 is not a divisor of any value.
    A substring is a contiguous sequence of characters in a string.

    Example 1:
    Input: num = 240, k = 2
    Output: 2
    Explanation: The following are the substrings of num of length k:
                 - "24" from "240": 24 is a divisor of 240.
                 - "40" from "240": 40 is a divisor of 240.
                 Therefore, the k-beauty is 2.

    Example 2:
    Input: num = 430043, k = 2
    Output: 2
    Explanation: The following are the substrings of num of length k:
                 - "43" from "430043": 43 is a divisor of 430043.
                 - "30" from "430043": 30 is not a divisor of 430043.
                 - "00" from "430043": 0 is not a divisor of 430043.
                 - "04" from "430043": 4 is not a divisor of 430043.
                 - "43" from "430043": 43 is a divisor of 430043.
                 Therefore, the k-beauty is 2.

    Constraints:
    * 1 <= num <= 10^9
    * 1 <= k <= num.length (taking num as a string)"""

    def divisorSubstrings(self, num: int, k: int) -> int:
        s = str(num)
        ans = div = 0
        for i in range(len(s)-k+1):
            div = int(s[i:i+k])
            if div and num % div == 0: ans += 1
        return ans


    """2270. Number of Ways to Split Array (Medium)
    You are given a 0-indexed integer array nums of length n. nums contains a
    valid split at index i if the following are true:
    * The sum of the first i + 1 elements is greater than or equal to the sum
      of the last n - i - 1 elements.
    * There is at least one element to the right of i. That is, 0 <= i < n - 1.
    Return the number of valid splits in nums.

    Example 1:
    Input: nums = [10,4,-8,7]
    Output: 2
    Explanation: There are three ways of splitting nums into two non-empty
                 parts:
                 - Split nums at index 0. Then, the first part is [10], and its
                   sum is 10. The second part is [4,-8,7], and its sum is 3.
                   Since 10 >= 3, i = 0 is a valid split.
                 - Split nums at index 1. Then, the first part is [10,4], and
                   its sum is 14. The second part is [-8,7], and its sum is -1.
                   Since 14 >= -1, i = 1 is a valid split.
                 - Split nums at index 2. Then, the first part is [10,4,-8],
                   and its sum is 6. The second part is [7], and its sum is 7.
                   Since 6 < 7, i = 2 is not a valid split.
                 Thus, the number of valid splits in nums is 2.

    Example 2:
    Input: nums = [2,3,1,0]
    Output: 2
    Explanation: There are two valid splits in nums:
                 - Split nums at index 1. Then, the first part is [2,3], and
                   its sum is 5. The second part is [1,0], and its sum is 1.
                   Since 5 >= 1, i = 1 is a valid split.
                 - Split nums at index 2. Then, the first part is [2,3,1], and
                   its sum is 6. The second part is [0], and its sum is 0.
                   Since 6 >= 0, i = 2 is a valid split.

    Constraints:
    * 2 <= nums.length <= 10^5
    * -10^5 <= nums[i] <= 10^5"""

    def waysToSplitArray(self, nums: List[int]) -> int:
        ans = prefix = 0
        total = sum(nums)
        for i, x in enumerate(nums):
            prefix += x
            if i < len(nums) - 1 and prefix >= total - prefix: ans += 1
        return ans


    """2271. Maximum White Tiles Covered by a Carpet (Medium)
    You are given a 2D integer array tiles where tiles[i] = [li, ri] represents
    that every tile j in the range li <= j <= ri is colored white. You are also
    given an integer carpetLen, the length of a single carpet that can be
    placed anywhere. Return the maximum number of white tiles that can be
    covered by the carpet.

    Example 1:
    Input: tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10
    Output: 9
    Explanation: Place the carpet starting on tile 10. It covers 9 white tiles,
                 so we return 9. Note that there may be other places where the
                 carpet covers 9 white tiles. It can be shown that the carpet
                 cannot cover more than 9 white tiles.

    Example 2:
    Input: tiles = [[10,11],[1,1]], carpetLen = 2
    Output: 2
    Explanation: Place the carpet starting on tile 10. It covers 2 white tiles,
                 so we return 2.

    Constraints:
    * 1 <= tiles.length <= 5 * 10^4
    * tiles[i].length == 2
    * 1 <= li <= ri <= 10^9
    * 1 <= carpetLen <= 10^9
    * The tiles are non-overlapping."""

    def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
        tiles.sort()
        ans = ii = val = 0
        for i in range(len(tiles)):
            hi = tiles[i][0] + carpetLen - 1
            while ii < len(tiles) and tiles[ii][1] <= hi:
                val += tiles[ii][1] - tiles[ii][0] + 1
                ii += 1
            partial = 0
            if ii < len(tiles): partial = max(0, hi - tiles[ii][0] + 1)
            ans = max(ans, val + partial)
            val -= tiles[i][1] - tiles[i][0] + 1
        return ans


    """2272. Substring With Largest Variance (Hard)
    The variance of a string is defined as the largest difference between the
    number of occurrences of any 2 characters present in the string. Note the
    two characters may or may not be the same. Given a string s consisting of
    lowercase English letters only, return the largest variance possible among
    all substrings of s. A substring is a contiguous sequence of characters
    within a string.

    Example 1:
    Input: s = "aababbb"
    Output: 3
    Explanation: All possible variances along with their respective substrings
                 are listed below:
                 - Variance 0 for substrings "a", "aa", "ab", "abab", "aababb",
                   "ba", "b", "bb", and "bbb".
                 - Variance 1 for substrings "aab", "aba", "abb", "aabab",
                   "ababb", "aababbb", and "bab".
                 - Variance 2 for substrings "aaba", "ababbb", "abbb", and
                   "babb".
                 - Variance 3 for substring "babbb".
                 Since the largest possible variance is 3, we return it.

    Example 2:
    Input: s = "abcde"
    Output: 0
    Explanation: No letter occurs more than once in s, so the variance of every
                 substring is 0.

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of lowercase English letters."""

    def largestVariance(self, s: str) -> int:
        ans = 0
        seen = set(s)
        for x in ascii_lowercase:
            for y in ascii_lowercase:
                if x != y and x in seen and y in seen:
                    vals = []
                    for ch in s:
                        if ch == x: vals.append(1)
                        elif ch == y: vals.append(-1)
                    cand = prefix = least = 0
                    ii = -1
                    for i, v in enumerate(vals):
                        prefix += v
                        if prefix < least:
                            least = prefix
                            ii = i
                        ans = max(ans, min(prefix-least, i-ii-1))
        return ans


    """2273. Find Resultant Array After Removing Anagrams (Easy)
    You are given a 0-indexed string array words, where words[i] consists of
    lowercase English letters. In one operation, select any index i such that
    0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete
    words[i] from words. Keep performing this operation as long as you can
    select an index that satisfies the conditions. Return words after
    performing all operations. It can be shown that selecting the indices for
    each operation in any arbitrary order will lead to the same result. An
    Anagram is a word or phrase formed by rearranging the letters of a
    different word or phrase using all the original letters exactly once. For
    example, "dacb" is an anagram of "abdc".

    Example 1:
    Input: words = ["abba","baba","bbaa","cd","cd"]
    Output: ["abba","cd"]
    Explanation: One of the ways we can obtain the resultant array is by using
                 the following operations:
                 - Since words[2] = "bbaa" and words[1] = "baba" are anagrams,
                   we choose index 2 and delete words[2]. Now
                   words = ["abba","baba","cd","cd"].
                 - Since words[1] = "baba" and words[0] = "abba" are anagrams,
                   we choose index 1 and delete words[1]. Now
                   words = ["abba","cd","cd"].
                 - Since words[2] = "cd" and words[1] = "cd" are anagrams, we
                   choose index 2 and delete words[2]. Now
                   words = ["abba","cd"].
                 We can no longer perform any operations, so ["abba","cd"] is
                 the final answer.

    Example 2:
    Input: words = ["a","b","c","d","e"]
    Output: ["a","b","c","d","e"]
    Explanation: No two adjacent strings in words are anagrams of each other,
                 so no operations are performed.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 10
    * words[i] consists of lowercase English letters."""

    def removeAnagrams(self, words: List[str]) -> List[str]:
        return [w for i, w in enumerate(words) if i == 0 or Counter(words[i-1]) != Counter(w)]


    """2274. Maximum Consecutive Floors Without Special Floors (Medium)
    Alice manages a company and has rented some floors of a building as office
    space. Alice has decided some of these floors should be special floors,
    used for relaxation only. You are given two integers bottom and top, which
    denote that Alice has rented all the floors from bottom to top (inclusive).
    You are also given the integer array special, where special[i] denotes a
    special floor that Alice has designated for relaxation. Return the maximum
    number of consecutive floors without a special floor.

    Example 1:
    Input: bottom = 2, top = 9, special = [4,6]
    Output: 3
    Explanation: The following are the ranges (inclusive) of consecutive floors
                 without a special floor:
                 - (2, 3) with a total amount of 2 floors.
                 - (5, 5) with a total amount of 1 floor.
                 - (7, 9) with a total amount of 3 floors.
                 Therefore, we return the maximum number which is 3 floors.

    Example 2:
    Input: bottom = 6, top = 8, special = [7,6,8]
    Output: 0
    Explanation: Every floor rented is a special floor, so we return 0.

    Constraints:
    * 1 <= special.length <= 10^5
    * 1 <= bottom <= special[i] <= top <= 10^9
    * All the values of special are unique."""

    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:
        aug = [bottom-1] + sorted(special) + [top+1]
        return max(aug[i]-aug[i-1]-1 for i in range(1, len(aug)))


    """2275. Largest Combination With Bitwise AND Greater Than Zero (Medium)
    The bitwise AND of an array nums is the bitwise AND of all integers in nums.
    * For example, for nums = [1, 5, 3], the bitwise AND is equal to
      1 & 5 & 3 = 1.
    * Also, for nums = [7], the bitwise AND is 7.
    You are given an array of positive integers candidates. Evaluate the
    bitwise AND of every combination of numbers of candidates. Each number in
    candidates may only be used once in each combination. Return the size of
    the largest combination of candidates with a bitwise AND greater than 0.

    Example 1:
    Input: candidates = [16,17,71,62,12,24,14]
    Output: 4
    Explanation: The combination [16,17,62,24] has a bitwise AND of
                 16 & 17 & 62 & 24 = 16 > 0. The size of the combination is 4.
                 It can be shown that no combination with a size greater than
                 4 has a bitwise AND greater than 0. Note that more than one
                 combination may have the largest size. For example, the
                 combination [62,12,24,14] has a bitwise AND of
                 62 & 12 & 24 & 14 = 8 > 0.

    Example 2:
    Input: candidates = [8,8]
    Output: 2
    Explanation: The largest combination [8,8] has a bitwise AND of
                 8 & 8 = 8 > 0. The size of the combination is 2, so we return
                 2.

    Constraints:
    * 1 <= candidates.length <= 10^5
    * 1 <= candidates[i] <= 10^7"""

    def largestCombination(self, candidates: List[int]) -> int:
        return max(sum(bool(x & 1<<i) for x in candidates) for i in range(24))


    """2277. Closest Node to Path in Tree (Hard)
    You are given a positive integer n representing the number of nodes in a
    tree, numbered from 0 to n - 1 (inclusive). You are also given a 2D integer
    array edges of length n - 1, where edges[i] = [node1i, node2i] denotes that
    there is a bidirectional edge connecting node1i and node2i in the tree. You
    are given a 0-indexed integer array query of length m where
    query[i] = [starti, endi, nodei] means that for the ith query, you are
    tasked with finding the node on the path from starti to endi that is
    closest to nodei. Return an integer array answer of length m, where
    answer[i] is the answer to the ith query.

    Example 1:
    Input: n = 7, edges = [[0,1],[0,2],[0,3],[1,4],[2,5],[2,6]], query = [[5,3,4],[5,3,6]]
    Output: [0,2]
    Explanation: The path from node 5 to node 3 consists of the nodes 5, 2, 0,
                 and 3. The distance between node 4 and node 0 is 2. Node 0 is
                 the node on the path closest to node 4, so the answer to the
                 first query is 0. The distance between node 6 and node 2 is 1.
                 Node 2 is the node on the path closest to node 6, so the
                 answer to the second query is 2.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2]], query = [[0,1,2]]
    Output: [1]
    Explanation: The path from node 0 to node 1 consists of the nodes 0, 1. The
                 distance between node 2 and node 1 is 1. Node 1 is the node on
                 the path closest to node 2, so the answer to the first query
                 is 1.

    Example 3:
    Input: n = 3, edges = [[0,1],[1,2]], query = [[0,0,0]]
    Output: [0]
    Explanation: The path from node 0 to node 0 consists of the node 0. Since 0
                 is the only node on the path, the answer to the first query is
                 0.

    Constraints:
    * 1 <= n <= 1000
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= node1i, node2i <= n - 1
    * node1i != node2i
    * 1 <= query.length <= 1000
    * query[i].length == 3
    * 0 <= starti, endi, nodei <= n - 1
    * The graph is a tree."""

    def closestNode(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        m = int(log2(n)) + 1
        lift = [[-1]*m for _ in range(n)] # binary lifting
        depth = [-1]*n
        stack = [(0, -1, 0)]
        while stack:
            u, p, d = stack.pop()
            depth[u] = d
            for v in tree[u]:
                if v != p:
                    lift[v][0] = u
                    for j in range(1, m):
                        if lift[v][j-1] == -1: break
                        lift[v][j] = lift[lift[v][j-1]][j-1]
                    stack.append((v, u, d+1))

        def lca(u, v):
            """Return lowest common ancestor via binary lifting."""
            if depth[u] > depth[v]: u, v = v, u
            for i in range(m):
                if depth[v]-depth[u] & 1<<i: v = lift[v][i]
            if u == v: return u
            for i in range(m-1, -1, -1):
                if lift[u][i] != lift[v][i]: u, v = lift[u][i], lift[v][i]
            return lift[u][0]

        ans = []
        for u, v, w in query:
            val = max(lca(u, v), lca(v, w), lca(w, u), key=depth.__getitem__)
            ans.append(val)
        return ans


    """2278. Percentage of Letter in String (Easy)
    Given a string s and a character letter, return the percentage of
    characters in s that equal letter rounded down to the nearest whole percent.

    Example 1:
    Input: s = "foobar", letter = "o"
    Output: 33
    Explanation: The percentage of characters in s that equal the letter 'o' is
                 2 / 6 * 100% = 33% when rounded down, so we return 33.

    Example 2:
    Input: s = "jjjj", letter = "k"
    Output: 0
    Explanation: The percentage of characters in s that equal the letter 'k' is
                 0%, so we return 0.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters.
    * letter is a lowercase English letter."""

    def percentageLetter(self, s: str, letter: str) -> int:
        return 100*s.count(letter)//len(s)


    """2279. Maximum Bags With Full Capacity of Rocks (Medium)
    You have n bags numbered from 0 to n - 1. You are given two 0-indexed
    integer arrays capacity and rocks. The ith bag can hold a maximum of
    capacity[i] rocks and currently contains rocks[i] rocks. You are also given
    an integer additionalRocks, the number of additional rocks you can place in
    any of the bags. Return the maximum number of bags that could have full
    capacity after placing the additional rocks in some bags.

    Example 1:
    Input: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2
    Output: 3
    Explanation: Place 1 rock in bag 0 and 1 rock in bag 1. The number of rocks
                 in each bag are now [2,3,4,4]. Bags 0, 1, and 2 have full
                 capacity. There are 3 bags at full capacity, so we return 3.
                 It can be shown that it is not possible to have more than 3
                 bags at full capacity. Note that there may be other ways of
                 placing the rocks that result in an answer of 3.

    Example 2:
    Input: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100
    Output: 3
    Explanation: Place 8 rocks in bag 0 and 2 rocks in bag 2. The number of
                 rocks in each bag are now [10,2,2]. Bags 0, 1, and 2 have full
                 capacity. There are 3 bags at full capacity, so we return 3.
                 It can be shown that it is not possible to have more than 3
                 bags at full capacity. Note that we did not use all of the
                 additional rocks.

    Constraints:
    * n == capacity.length == rocks.length
    * 1 <= n <= 5 * 10^4
    * 1 <= capacity[i] <= 10^9
    * 0 <= rocks[i] <= capacity[i]
    * 1 <= additionalRocks <= 10^9"""

    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
        ans = 0
        for x in sorted(c - r for c, r in zip(capacity, rocks)):
            if x <= additionalRocks:
                ans += 1
                additionalRocks -= x
        return ans


    """2280. Minimum Lines to Represent a Line Chart (Medium)
    You are given a 2D integer array stockPrices where
    stockPrices[i] = [dayi, pricei] indicates the price of the stock on day
    dayi is pricei. A line chart is created from the array by plotting the
    points on an XY plane with the X-axis representing the day and the Y-axis
    representing the price and connecting adjacent points. Return the minimum
    number of lines needed to represent the line chart.

    Example 1:
    Input: stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]
    Output: 3
    Explanation: The diagram above represents the input, with the X-axis
                 representing the day and Y-axis representing the price. The
                 following 3 lines can be drawn to represent the line chart:
                 - Line 1 (in red) from (1,7) to (4,4) passing through (1,7),
                   (2,6), (3,5), and (4,4).
                 - Line 2 (in blue) from (4,4) to (5,4).
                 - Line 3 (in green) from (5,4) to (8,1) passing through (5,4),
                   (6,3), (7,2), and (8,1).
                 It can be shown that it is not possible to represent the line
                 chart using less than 3 lines.

    Example 2:
    Input: stockPrices = [[3,4],[1,2],[7,8],[2,3]]
    Output: 1
    Explanation: As shown in the diagram above, the line chart can be
                 represented with a single line.

    Constraints:
    * 1 <= stockPrices.length <= 10^5
    * stockPrices[i].length == 2
    * 1 <= dayi, pricei <= 10^9
    * All dayi are distinct."""

    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        stockPrices.sort()
        ans = 0
        for i in range(1, len(stockPrices)):
            if i == 1 or (stockPrices[i][1]-stockPrices[i-1][1])*(stockPrices[i-1][0]-stockPrices[i-2][0]) != (stockPrices[i-1][1]-stockPrices[i-2][1])*(stockPrices[i][0]-stockPrices[i-1][0]): ans += 1
        return ans


    """2281. Sum of Total Strength of Wizards (Hard)
    As the ruler of a kingdom, you have an army of wizards at your command. You
    are given a 0-indexed integer array strength, where strength[i] denotes the
    strength of the ith wizard. For a contiguous group of wizards (i.e. the
    wizards' strengths form a subarray of strength), the total strength is
    defined as the product of the following two values:
    * The strength of the weakest wizard in the group.
    * The total of all the individual strengths of the wizards in the group.
    Return the sum of the total strengths of all contiguous groups of wizards.
    Since the answer may be very large, return it modulo 10^9 + 7. A subarray
    is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: strength = [1,3,1,2]
    Output: 44
    Explanation: The following are all the contiguous groups of wizards:
                 - [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
                 - [3] from [1,3,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9
                 - [1] from [1,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
                 - [2] from [1,3,1,2] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4
                 - [1,3] from [1,3,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4
                 - [3,1] from [1,3,1,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4
                 - [1,2] from [1,3,1,2] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3
                 - [1,3,1] from [1,3,1,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5
                 - [3,1,2] from [1,3,1,2] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6
                 - [1,3,1,2] from [1,3,1,2] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7
                 The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.

    Example 2:
    Input: strength = [5,4,6]
    Output: 213
    Explanation: The following are all the contiguous groups of wizards:
                 - [5] from [5,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25
                 - [4] from [5,4,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16
                 - [6] from [5,4,6] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36
                 - [5,4] from [5,4,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36
                 - [4,6] from [5,4,6] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40
                 - [5,4,6] from [5,4,6] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60
                 The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.

    Constraints:
    * 1 <= strength.length <= 10^5
    * 1 <= strength[i] <= 10^9"""

    def totalStrength(self, strength: List[int]) -> int:
        ans = 0
        stack = []
        prefix = list(accumulate(accumulate(strength, initial=0), initial=0))
        for i, x in enumerate(strength + [0]):
            while stack and stack[-1][1] >= x:
                mid = stack.pop()[0]
                lo = stack[-1][0] if stack else -1
                left = prefix[mid+1] - prefix[lo+1]
                right = prefix[i+1] - prefix[mid+1]
                ans = (ans + strength[mid]*(right*(mid-lo) - left*(i-mid))) % 1_000_000_007
            stack.append((i, x))
        return ans


    """2282. Number of People That Can Be Seen in a Grid (Medium)
    You are given an m x n 0-indexed 2D array of positive integers heights
    where heights[i][j] is the height of the person standing at position (i, j).
    A person standing at position (row1, col1) can see a person standing at
    position (row2, col2) if:
    * The person at (row2, col2) is to the right or below the person at
      (row1, col1). More formally, this means that either row1 == row2 and
      col1 < col2 or row1 < row2 and col1 == col2.
    * Everyone in between them is shorter than both of them.
    Return an m x n 2D array of integers answer where answer[i][j] is the
    number of people that the person at position (i, j) can see.

    Example 1:
    Input: heights = [[3,1,4,2,5]]
    Output: [[2,1,2,1,0]]
    Explanation: - The person at (0, 0) can see the people at (0, 1) and (0, 2).
                   Note that he cannot see the person at (0, 4) because the
                   person at (0, 2) is taller than him.
                 - The person at (0, 1) can see the person at (0, 2).
                 - The person at (0, 2) can see the people at (0, 3) and (0, 4).
                 - The person at (0, 3) can see the person at (0, 4).
                 - The person at (0, 4) cannot see anybody.

    Example 2:
    Input: heights = [[5,1],[3,1],[4,1]]
    Output: [[3,1],[2,1],[1,0]]
    Explanation: - The person at (0, 0) can see the people at (0, 1), (1, 0)
                   and (2, 0).
                 - The person at (0, 1) can see the person at (1, 1).
                 - The person at (1, 0) can see the people at (1, 1) and (2, 0).
                 - The person at (1, 1) can see the person at (2, 1).
                 - The person at (2, 0) can see the person at (2, 1).
                 - The person at (2, 1) cannot see anybody.

    Constraints:
    * 1 <= heights.length <= 400
    * 1 <= heights[i].length <= 400
    * 1 <= heights[i][j] <= 10^5"""

    def seePeople(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            stack = []
            for j in range(n):
                prev = -inf
                while stack and heights[i][stack[-1]] < heights[i][j]:
                    if prev < heights[i][stack[-1]]: ans[i][stack[-1]] += 1
                    prev = heights[i][stack.pop()]
                if stack and prev < heights[i][stack[-1]]: ans[i][stack[-1]] += 1
                stack.append(j)
        for j in range(n):
            stack = []
            for i in range(m):
                prev = -inf
                while stack and heights[stack[-1]][j] < heights[i][j]:
                    if prev < heights[stack[-1]][j]: ans[stack[-1]][j] += 1
                    prev = heights[stack.pop()][j]
                if stack and prev < heights[stack[-1]][j]: ans[stack[-1]][j] += 1
                stack.append(i)
        return ans


    """2283. Check if Number Has Equal Digit Count and Digit Value (Easy)
    You are given a 0-indexed string num of length n consisting of digits.
    Return true if for every index i in the range 0 <= i < n, the digit i
    occurs num[i] times in num, otherwise return false.

    Example 1:
    Input: num = "1210"
    Output: true
    Explanation: num[0] = '1'. The digit 0 occurs once in num.
                 num[1] = '2'. The digit 1 occurs twice in num.
                 num[2] = '1'. The digit 2 occurs once in num.
                 num[3] = '0'. The digit 3 occurs zero times in num.
                 The condition holds true for every index in "1210", so return
                 true.

    Example 2:
    Input: num = "030"
    Output: false
    Explanation: num[0] = '0'. The digit 0 should occur zero times, but
                               actually occurs twice in num.
                 num[1] = '3'. The digit 1 should occur three times, but
                               actually occurs zero times in num.
                 num[2] = '0'. The digit 2 occurs zero times in num.
                 The indices 0 and 1 both violate the condition, so return
                 false.

    Constraints:
    * n == num.length
    * 1 <= n <= 10
    * num consists of digits."""

    def digitCount(self, num: str) -> bool:
        freq = Counter(map(int, str(num)))
        return all(freq[i] == int(ch) for i, ch in enumerate(str(num)))


    """2284. Sender With Largest Word Count (Medium)
    You have a chat log of n messages. You are given two string arrays messages
    and senders where messages[i] is a message sent by senders[i]. A message is
    list of words that are separated by a single space with no leading or
    trailing spaces. The word count of a sender is the total number of words
    sent by the sender. Note that a sender may send more than one message.
    Return the sender with the largest word count. If there is more than one
    sender with the largest word count, return the one with the
    lexicographically largest name.

    Note: Uppercase letters come before lowercase letters in lexicographical
          order. "Alice" and "alice" are distinct.

    Example 1:
    Input: messages = ["Hello userTwooo","Hi userThree","Wonderful day Alice","Nice day userThree"], senders = ["Alice","userTwo","userThree","Alice"]
    Output: "Alice"
    Explanation: Alice sends a total of 2 + 3 = 5 words. userTwo sends a total
                 of 2 words. userThree sends a total of 3 words. Since Alice
                 has the largest word count, we return "Alice".

    Example 2:
    Input: messages = ["How is leetcode for everyone","Leetcode is useful for practice"], senders = ["Bob","Charlie"]
    Output: "Charlie"
    Explanation: Bob sends a total of 5 words. Charlie sends a total of 5 words.
                 Since there is a tie for the largest word count, we return the
                 sender with the lexicographically larger name, Charlie.

    Constraints:
    * n == messages.length == senders.length
    * 1 <= n <= 10^4
    * 1 <= messages[i].length <= 100
    * 1 <= senders[i].length <= 10
    * messages[i] consists of uppercase and lowercase English letters and ' '.
    * All the words in messages[i] are separated by a single space.
    * messages[i] does not have leading or trailing spaces.
    * senders[i] consists of uppercase and lowercase English letters only."""

    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:
        freq = defaultdict(int)
        for m, s in zip(messages, senders): freq[s] += len(m.split())
        return max(freq, key=lambda x: (freq[x], x))


    """2285. Maximum Total Importance of Roads (Medium)
    You are given an integer n denoting the number of cities in a country. The
    cities are numbered from 0 to n - 1. You are also given a 2D integer array
    roads where roads[i] = [ai, bi] denotes that there exists a bidirectional
    road connecting cities ai and bi. You need to assign each city with an
    integer value from 1 to n, where each value can only be used once. The
    importance of a road is then defined as the sum of the values of the two
    cities it connects. Return the maximum total importance of all roads
    possible after assigning the values optimally.

    Example 1:
    Input: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
    Output: 43
    Explanation: The figure above shows the country and the assigned values of
                 [2,4,5,3,1].
                 - The road (0,1) has an importance of 2 + 4 = 6.
                 - The road (1,2) has an importance of 4 + 5 = 9.
                 - The road (2,3) has an importance of 5 + 3 = 8.
                 - The road (0,2) has an importance of 2 + 5 = 7.
                 - The road (1,3) has an importance of 4 + 3 = 7.
                 - The road (2,4) has an importance of 5 + 1 = 6.
                 The total importance of all roads is
                 6 + 9 + 8 + 7 + 7 + 6 = 43. It can be shown that we cannot
                 obtain a greater total importance than 43.

    Example 2:
    Input: n = 5, roads = [[0,3],[2,4],[1,3]]
    Output: 20
    Explanation: The figure above shows the country and the assigned values of
                 [4,3,2,5,1].
                 - The road (0,3) has an importance of 4 + 5 = 9.
                 - The road (2,4) has an importance of 2 + 1 = 3.
                 - The road (1,3) has an importance of 3 + 5 = 8.
                 The total importance of all roads is 9 + 3 + 8 = 20. It can be
                 shown that we cannot obtain a greater total importance than 20.

    Constraints:
    * 2 <= n <= 5 * 10^4
    * 1 <= roads.length <= 5 * 10^4
    * roads[i].length == 2
    * 0 <= ai, bi <= n - 1
    * ai != bi
    * There are no duplicate roads."""

    def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
        degree = [0]*n
        for u, v in roads:
            degree[u] += 1
            degree[v] += 1
        return sum(x*y for x, y in zip(range(1, n+1), sorted(degree)))


    """2287. Rearrange Characters to Make Target String (Easy)
    You are given two 0-indexed strings s and target. You can take some letters
    from s and rearrange them to form new strings. Return the maximum number of
    copies of target that can be formed by taking letters from s and
    rearranging them.

    Example 1:
    Input: s = "ilovecodingonleetcode", target = "code"
    Output: 2
    Explanation: For the first copy of "code", take the letters at indices 4, 5,
                 6, and 7. For the second copy of "code", take the letters at
                 indices 17, 18, 19, and 20. The strings that are formed are
                 "ecod" and "code" which can both be rearranged into "code". We
                 can make at most two copies of "code", so we return 2.

    Example 2:
    Input: s = "abcba", target = "abc"
    Output: 1
    Explanation: We can make one copy of "abc" by taking the letters at indices
                 0, 1, and 2. We can make at most one copy of "abc", so we
                 return 1. Note that while there is an extra 'a' and 'b' at
                 indices 3 and 4, we cannot reuse the letter 'c' at index 2, so
                 we cannot make a second copy of "abc".

    Example 3:
    Input: s = "abbaccaddaeea", target = "aaaaa"
    Output: 1
    Explanation: We can make one copy of "aaaaa" by taking the letters at
                 indices 0, 3, 6, 9, and 12. We can make at most one copy of
                 "aaaaa", so we return 1.

    Constraints:
    * 1 <= s.length <= 100
    * 1 <= target.length <= 10
    * s and target consist of lowercase English letters."""

    def rearrangeCharacters(self, s: str, target: str) -> int:
        freq = Counter(s)
        return min(freq[k]//v for k, v in Counter(target).items())


    """2288. Apply Discount to Prices (Medium)
    A sentence is a string of single-space separated words where each word can
    contain digits, lowercase letters, and the dollar sign '$'. A word
    represents a price if it is a sequence of digits preceded by a dollar sign.
    * For example, "$100", "$23", and "$6" represent prices while "100", "$",
      and "$1e5" do not.
    You are given a string sentence representing a sentence and an integer
    discount. For each word representing a price, apply a discount of discount%
    on the price and update the word in the sentence. All updated prices should
    be represented with exactly two decimal places. Return a string
    representing the modified sentence. Note that all prices will contain at
    most 10 digits.

    Example 1:
    Input: sentence = "there are $1 $2 and 5$ candies in the shop", discount = 50
    Output: "there are $0.50 $1.00 and 5$ candies in the shop"
    Explanation: The words which represent prices are "$1" and "$2".
                 - A 50% discount on "$1" yields "$0.50", so "$1" is replaced
                   by "$0.50".
                 - A 50% discount on "$2" yields "$1". Since we need to have
                   exactly 2 decimal places after a price, we replace "$2" with
                   "$1.00".

    Example 2:
    Input: sentence = "1 2 $3 4 $5 $6 7 8$ $9 $10$", discount = 100
    Output: "1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$"
    Explanation: Applying a 100% discount on any price will result in 0. The
                 words representing prices are "$3", "$5", "$6", and "$9". Each
                 of them is replaced by "$0.00".

    Constraints:
    * 1 <= sentence.length <= 10^5
    * sentence consists of lowercase English letters, digits, ' ', and '$'.
    * sentence does not have leading or trailing spaces.
    * All words in sentence are separated by a single space.
    * All prices will be positive numbers without leading zeros.
    * All prices will have at most 10 digits.
    * 0 <= discount <= 100"""

    def discountPrices(self, sentence: str, discount: int) -> str:
        words = sentence.split()
        ans = []
        for word in words:
            if word.startswith('$') and word[1:].isdigit():
                word = f'${int(word[1:])*(1-discount/100):.2f}'
            ans.append(word)
        return ' '.join(ans)


    """2289. Steps to Make Array Non-decreasing (Medium)
    You are given a 0-indexed integer array nums. In one step, remove all
    elements nums[i] where nums[i - 1] > nums[i] for all 0 < i < nums.length.
    Return the number of steps performed until nums becomes a non-decreasing
    array.

    Example 1:
    Input: nums = [5,3,4,4,7,3,6,11,8,5,11]
    Output: 3
    Explanation: The following are the steps performed:
                 - Step 1: [5,3,4,4,7,3,6,11,8,5,11] becomes [5,4,4,7,6,11,11]
                 - Step 2: [5,4,4,7,6,11,11] becomes [5,4,7,11,11]
                 - Step 3: [5,4,7,11,11] becomes [5,7,11,11]
                 [5,7,11,11] is a non-decreasing array. Therefore, we return 3.

    Example 2:
    Input: nums = [4,5,7,7,13]
    Output: 0
    Explanation: nums is already a non-decreasing array. Therefore, we return 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def totalSteps(self, nums: List[int]) -> int:
        ans = 0
        stack = []
        for x in nums:
            val = 1
            while stack and stack[-1][0] <= x: val = max(val, stack.pop()[1]+1)
            if not stack: val = 0
            stack.append((x, val))
            ans = max(ans, val)
        return ans


    """2290. Minimum Obstacle Removal to Reach Corner (Hard)
    You are given a 0-indexed 2D integer array grid of size m x n. Each cell
    has one of two values:
    * 0 represents an empty cell,
    * 1 represents an obstacle that may be removed.
    You can move up, down, left, or right from and to an empty cell. Return the
    minimum number of obstacles to remove so you can move from the upper left
    corner (0, 0) to the lower right corner (m - 1, n - 1).

    Example 1:
    Input: grid = [[0,1,1],[1,1,0],[1,1,0]]
    Output: 2
    Explanation: We can remove the obstacles at (0, 1) and (0, 2) to create a
                 path from (0, 0) to (2, 2). It can be shown that we need to
                 remove at least 2 obstacles, so we return 2. Note that there
                 may be other ways to remove 2 obstacles to create a path.

    Example 2:
    Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
    Output: 0
    Explanation: We can move from (0, 0) to (2, 4) without removing any
                 obstacles, so we return 0.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10^5
    * 2 <= m * n <= 10^5
    * grid[i][j] is either 0 or 1.
    * grid[0][0] == grid[m - 1][n - 1] == 0"""

    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dist = [[inf]*n for _ in range(m)]
        dist[0][0] = 0
        pq = [(0, 0, 0)]
        while pq:
            x, i, j = heappop(pq)
            if i == m-1 and j == n-1: return x
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and x + grid[ii][jj] < dist[ii][jj]:
                    dist[ii][jj] = x + grid[ii][jj]
                    heappush(pq, (dist[ii][jj], ii, jj))


    """2291. Maximum Profit From Trading Stocks (Medium)
    You are given two 0-indexed integer arrays of the same length present and
    future where present[i] is the current price of the ith stock and future[i]
    is the price of the ith stock a year in the future. You may buy each stock
    at most once. You are also given an integer budget representing the amount
    of money you currently have. Return the maximum amount of profit you can
    make.

    Example 1:
    Input: present = [5,4,6,2,3], future = [8,5,4,3,5], budget = 10
    Output: 6
    Explanation: One possible way to maximize your profit is to:
                 Buy the 0th, 3rd, and 4th stocks for a total of 5 + 2 + 3 = 10.
                 Next year, sell all three stocks for a total of 8 + 3 + 5 = 16.
                 The profit you made is 16 - 10 = 6. It can be shown that the
                 maximum profit you can make is 6.

    Example 2:
    Input: present = [2,2,5], future = [3,4,10], budget = 6
    Output: 5
    Explanation: The only possible way to maximize your profit is to:
                 Buy the 2nd stock, and make a profit of 10 - 5 = 5.
                 It can be shown that the maximum profit you can make is 5.

    Example 3:
    Input: present = [3,3,12], future = [0,3,15], budget = 10
    Output: 0
    Explanation: One possible way to maximize your profit is to:
                 Buy the 1st stock, and make a profit of 3 - 3 = 0.
                 It can be shown that the maximum profit you can make is 0.

    Constraints:
    * n == present.length == future.length
    * 1 <= n <= 1000
    * 0 <= present[i], future[i] <= 100
    * 0 <= budget <= 1000"""

    def maximumProfit(self, present: List[int], future: List[int], budget: int) -> int:
        dp = [0] * (budget+1)
        for p, f in zip(present, future):
            for i in range(budget, p-1, -1):
                dp[i] = max(dp[i], dp[i-p] + f - p)
        return dp[-1]


    """2293. Min Max Game (Easy)
    You are given a 0-indexed integer array nums whose length is a power of 2.
    Apply the following algorithm on nums:
    * Let n be the length of nums. If n == 1, end the process. Otherwise,
      create a new 0-indexed integer array newNums of length n / 2.
    * For every even index i where 0 <= i < n / 2, assign the value of
      newNums[i] as min(nums[2 * i], nums[2 * i + 1]).
    * For every odd index i where 0 <= i < n / 2, assign the value of
      newNums[i] as max(nums[2 * i], nums[2 * i + 1]).
    * Replace the array nums with newNums.
    * Repeat the entire process starting from step 1.
    Return the last number that remains in nums after applying the algorithm.

    Example 1:
    Input: nums = [1,3,5,2,4,8,2,2]
    Output: 1
    Explanation: The following arrays are the results of applying the algorithm
                 repeatedly.
                 First: nums = [1,5,4,2]
                 Second: nums = [1,4]
                 Third: nums = [1]
                 1 is the last remaining number, so we return 1.

    Example 2:
    Input: nums = [3]
    Output: 3
    Explanation: 3 is already the last remaining number, so we return 3.

    Constraints:
    * 1 <= nums.length <= 1024
    * 1 <= nums[i] <= 10^9
    * nums.length is a power of 2."""

    def minMaxGame(self, nums: List[int]) -> int:
        n = len(nums)
        while n > 1:
            for i in range(n//2):
                if i&1: nums[i] = max(nums[2*i], nums[2*i+1])
                else: nums[i] = min(nums[2*i], nums[2*i+1])
            n //= 2
        return nums[0]


    """2294. Partition Array Such That Maximum Difference Is K (Medium)
    You are given an integer array nums and an integer k. You may partition
    nums into one or more subsequences such that each element in nums appears
    in exactly one of the subsequences. Return the minimum number of
    subsequences needed such that the difference between the maximum and
    minimum values in each subsequence is at most k. A subsequence is a
    sequence that can be derived from another sequence by deleting some or no
    elements without changing the order of the remaining elements.

    Example 1:
    Input: nums = [3,6,1,2,5], k = 2
    Output: 2
    Explanation: We can partition nums into the two subsequences [3,1,2] and
                 [6,5]. The difference between the maximum and minimum value
                 in the first subsequence is 3 - 1 = 2. The difference between
                 the maximum and minimum value in the second subsequence is
                 6 - 5 = 1. Since two subsequences were created, we return 2.
                 It can be shown that 2 is the minimum number of subsequences
                 needed.

    Example 2:
    Input: nums = [1,2,3], k = 1
    Output: 2
    Explanation: We can partition nums into the two subsequences [1,2] and [3].
                 The difference between the maximum and minimum value in the
                 first subsequence is 2 - 1 = 1. The difference between the
                 maximum and minimum value in the second subsequence is
                 3 - 3 = 0. Since two subsequences were created, we return 2.
                 Note that another optimal solution is to partition nums into
                 the two subsequences [1] and [2,3].

    Example 3:
    Input: nums = [2,2,4,5], k = 0
    Output: 3
    Explanation: We can partition nums into the three subsequences [2,2], [4],
                 and [5]. The difference between the maximum and minimum value
                 in the first subsequences is 2 - 2 = 0. The difference between
                 the maximum and minimum value in the second subsequences is
                 4 - 4 = 0. The difference between the maximum and minimum
                 value in the third subsequences is 5 - 5 = 0. Since three
                 subsequences were created, we return 3. It can be shown that 3
                 is the minimum number of subsequences needed.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5
    * 0 <= k <= 10^5"""

    def partitionArray(self, nums: List[int], k: int) -> int:
        ans = 0
        prev = -inf
        for x in sorted(set(nums)):
            if x > prev+k:
                ans += 1
                prev = x
        return ans


    """2295. Replace Elements in an Array (Medium)
    You are given a 0-indexed array nums that consists of n distinct positive
    integers. Apply m operations to this array, where in the ith operation you
    replace the number operations[i][0] with operations[i][1]. It is guaranteed
    that in the ith operation:
    * operations[i][0] exists in nums.
    * operations[i][1] does not exist in nums.
    Return the array obtained after applying all the operations.

    Example 1:
    Input: nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]
    Output: [3,2,7,1]
    Explanation: We perform the following operations on nums:
                 - Replace the number 1 with 3. nums becomes [3,2,4,6].
                 - Replace the number 4 with 7. nums becomes [3,2,7,6].
                 - Replace the number 6 with 1. nums becomes [3,2,7,1].
                 We return the final array [3,2,7,1].

    Example 2:
    Input: nums = [1,2], operations = [[1,3],[2,1],[3,2]]
    Output: [2,1]
    Explanation: We perform the following operations to nums:
                 - Replace the number 1 with 3. nums becomes [3,2].
                 - Replace the number 2 with 1. nums becomes [3,1].
                 - Replace the number 3 with 2. nums becomes [2,1].
                 We return the array [2,1].

    Constraints:
    * n == nums.length
    * m == operations.length
    * 1 <= n, m <= 10^5
    * All the values of nums are distinct.
    * operations[i].length == 2
    * 1 <= nums[i], operations[i][0], operations[i][1] <= 10^6
    * operations[i][0] will exist in nums when applying the ith operation.
    * operations[i][1] will not exist in nums when applying the ith operation."""

    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:
        mp = {}
        for x, y in reversed(operations): mp[x] = mp.get(y, y)
        return [mp.get(x, x) for x in nums]


    """2297. Jump Game VIII (Medium)
    You are given a 0-indexed integer array nums of length n. You are initially
    standing at index 0. You can jump from index i to index j where i < j if:
    * nums[i] <= nums[j] and nums[k] < nums[i] for all indexes k in the range
      i < k < j, or
    * nums[i] > nums[j] and nums[k] >= nums[i] for all indexes k in the range
      i < k < j.
    You are also given an integer array costs of length n where costs[i]
    denotes the cost of jumping to index i. Return the minimum cost to jump to
    the index n - 1.

    Example 1:
    Input: nums = [3,2,4,4,1], costs = [3,7,6,4,2]
    Output: 8
    Explanation: You start at index 0.
                 - Jump to index 2 with a cost of costs[2] = 6.
                 - Jump to index 4 with a cost of costs[4] = 2.
                 The total cost is 8. It can be proven that 8 is the minimum
                 cost needed. Two other possible paths are from index 0 -> 1 ->
                 4 and index 0 -> 2 -> 3 -> 4. These have a total cost of 9 and
                 12, respectively.

    Example 2:
    Input: nums = [0,1,2], costs = [1,1,1]
    Output: 2
    Explanation: Start at index 0.
                 - Jump to index 1 with a cost of costs[1] = 1.
                 - Jump to index 2 with a cost of costs[2] = 1.
                 The total cost is 2. Note that you cannot jump directly from
                 index 0 to index 2 because nums[0] <= nums[1].

    Constraints:
    * n == nums.length == costs.length
    * 1 <= n <= 10^5
    * 0 <= nums[i], costs[i] <= 10^5"""

    def minCost(self, nums: List[int], costs: List[int]) -> int:
        jump = [[] for _ in range(len(nums))]
        s0, s1 = [], []
        for i, x in enumerate(nums):
            while s0 and s0[-1][1] <= x: jump[i].append(s0.pop()[0])
            while s1 and s1[-1][1] > x: jump[i].append(s1.pop()[0])
            s0.append((i, x))
            s1.append((i, x))
        dp = [inf] * len(nums)
        dp[0] = 0
        for i, x in enumerate(costs):
            for k in jump[i]: dp[i] = min(dp[i], dp[k] + x)
        return dp[-1]


    """2303. Calculate Amount Paid in Taxes (Easy)
    You are given a 0-indexed 2D integer array brackets where
    brackets[i] = [upperi, percenti] means that the ith tax bracket has an
    upper bound of upperi and is taxed at a rate of percenti. The brackets are
    sorted by upper bound (i.e. upperi-1 < upperi for 0 < i < brackets.length).

    Tax is calculated as follows:
    * The first upper0 dollars earned are taxed at a rate of percent0.
    * The next upper1 - upper0 dollars earned are taxed at a rate of percent1.
    * The next upper2 - upper1 dollars earned are taxed at a rate of percent2.
    * And so on.
    You are given an integer income representing the amount of money you earned.
    Return the amount of money that you have to pay in taxes. Answers within
    10^-5 of the actual answer will be accepted.

    Example 1:
    Input: brackets = [[3,50],[7,10],[12,25]], income = 10
    Output: 2.65000
    Explanation: The first 3 dollars you earn are taxed at 50%. You have to pay
                 $3 * 50% = $1.50 dollars in taxes. The next 7 - 3 = 4 dollars
                 you earn are taxed at 10%. You have to pay $4 * 10% = $0.40
                 dollars in taxes. The final 10 - 7 = 3 dollars you earn are
                 taxed at 25%. You have to pay $3 * 25% = $0.75 dollars in
                 taxes. You have to pay a total of $1.50 + $0.40 + $0.75 = $2.65
                 dollars in taxes.

    Example 2:
    Input: brackets = [[1,0],[4,25],[5,50]], income = 2
    Output: 0.25000
    Explanation: The first dollar you earn is taxed at 0%. You have to pay
                 $1 * 0% = $0 dollars in taxes. The second dollar you earn is
                 taxed at 25%. You have to pay $1 * 25% = $0.25 dollars in
                 taxes. You have to pay a total of $0 + $0.25 = $0.25 dollars
                 in taxes.

    Example 3:
    Input: brackets = [[2,50]], income = 0
    Output: 0.00000
    Explanation: You have no income to tax, so you have to pay a total of $0
                 dollars in taxes.

    Constraints:
    * 1 <= brackets.length <= 100
    * 1 <= upperi <= 1000
    * 0 <= percenti <= 100
    * 0 <= income <= 1000
    * upperi is sorted in ascending order.
    * All the values of upperi are unique.
    * The upper bound of the last tax bracket is greater than or equal to
      income."""

    def calculateTax(self, brackets: List[List[int]], income: int) -> float:
        ans = prev = 0
        for hi, pct in brackets:
            hi = min(hi, income)
            ans += (hi - prev)*pct/100
            prev = hi
        return ans


    """2304. Minimum Path Cost in a Grid (Medium)
    You are given a 0-indexed m x n integer matrix grid consisting of distinct
    integers from 0 to m * n - 1. You can move in this matrix from a cell to
    any other cell in the next row. That is, if you are in cell (x, y) such
    that x < m - 1, you can move to any of the cells (x + 1, 0), (x + 1, 1),
    ..., (x + 1, n - 1). Note that it is not possible to move from cells in the
    last row. Each possible move has a cost given by a 0-indexed 2D array
    moveCost of size (m * n) x n, where moveCost[i][j] is the cost of moving
    from a cell with value i to a cell in column j of the next row. The cost of
    moving from cells in the last row of grid can be ignored. The cost of a
    path in grid is the sum of all values of cells visited plus the sum of
    costs of all the moves made. Return the minimum cost of a path that starts
    from any cell in the first row and ends at any cell in the last row.

    Example 1:
    Input: grid = [[5,3],[4,0],[2,1]],
           moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]
    Output: 17
    Explanation: The path with the minimum possible cost is the path 5 -> 0 -> 1.
                 - The sum of the values of cells visited is 5 + 0 + 1 = 6.
                 - The cost of moving from 5 to 0 is 3.
                 - The cost of moving from 0 to 1 is 8.
                 So the total cost of the path is 6 + 3 + 8 = 17.

    Example 2:
    Input: grid = [[5,1,2],[4,0,3]],
           moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]
    Output: 6
    Explanation: The path with the minimum possible cost is the path 2 -> 3.
                 - The sum of the values of cells visited is 2 + 3 = 5.
                 - The cost of moving from 2 to 3 is 1.
                 So the total cost of this path is 5 + 1 = 6.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 50
    * grid consists of distinct integers from 0 to m * n - 1.
    * moveCost.length == m * n
    * moveCost[i].length == n
    * 1 <= moveCost[i][j] <= 100"""

    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        @cache
        def fn(i, j):
            """Return min cost of moving from (i, j) to bottom row."""
            if i == m-1: return grid[i][j]
            ans = inf
            for jj in range(n):
                ans = min(ans, grid[i][j] + fn(i+1, jj) + moveCost[grid[i][j]][jj])
            return ans

        return min(fn(0, j) for j in range(n))


    """2305. Fair Distribution of Cookies (Medium)
    You are given an integer array cookies, where cookies[i] denotes the number
    of cookies in the ith bag. You are also given an integer k that denotes the
    number of children to distribute all the bags of cookies to. All the
    cookies in the same bag must go to the same child and cannot be split up.
    The unfairness of a distribution is defined as the maximum total cookies
    obtained by a single child in the distribution. Return the minimum
    unfairness of all distributions.

    Example 1:
    Input: cookies = [8,15,10,20,8], k = 2
    Output: 31
    Explanation: One optimal distribution is [8,15,8] and [10,20]
                 - The 1st child receives [8,15,8] which has a total of
                   8 + 15 + 8 = 31 cookies.
                 - The 2nd child receives [10,20] which has a total of
                   10 + 20 = 30 cookies.
                 The unfairness of the distribution is max(31,30) = 31. It can
                 be shown that there is no distribution with an unfairness less
                 than 31.

    Example 2:
    Input: cookies = [6,1,3,2,2,4,1,2], k = 3
    Output: 7
    Explanation: One optimal distribution is [6,1], [3,2,2], and [4,1,2]
                 - The 1st child receives [6,1] which has a total of 6 + 1 = 7
                   cookies.
                 - The 2nd child receives [3,2,2] which has a total of
                   3 + 2 + 2 = 7 cookies.
                 - The 3rd child receives [4,1,2] which has a total of
                   4 + 1 + 2 = 7 cookies.
                 The unfairness of the distribution is max(7,7,7) = 7. It can
                 be shown that there is no distribution with an unfairness less
                 than 7.

    Constraints:
    * 2 <= cookies.length <= 8
    * 1 <= cookies[i] <= 10^5
    * 2 <= k <= cookies.length"""

    def distributeCookies(self, cookies: List[int], k: int) -> int:
        n = len(cookies)

        @cache
        def fn(mask, k):
            """Return min unfairness of distributing cookies marked by mask to k children."""
            if mask == 0: return 0
            if k == 0: return inf
            ans = inf
            orig = mask
            while mask:
                mask = orig & (mask - 1)
                amt = sum(cookies[i] for i in range(n) if (orig ^ mask) & 1<<i)
                ans = min(ans, max(amt, fn(mask, k-1)))
            return ans

        return fn((1<<n)-1, k)


    """2306. Naming a Company (Hard)
    You are given an array of strings ideas that represents a list of names to
    be used in the process of naming a company. The process of naming a company
    is as follows:
    * Choose 2 distinct names from ideas, call them ideaA and ideaB.
    * Swap the first letters of ideaA and ideaB with each other.
    * If both of the new names are not found in the original ideas, then the
      name ideaA ideaB (the concatenation of ideaA and ideaB, separated by a
      space) is a valid company name.
    * Otherwise, it is not a valid name.
    Return the number of distinct valid names for the company.

    Example 1:
    Input: ideas = ["coffee","donuts","time","toffee"]
    Output: 6
    Explanation: The following selections are valid:
                 - ("coffee", "donuts"): The company name created is "doffee
                   conuts".
                 - ("donuts", "coffee"): The company name created is "conuts
                   doffee".
                 - ("donuts", "time"): The company name created is "tonuts
                   dime".
                 - ("donuts", "toffee"): The company name created is "tonuts
                   doffee".
                 - ("time", "donuts"): The company name created is "dime tonuts".
                 - ("toffee", "donuts"): The company name created is "doffee
                   tonuts".
                 Therefore, there are a total of 6 distinct company names. The
                 following are some examples of invalid selections:
                 - ("coffee", "time"): The name "toffee" formed after swapping
                   already exists in the original array.
                 - ("time", "toffee"): Both names are still the same after
                   swapping and exist in the original array.
                 - ("coffee", "toffee"): Both names formed after swapping
                   already exist in the original array.

    Example 2:
    Input: ideas = ["lack","back"]
    Output: 0
    Explanation: There are no valid selections. Therefore, 0 is returned.

    Constraints:
    * 2 <= ideas.length <= 5 * 10^4
    * 1 <= ideas[i].length <= 10
    * ideas[i] consists of lowercase English letters.
    * All the strings in ideas are unique."""

    def distinctNames(self, ideas: List[str]) -> int:
        seen = set(ideas)
        freq = Counter()
        letters = {x[0] for x in ideas}
        for idea in ideas:
            for ch in letters:
                if ch + idea[1:] not in seen: freq[idea[0], ch] += 1
        ans = 0
        for idea in ideas:
            for ch in letters:
                if ch + idea[1:] not in seen: ans += freq[ch, idea[0]]
        return ans


    """2307. Check for Contradictions in Equations (Hard)
    You are given a 2D array of strings equations and an array of real numbers
    values, where equations[i] = [Ai, Bi] and values[i] means that
    Ai / Bi = values[i]. Determine if there exists a contradiction in the
    equations. Return true if there is a contradiction, or false otherwise.

    Note:
    * When checking if two numbers are equal, check that their absolute
      difference is less than 10-5.
    * The testcases are generated such that there are no cases targeting
      precision, i.e. using double is enough to solve the problem.

    Example 1:
    Input: equations = [["a","b"],["b","c"],["a","c"]], values = [3,0.5,1.5]
    Output: false
    Explanation: The given equations are: a / b = 3, b / c = 0.5, a / c = 1.5
                 There are no contradictions in the equations. One possible
                 assignment to satisfy all equations is: a = 3, b = 1 and c = 2.

    Example 2:
    Input: equations = [["le","et"],["le","code"],["code","et"]], values = [2,5,0.5]
    Output: true
    Explanation: The given equations are: le / et = 2, le / code = 5,
                 code / et = 0.5 Based on the first two equations, we get
                 code / et = 0.4. Since the third equation is
                 code / et = 0.5, we get a contradiction.

    Constraints:
    * 1 <= equations.length <= 100
    * equations[i].length == 2
    * 1 <= Ai.length, Bi.length <= 5
    * Ai, Bi consist of lowercase English letters.
    * equations.length == values.length
    * 0.0 < values[i] <= 10.0
    * values[i] has a maximum of 2 decimal places."""

    def checkContradictions(self, equations: List[List[str]], values: List[float]) -> bool:
        node = set()
        graph = defaultdict(list)
        for (u, v), w in zip(equations, values):
            node |= {u, v}
            graph[u].append((v, w))
            graph[v].append((u, 1/w))
        vals = {}
        for u in node:
            if u not in vals:
                stack = [u]
                vals[u] = 1
                while stack:
                    u = stack.pop()
                    for v, w in graph[u]:
                        if v in vals:
                            if abs(vals[v] - vals[u]/w) >= 1e-5*vals[v]: return True
                        else:
                            stack.append(v)
                            vals[v] = vals[u] / w
        return False


    """2309. Greatest English Letter in Upper and Lower Case (Easy)
    Given a string of English letters s, return the greatest English letter
    which occurs as both a lowercase and uppercase letter in s. The returned
    letter should be in uppercase. If no such letter exists, return an empty
    string. An English letter b is greater than another letter a if b appears
    after a in the English alphabet.

    Example 1:
    Input: s = "lEeTcOdE"
    Output: "E"
    Explanation: The letter 'E' is the only letter to appear in both lower and
                 upper case.

    Example 2:
    Input: s = "arRAzFif"
    Output: "R"
    Explanation: The letter 'R' is the greatest letter to appear in both lower
                 and upper case. Note that 'A' and 'F' also appear in both
                 lower and upper case, but 'R' is greater than 'F' or 'A'.

    Example 3:
    Input: s = "AbCdEfGhIjK"
    Output: ""
    Explanation: There is no letter that appears in both lower and upper case.

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of lowercase and uppercase English letters."""

    def greatestLetter(self, s: str) -> str:
        seen = set(s)
        for ch in reversed(ascii_uppercase):
            if ch in seen and ch.swapcase() in seen: return ch
        return ""


    """2310. Sum of Numbers With Units Digit K (Medium)
    Given two integers num and k, consider a set of positive integers with the
    following properties:
    * The units digit of each integer is k.
    * The sum of the integers is num.
    Return the minimum possible size of such a set, or -1 if no such set exists.

    Note:
    * The set can contain multiple instances of the same integer, and the sum
      of an empty set is considered 0.
    * The units digit of a number is the rightmost digit of the number.

    Example 1:
    Input: num = 58, k = 9
    Output: 2
    Explanation: One valid set is [9,49], as the sum is 58 and each integer has
                 a units digit of 9. Another valid set is [19,39]. It can be
                 shown that 2 is the minimum possible size of a valid set.

    Example 2:
    Input: num = 37, k = 2
    Output: -1
    Explanation: It is not possible to obtain a sum of 37 using only integers
                 that have a units digit of 2.

    Example 3:
    Input: num = 0, k = 7
    Output: 0
    Explanation: The sum of an empty set is considered 0.

    Constraints:
    * 0 <= num <= 3000
    * 0 <= k <= 9"""

    def minimumNumbers(self, num: int, k: int) -> int:
        if num == 0: return 0
        for x in range(1, 11):
            if x*k <= num and (num - x*k) % 10 == 0: return x
        return -1


    """2311. Longest Binary Subsequence Less Than or Equal to K (Medium)
    You are given a binary string s and a positive integer k. Return the length
    of the longest subsequence of s that makes up a binary number less than or
    equal to k.

    Note:
    * The subsequence can contain leading zeroes.
    * The empty string is considered to be equal to 0.
    * A subsequence is a string that can be derived from another string by
      deleting some or no characters without changing the order of the
      remaining characters.

    Example 1:
    Input: s = "1001010", k = 5
    Output: 5
    Explanation: The longest subsequence of s that makes up a binary number
                 less than or equal to 5 is "00010", as this number is equal to
                 2 in decimal. Note that "00100" and "00101" are also possible,
                 which are equal to 4 and 5 in decimal, respectively. The
                 length of this subsequence is 5, so 5 is returned.

    Example 2:
    Input: s = "00101001", k = 1
    Output: 6
    Explanation: "000001" is the longest subsequence of s that makes up a
                 binary number less than or equal to 1, as this number is equal
                 to 1 in decimal. The length of this subsequence is 6, so 6 is
                 returned.

    Constraints:
    * 1 <= s.length <= 1000
    * s[i] is either '0' or '1'.
    * 1 <= k <= 10^9"""

    def longestSubsequence(self, s: str, k: int) -> int:
        ans = val = 0
        for i, ch in enumerate(reversed(s)):
            if ch == '0': ans += 1
            elif i < 30 and val + (1<<i) <= k:
                ans += 1
                val += 1<<i
        return ans


    """2312. Selling Pieces of Wood (Hard)
    You are given two integers m and n that represent the height and width of a
    rectangular piece of wood. You are also given a 2D integer array prices,
    where prices[i] = [hi, wi, pricei] indicates you can sell a rectangular
    piece of wood of height hi and width wi for pricei dollars. To cut a piece
    of wood, you must make a vertical or horizontal cut across the entire
    height or width of the piece to split it into two smaller pieces. After
    cutting a piece of wood into some number of smaller pieces, you can sell
    pieces according to prices. You may sell multiple pieces of the same shape,
    and you do not have to sell all the shapes. The grain of the wood makes a
    difference, so you cannot rotate a piece to swap its height and width.
    Return the maximum money you can earn after cutting an m x n piece of wood.
    Note that you can cut the piece of wood as many times as you want.

    Example 1:
    Input: m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]
    Output: 19
    Explanation: The diagram above shows a possible scenario. It consists of:
                 - 2 pieces of wood shaped 2 x 2, selling for a price of
                   2 * 7 = 14.
                 - 1 piece of wood shaped 2 x 1, selling for a price of
                   1 * 3 = 3.
                 - 1 piece of wood shaped 1 x 4, selling for a price of
                   1 * 2 = 2.
                 This obtains a total of 14 + 3 + 2 = 19 money earned. It can
                 be shown that 19 is the maximum amount of money that can be
                 earned.

    Example 2:
    Input: m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]
    Output: 32
    Explanation: The diagram above shows a possible scenario. It consists of:
                 - 3 pieces of wood shaped 3 x 2, selling for a price of
                   3 * 10 = 30.
                 - 1 piece of wood shaped 1 x 4, selling for a price of
                   1 * 2 = 2.
                 This obtains a total of 30 + 2 = 32 money earned. It can be
                 shown that 32 is the maximum amount of money that can be
                 earned. Notice that we cannot rotate the 1 x 4 piece of wood
                 to obtain a 4 x 1 piece of wood.

    Constraints:
    * 1 <= m, n <= 200
    * 1 <= prices.length <= 2 * 10^4
    * prices[i].length == 3
    * 1 <= hi <= m
    * 1 <= wi <= n
    * 1 <= pricei <= 10^6
    * All the shapes of wood (hi, wi) are pairwise distinct."""

    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:
        mp = {(h, w) : p for h, w, p in prices}

        @cache
        def fn(m, n):
            """Return max money of a mxn piece of wood."""
            if m == 0 or n == 0: return 0
            ans = 0
            if (m, n) in mp: ans = mp[m, n]
            if m > 1: ans = max(ans, max(fn(i, n) + fn(m-i, n) for i in range(1, m//2+1)))
            if n > 1: ans = max(ans, max(fn(m, j) + fn(m, n-j) for j in range(1, n//2+1)))
            return ans

        return fn(m, n)


    """2313. Minimum Flips in Binary Tree to Get Result (Hard)
    You are given the root of a binary tree with the following properties:
    * Leaf nodes have either the value 0 or 1, representing false and true
      respectively.
    * Non-leaf nodes have either the value 2, 3, 4, or 5, representing the
      boolean operations OR, AND, XOR, and NOT, respectively.
    You are also given a boolean result, which is the desired result of the
    evaluation of the root node. The evaluation of a node is as follows:
    * If the node is a leaf node, the evaluation is the value of the node, i.e.
      true or false.
    * Otherwise, evaluate the node's children and apply the boolean operation
      of its value with the children's evaluations.
    In one operation, you can flip a leaf node, which causes a false node to
    become true, and a true node to become false. Return the minimum number of
    operations that need to be performed such that the evaluation of root
    yields result. It can be shown that there is always a way to achieve result.
    A leaf node is a node that has zero children.

    Note: NOT nodes have either a left child or a right child, but other non-
          leaf nodes have both a left child and a right child.

    Example 1:
    Input: root = [3,5,4,2,null,1,1,1,0], result = true
    Output: 2
    Explanation: It can be shown that a minimum of 2 nodes have to be flipped
                 to make the root of the tree evaluate to true. One way to
                 achieve this is shown in the diagram above.

    Example 2:
    Input: root = [0], result = false
    Output: 0
    Explanation: The root of the tree already evaluates to false, so 0 nodes
                 have to be flipped.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 0 <= Node.val <= 5
    * OR, AND, and XOR nodes have 2 children.
    * NOT nodes have 1 child.
    * Leaf nodes have a value of 0 or 1.
    * Non-leaf nodes have a value of 2, 3, 4, or 5."""

    def minimumFlips(self, root: Optional[TreeNode], result: bool) -> int:

        def fn(node):
            """Return min swaps to return false and true."""
            if node.val == 0: return (0, 1)
            if node.val == 1: return (1, 0)
            if node.left: lf, lt = fn(node.left)
            if node.right: rf, rt = fn(node.right)
            match node.val:
                case 2: return (lf+rf, min(lt, rt))
                case 3: return (min(lf, rf), lt+rt)
                case 4: return (min(lf+rf, lt+rt), min(lf+rt, lt+rf))
                case _: return (lt, lf) if node.left else (rt, rf)

        return fn(root)[result]


    """2315. Count Asterisks (Easy)
    You are given a string s, where every two consecutive vertical bars '|' are
    grouped into a pair. In other words, the 1st and 2nd '|' make a pair, the
    3rd and 4th '|' make a pair, and so forth. Return the number of '*' in s,
    excluding the '*' between each pair of '|'. Note that each '|' will belong
    to exactly one pair.

    Example 1:
    Input: s = "l|*e*et|c**o|*de|"
    Output: 2
    Explanation: The considered characters are underlined: "l|*e*et|c**o|*de|".
                 The characters between the first and second '|' are excluded
                 from the answer. Also, the characters between the third and
                 fourth '|' are excluded from the answer. There are 2 asterisks
                 considered. Therefore, we return 2.

    Example 2:
    Input: s = "iamprogrammer"
    Output: 0
    Explanation: In this example, there are no asterisks in s. Therefore, we
                 return 0.

    Example 3:
    Input: s = "yo|uar|e**|b|e***au|tifu|l"
    Output: 5
    Explanation: The considered characters are underlined:
                 "yo|uar|e**|b|e***au|tifu|l". There are 5 asterisks considered.
                 Therefore, we return 5.

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of lowercase English letters, vertical bars '|', and asterisks
      '*'.
    * s contains an even number of vertical bars '|'."""

    def countAsterisks(self, s: str) -> int:
        return sum(w.count('*') for i, w in enumerate(s.split('|')) if not i&1)


    """2316. Count Unreachable Pairs of Nodes in an Undirected Graph (Medium)
    You are given an integer n. There is an undirected graph with n nodes,
    numbered from 0 to n - 1. You are given a 2D integer array edges where
    edges[i] = [ai, bi] denotes that there exists an undirected edge connecting
    nodes ai and bi. Return the number of pairs of different nodes that are
    unreachable from each other.

    Example 1:
    Input: n = 3, edges = [[0,1],[0,2],[1,2]]
    Output: 0
    Explanation: There are no pairs of nodes that are unreachable from each
                 other. Therefore, we return 0.

    Example 2:
    Input: n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]
    Output: 14
    Explanation: There are 14 pairs of nodes that are unreachable from each
                 other: 0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],
                 [3,4],[3,5],[3,6],[4,6],[5,6]]. Therefore, we return 14.

    Constraints:
    * 1 <= n <= 10^5
    * 0 <= edges.length <= 2 * 10^5
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * There are no repeated edges."""

    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        parent = list(range(n))

        def find(p):
            if parent[p] != p: parent[p] = find(parent[p])
            return parent[p]

        for p, q in edges:
            prt, qrt = find(p), find(q)
            if prt != qrt: parent[prt] = qrt

        freq = Counter(find(p) for p in range(n))
        return sum(v*(n-v) for v in freq.values())//2


    """2317. Maximum XOR After Operations (Medium)
    You are given a 0-indexed integer array nums. In one operation, select any
    non-negative integer x and an index i, then update nums[i] to be equal to
    nums[i] AND (nums[i] XOR x). Note that AND is the bitwise AND operation and
    XOR is the bitwise XOR operation. Return the maximum possible bitwise XOR
    of all elements of nums after applying the operation any number of times.

    Example 1:
    Input: nums = [3,2,4,6]
    Output: 7
    Explanation: Apply the operation with x = 4 and i = 3,
                 num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2. Now,
                 nums = [3, 2, 4, 2] and the bitwise XOR of all the
                 elements = 3 XOR 2 XOR 4 XOR 2 = 7. It can be shown that 7 is
                 the maximum possible bitwise XOR. Note that other operations
                 may be used to achieve a bitwise XOR of 7.

    Example 2:
    Input: nums = [1,2,3,9,2]
    Output: 11
    Explanation: Apply the operation zero times. The bitwise XOR of all the
                 elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11. It can be shown
                 that 11 is the maximum possible bitwise XOR.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^8"""

    def maximumXOR(self, nums: List[int]) -> int:
        return reduce(or_, nums)


    """2318. Number of Distinct Roll Sequences (Hard)
    You are given an integer n. You roll a fair 6-sided dice n times. Determine
    the total number of distinct sequences of rolls possible such that the
    following conditions are satisfied:
    * The greatest common divisor of any adjacent values in the sequence is
      equal to 1.
    * There is at least a gap of 2 rolls between equal valued rolls. More
      formally, if the value of the ith roll is equal to the value of the jth
      roll, then abs(i - j) > 2.
    Return the total number of distinct sequences possible. Since the answer
    may be very large, return it modulo 10^9 + 7. Two sequences are considered
    distinct if at least one element is different.

    Example 1:
    Input: n = 4
    Output: 184
    Explanation: Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3),
                 (1, 2, 3, 1), etc. Some invalid sequences are (1, 2, 1, 3),
                 (1, 2, 3, 6). (1, 2, 1, 3) is invalid since the first and
                 third roll have an equal value and abs(1 - 3) = 2 (i and j are
                 1-indexed). (1, 2, 3, 6) is invalid since the greatest common
                 divisor of 3 and 6 = 3. There are a total of 184 distinct
                 sequences possible, so we return 184.

    Example 2:
    Input: n = 2
    Output: 22
    Explanation: Some of the possible sequences are (1, 2), (2, 1), (3, 2).
                 Some invalid sequences are (3, 6), (2, 4) since the greatest
                 common divisor is not equal to 1. There are a total of 22
                 distinct sequences possible, so we return 22.

    Constraints: 1 <= n <= 10^4"""

    def distinctSequences(self, n: int) -> int:

        @lru_cache
        def fn(n, p, pp):
            """Return total number of distinct sequences."""
            if n == 0: return 1
            ans = 0
            for x in range(1, 7):
                if x not in (p, pp) and gcd(x, p) == 1: ans += fn(n-1, x, p)
            return ans % 1_000_000_007

        return fn(n, -1, -1)


    """2319. Check if Matrix Is X-Matrix (Easy)
    A square matrix is said to be an X-Matrix if both of the following
    conditions hold:
    * All the elements in the diagonals of the matrix are non-zero.
    * All other elements are 0.
    Given a 2D integer array grid of size n x n representing a square matrix,
    return true if grid is an X-Matrix. Otherwise, return false.

    Example 1:
    Input: grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]
    Output: true
    Explanation: Refer to the diagram above. An X-Matrix should have the green
                 elements (diagonals) be non-zero and the red elements be 0.
                 Thus, grid is an X-Matrix.

    Example 2:
    Input: grid = [[5,7,0],[0,3,1],[0,5,0]]
    Output: false
    Explanation: Refer to the diagram above. An X-Matrix should have the green
                 elements (diagonals) be non-zero and the red elements be 0.
                 Thus, grid is not an X-Matrix.

    Constraints:
    * n == grid.length == grid[i].length
    * 3 <= n <= 100
    * 0 <= grid[i][j] <= 10^5"""

    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if (i == j or i+j == n-1) and not x or i != j and i+j != n-1 and x: return False
        return True


    """2320. Count Number of Ways to Place Houses (Medium)
    There is a street with n * 2 plots, where there are n plots on each side of
    the street. The plots on each side are numbered from 1 to n. On each plot,
    a house can be placed. Return the number of ways houses can be placed such
    that no two houses are adjacent to each other on the same side of the
    street. Since the answer may be very large, return it modulo 10^9 + 7. Note
    that if a house is placed on the ith plot on one side of the street, a
    house can also be placed on the ith plot on the other side of the street.

    Example 1:
    Input: n = 1
    Output: 4
    Explanation: Possible arrangements:
                 1. All plots are empty.
                 2. A house is placed on one side of the street.
                 3. A house is placed on the other side of the street.
                 4. Two houses are placed, one on each side of the street.

    Example 2:
    Input: n = 2
    Output: 9
    Explanation: The 9 possible arrangements are shown in the diagram above.

    Constraints: 1 <= n <= 10^4"""

    def countHousePlacements(self, n: int) -> int:
        f0 = f1 = 1
        for _ in range(n): f0, f1 = f1, (f0+f1) % 1_000_000_007
        return f1*f1 % 1_000_000_007


    """2321. Maximum Score Of Spliced Array (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2, both of length
    n. You can choose two integers left and right where 0 <= left <= right < n
    and swap the subarray nums1[left...right] with the subarray
    nums2[left...right].
    * For example, if nums1 = [1,2,3,4,5] and nums2 = [11,12,13,14,15] and you
      choose left = 1 and right = 2, nums1 becomes [1,12,13,4,5] and nums2
      becomes [11,2,3,14,15].
    You may choose to apply the mentioned operation once or not do anything.
    The score of the arrays is the maximum of sum(nums1) and sum(nums2), where
    sum(arr) is the sum of all the elements in the array arr. Return the
    maximum possible score. A subarray is a contiguous sequence of elements
    within an array. arr[left...right] denotes the subarray that contains the
    elements of nums between indices left and right (inclusive).

    Example 1:
    Input: nums1 = [60,60,60], nums2 = [10,90,10]
    Output: 210
    Explanation: Choosing left = 1 and right = 1, we have nums1 = [60,90,60]
                 and nums2 = [10,60,10]. The score is
                 max(sum(nums1), sum(nums2)) = max(210, 80) = 210.

    Example 2:
    Input: nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]
    Output: 220
    Explanation: Choosing left = 3, right = 4, we have
                 nums1 = [20,40,20,40,20] and nums2 = [50,20,50,70,30]. The
                 score is max(sum(nums1), sum(nums2)) = max(140, 220) = 220.

    Example 3:
    Input: nums1 = [7,11,13], nums2 = [1,1,1]
    Output: 31
    Explanation: We choose not to swap any subarray. The score is
                 max(sum(nums1), sum(nums2)) = max(31, 3) = 31.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^4"""

    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
        v1 = v2 = m1 = m2 = 0
        for x1, x2 in zip(nums1, nums2):
            v1 = max(0, v1+x2-x1)
            v2 = max(0, v2+x1-x2)
            m1 = max(m1, v1)
            m2 = max(m2, v2)
        return max(sum(nums1)+m1, sum(nums2)+m2)


    """2322. Minimum Score After Removals on a Tree (Hard)
    There is an undirected connected tree with n nodes labeled from 0 to n - 1
    and n - 1 edges. You are given a 0-indexed integer array nums of length n
    where nums[i] represents the value of the ith node. You are also given a 2D
    integer array edges of length n - 1 where edges[i] = [ai, bi] indicates
    that there is an edge between nodes ai and bi in the tree. Remove two
    distinct edges of the tree to form three connected components. For a pair
    of removed edges, the following steps are defined:
    * Get the XOR of all the values of the nodes for each of the three
      components respectively.
    * The difference between the largest XOR value and the smallest XOR value
      is the score of the pair.
    * For example, say the three components have the node values: [4,5,7],
      [1,9], and [3,3,3]. The three XOR values are 4 ^ 5 ^ 7 = 6, 1 ^ 9 = 8,
      and 3 ^ 3 ^ 3 = 3. The largest XOR value is 8 and the smallest XOR value
      is 3. The score is then 8 - 3 = 5.
    Return the minimum score of any possible pair of edge removals on the given
    tree.

    Example 1:
    Input: nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]
    Output: 9
    Explanation: The diagram above shows a way to make a pair of removals.
                 - The 1st component has nodes [1,3,4] with values [5,4,11].
                   Its XOR value is 5 ^ 4 ^ 11 = 10.
                 - The 2nd component has node [0] with value [1]. Its XOR value
                   is 1 = 1.
                 - The 3rd component has node [2] with value [5]. Its XOR value
                   is 5 = 5.
                 The score is the difference between the largest and smallest
                 XOR value which is 10 - 1 = 9. It can be shown that no other
                 pair of removals will obtain a smaller score than 9.

    Example 2:
    Input: nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]
    Output: 0
    Explanation: The diagram above shows a way to make a pair of removals.
                 - The 1st component has nodes [3,4] with values [4,4]. Its XOR
                   value is 4 ^ 4 = 0.
                 - The 2nd component has nodes [1,0] with values [5,5]. Its XOR
                   value is 5 ^ 5 = 0.
                 - The 3rd component has nodes [2,5] with values [2,2]. Its XOR
                   value is 2 ^ 2 = 0.
                 The score is the difference between the largest and smallest
                 XOR value which is 0 - 0 = 0. We cannot obtain a smaller score
                 than 0.

    Constraints:
    * n == nums.length
    * 3 <= n <= 1000
    * 1 <= nums[i] <= 10^8
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * edges represents a valid tree."""

    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        def fn(u, p):
            nonlocal t
            score[u] = nums[u]
            tin[u] = (t := t+1) # time to enter
            for v in graph[u]:
                if v != p:
                    fn(v, u)
                    score[u] ^= score[v]
            tout[u] = t # time to exit

        t = 0
        score = [0]*n
        tin = [0]*n
        tout = [0]*n
        fn(0, -1)

        ans = inf
        for u in range(1, n):
            for v in range(u+1, n):
                if tin[v] <= tin[u] and tout[v] >= tout[u]: # enter earlier & exit later == parent
                    uu = score[u]
                    vv = score[v] ^ score[u]
                    xx = score[0] ^ score[v]
                elif tin[v] >= tin[u] and tout[v] <= tout[u]:
                    uu = score[u] ^ score[v]
                    vv = score[v]
                    xx = score[0] ^ score[u]
                else:
                    uu = score[u]
                    vv = score[v]
                    xx = score[0] ^ score[u] ^ score[v]
                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))
        return ans


    """2323. Find Minimum Time to Finish All Jobs II (Medium)
    You are given two 0-indexed integer arrays jobs and workers of equal length,
    where jobs[i] is the amount of time needed to complete the ith job, and
    workers[j] is the amount of time the jth worker can work each day. Each job
    should be assigned to exactly one worker, such that each worker completes
    exactly one job. Return the minimum number of days needed to complete all
    the jobs after assignment.

    Example 1:
    Input: jobs = [5,2,4], workers = [1,7,5]
    Output: 2
    Explanation: - Assign the 2nd worker to the 0th job. It takes them 1 day to
                   finish the job.
                 - Assign the 0th worker to the 1st job. It takes them 2 days
                   to finish the job.
                 - Assign the 1st worker to the 2nd job. It takes them 1 day to
                   finish the job.
                 It takes 2 days for all the jobs to be completed, so return 2.
                 It can be proven that 2 days is the minimum number of days needed.

    Example 2:
    Input: jobs = [3,18,15,9], workers = [6,5,1,3]
    Output: 3
    Explanation: - Assign the 2nd worker to the 0th job. It takes them 3 days
                   to finish the job.
                 - Assign the 0th worker to the 1st job. It takes them 3 days
                   to finish the job.
                 - Assign the 1st worker to the 2nd job. It takes them 3 days
                   to finish the job.
                 - Assign the 3rd worker to the 3rd job. It takes them 3 days
                   to finish the job.
                 It takes 3 days for all the jobs to be completed, so return 3.
                 It can be proven that 3 days is the minimum number of days
                 needed.

    Constraints:
    * n == jobs.length == workers.length
    * 1 <= n <= 10^5
    * 1 <= jobs[i], workers[i] <= 10^5"""

    def minimumTime(self, jobs: List[int], workers: List[int]) -> int:
        return max((j+w-1)//w for j, w in zip(sorted(jobs), sorted(workers)))


    """2325. Decode the Message (Easy)
    You are given the strings key and message, which represent a cipher key and
    a secret message, respectively. The steps to decode message are as follows:
    * Use the first appearance of all 26 lowercase English letters in key as
      the order of the substitution table.
    * Align the substitution table with the regular English alphabet.
    * Each letter in message is then substituted using the table.
    * Spaces ' ' are transformed to themselves.
      + For example, given key = "happy boy" (actual key would have at least
        one instance of each letter in the alphabet), we have the partial
        substitution table of ('h' -> 'a', 'a' -> 'b', 'p' -> 'c', 'y' -> 'd',
        'b' -> 'e', 'o' -> 'f').
    Return the decoded message.

    Example 1:
    Input: key = "the quick brown fox jumps over the lazy dog", message = "vkbs bs t suepuv"
    Output: "this is a secret"
    Explanation: The diagram above shows the substitution table. It is obtained
                 by taking the first appearance of each letter in "the quick
                 brown fox jumps over the lazy dog".

    Example 2:
    Input: key = "eljuxhpwnyrdgtqkviszcfmabo", message = "zwx hnfx lqantp mnoeius ycgk vcnjrdb"
    Output: "the five boxing wizards jump quickly"
    Explanation: The diagram above shows the substitution table. It is obtained
                 by taking the first appearance of each letter in
                 "eljuxhpwnyrdgtqkviszcfmabo".

    Constraints:
    * 26 <= key.length <= 2000
    * key consists of lowercase English letters and ' '.
    * key contains every letter in the English alphabet ('a' to 'z') at least
      once.
    * 1 <= message.length <= 2000
    * message consists of lowercase English letters and ' '."""

    def decodeMessage(self, key: str, message: str) -> str:
        mp = dict(zip(OrderedDict.fromkeys(key.replace(' ', '')).keys(), ascii_lowercase), **{' ' : ' '})
        return ''.join(map(mp.get, message))


    """2326. Spiral Matrix IV (Medium)
    You are given two integers m and n, which represent the dimensions of a
    matrix. You are also given the head of a linked list of integers. Generate
    an m x n matrix that contains the integers in the linked list presented in
    spiral order (clockwise), starting from the top-left of the matrix. If
    there are remaining empty spaces, fill them with -1. Return the generated
    matrix.

    Example 1:
    Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
    Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
    Explanation: The diagram above shows how the values are printed in the
                 matrix. Note that the remaining spaces in the matrix are
                 filled with -1.

    Example 2:
    Input: m = 1, n = 4, head = [0,1,2]
    Output: [[0,1,2,-1]]
    Explanation: The diagram above shows how the values are printed from left
                 to right in the matrix. The last space in the matrix is set to
                 -1.

    Constraints:
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * The number of nodes in the list is in the range [1, m * n].
    * 0 <= Node.val <= 1000"""

    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
        ans = [[-1]*n for _ in range(m)]
        node = head
        i, j, di, dj = 0, 0, 0, 1
        while node:
            ans[i][j] = node.val
            node = node.next
            if not (0 <= i+di < m and 0 <= j+dj < n and ans[i+di][j+dj] == -1): di, dj = dj, -di
            i, j = i+di, j+dj
        return ans


    """2327. Number of People Aware of a Secret (Medium)
    On day 1, one person discovers a secret. You are given an integer delay,
    which means that each person will share the secret with a new person every
    day, starting from delay days after discovering the secret. You are also
    given an integer forget, which means that each person will forget the
    secret forget days after discovering it. A person cannot share the secret
    on the same day they forgot it, or on any day afterwards. Given an integer
    n, return the number of people who know the secret at the end of day n.
    Since the answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 6, delay = 2, forget = 4
    Output: 5
    Explanation: Day 1: Suppose the first person is named A. (1 person)
                 Day 2: A is the only person who knows the secret. (1 person)
                 Day 3: A shares the secret with a new person, B. (2 people)
                 Day 4: A shares the secret with a new person, C. (3 people)
                 Day 5: A forgets the secret, and B shares the secret with a
                        new person, D. (3 people)
                 Day 6: B shares the secret with E, and C shares the secret
                        with F. (5 people)

    Example 2:
    Input: n = 4, delay = 1, forget = 3
    Output: 6
    Explanation: Day 1: The first person is named A. (1 person)
                 Day 2: A shares the secret with B. (2 people)
                 Day 3: A and B share the secret with 2 new people, C and D.
                        (4 people)
                 Day 4: A forgets the secret. B, C, and D share the secret with
                        3 new people. (6 people)

    Constraints:
    * 2 <= n <= 1000
    * 1 <= delay < forget <= n"""

    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
        dp = [0] * (n+1)
        dp[1] = 1
        rsm = 0
        for x in range(2, n+1):
            if x >= delay: rsm += dp[x-delay]
            if x >= forget: rsm -= dp[x-forget]
            dp[x] = rsm = rsm % 1_000_000_007
        return sum(dp[-forget:]) % 1_000_000_007


    """2328. Number of Increasing Paths in a Grid (Hard)
    You are given an m x n integer matrix grid, where you can move from a cell
    to any adjacent cell in all 4 directions. Return the number of strictly
    increasing paths in the grid such that you can start from any cell and end
    at any cell. Since the answer may be very large, return it modulo 10^9 + 7.
    Two paths are considered different if they do not have exactly the same
    sequence of visited cells.

    Example 1:
    Input: grid = [[1,1],[3,4]]
    Output: 8
    Explanation: The strictly increasing paths are:
                 - Paths with length 1: [1], [1], [3], [4].
                 - Paths with length 2: [1 -> 3], [1 -> 4], [3 -> 4].
                 - Paths with length 3: [1 -> 3 -> 4].
                 The total number of paths is 4 + 3 + 1 = 8.

    Example 2:
    Input: grid = [[1],[2]]
    Output: 3
    Explanation: The strictly increasing paths are:
                 - Paths with length 1: [1], [2].
                 - Paths with length 2: [1 -> 2].
                 The total number of paths is 2 + 1 = 3.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 1000
    * 1 <= m * n <= 10^5
    * 1 <= grid[i][j] <= 10^5"""

    def countPaths(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        @cache
        def fn(i, j):
            ans = 1
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] < grid[i][j]: ans += fn(ii, jj)
            return ans % 1_000_000_007

        return sum(fn(i, j) for i in range(m) for j in range(n)) % 1_000_000_007


    """2330. Valid Palindrome IV (Medium)
    You are given a 0-indexed string s consisting of only lowercase English
    letters. In one operation, you can change any character of s to any other
    character. Return true if you can make s a palindrome after performing
    exactly one or two operations, or return false otherwise.

    Example 1:
    Input: s = "abcdba"
    Output: true
    Explanation: One way to make s a palindrome using 1 operation is:
                 - Change s[2] to 'd'. Now, s = "abddba".
                 One operation could be performed to make s a palindrome so
                 return true.

    Example 2:
    Input: s = "aa"
    Output: true
    Explanation: One way to make s a palindrome using 2 operations is:
                 - Change s[0] to 'b'. Now, s = "ba".
                 - Change s[1] to 'b'. Now, s = "bb".
                 Two operations could be performed to make s a palindrome so
                 return true.

    Example 3:
    Input: s = "abcdef"
    Output: false
    Explanation: It is not possible to make s a palindrome using one or two
                 operations so return false.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters."""

    def makePalindrome(self, s: str) -> bool:
        return sum(s[i] != s[~i] for i in range(len(s)//2)) <= 2


    """2331. Evaluate Boolean Binary Tree (Easy)
    You are given the root of a full binary tree with the following properties:
    * Leaf nodes have either the value 0 or 1, where 0 represents False and 1
      represents True.
    * Non-leaf nodes have either the value 2 or 3, where 2 represents the
      boolean OR and 3 represents the boolean AND.
    The evaluation of a node is as follows:
    * If the node is a leaf node, the evaluation is the value of the node, i.e.
      True or False.
    * Otherwise, evaluate the node's two children and apply the boolean
      operation of its value with the children's evaluations.
    Return the boolean result of evaluating the root node. A full binary tree
    is a binary tree where each node has either 0 or 2 children. A leaf node is
    a node that has zero children.

    Example 1:
    Input: root = [2,1,3,null,null,0,1]
    Output: true
    Explanation: The above diagram illustrates the evaluation process. The AND
                 node evaluates to False AND True = False. The OR node
                 evaluates to True OR False = True. The root node evaluates to
                 True, so we return true.

    Example 2:
    Input: root = [0]
    Output: false
    Explanation: The root node is a leaf node and it evaluates to false, so we
                 return false.

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * 0 <= Node.val <= 3
    * Every node has either 0 or 2 children.
    * Leaf nodes have a value of 0 or 1.
    * Non-leaf nodes have a value of 2 or 3."""

    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        mp = {}
        stack = []
        prev, node = None, root
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack[-1]
                if node.right and node.right != prev: node = node.right
                else:
                    if not node.left and not node.right: mp[node] = node.val
                    elif node.val == 2: mp[node] = mp[node.left] or mp[node.right]
                    else: mp[node] = mp[node.left] and mp[node.right]
                    stack.pop()
                    prev = node
                    node = None
        return mp[root]


    """2332. The Latest Time to Catch a Bus (Medium)
    You are given a 0-indexed integer array buses of length n, where buses[i]
    represents the departure time of the ith bus. You are also given a 0-
    indexed integer array passengers of length m, where passengers[j]
    represents the arrival time of the jth passenger. All bus departure times
    are unique. All passenger arrival times are unique. You are given an
    integer capacity, which represents the maximum number of passengers that
    can get on each bus. The passengers will get on the next available bus. You
    can get on a bus that will depart at x minutes if you arrive at y minutes
    where y <= x, and the bus is not full. Passengers with the earliest arrival
    times get on the bus first. Return the latest time you may arrive at the
    bus station to catch a bus. You cannot arrive at the same time as another
    passenger. Note: The arrays buses and passengers are not necessarily sorted.

    Example 1:
    Input: buses = [10,20], passengers = [2,17,18,19], capacity = 2
    Output: 16
    Explanation: The 1st bus departs with the 1st passenger. The 2nd bus
                 departs with you and the 2nd passenger. Note that you must not
                 arrive at the same time as the passengers, which is why you
                 must arrive before the 2nd passenger to catch the bus.

    Example 2:
    Input: buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2
    Output: 20
    Explanation: The 1st bus departs with the 4th passenger. The 2nd bus
                 departs with the 6th and 2nd passengers. The 3rd bus departs
                 with the 1st passenger and you.

    Constraints:
    * n == buses.length
    * m == passengers.length
    * 1 <= n, m, capacity <= 10^5
    * 2 <= buses[i], passengers[i] <= 10^9
    * Each element in buses is unique.
    * Each element in passengers is unique."""

    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
        buses.sort()
        passengers.sort()
        prev = -inf
        queue = deque()
        prefix = i = j = 0
        while i < len(buses) or j < len(passengers):
            if i == len(buses) or j < len(passengers) and passengers[j] <= buses[i]:
                if j == 0 or passengers[j-1] + 1 < passengers[j]: prev = passengers[j]-1
                prefix += 1
                if prefix and prefix % capacity == 0: queue.append(prev)
                j += 1
            else:
                if prefix < capacity:
                    if j == 0 or buses[i] != passengers[j-1]: ans = buses[i]
                    else: ans = prev
                    prefix = 0
                elif queue:
                    ans = queue.popleft()
                    prefix -= capacity
                i += 1
        return ans


    """2333. Minimum Sum of Squared Difference (Medium)
    You are given two positive 0-indexed integer arrays nums1 and nums2, both
    of length n. The sum of squared difference of arrays nums1 and nums2 is
    defined as the sum of (nums1[i] - nums2[i])2 for each 0 <= i < n. You are
    also given two positive integers k1 and k2. You can modify any of the
    elements of nums1 by +1 or -1 at most k1 times. Similarly, you can modify
    any of the elements of nums2 by +1 or -1 at most k2 times. Return the
    minimum sum of squared difference after modifying array nums1 at most k1
    times and modifying array nums2 at most k2 times. Note: You are allowed to
    modify the array elements to become negative integers.

    Example 1:
    Input: nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0
    Output: 579
    Explanation: The elements in nums1 and nums2 cannot be modified because
                 k1 = 0 and k2 = 0. The sum of square difference will be:
                 (1 - 2)^2 + (2 - 10)^2 + (3 - 20)^2 + (4 - 19)^2 = 579.

    Example 2:
    Input: nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1
    Output: 43
    Explanation: One way to obtain the minimum sum of square difference is:
                 - Increase nums1[0] once.
                 - Increase nums2[2] once.
                 The minimum of the sum of square difference will be:
                 (2 - 5)^2 + (4 - 8)^2 + (10 - 7)^2 + (12 - 9)^2 = 43.
                 Note that, there are other ways to obtain the minimum of the
                 sum of square difference, but there is no way to obtain a sum
                 smaller than 43.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 0 <= nums1[i], nums2[i] <= 10^5
    * 0 <= k1, k2 <= 10^9"""

    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:
        freq = Counter(abs(x1-x2) for x1, x2 in zip(nums1, nums2) if x1 != x2)
        pq = [(-k, v) for k, v in freq.items()]
        total = k1 + k2
        heapify(pq)
        while total and pq:
            k, v = heappop(pq)
            if pq: kk, vv = heappop(pq)
            else: kk = vv = 0
            diff = kk - k
            if diff * v <= total:
                total -= diff * v
                if vv: heappush(pq, (kk, v+vv))
            else:
                q, r = divmod(total, v)
                total = 0
                heappush(pq, (k+q+1, r))
                heappush(pq, (k+q, v-r))
                if vv: heappush(pq, (kk, vv))
        return sum(k*k*v for k, v in pq)


    """2334. Subarray With Elements Greater Than Varying Threshold (Hard)
    You are given an integer array nums and an integer threshold. Find any
    subarray of nums of length k such that every element in the subarray is
    greater than threshold / k. Return the size of any such subarray. If there
    is no such subarray, return -1. A subarray is a contiguous non-empty
    sequence of elements within an array.

    Example 1:
    Input: nums = [1,3,4,3,1], threshold = 6
    Output: 3
    Explanation: The subarray [3,4,3] has a size of 3, and every element is
                 greater than 6 / 3 = 2. Note that this is the only valid
                 subarray.

    Example 2:
    Input: nums = [6,5,6,5,8], threshold = 7
    Output: 1
    Explanation: The subarray [8] has a size of 1, and 8 > 7 / 1 = 7. So 1 is
                 returned. Note that the subarray [6,5] has a size of 2, and
                 every element is greater than 7 / 2 = 3.5.  Similarly, the
                 subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the
                 given conditions. Therefore, 2, 3, 4, or 5 may also be
                 returned.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], threshold <= 10^9"""

    def validSubarraySize(self, nums: List[int], threshold: int) -> int:
        stack = []
        for i, x in enumerate(nums + [0]):
            while stack and stack[-1][1] > x:
                val = stack.pop()[1]
                if stack: ii = stack[-1][0]
                else: ii = -1
                if val > threshold // (i - ii - 1): return i - ii - 1
            stack.append((i, x))
        return -1


    """2335. Minimum Amount of Time to Fill Cups (Easy)
    You have a water dispenser that can dispense cold, warm, and hot water.
    Every second, you can either fill up 2 cups with different types of water,
    or 1 cup of any type of water. You are given a 0-indexed integer array
    amount of length 3 where amount[0], amount[1], and amount[2] denote the
    number of cold, warm, and hot water cups you need to fill respectively.
    Return the minimum number of seconds needed to fill up all the cups.

    Example 1:
    Input: amount = [1,4,2]
    Output: 4
    Explanation: One way to fill up the cups is:
                 Second 1: Fill up a cold cup and a warm cup.
                 Second 2: Fill up a warm cup and a hot cup.
                 Second 3: Fill up a warm cup and a hot cup.
                 Second 4: Fill up a warm cup.
                 It can be proven that 4 is the minimum number of seconds
                 needed.

    Example 2:
    Input: amount = [5,4,4]
    Output: 7
    Explanation: One way to fill up the cups is:
                 Second 1: Fill up a cold cup, and a hot cup.
                 Second 2: Fill up a cold cup, and a warm cup.
                 Second 3: Fill up a cold cup, and a warm cup.
                 Second 4: Fill up a warm cup, and a hot cup.
                 Second 5: Fill up a cold cup, and a hot cup.
                 Second 6: Fill up a cold cup, and a warm cup.
                 Second 7: Fill up a hot cup.

    Example 3:
    Input: amount = [5,0,0]
    Output: 5
    Explanation: Every second, we fill up a cold cup.

    Constraints:
    * amount.length == 3
    * 0 <= amount[i] <= 100"""

    def fillCups(self, amount: List[int]) -> int:
        return max(max(amount), (sum(amount)+1)//2)


    """2337. Move Pieces to Obtain a String (Medium)
    You are given two strings start and target, both of length n. Each string
    consists only of the characters 'L', 'R', and '_' where:
    * The characters 'L' and 'R' represent pieces, where a piece 'L' can move
      to the left only if there is a blank space directly to its left, and a
      piece 'R' can move to the right only if there is a blank space directly
      to its right.
    * The character '_' represents a blank space that can be occupied by any of
      the 'L' or 'R' pieces.
    Return true if it is possible to obtain the string target by moving the
    pieces of the string start any number of times. Otherwise, return false.

    Example 1:
    Input: start = "_L__R__R_", target = "L______RR"
    Output: true
    Explanation: We can obtain the string target from start by doing the
                 following moves:
                 - Move the first piece one step to the left, start becomes
                   equal to "L___R__R_".
                 - Move the last piece one step to the right, start becomes
                   equal to "L___R___R".
                 - Move the second piece three steps to the right, start
                   becomes equal to "L______RR".
                 Since it is possible to get the string target from start, we
                 return true.

    Example 2:
    Input: start = "R_L_", target = "__LR"
    Output: false
    Explanation: The 'R' piece in the string start can move one step to the
                 right to obtain "_RL_". After that, no pieces can move anymore,
                 so it is impossible to obtain the string target from start.

    Example 3:
    Input: start = "_R", target = "R_"
    Output: false
    Explanation: The piece in the string start can move only to the right, so
                 it is impossible to obtain the string target from start.

    Constraints:
    * n == start.length == target.length
    * 1 <= n <= 10^5
    * start and target consist of the characters 'L', 'R', and '_'."""

    def canChange(self, s: str, e: str) -> bool:
        dl = dr = 0
        for ss, ee in zip(s, e):
            if dl > 0 or dl < 0 and ss == 'R' or dr < 0 or dr > 0 and ss == 'L': return False
            dl += int(ss == 'L') - int(ee == 'L')
            dr += int(ss == 'R') - int(ee == 'R')
        return dl == dr == 0


    """2338. Count the Number of Ideal Arrays (Hard)
    You are given two integers n and maxValue, which are used to describe an
    ideal array. A 0-indexed integer array arr of length n is considered ideal
    if the following conditions hold:
    * Every arr[i] is a value from 1 to maxValue, for 0 <= i < n.
    * Every arr[i] is divisible by arr[i - 1], for 0 < i < n.
    Return the number of distinct ideal arrays of length n. Since the answer
    may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 2, maxValue = 5
    Output: 10
    Explanation: The following are the possible ideal arrays:
                 - Arrays starting with the value 1 (5 arrays): [1,1], [1,2],
                   [1,3], [1,4], [1,5]
                 - Arrays starting with the value 2 (2 arrays): [2,2], [2,4]
                 - Arrays starting with the value 3 (1 array): [3,3]
                 - Arrays starting with the value 4 (1 array): [4,4]
                 - Arrays starting with the value 5 (1 array): [5,5]
                 There are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal
                 arrays.

    Example 2:
    Input: n = 5, maxValue = 3
    Output: 11
    Explanation: The following are the possible ideal arrays:
                 - Arrays starting with the value 1 (9 arrays):
                    - With no other distinct values (1 array): [1,1,1,1,1]
                    - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2],
                      [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]
                    - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3],
                      [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]
                 - Arrays starting with the value 2 (1 array): [2,2,2,2,2]
                 - Arrays starting with the value 3 (1 array): [3,3,3,3,3]
                 There are a total of 9 + 1 + 1 = 11 distinct ideal arrays.

    Constraints:
    * 2 <= n <= 10^4
    * 1 <= maxValue <= 10^4"""

    def idealArrays(self, n: int, maxValue: int) -> int:
        ans = maxValue
        freq = {x : 1 for x in range(1, maxValue+1)}
        for k in range(1, n):
            temp = Counter()
            for x in freq:
                for m in range(2, maxValue//x+1):
                    ans += comb(n-1, k)*freq[x]
                    temp[m*x] += freq[x]
            freq = temp
            ans %= 1_000_000_007
        return ans


    """2340. Minimum Adjacent Swaps to Make a Valid Array (Medium)
    You are given a 0-indexed integer array nums. Swaps of adjacent elements
    are able to be performed on nums. A valid array meets the following
    conditions:
    * The largest element (any of the largest elements if there are multiple)
      is at the rightmost position in the array.
    * The smallest element (any of the smallest elements if there are multiple)
      is at the leftmost position in the array.
    Return the minimum swaps required to make nums a valid array.

    Example 1:
    Input: nums = [3,4,5,5,3,1]
    Output: 6
    Explanation: Perform the following swaps:
                 - Swap 1: Swap the 3rd and 4th elements, nums is then
                   [3,4,5,3,5,1].
                 - Swap 2: Swap the 4th and 5th elements, nums is then
                   [3,4,5,3,1,5].
                 - Swap 3: Swap the 3rd and 4th elements, nums is then
                   [3,4,5,1,3,5].
                 - Swap 4: Swap the 2nd and 3rd elements, nums is then
                   [3,4,1,5,3,5].
                 - Swap 5: Swap the 1st and 2nd elements, nums is then
                   [3,1,4,5,3,5].
                 - Swap 6: Swap the 0th and 1st elements, nums is then
                   [1,3,4,5,3,5].
                 It can be shown that 6 swaps is the minimum swaps required to
                 make a valid array.

    Example 2:
    Input: nums = [9]
    Output: 0
    Explanation: The array is already valid, so we return 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def minimumSwaps(self, nums: List[int]) -> int:
        imin = imax = 0
        for i, x in enumerate(nums):
            if x < nums[imin]: imin = i
            if x >= nums[imax]: imax = i
        return imin + len(nums) - imax - 1 - (imax < imin)


    """2341. Maximum Number of Pairs in Array (Easy)
    You are given a 0-indexed integer array nums. In one operation, you may do
    the following:
    * Choose two integers in nums that are equal.
    * Remove both integers from nums, forming a pair.
    The operation is done on nums as many times as possible. Return a 0-indexed
    integer array answer of size 2 where answer[0] is the number of pairs that
    are formed and answer[1] is the number of leftover integers in nums after
    doing the operation as many times as possible.

    Example 1:
    Input: nums = [1,3,2,1,3,2,2]
    Output: [3,1]
    Explanation: Form a pair with nums[0] and nums[3] and remove them from nums.
                 Now, nums = [3,2,3,2,2]. Form a pair with nums[0] and nums[2]
                 and remove them from nums. Now, nums = [2,2,2]. Form a pair
                 with nums[0] and nums[1] and remove them from nums. Now,
                 nums = [2]. No more pairs can be formed. A total of 3 pairs
                 have been formed, and there is 1 number leftover in nums.

    Example 2:
    Input: nums = [1,1]
    Output: [1,0]
    Explanation: Form a pair with nums[0] and nums[1] and remove them from nums.
                 Now, nums = []. No more pairs can be formed. A total of 1 pair
                 has been formed, and there are 0 numbers leftover in nums.

    Example 3:
    Input: nums = [0]
    Output: [0,1]
    Explanation: No pairs can be formed, and there is 1 number leftover in nums.

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 100"""

    def numberOfPairs(self, nums: List[int]) -> List[int]:
        pair = leftover = 0
        for x in Counter(nums).values():
            pair += x//2
            leftover += x&1
        return [pair, leftover]


    """2342. Max Sum of a Pair With Equal Sum of Digits (Medium)
    You are given a 0-indexed array nums consisting of positive integers. You
    can choose two indices i and j, such that i != j, and the sum of digits of
    the number nums[i] is equal to that of nums[j]. Return the maximum value of
    nums[i] + nums[j] that you can obtain over all possible indices i and j
    that satisfy the conditions.

    Example 1:
    Input: nums = [18,43,36,13,7]
    Output: 54
    Explanation: The pairs (i, j) that satisfy the conditions are:
                 - (0, 2), both numbers have a sum of digits equal to 9, and
                   their sum is 18 + 36 = 54.
                 - (1, 4), both numbers have a sum of digits equal to 7, and
                 their sum is 43 + 7 = 50.
                 So the maximum sum that we can obtain is 54.

    Example 2:
    Input: nums = [10,12,19,14]
    Output: -1
    Explanation: There are no two numbers that satisfy the conditions, so we
                 return -1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def maximumSum(self, nums: List[int]) -> int:
        ans = -1
        seen = {}
        for x in nums:
            sm = sum(int(d) for d in str(x))
            if sm in seen:
                ans = max(ans, seen[sm] + x)
                seen[sm] = max(seen[sm], x)
            else: seen[sm] = x
        return ans


    """2343. Query Kth Smallest Trimmed Number (Medium)
    You are given a 0-indexed array of strings nums, where each string is of
    equal length and consists of only digits. You are also given a 0-indexed 2D
    integer array queries where queries[i] = [ki, trimi]. For each queries[i],
    you need to:
    * Trim each number in nums to its rightmost trimi digits.
    * Determine the index of the kith smallest trimmed number in nums. If two
      trimmed numbers are equal, the number with the lower index is considered
      to be smaller.
    * Reset each number in nums to its original length.
    Return an array answer of the same length as queries, where answer[i] is
    the answer to the ith query.

    Note:
    * To trim to the rightmost x digits means to keep removing the leftmost
      digit, until only x digits remain.
    * Strings in nums may contain leading zeros.

    Example 1:
    Input: nums = ["102","473","251","814"], queries = [[1,1],[2,3],[4,2],[1,2]]
    Output: [2,2,1,0]
    Explanation: 1. After trimming to the last digit, nums = ["2","3","1","4"].
                    The smallest number is 1 at index 2.
                 2. Trimmed to the last 3 digits, nums is unchanged. The 2nd
                    smallest number is 251 at index 2.
                 3. Trimmed to the last 2 digits, nums = ["02","73","51","14"].
                    The 4th smallest number is 73.
                 4. Trimmed to the last 2 digits, the smallest number is 2 at
                    index 0. Note that the trimmed number "02" is evaluated as
                    2.

    Example 2:
    Input: nums = ["24","37","96","04"], queries = [[2,1],[2,2]]
    Output: [3,0]
    Explanation: 1. Trimmed to the last digit, nums = ["4","7","6","4"]. The
                    2nd smallest number is 4 at index 3. There are two
                    occurrences of 4, but the one at index 0 is considered
                    smaller than the one at index 3.
                 2. Trimmed to the last 2 digits, nums is unchanged. The 2nd
                    smallest number is 24.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i].length <= 100
    * nums[i] consists of only digits.
    * All nums[i].length are equal.
    * 1 <= queries.length <= 100
    * queries[i].length == 2
    * 1 <= ki <= nums.length
    * 1 <= trimi <= nums[i].length"""

    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:
        ans = []
        for k, trim in queries:
            cand = [x[-trim:] for x in nums]
            _, v = sorted(zip(cand, range(len(cand))))[k-1]
            ans.append(v)
        return ans


    """2344. Minimum Deletions to Make Array Divisible (Hard)
    You are given two positive integer arrays nums and numsDivide. You can
    delete any number of elements from nums. Return the minimum number of
    deletions such that the smallest element in nums divides all the elements
    of numsDivide. If this is not possible, return -1. Note that an integer x
    divides y if y % x == 0.

    Example 1:
    Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]
    Output: 2
    Explanation: The smallest element in [2,3,2,4,3] is 2, which does not
                 divide all the elements of numsDivide. We use 2 deletions to
                 delete the elements in nums that are equal to 2 which makes
                 nums = [3,4,3]. The smallest element in [3,4,3] is 3, which
                 divides all the elements of numsDivide. It can be shown that 2
                 is the minimum number of deletions needed.

    Example 2:
    Input: nums = [4,3,6], numsDivide = [8,2,6,10]
    Output: -1
    Explanation: We want the smallest element in nums to divide all the
                 elements of numsDivide. There is no way to delete elements
                 from nums to allow this.

    Constraints:
    * 1 <= nums.length, numsDivide.length <= 10^5
    * 1 <= nums[i], numsDivide[i] <= 10^9"""

    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        g = reduce(gcd, numsDivide)
        return next((i for i, x in enumerate(sorted(nums)) if g % x == 0), -1)


    """2345. Finding the Number of Visible Mountains (Medium)
    You are given a 0-indexed 2D integer array peaks where peaks[i] = [xi, yi]
    states that mountain i has a peak at coordinates (xi, yi). A mountain can
    be described as a right-angled isosceles triangle, with its base along the
    x-axis and a right angle at its peak. More formally, the gradients of
    ascending and descending the mountain are 1 and -1 respectively. A mountain
    is considered visible if its peak does not lie within another mountain
    (including the border of other mountains). Return the number of visible
    mountains.

    Example 1:
    Input: peaks = [[2,2],[6,3],[5,4]]
    Output: 2
    Explanation: The diagram above shows the mountains.
                 - Mountain 0 is visible since its peak does not lie within
                   another mountain or its sides.
                 - Mountain 1 is not visible since its peak lies within the
                   side of mountain 2.
                 - Mountain 2 is visible since its peak does not lie within
                   another mountain or its sides.
                 There are 2 mountains that are visible.

    Example 2:
    Input: peaks = [[1,3],[1,3]]
    Output: 0
    Explanation: The diagram above shows the mountains (they completely overlap).
                 Both mountains are not visible since their peaks lie within
                 each other.

    Constraints:
    * 1 <= peaks.length <= 10^5
    * peaks[i].length == 2
    * 1 <= xi, yi <= 10^5"""

    def visibleMountains(self, peaks: List[List[int]]) -> int:
        ans = 0
        right = -inf
        peaks.sort(key=lambda x: (x[0]-x[1], -x[0]-x[1]))
        for i, (p, s) in enumerate(peaks):
            hi = p+s
            if right < hi and (i+1 == len(peaks) or peaks[i] != peaks[i+1]): ans += 1
            right = max(right, hi)
        return ans


    """2347. Best Poker Hand (Easy)
    You are given an integer array ranks and a character array suits. You have
    5 cards where the ith card has a rank of ranks[i] and a suit of suits[i].
    The following are the types of poker hands you can make from best to worst:
    * "Flush": Five cards of the same suit.
    * "Three of a Kind": Three cards of the same rank.
    * "Pair": Two cards of the same rank.
    * "High Card": Any single card.
    Return a string representing the best type of poker hand you can make with
    the given cards. Note that the return values are case-sensitive.

    Example 1:
    Input: ranks = [13,2,3,1,9], suits = ["a","a","a","a","a"]
    Output: "Flush"
    Explanation: The hand with all the cards consists of 5 cards with the same
                 suit, so we have a "Flush".

    Example 2:
    Input: ranks = [4,4,2,4,4], suits = ["d","a","a","b","c"]
    Output: "Three of a Kind"
    Explanation: The hand with the first, second, and fourth card consists of 3
                 cards with the same rank, so we have a "Three of a Kind". Note
                 that we could also make a "Pair" hand but "Three of a Kind" is
                 a better hand. Also note that other cards could be used to
                 make the "Three of a Kind" hand.

    Example 3:
    Input: ranks = [10,10,2,12,9], suits = ["a","b","c","a","d"]
    Output: "Pair"
    Explanation: The hand with the first and second card consists of 2 cards
                 with the same rank, so we have a "Pair". Note that we cannot
                 make a "Flush" or a "Three of a Kind".

    Constraints:
    * ranks.length == suits.length == 5
    * 1 <= ranks[i] <= 13
    * 'a' <= suits[i] <= 'd'
    * No two cards have the same rank and suit."""

    def bestHand(self, r: List[int], s: List[str]) -> str:
        if len(set(s)) == 1: return "Flush"
        match m := max(Counter(r).values()):
            case _ if m >= 3: return "Three of a Kind"
            case 2: return "Pair"
            case _: return "High Card"


    """2348. Number of Zero-Filled Subarrays (Medium)
    Given an integer array nums, return the number of subarrays filled with 0.
    A subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,3,0,0,2,0,0,4]
    Output: 6
    Explanation: There are 4 occurrences of [0] as a subarray. There are 2
                 occurrences of [0,0] as a subarray. There is no occurrence of
                 a subarray with a size more than 2 filled with 0. Therefore,
                 we return 6.

    Example 2:
    Input: nums = [0,0,0,2,0,0]
    Output: 9
    Explanation: There are 5 occurrences of [0] as a subarray. There are 3
                 occurrences of [0,0] as a subarray. There is 1 occurrence of
                 [0,0,0] as a subarray. There is no occurrence of a subarray
                 with a size more than 3 filled with 0. Therefore, we return 9.

    Example 3:
    Input: nums = [2,10,2019]
    Output: 0
    Explanation: There is no subarray filled with 0. Therefore, we return 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9"""

    def zeroFilledSubarray(self, nums: List[int]) -> int:
        ans = cnt = 0
        for x in nums:
            if x: cnt = 0
            else: cnt += 1
            ans += cnt
        return ans


    """2350. Shortest Impossible Sequence of Rolls (Hard)
    You are given an integer array rolls of length n and an integer k. You roll
    a k sided dice numbered from 1 to k, n times, where the result of the ith
    roll is rolls[i]. Return the length of the shortest sequence of rolls that
    cannot be taken from rolls. A sequence of rolls of length len is the result
    of rolling a k sided dice len times. Note that the sequence taken does not
    have to be consecutive as long as it is in order.

    Example 1:
    Input: rolls = [4,2,1,2,3,3,2,4,1], k = 4
    Output: 3
    Explanation: Every sequence of rolls of length 1, [1], [2], [3], [4], can
                 be taken from rolls. Every sequence of rolls of length 2,
                 [1, 1], [1, 2], ..., [4, 4], can be taken from rolls. The
                 sequence [1, 4, 2] cannot be taken from rolls, so we return 3.
                 Note that there are other sequences that cannot be taken from
                 rolls.

    Example 2:
    Input: rolls = [1,1,2,2], k = 2
    Output: 2
    Explanation: Every sequence of rolls of length 1, [1], [2], can be taken
                 from rolls. The sequence [2, 1] cannot be taken from rolls, so
                 we return 2. Note that there are other sequences that cannot
                 be taken from rolls but [2, 1] is the shortest.

    Example 3:
    Input: rolls = [1,1,3,2,2,2,3,3], k = 4
    Output: 1
    Explanation: The sequence [4] cannot be taken from rolls, so we return 1.
                 Note that there are other sequences that cannot be taken from
                 rolls but [4] is the shortest.

    Constraints:
    * n == rolls.length
    * 1 <= n <= 10^5
    * 1 <= rolls[i] <= k <= 10^5"""

    def shortestSequence(self, rolls: List[int], k: int) -> int:
        ans = 1
        seen = set()
        for x in rolls:
            seen.add(x)
            if len(seen) == k:
                ans += 1
                seen.clear()
        return ans


    """2351. First Letter to Appear Twice (Easy)
    Given a string s consisting of lowercase English letters, return the first
    letter to appear twice. Note:
    * A letter a appears twice before another letter b if the second occurrence
      of a is before the second occurrence of b.
    * s will contain at least one letter that appears twice.

    Example 1:
    Input: s = "abccbaacz"
    Output: "c"
    Explanation: The letter 'a' appears on the indexes 0, 5 and 6.
                 The letter 'b' appears on the indexes 1 and 4.
                 The letter 'c' appears on the indexes 2, 3 and 7.
                 The letter 'z' appears on the index 8.
                 The letter 'c' is the first letter to appear twice, because
                 out of all the letters the index of its second occurrence is
                 the smallest.

    Example 2:
    Input: s = "abcdd"
    Output: "d"
    Explanation:
    The only letter that appears twice is 'd' so we return 'd'.

    Constraints:
    * 2 <= s.length <= 100
    * s consists of lowercase English letters.
    * s has at least one repeated letter."""

    def repeatedCharacter(self, s: str) -> str:
        mask = 0
        for ch in s:
            if mask & 1<<ord(ch)-97: return ch
            mask ^= 1<<ord(ch)-97


    """2352. Equal Row and Column Pairs (Medium)
    Given a 0-indexed n x n integer matrix grid, return the number of pairs
    (Ri, Cj) such that row Ri and column Cj are equal. A row and column pair is
    considered equal if they contain the same elements in the same order (i.e.
    an equal array).

    Example 1:
    Input: grid = [[3,2,1],[1,7,6],[2,7,7]]
    Output: 1
    Explanation: There is 1 equal row and column pair:
                 - (Row 2, Column 1): [2,7,7]

    Example 2:
    Input: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
    Output: 3
    Explanation: There are 3 equal row and column pairs:
                 - (Row 0, Column 0): [3,1,2,2]
                 - (Row 2, Column 2): [2,4,2,2]
                 - (Row 3, Column 2): [2,4,2,2]

    Constraints:
    * n == grid.length == grid[i].length
    * 1 <= n <= 200
    * 1 <= grid[i][j] <= 10^5"""

    def equalPairs(self, grid: List[List[int]]) -> int:
        freq = Counter(tuple(row) for row in grid)
        return sum(freq[tuple(col)] for col in zip(*grid))


    """2354. Number of Excellent Pairs (Hard)
    You are given a 0-indexed positive integer array nums and a positive
    integer k. A pair of numbers (num1, num2) is called excellent if the
    following conditions are satisfied:
    * Both the numbers num1 and num2 exist in the array nums.
    * The sum of the number of set bits in num1 OR num2 and num1 AND num2 is
      greater than or equal to k, where OR is the bitwise OR operation and AND
      is the bitwise AND operation.
    Return the number of distinct excellent pairs. Two pairs (a, b) and (c, d)
    are considered distinct if either a != c or b != d. For example, (1, 2) and
    (2, 1) are distinct. Note that a pair (num1, num2) such that num1 == num2
    can also be excellent if you have at least one occurrence of num1 in the
    array.

    Example 1:
    Input: nums = [1,2,3,1], k = 3
    Output: 5
    Explanation: The excellent pairs are the following:
                 - (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in
                   binary. The total number of set bits is 2 + 2 = 4, which is
                   greater than or equal to k = 3.
                 - (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and
                   (2 OR 3) is equal to (11) in binary. The total number of set
                   bits is 1 + 2 = 3.
                 - (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and
                   (1 OR 3) is equal to (11) in binary. The total number of set
                   bits is 1 + 2 = 3.
                 So the number of excellent pairs is 5.

    Example 2:
    Input: nums = [5,1,1], k = 10
    Output: 0
    Explanation: There are no excellent pairs for this array.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 60"""

    def countExcellentPairs(self, nums: List[int], k: int) -> int:
        freq = Counter(map(int.bit_count, set(nums)))
        return sum(v1*v2 for k1, v1 in freq.items() for k2, v2 in freq.items() if k1+k2 >= k)


    """2355. Maximum Number of Books You Can Take (Hard)
    You are given a 0-indexed integer array books of length n where books[i]
    denotes the number of books on the ith shelf of a bookshelf. You are going
    to take books from a contiguous section of the bookshelf spanning from l to
    r where 0 <= l <= r < n. For each index i in the range l <= i < r, you must
    take strictly fewer books from shelf i than shelf i + 1. Return the maximum
    number of books you can take from the bookshelf.

    Example 1:
    Input: books = [8,5,2,7,9]
    Output: 19
    Explanation: - Take 1 book from shelf 1.
                 - Take 2 books from shelf 2.
                 - Take 7 books from shelf 3.
                 - Take 9 books from shelf 4.
                 You have taken 19 books, so return 19. It can be proven that
                 19 is the maximum number of books you can take.

    Example 2:
    Input: books = [7,0,3,4,5]
    Output: 12
    Explanation: - Take 3 books from shelf 2.
                 - Take 4 books from shelf 3.
                 - Take 5 books from shelf 4.
                 You have taken 12 books so return 12. It can be proven that 12
                 is the maximum number of books you can take.

    Example 3:
    Input: books = [8,2,3,7,3,4,0,1,4,3]
    Output: 13
    Explanation: - Take 1 book from shelf 0.
                 - Take 2 books from shelf 1.
                 - Take 3 books from shelf 2.
                 - Take 7 books from shelf 3.
                 You have taken 13 books so return 13. It can be proven that 13
                 is the maximum number of books you can take.

    Constraints:
    * 1 <= books.length <= 10^5
    * 0 <= books[i] <= 10^5"""

    def maximumBooks(self, books: List[int]) -> int:
        dp = [0] * len(books)
        stack = [(-1, -inf)]
        for i, x in enumerate(books):
            while stack[-1][0]-stack[-1][1] <= i-x: stack.pop()
            ii = max(i-x, stack[-1][0])
            dp[i] = (i-ii)*(2*x-i+ii+1)//2
            if 0 <= ii == stack[-1][0]: dp[i] += dp[ii]
            stack.append((i, x))
        return max(dp)


    """2357. Make Array Zero by Subtracting Equal Amounts (Easy)
    You are given a non-negative integer array nums. In one operation, you must:
    * Choose a positive integer x such that x is less than or equal to the
      smallest non-zero element in nums.
    * Subtract x from every positive element in nums.
    Return the minimum number of operations to make every element in nums equal
    to 0.

    Example 1:
    Input: nums = [1,5,0,3,5]
    Output: 3
    Explanation: In the first operation, choose x = 1. Now, nums = [0,4,0,2,4].
                 In the second operation, choose x = 2. Now, nums = [0,2,0,0,2].
                 In the third operation, choose x = 2. Now, nums = [0,0,0,0,0].

    Example 2:
    Input: nums = [0]
    Output: 0
    Explanation: Each element in nums is already 0 so no operations are needed.

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 100"""

    def minimumOperations(self, nums: List[int]) -> int:
        return len(set(x for x in nums if x))


    """2358. Maximum Number of Groups Entering a Competition (Medium)
    You are given a positive integer array grades which represents the grades
    of students in a university. You would like to enter all these students
    into a competition in ordered non-empty groups, such that the ordering
    meets the following conditions:
    * The sum of the grades of students in the ith group is less than the sum
      of the grades of students in the (i + 1)th group, for all groups (except
      the last).
    * The total number of students in the ith group is less than the total
      number of students in the (i + 1)th group, for all groups (except the
      last).
    Return the maximum number of groups that can be formed.

    Example 1:
    Input: grades = [10,6,12,7,3,5]
    Output: 3
    Explanation: The following is a possible way to form 3 groups of students:
                 - 1st group has the students with grades = [12]. Sum of grades:
                   12. Student count: 1
                 - 2nd group has the students with grades = [6,7]. Sum of
                   grades: 6 + 7 = 13. Student count: 2
                 - 3rd group has the students with grades = [10,3,5]. Sum of
                   grades: 10 + 3 + 5 = 18. Student count: 3
                 It can be shown that it is not possible to form more than 3
                 groups.

    Example 2:
    Input: grades = [8,8]
    Output: 1
    Explanation: We can only form 1 group, since forming 2 groups would lead to
                 an equal number of students in both groups.

    Constraints:
    * 1 <= grades.length <= 10^5
    * 1 <= grades[i] <= 10^5"""

    def maximumGroups(self, grades: List[int]) -> int:
        return int((sqrt(1+8*len(grades))-1)//2)


    """2359. Find Closest Node to Given Two Nodes (Medium)
    You are given a directed graph of n nodes numbered from 0 to n - 1, where
    each node has at most one outgoing edge. The graph is represented with a
    given 0-indexed array edges of size n, indicating that there is a directed
    edge from node i to node edges[i]. If there is no outgoing edge from i,
    then edges[i] == -1. You are also given two integers node1 and node2.
    Return the index of the node that can be reached from both node1 and node2,
    such that the maximum between the distance from node1 to that node, and
    from node2 to that node is minimized. If there are multiple answers, return
    the node with the smallest index, and if no possible answer exists, return
    -1. Note that edges may contain cycles.

    Example 1:
    Input: edges = [2,2,3,-1], node1 = 0, node2 = 1
    Output: 2
    Explanation: The distance from node 0 to node 2 is 1, and the distance from
                 node 1 to node 2 is 1. The maximum of those two distances is 1.
                 It can be proven that we cannot get a node with a smaller
                 maximum distance than 1, so we return node 2.

    Example 2:
    Input: edges = [1,2,-1], node1 = 0, node2 = 2
    Output: 2
    Explanation: The distance from node 0 to node 2 is 2, and the distance from
                 node 2 to itself is 0. The maximum of those two distances is 2.
                 It can be proven that we cannot get a node with a smaller
                 maximum distance than 2, so we return node 2.

    Constraints:
    * n == edges.length
    * 2 <= n <= 10^5
    * -1 <= edges[i] < n
    * edges[i] != i
    * 0 <= node1, node2 < n"""

    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:

        def bfs(u):
            """Return distance from node u to reachable nodes."""
            k = 0
            dist = [inf]*len(edges)
            while u != -1 and dist[u] == inf:
                dist[u] = k
                k += 1
                u = edges[u]
            return dist

        ans = -1
        small = inf
        for i, (x1, x2) in enumerate(zip(bfs(node1), bfs(node2))):
            cand = max(x1, x2)
            if cand < small:
                ans = i
                small = cand
        return ans


    """2360. Longest Cycle in a Graph (Hard)
    You are given a directed graph of n nodes numbered from 0 to n - 1, where
    each node has at most one outgoing edge. The graph is represented with a
    given 0-indexed array edges of size n, indicating that there is a directed
    edge from node i to node edges[i]. If there is no outgoing edge from node i,
    then edges[i] == -1. Return the length of the longest cycle in the graph.
    If no cycle exists, return -1. A cycle is a path that starts and ends at
    the same node.

    Example 1:
    Input: edges = [3,3,4,2,3]
    Output: 3
    Explanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.
                 The length of this cycle is 3, so 3 is returned.

    Example 2:
    Input: edges = [2,-1,3,1]
    Output: -1
    Explanation: There are no cycles in this graph.

    Constraints:
    * n == edges.length
    * 2 <= n <= 10^5
    * -1 <= edges[i] < n
    * edges[i] != i"""

    def longestCycle(self, edges: List[int]) -> int:

        def dfs(u, k):
            """Update longest cycle while traversing the graph from u."""
            nonlocal ans
            if u > -1:
                if dist[u] == -1:
                    dist[u] = k
                    dfs(edges[u], k+1)
                elif dist[u]: ans = max(ans, k - dist[u])
                dist[u] = 0

        ans = -1
        dist = [-1]*len(edges)
        for x in range(len(edges)): dfs(x, 1)
        return ans


    """2361. Minimum Costs Using the Train Line (Hard)
    A train line going through a city has two routes, the regular route and the
    express route. Both routes go through the same n + 1 stops labeled from 0
    to n. Initially, you start on the regular route at stop 0. You are given
    two 1-indexed integer arrays regular and express, both of length n.
    regular[i] describes the cost it takes to go from stop i - 1 to stop i
    using the regular route, and express[i] describes the cost it takes to go
    from stop i - 1 to stop i using the express route. You are also given an
    integer expressCost which represents the cost to transfer from the regular
    route to the express route.

    Note that:
    * There is no cost to transfer from the express route back to the regular
      route.
    * You pay expressCost every time you transfer from the regular route to the
      express route.
    * There is no extra cost to stay on the express route.
    Return a 1-indexed array costs of length n, where costs[i] is the minimum
    cost to reach stop i from stop 0. Note that a stop can be counted as
    reached from either route.

    Example 1:
    Input: regular = [1,6,9,5], express = [5,2,3,10], expressCost = 8
    Output: [1,7,14,19]
    Explanation: The diagram above shows how to reach stop 4 from stop 0 with
                 minimum cost.
                 - Take the regular route from stop 0 to stop 1, costing 1.
                 - Take the express route from stop 1 to stop 2, costing 8 + 2 = 10.
                 - Take the express route from stop 2 to stop 3, costing 3.
                 - Take the regular route from stop 3 to stop 4, costing 5.
                 The total cost is 1 + 10 + 3 + 5 = 19. Note that a different
                 route could be taken to reach the other stops with minimum
                 cost.

    Example 2:
    Input: regular = [11,5,13], express = [7,10,6], expressCost = 3
    Output: [10,15,24]
    Explanation: The diagram above shows how to reach stop 3 from stop 0 with
                 minimum cost.
                 - Take the express route from stop 0 to stop 1, costing 3 + 7 = 10.
                 - Take the regular route from stop 1 to stop 2, costing 5.
                 - Take the express route from stop 2 to stop 3, costing 3 + 6 = 9.
                 The total cost is 10 + 5 + 9 = 24. Note that the expressCost
                 is paid again to transfer back to the express route.

    Constraints:
    * n == regular.length == express.length
    * 1 <= n <= 10^5
    * 1 <= regular[i], express[i], expressCost <= 10^5"""

    def minimumCosts(self, regular: List[int], express: List[int], expressCost: int) -> List[int]:
        ans = []
        cr, ce = 0, expressCost
        for r, e in zip(regular, express):
            cr, ce = min(cr+r, ce+e), min(cr+r+expressCost, ce+e)
            ans.append(min(cr, ce))
        return ans



    """2363. Merge Similar Items (Easy)
    You are given two 2D integer arrays, items1 and items2, representing two
    sets of items. Each array items has the following properties:
    * items[i] = [valuei, weighti] where valuei represents the value and
      weighti represents the weight of the ith item.
    * The value of each item in items is unique.
    Return a 2D integer array ret where ret[i] = [valuei, weighti], with
    weighti being the sum of weights of all items with value valuei. Note: ret
    should be returned in ascending order by value.

    Example 1:
    Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]
    Output: [[1,6],[3,9],[4,5]]
    Explanation: The item with value = 1 occurs in items1 with weight = 1 and
                 in items2 with weight = 5, total weight = 1 + 5 = 6. The item
                 with value = 3 occurs in items1 with weight = 8 and in items2
                 with weight = 1, total weight = 8 + 1 = 9. The item with
                 value = 4 occurs in items1 with weight = 5, total weight = 5.
                 Therefore, we return [[1,6],[3,9],[4,5]].

    Example 2:
    Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]
    Output: [[1,4],[2,4],[3,4]]
    Explanation: The item with value = 1 occurs in items1 with weight = 1 and
                 in items2 with weight = 3, total weight = 1 + 3 = 4. The item
                 with value = 2 occurs in items1 with weight = 3 and in items2
                 with weight = 1, total weight = 3 + 1 = 4. The item with
                 value = 3 occurs in items1 with weight = 2 and in items2 with
                 weight = 2, total weight = 2 + 2 = 4. Therefore, we return
                 [[1,4],[2,4],[3,4]].

    Example 3:
    Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]
    Output: [[1,7],[2,4],[7,1]]
    Explanation: The item with value = 1 occurs in items1 with weight = 3 and
                 in items2 with weight = 4, total weight = 3 + 4 = 7. The item
                 with value = 2 occurs in items1 with weight = 2 and in items2
                 with weight = 2, total weight = 2 + 2 = 4. The item with
                 value = 7 occurs in items2 with weight = 1, total weight = 1.
                 Therefore, we return [[1,7],[2,4],[7,1]].

    Constraints:
    * 1 <= items1.length, items2.length <= 1000
    * items1[i].length == items2[i].length == 2
    * 1 <= valuei, weighti <= 1000
    * Each valuei in items1 is unique.
    * Each valuei in items2 is unique."""

    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:
        mp = Counter(dict(items1)) + Counter(dict(items2))
        return sorted(mp.items())


    """2364. Count Number of Bad Pairs (Medium)
    You are given a 0-indexed integer array nums. A pair of indices (i, j) is a
    bad pair if i < j and j - i != nums[j] - nums[i]. Return the total number
    of bad pairs in nums.

    Example 1:
    Input: nums = [4,1,3,3]
    Output: 5
    Explanation: The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.
                 The pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.
                 The pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.
                 The pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.
                 The pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.
                 There are a total of 5 bad pairs, so we return 5.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: 0
    Explanation: There are no bad pairs.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def countBadPairs(self, nums: List[int]) -> int:
        freq = Counter(i-x for i, x in enumerate(nums))
        return sum(v*(len(nums)-v) for v in freq.values())//2


    """2365. Task Scheduler II (Medium)
    You are given a 0-indexed array of positive integers tasks, representing
    tasks that need to be completed in order, where tasks[i] represents the
    type of the ith task. You are also given a positive integer space, which
    represents the minimum number of days that must pass after the completion
    of a task before another task of the same type can be performed. Each day,
    until all tasks have been completed, you must either:
    * Complete the next task from tasks, or
    * Take a break.
    Return the minimum number of days needed to complete all tasks.

    Example 1:
    Input: tasks = [1,2,1,2,3,1], space = 3
    Output: 9
    Explanation: One way to complete all tasks in 9 days is as follows:
                 Day 1: Complete the 0th task.
                 Day 2: Complete the 1st task.
                 Day 3: Take a break.
                 Day 4: Take a break.
                 Day 5: Complete the 2nd task.
                 Day 6: Complete the 3rd task.
                 Day 7: Take a break.
                 Day 8: Complete the 4th task.
                 Day 9: Complete the 5th task.
                 It can be shown that the tasks cannot be completed in less than 9 days.

    Example 2:
    Input: tasks = [5,8,8,5], space = 2
    Output: 6
    Explanation: One way to complete all tasks in 6 days is as follows:
                 Day 1: Complete the 0th task.
                 Day 2: Complete the 1st task.
                 Day 3: Take a break.
                 Day 4: Take a break.
                 Day 5: Complete the 2nd task.
                 Day 6: Complete the 3rd task.
                 It can be shown that the tasks cannot be completed in less than 6 days.

    Constraints:
    * 1 <= tasks.length <= 10^5
    * 1 <= tasks[i] <= 10^9
    * 1 <= space <= tasks.length"""

    def taskSchedulerII(self, tasks: List[int], space: int) -> int:
        ans = 0
        prev = defaultdict(lambda: -inf)
        for t in tasks: ans = prev[t] = max(ans, prev[t]+space)+1
        return ans


    """2366. Minimum Replacements to Sort the Array (Hard)
    You are given a 0-indexed integer array nums. In one operation you can
    replace any element of the array with any two elements that sum to it.
    For example, consider nums = [5,6,7]. In one operation, we can replace
    nums[1] with 2 and 4 and convert nums to [5,2,4,7]. Return the minimum
    number of operations to make an array that is sorted in non-decreasing
    order.

    Example 1:
    Input: nums = [3,9,3]
    Output: 2
    Explanation: Here are the steps to sort the array in non-decreasing order:
                 - From [3,9,3], replace the 9 with 3 and 6 so the array
                   becomes [3,3,6,3]
                 - From [3,3,6,3], replace the 6 with 3 and 3 so the array
                   becomes [3,3,3,3,3]
                 There are 2 steps to sort the array in non-decreasing order.
                 Therefore, we return 2.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: 0
    Explanation: The array is already in non-decreasing order. Therefore, we
                 return 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def minimumReplacement(self, nums: List[int]) -> int:
        ans = 0
        prev = 1_000_000_001
        for x in reversed(nums):
            d = ceil(x/prev)
            ans += d-1
            prev = x//d
        return ans


    """2367. Number of Arithmetic Triplets (Easy)
    You are given a 0-indexed, strictly increasing integer array nums and a
    positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the
    following conditions are met:
    * i < j < k,
    * nums[j] - nums[i] == diff, and
    * nums[k] - nums[j] == diff.
    Return the number of unique arithmetic triplets.

    Example 1:
    Input: nums = [0,1,4,6,7,10], diff = 3
    Output: 2
    Explanation: (1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and
                 4 - 1 == 3. (2, 4, 5) is an arithmetic triplet because both
                 10 - 7 == 3 and 7 - 4 == 3.

    Example 2:
    Input: nums = [4,5,6,7,8,9], diff = 2
    Output: 2
    Explanation: (0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and
                 6 - 4 == 2. (1, 3, 5) is an arithmetic triplet because both
                 9 - 7 == 2 and 7 - 5 == 2.

    Constraints:
    * 3 <= nums.length <= 200
    * 0 <= nums[i] <= 200
    * 1 <= diff <= 50
    * nums is strictly increasing."""

    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        ans = 0
        seen = set()
        for x in nums:
            if x-diff in seen and x-2*diff in seen: ans += 1
            seen.add(x)
        return ans


    """2368. Reachable Nodes With Restrictions (Medium)
    There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1
    edges. You are given a 2D integer array edges of length n - 1 where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. You are also given an integer array restricted which
    represents restricted nodes. Return the maximum number of nodes you can
    reach from node 0 without visiting a restricted node. Note that node 0 will
    not be a restricted node.

    Example 1:
    Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
    Output: 4
    Explanation: The diagram above shows the tree. We have that [0,1,2,3] are
                 the only nodes that can be reached from node 0 without
                 visiting a restricted node.

    Example 2:
    Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
    Output: 3
    Explanation: The diagram above shows the tree. We have that [0,5,6] are the
                 only nodes that can be reached from node 0 without visiting a
                 restricted node.

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * edges represents a valid tree.
    * 1 <= restricted.length < n
    * 1 <= restricted[i] < n
    * All the values of restricted are unique."""

    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        ans = 0
        seen = set(restricted)
        stack = [0]
        while stack:
            u = stack.pop()
            ans += 1
            seen.add(u)
            for v in graph[u]:
                if v not in seen: stack.append(v)
        return ans


    """2369. Check if There is a Valid Partition For The Array (Medium)
    You are given a 0-indexed integer array nums. You have to partition the
    array into one or more contiguous subarrays. We call a partition of the
    array valid if each of the obtained subarrays satisfies one of the
    following conditions:
    * The subarray consists of exactly 2 equal elements. For example, the
      subarray [2,2] is good.
    * The subarray consists of exactly 3 equal elements. For example, the
      subarray [4,4,4] is good.
    * The subarray consists of exactly 3 consecutive increasing elements, that
      is, the difference between adjacent elements is 1. For example, the
      subarray [3,4,5] is good, but the subarray [1,3,5] is not.
    Return true if the array has at least one valid partition. Otherwise,
    return false.

    Example 1:
    Input: nums = [4,4,4,5,6]
    Output: true
    Explanation: The array can be partitioned into the subarrays [4,4] and
                 [4,5,6]. This partition is valid, so we return true.

    Example 2:
    Input: nums = [1,1,1,2]
    Output: false
    Explanation: There is no valid partition for this array.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def validPartition(self, nums: List[int]) -> bool:
        dp = [False]*(len(nums)+1)
        dp[-1] = True
        for i in range(len(nums)-1, -1, -1):
            if i+1 < len(nums) and dp[i+2] and nums[i] == nums[i+1] \
            or i+2 < len(nums) and dp[i+3] and (nums[i] == nums[i+1] == nums[i+2] or nums[i]+2 == nums[i+1]+1 == nums[i+2]): dp[i] = True
        return dp[0]


    """2370. Longest Ideal Subsequence (Medium)
    You are given a string s consisting of lowercase letters and an integer k.
    We call a string t ideal if the following conditions are satisfied:
    * t is a subsequence of the string s.
    * The absolute difference in the alphabet order of every two adjacent
      letters in t is less than or equal to k.
    Return the length of the longest ideal string. A subsequence is a string
    that can be derived from another string by deleting some or no characters
    without changing the order of the remaining characters. Note that the
    alphabet order is not cyclic. For example, the absolute difference in the
    alphabet order of 'a' and 'z' is 25, not 1.

    Example 1:
    Input: s = "acfgbd", k = 2
    Output: 4
    Explanation: The longest ideal string is "acbd". The length of this string
                 is 4, so 4 is returned. Note that "acfgbd" is not ideal
                 because 'c' and 'f' have a difference of 3 in alphabet order.

    Example 2:
    Input: s = "abcd", k = 3
    Output: 4
    Explanation: The longest ideal string is "abcd". The length of this string
                 is 4, so 4 is returned.

    Constraints:
    * 1 <= s.length <= 10^5
    * 0 <= k <= 25
    * s consists of lowercase English letters."""

    def longestIdealString(self, s: str, k: int) -> int:
        dp = [0]*26
        for ch in s:
            x = ord(ch)-97
            dp[x] = 1 + max(dp[max(0, x-k) : x+k+1])
        return max(dp)


    """2371. Minimize Maximum Value in a Grid (Hard)
    You are given an m x n integer matrix grid containing distinct positive
    integers. You have to replace each integer in the matrix with a positive
    integer satisfying the following conditions:
    * The relative order of every two elements that are in the same row or
      column should stay the same after the replacements.
    * The maximum number in the matrix after the replacements should be as
      small as possible.
    The relative order stays the same if for all pairs of elements in the
    original matrix such that grid[r1][c1] > grid[r2][c2] where either r1 == r2
    or c1 == c2, then it must be true that grid[r1][c1] > grid[r2][c2] after
    the replacements. For example, if grid = [[2, 4, 5], [7, 3, 9]] then a good
    replacement could be either grid = [[1, 2, 3], [2, 1, 4]] or
    grid = [[1, 2, 3], [3, 1, 4]]. Return the resulting matrix. If there are
    multiple answers, return any of them.

    Example 1:
    Input: grid = [[3,1],[2,5]]
    Output: [[2,1],[1,2]]
    Explanation: The above diagram shows a valid replacement. The maximum
                 number in the matrix is 2. It can be shown that no smaller
                 value can be obtained.

    Example 2:
    Input: grid = [[10]]
    Output: [[1]]
    Explanation: We replace the only number in the matrix with 1.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 1000
    * 1 <= m * n <= 10^5
    * 1 <= grid[i][j] <= 10^9
    * grid consists of distinct integers."""

    def minScore(self, grid: List[List[int]]) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        ans = [[0] * n for _ in range(m)]
        row = [0] * m
        col = [0] * n
        for _, i, j in sorted((grid[i][j], i, j) for i in range(m) for j in range(n)):
            ans[i][j] = row[i] = col[j] = max(row[i], col[j]) + 1
        return ans


    """2373. Largest Local Values in a Matrix (Easy)
    You are given an n x n integer matrix grid. Generate an integer matrix
    maxLocal of size (n - 2) x (n - 2) such that:
    * maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid
      centered around row i + 1 and column j + 1.
    In other words, we want to find the largest value in every contiguous 3 x 3
    matrix in grid. Return the generated matrix.

    Example 1:
    Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
    Output: [[9,9],[8,6]]
    Explanation: The diagram above shows the original matrix and the generated
                 matrix. Notice that each value in the generated matrix
                 corresponds to the largest value of a contiguous 3 x 3 matrix
                 in grid.

    Example 2:
    Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]
    Output: [[2,2,2],[2,2,2],[2,2,2]]
    Explanation: Notice that the 2 is contained within every contiguous 3 x 3
                 matrix in grid.

    Constraints:
    * n == grid.length == grid[i].length
    * 3 <= n <= 100
    * 1 <= grid[i][j] <= 100"""

    def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        ans = [[0]*(n-2) for _ in range(n-2)]
        for i in range(n-2):
            for j in range(n-2):
                ans[i][j] = max(grid[ii][jj] for ii in range(i, i+3) for jj in range(j, j+3))
        return ans


    """2374. Node With Highest Edge Score (Medium)
    You are given a directed graph with n nodes labeled from 0 to n - 1, where
    each node has exactly one outgoing edge. The graph is represented by a
    given 0-indexed integer array edges of length n, where edges[i] indicates
    that there is a directed edge from node i to node edges[i]. The edge score
    of a node i is defined as the sum of the labels of all the nodes that have
    an edge pointing to i. Return the node with the highest edge score. If
    multiple nodes have the same edge score, return the node with the smallest
    index.

    Example 1:
    Input: edges = [1,0,0,0,0,7,7,5]
    Output: 7
    Explanation: - The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The
                   edge score of node 0 is 1 + 2 + 3 + 4 = 10.
                 - The node 0 has an edge pointing to node 1. The edge score of
                   node 1 is 0.
                 - The node 7 has an edge pointing to node 5. The edge score of
                   node 5 is 7.
                 - The nodes 5 and 6 have an edge pointing to node 7. The edge
                   score of node 7 is 5 + 6 = 11.
                 Node 7 has the highest edge score so return 7.

    Example 2:
    Input: edges = [2,0,0,2]
    Output: 0
    Explanation: - The nodes 1 and 2 have an edge pointing to node 0. The edge
                   score of node 0 is 1 + 2 = 3.
                 - The nodes 0 and 3 have an edge pointing to node 2. The edge
                   score of node 2 is 0 + 3 = 3.
                 Nodes 0 and 2 both have an edge score of 3. Since node 0 has a
                 smaller index, we return 0.

    Constraints:
    * n == edges.length
    * 2 <= n <= 10^5
    * 0 <= edges[i] < n
    * edges[i] != i"""

    def edgeScore(self, edges: List[int]) -> int:
        score = [0]*len(edges)
        for i, x in enumerate(edges): score[x] += i
        return score.index(max(score))


    """2375. Construct Smallest Number From DI String (Medium)
    You are given a 0-indexed string pattern of length n consisting of the
    characters 'I' meaning increasing and 'D' meaning decreasing. A 0-indexed
    string num of length n + 1 is created using the following conditions:
    * num consists of the digits '1' to '9', where each digit is used at most
      once.
    * If pattern[i] == 'I', then num[i] < num[i + 1].
    * If pattern[i] == 'D', then num[i] > num[i + 1].
    Return the lexicographically smallest possible string num that meets the
    conditions.

    Example 1:
    Input: pattern = "IIIDIDDD"
    Output: "123549876"
    Explanation: At indices 0, 1, 2, and 4 we must have that num[i] < num[i+1].
                 At indices 3, 5, 6, and 7 we must have that num[i] > num[i+1].
                 Some possible values of num are "245639871", "135749862", and
                 "123849765". It can be proven that "123549876" is the smallest
                 possible num that meets the conditions. Note that "123414321"
                 is not possible because the digit '1' is used more than once.

    Example 2:
    Input: pattern = "DDD"
    Output: "4321"
    Explanation: Some possible values of num are "9876", "7321", and "8742". It
                 can be proven that "4321" is the smallest possible num that
                 meets the conditions.

    Constraints:
    * 1 <= pattern.length <= 8
    * pattern consists of only the letters 'I' and 'D'."""

    def smallestNumber(self, pattern: str) -> str:
        ans = []
        stack = []
        for i in range(len(pattern)+1):
            stack.append(str(i+1))
            if i == len(pattern) or pattern[i] == 'I':
                while stack: ans.append(stack.pop())
        return ''.join(ans)


    """2376. Count Special Integers (Hard)
    We call a positive integer special if all of its digits are distinct. Given
    a positive integer n, return the number of special integers that belong to
    the interval [1, n].

    Example 1:
    Input: n = 20
    Output: 19
    Explanation: All the integers from 1 to 20, except 11, are special. Thus,
                 there are 19 special integers.

    Example 2:
    Input: n = 5
    Output: 5
    Explanation: All the integers from 1 to 5 are special.

    Example 3:
    Input: n = 135
    Output: 110
    Explanation: There are 110 integers from 1 to 135 that are special. Some of
                 the integers that are not special are: 22, 114, and 131.

    Constraints: 1 <= n <= 2 * 10^9"""

    def countSpecialNumbers(self, n: int) -> int:
        vals = list(map(int, str(n)))

        @cache
        def fn(i, m, on):
            """Return count at index i with mask m and profile flag (True/False)"""
            ans = 0
            if i == len(vals): return 1
            for v in range(vals[i] if on else 10 ):
                if m & 1<<v == 0:
                    if m or v: ans += fn(i+1, m ^ 1<<v, False)
                    else: ans += fn(i+1, m, False)
            if on and m & 1<<vals[i] == 0: ans += fn(i+1, m ^ 1<<vals[i], True)
            return ans

        return fn(0, 0, True)-1


    """2378. Choose Edges to Maximize Score in a Tree (Medium)
    You are given a weighted tree consisting of n nodes numbered from 0 to
    n - 1. The tree is rooted at node 0 and represented with a 2D array edges
    of size n where edges[i] = [pari, weighti] indicates that node pari is the
    parent of node i, and the edge between them has a weight equal to weighti.
    Since the root does not have a parent, you have edges[0] = [-1, -1]. Choose
    some edges from the tree such that no two chosen edges are adjacent and the
    sum of the weights of the chosen edges is maximized. Return the maximum sum
    of the chosen edges.

    Note:
    * You are allowed to not choose any edges in the tree, the sum of weights
      in this case will be 0.
    * Two edges Edge1 and Edge2 in the tree are adjacent if they have a common
      node.
      + In other words, they are adjacent if Edge1 connects nodes a and b and
        Edge2 connects nodes b and c.

    Example 1:
    Input: edges = [[-1,-1],[0,5],[0,10],[2,6],[2,4]]
    Output: 11
    Explanation: The above diagram shows the edges that we have to choose
                 colored in red. The total score is 5 + 6 = 11. It can be shown
                 that no better score can be obtained.

    Example 2:
    Input: edges = [[-1,-1],[0,5],[0,-6],[0,7]]
    Output: 7
    Explanation: We choose the edge with weight 7. Note that we cannot choose
                 more than one edge because all edges are adjacent to each
                 other.

    Constraints:
    * n == edges.length
    * 1 <= n <= 10^5
    * edges[i].length == 2
    * par0 == weight0 == -1
    * 0 <= pari <= n - 1 for all i >= 1.
    * pari != i
    * -10^6 <= weighti <= 10^6 for all i >= 1.
    * edges represents a valid tree."""

    def maxScore(self, edges: List[List[int]]) -> int:
        n = len(edges)
        tree = [[] for _ in range(n)]
        for i, (p, w) in enumerate(edges):
            if i: tree[p].append((i, w))

        def dfs(u):
            """Return """
            sm = delta = 0
            for v, w in tree[u]:
                ss, dd = dfs(v)
                sm += ss + dd
                delta = max(delta, w-dd)
            return sm, delta

        return sum(dfs(0))


    """2379. Minimum Recolors to Get K Consecutive Black Blocks (Easy)
    You are given a 0-indexed string blocks of length n, where blocks[i] is
    either 'W' or 'B', representing the color of the ith block. The characters
    'W' and 'B' denote the colors white and black, respectively. You are also
    given an integer k, which is the desired number of consecutive black blocks.
    In one operation, you can recolor a white block such that it becomes a
    black block. Return the minimum number of operations needed such that there
    is at least one occurrence of k consecutive black blocks.

    Example 1:
    Input: blocks = "WBBWWBBWBW", k = 7
    Output: 3
    Explanation: One way to achieve 7 consecutive black blocks is to recolor
                 the 0th, 3rd, and 4th blocks so that blocks = "BBBBBBBWBW".
                 It can be shown that there is no way to achieve 7 consecutive
                 black blocks in less than 3 operations. Therefore, we return 3.

    Example 2:
    Input: blocks = "WBWBBBW", k = 2
    Output: 0
    Explanation: No changes need to be made, since 2 consecutive black blocks
                 already exist. Therefore, we return 0.

    Constraints:
    * n == blocks.length
    * 1 <= n <= 100
    * blocks[i] is either 'W' or 'B'.
    * 1 <= k <= n"""

    def minimumRecolors(self, blocks: str, k: int) -> int:
        ans = inf
        rsm = 0
        for i, ch in enumerate(blocks):
            if ch == 'W': rsm += 1
            if i >= k and blocks[i-k] == 'W': rsm -= 1
            if i >= k-1: ans = min(ans, rsm)
        return ans


    """2380. Time Needed to Rearrange a Binary String (Medium)
    You are given a binary string s. In one second, all occurrences of "01" are
    simultaneously replaced with "10". This process repeats until no
    occurrences of "01" exist. Return the number of seconds needed to complete
    this process.

    Example 1:
    Input: s = "0110101"
    Output: 4
    Explanation: After one second, s becomes "1011010".
                 After another second, s becomes "1101100".
                 After the third second, s becomes "1110100".
                 After the fourth second, s becomes "1111000".
                 No occurrence of "01" exists any longer, and the process
                 needed 4 seconds to complete, so we return 4.

    Example 2:
    Input: s = "11100"
    Output: 0
    Explanation: No occurrence of "01" exists in s, and the processes needed 0
                 seconds to complete, so we return 0.

    Constraints:
    * 1 <= s.length <= 1000
    * s[i] is either '0' or '1'."""

    def secondsToRemoveOccurrences(self, s: str) -> int:
        ans = prefix = prev = 0
        for i, ch in enumerate(s):
            if ch == '1':
                ans = max(prev, i - prefix)
                prefix += 1
                if ans: prev = ans+1
        return ans


    """2381. Shifting Letters II (Medium)
    You are given a string s of lowercase English letters and a 2D integer
    array shifts where shifts[i] = [starti, endi, directioni]. For every i,
    shift the characters in s from the index starti to the index endi
    (inclusive) forward if directioni = 1, or shift the characters backward if
    directioni = 0. Shifting a character forward means replacing it with the
    next letter in the alphabet (wrapping around so that 'z' becomes 'a').
    Similarly, shifting a character backward means replacing it with the
    previous letter in the alphabet (wrapping around so that 'a' becomes 'z').
    Return the final string after all such shifts to s are applied.

    Example 1:
    Input: s = "abc", shifts = [[0,1,0],[1,2,1],[0,2,1]]
    Output: "ace"
    Explanation: Firstly, shift the characters from index 0 to index 1 backward.
                 Now s = "zac". Secondly, shift the characters from index 1 to
                 index 2 forward. Now s = "zbd". Finally, shift the characters
                 from index 0 to index 2 forward. Now s = "ace".

    Example 2:
    Input: s = "dztz", shifts = [[0,0,0],[1,1,1]]
    Output: "catz"
    Explanation: Firstly, shift the characters from index 0 to index 0 backward.
                 Now s = "cztz". Finally, shift the characters from index 1 to
                 index 1 forward. Now s = "catz".

    Constraints:
    * 1 <= s.length, shifts.length <= 5 * 10^4
    * shifts[i].length == 3
    * 0 <= starti <= endi < s.length
    * 0 <= directioni <= 1
    * s consists of lowercase English letters."""

    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        ops = []
        for start, end, direction in shifts:
            direction = 2*direction-1
            ops.append((start, direction))
            ops.append((end+1, -direction))
        ops.sort()
        ans = []
        prefix = ii = 0
        for i, ch in enumerate(s):
            while ii < len(ops) and ops[ii][0] == i:
                prefix += ops[ii][1]
                ii += 1
            ans.append(chr((ord(ch)-97+prefix)%26+97))
        return ''.join(ans)


    """2382. Maximum Segment Sum After Removals (Hard)
    You are given two 0-indexed integer arrays nums and removeQueries, both of
    length n. For the ith query, the element in nums at the index
    removeQueries[i] is removed, splitting nums into different segments. A
    segment is a contiguous sequence of positive integers in nums. A segment
    sum is the sum of every element in a segment. Return an integer array
    answer, of length n, where answer[i] is the maximum segment sum after
    applying the ith removal. Note: The same index will not be removed more
    than once.

    Example 1:
    Input: nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]
    Output: [14,7,2,2,0]
    Explanation: Using 0 to indicate a removed element, the answer is as
                 follows:
                 Query 1: Remove the 0th element, nums becomes [0,2,5,6,1] and
                          the maximum segment sum is 14 for segment [2,5,6,1].
                 Query 2: Remove the 3rd element, nums becomes [0,2,5,0,1] and
                          the maximum segment sum is 7 for segment [2,5].
                 Query 3: Remove the 2nd element, nums becomes [0,2,0,0,1] and
                          the maximum segment sum is 2 for segment [2].
                 Query 4: Remove the 4th element, nums becomes [0,2,0,0,0] and
                          the maximum segment sum is 2 for segment [2].
                 Query 5: Remove the 1st element, nums becomes [0,0,0,0,0] and
                          the maximum segment sum is 0, since there are no
                          segments.
                 Finally, we return [14,7,2,2,0].

    Example 2:
    Input: nums = [3,2,11,1], removeQueries = [3,2,1,0]
    Output: [16,5,3,0]
    Explanation: Using 0 to indicate a removed element, the answer is as
                 follows:
                 Query 1: Remove the 3rd element, nums becomes [3,2,11,0] and
                          the maximum segment sum is 16 for segment [3,2,11].
                 Query 2: Remove the 2nd element, nums becomes [3,2,0,0] and
                          the maximum segment sum is 5 for segment [3,2].
                 Query 3: Remove the 1st element, nums becomes [3,0,0,0] and
                          the maximum segment sum is 3 for segment [3].
                 Query 4: Remove the 0th element, nums becomes [0,0,0,0] and
                          the maximum segment sum is 0, since there are no
                          segments.
                 Finally, we return [16,5,3,0].

    Constraints:
    * n == nums.length == removeQueries.length
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= 10^9
    * 0 <= removeQueries[i] < n
    * All the values of removeQueries are unique."""

    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        n = len(nums)
        sl = SortedList([-1, n])
        prefix = list(accumulate(nums, initial=0))
        mp = {-1 : n}
        pq = [(-prefix[-1], -1, n)]

        ans = []
        for q in removeQueries:
            sl.add(q)
            i = sl.bisect_left(q)
            lo = sl[i-1]
            hi = sl[i+1]
            mp[lo] = q
            mp[q] = hi
            heappush(pq, (-(prefix[q]-prefix[lo+1]), lo, q))
            heappush(pq, (-(prefix[hi]-prefix[q+1]), q, hi))

            while mp[pq[0][1]] != pq[0][2]: heappop(pq)
            ans.append(-pq[0][0])
        return ans


    """2383. Minimum Hours of Training to Win a Competition (Easy)
    You are entering a competition, and are given two positive integers
    initialEnergy and initialExperience denoting your initial energy and
    initial experience respectively. You are also given two 0-indexed integer
    arrays energy and experience, both of length n. You will face n opponents
    in order. The energy and experience of the ith opponent is denoted by
    energy[i] and experience[i] respectively. When you face an opponent, you
    need to have both strictly greater experience and energy to defeat them and
    move to the next opponent if available. Defeating the ith opponent
    increases your experience by experience[i], but decreases your energy by
    energy[i]. Before starting the competition, you can train for some number
    of hours. After each hour of training, you can either choose to increase
    your initial experience by one, or increase your initial energy by one.
    Return the minimum number of training hours required to defeat all n
    opponents.

    Example 1:
    Input: initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]
    Output: 8
    Explanation: You can increase your energy to 11 after 6 hours of training,
                 and your experience to 5 after 2 hours of training. You face
                 the opponents in the following order:
                 - You have more energy and experience than the 0th opponent so
                   you win. Your energy becomes 11 - 1 = 10, and your
                   experience becomes 5 + 2 = 7.
                 - You have more energy and experience than the 1st opponent so
                   you win. Your energy becomes 10 - 4 = 6, and your experience
                   becomes 7 + 6 = 13.
                 - You have more energy and experience than the 2nd opponent so
                   you win. Your energy becomes 6 - 3 = 3, and your experience
                   becomes 13 + 3 = 16.
                 - You have more energy and experience than the 3rd opponent so
                   you win. Your energy becomes 3 - 2 = 1, and your experience
                   becomes 16 + 1 = 17.
                 You did a total of 6 + 2 = 8 hours of training before the
                 competition, so we return 8. It can be proven that no smaller
                 answer exists.

    Example 2:
    Input: initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]
    Output: 0
    Explanation: You do not need any additional energy or experience to win the
                 competition, so we return 0.

    Constraints:
    * n == energy.length == experience.length
    * 1 <= n <= 100
    * 1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100"""

    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
        ans = 0
        for x, y in zip(energy, experience):
            if initialEnergy <= x:
                ans += x + 1 - initialEnergy
                initialEnergy = x + 1
            if initialExperience <= y:
                ans += y + 1 - initialExperience
                initialExperience = y + 1
            initialEnergy -= x
            initialExperience += y
        return ans


    """2384. Largest Palindromic Number (Medium)
    You are given a string num consisting of digits only. Return the largest
    palindromic integer (in the form of a string) that can be formed using
    digits taken from num. It should not contain leading zeroes.

    Notes:
    * You do not need to use all the digits of num, but you must use at least
      one digit.
    * The digits can be reordered.

    Example 1:
    Input: num = "444947137"
    Output: "7449447"
    Explanation: Use the digits "4449477" from "444947137" to form the
                 palindromic integer "7449447". It can be shown that "7449447"
                 is the largest palindromic integer that can be formed.

    Example 2:
    Input: num = "00009"
    Output: "9"
    Explanation: It can be shown that "9" is the largest palindromic integer
                 that can be formed. Note that the integer returned should not
                 contain leading zeroes.

    Constraints:
    * 1 <= num.length <= 10^5
    * num consists of digits."""

    def largestPalindromic(self, num: str) -> str:
        freq = Counter(num)
        mid = next((ch for ch in "9876543210" if freq[ch]&1), '')
        half = ''.join(ch*(freq[ch]//2) for ch in "0123456789")
        return (half[::-1] + mid + half).strip('0') or '0'


    """2385. Amount of Time for Binary Tree to Be Infected (Medium)
    You are given the root of a binary tree with unique values, and an integer
    start. At minute 0, an infection starts from the node with value start.
    Each minute, a node becomes infected if:
    * The node is currently uninfected.
    * The node is adjacent to an infected node.
    Return the number of minutes needed for the entire tree to be infected.

    Example 1:
    Input: root = [1,5,3,null,4,10,6,9,2], start = 3
    Output: 4
    Explanation: The following nodes are infected during:
                 - Minute 0: Node 3
                 - Minute 1: Nodes 1, 10 and 6
                 - Minute 2: Node 5
                 - Minute 3: Node 4
                 - Minute 4: Nodes 9 and 2
                 It takes 4 minutes for the whole tree to be infected so we
                 return 4.

    Example 2:
    Input: root = [1], start = 1
    Output: 0
    Explanation: At minute 0, the only node in the tree is infected so we
                 return 0.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 105
    * Each node has a unique value.
    * A node with a value of start exists in the tree."""

    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:
        graph = defaultdict(list)
        stack = [(root, None)]
        while stack:
            n, p = stack.pop()
            if p:
                graph[p.val].append(n.val)
                graph[n.val].append(p.val)
            if n.left: stack.append((n.left, n))
            if n.right: stack.append((n.right, n))
        ans = -1
        seen = {start}
        queue = deque([start])
        while queue:
            for _ in range(len(queue)):
                u = queue.popleft()
                for v in graph[u]:
                    if v not in seen:
                        seen.add(v)
                        queue.append(v)
            ans += 1
        return ans


    """2386. Find the K-Sum of an Array (Hard)
    You are given an integer array nums and a positive integer k. You can
    choose any subsequence of the array and sum all of its elements together.
    We define the K-Sum of the array as the kth largest subsequence sum that
    can be obtained (not necessarily distinct). Return the K-Sum of the array.
    A subsequence is an array that can be derived from another array by
    deleting some or no elements without changing the order of the remaining
    elements. Note that the empty subsequence is considered to have a sum of 0.

    Example 1:
    Input: nums = [2,4,-2], k = 5
    Output: 2
    Explanation: All the possible subsequence sums that we can obtain are the
                 following sorted in decreasing order:
                 - 6, 4, 4, 2, 2, 0, 0, -2.
                 The 5-Sum of the array is 2.

    Example 2:
    Input: nums = [1,-2,3,4,-10,12], k = 16
    Output: 10
    Explanation: The 16-Sum of the array is 10.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * -10^9 <= nums[i] <= 10^9
    * 1 <= k <= min(2000, 2n)"""

    def kSum(self, nums: List[int], k: int) -> int:
        m = sum(x for x in nums if x > 0)
        pq = [(-m, 0)]
        vals = sorted(abs(x) for x in nums)
        for _ in range(k):
            x, i = heappop(pq)
            if i < len(vals):
                heappush(pq, (x+vals[i], i+1))
                if i: heappush(pq, (x-vals[i-1]+vals[i], i+1))
        return -x


    """2387. Median of a Row Wise Sorted Matrix (Medium)
    Given an m x n matrix grid containing an odd number of integers where each
    row is sorted in non-decreasing order, return the median of the matrix.
    You must solve the problem in less than O(m * n) time complexity.

    Example 1:
    Input: grid = [[1,1,2],[2,3,3],[1,3,4]]
    Output: 2
    Explanation: The elements of the matrix in sorted order are
                 1,1,1,2,2,3,3,3,4. The median is 2.

    Example 2:
    Input: grid = [[1,1,3,3,4]]
    Output: 3
    Explanation: The elements of the matrix in sorted order are 1,1,3,3,4. The
                 median is 3.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 500
    * m and n are both odd.
    * 1 <= grid[i][j] <= 10^6
    * grid[i] is sorted in non-decreasing order."""

    def matrixMedian(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        lo, hi = inf, -inf
        for row in grid:
            lo = min(lo, row[0])
            hi = max(hi, row[-1])
        while lo < hi:
            mid = lo + hi >> 1
            more = sum(n - bisect_right(row, mid) for row in grid)
            if more > m*n/2: lo = mid + 1
            else: hi = mid
        return lo


    """2389. Longest Subsequence With Limited Sum (Easy)
    You are given an integer array nums of length n, and an integer array
    queries of length m. Return an array answer of length m where answer[i] is
    the maximum size of a subsequence that you can take from nums such that the
    sum of its elements is less than or equal to queries[i]. A subsequence is
    an array that can be derived from another array by deleting some or no
    elements without changing the order of the remaining elements.

    Example 1:
    Input: nums = [4,5,2,1], queries = [3,10,21]
    Output: [2,3,4]
    Explanation: We answer the queries as follows:
                 - The subsequence [2,1] has a sum less than or equal to 3. It
                   can be proven that 2 is the maximum size of such a
                   subsequence, so answer[0] = 2.
                 - The subsequence [4,5,1] has a sum less than or equal to 10.
                   It can be proven that 3 is the maximum size of such a
                   subsequence, so answer[1] = 3.
                 - The subsequence [4,5,2,1] has a sum less than or equal to 21.
                   It can be proven that 4 is the maximum size of such a
                   subsequence, so answer[2] = 4.

    Example 2:
    Input: nums = [2,3,4,5], queries = [1]
    Output: [0]
    Explanation: The empty subsequence is the only subsequence that has a sum
                 less than or equal to 1, so answer[0] = 0.

    Constraints:
    * n == nums.length
    * m == queries.length
    * 1 <= n, m <= 1000
    * 1 <= nums[i], queries[i] <= 10^6"""

    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        prefix = list(accumulate(sorted(nums)))
        return [bisect_right(prefix, q) for q in queries]


    """2390. Removing Stars From a String (Medium)
    You are given a string s, which contains stars *. In one operation, you can:
    * Choose a star in s.
    * Remove the closest non-star character to its left, as well as remove the
      star itself.
    Return the string after all stars have been removed.

    Note:
    * The input will be generated such that the operation is always possible.
    * It can be shown that the resulting string will always be unique.

    Example 1:
    Input: s = "leet**cod*e"
    Output: "lecoe"
    Explanation: Performing the removals from left to right:
                 - The closest character to the 1st star is 't' in "leet**cod*e".
                   s becomes "lee*cod*e".
                 - The closest character to the 2nd star is 'e' in "lee*cod*e".
                   s becomes "lecod*e".
                 - The closest character to the 3rd star is 'd' in "lecod*e". s
                   becomes "lecoe".
                 There are no more stars, so we return "lecoe".

    Example 2:
    Input: s = "erase*****"
    Output: ""
    Explanation: The entire string is removed, so we return an empty string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters and stars *.
    * The operation above can be performed on s."""

    def removeStars(self, s: str) -> str:
        stack = []
        for ch in s:
            if ch == '*': stack.pop()
            else: stack.append(ch)
        return ''.join(stack)


    """2391. Minimum Amount of Time to Collect Garbage (Medium)
    You are given a 0-indexed array of strings garbage where garbage[i]
    represents the assortment of garbage at the ith house. garbage[i] consists
    only of the characters 'M', 'P' and 'G' representing one unit of metal,
    paper and glass garbage respectively. Picking up one unit of any type of
    garbage takes 1 minute. You are also given a 0-indexed integer array travel
    where travel[i] is the number of minutes needed to go from house i to house
    i + 1. There are three garbage trucks in the city, each responsible for
    picking up one type of garbage. Each garbage truck starts at house 0 and
    must visit each house in order; however, they do not need to visit every
    house. Only one garbage truck may be used at any given moment. While one
    truck is driving or picking up garbage, the other two trucks cannot do
    anything. Return the minimum number of minutes needed to pick up all the
    garbage.

    Example 1:
    Input: garbage = ["G","P","GP","GG"], travel = [2,4,3]
    Output: 21
    Explanation: The paper garbage truck:
                 1. Travels from house 0 to house 1
                 2. Collects the paper garbage at house 1
                 3. Travels from house 1 to house 2
                 4. Collects the paper garbage at house 2
                 Altogether, it takes 8 minutes to pick up all the paper
                 garbage. The glass garbage truck:
                 1. Collects the glass garbage at house 0
                 2. Travels from house 0 to house 1
                 3. Travels from house 1 to house 2
                 4. Collects the glass garbage at house 2
                 5. Travels from house 2 to house 3
                 6. Collects the glass garbage at house 3
                 Altogether, it takes 13 minutes to pick up all the glass
                 garbage. Since there is no metal garbage, we do not need to
                 consider the metal garbage truck. Therefore, it takes a total
                 of 8 + 13 = 21 minutes to collect all the garbage.

    Example 2:
    Input: garbage = ["MMM","PGM","GP"], travel = [3,10]
    Output: 37
    Explanation: The metal garbage truck takes 7 minutes to pick up all the
                 metal garbage. The paper garbage truck takes 15 minutes to
                 pick up all the paper garbage. The glass garbage truck takes
                 15 minutes to pick up all the glass garbage. It takes a total
                 of 7 + 15 + 15 = 37 minutes to collect all the garbage.

    Constraints:
    * 2 <= garbage.length <= 10^5
    * garbage[i] consists of only the letters 'M', 'P', and 'G'.
    * 1 <= garbage[i].length <= 10
    * travel.length == garbage.length - 1
    * 1 <= travel[i] <= 100"""

    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        ans = sum(map(len, garbage))
        prefix = list(accumulate(travel, initial=0))
        for ch in "MPG":
            ii = 0
            for i, s in enumerate(garbage):
                if ch in s: ii = i
            ans += prefix[ii]
        return ans


    """2392. Build a Matrix With Conditions (Hard)
    You are given a positive integer k. You are also given:
    * a 2D integer array rowConditions of size n where
      rowConditions[i] = [abovei, belowi], and
    * a 2D integer array colConditions of size m where
      colConditions[i] = [lefti, righti].
    The two arrays contain integers from 1 to k. You have to build a k x k
    matrix that contains each of the numbers from 1 to k exactly once. The
    remaining cells should have the value 0. The matrix should also satisfy the
    following conditions:
    * The number abovei should appear in a row that is strictly above the row
      at which the number belowi appears for all i from 0 to n - 1.
    * The number lefti should appear in a column that is strictly left of the
      column at which the number righti appears for all i from 0 to m - 1.
    Return any matrix that satisfies the conditions. If no answer exists,
    return an empty matrix.

    Example 1:
    Input: k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]
    Output: [[3,0,0],[0,0,1],[0,2,0]]
    Explanation: The diagram above shows a valid example of a matrix that
                 satisfies all the conditions. The row conditions are the
                 following:
                 - Number 1 is in row 1, and number 2 is in row 2, so 1 is
                   above 2 in the matrix.
                 - Number 3 is in row 0, and number 2 is in row 2, so 3 is
                   above 2 in the matrix.
                 The column conditions are the following:
                 - Number 2 is in column 1, and number 1 is in column 2, so 2
                   is left of 1 in the matrix.
                 - Number 3 is in column 0, and number 2 is in column 1, so 3
                   is left of 2 in the matrix.
                 Note that there may be multiple correct answers.

    Example 2:
    Input: k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]
    Output: []
    Explanation: From the first two conditions, 3 has to be below 1 but the
                 third conditions needs 3 to be above 1 to be satisfied. No
                 matrix can satisfy all the conditions, so we return the empty matrix.

    Constraints:
    * 2 <= k <= 400
    * 1 <= rowConditions.length, colConditions.length <= 10^4
    * rowConditions[i].length == colConditions[i].length == 2
    * 1 <= abovei, belowi, lefti, righti <= k
    * abovei != belowi
    * lefti != righti"""

    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:

        def fn(cond):
            """Return topological sort"""
            graph = [[] for _ in range(k)]
            degree = [0]*k
            for u, v in cond:
                graph[u-1].append(v-1)
                degree[v-1] += 1
            queue = deque(u for u, x in enumerate(degree) if x == 0)
            ans = []
            while queue:
                u = queue.popleft()
                ans.append(u+1)
                for v in graph[u]:
                    degree[v] -= 1
                    if degree[v] == 0: queue.append(v)
            return ans

        row = fn(rowConditions)
        col = fn(colConditions)

        if len(row) < k or len(col) < k: return []
        ans = [[0]*k for _ in range(k)]
        row = {x : i for i, x in enumerate(row)}
        col = {x : j for j, x in enumerate(col)}
        for x in range(1, k+1): ans[row[x]][col[x]] = x
        return ans


    """2393. Count Strictly Increasing Subarrays (Medium)
    You are given an array nums consisting of positive integers. Return the
    number of subarrays of nums that are in strictly increasing order. A
    subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1,3,5,4,4,6]
    Output: 10
    Explanation: The strictly increasing subarrays are the following:
                 - Subarrays of length 1: [1], [3], [5], [4], [4], [6].
                 - Subarrays of length 2: [1,3], [3,5], [4,6].
                 - Subarrays of length 3: [1,3,5].
                 The total number of subarrays is 6 + 3 + 1 = 10.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: 15
    Explanation: Every subarray is strictly increasing. There are 15 possible
                 subarrays that we can take.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def countSubarrays(self, nums: List[int]) -> int:
        ans = cnt = 0
        for i, x in enumerate(nums):
            if i and nums[i-1] >= nums[i]: cnt = 0
            cnt += 1
            ans += cnt
        return ans


    """2395. Find Subarrays With Equal Sum (Easy)
    Given a 0-indexed integer array nums, determine whether there exist two
    subarrays of length 2 with equal sum. Note that the two subarrays must
    begin at different indices. Return true if these subarrays exist, and
    false otherwise. A subarray is a contiguous non-empty sequence of elements
    within an array.

    Example 1:
    Input: nums = [4,2,4]
    Output: true
    Explanation: The subarrays with elements [4,2] and [2,4] have the same sum
                 of 6.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: false
    Explanation: No two subarrays of size 2 have the same sum.

    Example 3:
    Input: nums = [0,0,0]
    Output: true
    Explanation: The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the
                 same sum of 0. Note that even though the subarrays have the
                 same content, the two subarrays are considered different
                 because they are in different positions in the original array.

    Constraints:
    * 2 <= nums.length <= 1000
    * -10^9 <= nums[i] <= 10^9"""

    def findSubarrays(self, nums: List[int]) -> bool:
        seen = set()
        for i in range(1, len(nums)):
            sm = nums[i-1] + nums[i]
            if sm in seen: return True
            seen.add(sm)
        return False


    """2396. Strictly Palindromic Number (Medium)
    An integer n is strictly palindromic if, for every base b between 2 and
    n - 2 (inclusive), the string representation of the integer n in base b is
    palindromic. Given an integer n, return true if n is strictly palindromic
    and false otherwise. A string is palindromic if it reads the same forward
    and backward.

    Example 1:
    Input: n = 9
    Output: false
    Explanation: In base 2: 9 = 1001 (base 2), which is palindromic. In base 3:
                 9 = 100 (base 3), which is not palindromic. Therefore, 9 is
                 not strictly palindromic so we return false. Note that in
                 bases 4, 5, 6, and 7, n = 9 is also not palindromic.

    Example 2:
    Input: n = 4
    Output: false
    Explanation: We only consider base 2: 4 = 100 (base 2), which is not
                 palindromic. Therefore, we return false.

    Constraints: 4 <= n <= 10^5"""

    def isStrictlyPalindromic(self, n: int) -> bool:
        return False


    """2397. Maximum Rows Covered by Columns (Medium)
    You are given a 0-indexed m x n binary matrix mat and an integer cols,
    which denotes the number of columns you must choose. A row is covered by a
    set of columns if each cell in the row that has a value of 1 also lies in
    one of the columns of the chosen set. Return the maximum number of rows
    that can be covered by a set of cols columns.

    Example 1:
    Input: mat = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], cols = 2
    Output: 3
    Explanation: As shown in the diagram above, one possible way of covering 3
                 rows is by selecting the 0th and 2nd columns. It can be shown
                 that no more than 3 rows can be covered, so we return 3.

    Example 2:
    Input: mat = [[1],[0]], cols = 1
    Output: 2
    Explanation: Selecting the only column will result in both rows being
                 covered, since the entire matrix is selected. Therefore, we
                 return 2.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 12
    * mat[i][j] is either 0 or 1.
    * 1 <= cols <= n"""

    def maximumRows(self, mat: List[List[int]], cols: int) -> int:
        m, n = len(mat), len(mat[0])
        masks = []
        for i in range(m):
            mask = reduce(xor, (1<<j for j in range(n) if mat[i][j]), 0)
            masks.append(mask)
        ans = 0
        for x in range(1<<n):
            if x.bit_count() == cols:
                ans = max(ans, sum(mask & x == mask for mask in masks))
        return ans


    """2398. Maximum Number of Robots Within Budget (Hard)
    You have n robots. You are given two 0-indexed integer arrays, chargeTimes
    and runningCosts, both of length n. The ith robot costs chargeTimes[i]
    units to charge and costs runningCosts[i] units to run. You are also given
    an integer budget. The total cost of running k chosen robots is equal to
    max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the
    largest charge cost among the k robots and sum(runningCosts) is the sum of
    running costs among the k robots. Return the maximum number of consecutive
    robots you can run such that the total cost does not exceed budget.

    Example 1:
    Input: chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25
    Output: 3
    Explanation: It is possible to run all individual and consecutive pairs of
                 robots within budget. To obtain answer 3, consider the first 3
                 robots. The total cost will be
                 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less
                 than 25. It can be shown that it is not possible to run more
                 than 3 consecutive robots within budget, so we return 3.

    Example 2:
    Input: chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19
    Output: 0
    Explanation: No robot can be run that does not exceed the budget, so we
                 return 0.

    Constraints:
    * chargeTimes.length == runningCosts.length == n
    * 1 <= n <= 5 * 10^4
    * 1 <= chargeTimes[i], runningCosts[i] <= 10^5
    * 1 <= budget <= 10^15"""

    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        ii = rsm = 0
        qq = deque()
        for i, (ct, rc) in enumerate(zip(chargeTimes, runningCosts)):
            rsm += rc
            while qq and qq[-1][0] <= ct: qq.pop()
            qq.append((ct, i))
            if chargeTimes[qq[0][1]] + (i - ii + 1) * rsm > budget:
                if qq[0][1] == ii: qq.popleft()
                rsm -= runningCosts[ii]
                ii += 1
        return len(chargeTimes)-ii


    """2399. Check Distances Between Same Letters (Easy)
    You are given a 0-indexed string s consisting of only lowercase English
    letters, where each letter in s appears exactly twice. You are also given a
    0-indexed integer array distance of length 26. Each letter in the alphabet
    is numbered from 0 to 25 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' ->
    25). In a well-spaced string, the number of letters between the two
    occurrences of the ith letter is distance[i]. If the ith letter does not
    appear in s, then distance[i] can be ignored. Return true if s is a well-
    spaced string, otherwise return false.

    Example 1:
    Input: s = "abaccb", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    Output: true
    Explanation: - 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1.
                 - 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3.
                 - 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0.
                 Note that distance[3] = 5, but since 'd' does not appear in s,
                 it can be ignored. Return true because s is a well-spaced string.

    Example 2:
    Input: s = "aa", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    Output: false
    Explanation: - 'a' appears at indices 0 and 1 so there are zero letters
                   between them.
                 Because distance[0] = 1, s is not a well-spaced string.

    Constraints:
    * 2 <= s.length <= 52
    * s consists only of lowercase English letters.
    * Each letter appears in s exactly twice.
    * distance.length == 26
    * 0 <= distance[i] <= 50"""

    def checkDistances(self, s: str, distance: List[int]) -> bool:
        seen = {}
        for i, ch in enumerate(s):
            if ch in seen:
                if i - seen[ch] - 1 != distance[ord(ch)-97]: return False
            else: seen[ch] = i
        return True


    """2400. Number of Ways to Reach a Position After Exactly k Steps (Medium)
    You are given two positive integers startPos and endPos. Initially, you are
    standing at position startPos on an infinite number line. With one step,
    you can move either one position to the left, or one position to the right.
    Given a positive integer k, return the number of different ways to reach
    the position endPos starting from startPos, such that you perform exactly k
    steps. Since the answer may be very large, return it modulo 10^9 + 7. Two
    ways are considered different if the order of the steps made is not exactly
    the same. Note that the number line includes negative integers.

    Example 1:
    Input: startPos = 1, endPos = 2, k = 3
    Output: 3
    Explanation: We can reach position 2 from 1 in exactly 3 steps in three
                 ways:
                 - 1 -> 2 -> 3 -> 2.
                 - 1 -> 2 -> 1 -> 2.
                 - 1 -> 0 -> 1 -> 2.
                 It can be proven that no other way is possible, so we return 3.

    Example 2:
    Input: startPos = 2, endPos = 5, k = 10
    Output: 0
    Explanation: It is impossible to reach position 5 from position 2 in
                 exactly 10 steps.

    Constraints: 1 <= startPos, endPos, k <= 1000"""

    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:
        diff = abs(endPos - startPos)
        if k < diff or (k-diff) & 1: return 0
        return comb(k, (k-diff)//2) % 1_000_000_007


    """2401. Longest Nice Subarray (Medium)
    You are given an array nums consisting of positive integers. We call a
    subarray of nums nice if the bitwise AND of every pair of elements that are
    in different positions in the subarray is equal to 0. Return the length of
    the longest nice subarray. A subarray is a contiguous part of an array.
    Note that subarrays of length 1 are always considered nice.

    Example 1:
    Input: nums = [1,3,8,48,10]
    Output: 3
    Explanation: The longest nice subarray is [3,8,48]. This subarray satisfies
                 the conditions:
                 - 3 AND 8 = 0.
                 - 3 AND 48 = 0.
                 - 8 AND 48 = 0.
                 It can be proven that no longer nice subarray can be obtained,
                 so we return 3.

    Example 2:
    Input: nums = [3,1,5,11,13]
    Output: 1
    Explanation: The length of the longest nice subarray is 1. Any subarray of
                 length 1 can be chosen.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def longestNiceSubarray(self, nums: List[int]) -> int:
        ans = ii = mask = 0
        for i, x in enumerate(nums):
            while mask & x:
                mask ^= nums[ii]
                ii += 1
            mask ^= x
            ans = max(ans, i - ii + 1)
        return ans


    """2402. Meeting Rooms III (Hard)
    You are given an integer n. There are n rooms numbered from 0 to n - 1. You
    are given a 2D integer array meetings where meetings[i] = [starti, endi]
    means that a meeting will be held during the half-closed time interval
    [starti, endi). All the values of starti are unique. Meetings are allocated
    to rooms in the following manner:
    * Each meeting will take place in the unused room with the lowest number.
    * If there are no available rooms, the meeting will be delayed until a room
      becomes free. The delayed meeting should have the same duration as the
      original meeting.
    * When a room becomes unused, meetings that have an earlier original start
      time should be given the room.
    Return the number of the room that held the most meetings. If there are
    multiple rooms, return the room with the lowest number. A half-closed
    interval [a, b) is the interval between a and b including a and not
    including b.

    Example 1:
    Input: n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]
    Output: 0
    Explanation: - At time 0, both rooms are not being used. The first meeting
                   starts in room 0.
                 - At time 1, only room 1 is not being used. The second meeting
                   starts in room 1.
                 - At time 2, both rooms are being used. The third meeting is
                   delayed.
                 - At time 3, both rooms are being used. The fourth meeting is
                   delayed.
                 - At time 5, the meeting in room 1 finishes. The third meeting
                   starts in room 1 for the time period [5,10).
                 - At time 10, the meetings in both rooms finish. The fourth
                   meeting starts in room 0 for the time period [10,11).
                 Both rooms 0 and 1 held 2 meetings, so we return 0.

    Example 2:
    Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]
    Output: 1
    Explanation: - At time 1, all three rooms are not being used. The first
                   meeting starts in room 0.
                 - At time 2, rooms 1 and 2 are not being used. The second
                   meeting starts in room 1.
                 - At time 3, only room 2 is not being used. The third meeting
                   starts in room 2.
                 - At time 4, all three rooms are being used. The fourth
                   meeting is delayed.
                 - At time 5, the meeting in room 2 finishes. The fourth
                   meeting starts in room 2 for the time period [5,10).
                 - At time 6, all three rooms are being used. The fifth meeting
                   is delayed.
                 - At time 10, the meetings in rooms 1 and 2 finish. The fifth
                   meeting starts in room 1 for the time period [10,12).
                 Room 0 held 1 meeting while rooms 1 and 2 each held 2 meetings,
                 so we return 1.

    Constraints:
    * 1 <= n <= 100
    * 1 <= meetings.length <= 10^5
    * meetings[i].length == 2
    * 0 <= starti < endi <= 5 * 10^5
    * All the values of starti are unique."""

    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        freq = [0]*n
        free = list(range(n))
        busy = []
        for x, y in sorted(meetings):
            while busy and busy[0][0] <= x: heappush(free, heappop(busy)[1])
            if free:
                room = heappop(free)
                heappush(busy, (y, room))
            else:
                t, room = heappop(busy)
                heappush(busy, (t+y-x, room))
            freq[room] += 1
        return freq.index(max(freq))


    """2403. Minimum Time to Kill All Monsters (Hard)
    You are given an integer array power where power[i] is the power of the ith
    monster. You start with 0 mana points, and each day you increase your mana
    points by gain where gain initially is equal to 1. Each day, after gaining
    gain mana, you can defeat a monster if your mana points are greater than or
    equal to the power of that monster. When you defeat a monster:
    * your mana points will be reset to 0, and
    * the value of gain increases by 1.
    Return the minimum number of days needed to defeat all the monsters.

    Example 1:
    Input: power = [3,1,4]
    Output: 4
    Explanation: The optimal way to beat all the monsters is to:
                 - Day 1: Gain 1 mana point to get a total of 1 mana point.
                   Spend all mana points to kill the 2nd monster.
                 - Day 2: Gain 2 mana points to get a total of 2 mana points.
                 - Day 3: Gain 2 mana points to get a total of 4 mana points.
                   Spend all mana points to kill the 3rd monster.
                 - Day 4: Gain 3 mana points to get a total of 3 mana points.
                   Spend all mana points to kill the 1st monster.
                 It can be proven that 4 is the minimum number of days needed.

    Example 2:
    Input: power = [1,1,4]
    Output: 4
    Explanation: The optimal way to beat all the monsters is to:
                 - Day 1: Gain 1 mana point to get a total of 1 mana point.
                   Spend all mana points to kill the 1st monster.
                 - Day 2: Gain 2 mana points to get a total of 2 mana points.
                   Spend all mana points to kill the 2nd monster.
                 - Day 3: Gain 3 mana points to get a total of 3 mana points.
                 - Day 4: Gain 3 mana points to get a total of 6 mana points.
                   Spend all mana points to kill the 3rd monster.
                 It can be proven that 4 is the minimum number of days needed.

    Example 3:
    Input: power = [1,2,4,9]
    Output: 6
    Explanation: The optimal way to beat all the monsters is to:
                 - Day 1: Gain 1 mana point to get a total of 1 mana point.
                   Spend all mana points to kill the 1st monster.
                 - Day 2: Gain 2 mana points to get a total of 2 mana points.
                   Spend all mana points to kill the 2nd monster.
                 - Day 3: Gain 3 mana points to get a total of 3 mana points.
                 - Day 4: Gain 3 mana points to get a total of 6 mana points.
                 - Day 5: Gain 3 mana points to get a total of 9 mana points.
                   Spend all mana points to kill the 4th monster.
                 - Day 6: Gain 4 mana points to get a total of 4 mana points.
                   Spend all mana points to kill the 3rd monster.
                 It can be proven that 6 is the minimum number of days needed.

    Constraints:
    * 1 <= power.length <= 17
    * 1 <= power[i] <= 10^9"""

    def minimumTime(self, power: List[int]) -> int:
        n = len(power)
        dp = [inf] * (1<<n)
        dp[0] = 0
        for m in range(1, 1<<n):
            gain = 1 + bin((1<<n)-1 ^ m).count('1')
            for i in range(n):
                if m & 1<<i: dp[m] = min(dp[m], (power[i]+gain-1)//gain + dp[m^1<<i])
        return dp[-1]


    """2404. Most Frequent Even Element (Easy)
    Given an integer array nums, return the most frequent even element. If
    there is a tie, return the smallest one. If there is no such element,
    return -1.

    Example 1:
    Input: nums = [0,1,2,2,4,4,1]
    Output: 2
    Explanation: The even elements are 0, 2, and 4. Of these, 2 and 4 appear
                 the most. We return the smallest one, which is 2.

    Example 2:
    Input: nums = [4,4,4,9,2,4]
    Output: 4
    Explanation: 4 is the even element appears the most.

    Example 3:
    Input: nums = [29,47,21,41,13,37,25,7]
    Output: -1
    Explanation: There is no even element.

    Constraints:
    * 1 <= nums.length <= 2000
    * 0 <= nums[i] <= 10^5"""

    def mostFrequentEven(self, nums: List[int]) -> int:
        freq = Counter(x for x in nums if x&1 == 0)
        return min(freq, key=lambda x: (-freq[x], x), default=-1)


    """2405. Optimal Partition of String (Medium)
    Given a string s, partition the string into one or more substrings such
    that the characters in each substring are unique. That is, no letter
    appears in a single substring more than once. Return the minimum number of
    substrings in such a partition. Note that each character should belong to
    exactly one substring in a partition.

    Example 1:
    Input: s = "abacaba"
    Output: 4
    Explanation: Two possible partitions are ("a","ba","cab","a") and
                 ("ab","a","ca","ba"). It can be shown that 4 is the minimum
                 number of substrings needed.

    Example 2:
    Input: s = "ssssss"
    Output: 6
    Explanation: The only valid partition is ("s","s","s","s","s","s").

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of only English lowercase letters."""

    def partitionString(self, s: str) -> int:
        ans = mask = 0
        for i, ch in enumerate(s):
            if mask & 1 << ord(ch)-97:
                ans += 1
                mask = 0
            mask ^= 1 << ord(ch)-97
        return ans+1


    """2406. Divide Intervals Into Minimum Number of Groups (Medium)
    You are given a 2D integer array intervals where intervals[i] = [lefti, righti]
    represents the inclusive interval [lefti, righti]. You have to divide the
    intervals into one or more groups such that each interval is in exactly one
    group, and no two intervals that are in the same group intersect each other.
    Return the minimum number of groups you need to make. Two intervals
    intersect if there is at least one common number between them. For example,
    the intervals [1, 5] and [5, 8] intersect.

    Example 1:
    Input: intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]
    Output: 3
    Explanation: We can divide the intervals into the following groups:
                 - Group 1: [1, 5], [6, 8].
                 - Group 2: [2, 3], [5, 10].
                 - Group 3: [1, 10].
                 It can be proven that it is not possible to divide the
                 intervals into fewer than 3 groups.

    Example 2:
    Input: intervals = [[1,3],[5,6],[8,10],[11,13]]
    Output: 1
    Explanation: None of the intervals overlap, so we can put all of them in
                 one group.

    Constraints:
    * 1 <= intervals.length <= 10^5
    * intervals[i].length == 2
    * 1 <= lefti <= righti <= 10^6"""

    def minGroups(self, intervals: List[List[int]]) -> int:
        line = []
        for x, y in intervals:
            line.append((x, 1))
            line.append((y+1, 0))
        ans = prefix = 0
        for x, k in sorted(line):
            if k: prefix += 1
            else: prefix -= 1
            ans = max(ans, prefix)
        return ans


    """2407. Longest Increasing Subsequence II (Hard)
    You are given an integer array nums and an integer k. Find the longest
    subsequence of nums that meets the following requirements:
    * The subsequence is strictly increasing and
    * The difference between adjacent elements in the subsequence is at most k.
    Return the length of the longest subsequence that meets the requirements. A
    subsequence is an array that can be derived from another array by deleting
    some or no elements without changing the order of the remaining elements.

    Example 1:
    Input: nums = [4,2,1,4,3,4,5,8,15], k = 3
    Output: 5
    Explanation: The longest subsequence that meets the requirements is
                 [1,3,4,5,8]. The subsequence has a length of 5, so we return 5.
                 Note that the subsequence [1,3,4,5,8,15] does not meet the
                 requirements because 15 - 8 = 7 is larger than 3.

    Example 2:
    Input: nums = [7,4,5,1,8,12,4,7], k = 5
    Output: 4
    Explanation: The longest subsequence that meets the requirements is
                 [4,5,8,12]. The subsequence has a length of 4, so we return 4.

    Example 3:
    Input: nums = [1,5], k = 1
    Output: 1
    Explanation: The longest subsequence that meets the requirements is [1].
                 The subsequence has a length of 1, so we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= 10^5

class SegTree:

    def __init__(self, arr: List[int]):
        self.n = len(arr)
        self.tree = [0] * (2*self.n)
        # for i in range(2*self.n-1, 0, -1):
        #     if i >= self.n: self.tree[i] = arr[i - self.n]
        #     else: self.tree[i] = max(self.tree[i<<1], self.tree[i<<1|1])

    def query(self, lo: int, hi: int) -> int:
        ans = 0
        lo += self.n
        hi += self.n
        while lo < hi:
            if lo & 1:
                ans = max(ans, self.tree[lo])
                lo += 1
            if hi & 1:
                hi -= 1
                ans = max(ans, self.tree[hi])
            lo >>= 1
            hi >>= 1
        return ans

    def update(self, i: int, val: int) -> None:
        i += self.n
        self.tree[i] = val
        while i > 1:
            self.tree[i>>1] = max(self.tree[i], self.tree[i^1])
            i >>= 1"""

    def lengthOfLIS(self, nums: List[int], k: int) -> int:
        m = max(nums)
        ans = 0
        tree = SegTree([0] * (m+1))
        for x in nums:
            val = tree.query(max(0, x-k), x) + 1
            ans = max(ans, val)
            tree.update(x, val)
        return ans


    """2409. Count Days Spent Together (Easy)
    Alice and Bob are traveling to Rome for separate business meetings. You are
    given 4 strings arriveAlice, leaveAlice, arriveBob, and leaveBob. Alice
    will be in the city from the dates arriveAlice to leaveAlice (inclusive),
    while Bob will be in the city from the dates arriveBob to leaveBob
    (inclusive). Each will be a 5-character string in the format "MM-DD",
    corresponding to the month and day of the date. Return the total number of
    days that Alice and Bob are in Rome together. You can assume that all dates
    occur in the same calendar year, which is not a leap year. Note that the
    number of days per month can be represented as:
    [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].

    Example 1:
    Input: arriveAlice = "08-15", leaveAlice = "08-18",
           arriveBob = "08-16", leaveBob = "08-19"
    Output: 3
    Explanation: Alice will be in Rome from August 15 to August 18. Bob will be
                 in Rome from August 16 to August 19. They are both in Rome
                 together on August 16th, 17th, and 18th, so the answer is 3.

    Example 2:
    Input: arriveAlice = "10-01", leaveAlice = "10-31",
           arriveBob = "11-01", leaveBob = "12-31"
    Output: 0
    Explanation: There is no day when Alice and Bob are in Rome together, so we return 0.

    Constraints:
    * All dates are provided in the format "MM-DD".
    * Alice and Bob's arrival dates are earlier than or equal to their leaving
      dates.
    * The given dates are valid dates of a non-leap year."""

    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:
        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

        def fn(date):
            m, d = map(int, date.split('-'))
            return sum(days[:m-1]) + d

        arrive = max(fn(arriveAlice), fn(arriveBob))
        leave = min(fn(leaveAlice), fn(leaveBob))
        return max(0, leave-arrive+1)


    """2410. Maximum Matching of Players With Trainers (Medium)
    You are given a 0-indexed integer array players, where players[i]
    represents the ability of the ith player. You are also given a 0-indexed
    integer array trainers, where trainers[j] represents the training capacity
    of the jth trainer. The ith player can match with the jth trainer if the
    player's ability is less than or equal to the trainer's training capacity.
    Additionally, the ith player can be matched with at most one trainer, and
    the jth trainer can be matched with at most one player. Return the maximum
    number of matchings between players and trainers that satisfy these
    conditions.

    Example 1:
    Input: players = [4,7,9], trainers = [8,2,5,8]
    Output: 2
    Explanation: One of the ways we can form two matchings is as follows:
                 - players[0] can be matched with trainers[0] since 4 <= 8.
                 - players[1] can be matched with trainers[3] since 7 <= 8.
                 It can be proven that 2 is the maximum number of matchings
                 that can be formed.

    Example 2:
    Input: players = [1,1,1], trainers = [10]
    Output: 1
    Explanation: The trainer can be matched with any of the 3 players. Each
                 player can only be matched with one trainer, so the maximum
                 answer is 1.

    Constraints:
    * 1 <= players.length, trainers.length <= 10^5
    * 1 <= players[i], trainers[j] <= 10^9"""

    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        trainers.sort()
        ans = j = 0
        for i, p in enumerate(sorted(players)):
            while j < len(trainers) and p > trainers[j]: j += 1
            if j < len(trainers): ans += 1
            j += 1
        return ans


    """2411. Smallest Subarrays With Maximum Bitwise OR (Medium)
    You are given a 0-indexed array nums of length n, consisting of non-
    negative integers. For each index i from 0 to n - 1, you must determine the
    size of the minimum sized non-empty subarray of nums starting at i
    (inclusive) that has the maximum possible bitwise OR. In other words, let
    Bij be the bitwise OR of the subarray nums[i...j]. You need to find the
    smallest subarray starting at i, such that bitwise OR of this subarray is
    equal to max(Bik) where i <= k <= n - 1. The bitwise OR of an array is the
    bitwise OR of all the numbers in it. Return an integer array answer of size
    n where answer[i] is the length of the minimum sized subarray starting at i
    with maximum bitwise OR. A subarray is a contiguous non-empty sequence of
    elements within an array.

    Example 1:
    Input: nums = [1,0,2,1,3]
    Output: [3,3,2,2,1]
    Explanation: The maximum possible bitwise OR starting at any index is 3.
                 - Starting at index 0, the shortest subarray that yields it is
                   [1,0,2].
                 - Starting at index 1, the shortest subarray that yields the
                   maximum bitwise OR is [0,2,1].
                 - Starting at index 2, the shortest subarray that yields the
                   maximum bitwise OR is [2,1].
                 - Starting at index 3, the shortest subarray that yields the
                   maximum bitwise OR is [1,3].
                 - Starting at index 4, the shortest subarray that yields the
                   maximum bitwise OR is [3].
                 Therefore, we return [3,3,2,2,1].

    Example 2:
    Input: nums = [1,2]
    Output: [2,1]
    Explanation: Starting at index 0, the shortest subarray that yields the
                 maximum bitwise OR is of length 2. Starting at index 1, the
                 shortest subarray that yields the maximum bitwise OR is of
                 length 1. Therefore, we return [2,1].

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 0 <= nums[i] <= 10^9"""

    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        ans = [0]*len(nums)
        seen = [0]*30
        for i in range(len(nums)-1, -1, -1):
            for j in range(30):
                if nums[i] & 1<<j: seen[j] = i
            ans[i] = max(1, max(seen)-i+1)
        return ans


    """2412. Minimum Money Required Before Transactions (Hard)
    You are given a 0-indexed 2D integer array transactions, where
    transactions[i] = [costi, cashbacki]. The array describes transactions,
    where each transaction must be completed exactly once in some order. At any
    given moment, you have a certain amount of money. In order to complete
    transaction i, money >= costi must hold true. After performing a
    transaction, money becomes money - costi + cashbacki. Return the minimum
    amount of money required before any transaction so that all of the
    transactions can be completed regardless of the order of the transactions.

    Example 1:
    Input: transactions = [[2,1],[5,0],[4,2]]
    Output: 10
    Explanation: Starting with money = 10, the transactions can be performed in
                 any order. It can be shown that starting with money < 10 will
                 fail to complete all transactions in some order.

    Example 2:
    Input: transactions = [[3,0],[0,3]]
    Output: 3
    Explanation: - If transactions are in the order [[3,0],[0,3]], the minimum
                   money required to complete the transactions is 3.
                 - If transactions are in the order [[0,3],[3,0]], the minimum
                   money required to complete the transactions is 0.
                 Thus, starting with money = 3, the transactions can be
                 performed in any order.

    Constraints:
    * 1 <= transactions.length <= 10^5
    * transactions[i].length == 2
    * 0 <= costi, cashbacki <= 10^9"""

    def minimumMoney(self, transactions: List[List[int]]) -> int:
        ans = val = 0
        for cost, cashback in transactions:
            ans += max(0, cost - cashback)
            val = max(val, min(cost, cashback))
        return ans + val


    """2413. Smallest Even Multiple (Easy)
    Given a positive integer n, return the smallest positive integer that is a
    multiple of both 2 and n.

    Example 1:
    Input: n = 5
    Output: 10
    Explanation: The smallest multiple of both 5 and 2 is 10.

    Example 2:
    Input: n = 6
    Output: 6
    Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number
                 is a multiple of itself.

    Constraints: 1 <= n <= 150"""

    def smallestEvenMultiple(self, n: int) -> int:
        return ((n&1)+1)*n


    """2414. Length of the Longest Alphabetical Continuous Substring (Medium)
    An alphabetical continuous string is a string consisting of consecutive
    letters in the alphabet. In other words, it is any substring of the string
    "abcdefghijklmnopqrstuvwxyz".
    * For example, "abc" is an alphabetical continuous string, while "acb" and
      "za" are not.
    Given a string s consisting of lowercase letters only, return the length of
    the longest alphabetical continuous substring.

    Example 1:
    Input: s = "abacaba"
    Output: 2
    Explanation: There are 4 distinct continuous substrings: "a", "b", "c" and
                 "ab". "ab" is the longest continuous substring.

    Example 2:
    Input: s = "abcde"
    Output: 5
    Explanation: "abcde" is the longest continuous substring.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of only English lowercase letters."""

    def longestContinuousSubstring(self, s: str) -> int:
        ans = cnt = 0
        for i, ch in enumerate(s):
            if i and ord(s[i-1])+1 != ord(ch): cnt = 0
            cnt += 1
            ans = max(ans, cnt)
        return ans


    """2415. Reverse Odd Levels of Binary Tree (Medium)
    Given the root of a perfect binary tree, reverse the node values at each
    odd level of the tree. For example, suppose the node values at level 3 are
    [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2]. Return
    the root of the reversed tree. A binary tree is perfect if all parent nodes
    have two children and all leaves are on the same level. The level of a node
    is the number of edges along the path between it and the root node.

    Example 1:
    Input: root = [2,3,5,8,13,21,34]
    Output: [2,5,3,8,13,21,34]
    Explanation: The tree has only one odd level. The nodes at level 1 are 3, 5
                 respectively, which are reversed and become 5, 3.

    Example 2:
    Input: root = [7,13,11]
    Output: [7,11,13]
    Explanation: The nodes at level 1 are 13, 11, which are reversed and become
                 11, 13.

    Example 3:
    Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]
    Output: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]
    Explanation: The odd levels have non-zero values. The nodes at level 1 were
                 1, 2, and are 2, 1 after the reversal. The nodes at level 3
                 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1
                 after the reversal.

    Constraints:
    * The number of nodes in the tree is in the range [1, 2^14].
    * 0 <= Node.val <= 10^5
    * root is a perfect binary tree."""

    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        level = 0
        queue = deque([root])
        while queue:
            if level&1:
                for i in range(len(queue)//2):
                    queue[i].val, queue[~i].val = queue[~i].val, queue[i].val
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            level ^= 1
        return root


    """2416. Sum of Prefix Scores of Strings (Hard)
    You are given an array words of size n consisting of non-empty strings. We
    define the score of a string word as the number of strings words[i] such
    that word is a prefix of words[i]. For example, if
    words = ["a", "ab", "abc", "cab"], then the score of "ab" is 2, since "ab"
    is a prefix of both "ab" and "abc". Return an array answer of size n where
    answer[i] is the sum of scores of every non-empty prefix of words[i]. Note
    that a string is considered as a prefix of itself.

    Example 1:
    Input: words = ["abc","ab","bc","b"]
    Output: [5,4,3,2]
    Explanation: The answer for each string is the following:
                 - "abc" has 3 prefixes: "a", "ab", and "abc".
                 - There are 2 strings with the prefix "a", 2 strings with the
                   prefix "ab", and 1 string with the prefix "abc".
                 The total is answer[0] = 2 + 2 + 1 = 5.
                 - "ab" has 2 prefixes: "a" and "ab".
                 - There are 2 strings with the prefix "a", and 2 strings with
                   the prefix "ab".
                 The total is answer[1] = 2 + 2 = 4.
                 - "bc" has 2 prefixes: "b" and "bc".
                 - There are 2 strings with the prefix "b", and 1 string with
                   the prefix "bc".
                 The total is answer[2] = 2 + 1 = 3.
                 - "b" has 1 prefix: "b".
                 - There are 2 strings with the prefix "b".
                 The total is answer[3] = 2.

    Example 2:
    Input: words = ["abcd"]
    Output: [4]
    Explanation: "abcd" has 4 prefixes: "a", "ab", "abc", and "abcd". Each
                 prefix has a score of one, so the total is
                 answer[0] = 1 + 1 + 1 + 1 = 4.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 1000
    * words[i] consists of lowercase English letters."""

    def sumPrefixScores(self, words: List[str]) -> List[int]:
        root = {}
        for word in words:
            node = root
            for ch in word:
                node = node.setdefault(ch, {})
                node['#'] = node.get('#', 0) + 1
        ans = []
        for word in words:
            val = 0
            node = root
            for ch in word:
                node = node[ch]
                val += node['#']
            ans.append(val)
        return ans


    """2417. Closest Fair Integer (Medium)
    You are given a positive integer n. We call an integer k fair if the number
    of even digits in k is equal to the number of odd digits in it. Return the
    smallest fair integer that is greater than or equal to n.

    Example 1:
    Input: n = 2
    Output: 10
    Explanation: The smallest fair integer that is greater than or equal to 2
                 is 10. 10 is fair because it has an equal number of even and
                 odd digits (one odd digit and one even digit).

    Example 2:
    Input: n = 403
    Output: 1001
    Explanation: The smallest fair integer that is greater than or equal to 403
                 is 1001. 1001 is fair because it has an equal number of even
                 and odd digits (two odd digits and two even digits).

    Constraints: 1 <= n <= 10^9"""

    def closestFair(self, n: int) -> int:
        s = str(n)
        if len(s) & 1:
            zeros = ones = (len(s)+1)//2
            return int("1" + "0"*zeros + "1"*(ones-1))
        freq = [0]*2
        for ch in s: freq[int(ch) & 1] += 1
        return n if freq[0] == freq[1] else self.closestFair(n+1)


    """2418. Sort the People (Easy)
    You are given an array of strings names, and an array heights that consists
    of distinct positive integers. Both arrays are of length n. For each index
    i, names[i] and heights[i] denote the name and height of the ith person.
    Return names sorted in descending order by the people's heights.

    Example 1:
    Input: names = ["Mary","John","Emma"], heights = [180,165,170]
    Output: ["Mary","Emma","John"]
    Explanation: Mary is the tallest, followed by Emma and John.

    Example 2:
    Input: names = ["Alice","Bob","Bob"], heights = [155,185,150]
    Output: ["Bob","Alice","Bob"]
    Explanation: The first Bob is the tallest, followed by Alice and the second
                 Bob.

    Constraints:
    * n == names.length == heights.length
    * 1 <= n <= 10^3
    * 1 <= names[i].length <= 20
    * 1 <= heights[i] <= 10^5
    * names[i] consists of lower and upper case English letters.
    * All the values of heights are distinct."""

    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        return list(zip(*sorted(zip(heights, names), reverse=True)))[1]


    """2419. Longest Subarray With Maximum Bitwise AND (Medium)
    You are given an integer array nums of size n. Consider a non-empty
    subarray from nums that has the maximum possible bitwise AND. In other
    words, let k be the maximum value of the bitwise AND of any subarray of
    nums. Then, only subarrays with a bitwise AND equal to k should be
    considered. Return the length of the longest such subarray. The bitwise AND
    of an array is the bitwise AND of all the numbers in it. A subarray is a
    contiguous sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,3,3,2,2]
    Output: 2
    Explanation: The maximum possible bitwise AND of a subarray is 3. The
                 longest subarray with that value is [3,3], so we return 2.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 1
    Explanation: The maximum possible bitwise AND of a subarray is 4. The
                 longest subarray with that value is [4], so we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def longestSubarray(self, nums: List[int]) -> int:
        most = max(nums)
        return max(len(list(grp)) for k, grp in groupby(nums) if k == most)


    """2420. Find All Good Indices (Medium)
    You are given a 0-indexed integer array nums of size n and a positive
    integer k. We call an index i in the range k <= i < n - k good if the
    following conditions are satisfied:
    * The k elements that are just before the index i are in non-increasing
      order.
    * The k elements that are just after the index i are in non-decreasing
      order.
    Return an array of all good indices sorted in increasing order.

    Example 1:
    Input: nums = [2,1,1,1,3,4,1], k = 2
    Output: [2,3]
    Explanation: There are two good indices in the array:
                 - Index 2. The subarray [2,1] is in non-increasing order, and
                   the subarray [1,3] is in non-decreasing order.
                 - Index 3. The subarray [1,1] is in non-increasing order, and
                   the subarray [3,4] is in non-decreasing order.
                 Note that the index 4 is not good because [4,1] is not non-
                 decreasing.

    Example 2:
    Input: nums = [2,1,1,2], k = 2
    Output: []
    Explanation: There are no good indices in this array.

    Constraints:
    * n == nums.length
    * 3 <= n <= 10^5
    * 1 <= nums[i] <= 10^6
    * 1 <= k <= n / 2"""

    def goodIndices(self, nums: List[int], k: int) -> List[int]:
        prefix = [1]*len(nums)
        for i in range(1, len(nums)):
            if nums[i-1] >= nums[i]: prefix[i] = prefix[i-1]+1
        ans = []
        suffix = 0
        for i in reversed(range(k, len(nums))):
            if prefix[i-1] >= k and suffix >= k: ans.append(i)
            if i+1 < len(nums) and nums[i] > nums[i+1]: suffix = 0
            suffix += 1
        return ans[::-1]


    """2421. Number of Good Paths (Hard)
    There is a tree (i.e. a connected, undirected graph with no cycles)
    consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. You
    are given a 0-indexed integer array vals of length n where vals[i] denotes
    the value of the ith node. You are also given a 2D integer array edges
    where edges[i] = [ai, bi] denotes that there exists an undirected edge
    connecting nodes ai and bi. A good path is a simple path that satisfies the
    following conditions:
    * The starting node and the ending node have the same value.
    * All nodes between the starting node and the ending node have values less
      than or equal to the starting node (i.e. the starting node's value should
      be the maximum value along the path).
    Return the number of distinct good paths. Note that a path and its reverse
    are counted as the same path. For example, 0 -> 1 is considered to be the
    same as 1 -> 0. A single node is also considered as a valid path.

    Example 1:
    Input: vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
    Output: 6
    Explanation: There are 5 good paths consisting of a single node. There is 1
                 additional good path: 1 -> 0 -> 2 -> 4. (The reverse path
                 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)
                 Note that 0 -> 2 -> 3 is not a good path because
                 vals[2] > vals[0].

    Example 2:
    Input: vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
    Output: 7
    Explanation: There are 5 good paths consisting of a single node. There are
                 2 additional good paths: 0 -> 1 and 2 -> 3.

    Example 3:
    Input: vals = [1], edges = []
    Output: 1
    Explanation: The tree consists of only one node, so there is one good path.

    Constraints:
    * n == vals.length
    * 1 <= n <= 3 * 10^4
    * 0 <= vals[i] <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * edges represents a valid tree."""

    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
        n = len(vals)
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        parent = list(range(n))
        def find(p):
            if parent[p] != p: parent[p] = find(parent[p])
            return parent[p]

        mp = defaultdict(list)
        for i, x in enumerate(vals): mp[x].append(i)

        ans = 0
        seen = set()
        for k in sorted(mp):
            freq = Counter()
            for u in mp[k]:
                seen.add(u)
                for v in graph[u]:
                    if v in seen: parent[find(u)] = find(v)
            ans += sum(v*(v-1)//2 for v in Counter(find(u) for u in mp[k]).values())
        return ans+n


    """2422. Merge Operations to Turn Array Into a Palindrome (Medium)
    You are given an array nums consisting of positive integers. You can
    perform the following operation on the array any number of times:
    * Choose any two adjacent elements and replace them with their sum.
      + For example, if nums = [1,2,3,1], you can apply one operation to make
        it [1,5,1].
    Return the minimum number of operations needed to turn the array into a
    palindrome.

    Example 1:
    Input: nums = [4,3,2,1,2,3,1]
    Output: 2
    Explanation: We can turn the array into a palindrome in 2 operations as
                 follows:
                 - Apply the operation on the fourth and fifth element of the
                   array, nums becomes equal to [4,3,2,3,3,1].
                 - Apply the operation on the fifth and sixth element of the
                   array, nums becomes equal to [4,3,2,3,4].
                 The array [4,3,2,3,4] is a palindrome. It can be shown that 2
                 is the minimum number of operations needed.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 3
    Explanation: We do the operation 3 times in any position, we obtain the
                 array [10] at the end which is a palindrome.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def minimumOperations(self, nums: List[int]) -> int:
        ans = diff = 0
        lo, hi = -1, len(nums)
        while lo < hi:
            if diff > 0:
                hi -= 1
                diff -= nums[hi]
                ans += 1
            elif diff < 0:
                lo += 1
                diff += nums[lo]
                ans += 1
            else:
                lo += 1
                hi -= 1
                diff = nums[lo] - nums[hi]
        return ans


    """2423. Remove Letter To Equalize Frequency (Easy)
    You are given a 0-indexed string word, consisting of lowercase English
    letters. You need to select one index and remove the letter at that index
    from word so that the frequency of every letter present in word is equal.
    Return true if it is possible to remove one letter so that the frequency of
    all letters in word are equal, and false otherwise.

    Note:
    * The frequency of a letter x is the number of times it occurs in the
      string.
    * You must remove exactly one letter and cannot chose to do nothing.

    Example 1:
    Input: word = "abcc"
    Output: true
    Explanation: Select index 3 and delete it: word becomes "abc" and each
                 character has a frequency of 1.

    Example 2:
    Input: word = "aazz"
    Output: false
    Explanation: We must delete a character, so either the frequency of "a" is
                 1 and the frequency of "z" is 2, or vice versa. It is
                 impossible to make all present letters have equal frequency.

    Constraints:
    * 2 <= word.length <= 100
    * word consists of lowercase English letters only."""

    def equalFrequency(self, word: str) -> bool:
        freq = sorted(Counter(word).values())
        return len(freq) == 1 or freq[0] == 1 and freq[1] == freq[-1] or freq[0] == freq[-2] and freq[-2]+1 == freq[-1]


    """2425. Bitwise XOR of All Pairings (Medium)
    You are given two 0-indexed arrays, nums1 and nums2, consisting of non-
    negative integers. There exists another array, nums3, which contains the
    bitwise XOR of all pairings of integers between nums1 and nums2 (every
    integer in nums1 is paired with every integer in nums2 exactly once).
    Return the bitwise XOR of all integers in nums3.

    Example 1:
    Input: nums1 = [2,1,3], nums2 = [10,2,5,0]
    Output: 13
    Explanation: A possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3]. The
                 bitwise XOR of all these numbers is 13, so we return 13.

    Example 2:
    Input: nums1 = [1,2], nums2 = [3,4]
    Output: 0
    Explanation: All possible pairs of bitwise XORs are nums1[0] ^ nums2[0],
                 nums1[0] ^ nums2[1], nums1[1] ^ nums2[0], and
                 nums1[1] ^ nums2[1]. Thus, one possible nums3 array is
                 [2,5,1,6]. 2 ^ 5 ^ 1 ^ 6 = 0, so we return 0.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 10^5
    * 0 <= nums1[i], nums2[j] <= 10^9"""

    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        return (len(nums1)%2 * reduce(xor, nums2)) ^ (len(nums2)%2 * reduce(xor, nums1))


    """2426. Number of Pairs Satisfying Inequality (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2, each of size n,
    and an integer diff. Find the number of pairs (i, j) such that:
    * 0 <= i < j <= n - 1 and
    * nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff.
    Return the number of pairs that satisfy the conditions.

    Example 1:
    Input: nums1 = [3,2,5], nums2 = [2,2,1], diff = 1
    Output: 3
    Explanation: There are 3 pairs that satisfy the conditions:
                 1. i = 0, j = 1: 3 - 2 <= 2 - 2 + 1. Since i < j and 1 <= 1,
                    this pair satisfies the conditions.
                 2. i = 0, j = 2: 3 - 5 <= 2 - 1 + 1. Since i < j and -2 <= 2,
                    this pair satisfies the conditions.
                 3. i = 1, j = 2: 2 - 5 <= 2 - 1 + 1. Since i < j and -3 <= 2,
                    this pair satisfies the conditions.
                 Therefore, we return 3.

    Example 2:
    Input: nums1 = [3,-1], nums2 = [-2,2], diff = -1
    Output: 0
    Explanation: Since there does not exist any pair that satisfies the
                 conditions, we return 0.

    Constraints:
    * n == nums1.length == nums2.length
    * 2 <= n <= 10^5
    * -10^4 <= nums1[i], nums2[i] <= 10^4
    * -10^4 <= diff <= 10^4"""

    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        ans = 0
        vals = SortedList()
        for x, y in zip(nums1, nums2):
            ans += vals.bisect_right(x-y)
            vals.add(x-y-diff)
        return ans


    """2427. Number of Common Factors (Easy)
    Given two positive integers a and b, return the number of common factors of
    a and b. An integer x is a common factor of a and b if x divides both a and
    b.

    Example 1:
    Input: a = 12, b = 6
    Output: 4
    Explanation: The common factors of 12 and 6 are 1, 2, 3, 6.

    Example 2:
    Input: a = 25, b = 30
    Output: 2
    Explanation: The common factors of 25 and 30 are 1, 5.

    Constraints: 1 <= a, b <= 1000"""

    def commonFactors(self, a: int, b: int) -> int:
        return sum(a % x == b % x == 0 for x in range(1, 1001))


    """2428. Maximum Sum of an Hourglass (Medium)
    You are given an m x n integer matrix grid. We define an hourglass as a
    part of the matrix with the following form:
    A B C
      D
    E F G
    Return the maximum sum of the elements of an hourglass. Note that an
    hourglass cannot be rotated and must be entirely contained within the
    matrix.

    Example 1:
    Input: grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]
    Output: 30
    Explanation: The cells shown above represent the hourglass with the maximum
                 sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.

    Example 2:
    Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 35
    Explanation: There is only one hourglass in the matrix, with the sum:
                 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 3 <= m, n <= 150
    * 0 <= grid[i][j] <= 10^6"""

    def maxSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        for i in range(m-2):
            for j in range(n-2):
                val = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]
                ans = max(ans, val)
        return ans


    """2429. Minimize XOR (Medium)
    Given two positive integers num1 and num2, find the integer x such that:
    * x has the same number of set bits as num2, and
    * The value x XOR num1 is minimal.
    Note that XOR is the bitwise XOR operation. Return the integer x. The test
    cases are generated such that x is uniquely determined. The number of set
    bits of an integer is the number of 1's in its binary representation.

    Example 1:
    Input: num1 = 3, num2 = 5
    Output: 3
    Explanation: The binary representations of num1 and num2 are 0011 and 0101,
                 respectively. The integer 3 has the same number of set bits as
                 num2, and the value 3 XOR 3 = 0 is minimal.

    Example 2:
    Input: num1 = 1, num2 = 12
    Output: 3
    Explanation: The binary representations of num1 and num2 are 0001 and 1100,
                 respectively. The integer 3 has the same number of set bits as
                 num2, and the value 3 XOR 1 = 2 is minimal.

    Constraints: 1 <= num1, num2 <= 10^9"""

    def minimizeXor(self, num1: int, num2: int) -> int:
        n = num2.bit_count()
        ans = 0
        for i in range(29, -1, -1):
            if n and num1 & 1<<i:
                ans ^= 1<<i
                n -= 1
        for i in range(30):
            if n and num1 & 1<<i == 0:
                ans ^= 1<<i
                n -= 1
        return ans


    """2430. Maximum Deletions on a String (Hard)
    You are given a string s consisting of only lowercase English letters. In
    one operation, you can:
    * Delete the entire string s, or
    * Delete the first i letters of s if the first i letters of s are equal to
      the following i letters in s, for any i in the range
      1 <= i <= s.length / 2.
    For example, if s = "ababc", then in one operation, you could delete the
    first two letters of s to get "abc", since the first two letters of s and
    the following two letters of s are both equal to "ab". Return the maximum
    number of operations needed to delete all of s.

    Example 1:
    Input: s = "abcabcdabc"
    Output: 2
    Explanation: - Delete the first 3 letters ("abc") since the next 3 letters
                   are equal. Now, s = "abcdabc".
                 - Delete all the letters.
                 We used 2 operations so return 2. It can be proven that 2 is
                 the maximum number of operations needed. Note that in the
                 second operation we cannot delete "abc" again because the next
                 occurrence of "abc" does not happen in the next 3 letters.

    Example 2:
    Input: s = "aaabaab"
    Output: 4
    Explanation: - Delete the first letter ("a") since the next letter is equal.
                   Now, s = "aabaab".
                 - Delete the first 3 letters ("aab") since the next 3 letters
                   are equal. Now, s = "aab".
                 - Delete the first letter ("a") since the next letter is equal.
                   Now, s = "ab".
                 - Delete all the letters.
                 We used 4 operations so return 4. It can be proven that 4 is
                 the maximum number of operations needed.

    Example 3:
    Input: s = "aaaaa"
    Output: 5
    Explanation: In each operation, we can delete the first letter of s.

    Constraints:
    * 1 <= s.length <= 4000
    * s consists only of lowercase English letters."""

    def deleteString(self, s: str) -> int:
        if len(set(s)) == 1: return len(s) # edge case but essential to pass OJ
        dp = [1]*len(s)
        for i in range(len(s)-2, -1, -1):
            lsp = [0]
            k = 0
            for j in range(i+1, len(s)):
                while k and s[i+k] != s[j]: k = lsp[k-1]
                if s[i+k] == s[j]: k += 1
                lsp.append(k)
                if 2*k == j-i+1: dp[i] = max(dp[i], 1+dp[i+k])
        return dp[0]


    """2431. Maximize Total Tastiness of Purchased Fruits (Medium)
    You are given two non-negative integer arrays price and tastiness, both
    arrays have the same length n. You are also given two non-negative integers
    maxAmount and maxCoupons.

    For every integer i in range [0, n - 1]:
    * price[i] describes the price of ith fruit.
    * tastiness[i] describes the tastiness of ith fruit.
    You want to purchase some fruits such that total tastiness is maximized and
    the total price does not exceed maxAmount. Additionally, you can use a
    coupon to purchase fruit for half of its price (rounded down to the closest
    integer). You can use at most maxCoupons of such coupons. Return the
    maximum total tastiness that can be purchased.

    Note that:
    * You can purchase each fruit at most once.
    * You can use coupons on some fruit at most once.

    Example 1:
    Input: price = [10,20,20], tastiness = [5,8,8], maxAmount = 20, maxCoupons = 1
    Output: 13
    Explanation: It is possible to make total tastiness 13 in following way:
                 - Buy first fruit without coupon, so that total price = 0 + 10
                   and total tastiness = 0 + 5.
                 - Buy second fruit with coupon, so that total price = 10 + 10
                   and total tastiness = 5 + 8.
                 - Do not buy third fruit, so that total price = 20 and total
                   tastiness = 13.
                 It can be proven that 13 is the maximum total tastiness that
                 can be obtained.

    Example 2:
    Input: price = [10,15,7], tastiness = [5,8,20], maxAmount = 10, maxCoupons = 2
    Output: 28
    Explanation: It is possible to make total tastiness 20 in following way:
                 - Do not buy first fruit, so that total price = 0 and total
                   tastiness = 0.
                 - Buy second fruit with coupon, so that total price = 0 + 7
                   and total tastiness = 0 + 8.
                 - Buy third fruit with coupon, so that total price = 7 + 3 and
                   total tastiness = 8 + 20.
                 It can be proven that 28 is the maximum total tastiness that
                 can be obtained.

    Constraints:
    * n == price.length == tastiness.length
    * 1 <= n <= 100
    * 0 <= price[i], tastiness[i], maxAmount <= 1000
    * 0 <= maxCoupons <= 5"""

    def maxTastiness(self, price: List[int], tastiness: List[int], maxAmount: int, maxCoupons: int) -> int:
        dp = [[0] * (maxCoupons+1) for _ in range(maxAmount+1)]
        for p, t in zip(price, tastiness):
            for i in range(maxAmount, p//2-1, -1):
                for j in range(maxCoupons, -1, -1):
                    if p <= i: dp[i][j] = max(dp[i][j], t + dp[i-p][j])
                    if j: dp[i][j] = max(dp[i][j], t + dp[i-p//2][j-1])
        return dp[-1][-1]


    """2432. The Employee That Worked on the Longest Task (Easy)
    There are n employees, each with a unique id from 0 to n - 1. You are given
    a 2D integer array logs where logs[i] = [idi, leaveTimei] where:
    * idi is the id of the employee that worked on the ith task, and
    * leaveTimei is the time at which the employee finished the ith task. All
      the values leaveTimei are unique.
    Note that the ith task starts the moment right after the (i - 1)th task
    ends, and the 0th task starts at time 0. Return the id of the employee that
    worked the task with the longest time. If there is a tie between two or
    more employees, return the smallest id among them.

    Example 1:
    Input: n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]
    Output: 1
    Explanation: Task 0 started at 0 and ended at 3 with 3 units of times.
                 Task 1 started at 3 and ended at 5 with 2 units of times.
                 Task 2 started at 5 and ended at 9 with 4 units of times.
                 Task 3 started at 9 and ended at 15 with 6 units of times.
                 The task with the longest time is task 3 and the employee with
                 id 1 is the one that worked on it, so we return 1.

    Example 2:
    Input: n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]
    Output: 3
    Explanation: Task 0 started at 0 and ended at 1 with 1 unit of times.
                 Task 1 started at 1 and ended at 7 with 6 units of times.
                 Task 2 started at 7 and ended at 12 with 5 units of times.
                 Task 3 started at 12 and ended at 17 with 5 units of times.
                 The tasks with the longest time is task 1. The employees that
                 worked on it is 3, so we return 3.

    Example 3:
    Input: n = 2, logs = [[0,10],[1,20]]
    Output: 0
    Explanation: Task 0 started at 0 and ended at 10 with 10 units of times.
                 Task 1 started at 10 and ended at 20 with 10 units of times.
                 The tasks with the longest time are tasks 0 and 1. The
                 employees that worked on them are 0 and 1, so we return the
                 smallest id 0.

    Constraints:
    * 2 <= n <= 500
    * 1 <= logs.length <= 500
    * logs[i].length == 2
    * 0 <= idi <= n - 1
    * 1 <= leaveTimei <= 500
    * idi != idi+1
    * leaveTimei are sorted in a strictly increasing order."""

    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:
        prefix = 0
        for log in logs:
            log[1] -= prefix
            prefix += log[1]
        return max(logs, key=lambda x: (x[1], -x[0]))[0]


    """2433. Find The Original Array of Prefix Xor (Medium)
    You are given an integer array pref of size n. Find and return the array
    arr of size n that satisfies:
    * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
    Note that ^ denotes the bitwise-xor operation. It can be proven that the
    answer is unique.

    Example 1:
    Input: pref = [5,2,0,3,1]
    Output: [5,7,2,3,2]
    Explanation: From the array [5,7,2,3,2] we have the following:
                 - pref[0] = 5.
                 - pref[1] = 5 ^ 7 = 2.
                 - pref[2] = 5 ^ 7 ^ 2 = 0.
                 - pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.
                 - pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.

    Example 2:
    Input: pref = [13]
    Output: [13]
    Explanation: We have pref[0] = arr[0] = 13.

    Constraints:
    * 1 <= pref.length <= 10^5
    * 0 <= pref[i] <= 10^6"""

    def findArray(self, pref: List[int]) -> List[int]:
        ans = []
        for i, x in enumerate(pref):
            if i: x ^= pref[i-1]
            ans.append(x)
        return ans


    """2434. Using a Robot to Print the Lexicographically Smallest String (Medium)
    You are given a string s and a robot that currently holds an empty string t.
    Apply one of the following operations until s and t are both empty:
    * Remove the first character of a string s and give it to the robot. The
      robot will append this character to the string t.
    * Remove the last character of a string t and give it to the robot. The
      robot will write this character on paper.
    Return the lexicographically smallest string that can be written on the
    paper.

    Example 1:
    Input: s = "zza"
    Output: "azz"
    Explanation: Let p denote the written string. Initially p="", s="zza", t="".
                 Perform first operation three times p="", s="", t="zza".
                 Perform second operation three times p="azz", s="", t="".

    Example 2:
    Input: s = "bac"
    Output: "abc"
    Explanation: Let p denote the written string. Perform first operation twice
                 p="", s="c", t="ba".  Perform second operation twice p="ab",
                 s="c", t="". Perform first operation p="ab", s="", t="c".
                 Perform second operation p="abc", s="", t="".

    Example 3:
    Input: s = "bdda"
    Output: "addb"
    Explanation: Let p denote the written string. Initially p="", s="bdda", t="".
                 Perform first operation four times p="", s="", t="bdda".
                 Perform second operation four times p="addb", s="", t="".

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of only English lowercase letters."""

    def robotWithString(self, s: str) -> str:
        last = [-1]*26
        for i, ch in enumerate(s): last[ord(ch)-97] = i
        ans, stack = [], []
        for i, ch in enumerate(s):
            stack.append(ch)
            while stack:
                for ii in range(ord(stack[-1])-97):
                    if i < last[ii]: break
                else:
                    ans.append(stack.pop())
                    continue
                break
        return ''.join(ans + stack[::-1])


    """2435. Paths in Matrix Whose Sum Is Divisible by K (Hard)
    You are given a 0-indexed m x n integer matrix grid and an integer k. You
    are currently at position (0, 0) and you want to reach position
    (m - 1, n - 1) moving only down or right. Return the number of paths where
    the sum of the elements on the path is divisible by k. Since the answer
    may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3
    Output: 2
    Explanation: There are two paths where the sum of the elements on the path
                 is divisible by k. The first path highlighted in red has a sum
                 of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3. The second
                 path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15
                 which is divisible by 3.

    Example 2:
    Input: grid = [[0,0]], k = 5
    Output: 1
    Explanation: The path highlighted in red has a sum of 0 + 0 = 0 which is
                 divisible by 5.

    Example 3:
    Input: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1
    Output: 10
    Explanation: Every integer is divisible by 1 so the sum of the elements on
                 every possible path is divisible by k.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 5 * 10^4
    * 1 <= m * n <= 5 * 10^4
    * 0 <= grid[i][j] <= 100
    * 1 <= k <= 50"""

    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        mod = 1_000_000_007
        m, n = len(grid), len(grid[0])
        dp = [[[0]*k for _ in range(n)] for _ in range(m)]
        dp[0][0][grid[0][0] % k] = 1
        for i in range(m):
            for j in range(n):
                for x in range(k):
                    xx = (grid[i][j]+x) % k
                    if i: dp[i][j][xx] = (dp[i][j][xx] + dp[i-1][j][x]) % mod
                    if j: dp[i][j][xx] = (dp[i][j][xx] + dp[i][j-1][x]) % mod
        return dp[-1][-1][0]


    """2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium)
    You are given an array nums consisting of positive integers. Split the
    array into one or more disjoint subarrays such that:
    * Each element of the array belongs to exactly one subarray, and
    * The GCD of the elements of each subarray is strictly greater than 1.
    Return the minimum number of subarrays that can be obtained after the split.

    Note that:
    * The GCD of a subarray is the largest positive integer that evenly divides
      all the elements of the subarray.
    * A subarray is a contiguous part of the array.

    Example 1:
    Input: nums = [12,6,3,14,8]
    Output: 2
    Explanation: We can split the array into the subarrays: [12,6,3] and [14,8].
                 - The GCD of 12, 6 and 3 is 3, which is strictly greater than
                   1.
                 - The GCD of 14 and 8 is 2, which is strictly greater than 1.
                 It can be shown that splitting the array into one subarray
                 will make the GCD = 1.

    Example 2:
    Input: nums = [4,12,6,14]
    Output: 1
    Explanation: We can split the array into only one subarray, which is the
                 whole array.

    Constraints:
    * 1 <= nums.length <= 2000
    * 2 <= nums[i] <= 10^9"""

    def minimumSplits(self, nums: List[int]) -> int:
        ans, g = 0, 1
        for x in nums:
            g = gcd(g, x)
            if g == 1:
                ans += 1
                g = x
        return ans


    """2437. Number of Valid Clock Times (Easy)
    You are given a string of length 5 called time, representing the current
    time on a digital clock in the format "hh:mm". The earliest possible time
    is "00:00" and the latest possible time is "23:59". In the string time, the
    digits represented by the ? symbol are unknown, and must be replaced with a
    digit from 0 to 9. Return an integer answer, the number of valid clock
    times that can be created by replacing every ? with a digit from 0 to 9.

    Example 1:
    Input: time = "?5:00"
    Output: 2
    Explanation: We can replace the ? with either a 0 or 1, producing "05:00"
                 or "15:00". Note that we cannot replace it with a 2, since the
                 time "25:00" is invalid. In total, we have two choices.

    Example 2:
    Input: time = "0?:0?"
    Output: 100
    Explanation: Each ? can be replaced by any digit from 0 to 9, so we have
                 100 total choices.

    Example 3:
    Input: time = "??:??"
    Output: 1440
    Explanation: There are 24 possible choices for the hours, and 60 possible
                 choices for the minutes. In total, we have 24 * 60 = 1440
                 choices.

    Constraints:
    * time is a valid string of length 5 in the format "hh:mm".
    * "00" <= hh <= "23"
    * "00" <= mm <= "59"
    * Some of the digits might be replaced with '?' and need to be replaced
      with digits from 0 to 9."""

    def countTime(self, time: str) -> int:
        ans = 1
        if time[0:2] == "??": ans *= 24
        elif time[0] == '?': ans *= 3 if time[1] < '4' else 2
        elif time[1] == '?': ans *= 4 if time[0] == '2' else 10
        if time[3] == '?': ans *= 6
        if time[4] == '?': ans *= 10
        return ans


    """2438. Range Product Queries of Powers (Medium)
    Given a positive integer n, there exists a 0-indexed array called powers,
    composed of the minimum number of powers of 2 that sum to n. The array is
    sorted in non-decreasing order, and there is only one way to form the array.
    You are also given a 0-indexed 2D integer array queries, where
    queries[i] = [lefti, righti]. Each queries[i] represents a query where you
    have to find the product of all powers[j] with lefti <= j <= righti. Return
    an array answers, equal in length to queries, where answers[i] is the
    answer to the ith query. Since the answer to the ith query may be too large,
    each answers[i] should be returned modulo 10^9 + 7.

    Example 1:
    Input: n = 15, queries = [[0,1],[2,2],[0,3]]
    Output: [2,4,64]
    Explanation: For n = 15, powers = [1,2,4,8]. It can be shown that powers
                 cannot be a smaller size.
                 Answer to 1st query: powers[0] * powers[1] = 1 * 2 = 2.
                 Answer to 2nd query: powers[2] = 4.
                 Answer to 3rd query: powers[0] * powers[1] * powers[2] *
                 powers[3] = 1 * 2 * 4 * 8 = 64.
                 Each answer modulo 10^9 + 7 yields the same answer, so [2,4,64]
                 is returned.

    Example 2:
    Input: n = 2, queries = [[0,0]]
    Output: [2]
    Explanation: For n = 2, powers = [2]. The answer to the only query is
                 powers[0] = 2. The answer modulo 10^9 + 7 is the same, so
                 [2] is returned.

    Constraints:
    * 1 <= n <= 10^9
    * 1 <= queries.length <= 10^5
    * 0 <= starti <= endi < powers.length"""

    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        powers = []
        for i in range(30):
            if n & 1<<i: powers.append(1<<i)
        ans = []
        for lo, hi in queries:
            val = 1
            for ii in range(lo, hi+1):
                val = (val * powers[ii]) % 1_000_000_007
            ans.append(val)
        return ans


    """2439. Minimize Maximum of Array (Medium)
    You are given a 0-indexed array nums comprising of n non-negative integers.
    In one operation, you must:
    * Choose an integer i such that 1 <= i < n and nums[i] > 0.
    * Decrease nums[i] by 1.
    * Increase nums[i - 1] by 1.
    Return the minimum possible value of the maximum integer of nums after
    performing any number of operations.

    Example 1:
    Input: nums = [3,7,1,6]
    Output: 5
    Explanation: One set of optimal operations is as follows:
                 1. Choose i = 1, and nums becomes [4,6,1,6].
                 2. Choose i = 3, and nums becomes [4,6,2,5].
                 3. Choose i = 1, and nums becomes [5,5,2,5].
                 The maximum integer of nums is 5. It can be shown that the
                 maximum number cannot be less than 5. Therefore, we return 5.

    Example 2:
    Input: nums = [10,1]
    Output: 10
    Explanation: It is optimal to leave nums as is, and since 10 is the maximum
                 value, we return 10.

    Constraints:
    * n == nums.length
    * 2 <= n <= 10^5
    * 0 <= nums[i] <= 10^9"""

    def minimizeArrayValue(self, nums: List[int]) -> int:
        return max((x+i)//(i+1) for i, x in enumerate(accumulate(nums)))


    """2440. Create Components With Same Value (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given a 0-indexed integer array nums of length n where nums[i] represents
    the value of the ith node. You are also given a 2D integer array edges of
    length n - 1 where edges[i] = [ai, bi] indicates that there is an edge
    between nodes ai and bi in the tree. You are allowed to delete some edges,
    splitting the tree into multiple connected components. Let the value of a
    component be the sum of all nums[i] for which node i is in the component.
    Return the maximum number of edges you can delete, such that every
    connected component in the tree has the same value.

    Example 1:
    Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]]
    Output: 2
    Explanation: The above figure shows how we can delete the edges [0,1] and
                 [3,4]. The created components are nodes [0], [1,2,3] and [4].
                 The sum of the values in each component equals 6. It can be
                 proven that no better deletion exists, so the answer is 2.

    Example 2:
    Input: nums = [2], edges = []
    Output: 0
    Explanation: There are no edges to be deleted.

    Constraints:
    * 1 <= n <= 2 * 10^4
    * nums.length == n
    * 1 <= nums[i] <= 50
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * edges represents a valid tree."""

    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)

        def fn(u, p):
            """Post-order dfs."""
            ans = nums[u]
            for v in tree[u]:
                if v != p: ans += fn(v, u)
            return 0 if ans == cand else ans

        total = sum(nums)
        for cand in range(1, total//2+1):
            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1
        return 0


    """2441. Largest Positive Integer That Exists With Its Negative (Easy)
    Given an integer array nums that does not contain any zeros, find the
    largest positive integer k such that -k also exists in the array. Return
    the positive integer k. If there is no such integer, return -1.

    Example 1:
    Input: nums = [-1,2,-3,3]
    Output: 3
    Explanation: 3 is the only valid k we can find in the array.

    Example 2:
    Input: nums = [-1,10,6,7,-7,1]
    Output: 7
    Explanation: Both 1 and 7 have their corresponding negative values in the
                 array. 7 has a larger value.

    Example 3:
    Input: nums = [-10,8,6,7,-2,-3]
    Output: -1
    Explanation: There is no a single valid k, we return -1.

    Constraints:
    * 1 <= nums.length <= 1000
    * -1000 <= nums[i] <= 1000
    * nums[i] != 0"""

    def findMaxK(self, nums: List[int]) -> int:
        seen = set(nums)
        return max((abs(x) for x in seen if -x in seen), default=-1)


    """2442. Count Number of Distinct Integers After Reverse Operations (Medium)
    You are given an array nums consisting of positive integers. You have to
    take each integer in the array, reverse its digits, and add it to the end
    of the array. You should apply this operation to the original integers in
    nums. Return the number of distinct integers in the final array.

    Example 1:
    Input: nums = [1,13,10,12,31]
    Output: 6
    Explanation: After including the reverse of each number, the resulting
                 array is [1,13,10,12,31,1,31,1,21,13]. The reversed integers
                 that were added to the end of the array are underlined. Note
                 that for the integer 10, after reversing it, it becomes 01
                 which is just 1. The number of distinct integers in this array
                 is 6 (The numbers 1, 10, 12, 13, 21, and 31).

    Example 2:
    Input: nums = [2,2,2]
    Output: 1
    Explanation: After including the reverse of each number, the resulting
                 array is [2,2,2,2,2,2]. The number of distinct integers in
                 this array is 1 (The number 2).

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def countDistinctIntegers(self, nums: List[int]) -> int:
        return len(set(nums) | {int(str(x)[::-1]) for x in nums})


    """2443. Sum of Number and Its Reverse (Medium)
    Given a non-negative integer num, return true if num can be expressed as
    the sum of any non-negative integer and its reverse, or false otherwise.

    Example 1:
    Input: num = 443
    Output: true
    Explanation: 172 + 271 = 443 so we return true.

    Example 2:
    Input: num = 63
    Output: false
    Explanation: 63 cannot be expressed as the sum of a non-negative integer
                 and its reverse so we return false.

    Example 3:
    Input: num = 181
    Output: true
    Explanation: 140 + 041 = 181 so we return true. Note that when a number is
                 reversed, there may be leading zeros.

    Constraints: 0 <= num <= 10^5"""

    def sumOfNumberAndReverse(self, num: int) -> bool:
        return any(x + int(str(x)[::-1]) == num for x in range(0, num+1))


    """2444. Count Subarrays With Fixed Bounds (Hard)
    You are given an integer array nums and two integers minK and maxK. A
    fixed-bound subarray of nums is a subarray that satisfies the following
    conditions:
    * The minimum value in the subarray is equal to minK.
    * The maximum value in the subarray is equal to maxK.
    Return the number of fixed-bound subarrays. A subarray is a contiguous
    part of an array.

    Example 1:
    Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5
    Output: 2
    Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].

    Example 2:
    Input: nums = [1,1,1,1], minK = 1, maxK = 1
    Output: 10
    Explanation: Every subarray of nums is a fixed-bound subarray. There are 10
                 possible subarrays.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i], minK, maxK <= 10^6"""

    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        ans = 0
        ii = imin = imax = -1
        for i, x in enumerate(nums):
            if minK <= x <= maxK:
                if minK == x: imin = i
                if maxK == x: imax = i
                ans += max(0, min(imax, imin) - ii)
            else: ii = i
        return ans


    """2445. Number of Nodes With Value One (Medium)
    There is an undirected connected tree with n nodes labeled from 1 to n and
    n - 1 edges. You are given the integer n. The parent node of a node with a
    label v is the node with the label floor (v / 2). The root of the tree is
    the node with the label 1.
    * For example, if n = 7, then the node with the label 3 has the node with
      the label floor(3 / 2) = 1 as its parent, and the node with the label 7
      has the node with the label floor(7 / 2) = 3 as its parent.
    You are also given an integer array queries. Initially, every node has a
    value 0 on it. For each query queries[i], you should flip all values in the
    subtree of the node with the label queries[i]. Return the total number of
    nodes with the value 1 after processing all the queries.

    Note that:
    * Flipping the value of a node means that the node with the value 0 becomes
      1 and vice versa.
    * floor(x) is equivalent to rounding x down to the nearest integer.

    Example 1:
    Input: n = 5 , queries = [1,2,5]
    Output: 3
    Explanation: The diagram above shows the tree structure and its status
                 after performing the queries. The blue node represents the
                 value 0, and the red node represents the value 1. After
                 processing the queries, there are three red nodes (nodes with
                 value 1): 1, 3, and 5.

    Example 2:
    Input: n = 3, queries = [2,3,3]
    Output: 1
    Explanation: The diagram above shows the tree structure and its status
                 after performing the queries. The blue node represents the
                 value 0, and the red node represents the value 1. After
                 processing the queries, there are one red node (node with
                 value 1): 2.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= queries.length <= 10^5
    * 1 <= queries[i] <= n"""

    def numberOfNodes(self, n: int, queries: List[int]) -> int:
        flip = [0] * (1+n)
        for q in queries: flip[q] ^= 1
        ans = 0
        stack = [(1, flip[1])]
        while stack:
            x, f = stack.pop()
            if f & 1: ans += 1
            if 2*x <= n: stack.append((2*x, f^flip[2*x]))
            if 2*x+1 <= n: stack.append((2*x+1, f^flip[2*x+1]))
        return ans


    """2446. Determine if Two Events Have Conflict (Easy)
    You are given two arrays of strings that represent two inclusive events
    that happened on the same day, event1 and event2, where:
    * event1 = [startTime1, endTime1] and
    * event2 = [startTime2, endTime2].
    Event times are valid 24 hours format in the form of HH:MM. A conflict
    happens when two events have some non-empty intersection (i.e., some moment
    is common to both events). Return true if there is a conflict between two
    events. Otherwise, return false.

    Example 1:
    Input: event1 = ["01:15","02:00"], event2 = ["02:00","03:00"]
    Output: true
    Explanation: The two events intersect at time 2:00.

    Example 2:
    Input: event1 = ["01:00","02:00"], event2 = ["01:20","03:00"]
    Output: true
    Explanation: The two events intersect starting from 01:20 to 02:00.

    Example 3:
    Input: event1 = ["10:00","11:00"], event2 = ["14:00","15:00"]
    Output: false
    Explanation: The two events do not intersect.

    Constraints:
    * evnet1.length == event2.length == 2.
    * event1[i].length == event2[i].length == 5
    * startTime1 <= endTime1
    * startTime2 <= endTime2
    * All the event times follow the HH:MM format."""

    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:
        return event1[0] <= event2[0] <= event1[1] or event2[0] <= event1[0] <= event2[1]


    """2447. Number of Subarrays With GCD Equal to K (Medium)
    Given an integer array nums and an integer k, return the number of
    subarrays of nums where the greatest common divisor of the subarray's
    elements is k. A subarray is a contiguous non-empty sequence of elements
    within an array. The greatest common divisor of an array is the largest
    integer that evenly divides all the array elements.

    Example 1:
    Input: nums = [9,3,1,2,6,3], k = 3
    Output: 4
    Explanation: The subarrays of nums where 3 is the greatest common divisor
                 of all the subarray's elements are:
                 - [9,3,1,2,6,3]
                 - [9,3,1,2,6,3]
                 - [9,3,1,2,6,3]
                 - [9,3,1,2,6,3]

    Example 2:
    Input: nums = [4], k = 7
    Output: 0
    Explanation: There are no subarrays of nums where 7 is the greatest common
                 divisor of all the subarray's elements.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i], k <= 10^9"""

    def subarrayGCD(self, nums: List[int], k: int) -> int:
        ans = 0
        freq = Counter()
        for x in nums:
            temp = Counter({x : 1})
            for key, v in freq.items():
                temp[gcd(key, x)] += v
            freq = temp
            ans += freq[k]
        return ans


    """2448. Minimum Cost to Make Array Equal (Hard)
    You are given two 0-indexed arrays nums and cost consisting each of n
    positive integers. You can do the following operation any number of times:
    * Increase or decrease any element of the array nums by 1.
    The cost of doing one operation on the ith element is cost[i]. Return the
    minimum total cost such that all the elements of the array nums become
    equal.

    Example 1:
    Input: nums = [1,3,5,2], cost = [2,3,1,14]
    Output: 8
    Explanation: We can make all the elements equal to 2 in the following way:
                 - Increase the 0th element one time. The cost is 2.
                 - Decrease the 1st element one time. The cost is 3.
                 - Decrease the 2nd element three times. The cost is
                   1 + 1 + 1 = 3.
                 The total cost is 2 + 3 + 3 = 8. It can be shown that we
                 cannot make the array equal with a smaller cost.

    Example 2:
    Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3]
    Output: 0
    Explanation: All the elements are already equal, so no operations are
                 needed.

    Constraints:
    * n == nums.length == cost.length
    * 1 <= n <= 10^5
    * 1 <= nums[i], cost[i] <= 10^6"""

    def minCost(self, nums: List[int], cost: List[int]) -> int:
        nums, cost = zip(*sorted(zip(nums, cost)))
        total = sum(cost)
        prefix = 0
        for i, x in enumerate(cost):
            prefix += x
            if prefix > total//2: break
        return sum(c*abs(x-nums[i]) for x, c in zip(nums, cost))


    """2449. Minimum Number of Operations to Make Arrays Similar (Hard)
    You are given two positive integer arrays nums and target, of the same
    length. In one operation, you can choose any two distinct indices i and j
    where 0 <= i, j < nums.length and:
    * set nums[i] = nums[i] + 2 and
    * set nums[j] = nums[j] - 2.
    Two arrays are considered to be similar if the frequency of each element is
    the same. Return the minimum number of operations required to make nums
    similar to target. The test cases are generated such that nums can always
    be similar to target.

    Example 1:
    Input: nums = [8,12,6], target = [2,14,10]
    Output: 2
    Explanation: It is possible to make nums similar to target in two
                 operations:
                 - Choose i = 0 and j = 2, nums = [10,12,4].
                 - Choose i = 1 and j = 2, nums = [10,14,2].
                 It can be shown that 2 is the minimum number of operations
                 needed.

    Example 2:
    Input: nums = [1,2,5], target = [4,1,3]
    Output: 1
    Explanation: We can make nums similar to target in one operation:
                 - Choose i = 1 and j = 2, nums = [1,4,3].

    Example 3:
    Input: nums = [1,1,1,1,1], target = [1,1,1,1,1]
    Output: 0
    Explanation: The array nums is already similiar to target.

    Constraints:
    * n == nums.length == target.length
    * 1 <= n <= 10^5
    * 1 <= nums[i], target[i] <= 10^6
    * It is possible to make nums similar to target."""

    def makeSimilar(self, nums: List[int], target: List[int]) -> int:
        nums.sort(key = lambda x : (x&1, x))
        target.sort(key = lambda x : (x&1, x))
        return sum(abs(x-y) for x, y in zip(nums, target))//4


    """2450. Number of Distinct Binary Strings After Applying Operations (Medium)
    You are given a binary string s and a positive integer k. You can apply the
    following operation on the string any number of times:
    * Choose any substring of size k from s and flip all its characters, that
      is, turn all 1's into 0's, and all 0's into 1's.
    Return the number of distinct strings you can obtain. Since the answer may
    be too large, return it modulo 10^9 + 7.

    Note that:
    * A binary string is a string that consists only of the characters 0 and 1.
    * A substring is a contiguous part of a string.

    Example 1:
    Input: s = "1001", k = 3
    Output: 4
    Explanation: We can obtain the following strings:
                 - Applying no operation on the string gives s = "1001".
                 - Applying one operation on the substring starting at index 0
                   gives s = "0111".
                 - Applying one operation on the substring starting at index 1
                   gives s = "1110".
                 - Applying one operation on both the substrings starting at
                   indices 0 and 1 gives s = "0000".
                 It can be shown that we cannot obtain any other string, so the
                 answer is 4.

    Example 2:
    Input: s = "10110", k = 5
    Output: 2
    Explanation: We can obtain the following strings:
                 - Applying no operation on the string gives s = "10110".
                 - Applying one operation on the whole string gives s = "01001".
                 It can be shown that we cannot obtain any other string, so the
                 answer is 2.

    Constraints:
    * 1 <= k <= s.length <= 10^5
    * s[i] is either 0 or 1."""

    def countDistinctStrings(self, s: str, k: int) -> int:
        return pow(2, len(s)-k+1, 1_000_000_007)


    """2451. Odd String Difference (Easy)
    You are given an array of equal-length strings words. Assume that the
    length of each string is n. Each string words[i] can be converted into a
    difference integer array difference[i] of length n - 1 where
    difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note
    that the difference between two letters is the difference between their
    positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z'
    is 25. For example, for the string "acb", the difference integer array is
    [2 - 0, 1 - 2] = [2, -1]. All the strings in words have the same difference
    integer array, except one. You should find that string. Return the string
    in words that has different difference integer array.

    Example 1:
    Input: words = ["adc","wzy","abc"]
    Output: "abc"
    Explanation: - The difference integer array of "adc" is
                   [3 - 0, 2 - 3] = [3, -1].
                 - The difference integer array of "wzy" is
                   [25 - 22, 24 - 25]= [3, -1].
                 - The difference integer array of "abc" is
                   [1 - 0, 2 - 1] = [1, 1].
                 The odd array out is [1, 1], so we return the corresponding
                 string, "abc".

    Example 2:
    Input: words = ["aaa","bob","ccc","ddd"]
    Output: "bob"
    Explanation: All the integer arrays are [0, 0] except for "bob", which
                 corresponds to [13, -13].

    Constraints:
    * 3 <= words.length <= 100
    * n == words[i].length
    * 2 <= n <= 20
    * words[i] consists of lowercase English letters."""

    def oddString(self, words: List[str]) -> str:
        mp = defaultdict(list)
        for word in words:
            diff = tuple(ord(word[i]) - ord(word[i-1]) for i in range(1, len(word)))
            mp[diff].append(word)
        return next(v[0] for v in mp.values() if len(v) == 1)


    """2452. Words Within Two Edits of Dictionary (Medium)
    You are given two string arrays, queries and dictionary. All words in each
    array comprise of lowercase English letters and have the same length. In
    one edit you can take a word from queries, and change any letter in it to
    any other letter. Find all words from queries that, after a maximum of two
    edits, equal some word from dictionary. Return a list of all words from
    queries, that match with some word from dictionary after a maximum of two
    edits. Return the words in the same order they appear in queries.

    Example 1:
    Input: queries = ["word","note","ants","wood"], dictionary = ["wood","joke","moat"]
    Output: ["word","note","wood"]
    Explanation: - Changing the 'r' in "word" to 'o' allows it to equal the
                   dictionary word "wood".
                 - Changing the 'n' to 'j' and the 't' to 'k' in "note" changes
                   it to "joke".
                 - It would take more than 2 edits for "ants" to equal a
                   dictionary word.
                 - "wood" can remain unchanged (0 edits) and match the
                   corresponding dictionary word.
                 Thus, we return ["word","note","wood"].

    Example 2:
    Input: queries = ["yes"], dictionary = ["not"]
    Output: []
    Explanation: Applying any two edits to "yes" cannot make it equal to "not".
                 Thus, we return an empty array.

    Constraints:
    * 1 <= queries.length, dictionary.length <= 100
    * n == queries[i].length == dictionary[j].length
    * 1 <= n <= 100
    * All queries[i] and dictionary[j] are composed of lowercase English
      letters."""

    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        seen = set()
        for word in dictionary:
            for i in range(len(word)):
                for ch in ascii_lowercase:
                    edit = word[:i] + ch + word[i+1:]
                    seen.add(edit)
        ans = []
        for word in queries:
            for i in range(len(word)):
                for ch in ascii_lowercase:
                    edit = word[:i] + ch + word[i+1:]
                    if edit in seen:
                        ans.append(word)
                        break
                else: continue
                break
        return ans


    """2453. Destroy Sequential Targets (Medium)
    You are given a 0-indexed array nums consisting of positive integers,
    representing targets on a number line. You are also given an integer space.
    You have a machine which can destroy targets. Seeding the machine with some
    nums[i] allows it to destroy all targets with values that can be
    represented as nums[i] + c * space, where c is any non-negative integer.
    You want to destroy the maximum number of targets in nums. Return the
    minimum value of nums[i] you can seed the machine with to destroy the
    maximum number of targets.

    Example 1:
    Input: nums = [3,7,8,1,1,5], space = 2
    Output: 1
    Explanation: If we seed the machine with nums[3], then we destroy all
                 targets equal to 1,3,5,7,9,... In this case, we would destroy
                 5 total targets (all except for nums[2]). It is impossible to
                 destroy more than 5 targets, so we return nums[3].

    Example 2:
    Input: nums = [1,3,5,2,4,6], space = 2
    Output: 1
    Explanation: Seeding the machine with nums[0], or nums[3] destroys 3
                 targets. It is not possible to destroy more than 3 targets.
                 Since nums[0] is the minimal integer that can destroy 3
                 targets, we return 1.

    Example 3:
    Input: nums = [6,2,5], space = 100
    Output: 2
    Explanation: Whatever initial seed we select, we can only destroy 1 target.
                 The minimal seed is nums[1].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= space <= 10^9"""

    def destroyTargets(self, nums: List[int], space: int) -> int:
        freq = Counter(x % space for x in nums)
        m = max(freq.values())
        return min(x for x in nums if freq[x % space] == m)


    """2454. Next Greater Element IV (Hard)
    You are given a 0-indexed array of non-negative integers nums. For each
    integer in nums, you must find its respective second greater integer.
    The second greater integer of nums[i] is nums[j] such that:
    * j > i
    * nums[j] > nums[i]
    * There exists exactly one index k such that nums[k] > nums[i] and
      i < k < j.
    If there is no such nums[j], the second greater integer is considered to be
    -1. For example, in the array [1, 2, 4, 3], the second greater integer of 1
    is 4, 2 is 3, and that of 3 and 4 is -1. Return an integer array answer,
    where answer[i] is the second greater integer of nums[i].

    Example 1:
    Input: nums = [2,4,0,9,6]
    Output: [9,6,6,-1,-1]
    Explanation: 0th index: 4 is the first integer greater than 2, and 9 is the
                            second integer greater than 2, to the right of 2.
                 1st index: 9 is the first, and 6 is the second integer greater
                            than 4, to the right of 4.
                 2nd index: 9 is the first, and 6 is the second integer greater
                            than 0, to the right of 0.
                 3rd index: There is no integer greater than 9 to its right, so
                            the second greater integer is considered to be -1.
                 4th index: There is no integer greater than 6 to its right, so
                            the second greater integer is considered to be -1.
                 Thus, we return [9,6,6,-1,-1].

    Example 2:
    Input: nums = [3,3]
    Output: [-1,-1]
    Explanation: We return [-1,-1] since neither integer has any integer
                 greater than it.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9"""

    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        s0, s1, buff = [], [], []
        for i, x in enumerate(nums):
            while s1 and nums[s1[-1]] < x: ans[s1.pop()] = x
            while s0 and nums[s0[-1]] < x: buff.append(s0.pop())
            while buff: s1.append(buff.pop())
            s0.append(i)
        return ans


    """2455. Average Value of Even Numbers That Are Divisible by Three (Easy)
    Given an integer array nums of positive integers, return the average value
    of all even integers that are divisible by 3. Note that the average of n
    elements is the sum of the n elements divided by n and rounded down to the
    nearest integer.

    Example 1:
    Input: nums = [1,3,6,10,12,15]
    Output: 9
    Explanation: 6 and 12 are even numbers that are divisible by 3.
                 (6 + 12) / 2 = 9.

    Example 2:
    Input: nums = [1,2,4,7,10]
    Output: 0
    Explanation: There is no single number that satisfies the requirement, so
                 return 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000"""

    def averageValue(self, nums: List[int]) -> int:
        cnt = total = 0
        for x in nums:
            if x % 6 == 0:
                cnt += 1
                total += x
        return cnt and total//cnt


    """2456. Most Popular Video Creator (Medium)
    You are given two string arrays creators and ids, and an integer array
    views, all of length n. The ith video on a platform was created by
    creator[i], has an id of ids[i], and has views[i] views. The popularity of
    a creator is the sum of the number of views on all of the creator's videos.
    Find the creator with the highest popularity and the id of their most
    viewed video.
    * If multiple creators have the highest popularity, find all of them.
    * If multiple videos have the highest view count for a creator, find the
      lexicographically smallest id.
    Return a 2D array of strings answer where answer[i] = [creatori, idi] means
    that creatori has the highest popularity and idi is the id of their most
    popular video. The answer can be returned in any order.

    Example 1:
    Input: creators = ["alice","bob","alice","chris"], ids = ["one","two","three","four"], views = [5,10,5,4]
    Output: [["alice","one"],["bob","two"]]
    Explanation: The popularity of alice is 5 + 5 = 10. The popularity of bob
                 is 10. The popularity of chris is 4. alice and bob are the
                 most popular creators. For bob, the video with the highest
                 view count is "two". For alice, the videos with the highest
                 view count are "one" and "three". Since "one" is
                 lexicographically smaller than "three", it is included in the
                 answer.

    Example 2:
    Input: creators = ["alice","alice","alice"], ids = ["a","b","c"], views = [1,2,2]
    Output: [["alice","b"]]
    Explanation: The videos with id "b" and "c" have the highest view count.
                 Since "b" is lexicographically smaller than "c", it is
                 included in the answer.

    Constraints:
    * n == creators.length == ids.length == views.length
    * 1 <= n <= 10^5
    * 1 <= creators[i].length, ids[i].length <= 5
    * creators[i] and ids[i] consist only of lowercase English letters.
    * 0 <= views[i] <= 10^5"""

    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:
        total = defaultdict(int)
        mp = defaultdict(list)
        for c, i, v in zip(creators, ids, views):
            total[c] += v
            mp[c].append((-v, i))
        ans = []
        most = max(total.values())
        for k, v in total.items():
            if v == most: ans.append([k, min(mp[k])[1]])
        return ans


    """2457. Minimum Addition to Make Integer Beautiful (Medium)
    You are given two positive integers n and target. An integer is considered
    beautiful if the sum of its digits is less than or equal to target. Return
    the minimum non-negative integer x such that n + x is beautiful. The input
    will be generated such that it is always possible to make n beautiful.

    Example 1:
    Input: n = 16, target = 6
    Output: 4
    Explanation: Initially n is 16 and its digit sum is 1 + 6 = 7. After adding
                 4, n becomes 20 and digit sum becomes 2 + 0 = 2. It can be
                 shown that we can not make n beautiful with adding non-
                 negative integer less than 4.

    Example 2:
    Input: n = 467, target = 6
    Output: 33
    Explanation: Initially n is 467 and its digit sum is 4 + 6 + 7 = 17. After
                 adding 33, n becomes 500 and digit sum becomes 5 + 0 + 0 = 5.
                 It can be shown that we can not make n beautiful with adding
                 non-negative integer less than 33.

    Example 3:
    Input: n = 1, target = 1
    Output: 0
    Explanation: Initially n is 1 and its digit sum is 1, which is already
                 smaller than or equal to target.

    Constraints:
    * 1 <= n <= 10^12
    * 1 <= target <= 150
    * The input will be generated such that it is always possible to make n
      beautiful."""

    def makeIntegerBeautiful(self, n: int, target: int) -> int:
        diff = i = 0
        while sum(map(int, str(n+diff))) > target:
            i += 1
            diff = 10**i - n % 10**i
        return diff


    """2458. Height of Binary Tree After Subtree Removal Queries (Hard)
    You are given the root of a binary tree with n nodes. Each node is assigned
    a unique value from 1 to n. You are also given an array queries of size m.
    You have to perform m independent queries on the tree where in the ith
    query you do the following:
    * Remove the subtree rooted at the node with the value queries[i] from the
      tree. It is guaranteed that queries[i] will not be equal to the value of
      the root.
    Return an array answer of size m where answer[i] is the height of the tree
    after performing the ith query.

    Note:
    * The queries are independent, so the tree returns to its initial state
      after each query.
    * The height of a tree is the number of edges in the longest simple path
      from the root to some node in the tree.

    Example 1:
    Input: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]
    Output: [2]
    Explanation: The diagram above shows the tree after removing the subtree
                 rooted at node with value 4. The height of the tree is 2 (The
                 path 1 -> 3 -> 2).

    Example 2:
    Input: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]
    Output: [3,2,3,2]
    Explanation: We have the following queries:
                 - Removing the subtree rooted at node with value 3. The height
                   of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).
                 - Removing the subtree rooted at node with value 2. The height
                   of the tree becomes 2 (The path 5 -> 8 -> 1).
                 - Removing the subtree rooted at node with value 4. The height
                   of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).
                 - Removing the subtree rooted at node with value 8. The height
                   of the tree becomes 2 (The path 5 -> 9 -> 3).

    Constraints:
    * The number of nodes in the tree is n.
    * 2 <= n <= 10^5
    * 1 <= Node.val <= n
    * All the values in the tree are unique.
    * m == queries.length
    * 1 <= m <= min(n, 10^4)
    * 1 <= queries[i] <= n
    * queries[i] != root.val"""

    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        depth = {}
        height = {0 : 0}

        def fn(node, d):
            if not node: return 0
            depth[node.val] = d
            height[node.val] = 1 + max(fn(node.left, d+1), fn(node.right, d+1))
            return height[node.val]

        h = fn(root, 0)
        level = [[0, 0] for _ in range(h)]
        for k, v in depth.items():
            if height[k] >= height[level[v][0]]: level[v] = [k, level[v][0]]
            elif height[k] > height[level[v][1]]: level[v][1] = k
        ans = []
        for q in queries:
            d = depth[q]
            if q == level[d][0]: ans.append(h-1-height[q]+height[level[d][1]])
            else: ans.append(h-1)
        return ans


    """2460. Apply Operations to an Array (Easy)
    You are given a 0-indexed array nums of size n consisting of non-negative
    integers. You need to apply n - 1 operations to this array where, in the
    ith operation (0-indexed), you will apply the following on the ith element
    of nums:
    * If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1]
      to 0. Otherwise, you skip this operation.
    After performing all the operations, shift all the 0's to the end of the
    array.
    * For example, the array [1,0,2,0,0,1] after shifting all its 0's to the
      end, is [1,2,1,0,0,0].
    Return the resulting array. Note that the operations are applied
    sequentially, not all at once.

    Example 1:
    Input: nums = [1,2,2,1,1,0]
    Output: [1,4,2,0,0,0]
    Explanation: We do the following operations:
                 - i = 0: nums[0] and nums[1] are not equal, so we skip this
                          operation.
                 - i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by
                          2 and change nums[2] to 0. The array becomes
                          [1,4,0,1,1,0].
                 - i = 2: nums[2] and nums[3] are not equal, so we skip this
                          operation.
                 - i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by
                          2 and change nums[4] to 0. The array becomes
                          [1,4,0,2,0,0].
                 - i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by
                          2 and change nums[5] to 0. The array becomes
                          [1,4,0,2,0,0].
                 After that, we shift the 0's to the end, which gives the array
                 [1,4,2,0,0,0].

    Example 2:
    Input: nums = [0,1]
    Output: [1,0]
    Explanation: No operation can be applied, we just shift the 0 to the end.

    Constraints:
    * 2 <= nums.length <= 2000
    * 0 <= nums[i] <= 1000"""

    def applyOperations(self, nums: List[int]) -> List[int]:
        ans = []
        for i, x in enumerate(nums):
            if i+1 < len(nums) and nums[i] == nums[i+1]:
                nums[i] *= 2
                nums[i+1] = 0
            if nums[i]: ans.append(nums[i])
        return ans + [0]*(len(nums)-len(ans))


    """2461. Maximum Sum of Distinct Subarrays With Length K (Medium)
    You are given an integer array nums and an integer k. Find the maximum
    subarray sum of all the subarrays of nums that meet the following
    conditions:
    * The length of the subarray is k, and
    * All the elements of the subarray are distinct.
    Return the maximum subarray sum of all the subarrays that meet the
    conditions. If no subarray meets the conditions, return 0. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,5,4,2,9,9,9], k = 3
    Output: 15
    Explanation: The subarrays of nums with length 3 are:
                 - [1,5,4] which meets the requirements and has a sum of 10.
                 - [5,4,2] which meets the requirements and has a sum of 11.
                 - [4,2,9] which meets the requirements and has a sum of 15.
                 - [2,9,9] which does not meet the requirements because the
                   element 9 is repeated.
                 - [9,9,9] which does not meet the requirements because the
                   element 9 is repeated.
                 We return 15 because it is the maximum subarray sum of all the
                 subarrays that meet the conditions

    Example 2:
    Input: nums = [4,4,4], k = 3
    Output: 0
    Explanation: The subarrays of nums with length 3 are:
                 - [4,4,4] which does not meet the requirements because the
                   element 4 is repeated.
                 We return 0 because no subarrays meet the conditions.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        ans = ii = rsm = 0
        seen = set()
        for i, x in enumerate(nums):
            while x in seen or i-ii == k:
                seen.remove(nums[ii])
                rsm -= nums[ii]
                ii += 1
            seen.add(x)
            rsm += x
            if i-ii == k-1: ans = max(ans, rsm)
        return ans


    """2462. Total Cost to Hire K Workers (Medium)
    You are given a 0-indexed integer array costs where costs[i] is the cost of
    hiring the ith worker. You are also given two integers k and candidates. We
    want to hire exactly k workers according to the following rules:
    * You will run k sessions and hire exactly one worker in each session.
    * In each hiring session, choose the worker with the lowest cost from
      either the first candidates workers or the last candidates workers. Break
      the tie by the smallest index.
      + For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the
        first hiring session, we will choose the 4th worker because they have
        the lowest cost [3,2,7,7,1,2].
      + In the second hiring session, we will choose 1st worker because they
        have the same lowest cost as 4th worker but they have the smallest
        index [3,2,7,7,2]. Please note that the indexing may be changed in the
        process.
    * If there are fewer than candidates workers remaining, choose the worker
      with the lowest cost among them. Break the tie by the smallest index.
    * A worker can only be chosen once.
    Return the total cost to hire exactly k workers.

    Example 1:
    Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4
    Output: 11
    Explanation: We hire 3 workers in total. The total cost is initially 0.
                 - In the first hiring round we choose the worker from
                   [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break
                   the tie by the smallest index, which is 3. The total cost =
                   0 + 2 = 2.
                 - In the second hiring round we choose the worker from
                   [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The
                   total cost = 2 + 2 = 4.
                 - In the third hiring round we choose the worker from
                   [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The
                   total cost = 4 + 7 = 11. Notice that the worker with index 3
                   was common in the first and last four workers.
                 The total hiring cost is 11.

    Example 2:
    Input: costs = [1,2,4,1], k = 3, candidates = 3
    Output: 4
    Explanation: We hire 3 workers in total. The total cost is initially 0.
                 - In the first hiring round we choose the worker from [1,2,4,1].
                   The lowest cost is 1, and we break the tie by the smallest
                   index, which is 0. The total cost = 0 + 1 = 1. Notice that
                   workers with index 1 and 2 are common in the first and last
                   3 workers.
                 - In the second hiring round we choose the worker from [2,4,1].
                   The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.
                 - In the third hiring round there are less than three
                   candidates. We choose the worker from the remaining workers
                   [2,4]. The lowest cost is 2 (index 0). The total cost =
                   2 + 2 = 4.
                 The total hiring cost is 4.

    Constraints:
    * 1 <= costs.length <= 10^5
    * 1 <= costs[i] <= 10^5
    * 1 <= k, candidates <= costs.length"""

    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        q = costs[:candidates]
        qq = costs[max(candidates, len(costs)-candidates):]
        heapify(q)
        heapify(qq)
        ans = 0
        i, ii = candidates, len(costs)-candidates-1
        for _ in range(k):
            if not qq or q and q[0] <= qq[0]:
                ans += heappop(q)
                if i <= ii:
                    heappush(q, costs[i])
                    i += 1
            else:
                ans += heappop(qq)
                if i <= ii:
                    heappush(qq, costs[ii])
                    ii -= 1
        return ans


    """2463. Minimum Total Distance Traveled (Hard)
    There are some robots and factories on the X-axis. You are given an integer
    array robot where robot[i] is the position of the ith robot. You are also
    given a 2D integer array factory where factory[j] = [positionj, limitj]
    indicates that positionj is the position of the jth factory and that the
    jth factory can repair at most limitj robots. The positions of each robot
    are unique. The positions of each factory are also unique. Note that a
    robot can be in the same position as a factory initially. All the robots
    are initially broken; they keep moving in one direction. The direction
    could be the negative or the positive direction of the X-axis. When a robot
    reaches a factory that did not reach its limit, the factory repairs the
    robot, and it stops moving. At any moment, you can set the initial
    direction of moving for some robot. Your target is to minimize the total
    distance traveled by all the robots. Return the minimum total distance
    traveled by all the robots. The test cases are generated such that all the
    robots can be repaired.

    Note that
    * All robots move at the same speed.
    * If two robots move in the same direction, they will never collide.
    * If two robots move in opposite directions and they meet at some point,
      they do not collide. They cross each other.
    * If a robot passes by a factory that reached its limits, it crosses it as
      if it does not exist.
    * If the robot moved from a position x to a position y, the distance it
      moved is |y - x|.

    Example 1:
    Input: robot = [0,4,6], factory = [[2,2],[6,2]]
    Output: 4
    Explanation: As shown in the figure:
                 - The first robot at position 0 moves in the positive
                   direction. It will be repaired at the first factory.
                 - The second robot at position 4 moves in the negative
                   direction. It will be repaired at the first factory.
                 - The third robot at position 6 will be repaired at the second
                   factory. It does not need to move.
                 The limit of the first factory is 2, and it fixed 2 robots.
                 The limit of the second factory is 2, and it fixed 1 robot.
                 The total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can
                 be shown that we cannot achieve a better total distance than 4.

    Example 2:
    Input: robot = [1,-1], factory = [[-2,1],[2,1]]
    Output: 2
    Explanation: As shown in the figure:
                 - The first robot at position 1 moves in the positive
                   direction. It will be repaired at the second factory.
                 - The second robot at position -1 moves in the negative
                   direction. It will be repaired at the first factory.
                 The limit of the first factory is 1, and it fixed 1 robot.
                 The limit of the second factory is 1, and it fixed 1 robot.
                 The total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be
                 shown that we cannot achieve a better total distance than 2.

    Constraints:
    * 1 <= robot.length, factory.length <= 100
    * factory[j].length == 2
    * -10^9 <= robot[i], positionj <= 10^9
    * 0 <= limitj <= robot.length
    * The input will be generated such that it is always possible to repair
      every robot."""

    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        robot.sort()
        factory.sort()
        m, n = len(robot), len(factory)
        dp = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m): dp[i][-1] = inf
        for j in range(n-1, -1, -1):
            prefix = 0
            qq = deque([(m, 0)])
            for i in range(m-1, -1, -1):
                prefix += abs(robot[i] - factory[j][0])
                if qq[0][0] > i+factory[j][1]: qq.popleft()
                while qq and qq[-1][1] >= dp[i][j+1] - prefix: qq.pop()
                qq.append((i, dp[i][j+1] - prefix))
                dp[i][j] = qq[0][1] + prefix
        return dp[0][0]


    """2464. Minimum Subarrays in a Valid Split (Medium)
    You are given an integer array nums. Splitting of an integer array nums
    into subarrays is valid if:
    * the greatest common divisor of the first and last elements of each
      subarray is greater than 1, and
    * each element of nums belongs to exactly one subarray.
    Return the minimum number of subarrays in a valid subarray splitting of
    nums. If a valid subarray splitting is not possible, return -1.

    Note that:
    * The greatest common divisor of two numbers is the largest positive
      integer that evenly divides both numbers.
    * A subarray is a contiguous non-empty part of an array.

    Example 1:
    Input: nums = [2,6,3,4,3]
    Output: 2
    Explanation: We can create a valid split in the following way:
                 [2,6] | [3,4,3].
                 - The starting element of the 1st subarray is 2 and the ending
                   is 6. Their greatest common divisor is 2, which is greater
                   than 1.
                 - The starting element of the 2nd subarray is 3 and the ending
                   is 3. Their greatest common divisor is 3, which is greater
                   than 1.
                 It can be proved that 2 is the minimum number of subarrays
                 that we can obtain in a valid split.

    Example 2:
    Input: nums = [3,5]
    Output: 2
    Explanation: We can create a valid split in the following way: [3] | [5].
                 - The starting element of the 1st subarray is 3 and the ending
                   is 3. Their greatest common divisor is 3, which is greater
                   than 1.
                 - The starting element of the 2nd subarray is 5 and the ending
                   is 5. Their greatest common divisor is 5, which is greater
                   than 1.
                 It can be proved that 2 is the minimum number of subarrays
                 that we can obtain in a valid split.

    Example 3:
    Input: nums = [1,2,1]
    Output: -1
    Explanation: It is impossible to create valid split.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5"""

    def validSubarraySplit(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [inf] * (n+1)
        dp[-1] = 0
        for i in range(n-1, -1, -1):
            for j in range(i, n):
                if gcd(nums[i], nums[j]) > 1: dp[i] = min(dp[i], 1+dp[j+1])
        return dp[0] if dp[0] < inf else -1


    """2465. Number of Distinct Averages (Easy)
    You are given a 0-indexed integer array nums of even length. As long as
    nums is not empty, you must repetitively:
    * Find the minimum number in nums and remove it.
    * Find the maximum number in nums and remove it.
    * Calculate the average of the two removed numbers.
    The average of two numbers a and b is (a + b) / 2. For example, the average
    of 2 and 3 is (2 + 3) / 2 = 2.5. Return the number of distinct averages
    calculated using the above process. Note that when there is a tie for a
    minimum or maximum number, any can be removed.

    Example 1:
    Input: nums = [4,1,4,0,3,5]
    Output: 2
    Explanation: 1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now,
                    nums = [4,1,4,3].
                 2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and
                    nums = [4,3].
                 3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.
                 Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we
                 return 2.

    Example 2:
    Input: nums = [1,100]
    Output: 1
    Explanation: There is only one average to be calculated after removing 1
                 and 100, so we return 1.

    Constraints:
    * 2 <= nums.length <= 100
    * nums.length is even.
    * 0 <= nums[i] <= 100"""

    def distinctAverages(self, nums: List[int]) -> int:
        nums.sort()
        seen = set()
        for i in range(len(nums)//2):
            seen.add((nums[i] + nums[~i])/2)
        return len(seen)


    """2466. Count Ways To Build Good Strings (Medium)
    Given the integers zero, one, low, and high, we can construct a string by
    starting with an empty string, and then at each step perform either of the
    following:
    * Append the character '0' zero times.
    * Append the character '1' one times.
    This can be performed any number of times. A good string is a string
    constructed by the above process having a length between low and high
    (inclusive). Return the number of different good strings that can be
    constructed satisfying these properties. Since the answer can be large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: low = 3, high = 3, zero = 1, one = 1
    Output: 8
    Explanation: One possible valid good string is "011". It can be constructed
                 as follows: "" -> "0" -> "01" -> "011". All binary strings
                 from "000" to "111" are good strings in this example.

    Example 2:
    Input: low = 2, high = 3, zero = 1, one = 2
    Output: 5
    Explanation: The good strings are "00", "11", "000", "110", and "011".

    Constraints:
    * 1 <= low <= high <= 10^5
    * 1 <= zero, one <= low"""

    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        dp = [0] * (high+1)
        for i in range(high, -1, -1):
            if low <= i: dp[i] = 1
            if i+zero <= high: dp[i] += dp[i+zero]
            if i+one <= high: dp[i] += dp[i+one]
            dp[i] %= 1_000_000_007
        return dp[0]


    """2467. Most Profitable Path in a Tree (Medium)
    There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at
    node 0. You are given a 2D integer array edges of length n - 1 where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. At every node i, there is a gate. You are also given an array
    of even integers amount, where amount[i] represents:
    * the price needed to open the gate at node i, if amount[i] is negative, or,
    * the cash reward obtained on opening the gate at node i, otherwise.
    The game goes on as follows:
    * Initially, Alice is at node 0 and Bob is at node bob.
    * At every second, Alice and Bob each move to an adjacent node. Alice moves
      towards some leaf node, while Bob moves towards node 0.
    * For every node along their path, Alice and Bob either spend money to open
      the gate at that node, or accept the reward. Note that:
      + If the gate is already open, no price will be required, nor will there
        be any cash reward.
      + If Alice and Bob reach the node simultaneously, they share the
        price/reward for opening the gate there. In other words, if the price
        to open the gate is c, then both Alice and Bob pay c / 2 each.
        Similarly, if the reward at the gate is c, both of them receive c / 2
        each.
    * If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches
      node 0, he stops moving. Note that these events are independent of each
      other.
    Return the maximum net income Alice can have if she travels towards the
    optimal leaf node.

    Example 1:
    Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
    Output: 6
    Explanation: The above diagram represents the given tree. The game goes as
                 follows:
                 - Alice is initially on node 0, Bob on node 3. They open the
                   gates of their respective nodes. Alice's net income is now
                   -2.
                 - Both Alice and Bob move to node 1. Since they reach here
                   simultaneously, they open the gate together and share the
                   reward. Alice's net income becomes -2 + (4 / 2) = 0.
                 - Alice moves on to node 3. Since Bob already opened its gate,
                   Alice's income remains unchanged. Bob moves on to node 0,
                   and stops moving.
                 - Alice moves on to node 4 and opens the gate there. Her net
                   income becomes 0 + 6 = 6.
                 Now, neither Alice nor Bob can make any further moves, and the
                 game ends. It is not possible for Alice to get a higher net
                 income.

    Example 2:
    Input: edges = [[0,1]], bob = 1, amount = [-7280,2350]
    Output: -7280
    Explanation: Alice follows the path 0->1 whereas Bob follows the path 1->0.
                 Thus, Alice opens the gate at node 0 only. Hence, her net
                 income is -7280.

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * edges represents a valid tree.
    * 1 <= bob < n
    * amount.length == n
    * amount[i] is an even integer in the range [-10^4, 10^4]."""

    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        n = 1 + len(edges)
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        seen = [False] * n

        def dfs(u, d):
            """Return max apple collected & distance to Bob."""
            seen[u] = True
            ans = -inf
            dd = 0 if u == bob else n
            for v in tree[u]:
                if not seen[v]:
                    x, y = dfs(v, d+1)
                    ans = max(ans, x)
                    dd = min(dd, y)
            if ans == -inf: ans = 0
            if d == dd: ans += amount[u]//2
            if d < dd: ans += amount[u]
            return ans, dd+1

        return dfs(0, 0)[0]


    """2468. Split Message Based on Limit (Hard)
    You are given a string, message, and a positive integer, limit. You must
    split message into one or more parts based on limit. Each resulting part
    should have the suffix "<a/b>", where "b" is to be replaced with the total
    number of parts and "a" is to be replaced with the index of the part,
    starting from 1 and going up to b. Additionally, the length of each
    resulting part (including its suffix) should be equal to limit, except for
    the last part whose length can be at most limit. The resulting parts should
    be formed such that when their suffixes are removed and they are all
    concatenated in order, they should be equal to message. Also, the result
    should contain as few parts as possible. Return the parts message would be
    split into as an array of strings. If it is impossible to split message as
    required, return an empty array.

    Example 1:
    Input: message = "this is really a very awesome message", limit = 9
    Output: ["thi<1/14>","s i<2/14>","s r<3/14>","eal<4/14>","ly <5/14>","a v<6/14>","ery<7/14>"," aw<8/14>","eso<9/14>","me<10/14>"," m<11/14>","es<12/14>","sa<13/14>","ge<14/14>"]
    Explanation: The first 9 parts take 3 characters each from the beginning of
                 message. The next 5 parts take 2 characters each to finish
                 splitting message. In this example, each part, including the
                 last, has length 9. It can be shown it is not possible to
                 split message into less than 14 parts.

    Example 2:
    Input: message = "short message", limit = 15
    Output: ["short mess<1/2>","age<2/2>"]
    Explanation: Under the given constraints, the string can be split into two
                 parts:
                 - The first part comprises of the first 10 characters, and has
                   a length 15.
                 - The next part comprises of the last 3 characters, and has a
                   length 8.

    Constraints:
    * 1 <= message.length <= 10^4
    * message consists only of lowercase English letters and ' '.
    * 1 <= limit <= 10^4"""

    def splitMessage(self, message: str, limit: int) -> List[str]:
        prefix = b = 0
        while 3 + len(str(b))*2 < limit and len(message) + prefix + (3+len(str(b)))*b > limit * b:
            b += 1
            prefix += len(str(b))
        ans = []
        if 3 + len(str(b))*2 < limit:
            i = 0
            for a in range(1, b+1):
                step = limit - (len(str(a)) + len(str(b)) + 3)
                ans.append(f"{message[i:i+step]}<{a}/{b}>")
                i += step
        return ans


    """2469. Convert the Temperature (Easy)
    You are given a non-negative floating point number rounded to two decimal
    places celsius, that denotes the temperature in Celsius. You should convert
    Celsius into Kelvin and Fahrenheit and return it as an array
    ans = [kelvin, fahrenheit]. Return the array ans. Answers within 10-5 of
    the actual answer will be accepted.

    Note that:
    * Kelvin = Celsius + 273.15
    * Fahrenheit = Celsius * 1.80 + 32.00

    Example 1:
    Input: celsius = 36.50
    Output: [309.65000,97.70000]
    Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and
                 converted in Fahrenheit is 97.70.

    Example 2:
    Input: celsius = 122.11
    Output: [395.26000,251.79800]
    Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26
                 and converted in Fahrenheit is 251.798.

    Constraints: 0 <= celsius <= 1000"""

    def convertTemperature(self, celsius: float) -> List[float]:
        return [celsius+273.15, 1.8*celsius+32]


    """2470. Number of Subarrays With LCM Equal to K (Medium)
    Given an integer array nums and an integer k, return the number of
    subarrays of nums where the least common multiple of the subarray's
    elements is k. A subarray is a contiguous non-empty sequence of elements
    within an array. The least common multiple of an array is the smallest
    positive integer that is divisible by all the array elements.

    Example 1:
    Input: nums = [3,6,2,7,1], k = 6
    Output: 4
    Explanation: The subarrays of nums where 6 is the least common multiple of
                 all the subarray's elements are:
                 - [3,6,2,7,1]
                 - [3,6,2,7,1]
                 - [3,6,2,7,1]
                 - [3,6,2,7,1]

    Example 2:
    Input: nums = [3], k = 2
    Output: 0
    Explanation: There are no subarrays of nums where 2 is the least common
                 multiple of all the subarray's elements.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i], k <= 1000"""

    def subarrayLCM(self, nums: List[int], k: int) -> int:
        ans = 0
        freq = Counter()
        for x in nums:
            temp = Counter()
            if k % x == 0:
                for key, val in freq.items():
                    temp[lcm(key, x)] += val
                temp[x] += 1
                ans += temp[k]
            freq = temp
        return ans


    """2471. Minimum Number of Operations to Sort a Binary Tree by Level (Medium)
    You are given the root of a binary tree with unique values. In one
    operation, you can choose any two nodes at the same level and swap their
    values. Return the minimum number of operations needed to make the values
    at each level sorted in a strictly increasing order. The level of a node is
    the number of edges along the path between it and the root node.

    Example 1:
    Input: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]
    Output: 3
    Explanation: - Swap 4 and 3. The 2nd level becomes [3,4].
                 - Swap 7 and 5. The 3rd level becomes [5,6,8,7].
                 - Swap 8 and 7. The 3rd level becomes [5,6,7,8].
                 We used 3 operations so return 3. It can be proven that 3 is
                 the minimum number of operations needed.

    Example 2:
    Input: root = [1,3,2,7,6,5,4]
    Output: 3
    Explanation: - Swap 3 and 2. The 2nd level becomes [2,3].
                 - Swap 7 and 4. The 3rd level becomes [4,6,5,7].
                 - Swap 6 and 5. The 3rd level becomes [4,5,6,7].
                 We used 3 operations so return 3. It can be proven that 3 is
                 the minimum number of operations needed.

    Example 3:
    Input: root = [1,2,3,4,5,6]
    Output: 0
    Explanation: Each level is already sorted in increasing order so return 0.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5
    * All the values of the tree are unique."""

    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        ans = 0
        queue = deque([root])
        while queue:
            vals = []
            for _ in range(len(queue)):
                node = queue.popleft()
                vals.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            _, perm = zip(*sorted(zip(vals, range(len(vals)))))
            perm = list(perm)
            for i in range(len(perm)):
                while i != perm[i]:
                    ans += 1
                    perm[perm[i]], perm[i] = perm[i], perm[perm[i]]
        return ans


    """2472. Maximum Number of Non-overlapping Palindrome Substrings (Hard)
    You are given a string s and a positive integer k. Select a set of non-
    overlapping substrings from the string s that satisfy the following
    conditions:
    * The length of each substring is at least k.
    * Each substring is a palindrome.
    Return the maximum number of substrings in an optimal selection. A
    substring is a contiguous sequence of characters within a string.

    Example 1:
    Input: s = "abaccdbbd", k = 3
    Output: 2
    Explanation: We can select the substrings underlined in s = "abaccdbbd".
                 Both "aba" and "dbbd" are palindromes and have a length of at
                 least k = 3. It can be shown that we cannot find a selection
                 with more than two valid substrings.

    Example 2:
    Input: s = "adbcda", k = 2
    Output: 0
    Explanation: There is no palindrome substring of length at least 2 in the
                 string.

    Constraints:
    * 1 <= k <= s.length <= 2000
    * s consists of lowercase English letters."""

    def maxPalindromes(self, s: str, k: int) -> int:
        intervals = []
        for i in range(2*len(s)-1):
            lo, hi = i//2, (i+1)//2
            while 0 <= lo <= hi < len(s) and s[lo] == s[hi]:
                if hi-lo+1 >= k:
                    intervals.append((lo, hi+1))
                    break
                lo -= 1
                hi += 1
        ans = hi = 0
        for x, y in intervals:
            if x >= hi:
                hi = y
                ans += 1
        return ans


    """2473. Minimum Cost to Buy Apples (Medium)
    You are given a positive integer n representing n cities numbered from 1 to
    n. You are also given a 2D array roads, where roads[i] = [ai, bi, costi]
    indicates that there is a bidirectional road between cities ai and bi with
    a cost of traveling equal to costi. You can buy apples in any city you want,
    but some cities have different costs to buy apples. You are given the array
    appleCost where appleCost[i] is the cost of buying one apple from city i.
    You start at some city, traverse through various roads, and eventually buy
    exactly one apple from any city. After you buy that apple, you have to
    return back to the city you started at, but now the cost of all the roads
    will be multiplied by a given factor k. Given the integer k, return an
    array answer of size n where answer[i] is the minimum total cost to buy an
    apple if you start at city i.

    Example 1:
    Input: n = 4, roads = [[1,2,4],[2,3,2],[2,4,5],[3,4,1],[1,3,4]],
           appleCost = [56,42,102,301], k = 2
    Output: [54,42,48,51]
    Explanation: The minimum cost for each starting city is the following:
                 - Starting at city 1: You take the path 1 -> 2, buy an apple
                   at city 2, and finally take the path 2 -> 1. The total
                   cost is 4 + 42 + 4 * 2 = 54.
                 - Starting at city 2: You directly buy an apple at city 2.
                   The total cost is 42.
                 - Starting at city 3: You take the path 3 -> 2, buy an apple
                   at city 2, and finally take the path 2 -> 3. The total cost
                   is 2 + 42 + 2 * 2 = 48.
                 - Starting at city 4: You take the path 4 -> 3 -> 2 then you
                   buy at city 2, and finally take the path 2 -> 3 -> 4. The
                   total cost is 1 + 2 + 42 + 1 * 2 + 2 * 2 = 51.

    Example 2:
    Input: n = 3, roads = [[1,2,5],[2,3,1],[3,1,2]], appleCost = [2,3,1], k = 3
    Output: [2,3,1]
    Explanation: It is always optimal to buy the apple in the starting city.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= roads.length <= 1000
    * 1 <= ai, bi <= n
    * ai != bi
    * 1 <= costi <= 105
    * appleCost.length == n
    * 1 <= appleCost[i] <= 105
    * 1 <= k <= 100
    * There are no repeated edges."""

    def minCost(self, n: int, roads: List[List[int]], appleCost: List[int], k: int) -> List[int]:
        graph = [[] for _ in range(n)]
        for u, v, w in roads:
            graph[u-1].append((v-1, w))
            graph[v-1].append((u-1, w))
        ans = [inf]*n
        for i in range(n):
            dist = [inf]*n
            dist[i] = 0
            pq = [(0, i)]
            while pq:
                x, u = heappop(pq)
                ans[i] = min(ans[i], appleCost[u]+(1+k)*x)
                for v, w in graph[u]:
                    xx = x + w
                    if xx < dist[v]:
                        dist[v] = xx
                        heappush(pq, (xx, v))
        return ans


    """2475. Number of Unequal Triplets in Array (Easy)
    You are given a 0-indexed array of positive integers nums. Find the number
    of triplets (i, j, k) that meet the following conditions:
    * 0 <= i < j < k < nums.length
    * nums[i], nums[j], and nums[k] are pairwise distinct.
      + In other words, nums[i] != nums[j], nums[i] != nums[k], and
        nums[j] != nums[k].
    Return the number of triplets that meet the conditions.

    Example 1:
    Input: nums = [4,4,2,4,3]
    Output: 3
    Explanation: The following triplets meet the conditions:
                 - (0, 2, 4) because 4 != 2 != 3
                 - (1, 2, 4) because 4 != 2 != 3
                 - (2, 3, 4) because 2 != 4 != 3
                 Since there are 3 triplets, we return 3. Note that (2, 0, 4)
                 is not a valid triplet because 2 > 0.

    Example 2:
    Input: nums = [1,1,1,1,1]
    Output: 0
    Explanation: No triplets meet the conditions so we return 0.

    Constraints:
    * 3 <= nums.length <= 100
    * 1 <= nums[i] <= 1000"""

    def unequalTriplets(self, nums: List[int]) -> int:
        freq = Counter(nums)
        ans = prefix = 0
        suffix = len(nums)
        for k, v in freq.items():
            suffix -= v
            ans += prefix * v * suffix
            prefix += v
        return ans


    """2476. Closest Nodes Queries in a Binary Search Tree (Medium)
    You are given the root of a binary search tree and an array queries of size
    n consisting of positive integers. Find a 2D array answer of size n where
    answer[i] = [mini, maxi]:
    * mini is the largest value in the tree that is smaller than or equal to
      queries[i]. If a such value does not exist, add -1 instead.
    * maxi is the smallest value in the tree that is greater than or equal to
      queries[i]. If a such value does not exist, add -1 instead.
    Return the array answer.

    Example 1:
    Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]
    Output: [[2,2],[4,6],[15,-1]]
    Explanation: We answer the queries in the following way:
                 - The largest number that is smaller or equal than 2 in the
                   tree is 2, and the smallest number that is greater or equal
                   than 2 is still 2. So the answer for the first query is
                   [2,2].
                 - The largest number that is smaller or equal than 5 in the
                   tree is 4, and the smallest number that is greater or equal
                   than 5 is 6. So the answer for the second query is [4,6].
                 - The largest number that is smaller or equal than 16 in the
                   tree is 15, and the smallest number that is greater or equal
                   than 16 does not exist. So the answer for the third query is
                   [15,-1].

    Example 2:
    Input: root = [4,null,9], queries = [3]
    Output: [[-1,4]]
    Explanation: The largest number that is smaller or equal to 3 in the tree
                 does not exist, and the smallest number that is greater or
                 equal to 3 is 4. So the answer for the query is [-1,4].

    Constraints:
    * The number of nodes in the tree is in the range [2, 10^5].
    * 1 <= Node.val <= 10^6
    * n == queries.length
    * 1 <= n <= 10^5
    * 1 <= queries[i] <= 10^6"""

    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:
        vals = []
        node = root
        stack = []
        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                vals.append(node.val)
                node = node.right
        ans = []
        for q in queries:
            ans.append([-1, -1])
            lo = bisect_right(vals, q)-1
            if 0 <= lo: ans[-1][0] = vals[lo]
            hi = bisect_left(vals, q)
            if hi < len(vals): ans[-1][1] = vals[hi]
        return ans


    """2477. Minimum Fuel Cost to Report to the Capital (Medium)
    There is a tree (i.e., a connected, undirected graph with no cycles)
    structure country network consisting of n cities numbered from 0 to n - 1
    and exactly n - 1 roads. The capital city is city 0. You are given a 2D
    integer array roads where roads[i] = [ai, bi] denotes that there exists a
    bidirectional road connecting cities ai and bi. There is a meeting for the
    representatives of each city. The meeting is in the capital city. There is
    a car in each city. You are given an integer seats that indicates the
    number of seats in each car. A representative can use the car in their city
    to travel or change the car and ride with another representative. The cost
    of traveling between two cities is one liter of fuel. Return the minimum
    number of liters of fuel to reach the capital city.

    Example 1:
    Input: roads = [[0,1],[0,2],[0,3]], seats = 5
    Output: 3
    Explanation: - Representative1 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative2 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative3 goes directly to the capital with 1 liter of
                   fuel.
                 It costs 3 liters of fuel at minimum. It can be proven that 3
                 is the minimum number of liters of fuel needed.

    Example 2:
    Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
    Output: 7
    Explanation: - Representative2 goes directly to city 3 with 1 liter of fuel.
                 - Representative2 and representative3 go together to city 1
                   with 1 liter of fuel.
                 - Representative2 and representative3 go together to the
                   capital with 1 liter of fuel.
                 - Representative1 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative5 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative6 goes directly to city 4 with 1 liter of fuel.
                 - Representative4 and representative6 go together to the
                   capital with 1 liter of fuel.
                 It costs 7 liters of fuel at minimum. It can be proven that 7
                 is the minimum number of liters of fuel needed.

    Example 3:
    Input: roads = [], seats = 1
    Output: 0
    Explanation: No representatives need to travel to the capital city.

    Constraints:
    * 1 <= n <= 10^5
    * roads.length == n - 1
    * roads[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * roads represents a valid tree
    * 1 <= seats <= 10^5"""

    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        graph = [[] for _ in range(len(roads)+1)]
        for u, v in roads:
            graph[u].append(v)
            graph[v].append(u)

        def dfs(u, p):
            """Return number of people going through city u."""
            ans = ppl = 0
            for v in graph[u]:
                if v != p:
                    x, y = dfs(v, u)
                    ppl += x
                    ans += y
            ppl += 1
            if u: ans += (ppl + seats - 1) // seats
            return ppl, ans

        return dfs(0, -1)[1]


    """2478. Number of Beautiful Partitions (Hard)
    You are given a string s that consists of the digits '1' to '9' and two
    integers k and minLength. A partition of s is called beautiful if:
    * s is partitioned into k non-intersecting substrings.
    * Each substring has a length of at least minLength.
    * Each substring starts with a prime digit and ends with a non-prime digit.
      Prime digits are '2', '3', '5', and '7', and the rest of the digits are
      non-prime.
    Return the number of beautiful partitions of s. Since the answer may be
    very large, return it modulo 10^9 + 7. A substring is a contiguous sequence
    of characters within a string.

    Example 1:
    Input: s = "23542185131", k = 3, minLength = 2
    Output: 3
    Explanation: There exists three ways to create a beautiful partition:
                 "2354 | 218 | 5131"
                 "2354 | 21851 | 31"
                 "2354218 | 51 | 31"

    Example 2:
    Input: s = "23542185131", k = 3, minLength = 3
    Output: 1
    Explanation: There exists one way to create a beautiful partition:
                 "2354 | 218 | 5131".

    Example 3:
    Input: s = "3312958", k = 3, minLength = 1
    Output: 1
    Explanation: There exists one way to create a beautiful partition:
                 "331 | 29 | 58".

    Constraints:
    * 1 <= k, minLength <= s.length <= 1000
    * s consists of the digits '1' to '9'."""

    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        prime = "2357"
        dp = [[0]*(len(s)+1) for _ in range(k)]
        if s[0] in prime and s[-1] not in prime:
            for j in range(len(s)+1): dp[0][j] = 1
            for i in range(1, k):
                for j in range(len(s)-1, -1, -1):
                    dp[i][j] = dp[i][j+1]
                    if minLength <= j <= len(s)-minLength and s[j-1] not in prime and s[j] in prime:
                        dp[i][j] = (dp[i][j] + dp[i-1][j+minLength]) % 1_000_000_007
        return dp[-1][0]


    """2479. Maximum XOR of Two Non-Overlapping Subtrees (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. The root of the tree is the node labeled 0. Each node has an
    associated value. You are given an array values of length n, where values[i]
    is the value of the ith node. Select any two non-overlapping subtrees. Your
    score is the bitwise XOR of the sum of the values within those subtrees.
    Return the maximum possible score you can achieve. If it is impossible to
    find two nonoverlapping subtrees, return 0.

    Note that:
    * The subtree of a node is the tree consisting of that node and all of its
      descendants.
    * Two subtrees are non-overlapping if they do not share any common node.

    Example 1:
    Input: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5]
    Output: 24
    Explanation: Node 1's subtree has sum of values 16, while node 2's subtree
                 has sum of values 8, so choosing these nodes will yield a
                 score of 16 XOR 8 = 24. It can be proved that is the maximum
                 possible score we can obtain.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2]], values = [4,6,1]
    Output: 0
    Explanation: There is no possible way to select two non-overlapping
                 subtrees, so we just return 0.

    Constraints:
    * 2 <= n <= 5 * 10^4
    * edges.length == n - 1
    * 0 <= ai, bi < n
    * values.length == n
    * 1 <= values[i] <= 10^9
    * It is guaranteed that edges represents a valid tree."""

    def maxXor(self, n: int, edges: List[List[int]], values: List[int]) -> int:
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)

        def dfs(u, p):
            """Return sum of subtree."""
            sm[u] = values[u]
            for v in tree[u]:
                if v != p: sm[u] += dfs(v, u)
            return sm[u]

        sm = [0]*n
        dfs(0, -1)

        def calc(u, p):
            """Return maximum xor value."""
            ans = 0
            if trie:
                node = trie
                for b in map(int, bin(sm[u])[2:].zfill(46)):
                    if 1-b in node: node = node[1-b]
                    else: node = node[b]
                ans = node['$'] ^ sm[u]
            for v in tree[u]:
                if v != p: ans = max(ans, calc(v, u))
            node = trie
            for b in map(int, bin(sm[u])[2:].zfill(46)):
                node = node.setdefault(b, {})
            node['$'] = sm[u]
            return ans

        trie = {}
        return calc(0, -1)


    """2481. Minimum Cuts to Divide a Circle (Easy)
    A valid cut in a circle can be:
    * A cut that is represented by a straight line that touches two points on
      the edge of the circle and passes through its center, or
    * A cut that is represented by a straight line that touches one point on
      the edge of the circle and its center.
    Some valid and invalid cuts are shown in the figures below. Given the
    integer n, return the minimum number of cuts needed to divide a circle into
    n equal slices.

    Example 1:
    Input: n = 4
    Output: 2
    Explanation: The above figure shows how cutting the circle twice through
                 the middle divides it into 4 equal slices.

    Example 2:
    Input: n = 3
    Output: 3
    Explanation: At least 3 cuts are needed to divide the circle into 3 equal
                 slices. It can be shown that less than 3 cuts cannot result in
                 3 slices of equal size and shape. Also note that the first cut
                 will not divide the circle into distinct parts.

    Constraints: 1 <= n <= 100"""

    def numberOfCuts(self, n: int) -> int:
        if n == 1: return 0
        return n if n&1 else n>>1


    """2482. Difference Between Ones and Zeros in Row and Column (Medium)
    You are given a 0-indexed m x n binary matrix grid. A 0-indexed m x n
    difference matrix diff is created with the following procedure:
    * Let the number of ones in the ith row be onesRowi.
    * Let the number of ones in the jth column be onesColj.
    * Let the number of zeros in the ith row be zerosRowi.
    * Let the number of zeros in the jth column be zerosColj.
    * diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
    Return the difference matrix diff.

    Example 1:
    Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
    Output: [[0,0,4],[0,0,4],[-2,-2,2]]
    Explanation: - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0
                   = 2 + 1 - 1 - 2 = 0
                 - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1
                   = 2 + 1 - 1 - 2 = 0
                 - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2
                   = 2 + 3 - 1 - 0 = 4
                 - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0
                   = 2 + 1 - 1 - 2 = 0
                 - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1
                   = 2 + 1 - 1 - 2 = 0
                 - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2
                   = 2 + 3 - 1 - 0 = 4
                 - diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0
                   = 1 + 1 - 2 - 2 = -2
                 - diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1
                   = 1 + 1 - 2 - 2 = -2
                 - diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2
                   = 1 + 3 - 2 - 0 = 2

    Example 2:
    Input: grid = [[1,1,1],[1,1,1]]
    Output: [[5,5,5],[5,5,5]]
    Explanation: - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0
                   = 3 + 2 - 0 - 0 = 5
                 - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1
                   = 3 + 2 - 0 - 0 = 5
                 - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2
                   = 3 + 2 - 0 - 0 = 5
                 - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0
                   = 3 + 2 - 0 - 0 = 5
                 - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1
                   = 3 + 2 - 0 - 0 = 5
                 - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2
                   = 3 + 2 - 0 - 0 = 5

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * grid[i][j] is either 0 or 1."""

    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        row = [0]*m
        col = [0]*n
        for i in range(m):
            for j in range(n):
                row[i] += grid[i][j]
                col[j] += grid[i][j]
        ans = [[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                ans[i][j] = 2*row[i] + 2*col[j] - m - n
        return ans


    """2483. Minimum Penalty for a Shop (Medium)
    You are given the customer visit log of a shop represented by a 0-indexed
    string customers consisting only of characters 'N' and 'Y':
    * if the ith character is 'Y', it means that customers come at the ith hour
    * whereas 'N' indicates that no customers come at the ith hour.
    If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated
    as follows:
    * For every hour when the shop is open and no customers come, the penalty
      increases by 1.
    * For every hour when the shop is closed and customers come, the penalty
      increases by 1.
    Return the earliest hour at which the shop must be closed to incur a
    minimum penalty. Note that if a shop closes at the jth hour, it means the
    shop is closed at the hour j.

    Example 1:
    Input: customers = "YYNY"
    Output: 2
    Explanation: - Closing the shop at the 0th hour incurs in 1+1+0+1 = 3
                   penalty.
                 - Closing the shop at the 1st hour incurs in 0+1+0+1 = 2
                   penalty.
                 - Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1
                   penalty.
                 - Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2
                   penalty.
                 - Closing the shop at the 4th hour incurs in 0+0+1+0 = 1
                   penalty.
                 Closing the shop at 2nd or 4th hour gives a minimum penalty.
                 Since 2 is earlier, the optimal closing time is 2.

    Example 2:
    Input: customers = "NNNNN"
    Output: 0
    Explanation: It is best to close the shop at the 0th hour as no customers
                 arrive.

    Example 3:
    Input: customers = "YYYY"
    Output: 4
    Explanation: It is best to close the shop at the 4th hour as customers
                 arrive at each hour.

    Constraints:
    * 1 <= customers.length <= 10^5
    * customers consists only of characters 'Y' and 'N'."""

    def bestClosingTime(self, customers: str) -> int:
        ans = 0
        prefix = least = customers.count('Y')
        for i, ch in enumerate(customers):
            if ch == 'N': prefix += 1
            else: prefix -= 1;
            if prefix < least:
                ans = i+1
                least = prefix
        return ans


    """2484. Count Palindromic Subsequences (Hard)
    Given a string of digits s, return the number of palindromic subsequences
    of s having length 5. Since the answer may be very large, return it modulo
    10^9 + 7.

    Note:
    * A string is palindromic if it reads the same forward and backward.
    * A subsequence is a string that can be derived from another string by
      deleting some or no characters without changing the order of the
      remaining characters.

    Example 1:
    Input: s = "103301"
    Output: 2
    Explanation: There are 6 possible subsequences of length 5: "10330","10331",
                 "10301","10301","13301","03301". Two of them (both equal to
                 "10301") are palindromic.

    Example 2:
    Input: s = "0000000"
    Output: 21
    Explanation: All 21 subsequences are "00000", which is palindromic.

    Example 3:
    Input: s = "9999900000"
    Output: 2
    Explanation: The only two palindromic subsequences are "99999" and "00000".

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of digits."""

    def countPalindromes(self, s: str) -> int:
        ans = 0
        for x in range(10):
            for y in range(10):
                pattern = f"{x}{y}|{y}{x}"
                dp = [0]*6
                dp[-1] = 1
                for i in range(len(s)):
                    for j in range(5):
                        if s[i] == pattern[j] or j == 2: dp[j] += dp[j+1]
                ans = (ans + dp[0]) % 1_000_000_007
        return ans


    """2485. Find the Pivot Integer (Easy)
    Given a positive integer n, find the pivot integer x such that:
    * The sum of all elements between 1 and x inclusively equals the sum of all
      elements between x and n inclusively.
    Return the pivot integer x. If no such integer exists, return -1. It is
    guaranteed that there will be at most one pivot index for the given input.

    Example 1:
    Input: n = 8
    Output: 6
    Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.

    Example 2:
    Input: n = 1
    Output: 1
    Explanation: 1 is the pivot integer since: 1 = 1.

    Example 3:
    Input: n = 4
    Output: -1
    Explanation: It can be proved that no such integer exist.

    Constraints: 1 <= n <= 1000"""

    def pivotInteger(self, n: int) -> int:
        total = n*(n+1)//2
        val = isqrt(total)
        return val if pow(val, 2) == total else -1


    """2486. Append Characters to String to Make Subsequence (Medium)
    You are given two strings s and t consisting of only lowercase English
    letters. Return the minimum number of characters that need to be appended
    to the end of s so that t becomes a subsequence of s. A subsequence is a
    string that can be derived from another string by deleting some or no
    characters without changing the order of the remaining characters.

    Example 1:
    Input: s = "coaching", t = "coding"
    Output: 4
    Explanation: Append the characters "ding" to the end of s so that
                 s = "coachingding". Now, t is a subsequence of s
                 ("coachingding"). It can be shown that appending any 3
                 characters to the end of s will never make t a subsequence.

    Example 2:
    Input: s = "abcde", t = "a"
    Output: 0
    Explanation: t is already a subsequence of s ("abcde").

    Example 3:
    Input: s = "z", t = "abcde"
    Output: 5
    Explanation: Append the characters "abcde" to the end of s so that
                 s = "zabcde". Now, t is a subsequence of s ("zabcde"). It can
                 be shown that appending any 4 characters to the end of s will
                 never make t a subsequence.

    Constraints:
    * 1 <= s.length, t.length <= 10^5
    * s and t consist only of lowercase English letters."""

    def appendCharacters(self, s: str, t: str) -> int:
        it = iter(s)
        return next((len(t)-i for i, ch in enumerate(t) if ch not in it), 0)


    """2487. Remove Nodes From Linked List (Medium)
    You are given the head of a linked list. Remove every node which has a node
    with a strictly greater value anywhere to the right side of it. Return the
    head of the modified linked list.

    Example 1:
    Input: head = [5,2,13,3,8]
    Output: [13,8]
    Explanation: The nodes that should be removed are 5, 2 and 3.
                 - Node 13 is to the right of node 5.
                 - Node 13 is to the right of node 2.
                 - Node 8 is to the right of node 3.

    Example 2:
    Input: head = [1,1,1,1]
    Output: [1,1,1,1]
    Explanation: Every node has value 1, so no nodes are removed.

    Constraints:
    * The number of the nodes in the given list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5"""

    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        stack = []
        node = head
        while node:
            while stack and stack[-1].val < node.val: stack.pop()
            if stack: stack[-1].next = node
            stack.append(node)
            node = node.next
        return stack[0]


    """2488. Count Subarrays With Median K (Hard)
    You are given an array nums of size n consisting of distinct integers from
    1 to n and a positive integer k. Return the number of non-empty subarrays
    in nums that have a median equal to k.

    Note:
    * The median of an array is the middle element after sorting the array in
      ascending order. If the array is of even length, the median is the left
      middle element.
      + For example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1]
        is 4.
    * A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [3,2,1,4,5], k = 4
    Output: 3
    Explanation: The subarrays that have a median equal to 4 are: [4], [4,5]
                 and [1,4,5].

    Example 2:
    Input: nums = [2,3,1], k = 3
    Output: 1
    Explanation: [3] is the only subarray that has a median equal to 3.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 1 <= nums[i], k <= n
    * The integers in nums are distinct."""

    def countSubarrays(self, nums: List[int], k: int) -> int:
        freq = Counter({0 : 1})
        ans = diff = found = 0
        for x in nums:
            if x < k: diff -= 1
            elif x > k: diff += 1
            else: found = 1
            if found: ans += freq[diff] + freq[diff-1]
            else: freq[diff] += 1
        return ans


    """2489. Number of Substrings With Fixed Ratio (Medium)
    You are given a binary string s, and two integers num1 and num2. num1 and
    num2 are coprime numbers. A ratio substring is a substring of s where the
    ratio between the number of 0's and the number of 1's in the substring is
    exactly num1 : num2.
    * For example, if num1 = 2 and num2 = 3, then "01011" and "1110000111" are
      ratio substrings, while "11000" is not.
    Return the number of non-empty ratio substrings of s.

    Note that:
    * A substring is a contiguous sequence of characters within a string.
    * Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the
      greatest common divisor of x and y.

    Example 1:
    Input: s = "0110011", num1 = 1, num2 = 2
    Output: 4
    Explanation: There exist 4 non-empty ratio substrings.
                 - The substring s[0..2]: "0110011". It contains one 0 and two
                   1's. The ratio is 1 : 2.
                 - The substring s[1..4]: "0110011". It contains one 0 and two
                   1's. The ratio is 1 : 2.
                 - The substring s[4..6]: "0110011". It contains one 0 and two
                   1's. The ratio is 1 : 2.
                 - The substring s[1..6]: "0110011". It contains two 0's and
                   four 1's. The ratio is 2 : 4 == 1 : 2.
                 It can be shown that there are no more ratio substrings.

    Example 2:
    Input: s = "10101", num1 = 3, num2 = 1
    Output: 0
    Explanation: There is no ratio substrings of s. We return 0.

    Constraints:
    * 1 <= s.length <= 10^5
    * 1 <= num1, num2 <= s.length
    * num1 and num2 are coprime integers."""

    def fixedRatio(self, s: str, num1: int, num2: int) -> int:
        ans = prefix = 0
        freq = Counter({0 : 1})
        for ch in s:
            if ch == '0': prefix += num2
            else: prefix -= num1
            ans += freq[prefix]
            freq[prefix] += 1
        return ans


    """2492. Minimum Score of a Path Between Two Cities (Medium)
    You are given a positive integer n representing n cities numbered from 1 to
    n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei]
    indicates that there is a bidirectional road between cities ai and bi with
    a distance equal to distancei. The cities graph is not necessarily
    connected. The score of a path between two cities is defined as the minimum
    distance of a road in this path. Return the minimum possible score of a
    path between cities 1 and n.

    Note:
    * A path is a sequence of roads between two cities.
    * It is allowed for a path to contain the same road multiple times, and you
      can visit cities 1 and n multiple times along the path.
    * The test cases are generated such that there is at least one path between
      1 and n.

    Example 1:
    Input: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]
    Output: 5
    Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 ->
                 4. The score of this path is min(9,5) = 5. It can be shown
                 that no other path has less score.

    Example 2:
    Input: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]
    Output: 2
    Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 ->
                 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= roads.length <= 10^5
    * roads[i].length == 3
    * 1 <= ai, bi <= n
    * ai != bi
    * 1 <= distancei <= 10^4
    * There are no repeated edges.
    * There is at least one path between 1 and n."""

    def minScore(self, n: int, roads: List[List[int]]) -> int:
        parent = list(range(n))

        def find(p):
            """Return parent of p."""
            if p != parent[p]: parent[p] = find(parent[p])
            return parent[p]

        mp = defaultdict(lambda : inf)
        for u, v, dist in roads:
            uu = find(u-1)
            vv = find(v-1)
            parent[uu] = vv
            mp[uu] = mp[vv] = min(mp[uu], mp[vv], dist)
        return mp[find(0)] if find(0) == find(n-1) else -1


    """2495. Number of Subarrays Having Even Product (Medium)
    Given a 0-indexed integer array nums, return the number of subarrays of
    nums having an even product.

    Example 1:
    Input: nums = [9,6,7,13]
    Output: 6
    Explanation: There are 6 subarrays with an even product:
                 - nums[0..1] = 9 * 6 = 54.
                 - nums[0..2] = 9 * 6 * 7 = 378.
                 - nums[0..3] = 9 * 6 * 7 * 13 = 4914.
                 - nums[1..1] = 6.
                 - nums[1..2] = 6 * 7 = 42.
                 - nums[1..3] = 6 * 7 * 13 = 546.

    Example 2:
    Input: nums = [7,3,5]
    Output: 0
    Explanation: There are no subarrays with an even product.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def evenProduct(self, nums: List[int]) -> int:
        ans = val = 0
        for i, x in enumerate(nums):
            if not x&1: val = i+1
            ans += val
        return ans


    """2496. Maximum Value of a String in an Array (Easy)
    The value of an alphanumeric string can be defined as:
    * The numeric representation of the string in base 10, if it comprises of
      digits only.
    * The length of the string, otherwise.
    Given an array strs of alphanumeric strings, return the maximum value of
    any string in strs.

    Example 1:
    Input: strs = ["alic3","bob","3","4","00000"]
    Output: 5
    Explanation: - "alic3" consists of both letters and digits, so its value is
                   its length, i.e. 5.
                 - "bob" consists only of letters, so its value is also its
                   length, i.e. 3.
                 - "3" consists only of digits, so its value is its numeric
                   equivalent, i.e. 3.
                 - "4" also consists only of digits, so its value is 4.
                 - "00000" consists only of digits, so its value is 0.
                 Hence, the maximum value is 5, of "alic3".

    Example 2:
    Input: strs = ["1","01","001","0001"]
    Output: 1
    Explanation: Each string in the array has value 1. Hence, we return 1.

    Constraints:
    * 1 <= strs.length <= 100
    * 1 <= strs[i].length <= 9
    * strs[i] consists of only lowercase English letters and digits."""

    def maximumValue(self, strs: List[str]) -> int:
        return max(int(x) if x.isdigit() else len(x) for x in strs)


    """2497. Maximum Star Sum of a Graph (Medium)
    There is an undirected graph consisting of n nodes numbered from 0 to n - 1.
    You are given a 0-indexed integer array vals of length n where vals[i]
    denotes the value of the ith node. You are also given a 2D integer array
    edges where edges[i] = [ai, bi] denotes that there exists an undirected
    edge connecting nodes ai and bi. A star graph is a subgraph of the given
    graph having a center node containing 0 or more neighbors. In other words,
    it is a subset of edges of the given graph such that there exists a common
    node for all edges. The image below shows star graphs with 3 and 4
    neighbors respectively, centered at the blue node. The star sum is the sum
    of the values of all the nodes present in the star graph. Given an integer
    k, return the maximum star sum of a star graph containing at most k edges.

    Example 1:
    Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2
    Output: 16
    Explanation: The above diagram represents the input graph. The star graph
                 with the maximum star sum is denoted by blue. It is centered
                 at 3 and includes its neighbors 1 and 4. It can be shown it is
                 not possible to get a star graph with a sum greater than 16.

    Example 2:
    Input: vals = [-5], edges = [], k = 0
    Output: -5
    Explanation: There is only one possible star graph, which is node 0 itself.
                 Hence, we return -5.

    Constraints:
    * n == vals.length
    * 1 <= n <= 10^5
    * -104 <= vals[i] <= 10^4
    * 0 <= edges.length <= min(n * (n - 1) / 2, 10^5)
    * edges[i].length == 2
    * 0 <= ai, bi <= n - 1
    * ai != bi
    * 0 <= k <= n - 1"""

    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        n = len(vals)
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        ans = -inf
        for i, u in enumerate(graph):
            u.sort(key=vals.__getitem__, reverse=True)
            cand = vals[i] + sum(max(0, vals[x]) for x in u[:k])
            ans = max(ans, cand)
        return ans


    """2498. Frog Jump II (Medium)
    You are given a 0-indexed integer array stones sorted in strictly
    increasing order representing the positions of stones in a river. A frog,
    initially on the first stone, wants to travel to the last stone and then
    return to the first stone. However, it can jump to any stone at most once.
    The length of a jump is the absolute difference between the position of the
    stone the frog is currently on and the position of the stone to which the
    frog jumps. More formally, if the frog is at stones[i] and is jumping to
    stones[j], the length of the jump is |stones[i] - stones[j]|. The cost of a
    path is the maximum length of a jump among all jumps in the path. Return
    the minimum cost of a path for the frog.

    Example 1:
    Input: stones = [0,2,5,6,7]
    Output: 5
    Explanation: The above figure represents one of the optimal paths the frog
                 can take. The cost of this path is 5, which is the maximum
                 length of a jump. Since it is not possible to achieve a cost
                 of less than 5, we return it.

    Example 2:
    Input: stones = [0,3,9]
    Output: 9
    Explanation: The frog can jump directly to the last stone and come back to
                 the first stone. In this case, the length of each jump will be
                 9. The cost for the path will be max(9, 9) = 9. It can be
                 shown that this is the minimum achievable cost.

    Constraints:
    * 2 <= stones.length <= 10^5
    * 0 <= stones[i] <= 10^9
    * stones[0] == 0
    * stones is sorted in a strictly increasing order."""

    def maxJump(self, stones: List[int]) -> int:
        ans = stones[1]
        for i in range(2, len(stones)):
            ans = max(ans, stones[i] - stones[i-2])
        return ans


    """2499. Minimum Total Cost to Make Arrays Unequal (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2, of equal length
    n. In one operation, you can swap the values of any two indices of nums1.
    The cost of this operation is the sum of the indices. Find the minimum
    total cost of performing the given operation any number of times such that
    nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the
    operations. Return the minimum total cost such that nums1 and nums2 satisfy
    the above condition. In case it is not possible, return -1.

    Example 1:
    Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]
    Output: 10
    Explanation: One of the ways we can perform the operations is:
                 - Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3.
                   Now, nums1 = [4,2,3,1,5]
                 - Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3.
                   Now, nums1 = [4,3,2,1,5].
                 - Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4.
                   Now, nums1 =[5,3,2,1,4].
                 We can see that for each index i, nums1[i] != nums2[i]. The
                 cost required here is 10. Note that there are other ways to
                 swap values, but it can be proven that it is not possible to
                 obtain a cost less than 10.

    Example 2:
    Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]
    Output: 10
    Explanation: One of the ways we can perform the operations is:
                 - Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5.
                   Now, nums1 = [2,2,1,2,3].
                 - Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5.
                   Now, nums1 = [2,3,1,2,2].
                 The total cost needed here is 10, which is the minimum
                 possible.

    Example 3:
    Input: nums1 = [1,2,2], nums2 = [1,2,2]
    Output: -1
    Explanation: It can be shown that it is not possible to satisfy the given
                 conditions irrespective of the number of operations we
                 perform. Hence, we return -1.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= n"""

    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        ans = total = 0
        freq = Counter()
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if x == y:
                freq[x] += 1
                total += 1
                ans += i
        key = max(freq, key=freq.get, default=None)
        most = freq[key]
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            if 2*most <= total: break
            if len({x, y, key}) == 3:
                total += 1
                ans += i
        return ans if 2*most <= total else -1


    """2500. Delete Greatest Value in Each Row (Easy)
    You are given an m x n matrix grid consisting of positive integers. Perform
    the following operation until grid becomes empty:
    * Delete the element with the greatest value from each row. If multiple
      such elements exist, delete any of them.
    * Add the maximum of deleted elements to the answer.
    Note that the number of columns decreases by one after each operation.
    Return the answer after performing the operations described above.

    Example 1:
    Input: grid = [[1,2,4],[3,3,1]]
    Output: 8
    Explanation: The diagram above shows the removed values in each step.
                 - In the first operation, we remove 4 from the first row and 3
                   from the second row (notice that, there are two cells with
                   value 3 and we can remove any of them). We add 4 to the
                   answer.
                 - In the second operation, we remove 2 from the first row and
                   3 from the second row. We add 3 to the answer.
                 - In the third operation, we remove 1 from the first row and 1
                   from the second row. We add 1 to the answer.
                 The final answer = 4 + 3 + 1 = 8.

    Example 2:
    Input: grid = [[10]]
    Output: 10
    Explanation: The diagram above shows the removed values in each step.
                 - In the first operation, we remove 10 from the first row. We
                   add 10 to the answer.
                 The final answer = 10.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * 1 <= grid[i][j] <= 100"""

    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        for row in grid: row.sort()
        return sum(max(col) for col in zip(*grid))


    """2501. Longest Square Streak in an Array (Medium)
    You are given an integer array nums. A subsequence of nums is called a
    square streak if:
    * The length of the subsequence is at least 2, and
    * after sorting the subsequence, each element (except the first element) is
      the square of the previous number.
    Return the length of the longest square streak in nums, or return -1 if
    there is no square streak. A subsequence is an array that can be derived
    from another array by deleting some or no elements without changing the
    order of the remaining elements.

    Example 1:
    Input: nums = [4,3,6,16,8,2]
    Output: 3
    Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes
                 [2,4,16].
                 - 4 = 2 * 2.
                 - 16 = 4 * 4.
                 Therefore, [4,16,2] is a square streak. It can be shown that
                 every subsequence of length 4 is not a square streak.

    Example 2:
    Input: nums = [2,3,5,6,7]
    Output: -1
    Explanation: There is no square streak in nums so return -1.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 2 <= nums[i] <= 10^5"""

    def longestSquareStreak(self, nums: List[int]) -> int:
        dp = defaultdict(int)
        for x in sorted(nums):
            dp[x] = max(dp[x], 1)
            v = isqrt(x)
            if v**2 == x: dp[x] = 1 + dp[v]
        ans = max(dp.values())
        return ans if ans > 1 else -1


    """2503. Maximum Number of Points From Grid Queries (Hard)
    You are given an m x n integer matrix grid and an array queries of size k.
    Find an array answer of size k such that for each integer queres[i] you
    start in the top left cell of the matrix and repeat the following process:
    * If queries[i] is strictly greater than the value of the current cell that
      you are in, then you get one point if it is your first time visiting this
      cell, and you can move to any adjacent cell in all 4 directions: up, down,
      left, and right.
    * Otherwise, you do not get any points, and you end this process.
    After the process, answer[i] is the maximum number of points you can get.
    Note that for each query you are allowed to visit the same cell multiple
    times. Return the resulting array answer.

    Example 1:
    Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]
    Output: [5,8,1]
    Explanation: The diagrams above show which cells we visit to get points for
                 each query.

    Example 2:
    Input: grid = [[5,2,1],[1,1,2]], queries = [3]
    Output: [0]
    Explanation: We can not get any points because the value of the top left
                 cell is already greater than or equal to 3.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 1000
    * 4 <= m * n <= 10^5
    * k == queries.length
    * 1 <= k <= 10^4
    * 1 <= grid[i][j], queries[i] <= 10^6"""

    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:
        m, n = len(grid), len(grid[0])
        point = []
        prefix = 0
        prev = -inf
        pq = [(grid[0][0], 0, 0)]
        grid[0][0] = 0
        while pq:
            v, i, j = heappop(pq)
            if prev != v: point.append((prev, prefix))
            prefix += 1
            prev = v
            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]:
                    vv = max(v, grid[ii][jj])
                    heappush(pq, (vv, ii, jj))
                    grid[ii][jj] = 0
        point.append((prev, prefix))
        ans = []
        for q in queries:
            i = bisect_left(point, q, key=lambda x: x[0]) - 1
            ans.append(point[i][1])
        return ans


    """2505. Bitwise OR of All Subsequence Sums (Medium)
    Given an integer array nums, return the value of the bitwise OR of the sum
    of all possible subsequences in the array. A subsequence is a sequence that
    can be derived from another sequence by removing zero or more elements
    without changing the order of the remaining elements.

    Example 1:
    Input: nums = [2,1,0,3]
    Output: 7
    Explanation: All possible subsequence sums that we can have are:
                 0, 1, 2, 3, 4, 5, 6. And we have
                 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 = 7, so we return 7.

    Example 2:
    Input: nums = [0,0,0]
    Output: 0
    Explanation: 0 is the only possible subsequence sum we can have, so we
                 return 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9"""

    def subsequenceSumOr(self, nums: List[int]) -> int:
        ans = prefix = 0
        for x in nums:
            prefix += x
            ans |= x | prefix
        return ans


    """2506. Count Pairs Of Similar Strings (Easy)
    You are given a 0-indexed string array words. Two strings are similar if
    they consist of the same characters.
    * For example, "abca" and "cba" are similar since both consist of
      characters 'a', 'b', and 'c'.
    * However, "abacba" and "bcfd" are not similar since they do not consist of
      the same characters.
    Return the number of pairs (i, j) such that 0 <= i < j <= word.length - 1
    and the two strings words[i] and words[j] are similar.

    Example 1:
    Input: words = ["aba","aabb","abcd","bac","aabc"]
    Output: 2
    Explanation: There are 2 pairs that satisfy the conditions:
                 - i = 0 and j = 1 : both words[0] and words[1] only consist of
                   characters 'a' and 'b'.
                 - i = 3 and j = 4 : both words[3] and words[4] only consist of
                   characters 'a', 'b', and 'c'.

    Example 2:
    Input: words = ["aabb","ab","ba"]
    Output: 3
    Explanation: There are 3 pairs that satisfy the conditions:
                 - i = 0 and j = 1 : both words[0] and words[1] only consist of
                   characters 'a' and 'b'.
                 - i = 0 and j = 2 : both words[0] and words[2] only consist of
                   characters 'a' and 'b'.
                 - i = 1 and j = 2 : both words[1] and words[2] only consist of
                   characters 'a' and 'b'.

    Example 3:
    Input: words = ["nba","cba","dba"]
    Output: 0
    Explanation: Since there does not exist any pair that satisfies the
                 conditions, we return 0.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consist of only lowercase English letters."""

    def similarPairs(self, words: List[str]) -> int:
        ans = 0
        freq = Counter()
        for word in words:
            mask = reduce(or_, (1<<ord(ch)-97 for ch in word))
            ans += freq[mask]
            freq[mask] += 1
        return ans


    """2507. Smallest Value After Replacing With Sum of Prime Factors (Medium)
    You are given a positive integer n. Continuously replace n with the sum of
    its prime factors.
    * Note that if a prime factor divides n multiple times, it should be
      included in the sum as many times as it divides n.
    Return the smallest value n will take on.

    Example 1:
    Input: n = 15
    Output: 5
    Explanation: Initially, n = 15.
                 15 = 3 * 5, so replace n with 3 + 5 = 8.
                 8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.
                 6 = 2 * 3, so replace n with 2 + 3 = 5.
                 5 is the smallest value n will take on.

    Example 2:
    Input: n = 3
    Output: 3
    Explanation: Initially, n = 3. 3 is the smallest value n will take on.

    Constraints: 2 <= n <= 10^5"""

    def smallestValue(self, n: int) -> int:
        while True:
            nn, sm = n, 0
            for f in range(2, nn+1):
                while nn % f == 0:
                    nn //= f
                    sm += f
            if sm == n: break
            n = sm
        return n


    """2508. Add Edges to Make Degrees of All Nodes Even (Hard)
    There is an undirected graph consisting of n nodes numbered from 1 to n.
    You are given the integer n and a 2D array edges where edges[i] = [ai, bi]
    indicates that there is an edge between nodes ai and bi. The graph can be
    disconnected. You can add at most two additional edges (possibly none) to
    this graph so that there are no repeated edges and no self-loops. Return
    true if it is possible to make the degree of each node in the graph even,
    otherwise return false. The degree of a node is the number of edges
    connected to it.

    Example 1:
    Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]
    Output: true
    Explanation: The above diagram shows a valid way of adding an edge. Every
                 node in the resulting graph is connected to an even number of
                 edges.

    Example 2:
    Input: n = 4, edges = [[1,2],[3,4]]
    Output: true
    Explanation: The above diagram shows a valid way of adding two edges.

    Example 3:
    Input: n = 4, edges = [[1,2],[1,3],[1,4]]
    Output: false
    Explanation: It is not possible to obtain a valid graph with adding at most
                 2 edges.

    Constraints:
    * 3 <= n <= 10^5
    * 2 <= edges.length <= 10^5
    * edges[i].length == 2
    * 1 <= ai, bi <= n
    * ai != bi
    * There are no repeated edges."""

    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        seen = set()
        degree = [0]*n
        for u, v in edges:
            degree[u-1] += 1
            degree[v-1] += 1
            seen.add((u-1, v-1))
            seen.add((v-1, u-1))
        odd = []
        for i, x in enumerate(degree):
            if x & 1: odd.append(i)
        if len(odd) == 0: return True
        if len(odd) == 2: return any((u, odd[0]) not in seen and (u, odd[1]) not in seen for u in range(n))
        if len(odd) == 4: return (odd[0], odd[1]) not in seen and (odd[2], odd[3]) not in seen or (odd[0], odd[2]) not in seen and (odd[1], odd[3]) not in seen or (odd[0], odd[3]) not in seen and (odd[1], odd[2]) not in seen
        return False


    """2509. Cycle Length Queries in a Tree (Hard)
    You are given an integer n. There is a complete binary tree with 2n - 1
    nodes. The root of that tree is the node with the value 1, and every node
    with a value val in the range [1, 2n - 1 - 1] has two children where:
    * The left node has the value 2 * val, and
    * The right node has the value 2 * val + 1.
    You are also given a 2D integer array queries of length m, where
    queries[i] = [ai, bi]. For each query, solve the following problem:
    * Add an edge between the nodes with values ai and bi.
    * Find the length of the cycle in the graph.
    * Remove the added edge between nodes with values ai and bi.
    Note that:
    * A cycle is a path that starts and ends at the same node, and each edge in
      the path is visited only once.
    * The length of a cycle is the number of edges visited in the cycle.
    * There could be multiple edges between two nodes in the tree after adding
      the edge of the query.
    Return an array answer of length m where answer[i] is the answer to the ith
    query.

    Example 1:
    Input: n = 3, queries = [[5,3],[4,7],[2,3]]
    Output: [4,5,3]
    Explanation: The diagrams above show the tree of 23 - 1 nodes. Nodes
                 colored in red describe the nodes in the cycle after adding
                 the edge.
                 - After adding the edge between nodes 3 and 5, the graph
                   contains a cycle of nodes [5,2,1,3]. Thus answer to the
                   first query is 4. We delete the added edge and process the
                   next query.
                 - After adding the edge between nodes 4 and 7, the graph
                   contains a cycle of nodes [4,2,1,3,7]. Thus answer to the
                   second query is 5. We delete the added edge and process the
                   next query.
                 - After adding the edge between nodes 2 and 3, the graph
                   contains a cycle of nodes [2,1,3]. Thus answer to the third
                   query is 3. We delete the added edge.

    Example 2:
    Input: n = 2, queries = [[1,2]]
    Output: [2]
    Explanation: The diagram above shows the tree of 22 - 1 nodes. Nodes
                 colored in red describe the nodes in the cycle after adding
                 the edge.
                 - After adding the edge between nodes 1 and 2, the graph
                   contains a cycle of nodes [2,1]. Thus answer for the first
                   query is 2. We delete the added edge.

    Constraints:
    * 2 <= n <= 30
    * m == queries.length
    * 1 <= m <= 10^5
    * queries[i].length == 2
    * 1 <= ai, bi <= 2n - 1
    * ai != bi"""

    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        ans = []
        for u, v in queries:
            dist = 1
            while u != v:
                if u < v: u, v = v, u
                u //= 2
                dist += 1
            ans.append(dist)
        return ans


    """2510. Check if There is a Path With Equal Number of 0's And 1's (Medium)
    You are given a 0-indexed m x n binary matrix grid. You can move from a
    cell (row, col) to any of the cells (row + 1, col) or (row, col + 1).
    Return true if there is a path from (0, 0) to (m - 1, n - 1) that visits an
    equal number of 0's and 1's. Otherwise return false.

    Example 1:
    Input: grid = [[0,1,0,0],[0,1,0,0],[1,0,1,0]]
    Output: true
    Explanation: The path colored in blue in the above diagram is a valid path
                 because we have 3 cells with a value of 1 and 3 with a value
                 of 0. Since there is a valid path, we return true.

    Example 2:
    Input: grid = [[1,1,0],[0,0,1],[1,0,0]]
    Output: false
    Explanation: There is no path in this grid with an equal number of 0's and
                 1's.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 100
    * grid[i][j] is either 0 or 1."""

    def isThereAPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        if (m+n) & 1:
            lo = [[inf]*n for _ in range(m)]
            hi = [[-inf]*n for _ in range(m)]
            lo[0][0] = hi[0][0] = 2*grid[0][0]-1
            for i in range(m):
                for j in range(n):
                    if i:
                        lo[i][j] = min(lo[i][j], lo[i-1][j] + 2*grid[i][j]-1)
                        hi[i][j] = max(hi[i][j], hi[i-1][j] + 2*grid[i][j]-1)
                    if j:
                        lo[i][j] = min(lo[i][j], lo[i][j-1] + 2*grid[i][j]-1)
                        hi[i][j] = max(hi[i][j], hi[i][j-1] + 2*grid[i][j]-1)
            return lo[-1][-1] <= 0 <= hi[-1][-1]


    """2511. Maximum Enemy Forts That Can Be Captured (Easy)
    You are given a 0-indexed integer array forts of length n representing the
    positions of several forts. forts[i] can be -1, 0, or 1 where:
    * -1 represents there is no fort at the ith position.
    * 0 indicates there is an enemy fort at the ith position.
    * 1 indicates the fort at the ith the position is under your command.
    Now you have decided to move your army from one of your forts at position i
    to an empty position j such that:
    * 0 <= i, j <= n - 1
    * The army travels over enemy forts only. Formally, for all k where
      min(i,j) < k < max(i,j), forts[k] == 0.
    While moving the army, all the enemy forts that come in the way are
    captured. Return the maximum number of enemy forts that can be captured. In
    case it is impossible to move your army, or you do not have any fort under
    your command, return 0.

    Example 1:
    Input: forts = [1,0,0,-1,0,0,0,0,1]
    Output: 4
    Explanation: - Moving the army from position 0 to position 3 captures 2
                   enemy forts, at 1 and 2.
                 - Moving the army from position 8 to position 3 captures 4
                   enemy forts.
                 Since 4 is the maximum number of enemy forts that can be
                 captured, we return 4.

    Example 2:
    Input: forts = [0,0,1,-1]
    Output: 0
    Explanation: Since no enemy fort can be captured, 0 is returned.

    Constraints:
    * 1 <= forts.length <= 1000
    * -1 <= forts[i] <= 1"""

    def captureForts(self, forts: List[int]) -> int:
        ans = ii = 0
        for i, x in enumerate(forts):
            if x:
                if forts[ii] == -x: ans = max(ans, i-ii-1)
                ii = i
        return ans


    """2512. Reward Top K Students (Medium)
    You are given two string arrays positive_feedback and negative_feedback,
    containing the words denoting positive and negative feedback, respectively.
    Note that no word is both positive and negative. Initially every student
    has 0 points. Each positive word in a feedback report increases the points
    of a student by 3, whereas each negative word decreases the points by 1.
    You are given n feedback reports, represented by a 0-indexed string array
    report and a 0-indexed integer array student_id, where student_id[i]
    represents the ID of the student who has received the feedback report
    report[i]. The ID of each student is unique. Given an integer k, return
    the top k students after ranking them in non-increasing order by their
    points. In case more than one student has the same points, the one with the
    lower ID ranks higher.

    Example 1:
    Input: positive_feedback = ["smart","brilliant","studious"],
           negative_feedback = ["not"],
           report = ["this student is studious","the student is smart"],
           student_id = [1,2], k = 2
    Output: [1,2]
    Explanation: Both the students have 1 positive feedback and 3 points but
                 since student 1 has a lower ID he ranks higher.

    Example 2:
    Input: positive_feedback = ["smart","brilliant","studious"],
           negative_feedback = ["not"],
           report = ["this student is not studious","the student is smart"],
           student_id = [1,2], k = 2
    Output: [2,1]
    Explanation: - The student with ID 1 has 1 positive feedback and 1 negative
                   feedback, so he has 3-1=2 points.
                 - The student with ID 2 has 1 positive feedback, so he has 3
                   points.
                 Since student 2 has more points, [2,1] is returned.

    Constraints:
    * 1 <= positive_feedback.length, negative_feedback.length <= 10^4
    * 1 <= positive_feedback[i].length, negative_feedback[j].length <= 100
    * Both positive_feedback[i] and negative_feedback[j] consists of lowercase
      English letters.
    * No word is present in both positive_feedback and negative_feedback.
    * n == report.length == student_id.length
    * 1 <= n <= 10^4
    * report[i] consists of lowercase English letters and spaces ' '.
    * There is a single space between consecutive words of report[i].
    * 1 <= report[i].length <= 100
    * 1 <= student_id[i] <= 10^9
    * All the values of student_id[i] are unique.
    * 1 <= k <= n"""

    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:
        positive = set(positive_feedback)
        negative = set(negative_feedback)
        mp = {}
        for sentence, i in zip(report, student_id):
            point = 0
            for word in sentence.split():
                if word in positive: point += 3
                elif word in negative: point -= 1
            mp[i] = point
        return sorted(mp, key=lambda x: (-mp[x], x))[:k]


    """2513. Minimize the Maximum of Two Arrays (Medium)
    We have two arrays arr1 and arr2 which are initially empty. You need to add
    positive integers to them such that they satisfy all the following
    conditions:
    * arr1 contains uniqueCnt1 distinct positive integers, each of which is not
      divisible by divisor1.
    * arr2 contains uniqueCnt2 distinct positive integers, each of which is not
      divisible by divisor2.
    * No integer is present in both arr1 and arr2.
    Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum
    possible maximum integer that can be present in either array.

    Example 1:
    Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3
    Output: 4
    Explanation: We can distribute the first 4 natural numbers into arr1 and
                 arr2. arr1 = [1] and arr2 = [2,3,4]. We can see that both
                 arrays satisfy all the conditions. Since the maximum value is
                 4, we return it.

    Example 2:
    Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1
    Output: 3
    Explanation: Here arr1 = [1,2], and arr2 = [3] satisfy all conditions.
                 Since the maximum value is 3, we return it.

    Example 3:
    Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2
    Output: 15
    Explanation: Here, the final possible arrays can be
                 arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6]. It can be shown
                 that it is not possible to obtain a lower maximum satisfying
                 all conditions.

    Constraints:
    * 2 <= divisor1, divisor2 <= 10^5
    * 1 <= uniqueCnt1, uniqueCnt2 < 10^9
    * 2 <= uniqueCnt1 + uniqueCnt2 <= 10^9"""

    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:
        lo, hi = 0, 1<<32-1
        mult = lcm(divisor1, divisor2)
        while lo < hi:
            mid = lo + hi >> 1
            if uniqueCnt1 <= mid-mid//divisor1 and uniqueCnt2 <= mid-mid//divisor2 and uniqueCnt1+uniqueCnt2 <= mid-mid//mult: hi = mid
            else: lo = mid+1
        return lo


    """2514. Count Anagrams (Hard)
    You are given a string s containing one or more words. Every consecutive
    pair of words is separated by a single space ' '. A string t is an anagram
    of string s if the ith word of t is a permutation of the ith word of s.
    * For example, "acb dfe" is an anagram of "abc def", but "def cab" and
      "adc bef" are not.
    Return the number of distinct anagrams of s. Since the answer may be very
    large, return it modulo 10^9 + 7.

    Example 1:
    Input: s = "too hot"
    Output: 18
    Explanation: Some of the anagrams of the given string are "too hot",
                 "oot hot", "oto toh", "too toh", and "too oht".

    Example 2:
    Input: s = "aa"
    Output: 1
    Explanation: There is only one anagram possible for the given string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters and spaces ' '.
    * There is single space between consecutive words."""

    def countAnagrams(self, s: str) -> int:
        n = len(s)
        mod = 1_000_000_007
        inv = [1]*(n+1)
        fact = [1]*(n+1)
        ifact = [1]*(n+1)
        for x in range(1, n+1):
            if x >= 2: inv[x] = mod - mod//x * inv[mod % x] % mod
            fact[x] = fact[x-1] * x % mod
            ifact[x] = ifact[x-1] * inv[x] % mod
        ans = 1
        for word in s.split():
            ans *= fact[len(word)]
            for x in Counter(word).values(): ans *= ifact[x]
            ans %= mod
        return ans


    """2515. Shortest Distance to Target String in a Circular Array (Easy)
    You are given a 0-indexed circular string array words and a string target.
    A circular array means that the array's end connects to the array's
    beginning.
    * Formally, the next element of words[i] is words[(i + 1) % n] and the
      previous element of words[i] is words[(i - 1 + n) % n], where n is the
      length of words.
    Starting from startIndex, you can move to either the next word or the
    previous word with 1 step at a time. Return the shortest distance needed to
    reach the string target. If the string target does not exist in words,
    return -1.

    Example 1:
    Input: words = ["hello","i","am","leetcode","hello"], target = "hello", startIndex = 1
    Output: 1
    Explanation: We start from index 1 and can reach "hello" by
                 - moving 3 units to the right to reach index 4.
                 - moving 2 units to the left to reach index 4.
                 - moving 4 units to the right to reach index 0.
                 - moving 1 unit to the left to reach index 0.
                 The shortest distance to reach "hello" is 1.

    Example 2:
    Input: words = ["a","b","leetcode"], target = "leetcode", startIndex = 0
    Output: 1
    Explanation: We start from index 0 and can reach "leetcode" by
                 - moving 2 units to the right to reach index 3.
                 - moving 1 unit to the left to reach index 3.
                 The shortest distance to reach "leetcode" is 1.

    Example 3:
    Input: words = ["i","eat","leetcode"], target = "ate", startIndex = 0
    Output: -1
    Explanation: Since "ate" does not exist in words, we return -1.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] and target consist of only lowercase English letters.
    * 0 <= startIndex < words.length"""

    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:
        ans = inf
        for i, word in enumerate(words):
            if word == target:
                dist = abs(i - startIndex)
                ans = min(ans, dist, len(words) - dist)
        return ans if ans < inf else -1


    """2516. Take K of Each Character From Left and Right (Medium)
    You are given a string s consisting of the characters 'a', 'b', and 'c' and
    a non-negative integer k. Each minute, you may take either the leftmost
    character of s, or the rightmost character of s. Return the minimum number
    of minutes needed for you to take at least k of each character, or return
    -1 if it is not possible to take k of each character.

    Example 1:
    Input: s = "aabaaaacaabc", k = 2
    Output: 8
    Explanation: Take three characters from the left of s. You now have two 'a'
                 characters, and one 'b' character. Take five characters from
                 the right of s. You now have four 'a' characters, two 'b'
                 characters, and two 'c' characters. A total of 3 + 5 = 8
                 minutes is needed. It can be proven that 8 is the minimum
                 number of minutes needed.

    Example 2:
    Input: s = "a", k = 1
    Output: -1
    Explanation: It is not possible to take one 'b' or 'c' so return -1.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of only the letters 'a', 'b', and 'c'.
    * 0 <= k <= s.length"""

    def takeCharacters(self, s: str, k: int) -> int:
        freq = [0] * 3
        ans = inf
        ii = 0
        n = len(s)
        for i, ch in enumerate(s+s):
            freq[ord(ch)-97] += 1
            while ii < n and i >= n-1 and freq[ord(s[ii])-97] > k and min(freq) >= k:
                ans = min(ans, i-ii)
                freq[ord(s[ii])-97] -= 1
                ii += 1
        return ans if ans <= len(s) else -1


    """2517. Maximum Tastiness of Candy Basket (Medium)
    You are given an array of positive integers price where price[i] denotes
    the price of the ith candy and a positive integer k. The store sells
    baskets of k distinct candies. The tastiness of a candy basket is the
    smallest absolute difference of the prices of any two candies in the basket.
    Return the maximum tastiness of a candy basket.

    Example 1:
    Input: price = [13,5,1,8,21,2], k = 3
    Output: 8
    Explanation: Choose the candies with the prices [13,5,21]. The tastiness of
                 the candy basket is:
                 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8. It can
                 be proven that 8 is the maximum tastiness that can be achieved.

    Example 2:
    Input: price = [1,3,1], k = 2
    Output: 2
    Explanation: Choose the candies with the prices [1,3]. The tastiness of the
                 candy basket is: min(|1 - 3|) = min(2) = 2. It can be proven
                 that 2 is the maximum tastiness that can be achieved.

    Example 3:
    Input: price = [7,7,7,7], k = 2
    Output: 0
    Explanation: Choosing any two distinct candies from the candies we have
                 will result in a tastiness of 0.

    Constraints:
    * 1 <= price.length <= 10^5
    * 1 <= price[i] <= 10^9
    * 2 <= k <= price.length"""

    def maximumTastiness(self, price: List[int], k: int) -> int:
        price.sort()
        lo, hi = 0, price[-1] - price[0]
        while lo < hi:
            mid = lo + hi +1 >> 1
            val = price[0]
            cnt = 0
            for x in price:
                if x >= mid + val:
                    cnt += 1
                    val = x
            if cnt >= k-1: lo = mid
            else: hi = mid - 1
        return lo


    """2518. Number of Great Partitions (Hard)
    You are given an array nums consisting of positive integers and an integer
    k. Partition the array into two ordered groups such that each element is in
    exactly one group. A partition is called great if the sum of elements of
    each group is greater than or equal to k. Return the number of distinct
    great partitions. Since the answer may be too large, return it modulo
    10^9 + 7. Two partitions are considered distinct if some element nums[i] is
    in different groups in the two partitions.

    Example 1:
    Input: nums = [1,2,3,4], k = 4
    Output: 6
    Explanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]),
                 ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and
                 ([4], [1,2,3]).

    Example 2:
    Input: nums = [3,3,3], k = 4
    Output: 0
    Explanation: There are no great partitions for this array.

    Example 3:
    Input: nums = [6,6], k = 2
    Output: 2
    Explanation: We can either put nums[0] in the first partition or in the
                 second partition. The great partitions will be ([6], [6]) and
                 ([6], [6]).

    Constraints:
    * 1 <= nums.length, k <= 1000
    * 1 <= nums[i] <= 10^9"""

    def countPartitions(self, nums: List[int], k: int) -> int:
        mod = 1_000_000_007
        if sum(nums) < 2*k: return 0
        dp = [0]*k
        dp[0] = 1
        for x in nums:
            for i in range(k-1-x, -1, -1):
                dp[i+x] += dp[i]
        return (pow(2, len(nums), mod) - 2*sum(dp)) % mod


    """2519. Count the Number of K-Big Indices (Hard)
    You are given a 0-indexed integer array nums and a positive integer k. We
    call an index i k-big if the following conditions are satisfied:
    * There exist at least k different indices idx1 such that idx1 < i and
      nums[idx1] < nums[i].
    * There exist at least k different indices idx2 such that idx2 > i and
      nums[idx2] < nums[i].
    Return the number of k-big indices.

    Example 1:
    Input: nums = [2,3,6,5,2,3], k = 2
    Output: 2
    Explanation: There are only two 2-big indices in nums:
                 - i = 2 --> There are two valid idx1: 0 and 1. There are three
                             valid idx2: 2, 3, and 4.
                 - i = 3 --> There are two valid idx1: 0 and 1. There are two
                             valid idx2: 3 and 4.

    Example 2:
    Input: nums = [1,1,1], k = 3
    Output: 0
    Explanation: There are no 3-big indices in nums.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= nums.length"""

    def kBigIndices(self, nums: List[int], k: int) -> int:
        prefix = [False] * len(nums)
        pq = []
        for i, x in enumerate(nums):
            if len(pq) == k and -pq[0] < x: prefix[i] = True
            heappush(pq, -x)
            if len(pq) > k: heappop(pq)
        ans = 0
        pq = []
        for i, x in reversed(list(enumerate(nums))):
            if len(pq) == k and -pq[0] < x and prefix[i]: ans += 1
            heappush(pq, -x)
            if len(pq) > k: heappop(pq)
        return ans


    """2520. Count the Digits That Divide a Number (Easy)
    Given an integer num, return the number of digits in num that divide num.
    An integer val divides nums if nums % val == 0.

    Example 1:
    Input: num = 7
    Output: 1
    Explanation: 7 divides itself, hence the answer is 1.

    Example 2:
    Input: num = 121
    Output: 2
    Explanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a
                 digit, we return 2.

    Example 3:
    Input: num = 1248
    Output: 4
    Explanation: 1248 is divisible by all of its digits, hence the answer is 4.

    Constraints:
    * 1 <= num <= 10^9
    * num does not contain 0 as one of its digits."""

    def countDigits(self, num: int) -> int:
        return sum(num % int(x) == 0 for x in str(num))


    """2521. Distinct Prime Factors of Product of Array (Medium)
    Given an array of positive integers nums, return the number of distinct
    prime factors in the product of the elements of nums. Note that:
    * A number greater than 1 is called prime if it is divisible by only 1 and
      itself.
    * An integer val1 is a factor of another integer val2 if val2 / val1 is an
      integer.

    Example 1:
    Input: nums = [2,4,3,7,10,6]
    Output: 4
    Explanation: The product of all the elements in nums is:
                 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2^5 * 3^2 * 5 * 7.
                 There are 4 distinct prime factors so we return 4.

    Example 2:
    Input: nums = [2,4,8,16]
    Output: 1
    Explanation: The product of all the elements in nums is:
                 2 * 4 * 8 * 16 = 1024 = 2^10.
                 There is 1 distinct prime factor so we return 1.

    Constraints:
    * 1 <= nums.length <= 10^4
    * 2 <= nums[i] <= 1000"""

    def distinctPrimeFactors(self, nums: List[int]) -> int:
        seen = set()
        for i, x in enumerate(nums):
            f = 2
            while f <= sqrt(x):
                while x % f == 0:
                    x //= f
                    seen.add(f)
                f += 1
            if 1 < x: seen.add(x)
        return len(seen)


    """2522. Partition String Into Substrings With Values at Most K (Medium)
    You are given a string s consisting of digits from 1 to 9 and an integer k.
    A partition of a string s is called good if:
    * Each digit of s is part of exactly one substring.
    * The value of each substring is less than or equal to k.
    Return the minimum number of substrings in a good partition of s. If no
    good partition of s exists, return -1. Note that:
    * The value of a string is its result when interpreted as an integer. For
      example, the value of "123" is 123 and the value of "1" is 1.
    * A substring is a contiguous sequence of characters within a string.

    Example 1:
    Input: s = "165462", k = 60
    Output: 4
    Explanation: We can partition the string into substrings "16", "54", "6",
                 and "2". Each substring has a value less than or equal to
                 k = 60. It can be shown that we cannot partition the string
                 into less than 4 substrings.

    Example 2:
    Input: s = "238182", k = 5
    Output: -1
    Explanation: There is no good partition for this string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is a digit from '1' to '9'.
    * 1 <= k <= 10^9"""

    def minimumPartition(self, s: str, k: int) -> int:
        ans = val = 0
        for ch in s:
            if 10*val + ord(ch) - 48  > k:
                ans += 1
                val = 0
            val = 10*val + ord(ch) - 48
            if val > k: return -1
        return ans + 1


    """2523. Closest Prime Numbers in Range (Medium)
    Given two positive integers left and right, find the two integers num1 and
    num2 such that:
    * left <= nums1 < nums2 <= right .
    * nums1 and nums2 are both prime numbers.
    * nums2 - nums1 is the minimum amongst all other pairs satisfying the above
      conditions.
    Return the positive integer array ans = [nums1, nums2]. If there are
    multiple pairs satisfying these conditions, return the one with the minimum
    nums1 value or [-1, -1] if such numbers do not exist. A number greater than
    1 is called prime if it is only divisible by 1 and itself.

    Example 1:
    Input: left = 10, right = 19
    Output: [11,13]
    Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.
                 The closest gap between any pair is 2, which can be achieved
                 by [11,13] or [17,19]. Since 11 is smaller than 17, we return
                 the first pair.

    Example 2:
    Input: left = 4, right = 6
    Output: [-1,-1]
    Explanation: There exists only one prime number in the given range, so the
                 conditions cannot be satisfied.

    Constraints: 1 <= left <= right <= 10^6"""

    def closestPrimes(self, left: int, right: int) -> List[int]:
        sieve = [True]*(right+1)
        sieve[0] = sieve[1] = False
        for i in range(2, int(sqrt(right))+1):
            if sieve[i]:
                for ii in range(i*i, right+1, i):
                    sieve[ii] = False
        ans = [-1, -1]
        prev = None
        least = inf
        for x in range(left, right+1):
            if sieve[x]:
                if prev and x - prev < least:
                    ans = [prev, x]
                    least = x - prev
                prev = x
        return ans


    """2524. Maximum Frequency Score of a Subarray (Hard)
    You are given an integer array nums and a positive integer k. The frequency
    score of an array is the sum of the distinct values in the array raised to
    the power of their frequencies, taking the sum modulo 10^9 + 7. For example,
    the frequency score of the array [5,4,5,7,4,4] is
    (4^3 + 5^2 + 7^1) modulo (10^9 + 7) = 96. Return the maximum frequency
    score of a subarray of size k in nums. You should maximize the value under
    the modulo and not the actual value. A subarray is a contiguous part of an
    array.

    Example 1:
    Input: nums = [1,1,1,2,1,2], k = 3
    Output: 5
    Explanation: The subarray [2,1,2] has a frequency score equal to 5. It can
                 be shown that it is the maximum frequency score we can have.

    Example 2:
    Input: nums = [1,1,1,1,1,1], k = 4
    Output: 1
    Explanation: All the subarrays of length 4 have a frequency score equal to
                 1.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def maxFrequencyScore(self, nums: List[int], k: int) -> int:
        mod = 1_000_000_007
        ans = val = 0
        freq = Counter()
        for i, x in enumerate(nums):
            if freq[x]: val -= pow(x, freq[x], mod)
            freq[x] += 1
            val += pow(x, freq[x], mod)
            if i >= k:
                val -= pow(nums[i-k], freq[nums[i-k]], mod)
                freq[nums[i-k]] -= 1
                if freq[nums[i-k]]: val += pow(nums[i-k], freq[nums[i-k]], mod)
            val %= mod
            if i >= k-1: ans = max(ans, val)
        return ans


    """2525. Categorize Box According to Criteria (Easy)
    Given four integers length, width, height, and mass, representing the
    dimensions and mass of a box, respectively, return a string representing
    the category of the box.
    * The box is "Bulky" if:
      + Any of the dimensions of the box is greater or equal to 10^4.
      + Or, the volume of the box is greater or equal to 10^9.
    * If the mass of the box is greater or equal to 100, it is "Heavy".
    * If the box is both "Bulky" and "Heavy", then its category is "Both".
    * If the box is neither "Bulky" nor "Heavy", then its category is "Neither".
    * If the box is "Bulky" but not "Heavy", then its category is "Bulky".
    * If the box is "Heavy" but not "Bulky", then its category is "Heavy".
    Note that the volume of the box is the product of its length, width and
    height.

    Example 1:
    Input: length = 1000, width = 35, height = 700, mass = 300
    Output: "Heavy"
    Explanation: None of the dimensions of the box is greater or equal to 10^4.
                 Its volume = 24500000 <= 10^9. So it cannot be categorized as
                 "Bulky". However mass >= 100, so the box is "Heavy". Since the
                 box is not "Bulky" but "Heavy", we return "Heavy".

    Example 2:
    Input: length = 200, width = 50, height = 800, mass = 50
    Output: "Neither"
    Explanation: None of the dimensions of the box is greater or equal to 10^4.
                 Its volume = 8 * 10^6 <= 10^9. So it cannot be categorized as
                 "Bulky". Its mass is also less than 100, so it cannot be
                 categorized as "Heavy" either.  Since its neither of the two
                 above categories, we return "Neither".

    Constraints:
    * 1 <= length, width, height <= 10^5
    * 1 <= mass <= 10^3"""

    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:
        bulky = max(length, width, height) >= 1e4 or length*width*height >= 1e9
        heavy = mass >= 100
        if bulky and heavy: return "Both"
        if bulky: return "Bulky"
        if heavy: return "Heavy"
        return "Neither"


    """2527. Find Xor-Beauty of Array (Medium)
    You are given a 0-indexed integer array nums. The effective value of three
    indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]). The xor-
    beauty of the array is the XORing of the effective values of all the
    possible triplets of indices (i, j, k) where 0 <= i, j, k < n. Return the
    xor-beauty of nums. Note that:
    * val1 | val2 is bitwise OR of val1 and val2.
    * val1 & val2 is bitwise AND of val1 and val2.

    Example 1:
    Input: nums = [1,4]
    Output: 5
    Explanation: The triplets and their corresponding effective values are
                 listed below:
                 - (0,0,0) with effective value ((1 | 1) & 1) = 1
                 - (0,0,1) with effective value ((1 | 1) & 4) = 0
                 - (0,1,0) with effective value ((1 | 4) & 1) = 1
                 - (0,1,1) with effective value ((1 | 4) & 4) = 4
                 - (1,0,0) with effective value ((4 | 1) & 1) = 1
                 - (1,0,1) with effective value ((4 | 1) & 4) = 4
                 - (1,1,0) with effective value ((4 | 4) & 1) = 0
                 - (1,1,1) with effective value ((4 | 4) & 4) = 4
                 Xor-beauty of array will be bitwise XOR of all beauties =
                 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.

    Example 2:
    Input: nums = [15,45,20,2,34,35,5,44,32,30]
    Output: 34
    Explanation: The xor-beauty of the given array is 34.

    Constraints:
    1 <= nums.length <= 10^5
    1 <= nums[i] <= 10^9"""

    def xorBeauty(self, nums: List[int]) -> int:
        return (lambda x: (x|x)&x)(reduce(xor, nums))


    """2528. Maximize the Minimum Powered City (Hard)
    You are given a 0-indexed integer array stations of length n, where
    stations[i] represents the number of power stations in the ith city. Each
    power station can provide power to every city in a fixed range. In other
    words, if the range is denoted by r, then a power station at city i can
    provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.
    * Note that |x| denotes absolute value. For example, |7 - 5| = 2 and
      |3 - 10| = 7.
    The power of a city is the total number of power stations it is being
    provided power from. The government has sanctioned building k more power
    stations, each of which can be built in any city, and have the same range
    as the pre-existing ones. Given the two integers r and k, return the
    maximum possible minimum power of a city, if the additional power stations
    are built optimally. Note that you can build the k power stations in
    multiple cities.

    Example 1:
    Input: stations = [1,2,4,5,0], r = 1, k = 2
    Output: 5
    Explanation: One of the optimal ways is to install both the power stations
                 at city 1. So stations will become [1,4,4,5,0].
                 - City 0 is provided by 1 + 4 = 5 power stations.
                 - City 1 is provided by 1 + 4 + 4 = 9 power stations.
                 - City 2 is provided by 4 + 4 + 5 = 13 power stations.
                 - City 3 is provided by 5 + 4 = 9 power stations.
                 - City 4 is provided by 5 + 0 = 5 power stations.
                 So the minimum power of a city is 5. Since it is not possible
                 to obtain a larger power, we return 5.

    Example 2:
    Input: stations = [4,4,4,4], r = 0, k = 3
    Output: 4
    Explanation: It can be proved that we cannot make the minimum power of a
                 city greater than 4.

    Constraints:
    * n == stations.length
    * 1 <= n <= 10^5
    * 0 <= stations[i] <= 10^5
    * 0 <= r <= n - 1
    * 0 <= k <= 10^9"""

    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        n = len(stations)
        lo, hi = 0, sum(stations)+k
        while lo < hi:
            mid = lo + hi + 1 >> 1
            ok = True
            kk = k
            ss = stations.copy()
            prefix = 0
            for i in range(n+r):
                if i < n: prefix += ss[i]
                if i >= 2*r+1: prefix -= ss[i-2*r-1]
                if i >= r and prefix < mid:
                    if kk < mid - prefix:
                        ok = False
                        break
                    kk -= mid - prefix
                    if i < n: ss[i] += mid - prefix
                    prefix = mid
            if ok: lo = mid
            else: hi = mid - 1
        return lo


    """2529. Maximum Count of Positive Integer and Negative Integer (Easy)
    Given an array nums sorted in non-decreasing order, return the maximum
    between the number of positive integers and the number of negative integers.
    In other words, if the number of positive integers in nums is pos and the
    number of negative integers is neg, then return the maximum of pos and neg.
    Note that 0 is neither positive nor negative.

    Example 1:
    Input: nums = [-2,-1,-1,1,2,3]
    Output: 3
    Explanation: There are 3 positive integers and 3 negative integers. The
                 maximum count among them is 3.

    Example 2:
    Input: nums = [-3,-2,-1,0,0,1,2]
    Output: 3
    Explanation: There are 2 positive integers and 3 negative integers. The
                 maximum count among them is 3.

    Example 3:
    Input: nums = [5,20,66,1314]
    Output: 4
    Explanation: There are 4 positive integers and 0 negative integers. The
                 maximum count among them is 4.

    Constraints:
    * 1 <= nums.length <= 2000
    * -2000 <= nums[i] <= 2000
    * nums is sorted in a non-decreasing order."""

    def maximumCount(self, nums: List[int]) -> int:
        neg = bisect_left(nums, 0)
        pos = len(nums) - bisect_right(nums, 0)
        return max(neg, pos)


    """2530. Maximal Score After Applying K Operations (Medium)
    You are given a 0-indexed integer array nums and an integer k. You have a
    starting score of 0. In one operation:
    * choose an index i such that 0 <= i < nums.length,
    * increase your score by nums[i], and
    * replace nums[i] with ceil(nums[i] / 3).
    Return the maximum possible score you can attain after applying exactly k
    operations. The ceiling function ceil(val) is the least integer greater
    than or equal to val.

    Example 1:
    Input: nums = [10,10,10,10,10], k = 5
    Output: 50
    Explanation: Apply the operation to each array element exactly once. The
                 final score is 10 + 10 + 10 + 10 + 10 = 50.

    Example 2:
    Input: nums = [1,10,3,3,3], k = 3
    Output: 17
    Explanation: You can do the following operations:
                 Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your
                              score increases by 10.
                 Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your
                              score increases by 4.
                 Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your
                              score increases by 3.
                 The final score is 10 + 4 + 3 = 17.

    Constraints:
    * 1 <= nums.length, k <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def maxKelements(self, nums: List[int], k: int) -> int:
        pq = [-x for x in nums]
        heapify(pq)
        ans = 0
        for i in range(k):
            ans -= pq[0]
            heapreplace(pq, pq[0]//3)
        return ans


    """2531. Make Number of Distinct Characters Equal (Medium)
    You are given two 0-indexed strings word1 and word2. A move consists of
    choosing two indices i and j such that 0 <= i < word1.length and
    0 <= j < word2.length and swapping word1[i] with word2[j]. Return true if
    it is possible to get the number of distinct characters in word1 and word2
    to be equal with exactly one move. Return false otherwise.

    Example 1:
    Input: word1 = "ac", word2 = "b"
    Output: false
    Explanation: Any pair of swaps would yield two distinct characters in the
                 first string, and one in the second string.

    Example 2:
    Input: word1 = "abcc", word2 = "aab"
    Output: true
    Explanation: We swap index 2 of the first string with index 0 of the second
                 string. The resulting strings are word1 = "abac" and
                 word2 = "cab", which both have 3 distinct characters.

    Example 3:
    Input: word1 = "abcde", word2 = "fghij"
    Output: true
    Explanation: Both resulting strings will have 5 distinct characters,
                 regardless of which indices we swap.

    Constraints:
    * 1 <= word1.length, word2.length <= 10^5
    * word1 and word2 consist of only lowercase English letters."""

    def isItPossible(self, word1: str, word2: str) -> bool:
        freq1 = Counter(word1)
        freq2 = Counter(word2)
        sz1, sz2 = len(freq1), len(freq2)
        for c1 in ascii_lowercase:
            for c2 in ascii_lowercase:
                if freq1[c1] and freq2[c2]:
                    if c1 == c2:
                        if sz1 == sz2: return True
                    else:
                        cnt1, cnt2 = sz1, sz2
                        if freq1[c1] == 1: cnt1 -= 1
                        if freq1[c2] == 0: cnt1 += 1
                        if freq2[c1] == 0: cnt2 += 1
                        if freq2[c2] == 1: cnt2 -= 1
                        if cnt1 == cnt2: return True
        return False


    """2532. Time to Cross a Bridge (Hard)
    There are k workers who want to move n boxes from an old warehouse to a new
    one. You are given the two integers n and k, and a 2D integer array time of
    size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].
    The warehouses are separated by a river and connected by a bridge. The old
    warehouse is on the right bank of the river, and the new warehouse is on
    the left bank of the river. Initially, all k workers are waiting on the
    left side of the bridge. To move the boxes, the ith worker (0-indexed) can :
    * Cross the bridge from the left bank (new warehouse) to the right bank
      (old warehouse) in leftToRighti minutes.
    * Pick a box from the old warehouse and return to the bridge in pickOldi
      minutes. Different workers can pick up their boxes simultaneously.
    * Cross the bridge from the right bank (old warehouse) to the left bank
      (new warehouse) in rightToLefti minutes.
    * Put the box in the new warehouse and return to the bridge in putNewi
      minutes. Different workers can put their boxes simultaneously.
    A worker i is less efficient than a worker j if either condition is met:
    * leftToRighti + rightToLefti > leftToRightj + rightToLeftj
    * leftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j
    The following rules regulate the movement of the workers through the bridge :
    * If a worker x reaches the bridge while another worker y is crossing the
      bridge, x waits at their side of the bridge.
    * If the bridge is free, the worker waiting on the right side of the bridge
      gets to cross the bridge. If more than one worker is waiting on the right
      side, the one with the lowest efficiency crosses first.
    * If the bridge is free and no worker is waiting on the right side, and at
      least one box remains at the old warehouse, the worker on the left side
      of the river gets to cross the bridge. If more than one worker is waiting
      on the left side, the one with the lowest efficiency crosses first.
    Return the instance of time at which the last worker reaches the left bank
    of the river after all n boxes have been put in the new warehouse.

    Example 1:
    Input: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]
    Output: 6
    Explanation: From 0 to 1: worker 2 crosses the bridge from the left bank to
                              the right bank.
                 From 1 to 2: worker 2 picks up a box from the old warehouse.
                 From 2 to 6: worker 2 crosses the bridge from the right bank
                              to the left bank.
                 From 6 to 7: worker 2 puts a box at the new warehouse.
                 The whole process ends after 7 minutes. We return 6 because
                 the problem asks for the instance of time at which the last
                 worker reaches the left bank.

    Example 2:
    Input: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]
    Output: 50
    Explanation: From 0  to 10: worker 1 crosses the bridge from the left bank
                                to the right bank.
                 From 10 to 20: worker 1 picks up a box from the old warehouse.
                 From 10 to 11: worker 0 crosses the bridge from the left bank
                                to the right bank.
                 From 11 to 20: worker 0 picks up a box from the old warehouse.
                 From 20 to 30: worker 1 crosses the bridge from the right bank
                                to the left bank.
                 From 30 to 40: worker 1 puts a box at the new warehouse.
                 From 30 to 31: worker 0 crosses the bridge from the right bank
                                to the left bank.
                 From 31 to 39: worker 0 puts a box at the new warehouse.
                 From 39 to 40: worker 0 crosses the bridge from the left bank
                                to the right bank.
                 From 40 to 49: worker 0 picks up a box from the old warehouse.
                 From 49 to 50: worker 0 crosses the bridge from the right bank
                                to the left bank.
                 From 50 to 58: worker 0 puts a box at the new warehouse.
                 The whole process ends after 58 minutes. We return 50 because
                 the problem asks for the instance of time at which the last
                 worker reaches the left bank.

    Constraints:
    * 1 <= n, k <= 10^4
    * time.length == k
    * time[i].length == 4
    * 1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000"""

    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
        ans = free = 0
        l, ll = [], []
        r, rr = [], []
        for i, (x, _, y, _) in enumerate(time): heappush(ll, (-x-y, -i))
        while n or r or rr:
            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)):
                cand = inf
                if n and l: cand = min(cand, l[0][0])
                if r: cand = min(cand, r[0][0])
                free = cand

            while r and r[0][0] <= free:
                _, i = heappop(r)
                heappush(rr, (-time[i][0] - time[i][2], -i))

            while l and l[0][0] <= free:
                _, i = heappop(l)
                heappush(ll, (-time[i][0] - time[i][2], -i))

            if rr:
                _, i = heappop(rr)
                free += time[-i][2]
                if n: heappush(l, (free + time[-i][3], -i))
                else: ans = max(ans, free)
            else:
                _, i = heappop(ll)
                free += time[-i][0]
                heappush(r, (free + time[-i][1], -i))
                n -= 1
        return ans


    """2533. Number of Good Binary Strings (Medium)
    You are given four integers minLenght, maxLength, oneGroup and zeroGroup. A
    binary string is good if it satisfies the following conditions:
    * The length of the string is in the range [minLength, maxLength].
    * The size of each block of consecutive 1's is a multiple of oneGroup.
      + For example in a binary string 00110111100 sizes of each block of
        consecutive ones are [2,4].
    * The size of each block of consecutive 0's is a multiple of zeroGroup.
      + For example, in a binary string 00110111100 sizes of each block of
        consecutive ones are [2,1,2].
    Return the number of good binary strings. Since the answer may be too large,
    return it modulo 10^9 + 7. Note that 0 is considered a multiple of all the
    numbers.

    Example 1:
    Input: minLength = 2, maxLength = 3, oneGroup = 1, zeroGroup = 2
    Output: 5
    Explanation: There are 5 good binary strings in this example: "00", "11",
                 "001", "100", and "111". It can be proven that there are only
                 5 good strings satisfying all conditions.

    Example 2:
    Input: minLength = 4, maxLength = 4, oneGroup = 4, zeroGroup = 3
    Output: 1
    Explanation: There is only 1 good binary string in this example: "1111". It
                 can be proven that there is only 1 good string satisfying all
                 conditions.

    Constraints:
    * 1 <= minLength <= maxLength <= 10^5
    * 1 <= oneGroup, zeroGroup <= maxLength"""

    def goodBinaryStrings(self, minLength: int, maxLength: int, oneGroup: int, zeroGroup: int) -> int:
        dp = [0] * (maxLength+1)
        for i in range(maxLength, -1, -1):
            if minLength <= i: dp[i] += 1
            if i+oneGroup <= maxLength: dp[i] += dp[i+oneGroup]
            if i+zeroGroup <= maxLength: dp[i] += dp[i+zeroGroup]
            dp[i] %= 1_000_000_007
        return dp[0]


    """2534. Time Taken to Cross the Door (Hard)
    There are n persons numbered from 0 to n - 1 and a door. Each person can
    enter or exit through the door once, taking one second. You are given a
    non-decreasing integer array arrival of size n, where arrival[i] is the
    arrival time of the ith person at the door. You are also given an array
    state of size n, where state[i] is 0 if person i wants to enter through the
    door or 1 if they want to exit through the door. If two or more persons
    want to use the door at the same time, they follow the following rules:
    * If the door was not used in the previous second, then the person who
      wants to exit goes first.
    * If the door was used in the previous second for entering, the person who
      wants to enter goes first.
    * If the door was used in the previous second for exiting, the person who
      wants to exit goes first.
    * If multiple persons want to go in the same direction, the person with the
      smallest index goes first.
    Return an array answer of size n where answer[i] is the second at which the
    ith person crosses the door.

    Note that:
    * Only one person can cross the door at each second.
    * A person may arrive at the door and wait without entering or exiting to
      follow the mentioned rules.

    Example 1:
    Input: arrival = [0,1,1,2,4], state = [0,1,0,0,1]
    Output: [0,3,1,2,4]
    Explanation: At each second we have the following:
                 - At t = 0: Person 0 is the only one who wants to enter, so
                             they just enter through the door.
                 - At t = 1: Person 1 wants to exit, and person 2 wants to
                             enter. Since the door was used the previous second
                             for entering, person 2 enters.
                 - At t = 2: Person 1 still wants to exit, and person 3 wants
                             to enter. Since the door was used the previous
                             second for entering, person 3 enters.
                 - At t = 3: Person 1 is the only one who wants to exit, so
                             they just exit through the door.
                 - At t = 4: Person 4 is the only one who wants to exit, so
                             they just exit through the door.

    Example 2:
    Input: arrival = [0,0,0], state = [1,0,1]
    Output: [0,2,1]
    Explanation: At each second we have the following:
                 - At t = 0: Person 1 wants to enter while persons 0 and 2 want
                             to exit. Since the door was not used in the
                             previous second, the persons who want to exit get
                             to go first. Since person 0 has a smaller index,
                             they exit first.
                 - At t = 1: Person 1 wants to enter, and person 2 wants to
                             exit. Since the door was used in the previous
                             second for exiting, person 2 exits.
                 - At t = 2: Person 1 is the only one who wants to enter, so
                             they just enter through the door.

    Constraints:
    * n == arrival.length == state.length
    * 1 <= n <= 10^5
    * 0 <= arrival[i] <= n
    * arrival is sorted in non-decreasing order.
    * state[i] is either 0 or 1."""

    def timeTaken(self, arrival: List[int], state: List[int]) -> List[int]:
        ans = [0] * len(arrival)
        qin = deque()
        qout = deque()
        time = i = 0
        enter = False
        while qin or qout or i < len(arrival):
            if i == len(arrival) or time < arrival[i]:
                if qin or qout:
                    if qin and (not qout or enter):
                        ans[qin.popleft()] = time
                        time += 1
                        enter = True
                    else:
                        ans[qout.popleft()] = time
                        time += 1
                        enter = False
                else:
                    if time+1 <= arrival[i]: enter = False
                    time = arrival[i]
            while i < len(arrival) and time == arrival[i]:
                if state[i]: qout.append(i)
                else: qin.append(i)
                i += 1
        return ans


    """2535. Difference Between Element Sum and Digit Sum of an Array (Easy)
    You are given a positive integer array nums.
    * The element sum is the sum of all the elements in nums.
    * The digit sum is the sum of all the digits (not necessarily distinct)
      that appear in nums.
    Return the absolute difference between the element sum and digit sum of
    nums. Note that the absolute difference between two integers x and y is
    defined as |x - y|.

    Example 1:
    Input: nums = [1,15,6,3]
    Output: 9
    Explanation: The element sum of nums is 1 + 15 + 6 + 3 = 25. The digit sum
                 of nums is 1 + 1 + 5 + 6 + 3 = 16. The absolute difference
                 between the element sum and digit sum is |25 - 16| = 9.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: The element sum of nums is 1 + 2 + 3 + 4 = 10. The digit sum
                 of nums is 1 + 2 + 3 + 4 = 10. The absolute difference between
                 the element sum and digit sum is |10 - 10| = 0.

    Constraints:
    * 1 <= nums.length <= 2000
    * 1 <= nums[i] <= 2000"""

    def differenceOfSum(self, nums: List[int]) -> int:
        return sum(x-sum(map(int, str(x))) for x in nums)


    """2536. Increment Submatrices by One (Medium)
    You are given a positive integer n, indicating that we initially have an
    n x n 0-indexed integer matrix mat filled with zeroes. You are also given a
    2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i],
    you should do the following operation:
    * Add 1 to every element in the submatrix with the top left corner
      (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1
      to mat[x][y] for for all row1i <= x <= row2i and col1i <= y <= col2i.
    Return the matrix mat after performing every query.

    Example 1:
    Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]
    Output: [[1,1,0],[1,2,1],[0,1,1]]
    Explanation: The diagram above shows the initial matrix, the matrix after
                 the first query, and the matrix after the second query.
                 - In the first query, we add 1 to every element in the
                   submatrix with the top left corner (1, 1) and bottom right
                   corner (2, 2).
                 - In the second query, we add 1 to every element in the
                   submatrix with the top left corner (0, 0) and bottom right
                   corner (1, 1).

    Example 2:
    Input: n = 2, queries = [[0,0,1,1]]
    Output: [[1,1],[1,1]]
    Explanation: The diagram above shows the initial matrix and the matrix
                 after the first query.
                 - In the first query we add 1 to every element in the matrix.

    Constraints:
    * 1 <= n <= 500
    * 1 <= queries.length <= 10^4
    * 0 <= row1i <= row2i < n
    * 0 <= col1i <= col2i < n"""

    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        ans = [[0]*n for _ in range(n)]
        for i, j, ii, jj in queries:
            ans[i][j] += 1
            if ii+1 < n: ans[ii+1][j] -= 1
            if jj+1 < n: ans[i][jj+1] -= 1
            if ii+1 < n and jj+1 < n: ans[ii+1][jj+1] += 1
        for i in range(n):
            prefix = 0
            for j in range(n):
                prefix += ans[i][j]
                ans[i][j] = prefix
                if i: ans[i][j] += ans[i-1][j]
        return ans


    """2537. Count the Number of Good Subarrays (Medium)
    Given an integer array nums and an integer k, return the number of good
    subarrays of nums. A subarray arr is good if it there are at least k pairs
    of indices (i, j) such that i < j and arr[i] == arr[j]. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,1,1,1,1], k = 10
    Output: 1
    Explanation: The only good subarray is the array nums itself.

    Example 2:
    Input: nums = [3,1,4,3,2,2,4], k = 2
    Output: 4
    Explanation: There are 4 different good subarrays:
                 - [3,1,4,3,2,2] that has 2 pairs.
                 - [3,1,4,3,2,2,4] that has 3 pairs.
                 - [1,4,3,2,2,4] that has 2 pairs.
                 - [4,3,2,2,4] that has 2 pairs.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= 10^9"""

    def countGood(self, nums: List[int], k: int) -> int:
        freq = Counter()
        ans = ii = 0
        for x in nums:
            k -= freq[x]
            freq[x] += 1
            while k <= 0:
                freq[nums[ii]] -= 1
                k += freq[nums[ii]]
                ii += 1
            ans += ii
        return ans


    """2538. Difference Between Maximum and Minimum Price Sum (Hard)
    There exists an undirected and initially unrooted tree with n nodes indexed
    from 0 to n - 1. You are given the integer n and a 2D integer array edges
    of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge
    between nodes ai and bi in the tree. Each node has an associated price. You
    are given an integer array price, where price[i] is the price of the ith
    node. The price sum of a given path is the sum of the prices of all nodes
    lying on that path. The tree can be rooted at any node root of your choice.
    The incurred cost after choosing root is the difference between the maximum
    and minimum price sum amongst all paths starting at root. Return the
    maximum possible cost amongst all possible root choices.

    Example 1:
    Input: n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]
    Output: 24
    Explanation: The diagram above denotes the tree after rooting it at node 2.
                 The first part (colored in red) shows the path with the
                 maximum price sum. The second part (colored in blue) shows the
                 path with the minimum price sum.
                 - The first path contains nodes [2,1,3,4]: the prices are
                   [7,8,6,10], and the sum of the prices is 31.
                 - The second path contains the node [2] with the price [7].
                 The difference between the maximum and minimum price sum is 24.
                 It can be proved that 24 is the maximum cost.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2]], price = [1,1,1]
    Output: 2
    Explanation: The diagram above denotes the tree after rooting it at node 0.
                 The first part (colored in red) shows the path with the
                 maximum price sum. The second part (colored in blue) shows the
                 path with the minimum price sum.
                 - The first path contains nodes [0,1,2]: the prices are
                   [1,1,1], and the sum of the prices is 3.
                 - The second path contains node [0] with a price [1].
                 The difference between the maximum and minimum price sum is 2.
                 It can be proved that 2 is the maximum cost.

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * 0 <= ai, bi <= n - 1
    * edges represents a valid tree.
    * price.length == n
    * 1 <= price[i] <= 10^5"""

    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)

        def dfs(u, p):
            """Return last path from u to leaf including and excluding leaf value."""
            nonlocal ans
            x, y = price[u], 0
            for v in tree[u]:
                if v != p:
                    xx, yy = dfs(v, u)
                    ans = max(ans, x + yy, xx+y)
                    x = max(x, xx + price[u])
                    y = max(y, yy + price[u])
            return x, y

        ans = 0
        dfs(0, -1)
        return ans


    """2539. Count the Number of Good Subsequences (Medium)
    A subsequence of a string is good if it is not empty and the frequency of
    each one of its characters is the same. Given a string s, return the number
    of good subsequences of s. Since the answer may be too large, return it
    modulo 10^9 + 7. A subsequence is a string that can be derived from another
    string by deleting some or no characters without changing the order of the
    remaining characters.

    Example 1:
    Input: s = "aabb"
    Output: 11
    Explanation: The total number of subsequences is 24. There are five
                 subsequences which are not good: "aabb", "aabb", "aabb",
                 "aabb", and the empty subsequence. Hence, the number of good
                 subsequences is 24-5 = 11.

    Example 2:
    Input: s = "leet"
    Output: 12
    Explanation: There are four subsequences which are not good: "leet", "leet",
                 "leet", and the empty subsequence. Hence, the number of good
                 subsequences is 24-4 = 12.

    Example 3:
    Input: s = "abcd"
    Output: 15
    Explanation: All of the non-empty subsequences are good subsequences.
                 Hence, the number of good subsequences is 24-1 = 15.

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of only lowercase English letters."""

    def countGoodSubsequences(self, s: str) -> int:
        mod = 1_000_000_007
        freq = [0]*26
        for ch in s: freq[ord(ch)-97] += 1
        ans = 0
        coef = [1]*26
        inv = [0]*(len(s)+1)
        inv[0] = inv[1] = 1
        for x in range(1, max(freq)+1):
            val = 1
            if x >= 2: inv[x] = mod - mod//x * inv[mod%x] % mod
            for i in range(26):
                coef[i] = coef[i] * (freq[i]-x+1) % mod
                coef[i] = coef[i] * inv[x] % mod
                val = val * (1+coef[i]) % mod
            ans = (ans + val - 1) % mod
        return ans


    """2540. Minimum Common Value (Easy)
    Given two integer arrays nums1 and nums2, sorted in non-decreasing order,
    return the minimum integer common to both arrays. If there is no common
    integer amongst nums1 and nums2, return -1. Note that an integer is said
    to be common to nums1 and nums2 if both arrays have at least one
    occurrence of that integer.

    Example 1:
    Input: nums1 = [1,2,3], nums2 = [2,4]
    Output: 2
    Explanation: The smallest element common to both arrays is 2, so we return
                 2.

    Example 2:
    Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
    Output: 2
    Explanation: There are two common elements in the array 2 and 3 out of
                 which 2 is the smallest, so 2 is returned.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 10^5
    * 1 <= nums1[i], nums2[j] <= 10^9
    * Both nums1 and nums2 are sorted in non-decreasing order."""

    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:
        i = ii = 0
        while i < len(nums1) and ii < len(nums2):
            if nums1[i] < nums2[ii]: i += 1
            elif nums1[i] == nums2[ii]: return nums1[i]
            else: ii += 1
        return -1


    """2541. Minimum Operations to Make Array Equal II (Medium)
    You are given two integer arrays nums1 and nums2 of equal length n and an
    integer k. You can perform the following operation on nums1:
    * Choose two indexes i and j and increment nums1[i] by k and decrement
      nums1[j] by k. In other words, nums1[i] = nums1[i] + k and
      nums1[j] = nums1[j] - k.
    nums1 is said to be equal to nums2 if for all indices i such that
    0 <= i < n, nums1[i] == nums2[i]. Return the minimum number of operations
    required to make nums1 equal to nums2. If it is impossible to make them
    equal, return -1.

    Example 1:
    Input: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3
    Output: 2
    Explanation: In 2 operations, we can transform nums1 to nums2. 1st
                 operation: i = 2, j = 0. After applying the operation,
                 nums1 = [1,3,4,4]. 2nd operation: i = 2, j = 3. After applying
                 the operation, nums1 = [1,3,7,1]. One can prove that it is
                 impossible to make arrays equal in fewer operations.

    Example 2:
    Input: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1
    Output: -1
    Explanation: It can be proved that it is impossible to make the two arrays
                 equal.

    Constraints:
    * n == nums1.length == nums2.length
    * 2 <= n <= 10^5
    * 0 <= nums1[i], nums2[j] <= 10^9
    * 0 <= k <= 10^5"""

    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        ans = total = 0
        for x, y in zip(nums1, nums2):
            diff = x-y
            if k == 0 and diff or k and abs(diff) % k: return -1
            if k: ans += abs(diff)//k
            total += diff
        return ans//2 if total == 0 else -1


    """2542. Maximum Subsequence Score (Medium)
    You are given two 0-indexed integer arrays nums1 and nums2 of equal length
    n and a positive integer k. You must choose a subsequence of indices from
    nums1 of length k. For chosen indices i0, i1, ..., ik - 1, your score is
    defined as:
    * The sum of the selected elements from nums1 multiplied with the minimum
      of the selected elements from nums2.
    * It can defined simply as:
      (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).
    Return the maximum possible score. A subsequence of indices of an array is
    a set that can be derived from the set {0, 1, ..., n-1} by deleting some or
    no elements.

    Example 1:
    Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
    Output: 12
    Explanation: The four possible subsequence scores are:
                 - We choose the indices 0, 1, and 2 with
                   score = (1+3+3) * min(2,1,3) = 7.
                 - We choose the indices 0, 1, and 3 with
                   score = (1+3+2) * min(2,1,4) = 6.
                 - We choose the indices 0, 2, and 3 with
                   score = (1+3+2) * min(2,3,4) = 12.
                 - We choose the indices 1, 2, and 3 with
                   score = (3+3+2) * min(1,3,4) = 8.
                 Therefore, we return the max score, which is 12.

    Example 2:
    Input: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1
    Output: 30
    Explanation: Choosing index 2 is optimal:
                 nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible
                 score.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 0 <= nums1[i], nums2[j] <= 10^5
    * 1 <= k <= n"""

    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:
        nums2, nums1 = zip(*sorted(zip(nums2, nums1), reverse=True))
        pq = []
        ans = total = 0
        for i, (x, y) in enumerate(zip(nums1, nums2)):
            total += x
            heappush(pq, x)
            if i >= k: total -= heappop(pq)
            if i >= k-1: ans = max(ans, total * y)
        return ans


    """2543. Check if Point Is Reachable (Hard)
    There exists an infinitely large grid. You are currently at point (1, 1),
    and you need to reach the point (targetX, targetY) using a finite number of
    steps. In one step, you can move from point (x, y) to any one of the
    following points: (x, y - x)
                      (x - y, y)
                      (2 * x, y)
                      (x, 2 * y)
    Given two integers targetX and targetY representing the X-coordinate and Y-
    coordinate of your final position, return true if you can reach the point
    from (1, 1) using some number of steps, and false otherwise.

    Example 1:
    Input: targetX = 6, targetY = 9
    Output: false
    Explanation: It is impossible to reach (6,9) from (1,1) using any sequence
                 of moves, so false is returned.

    Example 2:
    Input: targetX = 4, targetY = 7
    Output: true
    Explanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) ->
                 (1,7) -> (2,7) -> (4,7).

    Constraints: 1 <= targetX, targetY <= 10^9"""

    def isReachable(self, targetX: int, targetY: int) -> bool:
        g = gcd(targetX, targetY)
        return g & (g-1) == 0


    """2544. Alternating Digit Sum (Easy)
    You are given a positive integer n. Each digit of n has a sign according to
    the following rules:
    * The most significant digit is assigned a positive sign.
    * Each other digit has an opposite sign to its adjacent digits.
    Return the sum of all digits with their corresponding sign.

    Example 1:
    Input: n = 521
    Output: 4
    Explanation: (+5) + (-2) + (+1) = 4.

    Example 2:
    Input: n = 111
    Output: 1
    Explanation: (+1) + (-1) + (+1) = 1.

    Example 3:
    Input: n = 886996
    Output: 0
    Explanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.

    Constraints: 1 <= n <= 10^9"""

    def alternateDigitSum(self, n: int) -> int:
        return sum(x*(-1)**i for i, x in enumerate(map(int, str(n))))


    """2545. Sort the Students by Their Kth Score (Medium)
    There is a class with m students and n exams. You are given a 0-indexed
    m x n integer matrix score, where each row represents one student and
    score[i][j] denotes the score the ith student got in the jth exam. The
    matrix score contains distinct integers only. You are also given an integer
    k. Sort the students (i.e., the rows of the matrix) by their scores in the
    kth (0-indexed) exam from the highest to the lowest. Return the matrix
    after sorting it.

    Example 1:
    Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
    Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
    Explanation: In the above diagram, S denotes the student, while E denotes
                 the exam.
                 - The student with index 1 scored 11 in exam 2, which is the
                   highest score, so they got first place.
                 - The student with index 0 scored 9 in exam 2, which is the
                   second highest score, so they got second place.
                 - The student with index 2 scored 3 in exam 2, which is the
                   lowest score, so they got third place.

    Example 2:
    Input: score = [[3,4],[5,6]], k = 0
    Output: [[5,6],[3,4]]
    Explanation: In the above diagram, S denotes the student, while E denotes
                 the exam.
                 - The student with index 1 scored 5 in exam 0, which is the
                   highest score, so they got first place.
                 - The student with index 0 scored 3 in exam 0, which is the
                   lowest score, so they got second place.

    Constraints:
    * m == score.length
    * n == score[i].length
    * 1 <= m, n <= 250
    * 1 <= score[i][j] <= 10^5
    * score consists of distinct integers.
    * 0 <= k < n"""

    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:
        return sorted(score, key = lambda x: x[k], reverse=True)


    """2546. Apply Bitwise Operations to Make Strings Equal (Medium)
    You are given two 0-indexed binary strings s and target of the same length
    n. You can do the following operation on s any number of times:
    * Choose two different indices i and j where 0 <= i, j < n.
    * Simultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR
      s[j]).
    For example, if s = "0110", you can choose i = 0 and j = 2, then
    simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with
    (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = "1110". Return true if
    you can make the string s equal to target, or false otherwise.

    Example 1:
    Input: s = "1010", target = "0110"
    Output: true
    Explanation: We can do the following operations:
                 - Choose i = 2 and j = 0. We have now s = "0010".
                 - Choose i = 2 and j = 1. We have now s = "0110".
                 Since we can make s equal to target, we return true.

    Example 2:
    Input: s = "11", target = "00"
    Output: false
    Explanation: It is not possible to make s equal to target with any number
                 of operations.

    Constraints:
    * n == s.length == target.length
    * 2 <= n <= 10^5
    * s and target consist of only the digits 0 and 1."""

    def makeStringsEqual(self, s: str, target: str) -> bool:
        return ('1' in s) == ('1' in target)


    """2547. Minimum Cost to Split an Array (Hard)
    You are given an integer array nums and an integer k. Split the array into
    some number of non-empty subarrays. The cost of a split is the sum of the
    importance value of each subarray in the split. Let trimmed(subarray) be
    the version of the subarray where all numbers which appear only once are
    removed.
    * For example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].
    The importance value of a subarray is k + trimmed(subarray).length.
    * For example, if a subarray is [1,2,3,3,3,4,4], then
      trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this
      subarray will be k + 5.
    Return the minimum possible cost of a split of nums. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,1,2,1,3,3], k = 2
    Output: 8
    Explanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].
                 The importance value of [1,2] is 2 + (0) = 2.
                 The importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.
                 The cost of the split is 2 + 6 = 8. It can be shown that this
                 is the minimum possible cost among all the possible splits.

    Example 2:
    Input: nums = [1,2,1,2,1], k = 2
    Output: 6
    Explanation: We split nums to have two subarrays: [1,2], [1,2,1].
                 The importance value of [1,2] is 2 + (0) = 2.
                 The importance value of [1,2,1] is 2 + (2) = 4.
                 The cost of the split is 2 + 4 = 6. It can be shown that this
                 is the minimum possible cost among all the possible splits.

    Example 3:
    Input: nums = [1,2,1,2,1], k = 5
    Output: 10
    Explanation: We split nums to have one subarray: [1,2,1,2,1].
                 The importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.
                 The cost of the split is 10. It can be shown that this is the
                 minimum possible cost among all the possible splits.

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] < nums.length
    * 1 <= k <= 10^9"""

    def minCost(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [inf]*(n+1)
        dp[-1] = 0
        for i in range(n-1, -1, -1):
            val = 0
            freq = Counter()
            for ii in range(i, n):
                freq[nums[ii]] += 1
                if freq[nums[ii]] == 2: val += 2
                elif freq[nums[ii]] > 2: val += 1
                dp[i] = min(dp[i], k + val + dp[ii+1])
        return dp[0]


    """2548. Maximum Price to Fill a Bag (Medium)
    You are given a 2D integer array items where items[i] = [pricei, weighti]
    denotes the price and weight of the ith item, respectively. You are also
    given a positive integer capacity. Each item can be divided into two items
    with ratios part1 and part2, where part1 + part2 == 1.
    * The weight of the first item is weighti * part1 and the price of the
      first item is pricei * part1.
    * Similarly, the weight of the second item is weighti * part2 and the price
      of the second item is pricei * part2.
    Return the maximum total price to fill a bag of capacity capacity with
    given items. If it is impossible to fill a bag return -1. Answers within
    10^-5 of the actual answer will be considered accepted.

    Example 1:
    Input: items = [[50,1],[10,8]], capacity = 5
    Output: 55.00000
    Explanation: We divide the 2nd item into two parts with part1 = 0.5 and
                 part2 = 0.5. The price and weight of the 1st item are 5, 4.
                 And similarly, the price and the weight of the 2nd item are
                 5, 4. The array items after operation becomes
                 [[50,1],[5,4],[5,4]]. To fill a bag with capacity 5 we take
                 the 1st element with a price of 50 and the 2nd element with a
                 price of 5. It can be proved that 55.0 is the maximum total
                 price that we can achieve.

    Example 2:
    Input: items = [[100,30]], capacity = 50
    Output: -1.00000
    Explanation: It is impossible to fill a bag with the given item.

    Constraints:
    * 1 <= items.length <= 10^5
    * items[i].length == 2
    * 1 <= pricei, weighti <= 10^4
    * 1 <= capacity <= 10^9"""

    def maxPrice(self, items: List[List[int]], capacity: int) -> float:
        ans = 0
        for p, w in sorted(items, key=lambda x: x[0]/x[1], reverse=True):
            if w > capacity: p *= capacity / w
            ans += p
            capacity -= min(w, capacity)
            if not capacity: break
        return ans if not capacity else -1


    """2549. Count Distinct Numbers on Board (Easy)
    You are given a positive integer n, that is initially placed on a board.
    Every day, for 10^9 days, you perform the following procedure:
    * For each number x present on the board, find all numbers 1 <= i <= n such
      that x % i == 1.
    * Then, place those numbers on the board.
    Return the number of distinct integers present on the board after 10^9 days
    have elapsed.

    Note:
    * Once a number is placed on the board, it will remain on it until the end.
    * % stands for the modulo operation. For example, 14 % 3 is 2.

    Example 1:
    Input: n = 5
    Output: 4
    Explanation: Initially, 5 is present on the board. The next day, 2 and 4
                 will be added since 5 % 2 == 1 and 5 % 4 == 1. After that day,
                 3 will be added to the board because 4 % 3 == 1. At the end of
                 a billion days, the distinct numbers on the board will be 2, 3,
                 4, and 5.

    Example 2:
    Input: n = 3
    Output: 2
    Explanation: Since 3 % 2 == 1, 2 will be added to the board. After a
                 billion days, the only two distinct numbers on the board are 2
                 and 3.

    Constraints: 1 <= n <= 100"""

    def distinctIntegers(self, n: int) -> int:
        return n-1 if n > 1 else 1


    """2550. Count Collisions of Monkeys on a Polygon (Medium)
    There is a regular convex polygon with n vertices. The vertices are labeled
    from 0 to n - 1 in a clockwise direction, and each vertex has exactly one
    monkey. The following figure shows a convex polygon of 6 vertices. Each
    monkey moves simultaneously to a neighboring vertex. A neighboring vertex
    for a vertex i can be:
    * the vertex (i + 1) % n in the clockwise direction, or
    * the vertex (i - 1 + n) % n in the counter-clockwise direction.
    A collision happens if at least two monkeys reside on the same vertex after
    the movement. Return the number of ways the monkeys can move so that at
    least one collision happens. Since the answer may be very large, return it
    modulo 10^9 + 7. Note that each monkey can only move once.

    Example 1:
    Input: n = 3
    Output: 6
    Explanation: There are 8 total possible movements. Two ways such that they
                 collide at some point are:
                 - Monkey 1 moves in a clockwise direction; monkey 2 moves in
                   an anticlockwise direction; monkey 3 moves in a clockwise
                   direction. Monkeys 1 and 2 collide.
                 - Monkey 1 moves in an anticlockwise direction; monkey 2 moves
                   in an anticlockwise direction; monkey 3 moves in a clockwise
                   direction. Monkeys 1 and 3 collide.
                 It can be shown 6 total movements result in a collision.

    Example 2:
    Input: n = 4
    Output: 14
    Explanation: It can be shown that there are 14 ways for the monkeys to
                 collide.

    Constraints: 3 <= n <= 10^9"""

    def monkeyMove(self, n: int) -> int:
        mod = 1_000_000_007
        return (pow(2, n, mod) - 2) % mod


    """2551. Put Marbles in Bags (Hard)
    You have k bags. You are given a 0-indexed integer array weights where
    weights[i] is the weight of the ith marble. You are also given the integer
    k. Divide the marbles into the k bags according to the following rules:
    * No bag is empty.
    * If the ith marble and jth marble are in a bag, then all marbles with an
      index between the ith and jth indices should also be in that same bag.
    * If a bag consists of all the marbles with an index from i to j
      inclusively, then the cost of the bag is weights[i] + weights[j].
    The score after distributing the marbles is the sum of the costs of all the
    k bags. Return the difference between the maximum and minimum scores among
    marble distributions.

    Example 1:
    Input: weights = [1,3,5,1], k = 2
    Output: 4
    Explanation: The distribution [1],[3,5,1] results in the minimal score of
                 (1+1) + (3+1) = 6. The distribution [1,3],[5,1], results in
                 the maximal score of (1+3) + (5+1) = 10. Thus, we return their
                 difference 10 - 6 = 4.

    Example 2:
    Input: weights = [1, 3], k = 2
    Output: 0
    Explanation: The only distribution possible is [1],[3]. Since both the
                 maximal and minimal score are the same, we return 0.

    Constraints:
    * 1 <= k <= weights.length <= 10^5
    * 1 <= weights[i] <= 10^9"""

    def putMarbles(self, weight: List[int], k: int) -> int:
        if k == 1: return 0
        vals = sorted(weight[i]+weight[i+1] for i in range(len(weight)-1))
        return sum(vals[-k+1:]) - sum(vals[:k-1])


    """2552. Count Increasing Quadruplets (Hard)
    Given a 0-indexed integer array nums of size n containing all numbers from
    1 to n, return the number of increasing quadruplets. A quadruplet
    (i, j, k, l) is increasing if:
    * 0 <= i < j < k < l < n, and
    * nums[i] < nums[k] < nums[j] < nums[l].

    Example 1:
    Input: nums = [1,3,2,4,5]
    Output: 2
    Explanation: - When i = 0, j = 1, k = 2, and l = 3,
                   nums[i] < nums[k] < nums[j] < nums[l].
                 - When i = 0, j = 1, k = 2, and l = 4,
                   nums[i] < nums[k] < nums[j] < nums[l].
                 There are no other quadruplets, so we return 2.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: There exists only one quadruplet with i = 0, j = 1, k = 2,
                 l = 3, but since nums[j] < nums[k], we return 0.

    Constraints:
    * 4 <= nums.length <= 4000
    * 1 <= nums[i] <= nums.length
    * All the integers of nums are unique. nums is a permutation."""

    def countQuadruplets(self, nums: List[int]) -> int:
        ans = 0
        dp = [0] * len(nums)
        for j in range(len(nums)):
            prev = 0
            for i in range(j):
                if nums[i] < nums[j]:
                    prev += 1
                    ans += dp[i]
                elif nums[i] > nums[j]: dp[i] += prev
        return ans


    """2553. Separate the Digits in an Array (Easy)
    Given an array of positive integers nums, return an array answer that
    consists of the digits of each integer in nums after separating them in the
    same order they appear in nums. To separate the digits of an integer is to
    get all the digits it has in the same order. For example, for the integer
    10921, the separation of its digits is [1,0,9,2,1].

    Example 1:
    Input: nums = [13,25,83,77]
    Output: [1,3,2,5,8,3,7,7]
    Explanation: - The separation of 13 is [1,3].
                 - The separation of 25 is [2,5].
                 - The separation of 83 is [8,3].
                 - The separation of 77 is [7,7].
                 answer = [1,3,2,5,8,3,7,7]. Note that answer contains the
                 separations in the same order.

    Example 2:
    Input: nums = [7,1,3,9]
    Output: [7,1,3,9]
    Explanation: The separation of each integer in nums is itself.
                 answer = [7,1,3,9].

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5"""

    def separateDigits(self, nums: List[int]) -> List[int]:
        return map(int, ''.join(map(str, nums)))


    """2554. Maximum Number of Integers to Choose From a Range I (Medium)
    You are given an integer array banned and two integers n and maxSum. You
    are choosing some number of integers following the below rules:
    * The chosen integers have to be in the range [1, n].
    * Each integer can be chosen at most once.
    * The chosen integers should not be in the array banned.
    * The sum of the chosen integers should not exceed maxSum.
    Return the maximum number of integers you can choose following the
    mentioned rules.

    Example 1:
    Input: banned = [1,6,5], n = 5, maxSum = 6
    Output: 2
    Explanation: You can choose the integers 2 and 4. 2 and 4 are from the
                 range [1, 5], both did not appear in banned, and their sum is
                 6, which did not exceed maxSum.

    Example 2:
    Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1
    Output: 0
    Explanation: You cannot choose any integer while following the mentioned
                 conditions.

    Example 3:
    Input: banned = [11], n = 7, maxSum = 50
    Output: 7
    Explanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7. They are
                 from the range [1, 7], all did not appear in banned, and their
                 sum is 28, which did not exceed maxSum.

    Constraints:
    * 1 <= banned.length <= 10^4
    * 1 <= banned[i], n <= 10^4
    * 1 <= maxSum <= 10^9"""

    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
        ans = 0
        tabu = set(banned)
        for x in range(1, n+1):
            if x not in tabu and x <= maxSum:
                maxSum -= x
                ans += 1
        return ans


    """2555. Maximize Win From Two Segments (Medium)
    There are some prizes on the X-axis. You are given an integer array
    prizePositions that is sorted in non-decreasing order, where
    prizePositions[i] is the position of the ith prize. There could be
    different prizes at the same position on the line. You are also given an
    integer k. You are allowed to select two segments with integer endpoints.
    The length of each segment must be k. You will collect all prizes whose
    position falls within at least one of the two selected segments (including
    the endpoints of the segments). The two selected segments may intersect.
    For example if k = 2, you can choose segments [1, 3] and [2, 4], and you
    will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or
    2 <= prizePositions[i] <= 4. Return the maximum number of prizes you can
    win if you choose the two segments optimally.

    Example 1:
    Input: prizePositions = [1,1,2,2,3,3,5], k = 2
    Output: 7
    Explanation: In this example, you can win all 7 prizes by selecting two
                 segments [1, 3] and [3, 5].

    Example 2:
    Input: prizePositions = [1,2,3,4], k = 0
    Output: 2
    Explanation: For this example, one choice for the segments is [3, 3] and
                 [4, 4], and you will be able to get 2 prizes.

    Constraints:
    * 1 <= prizePositions.length <= 10^5
    * 1 <= prizePositions[i] <= 10^9
    * 0 <= k <= 10^9
    * prizePositions is sorted in non-decreasing order."""

    def maximizeWin(self, prizePositions: List[int], k: int) -> int:
        ans = ii = 0
        dp = [0]
        for i, x in enumerate(prizePositions):
            while x - prizePositions[ii] > k: ii += 1
            ans = max(ans, dp[ii] + i - ii + 1)
            dp.append(max(dp[-1], i-ii+1))
        return ans


    """2556. Disconnect Path in a Binary Matrix by at Most One Flip (Medium)
    You are given a 0-indexed m x n binary matrix grid. You can move from a
    cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that
    has the value 1. The matrix is disconnected if there is no path from
    (0, 0) to (m - 1, n - 1). You can flip the value of at most one (possibly
    none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1). Return
    true if it is possible to make the matrix disconnect or false otherwise.
    Note that flipping a cell changes its value from 0 to 1 or from 1 to 0.

    Example 1:
    Input: grid = [[1,1,1],[1,0,0],[1,1,1]]
    Output: true
    Explanation: We can change the cell shown in the diagram above. There is no
                 path from (0, 0) to (2, 2) in the resulting grid.

    Example 2:
    Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
    Output: false
    Explanation: It is not possible to change at most one cell such that there
                 is not path from (0, 0) to (2, 2).

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 1000
    * 1 <= m * n <= 10^5
    * grid[i][j] is either 0 or 1.
    * grid[0][0] == grid[m - 1][n - 1] == 1"""

    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if (i, j) != (0, 0) and (i == 0 or grid[i-1][j] == 0) and (j == 0 or grid[i][j-1] == 0): grid[i][j] = 0
        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                if (i, j) != (m-1, n-1) and (i == m-1 or grid[i+1][j] == 0) and (j == n-1 or grid[i][j+1] == 0): grid[i][j] = 0
        freq = [0]*(m+n-1)
        for i in range(m):
            for j in range(n):
                freq[i+j] += grid[i][j]
        return any(freq[i] <= 1 for i in range(1, m+n-2))


    """2557. Maximum Number of Integers to Choose From a Range II (Medium)
    You are given an integer array banned and two integers n and maxSum. You
    are choosing some number of integers following the below rules:
    * The chosen integers have to be in the range [1, n].
    * Each integer can be chosen at most once.
    * The chosen integers should not be in the array banned.
    * The sum of the chosen integers should not exceed maxSum.
    Return the maximum number of integers you can choose following the
    mentioned rules.

    Example 1:
    Input: banned = [1,4,6], n = 6, maxSum = 4
    Output: 1
    Explanation: You can choose the integer 2 and 3. 2 and 3 are are in the
                 range [1, 6], both do not appear in banned, and their sum is 5,
                 which does not exceed maxSum.

    Example 2:
    Input: banned = [4,3,5,6], n = 7, maxSum = 18
    Output: 3
    Explanation: You can choose the integers 1, 2, 3 and 7. All these integers
                 are in the range [1, 7], all do not appear in banned, and
                 their sum is 13, which does not exceed maxSum.

    Constraints:
    * 1 <= banned.length <= 10^5
    * 1 <= banned[i] <= n <= 10^9
    * 1 <= maxSum <= 10^15"""

    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
        lo, hi = 0, n
        while lo < hi:
            mid = lo + hi + 1 >> 1
            total = mid*(mid+1)//2
            for x in banned:
                if x <= mid: total -= x
            if total <= maxSum: lo = mid
            else: hi = mid-1
        return lo - sum(x <= lo for x in banned)


    """2558. Take Gifts From the Richest Pile (Easy)
    You are given an integer array gifts denoting the number of gifts in
    various piles. Every second, you do the following:
    * Choose the pile with the maximum number of gifts.
    * If there is more than one pile with the maximum number of gifts, choose
      any.
    * Leave behind the floor of the square root of the number of gifts in the
      pile. Take the rest of the gifts.
    Return the number of gifts remaining after k seconds.

    Example 1:
    Input: gifts = [25,64,9,4,100], k = 4
    Output: 29
    Explanation: The gifts are taken in the following way:
                 - In the first second, the last pile is chosen and 10 gifts
                   are left behind.
                 - Then the second pile is chosen and 8 gifts are left behind.
                 - After that the first pile is chosen and 5 gifts are left
                   behind.
                 - Finally, the last pile is chosen again and 3 gifts are left
                   behind.
                 The final remaining gifts are [5,8,9,4,3], so the total number
                 of gifts remaining is 29.

    Example 2:
    Input: gifts = [1,1,1,1], k = 4
    Output: 4
    Explanation: In this case, regardless which pile you choose, you have to
                 leave behind 1 gift in each pile. That is, you can't take any
                 pile with you. So, the total gifts remaining are 4.

    Constraints:
    * 1 <= gifts.length <= 10^3
    * 1 <= gifts[i] <= 10^9
    * 1 <= k <= 10^3"""

    def pickGifts(self, gifts: List[int], k: int) -> int:
        pq = [-x for x in gifts]
        heapify(pq)
        for _ in range(k): heapreplace(pq, -isqrt(-pq[0]))
        return -sum(pq)


    """2559. Count Vowel Strings in Ranges (Medium)
    You are given a 0-indexed array of strings words and a 2D array of integers
    queries. Each query queries[i] = [li, ri] asks us to find the number of
    strings present in the range li to ri (both inclusive) of words that start
    and end with a vowel. Return an array ans of size queries.length, where
    ans[i] is the answer to the ith query. Note that the vowel letters are
    'a', 'e', 'i', 'o', and 'u'.

    Example 1:
    Input: words = ["aba","bcb","ece","aa","e"], queries = [[0,2],[1,4],[1,1]]
    Output: [2,3,0]
    Explanation: The strings starting and ending with a vowel are "aba", "ece",
                 "aa" and "e". The answer to the query [0,2] is 2 (strings
                 "aba" and "ece").
                 to query [1,4] is 3 (strings "ece", "aa", "e").
                 to query [1,1] is 0.
                 We return [2,3,0].

    Example 2:
    Input: words = ["a","e","i"], queries = [[0,2],[0,1],[2,2]]
    Output: [3,2,1]
    Explanation: Every string satisfies the conditions, so we return [3,2,1].

    Constraints:
    * 1 <= words.length <= 10^5
    * 1 <= words[i].length <= 40
    * words[i] consists only of lowercase English letters.
    * sum(words[i].length) <= 3 * 10^5
    * 1 <= queries.length <= 10^5
    * 0 <= li <= ri < words.length"""

    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:
        prefix = [0]
        for i, word in enumerate(words):
            prefix.append(prefix[-1])
            if word[0] in "aeiou" and word[-1] in "aeiou": prefix[-1] += 1
        return [prefix[r+1]-prefix[l] for l, r in queries]


    """2560. House Robber IV (Medium)
    There are several consecutive houses along a street, each of which has some
    money inside. There is also a robber, who wants to steal money from the
    homes, but he refuses to steal from adjacent homes. The capability of the
    robber is the maximum amount of money he steals from one house of all the
    houses he robbed. You are given an integer array nums representing how much
    money is stashed in each house. More formally, the ith house from the left
    has nums[i] dollars. You are also given an integer k, representing the
    minimum number of houses the robber will steal from. It is always possible
    to steal at least k houses. Return the minimum capability of the robber out
    of all the possible ways to steal at least k houses.

    Example 1:
    Input: nums = [2,3,5,9], k = 2
    Output: 5
    Explanation: There are three ways to rob at least 2 houses:
                 - Rob the houses at indices 0 and 2. Capability is
                   max(nums[0], nums[2]) = 5.
                 - Rob the houses at indices 0 and 3. Capability is
                   max(nums[0], nums[3]) = 9.
                 - Rob the houses at indices 1 and 3. Capability is
                   max(nums[1], nums[3]) = 9.
                 Therefore, we return min(5, 9, 9) = 5.

    Example 2:
    Input: nums = [2,7,9,3,1], k = 2
    Output: 2
    Explanation: There are 7 ways to rob the houses. The way which leads to
                 minimum capability is to rob the house at index 0 and 4.
                 Return max(nums[0], nums[4]) = 2.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= (nums.length + 1)/2"""

    def minCapability(self, nums: List[int], k: int) -> int:
        lo, hi = 0, max(nums)
        while lo < hi:
            mid = lo + hi >> 1
            cnt = 0
            prev = -inf
            for i, x in enumerate(nums):
                if x <= mid and prev+1 < i:
                    cnt += 1
                    prev = i
            if cnt < k: lo = mid + 1
            else: hi = mid
        return lo


    """2561. Rearranging Fruits (Hard)
    You have two fruit baskets containing n fruits each. You are given two 0-
    indexed integer arrays basket1 and basket2 representing the cost of fruit
    in each basket. You want to make both baskets equal. To do so, you can use
    the following operation as many times as you want:
    * Chose two indices i and j, and swap the ith fruit of basket1 with the jth
      fruit of basket2.
    * The cost of the swap is min(basket1[i],basket2[j]).
    Two baskets are considered equal if sorting them according to the fruit
    cost makes them exactly the same baskets. Return the minimum cost to make
    both the baskets equal or -1 if impossible.

    Example 1:
    Input: basket1 = [4,2,2,2], basket2 = [1,4,1,2]
    Output: 1
    Explanation: Swap index 1 of basket1 with index 0 of basket2, which has
                 cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2].
                 Rearranging both the arrays makes them equal.

    Example 2:
    Input: basket1 = [2,3,4,1], basket2 = [3,2,5,1]
    Output: -1
    Explanation: It can be shown that it is impossible to make both the baskets
                 equal.

    Constraints:
    * basket1.length == bakste2.length
    * 1 <= basket1.length <= 10^5
    * 1 <= basket1[i],basket2[i] <= 10^9"""

    def minCost(self, basket1: List[int], basket2: List[int]) -> int:
        freq = defaultdict(int)
        for x in basket1: freq[x] += 1
        for x in basket2: freq[x] -= 1
        m = min(freq)
        ans = total = 0
        for k, v in freq.items():
            if v&1: return -1
            total += abs(v//2)
        total //= 2
        for k, v in sorted(freq.items()):
            v = min(abs(v//2), total)
            ans += v * min(2*m, k)
            total -= v
        return ans


    """2562. Find the Array Concatenation Value (Easy)
    You are given a 0-indexed integer array nums. The concatenation of two
    numbers is the number formed by concatenating their numerals.
    * For example, the concatenation of 15, 49 is 1549.
    The concatenation value of nums is initially equal to 0. Perform this
    operation until nums becomes empty:
    * If there exists more than one number in nums, pick the first element and
      last element in nums respectively and add the value of their
      concatenation to the concatenation value of nums, then delete the first
      and last element from nums.
    * If one element exists, add its value to the concatenation value of nums,
      then delete it.
    Return the concatenation value of the nums.

    Example 1:
    Input: nums = [7,52,2,4]
    Output: 596
    Explanation: Before performing any operation, nums is [7,52,2,4] and
                 concatenation value is 0.
                  - In the first operation:
                 We pick the first element, 7, and the last element, 4. Their
                 concatenation is 74, and we add it to the concatenation value,
                 so it becomes equal to 74. Then we delete them from nums, so
                 nums becomes equal to [52,2].
                  - In the second operation:
                 We pick the first element, 52, and the last element, 2. Their
                 concatenation is 522, and we add it to the concatenation value,
                 so it becomes equal to 596. Then we delete them from the nums,
                 so nums becomes empty. Since the concatenation value is 596 so
                 the answer is 596.

    Example 2:
    Input: nums = [5,14,13,8,12]
    Output: 673
    Explanation: Before performing any operation, nums is [5,14,13,8,12] and
                 concatenation value is 0.
                  - In the first operation:
                 We pick the first element, 5, and the last element, 12. Their
                 concatenation is 512, and we add it to the concatenation value,
                 so it becomes equal to 512. Then we delete them from the nums,
                 so nums becomes equal to [14,13,8].
                  - In the second operation:
                 We pick the first element, 14, and the last element, 8. Their
                 concatenation is 148, and we add it to the concatenation value,
                 so it becomes equal to 660. Then we delete them from the nums,
                 so nums becomes equal to [13].
                  - In the third operation:
                 nums has only one element, so we pick 13 and add it to the
                 concatenation value, so it becomes equal to 673. Then we
                 delete it from nums, so nums become empty. Since the
                 concatenation value is 673 so the answer is 673.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^4"""

    def findTheArrayConcVal(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range((n+1)//2):
            if i == n-1-i: ans += nums[i]
            else: ans += int(str(nums[i]) + str(nums[n-1-i]))
        return ans


    """2563. Count the Number of Fair Pairs (Medium)
    Given a 0-indexed integer array nums of size n and two integers lower and
    upper, return the number of fair pairs. A pair (i, j) is fair if:
    * 0 <= i < j < n, and
    * lower <= nums[i] + nums[j] <= upper

    Example 1:
    Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6
    Output: 6
    Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and
                 (1,5).

    Example 2:
    Input: nums = [1,7,9,2,5], lower = 11, upper = 11
    Output: 1
    Explanation: There is a single fair pair: (2,3).

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums.length == n
    * -10^9 <= nums[i] <= 10^9
    * -10^9 <= lower <= upper <= 10^9"""

    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()
        ans = 0
        lo = hi = len(nums)-1
        for i, x in enumerate(nums):
            while 0 <= hi and x + nums[hi] > upper: hi -= 1
            while 0 <= lo and x + nums[lo] >= lower: lo -= 1
            ans += hi - lo
            if lo < i <= hi: ans -= 1
        return ans//2


    """2564. Substring XOR Queries (Medium)
    You are given a binary string s, and a 2D integer array queries where
    queries[i] = [firsti, secondi]. For the ith query, find the shortest
    substring of s whose decimal value, val, yields secondi when bitwise XORed
    with firsti. In other words, val ^ firsti == secondi. The answer to the ith
    query is the endpoints (0-indexed) of the substring [lefti, righti] or
    [-1, -1] if no such substring exists. If there are multiple answers, choose
    the one with the minimum lefti. Return an array ans where
    ans[i] = [lefti, righti] is the answer to the ith query. A substring is a
    contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: s = "101101", queries = [[0,5],[1,2]]
    Output: [[0,2],[2,3]]
    Explanation: For the first query the substring in range [0,2] is "101"
                 which has a decimal value of 5, and 5 ^ 0 = 5, hence the
                 answer to the first query is [0,2]. In the second query, the
                 substring in range [2,3] is "11", and has a decimal value of 3,
                 and 3 ^ 1 = 2. So, [2,3] is returned for the second query.

    Example 2:
    Input: s = "0101", queries = [[12,8]]
    Output: [[-1,-1]]
    Explanation: In this example there is no substring that answers the query,
                 hence [-1,-1] is returned.

    Example 3:
    Input: s = "1", queries = [[4,5]]
    Output: [[0,0]]
    Explanation: For this example, the substring in range [0,0] has a decimal
                 value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].

    Constraints:
    * 1 <= s.length <= 10^4
    * s[i] is either '0' or '1'.
    * 1 <= queries.length <= 10^5
    * 0 <= firsti, secondi <= 10^9"""

    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        seen = {}
        for i, ch in enumerate(s):
            if ch == '1':
                val = 0
                for j in range(i, min(len(s), i+30)):
                    val <<= 1
                    if s[j] == '1': val += 1
                    seen.setdefault(val, [i, j])
            else: seen.setdefault(0, [i, i])
        return [seen.get(x^y, [-1, -1]) for x, y in queries]


    """2565. Subsequence With the Minimum Score (Hard)
    You are given two strings s and t. You are allowed to remove any number of
    characters from the string t. The score string is 0 if no characters are
    removed from the string t, otherwise:
    * Let left be the minimum index among all removed characters.
    * Let right be the maximum index among all removed characters.
    Then the score of the string is right - left + 1. Return the minimum
    possible score to make t a subsequence of s. A subsequence of a string is a
    new string that is formed from the original string by deleting some (can be
    none) of the characters without disturbing the relative positions of the
    remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec"
    is not).

    Example 1:
    Input: s = "abacaba", t = "bzaa"
    Output: 1
    Explanation: In this example, we remove the character "z" at index 1
                 (0-indexed). The string t becomes "baa" which is a subsequence
                 of the string "abacaba" and the score is 1 - 1 + 1 = 1. It can
                 be proven that 1 is the minimum score that we can achieve.

    Example 2:
    Input: s = "cde", t = "xyz"
    Output: 3
    Explanation: In this example, we remove characters "x", "y" and "z" at
                 indices 0, 1, and 2 (0-indexed). The string t becomes "" which
                 is a subsequence of the string "cde" and the score is
                 2 - 0 + 1 = 3. It can be proven that 3 is the minimum score
                 that we can achieve.

    Constraints:
    * 1 <= s.length, t.length <= 10^5
    * s and t consist of only lowercase English letters."""

    def minimumScore(self, s: str, t: str) -> int:
        prefix = []
        j = 0
        for ch in s:
            if j < len(t) and ch == t[j]: j += 1
            prefix.append(j)
        ans = len(t)-j
        j = len(t)
        for i in reversed(range(len(s))):
            ans = min(ans, max(0, j - prefix[i]))
            if 0 < j and s[i] == t[j-1]: j -= 1
        return min(ans, j)


    """2566. Maximum Difference by Remapping a Digit (Easy)
    You are given an integer num. You know that Danny Mittal will sneakily
    remap one of the 10 possible digits (0 to 9) to another digit. Return the
    difference between the maximum and minimum values Danny can make by
    remapping exactly one digit in num.

    Notes:
    * When Danny remaps a digit d1 to another digit d2, Danny replaces all
      occurrences of d1 in num with d2.
    * Danny can remap a digit to itself, in which case num does not change.
    * Danny can remap different digits for obtaining minimum and maximum values
      respectively.
    * The resulting number after remapping can contain leading zeroes.
    * We mentioned "Danny Mittal" to congratulate him on being in the top 10 in
      Weekly Contest 326.

    Example 1:
    Input: num = 11891
    Output: 99009
    Explanation: To achieve the maximum value, Danny can remap the digit 1 to
                 the digit 9 to yield 99899. To achieve the minimum value,
                 Danny can remap the digit 1 to the digit 0, yielding 890. The
                 difference between these two numbers is 99009.

    Example 2:
    Input: num = 90
    Output: 99
    Explanation: The maximum value that can be returned by the function is 99
                 (if 0 is replaced by 9) and the minimum value that can be
                 returned by the function is 0 (if 9 is replaced by 0). Thus,
                 we return 99.

    Constraints: 1 <= num <= 10^8"""

    def minMaxDifference(self, num: int) -> int:
        digits = list(map(int, str(num)))
        v = next((x for x in digits if x < 9), 9)
        diff = 0
        for x in digits:
            diff = 10*diff
            if x == digits[0]: diff += x
            if x == v: diff += 9 - x
        return diff


    """2567. Minimum Score by Changing Two Elements (Medium)
    You are given a 0-indexed integer array nums.
    * The low score of nums is the minimum value of |nums[i] - nums[j]| over
      all 0 <= i < j < nums.length.
    * The high score of nums is the maximum value of |nums[i] - nums[j]| over
      all 0 <= i < j < nums.length.
    * The score of nums is the sum of the high and low scores of nums.
    To minimize the score of nums, we can change the value of at most two
    elements of nums. Return the minimum possible score after changing the
    value of at most two elements of nums. Note that |x| denotes the absolute
    value of x.

    Example 1:
    Input: nums = [1,4,3]
    Output: 0
    Explanation: Change value of nums[1] and nums[2] to 1 so that nums becomes
                 [1,1,1]. Now, the value of |nums[i] - nums[j]| is always equal
                 to 0, so we return 0 + 0 = 0.

    Example 2:
    Input: nums = [1,4,7,8,5]
    Output: 3
    Explanation: Change nums[0] and nums[1] to be 6. Now nums becomes
                 [6,6,7,8,5]. Our low score is achieved when i = 0 and j = 1,
                 in which case |nums[i] - nums[j]| = |6 - 6| = 0. Our high
                 score is achieved when i = 3 and j = 4, in which case
                 |nums[i] - nums[j]| = |8 - 5| = 3. The sum of our high and low
                 score is 3, which we can prove to be minimal.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def minimizeSum(self, nums: List[int]) -> int:
        nums.sort()
        return min(nums[-1]-nums[2], nums[-2]-nums[1], nums[-3]-nums[0])


    """2568. Minimum Impossible OR (Medium)
    You are given a 0-indexed integer array nums. We say that an integer x is
    expressible from nums if there exist some integers
    0 <= index1 < index2 < ... < indexk < nums.length for which
    nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an
    integer is expressible if it can be written as the bitwise OR of some
    subsequence of nums. Return the minimum positive non-zero integer that is
    not expressible from nums.

    Example 1:
    Input: nums = [2,1]
    Output: 4
    Explanation: 1 and 2 are already present in the array. We know that 3 is
                 expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is
                 not expressible, we return 4.

    Example 2:
    Input: nums = [5,3,2]
    Output: 1
    Explanation: We can show that 1 is the smallest number that is not
                 expressible.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def minImpossibleOR(self, nums: List[int]) -> int:
        mask = 0
        for x in nums:
            if x & x-1 == 0: mask |= x
        for i in range(32):
            if not mask & 1<<i: return 1 << i


    """2569. Handling Sum Queries After Update (Hard)
    You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries
    of queries. There are three types of queries:
    * For a query of type 1, queries[i] = [1, l, r]. Flip the values from 0 to
      1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-
      indexed.
    * For a query of type 2, queries[i] = [2, p, 0]. For every index 0 <= i < n,
      set nums2[i] = nums2[i] + nums1[i] * p.
    * For a query of type 3, queries[i] = [3, 0, 0]. Find the sum of the
      elements in nums2.
    Return an array containing all the answers to the third type queries.

    Example 1:
    Input: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]
    Output: [3]
    Explanation: After the first query nums1 becomes [1,1,1]. After the second
                 query, nums2 becomes [1,1,1], so the answer to the third query
                 is 3. Thus, [3] is returned.

    Example 2:
    Input: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]
    Output: [5]
    Explanation: After the first query, nums2 remains [5], so the answer to the
                 second query is 5. Thus, [5] is returned.

    Constraints:
    * 1 <= nums1.length,nums2.length <= 10^5
    * nums1.length = nums2.length
    * 1 <= queries.length <= 10^5
    * queries[i].length = 3
    * 0 <= l <= r <= nums1.length - 1
    * 0 <= p <= 10^6
    * 0 <= nums1[i] <= 1
    * 0 <= nums2[i] <= 10^9

class SegTreeLazy:

    def __init__(self, arr: List[int]):
        self.n = n = len(arr)
        self.tree = [0]*(4*n)
        self.lazy = [0]*(4*n)

        def build(k: int, lo: int, hi: int) -> None:
            if lo+1 == hi: self.tree[k] = arr[lo]
            else:
                mid = lo + hi >> 1
                build(2*k+1, lo, mid)
                build(2*k+2, mid, hi)
                self.tree[k] = self.tree[2*k+1] + self.tree[2*k+2]

        build(0, 0, n)


    def update(self, qlo: int, qhi: int, k: int = 0, lo: int = 0, hi: int = 0) -> None:
        if not hi: hi = self.n
        if self.lazy[k]:
            self.tree[k] = (hi - lo) - self.tree[k]
            if lo+1 < hi:
                self.lazy[2*k+1] ^= 1
                self.lazy[2*k+2] ^= 1
            self.lazy[k] = 0
        if lo < hi and qlo < hi and lo < qhi:
            if qlo <= lo and hi <= qhi: # total overlap
                self.tree[k] = (hi - lo) - self.tree[k]
                if lo+1 < hi:
                    self.lazy[2*k+1] ^= 1
                    self.lazy[2*k+2] ^= 1
                return
            mid = lo + hi >> 1
            self.update(qlo, qhi, 2*k+1, lo, mid)
            self.update(qlo, qhi, 2*k+2, mid, hi)
            self.tree[k] = self.tree[2*k+1] + self.tree[2*k+2]"""

    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        tree = SegTreeLazy(nums1)
        ans = []
        val = sum(nums2)
        for x, y, z in queries:
            if x == 1: tree.update(y, z+1)
            elif x == 2: val += y * tree.tree[0]
            else: ans.append(val)
        return ans


    """2570. Merge Two 2D Arrays by Summing Values (Easy)
    You are given two 2D integer arrays nums1 and nums2.
    * nums1[i] = [idi, vali] indicate that the number with the id idi has a
      value equal to vali.
    * nums2[i] = [idi, vali] indicate that the number with the id idi has a
      value equal to vali.
    Each array contains unique ids and is sorted in ascending order by id.
    Merge the two arrays into one array that is sorted in ascending order by
    id, respecting the following conditions:
    * Only ids that appear in at least one of the two arrays should be included
      in the resulting array.
    * Each id should be included only once and its value should be the sum of
      the values of this id in the two arrays. If the id does not exist in one
      of the two arrays then its value in that array is considered to be 0.
    Return the resulting array. The returned array must be sorted in ascending
    order by id.

    Example 1:
    Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
    Output: [[1,6],[2,3],[3,2],[4,6]]
    Explanation: The resulting array contains the following:
                 - id = 1, the value of this id is 2 + 4 = 6.
                 - id = 2, the value of this id is 3.
                 - id = 3, the value of this id is 2.
                 - id = 4, the value of this id is 5 + 1 = 6.

    Example 2:
    Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
    Output: [[1,3],[2,4],[3,6],[4,3],[5,5]]
    Explanation: There are no common ids, so we just include each id with its
                 value in the resulting list.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 200
    * nums1[i].length == nums2[j].length == 2
    * 1 <= idi, vali <= 1000
    * Both arrays contain unique ids.
    * Both arrays are in strictly ascending order by id."""

    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        ans = []
        i = j = 0
        while i < len(nums1) or j < len(nums2):
            if j == len(nums2) or i < len(nums1) and nums1[i][0] <= nums2[j][0]:
                ans.append(nums1[i])
                i += 1
            else:
                if ans and ans[-1][0] == nums2[j][0]: ans[-1][1] += nums2[j][1]
                else: ans.append(nums2[j])
                j += 1
        return ans


    """2571. Minimum Operations to Reduce an Integer to 0 (Easy)
    You are given a positive integer n, you can do the following operation any
    number of times:
    * Add or subtract a power of 2 from n.
    Return the minimum number of operations to make n equal to 0. A number x is
    power of 2 if x == 2i where i >= 0.

    Example 1:
    Input: n = 39
    Output: 3
    Explanation: We can do the following operations:
                 - Add 20 = 1 to n, so now n = 40.
                 - Subtract 23 = 8 from n, so now n = 32.
                 - Subtract 25 = 32 from n, so now n = 0.
                 It can be shown that 3 is the minimum number of operations we
                 need to make n equal to 0.

    Example 2:
    Input: n = 54
    Output: 3
    Explanation: We can do the following operations:
                 - Add 21 = 2 to n, so now n = 56.
                 - Add 23 = 8 to n, so now n = 64.
                 - Subtract 26 = 64 from n, so now n = 0.
                 So the minimum number of operations is 3.

    Constraints: 1 <= n <= 10^5"""

    def minOperations(self, n: int) -> int:
        ans = carry = 0
        while n:
            carry += n & 1
            if carry == 1:
                if n & 2: carry = 1
                else: carry = 0
                ans += 1
            carry = min(1, carry)
            n >>= 1
        return ans + carry



    """2572. Count the Number of Square-Free Subsets (Medium)
    You are given a positive integer 0-indexed array nums. A subset of the
    array nums is square-free if the product of its elements is a square-free
    integer. A square-free integer is an integer that is divisible by no square
    number other than 1. Return the number of square-free non-empty subsets of
    the array nums. Since the answer may be too large, return it modulo
    10^9 + 7. A non-empty subset of nums is an array that can be obtained by
    deleting some (possibly none but not all) elements from nums. Two subsets
    are different if and only if the chosen indices to delete are different.

    Example 1:
    Input: nums = [3,4,4,5]
    Output: 3
    Explanation: There are 3 square-free subsets in this example:
                 - The subset consisting of the 0th element [3]. The product of
                   its elements is 3, which is a square-free integer.
                 - The subset consisting of the 3rd element [5]. The product of
                   its elements is 5, which is a square-free integer.
                 - The subset consisting of 0th and 3rd elements [3,5]. The
                   product of its elements is 15, which is a square-free
                   integer.
                 It can be proven that there are no more than 3 square-free
                 subsets in the given array.

    Example 2:
    Input: nums = [1]
    Output: 1
    Explanation: There is 1 square-free subset in this example:
                 - The subset consisting of the 0th element [1]. The product of
                   its elements is 1, which is a square-free integer.
                 It can be proven that there is no more than 1 square-free
                 subset in the given array.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 30"""

    def squareFreeSubsets(self, nums: List[int]) -> int:
        mod = 1_000_000_007
        primes = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29
        freq = Counter(nums)
        mask = [0]*31
        for x in range(2, 31):
            m, v = 0, 1
            for i, p in enumerate(primes):
                if x % p == 0:
                    v *= p
                    m ^= 1 << i
            if v == x: mask[x] = m
        dp = [[0]*32 for _ in range(1<<10)]
        for j in range(32): dp[0][j] = 1
        for i in range(1, 1<<10):
            for j in range(2, 31):
                for jj in range(j, 31):
                    if mask[jj] and mask[jj] & i == mask[jj]:
                        dp[i][j] += freq[jj] * dp[i ^ mask[jj]][jj+1]
        ans = 1
        for i in range(1, 1<<10): ans += dp[i][2]
        return (ans*pow(2, freq[1], mod)-1) % mod


    """2573. Find the String with LCP (Hard)
    We define the lcp matrix of any 0-indexed string word of n lowercase
    English letters as an n x n grid such that:
    * lcp[i][j] is equal to the length of the longest common prefix between the
      substrings word[i,n-1] and word[j,n-1].
    Given an n x n matrix lcp, return the alphabetically smallest string word
    that corresponds to lcp. If there is no such string, return an empty string.
    A string a is lexicographically smaller than a string b (of the same length)
    if in the first position where a and b differ, string a has a letter that
    appears earlier in the alphabet than the corresponding letter in b. For
    example, "aabd" is lexicographically smaller than "aaca" because the first
    position they differ is at the third letter, and 'b' comes before 'c'.

    Example 1:
    Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]
    Output: "abab"
    Explanation: lcp corresponds to any 4 letter string with two alternating
                 letters. The lexicographically smallest of them is "abab".

    Example 2:
    Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]
    Output: "aaaa"
    Explanation: lcp corresponds to any 4 letter string with a single distinct
                 letter. The lexicographically smallest of them is "aaaa".

    Example 3:
    Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]
    Output: ""
    Explanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of
                 only a single letter; Thus, no answer exists.

    Constraints:
    * 1 <= n == lcp.length == lcp[i].length <= 1000
    * 0 <= lcp[i][j] <= n"""

    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)
        ans = ['*'] * n
        c = 0
        for i in range(n):
            if lcp[i][i] != n-i: return ""
            for j in range(i+1, n):
                if lcp[i][j] != lcp[j][i] or lcp[i][j] and lcp[i][j] != 1 + (lcp[i+1][j+1] if i+1 < n and j+1 < n else 0): return ""
            if ans[i] == '*':
                for j in range(i, n):
                    if lcp[i][j]:
                        if ans[j] != '*' or c == 26: return ""
                        ans[j] = ascii_lowercase[c]
                c += 1
        return ''.join(ans)


    """2574. Left and Right Sum Differences (Easy)
    Given a 0-indexed integer array nums, find a 0-indexed integer array answer
    where:
    * answer.length == nums.length.
    * answer[i] = |leftSum[i] - rightSum[i]|.
    Where:
    * leftSum[i] is the sum of elements to the left of the index i in the array
      nums. If there is no such element, leftSum[i] = 0.
    * rightSum[i] is the sum of elements to the right of the index i in the
      array nums. If there is no such element, rightSum[i] = 0.
    Return the array answer.

    Example 1:
    Input: nums = [10,4,8,3]
    Output: [15,1,11,22]
    Explanation: The array leftSum is [0,10,14,22] and the array rightSum is
                 [15,11,3,0]. The array answer is
                 [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].

    Example 2:
    Input: nums = [1]
    Output: [0]
    Explanation: The array leftSum is [0] and the array rightSum is [0]. The
                 array answer is [|0 - 0|] = [0].

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5"""

    def leftRigthDifference(self, nums: List[int]) -> List[int]:
        ans = []
        diff = sum(nums)
        for x in nums:
            ans.append(abs(diff-x))
            diff -= 2*x
        return ans


    """2575. Find the Divisibility Array of a String (Medium)
    You are given a 0-indexed string word of length n consisting of digits, and
    a positive integer m. The divisibility array div of word is an integer
    array of length n such that:
    * div[i] = 1 if the numeric value of word[0,...,i] is divisible by m, or
    * div[i] = 0 otherwise.
    Return the divisibility array of word.

    Example 1:
    Input: word = "998244353", m = 3
    Output: [1,1,0,0,0,1,1,0,0]
    Explanation: There are only 4 prefixes that are divisible by 3: "9", "99",
                 "998244", and "9982443".

    Example 2:
    Input: word = "1010", m = 10
    Output: [0,1,0,1]
    Explanation: There are only 2 prefixes that are divisible by 10: "10", and
                 "1010".

    Constraints:
    * 1 <= n <= 10^5
    * word.length == n
    * word consists of digits from 0 to 9
    * 1 <= m <= 10^9"""

    def divisibilityArray(self, word: str, m: int) -> List[int]:
        ans = []
        prefix = 0
        for i, x in enumerate(word):
            prefix = 10*prefix + ord(x) - 48
            prefix %= m
            if prefix == 0: ans.append(1)
            else: ans.append(0)
        return ans


    """2576. Find the Maximum Number of Marked Indices (Medium)
    You are given a 0-indexed integer array nums. Initially, all of the indices
    are unmarked. You are allowed to make this operation any number of times:
    * Pick two different unmarked indices i and j such that
      2 * nums[i] <= nums[j], then mark i and j.
    Return the maximum possible number of marked indices in nums using the
    above operation any number of times.

    Example 1:
    Input: nums = [3,5,2,4]
    Output: 2
    Explanation: In the first operation: pick i = 2 and j = 1, the operation is
                 allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and
                 1. It can be shown that there's no other valid operation so
                 the answer is 2.

    Example 2:
    Input: nums = [9,2,5,4]
    Output: 4
    Explanation: In the first operation: pick i = 3 and j = 0, the operation is
                 allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and
                 0. In the second operation: pick i = 1 and j = 2, the
                 operation is allowed because 2 * nums[1] <= nums[2]. Then mark
                 index 1 and 2. Since there is no other operation, the answer
                 is 4.

    Example 3:
    Input: nums = [7,6,8]
    Output: 0
    Explanation: There is no valid operation to do, so the answer is 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:
        nums.sort()
        ans = 0
        j = len(nums)-1
        for i in range(len(nums)//2-1, -1, -1):
            if nums[i]*2 <= nums[j]:
                ans += 2
                j -= 1
        return ans


    """2577. Minimum Time to Visit a Cell In a Grid (Hard)
    You are given a m x n matrix grid consisting of non-negative integers where
    grid[row][col] represents the minimum time required to be able to visit the
    cell (row, col), which means you can visit the cell (row, col) only when
    the time you visit it is greater than or equal to grid[row][col]. You are
    standing in the top-left cell of the matrix in the 0th second, and you must
    move to any adjacent cell in the four directions: up, down, left, and right.
    Each move you make takes 1 second. Return the minimum time required in
    which you can visit the bottom-right cell of the matrix. If you cannot
    visit the bottom-right cell, then return -1.

    Example 1:
    Input: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
    Output: 7
    Explanation: One of the paths that we can take is the following:
                 - at t = 0, we are on the cell (0,0).
                 - at t = 1, we move to the cell (0,1). It is possible because
                   grid[0][1] <= 1.
                 - at t = 2, we move to the cell (1,1). It is possible because
                   grid[1][1] <= 2.
                 - at t = 3, we move to the cell (1,2). It is possible because
                   grid[1][2] <= 3.
                 - at t = 4, we move to the cell (1,1). It is possible because
                   grid[1][1] <= 4.
                 - at t = 5, we move to the cell (1,2). It is possible because
                   grid[1][2] <= 5.
                 - at t = 6, we move to the cell (1,3). It is possible because
                   grid[1][3] <= 6.
                 - at t = 7, we move to the cell (2,3). It is possible because
                   grid[1][3] <= 7.
                 The final time is 7. It can be shown that it is the minimum
                 time possible.

    Example 2:
    Input: grid = [[0,2,4],[3,2,1],[1,0,4]]
    Output: -1
    Explanation: There is no path from the top left to the bottom-right cell.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 1000
    * 4 <= m * n <= 10^5
    * 0 <= grid[i][j] <= 10^5
    * grid[0][0] == 0"""

    def minimumTime(self, grid: List[List[int]]) -> int:
        if grid[0][1] <= 1 or grid[1][0] <= 1:
            m, n = len(grid), len(grid[0])
            pq = [(0, 0, 0)]
            dist = defaultdict(lambda : inf, {(0, 0) : 0})
            while pq:
                x, i, j = heappop(pq)
                if (i, j) == (m-1, n-1): return x
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < m and 0 <= jj < n:
                        xx = x + 1 + max(0, (grid[ii][jj] - x)//2*2)
                        if dist[ii, jj] > xx:
                            heappush(pq, (xx, ii, jj))
                            dist[ii, jj] = xx
        return -1


    """2582. Pass the Pillow (Easy)
    There are n people standing in a line labeled from 1 to n. The first person
    in the line is holding a pillow initially. Every second, the person holding
    the pillow passes it to the next person standing in the line. Once the
    pillow reaches the end of the line, the direction changes, and people
    continue passing the pillow in the opposite direction.
    * For example, once the pillow reaches the nth person they pass it to the
      n - 1th person, then to the n - 2th person and so on.
    Given the two positive integers n and time, return the index of the person
    holding the pillow after time seconds.

    Example 1:
    Input: n = 4, time = 5
    Output: 2
    Explanation: People pass the pillow in the following way:
                 1 -> 2 -> 3 -> 4 -> 3 -> 2. Afer five seconds, the pillow is
                 given to the 2nd person.

    Example 2:
    Input: n = 3, time = 2
    Output: 3
    Explanation: People pass the pillow in the following way: 1 -> 2 -> 3. Afer
                 two seconds, the pillow is given to the 3rd person.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= time <= 1000"""

    def passThePillow(self, n: int, time: int) -> int:
        time %= 2*(n-1)
        if time > n-1: time = 2*(n-1) - time
        return time+1


    """2583. Kth Largest Sum in a Binary Tree (Medium)
    You are given the root of a binary tree and a positive integer k. The level
    sum in the tree is the sum of the values of the nodes that are on the same
    level. Return the kth largest level sum in the tree (not necessarily
    distinct). If there are fewer than k levels in the tree, return -1. Note
    that two nodes are on the same level if they have the same distance from
    the root.

    Example 1:
    Input: root = [5,8,9,2,1,3,7,4,6], k = 2
    Output: 13
    Explanation: The level sums are the following:
                 - Level 1: 5.
                 - Level 2: 8 + 9 = 17.
                 - Level 3: 2 + 1 + 3 + 7 = 13.
                 - Level 4: 4 + 6 = 10.
                 The 2nd largest level sum is 13.

    Example 2:
    Input: root = [1,2,null,3], k = 1
    Output: 3
    Explanation: The largest level sum is 3.

    Constraints:
    * The number of nodes in the tree is n.
    * 2 <= n <= 10^5
    * 1 <= Node.val <= 10^6
    * 1 <= k <= n"""

    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        vals = []
        stack = [(root, 0)]
        while stack:
            node, i = stack.pop()
            if i == len(vals): vals.append(0)
            vals[i] += node.val
            if node.left: stack.append((node.left, i+1))
            if node.right: stack.append((node.right, i+1))
        return sorted(vals, reverse=True)[k-1] if len(vals) >= k else -1


    """2584. Split the Array to Make Coprime Products (Medium)
    You are given a 0-indexed integer array nums of length n. A split at an
    index i where 0 <= i <= n - 2 is called valid if the product of the first
    i + 1 elements and the product of the remaining elements are coprime.
    * For example, if nums = [2, 3, 3], then a split at the index i = 0 is
      valid because 2 and 9 are coprime, while a split at the index i = 1 is
      not valid because 6 and 3 are not coprime. A split at the index i = 2 is
      not valid because i == n - 1.
    Return the smallest index i at which the array can be split validly or -1
    if there is no such split. Two values val1 and val2 are coprime if
    gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor
    of val1 and val2.

    Example 1:
    Input: nums = [4,7,8,15,3,5]
    Output: 2
    Explanation: The table above shows the values of the product of the first
                 i + 1 elements, the remaining elements, and their gcd at each
                 index i. The only valid split is at index 2.

    Example 2:
    Input: nums = [4,7,15,8,3,5]
    Output: -1
    Explanation: The table above shows the values of the product of the first
                 i + 1 elements, the remaining elements, and their gcd at each
                 index i. There is no valid split.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^4
    * 1 <= nums[i] <= 10^6"""

    def findValidSplit(self, nums: List[int]) -> int:
        freq = Counter()
        for x in nums:
            for p in range(2, isqrt(x)+1):
                while x % p == 0:
                    freq[p] += 1
                    x //= p
            if x > 1: freq[x] += 1
        ovlp = set()
        for i, x in enumerate(nums[:-1]):
            if i <= len(nums)-2:
                for p in range(2, isqrt(x)+1):
                    while x % p == 0:
                        ovlp.add(p)
                        x //= p
                        freq[p] -= 1
                        if freq[p] == 0: ovlp.remove(p)
                if x > 1:
                    ovlp.add(x)
                    freq[x] -= 1
                    if freq[x] == 0: ovlp.remove(x)
            if not ovlp: return i
        return -1


    """2585. Number of Ways to Earn Points (Hard)
    There is a test that has n types of questions. You are given an integer
    target and a 0-indexed 2D integer array types where
    types[i] = [counti, marksi] indicates that there are counti questions of
    the ith type, and each one of them is worth marksi points. Return the
    number of ways you can earn exactly target points in the exam. Since the
    answer may be too large, return it modulo 10^9 + 7. Note that questions of
    the same type are indistinguishable. For example, if there are 3 questions
    of the same type, then solving the 1st and 2nd questions is the same as
    solving the 1st and 3rd questions, or the 2nd and 3rd questions.

    Example 1:
    Input: target = 6, types = [[6,1],[3,2],[2,3]]
    Output: 7
    Explanation: You can earn 6 points in one of the seven ways:
                 - Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6
                 - Solve 4 questions of the 0th type and 1 question of the 1st
                   type: 1 + 1 + 1 + 1 + 2 = 6
                 - Solve 2 questions of the 0th type and 2 questions of the 1st
                   type: 1 + 1 + 2 + 2 = 6
                 - Solve 3 questions of the 0th type and 1 question of the 2nd
                   type: 1 + 1 + 1 + 3 = 6
                 - Solve 1 question of the 0th type, 1 question of the 1st type
                   and 1 question of the 2nd type: 1 + 2 + 3 = 6
                 - Solve 3 questions of the 1st type: 2 + 2 + 2 = 6
                 - Solve 2 questions of the 2nd type: 3 + 3 = 6

    Example 2:
    Input: target = 5, types = [[50,1],[50,2],[50,5]]
    Output: 4
    Explanation: You can earn 5 points in one of the four ways:
                 - Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5
                 - Solve 3 questions of the 0th type and 1 question of the 1st
                   type: 1 + 1 + 1 + 2 = 5
                 - Solve 1 questions of the 0th type and 2 questions of the 1st
                   type: 1 + 2 + 2 = 5
                 - Solve 1 question of the 2nd type: 5

    Example 3:
    Input: target = 18, types = [[6,1],[3,2],[2,3]]
    Output: 1
    Explanation: You can only earn 18 points by answering all questions.

    Constraints:
    * 1 <= target <= 1000
    * n == types.length
    * 1 <= n <= 50
    * types[i].length == 2
    * 1 <= counti, marksi <= 50"""

    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        n = len(types)
        dp = [[0]*(1+n) for _ in range(target+1)]
        for j in range(n+1): dp[0][j] = 1
        for i in range(1, target+1):
            for j in range(n-1, -1, -1):
                c, m = types[j]
                for x in range(c+1):
                    if i - x*m >= 0: dp[i][j] += dp[i-x*m][j+1]
                    else: break
                dp[i][j] %= 1_000_000_007
        return dp[target][0]


    """2586. Count the Number of Vowel Strings in Range (Easy)
    You are given a 0-indexed array of string words and two integers left and
    right. A string is called a vowel string if it starts with a vowel
    character and ends with a vowel character where vowel characters are 'a',
    'e', 'i', 'o', and 'u'. Return the number of vowel strings words[i] where i
    belongs to the inclusive range [left, right].

    Example 1:
    Input: words = ["are","amy","u"], left = 0, right = 2
    Output: 2
    Explanation: - "are" is a vowel string because it starts with 'a' and ends
                   with 'e'.
                 - "amy" is not a vowel string because it does not end with a
                   vowel.
                 - "u" is a vowel string because it starts with 'u' and ends
                   with 'u'.
                 The number of vowel strings in the mentioned range is 2.

    Example 2:
    Input: words = ["hey","aeo","mu","ooo","artro"], left = 1, right = 4
    Output: 3
    Explanation: - "aeo" is a vowel string because it starts with 'a' and ends
                   with 'o'.
                 - "mu" is not a vowel string because it does not start with a
                   vowel.
                 - "ooo" is a vowel string because it starts with 'o' and ends
                   with 'o'.
                 - "artro" is a vowel string because it starts with 'a' and
                   ends with 'o'.
                 The number of vowel strings in the mentioned range is 3.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 10
    * words[i] consists of only lowercase English letters.
    * 0 <= left <= right < words.length"""

    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(left <= i <= right and w[0] in "aeiou" and w[-1] in "aeiou" for i, w in enumerate(words))


    """2587. Rearrange Array to Maximize Prefix Score (Medium)
    You are given a 0-indexed integer array nums. You can rearrange the
    elements of nums to any order (including the given order). Let prefix be
    the array containing the prefix sums of nums after rearranging it. In other
    words, prefix[i] is the sum of the elements from 0 to i in nums after
    rearranging it. The score of nums is the number of positive integers in the
    array prefix. Return the maximum score you can achieve.

    Example 1:
    Input: nums = [2,-1,0,1,-3,3,-3]
    Output: 6
    Explanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].
                 prefix = [2,5,6,5,2,2,-1], so the score is 6. It can be shown
                 that 6 is the maximum score we can obtain.

    Example 2:
    Input: nums = [-2,-3,0]
    Output: 0
    Explanation: Any rearrangement of the array will result in a score of 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^6 <= nums[i] <= 10^6"""

    def maxScore(self, nums: List[int]) -> int:
        prefix = 0
        for i, x in enumerate(sorted(nums, reverse=True)):
            prefix += x
            if prefix <= 0: return i
        return len(nums)


    """2588. Count the Number of Beautiful Subarrays (Medium)
    You are given a 0-indexed integer array nums. In one operation, you can:
    * Choose two different indices i and j such that 0 <= i, j < nums.length.
    * Choose a non-negative integer k such that the kth bit (0-indexed) in the
      binary representation of nums[i] and nums[j] is 1.
    * Subtract 2k from nums[i] and nums[j].
    A subarray is beautiful if it is possible to make all of its elements equal
    to 0 after applying the above operation any number of times. Return the
    number of beautiful subarrays in the array nums. A subarray is a contiguous
    non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [4,3,1,2,4]
    Output: 2
    Explanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and
                 [4,3,1,2,4].
                 - We can make all elements in the subarray [3,1,2] equal to 0
                   in the following way:
                   - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers.
                     The subarray becomes [1, 1, 0].
                   - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers.
                     The subarray becomes [0, 0, 0].
                 - We can make all elements in the subarray [4,3,1,2,4] equal
                   to 0 in the following way:
                   - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both
                     numbers. The subarray becomes [0, 3, 1, 2, 0].
                   - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both
                     numbers. The subarray becomes [0, 2, 0, 2, 0].
                   - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both
                     numbers. The subarray becomes [0, 0, 0, 0, 0].

    Example 2:
    Input: nums = [1,10,4]
    Output: 0
    Explanation: There are no beautiful subarrays in nums.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6"""

    def beautifulSubarrays(self, nums: List[int]) -> int:
        ans = prefix = 0
        freq = Counter({0 : 1})
        for i, x in enumerate(nums):
            prefix ^= x
            ans += freq[prefix]
            freq[prefix] += 1
        return ans


    """2589. Minimum Time to Complete All Tasks (Hard)
    There is a computer that can run an unlimited number of tasks at the same
    time. You are given a 2D integer array tasks where
    tasks[i] = [starti, endi, durationi] indicates that the ith task should run
    for a total of durationi seconds (not necessarily continuous) within the
    inclusive time range [starti, endi]. You may turn on the computer only when
    it needs to run a task. You can also turn it off if it is idle. Return the
    minimum time during which the computer should be turned on to complete all
    tasks.

    Example 1:
    Input: tasks = [[2,3,1],[4,5,1],[1,5,2]]
    Output: 2
    Explanation: - The first task can be run in the inclusive time range [2, 2].
                 - The second task can be run in the inclusive time range [5, 5].
                 - The third task can be run in the two inclusive time ranges
                   [2, 2] and [5, 5].
                 The computer will be on for a total of 2 seconds.

    Example 2:
    Input: tasks = [[1,3,2],[2,5,3],[5,6,2]]
    Output: 4
    Explanation: - The first task can be run in the inclusive time range [2, 3].
                 - The second task can be run in the inclusive time ranges
                   [2, 3] and [5, 5].
                 - The third task can be run in the two inclusive time range
                   [5, 6].
                 The computer will be on for a total of 4 seconds.

    Constraints:
    * 1 <= tasks.length <= 2000
    * tasks[i].length == 3
    * 1 <= starti, endi <= 2000
    * 1 <= durationi <= endi - starti + 1"""

    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        line = [0]*2001
        for i, (lo, hi, time) in enumerate(sorted(tasks, key=lambda x: x[1])):
            cnt = sum(line[x] for x in range(lo, hi+1))
            time = max(0, time - cnt)
            for x in range(hi, lo-1, -1):
                if time and not line[x]:
                    line[x] = 1
                    time -= 1
        return sum(line)


    """2591. Distribute Money to Maximum Children (Easy)
    You are given an integer money denoting the amount of money (in dollars)
    that you have and another integer children denoting the number of children
    that you must distribute the money to. You have to distribute the money
    according to the following rules:
    * All money must be distributed.
    * Everyone must receive at least 1 dollar.
    * Nobody receives 4 dollars.
    Return the maximum number of children who may receive exactly 8 dollars if
    you distribute the money according to the aforementioned rules. If there is
    no way to distribute the money, return -1.

    Example 1:
    Input: money = 20, children = 3
    Output: 1
    Explanation: The maximum number of children with 8 dollars will be 1. One
                 of the ways to distribute the money is:
                 - 8 dollars to the first child.
                 - 9 dollars to the second child.
                 - 3 dollars to the third child.
                 It can be proven that no distribution exists such that number
                 of children getting 8 dollars is greater than 1.

    Example 2:
    Input: money = 16, children = 2
    Output: 2
    Explanation: Each child can be given 8 dollars.

    Constraints:
    * 1 <= money <= 200
    * 2 <= children <= 30"""

    def distMoney(self, money: int, children: int) -> int:
        if money < children: return -1
        if money > 8*children: return children-1
        q, r = divmod(money-children, 7)
        if q == children-1 and r == 3: q -= 1
        return q


    """2592. Maximize Greatness of an Array (Medium)
    You are given a 0-indexed integer array nums. You are allowed to permute
    nums into a new array perm of your choosing. We define the greatness of
    nums be the number of indices 0 <= i < nums.length for which
    perm[i] > nums[i]. Return the maximum possible greatness you can achieve
    after permuting nums.

    Example 1:
    Input: nums = [1,3,5,2,1,3,1]
    Output: 4
    Explanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].
                 At indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we
                 return 4.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 3
    Explanation: We can prove the optimal perm is [2,3,4,1]. At indices = 0, 1,
                 and 2, perm[i] > nums[i]. Hence, we return 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9"""

    def maximizeGreatness(self, nums: List[int]) -> int:
        nums.sort()
        k = 0
        for x in nums:
            if nums[k] < x: k += 1
        return k


    """2593. Find Score of an Array After Marking All Elements (Medium)
    You are given an array nums consisting of positive integers. Starting with
    score = 0, apply the following algorithm:
    * Choose the smallest integer of the array that is not marked. If there is
      a tie, choose the one with the smallest index.
    * Add the value of the chosen integer to score.
    * Mark the chosen element and its two adjacent elements if they exist.
    * Repeat until all the array elements are marked.
    Return the score you get after applying the above algorithm.

    Example 1:
    Input: nums = [2,1,3,4,5,2]
    Output: 7
    Explanation: We mark the elements as follows:
                 - 1 is the smallest unmarked element, so we mark it and its
                   two adjacent elements: [2,1,3,4,5,2].
                 - 2 is the smallest unmarked element, so we mark it and its
                   left adjacent element: [2,1,3,4,5,2].
                 - 4 is the only remaining unmarked element, so we mark it:
                   [2,1,3,4,5,2].
                 Our score is 1 + 2 + 4 = 7.

    Example 2:
    Input: nums = [2,3,5,1,3,2]
    Output: 5
    Explanation: We mark the elements as follows:
                 - 1 is the smallest unmarked element, so we mark it and its
                   two adjacent elements: [2,3,5,1,3,2].
                 - 2 is the smallest unmarked element, since there are two of
                   them, we choose the left-most one, so we mark the one at
                   index 0 and its right adjacent element: [2,3,5,1,3,2].
                 - 2 is the only remaining unmarked element, so we mark it:
                   [2,3,5,1,3,2].
                 Our score is 1 + 2 + 2 = 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def findScore(self, nums: List[int]) -> int:
        ans = 0
        pq = [(x, i) for i, x in enumerate(nums)]
        heapify(pq)
        mark = [False] * len(nums)
        while pq:
            x, i = heappop(pq)
            if not mark[i]:
                ans += x
                mark[i] = True
                if i: mark[i-1] = True
                if i+1 < len(nums): mark[i+1] = True
        return ans


    """2594. Minimum Time to Repair Cars (Medium)
    You are given an integer array ranks representing the ranks of some
    mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r
    can repair n cars in r * n2 minutes. You are also given an integer cars
    representing the total number of cars waiting in the garage to be repaired.
    Return the minimum time taken to repair all the cars. Note: All the
    mechanics can repair the cars simultaneously.

    Example 1:
    Input: ranks = [4,2,3,1], cars = 10
    Output: 16
    Explanation: - The first mechanic will repair two cars. The time required
                   is 4 * 2 * 2 = 16 minutes.
                 - The second mechanic will repair two cars. The time required
                   is 2 * 2 * 2 = 8 minutes.
                 - The third mechanic will repair two cars. The time required
                   is 3 * 2 * 2 = 12 minutes.
                 - The fourth mechanic will repair four cars. The time required
                   is 1 * 4 * 4 = 16 minutes.
                 It can be proved that the cars cannot be repaired in less than
                 16 minutes.

    Example 2:
    Input: ranks = [5,1,8], cars = 6
    Output: 16
    Explanation: - The first mechanic will repair one car. The time required is
                   5 * 1 * 1 = 5 minutes.
                 - The second mechanic will repair four cars. The time required
                   is 1 * 4 * 4 = 16 minutes.
                 - The third mechanic will repair one car. The time required is
                   8 * 1 * 1 = 8 minutes.
                 It can be proved that the cars cannot be repaired in less than
                 16 minutes.

    Constraints:
    * 1 <= ranks.length <= 10^5
    * 1 <= ranks[i] <= 100
    * 1 <= cars <= 10^6"""

    def repairCars(self, ranks: List[int], cars: int) -> int:
        lo, hi = 0, max(ranks)*cars**2
        while lo < hi:
            mid = lo + hi >> 1
            if sum(isqrt(mid//x) for x in ranks) < cars: lo = mid+1
            else: hi = mid
        return lo


    """2595. Number of Even and Odd Bits (Easy)
    You are given a positive integer n. Let even denote the number of even
    indices in the binary representation of n (0-indexed) with value 1. Let odd
    denote the number of odd indices in the binary representation of n
    (0-indexed) with value 1. Return an integer array answer where
    answer = [even, odd].

    Example 1:
    Input: n = 17
    Output: [2,0]
    Explanation: The binary representation of 17 is 10001. It contains 1 on the
                 0th and 4th indices. There are 2 even and 0 odd indices.

    Example 2:
    Input: n = 2
    Output: [0,1]
    Explanation: The binary representation of 2 is 10. It contains 1 on the 1st
                 index. There are 0 even and 1 odd indices.

    Constraints: 1 <= n <= 1000"""

    def evenOddBit(self, n: int) -> List[int]:
        ans = [0, 0]
        i = 0
        while n:
            if n&1: ans[i] += 1
            n >>= 1
            i ^= 1
        return ans


    """2596. Check Knight Tour Configuration (Medium)
    There is a knight on an n x n chessboard. In a valid configuration, the
    knight starts at the top-left cell of the board and visits every cell on
    the board exactly once. You are given an n x n integer matrix grid
    consisting of distinct integers from the range [0, n * n - 1] where
    grid[row][col] indicates that the cell (row, col) is the grid[row][col]th
    cell that the knight visited. The moves are 0-indexed. Return true if grid
    represents a valid configuration of the knight's movements or false
    otherwise. Note that a valid knight move consists of moving two squares
    vertically and one square horizontally, or two squares horizontally and one
    square vertically. The figure below illustrates all the possible eight
    moves of a knight from some cell.

    Example 1:
    Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
    Output: true
    Explanation: The above diagram represents the grid. It can be shown that it
                 is a valid configuration.

    Example 2:
    Input: grid = [[0,3,6],[5,8,1],[2,7,4]]
    Output: false
    Explanation: The above diagram represents the grid. The 8th move of the
                 knight is not valid considering its position after the 7th
                 move.

    Constraints:
    * n == grid.length == grid[i].length
    * 3 <= n <= 7
    * 0 <= grid[row][col] < n * n
    * All integers in grid are unique."""

    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        loc = {}
        for i in range(n):
            for j in range(n):
                loc[grid[i][j]] = (i, j)
        ii = jj = 0
        for x in range(1, n*n):
            i, j = loc[x]
            diff = (abs(i-ii), abs(j-jj))
            if diff not in ((1, 2), (2, 1)): return False
            ii, jj = i, j
        return True


    """2597. The Number of Beautiful Subsets (Medium)
    You are given an array nums of positive integers and a positive integer k.
    A subset of nums is beautiful if it does not contain two integers with an
    absolute difference equal to k. Return the number of non-empty beautiful
    subsets of the array nums. A subset of nums is an array that can be
    obtained by deleting some (possibly none) elements from nums. Two subsets
    are different if and only if the chosen indices to delete are different.

    Example 1:
    Input: nums = [2,4,6], k = 2
    Output: 4
    Explanation: The beautiful subsets of the array nums are: [2], [4], [6],
                 [2, 6]. It can be proved that there are only 4 beautiful
                 subsets in the array [2,4,6].

    Example 2:
    Input: nums = [1], k = 1
    Output: 1
    Explanation: The beautiful subset of the array nums is [1]. It can be
                 proved that there is only 1 beautiful subset in the array [1].

    Constraints:
    * 1 <= nums.length <= 20
    * 1 <= nums[i], k <= 1000"""

    def beautifulSubsets(self, nums: List[int], k: int) -> int:
        freq = Counter(nums)
        mp = defaultdict(list)
        for x in sorted(freq):
            mp[x-k].append(x)
            mp[x] = mp[x-k]
            mp.pop(x-k)
        ans = 1
        for v in mp.values():
            f0 = f1 = 1
            for x in v: f0, f1 = f1, f0*(2**freq[x]-1) + f1
            ans *= f1
        return ans-1


    """2598. Smallest Missing Non-negative Integer After Operations (Medium)
    You are given a 0-indexed integer array nums and an integer value. In one
    operation, you can add or subtract value from any element of nums.
    * For example, if nums = [1,2,3] and value = 2, you can choose to subtract
      value from nums[0] to make nums = [-1,2,3].
    The MEX (minimum excluded) of an array is the smallest missing non-
    negative integer in it.
    * For example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.
    Return the maximum MEX of nums after applying the mentioned operation any
    number of times.

    Example 1:
    Input: nums = [1,-10,7,13,6,8], value = 5
    Output: 4
    Explanation: One can achieve this result by applying the following
                 operations:
                 - Add value to nums[1] twice to make nums = [1,0,7,13,6,8]
                 - Subtract value from nums[2] once to make
                   nums = [1,0,2,13,6,8]
                 - Subtract value from nums[3] twice to make
                   nums = [1,0,2,3,6,8]
                 The MEX of nums is 4. It can be shown that 4 is the maximum
                 MEX we can achieve.

    Example 2:
    Input: nums = [1,-10,7,13,6,8], value = 7
    Output: 2
    Explanation: One can achieve this result by applying the following
                 operation:
                 - subtract value from nums[2] once to make
                   nums = [1,-10,0,13,6,8]
                 The MEX of nums is 2. It can be shown that 2 is the maximum
                 MEX we can achieve.

    Constraints:
    * 1 <= nums.length, value <= 10^5
    * -10^9 <= nums[i] <= 10^9"""

    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        freq = Counter(x % value for x in nums)
        k = 0
        for x in range(value):
            if freq[x] < freq[k]: k = x
        return k + freq[k]*value


    """2599. Make the Prefix Sum Non-negative (Medium)
    You are given a 0-indexed integer array nums. You can apply the following
    operation any number of times:
    * Pick any element from nums and put it at the end of nums.
    The prefix sum array of nums is an array prefix of the same length as nums
    such that prefix[i] is the sum of all the integers nums[j] where j is in
    the inclusive range [0, i]. Return the minimum number of operations such
    that the prefix sum array does not contain negative integers. The test
    cases are generated such that it is always possible to make the prefix sum
    array non-negative.

    Example 1:
    Input: nums = [2,3,-5,4]
    Output: 0
    Explanation: we do not need to do any operations. The array is [2,3,-5,4].
                 The prefix sum array is [2, 5, 0, 4].

    Example 2:
    Input: nums = [3,-5,-2,6]
    Output: 1
    Explanation: we can do one operation on index 1. The array after the
                 operation is [3,-2,6,-5]. The prefix sum array is [3, 1, 7, 2].

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9"""

    def makePrefSumNonNegative(self, nums: List[int]) -> int:
        ans = prefix = 0
        pq = []
        for x in nums:
            prefix += x
            heappush(pq, x)
            if prefix < 0:
                ans += 1
                xx = heappop(pq)
                prefix -= xx
                nums.append(xx)
        return ans


    """2600. K Items With the Maximum Sum (Easy)
    There is a bag that consists of items, each item has a number 1, 0, or -1
    written on it. You are given four non-negative integers numOnes, numZeros,
    numNegOnes, and k. The bag initially contains:
    * numOnes items with 1s written on them.
    * numZeroes items with 0s written on them.
    * numNegOnes items with -1s written on them.
    We want to pick exactly k items among the available items. Return the
    maximum possible sum of numbers written on the items.

    Example 1:
    Input: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2
    Output: 2
    Explanation: We have a bag of items with numbers written on them
                 {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and
                 get a sum in a total of 2. It can be proven that 2 is the
                 maximum possible sum.

    Example 2:
    Input: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4
    Output: 3
    Explanation: We have a bag of items with numbers written on them
                 {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1
                 item with 0 written on it, and get a sum in a total of 3. It
                 can be proven that 3 is the maximum possible sum.

    Constraints:
    * 0 <= numOnes, numZeros, numNegOnes <= 50
    * 0 <= k <= numOnes + numZeros + numNegOnes"""

    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:
        return min(k, numOnes, 2*numOnes+numZeros-k)


    """2601. Prime Subtraction Operation (Medium)
    You are given a 0-indexed integer array nums of length n. You can perform
    the following operation as many times as you want:
    * Pick an index i that you haven’t picked before, and pick a prime p
      strictly less than nums[i], then subtract p from nums[i].
    Return true if you can make nums a strictly increasing array using the
    above operation and false otherwise. A strictly increasing array is an
    array whose each element is strictly greater than its preceding element.

    Example 1:
    Input: nums = [4,9,6,10]
    Output: true
    Explanation: In the first operation: Pick i = 0 and p = 3, and then
                 subtract 3 from nums[0], so that nums becomes [1,9,6,10]. In
                 the second operation: i = 1, p = 7, subtract 7 from nums[1],
                 so nums becomes equal to [1,2,6,10]. After the second
                 operation, nums is sorted in strictly increasing order, so the
                 answer is true.

    Example 2:
    Input: nums = [6,8,11,12]
    Output: true
    Explanation: Initially nums is sorted in strictly increasing order, so we
                 don't need to make any operations.

    Example 3:
    Input: nums = [5,8,3]
    Output: false
    Explanation: It can be proven that there is no way to perform operations to
                 make nums sorted in strictly increasing order, so the answer
                 is false.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000
    * nums.length == n"""

    def primeSubOperation(self, nums: List[int]) -> bool:
        sieve = [True]*1001
        sieve[0] = sieve[1] = False
        for x in range(2, isqrt(1000)+1):
            if sieve[x]:
                for xx in range(x*x, 1001, x):
                    sieve[xx] = False
        prev = 0
        for x in nums:
            if prev >= x: return False
            for p in range(x-1, -1, -1):
                if sieve[p] and x-p > prev: break
            prev = x - p
        return True


    """2602. Minimum Operations to Make All Array Elements Equal (Medium)
    You are given an array nums consisting of positive integers. You are also
    given an integer array queries of size m. For the ith query, you want to
    make all of the elements of nums equal to queries[i]. You can perform the
    following operation on the array any number of times:
    * Increase or decrease an element of the array by 1.
    Return an array answer of size m where answer[i] is the minimum number of
    operations to make all elements of nums equal to queries[i]. Note that
    after each query the array is reset to its original state.

    Example 1:
    Input: nums = [3,1,6,8], queries = [1,5]
    Output: [14,10]
    Explanation: For the first query we can do the following operations:
                 - Decrease nums[0] 2 times, so that nums = [1,1,6,8].
                 - Decrease nums[2] 5 times, so that nums = [1,1,1,8].
                 - Decrease nums[3] 7 times, so that nums = [1,1,1,1].
                 So the total number of operations for the first query is
                 2 + 5 + 7 = 14. For the second query we can do the following
                 operations:
                 - Increase nums[0] 2 times, so that nums = [5,1,6,8].
                 - Increase nums[1] 4 times, so that nums = [5,5,6,8].
                 - Decrease nums[2] 1 time, so that nums = [5,5,5,8].
                 - Decrease nums[3] 3 times, so that nums = [5,5,5,5].
                 So the total number of operations for the second query is
                 2 + 4 + 1 + 3 = 10.

    Example 2:
    Input: nums = [2,9,6,3], queries = [10]
    Output: [20]
    Explanation: We can increase each value in the array to 10. The total
                 number of operations will be 8 + 1 + 4 + 7 = 20.

    Constraints:
    * n == nums.length
    * m == queries.length
    * 1 <= n, m <= 10^5
    * 1 <= nums[i], queries[i] <= 10^9"""

    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:
        nums.sort()
        total = sum(nums)
        prefix = k = 0
        ans = [0]*len(queries)
        for i, q in sorted(enumerate(queries), key=lambda x: x[1]):
            while k < len(nums) and nums[k] <= q:
                prefix += nums[k]
                k += 1
            ans[i] = total - 2*prefix + q*(2*k-len(nums))
        return ans


    """2603. Collect Coins in a Tree (Hard)
    There exists an undirected and unrooted tree with n nodes indexed from 0 to
    n - 1. You are given an integer n and a 2D integer array edges of length
    n - 1, where edges[i] = [ai, bi] indicates that there is an edge between
    nodes ai and bi in the tree. You are also given an array coins of size n
    where coins[i] can be either 0 or 1, where 1 indicates the presence of a
    coin in the vertex i. Initially, you choose to start at any vertex in the
    tree. Then, you can perform the following operations any number of times:
    * Collect all the coins that are at a distance of at most 2 from the
      current vertex, or
    * Move to any adjacent vertex in the tree.
    Find the minimum number of edges you need to go through to collect all the
    coins and go back to the initial vertex. Note that if you pass an edge
    several times, you need to count it into the answer several times.

    Example 1:
    Input: coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]
    Output: 2
    Explanation: Start at vertex 2, collect the coin at vertex 0, move to
                 vertex 3, collect the coin at vertex 5 then move back to
                 vertex 2.

    Example 2:
    Input: coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]
    Output: 2
    Explanation: Start at vertex 0, collect the coins at vertices 4 and 3, move
                 to vertex 2,  collect the coin at vertex 7, then move back to
                 vertex 0.

    Constraints:
    * n == coins.length
    * 1 <= n <= 3 * 10^4
    * 0 <= coins[i] <= 1
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * edges represents a valid tree."""

    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:
        n = len(coins)
        tree = [set() for _ in range(n)]
        for u, v in edges:
            tree[u].add(v)
            tree[v].add(u)
        leaf = deque()
        for u in range(n):
            while len(tree[u]) == 1 and not coins[u]:
                v = tree[u].pop()
                tree[v].remove(u)
                u = v
            if len(tree[u]) == 1: leaf.append(u)
        for _ in range(2):
            for _ in range(len(leaf)):
                u = leaf.popleft()
                if tree[u]:
                    v = tree[u].pop()
                    tree[v].remove(u)
                    if len(tree[v]) == 1: leaf.append(v)
        return sum(len(tree[u]) for u in range(n))


    """2604. Minimum Time to Eat All Grains (Hard)
    There are n hens and m grains on a line. You are given the initial
    positions of the hens and the grains in two integer arrays hens and grains
    of size n and m respectively. Any hen can eat a grain if they are on the
    same position. The time taken for this is negligible. One hen can also eat
    multiple grains. In 1 second, a hen can move right or left by 1 unit. The
    hens can move simultaneously and independently of each other. Return the
    minimum time to eat all grains if the hens act optimally.

    Example 1:
    Input: hens = [3,6,7], grains = [2,4,7,9]
    Output: 2
    Explanation: One of the ways hens eat all grains in 2 seconds is described
                 below:
                 - The first hen eats the grain at position 2 in 1 second.
                 - The second hen eats the grain at position 4 in 2 seconds.
                 - The third hen eats the grains at positions 7 and 9 in 2
                   seconds.
                 So, the maximum time needed is 2. It can be proven that the
                 hens cannot eat all grains before 2 seconds.

    Example 2:
    Input: hens = [4,6,109,111,213,215], grains = [5,110,214]
    Output: 1
    Explanation: One of the ways hens eat all grains in 1 second is described
                 below:
                 - The first hen eats the grain at position 5 in 1 second.
                 - The fourth hen eats the grain at position 110 in 1 second.
                 - The sixth hen eats the grain at position 214 in 1 second.
                 - The other hens do not move.
                 So, the maximum time needed is 1.

    Constraints:
    * 1 <= hens.length, grains.length <= 2*10^4
    * 0 <= hens[i], grains[j] <= 10^9"""

    def minimumTime(self, hens: List[int], grains: List[int]) -> int:
        hens.sort()
        grains.sort()
        lo, hi = 0, 1_000_000_000
        while lo < hi:
            mid = lo + hi >> 1
            i = 0
            for k, h in enumerate(hens):
                ii = i
                while i < len(grains) and (grains[i] <= h and h-grains[i] <= mid or h <= grains[ii] and grains[i]-h <= mid or grains[ii] <= h <= grains[i] and grains[i]-grains[ii] + min(grains[i]-h, h-grains[ii]) <= mid): i += 1
            if i == len(grains): hi = mid
            else: lo = mid + 1
        return lo


    """2605. Form Smallest Number From Two Digit Arrays (Easy)
    Given two arrays of unique digits nums1 and nums2, return the smallest
    number that contains at least one digit from each array.

    Example 1:
    Input: nums1 = [4,1,3], nums2 = [5,7]
    Output: 15
    Explanation: The number 15 contains the digit 1 from nums1 and the digit 5
                 from nums2. It can be proven that 15 is the smallest number we
                 can have.

    Example 2:
    Input: nums1 = [3,5,2,6], nums2 = [3,1,7]
    Output: 3
    Explanation: The number 3 contains the digit 3 which exists in both arrays.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 9
    * 1 <= nums1[i], nums2[i] <= 9
    * All digits in each array are unique."""

    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        inter = set(nums1) & set(nums2)
        if inter: return min(inter)
        d1 = min(nums1)
        d2 = min(nums2)
        return 10*min(d1, d2) + max(d1, d2)


    """2606. Find the Substring With Maximum Cost (Medium)
    You are given a string s, a string chars of distinct characters and an
    integer array vals of the same length as chars. The cost of the substring
    is the sum of the values of each character in the substring. The cost of an
    empty string is considered 0. The value of the character is defined in the
    following way:
    * If the character is not in the string chars, then its value is its
      corresponding position (1-indexed) in the alphabet.
      + For example, the value of 'a' is 1, the value of 'b' is 2, and so on.
        The value of 'z' is 26.
    * Otherwise, assuming i is the index where the character occurs in the
      string chars, then its value is vals[i].
    Return the maximum cost among all substrings of the string s.

    Example 1:
    Input: s = "adaa", chars = "d", vals = [-1000]
    Output: 2
    Explanation: The value of the characters "a" and "d" is 1 and -1000
                 respectively. The substring with the maximum cost is "aa" and
                 its cost is 1 + 1 = 2. It can be proven that 2 is the maximum
                 cost.

    Example 2:
    Input: s = "abc", chars = "abc", vals = [-1,-1,-1]
    Output: 0
    Explanation: The value of the characters "a", "b" and "c" is -1, -1, and -1
                 respectively. The substring with the maximum cost is the empty
                 substring "" and its cost is 0. It can be proven that 0 is the
                 maximum cost.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consist of lowercase English letters.
    * 1 <= chars.length <= 26
    * chars consist of distinct lowercase English letters.
    * vals.length == chars.length
    * -1000 <= vals[i] <= 1000"""

    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:
        mp = dict(zip(chars, vals))
        ans = val = 0
        for i, ch in enumerate(s):
            val = max(0, val + mp.get(ch, ord(ch)-96))
            ans = max(ans, val)
        return ans


    """2607. Make K-Subarray Sums Equal (Medium)
    You are given a 0-indexed integer array arr and an integer k. The array arr
    is circular. In other words, the first element of the array is the next
    element of the last element, and the last element of the array is the
    previous element of the first element. You can do the following operation
    any number of times:
    * Pick any element from arr and increase or decrease it by 1.
    Return the minimum number of operations such that the sum of each subarray
    of length k is equal. A subarray is a contiguous part of the array.

    Example 1:
    Input: arr = [1,4,1,3], k = 2
    Output: 1
    Explanation: we can do one operation on index 1 to make its value equal to
                 3. The array after the operation is [1,3,1,3]
                 - Subarray starts at index 0 is [1, 3], and its sum is 4
                 - Subarray starts at index 1 is [3, 1], and its sum is 4
                 - Subarray starts at index 2 is [1, 3], and its sum is 4
                 - Subarray starts at index 3 is [3, 1], and its sum is 4

    Example 2:
    Input: arr = [2,5,5,7], k = 3
    Output: 5
    Explanation: we can do three operations on index 0 to make its value equal
                 to 5 and two operations on index 3 to make its value equal to
                 5. The array after the operations is [5,5,5,5]
                 - Subarray starts at index 0 is [5, 5, 5], and its sum is 15
                 - Subarray starts at index 1 is [5, 5, 5], and its sum is 15
                 - Subarray starts at index 2 is [5, 5, 5], and its sum is 15
                 - Subarray starts at index 3 is [5, 5, 5], and its sum is 15

    Constraints:
    * 1 <= k <= arr.length <= 10^5
    * 1 <= arr[i] <= 10^9"""

    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:
        ans = 0
        g = gcd(len(arr), k)
        for i in range(g):
            vals = []
            for _ in range(len(arr)//g):
                vals.append(arr[i])
                i = (i+k) % len(arr)
            vals.sort()
            cand = vals[len(vals)//2]
            ans += sum(abs(x-cand) for x in vals)
        return ans


    """2608. Shortest Cycle in a Graph (Hard)
    There is a bi-directional graph with n vertices, where each vertex is
    labeled from 0 to n - 1. The edges in the graph are represented by a given
    2D integer array edges, where edges[i] = [ui, vi] denotes an edge between
    vertex ui and vertex vi. Every vertex pair is connected by at most one
    edge, and no vertex has an edge to itself. Return the length of the
    shortest cycle in the graph. If no cycle exists, return -1. A cycle is a
    path that starts and ends at the same node, and each edge in the path is
    used only once.

    Example 1:
    Input: n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]
    Output: 3
    Explanation: The cycle with the smallest length is : 0 -> 1 -> 2 -> 0

    Example 2:
    Input: n = 4, edges = [[0,1],[0,2]]
    Output: -1
    Explanation: There are no cycles in this graph.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= edges.length <= 1000
    * edges[i].length == 2
    * 0 <= ui, vi < n
    * ui != vi
    * There are no repeated edges."""

    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        ans = inf
        for u in range(n):
            dist = {}
            queue = deque([(u, -1, 0)])
            while queue:
                u, p, d = queue.popleft()
                if u in dist:
                    ans = min(ans, d + dist[u])
                    break
                dist[u] = d
                for v in graph[u]:
                    if v != p: queue.append((v, u, d+1))
        return ans if ans < inf else -1


    """2609. Find the Longest Balanced Substring of a Binary String (Easy)
    You are given a binary string s consisting only of zeroes and ones. A
    substring of s is considered balanced if all zeroes are before ones and the
    number of zeroes is equal to the number of ones inside the substring.
    Notice that the empty substring is considered a balanced substring. Return
    the length of the longest balanced substring of s. A substring is a
    contiguous sequence of characters within a string.

    Example 1:
    Input: s = "01000111"
    Output: 6
    Explanation: The longest balanced substring is "000111", which has length 6.

    Example 2:
    Input: s = "00111"
    Output: 4
    Explanation: The longest balanced substring is "0011", which has length 4.

    Example 3:
    Input: s = "111"
    Output: 0
    Explanation: There is no balanced substring except the empty substring, so
                 the answer is 0.

    Constraints:
    * 1 <= s.length <= 50
    * '0' <= s[i] <= '1'"""

    def findTheLongestBalancedSubstring(self, s: str) -> int:
        ans = val = 0
        for k, grp in groupby(s):
            cand = len(list(grp))
            if k == '0': val = cand
            else:
                val = min(val, cand)
                ans = max(2*val, ans)
        return ans


    """2610. Convert an Array Into a 2D Array With Conditions (Medium)
    You are given an integer array nums. You need to create a 2D array from
    nums satisfying the following conditions:
    * The 2D array should contain only the elements of the array nums.
    * Each row in the 2D array contains distinct integers.
    * The number of rows in the 2D array should be minimal.
    Return the resulting array. If there are multiple answers, return any of
    them. Note that the 2D array can have a different number of elements on
    each row.

    Example 1:
    Input: nums = [1,3,4,1,2,3,1]
    Output: [[1,3,4,2],[1,3],[1]]
    Explanation: We can create a 2D array that contains the following rows:
                 - 1,3,4,2
                 - 1,3
                 - 1
                 All elements of nums were used, and each row of the 2D array
                 contains distinct integers, so it is a valid answer. It can be
                 shown that we cannot have less than 3 rows in a valid array.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: [[4,3,2,1]]
    Explanation: All elements of the array are distinct, so we can keep all of
                 them in the first row of the 2D array.

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= nums.length"""

    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        freq = Counter(nums)
        m = max(freq.values())
        ans = [[] for _ in range(m)]
        for k, v in freq.items():
            for i in range(v): ans[i].append(k)
        return ans


    """2611. Mice and Cheese (Medium)
    There are two mice and n different types of cheese, each type of cheese
    should be eaten by exactly one mouse. A point of the cheese with index i
    (0-indexed) is:
    * reward1[i] if the first mouse eats it.
    * reward2[i] if the second mouse eats it.
    You are given a positive integer array reward1, a positive integer array
    reward2, and a non-negative integer k. Return the maximum points the mice
    can achieve if the first mouse eats exactly k types of cheese.

    Example 1:
    Input: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2
    Output: 15
    Explanation: In this example, the first mouse eats the 2nd (0-indexed) and
                 the 3rd types of cheese, and the second mouse eats the 0th and
                 the 1st types of cheese. The total points are
                 4 + 4 + 3 + 4 = 15. It can be proven that 15 is the maximum
                 total points that the mice can achieve.

    Example 2:
    Input: reward1 = [1,1], reward2 = [1,1], k = 2
    Output: 2
    Explanation: In this example, the first mouse eats the 0th (0-indexed) and
                 1st types of cheese, and the second mouse does not eat any
                 cheese. The total points are 1 + 1 = 2. It can be proven that
                 2 is the maximum total points that the mice can achieve.

    Constraints:
    * 1 <= n == reward1.length == reward2.length <= 10^5
    * 1 <= reward1[i], reward2[i] <= 1000
    * 0 <= k <= n"""

    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        return sum(reward2) + sum(nlargest(k, (x-y for x, y in zip(reward1, reward2))))


    """2612. Minimum Reverse Operations (Hard)
    You are given an integer n and an integer p in the range [0, n - 1].
    Representing a 0-indexed array arr of length n where all positions are set
    to 0's, except position p which is set to 1. You are also given an integer
    array banned containing some positions from the array. For the ith position
    in banned, arr[banned[i]] = 0, and banned[i] != p. You can perform multiple
    operations on arr. In an operation, you can choose a subarray with size k
    and reverse the subarray. However, the 1 in arr should never go to any of
    the positions in banned. In other words, after each operation
    arr[banned[i]] remains 0. Return an array ans where for each i from
    [0, n - 1], ans[i] is the minimum number of reverse operations needed to
    bring the 1 to position i in arr, or -1 if it is impossible.
    * A subarray is a contiguous non-empty sequence of elements within an array.
    * The values of ans[i] are independent for all i's.
    * The reverse of an array is an array containing the values in reverse
      order.

    Example 1:
    Input: n = 4, p = 0, banned = [1,2], k = 4
    Output: [0,-1,-1,1]
    Explanation: In this case k = 4 so there is only one possible reverse
                 operation we can perform, which is reversing the whole array.
                 Initially, 1 is placed at position 0 so the amount of
                 operations we need for position 0 is 0. We can never place a 1
                 on the banned positions, so the answer for positions 1 and 2
                 is -1. Finally, with one reverse operation we can bring the 1
                 to index 3, so the answer for position 3 is 1.

    Example 2:
    Input: n = 5, p = 0, banned = [2,4], k = 3
    Output: [0,-1,-1,-1,-1]
    Explanation: In this case the 1 is initially at position 0, so the answer
                 for that position is 0. We can perform reverse operations of
                 size 3. The 1 is currently located at position 0, so we need
                 to reverse the subarray [0, 2] for it to leave that position,
                 but reversing that subarray makes position 2 have a 1, which
                 shouldn't happen. So, we can't move the 1 from position 0,
                 making the result for all the other positions -1.

    Example 3:
    Input: n = 4, p = 2, banned = [0,1,3], k = 1
    Output: [-1,-1,0,-1]
    Explanation: In this case we can only perform reverse operations of size 1.
                 So the 1 never changes its position.

    Constraints:
    * 1 <= n <= 10^5
    * 0 <= p <= n - 1
    * 0 <= banned.length <= n - 1
    * 0 <= banned[i] <= n - 1
    * 1 <= k <= n
    * banned[i] != p
    * all values in banned are unique"""

    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:
        ans = [-1]*n
        banned = set(banned)
        avail = [SortedList(), SortedList()]
        for i in range(n):
            if i not in banned: avail[i&1].add(i)
        queue = deque([p])
        avail[p&1].remove(p)
        val = 0
        while queue:
            for _ in range(len(queue)):
                v = queue.popleft()
                ans[v] = val
                lo = abs(v-k+1)
                hi = n-1-abs(n-v-k)
                for i in list(avail[lo&1].irange(lo, hi)):
                    queue.append(i)
                    avail[lo&1].remove(i)
            val += 1
        return ans


    """2613. Beautiful Pairs (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2 of the same
    length. A pair of indices (i,j) is called beautiful if
    |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]| is the smallest amongst all
    possible indices pairs where i < j. Return the beautiful pair. In the case
    that there are multiple beautiful pairs, return the lexicographically
    smallest pair. Note that
    * |x| denotes the absolute value of x.
    * A pair of indices (i1, j1) is lexicographically smaller than (i2, j2) if
      i1 < i2 or i1 == i2 and j1 < j2.

    Example 1:
    Input: nums1 = [1,2,3,2,4], nums2 = [2,3,1,2,3]
    Output: [0,3]
    Explanation: Consider index 0 and index 3. The value of
                 |nums1[i]-nums1[j]| + |nums2[i]-nums2[j]| is 1, which is the
                 smallest value we can achieve.

    Example 2:
    Input: nums1 = [1,2,4,3,2,5], nums2 = [1,4,2,3,5,1]
    Output: [1,4]
    Explanation: Consider index 1 and index 4. The value of
                 |nums1[i]-nums1[j]| + |nums2[i]-nums2[j]| is 1, which is the
                 smallest value we can achieve.

    Constraints:
    * 2 <= nums1.length, nums2.length <= 10^5
    * nums1.length == nums2.length
    * 0 <= nums1i <= nums1.length
    * 0 <= nums2i <= nums2.length"""

    def beautifulPair(self, nums1: List[int], nums2: List[int]) -> List[int]:
        points = sorted(((i, x, y) for i, (x, y) in enumerate(zip(nums1, nums2))), key = lambda x : x[1])

        def fn(lo, hi):
            """Return the minimum distance and the corresponding pair."""
            if lo+1 == hi: return inf, -1, -1
            if lo+2 == hi:
                delta = abs(points[lo][1]-points[lo+1][1]) + abs(points[lo][2]-points[lo+1][2])
                i, ii = points[lo][0], points[lo+1][0]
                if i > ii: i, ii = ii, i
            else:
                mid = lo + hi >> 1
                ld, li, lii = fn(lo, mid)
                rd, ri, rii = fn(mid, hi)
                if (ld, li, lii) < (rd, ri, rii): delta, i, ii = ld, li, lii
                else: delta, i, ii = rd, ri, rii
                split = points[mid][1]
                strip = sorted((points[k] for k in range(lo, hi) if split - delta <= points[k][1] <= split + delta), key = lambda x : x[2])
                for l, (k, x, y) in enumerate(strip):
                    for kk, xx, yy in strip[l+1 : l+10]:
                        cand = abs(x-xx) + abs(y-yy)
                        j, jj = min(k, kk), max(k, kk)
                        if (cand, j, jj) < (delta, i, ii): delta, i, ii = cand, j, jj
            return delta, i, ii

        return fn(0, len(nums1))[1:]


    """2614. Prime In Diagonal (Easy)
    You are given a 0-indexed two-dimensional integer array nums. Return the
    largest prime number that lies on at least one of the diagonals of nums. In
    case, no prime is present on any of the diagonals, return 0. Note that:
    * An integer is prime if it is greater than 1 and has no positive integer
      divisors other than 1 and itself.
    * An integer val is on one of thediagonals of nums if there exists an
      integer i for which nums[i][i] = val or an i for which
      nums[i][nums.length - i - 1]= val.
    In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].

    Example 1:
    Input: nums = [[1,2,3],[5,6,7],[9,10,11]]
    Output: 11
    Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on
                 at least one of the diagonals. Since 11 is the largest prime,
                 we return 11.

    Example 2:
    Input: nums = [[1,2,3],[5,17,7],[9,11,10]]
    Output: 17
    Explanation: The numbers 1, 3, 9, 10, and 17 are all present on at least
                 one of the diagonals. 17 is the largest prime, so we return 17.

    Constraints:
    * 1 <= nums.length <= 300
    * nums.length == numsi.length
    * 1 <= nums[i][j] <= 4*10^6"""

    def diagonalPrime(self, nums: List[List[int]]) -> int:
        fn = lambda x : x > 1 and all(x % p for p in range(2, isqrt(x)+1))
        ans = 0
        for i in range(len(nums)):
            if fn(nums[i][i]): ans = max(ans, nums[i][i])
            if fn(nums[i][len(nums)-1-i]): ans = max(ans, nums[i][len(nums)-1-i])
        return ans


    """2615. Sum of Distances (Medium)
    You are given a 0-indexed integer array nums. There exists an array arr of
    length nums.length, where arr[i] is the sum of |i - j| over all j such that
    nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0.
    Return the array arr.

    Example 1:
    Input: nums = [1,3,1,1,2]
    Output: [5,0,3,4,0]
    Explanation: - When i = 0, nums[0] == nums[2] and nums[0] == nums[3].
                 Therefore, arr[0] = |0 - 2| + |0 - 3| = 5.
                 - When i = 1, arr[1] = 0 because there is no other index with
                   value 3.
                 - When i = 2, nums[2] == nums[0] and nums[2] == nums[3].
                   Therefore, arr[2] = |2 - 0| + |2 - 3| = 3.
                 - When i = 3, nums[3] == nums[0] and nums[3] == nums[2].
                   Therefore, arr[3] = |3 - 0| + |3 - 2| = 4.
                 - When i = 4, arr[4] = 0 because there is no other index with
                   value 2.

    Example 2:
    Input: nums = [0,5,3]
    Output: [0,0,0]
    Explanation: Since each element in nums is distinct, arr[i] = 0 for all i.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9"""

    def distance(self, nums: List[int]) -> List[int]:
        mp = defaultdict(list)
        for i, x in enumerate(nums): mp[x].append(i)
        ans = [0]*len(nums)
        for idx in mp.values():
            prefix = list(accumulate(idx, initial=0))
            for i, v in enumerate(idx):
                ans[v] = prefix[-1] - 2*prefix[i] + (2*i - len(idx))*idx[i]
        return ans


    """2616. Minimize the Maximum Difference of Pairs (Medium)
    You are given a 0-indexed integer array nums and an integer p. Find p pairs
    of indices of nums such that the maximum difference amongst all the pairs
    is minimized. Also, ensure no index appears more than once amongst the p
    pairs. Note that for a pair of elements at the index i and j, the
    difference of this pair is |nums[i] - nums[j]|, where |x| represents the
    absolute value of x. Return the minimum maximum difference among all p
    pairs.

    Example 1:
    Input: nums = [10,1,2,7,1,3], p = 2
    Output: 1
    Explanation: The first pair is formed from the indices 1 and 4, and the
                 second pair is formed from the indices 2 and 5. The maximum
                 difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|)
                 = max(0, 1) = 1. Therefore, we return 1.

    Example 2:
    Input: nums = [4,2,1,2], p = 1
    Output: 0
    Explanation: Let the indices 1 and 3 form a pair. The difference of that
                 pair is |2 - 2| = 0, which is the minimum we can attain.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 0 <= p <= (nums.length)/2"""

    def minimizeMax(self, nums: List[int], p: int) -> int:
        nums.sort()
        lo, hi = 0, 1_000_000_000
        while lo < hi:
            mid = lo + hi >> 1
            cnt = i = 0
            while i < len(nums):
                if i+1 < len(nums) and nums[i+1] - nums[i] <= mid:
                    cnt += 1
                    i += 1
                i += 1
            if cnt < p: lo = mid + 1
            else: hi = mid
        return lo


    """2617. Minimum Number of Visited Cells in a Grid (Hard)
    You are given a 0-indexed m x n integer matrix grid. Your initial position
    is at the top-left cell (0, 0). Starting from the cell (i, j), you can move
    to one of the following cells:
    * Cells (i, k) with j < k <= grid[i][j] + j (rightward movement), or
    * Cells (k, j) with i < k <= grid[i][j] + i (downward movement).
    Return the minimum number of cells you need to visit to reach the bottom-
    right cell (m - 1, n - 1). If there is no valid path, return -1.

    Example 1:
    Input: grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
    Output: 4
    Explanation: The image above shows one of the paths that visits exactly 4 cells.

    Example 2:
    Input: grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
    Output: 3
    Explanation: The image above shows one of the paths that visits exactly 3 cells.

    Example 3:
    Input: grid = [[2,1,0],[1,0,0]]
    Output: -1
    Explanation: It can be proven that no path exists.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 105
    * 1 <= m * n <= 105
    * 0 <= grid[i][j] < m * n
    * grid[m - 1][n - 1] == 0"""

    def minimumVisitedCells(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        pqs = [[] for _ in range(n)]
        dist = [[inf]*n for _ in range(m)]
        dist[0][0] = 1
        for i in range(m):
            pq = []
            for j in range(n):
                while pq and pq[0][1] < j: heappop(pq)
                while pqs[j] and pqs[j][0][1] < i: heappop(pqs[j])
                if pq: dist[i][j] = min(dist[i][j], pq[0][0] + 1)
                if pqs[j]: dist[i][j] = min(dist[i][j], pqs[j][0][0] + 1)
                if dist[i][j] < inf:
                    heappush(pq, (dist[i][j], j + grid[i][j]))
                    heappush(pqs[j], (dist[i][j], i + grid[i][j]))
        return dist[-1][-1] if dist[-1][-1] < inf else -1


    """2638. Count the Number of K-Free Subsets (Medium)
    You are given an integer array nums, which contains distinct elements and
    an integer k. A subset is called a k-Free subset if it contains no two
    elements with an absolute difference equal to k. Notice that the empty set
    is a k-Free subset. Return the number of k-Free subsets of nums. A subset
    of an array is a selection of elements (possibly none) of the array.

    Example 1:
    Input: nums = [5,4,6], k = 1
    Output: 5
    Explanation: There are 5 valid subsets: {}, {5}, {4}, {6} and {4, 6}.

    Example 2:
    Input: nums = [2,3,5,8], k = 5
    Output: 12
    Explanation: There are 12 valid subsets: {}, {2}, {3}, {5}, {8}, {2, 3},
                 {2, 3, 5}, {2, 5}, {2, 5, 8}, {2, 8}, {3, 5} and {5, 8}.

    Example 3:
    Input: nums = [10,5,9,11], k = 20
    Output: 16
    Explanation: All subsets are valid. Since the total count of subsets is
                 2^4 = 16, so the answer is 16.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 1000
    * 1 <= k <= 1000"""

    def countTheNumOfKFreeSubsets(self, nums: List[int], k: int) -> int:
        size = defaultdict(int)
        for x in sorted(nums):
            size[x] = size[x-k] + 1
            size.pop(x-k)
        m = max(size.values())
        fib = [1]*(m+2)
        for i in range(2, m+2): fib[i] = fib[i-2] + fib[i-1]
        return reduce(mul, (fib[v+1] for v in size.values()))


    """2639. Find the Width of Columns of a Grid (Easy)
    You are given a 0-indexed m x n integer matrix grid. The width of a column
    is the maximum length of its integers.
    * For example, if grid = [[-10], [3], [12]], the width of the only column
      is 3 since -10 is of length 3.
    Return an integer array ans of size n where ans[i] is the width of the ith
    column. The length of an integer x with len digits is equal to len if x is
    non-negative, and len + 1 otherwise.

    Example 1:
    Input: grid = [[1],[22],[333]]
    Output: [3]
    Explanation: In the 0th column, 333 is of length 3.

    Example 2:
    Input: grid = [[-15,1,3],[15,7,12],[5,6,-2]]
    Output: [3,1,2]
    Explanation: In the 0th column, only -15 is of length 3.
                 In the 1st column, all integers are of length 1.
                 In the 2nd column, both 12 and -2 are of length 2.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 100
    * -10^9 <= grid[r][c] <= 10^9"""

    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:
        return [max(len(str(x)) for x in row) for row in zip(*grid)]


    """2640. Find the Score of All Prefixes of an Array (Medium)
    We define the conversion array conver of an array arr as follows:
    * conver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum
      value of arr[j] over 0 <= j <= i.
    We also define the score of an array arr as the sum of the values of the
    conversion array of arr. Given a 0-indexed integer array nums of length n,
    return an array ans of length n where ans[i] is the score of the prefix
    nums[0..i].

    Example 1:
    Input: nums = [2,3,7,5,10]
    Output: [4,10,24,36,56]
    Explanation: - For the prefix [2], the conversion array is [4] hence the
                   score is 4
                 - For the prefix [2, 3], the conversion array is [4, 6] hence
                   the score is 10
                 - For the prefix [2, 3, 7], the conversion array is [4, 6, 14]
                   hence the score is 24
                 - For the prefix [2, 3, 7, 5], the conversion array is
                   [4, 6, 14, 12] hence the score is 36
                 - For the prefix [2, 3, 7, 5, 10], the conversion array is
                   [4, 6, 14, 12, 20] hence the score is 56

    Example 2:
    Input: nums = [1,1,2,4,8,16]
    Output: [2,4,8,16,32,64]
    Explanation: - For the prefix [1], the conversion array is [2] hence the
                   score is 2
                 - For the prefix [1, 1], the conversion array is [2, 2] hence
                   the score is 4
                 - For the prefix [1, 1, 2], the conversion array is [2, 2, 4]
                   hence the score is 8
                 - For the prefix [1, 1, 2, 4], the conversion array is
                   [2, 2, 4, 8] hence the score is 16
                 - For the prefix [1, 1, 2, 4, 8], the conversion array is
                   [2, 2, 4, 8, 16] hence the score is 32
                 - For the prefix [1, 1, 2, 4, 8, 16], the conversion array is
                   [2, 2, 4, 8, 16, 32] hence the score is 64

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def findPrefixScore(self, nums: List[int]) -> List[int]:
        most = prefix = 0
        ans = []
        for x in nums:
            most = max(most, x)
            prefix += x + most
            ans.append(prefix)
        return ans


    """2641. Cousins in Binary Tree II (Medium)
    Given the root of a binary tree, replace the value of each node in the tree
    with the sum of all its cousins' values. Two nodes of a binary tree are
    cousins if they have the same depth with different parents. Return the root
    of the modified tree. Note that the depth of a node is the number of edges
    in the path from the root node to it.

    Example 1:
    Input: root = [5,4,9,1,10,null,7]
    Output: [0,0,0,7,7,null,11]
    Explanation: The diagram above shows the initial binary tree and the binary
                 tree after changing the value of each node.
                 - Node with value 5 does not have any cousins so its sum is 0.
                 - Node with value 4 does not have any cousins so its sum is 0.
                 - Node with value 9 does not have any cousins so its sum is 0.
                 - Node with value 1 has a cousin with value 7 so its sum is 7.
                 - Node with value 10 has a cousin with value 7 so its sum is 7.
                 - Node with value 7 has cousins with values 1 and 10 so its
                   sum is 11.

    Example 2:
    Input: root = [3,1,2]
    Output: [0,0,0]
    Explanation: The diagram above shows the initial binary tree and the binary
                 tree after changing the value of each node.
                 - Node with value 3 does not have any cousins so its sum is 0.
                 - Node with value 1 does not have any cousins so its sum is 0.
                 - Node with value 2 does not have any cousins so its sum is 0.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 10^4"""

    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        mp = defaultdict(int)
        stack = [(root, None, 0)]
        while stack:
            node, p, d = stack.pop()
            mp[d] += node.val
            mp[p] += node.val
            if node.left: stack.append((node.left, node, d+1))
            if node.right: stack.append((node.right, node, d+1))
        stack = [(root, None, 0)]
        while stack:
            node, p, d = stack.pop()
            node.val = mp[d] - mp[p]
            if node.left: stack.append((node.left, node, d+1))
            if node.right: stack.append((node.right, node, d+1))
        return root


    """2643. Row With Maximum Ones (Easy)
    Given a m x n binary matrix mat, find the 0-indexed position of the row
    that contains the maximum count of ones, and the number of ones in that row.
    In case there are multiple rows that have the maximum count of ones, the
    row with the smallest row number should be selected. Return an array
    containing the index of the row, and the number of ones in it.

    Example 1:
    Input: mat = [[0,1],[1,0]]
    Output: [0,1]
    Explanation: Both rows have the same number of 1's. So we return the index
                 of the smaller row, 0, and the maximum count of ones (1). So,
                 the answer is [0,1].

    Example 2:
    Input: mat = [[0,0,0],[0,1,1]]
    Output: [1,2]
    Explanation: The row indexed 1 has the maximum count of ones (2). So we
                 return its index, 1, and the count. So, the answer is [1,2].

    Example 3:
    Input: mat = [[0,0],[1,1],[0,0]]
    Output: [1,2]
    Explanation: The row indexed 1 has the maximum count of ones (2). So the
                 answer is [1,2].

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 100
    * mat[i][j] is either 0 or 1."""

    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:
        idx = cnt = 0
        for i, row in enumerate(mat):
            c = row.count(1)
            if c > cnt:
                idx = i
                cnt = c
        return [idx, cnt]


    """2644. Find the Maximum Divisibility Score (Easy)
    You are given two 0-indexed integer arrays nums and divisors. The
    divisibility score of divisors[i] is the number of indices j such that
    nums[j] is divisible by divisors[i]. Return the integer divisors[i] with
    the maximum divisibility score. If there is more than one integer with the
    maximum score, return the minimum of them.

    Example 1:
    Input: nums = [4,7,9,3,9], divisors = [5,2,3]
    Output: 3
    Explanation: The divisibility score for every element in divisors is:
                 - The divisibility score of divisors[0] is 0 since no number
                   in nums is divisible by 5.
                 - The divisibility score of divisors[1] is 1 since nums[0] is
                   divisible by 2.
                 - The divisibility score of divisors[2] is 3 since nums[2],
                   nums[3], and nums[4] are divisible by 3.
                 - Since divisors[2] has the maximum divisibility score, we
                   return it.

    Example 2:
    Input: nums = [20,14,21,10], divisors = [5,7,5]
    Output: 5
    Explanation: The divisibility score for every element in divisors is:
                 - The divisibility score of divisors[0] is 2 since nums[0] and
                   nums[3] are divisible by 5.
                 - The divisibility score of divisors[1] is 2 since nums[1] and
                   nums[2] are divisible by 7.
                 - The divisibility score of divisors[2] is 2 since nums[0] and
                   nums[3] are divisible by 5.
                 Since divisors[0], divisors[1], and divisors[2] all have the
                 maximum divisibility score, we return the minimum of them
                 (i.e., divisors[2]).

    Example 3:
    Input: nums = [12], divisors = [10,16]
    Output: 10
    Explanation: The divisibility score for every element in divisors is:
                 - The divisibility score of divisors[0] is 0 since no number
                   in nums is divisible by 10.
                 - The divisibility score of divisors[1] is 0 since no number
                   in nums is divisible by 16.
                 Since divisors[0] and divisors[1] both have the maximum
                 divisibility score, we return the minimum of them (i.e.,
                 divisors[0]).

    Constraints:
    * 1 <= nums.length, divisors.length <= 1000
    * 1 <= nums[i], divisors[i] <= 10^9"""

    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:
        ans = most= -1
        for d in divisors:
            cnt = sum(1 for n in nums if n % d == 0)
            if cnt > most or cnt == most and d < ans:
                ans = d
                most = cnt
        return ans


    """2645. Minimum Additions to Make Valid String (Medium)
    Given a string word to which you can insert letters "a", "b" or "c"
    anywhere and any number of times, return the minimum number of letters that
    must be inserted so that word becomes valid. A string is called valid if it
    can be formed by concatenating the string "abc" several times.

    Example 1:
    Input: word = "b"
    Output: 2
    Explanation: Insert the letter "a" right before "b", and the letter "c"
                 right next to "a" to obtain the valid string "abc".

    Example 2:
    Input: word = "aaa"
    Output: 6
    Explanation: Insert letters "b" and "c" next to each "a" to obtain the
                 valid string "abcabcabc".

    Example 3:
    Input: word = "abc"
    Output: 0
    Explanation: word is already valid. No modifications are needed.

    Constraints:
    * 1 <= word.length <= 50
    * word consists of letters "a", "b" and "c" only."""

    def addMinimum(self, word: str) -> int:
        ans, cnt = 0, 3
        for i, ch in enumerate(word):
            if i and word[i-1] >= ch:
                ans += cnt
                cnt = 3
            cnt -= 1
        return ans + cnt


    """2646. Minimize the Total Price of the Trips (Hard)
    There exists an undirected and unrooted tree with n nodes indexed from 0 to
    n - 1. You are given the integer n and a 2D integer array edges of length
    n - 1, where edges[i] = [ai, bi] indicates that there is an edge between
    nodes ai and bi in the tree. Each node has an associated price. You are
    given an integer array price, where price[i] is the price of the ith node.
    The price sum of a given path is the sum of the prices of all nodes lying
    on that path. Additionally, you are given a 2D integer array trips, where
    trips[i] = [starti, endi] indicates that you start the ith trip from the
    node starti and travel to the node endi by any path you like. Before
    performing your first trip, you can choose some non-adjacent nodes and
    halve the prices. Return the minimum total price sum to perform all the
    given trips.

    Example 1:
    Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]
    Output: 23
    Explanation: The diagram above denotes the tree after rooting it at node 2.
                 The first part shows the initial tree and the second part
                 shows the tree after choosing nodes 0, 2, and 3, and making
                 their price half.
                 - For the 1st trip, we choose path [0,1,3]. The price sum of
                   that path is 1 + 2 + 3 = 6.
                 - For the 2nd trip, we choose path [2,1]. The price sum of
                   that path is 2 + 5 = 7.
                 - For the 3rd trip, we choose path [2,1,3]. The price sum of
                   that path is 5 + 2 + 3 = 10.
                 The total price sum of all trips is 6 + 7 + 10 = 23. It can be
                 proven, that 23 is the minimum answer that we can achieve.

    Example 2:
    Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]
    Output: 1
    Explanation: The diagram above denotes the tree after rooting it at node 0.
                 The first part shows the initial tree and the second part
                 shows the tree after choosing node 0, and making its price
                 half.
                 - For the 1st trip, we choose path [0]. The price sum of that
                   path is 1.
                 The total price sum of all trips is 1. It can be proven, that
                 1 is the minimum answer that we can achieve.

    Constraints:
    * 1 <= n <= 50
    * edges.length == n - 1
    * 0 <= ai, bi <= n - 1
    * edges represents a valid tree.
    * price.length == n
    * price[i] is an even integer.
    * 1 <= price[i] <= 1000
    * 1 <= trips.length <= 100
    * 0 <= starti, endi <= n - 1"""

    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        freq = [0]*n
        for s, e in trips:
            queue = deque([(s, -1)])
            parent = {s : -1}
            while queue:
                u, p = queue.popleft()
                if u == e: break
                for v in tree[u]:
                    if v != p:
                        queue.append((v, u))
                        parent[v] = u
            u = e
            while u >= 0:
                freq[u] += 1
                u = parent[u]

        def dfs(u, p):
            """Return max full and half prices."""
            full = half = 0
            for v in tree[u]:
                if v != p:
                    ff, hh = dfs(v, u)
                    full += ff
                    half += min(ff, hh)
            return price[u]*freq[u] + half, price[u]*freq[u]//2 + full

        return min(dfs(0, -1))


    """2647. Color the Triangle Red (Hard)
    You are given an integer n. Consider an equilateral triangle of side length
    n, broken up into n2 unit equilateral triangles. The triangle has n
    1-indexed rows where the ith row has 2i - 1 unit equilateral triangles.
    The triangles in the ith row are also 1-indexed with coordinates from (i, 1)
    to (i, 2i - 1). The following image shows a triangle of side length 4 with
    the indexing of its triangle. Two triangles are neighbors if they share a
    side. For example:
    * Triangles (1,1) and (2,2) are neighbors
    * Triangles (3,2) and (3,3) are neighbors.
    * Triangles (2,2) and (3,3) are not neighbors because they do not share any
      side.
    Initially, all the unit triangles are white. You want to choose k triangles
    and color them red. We will then run the following algorithm:
    * Choose a white triangle that has at least two red neighbors.
      - If there is no such triangle, stop the algorithm.
    * Color that triangle red.
    * Go to step 1.
    Choose the minimum k possible and set k triangles red before running this
    algorithm such that after the algorithm stops, all unit triangles are
    colored red. Return a 2D list of the coordinates of the triangles that you
    will color red initially. The answer has to be of the smallest size
    possible. If there are multiple valid solutions, return any.

    Example 1:
    Input: n = 3
    Output: [[1,1],[2,1],[2,3],[3,1],[3,5]]
    Explanation: Initially, we choose the shown 5 triangles to be red. Then, we
                 run the algorithm:
                 - Choose (2,2) that has three red neighbors and color it red.
                 - Choose (3,2) that has two red neighbors and color it red.
                 - Choose (3,4) that has three red neighbors and color it red.
                 - Choose (3,3) that has three red neighbors and color it red.
                 It can be shown that choosing any 4 triangles and running the
                 algorithm will not make all triangles red.

    Example 2:
    Input: n = 2
    Output: [[1,1],[2,1],[2,3]]
    Explanation: Initially, we choose the shown 3 triangles to be red. Then, we
                 run the algorithm:
                 - Choose (2,2) that has three red neighbors and color it red.
                 It can be shown that choosing any 2 triangles and running the
                 algorithm will not make all triangles red.

    Constraints: 1 <= n <= 1000"""

    def colorRed(self, n: int) -> List[List[int]]:
        ans = []
        for i in range(n, 0, -1):
            p = (n-i)%4
            if p == 0:
                for j in range(2*i-1, 0, -2): ans.append([i, j])
            elif p == 1:
                if 2 <= i: ans.append([i, 2])
            elif p == 2:
                for j in range(2*i-1, 2, -2): ans.append([i, j])
            else: ans.append([i, 1])
        if 1 <= p <= 2: ans.append([1, 1])
        return ans[::-1]


    """2655. Find Maximal Uncovered Ranges (Medium)
    You are given an integer n which is the length of a 0-indexed array nums,
    and a 0-indexed 2D-array ranges, which is a list of sub-ranges of nums
    (sub-ranges may overlap). Each row ranges[i] has exactly 2 cells:
    * ranges[i][0], which shows the start of the ith range (inclusive)
    * ranges[i][1], which shows the end of the ith range (inclusive)
    These ranges cover some cells of nums and leave some cells uncovered. Your
    task is to find all of the uncovered ranges with maximal length. Return a
    2D-array answer of the uncovered ranges, sorted by the starting point in
    ascending order. By all of the uncovered ranges with maximal length, we
    mean satisfying two conditions:
    * Each uncovered cell should belong to exactly one sub-range
    * There should not exist two ranges (l1, r1) and (l2, r2) such that
      r1 + 1 = l2

    Example 1:
    Input: n = 10, ranges = [[3,5],[7,8]]
    Output: [[0,2],[6,6],[9,9]]
    Explanation: The ranges (3, 5) and (7, 8) are covered, so if we simplify
                 the array nums to a binary array where 0 shows an uncovered
                 cell and 1 shows a covered cell, the array becomes
                 [0,0,0,1,1,1,0,1,1,0] in which we can observe that the ranges
                 (0, 2), (6, 6) and (9, 9) aren't covered.

    Example 2:
    Input: n = 3, ranges = [[0,2]]
    Output: []
    Explanation: In this example, the whole of the array nums is covered and
                 there are no uncovered cells so the output is an empty array.

    Example 3:
    Input: n = 7, ranges = [[2,4],[0,3]]
    Output: [[5,6]]
    Explanation: The ranges (0, 3) and (2, 4) are covered, so if we simplify
                 the array nums to a binary array where 0 shows an uncovered
                 cell and 1 shows a covered cell, the array becomes
                 [1,1,1,1,1,0,0] in which we can observe that the range
                 (5, 6) is uncovered.

    Constraints:
    * 1 <= n <= 10^9
    * 0 <= ranges.length <= 10^6
    * ranges[i].length = 2
    * 0 <= ranges[i][j] <= n - 1
    * ranges[i][0] <= ranges[i][1]"""

    def findMaximalUncoveredRanges(self, n: int, ranges: List[List[int]]) -> List[List[int]]:
        stack = []
        for x, y in sorted(ranges, key=lambda x: x[1]):
            while stack and x <= stack[-1][1]:
                xx, _ = stack.pop()
                x = min(x, xx)
            stack.append([x, y])
        ans = []
        prev = 0
        for x, y in stack:
            if prev < x: ans.append([prev, x-1])
            prev = max(prev, y+1)
        if prev <= n-1: ans.append([prev, n-1])
        return ans


    """2656. Maximum Sum With Exactly K Elements (Easy)
    You are given a 0-indexed integer array nums and an integer k. Your task is
    to perform the following operation exactly k times in order to maximize
    your score:
    * Select an element m from nums.
    * Remove the selected element m from the array.
    * Add a new element with a value of m + 1 to the array.
    * Increase your score by m.
    Return the maximum score you can achieve after performing the operation
    exactly k times.

    Example 1:
    Input: nums = [1,2,3,4,5], k = 3
    Output: 18
    Explanation: We need to choose exactly 3 elements from nums to maximize the
                 sum.
                 - For the first iteration, we choose 5. Then sum is 5 and
                   nums = [1,2,3,4,6]
                 - For the second iteration, we choose 6. Then sum is 5 + 6 and
                   nums = [1,2,3,4,7]
                 - For the third iteration, we choose 7. Then sum is
                   5 + 6 + 7 = 18 and nums = [1,2,3,4,8]
                 So, we will return 18. It can be proven, that 18 is the
                 maximum answer that we can achieve.

    Example 2:
    Input: nums = [5,5,5], k = 2
    Output: 11
    Explanation: We need to choose exactly 2 elements from nums to maximize the
                 sum.
                 - For the first iteration, we choose 5. Then sum is 5 and
                   nums = [5,5,6]
                 - For the second iteration, we choose 6. Then sum is
                   5 + 6 = 11 and nums = [5,5,7]
                 So, we will return 11. It can be proven, that 11 is the
                 maximum answer that we can achieve.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= k <= 100"""

    def maximizeSum(self, nums: List[int], k: int) -> int:
        return k*(2*max(nums)+k-1)//2


    """2657. Find the Prefix Common Array of Two Arrays (Medium)
    You are given two 0-indexed integer permutations A and B of length n. A
    prefix common array of A and B is an array C such that C[i] is equal to the
    count of numbers that are present at or before the index i in both A and B.
    Return the prefix common array of A and B. A sequence of n integers is
    called a permutation if it contains all integers from 1 to n exactly once.

    Example 1:
    Input: A = [1,3,2,4], B = [3,1,2,4]
    Output: [0,2,3,4]
    Explanation: At i = 0: no number is common, so C[0] = 0.
                 At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
                 At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
                 At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.

    Example 2:
    Input: A = [2,3,1], B = [3,1,2]
    Output: [0,1,3]
    Explanation: At i = 0: no number is common, so C[0] = 0.
                 At i = 1: only 3 is common in A and B, so C[1] = 1.
                 At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.

    Constraints:
    * 1 <= A.length == B.length == n <= 50
    * 1 <= A[i], B[i] <= n
    * It is guaranteed that A and B are both a permutation of n integers."""

    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        ans = []
        seen = [0]*len(A)
        prefix = 0
        for x, y in zip(A, B):
            if seen[x-1] == -1: prefix += 1
            seen[x-1] += 1
            if seen[y-1] == 1: prefix += 1
            seen[y-1] -= 1
            ans.append(prefix)
        return ans


    """2658. Maximum Number of Fish in a Grid (Hard)
    You are given a 0-indexed 2D matrix grid of size m x n, where (r, c)
    represents:
    * A land cell if grid[r][c] = 0, or
    * A water cell containing grid[r][c] fish, if grid[r][c] > 0.
    A fisher can start at any water cell (r, c) and can do the following
    operations any number of times:
    * Catch all the fish at cell (r, c), or
    * Move to any adjacent water cell.
    Return the maximum number of fish the fisher can catch if he chooses his
    starting cell optimally, or 0 if no water cell exists. An adjacent cell of
    the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or
    (r - 1, c) if it exists.

    Example 1:
    Input: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]
    Output: 7
    Explanation: The fisher can start at cell (1,3) and collect 3 fish, then
                 move to cell (2,3) and collect 4 fish.

    Example 2:
    Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]
    Output: 1
    Explanation: The fisher can start at cells (0,0) or (3,3) and collect a
                 single fish.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10
    * 0 <= grid[i][j] <= 10"""

    def findMaxFish(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        for r in range(m):
            for c in range(n):
                if grid[r][c]:
                    cand = grid[r][c]
                    stack = [(r, c)]
                    grid[r][c] = 0
                    while stack:
                        i, j = stack.pop()
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                            if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]:
                                cand += grid[ii][jj]
                                stack.append((ii, jj))
                                grid[ii][jj] = 0
                    ans = max(ans, cand)
        return ans


    """2659. Make Array Empty (Hard)
    You are given an integer array nums containing distinct numbers, and you
    can perform the following operations until the array is empty:
    * If the first element has the smallest value, remove it
    * Otherwise, put the first element at the end of the array.
    Return an integer denoting the number of operations it takes to make nums
    empty.

    Example 1:
    Input: nums = [3,4,-1]
    Output: 5
    Operation   Array
            1   [4, -1, 3]
            2   [-1, 3, 4]
            3   [3, 4]
            4   [4]
            5   []

    Example 2:
    Input: nums = [1,2,4,3]
    Output: 5
    Operation   Array
            1   [2, 4, 3]
            2   [4, 3]
            3   [3, 4]
            4   [4]
            5   []

    Example 3:
    Input: nums = [1,2,3]
    Output: 3
    Operation   Array
            1   [2, 3]
            2   [3]
            3   []

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9
    * All values in nums are distinct."""

    def countOperationsToEmptyArray(self, nums: List[int]) -> int:
        loc = {x : i for i, x in enumerate(nums)}
        ans = n = len(nums)
        nums.sort()
        for i in range(1, n):
            if loc[nums[i-1]] > loc[nums[i]]: ans += n - i
        return ans


    """2660. Determine the Winner of a Bowling Game (Easy)
    You are given two 0-indexed integer arrays player1 and player2, that
    represent the number of pins that player 1 and player 2 hit in a bowling
    game, respectively. The bowling game consists of n turns, and the number of
    pins in each turn is exactly 10. Assume a player hit xi pins in the ith
    turn. The value of the ith turn for the player is:
    * 2xi if the player hit 10 pins in any of the previous two turns.
    * Otherwise, It is xi.
    The score of the player is the sum of the values of their n turns. Return
    * 1 if the score of player 1 is more than the score of player 2,
    * 2 if the score of player 2 is more than the score of player 1, and
    * 0 in case of a draw.

    Example 1:
    Input: player1 = [4,10,7,9], player2 = [6,5,2,3]
    Output: 1
    Explanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.
                 The score of player2 is 6 + 5 + 2 + 3 = 16.
                 Score of player1 is more than the score of player2, so,
                 player1 is the winner, and the answer is 1.

    Example 2:
    Input: player1 = [3,5,7,6], player2 = [8,10,10,2]
    Output: 2
    Explanation: The score of player1 is 3 + 5 + 7 + 6 = 21.
                 The score of player2 is 8 + 10 + 2*10 + 2*2 = 42.
                 Score of player2 is more than the score of player1, so,
                 player2 is the winner, and the answer is 2.

    Example 3:
    Input: player1 = [2,3], player2 = [4,1]
    Output: 0
    Explanation: The score of player1 is 2 + 3 = 5
                 The score of player2 is 4 + 1 = 5
                 The score of player1 equals to the score of player2, so,
                 there is a draw, and the answer is 0.

    Constraints:
    * n == player1.length == player2.length
    * 1 <= n <= 1000
    * 0 <= player1[i], player2[i] <= 10"""

    def isWinner(self, player1: List[int], player2: List[int]) -> int:

        def fn(player):
            """Return the score of given player."""
            ans = 0
            for i, x in enumerate(player):
                ans += x
                if i and player[i-1] == 10 or i >= 2 and player[i-2] == 10: ans += x
            return ans

        diff = fn(player1) - fn(player2)
        return 1 if diff > 0 else 2 if diff < 0 else 0


    """2661. First Completely Painted Row or Column (Medium)
    You are given a 0-indexed integer array arr, and an m x n integer matrix
    mat. arr and mat both contain all the integers in the range [1, m * n].
    Go through each index i in arr starting from index 0 and paint the cell in
    mat containing the integer arr[i]. Return the smallest index i at which
    either a row or a column will be completely painted in mat.

    Example 1:
    image explanation for example 1
    Input: arr = [1,3,4,2], mat = [[1,4],[2,3]]
    Output: 2
    Explanation: The moves are shown in order, and both the first row and
                 second column of the matrix become fully painted at arr[2].

    Example 2:
    image explanation for example 2
    Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]
    Output: 3
    Explanation: The second column becomes fully painted at arr[3].

    Constraints:
    * m == mat.length
    * n = mat[i].length
    * arr.length == m * n
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 1 <= arr[i], mat[r][c] <= m * n
    * All the integers of arr are unique.
    * All the integers of mat are unique."""

    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        loc = {x : (i, j) for i, row in enumerate(mat) for j, x in enumerate(row)}
        rows = [0]*m
        cols = [0]*n
        for k, x in enumerate(arr):
            i, j = loc[x]
            rows[i] += 1
            cols[j] += 1
            if rows[i] == n or cols[j] == m: return k


    """2662. Minimum Cost of a Path With Special Roads (Medium)
    You are given an array start where start = [startX, startY] represents your
    initial position (startX, startY) in a 2D space. You are also given the
    array target where target = [targetX, targetY] represents your target
    position (targetX, targetY). The cost of going from a position (x1, y1) to
    any other position in the space (x2, y2) is |x2 - x1| + |y2 - y1|. There
    are also some special roads. You are given a 2D array specialRoads where
    specialRoads[i] = [x1i, y1i, x2i, y2i, costi] indicates that the ith
    special road can take you from (x1i, y1i) to (x2i, y2i) with a cost equal
    to costi. You can use each special road any number of times. Return the
    minimum cost required to go from (startX, startY) to (targetX, targetY).

    Example 1:
    Input: start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]
    Output: 5
    Explanation: The optimal path from (1,1) to (4,5) is the following:
                 - (1,1) -> (1,2). This move has a cost of |1 - 1| + |2 - 1| = 1.
                 - (1,2) -> (3,3). This move uses the first special edge, the
                   cost is 2.
                 - (3,3) -> (3,4). This move has a cost of |3 - 3| + |4 - 3| = 1.
                 - (3,4) -> (4,5). This move uses the second special edge, the
                   cost is 1.
                 So the total cost is 1 + 2 + 1 + 1 = 5. It can be shown that
                 we cannot achieve a smaller total cost than 5.

    Example 2:
    Input: start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]
    Output: 7
    Explanation: It is optimal to not use any special edges and go directly
                 from the starting to the ending position with a cost
                 |5 - 3| + |7 - 2| = 7.

    Constraints:
    * start.length == target.length == 2
    * 1 <= startX <= targetX <= 10^5
    * 1 <= startY <= targetY <= 10^5
    * 1 <= specialRoads.length <= 200
    * specialRoads[i].length == 5
    * startX <= x1i, x2i <= targetX
    * startY <= y1i, y2i <= targetY
    * 1 <= costi <= 10^5"""

    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:
        mp = defaultdict(list, {tuple(target) : [(0, 0, 0)]})
        for x, y, xx, yy, cost in specialRoads:
            mp[x, y].append((xx, yy, cost))
        dist = defaultdict(lambda : inf)
        dist[tuple(start)] = 0
        pq = [(0, *start)]
        while pq:
            d, x, y = heappop(pq)
            if [x, y] == target: return d
            for xx, yy, cost in mp[x, y]:
                if d+cost < dist[xx, yy]:
                    dist[xx, yy] = d+cost
                    heappush(pq, (d+cost, xx, yy))
            for x1, y1 in mp:
                dd = d + abs(x1-x) + abs(y1-y)
                if dd < dist[x1, y1]:
                    dist[x1, y1] = dd
                    heappush(pq, (dd, x1, y1))


    """2663. Lexicographically Smallest Beautiful String (Hard)
    A string is beautiful if:
    * It consists of the first k letters of the English lowercase alphabet.
    * It does not contain any substring of length 2 or more which is a
      palindrome.
    You are given a beautiful string s of length n and a positive integer k.
    Return the lexicographically smallest string of length n, which is larger
    than s and is beautiful. If there is no such string, return an empty string.
    A string a is lexicographically larger than a string b (of the same length)
    if in the first position where a and b differ, a has a character strictly
    larger than the corresponding character in b.
    * For example, "abcd" is lexicographically larger than "abcc" because the
      first position they differ is at the fourth character, and d is greater
      than c.

    Example 1:
    Input: s = "abcz", k = 26
    Output: "abda"
    Explanation: The string "abda" is beautiful and lexicographically larger
                 than the string "abcz". It can be proven that there is no
                 string that is lexicographically larger than the string
                 "abcz", beautiful, and lexicographically smaller than the
                 string "abda".

    Example 2:
    Input: s = "dc", k = 4
    Output: ""
    Explanation: It can be proven that there is no string that is
                 lexicographically larger than the string "dc" and is
                 beautiful.

    Constraints:
    * 1 <= n == s.length <= 10^5
    * 4 <= k <= 26
    * s is a beautiful string."""

    def smallestBeautifulString(self, s: str, k: int) -> str:
        s = list(s)
        for i in reversed(range(len(s))):
            for cc in ascii_lowercase[:k]:
                if s[i] < cc and cc not in s[max(0, i-2) : i]:
                    s[i] = cc
                    for ii in range(i+1, len(s)):
                        for cc in ascii_lowercase[:k]:
                            if cc not in s[max(0, ii-2) : ii]:
                                s[ii] = cc
                                break
                    return ''.join(s)
        return ""


    """2664. The Knight’s Tour (Medium)
    Given two positive integers m and n which are the height and width of a
    0-indexed 2D-array board, a pair of positive integers (r, c) which is the
    starting position of the knight on the board. Your task is to find an order
    of movements for the knight, in a manner that every cell of the board gets
    visited exactly once (the starting cell is considered visited and you
    shouldn't visit it again). Return the array board in which the cells'
    values show the order of visiting the cell starting from 0 (the initial
    place of the knight). Note that a knight can move from cell (r1, c1) to
    cell (r2, c2) if 0 <= r2 <= m - 1 and 0 <= c2 <= n - 1 and
    min(abs(r1 - r2), abs(c1 - c2)) = 1 and max(abs(r1 - r2), abs(c1 - c2)) = 2.

    Example 1:
    Input: m = 1, n = 1, r = 0, c = 0
    Output: [[0]]
    Explanation: There is only 1 cell and the knight is initially on it so
                 there is only a 0 inside the 1x1 grid.

    Example 2:
    Input: m = 3, n = 4, r = 0, c = 0
    Output: [[0,3,6,9],[11,8,1,4],[2,5,10,7]]
    Explanation: By the following order of movements we can visit the entire
                 board. (0,0)->(1,2)->(2,0)->(0,1)->(1,3)->(2,1)->(0,2)->(2,3)
                 ->(1,1)->(0,3)->(2,2)->(1,0)

    Constraints:
    * 1 <= m, n <= 5
    * 0 <= r <= m - 1
    * 0 <= c <= n - 1
    * The inputs will be generated such that there exists at least one possible
      order of movements with the given condition"""

    def tourOfKnight(self, m: int, n: int, r: int, c: int) -> List[List[int]]:
        board = [[-1]*n for _ in range(m)]

        def fn(i, j, k):
            """Return true if path is found."""
            if k == m*n: return True
            for ii, jj in (i-2, j-1), (i-2, j+1), (i-1, j-2), (i-1, j+2), (i+1, j-2), (i+1, j+2), (i+2, j-1), (i+2, j+1):
                if 0 <= ii < m and 0 <= jj < n and board[ii][jj] == -1:
                    board[ii][jj] = k
                    if fn(ii, jj, k+1): return True
                    board[ii][jj] = -1

        board[r][c] = 0
        fn(r, c, 1)
        return board


    """2670. Find the Distinct Difference Array (Easy)
    You are given a 0-indexed array nums of length n. The distinct difference
    array of nums is an array diff of length n such that diff[i] is equal to
    the number of distinct elements in the suffix nums[i + 1, ..., n - 1]
    subtracted from the number of distinct elements in the prefix
    nums[0, ..., i]. Return the distinct difference array of nums. Note that
    nums[i, ..., j] denotes the subarray of nums starting at index i and
    ending at index j inclusive. Particularly, if i > j then nums[i, ..., j]
    denotes an empty subarray.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: [-3,-1,1,3,5]
    Explanation: - For index i = 0, there is 1 element in the prefix and 4
                   distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.
                 - For index i = 1, there are 2 distinct elements in the prefix
                   and 3 distinct elements in the suffix. Thus,
                   diff[1] = 2 - 3 = -1.
                 - For index i = 2, there are 3 distinct elements in the prefix
                   and 2 distinct elements in the suffix. Thus,
                   diff[2] = 3 - 2 = 1.
                 - For index i = 3, there are 4 distinct elements in the prefix
                   and 1 distinct element in the suffix. Thus,
                   diff[3] = 4 - 1 = 3.
                 - For index i = 4, there are 5 distinct elements in the prefix
                   and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.

    Example 2:
    Input: nums = [3,2,3,4,2]
    Output: [-2,-1,0,2,3]
    Explanation: - For index i = 0, there is 1 element in the prefix and 3
                   distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.
                 - For index i = 1, there are 2 distinct elements in the prefix
                   and 3 distinct elements in the suffix. Thus,
                   diff[1] = 2 - 3 = -1.
                 - For index i = 2, there are 2 distinct elements in the prefix
                   and 2 distinct elements in the suffix. Thus,
                   diff[2] = 2 - 2 = 0.
                 - For index i = 3, there are 3 distinct elements in the prefix
                   and 1 distinct element in the suffix. Thus,
                   diff[3] = 3 - 1 = 2.
                 - For index i = 4, there are 3 distinct elements in the prefix
                   and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.

    Constraints:
    * 1 <= n == nums.length <= 50
    * 1 <= nums[i] <= 50"""

    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:
        ans = []
        prefix = set()
        suffix = Counter(nums)
        for x in nums:
            prefix.add(x)
            suffix[x] -= 1
            if suffix[x] == 0: suffix.pop(x)
            ans.append(len(prefix) - len(suffix))
        return ans


    """2672. Number of Adjacent Elements With the Same Color (Medium)
    There is a 0-indexed array nums of length n. Initially, all elements are
    uncolored (has a value of 0). You are given a 2D integer array queries
    where queries[i] = [indexi, colori]. For each query, you color the index
    indexi with the color colori in the array nums. Return an array answer of
    the same length as queries where answer[i] is the number of adjacent
    elements with the same color after the ith query. More formally, answer[i]
    is the number of indices j, such that 0 <= j < n - 1 and
    nums[j] == nums[j + 1] and nums[j] != 0 after the ith query.

    Example 1:
    Input: n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]
    Output: [0,1,1,0,2]
    Explanation: Initially array nums = [0,0,0,0], where 0 denotes uncolored
                 elements of the array.
                 - After the 1st query nums = [2,0,0,0]. The count of adjacent
                   elements with the same color is 0.
                 - After the 2nd query nums = [2,2,0,0]. The count of adjacent
                   elements with the same color is 1.
                 - After the 3rd query nums = [2,2,0,1]. The count of adjacent
                   elements with the same color is 1.
                 - After the 4th query nums = [2,1,0,1]. The count of adjacent
                   elements with the same color is 0.
                 - After the 5th query nums = [2,1,1,1]. The count of adjacent
                   elements with the same color is 2.

    Example 2:
    Input: n = 1, queries = [[0,100000]]
    Output: [0]
    Explanation: Initially array nums = [0], where 0 denotes uncolored elements
                 of the array.
                 - After the 1st query nums = [100000]. The count of adjacent
                   elements with the same color is 0.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= indexi <= n - 1
    * 1 <=  colori <= 10^5"""

    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:
        ans = []
        cnt = 0
        nums = [0]*n
        for i, x in queries:
            if i and nums[i-1] == nums[i] > 0: cnt -= 1
            if i+1 < n and nums[i] == nums[i+1] > 0: cnt -= 1
            nums[i] = x
            if i and nums[i-1] == nums[i]: cnt += 1
            if i+1 < n and nums[i] == nums[i+1]: cnt += 1
            ans.append(cnt)
        return ans


    """2673. Make Costs of Paths Equal in a Binary Tree (Medium)
    You are given an integer n representing the number of nodes in a perfect
    binary tree consisting of nodes numbered from 1 to n. The root of the tree
    is node 1 and each node i in the tree has two children where the left child
    is the node 2 * i and the right child is 2 * i + 1. Each node in the tree
    also has a cost represented by a given 0-indexed integer array cost of size
    n where cost[i] is the cost of node i + 1. You are allowed to increment the
    cost of any node by 1 any number of times. Return the minimum number of
    increments you need to make the cost of paths from the root to each leaf
    node equal.

    Note:
    * A perfect binary tree is a tree where each node, except the leaf nodes,
      has exactly 2 children.
    * The cost of a path is the sum of costs of nodes in the path.

    Example 1:
    Input: n = 7, cost = [1,5,2,2,3,3,1]
    Output: 6
    Explanation: We can do the following increments:
                 - Increase the cost of node 4 one time.
                 - Increase the cost of node 3 three times.
                 - Increase the cost of node 7 two times.
                 Each path from the root to a leaf will have a total cost of 9.
                 The total increments we did is 1 + 3 + 2 = 6. It can be shown
                 that this is the minimum answer we can achieve.

    Example 2:
    Input: n = 3, cost = [5,3,3]
    Output: 0
    Explanation: The two paths already have equal total costs, so no increments
                 are needed.

    Constraints:
    * 3 <= n <= 10^5
    * n + 1 is a power of 2
    * cost.length == n
    * 1 <= cost[i] <= 10^4"""

    def minIncrements(self, n: int, cost: List[int]) -> int:
        ans = 0
        for i in range(n//2-1, -1, -1):
            ans += abs(cost[2*i+1] - cost[2*i+2])
            cost[i] += max(cost[2*i+1], cost[2*i+2])
        return ans


    """2674. Split a Circular Linked Listn (Medium)
    Given a circular linked list list of positive integers, your task is to
    split it into 2 circular linked lists so that the first one contains the
    first half of the nodes in list (exactly ceil(list.length / 2) nodes) in the
    same order they appeared in list, and the second one contains the rest of
    the nodes in list in the same order they appeared in list. Return an array
    answer of length 2 in which the first element is a circular linked list
    representing the first half and the second element is a circular linked list
    representing the second half. A circular linked list is a normal linked list
    with the only difference being that the last node's next node, is the first
    node.

    Example 1:
    Input: nums = [1,5,7]
    Output: [[1,5],[7]]
    Explanation: The initial list has 3 nodes so the first half would be the
                 first 2 elements since ceil(3 / 2) = 2 and the rest which is 1
                 node is in the second half.

    Example 2:
    Input: nums = [2,6,1,5]
    Output: [[2,6],[1,5]]
    Explanation: The initial list has 4 nodes so the first half would be the
                 first 2 elements since ceil(4 / 2) = 2 and the rest which is 2
                 nodes are in the second half.

    Constraints:
    * The number of nodes in list is in the range [2, 10^5]
    * 0 <= Node.val <= 10^9
    * LastNode.next = FirstNode where LastNode is the last node of the list and
      FirstNode is the first one"""

    def splitCircularLinkedList(self, list: Optional[ListNode]) -> List[Optional[ListNode]]:
        fast = slow = list
        while fast.next != list and fast.next.next != list :
            fast = fast.next.next
            slow = slow.next
        if fast.next != list: fast = fast.next
        head = slow.next
        slow.next = list
        fast.next = head
        return [list, head]


    """2678. Number of Senior Citizens (Easy)
    You are given a 0-indexed array of strings details. Each element of details
    provides information about a given passenger compressed into a string of
    length 15. The system is such that:
    * The first ten characters consist of the phone number of passengers.
    * The next character denotes the gender of the person.
    * The following two characters are used to indicate the age of the person.
    * The last two characters determine the seat allotted to that person.
    Return the number of passengers who are strictly more than 60 years old.

    Example 1:
    Input: details = ["7868190130M7522","5303914400F9211","9273338290F4010"]
    Output: 2
    Explanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40.
                 Thus, there are 2 people who are over 60 years old.

    Example 2:
    Input: details = ["1313579440F2036","2921522980M5644"]
    Output: 0
    Explanation: None of the passengers are older than 60.

    Constraints:
    * 1 <= details.length <= 100
    * details[i].length == 15
    * details[i] consists of digits from '0' to '9'.
    * details[i][10] is either 'M' or 'F' or 'O'.
    * The phone numbers and seat numbers of the passengers are distinct."""

    def countSeniors(self, details: List[str]) -> int:
        return sum(int(d[11:13]) > 60 for d in details)


    """2689. Extract Kth Character From The Rope Tree (Easy)
    You are given the root of a binary tree and an integer k. Besides the left
    and right children, every node of this tree has two other properties, a
    string node.val containing only lowercase English letters (possibly empty)
    and a non-negative integer node.len. There are two types of nodes in this tree:
    * Leaf: These nodes have no children, node.len = 0, and node.val is some
      non-empty string.
    * Internal: These nodes have at least one child (also at most two children),
      node.len > 0, and node.val is an empty string.
    The tree described above is called a Rope binary tree. Now we define S[node]
    recursively as follows:
    * If node is some leaf node, S[node] = node.val,
    * Otherwise if node is some internal node,
      S[node] = concat(S[node.left], S[node.right]) and
      S[node].length = node.len.
    Return k-th character of the string S[root]. Note: If s and p are two
    strings, concat(s, p) is a string obtained by concatenating p to s. For
    example, concat("ab", "zz") = "abzz".

    Example 1:
    Input: root = [10,4,"abcpoe","g","rta"], k = 6
    Output: "b"
    Explanation: In the picture below, we put an integer on internal nodes that
                 represents node.len, and a string on leaf nodes that represents
                 node.val. You can see that
                 S[root] = concat(concat("g", "rta"), "abcpoe") = "grtaabcpoe".
                 So S[root][5], which represents 6th character of it, is equal
                 to "b".

    Example 2:
    Input: root = [12,6,6,"abc","efg","hij","klm"], k = 3
    Output: "c"
    Explanation: In the picture below, we put an integer on internal nodes that
                 represents node.len, and a string on leaf nodes that represents
                 node.val. You can see that
                 S[root] = concat(concat("abc", "efg"), concat("hij", "klm")) =
                 "abcefghijklm". So S[root][2], which represents the 3rd
                 character of it, is equal to "c".

    Example 3:
    Input: root = ["ropetree"], k = 8
    Output: "e"
    Explanation: In the picture below, we put an integer on internal nodes that
                 represents node.len, and a string on leaf nodes that represents
                 node.val. You can see that S[root] = "ropetree". So S[root][7],
                 which represents 8th character of it, is equal to "e".

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^3]
    * node.val contains only lowercase English letters
    * 0 <= node.val.length <= 50
    * 0 <= node.len <= 10^4
    * for leaf nodes, node.len = 0 and node.val is non-empty
    * for internal nodes, node.len > 0 and node.val is empty
    * 1 <= k <= S[root].length"""

    def getKthCharacter(self, root: Optional[object], k: int) -> str:
        node = root
        while node.len:
            val = max(node.left.len, len(node.left.val)) if node.left else 0
            if val >= k: node = node.left
            else:
                if node.left: k -= val
                node = node.right
        return node.val[k-1]


    """2699. Modify Graph Edge Weights (Hard)
    You are given an undirected weighted connected graph containing n nodes
    labeled from 0 to n - 1, and an integer array edges where
    edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and
    bi with weight wi. Some edges have a weight of -1 (wi = -1), while others
    have a positive weight (wi > 0). Your task is to modify all edges with a
    weight of -1 by assigning them positive integer values in the range
    [1, 2 * 10^9] so that the shortest distance between the nodes source and
    destination becomes equal to an integer target. If there are multiple
    modifications that make the shortest distance between source and destination
    equal to target, any of them will be considered correct. Return an array
    containing all edges (even unmodified ones) in any order if it is possible
    to make the shortest distance from source to destination equal to target, or
    an empty array if it's impossible. Note: You are not allowed to modify the
    weights of edges with initial positive weights.

    Example 1:
    Input: n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5
    Output: [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]
    Explanation: The graph above shows a possible modification to the edges,
                 making the distance from 0 to 1 equal to 5.

    Example 2:
    Input: n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6
    Output: []
    Explanation: The graph above contains the initial edges. It is not possible
                 to make the distance from 0 to 2 equal to 6 by modifying the
                 edge with weight -1. So, an empty array is returned.

    Example 3:
    Input: n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6
    Output: [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]
    Explanation: The graph above shows a modified graph having the shortest
                 distance from 0 to 2 as 6.

    Constraints:
    * 1 <= n <= 100
    * 1 <= edges.length <= n * (n - 1) / 2
    * edges[i].length == 3
    * 0 <= ai, bi < n
    * wi = -1 or 1 <= wi <= 10^7
    * ai != bi
    * 0 <= source, destination < n
    * source != destination
    * 1 <= target <= 10^9
    * The graph is connected, and there are no self-loops or repeated edges"""

    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:
        graph = [[0]*n for _ in range(n)]
        for u, v, w in edges:
            graph[u][v] = graph[v][u] = w
        orig = [inf] * n
        orig[source] = 0
        pq = [(0, source)]
        while pq:
            d, u = heappop(pq)
            if d == orig[u]:
                for v, w in enumerate(graph[u]):
                    if w and w != -1 and d+w < orig[v]:
                        orig[v] = d+w
                        heappush(pq, (orig[v], v))
        if orig[destination] < target: return []
        if orig[destination] == target:
            ans = []
            for u, v, w in edges:
                if w == -1: w = 2_000_000_000
                ans.append([u, v, w])
            return ans
        dist = [inf] * n
        dist[source] = 0
        parent = [-1] * n
        pq = [(0, source)]
        while pq:
            d, u = heappop(pq)
            if u == destination: break
            if d == dist[u]:
                for v, w in enumerate(graph[u]):
                    if w:
                        if w == -1: dd = d+1
                        else: dd = d+w
                        if dd < dist[v]:
                            dist[v] = dd
                            parent[v] = u
                            heappush(pq, (dd, v))
        if d > target: return []
        while u >= 0:
            p = parent[u]
            if p >= 0:
                if graph[p][u] == -1:
                    if orig[p] < target:
                        graph[p][u] = graph[u][p] = target - orig[p]
                        break
                    graph[p][u] = graph[u][p] = 1
                target -= graph[u][p]
            u = p
        ans = []
        for u, v, w in edges:
            if graph[u][v] == -1: graph[u][v] = 2_000_000_000
            ans.append([u, v, graph[u][v]])
        return ans


    """2728. Count Houses in a Circular Street (Easy)
    You are given an object street of class Street that represents a circular
    street and a positive integer k which represents a maximum bound for the
    number of houses in that street (in other words, the number of houses is
    less than or equal to k). Houses' doors could be open or closed initially.
    Initially, you are standing in front of a door to a house on this street.
    Your task is to count the number of houses in the street. The class Street
    contains the following functions which may help you:
    * void openDoor(): Open the door of the house you are in front of.
    * void closeDoor(): Close the door of the house you are in front of.
    * boolean isDoorOpen(): Returns true if the door of the current house is
      open and false otherwise.
    * void moveRight(): Move to the right house.
    * void moveLeft(): Move to the left house.
    Return ans which represents the number of houses on this street.

    Example 1:
    Input: street = [0,0,0,0], k = 10
    Output: 4
    Explanation: There are 4 houses, and all their doors are closed. The number
                 of houses is less than k, which is 10.

    Example 2:
    Input: street = [1,0,1,1,0], k = 5
    Output: 5
    Explanation: There are 5 houses, and the doors of the 1st, 3rd, and 4th
                 house (moving in the right direction) are open, and the rest
                 are closed. The number of houses is equal to k, which is 5.

    Constraints:
    * n == number of houses
    * 1 <= n <= k <= 10^3"""

    def houseCount(self, street: Optional['Street'], k: int) -> int:
        for _ in range(k):
            street.openDoor()
            street.moveRight()
        ans = 0
        while street.isDoorOpen():
            ans += 1
            street.closeDoor()
            street.moveRight()
        return ans


    """2729. Check if The Number is Fascinating (Easy)
    You are given an integer n that consists of exactly 3 digits. We call the
    number n fascinating if, after the following modification, the resulting
    number contains all the digits from 1 to 9 exactly once and does not contain
    any 0's:
    * Concatenate n with the numbers 2 * n and 3 * n.
    Return true if n is fascinating, or false otherwise. Concatenating two
    numbers means joining them together. For example, the concatenation of 121
    and 371 is 121371.

    Example 1:
    Input: n = 192
    Output: true
    Explanation: We concatenate the numbers n = 192 and 2 * n = 384 and
                 3 * n = 576. The resulting number is 192384576. This number
                 contains all the digits from 1 to 9 exactly once.

    Example 2:
    Input: n = 100
    Output: false
    Explanation: We concatenate the numbers n = 100 and 2 * n = 200 and
                 3 * n = 300. The resulting number is 100200300. This number
                 does not satisfy any of the conditions.

    Constraints: 100 <= n <= 999"""

    def isFascinating(self, n: int) -> bool:
        seen = set()
        for x in n, 2*n, 3*n:
            if x >= 1000: return False
            seen |= set(str(x))
        return len(seen) == 9 and '0' not in seen


    """2730. Find the Longest Semi-Repetitive Substring (Medium)
    You are given a digit string s that consists of digits from 0 to 9. A string
    is called semi-repetitive if there is at most one adjacent pair of the same
    digit. For example, "0010", "002020", "0123", "2002", and "54944" are semi-
    repetitive while the following are not: "00101022" (adjacent same digit
    pairs are 00 and 22), and "1101234883" (adjacent same digit pairs are 11 and
    88). Return the length of the longest semi-repetitive substring of s.

    Example 1:
    Input: s = "52233"
    Output: 4
    Explanation: The longest semi-repetitive substring is "5223". Picking the
                 whole string "52233" has two adjacent same digit pairs 22 and
                 33, but at most one is allowed.

    Example 2:
    Input: s = "5494"
    Output: 4
    Explanation: s is a semi-repetitive string.

    Example 3:
    Input: s = "1111111"
    Output: 2
    Explanation: The longest semi-repetitive substring is "11". Picking the
                 substring "111" has two adjacent same digit pairs, but at most
                 one is allowed.

    Constraints:
    * 1 <= s.length <= 50
    * '0' <= s[i] <= '9'"""

    def longestSemiRepetitiveSubstring(self, s: str) -> int:
        ans = ii = q = 0
        for i, ch in enumerate(s):
            if i and s[i-1] == s[i]:
                if q: ii = q
                q = i
            ans = max(ans, i-ii+1)
        return ans


    """2731. Movement of Robots (Medium)
    Some robots are standing on an infinite number line with their initial
    coordinates given by a 0-indexed integer array nums and will start moving
    once given the command to move. The robots will move a unit distance each
    second. You are given a string s denoting the direction in which robots will
    move on command. 'L' means the robot will move towards the left side or
    negative side of the number line, whereas 'R' means the robot will move
    towards the right side or positive side of the number line. If two robots
    collide, they will start moving in opposite directions. Return the sum of
    distances between all the pairs of robots d seconds after the command. Since
    the sum can be very large, return it modulo 109 + 7.

    Note:
    * For two robots at the index i and j, pair (i,j) and pair (j,i) are
      considered the same pair.
    * When robots collide, they instantly change their directions without
      wasting any time.
    * Collision happens when two robots share the same place in a moment.
      - For example, if a robot is positioned in 0 going to the right and
        another is positioned in 2 going to the left, the next second they'll be
        both in 1 and they will change direction and the next second the first
        one will be in 0, heading left, and another will be in 2, heading right.
      - For example, if a robot is positioned in 0 going to the right and
        another is positioned in 1 going to the left, the next second the first
        one will be in 0, heading left, and another will be in 1, heading right.

    Example 1:
    Input: nums = [-2,0,2], s = "RLL", d = 3
    Output: 8
    Explanation: - After 1 second, the positions are [-1,-1,1]. Now, the robot
                   at index 0 will move left, and the robot at index 1 will move
                   right.
                 - After 2 seconds, the positions are [-2,0,0]. Now, the robot
                   at index 1 will move left, and the robot at index 2 will move
                   right.
                 - After 3 seconds, the positions are [-3,-1,1].
                 - The distance between the robot at index 0 and 1 is
                   abs(-3 - (-1)) = 2.
                 - The distance between the robot at index 0 and 2 is
                   abs(-3 - 1) = 4.
                 - The distance between the robot at index 1 and 2 is
                   abs(-1 - 1) = 2.
                 - The sum of the pairs of all distances = 2 + 4 + 2 = 8.

    Example 2:
    Input: nums = [1,0], s = "RL", d = 2
    Output: 5
    Explanation: - After 1 second, the positions are [2,-1].
                 - After 2 seconds, the positions are [3,-2].
                 The distance between the two robots is abs(-2 - 3) = 5.

    Constraints:
    * 2 <= nums.length <= 10^5
    * -2 * 10^9 <= nums[i] <= 2 * 10^9
    * 0 <= d <= 10^9
    * nums.length == s.length
    * s consists of 'L' and 'R' only
    * nums[i] will be unique."""

    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        for i in range(len(nums)):
            if s[i] == 'L': nums[i] -= d
            else: nums[i] += d
        nums.sort()
        ans = prefix = 0
        for i, x in enumerate(nums):
            ans += i*x - prefix
            prefix += x
        return ans % 1_000_000_007


    """2732. Find a Good Subset of the Matrix (Hard)
    You are given a 0-indexed m x n binary matrix grid. Let us call a non-empty
    subset of rows good if the sum of each column of the subset is at most half
    of the length of the subset. More formally, if the length of the chosen
    subset of rows is k, then the sum of each column should be at most
    floor(k / 2). Return an integer array that contains row indices of a good
    subset sorted in ascending order. If there are multiple good subsets, you
    can return any of them. If there are no good subsets, return an empty array.
    A subset of rows of the matrix grid is any matrix that can be obtained by
    deleting some (possibly none or all) rows from grid.

    Example 1:
    Input: grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]
    Output: [0,1]
    Explanation: We can choose the 0th and 1st rows to create a good subset of rows.
                 The length of the chosen subset is 2.
                 - The sum of the 0th column is 0 + 0 = 0, which is at most half of the length of the subset.
                 - The sum of the 1st column is 1 + 0 = 1, which is at most half of the length of the subset.
                 - The sum of the 2nd column is 1 + 0 = 1, which is at most half of the length of the subset.
                 - The sum of the 3rd column is 0 + 1 = 1, which is at most half of the length of the subset.

    Example 2:
    Input: grid = [[0]]
    Output: [0]
    Explanation: We can choose the 0th row to create a good subset of rows.
                 The length of the chosen subset is 1.
                 - The sum of the 0th column is 0, which is at most half of the length of the subset.

    Example 3:
    Input: grid = [[1,1,1],[1,1,1]]
    Output: []
    Explanation: It is impossible to choose any subset of rows to create a good subset.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m <= 10^4
    * 1 <= n <= 5
    * grid[i][j] is either 0 or 1."""

    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0])
        seen = {}
        for i, row in enumerate(grid):
            v = reduce(xor, (x*(1<<j) for j, x in enumerate(row)))
            if v == 0: return [i]
            for vv, ii in seen.items():
                if vv & v == 0: return [ii, i]
            seen[v] = i
        return []


    """2733. Neither Minimum nor Maximum (Easy)
    Given an integer array nums containing distinct positive integers, find and
    return any number from the array that is neither the minimum nor the maximum
    value in the array, or -1 if there is no such number. Return the selected
    integer.

    Example 1:
    Input: nums = [3,2,1,4]
    Output: 2
    Explanation: In this example, the minimum value is 1 and the maximum value
                 is 4. Therefore, either 2 or 3 can be valid answers.

    Example 2:
    Input: nums = [1,2]
    Output: -1
    Explanation: Since there is no number in nums that is neither the maximum
                 nor the minimum, we cannot select a number that satisfies the
                 given condition. Therefore, there is no answer.

    Example 3:
    Input: nums = [2,1,3]
    Output: 2
    Explanation: Since 2 is neither the maximum nor the minimum value in nums,
                 it is the only valid answer.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * All values in nums are distinct"""

    def findNonMinOrMax(self, nums: List[int]) -> int:
        if len(nums) < 3: return -1
        return sorted(nums[:3])[1]


    """2737. Find the Closest Marked Node (Medium)
    You are given a positive integer n which is the number of nodes of a 0-
    indexed directed weighted graph and a 0-indexed 2D array edges where
    edges[i] = [ui, vi, wi] indicates that there is an edge from node ui to node
    vi with weight wi. You are also given a node s and a node array marked; your
    task is to find the minimum distance from s to any of the nodes in marked.
    Return an integer denoting the minimum distance from s to any node in marked
    or -1 if there are no paths from s to any of the marked nodes.

    Example 1:
    Input: n = 4, edges = [[0,1,1],[1,2,3],[2,3,2],[0,3,4]], s = 0, marked = [2,3]
    Output: 4
    Explanation: There is one path from node 0 (the green node) to node 2 (a red
                 node), which is 0->1->2, and has a distance of 1 + 3 = 4. There
                 are two paths from node 0 to node 3 (a red node), which are
                 0->1->2->3 and 0->3, the first one has a distance of
                 1 + 3 + 2 = 6 and the second one has a distance of 4. The
                 minimum of them is 4.

    Example 2:
    Input: n = 5, edges = [[0,1,2],[0,2,4],[1,3,1],[2,3,3],[3,4,2]], s = 1, marked = [0,4]
    Output: 3
    Explanation: There are no paths from node 1 (the green node) to node 0 (a
                 red node). There is one path from node 1 to node 4 (a red
                 node), which is 1->3->4, and has a distance of 1 + 2 = 3. So
                 the answer is 3.

    Example 3:
    Input: n = 4, edges = [[0,1,1],[1,2,3],[2,3,2]], s = 3, marked = [0,1]
    Output: -1
    Explanation: There are no paths from node 3 (the green node) to any of the
                 marked nodes (the red nodes), so the answer is -1.

    Constraints:
    * 2 <= n <= 500
    * 1 <= edges.length <= 10^4
    * edges[i].length = 3
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * 1 <= edges[i][2] <= 10^6
    * 1 <= marked.length <= n - 1
    * 0 <= s, marked[i] <= n - 1
    * s != marked[i]
    * marked[i] != marked[j] for every i != j
    * The graph might have repeated edges.
    * The graph is generated such that it has no self-loops."""

    def minimumDistance(self, n: int, edges: List[List[int]], s: int, marked: List[int]) -> int:
        graph = [[] for _ in range(n)]
        for u, v, w in edges:
            graph[u].append((v, w))
        marked = set(marked)
        pq = [(0, s)]
        dist = [inf]*n
        dist[s] = 0
        while pq:
            x, u = heappop(pq)
            if u in marked: return x
            for v, w in graph[u]:
                if x+w < dist[v]:
                    dist[v] = x+w
                    heappush(pq, (x+w, v))
        return -1


    """2739. Total Distance Traveled (Easy)
    A truck has two fuel tanks. You are given two integers, mainTank
    representing the fuel present in the main tank in liters and additionalTank
    representing the fuel present in the additional tank in liters. The truck
    has a mileage of 10 km per liter. Whenever 5 liters of fuel get used up in
    the main tank, if the additional tank has at least 1 liters of fuel, 1
    liters of fuel will be transferred from the additional tank to the main
    tank. Return the maximum distance which can be traveled. Note: Injection
    from the additional tank is not continuous. It happens suddenly and
    immediately for every 5 liters consumed.

    Example 1:
    Input: mainTank = 5, additionalTank = 10
    Output: 60
    Explanation: - After spending 5 litre of fuel, fuel remaining is
                   (5 - 5 + 1) = 1 litre and distance traveled is 50km.
                 - After spending another 1 litre of fuel, no fuel gets injected
                   in the main tank and the main tank becomes empty.
                 Total distance traveled is 60km.

    Example 2:
    Input: mainTank = 1, additionalTank = 2
    Output: 10
    Explanation: After spending 1 litre of fuel, the main tank becomes empty.
                 Total distance traveled is 10km.

    Constraints: 1 <= mainTank, additionalTank <= 100"""

    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:
        ans = 0
        while mainTank >= 5:
            q, mainTank = divmod(mainTank, 5)
            ans += 50*q
            q = min(q, additionalTank)
            mainTank += q
            additionalTank -= q
        return ans + 10*mainTank


    """2740. Find the Value of the Partition (Medium)
    You are given a positive integer array nums. Partition nums into two arrays,
    nums1 and nums2, such that:
    * Each element of the array nums belongs to either the array nums1 or the
      array nums2.
    * Both arrays are non-empty.
    * The value of the partition is minimized.
    The value of the partition is |max(nums1) - min(nums2)|. Here, max(nums1)
    denotes the maximum element of the array nums1, and min(nums2) denotes the
    minimum element of the array nums2. Return the integer denoting the value of
    such partition.

    Example 1:
    Input: nums = [1,3,2,4]
    Output: 1
    Explanation: We can partition the array nums into nums1 = [1,2] and
                 nums2 = [3,4].
                 - The maximum element of the array nums1 is equal to 2.
                 - The minimum element of the array nums2 is equal to 3.
                 The value of the partition is |2 - 3| = 1. It can be proven
                 that 1 is the minimum value out of all partitions.

    Example 2:
    Input: nums = [100,1,10]
    Output: 9
    Explanation: We can partition the array nums into nums1 = [10] and
                 nums2 = [100,1].
                 - The maximum element of the array nums1 is equal to 10.
                 - The minimum element of the array nums2 is equal to 1.
                 The value of the partition is |10 - 1| = 9. It can be proven
                 that 9 is the minimum value out of all partitions.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def findValueOfPartition(self, nums: List[int]) -> int:
        return min(y-x for x, y in pairwise(sorted(nums)))


    """2741. Special Permutations (Medium)
    You are given a 0-indexed integer array nums containing n distinct positive
    integers. A permutation of nums is called special if:
    * For all indexes 0 <= i < n - 1, either nums[i] % nums[i+1] == 0 or
      nums[i+1] % nums[i] == 0.
    Return the total number of special permutations. As the answer could be
    large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,3,6]
    Output: 2
    Explanation: [3,6,2] and [2,6,3] are the two special permutations of nums.

    Example 2:
    Input: nums = [1,4,3]
    Output: 2
    Explanation: [3,1,4] and [4,1,3] are the two special permutations of nums.

    Constraints:
    * 2 <= nums.length <= 14
    * 1 <= nums[i] <= 10^9"""

    def specialPerm(self, nums: List[int]) -> int:
        mod = 1_000_000_007
        n = len(nums)

        @cache
        def fn(i, m):
            """Return """
            if m+1 == 1<<n: return 1
            ans = 0
            for j in range(n):
                if not m & 1<<j and (nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0):
                    ans += fn(j, m ^ 1<<j)
            return ans % mod

        return sum(fn(i, 1<<i) for i in range(n)) % mod


    """2742. Painting the Walls (Hard)
    You are given two 0-indexed integer arrays, cost and time, of size n
    representing the costs and the time taken to paint n different walls
    respectively. There are two painters available:
    * A paid painter that paints the ith wall in time[i] units of time and takes
      cost[i] units of money.
    * A free painter that paints any wall in 1 unit of time at a cost of 0. But
      the free painter can only be used if the paid painter is already occupied.
    Return the minimum amount of money required to paint the n walls.

    Example 1:
    Input: cost = [1,2,3,2], time = [1,2,3,2]
    Output: 3
    Explanation: The walls at index 0 and 1 will be painted by the paid painter,
                 and it will take 3 units of time; meanwhile, the free painter
                 will paint the walls at index 2 and 3, free of cost in 2 units
                 of time. Thus, the total cost is 1 + 2 = 3.

    Example 2:
    Input: cost = [2,3,4,2], time = [1,1,1,1]
    Output: 4
    Explanation: The walls at index 0 and 3 will be painted by the paid painter,
                 and it will take 2 units of time; meanwhile, the free painter
                 will paint the walls at index 1 and 2, free of cost in 2 units
                 of time. Thus, the total cost is 2 + 2 = 4.

    Constraints:
    * 1 <= cost.length <= 500
    * cost.length == time.length
    * 1 <= cost[i] <= 10^6
    * 1 <= time[i] <= 500"""

    def paintWalls(self, cost: List[int], time: List[int]) -> int:
        n = len(cost)
        dp = [[inf]*(n+1) for _ in range(n+1)]
        for i in range(n-1, -1, -1):
            for j in range(n+1):
                dp[i][j] = dp[i+1][j]
                cand = cost[i]
                if j > 1+time[i]: cand += dp[i+1][j-1-time[i]]
                dp[i][j] = min(dp[i][j], cand)
        return dp[0][n]


    """2743. Count Substrings Without Repeating Character (Medium)
    You are given a string s consisting only of lowercase English letters. We
    call a substring special if it contains no character which has occurred at
    least twice (in other words, it does not contain a repeating character).
    Your task is to count the number of special substrings. For example, in the
    string "pop", the substring "po" is a special substring, however, "pop" is
    not special (since 'p' has occurred twice). Return the number of special
    substrings. A substring is a contiguous sequence of characters within a
    string. For example, "abc" is a substring of "abcd", but "acd" is not.

    Example 1:
    Input: s = "abcd"
    Output: 10
    Explanation: Since each character occurs once, every substring is a special
                 substring. We have 4 substrings of length one, 3 of length two,
                 2 of length three, and 1 substring of length four. So overall
                 there are 4 + 3 + 2 + 1 = 10 special substrings.

    Example 2:
    Input: s = "ooo"
    Output: 3
    Explanation: Any substring with a length of at least two contains a
                 repeating character. So we have to count the number of
                 substrings of length one, which is 3.

    Example 3:
    Input: s = "abab"
    Output: 7
    Explanation: Special substrings are as follows (sorted by their start positions):
                 Special substrings of length 1: "a", "b", "a", "b"
                 Special substrings of length 2: "ab", "ba", "ab"
                 And it can be shown that there are no special substrings with a
                 length of at least three. So the answer would be 4 + 3 = 7.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters"""

    def numberOfSpecialSubstrings(self, s: str) -> int:
        ans = 0
        ii = -1
        prev = defaultdict(lambda : -1)
        for i, x in enumerate(s):
            ii = max(ii, prev[x])
            prev[x] = i
            ans += i-ii
        return ans


    """2744. Find Maximum Number of String Pairs (Easy)
    You are given a 0-indexed array words consisting of distinct strings. The
    string words[i] can be paired with the string words[j] if:
    * The string words[i] is equal to the reversed string of words[j].
    * 0 <= i < j < words.length.
    Return the maximum number of pairs that can be formed from the array words.
    Note that each string can belong in at most one pair.

    Example 1:
    Input: words = ["cd","ac","dc","ca","zz"]
    Output: 2
    Explanation: In this example, we can form 2 pair of strings in the following
                 way:
                 - We pair the 0th string with the 2nd string, as the reversed
                   string of word[0] is "dc" and is equal to words[2].
                 - We pair the 1st string with the 3rd string, as the reversed
                   string of word[1] is "ca" and is equal to words[3].
                 It can be proven that 2 is the maximum number of pairs that can
                 be formed.

    Example 2:
    Input: words = ["ab","ba","cc"]
    Output: 1
    Explanation: In this example, we can form 1 pair of strings in the following
                 way:
                 - We pair the 0th string with the 1st string, as the reversed
                   string of words[1] is "ab" and is equal to words[0].
                 It can be proven that 1 is the maximum number of pairs that can
                 be formed.

    Example 3:
    Input: words = ["aa","ab"]
    Output: 0
    Explanation: In this example, we are unable to form any pair of strings.

    Constraints:
    * 1 <= words.length <= 50
    * words[i].length == 2
    * words consists of distinct strings.
    * words[i] contains only lowercase English letters."""

    def maximumNumberOfStringPairs(self, words: List[str]) -> int:
        ans = 0
        seen = set()
        for word in words:
            if word[::-1] in seen: ans += 1
            seen.add(word)
        return ans


    """2745. Construct the Longest New String (Medium)
    You are given three integers x, y, and z. You have x strings equal to "AA",
    y strings equal to "BB", and z strings equal to "AB". You want to choose
    some (possibly all or none) of these strings and concatenate them in some
    order to form a new string. This new string must not contain "AAA" or "BBB"
    as a substring. Return the maximum possible length of the new string. A
    substring is a contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: x = 2, y = 5, z = 1
    Output: 12
    Explanation: We can concactenate the strings "BB", "AA", "BB", "AA", "BB",
                 and "AB" in that order. Then, our new string is "BBAABBAABBAB".
                 That string has length 12, and we can show that it is
                 impossible to construct a string of longer length.

    Example 2:
    Input: x = 3, y = 2, z = 2
    Output: 14
    Explanation: We can concactenate the strings "AB", "AB", "AA", "BB", "AA",
                 "BB", and "AA" in that order. Then, our new string is
                 "ABABAABBAABBAA". That string has length 14, and we can show
                 that it is impossible to construct a string of longer length.

    Constraints: 1 <= x, y, z <= 50"""

    def longestString(self, x: int, y: int, z: int) -> int:
        return 2*(min(x+y, 2*x+1, 2*y+1) + z)


    """2746. Decremental String Concatenation (Medium)
    You are given a 0-indexed array words containing n strings. Let's define a
    join operation join(x, y) between two strings x and y as concatenating them
    into xy. However, if the last character of x is equal to the first character
    of y, one of them is deleted. For example join("ab", "ba") = "aba" and
    join("ab", "cde") = "abcde". You are to perform n - 1 join operations. Let
    str0 = words[0]. Starting from i = 1 up to i = n - 1, for the ith operation,
    you can do one of the following:
    * Make stri = join(stri - 1, words[i])
    * Make stri = join(words[i], stri - 1)
    Your task is to minimize the length of strn - 1. Return an integer denoting
    the minimum possible length of strn - 1.

    Example 1:
    Input: words = ["aa","ab","bc"]
    Output: 4
    Explanation: In this example, we can perform join operations in the
                 following order to minimize the length of str2:
                 - str0 = "aa"
                 - str1 = join(str0, "ab") = "aab"
                 - str2 = join(str1, "bc") = "aabc"
                 It can be shown that the minimum possible length of str2 is 4.

    Example 2:
    Input: words = ["ab","b"]
    Output: 2
    Explanation: In this example, str0 = "ab", there are two ways to get str1:
                 join(str0, "b") = "ab" or join("b", str0) = "bab".
                 The first string, "ab", has the minimum length. Hence, the
                 answer is 2.

    Example 3:
    Input: words = ["aaa","c","aba"]
    Output: 6
    Explanation: In this example, we can perform join operations in the
                 following order to minimize the length of str2:
                 - str0 = "aaa"
                 - str1 = join(str0, "c") = "aaac"
                 - str2 = join("aba", str1) = "abaaac"
                 It can be shown that the minimum possible length of str2 is 6.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 50
    * Each character in words[i] is an English lowercase letter"""

    def minimizeConcatenatedLength(self, words: List[str]) -> int:
        n = len(words)

        @cache
        def fn(i, s, e):
            """Return """
            if i == n: return 0
            w = words[i]
            return len(w) + min(fn(i+1, s, w[-1]) - int(e == w[0]), fn(i+1, w[0], e) - int(w[-1] == s))

        return len(words[0]) + fn(1, words[0][0], words[0][-1])


    """2747. Count Zero Request Servers (Medium)
    You are given an integer n denoting the total number of servers and a 2D
    0-indexed integer array logs, where logs[i] = [server_id, time] denotes that
    the server with id server_id received a request at time time. You are also
    given an integer x and a 0-indexed integer array queries. Return a 0-indexed
    integer array arr of length queries.length where arr[i] represents the
    number of servers that did not receive any requests during the time interval
    [queries[i] - x, queries[i]]. Note that the time intervals are inclusive.

    Example 1:
    Input: n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]
    Output: [1,2]
    Explanation:  - For queries[0]: The servers with ids 1 and 2 get requests in
                    the duration of [5, 10]. Hence, only server 3 gets zero
                    requests.
                  - For queries[1]: Only the server with id 2 gets a request in
                    duration of [6,11]. Hence, the servers with ids 1 and 3 are
                    the only servers that do not receive any requests during
                    that time period.

    Example 2:
    Input: n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]
    Output: [0,1]
    Explanation: - For queries[0]: All servers get at least one request in the
                   duration of [1, 3].
                 - For queries[1]: Only server with id 3 gets no request in the
                   duration [2,4].

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= logs.length <= 10^5
    * 1 <= queries.length <= 10^5
    * logs[i].length == 2
    * 1 <= logs[i][0] <= n
    * 1 <= logs[i][1] <= 10^6
    * 1 <= x <= 10^5
    * x < queries[i] <= 10^6"""

    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:
        logs.sort(key = lambda x: x[1])
        ans = [0]*len(queries)
        freq = Counter()
        j = jj = 0
        for i, q in sorted(enumerate(queries), key = lambda x: x[1]):
            while j < len(logs) and logs[j][1] <= q:
                freq[logs[j][0]] += 1
                j += 1
            while jj < len(logs) and logs[jj][1] < q-x:
                freq[logs[jj][0]] -= 1
                if freq[logs[jj][0]] == 0: freq.pop(logs[jj][0])
                jj += 1
            ans[i] = n - len(freq)
        return ans


    """2751. Robot Collisions (Hard)
    There are n 1-indexed robots, each having a position on a line, health, and
    movement direction. You are given 0-indexed integer arrays positions,
    healths, and a string directions (directions[i] is either 'L' for left or
    'R' for right). All integers in positions are unique. All robots start
    moving on the line simultaneously at the same speed in their given
    directions. If two robots ever share the same position while moving, they
    will collide. If two robots collide, the robot with lower health is removed
    from the line, and the health of the other robot decreases by one. The
    surviving robot continues in the same direction it was going. If both robots
    have the same health, they are both removed from the line. Your task is to
    determine the health of the robots that survive the collisions, in the same
    order that the robots were given, i.e. final heath of robot 1 (if survived),
    final health of robot 2 (if survived), and so on. If there are no survivors,
    return an empty array. Return an array containing the health of the
    remaining robots (in the order they were given in the input), after no
    further collisions can occur. Note: The positions may be unsorted.

    Example 1:
    Input: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = "RRRRR"
    Output: [2,17,9,15,10]
    Explanation: No collision occurs in this example, since all robots are
                 moving in the same direction. So, the health of the robots in
                 order from the first robot is returned, [2, 17, 9, 15, 10].

    Example 2:
    Input: positions = [3,5,2,6], healths = [10,10,15,12], directions = "RLRL"
    Output: [14]
    Explanation: There are 2 collisions in this example. Firstly, robot 1 and
                 robot 2 will collide, and since both have the same health, they
                 will be removed from the line. Next, robot 3 and robot 4 will
                 collide and since robot 4's health is smaller, it gets removed,
                 and robot 3's health becomes 15 - 1 = 14. Only robot 3 remains,
                 so we return [14].

    Example 3:
    Input: positions = [1,2,5,6], healths = [10,10,11,11], directions = "RLRL"
    Output: []
    Explanation: Robot 1 and robot 2 will collide and since both have the same
                 health, they are both removed. Robot 3 and 4 will collide and
                 since both have the same health, they are both removed. So, we
                 return an empty array, [].

    Constraints:
    * 1 <= positions.length == healths.length == directions.length == n <= 10^5
    * 1 <= positions[i], healths[i] <= 10^9
    * directions[i] == 'L' or directions[i] == 'R'
    * All values in positions are distinct"""

    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:
        ans = [0]*len(positions)
        stack = []
        for i, (p, h, d) in sorted(enumerate(zip(positions, healths, directions)), key=lambda x: x[1][0]):
            if d == 'R': stack.append((p, h, d, i))
            else:
                while stack and h:
                    pp, hh, dd, ii = stack.pop()
                    if hh < h: h -= 1
                    else:
                        if hh > h: stack.append((pp, hh-1, dd, ii))
                        h = 0
                ans[i] = h
        while stack:
            p, h, d, i = stack.pop()
            ans[i] = h
        return filter(None, ans)


    """2764. Is Array a Preorder of Some Binary Tree (Medium）
    Given a 0-indexed integer 2D array nodes, your task is to determine if the
    given array represents the preorder traversal of some binary tree. For each
    index i, nodes[i] = [id, parentId], where id is the id of the node at the
    index i and parentId is the id of its parent in the tree (if the node has no
    parent, then parentId == -1). Return true if the given array represents the
    preorder traversal of some tree, and false otherwise. Note: the preorder
    traversal of a tree is a recursive way to traverse a tree in which we first
    visit the current node, then we do the preorder traversal for the left child,
    and finally, we do it for the right child.

    Example 1:
    Input: nodes = [[0,-1],[1,0],[2,0],[3,2],[4,2]]
    Output: true
    Explanation: The given nodes make the tree in the picture below. We can show
                 that this is the preorder traversal of the tree, first we visit
                 node 0, then we do the preorder traversal of the right child
                 which is [1], then we do the preorder traversal of the left
                 child which is [2,3,4].

    Example 2:
    Input: nodes = [[0,-1],[1,0],[2,0],[3,1],[4,1]]
    Output: false
    Explanation: The given nodes make the tree in the picture below. For the
                 preorder traversal, first we visit node 0, then we do the
                 preorder traversal of the right child which is [1,3,4], but we
                 can see that in the given order, 2 comes between 1 and 3, so,
                 it's not the preorder traversal of the tree.

    Constraints:
    * 1 <= nodes.length <= 10^5
    * nodes[i].length == 2
    * 0 <= nodes[i][0] <= 10^5
    * -1 <= nodes[i][1] <= 10^5
    * The input is generated such that nodes make a binary tree."""

    def isPreorder(self, nodes: List[List[int]]) -> bool:
        stack = [-1]
        for n, p in nodes:
            while stack and stack[-1] != p: stack.pop()
            if not stack: return False
            stack.append(n)
        return True


    """2769. Find the Maximum Achievable Number (Easy)
    You are given two integers, num and t. An integer x is called achievable if
    it can become equal to num after applying the following operation no more
    than t times:
    * Increase or decrease x by 1, and simultaneously increase or decrease num
      by 1.
    Return the maximum possible achievable number. It can be proven that there
    exists at least one achievable number.

    Example 1:
    Input: num = 4, t = 1
    Output: 6
    Explanation: The maximum achievable number is x = 6; it can become equal to
                 num after performing this operation:
                 * 1- Decrease x by 1, and increase num by 1. Now, x = 5 and
                 num = 5.
                 It can be proven that there is no achievable number larger
                 than 6.

    Example 2:
    Input: num = 3, t = 2
    Output: 7
    Explanation: The maximum achievable number is x = 7; after performing these
                 operations, x will equal num:
                 * 1- Decrease x by 1, and increase num by 1. Now, x = 6 and
                   num = 4.
                 * 2- Decrease x by 1, and increase num by 1. Now, x = 5 and
                   num = 5.
                 It can be proven that there is no achievable number larger
                 than 7.

    Constraints: 1 <= num, t <= 50"""

    def theMaximumAchievableX(self, num: int, t: int) -> int:
        return num + 2*t


    """2770. Maximum Number of Jumps to Reach the Last Index (Medium)
    You are given a 0-indexed array nums of n integers and an integer target.
    You are initially positioned at index 0. In one step, you can jump from
    index i to any index j such that:
    * 0 <= i < j < n
    * -target <= nums[j] - nums[i] <= target
    Return the maximum number of jumps you can make to reach index n - 1. If
    there is no way to reach index n - 1, return -1.

    Example 1:
    Input: nums = [1,3,6,4,1,2], target = 2
    Output: 3
    Explanation: To go from index 0 to index n - 1 with the maximum number of
                 jumps, you can perform the following jumping sequence:
                 - Jump from index 0 to index 1.
                 - Jump from index 1 to index 3.
                 - Jump from index 3 to index 5.
                 It can be proven that there is no other jumping sequence that
                 goes from 0 to n - 1 with more than 3 jumps. Hence, the answer
                 is 3.

    Example 2:
    Input: nums = [1,3,6,4,1,2], target = 3
    Output: 5
    Explanation: To go from index 0 to index n - 1 with the maximum number of
                 jumps, you can perform the following jumping sequence:
                 - Jump from index 0 to index 1.
                 - Jump from index 1 to index 2.
                 - Jump from index 2 to index 3.
                 - Jump from index 3 to index 4.
                 - Jump from index 4 to index 5.
                 It can be proven that there is no other jumping sequence that
                 goes from 0 to n - 1 with more than 5 jumps. Hence, the answer
                 is 5.

    Example 3:
    Input: nums = [1,3,6,4,1,2], target = 0
    Output: -1
    Explanation: It can be proven that there is no jumping sequence that goes
                 from 0 to n - 1. Hence, the answer is -1.

    Constraints:
    * 2 <= nums.length == n <= 1000
    * -10^9 <= nums[i] <= 10^9
    * 0 <= target <= 2 * 10^9"""

    def maximumJumps(self, nums: List[int], target: int) -> int:
        n = len(nums)
        dp = [-1] * n
        dp[-1] = 0
        for i in range(n-2, -1, -1):
            for j in range(i+1, n):
                if dp[j] != -1 and abs(nums[i] - nums[j]) <= target:
                    dp[i] = max(dp[i], 1 + dp[j])
        return dp[0]


    """2771. Longest Non-decreasing Subarray From Two Arrays (Medium)
    You are given two 0-indexed integer arrays nums1 and nums2 of length n.
    Let's define another 0-indexed integer array, nums3, of length n. For each
    index i in the range [0, n - 1], you can assign either nums1[i] or nums2[i]
    to nums3[i]. Your task is to maximize the length of the longest non-
    decreasing subarray in nums3 by choosing its values optimally. Return an
    integer representing the length of the longest non-decreasing subarray in
    nums3. Note: A subarray is a contiguous non-empty sequence of elements
    within an array.

    Example 1:
    Input: nums1 = [2,3,1], nums2 = [1,2,1]
    Output: 2
    Explanation: One way to construct nums3 is:
                 nums3 = [nums1[0], nums2[1], nums2[2]] => [2,2,1].
                 The subarray starting from index 0 and ending at index 1,
                 [2,2], forms a non-decreasing subarray of length 2. We can
                 show that 2 is the maximum achievable length.

    Example 2:
    Input: nums1 = [1,3,2,1], nums2 = [2,2,3,4]
    Output: 4
    Explanation: One way to construct nums3 is:
                 nums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] => [1,2,3,4].
                 The entire array forms a non-decreasing subarray of length 4,
                 making it the maximum achievable length.

    Example 3:
    Input: nums1 = [1,1], nums2 = [2,2]
    Output: 2
    Explanation: One way to construct nums3 is:
                 nums3 = [nums1[0], nums1[1]] => [1,1].
                 The entire array forms a non-decreasing subarray of length 2,
                 making it the maximum achievable length.

    Constraints:
    * 1 <= nums1.length == nums2.length == n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^9"""

    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:
        ans = 0
        dp1 = dp2 = 1
        for i, (x1, x2) in enumerate(zip(nums1, nums2)):
            dp11 = dp12 = dp21 = dp22 = 1
            if i and nums1[i-1] <= x1: dp11 += dp1
            if i and nums2[i-1] <= x1: dp21 += dp2
            if i and nums1[i-1] <= x2: dp12 += dp1
            if i and nums2[i-1] <= x2: dp22 += dp2
            dp1 = max(dp11, dp21)
            dp2 = max(dp12, dp22)
            ans = max(ans, dp1, dp2)
        return ans


    """2772. Apply Operations to Make All Array Elements Equal to Zero (Medium)
    You are given a 0-indexed integer array nums and a positive integer k. You
    can apply the following operation on the array any number of times:
    * Choose any subarray of size k from the array and decrease all its
      elements by 1.
    Return true if you can make all the array elements equal to 0, or false
    otherwise. A subarray is a contiguous non-empty part of an array.

    Example 1:
    Input: nums = [2,2,3,1,1,0], k = 3
    Output: true
    Explanation: We can do the following operations:
                 - Choose the subarray [2,2,3]. The resulting array will be
                   nums = [1,1,2,1,1,0].
                 - Choose the subarray [2,1,1]. The resulting array will be
                   nums = [1,1,1,0,0,0].
                 - Choose the subarray [1,1,1]. The resulting array will be
                   nums = [0,0,0,0,0,0].

    Example 2:
    Input: nums = [1,3,1,1], k = 2
    Output: false
    Explanation: It is not possible to make all the array elements equal to 0.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6"""

    def checkArray(self, nums: List[int], k: int) -> bool:
        prefix = 0
        for i, x in enumerate(nums):
            if prefix > x: return False
            nums[i] -= prefix
            prefix = x
            if i >= k-1: prefix -= nums[i-k+1];
        return prefix == 0


    """2778. Sum of Squares of Special Elements (Easy)
    You are given a 1-indexed integer array nums of length n. An element nums[i]
    of nums is called special if i divides n, i.e. n % i == 0. Return the sum
    of the squares of all special elements of nums.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 21
    Explanation: There are exactly 3 special elements in nums: nums[1] since 1
                 divides 4, nums[2] since 2 divides 4, and nums[4] since 4
                 divides 4. Hence, the sum of the squares of all special
                 elements of nums is
                 nums[1] * nums[1] + nums[2] * nums[2] + nums[4] * nums[4] =
                 1 * 1 + 2 * 2 + 4 * 4 = 21.

    Example 2:
    Input: nums = [2,7,1,19,18,3]
    Output: 63
    Explanation: There are exactly 4 special elements in nums: nums[1] since 1
                 divides 6, nums[2] since 2 divides 6, nums[3] since 3 divides
                 6, and nums[6] since 6 divides 6. Hence, the sum of the
                 squares of all special elements of nums is
                 nums[1] * nums[1] + nums[2] * nums[2] + nums[3] * nums[3] +
                 nums[6] * nums[6] = 2 * 2 + 7 * 7 + 1 * 1 + 3 * 3 = 63.

    Constraints:
    * 1 <= nums.length == n <= 50
    * 1 <= nums[i] <= 50"""

    def sumOfSquares(self, nums: List[int]) -> int:
        ans = 0
        for i, x in enumerate(nums, 1):
            if len(nums) % i == 0: ans += x*x
        return ans


    """2779. Maximum Beauty of an Array After Applying Operation (Medium)
    You are given a 0-indexed array nums and a non-negative integer k. In one
    operation, you can do the following:
    * Choose an index i that hasn't been chosen before from the range
      [0, nums.length - 1].
    * Replace nums[i] with any integer from the range
      [nums[i] - k, nums[i] + k].
    The beauty of the array is the length of the longest subsequence consisting
    of equal elements. Return the maximum possible beauty of the array nums
    after applying the operation any number of times. Note that you can apply
    the operation to each index only once. A subsequence of an array is a new
    array generated from the original array by deleting some elements (possibly
    none) without changing the order of the remaining elements.

    Example 1:
    Input: nums = [4,6,1,2], k = 2
    Output: 3
    Explanation: In this example, we apply the following operations:
                 - Choose index 1, replace it with 4 (from range [4,8]),
                   nums = [4,4,1,2].
                 - Choose index 3, replace it with 4 (from range [0,4]),
                   nums = [4,4,1,4].
                 After the applied operations, the beauty of the array nums is
                 3 (subsequence consisting of indices 0, 1, and 3). It can be
                 proven that 3 is the maximum possible length we can achieve.

    Example 2:
    Input: nums = [1,1,1,1], k = 10
    Output: 4
    Explanation: In this example we don't have to apply any operations. The
                 beauty of the array nums is 4 (whole array).

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i], k <= 10^5"""

    def maximumBeauty(self, nums: List[int], k: int) -> int:
        nums.sort()
        ii = 0
        for i, x in enumerate(nums):
            if x - nums[ii] > 2*k: ii += 1
        return i - ii + 1


    """2780. Minimum Index of a Valid Split (Medium)
    An element x of an integer array arr of length m is dominant if
    freq(x) * 2 > m, where freq(x) is the number of occurrences of x in arr.
    Note that this definition implies that arr can have at most one dominant
    element. You are given a 0-indexed integer array nums of length n with one
    dominant element. You can split nums at an index i into two arrays
    nums[0, ..., i] and nums[i + 1, ..., n - 1], but the split is only valid if:
    * 0 <= i < n - 1
    * nums[0, ..., i], and nums[i + 1, ..., n - 1] have the same dominant
      element.
    Here, nums[i, ..., j] denotes the subarray of nums starting at index i and
    ending at index j, both ends being inclusive. Particularly, if j < i then
    nums[i, ..., j] denotes an empty subarray. Return the minimum index of a
    valid split. If no valid split exists, return -1.

    Example 1:
    Input: nums = [1,2,2,2]
    Output: 2
    Explanation: We can split the array at index 2 to obtain arrays [1,2,2] and
                 [2]. In array [1,2,2], element 2 is dominant since it occurs
                 twice in the array and 2 * 2 > 3. In array [2], element 2 is
                 dominant since it occurs once in the array and 1 * 2 > 1. Both
                 [1,2,2] and [2] have the same dominant element as nums, so
                 this is a valid split. It can be shown that index 2 is the
                 minimum index of a valid split.

    Example 2:
    Input: nums = [2,1,3,1,1,1,7,1,2,1]
    Output: 4
    Explanation: We can split the array at index 4 to obtain arrays [2,1,3,1,1]
                 and [1,7,1,2,1]. In array [2,1,3,1,1], element 1 is dominant
                 since it occurs thrice in the array and 3 * 2 > 5. In array
                 [1,7,1,2,1], element 1 is dominant since it occurs thrice in
                 the array and 3 * 2 > 5. Both [2,1,3,1,1] and [1,7,1,2,1] have
                 the same dominant element as nums, so this is a valid split.
                 It can be shown that index 4 is the minimum index of a valid
                 split.

    Example 3:
    Input: nums = [3,3,3,3,7,2,2]
    Output: -1
    Explanation: It can be shown that there is no valid split.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * nums has exactly one dominant element."""

    def minimumIndex(self, nums: List[int]) -> int:
        freq = Counter(nums)
        k, v = max(freq.items(), key=lambda x: x[1])
        prefix = 0
        for i, x in enumerate(nums):
            if x == k: prefix += 1
            if i < len(nums)-1 and prefix*2 > i+1 and (v-prefix)*2 > len(nums)-i-1: return i
        return -1


    """2781. Length of the Longest Valid Substring (Hard)
    You are given a string word and an array of strings forbidden. A string is
    called valid if none of its substrings are present in forbidden. Return the
    length of the longest valid substring of the string word. A substring is a
    contiguous sequence of characters in a string, possibly empty.

    Example 1:
    Input: word = "cbaaaabc", forbidden = ["aaa","cb"]
    Output: 4
    Explanation: There are 9 valid substrings in word: "c", "b", "a", "ba",
                 "aa", "bc", "baa", "aab", and "aabc". The length of the
                 longest valid substring is 4. It can be shown that all other
                 substrings contain either "aaa" or "cb" as a substring.

    Example 2:
    Input: word = "leetcode", forbidden = ["de","le","e"]
    Output: 4
    Explanation: There are 11 valid substrings in word: "l", "t", "c", "o",
                 "d", "tc", "co", "od", "tco", "cod", and "tcod". The length of
                 the longest valid substring is 4. It can be shown that all
                 other substrings contain either "de", "le", or "e" as a
                 substring.

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists only of lowercase English letters.
    * 1 <= forbidden.length <= 10^5
    * 1 <= forbidden[i].length <= 10
    * forbidden[i] consists only of lowercase English letters."""

    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        forbidden = set(forbidden)
        ans = val = 0
        for i in range(len(word)-1, -1, -1):
            val += 1
            for k in range(min(10, val)):
                if word[i:i+k+1] in forbidden:
                    val = k
                    break
            ans = max(ans, val)
        return ans


    """    /*2782. Number of Unique Categories (Medium)
    You are given an integer n and an object categoryHandler of class
    CategoryHandler. There are n elements, numbered from 0 to n - 1. Each
    element has a category, and your task is to find the number of unique
    categories. The class CategoryHandler contains the following function, which
    may help you:
    * boolean haveSameCategory(integer a, integer b): Returns true if a and b
      are in the same category and false otherwise. Also, if either a or b is
      not a valid number (i.e. it's greater than or equal to nor less than 0),
      it returns false.
    Return the number of unique categories.

    Example 1:
    Input: n = 6, categoryHandler = [1,1,2,2,3,3]
    Output: 3
    Explanation: There are 6 elements in this example. The first two elements
                 belong to category 1, the second two belong to category 2, and
                 the last two elements belong to category 3. So there are 3
                 unique categories.

    Example 2:
    Input: n = 5, categoryHandler = [1,2,3,4,5]
    Output: 5
    Explanation: There are 5 elements in this example. Each element belongs to a
                 unique category. So there are 5 unique categories.

    Example 3:
    Input: n = 3, categoryHandler = [1,1,1]
    Output: 1
    Explanation: There are 3 elements in this example. All of them belong to one
                 category. So there is only 1 unique category.

    Constraints: 1 <= n <= 100*/"""

    def numberOfCategories(self, n: int, categoryHandler: Optional['CategoryHandler']) -> int:
        ans = 0
        for j in range(n):
            for i in range(j):
                if categoryHandler.haveSameCategory(i, j): break
            else: ans += 1
        return ans


    """2784. Check if Array is Good (Easy)
    You are given an integer array nums. We consider an array good if it is a
    permutation of an array base[n]. base[n] = [1, 2, ..., n - 1, n, n] (in
    other words, it is an array of length n + 1 which contains 1 to n - 1
    exactly once, plus two occurrences of n). For example, base[1] = [1, 1] and
    base[3] = [1, 2, 3, 3]. Return true if the given array is good, otherwise
    return false. Note: A permutation of integers represents an arrangement of
    these numbers.

    Example 1:
    Input: nums = [2, 1, 3]
    Output: false
    Explanation: Since the maximum element of the array is 3, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 3. However, base[3] has four elements but
                 array nums has three. Therefore, it can not be a permutation
                 of base[3] = [1, 2, 3, 3]. So the answer is false.

    Example 2:
    Input: nums = [1, 3, 3, 2]
    Output: true
    Explanation: Since the maximum element of the array is 3, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 3. It can be seen that nums is a permutation
                 of base[3] = [1, 2, 3, 3] (by swapping the second and fourth
                 elements in nums, we reach base[3]). Therefore, the answer is
                 true.

    Example 3:
    Input: nums = [1, 1]
    Output: true
    Explanation: Since the maximum element of the array is 1, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 1. It can be seen that nums is a permutation
                 of base[1] = [1, 1]. Therefore, the answer is true.

    Example 4:
    Input: nums = [3, 4, 4, 1, 2, 1]
    Output: false
    Explanation: Since the maximum element of the array is 4, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 4. However, base[4] has five elements but
                 array nums has six. Therefore, it can not be a permutation of
                 base[4] = [1, 2, 3, 4, 4]. So the answer is false.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= num[i] <= 200"""

    def isGood(self, nums: List[int]) -> bool:
        n = len(nums)-1
        i = cnt = 0
        while i <= n and cnt <= n:
            if nums[i] == i+1 or i == n and nums[-1] == n: i += 1
            else:
                if not 0 <= nums[i] <= n: return False
                if nums[i] == n and nums[-1] != n: nums[i], nums[-1] = nums[-1], nums[i]
                else: nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
                cnt += 1
        return n and cnt <= n


    """2785. Sort Vowels in a String (Medium)
    Given a 0-indexed string s, permute s to get a new string t such that:
    * All consonants remain in their original places. More formally, if there
      is an index i with 0 <= i < s.length such that s[i] is a consonant, then
      t[i] = s[i].
    * The vowels must be sorted in the nondecreasing order of their ASCII
      values. More formally, for pairs of indices i, j with
      0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must
      not have a higher ASCII value than t[j].
    Return the resulting string. The vowels are 'a', 'e', 'i', 'o', and 'u',
    and they can appear in lowercase or uppercase. Consonants comprise all
    letters that are not vowels.

    Example 1:
    Input: s = "lEetcOde"
    Output: "lEOtcede"
    Explanation: 'E', 'O', and 'e' are the vowels in s; 'l', 't', 'c', and 'd'
                 are all consonants. The vowels are sorted according to their
                 ASCII values, and the consonants remain in the same places.

    Example 2:
    Input: s = "lYmpH"
    Output: "lYmpH"
    Explanation: There are no vowels in s (all characters in s are consonants),
                 so we return "lYmpH".

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of letters of the English alphabet in uppercase and
      lowercase."""

    def sortVowels(self, s: str) -> str:
        vowels = sorted((ch for ch in s if ch in "aeiouAEIOU"), reverse=True)
        return ''.join(vowels.pop() if ch in "aeiouAEIOU" else ch for ch in s)


    """2786. Visit Array Positions to Maximize Score (Medium)
    You are given a 0-indexed integer array nums and a positive integer x. You
    are initially at position 0 in the array and you can visit other positions
    according to the following rules:
    * If you are currently in position i, then you can move to any position j
      such that i < j.
    * For each position i that you visit, you get a score of nums[i].
    * If you move from a position i to a position j and the parities of nums[i]
      and nums[j] differ, then you lose a score of x.
    Return the maximum total score you can get. Note that initially you have
    nums[0] points.

    Example 1:
    Input: nums = [2,3,6,1,9,2], x = 5
    Output: 13
    Explanation: We can visit the following positions in the array: 0 -> 2 ->
                 3 -> 4. The corresponding values are 2, 6, 1 and 9. Since the
                 integers 6 and 1 have different parities, the move 2 -> 3 will
                 make you lose a score of x = 5. The total score will be:
                 2 + 6 + 1 + 9 - 5 = 13.

    Example 2:
    Input: nums = [2,4,6,8], x = 3
    Output: 20
    Explanation: All the integers in the array have the same parities, so we
                 can visit all of them without losing any score. The total
                 score is: 2 + 4 + 6 + 8 = 20.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i], x <= 10^6"""

    def maxScore(self, nums: List[int], x: int) -> int:
        dp = [-x]*2
        for i, v in enumerate(nums):
            if i: dp[v&1] = v + max(dp[v&1], dp[v&1 ^1]-x)
            else: dp[v&1] = v
        return max(dp)


    """2787. Ways to Express an Integer as Sum of Powers (Medium)
    Given two positive integers n and x. Return the number of ways n can be
    expressed as the sum of the xth power of unique positive integers, in other
    words, the number of sets of unique integers [n1, n2, ..., nk] where
    n = n1^x + n2^x + ... + nk^x. Since the result can be very large, return it
    modulo 10^9 + 7. For example, if n = 160 and x = 3, one way to express n is
    n = 2^3 + 3^3 + 5^3.

    Example 1:
    Input: n = 10, x = 2
    Output: 1
    Explanation: We can express n as the following: n = 32 + 12 = 10. It can be
                 shown that it is the only way to express 10 as the sum of the
                 2nd power of unique integers.

    Example 2:
    Input: n = 4, x = 1
    Output: 2
    Explanation: We can express n in the following ways:
                 - n = 4^1 = 4.
                 - n = 3^1 + 1^1 = 4.

    Constraints:
    * 1 <= n <= 300
    * 1 <= x <= 5"""

    def numberOfWays(self, n: int, x: int) -> int:
        dp = [0]*(n+1)
        dp[0] = 1
        for k in range(n):
            v = pow(k+1, x)
            if v > n: break
            for i in range(n, v-1, -1): dp[i] = (dp[i-v] + dp[i]) % 1_000_000_007
        return dp[n]


    """2802. Find The K-th Lucky Number (Medium）
    We know that 4 and 7 are lucky digits. Also, a number is called lucky if it
    contains only lucky digits. You are given an integer k, return the kth lucky
    number represented as a string.

    Example 1:
    Input: k = 4
    Output: "47"
    Explanation: The first lucky number is 4, the second one is 7, the third one
                 is 44 and the fourth one is 47.

    Example 2:
    Input: k = 10
    Output: "477"
    Explanation: Here are lucky numbers sorted in increasing order:
                 4, 7, 44, 47, 74, 77, 444, 447, 474, 477. So the 10th lucky
                 number is 477.

    Example 3:
    Input: k = 1000
    Output: "777747447"
    Explanation: It can be shown that the 1000th lucky number is 777747447.

    Constraints: 1 <= k <= 10^9"""

    def kthLuckyNumber(self, k: int) -> str:
        n = int(log2(k+1))
        k -= (1<<n)-1
        ans = []
        for i in range(n-1, -1, -1):
            if k & 1<<i: ans.append('7')
            else: ans.append('4')
        return ''.join(ans)


    """2806. Account Balance After Rounded Purchase (Easy)
    Initially, you have a bank account balance of 100 dollars. You are given an
    integer purchaseAmount representing the amount you will spend on a purchase
    in dollars. At the store where you will make the purchase, the purchase
    amount is rounded to the nearest multiple of 10. In other words, you pay a
    non-negative amount, roundedAmount, such that roundedAmount is a multiple
    of 10 and abs(roundedAmount - purchaseAmount) is minimized. If there is
    more than one nearest multiple of 10, the largest multiple is chosen.
    Return an integer denoting your account balance after making a purchase
    worth purchaseAmount dollars from the store. Note: 0 is considered to be a
    multiple of 10 in this problem.

    Example 1:
    Input: purchaseAmount = 9
    Output: 90
    Explanation: In this example, the nearest multiple of 10 to 9 is 10. Hence,
                 your account balance becomes 100 - 10 = 90.

    Example 2:
    Input: purchaseAmount = 15
    Output: 80
    Explanation: In this example, there are two nearest multiples of 10 to 15:
                 10 and 20. So, the larger multiple, 20, is chosen. Hence,
                 your account balance becomes 100 - 20 = 80.

    Constraints: 0 <= purchaseAmount <= 100"""

    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:
        return 100 - (purchaseAmount+5)//10*10


    """2807. Insert Greatest Common Divisors in Linked List (Medium)
    Given the head of a linked list head, in which each node contains an
    integer value. Between every pair of adjacent nodes, insert a new node with
    a value equal to the greatest common divisor of them. Return the linked
    list after insertion. The greatest common divisor of two numbers is the
    largest positive integer that evenly divides both numbers.

    Example 1:
    Input: head = [18,6,10,3]
    Output: [18,6,6,2,10,1,3]
    Explanation: The 1st diagram denotes the initial linked list and the 2nd
                 diagram denotes the linked list after inserting the new nodes
                 (nodes in blue are the inserted nodes).
                 - We insert the greatest common divisor of 18 and 6 = 6
                   between the 1st and the 2nd nodes.
                 - We insert the greatest common divisor of 6 and 10 = 2
                   between the 2nd and the 3rd nodes.
                 - We insert the greatest common divisor of 10 and 3 = 1
                   between the 3rd and the 4th nodes.
                 There are no more adjacent nodes, so we return the linked list.

    Example 2:
    Input: head = [7]
    Output: [7]
    Explanation: The 1st diagram denotes the initial linked list and the 2nd
                 diagram denotes the linked list after inserting the new nodes.
                 There are no pairs of adjacent nodes, so we return the initial
                 linked list.

    Constraints:
    * The number of nodes in the list is in the range [1, 5000].
    * 1 <= Node.val <= 1000"""

    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head
        while node and node.next:
            temp = ListNode(gcd(node.val, node.next.val), node.next)
            node.next = temp
            node = node.next.next
        return head


    """2808. Minimum Seconds to Equalize a Circular Array (Medium)
    You are given a 0-indexed array nums containing n integers. At each second,
    you perform the following operation on the array:
    * For every index i in the range [0, n - 1], replace nums[i] with either
      nums[i], nums[(i - 1 + n) % n], or nums[(i + 1) % n].
    Note that all the elements get replaced simultaneously. Return the minimum
    number of seconds needed to make all elements in the array nums equal.

    Example 1:
    Input: nums = [1,2,1,2]
    Output: 1
    Explanation: We can equalize the array in 1 second in the following way:
                 - At 1st second, replace values at each index with
                   [nums[3],nums[1],nums[3],nums[3]]. After replacement,
                   nums = [2,2,2,2].
                 It can be proven that 1 second is the minimum amount of
                 seconds needed for equalizing the array.

    Example 2:
    Input: nums = [2,1,3,3,2]
    Output: 2
    Explanation: We can equalize the array in 2 seconds in the following way:
                 - At 1st second, replace values at each index with
                   [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement,
                   nums = [2,3,3,3,3].
                 - At 2nd second, replace values at each index with
                   [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement,
                   nums = [3,3,3,3,3].
                 It can be proven that 2 seconds is the minimum amount of
                 seconds needed for equalizing the array.

    Example 3:
    Input: nums = [5,5,5,5]
    Output: 0
    Explanation: We don't need to perform any operations as all elements in the
                 initial array are the same.

    Constraints:
    * 1 <= n == nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def minimumSeconds(self, nums: List[int]) -> int:
        pos = defaultdict(list)
        for i, x in enumerate(nums): pos[x].append(i)
        ans = inf
        for k, v in pos.items():
            cand = 0
            prev = -1
            for x in v:
                if prev >= 0: cand = max(cand, x - prev)
                prev = x
            cand = max(cand, v[0] + len(nums) - v[-1])
            ans = min(ans, cand)
        return ans//2


    """2809. Minimum Time to Make Array Sum At Most x (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2 of equal length.
    Every second, for all indices 0 <= i < nums1.length, value of nums1[i] is
    incremented by nums2[i]. After this is done, you can do the following
    operation:
    * Choose an index 0 <= i < nums1.length and make nums1[i] = 0.
    You are also given an integer x. Return the minimum time in which you can
    make the sum of all elements of nums1 to be less than or equal to x, or -1
    if this is not possible.

    Example 1:
    Input: nums1 = [1,2,3], nums2 = [1,2,3], x = 4
    Output: 3
    Explanation: For the 1st second, we apply the operation on i = 0. Therefore
                 nums1 = [0,2+2,3+3] = [0,4,6].
                 For the 2nd second, we apply the operation on i = 1. Therefore
                 nums1 = [0+1,0,6+3] = [1,0,9].
                 For the 3rd second, we apply the operation on i = 2. Therefore
                 nums1 = [1+1,0+2,0] = [2,2,0].
                 Now sum of nums1 = 4. It can be shown that these operations
                 are optimal, so we return 3.

    Example 2:
    Input: nums1 = [1,2,3], nums2 = [3,3,3], x = 4
    Output: -1
    Explanation: It can be shown that the sum of nums1 will always be greater
                 than x, no matter which operations are performed.

    Constraints:
    * 1 <= nums1.length <= 10^3
    * 1 <= nums1[i] <= 10^3
    * 0 <= nums2[i] <= 10^3
    * nums1.length == nums2.length
    * 0 <= x <= 10^6"""

    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:
        nums1, nums2 = zip(*sorted(zip(nums1, nums2), key = lambda x: x[1]))
        n = len(nums1)
        dp = [[0]*(n+1) for _ in range(n+1)]
        for i in range(1, n+1):
            for j in range(1, i+1):
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums2[i-1]*j + nums1[i-1])
        s1 = sum(nums1)
        s2 = sum(nums2)
        for t in range(n+1):
            if s1 + s2*t - dp[n][t] <= x: return t
        return -1


    """2810. Faulty Keyboard (Easy)
    Your laptop keyboard is faulty, and whenever you type a character 'i' on it,
    it reverses the string that you have written. Typing other characters works
    as expected. You are given a 0-indexed string s, and you type each
    character of s using your faulty keyboard. Return the final string that
    will be present on your laptop screen.

    Example 1:
    Input: s = "string"
    Output: "rtsng"
    Explanation: - After typing first character, the text on the screen is "s".
                 - After the second character, the text is "st".
                 - After the third character, the text is "str".
                 - Since the fourth character is an 'i', the text gets reversed
                 - and becomes "rts".
                 - After the fifth character, the text is "rtsn".
                 - After the sixth character, the text is "rtsng".
                 - Therefore, we return "rtsng".

    Example 2:
    Input: s = "poiinter"
    Output: "ponter"
    Explanation: - After the first character, the text on the screen is "p".
                 - After the second character, the text is "po".
                 - Since the third character you type is an 'i', the text gets
                   reversed and becomes "op".
                 - Since the fourth character you type is an 'i', the text gets
                   reversed and becomes "po".
                 - After the fifth character, the text is "pon".
                 - After the sixth character, the text is "pont".
                 - After the seventh character, the text is "ponte".
                 - After the eighth character, the text is "ponter".
                 - Therefore, we return "ponter".

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters.
    * s[0] != 'i'"""

    def finalString(self, s: str) -> str:
        ans = deque()
        flip = False
        for ch in s:
            if ch == 'i': flip = not flip
            elif not flip: ans.append(ch)
            else: ans.appendleft(ch)
        if flip: ans.reverse()
        return ''.join(ans)


    """2811. Check if it is Possible to Split Array (Medium)
    You are given an array nums of length n and an integer m. You need to
    determine if it is possible to split the array into n non-empty arrays by
    performing a series of steps. In each step, you can select an existing
    array (which may be the result of previous steps) with a length of at least
    two and split it into two subarrays, if, for each resulting subarray, at
    least one of the following holds:
    * The length of the subarray is one, or
    * The sum of elements of the subarray is greater than or equal to m.
    Return true if you can split the given array into n arrays, otherwise
    return false. Note: A subarray is a contiguous non-empty sequence of
    elements within an array.

    Example 1:
    Input: nums = [2, 2, 1], m = 4
    Output: true
    Explanation: We can split the array into [2, 2] and [1] in the first step.
                 Then, in the second step, we can split [2, 2] into [2] and [2].
                 As a result, the answer is true.

    Example 2:
    Input: nums = [2, 1, 3], m = 5
    Output: false
    Explanation: We can try splitting the array in two different ways: the
                 first way is to have [2, 1] and [3], and the second way is to
                 have [2] and [1, 3]. However, both of these ways are not valid.
                 So, the answer is false.

    Example 3:
    Input: nums = [2, 3, 3, 2, 3], m = 6
    Output: true
    Explanation: We can split the array into [2, 3, 3, 2] and [3] in the first
                 step. Then, in the second step, we can split [2, 3, 3, 2] into
                 [2, 3, 3] and [2]. Then, in the third step, we can split
                 [2, 3, 3] into [2] and [3, 3]. And in the last step we can
                 split [3, 3] into [3] and [3]. As a result, the answer is true.

    Constraints:
    * 1 <= n == nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= m <= 200"""

    def canSplitArray(self, nums: List[int], m: int) -> bool:
        return len(nums) <= 2 or any(nums[i] + nums[i+1] >= m for i in range(len(nums)-1))


    """2812. Find the Safest Path in a Grid (Medium)
    You are given a 0-indexed 2D matrix grid of size n x n, where (r, c)
    represents:
    * A cell containing a thief if grid[r][c] = 1
    * An empty cell if grid[r][c] = 0
    You are initially positioned at cell (0, 0). In one move, you can move to
    any adjacent cell in the grid, including cells containing thieves. The
    safeness factor of a path on the grid is defined as the minimum manhattan
    distance from any cell in the path to any thief in the grid. Return the
    maximum safeness factor of all paths leading to cell (n - 1, n - 1). An
    adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1),
    (r + 1, c) and (r - 1, c) if it exists. The Manhattan distance between two
    cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes
    the absolute value of val.

    Example 1:
    Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
    Output: 0
    Explanation: All paths from (0, 0) to (n - 1, n - 1) go through the thieves
                 in cells (0, 0) and (n - 1, n - 1).

    Example 2:
    Input: grid = [[0,0,1],[0,0,0],[0,0,0]]
    Output: 2
    Explanation: The path depicted in the picture above has a safeness factor
                 of 2 since:
                 - The closest cell of the path to the thief at cell (0, 2) is
                   cell (0, 0). The distance between them is
                   | 0 - 0 | + | 0 - 2 | = 2.
                 It can be shown that there are no other paths with a higher
                 safeness factor.

    Example 3:
    Input: grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
    Output: 2
    Explanation: The path depicted in the picture above has a safeness factor
                 of 2 since:
                 - The closest cell of the path to the thief at cell (0, 3) is
                   cell (1, 2). The distance between them is
                   | 0 - 1 | + | 3 - 2 | = 2.
                 - The closest cell of the path to the thief at cell (3, 0) is
                   cell (3, 2). The distance between them is
                   | 3 - 3 | + | 0 - 2 | = 2.
                 It can be shown that there are no other paths with a higher
                 safeness factor.

    Constraints:
    * 1 <= grid.length == n <= 400
    * grid[i].length == n
    * grid[i][j] is either 0 or 1.
    * There is at least one thief in the grid."""

    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dist = [[-1]*n for _ in range(n)]
        queue = deque()
        for i in range(n):
            for j in range(n):
                if grid[i][j]:
                    dist[i][j] = 0
                    queue.append((i, j))
        v = 1
        while queue:
            for _ in range(len(queue)):
                i, j = queue.popleft()
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < n and 0 <= jj < n and dist[ii][jj] == -1:
                        dist[ii][jj] = v
                        queue.append((ii, jj))
            v += 1

        def check(mid):
            """Return """
            if dist[0][0] >= mid:
                seen = {(0, 0)}
                stack = [(0, 0)]
                while stack:
                    i, j = stack.pop()
                    if i == j == n-1: return True
                    for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                        if 0 <= ii < n and 0 <= jj < n and (ii, jj) not in seen and dist[ii][jj] >= mid:
                            seen.add((ii, jj))
                            stack.append((ii, jj))
            return False

        lo, hi = 0, n
        while lo < hi:
            mid = lo + hi + 1 >> 1
            if check(mid): lo = mid
            else: hi = mid - 1
        return lo


    """2813. Maximum Elegance of a K-Length Subsequence (Hard)
    You are given a 0-indexed 2D integer array items of length n and an integer
    k. items[i] = [profiti, categoryi], where profiti and categoryi denote the
    profit and category of the ith item respectively. Let's define the elegance
    of a subsequence of items as total_profit + distinct_categories2, where
    total_profit is the sum of all profits in the subsequence, and
    distinct_categories is the number of distinct categories from all the
    categories in the selected subsequence. Your task is to find the maximum
    elegance from all subsequences of size k in items. Return an integer
    denoting the maximum elegance of a subsequence of items with size exactly k.
    Note: A subsequence of an array is a new array generated from the original
    array by deleting some elements (possibly none) without changing the
    remaining elements' relative order.

    Example 1:
    Input: items = [[3,2],[5,1],[10,1]], k = 2
    Output: 17
    Explanation: In this example, we have to select a subsequence of size 2. We
                 can select items[0] = [3,2] and items[2] = [10,1]. The total
                 profit in this subsequence is 3 + 10 = 13, and the subsequence
                 contains 2 distinct categories [2,1]. Hence, the elegance is
                 13 + 22 = 17, and we can show that it is the maximum
                 achievable elegance.

    Example 2:
    Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3
    Output: 19
    Explanation: In this example, we have to select a subsequence of size 3. We
                 can select items[0] = [3,1], items[2] = [2,2], and
                 items[3] = [5,3]. The total profit in this subsequence is
                 3 + 2 + 5 = 10, and the subsequence contains 3 distinct
                 categories [1,2,3]. Hence, the elegance is 10 + 32 = 19, and
                 we can show that it is the maximum achievable elegance.

    Example 3:
    Input: items = [[1,1],[2,1],[3,1]], k = 3
    Output: 7
    Explanation: In this example, we have to select a subsequence of size 3. We
                 should select all the items. The total profit will be
                 1 + 2 + 3 = 6, and the subsequence contains 1 distinct
                 category [1]. Hence, the maximum elegance is 6 + 12 = 7.

    Constraints:
    * 1 <= items.length == n <= 10^5
    * items[i].length == 2
    * items[i][0] == profiti
    * items[i][1] == categoryi
    * 1 <= profiti <= 10^9
    * 1 <= categoryi <= n
    * 1 <= k <= n"""

    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items.sort(reverse=True)
        ans = cand = 0
        seen = set()
        stack = []
        for i, (p, c) in enumerate(items):
            if i <= k-1 or c not in seen and stack:
                cand += p
                if i >= k: cand -= stack.pop()
                if c in seen: stack.append(p)
                seen.add(c)
            ans = max(ans, cand + len(seen)**2)
        return ans


    """2815. Max Pair Sum in an Array (Easy)
    You are given a 0-indexed integer array nums. You have to find the maximum
    sum of a pair of numbers from nums such that the maximum digit in both
    numbers are equal. Return the maximum sum or -1 if no such pair exists.

    Example 1:
    Input: nums = [51,71,17,24,42]
    Output: 88
    Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum
                 digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4,
                 nums[i] and nums[j] have equal maximum digits with a pair sum
                 of 24 + 42 = 66. It can be shown that there are no other pairs
                 with equal maximum digits, so the answer is 88.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: -1
    Explanation: No pair exists in nums with equal maximum digits.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 10^4"""

    def maxSum(self, nums: List[int]) -> int:
        ans = -1
        seen = [0] * 10
        for x in nums:
            d = int(max(str(x)))
            if seen[d]: ans = max(ans, seen[d] + x)
            seen[d] = max(seen[d], x)
        return ans


    """2816. Double a Number Represented as a Linked List (Medium)
    You are given the head of a non-empty linked list representing a non-
    negative integer without leading zeroes. Return the head of the linked list
    after doubling it.

    Example 1:
    Input: head = [1,8,9]
    Output: [3,7,8]
    Explanation: The figure above corresponds to the given linked list which
                 represents the number 189. Hence, the returned linked list
                 represents the number 189 * 2 = 378.

    Example 2:
    Input: head = [9,9,9]
    Output: [1,9,9,8]
    Explanation: The figure above corresponds to the given linked list which
                 represents the number 999. Hence, the returned linked list
                 reprersents the number 999 * 2 = 1998.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^4]
    * 0 <= Node.val <= 9
    * The input is generated such that the list represents a number that does
      not have leading zeros, except the number 0 itself."""

    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head.val >= 5: head = ListNode(0, head)
        node = head
        while node:
            node.val = 2*node.val % 10
            if node.next and node.next.val >= 5: node.val += 1
            node = node.next
        return head


    """2817. Minimum Absolute Difference Between Elements With Constraint (Medium)
    You are given a 0-indexed integer array nums and an integer x. Find the
    minimum absolute difference between two elements in the array that are at
    least x indices apart. In other words, find two indices i and j such that
    abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized. Return an integer
    denoting the minimum absolute difference between two elements that are at
    least x indices apart.

    Example 1:
    Input: nums = [4,3,2,4], x = 2
    Output: 0
    Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2
                 indices apart, and their absolute difference is the minimum, 0.
                 It can be shown that 0 is the optimal answer.

    Example 2:
    Input: nums = [5,3,2,10,15], x = 1
    Output: 1
    Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1
                 index apart, and their absolute difference is the minimum, 1.
                 It can be shown that 1 is the optimal answer.

    Example 3:
    Input: nums = [1,2,3,4], x = 3
    Output: 3
    Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3
                 indices apart, and their absolute difference is the minimum, 3.
                 It can be shown that 3 is the optimal answer.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 0 <= x < nums.length"""

    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        vals = SortedList()
        ans = inf
        for i, v in enumerate(nums):
            if i >= x:
                vals.add(nums[i-x])
                k = vals.bisect_left(v)
                if k: ans = min(ans, v - vals[k-1])
                if k < len(vals): ans = min(ans, vals[k] - v)
        return ans


    """2818. Apply Operations to Maximize Score (Hard)
    You are given an array nums of n positive integers and an integer k.
    Initially, you start with a score of 1. You have to maximize your score by
    applying the following operation at most k times:
    * Choose any non-empty subarray nums[l, ..., r] that you haven't chosen
      previously.
    * Choose an element x of nums[l, ..., r] with the highest prime score. If
      multiple such elements exist, choose the one with the smallest index.
    * Multiply your score by x.
    Here, nums[l, ..., r] denotes the subarray of nums starting at index l and
    ending at the index r, both ends being inclusive. The prime score of an
    integer x is equal to the number of distinct prime factors of x. For
    example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5. Return
    the maximum possible score after applying at most k operations. Since the
    answer may be large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [8,3,9,3,8], k = 2
    Output: 81
    Explanation: To get a score of 81, we can apply the following operations:
                 - Choose subarray nums[2, ..., 2]. nums[2] is the only element
                   in this subarray. Hence, we multiply the score by nums[2].
                   The score becomes 1 * 9 = 9.
                 - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3]
                   have a prime score of 1, but nums[2] has the smaller index.
                   Hence, we multiply the score by nums[2]. The score becomes
                   9 * 9 = 81.
                 It can be proven that 81 is the highest score one can obtain.

    Example 2:
    Input: nums = [19,12,14,6,10,18], k = 3
    Output: 4788
    Explanation: To get a score of 4788, we can apply the following operations:
                 - Choose subarray nums[0, ..., 0]. nums[0] is the only element
                   in this subarray. Hence, we multiply the score by nums[0].
                   The score becomes 1 * 19 = 19.
                 - Choose subarray nums[5, ..., 5]. nums[5] is the only element
                   in this subarray. Hence, we multiply the score by nums[5].
                   The score becomes 19 * 18 = 342.
                 - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3]
                   have a prime score of 2, but nums[2] has the smaller index.
                   Hence, we multipy the score by nums[2]. The score becomes
                   342 * 14 = 4788.
                 It can be proven that 4788 is the highest score one can obtain.

    Constraints:
    * 1 <= nums.length == n <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= min(n * (n + 1) / 2, 10^9)"""

    def maximumScore(self, nums: List[int], k: int) -> int:
        MOD = 1_000_000_007
        score = []
        for x in nums:
            s = 0
            for p in range(2, isqrt(x)+1):
                if x % p == 0: s += 1
                while x % p == 0: x //= p
            if x > 1: s += 1
            score.append(s)
        vals = SortedList([-1, len(nums)])
        freq = defaultdict(int)
        for i, _ in sorted(((i, score[i]) for i in range(len(nums))), key = lambda x: (-x[1], x[0])):
            j = vals.bisect_left(i)
            freq[nums[i]] += (i - vals[j-1]) * (vals[j] - i)
            vals.add(i)
        ans = 1
        prefix = 0
        for x, v in sorted(freq.items(), reverse=True):
            if prefix < k:
                ans = ans * pow(x, min(k - prefix, v), MOD) % MOD
                prefix += v
        return ans


    """2824. Count Pairs Whose Sum is Less than Target (Easy)
    Given a 0-indexed integer array nums of length n and an integer target,
    return the number of pairs (i, j) where 0 <= i < j < n and
    nums[i] + nums[j] < target.

    Example 1:
    Input: nums = [-1,1,2,3,1], target = 2
    Output: 3
    Explanation: There are 3 pairs of indices that satisfy the conditions in the
                 statement:
                 - (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target
                 - (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target
                 - (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target
                 Note that (0, 3) is not counted since nums[0] + nums[3] is not
                 strictly less than the target.

    Example 2:
    Input: nums = [-6,2,5,-2,-7,-1,3], target = -2
    Output: 10
    Explanation: There are 10 pairs of indices that satisfy the conditions in
                 the statement:
                 - (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target
                 - (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target
                 - (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target
                 - (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target
                 - (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target
                 - (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target
                 - (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target
                 - (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target
                 - (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target
                 - (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target

    Constraints:
    * 1 <= nums.length == n <= 50
    * -50 <= nums[i], target <= 50"""

    def countPairs(self, nums: List[int], target: int) -> int:
        nums.sort()
        ans = 0
        lo, hi = 0, len(nums)-1
        while lo < hi:
            if nums[lo] + nums[hi] < target:
                ans += hi - lo
                lo += 1
            else: hi -= 1
        return ans


    """2828. Check if a String Is an Acronym of Words (Easy)
    Given an array of strings words and a string s, determine if s is an acronym
    of words. The string s is considered an acronym of words if it can be formed
    by concatenating the first character of each string in words in order. For
    example, "ab" can be formed from ["apple", "banana"], but it can't be formed
    from ["bear", "aardvark"]. Return true if s is an acronym of words, and
    false otherwise.

    Example 1:
    Input: words = ["alice","bob","charlie"], s = "abc"
    Output: true
    Explanation: The first character in the words "alice", "bob", and "charlie"
                 are 'a', 'b', and 'c', respectively. Hence, s = "abc" is the
                 acronym.

    Example 2:
    Input: words = ["an","apple"], s = "a"
    Output: false
    Explanation: The first character in the words "an" and "apple" are 'a' and
                 'a', respectively. The acronym formed by concatenating these
                 characters is "aa". Hence, s = "a" is not the acronym.

    Example 3:
    Input: words = ["never","gonna","give","up","on","you"], s = "ngguoy"
    Output: true
    Explanation: By concatenating the first character of the words in the array,
                 we get the string "ngguoy". Hence, s = "ngguoy" is the acronym.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 10
    * 1 <= s.length <= 100
    * words[i] and s consist of lowercase English letters."""

    def isAcronym(self, words: List[str], s: str) -> bool:
        return len(words) == len(s) and all(w[0] == ch for w, ch in zip(words, s))


    """2829. Determine the Minimum Sum of a k-avoiding Array (Medium)
    You are given two integers, n and k. An array of distinct positive integers
    is called a k-avoiding array if there does not exist any pair of distinct
    elements that sum to k. Return the minimum possible sum of a k-avoiding
    array of length n.

    Example 1:
    Input: n = 5, k = 4
    Output: 18
    Explanation: Consider the k-avoiding array [1,2,4,5,6], which has a sum of
                 18. It can be proven that there is no k-avoiding array with a
                 sum less than 18.

    Example 2:
    Input: n = 2, k = 6
    Output: 3
    Explanation: We can construct the array [1,2], which has a sum of 3. It can
                 be proven that there is no k-avoiding array with a sum less
                 than 3.

    Constraints: 1 <= n, k <= 50"""

    def minimumSum(self, n: int, k: int) -> int:
        if n <= k//2: return n*(n+1)//2
        return (k//2)**2 - k//2*(n+k-1) + n*(n+2*k-1)//2


    """2830. Maximize the Profit as the Salesman (Medium)
    You are given an integer n representing the number of houses on a number
    line, numbered from 0 to n - 1. Additionally, you are given a 2D integer
    array offers where offers[i] = [starti, endi, goldi], indicating that ith
    buyer wants to buy all the houses from starti to endi for goldi amount of
    gold. As a salesman, your goal is to maximize your earnings by strategically
    selecting and selling houses to buyers. Return the maximum amount of gold
    you can earn. Note that different buyers can't buy the same house, and some
    houses may remain unsold.

    Example 1:
    Input: n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]
    Output: 3
    Explanation: There are 5 houses numbered from 0 to 4 and there are 3
                 purchase offers. We sell houses in the range [0,0] to 1st buyer
                 for 1 gold and houses in the range [1,3] to 3rd buyer for 2
                 golds. It can be proven that 3 is the maximum amount of gold we
                 can achieve.

    Example 2:
    Input: n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]
    Output: 10
    Explanation: There are 5 houses numbered from 0 to 4 and there are 3
                 purchase offers. We sell houses in the range [0,2] to 2nd buyer
                 for 10 golds. It can be proven that 10 is the maximum amount of
                 gold we can achieve.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= offers.length <= 10^5
    * offers[i].length == 3
    * 0 <= starti <= endi <= n - 1
    * 1 <= goldi <= 10^3"""

    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:
        mp = [[] for _ in range(n)]
        for start, end, gold in offers:
            mp[start].append((end, gold))
        dp = [0]*(n+1)
        for i in range(n-1, -1, -1):
            dp[i] = dp[i+1]
            for j, x in mp[i]:
                dp[i] = max(dp[i], x + dp[j+1])
        return dp[0]


    """2831. Find the Longest Equal Subarray (Medium)
    You are given a 0-indexed integer array nums and an integer k. A subarray is
    called equal if all of its elements are equal. Note that the empty subarray
    is an equal subarray. Return the length of the longest possible equal
    subarray after deleting at most k elements from nums. A subarray is a
    contiguous, possibly empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,3,2,3,1,3], k = 3
    Output: 3
    Explanation: It's optimal to delete the elements at index 2 and index 4.
                 After deleting them, nums becomes equal to [1, 3, 3, 3]. The
                 longest equal subarray starts at i = 1 and ends at j = 3 with
                 length equal to 3. It can be proven that no longer equal
                 subarrays can be created.

    Example 2:
    Input: nums = [1,1,2,2,1,1], k = 2
    Output: 4
    Explanation: It's optimal to delete the elements at index 2 and index 3.
                 After deleting them, nums becomes equal to [1, 1, 1, 1]. The
                 array itself is an equal subarray, so the answer is 4. It can
                 be proven that no longer equal subarrays can be created.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= nums.length
    * 0 <= k <= nums.length"""

    def longestEqualSubarray(self, nums: List[int], k: int) -> int:
        most = ii = 0
        freq = Counter()
        for i, x in enumerate(nums):
            freq[x] += 1
            most = max(most, freq[x])
            if i-ii-most >= k:
                freq[nums[ii]] -= 1
                ii += 1
        return most


    """2832. Maximal Range That Each Element Is Maximum in It (Medium)
    You are given a 0-indexed array nums of distinct integers. Let us define a
    0-indexed array ans of the same length as nums in the following way:
    * ans[i] is the maximum length of a subarray nums[l..r], such that the
      maximum element in that subarray is equal to nums[i].
    Return the array ans. Note that a subarray is a contiguous part of the
    array.

    Example 1:
    Input: nums = [1,5,4,3,6]
    Output: [1,4,2,1,5]
    Explanation: - For nums[0] the longest subarray in which 1 is the maximum is
                   nums[0..0] so ans[0] = 1.
                 - For nums[1] the longest subarray in which 5 is the maximum is
                   nums[0..3] so ans[1] = 4.
                 - For nums[2] the longest subarray in which 4 is the maximum is
                   nums[2..3] so ans[2] = 2.
                 - For nums[3] the longest subarray in which 3 is the maximum is
                   nums[3..3] so ans[3] = 1.
                 - For nums[4] the longest subarray in which 6 is the maximum is
                   nums[0..4] so ans[4] = 5.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: [1,2,3,4,5]
    Explanation: For nums[i] the longest subarray in which it's the maximum is
                 nums[0..i] so ans[i] = i + 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * All elements in nums are distinct."""

    def maximumLengthOfRanges(self, nums: List[int]) -> List[int]:
        ans = [0]*len(nums)
        stack = [(-1, inf)]
        for i, x in enumerate(nums + [inf]):
            while stack and stack[-1][1] < x:
                ii = stack.pop()[0]
                ans[ii] = i - stack[-1][0] - 1
            stack.append((i, x))
        return ans


    """2833. Furthest Point From Origin (Easy)
    You are given a string moves of length n consisting only of characters 'L',
    'R', and '_'. The string represents your movement on a number line starting
    from the origin 0. In the ith move, you can choose one of the following
    directions:
    * move to the left if moves[i] = 'L' or moves[i] = '_'
    * move to the right if moves[i] = 'R' or moves[i] = '_'
    Return the distance from the origin of the furthest point you can get to
    after n moves.

    Example 1:
    Input: moves = "L_RL__R"
    Output: 3
    Explanation: The furthest point we can reach from the origin 0 is point -3
                 through the following sequence of moves "LLRLLLR".

    Example 2:
    Input: moves = "_R__LL_"
    Output: 5
    Explanation: The furthest point we can reach from the origin 0 is point -5
                 through the following sequence of moves "LRLLLLL".

    Example 3:
    Input: moves = "_______"
    Output: 7
    Explanation: The furthest point we can reach from the origin 0 is point 7
                 through the following sequence of moves "RRRRRRR".

    Constraints:
    * 1 <= moves.length == n <= 50
    * moves consists only of characters 'L', 'R' and '_'."""

    def furthestDistanceFromOrigin(self, moves: str) -> int:
        L = R = 0
        for ch in moves:
            if ch == 'L': L += 1
            elif ch == 'R': R += 1
        return len(moves) - L - R + abs(L - R)


    """2834. Find the Minimum Possible Sum of a Beautiful Array (Medium)
    You are given positive integers n and target. An array nums is beautiful if
    it meets the following conditions:
    * nums.length == n.
    * nums consists of pairwise distinct positive integers.
    * There doesn't exist two distinct indices, i and j, in the range
      [0, n - 1], such that nums[i] + nums[j] == target.
    Return the minimum possible sum that a beautiful array could have.

    Example 1:
    Input: n = 2, target = 3
    Output: 4
    Explanation: We can see that nums = [1,3] is beautiful.
                 - The array nums has length n = 2.
                 - The array nums consists of pairwise distinct positive integers.
                 - There doesn't exist two distinct indices, i and j, with
                   nums[i] + nums[j] == 3.
                 It can be proven that 4 is the minimum possible sum that a
                 beautiful array could have.

    Example 2:
    Input: n = 3, target = 3
    Output: 8
    Explanation: We can see that nums = [1,3,4] is beautiful.
                 - The array nums has length n = 3.
                 - The array nums consists of pairwise distinct positive integers.
                 - There doesn't exist two distinct indices, i and j, with
                   nums[i] + nums[j] == 3.
                 It can be proven that 8 is the minimum possible sum that a
                 beautiful array could have.

    Example 3:
    Input: n = 1, target = 1
    Output: 1
    Explanation: We can see, that nums = [1] is beautiful.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= target <= 10^5"""

    def minimumPossibleSum(self, n: int, target: int) -> int:
        m = target//2
        return n*(n+1)//2 if n <= m else m*(m+1)//2 + target*(n-m) + (n-m-1)*(n-m)//2


    """2835. Minimum Operations to Form Subsequence With Target Sum (Hard)
    You are given a 0-indexed array nums consisting of non-negative powers of 2,
    and an integer target. In one operation, you must apply the following
    changes to the array:
    * Choose any element of the array nums[i] such that nums[i] > 1.
    * Remove nums[i] from the array.
    * Add two occurrences of nums[i] / 2 to the end of nums.
    Return the minimum number of operations you need to perform so that nums
    contains a subsequence whose elements sum to target. If it is impossible to
    obtain such a subsequence, return -1. A subsequence is an array that can be
    derived from another array by deleting some or no elements without changing
    the order of the remaining elements.

    Example 1:
    Input: nums = [1,2,8], target = 7
    Output: 1
    Explanation: In the first operation, we choose element nums[2]. The array
                 becomes equal to nums = [1,2,4,4]. At this stage, nums
                 contains the subsequence [1,2,4] which sums up to 7. It can be
                 shown that there is no shorter sequence of operations that
                 results in a subsequnce that sums up to 7.

    Example 2:
    Input: nums = [1,32,1,2], target = 12
    Output: 2
    Explanation: In the first operation, we choose element nums[1]. The array
                 becomes equal to nums = [1,1,2,16,16]. In the second operation,
                 we choose element nums[3]. The array becomes equal to
                 nums = [1,1,2,16,8,8]. At this stage, nums contains the
                 subsequence [1,1,2,8] which sums up to 12. It can be shown
                 that there is no shorter sequence of operations that results
                 in a subsequence that sums up to 12.

    Example 3:
    Input: nums = [1,32,1], target = 35
    Output: -1
    Explanation: It can be shown that no sequence of operations results in a
                 subsequence that sums up to 35.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 2^30
    * nums consists only of non-negative powers of two.
    * 1 <= target < 2^31"""

    def minOperations(self, nums: List[int], target: int) -> int:
        ans = cnt = 0
        freq = Counter(nums)
        ii = -1
        for i in range(31):
            cnt //= 2
            cnt += freq[1<<i]
            if target & 1<<i:
                if cnt: cnt -= 1
                elif ii == -1: ii = i
            if cnt and ii >= 0:
                ans += i - ii
                cnt -= 1
                ii = -1
        return ans if ii == -1 else -1


    """2836. Maximize Value of Function in a Ball Passing Game (Hard)
    You are given a 0-indexed integer array receiver of length n and an integer
    k. There are n players having a unique id in the range [0, n - 1] who will
    play a ball passing game, and receiver[i] is the id of the player who
    receives passes from the player with id i. Players can pass to themselves,
    i.e. receiver[i] may be equal to i. You must choose one of the n players as
    the starting player for the game, and the ball will be passed exactly k
    times starting from the chosen player. For a chosen starting player having
    id x, we define a function f(x) that denotes the sum of x and the ids of
    all players who receive the ball during the k passes, including repetitions.
    In other words,
    f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver(k)[x].
    Your task is to choose a starting player having id x that maximizes the
    value of f(x). Return an integer denoting the maximum value of the function.
    Note: receiver may contain duplicates.

    Example 1:
    Pass Number Sender ID   Receiver ID x + Receiver IDs
                2
    1   2   1   3
    2   1   0   3
    3   0   2   5
    4   2   1   6
    Input: receiver = [2,0,1], k = 4
    Output: 6
    Explanation: The table above shows a simulation of the game starting with
                 the player having id x = 2. From the table, f(2) is equal to 6.
                 It can be shown that 6 is the maximum achievable value of the
                 function. Hence, the output is 6.

    Example 2:
    Pass Number Sender ID   Receiver ID x + Receiver IDs
                4
    1   4   3   7
    2   3   2   9
    3   2   1   10
    Input: receiver = [1,1,1,2,3], k = 3
    Output: 10
    Explanation: The table above shows a simulation of the game starting with
                 the player having id x = 4. From the table, f(4) is equal to
                 10. It can be shown that 10 is the maximum achievable value of
                 the function. Hence, the output is 10.

    Constraints:
    * 1 <= receiver.length == n <= 10^5
    * 0 <= receiver[i] <= n - 1
    * 1 <= k <= 10^10"""

    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:
        n, m = len(receiver), int(log2(k))+2
        lift = [[-1]*m for _ in range(n)] # binary lifting
        score = [[0]*m for _ in range(n)]
        for i in range(m):
            for x in range(n):
                if i == 0:
                    lift[x][0] = receiver[x]
                    score[x][0] = x
                elif lift[x][i-1] != -1:
                    lift[x][i] = lift[lift[x][i-1]][i-1]
                    score[x][i] = score[x][i-1] + score[lift[x][i-1]][i-1]
        ans = 0
        for x in range(n):
            cand = 0
            for i in range(m):
                if k+1 & 1<<i:
                    cand += score[x][i]
                    x = lift[x][i]
            ans = max(ans, cand)
        return ans


    """2838. Maximum Coins Heroes Can Collect (Medium)
    There is a battle and n heroes are trying to defeat m monsters. You are
    given two 1-indexed arrays of positive integers heroes and monsters of
    length n and m, respectively. heroes[i] is the power of ith hero, and
    monsters[i] is the power of ith monster. The ith hero can defeat the jth
    monster if monsters[j] <= heroes[i]. You are also given a 1-indexed array
    coins of length m consisting of positive integers. coins[i] is the number of
    coins that each hero earns after defeating the ith monster. Return an array
    ans of length n where ans[i] is the maximum number of coins that the ith
    hero can collect from this battle.

    Notes
    * The health of a hero doesn't get reduced after defeating a monster.
    * Multiple heroes can defeat a monster, but each monster can be defeated by
      a given hero only once.

    Example 1:
    Input: heroes = [1,4,2], monsters = [1,1,5,2,3], coins = [2,3,4,5,6]
    Output: [5,16,10]
    Explanation: For each hero, we list the index of all the monsters he can
                 defeat:
                 - 1st hero: [1,2] since the power of this hero is 1 and
                             monsters[1], monsters[2] <= 1. So this hero
                             collects coins[1] + coins[2] = 5 coins.
                 - 2nd hero: [1,2,4,5] since the power of this hero is 4 and
                             monsters[1], monsters[2], monsters[4], monsters[5]
                             <= 4. So this hero collects
                             coins[1] + coins[2] + coins[4] + coins[5] = 16 coins.
                 - 3rd hero: [1,2,4] since the power of this hero is 2 and
                             monsters[1], monsters[2], monsters[4] <= 2. So this
                             hero collects coins[1] + coins[2] + coins[4] = 10
                             coins.
                 - So the answer would be [5,16,10].

    Example 2:
    Input: heroes = [5], monsters = [2,3,1,2], coins = [10,6,5,2]
    Output: [23]
    Explanation: This hero can defeat all the monsters since monsters[i] <= 5.
                 So he collects all of the coins:
                 coins[1] + coins[2] + coins[3] + coins[4] = 23, and the answer
                 would be [23].

    Example 3:
    Input: heroes = [4,4], monsters = [5,7,8], coins = [1,1,1]
    Output: [0,0]
    Explanation: In this example, no hero can defeat a monster. So the answer
                 would be [0,0],

    Constraints:
    * 1 <= n == heroes.length <= 10^5
    * 1 <= m == monsters.length <= 10^5
    * coins.length == m
    * 1 <= heroes[i], monsters[i], coins[i] <= 10^9"""

    def maximumCoins(self, heroes: List[int], monsters: List[int], coins: List[int]) -> List[int]:
        monsters = sorted((m, c) for m, c in zip(monsters, coins))
        ans = [0]*len(heroes)
        j = prefix = 0
        for x, i in sorted((x, i) for i, x in enumerate(heroes)):
            while j < len(monsters) and monsters[j][0] <= x:
                prefix += monsters[j][1]
                j += 1
            ans[i] = prefix
        return ans


    """2839. Check if Strings Can be Made Equal With Operations I (Easy)
    You are given two strings s1 and s2, both of length 4, consisting of
    lowercase English letters. You can apply the following operation on any of
    the two strings any number of times:
    * Choose any two indices i and j such that j - i = 2, then swap the two
      characters at those indices in the string.
    Return true if you can make the strings s1 and s2 equal, and false
    otherwise.

    Example 1:
    Input: s1 = "abcd", s2 = "cdab"
    Output: true
    Explanation: We can do the following operations on s1:
                 - Choose the indices i = 0, j = 2. The resulting string is
                   s1 = "cbad".
                 - Choose the indices i = 1, j = 3. The resulting string is
                   s1 = "cdab" = s2.

    Example 2:
    Input: s1 = "abcd", s2 = "dacb"
    Output: false
    Explanation: It is not possible to make the two strings equal.

    Constraints:
    * s1.length == s2.length == 4
    * s1 and s2 consist only of lowercase English letters."""

    def canBeEqual(self, s1: str, s2: str) -> bool:
        s1 = list(s1)
        if s1[0] != s2[0]: s1[0], s1[2] = s1[2], s1[0]
        if s1[1] != s2[1]: s1[1], s1[3] = s1[3], s1[1]
        return ''.join(s1) == s2


    """2840. Check if Strings Can be Made Equal With Operations II (Medium)
    You are given two strings s1 and s2, both of length n, consisting of
    lowercase English letters. You can apply the following operation on any of
    the two strings any number of times:
    * Choose any two indices i and j such that i < j and the difference j - i
      is even, then swap the two characters at those indices in the string.
    Return true if you can make the strings s1 and s2 equal, and false
    otherwise.

    Example 1:
    Input: s1 = "abcdba", s2 = "cabdab"
    Output: true
    Explanation: We can apply the following operations on s1:
                 - Choose the indices i = 0, j = 2. The resulting string is
                   s1 = "cbadba".
                 - Choose the indices i = 2, j = 4. The resulting string is
                   s1 = "cbbdaa".
                 - Choose the indices i = 1, j = 5. The resulting string is
                   s1 = "cabdab" = s2.

    Example 2:
    Input: s1 = "abe", s2 = "bea"
    Output: false
    Explanation: It is not possible to make the two strings equal.

    Constraints:
    * n == s1.length == s2.length
    * 1 <= n <= 10^5
    * s1 and s2 consist only of lowercase English letters."""

    def checkStrings(self, s1: str, s2: str) -> bool:
        freq = [0]*52
        for i, (c1, c2) in enumerate(zip(s1, s2)):
            freq[ord(c1)-97 + 26*(i&1)] += 1
            freq[ord(c2)-97 + 26*(i&1)] -= 1
        return all(x == 0 for x in freq)


    """2841. Maximum Sum of Almost Unique Subarray (Medium)
    You are given an integer array nums and two positive integers m and k.
    Return the maximum sum out of all almost unique subarrays of length k of
    nums. If no such subarray exists, return 0. A subarray of nums is almost
    unique if it contains at least m distinct elements. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [2,6,7,3,1,7], m = 3, k = 4
    Output: 18
    Explanation: There are 3 almost unique subarrays of size k = 4. These
                 subarrays are [2, 6, 7, 3], [6, 7, 3, 1], and [7, 3, 1, 7].
                 Among these subarrays, the one with the maximum sum is
                 [2, 6, 7, 3] which has a sum of 18.

    Example 2:
    Input: nums = [5,9,9,2,4,5,4], m = 1, k = 3
    Output: 23
    Explanation: There are 5 almost unique subarrays of size k. These subarrays
                 are [5, 9, 9], [9, 9, 2], [9, 2, 4], [2, 4, 5], and [4, 5, 4].
                 Among these subarrays, the one with the maximum sum is
                 [5, 9, 9] which has a sum of 23.

    Example 3:
    Input: nums = [1,2,1,2,1,2,1], m = 3, k = 3
    Output: 0
    Explanation: There are no subarrays of size k = 3 that contain at least
                 m = 3 distinct elements in the given array [1,2,1,2,1,2,1].
                 Therefore, no almost unique subarrays exist, and the maximum
                 sum is 0.

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= m <= k <= nums.length
    * 1 <= nums[i] <= 10^9"""

    def maxSum(self, nums: List[int], m: int, k: int) -> int:
        ans = prefix = 0
        freq = Counter()
        for i, x in enumerate(nums):
            prefix += x
            freq[x] += 1
            if i >= k:
                prefix -= nums[i-k]
                freq[nums[i-k]] -= 1
                if freq[nums[i-k]] == 0: freq.pop(nums[i-k])
            if i >= k-1 and len(freq) >= m: ans = max(ans, prefix)
        return ans


    """2842. Count K-Subsequences of a String With Maximum Beauty (Hard)
    You are given a string s and an integer k. A k-subsequence is a subsequence
    of s, having length k, and all its characters are unique, i.e., every
    character occurs once. Let f(c) denote the number of times the character c
    occurs in s. The beauty of a k-subsequence is the sum of f(c) for every
    character c in the k-subsequence. For example, consider s = "abbbdd" and
    k = 2:
    * f('a') = 1, f('b') = 3, f('d') = 2
    * Some k-subsequences of s are:
      + "abbbdd" -> "ab" having a beauty of f('a') + f('b') = 4
      + "abbbdd" -> "ad" having a beauty of f('a') + f('d') = 3
      + "abbbdd" -> "bd" having a beauty of f('b') + f('d') = 5
    Return an integer denoting the number of k-subsequences whose beauty is the
    maximum among all k-subsequences. Since the answer may be too large, return
    it modulo 10^9 + 7. A subsequence of a string is a new string formed from
    the original string by deleting some (possibly none) of the characters
    without disturbing the relative positions of the remaining characters.

    Notes
    * f(c) is the number of times a character c occurs in s, not a k-subsequence.
    * Two k-subsequences are considered different if one is formed by an index
      that is not present in the other. So, two k-subsequences may form the
      same string.

    Example 1:
    Input: s = "bcca", k = 2
    Output: 4
    Explanation: From s we have f('a') = 1, f('b') = 1, and f('c') = 2.
                 The k-subsequences of s are:
                 bcca having a beauty of f('b') + f('c') = 3
                 bcca having a beauty of f('b') + f('c') = 3
                 bcca having a beauty of f('b') + f('a') = 2
                 bcca having a beauty of f('c') + f('a') = 3
                 bcca having a beauty of f('c') + f('a') = 3
                 There are 4 k-subsequences that have the maximum beauty, 3.
                 Hence, the answer is 4.

    Example 2:
    Input: s = "abbcd", k = 4
    Output: 2
    Explanation: From s we have f('a') = 1, f('b') = 2, f('c') = 1, and f('d') = 1.
                 The k-subsequences of s are:
                 abbcd having a beauty of f('a') + f('b') + f('c') + f('d') = 5
                 abbcd having a beauty of f('a') + f('b') + f('c') + f('d') = 5
                 There are 2 k-subsequences that have the maximum beauty, 5.
                 Hence, the answer is 2.

    Constraints:
    * 1 <= s.length <= 2 * 10^5
    * 1 <= k <= s.length
    * s consists only of lowercase English letters."""

    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
        MOD = 1_000_000_007
        vals = list(Counter(s).values())
        if len(vals) < k: return 0
        ans = 1
        for x, v in sorted(Counter(vals).items(), reverse=True):
            if v > k: ans = ans * comb(v, k)
            v = min(k, v)
            ans = ans * pow(x, v, MOD) % MOD
            k -= v
        return ans


    """2843. Count Symmetric Integers (Easy)
    You are given two positive integers low and high. An integer x consisting
    of 2 * n digits is symmetric if the sum of the first n digits of x is equal
    to the sum of the last n digits of x. Numbers with an odd number of digits
    are never symmetric. Return the number of symmetric integers in the range
    [low, high].

    Example 1:
    Input: low = 1, high = 100
    Output: 9
    Explanation: There are 9 symmetric integers between 1 and 100: 11, 22, 33,
                 44, 55, 66, 77, 88, and 99.

    Example 2:
    Input: low = 1200, high = 1230
    Output: 4
    Explanation: There are 4 symmetric integers between 1200 and 1230: 1203,
                 1212, 1221, and 1230.

    Constraints: 1 <= low <= high <= 10^4"""

    def countSymmetricIntegers(self, low: int, high: int) -> int:
        ans = 0
        for x in range(low, high+1):
            s = str(x)
            if not len(s) & 1:
                bal = 0
                for i, ch in enumerate(s):
                    if i < len(s)//2: bal += int(ch)
                    else: bal -= int(ch)
                if bal == 0: ans += 1
        return ans


    """2844. Minimum Operations to Make a Special Number (Medium)
    You are given a 0-indexed string num representing a non-negative integer.
    In one operation, you can pick any digit of num and delete it. Note that if
    you delete all the digits of num, num becomes 0. Return the minimum number
    of operations required to make num special. An integer x is considered
    special if it is divisible by 25.

    Example 1:
    Input: num = "2245047"
    Output: 2
    Explanation: Delete digits num[5] and num[6]. The resulting number is
                 "22450" which is special since it is divisible by 25. It can
                 be shown that 2 is the minimum number of operations required
                 to get a special number.

    Example 2:
    Input: num = "2908305"
    Output: 3
    Explanation: Delete digits num[3], num[4], and num[6]. The resulting number
                 is "2900" which is special since it is divisible by 25. It can
                 be shown that 3 is the minimum number of operations required
                 to get a special number.

    Example 3:
    Input: num = "10"
    Output: 1
    Explanation: Delete digit num[0]. The resulting number is "0" which is
                 special since it is divisible by 25. It can be shown that 1 is
                 the minimum number of operations required to get a special
                 number.

    Constraints:
    * 1 <= num.length <= 100
    * num only consists of digits '0' through '9'.
    * num does not contain any leading zeros."""

    def minimumOperations(self, num: str) -> int:
        ans = inf
        for p in "00", "25", "50", "75":
            cand = 0
            i = 1
            for ch in reversed(num):
                if p[i] == ch: i -= 1
                else: cand += 1
                if i == -1: break
            else: continue
            ans = min(ans, cand)
        return ans if ans < inf else len(num) - int('0' in num)


    """2845. Count of Interesting Subarrays (Medium)
    You are given a 0-indexed integer array nums, an integer modulo, and an
    integer k. Your task is to find the count of subarrays that are interesting.
    A subarray nums[l..r] is interesting if the following condition holds:
    * Let cnt be the number of indices i in the range [l, r] such that
      nums[i] % modulo == k. Then, cnt % modulo == k.
    Return an integer denoting the count of interesting subarrays. Note: A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [3,2,4], modulo = 2, k = 1
    Output: 3
    Explanation: In this example the interesting subarrays are:
                 The subarray nums[0..0] which is [3].
                 - There is only one index, i = 0, in the range [0, 0] that
                   satisfies nums[i] % modulo == k.
                 - Hence, cnt = 1 and cnt % modulo == k.
                 The subarray nums[0..1] which is [3,2].
                 - There is only one index, i = 0, in the range [0, 1] that
                   satisfies nums[i] % modulo == k.
                 - Hence, cnt = 1 and cnt % modulo == k.
                 The subarray nums[0..2] which is [3,2,4].
                 - There is only one index, i = 0, in the range [0, 2] that
                   satisfies nums[i] % modulo == k.
                 - Hence, cnt = 1 and cnt % modulo == k.
                 It can be shown that there are no other interesting subarrays.
                 So, the answer is 3.

    Example 2:
    Input: nums = [3,1,9,6], modulo = 3, k = 0
    Output: 2
    Explanation: In this example the interesting subarrays are:
                 The subarray nums[0..3] which is [3,1,9,6].
                 - There are three indices, i = 0, 2, 3, in the range [0, 3]
                   that satisfy nums[i] % modulo == k.
                 - Hence, cnt = 3 and cnt % modulo == k.
                 The subarray nums[1..1] which is [1].
                 - There is no index, i, in the range [1, 1] that satisfies
                   nums[i] % modulo == k.
                 - Hence, cnt = 0 and cnt % modulo == k.
                 It can be shown that there are no other interesting subarrays.
                 So, the answer is 2.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= modulo <= 10^9
    * 0 <= k < modulo"""

    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:
        ans = prefix = 0
        freq = Counter({0 : 1})
        for x in nums:
            if x % modulo == k: prefix += 1
            prefix %= modulo
            ans += freq[(prefix-k) % modulo]
            freq[prefix] += 1
        return ans


    """2846. Minimum Edge Weight Equilibrium Queries in a Tree (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui
    and vi with weight wi in the tree. You are also given a 2D integer array
    queries of length m, where queries[i] = [ai, bi]. For each query, find the
    minimum number of operations required to make the weight of every edge on
    the path from ai to bi equal. In one operation, you can choose any edge of
    the tree and change its weight to any value.

    Note that:
    * Queries are independent of each other, meaning that the tree returns to
      its initial state on each new query.
    * The path from ai to bi is a sequence of distinct nodes starting with node
      ai and ending with node bi such that every two adjacent nodes in the
      sequence share an edge in the tree.
    Return an array answer of length m where answer[i] is the answer to the ith
    query.

    Example 1:
    Input: n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]]
    Output: [0,0,1,3]
    Explanation: In the first query, all the edges in the path from 0 to 3 have
                 a weight of 1. Hence, the answer is 0. In the second query,
                 all the edges in the path from 3 to 6 have a weight of 2.
                 Hence, the answer is 0. In the third query, we change the
                 weight of edge [2,3] to 2. After this operation, all the edges
                 in the path from 2 to 6 have a weight of 2. Hence, the answer
                 is 1. In the fourth query, we change the weights of edges
                 [0,1], [1,2] and [2,3] to 2. After these operations, all the
                 edges in the path from 0 to 6 have a weight of 2. Hence, the
                 answer is 3. For each queries[i], it can be shown that
                 answer[i] is the minimum number of operations needed to
                 equalize all the edge weights in the path from ai to bi.

    Example 2:
    Input: n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]]
    Output: [1,2,2,3]
    Explanation: In the first query, we change the weight of edge [1,3] to 6.
                 After this operation, all the edges in the path from 4 to 6
                 have a weight of 6. Hence, the answer is 1. In the second
                 query, we change the weight of edges [0,3] and [3,1] to 6.
                 After these operations, all the edges in the path from 0 to 4
                 have a weight of 6. Hence, the answer is 2. In the third
                 query, we change the weight of edges [1,3] and [5,2] to 6.
                 After these operations, all the edges in the path from 6 to 5
                 have a weight of 6. Hence, the answer is 2. In the fourth
                 query, we change the weights of edges [0,7], [0,3] and [1,3]
                 to 6. After these operations, all the edges in the path from 7
                 to 4 have a weight of 6. Hence, the answer is 3. For each
                 queries[i], it can be shown that answer[i] is the minimum
                 number of operations needed to equalize all the edge weights
                 in the path from ai to bi.

    Constraints:
    * 1 <= n <= 10^4
    * edges.length == n - 1
    * edges[i].length == 3
    * 0 <= ui, vi < n
    * 1 <= wi <= 26
    * The input is generated such that edges represents a valid tree.
    * 1 <= queries.length == m <= 2 * 10^4
    * queries[i].length == 2
    * 0 <= ai, bi < n"""

    def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:
        tree = [[] for _ in range(n)]
        for u, v, w in edges:
            tree[u].append((v, w))
            tree[v].append((u, w))
        m = int(log2(n)) + 1
        lift = [[-1]*m for _ in range(n)] # binary lifting
        freq = [[0]*27 for _ in range(n)]
        depth = [-1]*n
        stack = [(0, -1, 0)]
        while stack:
            u, p, d = stack.pop()
            depth[u] = d
            for v, w in tree[u]:
                if v != p:
                    lift[v][0] = u
                    freq[v][:] = freq[u][:]
                    freq[v][w] += 1
                    for j in range(1, m):
                        if lift[v][j-1] == -1: break
                        lift[v][j] = lift[lift[v][j-1]][j-1]
                    stack.append((v, u, d+1))
        ans = []
        for u, v in queries:
            uu, vv = u, v
            if depth[u] > depth[v]: u, v = v, u
            for i in range(m):
                if depth[v]-depth[u] & 1<<i: v = lift[v][i]
            if u == v: k = u
            else:
                for i in range(m-1, -1, -1):
                    if lift[u][i] != lift[v][i]: u, v = lift[u][i], lift[v][i]
                k = lift[u][0]
            count = [freq[uu][w] + freq[vv][w] - 2*freq[k][w] for w in range(27)]
            ans.append(sum(count) - max(count))
        return ans


    """2847. Smallest Number With Given Digit Product (Medium)
    Given a positive integer n, return a string representing the smallest
    positive integer such that the product of its digits is equal to n, or "-1"
    if no such number exists.

    Example 1:
    Input: n = 105
    Output: "357"
    Explanation: 3 * 5 * 7 = 105. It can be shown that 357 is the smallest
                 number with a product of digits equal to 105. So the answer
                 would be "105".

    Example 2:
    Input: n = 7
    Output: "7"
    Explanation: Since 7 has only one digit, its product of digits would be 7.
                 We will show that 7 is the smallest number with a product of
                 digits equal to 7. Since the product of numbers 1 to 6 is 1 to
                 6 respectively, so "7" would be the answer.

    Example 3:
    Input: n = 44
    Output: "-1"
    Explanation: It can be shown that there is no number such that its product
                 of digits is equal to 44. So the answer would be "-1".

    Constraints: 1 <= n <= 10^18"""

    def smallestNumber(self, n: int) -> str:
        if n == 1: return "1"
        ans = []
        for d in range(9, 1, -1):
            while n and n % d == 0:
                ans.append(d)
                n //= d
        if n > 1: return "-1"
        return ''.join(map(str, reversed(ans)))


    """2852. Sum of Remoteness of All Cells (Medium)
    You are given a 0-indexed matrix grid of order n * n. Each cell in this
    matrix has a value grid[i][j], which is either a positive integer or -1
    representing a blocked cell. You can move from a non-blocked cell to any
    non-blocked cell that shares an edge. For any cell (i, j), we represent its
    remoteness as R[i][j] which is defined as the following:
    * If the cell (i, j) is a non-blocked cell, R[i][j] is the sum of the values
      grid[x][y] such that there is no path from the non-blocked cell (x, y) to
      the cell (i, j).
    * For blocked cells, R[i][j] == 0.
    Return the sum of R[i][j] over all cells.

    Example 1:
    Input: grid = [[-1,1,-1],[5,-1,4],[-1,3,-1]]
    Output: 39
    Explanation: In the picture above, there are four grids. The top-left grid
                 contains the initial values in the grid. Blocked cells are
                 colored black, and other cells get their values as it is in the
                 input. In the top-right grid, you can see the value of R[i][j]
                 for all cells. So the answer would be the sum of them. That is:
                 0 + 12 + 0 + 8 + 0 + 9 + 0 + 10 + 0 = 39. Let's jump on the
                 bottom-left grid in the above picture and calculate R[0][1]
                 (the target cell is colored green). We should sum up the value
                 of cells that can't be reached by the cell (0, 1). These cells
                 are colored yellow in this grid. So R[0][1] = 5 + 4 + 3 = 12.
                 Now let's jump on the bottom-right grid in the above picture
                 and calculate R[1][2] (the target cell is colored green). We
                 should sum up the value of cells that can't be reached by the
                 cell (1, 2). These cells are colored yellow in this grid. So
                 R[1][2] = 1 + 5 + 3 = 9.

    Example 2:
    Input: grid = [[-1,3,4],[-1,-1,-1],[3,-1,-1]]
    Output: 13
    Explanation: In the picture above, there are four grids. The top-left grid
                 contains the initial values in the grid. Blocked cells are
                 colored black, and other cells get their values as it is in the
                 input. In the top-right grid, you can see the value of R[i][j]
                 for all cells. So the answer would be the sum of them. That is:
                 3 + 3 + 0 + 0 + 0 + 0 + 7 + 0 + 0 = 13. Let's jump on the
                 bottom-left grid in the above picture and calculate R[0][2]
                 (the target cell is colored green). We should sum up the value
                 of cells that can't be reached by the cell (0, 2). This cell is
                 colored yellow in this grid. So R[0][2] = 3. Now let's jump on
                 the bottom-right grid in the above picture and calculate
                 R[2][0] (the target cell is colored green). We should sum up
                 the value of cells that can't be reached by the cell (2, 0).
                 These cells are colored yellow in this grid. So
                 R[2][0] = 3 + 4 = 7.

    Example 3:
    Input: grid = [[1]]
    Output: 0
    Explanation: Since there are no other cells than (0, 0), R[0][0] is equal to
                 0. So the sum of R[i][j] over all cells would be 0.

    Constraints:
    * 1 <= n <= 300
    * 1 <= grid[i][j] <= 10^6 or grid[i][j] == -1"""

    def sumRemoteness(self, grid: List[List[int]]) -> int:
        n = len(grid)
        ans = value = count = 0
        for r in range(n):
            for c in range(n):
                if grid[r][c] != -1:
                    val, cnt = grid[r][c], 1
                    grid[r][c] = -1
                    stack = [(r, c)]
                    while stack:
                        i, j = stack.pop()
                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] != -1:
                                val += grid[ii][jj]
                                cnt += 1
                                grid[ii][jj] = -1
                                stack.append((ii, jj))
                    ans -= val*cnt
                    value += val
                    count += cnt
        return ans + value*count


    """2855. Minimum Right Shifts to Sort the Array (Easy)
    You are given a 0-indexed array nums of length n containing distinct
    positive integers. Return the minimum number of right shifts required to
    sort nums and -1 if this is not possible. A right shift is defined as
    shifting the element at index i to index (i + 1) % n, for all indices.

    Example 1:
    Input: nums = [3,4,5,1,2]
    Output: 2
    Explanation: After the first right shift, nums = [2,3,4,5,1]. After the
                 second right shift, nums = [1,2,3,4,5]. Now nums is sorted;
                 therefore the answer is 2.

    Example 2:
    Input: nums = [1,3,5]
    Output: 0
    Explanation: nums is already sorted therefore, the answer is 0.

    Example 3:
    Input: nums = [2,1,4]
    Output: -1
    Explanation: It's impossible to sort the array using right shifts.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * nums contains distinct integers."""

    def minimumRightShifts(self, nums: List[int]) -> int:
        c = k = 0
        n = len(nums)
        for i in range(len(nums)):
            if nums[i] > nums[(i+1)%n]:
                c += 1
                k = i
        if c == 0: return 0
        if c == 1: return len(nums)-1-k
        return -1


    """2856. Minimum Array Length After Pair Removals (Medium)
    Given an integer array num sorted in non-decreasing order. You can perform
    the following operation any number of times:
    * Choose two indices, i and j, where nums[i] < nums[j].
    * Then, remove the elements at indices i and j from nums. The remaining
      elements retain their original order, and the array is re-indexed.
    Return the minimum length of nums after applying the operation zero or more
    times.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation:

    Example 2:
    Input: nums = [1,1,2,2,3,3]
    Output: 0
    Explanation:

    Example 3:
    Input: nums = [1000000000,1000000000]
    Output: 2
    Explanation: Since both numbers are equal, they cannot be removed.

    Example 4:
    Input: nums = [2,3,4,4,4]
    Output: 1
    Explanation:

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * nums is sorted in non-decreasing order."""

    def minLengthAfterRemovals(self, nums: List[int]) -> int:
        most = max(Counter(nums).values())
        if 2*most >= len(nums): return 2*most - len(nums)
        return len(nums) & 1


    """2857. Count Pairs of Points With Distance k (Medium)
    You are given a 2D integer array coordinates and an integer k, where
    coordinates[i] = [xi, yi] are the coordinates of the ith point in a 2D
    plane. We define the distance between two points (x1, y1) and (x2, y2) as
    (x1 XOR x2) + (y1 XOR y2) where XOR is the bitwise XOR operation. Return the
    number of pairs (i, j) such that i < j and the distance between points i and
    j is equal to k.

    Example 1:
    Input: coordinates = [[1,2],[4,2],[1,3],[5,2]], k = 5
    Output: 2
    Explanation: We can choose the following pairs:
                 - (0,1): Because we have (1 XOR 4) + (2 XOR 2) = 5.
                 - (2,3): Because we have (1 XOR 5) + (3 XOR 2) = 5.

    Example 2:
    Input: coordinates = [[1,3],[1,3],[1,3],[1,3],[1,3]], k = 0
    Output: 10
    Explanation: Any two chosen pairs will have a distance of 0. There are 10
                 ways to choose two pairs.

    Constraints:
    * 2 <= coordinates.length <= 50000
    * 0 <= xi, yi <= 10^6
    * 0 <= k <= 100"""

    def countPairs(self, coordinates: List[List[int]], k: int) -> int:
        ans = 0
        freq = Counter()
        for x, y in coordinates:
            for v in range(k+1):
                ans += freq[x^v, y^(k-v)]
            freq[x, y] += 1
        return ans


    """2858. Minimum Edge Reversals So Every Node Is Reachable (Hard)
    There is a simple directed graph with n nodes labeled from 0 to n - 1. The
    graph would form a tree if its edges were bi-directional. You are given an
    integer n and a 2D integer array edges, where edges[i] = [ui, vi] represents
    a directed edge going from node ui to node vi. An edge reversal changes the
    direction of an edge, i.e., a directed edge going from node ui to node vi
    becomes a directed edge going from node vi to node ui. For every node i in
    the range [0, n - 1], your task is to independently calculate the minimum
    number of edge reversals required so it is possible to reach any other node
    starting from node i through a sequence of directed edges. Return an integer
    array answer, where answer[i] is the minimum number of edge reversals
    required so it is possible to reach any other node starting from node i
    through a sequence of directed edges.

    Example 1:
    Input: n = 4, edges = [[2,0],[2,1],[1,3]]
    Output: [1,1,0,2]
    Explanation: The image above shows the graph formed by the edges.
                 - For node 0: after reversing the edge [2,0], it is possible to
                   reach any other node starting from node 0. So, answer[0] = 1.
                 - For node 1: after reversing the edge [2,1], it is possible to
                   reach any other node starting from node 1. So, answer[1] = 1.
                 - For node 2: it is already possible to reach any other node
                   starting from node 2. So, answer[2] = 0.
                 - For node 3: after reversing the edges [1,3] and [2,1], it is
                   possible to reach any other node starting from node 3. So,
                   answer[3] = 2.

    Example 2:
    Input: n = 3, edges = [[1,2],[2,0]]
    Output: [2,0,1]
    Explanation: The image above shows the graph formed by the edges.
                 - For node 0: after reversing the edges [2,0] and [1,2], it is
                   possible to reach any other node starting from node 0. So,
                   answer[0] = 2.
                 - For node 1: it is already possible to reach any other node
                   starting from node 1. So, answer[1] = 0.
                 - For node 2: after reversing the edge [1, 2], it is possible
                   to reach any other node starting from node 2. So,
                   answer[2] = 1.

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ui == edges[i][0] < n
    * 0 <= vi == edges[i][1] < n
    * ui != vi
    * The input is generated such that if the edges were bi-directional, the
      graph would be a tree."""

    def minEdgeReversals(self, n: int, edges: List[List[int]]) -> List[int]:
        tree = [{} for _ in range(n)]
        for u, v in edges:
            tree[u][v] = 1
            tree[v][u] = -1
        ans = [0]*n

        def fn(u, p):
            """Return """
            for v, x in tree[u].items():
                if v != p:
                    ans[u] += fn(v, u)
                    if x == -1: ans[u] += 1
            return ans[u]

        fn(0, -1)
        stack = [(0, -1)]
        while stack:
            u, p = stack.pop()
            for v in tree[u]:
                if v != p:
                    ans[v] += ans[u] - ans[v] + tree[u][v]
                    stack.append((v, u))
        return ans


    """2859. Sum of Values at Indices With K Set Bits (Easy)
    You are given a 0-indexed integer array nums and an integer k. Return an
    integer that denotes the sum of elements in nums whose corresponding
    indices have exactly k set bits in their binary representation. The set
    bits in an integer are the 1's present when it is written in binary. For
    example, the binary representation of 21 is 10101, which has 3 set bits.

    Example 1:
    Input: nums = [5,10,1,5,2], k = 1
    Output: 13
    Explanation: The binary representation of the indices are:
                 0 = 0002
                 1 = 0012
                 2 = 0102
                 3 = 0112
                 4 = 1002
                 Indices 1, 2, and 4 have k = 1 set bits in their binary
                 representation. Hence, the answer is
                 nums[1] + nums[2] + nums[4] = 13.

    Example 2:
    Input: nums = [4,3,2,1], k = 2
    Output: 1
    Explanation: The binary representation of the indices are:
                 0 = 002
                 1 = 012
                 2 = 102
                 3 = 112
                 Only index 3 has k = 2 set bits in its binary representation.
                 Hence, the answer is nums[3] = 1.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5
    * 0 <= k <= 10"""

    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:
        return sum(x for i, x in enumerate(nums) if i.bit_count() == k)


    """2860. Happy Students (Medium)
    You are given a 0-indexed integer array nums of length n where n is the
    total number of students in the class. The class teacher tries to select a
    group of students so that all the students remain happy. The ith student
    will become happy if one of these two conditions is met:
    * The student is selected and the total number of selected students is
      strictly greater than nums[i].
    * The student is not selected and the total number of selected students is
      strictly less than nums[i].
    Return the number of ways to select a group of students so that everyone
    remains happy.

    Example 1:
    Input: nums = [1,1]
    Output: 2
    Explanation: The two possible ways are:
                 1. The class teacher selects no student.
                 2. The class teacher selects both students to form the group.
                 If the class teacher selects just one student to form a group
                 then the both students will not be happy. Therefore, there are
                 only two possible ways.

    Example 2:
    Input: nums = [6,0,3,3,6,7,2,7]
    Output: 3
    Explanation: The three possible ways are:
                 1. The class teacher selects the student with index = 1 to
                    form the group.
                 2. The class teacher selects the students with
                    index = 1, 2, 3, 6 to form the group.
                 The class teacher selects all the students to form the group.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] < nums.length"""

    def countWays(self, nums: List[int]) -> int:
        ans = 0
        nums.sort()
        for i, x in enumerate(nums):
            if i == 0 and x: ans += 1
            if x < i+1 and (i+1 == len(nums) or i+1 < nums[i+1]): ans += 1
        return ans


    """2861. Maximum Number of Alloys (Medium)
    You are the owner of a company that creates alloys using various types of
    metals. There are n different types of metals available, and you have
    access to k machines that can be used to create alloys. Each machine
    requires a specific amount of each metal type to create an alloy. For the
    ith machine to create an alloy, it needs composition[i][j] units of metal
    of type j. Initially, you have stock[i] units of metal type i, and
    purchasing one unit of metal type i costs cost[i] coins. Given integers
    n, k, budget, a 1-indexed 2D array composition, and 1-indexed arrays stock
    and cost, your goal is to maximize the number of alloys the company can
    create while staying within the budget of budget coins. All alloys must be
    created with the same machine. Return the maximum number of alloys that the
    company can create.

    Example 1:
    Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]
    Output: 2
    Explanation: It is optimal to use the 1st machine to create alloys.
                 To create 2 alloys we need to buy the:
                 - 2 units of metal of the 1st type.
                 - 2 units of metal of the 2nd type.
                 - 2 units of metal of the 3rd type.
                 In total, we need 2 * 1 + 2 * 2 + 2 * 3 = 12 coins, which is
                 smaller than or equal to budget = 15. Notice that we have 0
                 units of metal of each type and we have to buy all the
                 required units of metal. It can be proven that we can create
                 at most 2 alloys.

    Example 2:
    Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,100], cost = [1,2,3]
    Output: 5
    Explanation: It is optimal to use the 2nd machine to create alloys.
                 To create 5 alloys we need to buy:
                 - 5 units of metal of the 1st type.
                 - 5 units of metal of the 2nd type.
                 - 0 units of metal of the 3rd type.
                 In total, we need 5 * 1 + 5 * 2 + 0 * 3 = 15 coins, which is
                 smaller than or equal to budget = 15. It can be proven that we
                 can create at most 5 alloys.

    Example 3:
    Input: n = 2, k = 3, budget = 10, composition = [[2,1],[1,2],[1,1]], stock = [1,1], cost = [5,5]
    Output: 2
    Explanation: It is optimal to use the 3rd machine to create alloys.
                 To create 2 alloys we need to buy the:
                 - 1 unit of metal of the 1st type.
                 - 1 unit of metal of the 2nd type.
                 In total, we need 1 * 5 + 1 * 5 = 10 coins, which is smaller
                 than or equal to budget = 10. It can be proven that we can
                 create at most 2 alloys.

    Constraints:
    * 1 <= n, k <= 100
    * 0 <= budget <= 10^8
    * composition.length == k
    * composition[i].length == n
    * 1 <= composition[i][j] <= 100
    * stock.length == cost.length == n
    * 0 <= stock[i] <= 10^8
    * 1 <= cost[i] <= 100"""

    def maxNumberOfAlloys(self, n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:
        ans = 0
        for comp in composition:
            lo, hi = 0, int(2e8)
            while lo < hi :
                mid = lo + hi + 1 >> 1
                spend = sum(ct*max(0, mid*cp-sk) for cp, sk, ct in zip(comp, stock, cost))
                if spend <= budget: lo = mid
                else: hi = mid - 1
            ans = max(ans, lo)
        return ans


    """2862. Maximum Element-Sum of a Complete Subset of Indices (Hard)
    You are given a 1-indexed array nums of n integers. A set of numbers is
    complete if the product of every pair of its elements is a perfect square.
    For a subset of the indices set {1, 2, ..., n} represented as
    {i1, i2, ..., ik}, we define its element-sum as:
    nums[i1] + nums[i2] + ... + nums[ik]. Return the maximum element-sum of a
    complete subset of the indices set {1, 2, ..., n}. A perfect square is a
    number that can be expressed as the product of an integer by itself.

    Example 1:
    Input: nums = [8,7,3,5,7,2,4,9]
    Output: 16
    Explanation: Apart from the subsets consisting of a single index, there are
                 two other complete subsets of indices: {1,4} and {2,8}.
                 - The sum of the elements corresponding to indices 1 and 4 is
                   equal to nums[1] + nums[4] = 8 + 5 = 13.
                 - The sum of the elements corresponding to indices 2 and 8 is
                   equal to nums[2] + nums[8] = 7 + 9 = 16.
                 Hence, the maximum element-sum of a complete subset of indices
                 is 16.

    Example 2:
    Input: nums = [5,10,3,10,1,13,7,9,4]
    Output: 19
    Explanation: Apart from the subsets consisting of a single index, there are
                 four other complete subsets of indices:
                 {1,4}, {1,9}, {2,8}, {4,9}, and {1,4,9}.
                 - The sum of the elements corresponding to indices 1 and 4 is
                   equal to nums[1] + nums[4] = 5 + 10 = 15.
                 - The sum of the elements corresponding to indices 1 and 9 is
                   equal to nums[1] + nums[9] = 5 + 4 = 9.
                 - The sum of the elements corresponding to indices 2 and 8 is
                   equal to nums[2] + nums[8] = 10 + 9 = 19.
                 - The sum of the elements corresponding to indices 4 and 9 is
                   equal to nums[4] + nums[9] = 10 + 4 = 14.
                 - The sum of the elements corresponding to indices 1, 4, and 9
                   is equal to nums[1] + nums[4] + nums[9] = 5 + 10 + 4 = 19.
                 Hence, the maximum element-sum of a complete subset of indices
                 is 19.

    Constraints:
    * 1 <= n == nums.length <= 10^4
    * 1 <= nums[i] <= 10^9"""

    def maximumSum(self, nums: List[int]) -> int:
        mp = defaultdict(int)
        for i, x in enumerate(nums):
            i += 1
            for v in range(2, isqrt(i)+1):
                while i % (v*v) == 0: i //= v*v
            mp[i] += x
        return max(mp.values())


    """2863. Maximum Length of Semi-Decreasing Subarrays (Medium)
    You are given an integer array nums. Return the length of the longest semi-
    decreasing subarray of nums, and 0 if there are no such subarrays. A
    subarray is a contiguous non-empty sequence of elements within an array. A
    non-empty array is semi-decreasing if its first element is strictly greater
    than its last element.

    Example 1:
    Input: nums = [7,6,5,4,3,2,1,6,10,11]
    Output: 8
    Explanation: Take the subarray [7,6,5,4,3,2,1,6]. The first element is 7 and
                 the last one is 6 so the condition is met. Hence, the answer
                 would be the length of the subarray or 8. It can be shown that
                 there aren't any subarrays with the given condition with a
                 length greater than 8.

    Example 2:
    Input: nums = [57,55,50,60,61,58,63,59,64,60,63]
    Output: 6
    Explanation: Take the subarray [61,58,63,59,64,60]. The first element is 61
                 and the last one is 60 so the condition is met. Hence, the
                 answer would be the length of the subarray or 6. It can be
                 shown that there aren't any subarrays with the given condition
                 with a length greater than 6.

    Example 3:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: Since there are no semi-decreasing subarrays in the given
                 array, the answer is 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9"""

    def maxSubarrayLength(self, nums: List[int]) -> int:
        stack = []
        for i, x in enumerate(nums):
            if not stack or stack[-1][1] < x:
                stack.append((i, x))
        ans = 0
        for i in range(len(nums)-1, -1, -1):
            while stack and stack[-1][1] > nums[i]:
                ii, _ = stack.pop()
                ans = max(ans, i-ii+1)
        return ans


    """2864. Maximum Odd Binary Number (Easy)
    You are given a binary string s that contains at least one '1'. You have to
    rearrange the bits in such a way that the resulting binary number is the
    maximum odd binary number that can be created from this combination. Return
    a string representing the maximum odd binary number that can be created
    from the given combination. Note that the resulting string can have leading
    zeros.

    Example 1:
    Input: s = "010"
    Output: "001"
    Explanation: Because there is just one '1', it must be in the last position.
                 So the answer is "001".

    Example 2:
    Input: s = "0101"
    Output: "1001"
    Explanation: One of the '1's must be in the last position. The maximum
                 number that can be made with the remaining digits is "100". So
                 the answer is "1001".

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of '0' and '1'.
    * s contains at least one '1'."""

    def maximumOddBinaryNumber(self, s: str) -> str:
        ones = s.count('1')
        return '1'*(ones-1) + '0'*(len(s)-ones) + '1'


    """2865. Beautiful Towers I (Medium)
    You are given a 0-indexed array maxHeights of n integers. You are tasked
    with building n towers in the coordinate line. The ith tower is built at
    coordinate i and has a height of heights[i]. A configuration of towers is
    beautiful if the following conditions hold:
    * 1 <= heights[i] <= maxHeights[i]
    * heights is a mountain array.
    Array heights is a mountain if there exists an index i such that:
    * For all 0 < j <= i, heights[j - 1] <= heights[j]
    * For all i <= k < n - 1, heights[k + 1] <= heights[k]
    Return the maximum possible sum of heights of a beautiful configuration of
    towers.

    Example 1:
    Input: maxHeights = [5,3,4,1,1]
    Output: 13
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [5,3,3,1,1]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 0.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 13.

    Example 2:
    Input: maxHeights = [6,5,3,9,2,7]
    Output: 22
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [3,3,3,9,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 3.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 22.

    Example 3:
    Input: maxHeights = [3,2,5,5,2,3]
    Output: 18
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [2,2,5,5,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 2.
                 Note that, for this configuration, i = 3 can also be
                 considered a peak. It can be shown that there exists no other
                 beautiful configuration with a sum of heights greater than 18.

    Constraints:
    * 1 <= n == maxHeights <= 10^3
    * 1 <= maxHeights[i] <= 10^9"""

    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:
        prefix = []
        stack = [-1]
        val = 0
        for i, x in enumerate(maxHeights):
            while len(stack) > 1 and maxHeights[stack[-1]] >= x:
                ii = stack.pop()
                val -= (ii - stack[-1])*maxHeights[ii]
            val += (i - stack[-1])*x
            prefix.append(val)
            stack.append(i)
        ans = val = 0
        stack = [len(maxHeights)]
        for i, x in reversed(list(enumerate(maxHeights))):
            while len(stack) > 1 and maxHeights[stack[-1]] >= x:
                ii = stack.pop()
                val -= (stack[-1] - ii)*maxHeights[ii]
            val += (stack[-1] - i) * x
            stack.append(i)
            ans = max(ans, prefix[i] + val - maxHeights[i])
        return ans


    """2866. Beautiful Towers II (Medium)
    You are given a 0-indexed array maxHeights of n integers. You are tasked
    with building n towers in the coordinate line. The ith tower is built at
    coordinate i and has a height of heights[i]. A configuration of towers is
    beautiful if the following conditions hold:
    * 1 <= heights[i] <= maxHeights[i]
    * heights is a mountain array.
    Array heights is a mountain if there exists an index i such that:
    * For all 0 < j <= i, heights[j - 1] <= heights[j]
    * For all i <= k < n - 1, heights[k + 1] <= heights[k]
    Return the maximum possible sum of heights of a beautiful configuration of
    towers.

    Example 1:
    Input: maxHeights = [5,3,4,1,1]
    Output: 13
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [5,3,3,1,1]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 0.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 13.

    Example 2:
    Input: maxHeights = [6,5,3,9,2,7]
    Output: 22
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [3,3,3,9,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 3.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 22.

    Example 3:
    Input: maxHeights = [3,2,5,5,2,3]
    Output: 18
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [2,2,5,5,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 2.
                 Note that, for this configuration, i = 3 can also be
                 considered a peak. It can be shown that there exists no other
                 beautiful configuration with a sum of heights greater than 18.

    Constraints:
    * 1 <= n == maxHeights <= 10^5
    * 1 <= maxHeights[i] <= 10^9"""

    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:
        prefix = []
        stack = [-1]
        val = 0
        for i, x in enumerate(maxHeights):
            while len(stack) > 1 and maxHeights[stack[-1]] >= x:
                ii = stack.pop()
                val -= (ii - stack[-1])*maxHeights[ii]
            val += (i - stack[-1])*x
            prefix.append(val)
            stack.append(i)
        ans = val = 0
        stack = [len(maxHeights)]
        for i, x in reversed(list(enumerate(maxHeights))):
            while len(stack) > 1 and maxHeights[stack[-1]] >= x:
                ii = stack.pop()
                val -= (stack[-1] - ii)*maxHeights[ii]
            val += (stack[-1] - i) * x
            stack.append(i)
            ans = max(ans, prefix[i] + val - maxHeights[i])
        return ans


    """2867. Count Valid Paths in a Tree (Hard)
    There is an undirected tree with n nodes labeled from 1 to n. You are given
    the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi
    in the tree. Return the number of valid paths in the tree. A path (a, b) is
    valid if there exists exactly one prime number among the node labels in the
    path from a to b.

    Note that:
    * The path (a, b) is a sequence of distinct nodes starting with node a and
      ending with node b such that every two adjacent nodes in the sequence
      share an edge in the tree.
    * Path (a, b) and path (b, a) are considered the same and counted only once.

    Example 1:
    Input: n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]
    Output: 4
    Explanation: The pairs with exactly one prime number on the path between
                 them are:
                 - (1, 2) since the path from 1 to 2 contains prime number 2.
                 - (1, 3) since the path from 1 to 3 contains prime number 3.
                 - (1, 4) since the path from 1 to 4 contains prime number 2.
                 - (2, 4) since the path from 2 to 4 contains prime number 2.
                 It can be shown that there are only 4 valid paths.

    Example 2:
    Input: n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]
    Output: 6
    Explanation: The pairs with exactly one prime number on the path between
                 them are:
                 - (1, 2) since the path from 1 to 2 contains prime number 2.
                 - (1, 3) since the path from 1 to 3 contains prime number 3.
                 - (1, 4) since the path from 1 to 4 contains prime number 2.
                 - (1, 6) since the path from 1 to 6 contains prime number 3.
                 - (2, 4) since the path from 2 to 4 contains prime number 2.
                 - (3, 6) since the path from 3 to 6 contains prime number 3.
                 It can be shown that there are only 6 valid paths.

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 1 <= ui, vi <= n
    * The input is generated such that edges represent a valid tree."""

    def countPaths(self, n: int, edges: List[List[int]]) -> int:
        prime = [True]*(n+1)
        prime[0] = prime[1] = False
        for x in range(2, isqrt(n)+1):
            if prime[x]:
                for xx in range(x*x, n+1, x):
                    prime[xx] = False
        tree = [[] for _ in range(n+1)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        mp = list(range(n+1))
        for x in range(1, n+1):
            if not prime[x] and mp[x] == x:
                stack = [(x, -1)]
                while stack:
                    u, p = stack.pop()
                    for v in tree[u]:
                        if v != p and not prime[v]:
                            mp[v] = x
                            stack.append((v, u))
        freq = Counter(mp)
        ans = 0
        for u in range(2, n+1):
            if prime[u]:
                cand = 0
                prefix = 1
                for v in tree[u]:
                    if not prime[v]:
                        cand += prefix * freq[mp[v]]
                        prefix += freq[mp[v]]
                ans += cand
        return ans


    """2869. Minimum Operations to Collect Elements (Easy)
    You are given an array nums of positive integers and an integer k. In one
    operation, you can remove the last element of the array and add it to your
    collection. Return the minimum number of operations needed to collect
    elements 1, 2, ..., k.

    Example 1:
    Input: nums = [3,1,5,4,2], k = 2
    Output: 4
    Explanation: After 4 operations, we collect elements 2, 4, 5, and 1, in
                 this order. Our collection contains elements 1 and 2. Hence,
                 the answer is 4.

    Example 2:
    Input: nums = [3,1,5,4,2], k = 5
    Output: 5
    Explanation: After 5 operations, we collect elements 2, 4, 5, 1, and 3, in
                 this order. Our collection contains elements 1 through 5.
                 Hence, the answer is 5.

    Example 3:
    Input: nums = [3,2,5,3,1], k = 3
    Output: 4
    Explanation: After 4 operations, we collect elements 1, 3, 5, and 2, in
                 this order. Our collection contains elements 1 through 3.
                 Hence, the answer is 4.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= nums.length
    * 1 <= k <= nums.length
    * The input is generated such that you can collect elements 1, 2, ..., k."""

    def minOperations(self, nums: List[int], k: int) -> int:
        left = (1<<k)-1
        for i, x in enumerate(reversed(nums)):
            if x <= k and left & 1<<x-1: left ^= 1<<x-1
            if left == 0: return i+1


    """2870. Minimum Number of Operations to Make Array Empty (Medium)
    You are given a 0-indexed array nums consisting of positive integers. There
    are two types of operations that you can apply on the array any number of
    times:
    * Choose two elements with equal values and delete them from the array.
    * Choose three elements with equal values and delete them from the array.
    Return the minimum number of operations required to make the array empty,
    or -1 if it is not possible.

    Example 1:
    Input: nums = [2,3,3,2,2,4,2,3,4]
    Output: 4
    Explanation: We can apply the following operations to make the array empty:
                 - Apply the first operation on the elements at indices 0 and 3.
                   The resulting array is nums = [3,3,2,4,2,3,4].
                 - Apply the first operation on the elements at indices 2 and 4.
                   The resulting array is nums = [3,3,4,3,4].
                 - Apply the second operation on the elements at indices 0, 1,
                   and 3. The resulting array is nums = [4,4].
                 - Apply the first operation on the elements at indices 0 and 1.
                   The resulting array is nums = [].
                 It can be shown that we cannot make the array empty in less
                 than 4 operations.

    Example 2:
    Input: nums = [2,1,2,2,3,3]
    Output: -1
    Explanation: It is impossible to empty the array.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for v in Counter(nums).values():
            if v == 1: return -1
            ans += (v + 2)//3
        return ans


    """2871. Split Array Into Maximum Number of Subarrays (Medium)
    You are given an array nums consisting of non-negative integers. We define
    the score of subarray nums[l..r] such that l <= r as
    nums[l] AND nums[l + 1] AND ... AND nums[r] where AND is the bitwise AND
    operation. Consider splitting the array into one or more subarrays such
    that the following conditions are satisfied:
    * Each element of the array belongs to exactly one subarray.
    * The sum of scores of the subarrays is the minimum possible.
    Return the maximum number of subarrays in a split that satisfies the
    conditions above. A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1,0,2,0,1,2]
    Output: 3
    Explanation: We can split the array into the following subarrays:
                 - [1,0]. The score of this subarray is 1 AND 0 = 0.
                 - [2,0]. The score of this subarray is 2 AND 0 = 0.
                 - [1,2]. The score of this subarray is 1 AND 2 = 0.
                 The sum of scores is 0 + 0 + 0 = 0, which is the minimum
                 possible score that we can obtain. It can be shown that we
                 cannot split the array into more than 3 subarrays with a total
                 score of 0. So we return 3.

    Example 2:
    Input: nums = [5,7,1,3]
    Output: 1
    Explanation: We can split the array into one subarray: [5,7,1,3] with a
                 score of 1, which is the minimum possible score that we can
                 obtain. It can be shown that we cannot split the array into
                 more than 1 subarray with a total score of 1. So we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6"""

    def maxSubarrays(self, nums: List[int]) -> int:
        ans = 0
        prefix = -1
        for x in nums:
            prefix &= x
            if prefix == 0:
                ans += 1
                prefix = -1
        return max(1, ans)


    """2872. Maximum Number of K-Divisible Components (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. You are also given a 0-indexed integer array values of length
    n, where values[i] is the value associated with the ith node, and an
    integer k. A valid split of the tree is obtained by removing any set of
    edges, possibly empty, from the tree such that the resulting components all
    have values that are divisible by k, where the value of a connected
    component is the sum of the values of its nodes. Return the maximum number
    of components in any valid split.

    Example 1:
    Input: n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6
    Output: 2
    Explanation: We remove the edge connecting node 1 with 2. The resulting
                 split is valid because:
                 - The value of the component containing nodes 1 and 3 is
                   values[1] + values[3] = 12.
                 - The value of the component containing nodes 0, 2, and 4 is
                   values[0] + values[2] + values[4] = 6.
                 It can be shown that no other valid split has more than 2
                 connected components.

    Example 2:
    Input: n = 7, edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [3,0,6,1,5,2,1], k = 3
    Output: 3
    Explanation: We remove the edge connecting node 0 with 2, and the edge
                 connecting node 0 with 1. The resulting split is valid because:
                 - The value of the component containing node 0 is values[0] = 3.
                 - The value of the component containing nodes 2, 5, and 6 is
                   values[2] + values[5] + values[6] = 9.
                 - The value of the component containing nodes 1, 3, and 4 is
                   values[1] + values[3] + values[4] = 6.
                 It can be shown that no other valid split has more than 3
                 connected components.

    Constraints:
    * 1 <= n <= 3 * 10^4
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * values.length == n
    * 0 <= values[i] <= 10^9
    * 1 <= k <= 10^9
    * Sum of values is divisible by k.
    * The input is generated such that edges represents a valid tree."""

    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)

        def fn(u, p):
            """Return sum of node values in subtree."""
            for v in tree[u]:
                if v != p: values[u] += fn(v, u)
            return values[u]

        fn(0, -1)
        return sum(x % k == 0 for x in values)


    """2873. Maximum Value of an Ordered Triplet I (Easy)
    You are given a 0-indexed integer array nums. Return the maximum value over
    all triplets of indices (i, j, k) such that i < j < k. If all such triplets
    have a negative value, return 0. The value of a triplet of indices (i, j, k)
    is equal to (nums[i] - nums[j]) * nums[k].

    Example 1:
    Input: nums = [12,6,1,2,7]
    Output: 77
    Explanation: The value of the triplet (0, 2, 4) is
                 (nums[0] - nums[2]) * nums[4] = 77. It can be shown that there
                 are no ordered triplets of indices with a value greater than
                 77.

    Example 2:
    Input: nums = [1,10,3,4,19]
    Output: 133
    Explanation: The value of the triplet (1, 2, 4) is
                 (nums[1] - nums[2]) * nums[4] = 133. It can be shown that
                 there are no ordered triplets of indices with a value greater
                 than 133.

    Example 3:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: The only ordered triplet of indices (0, 1, 2) has a negative
                 value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer
                 would be 0.

    Constraints:
    * 3 <= nums.length <= 100
    * 1 <= nums[i] <= 10^6"""

    def maximumTripletValue(self, nums: List[int]) -> int:
        ans = diff = prefix = 0
        for x in nums:
            ans = max(ans, x*diff)
            diff = max(diff, prefix-x)
            prefix = max(prefix, x)
        return ans


    """2874. Maximum Value of an Ordered Triplet II (Medium)
    You are given a 0-indexed integer array nums. Return the maximum value over
    all triplets of indices (i, j, k) such that i < j < k. If all such triplets
    have a negative value, return 0. The value of a triplet of indices (i, j, k)
    is equal to (nums[i] - nums[j]) * nums[k].

    Example 1:
    Input: nums = [12,6,1,2,7]
    Output: 77
    Explanation: The value of the triplet (0, 2, 4) is
                 (nums[0] - nums[2]) * nums[4] = 77. It can be shown that there
                 are no ordered triplets of indices with a value greater than
                 77.

    Example 2:
    Input: nums = [1,10,3,4,19]
    Output: 133
    Explanation: The value of the triplet (1, 2, 4) is
                 (nums[1] - nums[2]) * nums[4] = 133. It can be shown that
                 there are no ordered triplets of indices with a value greater
                 than 133.

    Example 3:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: The only ordered triplet of indices (0, 1, 2) has a negative
                 value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer
                 would be 0.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def maximumTripletValue(self, nums: List[int]) -> int:
        ans = diff = prefix = 0
        for i, x in enumerate(nums):
            ans = max(ans, x*diff)
            diff = max(diff, prefix-x)
            prefix = max(prefix, x)
        return ans


    """2875. Minimum Size Subarray in Infinite Array (Medium)
    You are given a 0-indexed array nums and an integer target. A 0-indexed
    array infinite_nums is generated by infinitely appending the elements of
    nums to itself. Return the length of the shortest subarray of the array
    infinite_nums with a sum equal to target. If there is no such subarray
    return -1.

    Example 1:
    Input: nums = [1,2,3], target = 5
    Output: 2
    Explanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...]. The
                 subarray in the range [1,2], has the sum equal to target = 5
                 and length = 2. It can be proven that 2 is the shortest length
                 of a subarray with sum equal to target = 5.

    Example 2:
    Input: nums = [1,1,1,2,3], target = 4
    Output: 2
    Explanation: In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
                 The subarray in the range [4,5], has the sum equal to
                 target = 4 and length = 2. It can be proven that 2 is the
                 shortest length of a subarray with sum equal to target = 4.

    Example 3:
    Input: nums = [2,4,6,8], target = 3
    Output: -1
    Explanation: In this example infinite_nums = [2,4,6,8,2,4,6,8,...]. It can
                 be proven that there is no subarray with sum equal to
                 target = 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= target <= 10^9"""

    def minSizeSubarray(self, nums: List[int], target: int) -> int:
        q, target = divmod(target, sum(nums))
        ans = q*len(nums)
        cand = inf
        ii = 0
        for i, x in enumerate(nums + nums):
            target -= x
            while target < 0:
                target += nums[ii % len(nums)]
                ii += 1
            if target == 0: cand = min(cand, i-ii+1)
        return ans + cand if cand < inf else -1


    """2876. Count Visited Nodes in a Directed Graph (Hard)
    There is a directed graph consisting of n nodes numbered from 0 to n - 1
    and n directed edges. You are given a 0-indexed array edges where edges[i]
    indicates that there is an edge from node i to node edges[i]. Consider the
    following process on the graph:
    * You start from a node x and keep visiting other nodes through edges until
      you reach a node that you have already visited before on this same
      process.
    Return an array answer where answer[i] is the number of different nodes
    that you will visit if you perform the process starting from node i.

    Example 1:
    Input: edges = [1,2,0,0]
    Output: [3,3,3,4]
    Explanation: We perform the process starting from each node in the
                 following way:
                 - Starting from node 0, we visit the nodes 0 -> 1 -> 2 -> 0.
                   The number of different nodes we visit is 3.
                 - Starting from node 1, we visit the nodes 1 -> 2 -> 0 -> 1.
                   The number of different nodes we visit is 3.
                 - Starting from node 2, we visit the nodes 2 -> 0 -> 1 -> 2.
                   The number of different nodes we visit is 3.
                 - Starting from node 3, we visit the nodes 3 -> 0 -> 1 -> 2 ->
                   0. The number of different nodes we visit is 4.

    Example 2:
    Input: edges = [1,2,3,4,0]
    Output: [5,5,5,5,5]
    Explanation: Starting from any node we can visit every node in the graph in
                 the process.

    Constraints:
    * n == edges.length
    * 2 <= n <= 10^5
    * 0 <= edges[i] <= n - 1
    * edges[i] != i"""

    def countVisitedNodes(self, edges: List[int]) -> List[int]:
        n = len(edges)
        ans = [0]*n
        for k in range(n):
            if ans[k] == 0:
                stack = []
                v = 0
                while ans[k] == 0:
                    ans[k] = v = v-1
                    stack.append(k)
                    k = edges[k]
                pp = k
                for kk in reversed(stack):
                    if ans[k] > 0: ans[kk] = ans[pp] + 1
                    else: ans[kk] = ans[k] - v + 1
                    pp = kk
        return ans


    """2892. Minimizing Array After Replacing Pairs With Their Product (Medium)
    Given an integer array nums and an integer k, you can perform the following
    operation on the array any number of times:
    * Select two adjacent elements of the array like x and y, such that
      x * y <= k, and replace both of them with a single element with value
      x * y (e.g. in one operation the array [1, 2, 2, 3] with k = 5 can become
      [1, 4, 3] or [2, 2, 3], but can't become [1, 2, 6]).
    Return the minimum possible length of nums after any number of operations.

    Example 1:
    Input: nums = [2,3,3,7,3,5], k = 20
    Output: 3
    Explanation: We perform these operations:
                 1. [2,3,3,7,3,5] -> [6,3,7,3,5]
                 2. [6,3,7,3,5] -> [18,7,3,5]
                 3. [18,7,3,5] -> [18,7,15]
                 It can be shown that 3 is the minimum length possible to
                 achieve with the given operation.

    Example 2:
    Input: nums = [3,3,3,3], k = 6
    Output: 4
    Explanation: We can't perform any operations since the product of every two
                 adjacent elements is greater than 6. Hence, the answer is 4.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 1 <= k <= 10^9"""

    def minArrayLength(self, nums: List[int], k: int) -> int:
        ans = prefix = 0
        for x in nums:
            if x == 0: return 1
            elif prefix and prefix*x <= k: prefix *= x
            else:
                ans += 1
                prefix = x
        return ans


    """2894. Divisible and Non-divisible Sums Difference (Easy)
    You are given positive integers n and m. Define two integers, num1 and num2,
    as follows:
    * num1: The sum of all integers in the range [1, n] that are not divisible
      by m.
    * num2: The sum of all integers in the range [1, n] that are divisible by m.
    Return the integer num1 - num2.

    Example 1:
    Input: n = 10, m = 3
    Output: 19
    Explanation: In the given example:
                 - Integers in the range [1, 10] that are not divisible by 3
                   are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.
                 - Integers in the range [1, 10] that are divisible by 3 are
                   [3,6,9], num2 is the sum of those integers = 18.
                 We return 37 - 18 = 19 as the answer.

    Example 2:
    Input: n = 5, m = 6
    Output: 15
    Explanation: In the given example:
                 - Integers in the range [1, 5] that are not divisible by 6 are
                   [1,2,3,4,5], num1 is the sum of those integers = 15.
                 - Integers in the range [1, 5] that are divisible by 6 are [],
                   num2 is the sum of those integers = 0.
                 We return 15 - 0 = 15 as the answer.

    Example 3:
    Input: n = 5, m = 1
    Output: -15
    Explanation: In the given example:
                 - Integers in the range [1, 5] that are not divisible by 1 are
                   [], num1 is the sum of those integers = 0.
                 - Integers in the range [1, 5] that are divisible by 1 are
                   [1,2,3,4,5], num2 is the sum of those integers = 15.
                 We return 0 - 15 = -15 as the answer.

    Constraints: 1 <= n, m <= 1000"""

    def differenceOfSums(self, n: int, m: int) -> int:
        return n*(n+1)//2 - (n//m)*(n//m+1)*m


    """2895. Minimum Processing Time (Medium)
    You have n processors each having 4 cores and n * 4 tasks that need to be
    executed such that each core should perform only one task. Given a
    0-indexed integer array processorTime representing the time at which each
    processor becomes available for the first time and a 0-indexed integer
    array tasks representing the time it takes to execute each task, return the
    minimum time when all of the tasks have been executed by the processors.
    Note: Each core executes the task independently of the others.

    Example 1:
    Input: processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]
    Output: 16
    Explanation: It's optimal to assign the tasks at indexes 4, 5, 6, 7 to the
                 first processor which becomes available at time = 8, and the
                 tasks at indexes 0, 1, 2, 3 to the second processor which
                 becomes available at time = 10. Time taken by the first
                 processor to finish execution of all tasks =
                 max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16. Time taken by the second
                 processor to finish execution of all tasks =
                 max(10 + 2, 10 + 2, 10 + 3, 10 + 1) = 13. Hence, it can be
                 shown that the minimum time taken to execute all the tasks is
                 16.

    Example 2:
    Input: processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]
    Output: 23
    Explanation: It's optimal to assign the tasks at indexes 1, 4, 5, 6 to the
                 first processor which becomes available at time = 10, and the
                 tasks at indexes 0, 2, 3, 7 to the second processor which
                 becomes available at time = 20. Time taken by the first
                 processor to finish execution of all tasks =
                 max(10 + 3, 10 + 5, 10 + 8, 10 + 4) = 18. Time taken by the
                 second processor to finish execution of all tasks =
                 max(20 + 2, 20 + 1, 20 + 2, 20 + 3) = 23. Hence, it can be
                 shown that the minimum time taken to execute all the tasks is
                 23.

    Constraints:
    * 1 <= n == processorTime.length <= 25000
    * 1 <= tasks.length <= 10^5
    * 0 <= processorTime[i] <= 10^9
    * 1 <= tasks[i] <= 10^9
    * tasks.length == 4 * n"""

    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:
        return max(x+y for x, y in zip(sorted(processorTime*4), sorted(tasks, reverse=True)))


    """2896. Apply Operations to Make Two Strings Equal (Medium)
    You are given two 0-indexed binary strings s1 and s2, both of length n, and
    a positive integer x. You can perform any of the following operations on
    the string s1 any number of times:
    * Choose two indices i and j, and flip both s1[i] and s1[j]. The cost of
      this operation is x.
    * Choose an index i such that i < n - 1 and flip both s1[i] and s1[i + 1].
      The cost of this operation is 1.
    Return the minimum cost needed to make the strings s1 and s2 equal, or
    return -1 if it is impossible. Note that flipping a character means
    changing it from 0 to 1 or vice-versa.

    Example 1:
    Input: s1 = "1100011000", s2 = "0101001010", x = 2
    Output: 4
    Explanation: We can do the following operations:
                 - Choose i = 3 and apply the second operation. The resulting
                   string is s1 = "1101111000".
                 - Choose i = 4 and apply the second operation. The resulting
                   string is s1 = "1101001000".
                 - Choose i = 0 and j = 8 and apply the first operation. The
                   resulting string is s1 = "0101001010" = s2.
                 The total cost is 1 + 1 + 2 = 4. It can be shown that it is
                 the minimum cost possible.

    Example 2:
    Input: s1 = "10110", s2 = "00011", x = 4
    Output: -1
    Explanation: It is not possible to make the two strings equal.

    Constraints:
    * n == s1.length == s2.length
    * 1 <= n, x <= 500
    * s1 and s2 consist only of the characters '0' and '1'."""

    def minOperations(self, s1: str, s2: str, x: int) -> int:
        diff = [i for i, (c1, c2) in enumerate(zip(s1, s2)) if c1 != c2]
        n = len(diff)
        if n&1: return -1
        f0 = f1 = 0
        for i in range(len(diff)):
            f2 = f1 + x/2
            if i: f2 = min(f2, f0 + diff[i] - diff[i-1])
            f0, f1 = f1, f2
        return int(f1)


    """2897. Apply Operations on Array to Maximize Sum of Squares (Hard)
    You are given a 0-indexed integer array nums and a positive integer k. You
    can do the following operation on the array any number of times:
    * Choose any two distinct indices i and j and simultaneously update the
      values of nums[i] to (nums[i] AND nums[j]) and nums[j] to
      (nums[i] OR nums[j]). Here, OR denotes the bitwise OR operation, and AND
      denotes the bitwise AND operation.
    You have to choose k elements from the final array and calculate the sum of
    their squares. Return the maximum sum of squares you can achieve. Since the
    answer can be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,6,5,8], k = 2
    Output: 261
    Explanation: We can do the following operations on the array:
                 - Choose i = 0 and j = 3, then change nums[0] to (2 AND 8) = 0
                   and nums[3] to (2 OR 8) = 10. The resulting array is
                   nums = [0,6,5,10].
                 - Choose i = 2 and j = 3, then change nums[2] to (5 AND 10) = 0
                   and nums[3] to (5 OR 10) = 15. The resulting array is
                   nums = [0,6,0,15].
                 We can choose the elements 15 and 6 from the final array. The
                 sum of squares is 152 + 62 = 261. It can be shown that this is
                 the maximum value we can get.

    Example 2:
    Input: nums = [4,5,4,7], k = 3
    Output: 90
    Explanation: We do not need to apply any operations. We can choose the
                 elements 7, 5, and 4 with a sum of squares: 72 + 52 + 42 = 90.
                 It can be shown that this is the maximum value we can get.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def maxSum(self, nums: List[int], k: int) -> int:
        freq = [0]*32
        for x in nums:
            for i in range(32):
                if x & 1<<i: freq[i] += 1
        ans = 0
        for _ in range(k):
            cand = 0
            for i in range(31, -1, -1):
                if freq[i]:
                    freq[i] -= 1
                    cand ^= 1<<i
            ans += cand**2
        return ans % 1_000_000_007


    """2898. Maximum Linear Stock Score (Medium)
    Given a 1-indexed integer array prices, where prices[i] is the price of a
    particular stock on the ith day, your task is to select some of the elements
    of prices such that your selection is linear. A selection indexes, where
    indexes is a 1-indexed integer array of length k which is a subsequence of
    the array [1, 2, ..., n], is linear if:
    * For every 1 < j <= k,
      prices[indexes[j]] - prices[indexes[j - 1]] == indexes[j] - indexes[j - 1].
    A subsequence is an array that can be derived from another array by deleting
    some or no elements without changing the order of the remaining elements.
    The score of a selection indexes, is equal to the sum of the following array:
    [prices[indexes[1]], prices[indexes[2]], ..., prices[indexes[k]]. Return the
    maximum score that a linear selection can have.

    Example 1:
    Input: prices = [1,5,3,7,8]
    Output: 20
    Explanation: We can select the indexes [2,4,5]. We show that our selection
                 is linear:
                 For j = 2, we have:
                 indexes[2] - indexes[1] = 4 - 2 = 2.
                 prices[4] - prices[2] = 7 - 5 = 2.
                 For j = 3, we have:
                 indexes[3] - indexes[2] = 5 - 4 = 1.
                 prices[5] - prices[4] = 8 - 7 = 1.
                 The sum of the elements is:
                 prices[2] + prices[4] + prices[5] = 20.
                 It can be shown that the maximum sum a linear selection can
                 have is 20.

    Example 2:
    Input: prices = [5,6,7,8,9]
    Output: 35
    Explanation: We can select all of the indexes [1,2,3,4,5]. Since each
                 element has a difference of exactly 1 from its previous
                 element, our selection is linear. The sum of all the elements
                 is 35 which is the maximum possible some out of every
                 selection.

    Constraints:
    * 1 <= prices.length <= 10^5
    * 1 <= prices[i] <= 10^9"""

    def maxScore(self, prices: List[int]) -> int:
        mp = defaultdict(int)
        for i, x in enumerate(prices):
            mp[x-i] += x
        return max(mp.values())


    """2899. Last Visited Integers (Easy)
    Given a 0-indexed array of strings words where words[i] is either a positive
    integer represented as a string or the string "prev". Start iterating from
    the beginning of the array; for every "prev" string seen in words, find the
    last visited integer in words which is defined as follows:
    * Let k be the number of consecutive "prev" strings seen so far (containing
      the current string). Let nums be the 0-indexed array of integers seen so
      far and nums_reverse be the reverse of nums, then the integer at (k - 1)th
      index of nums_reverse will be the last visited integer for this "prev".
    * If k is greater than the total visited integers, then the last visited
      integer will be -1.
    Return an integer array containing the last visited integers.

    Example 1:
    Input: words = ["1","2","prev","prev","prev"]
    Output: [2,1,-1]
    Explanation: - For "prev" at index = 2, last visited integer will be 2 as
                   here the number of consecutive "prev" strings is 1, and in
                   the array reverse_nums, 2 will be the first element.
                 - For "prev" at index = 3, last visited integer will be 1 as
                   there are a total of two consecutive "prev" strings including
                   this "prev" which are visited, and 1 is the second last
                   visited integer.
                 - For "prev" at index = 4, last visited integer will be -1 as
                   there are a total of three consecutive "prev" strings
                   including this "prev" which are visited, but the total number
                   of integers visited is two.

    Example 2:
    Input: words = ["1","prev","2","prev","prev"]
    Output: [1,2,1]
    Explanation: - For "prev" at index = 1, last visited integer will be 1.
                 - For "prev" at index = 3, last visited integer will be 2.
                 - For "prev" at index = 4, last visited integer will be 1 as
                   there are a total of two consecutive "prev" strings including
                   this "prev" which are visited, and 1 is the second last
                   visited integer.

    Constraints:
    * 1 <= words.length <= 100
    * words[i] == "prev" or 1 <= int(words[i]) <= 100"""

    def lastVisitedIntegers(self, words: List[str]) -> List[int]:
        ans, seen = [], []
        k = 0
        for w in words:
            if w == "prev":
                if k >= len(seen): ans.append(-1)
                else:
                    ans.append(seen[~k])
                    k += 1
            else:
                seen.append(int(w))
                k = 0
        return ans


    """2900. Longest Unequal Adjacent Groups Subsequence I (Easy)
    You are given a string array words and a binary array groups both of length
    n, where words[i] is associated with groups[i]. Your task is to select the
    longest alternating subsequence from words. A subsequence of words is
    alternating if for any two consecutive strings in the sequence, their
    corresponding elements in the binary array groups differ. Essentially, you
    are to choose strings such that adjacent elements have non-matching
    corresponding bits in the groups array. Formally, you need to find the
    longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as
    [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each
    0 <= j < k - 1 and then find the words corresponding to these indices.
    Return the selected subsequence. If there are multiple answers, return any
    of them. Note: The elements in words are distinct.

    Example 1:
    Input: words = ["e","a","b"], groups = [0,0,1]
    Output: ["e","b"]
    Explanation: A subsequence that can be selected is ["e","b"] because
                 groups[0] != groups[2]. Another subsequence that can be
                 selected is ["a","b"] because groups[1] != groups[2]. It can be
                 demonstrated that the length of the longest subsequence of
                 indices that satisfies the condition is 2.

    Example 2:
    Input: words = ["a","b","c","d"], groups = [1,0,1,1]
    Output: ["a","b","c"]
    Explanation: A subsequence that can be selected is ["a","b","c"] because
                 groups[0] != groups[1] and groups[1] != groups[2]. Another
                 subsequence that can be selected is ["a","b","d"] because
                 groups[0] != groups[1] and groups[1] != groups[3]. It can be
                 shown that the length of the longest subsequence of indices
                 that satisfies the condition is 3.

    Constraints:
    * 1 <= n == words.length == groups.length <= 100
    * 1 <= words[i].length <= 10
    * groups[i] is either 0 or 1.
    * words consists of distinct strings.
    * words[i] consists of lowercase English letters."""

    def getLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
        ans = []
        for i, (w, g) in enumerate(zip(words, groups)):
            if i == 0 or groups[i-1] != g:
                ans.append(w)
        return ans


    """2913. Subarrays Distinct Element Sum of Squares I (Easy)
    You are given a 0-indexed integer array nums. The distinct count of a
    subarray of nums is defined as:
    * Let nums[i..j] be a subarray of nums consisting of all the indices from i
      to j such that 0 <= i <= j < nums.length. Then the number of distinct
      values in nums[i..j] is called the distinct count of nums[i..j].
    Return the sum of the squares of distinct counts of all subarrays of nums. A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,1]
    Output: 15
    Explanation: Six possible subarrays are:
                 [1]: 1 distinct value
                 [2]: 1 distinct value
                 [1]: 1 distinct value
                 [1,2]: 2 distinct values
                 [2,1]: 2 distinct values
                 [1,2,1]: 2 distinct values
                 The sum of the squares of the distinct counts in all subarrays
                 is equal to 12 + 12 + 12 + 22 + 22 + 22 = 15.

    Example 2:
    Input: nums = [1,1]
    Output: 3
    Explanation: Three possible subarrays are:
                 [1]: 1 distinct value
                 [1]: 1 distinct value
                 [1,1]: 1 distinct value
                 The sum of the squares of the distinct counts in all subarrays
                 is equal to 12 + 12 + 12 = 3.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100"""

    def sumCounts(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums)):
            seen = set()
            for j in range(i, len(nums)):
                seen.add(nums[j])
                ans += len(seen)**2
        return ans


    """2917. Find the K-or of an Array (Easy)
    You are given a 0-indexed integer array nums, and an integer k. The K-or of
    nums is a non-negative integer that satisfies the following:
    * The ith bit is set in the K-or if and only if there are at least k
      elements of nums in which bit i is set.
    Return the K-or of nums. Note that a bit i is set in x if (2i AND x) == 2i,
    where AND is the bitwise AND operator.

    Example 1:
    Input: nums = [7,12,9,8,9,15], k = 4
    Output: 9
    Explanation: Bit 0 is set at nums[0], nums[2], nums[4], and nums[5].
                 Bit 1 is set at nums[0], and nums[5].
                 Bit 2 is set at nums[0], nums[1], and nums[5].
                 Bit 3 is set at nums[1], nums[2], nums[3], nums[4], and nums[5].
                 Only bits 0 and 3 are set in at least k elements of the array,
                 and bits i >= 4 are not set in any of the array's elements.
                 Hence, the answer is 2^0 + 2^3 = 9.

    Example 2:
    Input: nums = [2,12,1,11,4,5], k = 6
    Output: 0
    Explanation: Since k == 6 == nums.length, the 6-or of the array is equal to
                 the bitwise AND of all its elements. Hence, the answer is 2 AND
                 12 AND 1 AND 11 AND 4 AND 5 = 0.

    Example 3:
    Input: nums = [10,8,5,9,11,6,8], k = 1
    Output: 15
    Explanation: Since k == 1, the 1-or of the array is equal to the bitwise OR
                 of all its elements. Hence, the answer is
                 10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15.

    Constraints:
    * 1 <= nums.length <= 50
    * 0 <= nums[i] < 2^31
    * 1 <= k <= nums.length"""

    def findKOr(self, nums: List[int], k: int) -> int:
        ans = 0
        for i in range(32):
            freq = 0
            for x in nums:
                if x & 1<<i and (freq := freq+1) == k:
                    ans ^= 1<<i
                    break
        return ans


    """2918. Minimum Equal Sum of Two Arrays After Replacing Zeros (Medium)
    You are given two arrays nums1 and nums2 consisting of positive integers.
    You have to replace all the 0's in both arrays with strictly positive
    integers such that the sum of elements of both arrays becomes equal. Return
    the minimum equal sum you can obtain, or -1 if it is impossible.

    Example 1:
    Input: nums1 = [3,2,0,1,0], nums2 = [6,5,0]
    Output: 12
    Explanation: We can replace 0's in the following way:
                 - Replace the two 0's in nums1 with the values 2 and 4. The
                   resulting array is nums1 = [3,2,2,1,4].
                 - Replace the 0 in nums2 with the value 1. The resulting array
                   is nums2 = [6,5,1].
                 Both arrays have an equal sum of 12. It can be shown that it is
                 the minimum sum we can obtain.

    Example 2:
    Input: nums1 = [2,0,2,0], nums2 = [1,4]
    Output: -1
    Explanation: It is impossible to make the sum of both arrays equal.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 10^5
    * 0 <= nums1[i], nums2[i] <= 10^6"""

    def minSum(self, nums1: List[int], nums2: List[int]) -> int:
        s1 = sum(max(x, 1) for x in nums1)
        s2 = sum(max(x, 1) for x in nums2)
        if s1 < s2 and nums1.count(0) == 0: return -1
        if s1 > s2 and nums2.count(0) == 0: return -1
        return max(s1, s2)


    """2919. Minimum Increment Operations to Make Array Beautiful (Medium)
    You are given a 0-indexed integer array nums having length n, and an integer
    k. You can perform the following increment operation any number of times
    (including zero):
    * Choose an index i in the range [0, n - 1], and increase nums[i] by 1.
    An array is considered beautiful if, for any subarray with a size of 3 or
    more, its maximum element is greater than or equal to k. Return an integer
    denoting the minimum number of increment operations needed to make nums
    beautiful. A subarray is a contiguous non-empty sequence of elements within
    an array.

    Example 1:
    Input: nums = [2,3,0,0,2], k = 4
    Output: 3
    Explanation: We can perform the following increment operations to make nums
                 beautiful:
                 - Choose index i = 1 and increase nums[1] by 1 -> [2,4,0,0,2].
                 - Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,3].
                 - Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,4].
                 The subarrays with a size of 3 or more are: [2,4,0], [4,0,0],
                 [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4]. In all the
                 subarrays, the maximum element is equal to k = 4, so nums is
                 now beautiful. It can be shown that nums cannot be made
                 beautiful with fewer than 3 increment operations. Hence, the
                 answer is 3.

    Example 2:
    Input: nums = [0,1,3,3], k = 5
    Output: 2
    Explanation: We can perform the following increment operations to make nums
                 beautiful:
                 - Choose index i = 2 and increase nums[2] by 1 -> [0,1,4,3].
                 - Choose index i = 2 and increase nums[2] by 1 -> [0,1,5,3].
                 The subarrays with a size of 3 or more are: [0,1,5], [1,5,3],
                 [0,1,5,3]. In all the subarrays, the maximum element is equal
                 to k = 5, so nums is now beautiful. It can be shown that nums
                 cannot be made beautiful with fewer than 2 increment
                 operations. Hence, the answer is 2.

    Example 3:
    Input: nums = [1,1,2], k = 1
    Output: 0
    Explanation: The only subarray with a size of 3 or more in this example is
                 [1,1,2]. The maximum element, 2, is already greater than k = 1,
                 so we don't need any increment operation. Hence, the answer is
                 0.

    Constraints:
    * 3 <= n == nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 0 <= k <= 10^9"""

    def minIncrementOperations(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [0]*(n+1)
        for i in range(n-1, -1, -1):
            dp[i] = max(0, k-nums[i]) + min(dp[i+1:i+4], default=0)
        return min(dp[:3])


    """2920. Maximum Points After Collecting Coins From All Nodes (Hard)
    There exists an undirected tree rooted at node 0 with n nodes labeled from 0
    to n - 1. You are given a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. You are also given a 0-indexed array coins of size n where
    coins[i] indicates the number of coins in the vertex i, and an integer k.
    Starting from the root, you have to collect all the coins such that the
    coins at a node can only be collected if the coins of its ancestors have
    been already collected. Coins at nodei can be collected in one of the
    following ways:
    * Collect all the coins, but you will get coins[i] - k points. If
      coins[i] - k is negative then you will lose abs(coins[i] - k) points.
    * Collect all the coins, but you will get floor(coins[i] / 2) points. If
      this way is used, then for all the nodej present in the subtree of nodei,
      coins[j] will get reduced to floor(coins[j] / 2).
    Return the maximum points you can get after collecting the coins from all
    the tree nodes.

    Example 1:
    Input: edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5
    Output: 11
    Explanation: - Collect all the coins from node 0 using the first way. Total
                   points = 10 - 5 = 5.
                 - Collect all the coins from node 1 using the first way. Total
                   points = 5 + (10 - 5) = 10.
                 - Collect all the coins from node 2 using the second way so
                   coins left at node 3 will be floor(3 / 2) = 1. Total points
                   = 10 + floor(3 / 2) = 11.
                 - Collect all the coins from node 3 using the second way. Total
                   points = 11 + floor(1 / 2) = 11.
                 It can be shown that the maximum points we can get after
                 collecting coins from all the nodes is 11.

    Example 2:
    Input: edges = [[0,1],[0,2]], coins = [8,4,4], k = 0
    Output: 16
    Explanation: Coins will be collected from all the nodes using the first way.
                 Therefore, total points = (8 - 0) + (4 - 0) + (4 - 0) = 16.

    Constraints:
    * n == coins.length
    * 2 <= n <= 10^5
    * 0 <= coins[i] <= 10^4
    * edges.length == n - 1
    * 0 <= edges[i][0], edges[i][1] < n
    * 0 <= k <= 10^4"""

    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:
        n = len(edges)+1
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)

        @cache
        def fn(u, p, d):
            """Return """
            if d >= 14: return 0
            op1 = op2 = 0
            for v in tree[u]:
                if v != p:
                    op1 += fn(v, u, d)
                    op2 += fn(v, u, d+1)
            return max((coins[u]>>d) - k + op1, (coins[u]>>d+1) + op2)

        return fn(0, -1, 0)


    """2928. Distribute Candies Among Children I (Easy)
    You are given two positive integers n and limit. Return the total number of
    ways to distribute n candies among 3 children such that no child gets more
    than limit candies.

    Example 1:
    Input: n = 5, limit = 2
    Output: 3
    Explanation: There are 3 ways to distribute 5 candies such that no child
                 gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).

    Example 2:
    Input: n = 3, limit = 3
    Output: 10
    Explanation: There are 10 ways to distribute 3 candies such that no child
                 gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1),
                 (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1),
                 (2, 1, 0) and (3, 0, 0).

    Constraints:
    * 1 <= n <= 50
    * 1 <= limit <= 50"""

    def distributeCandies(self, n: int, limit: int) -> int:
        ans = 0
        for x in range(0, limit+1):
            for y in range(0, limit+1):
                if 0 <= n-x-y <= limit: ans += 1
        return ans


    """2929. Distribute Candies Among Children II (Medium)
    You are given two positive integers n and limit. Return the total number of
    ways to distribute n candies among 3 children such that no child gets more
    than limit candies.

    Example 1:
    Input: n = 5, limit = 2
    Output: 3
    Explanation: There are 3 ways to distribute 5 candies such that no child
                 gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).
    Example 2:
    Input: n = 3, limit = 3
    Output: 10
    Explanation: There are 10 ways to distribute 3 candies such that no child
                 gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1),
                 (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1),
                 (2, 1, 0) and (3, 0, 0).

    Constraints:
    * 1 <= n <= 10^6
    * 1 <= limit <= 10^6"""

    def distributeCandies(self, n: int, limit: int) -> int:
        ans = 0
        for x in range(limit+1):
            ans += max(0, min(n-x, 2*limit-n+x) + 1)
        return ans


    """2930. Number of Strings Which Can Be Rearranged to Contain Substring (Medium)
    You are given an integer n. A string s is called good if it contains only
    lowercase English characters and it is possible to rearrange the characters
    of s such that the new string contains "leet" as a substring.

    For example:
    * The string "lteer" is good because we can rearrange it to form "leetr" .
    * "letl" is not good because we cannot rearrange it to contain "leet" as a
      substring.
    Return the total number of good strings of length n. Since the answer may
    be large, return it modulo 10^9 + 7. A substring is a contiguous sequence
    of characters within a string.

    Example 1:
    Input: n = 4
    Output: 12
    Explanation: The 12 strings which can be rearranged to have "leet" as a
                 substring are: "eelt", "eetl", "elet", "elte", "etel", "etle",
                 "leet", "lete", "ltee", "teel", "tele", and "tlee".

    Example 2:
    Input: n = 10
    Output: 83943898
    Explanation: The number of strings with length 10 which can be rearranged
                 to have "leet" as a substring is 526083947580. Hence the
                 answer is 526083947580 % (10^9 + 7) = 83943898.

    Constraints: 1 <= n <= 10^5"""

    def stringCount(self, n: int) -> int:
        mod = 1_000_000_007
        return (pow(26, n, mod) - (75+n)*pow(25, n-1, mod) + (72+2*n)*pow(24, n-1, mod) - (23+n)*pow(23, n-1, mod)) % mod


    """2931. Maximum Spending After Buying Items (Hard)
    You are given a 0-indexed m * n integer matrix values, representing the
    values of m * n different items in m different shops. Each shop has n items
    where the jth item in the ith shop has a value of values[i][j].
    Additionally, the items in the ith shop are sorted in non-increasing order
    of value. That is, values[i][j] >= values[i][j + 1] for all 0 <= j < n - 1.
    On each day, you would like to buy a single item from one of the shops.
    Specifically, On the dth day you can:
    * Pick any shop i.
    * Buy the rightmost available item j for the price of values[i][j] * d.
      That is, find the greatest index j such that item j was never bought
      before, and buy it for the price of values[i][j] * d.
    Note that all items are pairwise different. For example, if you have bought
    item 0 from shop 1, you can still buy item 0 from any other shop. Return
    the maximum amount of money that can be spent on buying all m * n products.

    Example 1:
    Input: values = [[8,5,2],[6,4,1],[9,7,3]]
    Output: 285
    Explanation: - On the first day, we buy product 2 from shop 1 for a price
                   of values[1][2] * 1 = 1.
                 - On the second day, we buy product 2 from shop 0 for a price
                   of values[0][2] * 2 = 4.
                 - On the third day, we buy product 2 from shop 2 for a price
                   of values[2][2] * 3 = 9.
                 - On the fourth day, we buy product 1 from shop 1 for a price
                   of values[1][1] * 4 = 16.
                 - On the fifth day, we buy product 1 from shop 0 for a price
                   of values[0][1] * 5 = 25.
                 - On the sixth day, we buy product 0 from shop 1 for a price
                   of values[1][0] * 6 = 36.
                 - On the seventh day, we buy product 1 from shop 2 for a price
                   of values[2][1] * 7 = 49.
                 - On the eighth day, we buy product 0 from shop 0 for a price
                   of values[0][0] * 8 = 64.
                 - On the ninth day, we buy product 0 from shop 2 for a price
                   of values[2][0] * 9 = 81.
                 Hence, our total spending is equal to 285. It can be shown
                 that 285 is the maximum amount of money that can be spent
                 buying all m * n products.

    Example 2:
    Input: values = [[10,8,6,4,2],[9,7,5,3,2]]
    Output: 386
    Explanation: - On the first day, we buy product 4 from shop 0 for a price
                   of values[0][4] * 1 = 2.
                 - On the second day, we buy product 4 from shop 1 for a price
                   of values[1][4] * 2 = 4.
                 - On the third day, we buy product 3 from shop 1 for a price of values[1][3] * 3 = 9.
                 - On the fourth day, we buy product 3 from shop 0 for a price of values[0][3] * 4 = 16.
                 - On the fifth day, we buy product 2 from shop 1 for a price of values[1][2] * 5 = 25.
                 - On the sixth day, we buy product 2 from shop 0 for a price of values[0][2] * 6 = 36.
                 - On the seventh day, we buy product 1 from shop 1 for a price of values[1][1] * 7 = 49.
                 - On the eighth day, we buy product 1 from shop 0 for a price of values[0][1] * 8 = 64
                 - On the ninth day, we buy product 0 from shop 1 for a price of values[1][0] * 9 = 81.
                 - On the tenth day, we buy product 0 from shop 0 for a price of values[0][0] * 10 = 100.
                 Hence, our total spending is equal to 386. It can be shown
                 that 386 is the maximum amount of money that can be spent
                 buying all m * n products.

    Constraints:
    * 1 <= m == values.length <= 10
    * 1 <= n == values[i].length <= 10^4
    * 1 <= values[i][j] <= 10^6
    * values[i] are sorted in non-increasing order."""

    def maxSpending(self, values: List[List[int]]) -> int:
        m, n = len(values), len(values[0])
        pq = [(values[i][-1], i, n-1) for i in range(m)]
        heapify(pq)
        ans = 0
        for d in range(m*n):
            x, i, j = heappop(pq)
            if j: heappush(pq, (values[i][j-1], i, j-1))
            ans += x * (d+1)
        return ans


    """2932. Maximum Strong Pair XOR I (Easy)
    You are given a 0-indexed integer array nums. A pair of integers x and y is
    called a strong pair if it satisfies the condition:
    * |x - y| <= min(x, y)
    You need to select two integers from nums such that they form a strong pair
    and their bitwise XOR is the maximum among all strong pairs in the array.
    Return the maximum XOR value out of all possible strong pairs in the array
    nums. Note that you can pick the same integer twice to form a pair.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 7
    Explanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2),
                 (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5)
                 and (5, 5). The maximum XOR possible from these pairs is
                 3 XOR 4 = 7.

    Example 2:
    Input: nums = [10,100]
    Output: 0
    Explanation: There are 2 strong pairs in the array nums: (10, 10) and
                 (100, 100). The maximum XOR possible from these pairs is
                 10 XOR 10 = 0 since the pair (100, 100) also gives
                 100 XOR 100 = 0.

    Example 3:
    Input: nums = [5,6,25,30]
    Output: 7
    Explanation: There are 6 strong pairs in the array nums: (5, 5), (5, 6),
                 (6, 6), (25, 25), (25, 30) and (30, 30). The maximum XOR
                 possible from these pairs is 25 XOR 30 = 7 since the only other
                 non-zero XOR value is 5 XOR 6 = 3.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 100"""

    def maximumStrongPairXor(self, nums: List[int]) -> int:
        return max((x^y for x, y in combinations(nums, 2) if abs(x-y) <= min(x, y)), default=0)


    """2933. High-Access Employees (Medium)
    You are given a 2D 0-indexed array of strings, access_times, with size n.
    For each i where 0 <= i <= n - 1, access_times[i][0] represents the name of
    an employee, and access_times[i][1] represents the access time of that
    employee. All entries in access_times are within the same day. The access
    time is represented as four digits using a 24-hour time format, for example,
    "0800" or "2250". An employee is said to be high-access if he has accessed
    the system three or more times within a one-hour period. Times with exactly
    one hour of difference are not considered part of the same one-hour period.
    For example, "0815" and "0915" are not part of the same one-hour period.
    Access times at the start and end of the day are not counted within the same
    one-hour period. For example, "0005" and "2350" are not part of the same
    one-hour period. Return a list that contains the names of high-access
    employees with any order you want.

    Example 1:
    Input: access_times = [["a","0549"],["b","0457"],["a","0532"],["a","0621"],["b","0540"]]
    Output: ["a"]
    Explanation: "a" has three access times in the one-hour period of
                 [05:32, 06:31] which are 05:32, 05:49, and 06:21. But "b" does
                 not have more than two access times at all. So the answer is
                 ["a"].

    Example 2:
    Input: access_times = [["d","0002"],["c","0808"],["c","0829"],["e","0215"],["d","1508"],["d","1444"],["d","1410"],["c","0809"]]
    Output: ["c","d"]
    Explanation: "c" has three access times in the one-hour period of
                 [08:08, 09:07] which are 08:08, 08:09, and 08:29. "d" has also
                 three access times in the one-hour period of [14:10, 15:09]
                 which are 14:10, 14:44, and 15:08. However, "e" has just one
                 access time, so it can not be in the answer and the final
                 answer is ["c","d"].

    Example 3:
    Input: access_times = [["cd","1025"],["ab","1025"],["cd","1046"],["cd","1055"],["ab","1124"],["ab","1120"]]
    Output: ["ab","cd"]
    Explanation: "ab" has three access times in the one-hour period of
                 [10:25, 11:24] which are 10:25, 11:20, and 11:24. "cd" has also
                 three access times in the one-hour period of [10:25, 11:24]
                 which are 10:25, 10:46, and 10:55. So the answer is ["ab","cd"].

    Constraints:
    * 1 <= access_times.length <= 100
    * access_times[i].length == 2
    * 1 <= access_times[i][0].length <= 10
    * access_times[i][0] consists only of English small letters.
    * access_times[i][1].length == 4
    * access_times[i][1] is in 24-hour time format.
    * access_times[i][1] consists only of '0' to '9'."""

    def findHighAccessEmployees(self, access_times: List[List[str]]) -> List[str]:
        mp = defaultdict(list)
        for name, time in access_times:
            time = 60*int(time[:2]) + int(time[2:])
            mp[name].append(time)
        ans = []
        for name, times in mp.items():
            times.sort()
            for i in range(2, len(times)):
                if times[i] - times[i-2] < 60:
                    ans.append(name)
                    break
        return ans


    """2934. Minimum Operations to Maximize Last Elements in Arrays (Medium)
    You are given two 0-indexed integer arrays, nums1 and nums2, both having
    length n. You are allowed to perform a series of operations (possibly none).
    In an operation, you select an index i in the range [0, n - 1] and swap the
    values of nums1[i] and nums2[i]. Your task is to find the minimum number of
    operations required to satisfy the following conditions:
    * nums1[n - 1] is equal to the maximum value among all elements of nums1,
      i.e., nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]).
    * nums2[n - 1] is equal to the maximum value among all elements of nums2,
      i.e., nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]).
    Return an integer denoting the minimum number of operations needed to meet
    both conditions, or -1 if it is impossible to satisfy both conditions.

    Example 1:
    Input: nums1 = [1,2,7], nums2 = [4,5,3]
    Output: 1
    Explanation: In this example, an operation can be performed using index
                 i = 2. When nums1[2] and nums2[2] are swapped, nums1 becomes
                 [1,2,3] and nums2 becomes [4,5,7]. Both conditions are now
                 satisfied. It can be shown that the minimum number of
                 operations needed to be performed is 1. So, the answer is 1.

    Example 2:
    Input: nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]
    Output: 2
    Explanation: In this example, the following operations can be performed:
                 - First operation using index i = 4. When nums1[4] and nums2[4]
                   are swapped, nums1 becomes [2,3,4,5,4], and nums2 becomes
                   [8,8,4,4,9].
                 - Another operation using index i = 3. When nums1[3] and
                   nums2[3] are swapped, nums1 becomes [2,3,4,4,4], and nums2
                   becomes [8,8,4,5,9].
                 Both conditions are now satisfied. It can be shown that the
                 minimum number of operations needed to be performed is 2. So,
                 the answer is 2.

    Example 3:
    Input: nums1 = [1,5,4], nums2 = [2,5,3]
    Output: -1
    Explanation: In this example, it is not possible to satisfy both conditions.
                 So, the answer is -1.

    Constraints:
    * 1 <= n == nums1.length == nums2.length <= 1000
    * 1 <= nums1[i] <= 10^9
    * 1 <= nums2[i] <= 10^9"""

    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
        yes = no = 0
        for x1, x2 in zip(nums1, nums2):
            if max(nums1[-1], nums2[-1]) < max(x1, x2) or min(nums1[-1], nums2[-1]) < min(x1, x2): return -1
            if nums1[-1] < x1 or nums2[-1] < x2: yes += 1
            if nums1[-1] < x2 or nums2[-1] < x1: no += 1
        return min(yes, no)


    """2935. Maximum Strong Pair XOR II (Hard)
    You are given a 0-indexed integer array nums. A pair of integers x and y is
    called a strong pair if it satisfies the condition:
    * |x - y| <= min(x, y)
    You need to select two integers from nums such that they form a strong pair
    and their bitwise XOR is the maximum among all strong pairs in the array.
    Return the maximum XOR value out of all possible strong pairs in the array
    nums. Note that you can pick the same integer twice to form a pair.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 7
    Explanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2),
                 (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5)
                 and (5, 5). The maximum XOR possible from these pairs is
                 3 XOR 4 = 7.

    Example 2:
    Input: nums = [10,100]
    Output: 0
    Explanation: There are 2 strong pairs in the array nums: (10, 10) and
                 (100, 100). The maximum XOR possible from these pairs is
                 10 XOR 10 = 0 since the pair (100, 100) also gives
                 100 XOR 100 = 0.

    Example 3:
    Input: nums = [500,520,2500,3000]
    Output: 1020
    Explanation: There are 6 strong pairs in the array nums: (500, 500),
                 (500, 520), (520, 520), (2500, 2500), (2500, 3000) and
                 (3000, 3000). The maximum XOR possible from these pairs is
                 500 XOR 520 = 1020 since the only other non-zero XOR value is
                 2500 XOR 3000 = 636.

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 1 <= nums[i] <= 2^20 - 1"""

    def maximumStrongPairXor(self, nums: List[int]) -> int:
        nums.sort()
        trie = {}
        ans = k = 0
        for x in nums:
            node = trie
            bits = list(map(int, bin(x)[2:].zfill(20)))
            for b in bits:
                node = node.setdefault(b, {})
                node["#"] = node.get("#", 0) + 1
            node["$"] = x
            while 2*nums[k] < x:
                node = trie
                for b in map(int, bin(nums[k])[2:].zfill(20)):
                    node[b]["#"] -= 1
                    if node[b]["#"] == 0:
                        node.pop(b)
                        break
                    node = node[b]
                k += 1
            node = trie
            for b in bits:
                if 1^b in node: node = node[1^b]
                else: node = node[b]
            ans = max(ans, x ^ node["$"])
        return ans


    """2936. Number of Equal Numbers Blocks (Medium)
    You are given a 0-indexed array of integers, nums. The following property
    holds for nums:
    * All occurrences of a value are adjacent. In other words, if there are two
      indices i < j such that nums[i] == nums[j], then for every index k that
      i < k < j, nums[k] == nums[i].
    Since nums is a very large array, you are given an instance of the class
    BigArray which has the following functions:
    * int at(long long index): Returns the value of nums[i].
    * void size(): Returns nums.length.
    Let's partition the array into maximal blocks such that each block contains
    equal values. Return the number of these blocks. Note that if you want to
    test your solution using a custom test, behavior for tests with
    nums.length > 10 is undefined.

    Example 1:
    Input: nums = [3,3,3,3,3]
    Output: 1
    Explanation: There is only one block here which is the whole array (because
                 all numbers are equal) and that is: [3,3,3,3,3]. So the answer
                 would be 1.

    Example 2:
    Input: nums = [1,1,1,3,9,9,9,2,10,10]
    Output: 5
    Explanation: There are 5 blocks here:
    Block number 1: [1,1,1,3,9,9,9,2,10,10]
    Block number 2: [1,1,1,3,9,9,9,2,10,10]
    Block number 3: [1,1,1,3,9,9,9,2,10,10]
    Block number 4: [1,1,1,3,9,9,9,2,10,10]
    Block number 5: [1,1,1,3,9,9,9,2,10,10]
    So the answer would be 5.

    Example 3:
    Input: nums = [1,2,3,4,5,6,7]
    Output: 7
    Explanation: Since all numbers are distinct, there are 7 blocks here and
                 each element representing one block. So the answer would be 7.

    Constraints:
    * 1 <= nums.length <= 10^15
    * 1 <= nums[i] <= 10^9
    * The input is generated such that all equal values are adjacent.
    * The sum of the elements of nums is at most 10^15."""

    def countBlocks(self, nums: Optional['BigArray']) -> int:

        def fn(lo, hi):
            """Return number of equal blocks between lo and hi (inclusive)."""
            if lo == hi or nums.at(lo) == nums.at(hi): return 1
            mid = lo + hi >> 1
            ans = fn(lo, mid) + fn(mid+1, hi)
            if nums.at(mid) == nums.at(mid+1): ans -= 1
            return ans

        return fn(0, nums.size()-1)


    """2937. Make Three Strings Equal (Easy)
    You are given three strings s1, s2, and s3. You have to perform the
    following operation on these three strings as many times as you want. In
    one operation you can choose one of these three strings such that its
    length is at least 2 and delete the rightmost character of it. Return the
    minimum number of operations you need to perform to make the three strings
    equal if there is a way to make them equal, otherwise, return -1.

    Example 1:
    Input: s1 = "abc", s2 = "abb", s3 = "ab"
    Output: 2
    Explanation: Performing operations on s1 and s2 once will lead to three
                 equal strings. It can be shown that there is no way to make
                 them equal with less than two operations.

    Example 2:
    Input: s1 = "dac", s2 = "bac", s3 = "cac"
    Output: -1
    Explanation: Because the leftmost letters of s1 and s2 are not equal, they
                 could not be equal after any number of operations. So the
                 answer is -1.

    Constraints:
    * 1 <= s1.length, s2.length, s3.length <= 100
    * s1, s2 and s3 consist only of lowercase English letters."""

    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:
        for i, (c1, c2, c3) in enumerate(zip(s1, s2, s3)):
            if not c1 == c2 == c3: break
        else: i += 1
        return len(s1) + len(s2) + len(s3) - 3*i if i else -1


    """2938. Separate Black and White Balls (Medium)
    There are n balls on a table, each ball has a color black or white. You are
    given a 0-indexed binary string s of length n, where 1 and 0 represent
    black and white balls, respectively. In each step, you can choose two
    adjacent balls and swap them. Return the minimum number of steps to group
    all the black balls to the right and all the white balls to the left.

    Example 1:
    Input: s = "101"
    Output: 1
    Explanation: We can group all the black balls to the right in the following
                 way:
                 - Swap s[0] and s[1], s = "011".
                 Initially, 1s are not grouped together, requiring at least 1
                 step to group them to the right.

    Example 2:
    Input: s = "100"
    Output: 2
    Explanation: We can group all the black balls to the right in the following
                 way:
                 - Swap s[0] and s[1], s = "010".
                 - Swap s[1] and s[2], s = "001".
                 It can be proven that the minimum number of steps needed is 2.

    Example 3:
    Input: s = "0111"
    Output: 0
    Explanation: All the black balls are already grouped to the right.

    Constraints:
    * 1 <= n == s.length <= 10^5
    * s[i] is either '0' or '1'."""

    def minimumSteps(self, s: str) -> int:
        ans = prefix = 0
        for ch in s:
            if ch == "1": prefix += 1
            else: ans += prefix
        return ans


    """2939. Maximum Xor Product (Medium)
    Given three integers a, b, and n, return the maximum value of
    (a XOR x) * (b XOR x) where 0 <= x < 2n. Since the answer may be too large,
    return it modulo 10^9 + 7. Note that XOR is the bitwise XOR operation.

    Example 1:
    Input: a = 12, b = 5, n = 4
    Output: 98
    Explanation: For x = 2, (a XOR x) = 14 and (b XOR x) = 7. Hence,
                 (a XOR x) * (b XOR x) = 98. It can be shown that 98 is the
                 maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.

    Example 2:
    Input: a = 6, b = 7 , n = 5
    Output: 930
    Explanation: For x = 25, (a XOR x) = 31 and (b XOR x) = 30. Hence,
                 (a XOR x) * (b XOR x) = 930. It can be shown that 930 is the
                 maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.

    Example 3:
    Input: a = 1, b = 6, n = 3
    Output: 12
    Explanation: For x = 5, (a XOR x) = 4 and (b XOR x) = 3. Hence,
                 (a XOR x) * (b XOR x) = 12. It can be shown that 12 is the
                 maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.

    Constraints:
    * 0 <= a, b < 2^50
    * 0 <= n <= 50"""

    def maximumXorProduct(self, a: int, b: int, n: int) -> int:
        for i in range(n-1, -1, -1):
            if not min(a, b) & 1<<i:
                a ^= 1<<i
                b ^= 1<<i
        return a*b % 1_000_000_007


    """2940. Find Building Where Alice and Bob Can Meet (Hard)
    You are given a 0-indexed array heights of positive integers, where
    heights[i] represents the height of the ith building. If a person is in
    building i, they can move to any other building j if and only if i < j and
    heights[i] < heights[j]. You are also given another array queries where
    queries[i] = [ai, bi]. On the ith query, Alice is in building ai while Bob
    is in building bi. Return an array ans where ans[i] is the index of the
    leftmost building where Alice and Bob can meet on the ith query. If Alice
    and Bob cannot move to a common building on query i, set ans[i] to -1.

    Example 1:
    Input: heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]
    Output: [2,5,-1,5,2]
    Explanation: - In the first query, Alice and Bob can move to building 2
                   since heights[0] < heights[2] and heights[1] < heights[2].
                 - In the second query, Alice and Bob can move to building 5
                   since heights[0] < heights[5] and heights[3] < heights[5].
                 - In the third query, Alice cannot meet Bob since Alice cannot
                   move to any other building.
                 - In the fourth query, Alice and Bob can move to building 5
                   since heights[3] < heights[5] and heights[4] < heights[5].
                 - In the fifth query, Alice and Bob are already in the same
                   building.
                 For ans[i] != -1, It can be shown that ans[i] is the leftmost
                 building where Alice and Bob can meet. For ans[i] == -1, It
                 can be shown that there is no building where Alice and Bob can
                 meet.

    Example 2:
    Input: heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]
    Output: [7,6,-1,4,6]
    Explanation: - In the first query, Alice can directly move to Bob's
                   building since heights[0] < heights[7].
                 - In the second query, Alice and Bob can move to building 6
                   since heights[3] < heights[6] and heights[5] < heights[6].
                 - In the third query, Alice cannot meet Bob since Bob cannot
                   move to any other building.
                 - In the fourth query, Alice and Bob can move to building 4
                   since heights[3] < heights[4] and heights[0] < heights[4].
                 - In the fifth query, Alice can directly move to Bob's
                   building since heights[1] < heights[6].
                 For ans[i] != -1, It can be shown that ans[i] is the leftmost
                 building where Alice and Bob can meet. For ans[i] == -1, It
                 can be shown that there is no building where Alice and Bob can
                 meet.

    Constraints:
    * 1 <= heights.length <= 5 * 10^4
    * 1 <= heights[i] <= 10^9
    * 1 <= queries.length <= 5 * 10^4
    * queries[i] = [ai, bi]
    * 0 <= ai, bi <= heights.length - 1"""

    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:
        qs = [[] for _ in heights]
        ans = [-1] * len(queries)
        for i, (a, b) in enumerate(queries):
            if a > b: a, b = b, a
            if a == b or heights[a] < heights[b]: ans[i] = b
            else: qs[b].append((heights[a], i))
        pq = []
        for k, x in enumerate(heights):
            while pq and pq[0][0] < x:
                _, i = heappop(pq)
                ans[i] = k
            for elem in qs[k]: heappush(pq, elem)
        return ans


    """2942. Find Words Containing Character (Easy)
    You are given a 0-indexed array of strings words and a character x. Return
    an array of indices representing the words that contain the character x.
    Note that the returned array may be in any order.

    Example 1:
    Input: words = ["leet","code"], x = "e"
    Output: [0,1]
    Explanation: "e" occurs in both words: "leet", and "code". Hence, we return
                 indices 0 and 1.

    Example 2:
    Input: words = ["abc","bcd","aaaa","cbc"], x = "a"
    Output: [0,2]
    Explanation: "a" occurs in "abc", and "aaaa". Hence, we return indices 0 and
                 2.

    Example 3:
    Input: words = ["abc","bcd","aaaa","cbc"], x = "z"
    Output: []
    Explanation: "z" does not occur in any of the words. Hence, we return an
                 empty array.

    Constraints:
    * 1 <= words.length <= 50
    * 1 <= words[i].length <= 50
    * x is a lowercase English letter.
    * words[i] consists only of lowercase English letters."""

    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        return [i for i, w in enumerate(words) if x in w]


    """2946. Matrix Similarity After Cyclic Shifts (Easy)
    You are given a 0-indexed m x n integer matrix mat and an integer k. You
    have to cyclically right shift odd indexed rows k times and cyclically left
    shift even indexed rows k times. Return true if the initial and final
    matrix are exactly the same and false otherwise.

    Example 1:
    Input: mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2
    Output: true
    Explanation: Initially, the matrix looks like the first figure. Second
                 figure represents the state of the matrix after one right and
                 left cyclic shifts to even and odd indexed rows. Third figure
                 is the final state of the matrix after two cyclic shifts which
                 is similar to the initial matrix. Therefore, return true.

    Example 2:
    Input: mat = [[2,2],[2,2]], k = 3
    Output: true
    Explanation: As all the values are equal in the matrix, even after
                 performing cyclic shifts the matrix will remain the same.
                 Therefeore, we return true.

    Example 3:
    Input: mat = [[1,2]], k = 1
    Output: false
    Explanation: After one cyclic shift, mat = [[2,1]] which is not equal to
                 the initial matrix. Therefore we return false.

    Constraints:
    * 1 <= mat.length <= 25
    * 1 <= mat[i].length <= 25
    * 1 <= mat[i][j] <= 25
    * 1 <= k <= 50"""

    def areSimilar(self, mat: List[List[int]], k: int) -> bool:
        n = len(mat[0])
        for row in mat:
            for j in range(n):
                if row[j] != row[(j+k) % n]: return False
        return True


    """2947. Count Beautiful Substrings I (Medium)
    You are given a string s and a positive integer k. Let vowels and
    consonants be the number of vowels and consonants in a string. A string is
    beautiful if:
    * vowels == consonants.
    * (vowels * consonants) % k == 0, in other terms the multiplication of
      vowels and consonants is divisible by k.
    Return the number of non-empty beautiful substrings in the given string s.
    A substring is a contiguous sequence of characters in a string. Vowel
    letters in English are 'a', 'e', 'i', 'o', and 'u'. Consonant letters in
    English are every letter except vowels.

    Example 1:
    Input: s = "baeyh", k = 2
    Output: 2
    Explanation: There are 2 beautiful substrings in the given string.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["y","h"]). You can see that string "aeyh"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["b","y"]). You can see that string "baey"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 It can be shown that there are only 2 beautiful substrings in
                 the given string.

    Example 2:
    Input: s = "abba", k = 1
    Output: 3
    Explanation: There are 3 beautiful substrings in the given string.
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 2 (["a","a"]),
                   consonants = 2 (["b","b"]).
                 It can be shown that there are only 3 beautiful substrings in
                 the given string.

    Example 3:
    Input: s = "bcdf", k = 1
    Output: 0
    Explanation: There are no beautiful substrings in the given string.

    Constraints:
    * 1 <= s.length <= 1000
    * 1 <= k <= 1000
    * s consists of only English lowercase letters."""

    def beautifulSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        ans = 0
        for i in range(n):
            vowels = consonants = 0
            for j in range(i, n):
                if s[j] in "aeiou": vowels += 1
                else: consonants += 1
                if vowels == consonants and vowels * consonants % k == 0: ans += 1
        return ans


    """2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)
    You are given a 0-indexed array of positive integers nums and a positive
    integer limit. In one operation, you can choose any two indices i and j and
    swap nums[i] and nums[j] if |nums[i] - nums[j]| <= limit. Return the
    lexicographically smallest array that can be obtained by performing the
    operation any number of times. An array a is lexicographically smaller than
    an array b if in the first position where a and b differ, array a has an
    element that is less than the corresponding element in b. For example, the
    array [2,10,3] is lexicographically smaller than the array [10,2,3] because
    they differ at index 0 and 2 < 10.

    Example 1:
    Input: nums = [1,5,3,9,8], limit = 2
    Output: [1,3,5,8,9]
    Explanation: Apply the operation 2 times:
                 - Swap nums[1] with nums[2]. The array becomes [1,3,5,9,8]
                 - Swap nums[3] with nums[4]. The array becomes [1,3,5,8,9]
                 We cannot obtain a lexicographically smaller array by applying
                 any more operations. Note that it may be possible to get the
                 same result by doing different operations.

    Example 2:
    Input: nums = [1,7,6,18,2,1], limit = 3
    Output: [1,6,7,18,1,2]
    Explanation: Apply the operation 3 times:
                 - Swap nums[1] with nums[2]. The array becomes [1,6,7,18,2,1]
                 - Swap nums[0] with nums[4]. The array becomes [2,6,7,18,1,1]
                 - Swap nums[0] with nums[5]. The array becomes [1,6,7,18,1,2]
                 We cannot obtain a lexicographically smaller array by applying
                 any more operations.

    Example 3:
    Input: nums = [1,7,28,19,10], limit = 3
    Output: [1,7,28,19,10]
    Explanation: [1,7,28,19,10] is the lexicographically smallest array we can
                 obtain because we cannot apply the operation on any two
                 indices.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= limit <= 10^9"""

    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
        vals = sorted(list(enumerate(nums)), key=lambda x: x[1])
        idx = []
        kk = 0
        for k, (i, x) in enumerate(vals):
            idx.append(i)
            if k == len(vals)-1 or x+limit < vals[k+1][1]:
                for i, j in zip(sorted(idx), range(kk, k+1)): nums[i] = vals[j][1]
                idx.clear()
                kk = k+1
        return nums


    """2949. Count Beautiful Substrings II (Hard)
    You are given a string s and a positive integer k. Let vowels and
    consonants be the number of vowels and consonants in a string. A string is
    beautiful if:
    * vowels == consonants.
    * (vowels * consonants) % k == 0, in other terms the multiplication of
      vowels and consonants is divisible by k.
    Return the number of non-empty beautiful substrings in the given string s.
    A substring is a contiguous sequence of characters in a string. Vowel
    letters in English are 'a', 'e', 'i', 'o', and 'u'. Consonant letters in
    English are every letter except vowels.

    Example 1:
    Input: s = "baeyh", k = 2
    Output: 2
    Explanation: There are 2 beautiful substrings in the given string.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["y","h"]). You can see that string "aeyh"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["b","y"]). You can see that string "baey"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 It can be shown that there are only 2 beautiful substrings in
                 the given string.

    Example 2:
    Input: s = "abba", k = 1
    Output: 3
    Explanation: There are 3 beautiful substrings in the given string.
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 2 (["a","a"]), consonants = 2
                   (["b","b"]).
                 It can be shown that there are only 3 beautiful substrings in
                 the given string.

    Example 3:
    Input: s = "bcdf", k = 1
    Output: 0
    Explanation: There are no beautiful substrings in the given string.

    Constraints:
    * 1 <= s.length <= 5 * 10^4
    * 1 <= k <= 1000
    * s consists of only English lowercase letters."""

    def beautifulSubstrings(self, s: str, k: int) -> int:
        n = 2*next(x for x in range(1, k+1) if x*x % k == 0)
        seen = [Counter() for _ in range(n)]
        seen[-1][0] = 1
        ans = diff = 0
        for i, ch in enumerate(s):
            if ch in "aeiou": diff += 1
            else: diff -= 1
            ans += seen[i % n][diff]
            seen[i % n][diff] += 1
            print(i%n, diff, ans, seen)
        return ans


    """2950. Number of Divisible Substrings (Medium)
    Each character of the English alphabet has been mapped to a digit as shown
    below. A string is divisible if the sum of the mapped values of its
    characters is divisible by its length. Given a string s, return the number
    of divisible substrings of s. A substring is a contiguous non-empty sequence
    of characters within a string.

    Example 1: Substring   Mapped  Sum Length  Divisible?
               a   1   1   1   Yes
               s   7   7   1   Yes
               d   2   2   1   Yes
               f   3   3   1   Yes
               as  1, 7    8   2   Yes
               sd  7, 2    9   2   No
               df  2, 3    5   2   No
               asd 1, 7, 2 10  3   No
               sdf 7, 2, 3 12  3   Yes
               asdf    1, 7, 2, 3  13  4   No
    Input: word = "asdf"
    Output: 6
    Explanation: The table above contains the details about every substring of
                 word, and we can see that 6 of them are divisible.

    Example 2:
    Input: word = "bdh"
    Output: 4
    Explanation: The 4 divisible substrings are: "b", "d", "h", "bdh". It can be
                 shown that there are no other substrings of word that are
                 divisible.

    Example 3:
    Input: word = "abcd"
    Output: 6
    Explanation: The 6 divisible substrings are: "a", "b", "c", "d", "ab", "cd".
                 It can be shown that there are no other substrings of word that
                 are divisible.

    Constraints:
    * 1 <= word.length <= 2000
    * word consists only of lowercase English letters."""

    def countDivisibleSubstrings(self, word: str) -> int:
        ans = 0
        for k in range(1, 10):
            prefix = 0
            freq = Counter({ 0 : 1 })
            for i, ch in enumerate(word, 1):
                prefix += 2+(ord(ch)-99)//3
                ans += freq[prefix - k*i]
                freq[prefix-k*i] += 1
        return ans


    """"2955. Number of Same-End Substrings (Medium)
    You are given a 0-indexed string s, and a 2D array of integers queries,
    where queries[i] = [li, ri] indicates a substring of s starting from the
    index li and ending at the index ri (both inclusive), i.e. s[li..ri]. Return
    an array ans where ans[i] is the number of same-end substrings of queries[i].
    A 0-indexed string t of length n is called same-end if it has the same
    character at both of its ends, i.e., t[0] == t[n - 1]. A substring is a
    contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: s = "abcaab", queries = [[0,0],[1,4],[2,5],[0,5]]
    Output: [1,5,5,10]
    Explanation: Here is the same-end substrings of each query:
                 - 1st query: s[0..0] is "a" which has 1 same-end substring: "a".
                 - 2nd query: s[1..4] is "bcaa" which has 5 same-end substrings:
                   "bcaa", "bcaa", "bcaa", "bcaa", "bcaa".
                 - 3rd query: s[2..5] is "caab" which has 5 same-end substrings:
                   "caab", "caab", "caab", "caab", "caab".
                 - 4th query: s[0..5] is "abcaab" which has 10 same-end
                   substrings: "abcaab", "abcaab", "abcaab", "abcaab", "abcaab",
                   "abcaab", "abcaab", "abcaab", "abcaab", "abcaab".

    Example 2:
    Input: s = "abcd", queries = [[0,3]]
    Output: [4]
    Explanation: The only query is s[0..3] which is "abcd". It has 4 same-end
                 substrings: "abcd", "abcd", "abcd", "abcd".

    Constraints:
    * 2 <= s.length <= 3 * 10^4
    * s consists only of lowercase English letters.
    * 1 <= queries.length <= 3 * 10^4
    * queries[i] = [li, ri]
    * 0 <= li <= ri < s.length"""

    def sameEndSubstringCount(self, s: str, queries: List[List[int]]) -> List[int]:
        ans = [0]*len(queries)
        for c in ascii_lowercase:
            prefix = [0]
            for ch in s:
                prefix.append(prefix[-1])
                if ch == c: prefix[-1] += 1
            for i, (l, r) in enumerate(queries):
                diff = prefix[r+1] - prefix[l]
                ans[i] += diff*(diff+1)//2
        return ans


    """2956. Find Common Elements Between Two Arrays (Easy)
    You are given two 0-indexed integer arrays nums1 and nums2 of sizes n and m,
    respectively. Consider calculating the following values:
    * The number of indices i such that 0 <= i < n and nums1[i] occurs at least
      once in nums2.
    * The number of indices i such that 0 <= i < m and nums2[i] occurs at least
      once in nums1.
    Return an integer array answer of size 2 containing the two values in the
    above order.

    Example 1:
    Input: nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]
    Output: [3,4]
    Explanation: We calculate the values as follows:
                 - The elements at indices 1, 2, and 3 in nums1 occur at least
                   once in nums2. So the first value is 3.
                 - The elements at indices 0, 1, 3, and 4 in nums2 occur at
                   least once in nums1. So the second value is 4.

    Example 2:
    Input: nums1 = [3,4,2,3], nums2 = [1,5]
    Output: [0,0]
    Explanation: There are no common elements between the two arrays, so the two
                 values will be 0.

    Constraints:
    * n == nums1.length
    * m == nums2.length
    * 1 <= n, m <= 100
    * 1 <= nums1[i], nums2[i] <= 100"""

    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:
        ans = [0, 0]
        for x in nums1:
            if x in nums2: ans[0] += 1
        for x in nums2:
            if x in nums1: ans[1] += 1
        return ans


    """2957. Remove Adjacent Almost-Equal Characters (Medium)
    You are given a 0-indexed string word. In one operation, you can pick any
    index i of word and change word[i] to any lowercase English letter. Return
    the minimum number of operations needed to remove all adjacent almost-equal
    characters from word. Two characters a and b are almost-equal if a == b or
    a and b are adjacent in the alphabet.

    Example 1:
    Input: word = "aaaaa"
    Output: 2
    Explanation: We can change word into "acaca" which does not have any
                 adjacent almost-equal characters. It can be shown that the
                 minimum number of operations needed to remove all adjacent
                 almost-equal characters from word is 2.

    Example 2:
    Input: word = "abddez"
    Output: 2
    Explanation: We can change word into "ybdoez" which does not have any
                 adjacent almost-equal characters. It can be shown that the
                 minimum number of operations needed to remove all adjacent
                 almost-equal characters from word is 2.

    Example 3:
    Input: word = "zyxyxyz"
    Output: 3
    Explanation: We can change word into "zaxaxaz" which does not have any
                 adjacent almost-equal characters. It can be shown that the
                 minimum number of operations needed to remove all adjacent
                 almost-equal characters from word is 3.

    Constraints:
    * 1 <= word.length <= 100
    * word consists only of lowercase English letters."""

    def removeAlmostEqualCharacters(self, word: str) -> int:
        ans = skip = 0
        for i in range(1, len(word)):
            if skip: skip = 0
            elif abs(ord(word[i-1]) - ord(word[i])) <= 1:
                ans += 1
                skip = 1
        return ans


    """2958. Length of Longest Subarray With at Most K Frequency (Medium)
    You are given an integer array nums and an integer k. The frequency of an
    element x is the number of times it occurs in an array. An array is called
    good if the frequency of each element in this array is less than or equal to
    k. Return the length of the longest good subarray of nums. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,3,1,2,3,1,2], k = 2
    Output: 6
    Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the
                 values 1, 2, and 3 occur at most twice in this subarray. Note
                 that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also
                 good. It can be shown that there are no good subarrays with
                 length more than 6.

    Example 2:
    Input: nums = [1,2,1,2,1,2,1,2], k = 1
    Output: 2
    Explanation: The longest possible good subarray is [1,2] since the values 1
                 and 2 occur at most once in this subarray. Note that the
                 subarray [2,1] is also good. It can be shown that there are no
                 good subarrays with length more than 2.

    Example 3:
    Input: nums = [5,5,5,5,5,5,5], k = 4
    Output: 4
    Explanation: The longest possible good subarray is [5,5,5,5] since the value
                 5 occurs 4 times in this subarray. It can be shown that there
                 are no good subarrays with length more than 4.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= nums.length"""

    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        freq = defaultdict(int)
        ans = ii = 0
        for i, x in enumerate(nums):
            freq[x] += 1
            while freq[x] > k:
                freq[nums[ii]] -= 1
                ii += 1
            ans = max(ans, i-ii+1)
        return ans


    """2959. Number of Possible Sets of Closing Branches (Hard)
    There is a company with n branches across the country, some of which are
    connected by roads. Initially, all branches are reachable from each other by
    traveling some roads. The company has realized that they are spending an
    excessive amount of time traveling between their branches. As a result, they
    have decided to close down some of these branches (possibly none). However,
    they want to ensure that the remaining branches have a distance of at most
    maxDistance from each other. The distance between two branches is the
    minimum total traveled length needed to reach one branch from another. You
    are given integers n, maxDistance, and a 0-indexed 2D array roads, where
    roads[i] = [ui, vi, wi] represents the undirected road between branches ui
    and vi with length wi. Return the number of possible sets of closing
    branches, so that any branch has a distance of at most maxDistance from any
    other. Note that, after closing a branch, the company will no longer have
    access to any roads connected to it. Note that, multiple roads are allowed.

    Example 1:
    Input: n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]
    Output: 5
    Explanation: The possible sets of closing branches are:
                 - The set [2], after closing, active branches are [0,1] and
                   they are reachable to each other within distance 2.
                 - The set [0,1], after closing, the active branch is [2].
                 - The set [1,2], after closing, the active branch is [0].
                 - The set [0,2], after closing, the active branch is [1].
                 - The set [0,1,2], after closing, there are no active branches.
                 It can be proven, that there are only 5 possible sets of
                 closing branches.

    Example 2:
    Input: n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]
    Output: 7
    Explanation: The possible sets of closing branches are:
                 - The set [], after closing, active branches are [0,1,2] and
                   they are reachable to each other within distance 4.
                 - The set [0], after closing, active branches are [1,2] and
                   they are reachable to each other within distance 2.
                 - The set [1], after closing, active branches are [0,2] and
                   they are reachable to each other within distance 2.
                 - The set [0,1], after closing, the active branch is [2].
                 - The set [1,2], after closing, the active branch is [0].
                 - The set [0,2], after closing, the active branch is [1].
                 - The set [0,1,2], after closing, there are no active branches.
                 It can be proven, that there are only 7 possible sets of
                 closing branches.

    Example 3:
    Input: n = 1, maxDistance = 10, roads = []
    Output: 2
    Explanation: The possible sets of closing branches are:
                 - The set [], after closing, the active branch is [0].
                 - The set [0], after closing, there are no active branches.
                 It can be proven, that there are only 2 possible sets of
                 closing branches.

    Constraints:
    * 1 <= n <= 10
    * 1 <= maxDistance <= 10^5
    * 0 <= roads.length <= 1000
    * roads[i].length == 3
    * 0 <= ui, vi <= n - 1
    * ui != vi
    * 1 <= wi <= 1000
    * All branches are reachable from each other by traveling some roads."""

    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:
        ans = 0
        for m in range(1<<n):
            dist = [[inf]*n for _ in range(n)]
            for u in range(n):
                if m & 1<<u: dist[u][u] = 0
            for u, v, w in roads:
                if m & 1<<u and m & 1<<v:
                    dist[u][v] = dist[v][u] = min(dist[v][u], w)
            for k in range(n):
                for u in range(n):
                    for v in range(n):
                        dist[u][v] = min(dist[u][v], dist[u][k] + dist[k][v])
            for u in range(n):
                if m & 1<<u:
                    for v in range(n):
                        if m & 1<<v and dist[u][v] > maxDistance: break
                    else: continue
                    break
            else: ans += 1
        return ans


    """2960. Count Tested Devices After Test Operations (Easy)
    You are given a 0-indexed integer array batteryPercentages having length n,
    denoting the battery percentages of n 0-indexed devices. Your task is to
    test each device i in order from 0 to n - 1, by performing the following
    test operations:
    * If batteryPercentages[i] is greater than 0:
      + Increment the count of tested devices.
      + Decrease the battery percentage of all devices with indices j in the
        range [i + 1, n - 1] by 1, ensuring their battery percentage never goes
        below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).
      + Move to the next device.
    * Otherwise, move to the next device without performing any test.
    Return an integer denoting the number of devices that will be tested after
    performing the test operations in order.

    Example 1:
    Input: batteryPercentages = [1,1,2,1,3]
    Output: 3
    Explanation: Performing the test operations in order starting from device 0:
                 - At device 1, batteryPercentages [1] == 0, so we move to the
                   next device without testing.
                 - At device 2, batteryPercentages[2] > 0, so there are now 2
                   tested devices, and batteryPercentages becomes [1,0,1,0,1].
                 - At device 3, batteryPercentages [3] == 0, so we move to the
                   next device without testing.
                 - At device 0, batteryPercentages[0] > 0, so there is now 1
                   tested device, and batteryPercentages becomes [1,0,1,0,2].
                 - At device 4, batteryPercentages[4] > 0, so there are now 3
                   tested devices, and batteryPercentages stays the same.
                 So, the answer is 3.

    Example 2:
    Input: batteryPercentages = [0,1,2]
    Output: 2
    Explanation: Performing the test operations in order starting from device 0:
                 - At device 0, batteryPercentages[0] == 0, so we move to the
                   next device without testing.
                 - At device 1, batteryPercentages[1] > 0, so there is now 1
                   tested device, and batteryPercentages becomes [0,1,1].
                 - At device 2, batteryPercentages [2] > 0, so there are now 2
                   tested devices, and batteryPercentages stays the same.
                 So, the answer is 2.

    Constraints:
    * 1 <= n == batteryPercentages.length <= 100
    * 0 <= batteryPercentages[i] <= 100"""

    def countTestedDevices(self, batteryPercentages: List[int]) -> int:
        ans = 0
        for x in batteryPercentages:
            if ans < x: ans += 1
        return ans


    """2961. Double Modular Exponentiation (Medium)
    You are given a 0-indexed 2D array variables where
    variables[i] = [ai, bi, ci, mi], and an integer target. An index i is good
    if the following formula holds:
    * 0 <= i < variables.length
    * ((aibi % 10)ci) % mi == target
    Return an array consisting of good indices in any order.

    Example 1:
    Input: variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2
    Output: [0,2]
    Explanation: For each index i in the variables array:
                 1) For the index 0, variables[0] = [2,3,3,10],
                    (23 % 10)3 % 10 = 2.
                 2) For the index 1, variables[1] = [3,3,3,1],
                    (33 % 10)3 % 1 = 0.
                 3) For the index 2, variables[2] = [6,1,1,4],
                    (61 % 10)1 % 4 = 2.
                 Therefore we return [0,2] as the answer.

    Example 2:
    Input: variables = [[39,3,1000,1000]], target = 17
    Output: []
    Explanation: For each index i in the variables array:
                 1) For the index 0, variables[0] = [39,3,1000,1000],
                    (393 % 10)1000 % 1000 = 1.
                 Therefore we return [] as the answer.

    Constraints:
    * 1 <= variables.length <= 100
    * variables[i] == [ai, bi, ci, mi]
    * 1 <= ai, bi, ci, mi <= 10^3
    * 0 <= target <= 10^3"""

    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:
        ans = []
        for i, (a, b, c, m) in enumerate(variables):
            if pow(pow(a, b, 10), c, m) == target: ans.append(i)
        return ans


    """2962. Count Subarrays Where Max Element Appears at Least K Times (Meidum)
    You are given an integer array nums and a positive integer k. Return the
    number of subarrays where the maximum element of nums appears at least k
    times in that subarray. A subarray is a contiguous sequence of elements
    within an array.

    Example 1:
    Input: nums = [1,3,2,3,3], k = 2
    Output: 6
    Explanation: The subarrays that contain the element 3 at least 2 times are:
                 [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].

    Example 2:
    Input: nums = [1,4,2,1], k = 3
    Output: 0
    Explanation: No subarray contains the element 4 at least 3 times.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6
    * 1 <= k <= 10^5"""

    def countSubarrays(self, nums: List[int], k: int) -> int:
        m = max(nums)
        ans = ii = freq = 0
        for x in nums:
            if x == m: freq += 1
            while freq == k:
                if nums[ii] == m: freq -= 1
                ii += 1
            ans += ii
        return ans


    """2963. Count the Number of Good Partitions (Hard)
    You are given a 0-indexed array nums consisting of positive integers. A
    partition of an array into one or more contiguous subarrays is called good
    if no two subarrays contain the same number. Return the total number of good
    partitions of nums. Since the answer may be large, return it modulo
    10^9 + 7.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 8
    Explanation: The 8 possible good partitions are: ([1], [2], [3], [4]),
                 ([1], [2], [3,4]), ([1], [2,3], [4]), ([1], [2,3,4]),
                 ([1,2], [3], [4]), ([1,2], [3,4]), ([1,2,3], [4]), and
                 ([1,2,3,4]).

    Example 2:
    Input: nums = [1,1,1,1]
    Output: 1
    Explanation: The only possible good partition is: ([1,1,1,1]).

    Example 3:
    Input: nums = [1,2,1,3]
    Output: 2
    Explanation: The 2 possible good partitions are: ([1,2,1], [3]) and
                 ([1,2,1,3]).

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def numberOfGoodPartitions(self, nums: List[int]) -> int:
        last = {x : i for i, x in enumerate(nums)}
        ii = p = 0
        for i, x in enumerate(nums):
            if ii < i: p += 1
            ii = max(ii, last[x])
        return pow(2, p, 1_000_000_007)


    """2964. Number of Divisible Triplet Sums (Medium)
    Given a 0-indexed integer array nums and an integer d, return the number of
    triplets (i, j, k) such that i < j < k and
    (nums[i] + nums[j] + nums[k]) % d == 0.

    Example 1:
    Input: nums = [3,3,4,7,8], d = 5
    Output: 3
    Explanation: The triplets which are divisible by 5 are: (0, 1, 2),
                 (0, 2, 4), (1, 2, 4). It can be shown that no other triplet is
                 divisible by 5. Hence, the answer is 3.

    Example 2:
    Input: nums = [3,3,3,3], d = 3
    Output: 4
    Explanation: Any triplet chosen here has a sum of 9, which is divisible by
                 3. Hence, the answer is the total number of triplets which is 4.

    Example 3:
    Input: nums = [3,3,3,3], d = 6
    Output: 0
    Explanation: Any triplet chosen here has a sum of 9, which is not divisible
                 by 6. Hence, the answer is 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^9
    * 1 <= d <= 10^9"""

    def divisibleTripletCount(self, nums: List[int], d: int) -> int:
        ans = 0
        for i, x in enumerate(nums):
            freq = Counter()
            for ii in range(i+1, len(nums)):
                ans += freq[-nums[ii]%d]
                freq[(x + nums[ii]) % d] += 1
        return ans


    """2965. Find Missing and Repeated Values (Easy)
    You are given a 0-indexed 2D integer matrix grid of size n * n with values
    in the range [1, n2]. Each integer appears exactly once except a which
    appears twice and b which is missing. The task is to find the repeating and
    missing numbers a and b. Return a 0-indexed integer array ans of size 2
    where ans[0] equals to a and ans[1] equals to b.

    Example 1:
    Input: grid = [[1,3],[2,2]]
    Output: [2,4]
    Explanation: Number 2 is repeated and number 4 is missing so the answer is
                 [2,4].

    Example 2:
    Input: grid = [[9,1,7],[8,9,2],[3,4,6]]
    Output: [9,5]
    Explanation: Number 9 is repeated and number 5 is missing so the answer is
                 [9,5].

    Constraints:
    * 2 <= n == grid.length == grid[i].length <= 50
    * 1 <= grid[i][j] <= n * n
    * For all x that 1 <= x <= n * n there is exactly one x that is not equal to
      any of the grid members.
    * For all x that 1 <= x <= n * n there is exactly one x that is equal to
      exactly two of the grid members.
    * For all x that 1 <= x <= n * n except two of them there is exatly one pair
      of i, j that 0 <= i, j <= n - 1 and grid[i][j] == x."""

    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:
        s = s2 = 0
        for row in grid:
            for x in row:
                s += x
                s2 += x*x
        n = len(grid)**2
        diff = s-n*(n+1)//2
        total = (s2-n*(n+1)*(2*n+1)//6)//diff
        return [(total+diff)//2, (total-diff)//2]


    """2966. Divide Array Into Arrays With Max Difference (Medium)
    You are given an integer array nums of size n and a positive integer k.
    Divide the array into one or more arrays of size 3 satisfying the following
    conditions:
    * Each element of nums should be in exactly one array.
    * The difference between any two elements in one array is less than or equal
      to k.
    Return a 2D array containing all the arrays. If it is impossible to satisfy
    the conditions, return an empty array. And if there are multiple answers,
    return any of them.

    Example 1:
    Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
    Output: [[1,1,3],[3,4,5],[7,8,9]]
    Explanation: We can divide the array into the following arrays: [1,1,3],
                 [3,4,5] and [7,8,9]. The difference between any two elements in
                 each array is less than or equal to 2. Note that the order of
                 elements is not important.

    Example 2:
    Input: nums = [1,3,3,2,7,3], k = 3
    Output: []
    Explanation: It is not possible to divide the array satisfying all the
                 conditions.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * n is a multiple of 3.
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= 10^5"""

    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:
        nums.sort()
        ans = []
        for i in range(2, len(nums), 3):
            if nums[i] - nums[i-2] > k: return []
            ans.append(nums[i-2 : i+1])
        return ans


    """2967. Minimum Cost to Make Array Equalindromic (Medium)
    You are given a 0-indexed integer array nums having length n. You are
    allowed to perform a special move any number of times (including zero) on
    nums. In one special move you perform the following steps in order:
    * Choose an index i in the range [0, n - 1], and a positive integer x.
    * Add |nums[i] - x| to the total cost.
    * Change the value of nums[i] to x.
    A palindromic number is a positive integer that remains the same when its
    digits are reversed. For example, 121, 2552 and 65756 are palindromic
    numbers whereas 24, 46, 235 are not palindromic numbers. An array is
    considered equalindromic if all the elements in the array are equal to an
    integer y, where y is a palindromic number less than 10^9. Return an integer
    denoting the minimum possible total cost to make nums equalindromic by
    performing any number of special moves.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 6
    Explanation: We can make the array equalindromic by changing all elements to
                 3 which is a palindromic number. The cost of changing the array
                 to [3,3,3,3,3] using 4 special moves is given by
                 |1 - 3| + |2 - 3| + |4 - 3| + |5 - 3| = 6. It can be shown that
                 changing all elements to any palindromic number other than 3
                 cannot be achieved at a lower cost.

    Example 2:
    Input: nums = [10,12,13,14,15]
    Output: 11
    Explanation: We can make the array equalindromic by changing all elements to
                 11 which is a palindromic number. The cost of changing the
                 array to [11,11,11,11,11] using 5 special moves is given by
                 |10 - 11| + |12 - 11| + |13 - 11| + |14 - 11| + |15 - 11| = 11.
                 It can be shown that changing all elements to any palindromic
                 number other than 11 cannot be achieved at a lower cost.

    Example 3:
    Input: nums = [22,33,22,33,22]
    Output: 22
    Explanation: We can make the array equalindromic by changing all elements to
                 22 which is a palindromic number. The cost of changing the
                 array to [22,22,22,22,22] using 2 special moves is given by
                 |33 - 22| + |33 - 22| = 22. It can be shown that changing all
                 elements to any palindromic number other than 22 cannot be
                 achieved at a lower cost.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def minimumCost(self, nums: List[int]) -> int:
        nums.sort()
        median = nums[len(nums)//2]
        digits = str(median)
        n = len(digits)
        val = int(digits[:(n+1)//2] + digits[:n//2][::-1])
        vals = [val]
        if val < median:
            half = str(int(digits[:(n+1)//2]) + 1)
            if len(half) > (n+1)//2: cand = val+2
            else: cand = int(half + half[:-(n&1) or len(half)][::-1])
            vals.append(cand)
        elif val > median:
            half = str(int(digits[:(n+1)//2]) - 1)
            if len(half) < (n+1)//2 or half == '0' and val > 10: cand = val-2
            else: cand = int(half + half[:-(n&1) or len(half)][::-1])
            vals.append(cand)
        print(vals)
        return min(sum(abs(v-x) for x in nums) for v in vals)


    """2968. Apply Operations to Maximize Frequency Score (Hard)
    You are given a 0-indexed integer array nums and an integer k. You can
    perform the following operation on the array at most k times:
    * Choose any index i from the array and increase or decrease nums[i] by 1.
    The score of the final array is the frequency of the most frequent element
    in the array. Return the maximum score you can achieve. The frequency of an
    element is the number of occurences of that element in the array.

    Example 1:
    Input: nums = [1,2,6,4], k = 3
    Output: 3
    Explanation: We can do the following operations on the array:
                 - Choose i = 0, and increase the value of nums[0] by 1. The
                   resulting array is [2,2,6,4].
                 - Choose i = 3, and decrease the value of nums[3] by 1. The
                   resulting array is [2,2,6,3].
                 - Choose i = 3, and decrease the value of nums[3] by 1. The
                   resulting array is [2,2,6,2].
                 The element 2 is the most frequent in the final array so our
                 score is 3. It can be shown that we cannot achieve a better
                 score.

    Example 2:
    Input: nums = [1,4,4,2,4], k = 0
    Output: 3
    Explanation: We cannot apply any operations so our score will be the
                 frequency of the most frequent element in the original array,
                 which is 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= 10^14"""

    def maxFrequencyScore(self, nums: List[int], k: int) -> int:
        nums.sort()
        ii = 0
        for i, x in enumerate(nums):
            k -= x - nums[ii+i >> 1]
            if k < 0:
                k += nums[ii+i+1 >> 1] - nums[ii]
                ii += 1
        return len(nums) - ii


    """2971. Find Polygon With the Largest Perimeter (Medium)
    You are given an array of positive integers nums of length n. A polygon is a
    closed plane figure that has at least 3 sides. The longest side of a polygon
    is smaller than the sum of its other sides. Conversely, if you have k
    (k >= 3) positive real numbers a1, a2, a3, ..., ak where
    a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there
    always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.
    The perimeter of a polygon is the sum of lengths of its sides. Return the
    largest possible perimeter of a polygon whose sides can be formed from nums,
    or -1 if it is not possible to create a polygon.

    Example 1:
    Input: nums = [5,5,5]
    Output: 15
    Explanation: The only possible polygon that can be made from nums has 3
                 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.

    Example 2:
    Input: nums = [1,12,1,2,5,50,3]
    Output: 12
    Explanation: The polygon with the largest perimeter which can be made from
                 nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is
                 1 + 1 + 2 + 3 + 5 = 12. We cannot have a polygon with either 12
                 or 50 as the longest side because it is not possible to include
                 2 or more smaller sides that have a greater sum than either of
                 them. It can be shown that the largest possible perimeter is 12.

    Example 3:
    Input: nums = [5,5,50]
    Output: -1
    Explanation: There is no possible way to form a polygon from nums, as a
                 polygon has at least 3 sides and 50 > 5 + 5.

    Constraints:
    * 3 <= n <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        ans = -1
        prefix = 0
        for i, x in enumerate(nums):
            if i >= 2 and prefix > x: ans = max(ans, prefix + x)
            prefix += x
        return ans


    """2979. Most Expensive Item That Can Not Be Bought (Medium)
    You are given two distinct prime numbers primeOne and primeTwo. Alice and
    Bob are visiting a market. The market has an infinite number of items, for
    any positive integer x there exists an item whose price is x. Alice wants to
    buy some items from the market to gift to Bob. She has an infinite number of
    coins in the denomination primeOne and primeTwo. She wants to know the most
    expensive item she can not buy to gift to Bob. Return the price of the most
    expensive item which Alice can not gift to Bob.

    Example 1:
    Input: primeOne = 2, primeTwo = 5
    Output: 3
    Explanation: The prices of items which cannot be bought are [1,3]. It can be
                 shown that all items with a price greater than 3 can be bought
                 using a combination of coins of denominations 2 and 5.

    Example 2:
    Input: primeOne = 5, primeTwo = 7
    Output: 23
    Explanation: The prices of items which cannot be bought are
                 [1,2,3,4,6,8,9,11,13,16,18,23]. It can be shown that all items
                 with a price greater than 23 can be bought.

    Constraints:
    * 1 < primeOne, primeTwo < 10^4
    * primeOne, primeTwo are prime numbers.
    * primeOne * primeTwo < 10^5"""

    def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:
        return primeOne * primeTwo - primeOne - primeTwo


    """2992. Number of Self-Divisible Permutations (Medium)
    Given an integer n, return the number of permutations of the 1-indexed array
    nums = [1, 2, ..., n], such that it's self-divisible. A 1-indexed array a of
    length n is self-divisible if for every 1 <= i <= n, gcd(a[i], i) == 1. A
    permutation of an array is a rearrangement of the elements of that array,
    for example here are all of the permutations of the array [1, 2, 3]:
    * [1, 2, 3]
    * [1, 3, 2]
    * [2, 1, 3]
    * [2, 3, 1]
    * [3, 1, 2]
    * [3, 2, 1]

    Example 1:
    Input: n = 1
    Output: 1
    Explanation: The array [1] has only 1 permutation which is self-divisible.

    Example 2:
    Input: n = 2
    Output: 1
    Explanation: The array [1,2] has 2 permutations and only one of them is
                 self-divisible:
                 * nums = [1,2]: This is not self-divisible since
                   gcd(nums[2], 2) != 1.
                 * nums = [2,1]: This is self-divisible since
                   gcd(nums[1], 1) == 1 and gcd(nums[2], 2) == 1.

    Example 3:
    Input: n = 3
    Output: 3
    Explanation: The array [1,2,3] has 3 self-divisble permutations: [1,3,2],
                 [3,1,2], [2,3,1]. It can be shown that the other 3 permutations
                 are not self-divisible. Hence the answer is 3.

    Constraints: 1 <= n <= 12"""

    def selfDivisiblePermutationCount(self, n: int) -> int:

        @cache
        def fn(i, m):
            if i == n: return 1
            ans = 0
            for x in range(n):
                if not m & 1<<x and gcd(i+1, x+1) == 1: ans += fn(i+1, m ^ 1<<x)
            return ans

        return fn(0, 0)


    """2996. Smallest Missing Integer Greater Than Sequential Prefix Sum (Easy)
    You are given a 0-indexed array of integers nums. A prefix nums[0..i] is
    sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In
    particular, the prefix consisting only of nums[0] is sequential. Return the
    smallest integer x missing from nums such that x is greater than or equal to
    the sum of the longest sequential prefix.

    Example 1:
    Input: nums = [1,2,3,2,5]
    Output: 6
    Explanation: The longest sequential prefix of nums is [1,2,3] with a sum of
                 6. 6 is not in the array, therefore 6 is the smallest missing
                 integer greater than or equal to the sum of the longest
                 sequential prefix.

    Example 2:
    Input: nums = [3,4,5,1,12,14,13]
    Output: 15
    Explanation: The longest sequential prefix of nums is [3,4,5] with a sum of
                 12. 12, 13, and 14 belong to the array while 15 does not.
                 Therefore 15 is the smallest missing integer greater than or
                 equal to the sum of the longest sequential prefix.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50"""

    def missingInteger(self, nums: List[int]) -> int:
        prefix = 0
        for i, x in enumerate(nums):
            if i and x != nums[i-1]+1: break
            prefix += x
        seen = set(nums)
        while prefix in seen: prefix += 1
        return prefix


    """2997. Minimum Number of Operations to Make Array XOR Equal to K (Medium)
    You are given a 0-indexed integer array nums and a positive integer k. You
    can apply the following operation on the array any number of times:
    * Choose any element of the array and flip a bit in its binary
      representation. Flipping a bit means changing a 0 to 1 or vice versa.
    Return the minimum number of operations required to make the bitwise XOR of
    all elements of the final array equal to k. Note that you can flip leading
    zero bits in the binary representation of elements. For example, for the
    number (101)2 you can flip the fourth bit and obtain (1101)2.

    Example 1:
    Input: nums = [2,1,3,4], k = 1
    Output: 2
    Explanation: We can do the following operations:
                 - Choose element 2 which is 3 == (011)2, we flip the first bit
                   and we obtain (010)2 == 2. nums becomes [2,1,2,4].
                 - Choose element 0 which is 2 == (010)2, we flip the third bit
                   and we obtain (110)2 = 6. nums becomes [6,1,2,4].
                 The XOR of elements of the final array is
                 (6 XOR 1 XOR 2 XOR 4) == 1 == k. It can be shown that we cannot
                 make the XOR equal to k in less than 2 operations.

    Example 2:
    Input: nums = [2,0,2,0], k = 0
    Output: 0
    Explanation: The XOR of elements of the array is
                 (2 XOR 0 XOR 2 XOR 0) == 0 == k. So no operation is needed.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6
    * 0 <= k <= 10^6"""

    def minOperations(self, nums: List[int], k: int) -> int:
        return reduce(xor, nums, k).bit_count()


    """2998. Minimum Number of Operations to Make X and Y Equal (Medium)
    You are given two positive integers x and y. In one operation, you can do
    one of the four following operations:
    * Divide x by 11 if x is a multiple of 11.
    * Divide x by 5 if x is a multiple of 5.
    * Decrement x by 1.
    * Increment x by 1.
    Return the minimum number of operations required to make x and y equal.

    Example 1:
    Input: x = 26, y = 1
    Output: 3
    Explanation: We can make 26 equal to 1 by applying the following operations:
                 1. Decrement x by 1
                 2. Divide x by 5
                 3. Divide x by 5
                 It can be shown that 3 is the minimum number of operations
                 required to make 26 equal to 1.

    Example 2:
    Input: x = 54, y = 2
    Output: 4
    Explanation: We can make 54 equal to 2 by applying the following operations:
                 1. Increment x by 1
                 2. Divide x by 11
                 3. Divide x by 5
                 4. Increment x by 1
                 It can be shown that 4 is the minimum number of operations
                 required to make 54 equal to 2.

    Example 3:
    Input: x = 25, y = 30
    Output: 5
    Explanation: We can make 25 equal to 30 by applying the following operations:
                 1. Increment x by 1
                 2. Increment x by 1
                 3. Increment x by 1
                 4. Increment x by 1
                 5. Increment x by 1
                 It can be shown that 5 is the minimum number of operations
                 required to make 25 equal to 30.

    Constraints: 1 <= x, y <= 10^4"""

    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:
        if x <= y: return y - x
        ans = x - y
        for v in 5, 11:
            ans = min(ans, self.minimumOperationsToMakeEqual(x//v, y) + 1 + x % v)
            ans = min(ans, self.minimumOperationsToMakeEqual(x//v+1, y) + 1 + v - x % v)
        return ans


    """2999. Count the Number of Powerful Integers (Hard)
    You are given three integers start, finish, and limit. You are also given a
    0-indexed string s representing a positive integer. A positive integer x is
    called powerful if it ends with s (in other words, s is a suffix of x) and
    each digit in x is at most limit. Return the total number of powerful
    integers in the range [start..finish]. A string x is a suffix of a string y
    if and only if x is a substring of y that starts from some index (including
    0) in y and extends to the index y.length - 1. For example, 25 is a suffix
    of 5125 whereas 512 is not.

    Example 1:
    Input: start = 1, finish = 6000, limit = 4, s = "124"
    Output: 5
    Explanation: The powerful integers in the range [1..6000] are 124, 1124,
                 2124, 3124, and, 4124. All these integers have each digit <= 4,
                 and "124" as a suffix. Note that 5124 is not a powerful integer
                 because the first digit is 5 which is greater than 4. It can be
                 shown that there are only 5 powerful integers in this range.

    Example 2:
    Input: start = 15, finish = 215, limit = 6, s = "10"
    Output: 2
    Explanation: The powerful integers in the range [15..215] are 110 and 210.
                 All these integers have each digit <= 6, and "10" as a suffix.
                 It can be shown that there are only 2 powerful integers in this
                 range.

    Example 3:
    Input: start = 1000, finish = 2000, limit = 4, s = "3000"
    Output: 0
    Explanation: All integers in the range [1000..2000] are smaller than 3000,
                 hence "3000" cannot be a suffix of any integer in this range.

    Constraints:
    * 1 <= start <= finish <= 10^15
    * 1 <= limit <= 9
    * 1 <= s.length <= floor(log10(finish)) + 1
    * s only consists of numeric digits which are at most limit.
    * s does not have leading zeros."""

    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:

        def fn(val):
            """Return # powful integers <= val."""
            n = len(val) - len(s)
            if n < 0: return 0
            dp = [[0]*2 for _ in range(n+1)]
            dp[-1][0] = 1
            dp[-1][1] = int(val[n:] >= s)
            for i in range(n-1, -1, -1):
                dp[i][0] = (1+limit)*dp[i+1][0]
                if int(val[i]) <= limit: dp[i][1] = int(val[i])*dp[i+1][0] + dp[i+1][1]
                else: dp[i][1] = (1+limit)*dp[i+1][0]
            return dp[0][1]

        return fn(str(finish)) - fn(str(start-1))


    """3004. Maximum Subtree of the Same Color (Medium)
    You are given a 2D integer array edges representing a tree with n nodes,
    numbered from 0 to n - 1, rooted at node 0, where edges[i] = [ui, vi] means
    there is an edge between the nodes vi and ui. You are also given a 0-indexed
    integer array colors of size n, where colors[i] is the color assigned to
    node i. We want to find a node v such that every node in the subtree of v
    has the same color. Return the size of such subtree with the maximum number
    of nodes possible.

    Example 1:
    Input: edges = [[0,1],[0,2],[0,3]], colors = [1,1,2,3]
    Output: 1
    Explanation: Each color is represented as: 1 -> Red, 2 -> Green, 3 -> Blue.
                 We can see that the subtree rooted at node 0 has children with
                 different colors. Any other subtree is of the same color and
                 has a size of 1. Hence, we return 1.

    Example 2:
    Input: edges = [[0,1],[0,2],[0,3]], colors = [1,1,1,1]
    Output: 4
    Explanation: The whole tree has the same color, and the subtree rooted at
                 node 0 has the most number of nodes which is 4. Hence, we
                 return 4.

    Example 3:
    Input: edges = [[0,1],[0,2],[2,3],[2,4]], colors = [1,2,3,3,3]
    Output: 3
    Explanation: Each color is represented as: 1 -> Red, 2 -> Green, 3 -> Blue.
                 We can see that the subtree rooted at node 0 has children with
                 different colors. Any other subtree is of the same color, but
                 the subtree rooted at node 2 has a size of 3 which is the
                 maximum. Hence, we return 3.

    Constraints:
    * n == edges.length + 1
    * 1 <= n <= 5 * 10^4
    * edges[i] == [ui, vi]
    * 0 <= ui, vi < n
    * colors.length == n
    * 1 <= colors[i] <= 10^5
    * The input is generated such that the graph represented by edges is a
      tree."""

      def maximumSubtreeSize(self, edges: List[List[int]], colors: List[int]) -> int:
          graph = [[] for _ in colors]
          for u, v in edges:
              graph[u].append(v)
              graph[v].append(u)

          def fn(u, p):
              """Return """
              same = val = 1
              most = 0
              for v in graph[u]:
                  if v != p:
                      vv, ss = fn(v, u)
                      if ss and colors[u] == colors[v]: val += vv
                      else: same = 0
                      most = max(most, vv)
              if same: most = val
              return most, same

          return fn(0, -1)[0]


    """3005. Count Elements With Maximum Frequency (Easy)
    You are given an array nums consisting of positive integers. Return the
    total frequencies of elements in nums such that those elements all have the
    maximum frequency. The frequency of an element is the number of occurrences
    of that element in the array.

    Example 1:
    Input: nums = [1,2,2,3,1,4]
    Output: 4
    Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum
                 frequency in the array. So the number of elements in the array
                 with maximum frequency is 4.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: 5
    Explanation: All elements of the array have a frequency of 1 which is the
                 maximum. So the number of elements in the array with maximum
                 frequency is 5.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100"""

    def maxFrequencyElements(self, nums: List[int]) -> int:
        freq = Counter(nums)
        m = max(freq.values())
        return sum(v for v in freq.values() if v == m)


    """3006. Find Beautiful Indices in the Given Array I (Medium)
    You are given a 0-indexed string s, a string a, a string b, and an integer
    k. An index i is beautiful if:
    * 0 <= i <= s.length - a.length
    * s[i..(i + a.length - 1)] == a
    * There exists an index j such that:
      - 0 <= j <= s.length - b.length
      - s[j..(j + b.length - 1)] == b
      - |j - i| <= k
    Return the array that contains beautiful indices in sorted order from
    smallest to largest.

    Example 1:
    Input: s = "isawsquirrelnearmysquirrelhouseohmy", a = "my", b = "squirrel", k = 15
    Output: [16,33]
    Explanation: There are 2 beautiful indices: [16,33].
                 - The index 16 is beautiful as s[16..17] == "my" and there
                   exists an index 4 with s[4..11] == "squirrel" and
                   |16 - 4| <= 15.
                 - The index 33 is beautiful as s[33..34] == "my" and there
                   exists an index 18 with s[18..25] == "squirrel" and
                   |33 - 18| <= 15.
                 Thus we return [16,33] as the result.

    Example 2:
    Input: s = "abcd", a = "a", b = "a", k = 4
    Output: [0]
    Explanation: There is 1 beautiful index: [0].
                 - The index 0 is beautiful as s[0..0] == "a" and there exists
                   an index 0 with s[0..0] == "a" and |0 - 0| <= 4.
                 Thus we return [0] as the result.

    Constraints:
    * 1 <= k <= s.length <= 10^5
    * 1 <= a.length, b.length <= 10
    * s, a, and b contain only lowercase English letters."""

    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:
        ans = []
        j = 0
        for i in range(len(s)):
            if s[i : i+len(a)] == a:
                while j < len(s) and j <= i+k:
                    if s[j:j+len(b)] == b and abs(i-j) <= k: break
                    j += 1
                else: continue
                ans.append(i)
        return ans


    """3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)
    You are given an integer k and an integer x. Consider s is the 1-indexed
    binary representation of an integer num. The price of a number num is the
    number of i's such that i % x == 0 and s[i] is a set bit. Return the
    greatest integer num such that the sum of prices of all numbers from 1 to
    num is less than or equal to k.

    Note:
    * In the binary representation of a number set bit is a bit of value 1.
    * The binary representation of a number will be indexed from right to left.
      For example, if s == 11100, s[4] == 1 and s[2] == 0.

    Example 1:
    Input: k = 9, x = 1
    Output: 6
    Explanation: The numbers 1, 2, 3, 4, 5, and 6 can be written in binary
                 representation as "1", "10", "11", "100", "101", and "110"
                 respectively. Since x is equal to 1, the price of each number
                 is the number of its set bits. The number of set bits in these
                 numbers is 9. So the sum of the prices of the first 6 numbers
                 is 9. So the answer is 6.

    Example 2:
    Input: k = 7, x = 2
    Output: 9
    Explanation: Since x is equal to 2, we should just check eventh bits. The
                 second bit of binary representation of numbers 2 and 3 is a set
                 bit. So the sum of their prices is 2. The second bit of binary
                 representation of numbers 6 and 7 is a set bit. So the sum of
                 their prices is 2. The fourth bit of binary representation of
                 numbers 8 and 9 is a set bit but their second bit is not. So
                 the sum of their prices is 2. Numbers 1, 4, and 5 don't have
                 set bits in their eventh bits in their binary representation.
                 So the sum of their prices is 0. The second and the fourth bit
                 of the binary representation of the number 10 are a set bit. So
                 its price is 2. The sum of the prices of the first 9 numbers is
                 6. Because the sum of the prices of the first 10 numbers is 8,
                 the answer is 9.

    Constraints:
    * 1 <= k <= 10^15
    * 1 <= x <= 8"""

    def findMaximumNumber(self, k: int, x: int) -> int:

        def fn(mid):
            """Return """
            if mid == 0: return 0
            n = mid.bit_length()
            mid ^= 1 << n-1
            return (n-1)//x*pow(2, n-2) + fn(mid) + (mid+1 if n % x == 0 else 0)

        lo, hi = 1, int(1e15)
        while lo < hi:
            mid = lo + hi + 1 >> 1
            if fn(mid) <= k: lo = mid
            else: hi = mid-1
        return lo


    """3008. Find Beautiful Indices in the Given Array II (Hard)
    You are given a 0-indexed string s, a string a, a string b, and an integer
    k. An index i is beautiful if:
    * 0 <= i <= s.length - a.length
    * s[i..(i + a.length - 1)] == a
    * There exists an index j such that:
      - 0 <= j <= s.length - b.length
      - s[j..(j + b.length - 1)] == b
      - |j - i| <= k
    Return the array that contains beautiful indices in sorted order from
    smallest to largest.

    Example 1:
    Input: s = "isawsquirrelnearmysquirrelhouseohmy", a = "my", b = "squirrel", k = 15
    Output: [16,33]
    Explanation: There are 2 beautiful indices: [16,33].
                 - The index 16 is beautiful as s[16..17] == "my" and there
                   exists an index 4 with s[4..11] == "squirrel" and
                   |16 - 4| <= 15.
                 - The index 33 is beautiful as s[33..34] == "my" and there
                   exists an index 18 with s[18..25] == "squirrel" and
                   |33 - 18| <= 15.
                 Thus we return [16,33] as the result.

    Example 2:
    Input: s = "abcd", a = "a", b = "a", k = 4
    Output: [0]
    Explanation: There is 1 beautiful index: [0].
                 - The index 0 is beautiful as s[0..0] == "a" and there exists
                   an index 0 with s[0..0] == "a" and |0 - 0| <= 4.
                 Thus we return [0] as the result.

    Constraints:
    * 1 <= k <= s.length <= 5 * 10^5
    * 1 <= a.length, b.length <= 5 * 10^5
    * s, a, and b contain only lowercase English letters."""

    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:

        def kmp(pattern, text):
            """Knuth-Moore-Pratt algo
            Return location of 1st occurrence of pattern in text."""
            lps = [0] # longest proper prefix also suffix
            k = 0
            for i in range(1, len(pattern)):
                while k and pattern[k] != pattern[i]: k = lps[k-1]
                if pattern[k] == pattern[i]: k += 1
                lps.append(k)
            ans = []
            k = 0
            for i, ch in enumerate(text):
                while k and (k == len(pattern) or pattern[k] != ch): k = lps[k-1]
                if pattern[k] == ch: k += 1
                if k == len(pattern): ans.append(i - len(pattern) + 1)
            return ans

        ans = []
        j = 0
        vals = kmp(b, s)
        for i in kmp(a, s):
            while j < len(vals) and vals[j] <= i+k:
                if abs(i-vals[j]) <= k: break
                j += 1
            else: continue
            ans.append(i)
        return ans


    """3010. Divide an Array Into Subarrays With Minimum Cost I (Easy)
    You are given an array of integers nums of length n. The cost of an array is
    the value of its first element. For example, the cost of [1,2,3] is 1 while
    the cost of [3,4,1] is 3. You need to divide nums into 3 disjoint contiguous
    subarrays. Return the minimum possible sum of the cost of these subarrays.

    Example 1:
    Input: nums = [1,2,3,12]
    Output: 6
    Explanation: The best possible way to form 3 subarrays is: [1], [2], and
                 [3,12] at a total cost of 1 + 2 + 3 = 6. The other possible
                 ways to form 3 subarrays are:
                 - [1], [2,3], and [12] at a total cost of 1 + 2 + 12 = 15.
                 - [1,2], [3], and [12] at a total cost of 1 + 3 + 12 = 16.

    Example 2:
    Input: nums = [5,4,3]
    Output: 12
    Explanation: The best possible way to form 3 subarrays is: [5], [4], and [3]
                 at a total cost of 5 + 4 + 3 = 12. It can be shown that 12 is
                 the minimum cost achievable.

    Example 3:
    Input: nums = [10,3,1,1]
    Output: 12
    Explanation: The best possible way to form 3 subarrays is: [10,3], [1], and
                 [1] at a total cost of 10 + 1 + 1 = 12. It can be shown that 12
                 is the minimum cost achievable.

    Constraints:
    * 3 <= n <= 50
    * 1 <= nums[i] <= 50"""

    def minimumCost(self, nums: List[int]) -> int:
        m0 = m1 = 50
        for i, x in enumerate(nums):
            if i and x <= m0: m0, m1 = x, m0
            elif i and x < m1: m1 = x
        return nums[0] + m0 + m1


    """3011. Find if Array Can Be Sorted (Medium)
    You are given a 0-indexed array of positive integers nums. In one operation,
    you can swap any two adjacent elements if they have the same number of set
    bits. You are allowed to do this operation any number of times (including
    zero). Return true if you can sort the array, else return false.

    Example 1:
    Input: nums = [8,4,2,30,15]
    Output: true
    Explanation: Let's look at the binary representation of every element. The
                 numbers 2, 4, and 8 have one set bit each with binary
                 representation "10", "100", and "1000" respectively. The
                 numbers 15 and 30 have four set bits each with binary
                 representation "1111" and "11110". We can sort the array using
                 4 operations:
                 - Swap nums[0] with nums[1]. This operation is valid because 8
                   and 4 have one set bit each. The array becomes [4,8,2,30,15].
                 - Swap nums[1] with nums[2]. This operation is valid because 8
                   and 2 have one set bit each. The array becomes [4,2,8,30,15].
                 - Swap nums[0] with nums[1]. This operation is valid because 4
                   and 2 have one set bit each. The array becomes [2,4,8,30,15].
                 - Swap nums[3] with nums[4]. This operation is valid because 30
                   and 15 have four set bits each. The array becomes [2,4,8,15,30].
                 The array has become sorted, hence we return true. Note that
                 there may be other sequences of operations which also sort the
                 array.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: true
    Explanation: The array is already sorted, hence we return true.

    Example 3:
    Input: nums = [3,16,8,4,2]
    Output: false
    Explanation: It can be shown that it is not possible to sort the input array
                 using any number of operations.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 2^8"""

    def canSortArray(self, nums: List[int]) -> bool:
        bits = curr = prev = 0
        for i, x in enumerate(nums):
            b = x.bit_count()
            if bits != b: prev, bits = curr, b
            if prev > x: return False
            curr = max(curr, x)
        return True


    """3012. Minimize Length of Array Using Operations (Medium)
    You are given a 0-indexed integer array nums containing positive integers.
    Your task is to minimize the length of nums by performing the following
    operations any number of times (including zero):
    * Select two distinct indices i and j from nums, such that nums[i] > 0 and
      nums[j] > 0.
    * Insert the result of nums[i] % nums[j] at the end of nums.
    * Delete the elements at indices i and j from nums.
    Return an integer denoting the minimum length of nums after performing the
    operation any number of times.

    Example 1:
    Input: nums = [1,4,3,1]
    Output: 1
    Explanation: One way to minimize the length of the array is as follows:
                 - Operation 1: Select indices 2 and 1, insert nums[2] % nums[1]
                   at the end and it becomes [1,4,3,1,3], then delete elements
                   at indices 2 and 1. nums becomes [1,1,3].
                 - Operation 2: Select indices 1 and 2, insert nums[1] % nums[2]
                   at the end and it becomes [1,1,3,1], then delete elements at
                   indices 1 and 2. nums becomes [1,1].
                 - Operation 3: Select indices 1 and 0, insert nums[1] % nums[0]
                   at the end and it becomes [1,1,0], then delete elements at
                   indices 1 and 0. nums becomes [0].
                 The length of nums cannot be reduced further. Hence, the answer
                 is 1. It can be shown that 1 is the minimum achievable length.

    Example 2:
    Input: nums = [5,5,5,10,5]
    Output: 2
    Explanation: One way to minimize the length of the array is as follows:
                 - Operation 1: Select indices 0 and 3, insert nums[0] % nums[3]
                   at the end and it becomes [5,5,5,10,5,5], then delete
                   elements at indices 0 and 3. nums becomes [5,5,5,5].
                 - Operation 2: Select indices 2 and 3, insert nums[2] % nums[3]
                   at the end and it becomes [5,5,5,5,0], then delete elements
                   at indices 2 and 3. nums becomes [5,5,0].
                 - Operation 3: Select indices 0 and 1, insert nums[0] % nums[1]
                   at the end and it becomes [5,5,0,0], then delete elements at
                   indices 0 and 1. nums becomes [0,0].
                 The length of nums cannot be reduced further. Hence, the answer
                 is 2. It can be shown that 2 is the minimum achievable length.

    Example 3:
    Input: nums = [2,3,4]
    Output: 1
    Explanation: One way to minimize the length of the array is as follows:
                 - Operation 1: Select indices 1 and 2, insert nums[1] % nums[2]
                   at the end and it becomes [2,3,4,3], then delete elements at
                   indices 1 and 2. nums becomes [2,3].
                 - Operation 2: Select indices 1 and 0, insert nums[1] % nums[0]
                   at the end and it becomes [2,3,1], then delete elements at
                   indices 1 and 0. nums becomes [1].
                 The length of nums cannot be reduced further. Hence, the answer
                 is 1. It can be shown that 1 is the minimum achievable length.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def minimumArrayLength(self, nums: List[int]) -> int:
        m = min(nums)
        return 1 if any(x % m for x in nums) else (nums.count(m)+1)//2


    """3013. Divide an Array Into Subarrays With Minimum Cost II (Hard)
    You are given a 0-indexed array of integers nums of length n, and two
    positive integers k and dist. The cost of an array is the value of its first
    element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is
    3. You need to divide nums into k disjoint contiguous subarrays, such that
    the difference between the starting index of the second subarray and the
    starting index of the kth subarray should be less than or equal to dist. In
    other words, if you divide nums into the subarrays nums[0..(i1 - 1)],
    nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)], then ik-1 - i1 <= dist. Return
    the minimum possible sum of the cost of these subarrays.

    Example 1:
    Input: nums = [1,3,2,6,4,2], k = 3, dist = 3
    Output: 5
    Explanation: The best possible way to divide nums into 3 subarrays is:
                 [1,3], [2,6,4], and [2]. This choice is valid because ik-1 - i1
                 is 5 - 2 = 3 which is equal to dist. The total cost is
                 nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5. It can be
                 shown that there is no possible way to divide nums into 3
                 subarrays at a cost lower than 5.

    Example 2:
    Input: nums = [10,1,2,2,2,1], k = 4, dist = 3
    Output: 15
    Explanation: The best possible way to divide nums into 4 subarrays is:
                 [10], [1], [2], and [2,2,1]. This choice is valid because
                 ik-1 - i1 is 3 - 1 = 2 which is less than dist. The total cost
                 is nums[0] + nums[1] + nums[2] + nums[3] which is
                 10 + 1 + 2 + 2 = 15. The division [10], [1], [2,2,2], and [1]
                 is not valid, because the difference between ik-1 and i1 is
                 5 - 1 = 4, which is greater than dist. It can be shown that
                 there is no possible way to divide nums into 4 subarrays at a
                 cost lower than 15.

    Example 3:
    Input: nums = [10,8,18,9], k = 3, dist = 1
    Output: 36
    Explanation: The best possible way to divide nums into 4 subarrays is:
                 [10], [8], and [18,9]. This choice is valid because ik-1 - i1
                 is 2 - 1 = 1 which is equal to dist.The total cost is
                 nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36. The
                 division [10], [8,18], and [9] is not valid, because the
                 difference between ik-1 and i1 is 3 - 1 = 2, which is greater
                 than dist. It can be shown that there is no possible way to
                 divide nums into 3 subarrays at a cost lower than 36.

    Constraints:
    * 3 <= n <= 10^5
    * 1 <= nums[i] <= 10^9
    * 3 <= k <= n
    * k - 2 <= dist <= n - 2"""

    def minimumCost(self, nums: List[int], k: int, dist: int) -> int:
        ans = inf
        total = 0
        vals = SortedList()
        for i, x in enumerate(nums[1:]):
            if i > dist:
                xx = nums[i-dist]
                if vals.bisect(xx) < k:
                    total -= xx
                    if len(vals) > k-1: total += vals[k-1]
                vals.remove(xx)
            if vals.bisect(x) < k-1:
                total += x
                if len(vals) >= k-1: total -= vals[k-2]
            vals.add(x)
            if i >= k-2: ans = min(ans, total)
        return nums[0] + ans


    """3016. Minimum Number of Pushes to Type Word II (Medium)
    You are given a string word containing lowercase English letters. Telephone
    keypads have keys mapped with distinct collections of lowercase English
    letters, which can be used to form words by pushing them. For example, the
    key 2 is mapped with ["a","b","c"], we need to push the key one time to type
    "a", two times to type "b", and three times to type "c". It is allowed to
    remap the keys numbered 2 to 9 to distinct collections of letters. The keys
    can be remapped to any amount of letters, but each letter must be mapped to
    exactly one key. You need to find the minimum number of times the keys will
    be pushed to type the string word. Return the minimum number of pushes
    needed to type word after remapping the keys. An example mapping of letters
    to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do
    not map to any letters.

    Example 1:
    Input: word = "abcde"
    Output: 5
    Explanation: The remapped keypad given in the image provides the minimum cost.
                 "a" -> one push on key 2
                 "b" -> one push on key 3
                 "c" -> one push on key 4
                 "d" -> one push on key 5
                 "e" -> one push on key 6
                 Total cost is 1 + 1 + 1 + 1 + 1 = 5. It can be shown that no
                 other mapping can provide a lower cost.

    Example 2:
    Input: word = "xyzxyzxyzxyz"
    Output: 12
    Explanation: The remapped keypad given in the image provides the minimum cost.
                 "x" -> one push on key 2
                 "y" -> one push on key 3
                 "z" -> one push on key 4
                 Total cost is 1 * 4 + 1 * 4 + 1 * 4 = 12
                 It can be shown that no other mapping can provide a lower cost.
                 Note that the key 9 is not mapped to any letter: it is not
                 necessary to map letters to every key, but to map all the letters.

    Example 3:
    Input: word = "aabbccddeeffgghhiiiiii"
    Output: 24
    Explanation: The remapped keypad given in the image provides the minimum cost.
                 "a" -> one push on key 2
                 "b" -> one push on key 3
                 "c" -> one push on key 4
                 "d" -> one push on key 5
                 "e" -> one push on key 6
                 "f" -> one push on key 7
                 "g" -> one push on key 8
                 "h" -> two pushes on key 9
                 "i" -> one push on key 9
                 Total cost is 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 +
                 1 * 2 + 2 * 2 + 6 * 1 = 24. It can be shown that no other
                 mapping can provide a lower cost.

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists of lowercase English letters."""

    def minimumPushes(self, word: str) -> int:
        ans = cnt = 0
        for i, x in enumerate(sorted(Counter(word).values(), reverse=True)):
            if i % 8 == 0: cnt += 1
            ans += cnt * x
        return ans


    """3019. Number of Changing Keys (Easy)
    You are given a 0-indexed string s typed by a user. Changing a key is
    defined as using a key different from the last used key. For example,
    s = "ab" has a change of a key while s = "bBBb" does not have any. Return
    the number of times the user had to change the key. Note: Modifiers like
    shift or caps lock won't be counted in changing the key that is if a user
    typed the letter 'a' and then the letter 'A' then it will not be considered
    as a changing of key.

    Example 1:
    Input: s = "aAbBcC"
    Output: 2
    Explanation: - From s[0] = 'a' to s[1] = 'A', there is no change of key as
                   caps lock or shift is not counted.
                 - From s[1] = 'A' to s[2] = 'b', there is a change of key.
                 - From s[2] = 'b' to s[3] = 'B', there is no change of key as
                   caps lock or shift is not counted.
                 - From s[3] = 'B' to s[4] = 'c', there is a change of key.
                 - From s[4] = 'c' to s[5] = 'C', there is no change of key as
                   caps lock or shift is not counted.

    Example 2:
    Input: s = "AaAaAaaA"
    Output: 0
    Explanation: There is no change of key since only the letters 'a' and 'A'
                 are pressed which does not require change of key.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of only upper case and lower case English letters."""

    def countKeyChanges(self, s: str) -> int:
        return sum(s[i-1].lower() != s[i].lower() for i in range(1, len(s)))


    """3020. Find the Maximum Number of Elements in Subset (Medium)
    You are given an array of positive integers nums. You need to select a
    subset of nums which satisfies the following condition:
    * You can place the selected elements in a 0-indexed array such that it
      follows the pattern: [x, x2, x4, ..., xk/2, xk, xk/2, ..., x4, x2, x]
      (Note that k can be be any non-negative power of 2). For example,
      [2, 4, 16, 4, 2] and [3, 9, 3] follow the pattern while [2, 4, 8, 4, 2]
      does not.
    Return the maximum number of elements in a subset that satisfies these
    conditions.

    Example 1:
    Input: nums = [5,4,1,2,2]
    Output: 3
    Explanation: We can select the subset {4,2,2}, which can be placed in the
                 array as [2,4,2] which follows the pattern and 22 == 4. Hence
                 the answer is 3.

    Example 2:
    Input: nums = [1,3,2,4]
    Output: 1
    Explanation: We can select the subset {1}, which can be placed in the array
                 as [1] which follows the pattern. Hence the answer is 1. Note
                 that we could have also selected the subsets {2}, {4}, or {3},
                 there may be multiple subsets which provide the same answer.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def maximumLength(self, nums: List[int]) -> int:
        ans = 0
        freq = Counter(nums)
        for k, v in freq.items():
            if k == 1: cand = v
            else:
                cand = 0
                while k in freq:
                    cand += 2
                    if freq[k] == 1: break
                    k *= k
            if not cand&1: cand -= 1
            ans = max(ans, cand)
        return ans


    """3021. Alice and Bob Playing Flower Game (Medium)
    Alice and Bob are playing a turn-based game on a circular field surrounded
    by flowers. The circle represents the field, and there are x flowers in the
    clockwise direction between Alice and Bob, and y flowers in the anti-
    clockwise direction between them. The game proceeds as follows:
    * Alice takes the first turn.
    * In each turn, a player must choose either the clockwise or anti-clockwise
      direction and pick one flower from that side.
    * At the end of the turn, if there are no flowers left at all, the current
      player captures their opponent and wins the game.
    Given two integers, n and m, the task is to compute the number of possible
    pairs (x, y) that satisfy the conditions:
    * Alice must win the game according to the described rules.
    * The number of flowers x in the clockwise direction must be in the range
      [1,n].
    * The number of flowers y in the anti-clockwise direction must be in the
      range [1,m].
    Return the number of possible pairs (x, y) that satisfy the conditions
    mentioned in the statement.

    Example 1:
    Input: n = 3, m = 2
    Output: 3
    Explanation: The following pairs satisfy conditions described in the
                 statement: (1,2), (3,2), (2,1).

    Example 2:
    Input: n = 1, m = 1
    Output: 0
    Explanation: No pairs satisfy the conditions described in the statement.

    Constraints: 1 <= n, m <= 10^5"""

    def flowerGame(self, n: int, m: int) -> int:
        return m*n//2


    """3022. Minimize OR of Remaining Elements Using Operations (Hard)
    You are given a 0-indexed integer array nums and an integer k. In one
    operation, you can pick any index i of nums such that
    0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a single
    occurrence of nums[i] & nums[i + 1], where & represents the bitwise AND
    operator. Return the minimum possible value of the bitwise OR of the
    remaining elements of nums after applying at most k operations.

    Example 1:
    Input: nums = [3,5,3,2,7], k = 2
    Output: 3
    Explanation: Let's do the following operations:
                 1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [1,3,2,7].
                 2. Replace nums[2] and nums[3] with (nums[2] & nums[3]) so that
                    nums becomes equal to [1,3,2].
                 The bitwise-or of the final array is 3. It can be shown that 3
                 is the minimum possible value of the bitwise OR of the
                 remaining elements of nums after applying at most k operations.

    Example 2:
    Input: nums = [7,3,15,14,2,8], k = 4
    Output: 2
    Explanation: Let's do the following operations:
                 1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [3,15,14,2,8].
                 2. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [3,14,2,8].
                 3. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [2,2,8].
                 4. Replace nums[1] and nums[2] with (nums[1] & nums[2]) so that
                    nums becomes equal to [2,0].
                 The bitwise-or of the final array is 2. It can be shown that 2
                 is the minimum possible value of the bitwise OR of the
                 remaining elements of nums after applying at most k operations.

    Example 3:
    Input: nums = [10,7,10,3,9,14,9,4], k = 1
    Output: 15
    Explanation: Without applying any operations, the bitwise-or of nums is 15.
                 It can be shown that 15 is the minimum possible value of the
                 bitwise OR of the remaining elements of nums after applying at
                 most k operations.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] < 2^30
    * 0 <= k < nums.length"""

    def minOrAfterOperations(self, nums: List[int], k: int) -> int:
        n = len(nums)
        ans = 0
        for bit in range(30, -1, -1):
            cnt = 0
            mask = (1<<30)-1
            target = ans | (1<<bit)-1
            for x in nums:
                mask &= x
                if mask | target > target: cnt += 1
                else: mask = (1<<30)-1
            if cnt > k: ans |= 1<<bit
        return ans


    """3023. Find Pattern in Infinite Stream I (Medium)
    You are given a binary array pattern and an object stream of class
    InfiniteStream representing a 0-indexed infinite stream of bits. The class
    InfiniteStream contains the following function:
    * int next(): Reads a single bit (which is either 0 or 1) from the stream
      and returns it.
    Return the first starting index where the pattern matches the bits read from
    the stream. For example, if the pattern is [1, 0], the first match is the
    highlighted part in the stream [0, 1, 0, 1, ...].

    Example 1:
    Input: stream = [1,1,1,0,1,1,1,...], pattern = [0,1]
    Output: 3
    Explanation: The first occurrence of the pattern [0,1] is highlighted in the
                 stream [1,1,1,0,1,...], which starts at index 3.

    Example 2:
    Input: stream = [0,0,0,0,...], pattern = [0]
    Output: 0
    Explanation: The first occurrence of the pattern [0] is highlighted in the
                 stream [0,...], which starts at index 0.

    Example 3:
    Input: stream = [1,0,1,1,0,1,1,0,1,...], pattern = [1,1,0,1]
    Output: 2
    Explanation: The first occurrence of the pattern [1,1,0,1] is highlighted in
                 the stream [1,0,1,1,0,1,...], which starts at index 2.

    Constraints:
    * 1 <= pattern.length <= 100
    * pattern consists only of 0 and 1.
    * stream consists only of 0 and 1.
    * The input is generated such that the pattern's start index exists in the
      first 10^5 bits of the stream."""

    def findPattern(self, stream: Optional['InfiniteStream'], pattern: List[int]) -> int:
        lps = [0]
        k = 0
        for i in range(1, len(pattern)):
            while k and pattern[k] != pattern[i]: k = lps[k-1]
            if pattern[k] == pattern[i]: k += 1
            lps.append(k)
        k = 0
        for i in count(0):
            ch = stream.next()
            while k and pattern[k] != ch: k = lps[k-1]
            if pattern[k] == ch: k += 1
            if k == len(pattern): return i-len(pattern)+1


    """3024. Type of Triangle II (Easy)
    You are given a 0-indexed integer array nums of size 3 which can form the
    sides of a triangle.
    * A triangle is called equilateral if it has all sides of equal length.
    * A triangle is called isosceles if it has exactly two sides of equal length.
    * A triangle is called scalene if all its sides are of different lengths.
    Return a string representing the type of triangle that can be formed or
    "none" if it cannot form a triangle.

    Example 1:
    Input: nums = [3,3,3]
    Output: "equilateral"
    Explanation: Since all the sides are of equal length, therefore, it will
                 form an equilateral triangle.

    Example 2:
    Input: nums = [3,4,5]
    Output: "scalene"
    Explanation: nums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.
                 nums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.
                 nums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3.
                 Since the sum of the two sides is greater than the third side
                 for all three cases, therefore, it can form a triangle. As all
                 the sides are of different lengths, it will form a scalene
                 triangle.

    Constraints:
    * nums.length == 3
    * 1 <= nums[i] <= 100"""

    def triangleType(self, nums: List[int]) -> str:
        x, y, z = sorted(nums)
        if x+y <= z: return "none"
        if x == z: return "equilateral"
        if x == y or y == z: return "isosceles"
        return "scalene"


    """3025. Find the Number of Ways to Place People I (Medium)
    You are given a 2D array points of size n x 2 representing integer
    coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. We
    define the right direction as positive x-axis (increasing x-coordinate) and
    the left direction as negative x-axis (decreasing x-coordinate). Similarly,
    we define the up direction as positive y-axis (increasing y-coordinate) and
    the down direction as negative y-axis (decreasing y-coordinate). You have to
    place n people, including Chisato and Takina, at these points such that
    there is exactly one person at every point. Chisato wants to be alone with
    Takina, so Chisato will build a rectangular fence with Chisato's position as
    the upper left corner and Takina's position as the lower right corner of the
    fence (Note that the fence might not enclose any area, i.e. it can be a
    line). If any person other than Chisato and Takina is either inside the
    fence or on the fence, Chisato will be sad. Return the number of pairs of
    points where you can place Chisato and Takina, such that Chisato does not
    become sad on building the fence. Note that Chisato can only build a fence
    with Chisato's position as the upper left corner, and Takina's position as
    the lower right corner. For example, Chisato cannot build either of the
    fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and
    (3, 3), because:
    * With Chisato at (3, 3) and Takina at (1, 1), Chisato's position is not the
      upper left corner and Takina's position is not the lower right corner of
      the fence.
    * With Chisato at (1, 3) and Takina at (1, 1), Takina's position is not the
      lower right corner of the fence.

    Example 1:
    Input: points = [[1,1],[2,2],[3,3]]
    Output: 0
    Explanation: There is no way to place Chisato and Takina such that Chisato
                 can build a fence with Chisato's position as the upper left
                 corner and Takina's position as the lower right corner. Hence
                 we return 0.

    Example 2:
    Input: points = [[6,2],[4,4],[2,6]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (4, 4) and Takina at (6, 2).
                 - Place Chisato at (2, 6) and Takina at (4, 4).
                 You cannot place Chisato at (2, 6) and Takina at (6, 2) because
                 the person at (4, 4) will be inside the fence.

    Example 3:
    Input: points = [[3,1],[1,3],[1,1]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (1, 1) and Takina at (3, 1).
                 - Place Chisato at (1, 3) and Takina at (1, 1).
                 You cannot place Chisato at (1, 3) and Takina at (3, 1) because
                 the person at (1, 1) will be on the fence. Note that it does
                 not matter if the fence encloses any area, the first and second
                 fences in the image are valid.

    Constraints:
    * 2 <= n <= 50
    * points[i].length == 2
    * 0 <= points[i][0], points[i][1] <= 50
    * All points[i] are distinct."""

    def numberOfPairs(self, points: List[List[int]]) -> int:
        ans = 0
        points.sort(key = lambda x : (x[0], -x[1]))
        for i, (x, y) in enumerate(points):
            val = -inf
            for xx, yy in points[i+1:]:
                if y >= yy > val:
                    ans += 1
                    val = yy
        return ans


    """3026. Maximum Good Subarray Sum (Medium)
    You are given an array nums of length n and a positive integer k. A subarray
    of nums is called good if the absolute difference between its first and last
    element is exactly k, in other words, the subarray nums[i..j] is good if
    |nums[i] - nums[j]| == k. Return the maximum sum of a good subarray of nums.
    If there are no good subarrays, return 0.

    Example 1:
    Input: nums = [1,2,3,4,5,6], k = 1
    Output: 11
    Explanation: The absolute difference between the first and last element must
                 be 1 for a good subarray. All the good subarrays are:
                 [1,2], [2,3], [3,4], [4,5], and [5,6]. The maximum subarray sum
                 is 11 for the subarray [5,6].

    Example 2:
    Input: nums = [-1,3,2,4,5], k = 3
    Output: 11
    Explanation: The absolute difference between the first and last element must
                 be 3 for a good subarray. All the good subarrays are: [-1,3,2],
                 and [2,4,5]. The maximum subarray sum is 11 for the subarray
                 [2,4,5].

    Example 3:
    Input: nums = [-1,-2,-3,-4], k = 2
    Output: -6
    Explanation: The absolute difference between the first and last element must
                 be 2 for a good subarray. All the good subarrays are:
                 [-1,-2,-3], and [-2,-3,-4]. The maximum subarray sum is -6 for
                 the subarray [-1,-2,-3].

    Constraints:
    * 2 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9
    * 1 <= k <= 10^9"""

    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        ans = -inf
        seen = defaultdict(lambda: inf)
        prefix = 0
        for x in nums:
            prefix += x
            ans = max(ans, prefix-seen[x-k], prefix-seen[x+k])
            seen[x] = min(seen[x], prefix-x)
        return ans if ans > -inf else 0


    """3027. Find the Number of Ways to Place People II (Hard)
    You are given a 2D array points of size n x 2 representing integer
    coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. We
    define the right direction as positive x-axis (increasing x-coordinate) and
    the left direction as negative x-axis (decreasing x-coordinate). Similarly,
    we define the up direction as positive y-axis (increasing y-coordinate) and
    the down direction as negative y-axis (decreasing y-coordinate). You have to
    place n people, including Chisato and Takina, at these points such that
    there is exactly one person at every point. Chisato wants to be alone with
    Takina, so Chisato will build a rectangular fence with Chisato's position as
    the upper left corner and Takina's position as the lower right corner of the
    fence (Note that the fence might not enclose any area, i.e. it can be a
    line). If any person other than Chisato and Takina is either inside the
    fence or on the fence, Chisato will be sad. Return the number of pairs of
    points where you can place Chisato and Takina, such that Chisato does not
    become sad on building the fence. Note that Chisato can only build a fence
    with Chisato's position as the upper left corner, and Takina's position as
    the lower right corner. For example, Chisato cannot build either of the
    fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and
    (3, 3), because:
    * With Chisato at (3, 3) and Takina at (1, 1), Chisato's position is not the
      upper left corner and Takina's position is not the lower right corner of
      the fence.
    * With Chisato at (1, 3) and Takina at (1, 1), Takina's position is not the
      lower right corner of the fence.

    Example 1:
    Input: points = [[1,1],[2,2],[3,3]]
    Output: 0
    Explanation: There is no way to place Chisato and Takina such that Chisato
                 can build a fence with Chisato's position as the upper left
                 corner and Takina's position as the lower right corner. Hence
                 we return 0.

    Example 2:
    Input: points = [[6,2],[4,4],[2,6]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (4, 4) and Takina at (6, 2).
                 - Place Chisato at (2, 6) and Takina at (4, 4).
                 You cannot place Chisato at (2, 6) and Takina at (6, 2) because
                 the person at (4, 4) will be inside the fence.

    Example 3:
    Input: points = [[3,1],[1,3],[1,1]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (1, 1) and Takina at (3, 1).
                 - Place Chisato at (1, 3) and Takina at (1, 1).
                 You cannot place Chisato at (1, 3) and Takina at (3, 1) because
                 the person at (1, 1) will be on the fence. Note that it does
                 not matter if the fence encloses any area, the first and second
                 fences in the image are valid.

    Constraints:
    * 2 <= n <= 1000
    * points[i].length == 2
    * -10^9 <= points[i][0], points[i][1] <= 10^9
    * All points[i] are distinct."""

    def numberOfPairs(self, points: List[List[int]]) -> int:
        ans = 0
        points.sort(key = lambda x : (x[0], -x[1]))
        for i, (x, y) in enumerate(points):
            val = -inf
            for xx, yy in points[i+1:]:
                if y >= yy > val:
                    ans += 1
                    val = yy
        return ans


    """3028. Ant on the Boundary (Easy)
    An ant is on a boundary. It sometimes goes left and sometimes right. You are
    given an array of non-zero integers nums. The ant starts reading nums from
    the first element of it to its end. At each step, it moves according to the
    value of the current element:
    * If nums[i] < 0, it moves left by -nums[i] units.
    * If nums[i] > 0, it moves right by nums[i] units.
    Return the number of times the ant returns to the boundary.

    Notes:
    * There is an infinite space on both sides of the boundary.
    * We check whether the ant is on the boundary only after it has moved
      |nums[i]| units. In other words, if the ant crosses the boundary during
      its movement, it does not count.

    Example 1:
    Input: nums = [2,3,-5]
    Output: 1
    Explanation: - After the first step, the ant is 2 steps to the right of the
                   boundary.
                 - After the second step, the ant is 5 steps to the right of the
                   boundary.
                 - After the third step, the ant is on the boundary.
                 So the answer is 1.

    Example 2:
    Input: nums = [3,2,-3,-4]
    Output: 0
    Explanation: - After the first step, the ant is 3 steps to the right of the
                   boundary.
                 - After the second step, the ant is 5 steps to the right of the
                   boundary.
                 - After the third step, the ant is 2 steps to the right of the
                   boundary.
                 - After the fourth step, the ant is 2 steps to the left of the
                   boundary.
                 The ant never returned to the boundary, so the answer is 0.

    Constraints:
    * 1 <= nums.length <= 100
    * -10 <= nums[i] <= 10
    * nums[i] != 0"""

    def returnToBoundaryCount(self, nums: List[int]) -> int:
        return list(accumulate(nums)).count(0)


    """3029. Minimum Time to Revert Word to Initial State I (Medium)
    You are given a 0-indexed string word and an integer k. At every second, you
    must perform the following operations:
    * Remove the first k characters of word.
    * Add any k characters to the end of word.
    Note that you do not necessarily need to add the same characters that you
    removed. However, you must perform both operations at every second. Return
    the minimum time greater than zero required for word to revert to its
    initial state.

    Example 1:
    Input: word = "abacaba", k = 3
    Output: 2
    Explanation: - At the 1st second, we remove characters "aba" from the prefix
                   of word, and add characters "bac" to the end of word. Thus,
                   word becomes equal to "cababac".
                 - At the 2nd second, we remove characters "cab" from the prefix
                   of word, and add "aba" to the end of word. Thus, word becomes
                   equal to "abacaba" and reverts to its initial state.
                 It can be shown that 2 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 2:
    Input: word = "abacaba", k = 4
    Output: 1
    Explanation: - At the 1st second, we remove characters "abac" from the
                   prefix of word, and add characters "caba" to the end of word.
                   Thus, word becomes equal to "abacaba" and reverts to its
                   initial state.
                 It can be shown that 1 second is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 3:
    Input: word = "abcbabcd", k = 2
    Output: 4
    Explanation: - At every second, we will remove the first 2 characters of
                   word, and add the same characters to the end of word.
                 - After 4 seconds, word becomes equal to "abcbabcd" and reverts
                   to its initial state.
                 It can be shown that 4 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Constraints:
    * 1 <= word.length <= 50
    * 1 <= k <= word.length
    * word consists only of lowercase English letters."""

    def minimumTimeToInitialState(self, word: str, k: int) -> int:

        def z_algo(s: str) -> List[int]:
            ans = [0] * len(s)
            lo = hi = ii = 0
            for i in range(1, len(s)):
                if i <= hi: ii = i - lo
                if i + ans[ii] <= hi: ans[i] = ans[ii]
                else:
                    lo, hi = i, max(hi, i)
                    while hi < len(s) and s[hi] == s[hi-lo]: hi += 1
                    ans[i] = hi - lo
                    hi -= 1
            return ans

        z = z_algo(word)
        for i in range(0, ceil(len(word)/k)):
            if i*k + z[i*k] == len(word): return i
        return i+1


    """3030. Find the Grid of Region Average (Medium)
    You are given m x n grid image which represents a grayscale image, where
    image[i][j] represents a pixel with intensity in the range [0..255]. You are
    also given a non-negative integer threshold. Two pixels are adjacent if they
    share an edge. A region is a 3 x 3 subgrid where the absolute difference in
    intensity between any two adjacent pixels is less than or equal to threshold.
    All pixels in a region belong to that region, note that a pixel can belong
    to multiple regions. You need to calculate a m x n grid result, where
    result[i][j] is the average intensity of the regions to which image[i][j]
    belongs, rounded down to the nearest integer. If image[i][j] belongs to
    multiple regions, result[i][j] is the average of the rounded-down average
    intensities of these regions, rounded down to the nearest integer. If
    image[i][j] does not belong to any region, result[i][j] is equal to
    image[i][j]. Return the grid result.

    Example 1:
    Input: image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3
    Output: [[9,9,9,9],[9,9,9,9],[9,9,9,9]]
    Explanation: There are two regions as illustrated above. The average
                 intensity of the first region is 9, while the average intensity
                 of the second region is 9.67 which is rounded down to 9. The
                 average intensity of both of the regions is (9 + 9) / 2 = 9. As
                 all the pixels belong to either region 1, region 2, or both of
                 them, the intensity of every pixel in the result is 9. Please
                 note that the rounded-down values are used when calculating the
                 average of multiple regions, hence the calculation is done
                 using 9 as the average intensity of region 2, not 9.67.

    Example 2:
    Input: image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12
    Output: [[25,25,25],[27,27,27],[27,27,27],[30,30,30]]
    Explanation: There are two regions as illustrated above. The average
                 intensity of the first region is 25, while the average
                 intensity of the second region is 30. The average intensity of
                 both of the regions is (25 + 30) / 2 = 27.5 which is rounded
                 down to 27. All the pixels in row 0 of the image belong to
                 region 1, hence all the pixels in row 0 in the result are 25.
                 Similarly, all the pixels in row 3 in the result are 30. The
                 pixels in rows 1 and 2 of the image belong to region 1 and
                 region 2, hence their assigned value is 27 in the result.

    Example 3:
    Input: image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1
    Output: [[5,6,7],[8,9,10],[11,12,13]]
    Explanation: There is only one 3 x 3 subgrid, while it does not have the
                 condition on difference of adjacent pixels, for example, the
                 difference between image[0][0] and image[1][0] is
                 |5 - 8| = 3 > threshold = 1. None of them belong to any valid
                 regions, so the result should be the same as image.

    Constraints:
    * 3 <= n, m <= 500
    * 0 <= image[i][j] <= 255
    * 0 <= threshold <= 255"""

    def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:
        m, n = len(image), len(image[0])
        ans = [[[0, 0] for _ in range(n)] for _ in range(m)]
        for i in range(m-2):
            for j in range(n-2):
                total = diff = 0
                for ii in range(i, i+3):
                    for jj in range(j, j+3):
                        total += image[ii][jj]
                        if ii+1 < i+3: diff = max(diff, abs(image[ii][jj]-image[ii+1][jj]))
                        if jj+1 < j+3: diff = max(diff, abs(image[ii][jj]-image[ii][jj+1]))
                if diff <= threshold:
                    for ii in range(i, i+3):
                        for jj in range(j, j+3):
                            ans[ii][jj][0] += total//9
                            ans[ii][jj][1] += 1
        for i in range(m):
            for j in range(n):
                if ans[i][j][1]:
                    image[i][j] = ans[i][j][0]//ans[i][j][1]
        return image


    """3031. Minimum Time to Revert Word to Initial State II (Hard)
    You are given a 0-indexed string word and an integer k. At every second, you
    must perform the following operations:
    * Remove the first k characters of word.
    * Add any k characters to the end of word.
    Note that you do not necessarily need to add the same characters that you
    removed. However, you must perform both operations at every second. Return
    the minimum time greater than zero required for word to revert to its
    initial state.

    Example 1:
    Input: word = "abacaba", k = 3
    Output: 2
    Explanation: - At the 1st second, we remove characters "aba" from the prefix
                   of word, and add characters "bac" to the end of word. Thus,
                   word becomes equal to "cababac".
                 - At the 2nd second, we remove characters "cab" from the prefix
                   of word, and add "aba" to the end of word. Thus, word becomes
                   equal to "abacaba" and reverts to its initial state.
                 It can be shown that 2 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 2:
    Input: word = "abacaba", k = 4
    Output: 1
    Explanation: - At the 1st second, we remove characters "abac" from the
                   prefix of word, and add characters "caba" to the end of word.
                   Thus, word becomes equal to "abacaba" and reverts to its
                   initial state.
                 It can be shown that 1 second is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 3:
    Input: word = "abcbabcd", k = 2
    Output: 4
    Explanation: - At every second, we will remove the first 2 characters of
                   word, and add the same characters to the end of word.
                 - After 4 seconds, word becomes equal to "abcbabcd" and reverts
                   to its initial state.
                 It can be shown that 4 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Constraints:
    * 1 <= word.length <= 10^6
    * 1 <= k <= word.length
    * word consists only of lowercase English letters."""

    def minimumTimeToInitialState(self, word: str, k: int) -> int:

        def z_algo(s: str) -> List[int]:
            ans = [0] * len(s)
            lo = hi = ii = 0
            for i in range(1, len(s)):
                if i <= hi: ii = i - lo
                if i + ans[ii] <= hi: ans[i] = ans[ii]
                else:
                    lo, hi = i, max(hi, i)
                    while hi < len(s) and s[hi] == s[hi-lo]: hi += 1
                    ans[i] = hi - lo
                    hi -= 1
            return ans

        z = z_algo(word)
        for i in range(0, ceil(len(word)/k)):
            if i*k + z[i*k] == len(word): return i
        return i+1


    """3032. Count Numbers With Unique Digits II (Easy)
    Given two positive integers a and b, return the count of numbers having
    unique digits in the range [a, b] (inclusive).

    Example 1:
    Input: a = 1, b = 20
    Output: 19
    Explanation: All the numbers in the range [1, 20] have unique digits except
                 11. Hence, the answer is 19.

    Example 2:
    Input: a = 9, b = 19
    Output: 10
    Explanation: All the numbers in the range [9, 19] have unique digits except
                 11. Hence, the answer is 10.

    Example 3:
    Input: a = 80, b = 120
    Output: 27
    Explanation: There are 41 numbers in the range [80, 120], 27 of which have
                 unique digits.

    Constraints: 1 <= a <= b <= 1000"""

    def numberCount(self, a: int, b: int) -> int:
        ans = 0
        for x in range(a, b+1):
            mask = 0
            while x:
                x, d = divmod(x, 10)
                if mask & 1<<d: break
                mask ^= 1<<d
            else: ans += 1
        return ans


    """3033. Modify the Matrix （Easy）
    Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix
    called answer. Make answer equal to matrix, then replace each element with
    the value -1 with the maximum element in its respective column. Return the
    matrix answer.

    Example 1:
    Input: matrix = [[1,2,-1],[4,-1,6],[7,8,9]]
    Output: [[1,2,9],[4,8,6],[7,8,9]]
    Explanation: The diagram above shows the elements that are changed (in blue).
                 - We replace the value in the cell [1][1] with the maximum
                   value in the column 1, that is 8.
                 - We replace the value in the cell [0][2] with the maximum
                   value in the column 2, that is 9.

    Example 2:
    Input: matrix = [[3,-1],[5,2]]
    Output: [[3,2],[5,2]]
    Explanation: The diagram above shows the elements that are changed (in blue).

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 2 <= m, n <= 50
    * -1 <= matrix[i][j] <= 100
    * The input is generated such that each column contains at least one non-
      negative integer."""

    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0])
        for j in range(n):
            mv = max(matrix[i][j] for i in range(m))
            for i in range(m):
                if matrix[i][j] == -1: matrix[i][j] = mv
        return matrix


    """3034. Number of Subarrays That Match a Pattern I (Medium)
    You are given a 0-indexed integer array nums of size n, and a 0-indexed
    integer array pattern of size m consisting of integers -1, 0, and 1. A
    subarray nums[i..j] of size m + 1 is said to match the pattern if the
    following conditions hold for each element pattern[k]:
    * nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
    * nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
    * nums[i + k + 1] < nums[i + k] if pattern[k] == -1.
    Return the count of subarrays in nums that match the pattern.

    Example 1:
    Input: nums = [1,2,3,4,5,6], pattern = [1,1]
    Output: 4
    Explanation: The pattern [1,1] indicates that we are looking for strictly
                 increasing subarrays of size 3. In the array nums, the
                 subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this
                 pattern. Hence, there are 4 subarrays in nums that match the
                 pattern.

    Example 2:
    Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
    Output: 2
    Explanation: Here, the pattern [1,0,-1] indicates that we are looking for a
                 sequence where the first number is smaller than the second, the
                 second is equal to the third, and the third is greater than the
                 fourth. In the array nums, the subarrays [1,4,4,1], and
                 [3,5,5,3] match this pattern. Hence, there are 2 subarrays in
                 nums that match the pattern.

    Constraints:
    * 2 <= n == nums.length <= 100
    * 1 <= nums[i] <= 10^9
    * 1 <= m == pattern.length < n
    * -1 <= pattern[i] <= 1"""

    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:
        text = []
        for i in range(1, len(nums)):
            diff = nums[i] - nums[i-1]
            if diff: diff //= abs(diff)
            text.append(diff)
        k = 0
        lps = [0]
        for i in range(1, len(pattern)):
            while k and pattern[k] != pattern[i]: k = lps[k-1]
            if pattern[k] == pattern[i]: k += 1
            lps.append(k)
        ans = k = 0
        for i, ch in enumerate(text):
            while k and (k == len(pattern) or pattern[k] != ch): k = lps[k-1]
            if pattern[k] == ch: k += 1
            if k == len(pattern): ans += 1
        return ans


    """3035. Maximum Palindromes After Operations (Medium)
    You are given a 0-indexed string array words having length n and containing
    0-indexed strings. You are allowed to perform the following operation any
    number of times (including zero):
    * Choose integers i, j, x, and y such that 0 <= i, j < n,
      0 <= x < words[i].length, 0 <= y < words[j].length, and swap the
      characters words[i][x] and words[j][y].
    Return an integer denoting the maximum number of palindromes words can
    contain, after performing some operations. Note: i and j may be equal during
    an operation.

    Example 1:
    Input: words = ["abbb","ba","aa"]
    Output: 3
    Explanation: In this example, one way to get the maximum number of
                 palindromes is:
                 - Choose i = 0, j = 1, x = 0, y = 0, so we swap words[0][0] and
                   words[1][0]. words becomes ["bbbb","aa","aa"].
                 All strings in words are now palindromes. Hence, the maximum
                 number of palindromes achievable is 3.

    Example 2:
    Input: words = ["abc","ab"]
    Output: 2
    Explanation: In this example, one way to get the maximum number of
                 palindromes is:
                 - Choose i = 0, j = 1, x = 1, y = 0, so we
                   words[1][0]. words becomes ["aac","bb"].
                 - Choose i = 0, j = 0, x = 1, y = 2, so we swap words[0][1] and
                   words[0][2]. words becomes ["aca","bb"].
                 Both strings are now palindromes. Hence, the maximum number of
                 palindromes achievable is 2.

    Example 3:
    Input: words = ["cd","ef","a"]
    Output: 1
    Explanation: In this example, there is no need to perform any operation.
                 There is one palindrome in words "a". It can be shown that it
                 is not possible to get more than one palindrome after any
                 number of operations. Hence, the answer is 1.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 100
    * words[i] consists only of lowercase English letters."""

    def maxPalindromesAfterOperations(self, words: List[str]) -> int:
        freq = Counter(ch for word in words for ch in word)
        pairs = sum(x // 2 for x in freq.values())
        for i, x in enumerate(sorted(map(len, words))):
            pairs -= x // 2
            if pairs < 0: return i
        return len(words)


    """3036. Number of Subarrays That Match a Pattern II (Hard)
    You are given a 0-indexed integer array nums of size n, and a 0-indexed
    integer array pattern of size m consisting of integers -1, 0, and 1. A
    subarray nums[i..j] of size m + 1 is said to match the pattern if the
    following conditions hold for each element pattern[k]:
    * nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
    * nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
    * nums[i + k + 1] < nums[i + k] if pattern[k] == -1.
    Return the count of subarrays in nums that match the pattern.

    Example 1:
    Input: nums = [1,2,3,4,5,6], pattern = [1,1]
    Output: 4
    Explanation: The pattern [1,1] indicates that we are looking for strictly
                 increasing subarrays of size 3. In the array nums, the
                 subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this
                 pattern. Hence, there are 4 subarrays in nums that match the
                 pattern.

    Example 2:
    Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
    Output: 2
    Explanation: Here, the pattern [1,0,-1] indicates that we are looking for a
                 sequence where the first number is smaller than the second, the
                 second is equal to the third, and the third is greater than the
                 fourth. In the array nums, the subarrays [1,4,4,1], and
                 [3,5,5,3] match this pattern. Hence, there are 2 subarrays in
                 nums that match the pattern.

    Constraints:
    * 2 <= n == nums.length <= 10^6
    * 1 <= nums[i] <= 10^9
    * 1 <= m == pattern.length < n
    * -1 <= pattern[i] <= 1"""

    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:
        text = []
        for i in range(1, len(nums)):
            diff = nums[i] - nums[i-1]
            if diff: diff //= abs(diff)
            text.append(diff)
        k = 0
        lps = [0]
        for i in range(1, len(pattern)):
            while k and pattern[k] != pattern[i]: k = lps[k-1]
            if pattern[k] == pattern[i]: k += 1
            lps.append(k)
        ans = k = 0
        for i, ch in enumerate(text):
            while k and (k == len(pattern) or pattern[k] != ch): k = lps[k-1]
            if pattern[k] == ch: k += 1
            if k == len(pattern): ans += 1
        return ans


    """3037. Find Pattern in Infinite Stream II (Hard)
    You are given a binary array pattern and an object stream of class
    InfiniteStream representing a 0-indexed infinite stream of bits. The class
    InfiniteStream contains the following function:
    * int next(): Reads a single bit (which is either 0 or 1) from the stream
      and returns it.
    Return the first starting index where the pattern matches the bits read from
    the stream. For example, if the pattern is [1, 0], the first match is the
    highlighted part in the stream [0, 1, 0, 1, ...].

    Example 1:
    Input: stream = [1,1,1,0,1,1,1,...], pattern = [0,1]
    Output: 3
    Explanation: The first occurrence of the pattern [0,1] is highlighted in the
                 stream [1,1,1,0,1,...], which starts at index 3.

    Example 2:
    Input: stream = [0,0,0,0,...], pattern = [0]
    Output: 0
    Explanation: The first occurrence of the pattern [0] is highlighted in the
                 stream [0,...], which starts at index 0.

    Example 3:
    Input: stream = [1,0,1,1,0,1,1,0,1,...], pattern = [1,1,0,1]
    Output: 2
    Explanation: The first occurrence of the pattern [1,1,0,1] is highlighted in
                 the stream [1,0,1,1,0,1,...], which starts at index 2.

    Constraints:
    * 1 <= pattern.length <= 10^4
    * pattern consists only of 0 and 1.
    * stream consists only of 0 and 1.
    * The input is generated such that the pattern's start index exists in the
      first 10^5 bits of the stream."""

    def findPattern(self, stream: Optional['InfiniteStream'], pattern: List[int]) -> int:
        lps = [0]
        k = 0
        for i in range(1, len(pattern)):
            while k and pattern[k] != pattern[i]: k = lps[k-1]
            if pattern[k] == pattern[i]: k += 1
            lps.append(k)
        k = 0
        for i in count(0):
            ch = stream.next()
            while k and pattern[k] != ch: k = lps[k-1]
            if pattern[k] == ch: k += 1
            if k == len(pattern): return i-k+1


    """3038. Maximum Number of Operations With the Same Score I (Easy)
    Given an array of integers called nums, you can perform the following
    operation while nums contains at least 2 elements:
    * Choose the first two elements of nums and delete them.
    The score of the operation is the sum of the deleted elements. Your task is
    to find the maximum number of operations that can be performed, such that
    all operations have the same score. Return the maximum number of operations
    possible that satisfy the condition mentioned above.

    Example 1:
    Input: nums = [3,2,1,4,5]
    Output: 2
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [1,4,5].
                 - Delete the first two elements, with score 1 + 4 = 5,
                   nums = [5].
                 We are unable to perform any more operations as nums contain
                 only 1 element.

    Example 2:
    Input: nums = [3,2,6,1,4]
    Output: 1
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [6,1,4].
                 We are unable to perform any more operations as the score of
                 the next operation isn't the same as the previous one.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 1000"""

    def maxOperations(self, nums: List[int]) -> int:
        ans = 0
        score = nums[0] + nums[1]
        for i in range(0, len(nums)-1, 2):
            if nums[i] + nums[i+1] == score: ans += 1
            else: break
        return ans


    """3039. Apply Operations to Make String Empty (Medium)
    You are given a string s. Consider performing the following operation until
    s becomes empty:
    * For every alphabet character from 'a' to 'z', remove the first occurrence
      of that character in s (if it exists).
    For example, let initially s = "aabcbbca". We do the following operations:
    * Remove the underlined characters s = "aabcbbca". The resulting string is
      s = "abbca".
    * Remove the underlined characters s = "abbca". The resulting string is
      s = "ba".
    * Remove the underlined characters s = "ba". The resulting string is s = "".
    Return the value of the string s right before applying the last operation.
    In the example above, answer is "ba".

    Example 1:
    Input: s = "aabcbbca"
    Output: "ba"
    Explanation: Explained in the statement.

    Example 2:
    Input: s = "abcd"
    Output: "abcd"
    Explanation: We do the following operation:
                 - Remove the underlined characters s = "abcd". The resulting
                   string is s = "".
                 The string just before the last operation is "abcd".

    Constraints:
    * 1 <= s.length <= 5 * 10^5
    * s consists only of lowercase English letters."""

    def lastNonEmptyString(self, s: str) -> str:
        freq = Counter(s)
        m = max(freq.values())
        ans = []
        for ch in reversed(s):
            if freq[ch] == m:
                ans.append(ch)
                freq[ch] -= 1
        return "".join(reversed(ans))


    """3040. Maximum Number of Operations With the Same Score II (Medium)
    Given an array of integers called nums, you can perform any of the following
    operation while nums contains at least 2 elements:
    * Choose the first two elements of nums and delete them.
    * Choose the last two elements of nums and delete them.
    * Choose the first and the last elements of nums and delete them.
    The score of the operation is the sum of the deleted elements. Your task is
    to find the maximum number of operations that can be performed, such that
    all operations have the same score. Return the maximum number of operations
    possible that satisfy the condition mentioned above.

    Example 1:
    Input: nums = [3,2,1,2,3,4]
    Output: 3
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [1,2,3,4].
                 - Delete the first and the last elements, with score 1 + 4 = 5,
                   nums = [2,3].
                 - Delete the first and the last elements, with score 2 + 3 = 5,
                   nums = [].
                 We are unable to perform any more operations as nums is empty.

    Example 2:
    Input: nums = [3,2,6,1,4]
    Output: 2
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [6,1,4].
                 - Delete the last two elements, with score 1 + 4 = 5,
                   nums = [6].
                 It can be proven that we can perform at most 2 operations.

    Constraints:
    * 2 <= nums.length <= 2000
    * 1 <= nums[i] <= 1000"""

    def maxOperations(self, nums: List[int]) -> int:
        n = len(nums)

        @cache
        def fn(i, j, target):
            ans = 0
            if i+1 <= j:
                if nums[i]+nums[i+1] == target: ans = max(ans, 1 + fn(i+2, j, target))
                if nums[j-1]+nums[j] == target: ans = max(ans, 1 + fn(i, j-2, target))
                if nums[i]+nums[j] == target: ans = max(ans, 1 + fn(i+1, j-1, target))
            return ans

        return max(fn(0, n-1, t) for t in {nums[0]+nums[1], nums[-2]+nums[-1], nums[0]+nums[-1]})


    """3041. Maximize Consecutive Elements in an Array After Modification (Hard)
    You are given a 0-indexed array nums consisting of positive integers.
    Initially, you can increase the value of any element in the array by at most
    1. After that, you need to select one or more elements from the final array
    such that those elements are consecutive when sorted in increasing order.
    For example, the elements [3, 4, 5] are consecutive while [3, 4, 6] and
    [1, 1, 2, 3] are not. Return the maximum number of elements that you can
    select.

    Example 1:
    Input: nums = [2,1,5,1,1]
    Output: 3
    Explanation: We can increase the elements at indices 0 and 3. The resulting
                 array is nums = [3,1,5,2,1]. We select the elements [3,1,5,2,1]
                 and we sort them to obtain [1,2,3], which are consecutive. It
                 can be shown that we cannot select more than 3 consecutive
                 elements.

    Example 2:
    Input: nums = [1,4,7,10]
    Output: 1
    Explanation: The maximum consecutive elements that we can select is 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6"""

    def maxSelectedElements(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        dp = [[1]*2 for _ in range(n)]
        for i in range(1, n):
            if nums[i-1]+2 == nums[i]: dp[i][0] = dp[i-1][1] + 1
            elif nums[i-1]+1 == nums[i]:
                dp[i][0] = dp[i-1][0] + 1
                dp[i][1] = dp[i-1][1] + 1
            elif nums[i-1] == nums[i]:
                dp[i][0] = dp[i-1][0]
                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + 1)
        return max(map(max, dp))


    """3042. Count Prefix and Suffix Pairs I (Easy)
    You are given a 0-indexed string array words. Let's define a boolean
    function isPrefixAndSuffix that takes two strings, str1 and str2:
    * isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a
      suffix of str2, and false otherwise.
    For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a
    prefix of "ababa" and also a suffix, but isPrefixAndSuffix("abc", "abcd") is
    false. Return an integer denoting the number of index pairs (i, j) such that
    i < j, and isPrefixAndSuffix(words[i], words[j]) is true.

    Example 1:
    Input: words = ["a","aba","ababa","aa"]
    Output: 4
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("a", "aba") is true.
                 - i = 0 and j = 2 because isPrefixAndSuffix("a", "ababa") is
                   true.
                 - i = 0 and j = 3 because isPrefixAndSuffix("a", "aa") is true.
                 - i = 1 and j = 2 because isPrefixAndSuffix("aba", "ababa") is
                   true.
                 Therefore, the answer is 4.

    Example 2:
    Input: words = ["pa","papa","ma","mama"]
    Output: 2
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("pa", "papa") is
                   true.
                 - i = 2 and j = 3 because isPrefixAndSuffix("ma", "mama") is
                   true.
                 Therefore, the answer is 2.

    Example 3:
    Input: words = ["abab","ab"]
    Output: 0
    Explanation: In this example, the only valid index pair is i = 0 and j = 1,
                 and isPrefixAndSuffix("abab", "ab") is false. Therefore, the
                 answer is 0.

    Constraints:
    * 1 <= words.length <= 50
    * 1 <= words[i].length <= 10
    * words[i] consists only of lowercase English letters."""

    def countPrefixSuffixPairs(self, words: List[str]) -> int:
        ans = 0
        for i, w in enumerate(words):
            for ii in range(i):
                if w.startswith(words[ii]) and w.endswith(words[ii]): ans += 1
        return ans


    """3043. Find the Length of the Longest Common Prefix (Medium)
    You are given two arrays with positive integers arr1 and arr2. A prefix of a
    positive integer is an integer formed by one or more of its digits, starting
    from its leftmost digit. For example, 123 is a prefix of the integer 12345,
    while 234 is not. A common prefix of two integers a and b is an integer c,
    such that c is a prefix of both a and b. For example, 5655359 and 56554 have
    a common prefix 565 while 1223 and 43456 do not have a common prefix. You
    need to find the length of the longest common prefix between all pairs of
    integers (x, y) such that x belongs to arr1 and y belongs to arr2. Return
    the length of the longest common prefix among all pairs. If no common prefix
    exists among them, return 0.

    Example 1:
    Input: arr1 = [1,10,100], arr2 = [1000]
    Output: 3
    Explanation: There are 3 pairs (arr1[i], arr2[j]):
                 - The longest common prefix of (1, 1000) is 1.
                 - The longest common prefix of (10, 1000) is 10.
                 - The longest common prefix of (100, 1000) is 100.
                 The longest common prefix is 100 with a length of 3.

    Example 2:
    Input: arr1 = [1,2,3], arr2 = [4,4,4]
    Output: 0
    Explanation: There exists no common prefix for any pair (arr1[i], arr2[j]),
                 hence we return 0. Note that common prefixes between elements
                 of the same array do not count.

    Constraints:
    * 1 <= arr1.length, arr2.length <= 5 * 10^4
    * 1 <= arr1[i], arr2[i] <= 10^8"""

    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:
        trie = {}
        for x in arr1:
            node = trie
            for d in str(x):
                node = node.setdefault(d, {})
        ans = 0
        for x in arr2:
            node = trie
            prefix = 0
            for d in str(x):
                if d in node:
                    prefix += 1
                    node = node[d]
                else: break
            ans = max(ans, prefix)
        return ans


    """3044. Most Frequent Prime (Medium)
    You are given a m x n 0-indexed 2D matrix mat. From every cell, you can
    create numbers in the following way:
    * There could be at most 8 paths from the cells namely: east, south-east,
      south, south-west, west, north-west, north, and north-east.
    * Select a path from them and append digits in this path to the number being
      formed by traveling in this direction.
    * Note that numbers are generated at every step, for example, if the digits
      along the path are 1, 9, 1, then there will be three numbers generated
      along the way: 1, 19, 191.
    Return the most frequent prime number greater than 10 out of all the numbers
    created by traversing the matrix or -1 if no such prime number exists. If
    there are multiple prime numbers with the highest frequency, then return the
    largest among them. Note: It is invalid to change the direction during the
    move.

    Example 1:
    Input: mat = [[1,1],[9,9],[1,1]]
    Output: 19
    Explanation: From cell (0,0) there are 3 possible directions and the numbers
                 greater than 10 which can be created in those directions are:
                 East: [11], South-East: [19], South: [19,191].
                 - Numbers greater than 10 created from the cell (0,1) in all
                   possible directions are: [19,191,19,11].
                 - Numbers greater than 10 created from the cell (1,0) in all
                   possible directions are: [99,91,91,91,91].
                 - Numbers greater than 10 created from the cell (1,1) in all
                   possible directions are: [91,91,99,91,91].
                 - Numbers greater than 10 created from the cell (2,0) in all
                   possible directions are: [11,19,191,19].
                 - Numbers greater than 10 created from the cell (2,1) in all
                   possible directions are: [11,19,19,191].
                 The most frequent prime number among all the created numbers is
                 19.

    Example 2:
    Input: mat = [[7]]
    Output: -1
    Explanation: The only number which can be formed is 7. It is a prime number
                 however it is not greater than 10, so return -1.

    Example 3:
    Input: mat = [[9,7,8],[4,6,5],[2,8,6]]
    Output: 97
    Explanation: - Numbers greater than 10 created from the cell (0,0) in all
                   possible directions are: [97,978,96,966,94,942].
                 - Numbers greater than 10 created from the cell (0,1) in all
                   possible directions are: [78,75,76,768,74,79].
                 - Numbers greater than 10 created from the cell (0,2) in all
                   possible directions are: [85,856,86,862,87,879].
                 - Numbers greater than 10 created from the cell (1,0) in all
                   possible directions are: [46,465,48,42,49,47].
                 - Numbers greater than 10 created from the cell (1,1) in all
                   possible directions are: [65,66,68,62,64,69,67,68].
                 - Numbers greater than 10 created from the cell (1,2) in all
                   possible directions are: [56,58,56,564,57,58].
                 - Numbers greater than 10 created from the cell (2,0) in all
                   possible directions are: [28,286,24,249,26,268].
                 - Numbers greater than 10 created from the cell (2,1) in all
                   possible directions are: [86,82,84,86,867,85].
                 - Numbers greater than 10 created from the cell (2,2) in all
                   possible directions are: [68,682,66,669,65,658].
                 The most frequent prime number among all the created numbers is
                 97.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 6
    * 1 <= mat[i][j] <= 9"""

    def mostFrequentPrime(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])

        def check(x):
            for p in range(2, isqrt(x)+1):
                if x % p == 0: return False
            return True

        ans = -1
        freq = Counter()
        for i in range(m):
            for j in range(n):
                for di, dj in (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1):
                    ii, jj = i, j
                    prefix = 0
                    while 0 <= ii < m and 0 <= jj < n:
                        prefix = 10*prefix + mat[ii][jj]
                        if prefix > 10 and check(prefix):
                            freq[prefix] += 1
                            if ans == -1 or freq[ans] < freq[prefix] or freq[ans] == freq[prefix] and ans < prefix:
                                ans = prefix
                        ii += di
                        jj += dj
        return ans


    """3045. Count Prefix and Suffix Pairs II (Hard)
    You are given a 0-indexed string array words. Let's define a boolean
    function isPrefixAndSuffix that takes two strings, str1 and str2:
    * isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a
      suffix of str2, and false otherwise.
    For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a
    prefix of "ababa" and also a suffix, but isPrefixAndSuffix("abc", "abcd") is
    false. Return an integer denoting the number of index pairs (i, j) such that
    i < j, and isPrefixAndSuffix(words[i], words[j]) is true.

    Example 1:
    Input: words = ["a","aba","ababa","aa"]
    Output: 4
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("a", "aba") is true.
                 - i = 0 and j = 2 because isPrefixAndSuffix("a", "ababa") is
                   true.
                 - i = 0 and j = 3 because isPrefixAndSuffix("a", "aa") is true.
                 - i = 1 and j = 2 because isPrefixAndSuffix("aba", "ababa") is
                   true.
                 Therefore, the answer is 4.

    Example 2:
    Input: words = ["pa","papa","ma","mama"]
    Output: 2
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("pa", "papa") is
                   true.
                 - i = 2 and j = 3 because isPrefixAndSuffix("ma", "mama") is
                   true.
                 Therefore, the answer is 2.

    Example 3:
    Input: words = ["abab","ab"]
    Output: 0
    Explanation: In this example, the only valid index pair is i = 0 and j = 1,
                 and isPrefixAndSuffix("abab", "ab") is false. Therefore, the
                 answer is 0.

    Constraints:
    * 1 <= words.length <= 10^5
    * 1 <= words[i].length <= 10^5
    * words[i] consists only of lowercase English letters.
    * The sum of the lengths of all words[i] does not exceed 5 * 10^5."""

    def countPrefixSuffixPairs(self, words: List[str]) -> int:
        ans = 0
        trie = {}
        for w in words:
            node = trie
            for k in zip(w, reversed(w)):
                node = node.setdefault(k, {})
                ans += node.get("#", 0)
            if "#" not in node: node["#"] = 0
            node["#"] += 1
        return ans


    """3063. Linked List Frequency (Medium)
    Given the head of a linked list containing k distinct elements, return the
    head to a linked list of length k containing the frequency of each distinct
    element in the given linked list in any order.

    Example 1:
    Input: head = [1,1,1,2,2,3]
    Output: [3,2,1]
    Explanation: There are 3 distinct elements in the list. The frequency of 1
                 is 3, the frequency of 2 is 2 and the frequency of 3 is 1.
                 Hence, we return 3 -> 2 -> 1. Note that 1 -> 2 -> 3,
                 1 -> 3 -> 2, 2 -> 1 -> 3, 2 -> 3 -> 1, and 3 -> 1 -> 2 are also
                 valid answers.

    Example 2:
    Input: head = [1,1,2,2,2]
    Output: [2,3]
    Explanation: There are 2 distinct elements in the list. The frequency of 1
                 is 2 and the frequency of 2 is 3. Hence, we return 2 -> 3.

    Example 3:
    Input: head = [6,5,4,3,2,1]
    Output: [1,1,1,1,1,1]
    Explanation: There are 6 distinct elements in the list. The frequency of
                 each of them is 1. Hence, we return 1 -> 1 -> 1 -> 1 -> 1 -> 1.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5"""

    def frequenciesOfElements(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = node = ListNode()
        prev = 0
        while head:
            if prev != head.val:
                node.next = node = ListNode()
            node.val += 1
            prev = head.val
            head = head.next
        return dummy.next


    """3064. Guess the Number Using Bitwise Questions I (Medium)
    There is a number n that you have to find. There is also a pre-defined API
    int commonSetBits(int num), which returns the number of bits where both n
    and num are 1 in that position of their binary representation. In other
    words, it returns the number of set bits in n & num, where & is the bitwise
    AND operator. Return the number n.

    Example 1:
    Input: n = 31
    Output: 31
    Explanation: It can be proven that it's possible to find 31 using the
                 provided API.

    Example 2:
    Input: n = 33
    Output: 33
    Explanation: It can be proven that it's possible to find 33 using the
                 provided API.

    Constraints:
    * 1 <= n <= 2^30 - 1
    * 0 <= num <= 2^30 - 1
    * If you ask for some num out of the given range, the output wouldn't be
      reliable."""

    def findNumber(self) -> int:
        return reduce(xor, (1<<i if commonSetBits(1<<i) else 0 for i in range(30)))


    """3065. Minimum Operations to Exceed Threshold Value I (Easy)
    You are given a 0-indexed integer array nums, and an integer k. In one
    operation, you can remove one occurrence of the smallest element of nums.
    Return the minimum number of operations needed so that all elements of the
    array are greater than or equal to k.

    Example 1:
    Input: nums = [2,11,10,1,3], k = 10
    Output: 3
    Explanation: After one operation, nums becomes equal to [2, 11, 10, 3].
                 After two operations, nums becomes equal to [11, 10, 3].
                 After three operations, nums becomes equal to [11, 10].
                 At this stage, all the elements of nums are greater than or
                 equal to 10 so we can stop. It can be shown that 3 is the
                 minimum number of operations needed so that all elements of the
                 array are greater than or equal to 10.

    Example 2:
    Input: nums = [1,1,2,4,9], k = 1
    Output: 0
    Explanation: All elements of the array are greater than or equal to 1 so we
                 do not need to apply any operations on nums.

    Example 3:
    Input: nums = [1,1,2,4,9], k = 9
    Output: 4
    Explanation: only a single element of nums is greater than or equal to 9 so
                 we need to apply the operations 4 times on nums.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9
    * The input is generated such that there is at least one index i such that
      nums[i] >= k."""

    def minOperations(self, nums: List[int], k: int) -> int:
        return sum(1 for x in nums if x < k)


    """3066. Minimum Operations to Exceed Threshold Value II (Medium)
    You are given a 0-indexed integer array nums, and an integer k. In one
    operation, you will:
    * Take the two smallest integers x and y in nums.
    * Remove x and y from nums.
    * Add min(x, y) * 2 + max(x, y) anywhere in the array.
    Note that you can only apply the described operation if nums contains at
    least two elements. Return the minimum number of operations needed so that
    all elements of the array are greater than or equal to k.

    Example 1:
    Input: nums = [2,11,10,1,3], k = 10
    Output: 2
    Explanation: In the first operation, we remove elements 1 and 2, then add
                 1 * 2 + 2 to nums. nums becomes equal to [4, 11, 10, 3]. In the
                 second operation, we remove elements 3 and 4, then add
                 3 * 2 + 4 to nums. nums becomes equal to [10, 11, 10]. At this
                 stage, all the elements of nums are greater than or equal to 10
                 so we can stop. It can be shown that 2 is the minimum number of
                 operations needed so that all elements of the array are greater
                 than or equal to 10.

    Example 2:
    Input: nums = [1,1,2,4,9], k = 20
    Output: 4
    Explanation: After one operation, nums becomes equal to [2, 4, 9, 3].
                 After two operations, nums becomes equal to [7, 4, 9].
                 After three operations, nums becomes equal to [15, 9].
                 After four operations, nums becomes equal to [33].
                 At this stage, all the elements of nums are greater than 20 so
                 we can stop. It can be shown that 4 is the minimum number of
                 operations needed so that all elements of the array are greater
                 than or equal to 20.

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9
    * The input is generated such that an answer always exists. That is, there
      exists some sequence of operations after which all elements of the array
      are greater than or equal to k."""

    def minOperations(self, nums: List[int], k: int) -> int:
        n = len(nums)
        heapify(nums)
        while nums[0] < k:
            heappush(nums, 2*heappop(nums) + heappop(nums))
        return n - len(nums)


    """3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)
    You are given an unrooted weighted tree with n vertices representing servers
    numbered from 0 to n - 1, an array edges where edges[i] = [ai, bi, weighti]
    represents a bidirectional edge between vertices ai and bi of weight
    weighti. You are also given an integer signalSpeed. Two servers a and b are
    connectable through a server c if:
    * a < b, a != c and b != c.
    * The distance from c to a is divisible by signalSpeed.
    * The distance from c to b is divisible by signalSpeed.
    * The path from c to b and the path from c to a do not share any edges.
    Return an integer array count of length n where count[i] is the number of
    server pairs that are connectable through the server i.

    Example 1:
    Input: edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1
    Output: [0,4,6,6,4,0]
    Explanation: Since signalSpeed is 1, count[c] is equal to the number of
                 pairs of paths that start at c and do not share any edges. In
                 the case of the given path graph, count[c] is equal to the
                 number of servers to the left of c multiplied by the servers to
                 the right of c.

    Example 2:
    Input: edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3
    Output: [2,0,0,0,0,0,2]
    Explanation: Through server 0, there are 2 pairs of connectable servers:
                 (4, 5) and (4, 6). Through server 6, there are 2 pairs of
                 connectable servers: (4, 5) and (0, 5). It can be shown that no
                 two servers are connectable through servers other than 0 and 6.

    Constraints:
    * 2 <= n <= 1000
    * edges.length == n - 1
    * edges[i].length == 3
    * 0 <= ai, bi < n
    * edges[i] = [ai, bi, weighti]
    * 1 <= weighti <= 10^6
    * 1 <= signalSpeed <= 106^
    * The input is generated such that edges represents a valid tree."""

    def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:
        n = len(edges)+1
        tree = [[] for _ in range(n)]
        for u, v, w in edges:
            tree[u].append((v, w))
            tree[v].append((u, w))
        ans = [0]*n
        for x in range(n):
            prefix = 0
            for v, w in tree[x]:
                cnt = 0
                stack = [(x, v, w)]
                while stack:
                    p, u, w = stack.pop()
                    if w % signalSpeed == 0: cnt += 1
                    for v, wt in tree[u]:
                        if v != p:
                            stack.append((u, v, w+wt))
                ans[x] += prefix*cnt
                prefix += cnt
        return ans


    """3068. Find the Maximum Sum of Node Values (Hard)
    There exists an undirected tree with n nodes numbered 0 to n - 1. You are
    given a 0-indexed 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi
    in the tree. You are also given a positive integer k, and a 0-indexed array
    of non-negative integers nums of length n, where nums[i] represents the
    value of the node numbered i. Bogdan wants the sum of values of tree nodes
    to be maximum, for which Bogdan can perform the following operation any
    number of times (including zero) on the tree:
    * Choose any edge [u, v] connecting the nodes u and v, and update their
      values as follows:
      + nums[u] = nums[u] XOR k
      + nums[v] = nums[v] XOR k
    Return the maximum possible sum of the values Bogdan can achieve by
    performing the operation any number of times.

    Example 1:
    Input: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]
    Output: 6
    Explanation: Bogdan can achieve the maximum sum of 6 using a single
                 operation:
                 - Choose the edge [0,2]. nums[0] and nums[2] become:
                   1 XOR 3 = 2, and the array nums becomes: [1,2,1] -> [2,2,2].
                 The total sum of values is 2 + 2 + 2 = 6. It can be shown that
                 6 is the maximum achievable sum of values.

    Example 2:
    Input: nums = [2,3], k = 7, edges = [[0,1]]
    Output: 9
    Explanation: Bogdan can achieve the maximum sum of 9 using a single
                 operation:
                 - Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and
                   nums[1] become: 3 XOR 7 = 4, and the array nums becomes:
                   [2,3] -> [5,4].
                 The total sum of values is 5 + 4 = 9. It can be shown that 9 is
                 the maximum achievable sum of values.

    Example 3:
    Input: nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]]
    Output: 42
    Explanation: The maximum achievable sum is 42 which can be achieved by
                 Bogdan performing no operations.

    Constraints:
    * 2 <= n == nums.length <= 2 * 10^4
    * 1 <= k <= 10^9
    * 0 <= nums[i] <= 10^9
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * The input is generated such that edges represent a valid tree."""

    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        ans = cnt = 0
        diff = inf
        for x in nums:
            xx = x ^ k
            if x < xx: cnt ^= 1
            ans += max(x, xx)
            diff = min(diff, abs(xx-x))
        if cnt: ans -= diff
        return ans


    """3074. Apple Redistribution into Boxes (Easy)
    You are given an array apple of size n and an array capacity of size m.
    There are n packs where the ith pack contains apple[i] apples. There are m
    boxes as well, and the ith box has a capacity of capacity[i] apples. Return
    the minimum number of boxes you need to select to redistribute these n packs
    of apples into boxes. Note that, apples from the same pack can be
    distributed into different boxes.

    Example 1:
    Input: apple = [1,3,2], capacity = [4,3,1,5,2]
    Output: 2
    Explanation: We will use boxes with capacities 4 and 5. It is possible to
                 distribute the apples as the total capacity is greater than or
                 equal to the total number of apples.

    Example 2:
    Input: apple = [5,5,5], capacity = [2,4,2,7]
    Output: 4
    Explanation: We will need to use all the boxes.

    Constraints:
    * 1 <= n == apple.length <= 50
    * 1 <= m == capacity.length <= 50
    * 1 <= apple[i], capacity[i] <= 50
    * The input is generated such that it's possible to redistribute packs of
      apples into boxes."""

    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        total = sum(apple)
        for i, x in enumerate(sorted(capacity, reverse=True)):
            total -= x
            if total <= 0: return i+1


    """3075. Maximize Happiness of Selected Children (Medium)
    You are given an array happiness of length n, and a positive integer k.
    There are n children standing in a queue, where the ith child has happiness
    value happiness[i]. You want to select k children from these n children in k
    turns. In each turn, when you select a child, the happiness value of all the
    children that have not been selected till now decreases by 1. Note that the
    happiness value cannot become negative and gets decremented only if it is
    positive. Return the maximum sum of the happiness values of the selected
    children you can achieve by selecting k children.

    Example 1:
    Input: happiness = [1,2,3], k = 2
    Output: 4
    Explanation: We can pick 2 children in the following way:
                 - Pick the child with the happiness value == 3. The happiness
                   value of the remaining children becomes [0,1].
                 - Pick the child with the happiness value == 1. The happiness
                   value of the remaining child becomes [0]. Note that the
                   happiness value cannot become less than 0.
                 The sum of the happiness values of the selected children is
                 3 + 1 = 4.

    Example 2:
    Input: happiness = [1,1,1,1], k = 2
    Output: 1
    Explanation: We can pick 2 children in the following way:
                 - Pick any child with the happiness value == 1. The happiness
                   value of the remaining children becomes [0,0,0].
                 - Pick the child with the happiness value == 0. The happiness
                   value of the remaining child becomes [0,0].
                 The sum of the happiness values of the selected children is
                 1 + 0 = 1.
    Example 3:
    Input: happiness = [2,3,4,5], k = 1
    Output: 5
    Explanation: We can pick 1 child in the following way:
                 - Pick the child with the happiness value == 5. The happiness
                   value of the remaining children becomes [1,2,3].
                 The sum of the happiness values of the selected children is 5.

    Constraints:
    * 1 <= n == happiness.length <= 2 * 10^5
    * 1 <= happiness[i] <= 10^8
    * 1 <= k <= n"""

    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        ans = 0
        happiness.sort(reverse=True)
        for i in range(k):
            ans += max(0, happiness[i]-i)
        return ans


    """3076. Shortest Uncommon Substring in an Array (Medium)
    You are given an array arr of size n consisting of non-empty strings. Find a
    string array answer of size n such that:
    * answer[i] is the shortest substring of arr[i] that does not occur as a
      substring in any other string in arr. If multiple such substrings exist,
      answer[i] should be the lexicographically smallest. And if no such
      substring exists, answer[i] should be an empty string.
    Return the array answer.

    Example 1:
    Input: arr = ["cab","ad","bad","c"]
    Output: ["ab","","ba",""]
    Explanation: We have the following:
                 - For the string "cab", the shortest substring that does not
                   occur in any other string is either "ca" or "ab", we choose
                   the lexicographically smaller substring, which is "ab".
                 - For the string "ad", there is no substring that does not
                   occur in any other string.
                 - For the string "bad", the shortest substring that does not
                   occur in any other string is "ba".
                 - For the string "c", there is no substring that does not occur
                   in any other string.

    Example 2:
    Input: arr = ["abc","bcd","abcd"]
    Output: ["","","abcd"]
    Explanation: We have the following:
                 - For the string "abc", there is no substring that does not
                   occur in any other string.
                 - For the string "bcd", there is no substring that does not
                   occur in any other string.
                 - For the string "abcd", the shortest substring that does not
                   occur in any other string is "abcd".

    Constraints:
    * n == arr.length
    * 2 <= n <= 100
    * 1 <= arr[i].length <= 20
    * arr[i] consists only of lowercase English letters."""

    def shortestSubstrings(self, arr: List[str]) -> List[str]:
        seen = defaultdict(list)
        for i, word in enumerate(arr):
            for j in range(0, len(word)):
                for k in range(j, len(word)):
                    key = word[j:k+1]
                    if not seen[key] or seen[key][-1] != i: seen[key].append(i)
        ans = ['']*len(arr)
        for k, v in seen.items():
            if len(v) == 1:
                i = v.pop()
                if ans[i] == '' or len(ans[i]) > len(k) or len(ans[i]) == len(k) and ans[i] > k: ans[i] = k
        return ans


    """3077. Maximum Strength of K Disjoint Subarrays (Hard)
    You are given a 0-indexed array of integers nums of length n, and a positive
    odd integer k. The strength of x subarrays is defined as
    strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1
    where sum[i] is the sum of the elements in the ith subarray. Formally,
    strength is sum of (-1)i+1 * sum[i] * (x - i + 1) over all i's such that
    1 <= i <= x. You need to select k disjoint subarrays from nums, such that
    their strength is maximum. Return the maximum possible strength that can be
    obtained. Note that the selected subarrays don't need to cover the entire
    array.

    Example 1:
    Input: nums = [1,2,3,-1,2], k = 3
    Output: 22
    Explanation: The best possible way to select 3 subarrays is: nums[0..2],
                 nums[3..3], and nums[4..4]. The strength is
                 (1 + 2 + 3) * 3 - (-1) * 2 + 2 * 1 = 22.

    Example 2:
    Input: nums = [12,-2,-2,-2,-2], k = 5
    Output: 64
    Explanation: The only possible way to select 5 disjoint subarrays is:
                 nums[0..0], nums[1..1], nums[2..2], nums[3..3], and nums[4..4].
                 The strength is
                 12 * 5 - (-2) * 4 + (-2) * 3 - (-2) * 2 + (-2) * 1 = 64.

    Example 3:
    Input: nums = [-1,-2,-3], k = 1
    Output: -1
    Explanation: The best possible way to select 1 subarray is: nums[0..0]. The
                 strength is -1.

    Constraints:
    * 1 <= n <= 10^4
    * -10^9 <= nums[i] <= 10^9
    * 1 <= k <= n
    * 1 <= n * k <= 10^6
    * k is odd."""

    def maximumStrength(self, nums: List[int], k: int) -> int:
        dp = [[-1]*2 for _ in range(k+1)]
        dp[0][0] = dp[0][1] = 0
        for i in range(len(nums)-1, -1, -1):
            for j in range(k, 0, -1):
                cand = pow(-1, k-j)*nums[i]*j + max(dp[j][1], dp[j-1][0])
                dp[j][0] = max(cand, dp[j][0])
                dp[j][1] = max(cand, dp[j-1][0])
        return dp[k][0]


    """3079. Find the Sum of Encrypted Integers (Easy)
    You are given an integer array nums containing positive integers. We define
    a function encrypt such that encrypt(x) replaces every digit in x with the
    largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.
    Return the sum of encrypted elements.

    Example 1:
    Input: nums = [1,2,3]
    Output: 6
    Explanation: The encrypted elements are [1,2,3]. The sum of encrypted
                 elements is 1 + 2 + 3 == 6.

    Example 2:
    Input: nums = [10,21,31]
    Output: 66
    Explanation: The encrypted elements are [11,22,33]. The sum of encrypted
                 elements is 11 + 22 + 33 == 66.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 1000"""

    def sumOfEncryptedInt(self, nums: List[int]) -> int:
        ans = 0
        for x in nums:
            s = str(x)
            ans += int(max(s)*len(s))
        return ans


    """3080. Mark Elements on Array by Performing Queries (Medium)
    You are given a 0-indexed array nums of size n consisting of positive
    integers. You are also given a 2D array queries of size m where
    queries[i] = [indexi, ki]. Initially all elements of the array are unmarked.
    You need to apply m queries on the array in order, where on the ith query
    you do the following:
    * Mark the element at index indexi if it is not already marked.
    * Then mark ki unmarked elements in the array with the smallest values. If
      multiple such elements exist, mark the ones with the smallest indices. And
      if less than ki unmarked elements exist, then mark all of them.
    Return an array answer of size m where answer[i] is the sum of unmarked
    elements in the array after the ith query.

    Example 1:
    Input: nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]
    Output: [8,3,0]
    Explanation: We do the following queries on the array:
                 - Mark the element at index 1, and 2 of the smallest unmarked
                   elements with the smallest indices if they exist, the marked
                   elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked
                   elements is 2 + 2 + 3 + 1 = 8.
                 - Mark the element at index 3, since it is already marked we
                   skip it. Then we mark 3 of the smallest unmarked elements
                   with the smallest indices, the marked elements now are
                   nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 3.
                 - Mark the element at index 4, since it is already marked we
                   skip it. Then we mark 2 of the smallest unmarked elements
                   with the smallest indices if they exist, the marked elements
                   now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements
                   is 0.

    Example 2:
    Input: nums = [1,4,2,3], queries = [[0,1]]
    Output: [7]
    Explanation: We do one query which is mark the element at index 0 and mark
                 the smallest element among unmarked elements. The marked
                 elements will be nums = [1,4,2,3], and the sum of unmarked
                 elements is 4 + 3 = 7.

    Constraints:
    * n == nums.length
    * m == queries.length
    * 1 <= m <= n <= 10^5
    * 1 <= nums[i] <= 10^5
    * queries[i].length == 2
    * 0 <= indexi, ki <= n - 1"""

    def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        pq = [(x, i) for i, x in enumerate(nums)]
        heapify(pq)
        suffix = sum(nums)
        ans = []
        for i, k in queries:
            if nums[i]:
                suffix -= nums[i]
                nums[i] = 0
            while k and pq:
                _, j = heappop(pq)
                if nums[j]:
                    k -= 1
                    suffix -= nums[j]
                    nums[j] = 0
            ans.append(suffix)
        return ans


    """3081. Replace Question Marks in String to Minimize Its Value (Medium)
    You are given a string s. s[i] is either a lowercase English letter or '?'.
    For a string t having length m containing only lowercase English letters, we
    define the function cost(i) for an index i as the number of characters equal
    to t[i] that appeared before it, i.e. in the range [0, i - 1]. The value of
    t is the sum of cost(i) for all indices i. For example, for the string
    t = "aab":
    * cost(0) = 0
    * cost(1) = 1
    * cost(2) = 0
    * Hence, the value of "aab" is 0 + 1 + 0 = 1.
    Your task is to replace all occurrences of '?' in s with any lowercase
    English letter so that the value of s is minimized. Return a string denoting
    the modified string with replaced occurrences of '?'. If there are multiple
    strings resulting in the minimum value, return the lexicographically
    smallest one.

    Example 1:
    Input:  s = "???"
    Output:  "abc"
    Explanation: In this example, we can replace the occurrences of '?' to make
                 s equal to "abc". For "abc", cost(0) = 0, cost(1) = 0, and
                 cost(2) = 0. The value of "abc" is 0. Some other modifications
                 of s that have a value of 0 are "cba", "abz", and, "hey". Among
                 all of them, we choose the lexicographically smallest.

    Example 2:
    Input: s = "a?a?"
    Output: "abac"
    Explanation: In this example, the occurrences of '?' can be replaced to make
                 s equal to "abac". For "abac", cost(0) = 0, cost(1) = 0,
                 cost(2) = 1, and cost(3) = 0. The value of "abac" is 1.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either a lowercase English letter or '?'."""

    def minimizeStringValue(self, s: str) -> str:
        loc = []
        freq = [0]*26
        for i, ch in enumerate(s):
            if ch != '?': freq[ord(ch)-97] += 1
            else: loc.append(i)
        pq = [(x, ch) for x, ch in zip(freq, ascii_lowercase)]
        heapify(pq)
        vals = []
        for _ in loc:
            x, c = heappop(pq)
            vals.append(c)
            heappush(pq, (x+1, c))
        ans = list(s)
        for i, ch in zip(loc, sorted(vals)):
            ans[i] = ch
        return ''.join(ans)


    """3082. Find the Sum of the Power of All Subsequences (Hard)
    You are given an integer array nums of length n and a positive integer k.
    The power of an array of integers is defined as the number of subsequences
    with their sum equal to k. Return the sum of power of all subsequences of
    nums. Since the answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input:  nums = [1,2,3], k = 3
    Output:  6
    Explanation: There are 5 subsequences of nums with non-zero power:
                 - The subsequence [1,2,3] has 2 subsequences with sum == 3:
                   [1,2,3] and [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 Hence the answer is 2 + 1 + 1 + 1 + 1 = 6.

    Example 2:
    Input:  nums = [2,3,3], k = 5
    Output:  4
    Explanation: There are 3 subsequences of nums with non-zero power:
                 - The subsequence [2,3,3] has 2 subsequences with sum == 5:
                   [2,3,3] and [2,3,3].
                 - The subsequence [2,3,3] has 1 subsequence with sum == 5:
                   [2,3,3].
                 - The subsequence [2,3,3] has 1 subsequence with sum == 5:
                   [2,3,3].
                 Hence the answer is 2 + 1 + 1 = 4.

    Example 3:
    Input:  nums = [1,2,3], k = 7
    Output:  0
    Explanation: There exists no subsequence with sum 7. Hence all subsequences
                 of nums have power = 0.

    Constraints:
    * 1 <= n <= 100
    * 1 <= nums[i] <= 10^4
    * 1 <= k <= 100"""

    def sumOfPower(self, nums: List[int], k: int) -> int:
        n = min(k, len(nums))
        mod = 1_000_000_007
        dp = [[0]*(k+1) for _ in range(n+1)]
        dp[0][0] = 1
        for x in nums:
            for i in range(n, 0, -1):
                for j in range(k, x-1, -1):
                    dp[i][j] = (dp[i][j] + dp[i-1][j-x]) % mod
        return sum(dp[i][k]*pow(2, len(nums)-i, mod) for i in range(n+1)) % mod


    """3083. Existence of a Substring in a String and Its Reverse (Easy)
    Given a string s, find any substring of length 2 which is also present in
    the reverse of s. Return true if such a substring exists, and false
    otherwise.

    Example 1:
    Input: s = "leetcode"
    Output: true
    Explanation: Substring "ee" is of length 2 which is also present in
                 reverse(s) == "edocteel".

    Example 2:
    Input: s = "abcba"
    Output: true
    Explanation: All of the substrings of length 2 "ab", "bc", "cb", "ba" are
                 also present in reverse(s) == "abcba".

    Example 3:
    Input: s = "abcd"
    Output: false
    Explanation: There is no substring of length 2 in s, which is also present
                 in the reverse of s.

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of lowercase English letters."""

    def isSubstringPresent(self, s: str) -> bool:
        seen = set()
        for i in range(len(s)-1):
            seen.add(s[i:i+2])
        for i in range(len(s)-2, -1, -1):
            if s[i:i+2][::-1] in seen: return True
        return False


    """3084. Count Substrings Starting and Ending with Given Character (Medium)
    You are given a string s and a character c. Return the total number of
    substrings of s that start and end with c.

    Example 1:
    Input: s = "abada", c = "a"
    Output: 6
    Explanation: Substrings starting and ending with "a" are: "abada", "abada",
                 "abada", "abada", "abada", "abada".

    Example 2:
    Input: s = "zzz", c = "z"
    Output: 6
    Explanation: There are a total of 6 substrings in s and all start and end
                 with "z".

    Constraints:
    * 1 <= s.length <= 10^5
    * s and c consist only of lowercase English letters."""

    def countSubstrings(self, s: str, c: str) -> int:
        return (lambda x: x*(x+1)//2)(s.count(c))


    """3085. Minimum Deletions to Make String K-Special (Medium)
    You are given a string word and an integer k. We consider word to be
    k-special if |freq(word[i]) - freq(word[j])| <= k for all indices i and j in
    the string. Here, freq(x) denotes the frequency of the character x in word,
    and |y| denotes the absolute value of y. Return the minimum number of
    characters you need to delete to make word k-special.

    Example 1:
    Input: word = "aabcaba", k = 0
    Output: 3
    Explanation: We can make word 0-special by deleting 2 occurrences of "a" and
                 1 occurrence of "c". Therefore, word becomes equal to "baba"
                 where freq('a') == freq('b') == 2.

    Example 2:
    Input: word = "dabdcbdcdcd", k = 2
    Output: 2
    Explanation: We can make word 2-special by deleting 1 occurrence of "a" and
                 1 occurrence of "d". Therefore, word becomes equal to
                 "bdcbdcdcd" where freq('b') == 2, freq('c') == 3, and
                 freq('d') == 4.

    Example 3:
    Input: word = "aaabaaa", k = 2
    Output: 1
    Explanation: We can make word 2-special by deleting 1 occurrence of "b".
                 Therefore, word becomes equal to "aaaaaa" where each letter's
                 frequency is now uniformly 6.

    Constraints:
    * 1 <= word.length <= 10^5
    * 0 <= k <= 10^5
    * word consists only of lowercase English letters."""

    def minimumDeletions(self, word: str, k: int) -> int:
        freq = sorted(Counter(word).values())
        prefix = list(accumulate(freq, initial=0))
        ans = inf
        val = j = 0
        for i, x in enumerate(freq):
            while j < len(freq) and freq[j] - freq[i] <= k: j += 1
            cand = prefix[i] + prefix[-1] - prefix[j] - (len(freq)-j)*(freq[i]+k)
            ans = min(ans, cand)
        return ans


    """3086. Minimum Moves to Pick K Ones (Hard)
    You are given a binary array nums of length n, a positive integer k and a
    non-negative integer maxChanges. Alice plays a game, where the goal is for
    Alice to pick up k ones from nums using the minimum number of moves. When
    the game starts, Alice picks up any index aliceIndex in the range [0, n - 1]
    and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and
    nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice
    can make any number of moves (including zero) where in each move Alice must
    perform exactly one of the following actions:
    * Select any index j != aliceIndex such that nums[j] == 0 and set
      nums[j] = 1. This action can be performed at most maxChanges times.
    * Select any two adjacent indices x and y (|x - y| == 1) such that
      nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 and
      nums[x] = 0). If y == aliceIndex, Alice picks up the one after this move
      and nums[y] becomes 0.
    Return the minimum number of moves required by Alice to pick exactly k ones.

    Example 1:
    Input: nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1
    Output: 3
    Explanation: Alice can pick up 3 ones in 3 moves, if Alice performs the
                 following actions in each move when standing at
                 aliceIndex == 1:
                 * At the start of the game Alice picks up the one and nums[1]
                   becomes 0. nums becomes [1,1,1,0,0,1,1,0,0,1].
                 * Select j == 2 and perform an action of the first type. nums
                   becomes [1,0,1,0,0,1,1,0,0,1]
                 * Select x == 2 and y == 1, and perform an action of the second
                   type. nums becomes [1,1,0,0,0,1,1,0,0,1]. As y == aliceIndex,
                   Alice picks up the one and nums becomes [1,0,0,0,0,1,1,0,0,1].
                 * Select x == 0 and y == 1, and perform an action of the second
                   type. nums becomes [0,1,0,0,0,1,1,0,0,1]. As y == aliceIndex,
                   Alice picks up the one and nums becomes [0,0,0,0,0,1,1,0,0,1].
                 Note that it may be possible for Alice to pick up 3 ones using
                 some other sequence of 3 moves.

    Example 2:
    Input: nums = [0,0,0,0], k = 2, maxChanges = 3
    Output: 4
    Explanation: Alice can pick up 2 ones in 4 moves, if Alice performs the
                 following actions in each move when standing at
                 aliceIndex == 0:
                 * Select j == 1 and perform an action of the first type. nums
                   becomes [0,1,0,0].
                 * Select x == 1 and y == 0, and perform an action of the second
                   type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks
                   up the one and nums becomes [0,0,0,0].
                 * Select j == 1 again and perform an action of the first type.
                   nums becomes [0,1,0,0].
                 * Select x == 1 and y == 0 again, and perform an action of the
                   second type. nums becomes [1,0,0,0]. As y == aliceIndex,
                   Alice picks up the one and nums becomes [0,0,0,0].

    Constraints:
    * 2 <= n <= 10^5
    * 0 <= nums[i] <= 1
    * 1 <= k <= 10^5
    * 0 <= maxChanges <= 10^5
    * maxChanges + sum(nums) >= k"""

    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:
        cnt = seq = 0
        ones = []
        for i, x in enumerate(nums):
            if x: ones.append(i)
            seq = max(seq, cnt := x and cnt+1)
        seq = min(3, k, seq)
        if seq + maxChanges >= k: return max(0, seq-1) + 2*(k-seq)
        ans = inf
        n = k - maxChanges
        prefix = list(accumulate(ones, initial=0))
        for i in range(len(ones)-n+1):
            cand = (prefix[i+n] - prefix[i+(n+1)//2]) - (prefix[i+n//2] - prefix[i])
            ans = min(ans, cand+2*maxChanges)
        return ans


    """3090. Maximum Length Substring With Two Occurrences (Easy)
    Given a string s, return the maximum length of a substring such that it
    contains at most two occurrences of each character.

    Example 1:
    Input: s = "bcbbbcba"
    Output: 4
    Explanation: The following substring has a length of 4 and contains at most
                 two occurrences of each character: "bcbbbcba".

    Example 2:
    Input: s = "aaaa"
    Output: 2
    Explanation: The following substring has a length of 2 and contains at most
                 two occurrences of each character: "aaaa".

    Constraints:
    * 2 <= s.length <= 100
    * s consists only of lowercase English letters."""

    def maximumLengthSubstring(self, s: str) -> int:
        ans = ii = 0
        freq = Counter()
        for i, ch in enumerate(s):
            freq[ch] += 1
            while freq[ch] == 3:
                freq[s[ii]] -= 1
                ii += 1
            ans = max(ans, i-ii+1)
        return ans


    """3091. Apply Operations to Make Sum of Array Greater Than or Equal to k (Medium)
    You are given a positive integer k. Initially, you have an array nums = [1].
    You can perform any of the following operations on the array any number of
    times (possibly zero):
    * Choose any element in the array and increase its value by 1.
    * Duplicate any element in the array and add it to the end of the array.
    Return the minimum number of operations required to make the sum of elements
    of the final array greater than or equal to k.

    Example 1:
    Input: k = 11
    Output: 5
    Explanation: We can do the following operations on the array nums = [1]:
                 * Increase the element by 1 three times. The resulting array is
                   nums = [4].
                 * Duplicate the element two times. The resulting array is
                   nums = [4,4,4].
                 The sum of the final array is 4 + 4 + 4 = 12 which is greater
                 than or equal to k = 11. The total number of operations
                 performed is 3 + 2 = 5.

    Example 2:
    Input: k = 1
    Output: 0
    Explanation: The sum of the original array is already greater than or equal
                 to 1, so no operations are needed.

    Constraints: 1 <= k <= 10^5"""

    def minOperations(self, k: int) -> int:
        p = isqrt(k)
        q = (k+p-1)//p
        return p+q-2


    """3092. Most Frequent IDs (Medium)
    The problem involves tracking the frequency of IDs in a collection that
    changes over time. You have two integer arrays, nums and freq, of equal
    length n. Each element in nums represents an ID, and the corresponding
    element in freq indicates how many times that ID should be added to or
    removed from the collection at each step.
    * Addition of IDs: If freq[i] is positive, it means freq[i] IDs with the
      value nums[i] are added to the collection at step i.
    * Removal of IDs: If freq[i] is negative, it means -freq[i] IDs with the
      value nums[i] are removed from the collection at step i.
    Return an array ans of length n, where ans[i] represents the count of the
    most frequent ID in the collection after the ith step. If the collection is
    empty at any step, ans[i] should be 0 for that step.

    Example 1:
    Input: nums = [2,3,2,1], freq = [3,2,-3,1]
    Output: [3,3,2,2]
    Explanation: * After step 0, we have 3 IDs with the value of 2. So
                   ans[0] = 3.
                 * After step 1, we have 3 IDs with the value of 2 and 2 IDs
                   with the value of 3. So ans[1] = 3.
                 * After step 2, we have 2 IDs with the value of 3. So
                   ans[2] = 2.
                 * After step 3, we have 2 IDs with the value of 3 and 1 ID with
                   the value of 1. So ans[3] = 2.

    Example 2:
    Input: nums = [5,5,3], freq = [2,-2,1]
    Output: [2,0,1]
    Explanation: * After step 0, we have 2 IDs with the value of 5. So
                   ans[0] = 2.
                 * After step 1, there are no IDs. So ans[1] = 0.
                 * After step 2, we have 1 ID with the value of 3. So ans[2] = 1.

    Constraints:
    * 1 <= nums.length == freq.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * -10^5 <= freq[i] <= 10^5
    * freq[i] != 0
    * The input is generated such that the occurrences of an ID will not be
      negative in any step."""

    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:
        pq = []
        cnt = Counter()
        ans = []
        for x, f in zip(nums, freq):
            cnt[x] += f
            while pq and cnt[pq[0][1]] + pq[0][0] != 0: heappop(pq)
            heappush(pq, (-cnt[x], x))
            ans.append(-pq[0][0])
        return ans


    """3093. Longest Common Suffix Queries (Hard)
    You are given two arrays of strings wordsContainer and wordsQuery. For each
    wordsQuery[i], you need to find a string from wordsContainer that has the
    longest common suffix with wordsQuery[i]. If there are two or more strings
    in wordsContainer that share the longest common suffix, find the string that
    is the smallest in length. If there are two or more such strings that have
    the same smallest length, find the one that occurred earlier in
    wordsContainer. Return an array of integers ans, where ans[i] is the index
    of the string in wordsContainer that has the longest common suffix with
    wordsQuery[i].

    Example 1:
    Input: wordsContainer = ["abcd","bcd","xbcd"], wordsQuery = ["cd","bcd","xyz"]
    Output: [1,1,1]
    Explanation: Let's look at each wordsQuery[i] separately:
                 - For wordsQuery[0] = "cd", strings from wordsContainer that
                   share the longest common suffix "cd" are at indices 0, 1, and
                   2. Among these, the answer is the string at index 1 because
                   it has the shortest length of 3.
                 - For wordsQuery[1] = "bcd", strings from wordsContainer that
                   share the longest common suffix "bcd" are at indices 0, 1,
                   and 2. Among these, the answer is the string at index 1
                   because it has the shortest length of 3.
                 - For wordsQuery[2] = "xyz", there is no string from
                   wordsContainer that shares a common suffix. Hence the longest
                   common suffix is "", that is shared with strings at index 0,
                   1, and 2. Among these, the answer is the string at index 1
                   because it has the shortest length of 3.

    Example 2:
    Input: wordsContainer = ["abcdefgh","poiuygh","ghghgh"], wordsQuery = ["gh","acbfgh","acbfegh"]
    Output: [2,0,2]
    Explanation: Let's look at each wordsQuery[i] separately:
                 - For wordsQuery[0] = "gh", strings from wordsContainer that
                   share the longest common suffix "gh" are at indices 0, 1, and
                   2. Among these, the answer is the string at index 2 because
                   it has the shortest length of 6.
                 - For wordsQuery[1] = "acbfgh", only the string at index 0
                   shares the longest common suffix "fgh". Hence it is the
                   answer, even though the string at index 2 is shorter.
                 - For wordsQuery[2] = "acbfegh", strings from wordsContainer
                   that share the longest common suffix "gh" are at indices 0,
                   1, and 2. Among these, the answer is the string at index 2
                   because it has the shortest length of 6.

    Constraints:
    * 1 <= wordsContainer.length, wordsQuery.length <= 10^4
    * 1 <= wordsContainer[i].length <= 5 * 10^3
    * 1 <= wordsQuery[i].length <= 5 * 10^3
    * wordsContainer[i] consists only of lowercase English letters.
    * wordsQuery[i] consists only of lowercase English letters.
    * Sum of wordsContainer[i].length is at most 5 * 10^5.
    * Sum of wordsQuery[i].length is at most 5 * 10^5."""

    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:
        trie = {}
        for i, w in enumerate(wordsContainer):
            node = trie
            if '$' not in node or len(w) < node['$'][1]:
                node['$'] = (i, len(w))
            for ch in reversed(w):
                node = node.setdefault(ch, {})
                if '$' not in node or len(w) < node['$'][1]:
                    node['$'] = (i, len(w))
        ans = []
        for w in wordsQuery:
            node = trie
            for ch in reversed(w):
                if ch not in node: break
                node = node[ch]
            ans.append(node['$'][0])
        return ans


    """3099. Harshad Number (Easy)
    An integer divisible by the sum of its digits is said to be a Harshad
    number. You are given an integer x. Return the sum of the digits of x if x
    is a Harshad number, otherwise, return -1.

    Example 1:
    Input: x = 18
    Output: 9
    Explanation: The sum of digits of x is 9. 18 is divisible by 9. So 18 is a
                 Harshad number and the answer is 9.

    Example 2:
    Input: x = 23
    Output: -1
    Explanation: The sum of digits of x is 5. 23 is not divisible by 5. So 23 is
                 not a Harshad number and the answer is -1.

    Constraints: 1 <= x <= 100"""

    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:
        val = sum(map(int, str(x)))
        return val if x % val == 0 else -1


    """3100. Water Bottles II (Medium)
    You are given two integers numBottles and numExchange. numBottles represents
    the number of full water bottles that you initially have. In one operation,
    you can perform one of the following operations:
    * Drink any number of full water bottles turning them into empty bottles.
    * Exchange numExchange empty bottles with one full water bottle. Then,
      increase numExchange by one.
    Note that you cannot exchange multiple batches of empty bottles for the same
    value of numExchange. For example, if numBottles == 3 and numExchange == 1,
    you cannot exchange 3 empty water bottles for 3 full bottles. Return the
    maximum number of water bottles you can drink.

    Example 1:
    Input: numBottles = 13, numExchange = 6
    Output: 15
    Explanation: The table above shows the number of full water bottles, empty
                 water bottles, the value of numExchange, and the number of
                 bottles drunk.

    Example 2:
    Input: numBottles = 10, numExchange = 3
    Output: 13
    Explanation: The table above shows the number of full water bottles, empty
                 water bottles, the value of numExchange, and the number of
                 bottles drunk.

    Constraints:
    * 1 <= numBottles <= 100
    * 1 <= numExchange <= 100"""

    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
        ans = empty = 0
        while numBottles:
            ans += numBottles
            empty += numBottles
            numBottles = 0
            while empty>= numExchange:
                empty -= numExchange
                numBottles += 1
                numExchange += 1
        return ans


    """3101. Count Alternating Subarrays (Medium)
    You are given a binary array nums. We call a subarray alternating if no two
    adjacent elements in the subarray have the same value. Return the number of
    alternating subarrays in nums.

    Example 1:
    Input: nums = [0,1,1,1]
    Output: 5
    Explanation: The following subarrays are alternating: [0], [1], [1], [1],
                 and [0,1].

    Example 2:
    Input: nums = [1,0,1,0]
    Output: 10
    Explanation: Every subarray of the array is alternating. There are 10
                 possible subarrays that we can choose.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1."""

    def countAlternatingSubarrays(self, nums: List[int]) -> int:
        ans = cnt = 0
        for i in range(len(nums)):
            if i and nums[i-1] == nums[i]: cnt = 0
            cnt += 1
            ans += cnt
        return ans


    """3102. Minimize Manhattan Distances (Hard)
    You are given a 0-indexed array points representing integer coordinates of
    some points on a 2D plane, where points[i] = [xi, yi]. The distance between
    two points is defined as their Manhattan distance. Return the minimum
    possible value for maximum distance between any two points by removing
    exactly one point.

    Example 1:
    Input: points = [[3,10],[5,15],[10,2],[4,4]]
    Output: 12
    Explanation: The maximum distance after removing each point is the following:
                 - After removing the 0th point the maximum distance is between
                   points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.
                 - After removing the 1st point the maximum distance is between
                   points (3, 10) and (10, 2), which is |3 - 10| + |10 - 2| = 15.
                 - After removing the 2nd point the maximum distance is between
                   points (5, 15) and (4, 4), which is |5 - 4| + |15 - 4| = 12.
                 - After removing the 3rd point the maximum distance is between
                   points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.
                 It can be seen that 12 is the minimum possible maximum distance
                 between any two points after removing exactly one point.

    Example 2:
    Input: points = [[1,1],[1,1],[1,1]]
    Output: 0
    Explanation: It can be seen that removing any of the points results in the
                 maximum distance between any two points of 0.

    Constraints:
    * 3 <= points.length <= 10^5
    * points[i].length == 2=
    * 1 <= points[i][0], points[i][1] <= 10^8"""

    def minimumDistance(self, points: List[List[int]]) -> int:
        diff = []
        summ = []
        for i, (x, y) in enumerate(points):
            diff.append([x-y, i])
            summ.append([x+y, i])
        d0, d1 = nsmallest(2, diff); d3, d2 = nlargest(2, diff)
        s0, s1 = nsmallest(2, summ); s3, s2 = nlargest(2, summ)
        cand = d0[1], d3[1]
        if d3[0] - d0[0] < s3[0] - s0[0]: cand = s0[1], s3[1]
        ans = inf
        for x in cand:
            val = 0
            if s0[1] == x: val = max(val, s3[0] - s1[0])
            elif s3[1] == x: val = max(val, s2[0] - s0[0])
            else: val = max(val, s3[0] - s0[0])
            if d0[1] == x: val = max(val, d3[0] - d1[0])
            elif d3[1] == x: val = max(val, d2[0] - d0[0])
            else: val = max(val, d3[0] - d0[0])
            ans = min(ans, val)
        return ans


    """3105. Longest Strictly Increasing or Strictly Decreasing Subarray (Easy)
    You are given an array of integers nums. Return the length of the longest
    subarray of nums which is either strictly increasing or strictly decreasing.

    Example 1:
    Input: nums = [1,4,3,3,2]
    Output: 2
    Explanation: The strictly increasing subarrays of nums are [1], [2], [3],
                 [3], [4], and [1,4]. The strictly decreasing subarrays of nums
                 are [1], [2], [3], [3], [4], [3,2], and [4,3]. Hence, we return
                 2.

    Example 2:
    Input: nums = [3,3,3,3]
    Output: 1
    Explanation: The strictly increasing subarrays of nums are [3], [3], [3],
                 and [3]. The strictly decreasing subarrays of nums are [3],
                 [3], [3], and [3]. Hence, we return 1.

    Example 3:
    Input: nums = [3,2,1]
    Output: 3
    Explanation: The strictly increasing subarrays of nums are [3], [2], and
                 [1]. The strictly decreasing subarrays of nums are [3], [2],
                 [1], [3,2], [2,1], and [3,2,1]. Hence, we return 3.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50"""

    def longestMonotonicSubarray(self, nums: List[int]) -> int:
        ans = val = 0
        for i in range(len(nums)):
            if i and nums[i-1] == nums[i]: val = 0
            elif i >= 2 and (nums[i-2] - nums[i-1]) * (nums[i-1] - nums[i]) <= 0: val = 1
            val += 1
            ans = max(ans, val)
        return ans


    """3106. Lexicographically Smallest String After Operations With Constraint (Medium)
    You are given a string s and an integer k. Define a function
    distance(s1, s2) between two strings s1 and s2 of the same length n as:
    * The sum of the minimum distance between s1[i] and s2[i] when the
      characters from 'a' to 'z' are placed in a cyclic order, for all i in the
      range [0, n - 1].
    For example, distance("ab", "cd") == 4, and distance("a", "z") == 1. You can
    change any letter of s to any other lowercase English letter, any number of
    times. Return a string denoting the lexicographically smallest string t you
    can get after some changes, such that distance(s, t) <= k.

    Example 1:
    Input: s = "zbbz", k = 3
    Output: "aaaz"
    Explanation: Change s to "aaaz". The distance between "zbbz" and "aaaz" is
                 equal to k = 3.

    Example 2:
    Input: s = "xaxcd", k = 4
    Output: "aawcd"
    Explanation: The distance between "xaxcd" and "aawcd" is equal to k = 4.

    Example 3:
    Input: s = "lol", k = 0
    Output: "lol"
    Explanation: It's impossible to change any character as k = 0.

    Constraints:
    * 1 <= s.length <= 100
    * 0 <= k <= 2000
    * s consists only of lowercase English letters."""

    def getSmallestString(self, s: str, k: int) -> str:
        ans = []
        for ch in s:
            v = ord(ch) - 97
            dist = min(v, 26-v)
            if dist <= k: ans.append('a')
            else: ans.append(chr(v-k+97))
            k -= min(k, dist)
        return ''.join(ans)


    """3107. Minimum Operations to Make Median of Array Equal to K (Medium)
    You are given an integer array nums and a non-negative integer k. In one
    operation, you can increase or decrease any element by 1. Return the minimum
    number of operations needed to make the median of nums equal to k. The
    median of an array is defined as the middle element of the array when it is
    sorted in non-decreasing order. If there are two choices for a median, the
    larger of the two values is taken.

    Example 1:
    Input: nums = [2,5,6,8,5], k = 4
    Output: 2
    Explanation: We can subtract one from nums[1] and nums[4] to obtain
                 [2, 4, 6, 8, 4]. The median of the resulting array is equal to
                 k.

    Example 2:
    Input: nums = [2,5,6,8,5], k = 7
    Output: 3
    Explanation: We can add one to nums[1] twice and add one to nums[2] once to
                 obtain [2, 7, 7, 8, 5].

    Example 3:
    Input: nums = [1,2,3,4,5,6], k = 4
    Output: 0
    Explanation: The median of the array is already equal to k.

    Constraints:
    * 1 <= nums.length <= 2 * 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9"""

    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = 0
        for i, x in enumerate(nums):
            if i < len(nums)//2: ans += max(0, x-k)
            elif i == len(nums)//2: ans += abs(x-k)
            else: ans += max(0, k-x)
        return ans


    """3108. Minimum Cost Walk in Weighted Graph (Hard)
    There is an undirected weighted graph with n vertices labeled from 0 to
    n - 1. You are given the integer n and an array edges, where
    edges[i] = [ui, vi, wi] indicates that there is an edge between vertices ui
    and vi with a weight of wi. A walk on a graph is a sequence of vertices and
    edges. The walk starts and ends with a vertex, and each edge connects the
    vertex that comes before it and the vertex that comes after it. It's
    important to note that a walk may visit the same edge or vertex more than
    once. The cost of a walk starting at node u and ending at node v is defined
    as the bitwise AND of the weights of the edges traversed during the walk. In
    other words, if the sequence of edge weights encountered during the walk is
    w0, w1, w2, ..., wk, then the cost is calculated as w0 & w1 & w2 & ... & wk,
    where & denotes the bitwise AND operator. You are also given a 2D array
    query, where query[i] = [si, ti]. For each query, you need to find the
    minimum cost of the walk starting at vertex si and ending at vertex ti. If
    there exists no such walk, the answer is -1. Return the array answer, where
    answer[i] denotes the minimum cost of a walk for query i.

    Example 1:
    Input: n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]
    Output: [1,-1]
    Explanation: To achieve the cost of 1 in the first query, we need to move on
                 the following edges: 0->1 (weight 7), 1->2 (weight 1),
                 2->1 (weight 1), 1->3 (weight 7). In the second query, there is
                 no walk between nodes 3 and 4, so the answer is -1.

    Example 2:
    Input: n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]
    Output: [0]
    Explanation: To achieve the cost of 0 in the first query, we need to move on
                 the following edges: 1->2 (weight 1), 2->1 (weight 6),
                 1->2 (weight 1).

    Constraints:
    * 1 <= n <= 10^5
    * 0 <= edges.length <= 10^5
    * edges[i].length == 3
    * 0 <= ui, vi <= n - 1
    * ui != vi
    * 0 <= wi <= 10^5
    * 1 <= query.length <= 10^5
    * query[i].length == 2
    * 0 <= si, ti <= n - 1"""

    def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:

        def find(p):
            """Return parent of p"""
            if parent[p] != p: parent[p] = find(parent[p])
            return parent[p]

        parent = list(range(n))
        weight = [-1]*n
        for u, v, w in edges:
            uu, vv = find(u), find(v)
            if uu != vv: parent[vv] = uu
            weight[uu] &= weight[vv] & w
        ans = []
        for u, v in query:
            if u == v: ans.append(0)
            else:
                uu, vv = find(u), find(v)
                if uu == vv: ans.append(weight[uu])
                else: ans.append(-1)
        return ans


    """3110. Score of a String (Easy)
    You are given a string s. The score of a string is defined as the sum of the
    absolute difference between the ASCII values of adjacent characters. Return
    the score of s.

    Example 1:
    Input: s = "hello"
    Output: 13
    Explanation: The ASCII values of the characters in s are: 'h' = 104,
                 'e' = 101, 'l' = 108, 'o' = 111. So, the score of s would be
                 |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111|
                 = 3 + 7 + 0 + 3 = 13.

    Example 2:
    Input: s = "zaz"
    Output: 50
    Explanation: The ASCII values of the characters in s are: 'z' = 122,
                 'a' = 97. So, the score of s would be
                 |122 - 97| + |97 - 122| = 25 + 25 = 50.

    Constraints:
    * 2 <= s.length <= 100
    * s consists only of lowercase English letters."""

    def scoreOfString(self, s: str) -> int:
        return sum(abs(ord(x)-ord(y)) for x, y in pairwise(s))


    """3111. Minimum Rectangles to Cover Points (Medium)
    You are given a 2D integer array points, where points[i] = [xi, yi]. You are
    also given an integer w. Your task is to cover all the given points with
    rectangles. Each rectangle has its lower end at some point (x1, 0) and its
    upper end at some point (x2, y2), where x1 <= x2, y2 >= 0, and the condition
    x2 - x1 <= w must be satisfied for each rectangle. A point is considered
    covered by a rectangle if it lies within or on the boundary of the
    rectangle. Return an integer denoting the minimum number of rectangles
    needed so that each point is covered by at least one rectangle. Note: A
    point may be covered by more than one rectangle.

    Example 1:
    Input: points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1
    Output: 2
    Explanation: The image above shows one possible placement of rectangles to
                 cover the points:
                 - A rectangle with a lower end at (1, 0) and its upper end at
                   (2, 8)
                 - A rectangle with a lower end at (3, 0) and its upper end at
                   (4, 8)

    Example 2:
    Input: points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2
    Output: 3
    Explanation: The image above shows one possible placement of rectangles to
                 cover the points:
                 - A rectangle with a lower end at (0, 0) and its upper end at
                   (2, 2)
                 - A rectangle with a lower end at (3, 0) and its upper end at
                   (5, 5)
                 - A rectangle with a lower end at (6, 0) and its upper end at
                   (6, 6)

    Example 3:
    Input: points = [[2,3],[1,2]], w = 0
    Output: 2
    Explanation: The image above shows one possible placement of rectangles to
                 cover the points:
                 - A rectangle with a lower end at (1, 0) and its upper end at
                   (1, 2)
                 - A rectangle with a lower end at (2, 0) and its upper end at
                   (2, 3)

    Constraints:
    * 1 <= points.length <= 10^5
    * points[i].length == 2
    * 0 <= xi == points[i][0] <= 10^9
    * 0 <= yi == points[i][1] <= 10^9
    * 0 <= w <= 10^9
    * All pairs (xi, yi) are distinct."""

    def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -> int:
        ans = 0
        prev = -inf
        for x, _ in sorted(points):
            if prev + w < x:
                ans += 1
                prev = x
        return ans


    """3112. Minimum Time to Visit Disappearing Nodes (Medium)
    There is an undirected graph of n nodes. You are given a 2D array edges,
    where edges[i] = [ui, vi, lengthi] describes an edge between node ui and
    node vi with a traversal time of lengthi units. Additionally, you are given
    an array disappear, where disappear[i] denotes the time when the node i
    disappears from the graph and you won't be able to visit it. Notice that the
    graph might be disconnected and might contain multiple edges. Return the
    array answer, with answer[i] denoting the minimum units of time required to
    reach node i from node 0. If node i is unreachable from node 0 then
    answer[i] is -1.

    Example 1:
    Input:  n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]
    Output:  [0,-1,4]
    Explanation: We are starting our journey from node 0, and our goal is to
                 find the minimum time required to reach each node before it
                 disappears.
                 - For node 0, we don't need any time as it is our starting
                   point.
                 - For node 1, we need at least 2 units of time to traverse
                   edges[0]. Unfortunately, it disappears at that moment, so we
                   won't be able to visit it.
                 - For node 2, we need at least 4 units of time to traverse
                   edges[2].

    Example 2:
    Input:  n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]
    Output:  [0,2,3]
    Explanation: We are starting our journey from node 0, and our goal is to
                 find the minimum time required to reach each node before it
                 disappears.
                 - For node 0, we don't need any time as it is the starting
                   point.
                 - For node 1, we need at least 2 units of time to traverse
                   edges[0].
                 - For node 2, we need at least 3 units of time to traverse
                   edges[0] and edges[1].

    Example 3:
    Input: n = 2, edges = [[0,1,1]], disappear = [1,1]
    Output: [0,-1]
    Explanation: Exactly when we reach node 1, it disappears.

    Constraints:
    * 1 <= n <= 5 * 10^4
    * 0 <= edges.length <= 10^5
    * edges[i] == [ui, vi, lengthi]
    * 0 <= ui, vi <= n - 1
    * 1 <= lengthi <= 10^5
    * disappear.length == n
    * 1 <= disappear[i] <= 10^5"""

    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        graph = [[] for _ in range(n)]
        for u, v, w in edges:
            graph[u].append((v, w))
            graph[v].append((u, w))
        pq = [(0, 0)]
        ans = [inf]*n
        ans[0] = 0
        while pq:
            x, u = heappop(pq)
            if x == ans[u]:
                for v, w in graph[u]:
                    if x+w < disappear[v] and x+w < ans[v]:
                        ans[v] = x+w
                        heappush(pq, (x+w, v))
        return [x if x < inf else -1 for x in ans]


    """3113. Find the Number of Subarrays Where Boundary Elements Are Maximum (Hard)
    You are given an array of positive integers nums. Return the number of
    subarrays of nums, where the first and the last elements of the subarray are
    equal to the largest element in the subarray.

    Example 1:
    Input: nums = [1,4,3,3,2]
    Output: 6
    Explanation: There are 6 subarrays which have the first and the last
                 elements equal to the largest element of the subarray:
                 - subarray [1,4,3,3,2], with its largest element 1. The first
                   element is 1 and the last element is also 1.
                 - subarray [1,4,3,3,2], with its largest element 4. The first
                   element is 4 and the last element is also 4.
                 - subarray [1,4,3,3,2], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [1,4,3,3,2], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [1,4,3,3,2], with its largest element 2. The first
                   element is 2 and the last element is also 2.
                 - subarray [1,4,3,3,2], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 Hence, we return 6.

    Example 2:
    Input: nums = [3,3,3]
    Output: 6
    Explanation: There are 6 subarrays which have the first and the last
                 elements equal to the largest element of the subarray:
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 Hence, we return 6.

    Example 3:
    Input: nums = [1]
    Output: 1
    Explanation: There is a single subarray of nums which is [1], with its
                 largest element 1. The first element is 1 and the last element
                 is also 1. Hence, we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9"""

    def numberOfSubarrays(self, nums: List[int]) -> int:
        dp = [1]*len(nums)
        stack = []
        for i, x in enumerate(nums):
            while stack and stack[-1][1] <= x:
                ii, xx = stack.pop()
                if xx == x:
                    dp[i] = dp[ii]+1
                    break
            stack.append((i, x))
        return sum(dp)


    """3114. Latest Time You Can Obtain After Replacing Characters (Easy)
    You are given a string s representing a 12-hour format time where some of
    the digits (possibly none) are replaced with a "?". 12-hour times are
    formatted as "HH:MM", where HH is between 00 and 11, and MM is between 00
    and 59. The earliest 12-hour time is 00:00, and the latest is 11:59. You
    have to replace all the "?" characters in s with digits such that the time
    we obtain by the resulting string is a valid 12-hour format time and is the
    latest possible. Return the resulting string.

    Example 1:
    Input: s = "1?:?4"
    Output: "11:54"
    Explanation: The latest 12-hour format time we can achieve by replacing "?"
                 characters is "11:54".

    Example 2:
    Input: s = "0?:5?"
    Output: "09:59"
    Explanation: The latest 12-hour format time we can achieve by replacing "?"
                 characters is "09:59".

    Constraints:
    * s.length == 5
    * s[2] is equal to the character ":".
    * All characters except s[2] are digits or "?" characters.
    * The input is generated such that there is at least one time between
      "00:00" and "11:59" that you can obtain after replacing the "?"
      characters."""

    def findLatestTime(self, s: str) -> str:
        s = list(s)
        if s[0] == '?':
            s[0] = '1' if s[1] == '?' or s[1] <= '1' else '0'
        if s[1] == '?':
            s[1] = '1' if s[0] == '1' else '9'
        if s[3] == '?': s[3] = '5'
        if s[4] == '?': s[4] = '9'
        return ''.join(s)


    """3115. Maximum Prime Difference (Medium)
    You are given an integer array nums. Return an integer that is the maximum
    distance between the indices of two (not necessarily different) prime
    numbers in nums.

    Example 1:
    Input: nums = [4,2,9,5,3]
    Output: 3
    Explanation: nums[1], nums[3], and nums[4] are prime. So the answer is
                 |4 - 1| = 3.

    Example 2:
    Input: nums = [4,8,2,8]
    Output: 0
    Explanation: nums[2] is prime. Because there is just one prime number, the
                 answer is |2 - 2| = 0.

    Constraints:
    * 1 <= nums.length <= 3 * 10^5
    * 1 <= nums[i] <= 100
    * The input is generated such that the number of prime numbers in the nums
      is at least one."""

    def maximumPrimeDifference(self, nums: List[int]) -> int:
        sieve = [True]*101
        sieve[0] = sieve[1] = False
        for x in range(2, 11):
            if sieve[x]:
                for xx in range(x*x, 101, x):
                    sieve[xx] = False
        lo = hi = -1
        for i, x in enumerate(nums):
            if sieve[x]:
                if lo == -1: lo = i
                hi = i
        return hi - lo


    """3116. Kth Smallest Amount With Single Denomination Combination (Hard)
    You are given an integer array coins representing coins of different
    denominations and an integer k. You have an infinite number of coins of each
    denomination. However, you are not allowed to combine coins of different
    denominations. Return the kth smallest amount that can be made using these
    coins.

    Example 1:
    Input: coins = [3,6,9], k = 3
    Output:  9
    Explanation: The given coins can make the following amounts:
                 Coin 3 produces multiples of 3: 3, 6, 9, 12, 15, etc.
                 Coin 6 produces multiples of 6: 6, 12, 18, 24, etc.
                 Coin 9 produces multiples of 9: 9, 18, 27, 36, etc.
                 All of the coins combined produce: 3, 6, 9, 12, 15, etc.

    Example 2:
    Input: coins = [5,2], k = 7
    Output: 12
    Explanation: The given coins can make the following amounts:
                 Coin 5 produces multiples of 5: 5, 10, 15, 20, etc.
                 Coin 2 produces multiples of 2: 2, 4, 6, 8, 10, 12, etc.
                 All of the coins combined produce: 2, 4, 5, 6, 8, 10, 12, 14,
                 15, etc.

    Constraints:
    * 1 <= coins.length <= 15
    * 1 <= coins[i] <= 25
    * 1 <= k <= 2 * 10^9
    * coins contains pairwise distinct integers."""

    def findKthSmallest(self, coins: List[int], k: int) -> int:
        n = len(coins)

        def fn(val):
            """Return number of denominations <= val."""
            ans = 0
            for i in range(1, n+1):
                for comb in combinations(coins, i):
                    x = lcm(*comb)
                    ans -= pow(-1, i)*(val//x)
            return ans

        lo, hi = 0, k*min(coins)
        while lo < hi:
            mid = lo + hi >> 1
            if fn(mid) < k: lo = mid+1
            else: hi = mid
        return lo


    """3117. Minimum Sum of Values by Dividing Array (Hard)
    You are given two arrays nums and andValues of length n and m respectively.
    The value of an array is equal to the last element of that array. You have
    to divide nums into m disjoint contiguous subarrays such that for the ith
    subarray [li, ri], the bitwise AND of the subarray elements is equal to
    andValues[i], in other words, nums[li] & nums[li + 1] & ... &
    nums[ri] == andValues[i] for all 1 <= i <= m, where & represents the bitwise
    AND operator. Return the minimum possible sum of the values of the m
    subarrays nums is divided into. If it is not possible to divide nums into m
    subarrays satisfying these conditions, return -1.

    Example 1:
    Input: nums = [1,4,3,3,2], andValues = [0,3,3,2]
    Output: 12
    Explanation: The only possible way to divide nums is:
                 - [1,4] as 1 & 4 == 0.
                 - [3] as the bitwise AND of a single element subarray is that
                   element itself.
                 - [3] as the bitwise AND of a single element subarray is that
                   element itself.
                 - [2] as the bitwise AND of a single element subarray is that
                   element itself.
                 - The sum of the values for these subarrays is
                   4 + 3 + 3 + 2 = 12.

    Example 2:
    Input: nums = [2,3,5,7,7,7,5], andValues = [0,7,5]
    Output: 17
    Explanation: There are three ways to divide nums:
                 - [[2,3,5],[7,7,7],[5]] with the sum of the values
                   5 + 7 + 5 == 17.
                 - [[2,3,5,7],[7,7],[5]] with the sum of the values
                   7 + 7 + 5 == 19.
                 - [[2,3,5,7,7],[7],[5]] with the sum of the values
                   7 + 7 + 5 == 19.
                 - The minimum possible sum of the values is 17.

    Example 3:
    Input: nums = [1,2,3,4], andValues = [2]
    Output: -1
    Explanation: The bitwise AND of the entire array nums is 0. As there is no
                 possible way to divide nums into a single subarray to have the
                 bitwise AND of elements 2, return -1.

    Constraints:
    * 1 <= n == nums.length <= 10^4
    * 1 <= m == andValues.length <= min(n, 10)
    * 1 <= nums[i] < 10^5
    * 0 <= andValues[j] < 10^5"""

    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:
        m, n = len(nums), len(andValues)

        @cache
        def fn(i, j, mask):
            """Return min sum at nums[j] and andValues[k] with given mask."""
            if i == m and j == n: return 0
            if i == m or j == n: return inf
            mask &= nums[i]
            if mask < andValues[j]: return inf
            if mask == andValues[j]: return min(fn(i+1, j, mask), nums[i] + fn(i+1, j+1, -1))
            return fn(i+1, j, mask)

        ans = fn(0, 0, -1)
        return ans if ans < inf else -1


    """3120. Count the Number of Special Characters I (Easy)
    You are given a string word. A letter is called special if it appears both
    in lowercase and uppercase in word. Return the number of special letters in
    word.

    Example 1:
    Input: word = "aaAbcBC"
    Output: 3
    Explanation: The special characters in word are 'a', 'b', and 'c'.

    Example 2:
    Input: word = "abc"
    Output: 0
    Explanation: No character in word appears in uppercase.

    Example 3:
    Input: word = "abBCab"
    Output: 1
    Explanation: The only special character in word is 'b'.

    Constraints:
    * 1 <= word.length <= 50
    * word consists of only lowercase and uppercase English letters."""

    def numberOfSpecialChars(self, word: str) -> int:
        lower = upper = 0
        for ch in word:
            if ch.islower(): lower |= 1<<ord(ch)-97
            else: upper |= 1<<ord(ch)-65
        return (lower&upper).bit_count()


    """3121. Count the Number of Special Characters II (Medium)
    You are given a string word. A letter c is called special if it appears both
    in lowercase and uppercase in word, and every lowercase occurrence of c
    appears before the first uppercase occurrence of c. Return the number of
    special letters in word.

    Example 1:
    Input: word = "aaAbcBC"
    Output: 3
    Explanation: The special characters are 'a', 'b', and 'c'.

    Example 2:
    Input: word = "abc"
    Output: 0
    Explanation: There are no special characters in word.

    Example 3:
    Input: word = "AbBCab"
    Output: 0
    Explanation: There are no special characters in word.

    Constraints:
    * 1 <= word.length <= 2 * 10^5
    * word consists of only lowercase and uppercase English letters."""

    def numberOfSpecialChars(self, word: str) -> int:
        lower = upper = 0
        for ch in word:
            if ch.islower():
                lower &= ~(1 << ord(ch)-97)
                lower |= ~upper & 1 << ord(ch)-97
            else: upper |= 1 << ord(ch)-65
        return (lower & upper).bit_count()


    """3122. Minimum Number of Operations to Satisfy Conditions (Medium)
    You are given a 2D matrix grid of size m x n. In one operation, you can
    change the value of any cell to any non-negative number. You need to perform
    some operations such that each cell grid[i][j] is:
    * Equal to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it
      exists).
    * Different from the cell to its right, i.e. grid[i][j] != grid[i][j + 1]
      (if it exists).
    Return the minimum number of operations needed.

    Example 1:
    Input: grid = [[1,0,2],[1,0,2]]
    Output: 0
    Explanation: All the cells in the matrix already satisfy the properties.

    Example 2:
    Input: grid = [[1,1,1],[0,0,0]]
    Output: 3
    Explanation: The matrix becomes [[1,0,1],[1,0,1]] which satisfies the
                 properties, by doing these 3 operations:
                 - Change grid[1][0] to 1.
                 - Change grid[0][1] to 0.
                 - Change grid[1][2] to 1.

    Example 3:
    Input: grid = [[1],[2],[3]]
    Output: 2
    Explanation: There is a single column. We can change the value to 1 in each
                 cell using 2 operations.

    Constraints:
    * 1 <= n, m <= 1000
    * 0 <= grid[i][j] <= 9"""

    def minimumOperations(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[0]*(n+1) for _ in range(10)]
        for j in range(n-1, -1, -1):
            freq = Counter(grid[i][j] for i in range(m))
            vals = sorted(list(range(10)), key = lambda x: dp[x][j+1])
            for x in range(10):
                dp[x][j] = m - freq[x]
                if x != vals[0]: dp[x][j] += dp[vals[0]][j+1]
                else: dp[x][j] += dp[vals[1]][j+1]
        return min(dp[x][0] for x in range(10))


    """3123. Find Edges in Shortest Paths (Hard)
    You are given an undirected weighted graph of n nodes numbered from 0 to
    n - 1. The graph consists of m edges represented by a 2D array edges, where
    edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and
    bi with weight wi. Consider all the shortest paths from node 0 to node n - 1
    in the graph. You need to find a boolean array answer where answer[i] is
    true if the edge edges[i] is part of at least one shortest path. Otherwise,
    answer[i] is false. Return the array answer. Note that the graph may not be
    connected.

    Example 1:
    Input: n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]
    Output: [true,true,true,false,true,true,true,false]
    Explanation: The following are all the shortest paths between nodes 0 and 5:
                 - The path 0 -> 1 -> 5: The sum of weights is 4 + 1 = 5.
                 - The path 0 -> 2 -> 3 -> 5: The sum of weights is
                   1 + 1 + 3 = 5.
                 - The path 0 -> 2 -> 3 -> 1 -> 5: The sum of weights is
                   1 + 1 + 2 + 1 = 5.

    Example 2:
    Input: n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]
    Output: [true,false,false,true]
    Explanation: There is one shortest path between nodes 0 and 3, which is the
                 path 0 -> 2 -> 3 with the sum of weights 1 + 2 = 3.

    Constraints:
    * 2 <= n <= 5 * 10^4
    * m == edges.length
    * 1 <= m <= min(5 * 10^4, n * (n - 1) / 2)
    * 0 <= ai, bi < n
    * ai != bi
    * 1 <= wi <= 10^5
    * There are no repeated edges."""

    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:
        graph = [[] for _ in range(n)]
        for u, v, w in edges:
            graph[u].append((v, w))
            graph[v].append((u, w))

        def fn(source):
            dist = [inf]*n
            dist[source] = 0
            pq = [(0, source)]
            while pq:
                x, u = heappop(pq)
                if dist[u] == x:
                    for v, w in graph[u]:
                        if x+w < dist[v]:
                            dist[v] = x+w
                            heappush(pq, (x+w, v))
            return dist

        dist0, dist1 = fn(0), fn(n-1)
        return [dist0[n-1] < inf and (dist0[u] + w + dist1[v] == dist0[n-1] or dist0[v] + w + dist1[u] == dist0[n-1]) for u, v, w in edges]


    """3127. Make a Square with the Same Color (Easy)
    You are given a 2D matrix grid of size 3 x 3 consisting only of characters
    'B' and 'W'. Character 'W' represents the white color, and character 'B'
    represents the black color. Your task is to change the color of at most one
    cell so that the matrix has a 2 x 2 square where all cells are of the same
    color. Return true if it is possible to create a 2 x 2 square of the same
    color, otherwise, return false.

    Example 1:
    Input: grid = [["B","W","B"],["B","W","W"],["B","W","B"]]
    Output: true
    Explanation: It can be done by changing the color of the grid[0][2].

    Example 2:
    Input: grid = [["B","W","B"],["W","B","W"],["B","W","B"]]
    Output: false
    Explanation: It cannot be done by changing at most one cell.

    Example 3:
    Input: grid = [["B","W","B"],["B","W","W"],["B","W","W"]]
    Output: true
    Explanation: The grid already contains a 2 x 2 square of the same color.

    Constraints:
    * grid.length == 3
    * grid[i].length == 3
    * grid[i][j] is either 'W' or 'B'."""

    def canMakeSquare(self, grid: List[List[str]]) -> bool:
        m, n = len(grid), len(grid[0])
        for i in range(m-1):
            for j in range(n-1):
                if sum(row[j:j+2].count('B') for row in grid[i:i+2]) != 2: return True
        return False


    """3128. Right Triangles (Medium)
    You are given a 2D boolean matrix grid. Return an integer that is the number
    of right triangles that can be made with the 3 elements of grid such that
    all of them have a value of 1. Note: A collection of 3 elements of grid is a
    right triangle if one of its elements is in the same row with another
    element and in the same column with the third element. The 3 elements do not
    have to be next to each other.

    Example 1: 0   1   0
               0   1   1
               0   1   0
               0   1   0
               0   1   1
               0   1   0
    Input: grid = [[0,1,0],[0,1,1],[0,1,0]]
    Output: 2
    Explanation: There are two right triangles.

    Example 2: 1   0   0   0
               0   1   0   1
               1   0   0   0
    Input: grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]
    Output: 0
    Explanation: There are no right triangles.

    Example 3: 1   0   1
               1   0   0
               1   0   0
               1   0   1
               1   0   0
               1   0   0
    Input: grid = [[1,0,1],[1,0,0],[1,0,0]]
    Output: 2
    Explanation: There are two right triangles.

    Constraints:
    * 1 <= grid.length <= 1000
    * 1 <= grid[i].length <= 1000
    * 0 <= grid[i][j] <= 1"""

    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        rows = [0]*m
        cols = [0]*n
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    rows[i] += 1
                    cols[j] += 1
        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    ans += (rows[i]-1)*(cols[j]-1)
        return ans


    """3129. Find All Possible Stable Binary Arrays I (Medium)
    You are given 3 positive integers zero, one, and limit. A binary array arr
    is called stable if:
    * The number of occurrences of 0 in arr is exactly zero.
    * The number of occurrences of 1 in arr is exactly one.
    * Each subarray of arr with a size greater than limit must contain both 0
      and 1.
    Return the total number of stable binary arrays. Since the answer may be
    very large, return it modulo 10^9 + 7.

    Example 1:
    Input: zero = 1, one = 1, limit = 2
    Output: 2
    Explanation: The two possible stable binary arrays are [1,0] and [0,1], as
                 both arrays have a single 0 and a single 1, and no subarray has
                 a length greater than 2.

    Example 2:
    Input: zero = 1, one = 2, limit = 1
    Output: 1
    Explanation: The only possible stable binary array is [1,0,1]. Note that the
                 binary arrays [1,1,0] and [0,1,1] have subarrays of length 2
                 with identical elements, hence, they are not stable.

    Example 3:
    Input: zero = 3, one = 3, limit = 2
    Output: 14
    Explanation: All the possible stable binary arrays are [0,0,1,0,1,1],
                 [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0],
                 [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0],
                 [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and
                 [1,1,0,1,0,0].

    Constraints: 1 <= zero, one, limit <= 200"""

    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:
        mod = 1_000_000_007
        dp = [[[0]*2 for _ in range(one+1)] for _ in range(zero+1)]
        for i in range(1, min(zero, limit)+1): dp[i][0][0] = 1
        for j in range(1, min(one, limit)+1): dp[0][j][1] = 1
        for i in range(1, zero+1):
            for j in range(1, one+1):
                dp[i][j][0] = (dp[i-1][j][1] + dp[i-1][j][0]) % mod
                if i-1-limit >= 0: dp[i][j][0] = (dp[i][j][0] - dp[i-1-limit][j][1]) % mod
                dp[i][j][1] = (dp[i][j-1][0] + dp[i][j-1][1]) % mod
                if j-1-limit >= 0: dp[i][j][1] = (dp[i][j][1] - dp[i][j-1-limit][0]) % mod
        return (dp[zero][one][0] + dp[zero][one][1]) % mod


    """3130. Find All Possible Stable Binary Arrays II (Hard)
    You are given 3 positive integers zero, one, and limit. A binary array arr
    is called stable if:
    * The number of occurrences of 0 in arr is exactly zero.
    * The number of occurrences of 1 in arr is exactly one.
    * Each subarray of arr with a size greater than limit must contain both 0
      and 1.
    Return the total number of stable binary arrays. Since the answer may be
    very large, return it modulo 10^9 + 7.

    Example 1:
    Input: zero = 1, one = 1, limit = 2
    Output: 2
    Explanation: The two possible stable binary arrays are [1,0] and [0,1].

    Example 2:
    Input: zero = 1, one = 2, limit = 1
    Output: 1
    Explanation: The only possible stable binary array is [1,0,1].

    Example 3:
    Input: zero = 3, one = 3, limit = 2
    Output: 14
    Explanation: All the possible stable binary arrays are [0,0,1,0,1,1],
                 [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0],
                 [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0],
                 [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and
                 [1,1,0,1,0,0].

    Constraints: 1 <= zero, one, limit <= 1000"""

    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:
        mod = 1_000_000_007
        dp = [[[0]*2 for _ in range(one+1)] for _ in range(zero+1)]
        for i in range(1, min(zero, limit)+1): dp[i][0][0] = 1
        for j in range(1, min(one, limit)+1): dp[0][j][1] = 1
        for i in range(1, zero+1):
            for j in range(1, one+1):
                dp[i][j][0] = (dp[i-1][j][1] + dp[i-1][j][0]) % mod
                if i-1-limit >= 0: dp[i][j][0] = (dp[i][j][0] - dp[i-1-limit][j][1]) % mod
                dp[i][j][1] = (dp[i][j-1][0] + dp[i][j-1][1]) % mod
                if j-1-limit >= 0: dp[i][j][1] = (dp[i][j][1] - dp[i][j-1-limit][0]) % mod
        return (dp[zero][one][0] + dp[zero][one][1]) % mod


    """3131. Find the Integer Added to Array I (Easy)
    You are given two arrays of equal length, nums1 and nums2. Each element in
    nums1 has been increased (or decreased in the case of negative) by an
    integer, represented by the variable x. As a result, nums1 becomes equal to
    nums2. Two arrays are considered equal when they contain the same integers
    with the same frequencies. Return the integer x.

    Example 1:
    Input: nums1 = [2,6,4], nums2 = [9,7,5]
    Output: 3
    Explanation: The integer added to each element of nums1 is 3.

    Example 2:
    Input: nums1 = [10], nums2 = [5]
    Output: -5
    Explanation: The integer added to each element of nums1 is -5.

    Example 3:
    Input: nums1 = [1,1,1,1], nums2 = [1,1,1,1]
    Output: 0
    Explanation: The integer added to each element of nums1 is 0.

    Constraints:
    * 1 <= nums1.length == nums2.length <= 100
    * 0 <= nums1[i], nums2[i] <= 1000
    * The test cases are generated in a way that there is an integer x such that
      nums1 can become equal to nums2 by adding x to each element of nums1."""

    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        return min(nums2) - min(nums1)


    """3132. Find the Integer Added to Array II (Medium)
    You are given two integer arrays nums1 and nums2. From nums1 two elements
    have been removed, and all other elements have been increased (or decreased
    in the case of negative) by an integer, represented by the variable x. As a
    result, nums1 becomes equal to nums2. Two arrays are considered equal when
    they contain the same integers with the same frequencies. Return the minimum
    possible integer x that achieves this equivalence.

    Example 1:
    Input: nums1 = [4,20,16,12,8], nums2 = [14,18,10]
    Output: -2
    Explanation: After removing elements at indices [0,4] and adding -2, nums1
                 becomes [18,14,10].

    Example 2:
    Input: nums1 = [3,5,5,3], nums2 = [7,7]
    Output: 2
    Explanation: After removing elements at indices [0,3] and adding 2, nums1
                 becomes [7,7].

    Constraints:
    * 3 <= nums1.length <= 200
    * nums2.length == nums1.length - 2
    * 0 <= nums1[i], nums2[i] <= 1000
    * The test cases are generated in a way that there is an integer x such that
      nums1 can become equal to nums2 by removing two elements and adding x to
      each element of nums1."""

    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        nums1.sort()
        nums2.sort()
        ans = inf
        n = len(nums1)
        for x in range(n):
            for y in range(x+1, n):
                j = 0
                seen = None
                for i in range(n):
                    if i not in (x, y):
                        diff = nums2[j] - nums1[i]
                        if seen is None: seen = diff
                        elif seen != diff: break
                        j += 1
                else: ans = min(ans, seen)
        return ans


    """3133. Minimum Array End (Medium)
    You are given two integers n and x. You have to construct an array of
    positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1]
    is greater than nums[i], and the result of the bitwise AND operation between
    all elements of nums is x. Return the minimum possible value of nums[n - 1].

    Example 1:
    Input: n = 3, x = 4
    Output: 6
    Explanation: nums can be [4,5,6] and its last element is 6.

    Example 2:
    Input: n = 2, x = 7
    Output: 15
    Explanation: nums can be [7,15] and its last element is 15.

    Constraints: 1 <= n, x <= 10^8"""

    def minEnd(self, n: int, x: int) -> int:
        n -= 1
        i = 0
        while n:
            if not x & 1<<i:
                if n & 1: x ^= 1 << i
                n >>= 1
            i += 1
        return x


    """3134. Find the Median of the Uniqueness Array (Hard)
    You are given an integer array nums. The uniqueness array of nums is the
    sorted array that contains the number of distinct elements of all the
    subarrays of nums. In other words, it is a sorted array consisting of
    distinct(nums[i..j]), for all 0 <= i <= j < nums.length. Here,
    distinct(nums[i..j]) denotes the number of distinct elements in the subarray
    that starts at index i and ends at index j. Return the median of the
    uniqueness array of nums. Note that the median of an array is defined as the
    middle element of the array when it is sorted in non-decreasing order. If
    there are two choices for a median, the smaller of the two values is taken.

    Example 1:
    Input: nums = [1,2,3]
    Output: 1
    Explanation: The uniqueness array of nums is [distinct(nums[0..0]),
                 distinct(nums[1..1]), distinct(nums[2..2]),
                 distinct(nums[0..1]), distinct(nums[1..2]),
                 distinct(nums[0..2])] which is equal to [1, 1, 1, 2, 2, 3]. The
                 uniqueness array has a median of 1. Therefore, the answer is 1.

    Example 2:
    Input: nums = [3,4,3,4,5]
    Output: 2
    Explanation: The uniqueness array of nums is
                 [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]. The uniqueness
                 array has a median of 2. Therefore, the answer is 2.

    Example 3:
    Input: nums = [4,3,5,4]
    Output: 2
    Explanation: The uniqueness array of nums is [1, 1, 1, 1, 2, 2, 2, 3, 3, 3].
                 The uniqueness array has a median of 2. Therefore, the answer
                 is 2.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def medianOfUniquenessArray(self, nums: List[int]) -> int:
        n = len(nums)
        lo, hi = 0, n
        while lo < hi:
            mid = lo + hi >> 1
            val = ii = 0
            freq = defaultdict(int)
            for i, x in enumerate(nums):
                freq[x] += 1
                while len(freq) > mid:
                    freq[nums[ii]] -= 1
                    if freq[nums[ii]] == 0: freq.pop(nums[ii])
                    ii += 1
                val += i-ii+1
            if val < (n*(n+1)//2+1)//2: lo = mid + 1
            else: hi = mid
        return lo


    """3146. Permutation Difference between Two Strings (Easy)
    You are given two strings s and t such that every character occurs at most
    once in s and t is a permutation of s. The permutation difference between s
    and t is defined as the sum of the absolute difference between the index of
    the occurrence of each character in s and the index of the occurrence of the
    same character in t. Return the permutation difference between s and t.

    Example 1:
    Input: s = "abc", t = "bac"
    Output: 2
    Explanation: For s = "abc" and t = "bac", the permutation difference of s
                 and t is equal to the sum of:
                 - The absolute difference between the index of the occurrence
                   of "a" in s and the index of the occurrence of "a" in t.
                 - The absolute difference between the index of the occurrence
                   of "b" in s and the index of the occurrence of "b" in t.
                 - The absolute difference between the index of the occurrence
                   of "c" in s and the index of the occurrence of "c" in t.
                 - That is, the permutation difference between s and t is equal
                   to |0 - 1| + |1 - 0| + |2 - 2| = 2.

    Example 2:
    Input: s = "abcde", t = "edbac"
    Output: 12
    Explanation: The permutation difference between s and t is equal to
                 |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12.

    Constraints:
    * 1 <= s.length <= 26
    * Each character occurs at most once in s.
    * t is a permutation of s.
    * s consists only of lowercase English letters."""

    def findPermutationDifference(self, s: str, t: str) -> int:
        loc = {ch : i for i, ch in enumerate(s)}
        return sum(abs(i-loc[ch]) for i, ch in enumerate(t))


    """3147. Taking Maximum Energy From the Mystic Dungeon (Medium)
    In a mystic dungeon, n magicians are standing in a line. Each magician has
    an attribute that gives you energy. Some magicians can give you negative
    energy, which means taking energy from you. You have been cursed in such a
    way that after absorbing energy from magician i, you will be instantly
    transported to magician (i + k). This process will be repeated until you
    reach the magician where (i + k) does not exist. In other words, you will
    choose a starting point and then teleport with k jumps until you reach the
    end of the magicians' sequence, absorbing all the energy during the journey.
    You are given an array energy and an integer k. Return the maximum possible
    energy you can gain.

    Example 1:
    Input:  energy = [5,2,-10,-5,1], k = 3
    Output: 3
    Explanation: We can gain a total energy of 3 by starting from magician 1
                 absorbing 2 + 1 = 3.

    Example 2:
    Input: energy = [-2,-3,-1], k = 2
    Output: -1
    Explanation: We can gain a total energy of -1 by starting from magician 2.

    Constraints:
    * 1 <= energy.length <= 10^5
    * -1000 <= energy[i] <= 1000
    * 1 <= k <= energy.length - 1"""

    def maximumEnergy(self, energy: List[int], k: int) -> int:
        dp = [0]*k
        for i, x in enumerate(energy):
            dp[i%k] = max(0, dp[i%k]) + x
        return max(dp)


    """3148. Maximum Difference Score in a Grid (Medium)
    You are given an m x n matrix grid consisting of positive integers. You can
    move from a cell in the matrix to any other cell that is either to the
    bottom or to the right (not necessarily adjacent). The score of a move from
    a cell with the value c1 to a cell with the value c2 is c2 - c1. You can
    start at any cell, and you have to make at least one move. Return the
    maximum total score you can achieve.

    Example 1:
    Input: grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]
    Output: 9
    Explanation: We start at the cell (0, 1), and we perform the following moves:
                 - Move from the cell (0, 1) to (2, 1) with a score of 7 - 5 = 2.
                 - Move from the cell (2, 1) to (2, 2) with a score of 14 - 7 = 7.
                 The total score is 2 + 7 = 9.

    Example 2:
    Input: grid = [[4,3,2],[3,2,1]]
    Output: -1
    Explanation: We start at the cell (0, 0), and we perform one move: (0, 0) to
                 (0, 1). The score is 3 - 4 = -1.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 1000
    * 4 <= m * n <= 10^5
    * 1 <= grid[i][j] <= 10^5"""

    def maxScore(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = -inf
        prefix = [[inf]*(n+1) for _ in range(m+1)]
        for i in range(m):
            for j in range(n):
                val = min(prefix[i+1][j], prefix[i][j+1])
                ans = max(ans, grid[i][j] - val)
                prefix[i+1][j+1] = min(grid[i][j], val)
        return ans


    """3149. Find the Minimum Cost Array Permutation (Hard)
    You are given an array nums which is a permutation of [0, 1, 2, ..., n - 1].
    The score of any permutation of [0, 1, 2, ..., n - 1] named perm is defined
    as:
    * score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ...
      + |perm[n - 1] - nums[perm[0]]|
    Return the permutation perm which has the minimum possible score. If
    multiple permutations exist with this score, return the one that is
    lexicographically smallest among them.

    Example 1:
    Input: nums = [1,0,2]
    Output: [0,1,2]
    Explanation: The lexicographically smallest permutation with minimum cost is
                 [0,1,2]. The cost of this permutation is
                 |0 - 0| + |1 - 2| + |2 - 1| = 2.

    Example 2:
    Input: nums = [0,2,1]
    Output: [0,2,1]
    Explanation: The lexicographically smallest permutation with minimum cost is
                 [0,2,1]. The cost of this permutation is
                 |0 - 1| + |2 - 2| + |1 - 0| = 2.

    Constraints:
    * 2 <= n == nums.length <= 14
    * nums is a permutation of [0, 1, 2, ..., n - 1]."""

    def findPermutation(self, nums: List[int]) -> List[int]:
        n = len(nums)
        dp = [[inf]*n for _ in range(1<<n)]
        jump = [[0]*n for _ in range(1<<n)]
        for m in range((1<<n)-1, 0, -1):
            i = m.bit_count()
            for p in range(n):
                if i == n: dp[m][p] = abs(p - nums[0])
                else:
                    for k in range(n):
                        if not m & 1<<k:
                            cand = abs(p - nums[k]) + dp[m^1<<k][k]
                            if cand < dp[m][p]:
                                dp[m][p] = cand
                                jump[m][p] = k
        ans = [0]
        m = 1
        for _ in range(n-1):
            k = jump[m][ans[-1]]
            ans.append(k)
            m ^= 1<<k
        return ans


    """3151. Special Array I (Easy)
    An array is considered special if every pair of its adjacent elements
    contains two numbers with different parity. You are given an array of
    integers nums. Return true if nums is a special array, otherwise, return
    false.

    Example 1:
    Input: nums = [1]
    Output: true
    Explanation: There is only one element. So the answer is true.

    Example 2:
    Input: nums = [2,1,4]
    Output: true
    Explanation: There is only two pairs: (2,1) and (1,4), and both of them
                 contain numbers with different parity. So the answer is true.

    Example 3:
    Input: nums = [4,3,1,6]
    Output: false
    Explanation: nums[1] and nums[2] are both odd. So the answer is false.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100"""

    def isArraySpecial(self, nums: List[int]) -> bool:
        return all((nums[i-1]-nums[i])%2 for i in range(1, len(nums)))


    """3152. Special Array II (Medium)
    An array is considered special if every pair of its adjacent elements
    contains two numbers with different parity. You are given an array of
    integer nums and a 2D integer matrix queries, where for
    queries[i] = [fromi, toi] your task is to check that subarray
    nums[fromi..toi] is special or not. Return an array of booleans answer such
    that answer[i] is true if nums[fromi..toi] is special.

    Example 1:
    Input: nums = [3,4,1,2,6], queries = [[0,4]]
    Output: [false]
    Explanation: The subarray is [3,4,1,2,6]. 2 and 6 are both even.

    Example 2:
    Input: nums = [4,3,1,6], queries = [[0,2],[2,3]]
    Output: [false,true]
    Explanation: The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to
                 this query is false. The subarray is [1,6]. There is only one
                 pair: (1,6) and it contains numbers with different parity. So
                 the answer to this query is true.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= queries[i][0] <= queries[i][1] <= nums.length - 1"""

    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:
        n = len(nums)
        dp = [0]*n
        for i in range(n):
            if i and (nums[i-1]-nums[i]) % 2 != 0: dp[i] = dp[i-1]
            else: dp[i] = i
        return [lo >= dp[hi] for lo, hi in queries]


    """3153. Sum of Digit Differences of All Pairs (Medium)
    You are given an array nums consisting of positive integers where all
    integers have the same number of digits. The digit difference between two
    integers is the count of different digits that are in the same position in
    the two integers. Return the sum of the digit differences between all pairs
    of integers in nums.

    Example 1:
    Input: nums = [13,23,12]
    Output: 4
    Explanation: We have the following:
                 - The digit difference between 13 and 23 is 1.
                 - The digit difference between 13 and 12 is 1.
                 - The digit difference between 23 and 12 is 2.
                 So the total sum of digit differences between all pairs of
                 integers is 1 + 1 + 2 = 4.

    Example 2:
    Input: nums = [10,10,10,10]
    Output: 0
    Explanation: All the integers in the array are the same. So the total sum of
                 digit differences between all pairs of integers will be 0.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] < 10^9
    * All integers in nums have the same number of digits."""

    def sumDigitDifferences(self, nums: List[int]) -> int:
        ans = 0
        while nums[0]:
            freq = [0]*10
            for i in range(len(nums)):
                nums[i], d = divmod(nums[i], 10)
                freq[d] += 1
            ans += sum(x*(len(nums)-x) for x in freq)
        return ans//2


    """3154. Find Number of Ways to Reach the K-th Stair (Hard)
    You are given a non-negative integer k. There exists a staircase with an
    infinite number of stairs, with the lowest stair numbered 0. Alice has an
    integer jump, with an initial value of 0. She starts on stair 1 and wants to
    reach stair k using any number of operations. If she is on stair i, in one
    operation she can:
    * Go down to stair i - 1. This operation cannot be used consecutively or on
      stair 0.
    * Go up to stair i + 2jump. And then, jump becomes jump + 1.
    Return the total number of ways Alice can reach stair k. Note that it is
    possible that Alice reaches the stair k, and performs some operations to
    reach the stair k again.

    Example 1:
    Input: k = 0
    Output: 2
    Explanation: The 2 possible ways of reaching stair 0 are:
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.

    Example 2:
    Input: k = 1
    Output: 4
    Explanation: The 4 possible ways of reaching stair 1 are:
                 - Alice starts at stair 1. Alice is at stair 1.
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 1.
                 - Alice starts at stair 1.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 2.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 1.
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 21 stairs
                   to reach stair 2.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 1.

    Constraints: 0 <= k <= 10^9"""

    def waysToReachStair(self, k: int) -> int:
        ans = 0
        for jump in range(31):
            if 1 << jump >= k:
                ans += comb(jump+1, (1<<jump) - k)
        return ans


    """3158. Find the XOR of Numbers Which Appear Twice (Easy)
    You are given an array nums, where each number in the array appears either
    once or twice. Return the bitwise XOR of all the numbers that appear twice
    in the array, or 0 if no number appears twice.

    Example 1:
    Input: nums = [1,2,1,3]
    Output: 1
    Explanation: The only number that appears twice in nums is 1.

    Example 2:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: No number appears twice in nums.

    Example 3:
    Input: nums = [1,2,2,1]
    Output: 3
    Explanation: Numbers 1 and 2 appeared twice. 1 XOR 2 == 3.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50
    * Each number in nums appears either once or twice."""

    def duplicateNumbersXOR(self, nums: List[int]) -> int:
        ans = seen = 0
        for x in nums:
            if seen & 1<<x: ans ^= x
            seen ^= 1<<x
        return ans


    """3159. Find Occurrences of an Element in an Array (Medium)
    You are given an integer array nums, an integer array queries, and an
    integer x. For each queries[i], you need to find the index of the
    queries[i]th occurrence of x in the nums array. If there are fewer than
    queries[i] occurrences of x, the answer should be -1 for that query. Return
    an integer array answer containing the answers to all queries.

    Example 1:
    Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1
    Output: [0,-1,2,-1]
    Explanation: - For the 1st query, the first occurrence of 1 is at index 0.
                 - For the 2nd query, there are only two occurrences of 1 in
                   nums, so the answer is -1.
                 - For the 3rd query, the second occurrence of 1 is at index 2.
                 - For the 4th query, there are only two occurrences of 1 in
                   nums, so the answer is -1.

    Example 2:
    Input: nums = [1,2,3], queries = [10], x = 5
    Output: [-1]
    Explanation: For the 1st query, 5 doesn't exist in nums, so the answer is -1.

    Constraints:
    * 1 <= nums.length, queries.length <= 10^5
    * 1 <= queries[i] <= 10^5
    * 1 <= nums[i], x <= 10^4"""

    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:
        loc = [i for i, v in enumerate(nums) if v == x]
        return [loc[q-1] if q <= len(loc) else -1 for q in queries]


    """3160. Find the Number of Distinct Colors Among the Balls (Medium)
    You are given an integer limit and a 2D array queries of size n x 2. There
    are limit + 1 balls with distinct labels in the range [0, limit]. Initially,
    all balls are uncolored. For every query in queries that is of the form
    [x, y], you mark ball x with the color y. After each query, you need to find
    the number of distinct colors among the balls. Return an array result of
    length n, where result[i] denotes the number of distinct colors after ith
    query. Note that when answering a query, lack of a color will not be
    considered as a color.

    Example 1:
    Input: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]
    Output: [1,2,2,3]
    Explanation: - After query 0, ball 1 has color 4.
                 - After query 1, ball 1 has color 4, and ball 2 has color 5.
                 - After query 2, ball 1 has color 3, and ball 2 has color 5.
                 - After query 3, ball 1 has color 3, ball 2 has color 5, and
                   ball 3 has color 4.

    Example 2:
    Input: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]
    Output: [1,2,2,3,4]
    Explanation: - After query 0, ball 0 has color 1.
                 - After query 1, ball 0 has color 1, and ball 1 has color 2.
                 - After query 2, ball 0 has color 1, and balls 1 and 2 have
                   color 2.
                 - After query 3, ball 0 has color 1, balls 1 and 2 have color
                   2, and ball 3 has color 4.
                 - After query 4, ball 0 has color 1, balls 1 and 2 have color
                   2, ball 3 has color 4, and ball 4 has color 5.

    Constraints:
    * 1 <= limit <= 10^9
    * 1 <= n == queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= queries[i][0] <= limit
    * 1 <= queries[i][1] <= 10^9"""

    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:
        mp = defaultdict(int)
        freq = Counter()
        ans = []
        for b, c in queries:
            if mp[b]:
                freq[mp[b]] -= 1
                if freq[mp[b]] == 0: freq.pop(mp[b])
            mp[b] = c
            freq[c] += 1
            ans.append(len(freq))
        return ans


    """3161. Block Placement Queries (Hard）
    There exists an infinite number line, with its origin at 0 and extending
    towards the positive x-axis. You are given a 2D array queries, which
    contains two types of queries:
    * For a query of type 1, queries[i] = [1, x]. Build an obstacle at distance
      x from the origin. It is guaranteed that there is no obstacle at distance
      x when the query is asked.
    * For a query of type 2, queries[i] = [2, x, sz]. Check if it is possible to
      place a block of size sz anywhere in the range [0, x] on the line, such
      that the block entirely lies in the range [0, x]. A block cannot be placed
      if it intersects with any obstacle, but it may touch it. Note that you do
      not actually place the block. Queries are separate.
    Return a boolean array results, where results[i] is true if you can place
    the block specified in the ith query of type 2, and false otherwise.

    Example 1:
    Input: queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]
    Output: [false,true,true]
    Explanation: For query 0, place an obstacle at x = 2. A block of size at
                 most 2 can be placed before x = 3.

    Example 2:
    Input: queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]
    Output: [true,true,false]
    Explanation: - Place an obstacle at x = 7 for query 0. A block of size at
                   most 7 can be placed before x = 7.
                 - Place an obstacle at x = 2 for query 2. Now, a block of size
                   at most 5 can be placed before x = 7, and a block of size at
                   most 2 before x = 2.

    Constraints:
    * 1 <= queries.length <= 15 * 10^4
    * 2 <= queries[i].length <= 3
    * 1 <= queries[i][0] <= 2
    * 1 <= x, sz <= min(5 * 104, 3 * queries.length)
    * The input is generated such that for queries of type 1, no obstacle exists
      at distance x when the query is asked.
    * The input is generated such that there is at least one query of type 2.

    class Fenwick:

        def __init__(self, n: int):
            self.nums = [0]*(n+1)

        def update(self, k: int, val: int) -> None:
            k += 1
            while k < len(self.nums):
                self.nums[k] = max(self.nums[k], val)
                k += k & -k

        def query(self, k: int) -> int:
            ans = 0
            k += 1
            while k:
                ans = max(ans, self.nums[k])
                k -= k & -k
            return ans"""

    def getResults(self, queries: List[List[int]]) -> List[bool]:
        vals = SortedList([0])
        tree = Fenwick(50001)
        prev = 0
        for _, x in sorted(filter(lambda x: x[0] == 1, queries)):
            vals.add(x)
            tree.update(x, x-prev)
            prev = x
        ans = []
        for t, x, *sz in reversed(queries):
            k = vals.bisect_left(x)
            if t == 1:
                vals.pop(k)
                if k < len(vals):
                    tree.update(vals[k], vals[k] - vals[k-1])
            else:
                ans.append(max(tree.query(x), x - vals[k-1]) >= sz[0])
        return ans[::-1]


    """3162. Find the Number of Good Pairs I (Easy)
    You are given 2 integer arrays nums1 and nums2 of lengths n and m
    respectively. You are also given a positive integer k. A pair (i, j) is
    called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1,
    0 <= j <= m - 1). Return the total number of good pairs.

    Example 1:
    Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
    Output: 5
    Explanation: The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).

    Example 2:
    Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
    Output: 2
    Explanation: The 2 good pairs are (3, 0) and (3, 1).

    Constraints:
    * 1 <= n, m <= 50
    * 1 <= nums1[i], nums2[j] <= 50
    * 1 <= k <= 50"""

    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:
        return sum(x % (y*k) == 0 for x, y in product(nums1, nums2))


    """3163. String Compression III (Medium)
    Given a string word, compress it using the following algorithm:
    * Begin with an empty string comp. While word is not empty, use the
      following operation:
      - Remove a maximum length prefix of word made of a single character c
        repeating at most 9 times.
      - Append the length of the prefix followed by c to comp.
    Return the string comp.

    Example 1:
    Input: word = "abcde"
    Output: "1a1b1c1d1e"
    Explanation: Initially, comp = "". Apply the operation 5 times, choosing
                 "a", "b", "c", "d", and "e" as the prefix in each operation.
                 For each prefix, append "1" followed by the character to comp.

    Example 2:
    Input: word = "aaaaaaaaaaaaaabb"
    Output: "9a5a2b"
    Explanation: Initially, comp = "". Apply the operation 3 times, choosing
                 "aaaaaaaaa", "aaaaa", and "bb" as the prefix in each operation.
                 - For prefix "aaaaaaaaa", append "9" followed by "a" to comp.
                 - For prefix "aaaaa", append "5" followed by "a" to comp.
                 - For prefix "bb", append "2" followed by "b" to comp.

    Constraints:
    * 1 <= word.length <= 2 * 10^5
    * word consists only of lowercase English letters."""

    def compressedString(self, word: str) -> str:
        ans = []
        for ch, grp in groupby(word):
            x = len(list(grp))
            q, x = divmod(x, 9)
            ans.append(('9'+ch) * q)
            if x: ans.append(str(x) + ch)
        return "".join(ans)


    """3164. Find the Number of Good Pairs II (Medium)
    You are given 2 integer arrays nums1 and nums2 of lengths n and m
    respectively. You are also given a positive integer k. A pair (i, j) is
    called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1,
    0 <= j <= m - 1). Return the total number of good pairs.

    Example 1:
    Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
    Output: 5
    Explanation: The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).

    Example 2:
    Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
    Output: 2
    Explanation: The 2 good pairs are (3, 0) and (3, 1).

    Constraints:
    * 1 <= n, m <= 10^5
    * 1 <= nums1[i], nums2[j] <= 10^6
    * 1 <= k <= 10^3"""

    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:
        freq = Counter(x//k for x in nums1 if x % k == 0)
        m = max(freq, default = 0)
        ans = 0
        for x, v in Counter(nums2).items():
            for xx in range(x, m+1, x):
                ans += freq[xx]*v
        return ans


    """3165. Maximum Sum of Subsequence With Non-adjacent Elements (Hard)
    You are given an array nums consisting of integers. You are also given a 2D
    array queries, where queries[i] = [posi, xi]. For query i, we first set
    nums[posi] equal to xi, then we calculate the answer to query i which is the
    maximum sum of a subsequence of nums where no two adjacent elements are
    selected. Return the sum of the answers to all queries. Since the final
    answer may be very large, return it modulo 10^9 + 7. A subsequence is an
    array that can be derived from another array by deleting some or no elements
    without changing the order of the remaining elements.

    Example 1:
    Input: nums = [3,5,9], queries = [[1,-2],[0,-3]]
    Output: 21
    Explanation: - After the 1st query, nums = [3,-2,9] and the maximum sum of a
                   subsequence with non-adjacent elements is 3 + 9 = 12.
                 - After the 2nd query, nums = [-3,-2,9] and the maximum sum of
                   a subsequence with non-adjacent elements is 9.

    Example 2:
    Input: nums = [0,-1], queries = [[0,-5]]
    Output: 0
    Explanation: After the 1st query, nums = [-5,-1] and the maximum sum of a
                 subsequence with non-adjacent elements is 0 (choosing an empty
                 subsequence).

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * -10^5 <= nums[i] <= 10^5
    * 1 <= queries.length <= 5 * 10^4
    * queries[i] == [posi, xi]
    * 0 <= posi <= nums.length - 1
    * -10^5 <= xi <= 10^5

class SegTree:

    def __init__(self, arr: List[int]):
        self.n = n = len(arr)
        self.tree = [0]*(4*n)
        self._build(arr, 0, 0, n)
        print(self.tree)

    def _op(self, left, right):
        lv, ls, le, lse = left
        rv, rs, re, rse = right
        v = max(le+rv, lv+rs)
        s = max(ls+rs, lse+rv)
        e = max(le+re, lv+rse)
        se = max(lse+re, ls+rse)
        return (v, s, e, se)

    def _build(self, arr: List[int], k: int, lo: int, hi: int) -> None:
        if lo+1 == hi: self.tree[k] = (max(0, arr[lo]), 0, 0, 0)
        else:
            mid = lo + hi >> 1
            self._build(arr, 2*k+1, lo, mid)
            self._build(arr, 2*k+2, mid, hi)
            self.tree[k] = self._op(self.tree[2*k+1], self.tree[2*k+2])

    def update(self, i: int, x: int, k: int = 0, lo: int = 0, hi: int = 0) -> None:
        if not hi: hi = self.n
        if lo+1 == hi: self.tree[k] = (max(0, x), 0, 0, 0) # leaf node
        else:
            mid = lo + hi >> 1
            if i < mid: self.update(i, x, 2*k+1, lo, mid)
            else: self.update(i, x, 2*k+2, mid, hi)
            self.tree[k] = self._op(self.tree[2*k+1], self.tree[2*k+2])

    def query(self, qlo: int, qhi: int, k: int = 0, lo: int = 0, hi: int = 0) -> int:
        if not hi: hi = self.n
        if qhi <= lo or  hi <= qlo: return inf          #      no overlap
        if qlo <= lo and hi <= qhi: return self.tree[k] #   total overlap
        mid = lo + hi >> 1                              # partial overlap
        return self._op(self.query(qlo, qhi, 2*k+1, lo, mid), self.query(qlo, qhi, 2*k+2, mid, hi))"""

    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:
        tree = SegTree(nums)
        ans = 0
        for i, x in queries:
            tree.update(i, x)
            ans = (ans + tree.query(0, len(nums))[0]) % 1_000_000_007
        return ans


    """3168. Minimum Number of Chairs in a Waiting Room (Easy)
    You are given a string s. Simulate events at each second i:
    * If s[i] == 'E', a person enters the waiting room and takes one of the
      chairs in it.
    * If s[i] == 'L', a person leaves the waiting room, freeing up a chair.
    Return the minimum number of chairs needed so that a chair is available for
    every person who enters the waiting room given that it is initially empty.

    Example 1:
    Input: s = "EEEEEEE"
    Output: 7
    Explanation: After each second, a person enters the waiting room and no
                 person leaves it. Therefore, a minimum of 7 chairs is needed.

    Example 2:
    Input: s = "ELELEEL"
    Output: 2
    Explanation: Let's consider that there are 2 chairs in the waiting room. The
                 table below shows the state of the waiting room at each second.
                 Second  Event   People in the Waiting Room  Available Chairs
                 0   Enter   1   1
                 1   Leave   0   2
                 2   Enter   1   1
                 3   Leave   0   2
                 4   Enter   1   1
                 5   Enter   2   0
                 6   Leave   1   1

    Example 3:
    Input: s = "ELEELEELLL"
    Output: 3
    Explanation: Let's consider that there are 3 chairs in the waiting room. The
                 table below shows the state of the waiting room at each second.
                 Second  Event   People in the Waiting Room  Available Chairs
                 0   Enter   1   2
                 1   Leave   0   3
                 2   Enter   1   2
                 3   Enter   2   1
                 4   Leave   1   2
                 5   Enter   2   1
                 6   Enter   3   0
                 7   Leave   2   1
                 8   Leave   1   2
                 9   Leave   0   3

    Constraints:
    * 1 <= s.length <= 50
    * s consists only of the letters 'E' and 'L'.
    * s represents a valid sequence of entries and exits."""

    def minimumChairs(self, s: str) -> int:
        ans = prefix = 0
        for ch in s:
            if ch == 'E': prefix += 1
            else: prefix -= 1
            ans = max(ans, prefix)
        return ans


    """3169. Count Days Without Meetings (Medium)
    You are given a positive integer days representing the total number of days
    an employee is available for work (starting from day 1). You are also given
    a 2D array meetings of size n where, meetings[i] = [start_i, end_i]
    represents the starting and ending days of meeting i (inclusive). Return the
    count of days when the employee is available for work but no meetings are
    scheduled. Note: The meetings may overlap.

    Example 1:
    Input: days = 10, meetings = [[5,7],[1,3],[9,10]]
    Output: 2
    Explanation: There is no meeting scheduled on the 4th and 8th days.

    Example 2:
    Input: days = 5, meetings = [[2,4],[1,3]]
    Output: 1
    Explanation: There is no meeting scheduled on the 5th day.

    Example 3:
    Input: days = 6, meetings = [[1,6]]
    Output: 0
    Explanation: Meetings are scheduled for all working days.

    Constraints:
    * 1 <= days <= 10^9
    * 1 <= meetings.length <= 10^5
    * meetings[i].length == 2
    * 1 <= meetings[i][0] <= meetings[i][1] <= days"""

    def countDays(self, days: int, meetings: List[List[int]]) -> int:
        ans = prev = 0
        for x, y in sorted(meetings):
            ans += max(0, min(x, days) - prev - 1)
            prev = max(prev, y)
        return ans + max(0, days - prev)


    """3170. Lexicographically Minimum String After Removing Stars (Medium)
    You are given a string s. It may contain any number of '*' characters. Your
    task is to remove all '*' characters. While there is a '*', do the following
    operation:
    * Delete the leftmost '*' and the smallest non-'*' character to its left. If
      there are several smallest characters, you can delete any of them.
    Return the lexicographically smallest resulting string after removing all
    '*' characters.

    Example 1:
    Input: s = "aaba*"
    Output: "aab"
    Explanation: We should delete one of the 'a' characters with '*'. If we
                 choose s[3], s becomes the lexicographically smallest.

    Example 2:
    Input: s = "abc"
    Output: "abc"
    Explanation: There is no '*' in the string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters and '*'.
    * The input is generated such that it is possible to delete all '*'
    characters."""

    def clearStars(self, s: str) -> str:
        s = list(s)
        pq = []
        for i, ch in enumerate(s):
            if ch == '*': s[-heappop(pq)[1]] = '*'
            else: heappush(pq, (ch, -i))
        return ''.join(s).replace('*', '')


    """3171. Find Subarray With Bitwise AND Closest to K (Hard)
    You are given an array nums and an integer k. You need to find a subarray of
    nums such that the absolute difference between k and the bitwise AND of the
    subarray elements is as small as possible. In other words, select a subarray
    nums[l..r] such that |k - (nums[l] AND nums[l + 1] ... AND nums[r])| is
    minimum. Return the minimum possible value of the absolute difference. A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,4,5], k = 3
    Output: 1
    Explanation: The subarray nums[2..3] has AND value 4, which gives the
                 minimum absolute difference |3 - 4| = 1.

    Example 2:
    Input: nums = [1,2,1,2], k = 2
    Output: 0
    Explanation: The subarray nums[1..1] has AND value 2, which gives the
                 minimum absolute difference |2 - 2| = 0.

    Example 3:
    Input: nums = [1], k = 10
    Output: 9
    Explanation: There is a single subarray with AND value 1, which gives the
                 minimum absolute difference |10 - 1| = 9.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9"""

    def minimumDifference(self, nums: List[int], k: int) -> int:
        freq = [0]*30
        mask = (1<<30)-1
        ans = inf
        ii = 0
        for i, x in enumerate(nums):
            for j in range(30):
                if not x & 1<<j:
                    if freq[j] == 0: mask ^= 1<<j
                    freq[j] += 1
            ans = min(ans, abs(mask-k))
            while ii < i and mask < k:
                for j in range(30):
                    if not nums[ii] & 1<<j:
                        freq[j] -= 1
                        if freq[j] == 0: mask ^= 1<<j
                ans = min(ans, abs(mask-k))
                ii += 1
        return ans


    """3174. Clear Digits (Easy)
    You are given a string s. Your task is to remove all digits by doing this
    operation repeatedly:
    * Delete the first digit and the closest non-digit character to its left.
    Return the resulting string after removing all digits.

    Example 1:
    Input: s = "abc"
    Output: "abc"
    Explanation: There is no digit in the string.

    Example 2:
    Input: s = "cb34"
    Output: ""
    Explanation: First, we apply the operation on s[2], and s becomes "c4". Then
                 we apply the operation on s[1], and s becomes "".

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of lowercase English letters and digits.
    * The input is generated such that it is possible to delete all digits."""

    def clearDigits(self, s: str) -> str:
        stack = []
        for ch in s:
            if ch.isdigit(): stack.pop()
            else: stack.append(ch)
        return ''.join(stack)


    """3175. Find The First Player to win K Games in a Row (Medium)
    A competition consists of n players numbered from 0 to n - 1. You are given
    an integer array skills of size n and a positive integer k, where skills[i]
    is the skill level of player i. All integers in skills are unique. All
    players are standing in a queue in order from player 0 to player n - 1. The
    competition process is as follows:
    * The first two players in the queue play a game, and the player with the
      higher skill level wins.
    * After the game, the winner stays at the beginning of the queue, and the
      loser goes to the end of it.
    The winner of the competition is the first player who wins k games in a row.
    Return the initial index of the winning player.

    Example 1:
    Input: skills = [4,2,6,3,9], k = 2
    Output: 2
    Explanation: Initially, the queue of players is [0,1,2,3,4]. The following
                 process happens:
                 - Players 0 and 1 play a game, since the skill of player 0 is
                   higher than that of player 1, player 0 wins. The resulting
                   queue is [0,2,3,4,1].
                 - Players 0 and 2 play a game, since the skill of player 2 is
                   higher than that of player 0, player 2 wins. The resulting
                   queue is [2,3,4,1,0].
                 - Players 2 and 3 play a game, since the skill of player 2 is
                   higher than that of player 3, player 2 wins. The resulting
                   queue is [2,4,1,0,3].
                 - Player 2 won k = 2 games in a row, so the winner is player 2.

    Example 2:
    Input: skills = [2,5,4], k = 3
    Output: 1
    Explanation: Initially, the queue of players is [0,1,2]. The following
                 process happens:
                 - Players 0 and 1 play a game, since the skill of player 1 is
                   higher than that of player 0, player 1 wins. The resulting
                   queue is [1,2,0].
                 - Players 1 and 2 play a game, since the skill of player 1 is
                   higher than that of player 2, player 1 wins. The resulting
                   queue is [1,0,2].
                 - Players 1 and 0 play a game, since the skill of player 1 is
                   higher than that of player 0, player 1 wins. The resulting
                   queue is [1,2,0].
                 - Player 1 won k = 3 games in a row, so the winner is player 1.

    Constraints:
    * n == skills.length
    * 2 <= n <= 10^5
    * 1 <= k <= 10^9
    * 1 <= skills[i] <= 10^6
    * All integers in skills are unique."""

    def findWinningPlayer(self, skills: List[int], k: int) -> int:
        j = cnt = 0
        for i in range(1, len(skills)):
            if skills[j] < skills[i]:
                j = i
                cnt = 0
            cnt += 1
            if cnt == k: break
        return j


    """3176. Find the Maximum Length of a Good Subsequence I (Medium)
    You are given an integer array nums and a non-negative integer k. A sequence
    of integers seq is called good if there are at most k indices i in the range
    [0, seq.length - 2] such that seq[i] != seq[i + 1]. Return the maximum
    possible length of a good subsequence of nums.

    Example 1:
    Input: nums = [1,2,1,1,3], k = 2
    Output: 4
    Explanation: The maximum length subsequence is [1,2,1,1,3].

    Example 2:
    Input: nums = [1,2,3,4,5,1], k = 0
    Output: 2
    Explanation: The maximum length subsequence is [1,2,3,4,5,1].

    Constraints:
    * 1 <= nums.length <= 500
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= min(nums.length, 25)"""

    def maximumLength(self, nums: List[int], k: int) -> int:
        dp = [defaultdict(int) for _ in range(k+1)]
        most = [0]*(k+1)
        for x in nums:
            for i in range(k, -1, -1):
                dp[i][x] += 1
                if i: dp[i][x] = max(dp[i][x], 1 + most[i-1])
                most[i] = max(most[i], dp[i][x])
        return most[k]


    """3177. Find the Maximum Length of a Good Subsequence II (Hard)
    You are given an integer array nums and a non-negative integer k. A sequence
    of integers seq is called good if there are at most k indices i in the range
    [0, seq.length - 2] such that seq[i] != seq[i + 1]. Return the maximum
    possible length of a good subsequence of nums.

    Example 1:
    Input: nums = [1,2,1,1,3], k = 2
    Output: 4
    Explanation: The maximum length subsequence is [1,2,1,1,3].

    Example 2:
    Input: nums = [1,2,3,4,5,1], k = 0
    Output: 2
    Explanation: The maximum length subsequence is [1,2,3,4,5,1].

    Constraints:
    * 1 <= nums.length <= 5 * 10^3
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= min(50, nums.length)"""

    def maximumLength(self, nums: List[int], k: int) -> int:
        dp = [defaultdict(int) for _ in range(k+1)]
        most = [0]*(k+1)
        for x in nums:
            for i in range(k, -1, -1):
                dp[i][x] += 1
                if i: dp[i][x] = max(dp[i][x], 1 + most[i-1])
                most[i] = max(most[i], dp[i][x])
        return most[k]


    """3179. Find the N-th Value After K Seconds (Medium)
    You are given two integers n and k. Initially, you start with an array a of
    n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you
    simultaneously update each element to be the sum of all its preceding
    elements plus the element itself. For example, after one second, a[0]
    remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2],
    and so on. Return the value of a[n - 1] after k seconds. Since the answer
    may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 4, k = 5
    Output: 56
    Explanation: Second  State After
                 0   [1,1,1,1]
                 1   [1,2,3,4]
                 2   [1,3,6,10]
                 3   [1,4,10,20]
                 4   [1,5,15,35]
                 5   [1,6,21,56]

    Example 2:
    Input: n = 5, k = 3
    Output: 35
    Explanation: Second  State After
                 0   [1,1,1,1,1]
                 1   [1,2,3,4,5]
                 2   [1,3,6,10,15]
                 3   [1,4,10,20,35]

    Constraints: 1 <= n, k <= 1000"""

    def valueAfterKSeconds(self, n: int, k: int) -> int:
        return comb(k+n-1, n-1) % 1_000_000_007


    """3184. Count Pairs That Form a Complete Day I (Easy)
    Given an integer array hours representing times in hours, return an integer
    denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms
    a complete day. A complete day is defined as a time duration that is an
    exact multiple of 24 hours. For example, 1 day is 24 hours, 2 days is 48
    hours, 3 days is 72 hours, and so on.

    Example 1:
    Input: hours = [12,12,30,24,24]
    Output: 2
    Explanation: The pairs of indices that form a complete day are (0, 1) and
                 (3, 4).

    Example 2:
    Input: hours = [72,48,24,3]
    Output: 3
    Explanation: The pairs of indices that form a complete day are (0, 1),
                 (0, 2), and (1, 2).

    Constraints:
    * 1 <= hours.length <= 100
    * 1 <= hours[i] <= 10^9"""

    def countCompleteDayPairs(self, hours: List[int]) -> int:
        ans = 0
        freq = [0]*24
        for h in hours:
            ans += freq[(24-h) % 24]
            freq[h % 24] += 1
        return ans


    """3185. Count Pairs That Form a Complete Day II (Medium)
    Given an integer array hours representing times in hours, return an integer
    denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms
    a complete day. A complete day is defined as a time duration that is an
    exact multiple of 24 hours. For example, 1 day is 24 hours, 2 days is 48
    hours, 3 days is 72 hours, and so on.

    Example 1:
    Input: hours = [12,12,30,24,24]
    Output: 2
    Explanation: The pairs of indices that form a complete day are (0, 1) and
                 (3, 4).

    Example 2:
    Input: hours = [72,48,24,3]
    Output: 3
    Explanation: The pairs of indices that form a complete day are (0, 1),
                 (0, 2), and (1, 2).

    Constraints:
    * 1 <= hours.length <= 5 * 10^5
    * 1 <= hours[i] <= 10^9"""

    def countCompleteDayPairs(self, hours: List[int]) -> int:
        ans = 0
        freq = [0]*24
        for h in hours:
            ans += freq[(24-h) % 24]
            freq[h % 24] += 1
        return ans


    """3186. Maximum Total Damage With Spell Casting (Medium)
    A magician has various spells. You are given an array power, where each
    element represents the damage of a spell. Multiple spells can have the same
    damage value. It is a known fact that if a magician decides to cast a spell
    with a damage of power[i], they cannot cast any spell with a damage of
    power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2. Each spell can be
    cast only once. Return the maximum possible total damage that a magician can
    cast.

    Example 1:
    Input: power = [1,1,3,4]
    Output: 6
    Explanation: The maximum possible damage of 6 is produced by casting spells
                 0, 1, 3 with damage 1, 1, 4.

    Example 2:
    Input: power = [7,1,6,6]
    Output: 13
    Explanation: The maximum possible damage of 13 is produced by casting spells
                 1, 2, 3 with damage 1, 6, 6.

    Constraints:
    * 1 <= power.length <= 10^5
    * 1 <= power[i] <= 10^9"""

    def maximumTotalDamage(self, power: List[int]) -> int:
        power.sort()
        dp = [0]*len(power)
        prefix = j = 0
        for i, x in enumerate(power):
            if i and power[i-1] == x: dp[i] = dp[i-1] + x
            else:
                while power[j] < x-2:
                    prefix = max(prefix, dp[j])
                    j += 1
                dp[i] = prefix + x
        return max(dp)


    """3187. Peaks in Array (Hard)
    A peak in an array arr is an element that is greater than its previous and
    next element in arr. You are given an integer array nums and a 2D integer
    array queries. You have to process queries of two types:
    * queries[i] = [1, li, ri], determine the count of peak elements in the
      subarray nums[li..ri].
    * queries[i] = [2, indexi, vali], change nums[indexi] to vali.
    Return an array answer containing the results of the queries of the first
    type in order. Notes:
    * The first and the last element of an array or a subarray cannot be a peak.

    Example 1:
    Input: nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]
    Output: [0]
    Explanation: First query: We change nums[3] to 4 and nums becomes
                 [3,1,4,4,5]. Second query: The number of peaks in the
                 [3,1,4,4,5] is 0.

    Example 2:
    Input: nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]
    Output: [0,1]
    Explanation: First query: nums[2] should become 4, but it is already set to
                 4. Second query: The number of peaks in the [4,1,4] is 0. Third
                 query: The second 4 is a peak in the [4,1,4,2,1].

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i][0] == 1 or queries[i][0] == 2
    * For all i that:
      - queries[i][0] == 1: 0 <= queries[i][1] <= queries[i][2] <= nums.length - 1
      - queries[i][0] == 2: 0 <= queries[i][1] <= nums.length - 1,
        1 <= queries[i][2] <= 10^5

    class Fenwick:
        def __init__(self, n):
            self.nums = [0]*(n+1)

        def add(self, k, delta):
            k += 1
            while k < len(self.nums):
                self.nums[k] += delta
                k += k & -k

        def query(self, k):
            ans = 0
            k += 1
            while k:
                ans += self.nums[k]
                k -= k & -k
            return ans"""

    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n = len(nums)
        tree = Fenwick(n)
        for i, x in enumerate(nums):
            if i and i+1 < n and nums[i-1] < x > nums[i+1]:
                tree.add(i, 1)
        ans = []
        for q in queries:
            if q[0] == 1:
                lo, hi = q[1], q[2]
                ans.append(tree.query(max(lo, hi-1)) - tree.query(lo))
            else:
                k, v = q[1], q[2]
                for i in k-1, k, k+1:
                    if 0 < i and i+1 < n and nums[i-1] < nums[i] > nums[i+1]:
                        tree.add(i, -1)
                nums[k] = v
                for i in k-1, k, k+1:
                    if 0 < i and i+1 < n and nums[i-1] < nums[i] > nums[i+1]:
                        tree.add(i, 1)
        return ans


    """3190. Find Minimum Operations to Make All Elements Divisible by Three (Easy)
    You are given an integer array nums. In one operation, you can add or
    subtract 1 from any element of nums. Return the minimum number of operations
    to make all elements of nums divisible by 3.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 3
    Explanation: All array elements can be made divisible by 3 using 3
                 operations:
                 - Subtract 1 from 1.
                 - Add 1 to 2.
                 - Subtract 1 from 4.

    Example 2:
    Input: nums = [3,6,9]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50"""

    def minimumOperations(self, nums: List[int]) -> int:
        return sum(min(x%3, 3-x%3) for x in nums)


    """3191. Minimum Operations to Make Binary Array Elements Equal to One I (Medium)
    You are given a binary array nums. You can do the following operation on the
    array any number of times (possibly zero):
    * Choose any 3 consecutive elements from the array and flip all of them.
    Flipping an element means changing its value from 0 to 1, and from 1 to 0.
    Return the minimum number of operations required to make all elements in
    nums equal to 1. If it is impossible, return -1.

    Example 1:
    Input: nums = [0,1,1,1,0,0]
    Output: 3
    Explanation: We can do the following operations:
                 - Choose the elements at indices 0, 1 and 2. The resulting
                   array is nums = [1,0,0,1,0,0].
                 - Choose the elements at indices 1, 2 and 3. The resulting
                   array is nums = [1,1,1,0,0,0].
                 - Choose the elements at indices 3, 4 and 5. The resulting
                   array is nums = [1,1,1,1,1,1].

    Example 2:
    Input: nums = [0,1,1,1]
    Output: -1
    Explanation: It is impossible to make all elements equal to 1.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1"""

    def minOperations(self, nums: List[int]) -> int:
        ans = flip = 0
        n = len(nums)
        line = [0]*n
        for i, x in enumerate(nums):
            if line[i]: flip ^= 1
            x ^= flip
            if x == 0:
                if i+2 >= n: return -1
                ans += 1
                flip ^= 1
                if i+3 < n: line[i+3] = 1
        return ans


    """3192. Minimum Operations to Make Binary Array Elements Equal to One II (Medium)
    You are given a binary array nums. You can do the following operation on
    the array any number of times (possibly zero):
    * Choose any index i from the array and flip all the elements from index i
      to the end of the array.
    Flipping an element means changing its value from 0 to 1, and from 1 to 0.
    Return the minimum number of operations required to make all elements in
    nums equal to 1.

    Example 1:
    Input: nums = [0,1,1,0,1]
    Output: 4
    Explanation: We can do the following operations:
                 - Choose the index i = 1. The resulting array will be
                   nums = [0,0,0,1,0].
                 - Choose the index i = 0. The resulting array will be
                   nums = [1,1,1,0,1].
                 - Choose the index i = 4. The resulting array will be
                   nums = [1,1,1,0,0].
                 - Choose the index i = 3. The resulting array will be
                   nums = [1,1,1,1,1].

    Example 2:
    Input: nums = [1,0,0,0]
    Output: 1
    Explanation: We can do the following operation:
                 - Choose the index i = 1. The resulting array will be
                   nums = [1,1,1,1].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1"""

    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for x in nums:
            if x == 1 & ans:
                ans += 1
        return ans


    """3193. Count the Number of Inversions (Hard)
    You are given an integer n and a 2D array requirements, where
    requirements[i] = [endi, cnti] represents the end index and the inversion
    count of each requirement. A pair of indices (i, j) from an integer array
    nums is called an inversion if:
    * i < j and nums[i] > nums[j]
    Return the number of permutations perm of [0, 1, 2, ..., n - 1] such that
    for all requirements[i], perm[0..endi] has exactly cnti inversions. Since
    the answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, requirements = [[2,2],[0,0]]
    Output: 2
    Explanation: The two permutations are:
                 - [2, 0, 1]
                   + Prefix [2, 0, 1] has inversions (0, 1) and (0, 2).
                   + Prefix [2] has 0 inversions.
                 - [1, 2, 0]
                   + Prefix [1, 2, 0] has inversions (0, 2) and (1, 2).
                   + Prefix [1] has 0 inversions.

    Example 2:
    Input: n = 3, requirements = [[2,2],[1,1],[0,0]]
    Output: 1
    Explanation: The only satisfying permutation is [2, 0, 1]:
                 - Prefix [2, 0, 1] has inversions (0, 1) and (0, 2).
                 - Prefix [2, 0] has an inversion (0, 1).
                 - Prefix [2] has 0 inversions.

    Example 3:
    Input: n = 2, requirements = [[0,0],[1,0]]
    Output: 1
    Explanation: The only satisfying permutation is [0, 1]:
                 - Prefix [0] has 0 inversions.
                 - Prefix [0, 1] has an inversion (0, 1).

    Constraints:
    * 2 <= n <= 300
    * 1 <= requirements.length <= n
    * requirements[i] = [endi, cnti]
    * 0 <= endi <= n - 1
    * 0 <= cnti <= 400
    * The input is generated such that there is at least one i such that
      endi == n - 1.
    * The input is generated such that all endi are unique."""

    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:
        requirements = dict(requirements)
        m = max(requirements.values())
        dp = [[0]*(m+1) for _ in range(n)]
        dp[0][0] = 1
        for i in range(n):
            prefix = 0
            for j in range(m+1):
                if i:
                    prefix += dp[i-1][j]
                    if j > i: prefix -= dp[i-1][j-i-1]
                    dp[i][j] = prefix = prefix % 1_000_000_007
                if i in requirements and j != requirements[i]: dp[i][j] = 0
        return dp[n-1][requirements[n-1]]


    """3194. Minimum Average of Smallest and Largest Elements (Easy)
    You have an array of floating point numbers averages which is initially
    empty. You are given an array nums of n integers where n is even. You repeat
    the following procedure n / 2 times:
    * Remove the smallest element, minElement, and the largest element
      maxElement, from nums.
    * Add (minElement + maxElement) / 2 to averages.
    Return the minimum element in averages.

    Example 1:
    Input: nums = [7,8,3,4,15,13,4,1]
    Output: 5.5
    Explanation: step  nums                 averages
                 0     [7,8,3,4,15,13,4,1]  []
                 1     [7,8,3,4,13,4]       [8]
                 2     [7,8,4,4]            [8,8]
                 3     [7,4]                [8,8,6]
                 4     []                   [8,8,6,5.5]
                 The smallest element of averages, 5.5, is returned.

    Example 2:
    Input: nums = [1,9,8,3,10,5]
    Output: 5.5
    Explanation: step  nums                 averages
                 0     [1,9,8,3,10,5]       []
                 1     [9,8,3,5]            [5.5]
                 2     [8,5]                [5.5,6]
                 3     []                   [5.5,6,6.5]

    Example 3:
    Input: nums = [1,2,3,7,8,9]
    Output: 5.0
    Explanation: step  nums                 averages
                 0     [1,2,3,7,8,9]        []
                 1     [2,3,7,8]            [5]
                 2     [3,7]                [5,5]
                 3     []                   [5,5,5]

    Constraints:
    * 2 <= n == nums.length <= 50
    * n is even.
    * 1 <= nums[i] <= 50"""

    def minimumAverage(self, nums: List[int]) -> float:
        nums.sort()
        return min((nums[i]+nums[~i])/2 for i in range(len(nums)//2))


    """3195. Find the Minimum Area to Cover All Ones I (Medium)
    You are given a 2D binary array grid. Find a rectangle with horizontal and
    vertical sides with the smallest area, such that all the 1's in grid lie
    inside this rectangle. Return the minimum possible area of the rectangle.

    Example 1:
    Input: grid = [[0,1,0],[1,0,1]]
    Output: 6
    Explanation: The smallest rectangle has a height of 2 and a width of 3, so
                 it has an area of 2 * 3 = 6.

    Example 2:
    Input: grid = [[1,0],[0,0]]
    Output: 1
    Explanation: The smallest rectangle has both height and width 1, so its area
                 is 1 * 1 = 1.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 1000
    * grid[i][j] is either 0 or 1.
    * The input is generated such that there is at least one 1 in grid."""

    def minimumArea(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        rmin = cmin = inf
        rmax = cmax = -1
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    rmin = min(rmin, i)
                    rmax = max(rmax, i)
                    cmin = min(cmin, j)
                    cmax = max(cmax, j)
        return (rmax-rmin+1) * (cmax-cmin+1)


    """3196. Maximize Total Cost of Alternating Subarrays (Medium)
    You are given an integer array nums with length n. The cost of a subarray
    nums[l..r], where 0 <= l <= r < n, is defined as:

    * cost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)r − l

    Your task is to split nums into subarrays such that the total cost of the
    subarrays is maximized, ensuring each element belongs to exactly one
    subarray. Formally, if nums is split into k subarrays, where k > 1, at
    indices i1, i2, ..., ik − 1, where 0 <= i1 < i2 < ... < ik - 1 < n - 1, then
    the total cost will be:

    * cost(0, i1) + cost(i1 + 1, i2) + ... + cost(ik − 1 + 1, n − 1)

    Return an integer denoting the maximum total cost of the subarrays after
    splitting the array optimally. Note: If nums is not split into subarrays,
    i.e. k = 1, the total cost is simply cost(0, n - 1).

    Example 1:
    Input: nums = [1,-2,3,4]
    Output: 10
    Explanation: One way to maximize the total cost is by splitting
                 [1, -2, 3, 4] into subarrays [1, -2, 3] and [4]. The total cost
                 will be (1 + 2 + 3) + 4 = 10.

    Example 2:
    Input: nums = [1,-1,1,-1]
    Output: 4
    Explanation: One way to maximize the total cost is by splitting
                 [1, -1, 1, -1] into subarrays [1, -1] and [1, -1]. The total
                 cost will be (1 + 1) + (1 + 1) = 4.

    Example 3:
    Input: nums = [0]
    Output: 0
    Explanation: We cannot split the array further, so the answer is 0.

    Example 4:
    Input: nums = [1,-1]
    Output: 2
    Explanation: Selecting the whole array gives a total cost of 1 + 1 = 2,
                 which is the maximum.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9"""

    def maximumTotalCost(self, nums: List[int]) -> int:
        ans = suffix = 0
        for x in reversed(nums):
            suffix = x - suffix
            if suffix > 0:
                ans += suffix
                suffix = 0
        return ans + suffix


    """3197. Find the Minimum Area to Cover All Ones II (Hard)
    You are given a 2D binary array grid. You need to find 3 non-overlapping
    rectangles having non-zero areas with horizontal and vertical sides such
    that all the 1's in grid lie inside these rectangles. Return the minimum
    possible sum of the area of these rectangles. Note that the rectangles are
    allowed to touch.

    Example 1:
    Input: grid = [[1,0,1],[1,1,1]]
    Output: 5
    Explanation: - The 1's at (0, 0) and (1, 0) are covered by a rectangle of
                   area 2.
                 - The 1's at (0, 2) and (1, 2) are covered by a rectangle of
                   area 2.
                 - The 1 at (1, 1) is covered by a rectangle of area 1.

    Example 2:
    Input: grid = [[1,0,1,0],[0,1,0,1]]
    Output: 5
    Explanation: - The 1's at (0, 0) and (0, 2) are covered by a rectangle of
                   area 3.
                 - The 1 at (1, 1) is covered by a rectangle of area 1.
                 - The 1 at (1, 3) is covered by a rectangle of area 1.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 30
    * grid[i][j] is either 0 or 1.
    * The input is generated such that there are at least three 1's in grid."""

    def minimumSum(self, grid: List[List[int]]) -> int:

        def fn(grid):
            """Return """
            ans = []
            imin = jmin = inf
            imax = jmax = -inf
            for i, row in enumerate(grid):
                for j, val in enumerate(row):
                    if val:
                        imin = min(imin, i)
                        jmin = min(jmin, j)
                        imax = max(imax, i)
                        jmax = max(jmax, j)
                val = max(0, (imax-imin+1)*(jmax-jmin+1))
                ans.append(val)
            return ans[:-1]

        ans = inf
        for _ in range(4):
            half = fn(grid)
            for i, h in enumerate(half):
                if h:
                    sub = grid[i+1:]
                    for _ in range(2):
                        top = fn(sub)
                        bottom = fn(sub[::-1])
                        for i in range(len(top)):
                            if top[i] and bottom[~i]:
                                ans = min(ans, h + top[i] + bottom[~i])
                        sub = list(zip(*sub[::-1]))
            grid = list(zip(*grid[::-1]))
        return ans


    """3200. Maximum Height of a Triangle (Easy)
    You are given two integers red and blue representing the count of red and
    blue colored balls. You have to arrange these balls to form a triangle such
    that the 1st row will have 1 ball, the 2nd row will have 2 balls, the 3rd
    row will have 3 balls, and so on. All the balls in a particular row should
    be the same color, and adjacent rows should have different colors. Return
    the maximum height of the triangle that can be achieved.

    Example 1:
    Input: red = 2, blue = 4
    Output: 3
    Explanation: The only possible arrangement is shown above.

    Example 2:
    Input: red = 2, blue = 1
    Output: 2
    Explanation: The only possible arrangement is shown above.

    Example 3:
    Input: red = 1, blue = 1
    Output: 1

    Example 4:
    Input: red = 10, blue = 1
    Output: 2
    Explanation: The only possible arrangement is shown above.

    Constraints: 1 <= red, blue <= 100"""

    def maxHeightOfTriangle(self, red: int, blue: int) -> int:
        ans = 0
        for ball in [red, blue], [blue, red]:
            cand = i = 0
            for k in count(1):
                if ball[i] < k: break
                ball[i] -= k
                cand += 1
                i ^= 1
            ans = max(ans, cand)
        return ans


    """3201. Find the Maximum Length of Valid Subsequence I (Medium)
    You are given an integer array nums. A subsequence sub of nums with length x
    is called valid if it satisfies:
    * (sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ...
      == (sub[x - 2] + sub[x - 1]) % 2.
    Return the length of the longest valid subsequence of nums. A subsequence is
    an array that can be derived from another array by deleting some or no
    elements without changing the order of the remaining elements.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 4
    Explanation: The longest valid subsequence is [1, 2, 3, 4].

    Example 2:
    Input: nums = [1,2,1,1,2,1,2]
    Output: 6
    Explanation: The longest valid subsequence is [1, 2, 1, 2, 1, 2].

    Example 3:
    Input: nums = [1,3]
    Output: 2
    Explanation: The longest valid subsequence is [1, 3].

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * 1 <= nums[i] <= 10^7"""

    def maximumLength(self, nums: List[int]) -> int:
        dp = [[0]*2 for _ in range(2)]
        for x in nums:
            x %= 2
            dp[x][0] = 1 + dp[0][x];
            dp[x][1] = 1 + dp[1][x];
        return max(map(max, dp))


    """3202. Find the Maximum Length of Valid Subsequence II (Medium)
    You are given an integer array nums and a positive integer k. A subsequence
    sub of nums with length x is called valid if it satisfies:
    * (sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k.
    Return the length of the longest valid subsequence of nums.

    Example 1:
    Input: nums = [1,2,3,4,5], k = 2
    Output: 5
    Explanation: The longest valid subsequence is [1, 2, 3, 4, 5].

    Example 2:
    Input: nums = [1,4,2,3,1,4], k = 3
    Output: 4
    Explanation: The longest valid subsequence is [1, 4, 1, 4].

    Constraints:
    * 2 <= nums.length <= 10^3
    * 1 <= nums[i] <= 10^7
    * 1 <= k <= 10^3"""

    def maximumLength(self, nums: List[int], k: int) -> int:
        dp = [[0]*k for _ in range(k)]
        for x in nums:
            x %= k
            for y in range(k):
                dp[x][y] = 1 + dp[y][x]
        return max(map(max, dp))


    """3203. Find Minimum Diameter After Merging Two Trees (Hard)
    There exist two undirected trees with n and m nodes, numbered from 0 to
    n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays
    edges1 and edges2 of lengths n - 1 and m - 1, respectively, where
    edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the first tree and edges2[i] = [ui, vi] indicates that there is an edge
    between nodes ui and vi in the second tree. You must connect one node from
    the first tree with another node from the second tree with an edge. Return
    the minimum possible diameter of the resulting tree. The diameter of a tree
    is the length of the longest path between any two nodes in the tree.

    Example 1:
    Input: edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]
    Output: 3
    Explanation: We can obtain a tree of diameter 3 by connecting node 0 from
                 the first tree with any node from the second tree.

    Example 2:
    Input: edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]
    Output: 5
    Explanation: We can obtain a tree of diameter 5 by connecting node 0 from
                 the first tree with node 0 from the second tree.

    Constraints:
    * 1 <= n, m <= 10^5
    * edges1.length == n - 1
    * edges2.length == m - 1
    * edges1[i].length == edges2[i].length == 2
    * edges1[i] = [ai, bi]
    * 0 <= ai, bi < n
    * edges2[i] = [ui, vi]
    * 0 <= ui, vi < m
    * The input is generated such that edges1 and edges2 represent valid trees."""

    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:

        def bfs(u, graph):
            """Return """
            ans = 0
            queue = deque([(u, -1)])
            while queue:
                ans += 1
                for _ in range(len(queue)):
                    u, p = queue.popleft()
                    for v in graph[u]:
                        if v != p:
                            queue.append((v, u))
            return ans-1, u

        def fn(edges):
            """Return """
            n = len(edges)+1
            graph = [[] for _ in range(n)]
            for u, v in edges:
                graph[u].append(v)
                graph[v].append(u)
            _, u = bfs(0, graph)
            dia, _ = bfs(u, graph)
            return dia

        d1 = fn(edges1)
        d2 = fn(edges2)
        return max(d1, d2, (d1+1)//2+(d2+1)//2+1)


    """3206. Alternating Groups I (Easy)
    There is a circle of red and blue tiles. You are given an array of integers
    colors. The color of tile i is represented by colors[i]:
    * colors[i] == 0 means that tile i is red.
    * colors[i] == 1 means that tile i is blue.
    Every 3 contiguous tiles in the circle with alternating colors (the middle
    tile has a different color from its left and right tiles) is called an
    alternating group. Return the number of alternating groups. Note that since
    colors represents a circle, the first and the last tiles are considered to
    be next to each other.

    Example 1:
    Input: colors = [1,1,1]
    Output: 0
    Explanation:

    Example 2:
    Input: colors = [0,1,0,0,1]
    Output: 3
    Explanation:
    Alternating groups:

    Constraints:
    * 3 <= colors.length <= 100
    * 0 <= colors[i] <= 1"""

    def numberOfAlternatingGroups(self, colors: List[int]) -> int:
        ans = cnt = 0
        n = len(colors)
        for i in range(n+2):
            if i and colors[(i-1)%n] == colors[i%n]: cnt = 0
            cnt += 1
            if cnt >= 3: ans += 1
        return ans


    """3207. Maximum Points After Enemy Battles (Medium)
    You are given an integer array enemyEnergies denoting the energy values of
    various enemies. You are also given an integer currentEnergy denoting the
    amount of energy you have initially. You start with 0 points, and all the
    enemies are unmarked initially. You can perform either of the following
    operations zero or multiple times to gain points:
    * Choose an unmarked enemy, i, such that currentEnergy >= enemyEnergies[i].
      By choosing this option:
      + You gain 1 point.
      + Your energy is reduced by the enemy's energy, i.e. currentEnergy =
        currentEnergy - enemyEnergies[i].
    * If you have at least 1 point, you can choose an unmarked enemy, i. By
      choosing this option:
      + Your energy increases by the enemy's energy, i.e. currentEnergy =
        currentEnergy + enemyEnergies[i].
      + The enemy i is marked.
    Return an integer denoting the maximum points you can get in the end by
    optimally performing operations.

    Example 1:
    Input: enemyEnergies = [3,2,2], currentEnergy = 2
    Output: 3
    Explanation: The following operations can be performed to get 3 points,
                 which is the maximum:
                 - First operation on enemy 1: points increases by 1, and
                   currentEnergy decreases by 2. So, points = 1, and
                   currentEnergy = 0.
                 - Second operation on enemy 0: currentEnergy increases by 3,
                   and enemy 0 is marked. So, points = 1, currentEnergy = 3, and
                   marked enemies = [0].
                 - First operation on enemy 2: points increases by 1, and
                   currentEnergy decreases by 2. So, points = 2,
                   currentEnergy = 1, and marked enemies = [0].
                 - Second operation on enemy 2: currentEnergy increases by 2,
                   and enemy 2 is marked. So, points = 2, currentEnergy = 3, and
                   marked enemies = [0, 2].
                 - First operation on enemy 1: points increases by 1, and
                   currentEnergy decreases by 2. So, points = 3,
                   currentEnergy = 1, and marked enemies = [0, 2].

    Example 2:
    Input: enemyEnergies = [2], currentEnergy = 10
    Output: 5
    Explanation: Performing the first operation 5 times on enemy 0 results in
                 the maximum number of points.

    Constraints:
    * 1 <= enemyEnergies.length <= 10^5
    * 1 <= enemyEnergies[i] <= 10^9
    * 0 <= currentEnergy <= 10^9"""

    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:
        m = min(enemyEnergies)
        if currentEnergy < m: return 0
        return (currentEnergy + sum(enemyEnergies) - m)//m


    """3208. Alternating Groups II (Medium）
    There is a circle of red and blue tiles. You are given an array of integers
    colors and an integer k. The color of tile i is represented by colors[i]:
    * colors[i] == 0 means that tile i is red.
    * colors[i] == 1 means that tile i is blue.
    An alternating group is every k contiguous tiles in the circle with
    alternating colors (each tile in the group except the first and last one has
    a different color from its left and right tiles). Return the number of
    alternating groups. Note that since colors represents a circle, the first
    and the last tiles are considered to be next to each other.

    Example 1:
    Input: colors = [0,1,0,1,0], k = 3
    Output: 3
    Explanation:
    Alternating groups:

    Example 2:
    Input: colors = [0,1,0,0,1,0,1], k = 6
    Output: 2
    Explanation:
    Alternating groups:

    Example 3:
    Input: colors = [1,1,0,1], k = 4
    Output: 0
    Explanation:

    Constraints:
    * 3 <= colors.length <= 10^5
    * 0 <= colors[i] <= 1
    * 3 <= k <= colors.length"""

    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:
        ans = cnt = 0
        n = len(colors)
        for i in range(n+k-1):
            if i and colors[(i-1)%n] == colors[i%n]: cnt = 0
            cnt += 1
            if cnt >= k: ans += 1
        return ans


    """3209. Number of Subarrays With AND Value of K (Hard)
    Given an array of integers nums and an integer k, return the number of
    subarrays of nums where the bitwise AND of the elements of the subarray
    equals k.

    Example 1:
    Input: nums = [1,1,1], k = 1
    Output: 6
    Explanation: All subarrays contain only 1's.

    Example 2:
    Input: nums = [1,1,2], k = 1
    Output: 3
    Explanation: Subarrays having an AND value of 1 are: [1,1,2], [1,1,2], [1,1,2].

    Example 3:
    Input: nums = [1,2,3], k = 2
    Output: 2
    Explanation: Subarrays having an AND value of 2 are: [1,2,3], [1,2,3].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i], k <= 10^9"""

    def countSubarrays(self, nums: List[int], k: int) -> int:
        ans = 0
        freq = Counter()
        for x in nums:
            temp = Counter()
            if k & x == k:
                freq[x] += 1
                for key, val in freq.items():
                    temp[key & x] += val
                ans += temp[k]
            freq = temp
        return ans


    """3216. Lexicographically Smallest String After a Swap (Easy)
    Given a string s containing only digits, return the lexicographically
    smallest string that can be obtained after swapping adjacent digits in s
    with the same parity at most once. Digits have the same parity if both are
    odd or both are even. For example, 5 and 9, as well as 2 and 4, have the
    same parity, while 6 and 9 do not.

    Example 1:
    Input: s = "45320"
    Output: "43520"
    Explanation: s[1] == '5' and s[2] == '3' both have the same parity, and
                 swapping them results in the lexicographically smallest string.

    Example 2:
    Input: s = "001"
    Output: "001"
    Explanation: There is no need to perform a swap because s is already the
                 lexicographically smallest.

    Constraints:
    * 2 <= s.length <= 100
    * s consists only of digits."""

    def getSmallestString(self, s: str) -> str:
        s = list(map(int, s))
        for i in range(len(s)-1):
            if s[i]&1 == s[i+1]&1 and s[i] > s[i+1]:
                s[i], s[i+1] = s[i+1], s[i]
                break
        return ''.join(map(str, s))


    """3217. Delete Nodes From Linked List Present in Array (Medium)
    You are given an array of integers nums and the head of a linked list.
    Return the head of the modified linked list after removing all nodes from
    the linked list that have a value that exists in nums.

    Example 1:
    Input: nums = [1,2,3], head = [1,2,3,4,5]
    Output: [4,5]
    Explanation: Remove the nodes with values 1, 2, and 3.

    Example 2:
    Input: nums = [1], head = [1,2,1,2,1,2]
    Output: [2,2,2]
    Explanation: Remove the nodes with value 1.

    Example 3:
    Input: nums = [5], head = [1,2,3,4]
    Output: [1,2,3,4]
    Explanation: No node has value 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * All elements in nums are unique.
    * The number of nodes in the given list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5
    * The input is generated such that there is at least one node in the linked
      list that has a value not present in nums."""

    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        seen = set(nums)
        dummy = node = ListNode(0, head)
        while node.next:
            if node.next.val in seen: node.next = node.next.next
            else: node = node.next
        return dummy.next


    """3218. Minimum Cost for Cutting Cake I (Medium)
    There is an m x n cake that needs to be cut into 1 x 1 pieces. You are given
    integers m, n, and two arrays:
    * horizontalCut of size m - 1, where horizontalCut[i] represents the cost to
      cut along the horizontal line i.
    * verticalCut of size n - 1, where verticalCut[j] represents the cost to cut
      along the vertical line j.
    In one operation, you can choose any piece of cake that is not yet a 1 x 1
    square and perform one of the following cuts:
    * Cut along a horizontal line i at a cost of horizontalCut[i].
    * Cut along a vertical line j at a cost of verticalCut[j].
    After the cut, the piece of cake is divided into two distinct pieces. The
    cost of a cut depends only on the initial cost of the line and does not
    change. Return the minimum total cost to cut the entire cake into 1 x 1
    pieces.

    Example 1:
    Input: m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]
    Output: 13
    Explanation: Perform a cut on the vertical line 0 with cost 5, current total
                 cost is 5.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 The total cost is 5 + 1 + 1 + 3 + 3 = 13.

    Example 2:
    Input: m = 2, n = 2, horizontalCut = [7], verticalCut = [4]
    Output: 15
    Explanation: Perform a cut on the horizontal line 0 with cost 7.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 The total cost is 7 + 4 + 4 = 15.

    Constraints:
    * 1 <= m, n <= 20
    * horizontalCut.length == m - 1
    * verticalCut.length == n - 1
    * 1 <= horizontalCut[i], verticalCut[i] <= 10^3"""

    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
        ans = 0
        horizontalCut.sort()
        verticalCut.sort()
        hh = sum(horizontalCut)
        vv = sum(verticalCut)
        while horizontalCut or verticalCut:
            if not horizontalCut or verticalCut and verticalCut[-1] > horizontalCut[-1]:
                ans += verticalCut[-1] + hh
                vv -= verticalCut.pop()
            else:
                ans += horizontalCut[-1] + vv
                hh -= horizontalCut.pop()
        return ans


    """3219. Minimum Cost for Cutting Cake II (Hard)
    There is an m x n cake that needs to be cut into 1 x 1 pieces. You are given
    integers m, n, and two arrays:
    * horizontalCut of size m - 1, where horizontalCut[i] represents the cost to
      cut along the horizontal line i.
    * verticalCut of size n - 1, where verticalCut[j] represents the cost to cut
      along the vertical line j.
    In one operation, you can choose any piece of cake that is not yet a 1 x 1
    square and perform one of the following cuts:
    * Cut along a horizontal line i at a cost of horizontalCut[i].
    * Cut along a vertical line j at a cost of verticalCut[j].
    After the cut, the piece of cake is divided into two distinct pieces. The
    cost of a cut depends only on the initial cost of the line and does not
    change. Return the minimum total cost to cut the entire cake into 1 x 1
    pieces.

    Example 1:
    Input: m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]
    Output: 13
    Explanation: Perform a cut on the vertical line 0 with cost 5, current total
                 cost is 5.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 The total cost is 5 + 1 + 1 + 3 + 3 = 13.

    Example 2:
    Input: m = 2, n = 2, horizontalCut = [7], verticalCut = [4]
    Output: 15
    Explanation: Perform a cut on the horizontal line 0 with cost 7.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 The total cost is 7 + 4 + 4 = 15.

    Constraints:
    * 1 <= m, n <= 10^5
    * horizontalCut.length == m - 1
    * verticalCut.length == n - 1
    * 1 <= horizontalCut[i], verticalCut[i] <= 10^3"""

    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
        ans = 0
        horizontalCut.sort()
        verticalCut.sort()
        hh = sum(horizontalCut)
        vv = sum(verticalCut)
        while horizontalCut or verticalCut:
            if not horizontalCut or verticalCut and verticalCut[-1] > horizontalCut[-1]:
                ans += verticalCut[-1] + hh
                vv -= verticalCut.pop()
            else:
                ans += horizontalCut[-1] + vv
                hh -= horizontalCut.pop()
        return ans


    """3222. Find the Winning Player in Coin Game (Easy)
    You are given two positive integers x and y, denoting the number of coins
    with values 75 and 10 respectively. Alice and Bob are playing a game. Each
    turn, starting with Alice, the player must pick up coins with a total value
    115. If the player is unable to do so, they lose the game. Return the name
    of the player who wins the game if both players play optimally.

    Example 1:
    Input: x = 2, y = 7
    Output: "Alice"
    Explanation: The game ends in a single turn:
                 - Alice picks 1 coin with a value of 75 and 4 coins with a value
                   of 10.

    Example 2:
    Input: x = 4, y = 11
    Output: "Bob"
    Explanation: The game ends in 2 turns:
                 - Alice picks 1 coin with a value of 75 and 4 coins with a
                   value of 10.
                 - Bob picks 1 coin with a value of 75 and 4 coins with a value
                   of 10.

    Constraints: 1 <= x, y <= 100"""

    def losingPlayer(self, x: int, y: int) -> str:
        return "Alice" if min(x, y//4)&1 else "Bob"


    """3223. Minimum Length of String After Operations (Medium)
    You are given a string s. You can perform the following process on s any
    number of times:
    * Choose an index i in the string such that there is at least one character
      to the left of index i that is equal to s[i], and at least one character
      to the right that is also equal to s[i].
    * Delete the closest character to the left of index i that is equal to s[i].
    * Delete the closest character to the right of index i that is equal to s[i].
    Return the minimum length of the final string s that you can achieve.

    Example 1:
    Input: s = "abaacbcbb"
    Output: 5
    Explanation: We do the following operations:
                 - Choose index 2, then remove the characters at indices 0 and
                   3. The resulting string is s = "bacbcbb".
                 - Choose index 3, then remove the characters at indices 0 and
                   5. The resulting string is s = "acbcb".

    Example 2:
    Input: s = "aa"
    Output: 2
    Explanation: We cannot perform any operations, so we return the length of
                 the original string.

    Constraints:
    * 1 <= s.length <= 2 * 10^5
    * s consists only of lowercase English letters."""

    def minimumLength(self, s: str) -> int:
        return sum(2 - v%2 for v in Counter(s).values())


    """3224. Minimum Array Changes to Make Differences Equal (Medium)
    You are given an integer array nums of size n where n is even, and an
    integer k. You can perform some changes on the array, where in one change
    you can replace any element in the array with any integer in the range from
    0 to k. You need to perform some changes (possibly none) such that the final
    array satisfies the following condition:
    * There exists an integer X such that abs(a[i] - a[n - i - 1]) = X for all
      (0 <= i < n).
    Return the minimum number of changes required to satisfy the above
    condition.

    Example 1:
    Input: nums = [1,0,1,2,4,3], k = 4
    Output: 2
    Explanation: We can perform the following changes:
                 - Replace nums[1] by 2. The resulting array is
                   nums = [1,2,1,2,4,3].
                 - Replace nums[3] by 3. The resulting array is
                   nums = [1,2,1,3,4,3].
                 The integer X will be 2.

    Example 2:
    Input: nums = [0,1,2,3,3,6,5,4], k = 6
    Output: 2
    Explanation: We can perform the following operations:
                 - Replace nums[3] by 0. The resulting array is
                   nums = [0,1,2,0,3,6,5,4].
                 - Replace nums[4] by 4. The resulting array is
                   nums = [0,1,2,0,4,6,5,4].
                 The integer X will be 4.

    Constraints:
    * 2 <= n == nums.length <= 10^5
    * n is even.
    * 0 <= nums[i] <= k <= 10^5"""

    def minChanges(self, nums: List[int], k: int) -> int:
        line = [0]*(k+2)
        n = len(nums)
        for i in range(n//2):
            if nums[i] > nums[~i]:
                nums[i], nums[~i] = nums[~i], nums[i]
            diff = nums[~i] - nums[i]
            line[diff] -= 1
            line[diff+1] += 1
            diff += max(nums[i], k-nums[~i])
            line[diff+1] += 1
        ans = prefix = n//2
        for x in range(k+1):
            prefix += line[x]
            ans = min(ans, prefix)
        return ans


    """3225. Maximum Score From Grid Operations (Hard)
    You are given a 2D matrix grid of size n x n. Initially, all cells of the
    grid are colored white. In one operation, you can select any cell of indices
    (i, j), and color black all the cells of the jth column starting from the
    top row down to the ith row. The grid score is the sum of all grid[i][j]
    such that cell (i, j) is white and it has a horizontally adjacent black
    cell. Return the maximum score that can be achieved after some number of
    operations.

    Example 1:
    Input: grid = [[0,0,0,0,0],[0,0,3,0,0],[0,1,0,0,0],[5,0,0,3,0],[0,0,0,0,2]]
    Output: 11
    Explanation: In the first operation, we color all cells in column 1 down to
                 row 3, and in the second operation, we color all cells in
                 column 4 down to the last row. The score of the resulting grid
                 is grid[3][0] + grid[1][2] + grid[3][3] which is equal to 11.

    Example 2:
    Input: grid = [[10,9,0,0,15],[7,1,0,8,0],[5,20,0,11,0],[0,0,0,1,2],[8,12,1,10,3]]
    Output: 94
    Explanation: We perform operations on 1, 2, and 3 down to rows 1, 4, and 0,
                 respectively. The score of the resulting grid is
                 grid[0][0] + grid[1][0] + grid[2][1] + grid[4][1] + grid[1][3]
                 + grid[2][3] + grid[3][3] + grid[4][3] + grid[0][4] which is
                 equal to 94.

    Constraints:
    * 1 <= n == grid.length <= 100
    * n == grid[i].length
    * 0 <= grid[i][j] <= 10^9"""

    def maximumScore(self, grid: List[List[int]]) -> int:
        n = len(grid)
        prefix = [[0]*n for _ in range(n+1)]
        excl = [[0]*n for _ in range(n+1)]
        incl = [[0]*n for _ in range(n+1)]
        for j in range(n):
            for i in range(n):
                prefix[i+1][j] = prefix[i][j] + grid[i][j]
            if j:
                for c in range(n+1):
                    for p in range(n+1):
                        pv = cv = 0
                        if c > p: pv = prefix[c][j-1] - prefix[p][j-1]
                        else: cv = prefix[p][j] - prefix[c][j]
                        excl[c][j] = max(excl[c][j], pv + excl[p][j-1], incl[p][j-1])
                        incl[c][j] = max(incl[c][j], cv + incl[p][j-1], cv + pv + excl[p][j-1])
        return max(incl[i][n-1] for i in range(n+1))


    """3226. Number of Bit Changes to Make Two Integers Equal (Easy)
    You are given two positive integers n and k. You can choose any bit in the
    binary representation of n that is equal to 1 and change it to 0. Return the
    number of changes needed to make n equal to k. If it is impossible, return
    -1.

    Example 1:
    Input: n = 13, k = 4
    Output: 2
    Explanation: Initially, the binary representations of n and k are
                 n = (1101)2 and k = (0100)2. We can change the first and fourth
                 bits of n. The resulting integer is n = (0100)2 = k.

    Example 2:
    Input: n = 21, k = 21
    Output: 0
    Explanation: n and k are already equal, so no changes are needed.

    Example 3:
    Input: n = 14, k = 13
    Output: -1
    Explanation: It is not possible to make n equal to k.

    Constraints: 1 <= n, k <= 10^6"""

    def minChanges(self, n: int, k: int) -> int:
        return (n ^ k).bit_count() if n & k == k else -1


    """3227. Vowels Game in a String (Medium)
    Alice and Bob are playing a game on a string. You are given a string s,
    Alice and Bob will take turns playing the following game where Alice starts
    first:
    * On Alice's turn, she has to remove any non-empty substring from s that
      contains an odd number of vowels.
    * On Bob's turn, he has to remove any non-empty substring from s that
      contains an even number of vowels.
    The first player who cannot make a move on their turn loses the game. We
    assume that both Alice and Bob play optimally. Return true if Alice wins the
    game, and false otherwise. The English vowels are: a, e, i, o, and u.

    Example 1:
    Input: s = "leetcoder"
    Output: true
    Explanation: Alice can win the game as follows:
                 * Alice plays first, she can delete the underlined substring in
                   s = "leetcoder" which contains 3 vowels. The resulting string
                   is s = "der".
                 * Bob plays second, he can delete the underlined substring in
                   s = "der" which contains 0 vowels. The resulting string is
                   s = "er".
                 * Alice plays third, she can delete the whole string s = "er"
                   which contains 1 vowel.
                 * Bob plays fourth, since the string is empty, there is no
                 valid play for Bob. So Alice wins the game.

    Example 2:
    Input: s = "bbcd"
    Output: false
    Explanation: There is no valid play for Alice in her first turn, so Alice
                 loses the game.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters."""

    def doesAliceWin(self, s: str) -> bool:
        return set(s) & set("aeiou")


    """3228. Maximum Number of Operations to Move Ones to the End (Medium)
    You are given a binary string s. You can perform the following operation on
    the string any number of times:
    * Choose any index i from the string where i + 1 < s.length such that
      s[i] == '1' and s[i + 1] == '0'.
    * Move the character s[i] to the right until it reaches the end of the
      string or another '1'. For example, for s = "010010", if we choose i = 1,
      the resulting string will be s = "000110".
    Return the maximum number of operations that you can perform.

    Example 1:
    Input: s = "1001101"
    Output: 4
    Explanation: We can perform the following operations:
                 Choose index i = 0. The resulting string is s = "0011101".
                 Choose index i = 4. The resulting string is s = "0011011".
                 Choose index i = 3. The resulting string is s = "0010111".
                 Choose index i = 2. The resulting string is s = "0001111".

    Example 2:
    Input: s = "00111"
    Output: 0

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'."""

    def maxOperations(self, s: str) -> int:
        ans = cnt = 0
        for i in range(len(s)-1, -1, -1):
            if s[i] == '0':
                if (i+1 == len(s) or s[i+1] == '1'): cnt += 1
            else: ans += cnt
        return ans


    """3229. Minimum Operations to Make Array Equal to Target (Hard)
    You are given two positive integer arrays nums and target, of the same
    length. In a single operation, you can select any subarray of nums and
    increment or decrement each element within that subarray by 1. Return the
    minimum number of operations required to make nums equal to the array
    target.

    Example 1:
    Input: nums = [3,5,1,2], target = [4,6,2,4]
    Output: 2
    Explanation: We will perform the following operations to make nums equal to
                 target:
                - Increment nums[0..3] by 1, nums = [4,6,2,3].
                 - Increment nums[3..3] by 1, nums = [4,6,2,4].

    Example 2:
    Input: nums = [1,3,2], target = [2,1,4]
    Output: 5
    Explanation: We will perform the following operations to make nums equal to
                 target:
                 - Increment nums[0..0] by 1, nums = [2,3,2].
                 - Decrement nums[1..1] by 1, nums = [2,2,2].
                 - Decrement nums[1..1] by 1, nums = [2,1,2].
                 - Increment nums[2..2] by 1, nums = [2,1,3].
                 - Increment nums[2..2] by 1, nums = [2,1,4].

    Constraints:
    * 1 <= nums.length == target.length <= 10^5
    * 1 <= nums[i], target[i] <= 10^8"""

    def minimumOperations(self, nums: List[int], target: List[int]) -> int:
        ans = prev = 0
        for n, t in zip(nums, target):
            diff = t - n
            ans += max(0, diff - prev)
            prev = diff
        return ans + max(0, -prev)


    """3232. Find if Digit Game Can Be Won (Easy)
    You are given an array of positive integers nums. Alice and Bob are playing
    a game. In the game, Alice can choose either all single-digit numbers or all
    double-digit numbers from nums, and the rest of the numbers are given to
    Bob. Alice wins if the sum of her numbers is strictly greater than the sum
    of Bob's numbers. Return true if Alice can win this game, otherwise, return
    false.

    Example 1:
    Input: nums = [1,2,3,4,10]
    Output: false
    Explanation: Alice cannot win by choosing either single-digit or double-
                 digit numbers.

    Example 2:
    Input: nums = [1,2,3,4,5,14]
    Output: true
    Explanation: Alice can win by choosing single-digit numbers which have a sum
                 equal to 15.

    Example 3:
    Input: nums = [5,5,5,25]
    Output: true
    Explanation: Alice can win by choosing double-digit numbers which have a sum
                 equal to 25.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 99"""

    def canAliceWin(self, nums: List[int]) -> bool:
        single = total = 0
        for x in nums:
            if x < 10: single += x
            total += x
        return 2*single != total


    """3233. Find the Count of Numbers Which Are Not Special (Medium)
    You are given 2 positive integers l and r. For any number x, all positive
    divisors of x except x are called the proper divisors of x. A number is
    called special if it has exactly 2 proper divisors. For example:
    * The number 4 is special because it has proper divisors 1 and 2.
    * The number 6 is not special because it has proper divisors 1, 2, and 3.
    Return the count of numbers in the range [l, r] that are not special.

    Example 1:
    Input: l = 5, r = 7
    Output: 3
    Explanation: There are no special numbers in the range [5, 7].

    Example 2:
    Input: l = 4, r = 16
    Output: 11
    Explanation: The special numbers in the range [4, 16] are 4 and 9.

    Constraints: 1 <= l <= r <= 10^9"""

    def nonSpecialCount(self, l: int, r: int) -> int:
        lo = ceil(sqrt(l))
        hi = floor(sqrt(r))
        sieve = [1]*(hi+1)
        sieve[0] = sieve[1] = 0
        for x in range(2, hi+1):
            if x:
                for xx in range(x*x, hi+1, x):
                    sieve[xx] = 0
        return r-l+1-sum(sieve[x] for x in range(lo, hi+1))


    """3234. Count the Number of Substrings With Dominant Ones (Medium)
    You are given a binary string s. Return the number of substrings with
    dominant ones. A string has dominant ones if the number of ones in the
    string is greater than or equal to the square of the number of zeros in the
    string.

    Example 1:
    Input: s = "00011"
    Output: 5
    Explanation: The substrings with dominant ones are shown in the table below.
                 i   j   s[i..j] Number of Zeros Number of Ones
                 3   3   1   0   1
                 4   4   1   0   1
                 2   3   01  1   1
                 3   4   11  0   2
                 2   4   011 1   2

    Example 2:
    Input: s = "101101"
    Output: 16
    Explanation: The substrings with non-dominant ones are shown in the table
                 below. Since there are 21 substrings total and 5 of them have
                 non-dominant ones, it follows that there are 16 substrings with
                 dominant ones.
                 i   j   s[i..j] Number of Zeros Number of Ones
                 1   1   0   1   0
                 4   4   0   1   0
                 1   4   0110    2   2
                 0   4   10110   2   3
                 1   5   01101   2   3

    Constraints:
    * 1 <= s.length <= 4 * 10^4
    * s consists only of characters '0' and '1'."""

    def numberOfSubstrings(self, s: str) -> int:
        ans = 0
        for z in range(isqrt(len(s))+1):
            j = zeroj = 0
            k = zerok = onek = 0
            for i, ch in enumerate(s):
                if ch == '0': zeroj += 1; zerok += 1
                else: onek += 1
                while zeroj > z:
                    if s[j] == '0': zeroj -= 1
                    j += 1
                while zerok > z or k <= i and zerok == z and onek >= zerok**2:
                    if s[k] == '0': zerok -= 1
                    else: onek -= 1
                    k += 1
                ans += k-j
        return ans


    """3235. Check if the Rectangle Corner Is Reachable (Hard)
    You are given two positive integers X and Y, and a 2D array circles, where
    circles[i] = [xi, yi, ri] denotes a circle with center at (xi, yi) and
    radius ri. There is a rectangle in the coordinate plane with its bottom left
    corner at the origin and top right corner at the coordinate (X, Y). You need
    to check whether there is a path from the bottom left corner to the top
    right corner such that the entire path lies inside the rectangle, does not
    touch or lie inside any circle, and touches the rectangle only at the two
    corners. Return true if such a path exists, and false otherwise.

    Example 1:
    Input: X = 3, Y = 4, circles = [[2,1,1]]
    Output: true
    Explanation: The black curve shows a possible path between (0, 0) and (3, 4).

    Example 2:
    Input: X = 3, Y = 3, circles = [[1,1,2]]
    Output: false
    Explanation: No path exists from (0, 0) to (3, 3).

    Example 3:
    Input: X = 3, Y = 3, circles = [[2,1,1],[1,2,1]]
    Output: false
    Explanation: No path exists from (0, 0) to (3, 3).

    Constraints:
    * 3 <= X, Y <= 10^9
    * 1 <= circles.length <= 1000
    * circles[i].length == 3
    * 1 <= xi, yi, ri <= 10^9"""

    def canReachCorner(self, X: int, Y: int, circles: List[List[int]]) -> bool:
        vals = []
        for x, y, r in circles:
            if x**2 + y**2 <= r**2: return False
            if (X-x)**2 + (Y-y)**2 <= r**2: return False
            if x >= X+r or y >= Y+r: continue
            vals.append([x, y, r])
        circles = vals

        n = len(circles)
        parent = list(range(n))

        def find(p):
            if p != parent[p]:
                parent[p] = find(parent[p])
            return parent[p]

        for i in range(n):
            xi, yi, ri = circles[i]
            for j in range(i+1, n):
                xj, yj, rj = circles[j]
                if (xi-xj)**2 + (yi-yj)**2 <= (ri+rj)**2:
                    ii = find(i)
                    jj = find(j)
                    parent[ii] = jj

        group = defaultdict(list)
        for i in range(n):
            ii = find(i)
            group[ii].append(i)

        for grp in group.values():
            xmax = ymax = -inf
            xmin = ymin = inf
            inside = False
            for i in grp:
                x, y, r = circles[i]
                if 0 <= x <= X or 0 <= y <= Y: inside = True
                xmax = max(xmax, x+r)
                ymax = max(ymax, y+r)
                xmin = min(xmin, x-r)
                ymin = min(ymin, y-r)
            if inside:
                if xmin <= 0 and xmax >= X: return False
                if ymin <= 0 and ymax >= Y: return False
                if xmax >= X and ymax >= Y: return False
                if xmin <= 0 and ymin <= 0: return False
        return True


    """3238. Find the Number of Winning Players (Easy)
    You are given an integer n representing the number of players in a game and
    a 2D array pick where pick[i] = [xi, yi] represents that the player xi
    picked a ball of color yi. Player i wins the game if they pick strictly more
    than i balls of the same color. In other words,
    * Player 0 wins if they pick any ball.
    * Player 1 wins if they pick at least two balls of the same color.
    * ...
    * Player i wins if they pick at leasti + 1 balls of the same color.
    Return the number of players who win the game. Note that multiple players
    can win the game.

    Example 1:
    Input: n = 4, pick = [[0,0],[1,0],[1,0],[2,1],[2,1],[2,0]]
    Output: 2
    Explanation: Player 0 and player 1 win the game, while players 2 and 3 do
    not win.

    Example 2:
    Input: n = 5, pick = [[1,1],[1,2],[1,3],[1,4]]
    Output: 0
    Explanation: No player wins the game.

    Example 3:
    Input: n = 5, pick = [[1,1],[2,4],[2,4],[2,4]]
    Output: 1
    Explanation: Player 2 wins the game by picking 3 balls with color 4.

    Constraints:
    * 2 <= n <= 10
    * 1 <= pick.length <= 100
    * pick[i].length == 2
    * 0 <= xi <= n - 1
    * 0 <= yi <= 10"""

    def winningPlayerCount(self, n: int, pick: List[List[int]]) -> int:
        freq = [[0]*11 for _ in range(n)]
        for x, y in pick:
            freq[x][y] += 1
        return sum(1 for i, row in enumerate(freq) if i+1 <= max(row))


    """3239. Minimum Number of Flips to Make Binary Grid Palindromic I (Medium)
    You are given an m x n binary matrix grid. A row or column is considered
    palindromic if its values read the same forward and backward. You can flip
    any number of cells in grid from 0 to 1, or from 1 to 0. Return the minimum
    number of cells that need to be flipped to make either all rows palindromic
    or all columns palindromic.

    Example 1:
    Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
    Output: 2
    Explanation: Flipping the highlighted cells makes all the rows palindromic.

    Example 2:
    Input: grid = [[0,1],[0,1],[0,0]]
    Output: 1
    Explanation: Flipping the highlighted cell makes all the columns palindromic.

    Example 3:
    Input: grid = [[1],[0]]
    Output: 0
    Explanation: All rows are already palindromic.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m * n <= 2 * 10^5
    * 0 <= grid[i][j] <= 1"""

    def minFlips(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        row = col = 0
        for i in range(m):
            for j in range(n):
                row += grid[i][j] ^ grid[m-1-i][j]
                col += grid[i][j] ^ grid[i][n-1-j]
        return min(row, col)//2;


    """3240. Minimum Number of Flips to Make Binary Grid Palindromic II (Medium)
    You are given an m x n binary matrix grid. A row or column is considered
    palindromic if its values read the same forward and backward. You can flip
    any number of cells in grid from 0 to 1, or from 1 to 0. Return the minimum
    number of cells that need to be flipped to make all rows and columns
    palindromic, and the total number of 1's in grid divisible by 4.

    Example 1:
    Input: grid = [[1,0,0],[0,1,0],[0,0,1]]
    Output: 3
    Explanation:

    Example 2:
    Input: grid = [[0,1],[0,1],[0,0]]
    Output: 2
    Explanation:

    Example 3:
    Input: grid = [[1],[1]]
    Output: 2
    Explanation:

    * Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m * n <= 2 * 10^5
    * 0 <= grid[i][j] <= 1"""

    def minFlips(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = ones = 0
        if n & 1:
            for i in range(m//2):
                total = grid[i][n//2] + grid[~i][n//2]
                if total == 2: ones = (ones+1) % 2
                elif total == 1: ans += 1
        if m & 1:
            for j in range(n//2):
                total = grid[m//2][j] + grid[m//2][~j]
                if total == 2: ones = (ones+1) % 2
                elif total == 1: ans += 1
        if ones and ans == 0: ans += 2
        if m&1 and n&1 and grid[m//2][n//2]: ans += 1
        for i in range(m//2):
            for j in range(n//2):
                total = grid[i][j] + grid[i][~j] + grid[~i][j] + grid[~i][~j]
                ans += min(total, 4-total)
        return ans


    """3241. Time Taken to Mark All Nodes (Hard)
    There exists an undirected tree with n nodes numbered 0 to n - 1. You are
    given a 2D integer array edges of length n - 1, where edges[i] = [ui, vi]
    indicates that there is an edge between nodes ui and vi in the tree.
    Initially, all nodes are unmarked. For each node i:
    * If i is odd, the node will get marked at time x if there is at least one
      node adjacent to it which was marked at time x - 1.
    * If i is even, the node will get marked at time x if there is at least one
      node adjacent to it which was marked at time x - 2.
    Return an array times where times[i] is the time when all nodes get marked
    in the tree, if you mark node i at time t = 0. Note that the answer for each
    times[i] is independent, i.e. when you mark node i all other nodes are
    unmarked.

    Example 1:
    Input: edges = [[0,1],[0,2]]
    Output: [2,4,3]
    Explanation: For i = 0: Node 1 is marked at t = 1, and Node 2 at t = 2.
                 For i = 1: Node 0 is marked at t = 2, and Node 2 at t = 4.
                 For i = 2: Node 0 is marked at t = 2, and Node 1 at t = 3.

    Example 2:
    Input: edges = [[0,1]]
    Output: [1,2]
    Explanation: For i = 0: Node 1 is marked at t = 1.
                 For i = 1: Node 0 is marked at t = 2.

    Example 3:
    Input: edges = [[2,4],[0,1],[2,3],[0,2]]
    Output: [4,6,3,5,5]
    Explanation:

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * The input is generated such that edges represents a valid tree."""

    def timeTaken(self, edges: List[List[int]]) -> List[int]:
        n = 1+len(edges)
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        vals = [[(-1, 0)]*2 for _ in range(n)]

        def dfs(u, p):
            """Return """
            for v in tree[u]:
                if v != p:
                    cand = 2-(v&1)+dfs(v, u)
                    insort(vals[u], (v, cand), key = lambda x: -x[1])
                    vals[u].pop()
            return vals[u][0][1]

        dfs(0, -1)
        ans = [0]*n
        stack = [(0, -1, 0)]
        while stack:
            u, p, x = stack.pop()
            insort(vals[u], (p, x), key = lambda x: -x[1])
            ans[u] = vals[u][0][1]
            for v in tree[u]:
                if v != p:
                    if v != vals[u][0][0]: xx = vals[u][0][1]
                    else: xx = vals[u][1][1]
                    stack.append((v, u, xx+2-(u&1)))
        return ans


    """3243. Shortest Distance After Road Addition Queries I (Medium)
    You are given an integer n and a 2D integer array queries. There are n
    cities numbered from 0 to n - 1. Initially, there is a unidirectional road
    from city i to city i + 1 for all 0 <= i < n - 1. queries[i] = [ui, vi]
    represents the addition of a new unidirectional road from city ui to city
    vi. After each query, you need to find the length of the shortest path from
    city 0 to city n - 1. Return an array answer where for each i in the range
    [0, queries.length - 1], answer[i] is the length of the shortest path from
    city 0 to city n - 1 after processing the first i + 1 queries.

    Example 1:
    Input: n = 5, queries = [[2,4],[0,2],[0,4]]
    Output: [3,2,1]
    Explanation: - After the addition of the road from 2 to 4, the length of the
                   shortest path from 0 to 4 is 3.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path from 0 to 4 is 2.
                 - After the addition of the road from 0 to 4, the length of the
                   shortest path from 0 to 4 is 1.

    Example 2:
    Input: n = 4, queries = [[0,3],[0,2]]
    Output: [1,1]
    Explanation: - After the addition of the road from 0 to 3, the length of the
                   shortest path from 0 to 3 is 1.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path remains 1.

    Constraints:
    * 3 <= n <= 500
    * 1 <= queries.length <= 500
    * queries[i].length == 2
    * 0 <= queries[i][0] < queries[i][1] < n
    * 1 < queries[i][1] - queries[i][0]
    * There are no repeated roads among the queries."""

    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(n)]
        for i in range(n-1):
            graph[i].append(i+1)

        def bfs(graph):
            """Return """
            queue = deque([0])
            seen = {0}
            ans = 0
            while queue:
                for _ in range(len(queue)):
                    u = queue.popleft()
                    if u == n-1: return ans
                    for v in graph[u]:
                        if v not in seen:
                            queue.append(v)
                            seen.add(v)
                ans += 1

        ans = []
        for u, v in queries:
            graph[u].append(v)
            ans.append(bfs(graph))
        return ans


    """3244. Shortest Distance After Road Addition Queries II (Hard)
    You are given an integer n and a 2D integer array queries. There are n
    cities numbered from 0 to n - 1. Initially, there is a unidirectional road
    from city i to city i + 1 for all 0 <= i < n - 1. queries[i] = [ui, vi]
    represents the addition of a new unidirectional road from city ui to city
    vi. After each query, you need to find the length of the shortest path from
    city 0 to city n - 1. There are no two queries such that
    queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]. Return an
    array answer where for each i in the range [0, queries.length - 1],
    answer[i] is the length of the shortest path from city 0 to city n - 1 after
    processing the first i + 1 queries.

    Example 1:
    Input: n = 5, queries = [[2,4],[0,2],[0,4]]
    Output: [3,2,1]
    Explanation: - After the addition of the road from 2 to 4, the length of the
                   shortest path from 0 to 4 is 3.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path from 0 to 4 is 2.
                 - After the addition of the road from 0 to 4, the length of the
                   shortest path from 0 to 4 is 1.

    Example 2:
    Input: n = 4, queries = [[0,3],[0,2]]
    Output: [1,1]
    Explanation: - After the addition of the road from 0 to 3, the length of the
                   shortest path from 0 to 3 is 1.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path remains 1.

    Constraints:
    * 3 <= n <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= queries[i][0] < queries[i][1] < n
    * 1 < queries[i][1] - queries[i][0]
    * There are no repeated roads among the queries.
    * There are no two queries such that i != j and queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]."""

    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        ans = []
        jump = list(range(1, n))
        n -= 1
        for u, v in queries:
            while jump[u] < v:
                jump[u], u = v, jump[u]
                n -= 1
            ans.append(n)
        return ans


    """3245. Alternating Groups III (Hard)
    There are some red and blue tiles arranged circularly. You are given an
    array of integers colors and a 2D integers array queries. The color of tile
    i is represented by colors[i]:
    * colors[i] == 0 means that tile i is red.
    * colors[i] == 1 means that tile i is blue.
    An alternating group is a contiguous subset of tiles in the circle with
    alternating colors (each tile in the group except the first and last one has
    a different color from its adjacent tiles in the group). You have to process
    queries of two types:
    * queries[i] = [1, sizei], determine the count of alternating groups with
      size sizei.
    * queries[i] = [2, indexi, colori], change colors[indexi] to colori.
    Return an array answer containing the results of the queries of the first
    type in order. Note that since colors represents a circle, the first and the
    last tiles are considered to be next to each other.

    Example 1:
    Input: colors = [0,1,1,0,1], queries = [[2,1,0],[1,4]]
    Output: [2]
    Explanation: First query:
                 Change colors[1] to 0.
                 Second query:
                 Count of the alternating groups with size 4:

    Example 2:
    Input: colors = [0,0,1,0,1,1], queries = [[1,3],[2,3,0],[1,5]]
    Output: [2,0]
    Explanation: First query:
                 Count of the alternating groups with size 3:
                 Second query: colors will not change.
                 Third query: There is no alternating group with size 5.

    Constraints:
    * 4 <= colors.length <= 5 * 10^4
    * 0 <= colors[i] <= 1
    * 1 <= queries.length <= 5 * 10^4
    * queries[i][0] == 1 or queries[i][0] == 2
    * For all i that:
    * queries[i][0] == 1: queries[i].length == 2, 3 <= queries[i][1] <= colors.length - 1
    * queries[i][0] == 2: queries[i].length == 3, 0 <= queries[i][1] <= colors.length - 1, 0 <= queries[i][2] <= 1

    class Fenwick:

        def __init__(self, n: int):
            self.cnts = [0]*(n+1)
            self.vals = [0]*(n+1)

        def add(self, k: int, v: int) -> None:
            i = k+1
            while i < len(self.cnts):
                self.cnts[i] += v
                self.vals[i] += k*v
                i += i & -i

        def query(self, k: int, v: int) -> int:
            ans = 0
            i = k+1
            while i:
                ans += self.vals[i] - v*self.cnts[i]
                i -= i & -i
            return ans
    """

    def numberOfAlternatingGroups(self, colors: List[int], queries: List[List[int]]) -> List[int]:
        n = len(colors)
        i = 0
        mp = {}
        while i < n:
            for j in range(i, i+n):
                if colors[j%n] == colors[(j+1)%n]: break
            mp[j%n] = i
            i = j+1
        groups = SortedList()
        fen = Fenwick(n+1)

        dist = lambda i, j: j-i+1 if i <= j else n+j-i+1

        def add(i, j):
            groups.add((j, i))
            fen.add(dist(i, j), 1)

        def remove(k):
            j, i = groups.pop(k)
            fen.add(dist(i, j), -1)
            return i, j

        for j, i in mp.items(): add(i, j)
        ans = []
        for q in queries:
            if q[0] == 1:
                if len(groups) == 1 and colors[groups[0][0]] != colors[groups[0][1]]: val = n
                else:
                    _, sz = q
                    val = min(n, fen.query(n, sz-1) - fen.query(sz-1, sz-1))
                ans.append(val)
            else:
                _, i, c = q
                if colors[i] != c:
                    colors[i] = c
                    k = groups.bisect_left((i, 0)) % len(groups)
                    lo, hi = remove(k)
                    if lo == i == hi:
                        if colors[(i-1)%n] != colors[i]: lo = remove((k-1) % len(groups))[0]
                        if colors[i] != colors[(i+1)%n] and groups: hi = remove((k-1) % len(groups) if k else 0)[1]
                        add(lo, hi)
                    elif lo == i != hi:
                        add((i+1)%n, hi)
                        if colors[(i-1)%n] != colors[i]: lo = remove((k-1)%len(groups))[0]
                        add(lo, i)
                    elif lo != i == hi:
                        add(lo, (i-1)%n)
                        if colors[i] != colors[(i+1)%n]: hi = remove((k+1)%len(groups) if i else 0)[1]
                        add(i, hi)
                    else:
                        i0 = (i-1)%n
                        i1 = (i+1)%n
                        if dist(lo, hi) == n and colors[lo] != colors[hi]: add(i1, i0)
                        else:
                            add(lo, i0)
                            add(i1, hi)
                        add(i, i)
        return ans


    """3248. Snake in Matrix (Easy)
    There is a snake in an n x n matrix grid and can move in four possible
    directions. Each cell in the grid is identified by the position:
    grid[i][j] = (i * n) + j. The snake starts at cell 0 and follows a sequence
    of commands. You are given an integer n representing the size of the grid
    and an array of strings commands where each command[i] is either "UP",
    "RIGHT", "DOWN", and "LEFT". It's guaranteed that the snake will remain
    within the grid boundaries throughout its movement. Return the position of
    the final cell where the snake ends up after executing commands.

    Example 1:
    Input: n = 2, commands = ["RIGHT","DOWN"]
    Output: 3
    Explanation: 0   1
                 2   3
                 0   1
                 2   3
                 0   1
                 2   3

    Example 2:
    Input: n = 3, commands = ["DOWN","RIGHT","UP"]
    Output: 1
    Explanation: 0   1   2
                 3   4   5
                 6   7   8
                 0   1   2
                 3   4   5
                 6   7   8
                 0   1   2
                 3   4   5
                 6   7   8
                 0   1   2
                 3   4   5
                 6   7   8

    Constraints:
    * 2 <= n <= 10
    * 1 <= commands.length <= 100
    * commands consists only of "UP", "RIGHT", "DOWN", and "LEFT".
    * The input is generated such the snake will not move outside of the
      boundaries."""

    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:
        i = j = 0
        for c in commands:
            if c == "UP": i -= 1
            elif c == "RIGHT": j += 1
            elif c == "DOWN": i += 1
            else: j -= 1
        return i * n + j


    """3249. Count the Number of Good Nodes (Medium)
    There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted
    at node 0. You are given a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. A node is good if all the subtrees rooted at its children have
    the same size. Return the number of good nodes in the given tree. A subtree
    of treeName is a tree consisting of a node in treeName and all of its
    descendants.

    Example 1:
    Input: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
    Output: 7
    Explanation: All of the nodes of the given tree are good.

    Example 2:
    Input: edges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]]
    Output: 6
    Explanation: There are 6 good nodes in the given tree. They are colored in
                 the image above.

    Example 3:
    Input: edges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]]
    Output: 12
    Explanation: All nodes except node 9 are good.

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * The input is generated such that edges represents a valid tree."""

    def countGoodNodes(self, edges: List[List[int]]) -> int:
        n = len(edges)+1
        tree = [[] for _ in range(n)]
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        ans = 0

        def dfs(u, p):
            nonlocal ans
            freq = Counter()
            for v in tree[u]:
                if v != p: freq[dfs(v, u)] += 1
            if len(freq) <= 1: ans += 1
            return 1 + sum(k*v for k, v in freq.items())

        dfs(0, -1)
        return ans


    """3250. Find the Count of Monotonic Pairs I (Hard)
    You are given an array of positive integers nums of length n. We call a pair
    of non-negative integer arrays (arr1, arr2) monotonic if:
    * The lengths of both arrays are n.
    * arr1 is monotonically non-decreasing, in other words,
      arr1[0] <= arr1[1] <= ... <= arr1[n - 1].
    * arr2 is monotonically non-increasing, in other words,
      arr2[0] >= arr2[1] >= ... >= arr2[n - 1].
    * arr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.
    Return the count of monotonic pairs. Since the answer may be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,3,2]
    Output: 4
    Explanation: The good pairs are:
                 ([0, 1, 1], [2, 2, 1])
                 ([0, 1, 2], [2, 2, 0])
                 ([0, 2, 2], [2, 1, 0])
                 ([1, 2, 2], [1, 1, 0])

    Example 2:
    Input: nums = [5,5,5,5]
    Output: 126

    Constraints:
    * 1 <= n == nums.length <= 2000
    * 1 <= nums[i] <= 50"""

    def countOfPairs(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0]*51 for _ in range(n+1)]
        dp[n] = [1]*51
        for i in range(n-1, -1, -1):
            diff = 0
            if i: diff = max(0, nums[i] - nums[i-1])
            for j in range(50, -1, -1):
                if j+1 <= 50: dp[i][j] = dp[i][j+1]
                if j+diff <= nums[i]:
                    dp[i][j] = (dp[i][j] + dp[i+1][j+diff]) % 1_000_000_007
        return dp[0][0]


    """3251. Find the Count of Monotonic Pairs II (Hard)
    You are given an array of positive integers nums of length n. We call a pair
    of non-negative integer arrays (arr1, arr2) monotonic if:
    * The lengths of both arrays are n.
    * arr1 is monotonically non-decreasing, in other words,
      arr1[0] <= arr1[1] <= ... <= arr1[n - 1].
    * arr2 is monotonically non-increasing, in other words,
      arr2[0] >= arr2[1] >= ... >= arr2[n - 1].
    * arr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.
    Return the count of monotonic pairs. Since the answer may be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,3,2]
    Output: 4
    Explanation: The good pairs are:
                 ([0, 1, 1], [2, 2, 1])
                 ([0, 1, 2], [2, 2, 0])
                 ([0, 2, 2], [2, 1, 0])
                 ([1, 2, 2], [1, 1, 0])

    Example 2:
    Input: nums = [5,5,5,5]
    Output: 126

    Constraints:
    * 1 <= n == nums.length <= 2000
    * 1 <= nums[i] <= 1000"""

    def countOfPairs(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0]*1001 for _ in range(n+1)]
        dp[n] = [1]*1001
        for i in range(n-1, -1, -1):
            diff = 0
            if i: diff = max(0, nums[i] - nums[i-1])
            for j in range(1000, -1, -1):
                if j+1 <= 1000: dp[i][j] = dp[i][j+1]
                if j+diff <= nums[i]:
                    dp[i][j] = (dp[i][j] + dp[i+1][j+diff]) % 1_000_000_007
        return dp[0][0]


    """3254. Find the Power of K-Size Subarrays I (Medium)
    You are given an array of integers nums of length n and a positive integer
    k. The power of an array is defined as:
    * Its maximum element if all of its elements are consecutive and sorted in
      ascending order.
    * -1 otherwise.
    You need to find the power of all subarrays of nums of size k. Return an
    integer array results of size n - k + 1, where results[i] is the power of
    nums[i..(i + k - 1)].

    Example 1:
    Input: nums = [1,2,3,4,3,2,5], k = 3
    Output: [3,4,-1,-1,-1]
    Explanation: There are 5 subarrays of nums of size 3:
                 - [1, 2, 3] with the maximum element 3.
                 - [2, 3, 4] with the maximum element 4.
                 - [3, 4, 3] whose elements are not consecutive.
                 - [4, 3, 2] whose elements are not sorted.
                 - [3, 2, 5] whose elements are not consecutive.

    Example 2:
    Input: nums = [2,2,2,2,2], k = 4
    Output: [-1,-1]

    Example 3:
    Input: nums = [3,2,3,2,3,2], k = 2
    Output: [-1,3,-1,3,-1]

    Constraints:
    * 1 <= n == nums.length <= 500
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= n"""

    def resultsArray(self, nums: List[int], k: int) -> List[int]:
        ans = []
        cnt = 0
        for i, x in enumerate(nums):
            if i and nums[i-1]+1 != nums[i]: cnt = 0
            cnt += 1
            if i >= k-1:
                if cnt >= k: ans.append(nums[i])
                else: ans.append(-1)
        return ans


    """3255. Find the Power of K-Size Subarrays II (Medium)
    You are given an array of integers nums of length n and a positive integer
    k. The power of an array is defined as:
    * Its maximum element if all of its elements are consecutive and sorted in
      ascending order.
    * -1 otherwise.
    You need to find the power of all subarrays of nums of size k. Return an
    integer array results of size n - k + 1, where results[i] is the power of
    nums[i..(i + k - 1)].

    Example 1:
    Input: nums = [1,2,3,4,3,2,5], k = 3
    Output: [3,4,-1,-1,-1]
    Explanation: There are 5 subarrays of nums of size 3:
                 - [1, 2, 3] with the maximum element 3.
                 - [2, 3, 4] with the maximum element 4.
                 - [3, 4, 3] whose elements are not consecutive.
                 - [4, 3, 2] whose elements are not sorted.
                 - [3, 2, 5] whose elements are not consecutive.

    Example 2:
    Input: nums = [2,2,2,2,2], k = 4
    Output: [-1,-1]

    Example 3:
    Input: nums = [3,2,3,2,3,2], k = 2
    Output: [-1,3,-1,3,-1]

    Constraints:
    * 1 <= n == nums.length <= 10^5
    * 1 <= nums[i] <= 10^6
    * 1 <= k <= n"""

    def resultsArray(self, nums: List[int], k: int) -> List[int]:
        ans = []
        cnt = 0
        for i, x in enumerate(nums):
            if i and nums[i-1]+1 != nums[i]: cnt = 0
            cnt += 1
            if i >= k-1:
                if cnt >= k: ans.append(nums[i])
                else: ans.append(-1)
        return ans


    """3256. Maximum Value Sum by Placing Three Rooks I (Hard)
    You are given a m x n 2D array board representing a chessboard, where
    board[i][j] represents the value of the cell (i, j). Rooks in the same row
    or column attack each other. You need to place three rooks on the chessboard
    such that the rooks do not attack each other. Return the maximum sum of the
    cell values on which the rooks are placed.

    Example 1:
    Input: board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]
    Output: 4
    Explanation: We can place the rooks in the cells (0, 2), (1, 3), and (2, 1)
                 for a sum of 1 + 1 + 2 = 4.

    Example 2:
    Input: board = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 15
    Explanation: We can place the rooks in the cells (0, 0), (1, 1), and (2, 2)
                 for a sum of 1 + 5 + 9 = 15.

    Example 3:
    Input: board = [[1,1,1],[1,1,1],[1,1,1]]
    Output: 3
    Explanation: We can place the rooks in the cells (0, 2), (1, 1), and (2, 0)
                 for a sum of 1 + 1 + 1 = 3.

    Constraints:
    * 3 <= m == board.length <= 100
    * 3 <= n == board[i].length <= 100
    * -10^9 <= board[i][j] <= 10^9"""

    def maximumValueSum(self, board: List[List[int]]) -> int:
        m, n = len(board), len(board[0])
        cols = [[] for _ in range(n)]
        for i, row in enumerate(board):
            for x, j in nlargest(3, ((x, j) for j, x in enumerate(row))):
                cols[j].append((x, i, j))
        vals = []
        for j in range(n):
            vals.extend(nlargest(3, cols[j]))
        vals = nlargest(9, vals)
        print(vals)
        ans = -inf
        for x, y, z in combinations(vals, 3):
            if len(set([x[1], y[1], z[1]])) == 3 and len(set([x[2], y[2], z[2]])) == 3:
                ans = max(ans, x[0] + y[0] + z[0])
        return ans


    """3257. Maximum Value Sum by Placing Three Rooks II (Hard)
    You are given a m x n 2D array board representing a chessboard, where
    board[i][j] represents the value of the cell (i, j). Rooks in the same row
    or column attack each other. You need to place three rooks on the chessboard
    such that the rooks do not attack each other. Return the maximum sum of the
    cell values on which the rooks are placed.

    Example 1:
    Input: board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]
    Output: 4
    Explanation: We can place the rooks in the cells (0, 2), (1, 3), and (2, 1)
                 for a sum of 1 + 1 + 2 = 4.

    Example 2:
    Input: board = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 15
    Explanation: We can place the rooks in the cells (0, 0), (1, 1), and (2, 2)
                 for a sum of 1 + 5 + 9 = 15.

    Example 3:
    Input: board = [[1,1,1],[1,1,1],[1,1,1]]
    Output: 3
    Explanation: We can place the rooks in the cells (0, 2), (1, 1), and (2, 0)
                 for a sum of 1 + 1 + 1 = 3.

    Constraints:
    * 3 <= m == board.length <= 500
    * 3 <= n == board[i].length <= 500
    * -10^9 <= board[i][j] <= 10^9"""

    def maximumValueSum(self, board: List[List[int]]) -> int:
        m, n = len(board), len(board[0])
        cols = [[] for _ in range(n)]
        for i, row in enumerate(board):
            for x, j in nlargest(3, ((x, j) for j, x in enumerate(row))):
                cols[j].append((x, i, j))
        vals = []
        for j in range(n):
            vals.extend(nlargest(3, cols[j]))
        vals = nlargest(9, vals)
        print(vals)
        ans = -inf
        for x, y, z in combinations(vals, 3):
            if len(set([x[1], y[1], z[1]])) == 3 and len(set([x[2], y[2], z[2]])) == 3:
                ans = max(ans, x[0] + y[0] + z[0])
        return ans


    """3258. Count Substrings That Satisfy K-Constraint I (Easy)
    You are given a binary string s and an integer k. A binary string satisfies
    the k-constraint if either of the following conditions holds:
    * The number of 0's in the string is at most k.
    * The number of 1's in the string is at most k.
    Return an integer denoting the number of substrings of s that satisfy the k-
    constraint.

    Example 1:
    Input: s = "10101", k = 1
    Output: 12
    Explanation: Every substring of s except the substrings "1010", "10101", and
                 "0101" satisfies the k-constraint.

    Example 2:
    Input: s = "1010101", k = 2
    Output: 25
    Explanation: Every substring of s except the substrings with a length
                 greater than 5 satisfies the k-constraint.

    Example 3:
    Input: s = "11111", k = 1
    Output: 15
    Explanation: All substrings of s satisfy the k-constraint.

    Constraints:
    * 1 <= s.length <= 50
    * 1 <= k <= s.length
    * s[i] is either '0' or '1'."""

    def countKConstraintSubstrings(self, s: str, k: int) -> int:
        ans = one = ii = 0
        for i, ch in enumerate(s):
            if ch == '1': one += 1
            while one > k and i-ii-one+1 > k:
                if s[ii] == '1': one -= 1
                ii += 1
            ans += i-ii+1
        return ans


    """3259. Maximum Energy Boost From Two Drinks (Medium)
    You are given two integer arrays energyDrinkA and energyDrinkB of the same
    length n by a futuristic sports scientist. These arrays represent the energy
    boosts per hour provided by two different energy drinks, A and B,
    respectively. You want to maximize your total energy boost by drinking one
    energy drink per hour. However, if you want to switch from consuming one
    energy drink to the other, you need to wait for one hour to cleanse your
    system (meaning you won't get any energy boost in that hour). Return the
    maximum total energy boost you can gain in the next n hours. Note that you
    can start consuming either of the two energy drinks.

    Example 1:
    Input: energyDrinkA = [1,3,1], energyDrinkB = [3,1,1]
    Output: 5
    Explanation: To gain an energy boost of 5, drink only the energy drink A (or
                 only B).

    Example 2:
    Input: energyDrinkA = [4,1,1], energyDrinkB = [1,1,3]
    Output: 7
    Explanation: To gain an energy boost of 7:
                 Drink the energy drink A for the first hour. Switch to the
                 energy drink B and we lose the energy boost of the second hour.
                 Gain the energy boost of the drink B in the third hour.

    Constraints:
    * n == energyDrinkA.length == energyDrinkB.length
    * 3 <= n <= 10^5
    * 1 <= energyDrinkA[i], energyDrinkB[i] <= 10^5"""

    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:
        dp = [0]*2
        for i in range(len(energyDrinkA)):
            dp = [max(dp[0] + energyDrinkA[i], dp[1]), max(dp[0], dp[1] + energyDrinkB[i])]
        return max(dp)


    """3260. Find the Largest Palindrome Divisible by K (Hard)
    You are given two positive integers n and k. An integer x is called k-
    palindromic if:
    * x is a palindrome.
    * x is divisible by k.
    Return the largest integer having n digits (as a string) that is k-
    palindromic. Note that the integer must not have leading zeros.

    Example 1:
    Input: n = 3, k = 5
    Output: "595"
    Explanation: 595 is the largest k-palindromic integer with 3 digits.

    Example 2:
    Input: n = 1, k = 4
    Output: "8"
    Explanation: 4 and 8 are the only k-palindromic integers with 1 digit.

    Example 3:
    Input: n = 5, k = 6
    Output: "89898"

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= k <= 9"""

    def largestPalindrome(self, n: int, k: int) -> str:
        pw = [1]*n
        for i in range(1, n):
            pw[i] = pw[i-1]*10 % k
        dp = [[0]*k for _ in range((n+1)//2)]
        dp[(n-1)//2][0] = 1
        for i in range((n-1)//2, 0, -1):
            if i == n-1-i: coef = pw[i]
            else: coef = pw[i] + pw[n-1-i]
            for j in range(k):
                if dp[i][j]:
                    for d in range(10):
                        jj = (j + coef*d) % k
                        dp[i-1][jj] = 1
        ans = [9]*n
        total = 0
        for i in range((n-1)//2+1):
            if i == n-1-i: coef = pw[i]
            else: coef = pw[i] + pw[n-1-i]
            for d in range(9, -1, -1):
                j = (total - coef*d)%k
                if dp[i][j]:
                    ans[i] = ans[~i] = d
                    total = j
                    break
        return "".join(map(str, ans))


    """3261. Count Substrings That Satisfy K-Constraint II (Hard)
    You are given a binary string s and an integer k. You are also given a 2D
    integer array queries, where queries[i] = [li, ri]. A binary string
    satisfies the k-constraint if either of the following conditions holds:
    * The number of 0's in the string is at most k.
    * The number of 1's in the string is at most k.
    Return an integer array answer, where answer[i] is the number of substrings
    of s[li..ri] that satisfy the k-constraint.

    Example 1:
    Input: s = "0001111", k = 2, queries = [[0,6]]
    Output: [26]
    Explanation: For the query [0, 6], all substrings of s[0..6] = "0001111"
                 satisfy the k-constraint except for the substrings
                 s[0..5] = "000111" and s[0..6] = "0001111".

    Example 2:
    Input: s = "010101", k = 1, queries = [[0,5],[1,4],[2,3]]
    Output: [15,9,3]
    Explanation: The substrings of s with a length greater than 3 do not satisfy
                 the k-constraint.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'.
    * 1 <= k <= s.length
    * 1 <= queries.length <= 10^5
    * queries[i] == [li, ri]
    * 0 <= li <= ri < s.length
    * All queries are distinct."""

    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:
        n = len(s)
        prefix = [0]*(n+1)
        jump = [0]*n
        ii = one = 0
        for i, ch in enumerate(s):
            if ch == '1': one += 1
            while one > k and i-ii-one+1 > k:
                if s[ii] == '1': one -= 1
                ii += 1
            prefix[i+1] = prefix[i] + (i-ii+1)
            jump[ii] = i
        for i, x in enumerate(jump):
            if x == 0: jump[i] = jump[i-1]
        ans = []
        for lo, hi in queries:
            mid = min(hi, jump[lo])
            c = mid-lo+1
            cand = c*(c+1)//2
            if mid < hi: cand += prefix[hi+1] - prefix[mid+1]
            ans.append(cand)
        return ans


    """3264. Final Array State After K Multiplication Operations I (Easy)
    You are given an integer array nums, an integer k, and an integer
    multiplier. You need to perform k operations on nums. In each operation:
    * Find the minimum value x in nums. If there are multiple occurrences of the
      minimum value, select the one that appears first.
    * Replace the selected minimum value x with x * multiplier.
    Return an integer array denoting the final state of nums after performing
    all k operations.

    Example 1:
    Input: nums = [2,1,3,5,6], k = 5, multiplier = 2
    Output: [8,4,6,5,6]
    Explanation: Operation           Result
                 After operation 1   [2, 2, 3, 5, 6]
                 After operation 2   [4, 2, 3, 5, 6]
                 After operation 3   [4, 4, 3, 5, 6]
                 After operation 4   [4, 4, 6, 5, 6]
                 After operation 5   [8, 4, 6, 5, 6]

    Example 2:
    Input: nums = [1,2], k = 3, multiplier = 4
    Output: [16,8]
    Explanation: Operation           Result
                 After operation 1   [4, 2]
                 After operation 2   [4, 8]
                 After operation 3   [16, 8]

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= k <= 10
    * 1 <= multiplier <= 5"""

    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:
        for _ in range(k):
            i = nums.index(min(nums))
            nums[i] *= multiplier
        return nums


    """3265. Count Almost Equal Pairs I (Medium)
    You are given an array nums consisting of positive integers. We call two
    integers x and y in this problem almost equal if both integers can become
    equal after performing the following operation at most once:
    * Choose either x or y and swap any two digits within the chosen number.
    Return the number of indices i and j in nums where i < j such that nums[i]
    and nums[j] are almost equal. Note that it is allowed for an integer to have
    leading zeros after performing an operation.

    Example 1:
    Input: nums = [3,12,30,17,21]
    Output: 2
    Explanation: The almost equal pairs of elements are:
                 - 3 and 30. By swapping 3 and 0 in 30, you get 3.
                 - 12 and 21. By swapping 1 and 2 in 12, you get 21.

    Example 2:
    Input: nums = [1,1,1,1,1]
    Output: 10
    Explanation: Every two elements in the array are almost equal.

    Example 3:
    Input: nums = [123,231]
    Output: 0
    Explanation: We cannot swap any two digits of 123 or 231 to reach the other.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 10^6"""

    def countPairs(self, nums: List[int]) -> int:
        ans = 0
        freq = Counter()
        for x in nums:
            ans += freq[x]
            freq[x] += 1
            s = list(str(x).zfill(6))
            for i, j in combinations(range(6), 2):
                if s[i] != s[j]:
                    s[i], s[j] = s[j], s[i]
                    cand = int("".join(s))
                    ans += freq[cand]
                    s[i], s[j] = s[j], s[i]
        return ans


    """3266. Final Array State After K Multiplication Operations II (Hard)
    You are given an integer array nums, an integer k, and an integer
    multiplier. You need to perform k operations on nums. In each operation:
    * Find the minimum value x in nums. If there are multiple occurrences of the
      minimum value, select the one that appears first.
    * Replace the selected minimum value x with x * multiplier.
    After the k operations, apply modulo 109 + 7 to every value in nums. Return
    an integer array denoting the final state of nums after performing all k
    operations and then applying the modulo.

    Example 1:
    Input: nums = [2,1,3,5,6], k = 5, multiplier = 2
    Output: [8,4,6,5,6]
    Explanation: Operation           Result
                 After operation 1   [2, 2, 3, 5, 6]
                 After operation 2   [4, 2, 3, 5, 6]
                 After operation 3   [4, 4, 3, 5, 6]
                 After operation 4   [4, 4, 6, 5, 6]
                 After operation 5   [8, 4, 6, 5, 6]
                 After applying modulo   [8, 4, 6, 5, 6]

    Example 2:
    Input: nums = [100000,2000], k = 2, multiplier = 1000000
    Output: [999999307,999999993]
    Explanation: Operation               Result
                 After operation 1       [100000, 2000000000]
                 After operation 2       [100000000000, 2000000000]
                 After applying modulo   [999999307, 999999993]

    Constraints:
    * 1 <= nums.length <= 10^4
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9
    * 1 <= multiplier <= 10^6"""

    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:
        if multiplier == 1: return nums
        m = max(nums)
        n = len(nums)
        mod = 1_000_000_007
        pq = [[x, i] for i, x in enumerate(nums)]
        heapify(pq)
        while k and pq[0][0]*multiplier <= m:
            x, i = heappop(pq)
            heappush(pq, [x*multiplier, i])
            k -= 1
        vals = sorted(pq)
        q, k = divmod(k, n)
        for v in vals:
            v[0] = v[0] * pow(multiplier, q, mod) % mod
        for i in range(k):
            vals[i][0] = vals[i][0] * multiplier % mod
        ans = [0]*n
        for x, i in vals: ans[i] = x
        return ans


    """3267. Count Almost Equal Pairs II (Hard)
    Attention: In this version, the number of operations that can be performed,
    has been increased to twice. You are given an array nums consisting of
    positive integers. We call two integers x and y almost equal if both
    integers can become equal after performing the following operation at most
    twice:
    * Choose either x or y and swap any two digits within the chosen number.
    Return the number of indices i and j in nums where i < j such that nums[i]
    and nums[j] are almost equal. Note that it is allowed for an integer to have
    leading zeros after performing an operation.

    Example 1:
    Input: nums = [1023,2310,2130,213]
    Output: 4
    Explanation: The almost equal pairs of elements are:
                 - 1023 and 2310. By swapping the digits 1 and 2, and then the
                   digits 0 and 3 in 1023, you get 2310.
                 - 1023 and 213. By swapping the digits 1 and 0, and then the
                   digits 1 and 2 in 1023, you get 0213, which is 213.
                 - 2310 and 213. By swapping the digits 2 and 0, and then the
                   digits 3 and 2 in 2310, you get 0213, which is 213.
                 - 2310 and 2130. By swapping the digits 3 and 1 in 2310, you
                   get 2130.

    Example 2:
    Input: nums = [1,10,100]
    Output: 3
    Explanation: The almost equal pairs of elements are:
                 - 1 and 10. By swapping the digits 1 and 0 in 10, you get 01
                   which is 1.
                 - 1 and 100. By swapping the second 0 with the digit 1 in 100,
                   you get 001, which is 1.
                 - 10 and 100. By swapping the first 0 with the digit 1 in 100,
                   you get 010, which is 10.

    Constraints:
    * 2 <= nums.length <= 5000
    * 1 <= nums[i] < 10^7"""

    def countPairs(self, nums: List[int]) -> int:
        ans = 0
        freq = Counter(nums)
        for x in freq:
            ans += freq[x]*(freq[x]-1)
            s = list(str(x).zfill(7))
            neighbor = set()
            for i, j in combinations(range(7), 2):
                if s[i] != s[j]:
                    s[i], s[j] = s[j], s[i]
                    cand = int("".join(s))
                    neighbor.add(cand)
                    for k, l in combinations(range(7), 2):
                        if s[k] != s[l] and (i, j) != (k, l):
                            s[k], s[l] = s[l], s[k]
                            cand = int("".join(s))
                            neighbor.add(cand)
                            s[k], s[l] = s[l], s[k]
                    s[i], s[j] = s[j], s[i]
            for v in neighbor:
                if v != x: ans += freq[v]*freq[x]
        return ans//2


    """3270. Find the Key of the Numbers (Easy)
    You are given three positive integers num1, num2, and num3. The key of num1,
    num2, and num3 is defined as a four-digit number such that:
    * Initially, if any number has less than four digits, it is padded with
      leading zeros.
    * The ith digit (1 <= i <= 4) of the key is generated by taking the smallest
      digit among the ith digits of num1, num2, and num3.
    Return the key of the three numbers without leading zeros (if any).

    Example 1:
    Input: num1 = 1, num2 = 10, num3 = 1000
    Output: 0
    Explanation: On padding, num1 becomes "0001", num2 becomes "0010", and num3
                 remains "1000".
                 - The 1st digit of the key is min(0, 0, 1).
                 - The 2nd digit of the key is min(0, 0, 0).
                 - The 3rd digit of the key is min(0, 1, 0).
                 - The 4th digit of the key is min(1, 0, 0).
                 Hence, the key is "0000", i.e. 0.

    Example 2:
    Input: num1 = 987, num2 = 879, num3 = 798
    Output: 777

    Example 3:
    Input: num1 = 1, num2 = 2, num3 = 3
    Output: 1

    Constraints: 1 <= num1, num2, num3 <= 9999"""

    def generateKey(self, num1: int, num2: int, num3: int) -> int:
        vals = [str(x).zfill(4) for x in (num1, num2, num3)]
        return int("".join(map(min, zip(*vals))))


    """3271. Hash Divided String (Medium)
    You are given a string s of length n and an integer k, where n is a multiple
    of k. Your task is to hash the string s into a new string called result,
    which has a length of n / k. First, divide s into n / k substrings, each
    with a length of k. Then, initialize result as an empty string. For each
    substring in order from the beginning:
    * The hash value of a character is the index of that character in the
      English alphabet (e.g., 'a' → 0, 'b' → 1, ..., 'z' → 25).
    * Calculate the sum of all the hash values of the characters in the
      substring.
    * Find the remainder of this sum when divided by 26, which is called
      hashedChar.
    * Identify the character in the English lowercase alphabet that corresponds
      to hashedChar.
    * Append that character to the end of result.
    Return result.

    Example 1:
    Input: s = "abcd", k = 2
    Output: "bf"
    Explanation: First substring: "ab", 0 + 1 = 1, 1 % 26 = 1, result[0] = 'b'.
                 Second substring: "cd", 2 + 3 = 5, 5 % 26 = 5, result[1] = 'f'.

    Example 2:
    Input: s = "mxz", k = 3
    Output: "i"
    Explanation: The only substring: "mxz", 12 + 23 + 25 = 60, 60 % 26 = 8,
                 result[0] = 'i'.

    Constraints:
    * 1 <= k <= 100
    * k <= s.length <= 1000
    * s.length is divisible by k.
    * s consists only of lowercase English letters."""

    def stringHash(self, s: str, k: int) -> str:
        ans = []
        prefix = 0
        for i, ch in enumerate(s):
            prefix += ord(ch)-97
            if (i+1) % k == 0:
                ans.append(chr(97 + prefix%26))
                prefix = 0
        return "".join(ans)


    """3272. Find the Count of Good Integers (Hard)
    You are given two positive integers n and k. An integer x is called k-
    palindromic if:
    * x is a palindrome.
    * x is divisible by k.
    An integer is called good if its digits can be rearranged to form a k-
    palindromic integer. For example, for k = 2, 2020 can be rearranged to form
    the k-palindromic integer 2002, whereas 1010 cannot be rearranged to form a
    k-palindromic integer. Return the count of good integers containing n digits.
    Note that any integer must not have leading zeros, neither before nor after
    rearrangement. For example, 1010 cannot be rearranged to form 101.

    Example 1:
    Input: n = 3, k = 5
    Output: 27
    Explanation: Some of the good integers are:
                 - 551 because it can be rearranged to form 515.
                 - 525 because it is already k-palindromic.

    Example 2:
    Input: n = 1, k = 4
    Output: 2
    Explanation: The two good integers are 4 and 8.

    Example 3:
    Input: n = 5, k = 6
    Output: 2468

    Constraints:
    * 1 <= n <= 10
    * 1 <= k <= 9"""

    def countGoodIntegers(self, n: int, k: int) -> int:
        ans = 0
        half = (n+1)//2
        seen = set()

        def multinom(vals):
            """Return multinomial coefficient."""
            ans = k = 1
            for v in vals:
                for x in range(1, v+1):
                    ans *= k
                    ans //= x
                    k += 1
            return ans

        for x in range(pow(10, half-1), pow(10, half)):
            cand = str(x) + str(x)[::-1][n%2 : ]
            key = "".join(sorted(cand))
            if int(cand) % k == 0 and key not in seen:
                freq = Counter(cand)
                seen.add(key)
                val = multinom(freq.values())
                if freq['0']:
                    freq['0'] -= 1
                    val -= multinom(freq.values())
                ans += val
        return ans


    """3273. Minimum Amount of Damage Dealt to Bob (Hard)
    You are given an integer power and two integer arrays damage and health,
    both having length n. Bob has n enemies, where enemy i will deal Bob
    damage[i] points of damage per second while they are alive (i.e.
    health[i] > 0). Every second, after the enemies deal damage to Bob, he
    chooses one of the enemies that is still alive and deals power points of
    damage to them. Determine the minimum total amount of damage points that
    will be dealt to Bob before all n enemies are dead.

    Example 1:
    Input: power = 4, damage = [1,2,3,4], health = [4,5,6,8]
    Output: 39
    Explanation: - Attack enemy 3 in the first two seconds, after which enemy 3
                   will go down, the number of damage points dealt to Bob is
                   10 + 10 = 20 points.
                 - Attack enemy 2 in the next two seconds, after which enemy 2
                   will go down, the number of damage points dealt to Bob is
                   6 + 6 = 12 points.
                 - Attack enemy 0 in the next second, after which enemy 0 will
                   go down, the number of damage points dealt to Bob is 3 points.
                 - Attack enemy 1 in the next two seconds, after which enemy 1
                   will go down, the number of damage points dealt to Bob is
                   2 + 2 = 4 points.

    Example 2:
    Input: power = 1, damage = [1,1,1,1], health = [1,2,3,4]
    Output: 20
    Explanation: - Attack enemy 0 in the first second, after which enemy 0 will
                   go down, the number of damage points dealt to Bob is 4 points.
                 - Attack enemy 1 in the next two seconds, after which enemy 1
                   will go down, the number of damage points dealt to Bob is
                   3 + 3 = 6 points.
                 - Attack enemy 2 in the next three seconds, after which enemy 2
                   will go down, the number of damage points dealt to Bob is
                   2 + 2 + 2 = 6 points.
                 - Attack enemy 3 in the next four seconds, after which enemy 3
                   will go down, the number of damage points dealt to Bob is
                   1 + 1 + 1 + 1 = 4 points.

    Example 3:
    Input: power = 8, damage = [40], health = [59]
    Output: 320

    Constraints:
    * 1 <= power <= 10^4
    * 1 <= n == damage.length == health.length <= 10^5
    * 1 <= damage[i], health[i] <= 10^4"""

    def minDamage(self, power: int, damage: List[int], health: List[int]) -> int:
        ans = prefix = 0
        for d, h in sorted(zip(damage, (ceil(h/power) for h in health)), key = lambda x: -x[0]/x[1]):
            prefix += h
            ans += d*prefix
        return ans


    """3274. Check if Two Chessboard Squares Have the Same Color (Easy)
    You are given two strings, coordinate1 and coordinate2, representing the
    coordinates of a square on an 8 x 8 chessboard. Below is the chessboard for
    reference. Return true if these two squares have the same color and false
    otherwise. The coordinate will always represent a valid chessboard square.
    The coordinate will always have the letter first (indicating its column),
    and the number second (indicating its row).

    Example 1:
    Input: coordinate1 = "a1", coordinate2 = "c3"
    Output: true
    Explanation: Both squares are black.

    Example 2:
    Input: coordinate1 = "a1", coordinate2 = "h3"
    Output: false
    Explanation: Square "a1" is black and "h3" is white.

    Constraints:
    * coordinate1.length == coordinate2.length == 2
    * 'a' <= coordinate1[0], coordinate2[0] <= 'h'
    * '1' <= coordinate1[1], coordinate2[1] <= '8'"""

    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:
        return sum(map(ord, coordinate1)) % 2 == sum(map(ord, coordinate2)) % 2


    """3275. K-th Nearest Obstacle Queries (Medium)
    There is an infinite 2D plane. You are given a positive integer k. You are
    also given a 2D array queries, which contains the following queries:
    * queries[i] = [x, y]: Build an obstacle at coordinate (x, y) in the plane.
      It is guaranteed that there is no obstacle at this coordinate when this
      query is made.
    After each query, you need to find the distance of the kth nearest obstacle
    from the origin. Return an integer array results where results[i] denotes
    the kth nearest obstacle after query i, or results[i] == -1 if there are
    less than k obstacles. Note that initially there are no obstacles anywhere.
    The distance of an obstacle at coordinate (x, y) from the origin is given by
    |x| + |y|.

    Example 1:
    Input: queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2
    Output: [-1,7,5,3]
    Explanation: Initially, there are 0 obstacles.
                 - After queries[0], there are less than 2 obstacles.
                 - After queries[1], there are obstacles at distances 3 and 7.
                 - After queries[2], there are obstacles at distances 3, 5, and
                   7.
                 - After queries[3], there are obstacles at distances 3, 3, 5,
                   and 7.

    Example 2:
    Input: queries = [[5,5],[4,4],[3,3]], k = 1
    Output: [10,8,6]
    Explanation: - After queries[0], there is an obstacle at distance 10.
                 - After queries[1], there are obstacles at distances 8 and 10.
                 - After queries[2], there are obstacles at distances 6, 8, and
                   10.

    Constraints:
    * 1 <= queries.length <= 2 * 10^5
    * All queries[i] are unique.
    * -10^9 <= queries[i][0], queries[i][1] <= 10^9
    * 1 <= k <= 10^5"""

    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:
        ans = []
        pq = []
        for x, y in queries:
            heappush(pq, -(abs(x) + abs(y)))
            if len(pq) > k: heappop(pq)
            ans.append(-pq[0] if len(pq) == k else -1)
        return ans


    """3276. Select Cells in Grid With Maximum Score (Hard)
    You are given a 2D matrix grid consisting of positive integers. You have to
    select one or more cells from the matrix such that the following conditions
    are satisfied:
    * No two selected cells are in the same row of the matrix.
    * The values in the set of selected cells are unique.
    Your score will be the sum of the values of the selected cells. Return the
    maximum score you can achieve.

    Example 1:
    Input: grid = [[1,2,3],[4,3,2],[1,1,1]]
    Output: 8
    Explanation: We can select the cells with values 1, 3, and 4 that are
                 colored above.

    Example 2:
    Input: grid = [[8,7,6],[8,3,2]]
    Output: 15
    Explanation: We can select the cells with values 7 and 8 that are colored
                 above.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 10
    * 1 <= grid[i][j] <= 100"""

    def maxScore(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        vals = sorted((x, i) for i, row in enumerate(grid) for x in row)
        dp = [[0]*(1<<m) for _ in range(m*n+1)]
        for i in range(m*n-1, -1, -1):
            v, k = vals[i]
            for x in range(1<<m):
                dp[i][x] = dp[i+1][x]
                if not x & 1<<k:
                    ii = i+1
                    while ii < len(vals) and vals[ii][0] == vals[i][0]: ii += 1
                    dp[i][x] = max(dp[i][x], v + dp[ii][x^1<<k])
        return dp[0][0]


    """3277. Maximum XOR Score Subarray Queries (Hard)
    You are given an array nums of n integers, and a 2D integer array queries of
    size q, where queries[i] = [li, ri]. For each query, you must find the
    maximum XOR score of any subarray of nums[li..ri]. The XOR score of an array
    a is found by repeatedly applying the following operations on a so that only
    one element remains, that is the score:
    * Simultaneously replace a[i] with a[i] XOR a[i + 1] for all indices i
      except the last one.
    * Remove the last element of a.
    Return an array answer of size q where answer[i] is the answer to query i.

    Example 1:
    Input: nums = [2,8,4,32,16,1], queries = [[0,2],[1,4],[0,5]]
    Output: [12,60,60]
    Explanation: - In the first query, nums[0..2] has 6 subarrays [2], [8], [4],
                   [2, 8], [8, 4], and [2, 8, 4] each with a respective XOR
                   score of 2, 8, 4, 10, 12, and 6. The answer for the query is
                   12, the largest of all XOR scores.
                 - In the second query, the subarray of nums[1..4] with the
                   largest XOR score is nums[1..4] with a score of 60.
                 - In the third query, the subarray of nums[0..5] with the
                   largest XOR score is nums[1..4] with a score of 60.

    Example 2:
    Input: nums = [0,7,3,2,8,5,1], queries = [[0,3],[1,5],[2,4],[2,6],[5,6]]
    Output: [7,14,11,14,5]
    Explanation: Index   nums[li..ri]    Maximum XOR Score Subarray  Maximum Subarray XOR Score
                     0   [0, 7, 3, 2]    [7]                         7
                     1   [7, 3, 2, 8, 5] [7, 3, 2, 8]                14
                     2   [3, 2, 8]       [3, 2, 8]                   11
                     3   [3, 2, 8, 5, 1] [2, 8, 5, 1]                14
                     4   [5, 1]          [5]                         5

    Constraints:
    * 1 <= n == nums.length <= 2000
    * 0 <= nums[i] <= 2^31 - 1
    * 1 <= q == queries.length <= 10^5
    * queries[i].length == 2
    * queries[i] = [li, ri]
    * 0 <= li <= ri <= n - 1"""

    def maximumSubarrayXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n = len(nums)
        dp = [[0]*n for _ in range(n+1)]
        for l in range(n-1, -1, -1):
            dp[l][l] = nums[l]
            for r in range(l+1, n):
                dp[l][r] = dp[l][r-1] ^ dp[l+1][r]
        for l in range(n):
            for r in range(l+1, n):
                dp[l][r] = max(dp[l][r], dp[l][r-1])
        for r in range(n):
            for l in range(r-1, -1, -1):
                dp[l][r] = max(dp[l][r], dp[l+1][r])
        return [dp[l][r] for l, r in queries]


    """3280. Convert Date to Binary (Easy)
    You are given a string date representing a Gregorian calendar date in the
    yyyy-mm-dd format. date can be written in its binary representation obtained
    by converting year, month, and day to their binary representations without
    any leading zeroes and writing them down in year-month-day format. Return
    the binary representation of date.

    Example 1:
    Input: date = "2080-02-29"
    Output: "100000100000-10-11101"
    Explanation: 100000100000, 10, and 11101 are the binary representations of
                 2080, 02, and 29 respectively.

    Example 2:
    Input: date = "1900-01-01"
    Output: "11101101100-1-1"
    Explanation: 11101101100, 1, and 1 are the binary representations of 1900,
                 1, and 1 respectively.

    Constraints:
    * date.length == 10
    * date[4] == date[7] == '-', and all other date[i]'s are digits.
    * The input is generated such that date represents a valid Gregorian
      calendar date between Jan 1st, 1900 and Dec 31st, 2100 (both inclusive)."""

    def convertDateToBinary(self, date: str) -> str:
        return "-".join(map(lambda x: bin(int(x))[2:], date.split("-")))


    """3281. Maximize Score of Numbers in Ranges (Medium)
    You are given an array of integers start and an integer d, representing n
    intervals [start[i], start[i] + d]. You are asked to choose n integers where
    the ith integer must belong to the ith interval. The score of the chosen
    integers is defined as the minimum absolute difference between any two
    integers that have been chosen. Return the maximum possible score of the
    chosen integers.

    Example 1:
    Input: start = [6,0,3], d = 2
    Output: 4
    Explanation: The maximum possible score can be obtained by choosing
                 integers: 8, 0, and 4. The score of these chosen integers is
                 min(|8 - 0|, |8 - 4|, |0 - 4|) which equals 4.

    Example 2:
    Input: start = [2,6,13,13], d = 5
    Output: 5
    Explanation: The maximum possible score can be obtained by choosing
                 integers: 2, 7, 13, and 18. The score of these chosen integers
                 is min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|)
                 which equals 5.

    Constraints:
    * 2 <= start.length <= 10^5
    * 0 <= start[i] <= 10^9
    * 0 <= d <= 10^9"""

    def maxPossibleScore(self, start: List[int], d: int) -> int:
        start.sort()

        def fn(mid):
            x = -inf
            for s in start:
                x += mid
                if x > s+d: return False
                x = max(x, s)
            return True

        lo, hi = 0, 2_000_000_000
        while lo < hi:
            mid = lo + hi + 1 >> 1
            if fn(mid): lo = mid
            else: hi = mid-1
        return lo


    """3282. Reach End of Array With Max Score (Medium)
    You are given an integer array nums of length n. Your goal is to start at
    index 0 and reach index n - 1. You can only jump to indices greater than
    your current index. The score for a jump from index i to index j is
    calculated as (j - i) * nums[i]. Return the maximum possible total score by
    the time you reach the last index.

    Example 1:
    Input: nums = [1,3,1,5]
    Output: 7
    Explanation: First, jump to index 1 and then jump to the last index. The
                 final score is 1 * 1 + 2 * 3 = 7.

    Example 2:
    Input: nums = [4,3,1,3,2]
    Output: 16
    Explanation: Jump directly to the last index. The final score is 4 * 4 = 16.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5"""

    def findMaximumScore(self, nums: List[int]) -> int:
        dp = prefix = 0
        for x in nums:
            dp += prefix
            prefix = max(prefix, x)
        return dp


    """3283. Maximum Number of Moves to Kill All Pawns (Hard)
    There is a 50 x 50 chessboard with one knight and some pawns on it. You are
    given two integers kx and ky where (kx, ky) denotes the position of the
    knight, and a 2D array positions where positions[i] = [xi, yi] denotes the
    position of the pawns on the chessboard. Alice and Bob play a turn-based
    game, where Alice goes first. In each player's turn:
    * The player selects a pawn that still exists on the board and captures it
      with the knight in the fewest possible moves. Note that the player can
      select any pawn, it might not be one that can be captured in the least
      number of moves.
    * In the process of capturing the selected pawn, the knight may pass other
      pawns without capturing them. Only the selected pawn can be captured in
      this turn.
    Alice is trying to maximize the sum of the number of moves made by both
    players until there are no more pawns on the board, whereas Bob tries to
    minimize them. Return the maximum total number of moves made during the game
    that Alice can achieve, assuming both players play optimally. Note that in
    one move, a chess knight has eight possible positions it can move to, as
    illustrated below. Each move is two cells in a cardinal direction, then one
    cell in an orthogonal direction.

    Example 1:
    Input: kx = 1, ky = 1, positions = [[0,0]]
    Output: 4
    Explanation: The knight takes 4 moves to reach the pawn at (0, 0).

    Example 2:
    Input: kx = 0, ky = 2, positions = [[1,1],[2,2],[3,3]]
    Output: 8
    Explanation: - Alice picks the pawn at (2, 2) and captures it in two moves:
                   (0, 2) -> (1, 4) -> (2, 2).
                 - Bob picks the pawn at (3, 3) and captures it in two moves:
                   (2, 2) -> (4, 1) -> (3, 3).
                 - Alice picks the pawn at (1, 1) and captures it in four moves:
                   (3, 3) -> (4, 1) -> (2, 2) -> (0, 3) -> (1, 1).

    Example 3:
    Input: kx = 0, ky = 0, positions = [[1,2],[2,4]]
    Output: 3
    Explanation: - Alice picks the pawn at (2, 4) and captures it in two moves:
                   (0, 0) -> (1, 2) -> (2, 4). Note that the pawn at (1, 2) is
                   not captured.
                 - Bob picks the pawn at (1, 2) and captures it in one move:
                   (2, 4) -> (1, 2).

    Constraints:
    * 0 <= kx, ky <= 49
    * 1 <= positions.length <= 15
    * positions[i].length == 2
    * 0 <= positions[i][0], positions[i][1] <= 49
    * All positions[i] are unique.
    * The input is generated such that positions[i] != [kx, ky] for all
    0 <= i < positions.length."""

    def maxMoves(self, kx: int, ky: int, positions: List[List[int]]) -> int:
        n = len(positions)
        dist = [[0]*(n+1) for _ in range(n+1)]
        positions.append([kx, ky])

        def bfs(i, j):
            queue = deque([positions[i]])
            seen = set(tuple(positions[i]))
            step = 0
            while queue:
                for _ in range(len(queue)):
                    x, y = queue.popleft()
                    if [x, y] == positions[j]: return step
                    for xx, yy in (x-2, y-1), (x-2, y+1), (x-1, y-2), (x-1, y+2), (x+1, y-2), (x+1, y+2), (x+2, y-1), (x+2, y+1):
                        if 0 <= xx < 50 and 0 <= yy < 50 and (xx, yy) not in seen:
                            queue.append([xx, yy])
                            seen.add((xx, yy))
                step += 1

        for i in range(n):
            for j in range(i+1, n+1):
                dist[i][j] = dist[j][i] = bfs(i, j)

        dp = [[[0]*2 for _ in range(n+1)] for _ in range(1<<n)]
        for m in range((1<<n)-2, -1, -1):
            for i in range(n+1):
                if m & 1<<i or i == n:
                    dp[m][i] = [0, inf]
                    for j in range(n):
                        if not m & 1<<j:
                            mm = m ^ 1<<j
                            dp[m][i][0] = max(dp[m][i][0], dist[i][j] + dp[mm][j][1])
                            dp[m][i][1] = min(dp[m][i][1], dist[i][j] + dp[mm][j][0])
        return dp[0][n][0]


"""146. LRU Cache (Medium)
Design and implement a data structure for Least Recently Used (LRU) cache. It
should support the following operations: get and put.
get(key)        - Get the value (will always be positive) of the key if the key
                  exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present.

When the cache reached its capacity, it should invalidate the least recently
used item before inserting a new item. The cache is initialized with a positive
capacity.

Follow up: Could you do both operations in O(1) time complexity?

Example:
LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4"""

class ListNode:
    def __init__(self, key=0, val=0, prev=None, next=None):
        self.key = key
        self.val = val
        self.prev = prev
        self.next = next


class LRUCache:

    def __init__(self, capacity: int):
        """Initialize hash table & dll"""
        self.cpty = capacity
        self.htab = dict() #hash table
        self.head = ListNode() #doubly linked list
        self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head

    def _del(self, key: int) -> int:
        """Delete given key from hash table & dll"""
        node = self.htab.pop(key)
        node.prev.next = node.next
        node.next.prev = node.prev
        return node.val

    def _ins(self, key: int, value: int) -> None:
        """Insert at tail"""
        node = ListNode(key, value, self.tail.prev, self.tail)
        self.tail.prev.next = self.tail.prev = node
        self.htab[key] = node

    def get(self, key: int) -> int:
        if key not in self.htab: return -1
        value = self._del(key)
        self._ins(key, value)
        return value

    def put(self, key: int, value: int) -> None:
        if key in self.htab: self._del(key)
        self._ins(key, value)
        if len(self.htab) > self.cpty:
            self._del(self.head.next.key)


"""155. Min Stack (Easy)
Design a stack that supports push, pop, top, and retrieving the minimum element
in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.

Example 1:
Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2

Constraints:
Methods pop, top and getMin operations will always be called on non-empty stacks."""

class MinStack:

    def __init__(self):
        self.stack = []

    def push(self, val: int) -> None:
        if self.stack: self.stack.append((val, min(val, self.stack[-1][1])))
        else: self.stack.append((val, val))

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1]


"""170. Two Sum III - Data structure design (Easy)
Design a data structure that accepts a stream of integers and checks if it has
a pair of integers that sum up to a particular value.

Implement the TwoSum class:
* TwoSum() Initializes the TwoSum object, with an empty array initially.
* void add(int number) Adds number to the data structure.
* boolean find(int value) Returns true if there exists any pair of numbers whose sum is equal to value, otherwise, it returns false.

Example 1:
Input: ["TwoSum", "add", "add", "add", "find", "find"]
       [[], [1], [3], [5], [4], [7]]
Output: [null, null, null, null, true, false]
Explanation:
TwoSum twoSum = new TwoSum();
twoSum.add(1);   // [] --> [1]
twoSum.add(3);   // [1] --> [1,3]
twoSum.add(5);   // [1,3] --> [1,3,5]
twoSum.find(4);  // 1 + 3 = 4, return true
twoSum.find(7);  // No two integers sum up to 7, return false

Constraints:
* -10^5 <= number <= 10^5
* -2^31 <= value <= 2^31 - 1
* At most 5 * 10^4 calls will be made to add and find."""

class TwoSum:

    def __init__(self):
        self.freq = Counter()

    def add(self, number: int) -> None:
        self.freq[number] += 1

    def find(self, value: int) -> bool:
        for k in self.freq:
            if value-k in self.freq and (k != value-k or self.freq[k] > 1): return True
        return False


"""173. Binary Search Tree Iterator (Medium)
Implement an iterator over a binary search tree (BST). Your iterator will be
initialized with the root node of a BST. Calling next() will return the next
smallest number in the BST.

Example:

BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false

Note:
next() and hasNext() should run in average O(1) time and uses O(h) memory,
where h is the height of the tree. You may assume that next() call will always
be valid, that is, there will be at least a next smallest number in the BST
when next() is called."""

class BSTIterator:

    def __init__(self, root: TreeNode):
        self.stack = []
        self.node = root

    def next(self) -> int:
        while self.node:
            self.stack.append(self.node)
            self.node = self.node.left
        self.node = node = self.stack.pop()
        self.node = self.node.right
        return node.val

    def hasNext(self) -> bool:
        return self.stack or self.node


"""208. Implement Trie (Prefix Tree) (Medium)
Implement a trie with insert, search, and startsWith methods.

Example:
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // returns true
trie.search("app");     // returns false
trie.startsWith("app"); // returns true
trie.insert("app");
trie.search("app");     // returns true

Note:
You may assume that all inputs are consist of lowercase letters a-z.
All inputs are guaranteed to be non-empty strings."""

class Trie:

    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        node = self.root
        for ch in word: node = node.setdefault(ch, {})
        node["$"] = word

    def search(self, word: str) -> bool:
        node = self.root
        for ch in word:
            if ch not in node: return False
            node = node[ch]
        return node.get("$")

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for ch in prefix:
            if ch not in node: return False
            node = node[ch]
        return True


"""211. Add and Search Word - Data structure design (Medium)
Design a data structure that supports the following two operations:
void addWord(word)
bool search(word)

search(word) can search a literal word or a regular expression string
containing only letters a-z or .. A . means it can represent any one letter.

Example:
addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true

Note: You may assume that all words are consist of lowercase letters a-z."""

class WordDictionary:

    def __init__(self):
        self.trie = {}

    def addWord(self, word: str) -> None:
        node = self.trie
        for ch in word: node = node.setdefault(ch, {})
        node['$'] = word

    def search(self, word: str) -> bool:

        def fn(node, i):
            if not node: return False
            if i == len(word): return node.get('$')
            if word[i] == '.': return any(fn(node[k], i+1) for k in node if k != '$')
            return fn(node.get(word[i]), i+1)

        return fn(self.trie, 0)


"""225. Implement Stack using Queues (Easy)
Implement the following operations of a stack using queues.

push(x) -- Push element x onto stack.
pop()   -- Removes the element on top of the stack.
top()   -- Get the top element.
empty() -- Return whether the stack is empty.

Example:
MyStack stack = new MyStack();

stack.push(1);
stack.push(2);
stack.top();   // returns 2
stack.pop();   // returns 2
stack.empty(); // returns false

Notes:
You must use only standard operations of a queue -- which means only push to
back, peek/pop from front, size, and is empty operations are valid. Depending
on your language, queue may not be supported natively. You may simulate a queue
by using a list or deque (double-ended queue), as long as you use only standard
operations of a queue. You may assume that all operations are valid (for
example, no pop or top operations will be called on an empty stack)."""

class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = deque()

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.queue.append(x)
        for _ in range(len(self.queue)-1):
            self.queue.append(self.queue.popleft())

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue.popleft()

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue[0]

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue


"""232. Implement Queue using Stacks (Easy)
Implement the following operations of a queue using stacks.
push(x) -- Push element x to the back of queue.
pop()   -- Removes the element from in front of queue.
peek()  -- Get the front element.
empty() -- Return whether the queue is empty.

Example:
MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek();  // returns 1
queue.pop();   // returns 1
queue.empty(); // returns false

Notes:
You must use only standard operations of a stack -- which means only push to
top, peek/pop from top, size, and is empty operations are valid. Depending on
your language, stack may not be supported natively. You may simulate a stack by
using a list or deque (double-ended queue), as long as you use only standard
operations of a stack. You may assume that all operations are valid (for
example, no pop or peek operations will be called on an empty queue)."""

class MyQueue:

    def __init__(self):
        self.in_ = []
        self.out = []

    def push(self, x: int) -> None:
        self.in_.append(x)

    def pop(self) -> int:
        self.peek()
        return self.out.pop()

    def peek(self) -> int:
        if not self.out:
            while self.in_: self.out.append(self.in_.pop())
        return self.out[-1]

    def empty(self) -> bool:
        return not self.in_ and not self.out


"""244. Shortest Word Distance II (Medium)
Design a class which receives a list of words in the constructor, and implements
a method that takes two words word1 and word2 and return the shortest distance
between these two words in the list. Your method will be called repeatedly many
times with different parameters.

Example:
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Input: word1 = “coding”, word2 = “practice”
Output: 3
Input: word1 = "makes", word2 = "coding"
Output: 1
Note: You may assume that word1 does not equal to word2, and word1 and word2
      are both in the list."""

class WordDistance:

    def __init__(self, words: List[str]):
        self.loc = {}
        for i, w in enumerate(words):
            self.loc.setdefault(w, []).append(i)

    def shortest(self, word1: str, word2: str) -> int:
        ans = inf
        loc1, loc2 = self.loc[word1], self.loc[word2]
        i1 = i2 = 0
        while i1 < len(loc1) and i2 < len(loc2):
            ans = min(ans, abs(loc1[i1] - loc2[i2]))
            if loc1[i1] < loc2[i2]: i1 += 1
            else: i2 += 1
        return ans


"""251. Flatten 2D Vector (Medium)
Design and implement an iterator to flatten a 2d vector. It should support the
following operations: next and hasNext.

Example:
Vector2D iterator = new Vector2D([[1,2],[3],[4]]);

iterator.next(); // return 1
iterator.next(); // return 2
iterator.next(); // return 3
iterator.hasNext(); // return true
iterator.hasNext(); // return true
iterator.next(); // return 4
iterator.hasNext(); // return false

Notes: Please remember to RESET your class variables declared in Vector2D, as
       static/class variables are persisted across multiple test cases. Please
       see here for more details. You may assume that next() call will always
       be valid, that is, there will be at least a next element in the 2d vector
       when next() is called.

Follow up: As an added challenge, try to code it using only iterators in C++ or
           iterators in Java."""

class Vector2D:

    def __init__(self, v: List[List[int]]):

        def fn(arr):
            """Return flattened array."""
            ans = []
            for x in arr:
                if isinstance(x, int): ans.append(x)
                else: ans.extend(fn(x))
            return ans

        self.vals = fn(v)
        self.i = 0

    def next(self) -> int:
        i, self.i = self.i, self.i+1
        return self.vals[i]

    def hasNext(self) -> bool:
        return self.i < len(self.vals)


"""271. Encode and Decode Strings (Medium)
Design an algorithm to encode a list of strings to a string. The encoded string
is then sent over the network and is decoded back to the original list of strings.

Machine 1 (sender) has the function:

string encode(vector<string> strs) {
  // ... your code
  return encoded_string;
}
Machine 2 (receiver) has the function:
vector<string> decode(string s) {
  //... your code
  return strs;
}
So Machine 1 does:

string encoded_string = encode(strs);
and Machine 2 does:

vector<string> strs2 = decode(encoded_string);
strs2 in Machine 2 should be the same as strs in Machine 1. Implement the encode
and decode methods.

Note:
* The string may contain any possible characters out of 256 valid ascii
  characters. Your algorithm should be generalized enough to work on any
  possible characters.
* Do not use class member/global/static variables to store states. Your encode
  and decode algorithms should be stateless.
* Do not rely on any library method such as eval or serialize methods. You
  should implement your own encode/decode algorithm."""

class Codec:
    def encode(self, strs: [str]) -> str:
        return "".join(f"{len(ss)}|{ss}" for ss in strs)

    def decode(self, s: str) -> [str]:
        ans = []
        i = 0
        while i < len(s):
            ii = s.find("|", i)
            i = ii+1+int(s[i:ii])
            ans.append(s[ii+1:i])
        return ans


"""297. Serialize and Deserialize Binary Tree (Hard)
Serialization is the process of converting a data structure or object into a
sequence of bits so that it can be stored in a file or memory buffer, or
transmitted across a network connection link to be reconstructed later in the
same or another computer environment. Design an algorithm to serialize and
deserialize a binary tree. There is no restriction on how your
serialization/deserialization algorithm should work. You just need to ensure
that a binary tree can be serialized to a string and this string can be
deserialized to the original tree structure. Clarification: The input/output
format is the same as how LeetCode serializes a binary tree. You do not
necessarily need to follow this format, so please be creative and come up with
different approaches yourself.

Example 1:
Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]

Example 2:
Input: root = []
Output: []

Example 3:
Input: root = [1]
Output: [1]

Example 4:
Input: root = [1,2]
Output: [1,2]

Constraints:
* The number of nodes in the tree is in the range [0, 10^4].
* -1000 <= Node.val <= 1000"""

class Codec:

    def serialize(self, root):
        ans = []
        queue = [root]
        for node in queue:
            if node: ans.append(node.val)
            else: ans.append('$')
            if node:
                queue.append(node.left)
                queue.append(node.right)
        return ",".join(map(str, ans))

    def deserialize(self, data):
        root = parent = None
        queue = deque()
        for x in data.split(','):
            if x == '$': node = None
            else: node = TreeNode(int(x))
            if not root: root = node
            elif parent:
                parent.right = node
                parent = None
            else:
                parent = queue.popleft()
                parent.left = node
            if node: queue.append(node)
        return root


"""281. Zigzag Iterator (Medium)
Given two 1d vectors, implement an iterator to return their elements alternately.

Example:
Input:
v1 = [1,2]
v2 = [3,4,5,6]
Output: [1,3,2,4,5,6]
Explanation: By calling next repeatedly until hasNext returns false, the order
             of elements returned by next should be: [1,3,2,4,5,6].

Follow up: What if you are given k 1d vectors? How well can your code be
           extended to such cases?

Clarification for the follow up question: The "Zigzag" order is not clearly
defined and is ambiguous for k > 2 cases. If "Zigzag" does not look right to
you, replace "Zigzag" with "Cyclic". For example:

Input:
[1,2,3]
[4,5,6,7]
[8,9]
Output: [1,4,8,2,5,9,3,6,7]."""

class ZigzagIterator:
    def __init__(self, v1: List[int], v2: List[int]):
        self.vals = deque()
        if v1: self.vals.append(deque(v1))
        if v2: self.vals.append(deque(v2))

    def next(self) -> int:
        v = self.vals.popleft()
        ans = v.popleft()
        if v: self.vals.append(v)
        return ans

    def hasNext(self) -> bool:
        return self.vals


"""284. Peeking Iterator (Medium)
Given an Iterator class interface with methods: next() and hasNext(), design
and implement a PeekingIterator that support the peek() operation -- it
essentially peek() at the element that will be returned by the next call to
next().

Example:
Assume that the iterator is initialized to the beginning of the list: [1,2,3].
Call next() gets you 1, the first element in the list.
Now you call peek() and it returns 2, the next element. Calling next() after
that still return 2.
You call next() the final time and it returns 3, the last element.
Calling hasNext() after that should return false.

Follow up: How would you extend your design to be generic and work with all
           types, not just integer?"""

class PeekingIterator:
    def __init__(self, iterator):
        self.iter = iterator
        self._fill() #fill the buffer

    def _fill(self):
        if self.iter.hasNext(): self.buff = self.iter.next()
        else: self.buff = None

    def peek(self):
        return self.buff

    def next(self):
        tmp = self.buff
        self._fill()
        return tmp

    def hasNext(self):
        return self.buff is not None


"""288. Unique Word Abbreviation (Medium)
The abbreviation of a word is a concatenation of its first letter, the number
of characters between the first and last letter, and its last letter. If a word
has only two characters, then it is an abbreviation of itself.

For example:
* dog --> d1g because there is one letter between the first letter 'd' and the
  last letter 'g'.
* internationalization --> i18n because there are 18 letters between the first
  letter 'i' and the last letter 'n'.
* it --> it because any word with only two characters is an abbreviation of
  itself.

Implement the ValidWordAbbr class:
* ValidWordAbbr(String[] dictionary) Initializes the object with a dictionary
  of words.
* boolean isUnique(string word) Returns true if either of the following
  conditions are met (otherwise returns false):
  + There is no word in dictionary whose abbreviation is equal to word's
    abbreviation.
  + For any word in dictionary whose abbreviation is equal to word's
    abbreviation, that word and word are the same.

Example 1:
Input: ["ValidWordAbbr", "isUnique", "isUnique", "isUnique", "isUnique"]
       [[["deer", "door", "cake", "card"]], ["dear"], ["cart"], ["cane"], ["make"]]
Output: [null, false, true, false, true]

Explanation:
ValidWordAbbr validWordAbbr = new ValidWordAbbr(["deer", "door", "cake", "card"]);
validWordAbbr.isUnique("dear"); // return false, dictionary word "deer" and word "dear" have the same abbreviation
                                // "d2r" but are not the same.
validWordAbbr.isUnique("cart"); // return true, no words in the dictionary have the abbreviation "c2t".
validWordAbbr.isUnique("cane"); // return false, dictionary word "cake" and word "cane" have the same abbreviation
                                // "c2e" but are not the same.
validWordAbbr.isUnique("make"); // return true, no words in the dictionary have the abbreviation "m2e".
validWordAbbr.isUnique("cake"); // return true, because "cake" is already in the dictionary and no other word in the dictionary has "c2e" abbreviation.

Constraints:
* 1 <= dictionary.length <= 3 * 10^4
* 1 <= dictionary[i].length <= 20
* dictionary[i] consists of lowercase English letters.
* 1 <= word.length <= 20
* word consists of lowercase English letters.
* At most 5000 calls will be made to isUnique."""

class ValidWordAbbr:

    def __init__(self, dictionary: List[str]):
        self.mp = {}
        for word in set(dictionary):
            key = word[0] + str(len(word)) + word[-1]
            self.mp.setdefault(key, set()).add(word)

    def isUnique(self, word: str) -> bool:
        key = word[0] + str(len(word)) + word[-1]
        return self.mp.get(key, set()) <= {word}


"""295. Find Median from Data Stream (Hard)
Median is the middle value in an ordered integer list. If the size of the list
is even, there is no middle value. So the median is the mean of the two middle
value.

For example, [2,3,4], the median is 3; [2,3], the median is (2 + 3) / 2 = 2.5

Design a data structure that supports the following two operations:
* void addNum(int num) - Add a integer number from the data stream to the data
  structure.
* double findMedian() - Return the median of all elements so far.

Example:
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3)
findMedian() -> 2

Follow up:
* If all integer numbers from the stream are between 0 and 100, how would you
  optimize it?
* If 99% of all integer numbers from the stream are between 0 and 100, how
  would you optimize it?"""

class MedianFinder:

    def __init__(self):
        self.small = [] # min-heap
        self.large = [] # max-heap

    def addNum(self, num: int) -> None:
        if not self.small or num >= self.small[0]: heappush(self.small, num)
        else: heappush(self.large, -num)
        if len(self.small) > 1 + len(self.large): heappush(self.large, -heappop(self.small))
        elif len(self.small) < len(self.large): heappush(self.small, -heappop(self.large))

    def findMedian(self) -> float:
        if len(self.small) > len(self.large): return self.small[0]
        return (self.small[0] - self.large[0])/2


"""303. Range Sum Query - Immutable (Easy)
Given an integer array nums, handle multiple queries of the following type:
* Calculate the sum of the elements of nums between indices left and right
  inclusive where left <= right.
Implement the NumArray class:
* NumArray(int[] nums) Initializes the object with the integer array nums.
* int sumRange(int left, int right) Returns the sum of the elements of nums
  between indices left and right inclusive (i.e.
  nums[left] + nums[left + 1] + ... + nums[right]).

Example 1:
Input: ["NumArray", "sumRange", "sumRange", "sumRange"]
       [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
Output: [null, 1, -1, -3]
Explanation:
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1
numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1
numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3

Constraints:
* 1 <= nums.length <= 10^4
* -10^5 <= nums[i] <= 10^5
* 0 <= left <= right < nums.length
* At most 10^4 calls will be made to sumRange."""

class NumArray:

    def __init__(self, nums: List[int]):
        self.prefix = [0]
        for x in nums: self.prefix.append(self.prefix[-1] + x)

    def sumRange(self, i: int, j: int) -> int:
        return self.prefix[j+1] - self.prefix[i]


"""304. Range Sum Query 2D - Immutable (Medium)
Given a 2D matrix matrix, find the sum of the elements inside the rectangle
defined by its upper left corner (row1, col1) and lower right corner (row2,
col2).

Example:
Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12

Note:
You may assume that the matrix does not change.
There are many calls to sumRegion function.
You may assume that row1 ≤ row2 and col1 ≤ col2."""

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        if not matrix: return
        m, n = len(matrix), len(matrix[0])
        self.prefix = [[0]*(n+1) for _ in range(m+1)]
        for i in range(m):
            for j in range(n):
                self.prefix[i+1][j+1] = matrix[i][j] + self.prefix[i][j+1] + self.prefix[i+1][j] - self.prefix[i][j]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.prefix[row2+1][col2+1] - self.prefix[row1][col2+1] - self.prefix[row2+1][col1] + self.prefix[row1][col1]


"""308. Range Sum Query 2D - Mutable (Hard)
Given a 2D matrix matrix, handle multiple queries of the following types:
* Update the value of a cell in matrix.
* Calculate the sum of the elements of matrix inside the rectangle defined by
  its upper left corner (row1, col1) and lower right corner (row2, col2).
Implement the NumMatrix class:
* NumMatrix(int[][] matrix) Initializes the object with the integer matrix
  matrix.
* void update(int row, int col, int val) Updates the value of matrix[row][col]
  to be val.
* int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the
  elements of matrix inside the rectangle defined by its upper left corner
  (row1, col1) and lower right corner (row2, col2).

Example 1:
Input: ["NumMatrix", "sumRegion", "update", "sumRegion"]
       [[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [3, 2, 2], [2, 1, 4, 3]]
Output: [null, 8, null, 10]
Explanation:
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e. sum of the left red rectangle)
numMatrix.update(3, 2, 2);       // matrix changes from left image to right image
numMatrix.sumRegion(2, 1, 4, 3); // return 10 (i.e. sum of the right red rectangle)

Constraints:
* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 200
* -1000 <= matrix[i][j] <= 1000
* 0 <= row < m
* 0 <= col < n
* -1000 <= val <= 1000
* 0 <= row1 <= row2 < m
* 0 <= col1 <= col2 < n
* At most 5000 calls will be made to sumRegion and update."""

class Fenwick2D:
    def __init__(self, m: int, n: int):
        self.m = m
        self.n = n
        self.nums = [[0]*(n+1) for _ in range(m+1)]

    def query(self, i: int, j: int) -> int:
        """Return 2d prefix sum nums[:i+1][:j+1]."""
        ans = 0
        i += 1
        jj = j+1
        while i:
            j = jj
            while j:
                ans += self.nums[i][j]
                j -= j & -j
            i -= i & -i
        return ans

    def add(self, i: int, j: int, delta: int) -> None:
        """Add delta to the element on ith row and jth column."""
        i += 1
        jj = j+1
        while i <= self.m:
            j = jj
            while j <= self.n:
                self.nums[i][j] += delta
                j += j & -j
            i += i & -i


class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.m = m = len(matrix)
        self.n = n = len(matrix[0])
        self.vals = [[0]*n for _ in range(m)]
        self.tree = Fenwick2D(m, n)
        for i in range(m):
            for j in range(n):
                self.update(i, j, matrix[i][j])

    def update(self, row: int, col: int, val: int) -> None:
        delta = val - self.vals[row][col]
        self.vals[row][col] = val
        self.tree.add(row, col, delta)

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.tree.query(row2, col2) - self.tree.query(row1-1, col2) - self.tree.query(row2, col1-1) + self.tree.query(row1-1, col1-1)


"""341. Flatten Nested List Iterator (Medium)
Given a nested list of integers, implement an iterator to flatten it. Each
element is either an integer, or a list -- whose elements may also be integers
or other lists.

Example 1:
Input: [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false,
             the order of elements returned by next should be: [1,1,2,1,1].

Example 2:
Input: [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false,
the order of elements returned by next should be: [1,4,6]."""

class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.stack = [(nestedList, 0)]
        self.val = self.read()

    def next(self) -> int:
        ans = self.val
        self.val = self.read()
        return ans

    def hasNext(self) -> bool:
        return self.val is not None

    def read(self):
        while self.stack:
            data, i = self.stack.pop()
            if i+1 < len(data): self.stack.append((data, i+1))
            if data[i].isInteger(): return data[i].getInteger()
            elif data[i].getList():
                self.stack.append((data[i].getList(), 0))
        return None


"""346. Moving Average from Data Stream (Easy)
Given a stream of integers and a window size, calculate the moving average of
all integers in the sliding window.

Implement the MovingAverage class:
* MovingAverage(int size) Initializes the object with the size of the window size.
* double next(int val) Returns the moving average of the last size values of the stream.

Example 1:
Input: ["MovingAverage", "next", "next", "next", "next"]
       [[3], [1], [10], [3], [5]]
Output: [null, 1.0, 5.5, 4.66667, 6.0]
Explanation:
MovingAverage movingAverage = new MovingAverage(3);
movingAverage.next(1); // return 1.0 = 1 / 1
movingAverage.next(10); // return 5.5 = (1 + 10) / 2
movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3
movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3

Constraints:
* 1 <= size <= 1000
* -10^5 <= val <= 10^5
* At most 10^4 calls will be made to next."""

class MovingAverage:

    def __init__(self, size: int):
        """
        Initialize your data structure here.
        """
        self.nums = deque()
        self.size = size
        self.rsm = 0

    def next(self, val: int) -> float:
        self.nums.append(val)
        self.rsm += val
        if len(self.nums) > self.size:
            self.rsm -= self.nums.popleft()
        return self.rsm/len(self.nums)


"""348. Design Tic-Tac-Toe (Medium)
Assume the following rules are for the tic-tac-toe game on an n x n board
between two players:
* A move is guaranteed to be valid and is placed on an empty block.
* Once a winning condition is reached, no more moves are allowed.
* A player who succeeds in placing n of their marks in a horizontal, vertical,
  or diagonal row wins the game.

Implement the TicTacToe class:
* TicTacToe(int n) Initializes the object the size of the board n.
* int move(int row, int col, int player) Indicates that player with id player
  plays at the cell (row, col) of the board. The move is guaranteed to be a valid move.

Follow up: Could you do better than O(n2) per move() operation?

Example 1:
Input: ["TicTacToe", "move", "move", "move", "move", "move", "move", "move"]
       [[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]]
Output: [null, 0, 0, 0, 0, 0, 0, 1]
Explanation:
TicTacToe ticTacToe = new TicTacToe(3);
Assume that player 1 is "X" and player 2 is "O" in the board.
ticTacToe.move(0, 0, 1); // return 0 (no one wins)
|X| | |
| | | |    // Player 1 makes a move at (0, 0).
| | | |

ticTacToe.move(0, 2, 2); // return 0 (no one wins)
|X| |O|
| | | |    // Player 2 makes a move at (0, 2).
| | | |

ticTacToe.move(2, 2, 1); // return 0 (no one wins)
|X| |O|
| | | |    // Player 1 makes a move at (2, 2).
| | |X|

ticTacToe.move(1, 1, 2); // return 0 (no one wins)
|X| |O|
| |O| |    // Player 2 makes a move at (1, 1).
| | |X|

ticTacToe.move(2, 0, 1); // return 0 (no one wins)
|X| |O|
| |O| |    // Player 1 makes a move at (2, 0).
|X| |X|

ticTacToe.move(1, 0, 2); // return 0 (no one wins)
|X| |O|
|O|O| |    // Player 2 makes a move at (1, 0).
|X| |X|

ticTacToe.move(2, 1, 1); // return 1 (player 1 wins)
|X| |O|
|O|O| |    // Player 1 makes a move at (2, 1).
|X|X|X|

Constraints:
* 2 <= n <= 100
* player is 1 or 2.
* 1 <= row, col <= n
* (row, col) are unique for each different call to move.
* At most n2 calls will be made to move."""

class TicTacToe:

    def __init__(self, n: int):
        self.n = n
        self.rows = [[0]*n for _ in range(2)]
        self.cols = [[0]*n for _ in range(2)]
        self.diag = [0]*2
        self.anti = [0]*2

    def move(self, row: int, col: int, player: int) -> int:
        self.rows[player-1][row] += 1
        self.cols[player-1][col] += 1
        if row == col: self.diag[player-1] += 1
        if row + col == self.n-1: self.anti[player-1] += 1
        if self.n in (self.rows[player-1][row], self.cols[player-1][col], self.diag[player-1], self.anti[player-1]): return player
        return 0


"""352. Data Stream as Disjoint Intervals (Hard)
Given a data stream input of non-negative integers a1, a2, ..., an, summarize
the numbers seen so far as a list of disjoint intervals. Implement the
SummaryRanges class:
* SummaryRanges() Initializes the object with an empty stream.
* void addNum(int val) Adds the integer val to the stream.
* int[][] getIntervals() Returns a summary of the integers in the stream
  currently as a list of disjoint intervals [starti, endi].

Example 1:
Input: ["SummaryRanges", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals"]
       [[], [1], [], [3], [], [7], [], [2], [], [6], []]
Output: [null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]
Explanation
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // return [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // return [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // return [[1, 3], [6, 7]]

Constraints:
* 0 <= val <= 10^4
* At most 3 * 10^4 calls will be made to addNum and getIntervals.

Follow up: What if there are lots of merges and the number of disjoint
           intervals is small compared to the size of the data stream?"""

class SummaryRanges:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = SortedList()

    def addNum(self, val: int) -> None:
        k = self.data.bisect_left([val, val])
        if k and val <= self.data[k-1][1] or k < len(self.data) and self.data[k][0] == val: return
        if (k == 0 or self.data[k-1][1]+1 < val) and (k == len(self.data) or val+1 < self.data[k][0]): self.data.add([val, val])
        elif k and self.data[k-1][1]+1 == val:
            self.data[k-1][1] += 1
            if k < len(self.data) and val+1 == self.data[k][0]:
                self.data[k-1][1] = self.data.pop(k)[1]
        elif k < len(self.data) and val+1 == self.data[k][0]: self.data[k][0] -= 1

    def getIntervals(self) -> List[List[int]]:
        return list(self.data)


"""353. Design Snake Game (Medium)
Design a Snake game that is played on a device with screen size height x width.
Play the game online if you are not familiar with the game. The snake is
initially positioned at the top left corner (0, 0) with a length of 1 unit. You
are given an array food where food[i] = (ri, ci) is the row and column position
of a piece of food that the snake can eat. When a snake eats a piece of food,
its length and the game's score both increase by 1. Each piece of food appears
one by one on the screen, meaning the second piece of food will not appear
until the snake eats the first piece of food. When a piece of food appears on
the screen, it is guaranteed that it will not appear on a block occupied by the
snake. The game is over if the snake goes out of bounds (hits a wall) or if its
head occupies a space that its body occupies after moving (i.e. a snake of
length 4 cannot run into itself).

Implement the SnakeGame class:
* SnakeGame(int width, int height, int[][] food) Initializes the object with a
  screen of size height x width and the positions of the food.
* int move(String direction) Returns the score of the game after applying one
  direction move by the snake. If the game is over, return -1.

Example 1:
Input: ["SnakeGame", "move", "move", "move", "move", "move", "move"]
       [[3, 2, [[1, 2], [0, 1]]], ["R"], ["D"], ["R"], ["U"], ["L"], ["U"]]
Output: [null, 0, 0, 1, 1, 2, -1]
Explanation:
SnakeGame snakeGame = new SnakeGame(3, 2, [[1, 2], [0, 1]]);
snakeGame.move("R"); // return 0
snakeGame.move("D"); // return 0
snakeGame.move("R"); // return 1, snake eats the first piece of food. The second piece of food appears
                     // at (0, 1).
snakeGame.move("U"); // return 1
snakeGame.move("L"); // return 2, snake eats the second food. No more food appears.
snakeGame.move("U"); // return -1, game over because snake collides with border

Constraints:
* 1 <= width, height <= 10^4
* 1 <= food.length <= 50
* food[i].length == 2
* 0 <= ri < height
* 0 <= ci < width
* direction.length == 1
* direction is 'U', 'D', 'L', or 'R'.
* At most 10^4 calls will be made to move."""

class SnakeGame:

    def __init__(self, width: int, height: int, food: List[List[int]]):
        """
        Initialize your data structure here.
        @param width - screen width
        @param height - screen height
        @param food - A list of food positions
        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].
        """
        self.width = width
        self.height = height
        self.food = deque(food)
        self.position = OrderedDict({(0,0): 0})

    def move(self, direction: str) -> int:
        """
        Moves the snake.
        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down
        @return The game's score after the move. Return -1 if game over.
        Game over when snake crosses the screen boundary or bites its body.
        """
        (i, j), _ = self.position.popitem(last=True) # current position
        self.position[(i, j)] = 0 # add back
        if direction == "U": i -= 1
        elif direction == "L": j -= 1
        elif direction == "R": j += 1
        else: i += 1
        if self.food and self.food[0] == [i, j]: self.food.popleft()
        else: self.position.popitem(last=False)
        if not (0 <= i < self.height and 0 <= j < self.width) or (i, j) in self.position: return -1 # game over
        self.position[(i, j)] = 0
        return len(self.position)-1


"""355. Design Twitter (Medium)
Design a simplified version of Twitter where users can post tweets,
follow/unfollow another user and is able to see the 10 most recent tweets in
the user's news feed. Your design should support the following methods:
+ postTweet(userId, tweetId): Compose a new tweet.
+ getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news
  feed. Each item in the news feed must be posted by users who the user followed
  or by the user herself. Tweets must be ordered from most recent to least recent.
+ follow(followerId, followeeId): Follower follows a followee.
+ unfollow(followerId, followeeId): Follower unfollows a followee.

Example:
Twitter twitter = new Twitter();
// User 1 posts a new tweet (id = 5).
twitter.postTweet(1, 5);
// User 1's news feed should return a list with 1 tweet id -> [5].
twitter.getNewsFeed(1);
// User 1 follows user 2.
twitter.follow(1, 2);
// User 2 posts a new tweet (id = 6).
twitter.postTweet(2, 6);
// User 1's news feed should return a list with 2 tweet ids -> [6, 5].
// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.getNewsFeed(1);
// User 1 unfollows user 2.
twitter.unfollow(1, 2);
// User 1's news feed should return a list with 1 tweet id -> [5],
// since user 1 is no longer following user 2.
twitter.getNewsFeed(1);"""

class Twitter:

    def __init__(self):
        self.cnt = 0 # global counter
        self.tweets = {} # mapping from user to tweets
        self.followers = {} # mapping from user to followers

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.cnt += 1
        self.tweets.setdefault(userId, deque()).appendleft((self.cnt, tweetId))

    def getNewsFeed(self, userId: int) -> List[int]:
        hp = [] # max heap
        for fid in self.followers.get(userId, set()) | {userId}:
            if fid in self.tweets: # has tweeted
                cnt, tid = self.tweets[fid][0]
                heappush(hp, (-cnt, tid, fid, 0)) # push follower's tweet on heap
        ans = []
        for _ in range(10):
            if not hp: break
            _, tid, uid, i = heappop(hp)
            ans.append(tid)
            if i+1 < len(self.tweets[uid]):
                cnt, tid = self.tweets[uid][i+1]
                heappush(hp, (-cnt, tid, uid, i+1))
        return ans

    def follow(self, followerId: int, followeeId: int) -> None:
        self.followers.setdefault(followerId, set()).add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        self.followers.setdefault(followerId, set()).discard(followeeId)


"""359. Logger Rate Limiter (Easy)
Design a logger system that receives a stream of messages along with their
timestamps. Each unique message should only be printed at most every 10 seconds
(i.e. a message printed at timestamp t will prevent other identical messages
from being printed until timestamp t + 10). All messages will come in
chronological order. Several messages may arrive at the same timestamp.

Implement the Logger class:
* Logger() Initializes the logger object.
* bool shouldPrintMessage(int timestamp, string message) Returns true if the message should be printed in the given timestamp, otherwise returns false.

Example 1:
Input: ["Logger", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage"]
       [[], [1, "foo"], [2, "bar"], [3, "foo"], [8, "bar"], [10, "foo"], [11, "foo"]]
Output: [null, true, true, false, false, false, true]
Explanation:
Logger logger = new Logger();
logger.shouldPrintMessage(1, "foo");  // return true, next allowed timestamp for "foo" is 1 + 10 = 11
logger.shouldPrintMessage(2, "bar");  // return true, next allowed timestamp for "bar" is 2 + 10 = 12
logger.shouldPrintMessage(3, "foo");  // 3 < 11, return false
logger.shouldPrintMessage(8, "bar");  // 8 < 12, return false
logger.shouldPrintMessage(10, "foo"); // 10 < 11, return false
logger.shouldPrintMessage(11, "foo"); // 11 >= 11, return true, next allowed timestamp for "foo" is
                                      // 11 + 10 = 21

Constraints:
* 0 <= timestamp <= 10^9
* Every timestamp will be passed in non-decreasing order (chronological order).
* 1 <= message.length <= 30
* At most 10^4 calls will be made to shouldPrintMessage."""

class Logger:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.seen = {}

    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
        """
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity.
        """
        if timestamp - self.seen.get(message, -inf) >= 10:
            self.seen[message] = timestamp
            return True
        return False


"""362. Design Hit Counter (Medium)
Design a hit counter which counts the number of hits received in the past 5
minutes. Each function accepts a timestamp parameter (in seconds granularity)
and you may assume that calls are being made to the system in chronological
order (ie, the timestamp is monotonically increasing). You may assume that the
earliest timestamp starts at 1. It is possible that several hits arrive roughly
at the same time.

Example:
HitCounter counter = new HitCounter();

// hit at timestamp 1.
counter.hit(1);

// hit at timestamp 2.
counter.hit(2);

// hit at timestamp 3.
counter.hit(3);

// get hits at timestamp 4, should return 3.
counter.getHits(4);

// hit at timestamp 300.
counter.hit(300);

// get hits at timestamp 300, should return 4.
counter.getHits(300);

// get hits at timestamp 301, should return 3.
counter.getHits(301);
Follow up:
What if the number of hits per second could be very large? Does your design scale?"""

class HitCounter:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = deque()
        self.val = 0

    def hit(self, timestamp: int) -> None:
        """
        Record a hit.
        @param timestamp - The current timestamp (in seconds granularity).
        """
        if self.queue and self.queue[-1][0] == timestamp: self.queue[-1][1] += 1
        else: self.queue.append([timestamp, 1])
        self.val += 1

    def getHits(self, timestamp: int) -> int:
        """
        Return the number of hits in the past 5 minutes.
        @param timestamp - The current timestamp (in seconds granularity).
        """
        while self.queue and self.queue[0][0] + 300 <= timestamp:
            self.val -= self.queue.popleft()[1]
        return self.val


"""379. Design Phone Directory (Medium)
Design a Phone Directory which supports the following operations:
* get: Provide a number which is not assigned to anyone.
* check: Check if a number is available or not.
* release: Recycle or release a number.

Example:
// Init a phone directory containing a total of 3 numbers: 0, 1, and 2.
PhoneDirectory directory = new PhoneDirectory(3);

// It can return any available phone number. Here we assume it returns 0.
directory.get();

// Assume it returns 1.
directory.get();

// The number 2 is available, so return true.
directory.check(2);

// It returns 2, the only number that is left.
directory.get();

// The number 2 is no longer available, so return false.
directory.check(2);

// Release number 2 back to the pool.
directory.release(2);

// Number 2 is available again, return true.
directory.check(2);

Constraints:
* 1 <= maxNumbers <= 10^4
* 0 <= number < maxNumbers
* The total number of call of the methods is between [0 - 20000]"""

class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        """
        Initialize your data structure here
        @param maxNumbers - The maximum numbers that can be stored in the phone directory.
        """
        self.nums = set(range(maxNumbers))

    def get(self) -> int:
        """
        Provide a number which is not assigned to anyone.
        @return - Return an available number. Return -1 if none is available.
        """
        return self.nums.pop() if self.nums else -1

    def check(self, number: int) -> bool:
        """
        Check if a number is available or not.
        """
        return number in self.nums

    def release(self, number: int) -> None:
        """
        Recycle or release a number.
        """
        self.nums.add(number)


"""380. Insert Delete GetRandom O(1) (Medium)
Design a data structure that supports all following operations in average O(1)
time.
+ insert(val): Inserts an item val to the set if not already present.
+ remove(val): Removes an item val from the set if present.
+ getRandom: Returns a random element from current set of elements (it's
             guaranteed that at least one element exists when this method is
             called). Each element must have the same probability of being
             returned.
Example:
// Init an empty set.
RandomizedSet randomSet = new RandomizedSet();
// Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomSet.insert(1);
// Returns false as 2 does not exist in the set.
randomSet.remove(2);
// Inserts 2 to the set, returns true. Set now contains [1,2].
randomSet.insert(2);
// getRandom should return either 1 or 2 randomly.
randomSet.getRandom();
// Removes 1 from the set, returns true. Set now contains [2].
randomSet.remove(1);
// 2 was already in the set, so return false.
randomSet.insert(2);
// Since 2 is the only number in the set, getRandom always return 2.
randomSet.getRandom();"""

class RandomizedSet:

    def __init__(self):
        self.loc = {} # val-to-index mapping
        self.vals = []

    def insert(self, val: int) -> bool:
        if val in self.loc: return False
        self.loc[val] = len(self.vals)
        self.vals.append(val)
        return True

    def remove(self, val: int) -> bool:
        if val not in self.loc: return False
        i = self.loc[val]
        self.loc[self.vals[-1]] = i
        self.loc.pop(val)
        self.vals[i] = self.vals[-1]
        self.vals.pop()
        return True

    def getRandom(self) -> int:
        return choice(self.vals)


"""381. Insert Delete GetRandom O(1) - Duplicates allowed (Hard)
Design a data structure that supports all following operations in average O(1)
time. Note: Duplicate elements are allowed.
+ insert(val): Inserts an item val to the collection.
+ remove(val): Removes an item val from the collection if present.
+ getRandom: Returns a random element from current collection of elements. The
             probability of each element being returned is linearly related to
             the number of same value the collection contains.
Example:
// Init an empty collection.
RandomizedCollection collection = new RandomizedCollection();
// Inserts 1 to the collection. Returns true as the collection did not contain 1.
collection.insert(1);
// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].
collection.insert(1);
// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].
collection.insert(2);
// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.
collection.getRandom();
// Removes 1 from the collection, returns true. Collection now contains [1,2].
collection.remove(1);
// getRandom should return 1 and 2 both equally likely.
collection.getRandom();"""

class RandomizedCollection:

    def __init__(self):
        self.val = [] # val
        self.mpp = {} # val to set of indices

    def insert(self, val: int) -> bool:
        self.mpp.setdefault(val, set()).add(len(self.val))
        self.val.append(val)
        return len(self.mpp[val]) == 1

    def remove(self, val: int) -> bool:
        if val not in self.mpp or not self.mpp[val]: return False  # flag
        i = self.mpp[val].pop()
        self.mpp[self.val[-1]].add(i)
        self.mpp[self.val[-1]].remove(len(self.val)-1)
        self.val[i] = self.val[-1]
        self.val.pop()
        return True

    def getRandom(self) -> int:
        return choice(self.val)


"""382. Linked List Random Node (Medium)
Given a singly linked list, return a random node's value from the linked list.
Each node must have the same probability of being chosen.

Follow up: What if the linked list is extremely large and its length is unknown
           to you? Could you solve this efficiently without using extra space?

Example:
// Init a singly linked list [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom() should return either 1, 2, or 3 randomly. Each element should
// have equal probability of returning.
solution.getRandom();"""

class Solution:
    def __init__(self, head: ListNode):
        self.head = head

    def getRandom(self) -> int:
        node = self.head
        n = 0
        while node:
            if randint(0, n) == 0: ans = node.val
            n += 1
            node = node.next
        return ans


"""384. Shuffle an Array (Medium)
Shuffle a set of numbers without duplicates.

Example:
// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();"""

class Solution:
    """Knuth shuffle aka Fisher-Yates shuffle"""

    def __init__(self, nums: List[int]):
        self.orig = nums.copy()
        self.nums = nums

    def reset(self) -> List[int]:
        return self.orig

    def shuffle(self) -> List[int]:
        for i in range(1, len(self.nums)):
            ii = randint(0, i)
            self.nums[ii], self.nums[i] = self.nums[i], self.nums[ii]
        return self.nums


"""398. Random Pick Index (Medium)
Given an array of integers with possible duplicates, randomly output the index
of a given target number. You can assume that the given target number must
exist in the array. Note that the array size can be very large. Solution that
uses too much extra space will not pass the judge.

Example:
int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);
// pick(3) should return either index 2, 3, or 4 randomly. Each index should
// have equal probability of returning.
solution.pick(3);
// pick(1) should return 0. Since in the array only nums[0] is equal to 1.
solution.pick(1);"""

class Solution:

    def __init__(self, nums: List[int]):
        self.nums = nums # store nums

    def pick(self, target: int) -> int:
        """Sample index of target via resevoir sampling."""
        ans = None
        cnt = 0
        for i, x in enumerate(self.nums):
            if x == target:
                cnt += 1
                if randint(1, cnt) == cnt: ans = i # prob 1/cnt
        return ans


"""432. All O`one Data Structure (Hard)
Design a data structure to store the strings' count with the ability to return
the strings with minimum and maximum counts. Implement the AllOne class:
* AllOne() Initializes the object of the data structure.
* inc(String key) Increments the count of the string key by 1. If key does not
  exist in the data structure, insert it with count 1.
* dec(String key) Decrements the count of the string key by 1. If the count of
  key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.
* getMaxKey() Returns one of the keys with the maximal count. If no element
  exists, return an empty string "".
* getMinKey() Returns one of the keys with the minimum count. If no element
  exists, return an empty string "".

Example 1:
Input: ["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
       [[], ["hello"], ["hello"], [], [], ["leet"], [], []]
Output: [null, null, null, "hello", "hello", null, "hello", "leet"]
Explanation
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "hello"
allOne.inc("leet");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "leet"

Constraints:
* 1 <= key.length <= 10
* key consists of lowercase English letters.
* It is guaranteed that for each call to dec, key is existing in the data structure.
* At most 5 * 10^4 calls will be made to inc, dec, getMaxKey, and getMinKey."""

class ListNode:

    def __init__(self, keys, freq=0, next=None, prev=None):
        self.keys = keys
        self.freq = freq
        self.next = next
        self.prev = prev


class AllOne:

    def __init__(self):
        self.mp = {}
        self.head = ListNode(set())
        self.tail = ListNode(set())
        self.head.next = self.tail
        self.tail.prev = self.head

    def inc(self, key: str) -> None:
        if key in self.mp:
            node = self.mp[key]
            node.keys.remove(key)
        else: node = self.head
        if node.next.freq == node.freq + 1:
            self.mp[key] = node.next
            node.next.keys.add(key)
        else:
            newn = ListNode({key}, node.freq+1, next=node.next, prev=node)
            node.next.prev = node.next = newn
            self.mp[key] = newn
        if node != self.head and not node.keys:
            node.prev.next = node.next
            node.next.prev = node.prev

    def dec(self, key: str) -> None:
        node = self.mp[key]
        node.keys.remove(key)
        if node.freq == 1: self.mp.pop(key)
        elif node.prev.freq + 1 == node.freq:
            node.prev.keys.add(key)
            self.mp[key] = node.prev
        else:
            newn = ListNode({key}, node.freq-1, next=node, prev=node.prev)
            node.prev.next = node.prev = newn
            self.mp[key] = newn
        if not node.keys:
            node.prev.next = node.next
            node.next.prev = node.prev

    def getMaxKey(self) -> str:
        if self.tail.prev == self.head: return ""
        ans = self.tail.prev.keys.pop()
        self.tail.prev.keys.add(ans)
        return ans

    def getMinKey(self) -> str:
        if self.head.next == self.tail: return ""
        ans = self.head.next.keys.pop()
        self.head.next.keys.add(ans)
        return ans


"""460. LFU Cache (Hard)
Design and implement a data structure for a Least Frequently Used (LFU) cache.
Implement the LFUCache class:
* LFUCache(int capacity) Initializes the object with the capacity of the data
  structure.
* int get(int key) Gets the value of the key if the key exists in the cache.
  Otherwise, returns -1.
* void put(int key, int value) Update the value of the key if present, or
  inserts the key if not already present. When the cache reaches its capacity,
  it should invalidate and remove the least frequently used key before
  inserting a new item. For this problem, when there is a tie (i.e., two or
  more keys with the same frequency), the least recently used key would be
  invalidated.
To determine the least frequently used key, a use counter is maintained for
each key in the cache. The key with the smallest use counter is the least
frequently used key. When a key is first inserted into the cache, its use
counter is set to 1 (due to the put operation). The use counter for a key in
the cache is incremented either a get or put operation is called on it. The
functions get and put must each run in O(1) average time complexity.

Example 1:
Input: ["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
       [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
Output: [null, null, null, 1, null, -1, 3, null, -1, 3, 4]
Explanation
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[4,3], cnt(4)=2, cnt(3)=3

Constraints:
* 0 <= capacity <= 10^4
* 0 <= key <= 10^5
* 0 <= value <= 10^9
* At most 2 * 10^5 calls will be made to get and put."""

class ListNode:

    def __init__(self, key=0, val=0, freq = 0, prev=None, next=None):
        self.key = key
        self.val = val
        self.freq = freq
        self.prev = prev
        self.next = next


class LFUCache:

    def __init__(self, capacity: int):
        self.cap = capacity
        self.lo = 0
        self.mp = {}
        self.freq = []

    def _remove(self, node):
        if self.lo == node.freq and self.freq[node.freq] == (node.prev, node.next): self.lo += 1
        node.next.prev = node.prev
        node.prev.next = node.next
        self.mp.pop(node.key)

    def _insert(self, node):
        if node.freq == len(self.freq):
            head = ListNode()
            tail = ListNode()
            head.next = tail
            tail.prev = head
            self.freq.append((head, tail))
        head = self.freq[node.freq][0]
        node.next = head.next
        node.prev = head
        head.next.prev = head.next = node
        self.mp[node.key] = node

    def get(self, key: int) -> int:
        if key not in self.mp: return -1
        node = self.mp[key]
        self._remove(node)
        node.freq += 1
        self._insert(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if self.get(key) == -1:
            if self.cap == 0 and self.freq:
                self.cap += 1
                node = self.freq[self.lo][1].prev
                self._remove(node)
            if self.cap:
                self.cap -= 1
                node = ListNode(key, value)
                self._insert(node)
                self.lo = 0
        else:
            node = self.mp[key]
            node.val = value


"""519. Random Flip Matrix (Medium)
You are given the number of rows n_rows and number of columns n_cols of a 2D
binary matrix where all values are initially 0. Write a function flip which
chooses a 0 value uniformly at random, changes it to 1, and then returns the
position [row.id, col.id] of that value. Also, write a function reset which
sets all values back to 0. Try to minimize the number of calls to system's
Math.random() and optimize the time and space complexity.

Note:
* 1 <= n_rows, n_cols <= 10000
* 0 <= row.id < n_rows and 0 <= col.id < n_cols
* flip will not be called when the matrix has no 0 values left.
* the total number of calls to flip and reset will not exceed 1000.

Example 1:
Input:
["Solution","flip","flip","flip","flip"]
[[2,3],[],[],[],[]]
Output: [null,[0,1],[1,2],[1,0],[1,1]]

Example 2:
Input:
["Solution","flip","flip","reset","flip"]
[[1,2],[],[],[],[]]
Output: [null,[0,0],[0,1],null,[0,0]]

Explanation of Input Syntax: The input is two lists: the subroutines called and
their arguments. Solution's constructor has two arguments, n_rows and n_cols.
flip and reset have no arguments. Arguments are always wrapped with a list,
even if there aren't any."""

class Solution:

    def __init__(self, n_rows: int, n_cols: int):
        self.mp = {}
        self.cols = n_cols
        self.size = self.cpty = n_rows * n_cols

    def flip(self) -> List[int]:
        self.size -= 1
        r = randint(0, self.size)
        rr = self.mp.get(r, r) # mapped random number (remove duplicates)
        self.mp[r] = self.mp.get(self.size, self.size) # move rn at self.size to r
        return rr//self.cols, rr%self.cols

    def reset(self) -> None:
        self.mp = {}
        self.size = self.cpty


"""528. Random Pick with Weight (Medium)
You are given an array of positive integers w where w[i] describes the weight
of ith index (0-indexed). We need to call the function pickIndex() which
randomly returns an integer in the range [0, w.length - 1]. pickIndex() should
return the integer proportional to its weight in the w array. For example, for
w = [1, 3], the probability of picking the index 0 is 1 / (1 + 3) = 0.25
(i.e 25%) while the probability of picking the index 1 is 3 / (1 + 3) = 0.75
(i.e 75%). More formally, the probability of picking index i is w[i] / sum(w).

Example 1:
Input:
["Solution","pickIndex"]
[[[1]],[]]
Output: [null,0]

Explanation:
Solution solution = new Solution([1]);
solution.pickIndex(); // return 0. Since there is only one single element on the array the only option is to return the first element.

Example 2:
Input:
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
Output: [null,1,1,1,1,0]
Explanation:
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // return 1. It's returning the second element (index = 1) that has probability of 3/4.
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 0. It's returning the first element (index = 0) that has probability of 1/4.

Since this is a randomization problem, multiple answers are allowed so the following outputs can be considered correct :
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
and so on.

Constraints:
* 1 <= w.length <= 10000
* 1 <= w[i] <= 10^5
* pickIndex will be called at most 10000 times."""

class Solution:

    def __init__(self, w: List[int]):
        self.prefix = [0]
        for x in w: self.prefix.append(self.prefix[-1] + x)

    def pickIndex(self) -> int:
        r = randint(1, self.prefix[-1])

        def fn(arr, x):
            """Return the position of x in arr."""
            lo, hi = 0, len(arr)
            while lo < hi:
                mid = lo + hi >> 1
                if arr[mid] < x: lo = mid+1
                else: hi = mid
            return lo

        return fn(self.prefix, r)-1


"""535. Encode and Decode TinyURL (Medium)
Note: This is a companion problem to the System Design problem: Design TinyURL.
TinyURL is a URL shortening service where you enter a URL such as
https://leetcode.com/problems/design-tinyurl and it returns a short URL such as
http://tinyurl.com/4e9iAk. Design the encode and decode methods for the TinyURL
service. There is no restriction on how your encode/decode algorithm should
work. You just need to ensure that a URL can be encoded to a tiny URL and the
tiny URL can be decoded to the original URL."""

class Codec:

    def __init__(self):
        self.lookup = {}

    def encode(self, longUrl: str) -> str:
        """Encodes a URL to a shortened URL."""
        ans = "http://tinyurl.com/" + hex(abs(hash(longUrl)))
        self.lookup[ans] = longUrl
        return ans


    def decode(self, shortUrl: str) -> str:
        """Decodes a shortened URL to its original URL."""
        return self.lookup[shortUrl]


"""604. Design Compressed String Iterator (Easy)
Design and implement a data structure for a compressed string iterator. The
given compressed string will be in the form of each letter followed by a
positive integer representing the number of this letter existing in the original
uncompressed string.

Implement the StringIterator class:
* next() Returns the next character if the original string still has uncompressed characters, otherwise returns a white space.
* hasNext() Returns true if there is any letter needs to be uncompressed in the original string, otherwise returns false.

Example 1:
Input: ["StringIterator", "next", "next", "next", "next", "next", "next", "hasNext", "next", "hasNext"]
       [["L1e2t1C1o1d1e1"], [], [], [], [], [], [], [], [], []]
Output: [null, "L", "e", "e", "t", "C", "o", true, "d", true]
Explanation:
StringIterator stringIterator = new StringIterator("L1e2t1C1o1d1e1");
stringIterator.next(); // return "L"
stringIterator.next(); // return "e"
stringIterator.next(); // return "e"
stringIterator.next(); // return "t"
stringIterator.next(); // return "C"
stringIterator.next(); // return "o"
stringIterator.hasNext(); // return True
stringIterator.next(); // return "d"
stringIterator.hasNext(); // return True

Constraints:
* 1 <= compressedString.length <= 1000
* compressedString consists of lower-case an upper-case English letters and digits.
* The number of a single character repetitions in compressedString is in the range [1, 10^9]
* At most 100 calls will be made to next and hasNext."""

class StringIterator:

    def __init__(self, compressedString: str):
        self.data = compressedString
        self.char = None
        self.i = self.n = 0

    def next(self) -> str:
        if not self.hasNext(): return " "
        if not self.n:
            self.char = self.data[self.i]
            self.i = ii = self.i+1
            while self.i < len(self.data) and self.data[self.i].isdigit(): self.i += 1
            self.n = int(self.data[ii:self.i])
        self.n -= 1
        return self.char

    def hasNext(self) -> bool:
        return self.i < len(self.data) or self.n


"""635. Design Log Storage System (Medium)
You are given several logs, where each log contains a unique ID and timestamp.
Timestamp is a string that has the following format:
Year:Month:Day:Hour:Minute:Second, for example, 2017:01:01:23:59:59. All
domains are zero-padded decimal numbers. Implement the LogSystem class:
* LogSystem() Initializes the LogSystem object.
* void put(int id, string timestamp) Stores the given log (id, timestamp) in
  your storage system.
* int[] retrieve(string start, string end, string granularity) Returns the IDs
  of the logs whose timestamps are within the range from start to end inclusive.
  start and end all have the same format as timestamp, and granularity means
  how precise the range should be (i.e. to the exact Day, Minute, etc.). For
  example, start = "2017:01:01:23:59:59", end = "2017:01:02:23:59:59", and
  granularity = "Day" means that we need to find the logs within the inclusive
  range from Jan. 1st 2017 to Jan. 2nd 2017, and the Hour, Minute, and Second
  for each log entry can be ignored.

Example 1:
Input: ["LogSystem", "put", "put", "put", "retrieve", "retrieve"]
       [[], [1, "2017:01:01:23:59:59"], [2, "2017:01:01:22:59:59"], [3, "2016:01:01:00:00:00"], ["2016:01:01:01:01:01", "2017:01:01:23:00:00", "Year"], ["2016:01:01:01:01:01", "2017:01:01:23:00:00", "Hour"]]
Output: [null, null, null, null, [3, 2, 1], [2, 1]]
Explanation:
LogSystem logSystem = new LogSystem();
logSystem.put(1, "2017:01:01:23:59:59");
logSystem.put(2, "2017:01:01:22:59:59");
logSystem.put(3, "2016:01:01:00:00:00");

// return [3,2,1], because you need to return all logs between 2016 and 2017.
logSystem.retrieve("2016:01:01:01:01:01", "2017:01:01:23:00:00", "Year");

// return [2,1], because you need to return all logs between Jan. 1, 2016 01:XX:XX and Jan. 1, 2017 23:XX:XX.
// Log 3 is not returned because Jan. 1, 2016 00:00:00 comes before the start of the range.
logSystem.retrieve("2016:01:01:01:01:01", "2017:01:01:23:00:00", "Hour");

Constraints:
* 1 <= id <= 500
* 2000 <= Year <= 2017
* 1 <= Month <= 12
* 1 <= Day <= 31
* 0 <= Hour <= 23
* 0 <= Minute, Second <= 59
* granularity is one of the values ["Year", "Month", "Day", "Hour", "Minute", "Second"].
* At most 500 calls will be made to put and retrieve."""

class LogSystem:

    def __init__(self):
        self.vals = []
        self.mp = {"Year": 4, "Month": 7, "Day": 10, "Hour": 13, "Minute": 16, "Second": 19}

    def put(self, id: int, timestamp: str) -> None:
        self.vals.append((id, timestamp))

    def retrieve(self, start: str, end: str, granularity: str) -> List[int]:
        k = self.mp[granularity]
        ans = []
        for id, timestamp in self.vals:
            if start[:k] <= timestamp[:k] <= end[:k]: ans.append(id)
        return ans


"""677. Map Sum Pairs (Medium)
Implement the MapSum class:
* MapSum() Initializes the MapSum object.
* void insert(String key, int val) Inserts the key-val pair into the map. If
  the key already existed, the original key-value pair will be overridden to
  the new one.
* int sum(string prefix) Returns the sum of all the pairs' value whose key
  starts with the prefix.

Example 1:
Input: ["MapSum", "insert", "sum", "insert", "sum"]
       [[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
Output: [null, null, 3, null, 5]
Explanation:
MapSum mapSum = new MapSum();
mapSum.insert("apple", 3);
mapSum.sum("ap");           // return 3 (apple = 3)
mapSum.insert("app", 2);
mapSum.sum("ap");           // return 5 (apple + app = 3 + 2 = 5)

Constraints:
* 1 <= key.length, prefix.length <= 50
* key and prefix consist of only lowercase English letters.
* 1 <= val <= 1000
* At most 50 calls will be made to insert and sum."""

class MapSum:

    def __init__(self):
        self.trie = {}
        self.seen = defaultdict(int)

    def insert(self, key: str, val: int) -> None:
        val -= self.seen[key]
        node = self.trie
        for ch in key:
            node = node.setdefault(ch, {})
            node["#"] = node.get("#", 0) + val
        self.seen[key] += val

    def sum(self, prefix: str) -> int:
        node = self.trie
        for ch in prefix:
            if ch not in node: return 0
            node = node[ch]
        return node["#"]


"""703. Kth Largest Element in a Stream (Easy)
Design a class to find the kth largest element in a stream. Note that it is the
kth largest element in the sorted order, not the kth distinct element. Implement
KthLargest class:
* KthLargest(int k, int[] nums) Initializes the object with the integer k and
  the stream of integers nums.
* int add(int val) Appends the integer val to the stream and returns the element
  representing the kth largest element in the stream.

Example 1:
Input ["KthLargest", "add", "add", "add", "add", "add"]
      [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output [null, 4, 5, 5, 8, 8]
Explanation
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8

Constraints:
* 1 <= k <= 10^4
* 0 <= nums.length <= 10^4
* -10^4 <= nums[i] <= 10^4
* -10^4 <= val <= 10^4
* At most 10^4 calls will be made to add.
* It is guaranteed that there will be at least k elements in the array when you
search for the kth element."""

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        heapify(nums)
        while len(nums) > k:
            heappop(nums)
        self.nums = nums
        self.k = k

    def add(self, val: int) -> int:
        heappush(self.nums, val)
        if len(self.nums) > self.k: heappop(self.nums)
        return self.nums[0]


"""706. Design HashMap (Easy)
Design a HashMap without using any built-in hash table libraries. To be
specific, your design should include these functions:
* put(key, value) : Insert a (key, value) pair into the HashMap. If the value
  already exists in the HashMap, update the value.
* get(key): Returns the value to which the specified key is mapped, or -1 if
  this map contains no mapping for the key.
* remove(key) : Remove the mapping for the value key if this map contains the
  mapping for the key.

Example:
MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);
hashMap.put(2, 2);
hashMap.get(1);            // returns 1
hashMap.get(3);            // returns -1 (not found)
hashMap.put(2, 1);         // update the existing value
hashMap.get(2);            // returns 1
hashMap.remove(2);         // remove the mapping for 2
hashMap.get(2);            // returns -1 (not found)

Note:
* All keys and values will be in the range of [0, 1000000].
* The number of operations will be in the range of [1, 10000].
* Please do not use the built-in HashMap library."""

class ListNode:
    def __init__(self, key=None, val=None, next=None):
        self.key = key
        self.val = val
        self.next = next


class MyHashMap:

    def __init__(self):
        self.data = [ListNode()] * 1000

    def put(self, key: int, value: int) -> None:
        node = self.data[key % len(self.data)]
        while node.next:
            if node.next.key == key:
                node.next.val = value
                return
            node = node.next
        node.next = ListNode(key, value)

    def get(self, key: int) -> int:
        node = self.data[key % len(self.data)]
        while node:
            if node.key == key: return node.val
            node = node.next
        return -1

    def remove(self, key: int) -> None:
        node = self.data[key % len(self.data)]
        while node.next:
            if node.next.key == key:
                node.next = node.next.next
                return
            node = node.next


"""707. Design Linked List (Medium)
Design your implementation of the linked list. You can choose to use a singly
or doubly linked list. A node in a singly linked list should have two
attributes: val and next. val is the value of the current node, and next is a
pointer/reference to the next node. If you want to use the doubly linked list,
you will need one more attribute prev to indicate the previous node in the
linked list. Assume all nodes in the linked list are 0-indexed. Implement the
MyLinkedList class:
* MyLinkedList() Initializes the MyLinkedList object.
* int get(int index) Get the value of the indexth node in the linked list. If
  the index is invalid, return -1.
* void addAtHead(int val) Add a node of value val before the first element of
  the linked list. After the insertion, the new node will be the first node of
  the linked list.
* void addAtTail(int val) Append a node of value val as the last element of the
  linked list.
* void addAtIndex(int index, int val) Add a node of value val before the
  indexth node in the linked list. If index equals the length of the linked
  list, the node will be appended to the end of the linked list. If index is
  greater than the length, the node will not be inserted.
* void deleteAtIndex(int index) Delete the indexth node in the linked list, if
  the index is valid.

Example 1:
Input: ["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
       [[], [1], [3], [1, 2], [1], [1], [1]]
Output: [null, null, null, null, 2, null, 3]
Explanation:
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3
myLinkedList.get(1);              // return 2
myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3
myLinkedList.get(1);              // return 3

Constraints:
* 0 <= index, val <= 1000
* Please do not use the built-in LinkedList library.
* At most 2000 calls will be made to get, addAtHead, addAtTail, addAtIndex and
  deleteAtIndex."""

class ListNode:

    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev
        self.next = next


class MyLinkedList:

    def __init__(self):
        self.size = 0
        self.head = ListNode()
        self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head

    def _moveTo(self, index: int) -> ListNode:
        if 0 <= index <= self.size:
            if index < self.size//2:
                node = self.head
                for _ in range(index+1): node = node.next
            else:
                node = self.tail
                for _ in range(self.size-index): node = node.prev
            return node

    def get(self, index: int) -> int:
        node = self._moveTo(index)
        return node.val if node and node != self.tail else -1

    def addAtHead(self, val: int) -> None:
        self.addAtIndex(0, val)

    def addAtTail(self, val: int) -> None:
        self.addAtIndex(self.size, val)

    def addAtIndex(self, index: int, val: int) -> None:
        node = self._moveTo(index)
        if node:
            self.size += 1
            node.prev.next = node.prev = ListNode(val, node.prev, node)

    def deleteAtIndex(self, index: int) -> None:
        node = self._moveTo(index)
        if node and node != self.tail:
            self.size -= 1
            node.prev.next = node.next
            node.next.prev = node.prev


"""715. Range Module (Hard)
A Range Module is a module that tracks ranges of numbers. Design a data
structure to track the ranges represented as half-open intervals and query
about them. A half-open interval [left, right) denotes all the real numbers x
where left <= x < right. Implement the RangeModule class:
* RangeModule() Initializes the object of the data structure.
* void addRange(int left, int right) Adds the half-open interval [left, right),
  tracking every real number in that interval. Adding an interval that
  partially overlaps with currently tracked numbers should add any numbers in
  the interval [left, right) that are not already tracked.
* boolean queryRange(int left, int right) Returns true if every real number in
  the interval [left, right) is currently being tracked, and false otherwise.
* void removeRange(int left, int right) Stops tracking every real number
  currently being tracked in the half-open interval [left, right).

Example 1:
Input: ["RangeModule", "addRange", "removeRange", "queryRange", "queryRange", "queryRange"]
       [[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]
Output: [null, null, null, true, false, true]
Explanation
RangeModule rangeModule = new RangeModule();
rangeModule.addRange(10, 20);
rangeModule.removeRange(14, 16);
rangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is
                                // being tracked)
rangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17
                                // in [13, 15) are not being tracked)
rangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is
                                // still being tracked, despite the remove
                                // operation)

Constraints:
* 1 <= left < right <= 10^9
* At most 104 calls will be made to addRange, queryRange, and removeRange."""

class RangeModule:

    def __init__(self):
        self.intervals = SortedList()

    def addRange(self, left: int, right: int) -> None:
        k = self.intervals.bisect_left([left, right])
        while k < len(self.intervals) and right >= self.intervals[k][0]:
            right = max(right, self.intervals[k][1])
            self.intervals.pop(k)
        if k and self.intervals[k-1][1] >= left:
            left = min(left, self.intervals[k-1][0])
            right = max(right, self.intervals[k-1][1])
            self.intervals.pop(k-1)
        self.intervals.add([left, right])

    def queryRange(self, left: int, right: int) -> bool:
        k = self.intervals.bisect_left([left, right])
        return k and self.intervals[k-1][0] <= left < right <= self.intervals[k-1][1] or k < len(self.intervals) and self.intervals[k][0] <= left < right <= self.intervals[k][1]

    def removeRange(self, left: int, right: int) -> None:
        k = self.intervals.bisect_left([left, right])
        while k < len(self.intervals) and self.intervals[k][0] <= right:
            if right < self.intervals[k][1]:
                self.intervals[k][0] = right
                break
            else: self.intervals.pop(k)
        if k and left < self.intervals[k-1][1]:
            if right < self.intervals[k-1][1]: self.intervals.add([right, self.intervals[k-1][1]])
            self.intervals[k-1][1] = left


"""716. Max Stack (Easy)
Design a max stack data structure that supports the stack operations and
supports finding the stack's maximum element.

Implement the MaxStack class:
* MaxStack() Initializes the stack object.
* void push(int x) Pushes element x onto the stack.
* int pop() Removes the element on top of the stack and returns it.
* int top() Gets the element on the top of the stack without removing it.
* int peekMax() Retrieves the maximum element in the stack without removing it.
* int popMax() Retrieves the maximum element in the stack and removes it. If
  there is more than one maximum element, only remove the top-most one.

Example 1:
Input: ["MaxStack", "push", "push", "push", "top", "popMax", "top", "peekMax", "pop", "top"]
       [[], [5], [1], [5], [], [], [], [], [], []]
Output: [null, null, null, null, 5, 5, 1, 5, 1, 5]
Explanation
MaxStack stk = new MaxStack();
stk.push(5);   // [5] the top of the stack and the maximum number is 5.
stk.push(1);   // [5, 1] the top of the stack is 1, but the maximum is 5.
stk.push(5);   // [5, 1, 5] the top of the stack is 5, which is also the maximum, because it is the top most one.
stk.top();     // return 5, [5, 1, 5] the stack did not change.
stk.popMax();  // return 5, [5, 1] the stack is changed now, and the top is different from the max.
stk.top();     // return 1, [5, 1] the stack did not change.
stk.peekMax(); // return 5, [5, 1] the stack did not change.
stk.pop();     // return 1, [5] the top of the stack and the max element is now 5.
stk.top();     // return 5, [5] the stack did not change.

Constraints:
* -10^7 <= x <= 10^7
* At most 10^4 calls will be made to push, pop, top, peekMax, and popMax.
* There will be at least one element in the stack when pop, top, peekMax, or
  popMax is called.

Follow up: Could you come up with a solution that supports O(1) for each top
           call and O(logn) for each other call? """

class MaxStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.k = 0              # key
        self.pq = []            # priority queue
        self.od = OrderedDict() # ordered dict

    def push(self, x: int) -> None:
        heappush(self.pq, (-x, self.k))
        self.od[self.k] = x
        self.k -= 1

    def pop(self) -> int:
        k, x = self.od.popitem(last=True)
        return x

    def top(self) -> int:
        k, x = self.od.popitem(last=True)
        self.od[k] = x
        return x

    def peekMax(self) -> int:
        while self.pq:
            x, k = heappop(self.pq)
            if k in self.od: break
        heappush(self.pq, (x, k))
        return -x

    def popMax(self) -> int:
        while self.pq:
            x, k = heappop(self.pq)
            if k in self.od: break
        self.od.pop(k)
        return -x


"""729. My Calendar I (Medium)
Implement a MyCalendar class to store your events. A new event can be added if
adding the event will not cause a double booking. Your class will have the
method, book(int start, int end). Formally, this represents a booking on the
half open interval [start, end), the range of real numbers x such that
start <= x < end. A double booking happens when two events have some non-empty
intersection (ie., there is some time that is common to both events.) For each
call to the method MyCalendar.book, return true if the event can be added to
the calendar successfully without causing a double booking. Otherwise, return
false and do not add the event to the calendar. Your class will be called like
this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)

Example 1:
MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(15, 25); // returns false
MyCalendar.book(20, 30); // returns true
Explanation:
The first event can be booked. The second can't because time 15 is already
booked by another event. The third event can be booked, as the first event
takes every time less than 20, but not including 20.

Note:
* The number of calls to MyCalendar.book per test case will be at most 1000.
* In calls to MyCalendar.book(start, end), start and end are integers in the
  range [0, 10^9].

class Node:
    def __init__(self, val=(0,0), left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""

class MyCalendar:

    def __init__(self):
        self.root = None

    def book(self, start: int, end: int) -> bool:
        if not self.root: self.root = Node((start, end))
        else:
            node = self.root
            while node:
                if end <= node.val[0]:
                    if node.left: node = node.left
                    else:
                        node.left = Node((start, end))
                        break
                elif node.val[1] <= start:
                    if node.right: node = node.right
                    else:
                        node.right = Node((start, end))
                        break
                else: return False # double booking
        return True


"""745. Prefix and Suffix Search (Hard)
Design a special dictionary with some words that searchs the words in it by a
prefix and a suffix. Implement the WordFilter class:
* WordFilter(string[] words) Initializes the object with the words in the
  dictionary.
* f(string prefix, string suffix) Returns the index of the word in the
  dictionary, which has the prefix prefix and the suffix suffix. If there is
  more than one valid index, return the largest of them. If there is no such
  word in the dictionary, return -1.

Example 1:
Input: ["WordFilter", "f"]
       [[["apple"]], ["a", "e"]]
Output: [null, 0]
Explanation:
WordFilter wordFilter = new WordFilter(["apple"]);
wordFilter.f("a", "e"); // return 0, because the word at index 0 has prefix = "a" and suffix = 'e".

Constraints:
* 1 <= words.length <= 15000
* 1 <= words[i].length <= 10
* 1 <= prefix.length, suffix.length <= 10
* words[i], prefix and suffix consist of lower-case English letters only.
* At most 15000 calls will be made to the function f.

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, i, word):
        node = self.root
        for c in word:
            node = node.setdefault(c, {})
            node["#"] = i

    def search(self, word):
        node = self.root
        for c in word:
            if c in node: node = node[c]
            else: return -1
        return node["#"]
"""

class WordFilter:

    def __init__(self, words: List[str]):
        self.trie = Trie()
        for i, word in enumerate(words):
            for k in range(len(word)):
                key = word[k:] + "$" + word
                self.trie.insert(i, key)

    def f(self, prefix: str, suffix: str) -> int:
        key = suffix + "$" + prefix
        return self.trie.search(key)


"""900. RLE Iterator (Medium)
We can use run-length encoding (i.e., RLE) to encode a sequence of integers.
In a run-length encoded array of even length encoding (0-indexed), for all even
i, encoding[i] tells us the number of times that the non-negative integer value
encoding[i + 1] is repeated in the sequence.

For example, the sequence arr = [8,8,8,5,5] can be encoded to be
encoding = [3,8,2,5]. encoding = [3,8,0,9,2,5] and encoding = [2,8,1,8,2,5] are
also valid RLE of arr. Given a run-length encoded array, design an iterator that
iterates through it. Implement the RLEIterator class:
* RLEIterator(int[] encoded) Initializes the object with the encoded array
  encoded.
* int next(int n) Exhausts the next n elements and returns the last element
  exhausted in this way. If there is no element left to exhaust, return -1
  instead.

Example 1:
Input: ["RLEIterator", "next", "next", "next", "next"]
       [[[3, 8, 0, 9, 2, 5]], [2], [1], [1], [2]]
Output: [null, 8, 8, 5, -1]
Explanation:
RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // This maps to the sequence [8,8,8,5,5].
rLEIterator.next(2); // exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5].
rLEIterator.next(1); // exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5].
rLEIterator.next(1); // exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5].
rLEIterator.next(2); // exhausts 2 terms, returning -1. This is because the first term exhausted was 5,
but the second term did not exist. Since the last term exhausted does not exist, we return -1.

Constraints:
* 2 <= encoding.length <= 1000
* encoding.length is even.
* 0 <= encoding[i] <= 10^9
* 1 <= n <= 10^9
* At most 1000 calls will be made to next."""

class RLEIterator:

    def __init__(self, A: List[int]):
        self.rle = A
        self.k = 0

    def next(self, n: int) -> int:
        while self.k < len(self.rle) and n > self.rle[self.k]:
            n -= self.rle[self.k]
            self.k += 2
        if self.k < len(self.rle):
            self.rle[self.k] -= n
            return self.rle[self.k+1]
        return -1


"""911. Online Election (Medium)
In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we
would like to implement the following query function: TopVotedCandidate.q(int t)
will return the number of the person that was leading the election at time t.
Votes cast at time t will count towards our query.  In the case of a tie, the
most recent vote (among tied candidates) wins.

Example 1:
Input: ["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]
Output: [null,0,1,1,0,0,1]
Explanation:
At time 3, the votes are [0], and 0 is leading.
At time 12, the votes are [0,1,1], and 1 is leading.
At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)
This continues for 3 more queries at time 15, 24, and 8.

Note:
* 1 <= persons.length = times.length <= 5000
* 0 <= persons[i] <= persons.length
* times is a strictly increasing array with all elements in [0, 10^9].
* TopVotedCandidate.q is called at most 10000 times per test case.
* TopVotedCandidate.q(int t) is always called with t >= times[0]."""

class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int]):
        self.times = times
        self.lead = []

        pp = 0
        freq = defaultdict(int)
        for p in persons:
            freq[p] += 1
            if freq[p] >= freq[pp]: pp = p
            self.lead.append(pp)


    def q(self, t: int) -> int:
        k = bisect_right(self.times, t) - 1
        return self.lead[k]


"""919. Complete Binary Tree Inserter (Medium)
A complete binary tree is a binary tree in which every level, except possibly
the last, is completely filled, and all nodes are as far left as possible.
Write a data structure CBTInserter that is initialized with a complete binary
tree and supports the following operations:
* CBTInserter(TreeNode root) initializes the data structure on a given tree
  with head node root;
* CBTInserter.insert(int v) will insert a TreeNode into the tree with value
  node.val = v so that the tree remains complete, and returns the value of the
  parent of the inserted TreeNode;
* CBTInserter.get_root() will return the head node of the tree.

Example 1:
Input: inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]]
Output: [null,1,[1,2]]

Example 2:
Input: inputs = ["CBTInserter","insert","insert","get_root"],
       inputs = [[[1,2,3,4,5,6]],[7],[8],[]]
Output: [null,3,4,[1,2,3,4,5,6,7,8]]

Note:
* The initial given tree is complete and contains between 1 and 1000 nodes.
* CBTInserter.insert is called at most 10000 times per test case.
* Every value of a given or inserted node is between 0 and 5000."""

class CBTInserter:

    def __init__(self, root: TreeNode):
        self.root = root
        self.nodes = deque([]) # nodes with None child
        queue = deque([root])
        while queue: # bfs
            node = queue.popleft()
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
            else: self.nodes.append(node)

    def insert(self, v: int) -> int:
        node = self.nodes[0]
        ans = node.val
        if not node.left: node.left = node = TreeNode(v)
        else:
            node.right = node = TreeNode(v)
            self.nodes.popleft()
        self.nodes.append(node)
        return ans

    def get_root(self) -> TreeNode:
        return self.root


"""981. Time Based Key-Value Store (Medium)
Design a time-based key-value data structure that can store multiple values for
the same key at different time stamps and retrieve the key's value at a certain
timestamp. Implement the TimeMap class:
* TimeMap() Initializes the object of the data structure.
* void set(String key, String value, int timestamp) Stores the key key with the
  value value at the given time timestamp.
* String get(String key, int timestamp) Returns a value such that set was
  called previously, with timestamp_prev <= timestamp. If there are multiple
  such values, it returns the value associated with the largest timestamp_prev.
  If there are no values, it returns "".

Example 1:
Input: ["TimeMap", "set", "get", "get", "set", "get", "get"]
       [[], ["foo", "bar", 1], ["foo", 1], ["foo", 3], ["foo", "bar2", 4], ["foo", 4], ["foo", 5]]
Output: [null, null, "bar", "bar", null, "bar2", "bar2"]
Explanation
TimeMap timeMap = new TimeMap();
timeMap.set("foo", "bar", 1);  // store the key "foo" and value "bar" along with timestamp = 1.
timeMap.get("foo", 1);         // return "bar"
timeMap.get("foo", 3);         // return "bar", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is "bar".
timeMap.set("foo", "bar2", 4); // store the key "foo" and value "bar2" along with timestamp = 4.
timeMap.get("foo", 4);         // return "bar2"
timeMap.get("foo", 5);         // return "bar2"

Constraints:
* 1 <= key.length, value.length <= 100
* key and value consist of lowercase English letters and digits.
* 1 <= timestamp <= 10^7
* All the timestamps timestamp of set are strictly increasing.
* At most 2 * 10^5 calls will be made to set and get."""

class TimeMap:

    def __init__(self):
        self.data = {}

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.data.setdefault(key, []).append((timestamp, value))

    def get(self, key: str, timestamp: int) -> str:
        k = bisect_right(self.data.get(key, []), timestamp, key=lambda x: x[0])
        return self.data[key][k-1][1] if k else ""


"""1032. Stream of Characters (Hard)
Design an algorithm that accepts a stream of characters and checks if a suffix
of these characters is a string of a given array of strings words. For example,
if words = ["abc", "xyz"] and the stream added the four characters (one by one)
'a', 'x', 'y', and 'z', your algorithm should detect that the suffix "xyz" of
the characters "axyz" matches "xyz" from words. Implement the StreamChecker
class:
* StreamChecker(String[] words) Initializes the object with the strings array
  words.
* boolean query(char letter) Accepts a new character from the stream and
  returns true if any non-empty suffix from the stream forms a word that is in
  words.

Example 1:
Input: ["StreamChecker", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query"]
       [[["cd", "f", "kl"]], ["a"], ["b"], ["c"], ["d"], ["e"], ["f"], ["g"], ["h"], ["i"], ["j"], ["k"], ["l"]]
Output: [null, false, false, false, true, false, true, false, false, false, false, false, true]
Explanation
StreamChecker streamChecker = new StreamChecker(["cd", "f", "kl"]);
streamChecker.query("a"); // return False
streamChecker.query("b"); // return False
streamChecker.query("c"); // return False
streamChecker.query("d"); // return True, because 'cd' is in the wordlist
streamChecker.query("e"); // return False
streamChecker.query("f"); // return True, because 'f' is in the wordlist
streamChecker.query("g"); // return False
streamChecker.query("h"); // return False
streamChecker.query("i"); // return False
streamChecker.query("j"); // return False
streamChecker.query("k"); // return False
streamChecker.query("l"); // return True, because 'kl' is in the wordlist

Constraints:
* 1 <= words.length <= 2000
* 1 <= words[i].length <= 2000
* words[i] consists of lowercase English letters.
* letter is a lowercase English letter.
* At most 4 * 10^4 calls will be made to query."""

class StreamChecker:

    def __init__(self, words: List[str]):
        self.trie = {}
        for word in words:
            node = self.trie
            for ch in reversed(word): node = node.setdefault(ch, {})
            node['$'] = word
        self.stream = []

    def query(self, letter: str) -> bool:
        self.stream.append(letter)
        node = self.trie
        for ch in reversed(self.stream):
            if ch not in node: return False
            node = node[ch]
            if '$' in node: return True


"""1115. Print FooBar Alternately (Medium)
Suppose you are given the following code:

class FooBar {
  public void foo() {
    for (int i = 0; i < n; i++) {
      print("foo");
    }
  }

  public void bar() {
    for (int i = 0; i < n; i++) {
      print("bar");
    }
  }
}
The same instance of FooBar will be passed to two different threads. Thread A
will call foo() while thread B will call bar(). Modify the given program to
output "foobar" n times.

Example 1:
Input: n = 1
Output: "foobar"
Explanation: There are two threads being fired asynchronously. One of them
             calls foo(), while the other calls bar(). "foobar" is being output
             1 time.

Example 2:
Input: n = 2
Output: "foobarfoobar"
Explanation: "foobar" is being output 2 times."""

class FooBar:
    def __init__(self, n):
        self.n = n
        self.lock0 = Lock()
        self.lock1 = Lock()
        self.lock1.acquire()


    def foo(self, printFoo: 'Callable[[], None]') -> None:
        for i in range(self.n):
            # printFoo() outputs "foo". Do not change or remove this line.
            self.lock0.acquire()
            printFoo()
            self.lock1.release()


    def bar(self, printBar: 'Callable[[], None]') -> None:
        for i in range(self.n):
            # printBar() outputs "bar". Do not change or remove this line.
            self.lock1.acquire()
            printBar()
            self.lock0.release()


"""1117. Building H2O (Medium)
There are two kinds of threads, oxygen and hydrogen. Your goal is to group
these threads to form water molecules. There is a barrier where each thread
has to wait until a complete molecule can be formed. Hydrogen and oxygen
threads will be given releaseHydrogen and releaseOxygen methods respectively,
which will allow them to pass the barrier. These threads should pass the
barrier in groups of three, and they must be able to immediately bond with
each other to form a water molecule. You must guarantee that all the threads
from one molecule bond before any other threads from the next molecule do.

In other words:
* If an oxygen thread arrives at the barrier when no hydrogen threads are
  present, it has to wait for two hydrogen threads.
* If a hydrogen thread arrives at the barrier when no other threads are
  present, it has to wait for an oxygen thread and another hydrogen thread.
We don’t have to worry about matching the threads up explicitly; that is, the
threads do not necessarily know which other threads they are paired up with.
The key is just that threads pass the barrier in complete sets; thus, if we
examine the sequence of threads that bond and divide them into groups of three,
each group should contain one oxygen and two hydrogen threads. Write
synchronization code for oxygen and hydrogen molecules that enforces these
constraints.

Example 1:
Input: "HOH"
Output: "HHO"
Explanation: "HOH" and "OHH" are also valid answers.

Example 2:
Input: "OOHHHH"
Output: "HHOHHO"
Explanation: "HOHHHO", "OHHHHO", "HHOHOH", "HOHHOH", "OHHHOH", "HHOOHH", "HOHOHH" and "OHHOHH" are also valid answers.

Constraints:
* Total length of input string will be 3n, where 1 ≤ n ≤ 20.
* Total number of H will be 2n in the input string.
* Total number of O will be n in the input string."""

from threading import Barrier, Semaphore

class H2O:
    def __init__(self):
        self.bar = Barrier(3)
        self.semH = Semaphore(2)
        self.semO = Semaphore(1)


    def hydrogen(self, releaseHydrogen: 'Callable[[], None]') -> None:
        self.semH.acquire()
        self.bar.wait()
        # releaseHydrogen() outputs "H". Do not change or remove this line.
        releaseHydrogen()
        self.semH.release()


    def oxygen(self, releaseOxygen: 'Callable[[], None]') -> None:
        self.semO.acquire()
        self.bar.wait()
        # releaseOxygen() outputs "O". Do not change or remove this line.
        releaseOxygen()
        self.semO.release()


"""1146. Snapshot Array (Medium)
Implement a SnapshotArray that supports the following interface:
* SnapshotArray(int length) initializes an array-like data structure with the
  given length. Initially, each element equals 0.
* void set(index, val) sets the element at the given index to be equal to val.
* int snap() takes a snapshot of the array and returns the snap_id: the total
  number of times we called snap() minus 1.
* int get(index, snap_id) returns the value at the given index, at the time we
  took the snapshot with the given snap_id

Example 1:
Input: ["SnapshotArray","set","snap","set","get"]
[[3],[0,5],[],[0,6],[0,0]]
Output: [null,null,0,null,5]
Explanation:
SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3
snapshotArr.set(0,5);  // Set array[0] = 5
snapshotArr.snap();  // Take a snapshot, return snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5

Constraints:
* 1 <= length <= 50000
* At most 50000 calls will be made to set, snap, and get.
* 0 <= index < length
* 0 <= snap_id < (the total number of times we call snap())
* 0 <= val <= 10^9"""

class SnapshotArray:

    def __init__(self, length: int):
        self.data = [[[0, 0]] for _ in range(length)]
        self.id = 0

    def set(self, index: int, val: int) -> None:
        if self.data[index][-1][0] == self.id: self.data[index][-1][1] = val
        else: self.data[index].append([self.id, val])

    def snap(self) -> int:
        self.id += 1
        return self.id - 1

    def get(self, index: int, snap_id: int) -> int:
        lo, hi = 0, len(self.data[index])
        while lo < hi:
            mid = lo + hi >> 1
            if self.data[index][mid][0] <= snap_id: lo = mid + 1
            else: hi = mid
        return self.data[index][lo-1][1]


"""1166. Design File System (Medium)
You are asked to design a file system that allows you to create new paths and
associate them with different values. The format of a path is one or more
concatenated strings of the form: / followed by one or more lowercase English
letters. For example, "/leetcode" and "/leetcode/problems" are valid paths
while an empty string "" and "/" are not. Implement the FileSystem class:
* bool createPath(string path, int value) Creates a new path and associates a
  value to it if possible and returns true. Returns false if the path already
  exists or its parent path doesn't exist.
* int get(string path) Returns the value associated with path or returns -1 if
  the path doesn't exist.

Example 1:
Input: ["FileSystem","createPath","get"]
       [[],["/a",1],["/a"]]
Output: [null,true,1]
Explanation:
FileSystem fileSystem = new FileSystem();
fileSystem.createPath("/a", 1); // return true
fileSystem.get("/a"); // return 1

Example 2:
Input: ["FileSystem","createPath","createPath","get","createPath","get"]
       [[],["/leet",1],["/leet/code",2],["/leet/code"],["/c/d",1],["/c"]]
Output: [null,true,true,2,false,-1]
Explanation:
FileSystem fileSystem = new FileSystem();
fileSystem.createPath("/leet", 1); // return true
fileSystem.createPath("/leet/code", 2); // return true
fileSystem.get("/leet/code"); // return 2
fileSystem.createPath("/c/d", 1); // return false because the parent path "/c" doesn't exist.
fileSystem.get("/c"); // return -1 because this path doesn't exist.

Constraints:
* The number of calls to the two functions is less than or equal to 10^4 in total.
* 2 <= path.length <= 100
* 1 <= value <= 10^9"""

class FileSystem:

    def __init__(self):
        self.mp = {}

    def createPath(self, path: str, value: int) -> bool:
        if path in self.mp: return False
        parent = path[:path.rfind("/")]
        if parent and parent not in self.mp: return False
        self.mp[path] = value
        return True

    def get(self, path: str) -> int:
        return self.mp.get(path, -1)


"""1195. Fizz Buzz Multithreaded (Medium)
Write a program that outputs the string representation of numbers from 1 to n,
however:
* If the number is divisible by 3, output "fizz".
* If the number is divisible by 5, output "buzz".
* If the number is divisible by both 3 and 5, output "fizzbuzz".
For example, for n = 15, we output: 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz,
11, fizz, 13, 14, fizzbuzz. Suppose you are given the following code:

class FizzBuzz {
  public FizzBuzz(int n) { ... }               // constructor
  public void fizz(printFizz) { ... }          // only output "fizz"
  public void buzz(printBuzz) { ... }          // only output "buzz"
  public void fizzbuzz(printFizzBuzz) { ... }  // only output "fizzbuzz"
  public void number(printNumber) { ... }      // only output the numbers
}

Implement a multithreaded version of FizzBuzz with four threads. The same
instance of FizzBuzz will be passed to four different threads:
* Thread A will call fizz() to check for divisibility of 3 and outputs fizz.
* Thread B will call buzz() to check for divisibility of 5 and outputs buzz.
* Thread C will call fizzbuzz() to check for divisibility of 3 and 5 and outputs fizzbuzz.
* Thread D will call number() which should only output the numbers."""

class FizzBuzz:
    def __init__(self, n: int):
        self.n = n
        self.fizzLock = Lock(); self.fizzLock.acquire()
        self.buzzLock = Lock(); self.buzzLock.acquire()
        self.fzbzLock = Lock(); self.fzbzLock.acquire()
        self.numberLock = Lock()

    # printFizz() outputs "fizz"
    def fizz(self, printFizz: 'Callable[[], None]') -> None:
        while True:
            self.fizzLock.acquire()
            if self.n == 0: break
            printFizz()
            self.numberLock.release()

    # printBuzz() outputs "buzz"
    def buzz(self, printBuzz: 'Callable[[], None]') -> None:
        while True:
            self.buzzLock.acquire()
            if self.n == 0: break
            printBuzz()
            self.numberLock.release()

    # printFizzBuzz() outputs "fizzbuzz"
    def fizzbuzz(self, printFizzBuzz: 'Callable[[], None]') -> None:
        while True:
            self.fzbzLock.acquire()
            if self.n == 0: break
            printFizzBuzz()
            self.numberLock.release()

    # printNumber(x) outputs "x", where x is an integer.
    def number(self, printNumber: 'Callable[[int], None]') -> None:
        for x in range(1, self.n+1):
            self.numberLock.acquire()
            if x % 15 == 0:
                self.fzbzLock.release()
            elif x % 3 == 0:
                self.fizzLock.release()
            elif x % 5 == 0:
                self.buzzLock.release()
            else:
                printNumber(x)
                self.numberLock.release()

        self.numberLock.acquire()
        self.n = 0
        self.fizzLock.release()
        self.buzzLock.release()
        self.fzbzLock.release()


"""1206. Design Skiplist (Hard)
Design a Skiplist without using any built-in libraries. A Skiplist is a data
structure that takes O(log(n)) time to add, erase and search. Comparing with
treap and red-black tree which has the same function and performance, the code
length of Skiplist can be comparatively short and the idea behind Skiplists are
just simple linked lists. For example: we have a Skiplist containing
[30,40,50,60,70,90] and we want to add 80 and 45 into it. You can see there are
many layers in the Skiplist. Each layer is a sorted linked list. With the help
of the top layers, add , erase and search can be faster than O(n). It can be
proven that the average time complexity for each operation is O(log(n)) and
space complexity is O(n). To be specific, your design should include these
functions:
* bool search(int target) : Return whether the target exists in the Skiplist or
  not.
* void add(int num): Insert a value into the SkipList.
* bool erase(int num): Remove a value in the Skiplist. If num does not exist in
  the Skiplist, do nothing and return false. If there exists multiple num
  values, removing any one of them is fine.
See more about Skiplist : https://en.wikipedia.org/wiki/Skip_list. Note that
duplicates may exist in the Skiplist, your code needs to handle this situation.

Example:
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // return false.
skiplist.add(4);
skiplist.search(1);   // return true.
skiplist.erase(0);    // return false, 0 is not in skiplist.
skiplist.erase(1);    // return true.
skiplist.search(1);   // return false, 1 has already been erased.

Constraints:
* 0 <= num, target <= 20000
* At most 50000 calls will be made to search, add, and erase."""

class ListNode:
    def __init__(self, val, cnt=1, next=None, down=None):
        self.val = val
        self.cnt = cnt
        self.next = next
        self.down = down


class Skiplist:

    def __init__(self):
        self.head = ListNode(-inf)
        self.p = 1/4

    def search(self, target: int) -> bool:
        node = self.head
        while node and node.val < target:
            if node.next and node.next.val <= target: node = node.next
            else: node = node.down
        return node

    def add(self, num: int) -> None:
        node = self.head
        stack = []
        while node and node.val < num:
            if node.next and node.next.val <= num: node = node.next
            else:
                stack.append(node)
                node = node.down
        if node:
            while node:
                node.cnt += 1
                node = node.down
        else:
            prev = None
            while True:
                if stack:
                    node = stack.pop()
                    node.next = prev = ListNode(num, down=prev, next=node.next)
                else:
                    self.head = ListNode(-inf, down=self.head)
                    self.head.next = prev = ListNode(num, down=prev)
                if random.random() >= self.p: break

    def erase(self, num: int) -> bool:
        node = self.head
        stack = []
        ans = False
        while node:
            if node.next and node.next.val < num: node = node.next
            else:
                stack.append(node)
                node = node.down
        while stack:
            node = stack.pop()
            if node.next and node.next.val == num:
                ans = True
                if node.next.cnt > 1: node.next.cnt -= 1
                else: node.next = node.next.next
            else: break
        return ans


"""1226. The Dining Philosophers (Medium)
Five silent philosophers sit at a round table with bowls of spaghetti. Forks
are placed between each pair of adjacent philosophers. Each philosopher must
alternately think and eat. However, a philosopher can only eat spaghetti when
they have both left and right forks. Each fork can be held by only one
philosopher and so a philosopher can use the fork only if it is not being used
by another philosopher. After an individual philosopher finishes eating, they
need to put down both forks so that the forks become available to others. A
philosopher can take the fork on their right or the one on their left as they
become available, but cannot start eating before getting both forks. Eating is
not limited by the remaining amounts of spaghetti or stomach space; an infinite
supply and an infinite demand are assumed. Design a discipline of behaviour (a
concurrent algorithm) such that no philosopher will starve; i.e., each can
forever continue to alternate between eating and thinking, assuming that no
philosopher can know when others may want to eat or think. The problem
statement and the image above are taken from wikipedia.org.

The philosophers' ids are numbered from 0 to 4 in a clockwise order. Implement
the function void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat,
putLeftFork, putRightFork) where:
* philosopher is the id of the philosopher who wants to eat.
* pickLeftFork and pickRightFork are functions you can call to pick the
  corresponding forks of that philosopher.
* eat is a function you can call to let the philosopher eat once he has picked
  both forks.
* putLeftFork and putRightFork are functions you can call to put down the
  corresponding forks of that philosopher.
* The philosophers are assumed to be thinking as long as they are not asking to
  eat (the function is not being called with their number).
Five threads, each representing a philosopher, will simultaneously use one
object of your class to simulate the process. The function may be called for
the same philosopher more than once, even before the last call ends.

Example 1:
Input: n = 1
Output: [[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]
Explanation: n is the number of times each philosopher will call the function.
             The output array describes the calls you made to the functions
             controlling the forks and the eat function, its format is:
             output[i] = [a, b, c] (three integers)
             - a is the id of a philosopher.
             - b specifies the fork: {1 : left, 2 : right}.
             - c specifies the operation: {1 : pick, 2 : put, 3 : eat}.

Constraints: 1 <= n <= 60"""

class DiningPhilosophers:

    def __init__(self):
        self.locks = [Lock() for _ in range(5)]

    # call the functions directly to execute, for example, eat()
    def wantsToEat(self,
                   philosopher: int,
                   pickLeftFork: 'Callable[[], None]',
                   pickRightFork: 'Callable[[], None]',
                   eat: 'Callable[[], None]',
                   putLeftFork: 'Callable[[], None]',
                   putRightFork: 'Callable[[], None]') -> None:
        small, large = min(philosopher, (philosopher + 1) % 5), max(philosopher, (philosopher + 1) % 5)
        with self.locks[small]:
            with self.locks[large]:
                pickLeftFork()
                pickRightFork()
                eat()
                putLeftFork()
                putRightFork()


"""1244. Design A Leaderboard (Medium)
Design a Leaderboard class, which has 3 functions:
* addScore(playerId, score): Update the leaderboard by adding score to the
  given player's score. If there is no player with such id in the leaderboard,
  add him to the leaderboard with the given score.
* top(K): Return the score sum of the top K players.
* reset(playerId): Reset the score of the player with the given id to 0 (in
  other words erase it from the leaderboard). It is guaranteed that the player
  was added to the leaderboard before calling this function.
Initially, the leaderboard is empty.

Example 1:
Input: ["Leaderboard","addScore","addScore","addScore","addScore","addScore","top","reset","reset","addScore","top"]
       [[],[1,73],[2,56],[3,39],[4,51],[5,4],[1],[1],[2],[2,51],[3]]
Output: [null,null,null,null,null,null,73,null,null,null,141]
Explanation:
Leaderboard leaderboard = new Leaderboard ();
leaderboard.addScore(1,73);   // leaderboard = [[1,73]];
leaderboard.addScore(2,56);   // leaderboard = [[1,73],[2,56]];
leaderboard.addScore(3,39);   // leaderboard = [[1,73],[2,56],[3,39]];
leaderboard.addScore(4,51);   // leaderboard = [[1,73],[2,56],[3,39],[4,51]];
leaderboard.addScore(5,4);    // leaderboard = [[1,73],[2,56],[3,39],[4,51],[5,4]];
leaderboard.top(1);           // returns 73;
leaderboard.reset(1);         // leaderboard = [[2,56],[3,39],[4,51],[5,4]];
leaderboard.reset(2);         // leaderboard = [[3,39],[4,51],[5,4]];
leaderboard.addScore(2,51);   // leaderboard = [[2,51],[3,39],[4,51],[5,4]];
leaderboard.top(3);           // returns 141 = 51 + 51 + 39;

Constraints:
* 1 <= playerId, K <= 10000
* It's guaranteed that K is less than or equal to the current number of players.
* 1 <= score <= 100
* There will be at most 1000 function calls."""

class Leaderboard:

    def __init__(self):
        self.mp = {}
        self.data = []

    def addScore(self, playerId: int, score: int) -> None:
        if playerId in self.mp:
            self.data.remove(self.mp[playerId])
            self.mp[playerId] += score
        else: self.mp[playerId] = score
        insort(self.data, self.mp[playerId])

    def top(self, K: int) -> int:
        return sum(self.data[-K:])

    def reset(self, playerId: int) -> None:
        self.data.remove(self.mp[playerId])
        self.mp.pop(playerId)


"""1357. Apply Discount Every n Orders (Medium)
There is a sale in a supermarket, there will be a discount every n customer.
There are some products in the supermarket where the id of the i-th product is
products[i] and the price per unit of this product is prices[i]. The system
will count the number of customers and when the n-th customer arrive he/she
will have a discount on the bill. (i.e if the cost is x the new cost is
x - (discount * x) / 100). Then the system will start counting customers again.
The customer orders a certain amount of each product where product[i] is the id
of the i-th product the customer ordered and amount[i] is the number of units
the customer ordered of that product. Implement the Cashier class:
* Cashier(int n, int discount, int[] products, int[] prices) Initializes the
  object with n, the discount, the products and their prices.
* double getBill(int[] product, int[] amount) returns the value of the bill and
  apply the discount if needed. Answers within 10^-5 of the actual value will
  be accepted as correct.

Example 1:
Input
["Cashier","getBill","getBill","getBill","getBill","getBill","getBill","getBill"]
[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]
Output
[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]
Explanation
Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);
cashier.getBill([1,2],[1,2]);                        // return 500.0, bill = 1 * 100 + 2 * 200 = 500.
cashier.getBill([3,7],[10,10]);                      // return 4000.0
cashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0, The bill was 1600.0 but as this is the third customer, he has a discount of 50% which means his bill is only 1600 - 1600 * (50 / 100) = 800.
cashier.getBill([4],[10]);                           // return 4000.0
cashier.getBill([7,3],[10,10]);                      // return 4000.0
cashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0, Bill was 14700.0 but as the system counted three more customers, he will have a 50% discount and the bill becomes 7350.0
cashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0

Constraints:
* 1 <= n <= 10^4
* 0 <= discount <= 100
* 1 <= products.length <= 200
* 1 <= products[i] <= 200
* There are not repeated elements in the array products.
* prices.length == products.length
* 1 <= prices[i] <= 1000
* 1 <= product.length <= products.length
* product[i] exists in products.
* amount.length == product.length
* 1 <= amount[i] <= 1000
* At most 1000 calls will be made to getBill.
* Answers within 10^-5 of the actual value will be accepted as correct."""

class Cashier:

    def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):
        self.k = 0 # counter
        self.n = n
        self.discount = discount
        self.prices = dict(zip(products, prices))

    def getBill(self, product: List[int], amount: List[int]) -> float:
        self.k += 1
        cost = sum(self.prices[i]*amt for i, amt in zip(product, amount))
        if self.k == self.n:
            cost *= 1 - self.discount/100
            self.k = 0
        return cost


"""1396. Design Underground System (Medium)
Implement the UndergroundSystem class:
* void checkIn(int id, string stationName, int t)
  + A customer with a card id equal to id, gets in the station stationName at time t.
  + A customer can only be checked into one place at a time.
* void checkOut(int id, string stationName, int t)
  + A customer with a card id equal to id, gets out from the station stationName at time t.
* double getAverageTime(string startStation, string endStation)
  + Returns the average time to travel between the startStation and the endStation.
  + The average time is computed from all the previous traveling from startStation to endStation that happened directly.
  + Call to getAverageTime is always valid.
You can assume all calls to checkIn and checkOut methods are consistent. If a
customer gets in at time t1 at some station, they get out at time t2 with
t2 > t1. All events happen in chronological order.

Example 1:
Input: ["UndergroundSystem","checkIn","checkIn","checkIn","checkOut","checkOut","checkOut","getAverageTime","getAverageTime","checkIn","getAverageTime","checkOut","getAverageTime"]
       [[],[45,"Leyton",3],[32,"Paradise",8],[27,"Leyton",10],[45,"Waterloo",15],[27,"Waterloo",20],[32,"Cambridge",22],["Paradise","Cambridge"],["Leyton","Waterloo"],[10,"Leyton",24],["Leyton","Waterloo"],[10,"Waterloo",38],["Leyton","Waterloo"]]
Output: [null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]
Explanation:
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(45, "Leyton", 3);
undergroundSystem.checkIn(32, "Paradise", 8);
undergroundSystem.checkIn(27, "Leyton", 10);
undergroundSystem.checkOut(45, "Waterloo", 15);
undergroundSystem.checkOut(27, "Waterloo", 20);
undergroundSystem.checkOut(32, "Cambridge", 22);
undergroundSystem.getAverageTime("Paradise", "Cambridge");       // return 14.00000. There was only one travel from "Paradise" (at time 8) to "Cambridge" (at time 22)
undergroundSystem.getAverageTime("Leyton", "Waterloo");          // return 11.00000. There were two travels from "Leyton" to "Waterloo", a customer with id=45 from time=3 to time=15 and a customer with id=27 from time=10 to time=20. So the average time is ( (15-3) + (20-10) ) / 2 = 11.00000
undergroundSystem.checkIn(10, "Leyton", 24);
undergroundSystem.getAverageTime("Leyton", "Waterloo");          // return 11.00000
undergroundSystem.checkOut(10, "Waterloo", 38);
undergroundSystem.getAverageTime("Leyton", "Waterloo");          // return 12.00000

Example 2:
Input: ["UndergroundSystem","checkIn","checkOut","getAverageTime","checkIn","checkOut","getAverageTime","checkIn","checkOut","getAverageTime"]
       [[],[10,"Leyton",3],[10,"Paradise",8],["Leyton","Paradise"],[5,"Leyton",10],[5,"Paradise",16],["Leyton","Paradise"],[2,"Leyton",21],[2,"Paradise",30],["Leyton","Paradise"]]
Output: [null,null,null,5.00000,null,null,5.50000,null,null,6.66667]
Explanation:
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(10, "Leyton", 3);
undergroundSystem.checkOut(10, "Paradise", 8);
undergroundSystem.getAverageTime("Leyton", "Paradise"); // return 5.00000
undergroundSystem.checkIn(5, "Leyton", 10);
undergroundSystem.checkOut(5, "Paradise", 16);
undergroundSystem.getAverageTime("Leyton", "Paradise"); // return 5.50000
undergroundSystem.checkIn(2, "Leyton", 21);
undergroundSystem.checkOut(2, "Paradise", 30);
undergroundSystem.getAverageTime("Leyton", "Paradise"); // return 6.66667

Constraints:
* There will be at most 20000 operations.
* 1 <= id, t <= 10^6
* All strings consist of uppercase and lowercase English letters, and digits.
* 1 <= stationName.length <= 10
* Answers within 10-5 of the actual value will be accepted as correct."""

class UndergroundSystem:

    def __init__(self):
        self.in_ = {}
        self.out = defaultdict(lambda: defaultdict(lambda: [0, 0]))

    def checkIn(self, id: int, stationName: str, t: int) -> None:
        self.in_[id] = (stationName, t)

    def checkOut(self, id: int, stationName: str, t: int) -> None:
        ss, tt = self.in_[id]
        self.out[stationName][ss][0] += t - tt
        self.out[stationName][ss][1] += 1

    def getAverageTime(self, startStation: str, endStation: str) -> float:
        s, c = self.out[endStation][startStation]
        return s/c


"""1476. Subrectangle Queries (Medium)
Implement the class SubrectangleQueries which receives a rows x cols rectangle
as a matrix of integers in the constructor and supports two methods:
1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)
  * Updates all values with newValue in the subrectangle whose upper left
    coordinate is (row1,col1) and bottom right coordinate is (row2,col2).
2. getValue(int row, int col)
  * Returns the current value of the coordinate (row,col) from the rectangle.

Example 1:
Input
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue","getValue"]
[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]
Output
[null,1,null,5,5,null,10,5]
Explanation
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);
// The initial rectangle (4x3) looks like:
// 1 2 1
// 4 3 4
// 3 2 1
// 1 1 1
subrectangleQueries.getValue(0, 2); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);
// After this update the rectangle looks like:
// 5 5 5
// 5 5 5
// 5 5 5
// 5 5 5
subrectangleQueries.getValue(0, 2); // return 5
subrectangleQueries.getValue(3, 1); // return 5
subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);
// After this update the rectangle looks like:
// 5   5   5
// 5   5   5
// 5   5   5
// 10  10  10
subrectangleQueries.getValue(3, 1); // return 10
subrectangleQueries.getValue(0, 2); // return 5

Example 2:
Input
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue"]
[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]
Output
[null,1,null,100,100,null,20]
Explanation
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);
subrectangleQueries.getValue(0, 0); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);
subrectangleQueries.getValue(0, 0); // return 100
subrectangleQueries.getValue(2, 2); // return 100
subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);
subrectangleQueries.getValue(2, 2); // return 20

Constraints:
* There will be at most 500 operations considering both methods: updateSubrectangle and getValue.
* 1 <= rows, cols <= 100
* rows == rectangle.length
* cols == rectangle[i].length
* 0 <= row1 <= row2 < rows
* 0 <= col1 <= col2 < cols
* 1 <= newValue, rectangle[i][j] <= 10^9
* 0 <= row < rows
* 0 <= col < cols"""

class SubrectangleQueries:

    def __init__(self, rectangle: List[List[int]]):
        self.rectangle = rectangle
        self.ops = []

    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:
        self.ops.append([row1, col1, row2, col2, newValue])

    def getValue(self, row: int, col: int) -> int:
        for r1, c1, r2, c2, val in reversed(self.ops):
            if r1 <= row <= r2 and c1 <= col <= c2: return val
        return self.rectangle[row][col]


"""1483. Kth Ancestor of a Tree Node (Hard)
You are given a tree with n nodes numbered from 0 to n - 1 in the form of a
parent array parent where parent[i] is the parent of ith node. The root of the
tree is node 0. Find the kth ancestor of a given node. The kth ancestor of a
tree node is the kth node in the path from that node to the root node.
Implement the TreeAncestor class:
* TreeAncestor(int n, int[] parent) Initializes the object with the number of
  nodes in the tree and the parent array.
* int getKthAncestor(int node, int k) return the kth ancestor of the given node
  node. If there is no such ancestor, return -1.

Example 1:
Input: ["TreeAncestor", "getKthAncestor", "getKthAncestor", "getKthAncestor"]
       [[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]
Output: [null, 1, 0, -1]
Explanation
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);
treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3
treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5
treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor

Constraints:
* 1 <= k <= n <= 5 * 10^4
* parent.length == n
* parent[0] == -1
* 0 <= parent[i] < n for all 0 < i < n
* 0 <= node < n
* There will be at most 5 * 10^4 queries."""

class TreeAncestor:

    def __init__(self, n: int, parent: List[int]):
        self.m = m = 1 + int(log2(n))
        self.lift = [[-1]*m for _ in range(n)] # binary lifting
        for j in range(m):
            for i in range(n):
                if j == 0: self.lift[i][j] = parent[i]
                elif self.lift[i][j-1] != -1: self.lift[i][j] = self.lift[self.lift[i][j-1]][j-1]

    def getKthAncestor(self, node: int, k: int) -> int:
        for i in range(self.m):
            if k & 1<<i and 0 <= node: node = self.lift[node][i]
        return node


"""1500. Design a File Sharing System (Medium)
We will use a file-sharing system to share a very large file which consists of
m small chunks with IDs from 1 to m. When users join the system, the system
should assign a unique ID to them. The unique ID should be used once for each
user, but when a user leaves the system, the ID can be reused again. Users can
request a certain chunk of the file, the system should return a list of IDs of
all the users who own this chunk. If the user receives a non-empty list of IDs,
they receive the requested chunk successfully.

Implement the FileSharing class:
* FileSharing(int m) Initializes the object with a file of m chunks.
* int join(int[] ownedChunks): A new user joined the system owning some chunks
  of the file, the system should assign an id to the user which is the smallest
  positive integer not taken by any other user. Return the assigned id.
* void leave(int userID): The user with userID will leave the system, you
  cannot take file chunks from them anymore.
* int[] request(int userID, int chunkID): The user userID requested the file
  chunk with chunkID. Return a list of the IDs of all users that own this chunk
  sorted in ascending order.

Example:
Input: ["FileSharing","join","join","join","request","request","leave","request","leave","join"]
       [[4],[[1,2]],[[2,3]],[[4]],[1,3],[2,2],[1],[2,1],[2],[[]]]
Output: [null,1,2,3,[2],[1,2],null,[],null,1]
Explanation:
FileSharing fileSharing = new FileSharing(4); // We use the system to share a file of 4 chunks.
fileSharing.join([1, 2]);    // A user who has chunks [1,2] joined the system, assign id = 1 to them and return 1.
fileSharing.join([2, 3]);    // A user who has chunks [2,3] joined the system, assign id = 2 to them and return 2.
fileSharing.join([4]);       // A user who has chunk [4] joined the system, assign id = 3 to them and return 3.
fileSharing.request(1, 3);   // The user with id = 1 requested the third file chunk, as only the user with id = 2 has the file, return [2] . Notice that user 1 now has chunks [1,2,3].
fileSharing.request(2, 2);   // The user with id = 2 requested the second file chunk, users with ids [1,2] have this chunk, thus we return [1,2].
fileSharing.leave(1);        // The user with id = 1 left the system, all the file chunks with them are no longer available for other users.
fileSharing.request(2, 1);   // The user with id = 2 requested the first file chunk, no one in the system has this chunk, we return empty list [].
fileSharing.leave(2);        // The user with id = 2 left the system.
fileSharing.join([]);        // A user who doesn't have any chunks joined the system, assign id = 1 to them and return 1. Notice that ids 1 and 2 are free and we can reuse them.

Constraints:
* 1 <= m <= 10^5
* 0 <= ownedChunks.length <= min(100, m)
* 1 <= ownedChunks[i] <= m
* Values of ownedChunks are unique.
* 1 <= chunkID <= m
* userID is guaranteed to be a user in the system if you assign the IDs
  correctly.
* At most 10^4 calls will be made to join, leave and request.
* Each call to leave will have a matching call for join.

Follow-up:
* What happens if the system identifies the user by their IP address instead of
  their unique ID and users disconnect and connect from the system with the
  same IP?
* If the users in the system join and leave the system frequently without
  requesting any chunks, will your solution still be efficient?
* If all users join the system one time, request all files, and then leave,
  will your solution still be efficient?
* If the system will be used to share n files where the ith file consists of
  m[i], what are the changes you have to make?"""

class FileSharing:

    def __init__(self, m: int):
        self.n = 1
        self.pq = [] # available id's below n (min-heap)
        self.chunks = {} # chunk-to-owner mapping
        self.owners = {} # owner-to-chunk mapping

    def join(self, ownedChunks: List[int]) -> int:
        if self.pq: userID = heappop(self.pq)
        else:
            userID = self.n
            self.n += 1
        self.owners[userID] = set(ownedChunks)
        for chunkID in ownedChunks:
            self.chunks.setdefault(chunkID, set()).add(userID)
        return userID

    def leave(self, userID: int) -> None:
        heappush(self.pq, userID)
        for chunkID in self.owners.pop(userID):
            self.chunks[chunkID].remove(userID)

    def request(self, userID: int, chunkID: int) -> List[int]:
        ans = sorted(self.chunks.get(chunkID, set()))
        if ans:
            self.chunks[chunkID].add(userID)
            self.owners[userID].add(chunkID)
        return ans


"""1586. Binary Search Tree Iterator II (Medium)
Implement the BSTIterator class that represents an iterator over the in-order
traversal of a binary search tree (BST):
* BSTIterator(TreeNode root) Initializes an object of the BSTIterator class.
  The root of the BST is given as part of the constructor. The pointer should
  be initialized to a non-existent number smaller than any element in the BST.
* boolean hasNext() Returns true if there exists a number in the traversal to
  the right of the pointer, otherwise returns false.
* int next() Moves the pointer to the right, then returns the number at the
  pointer.
* boolean hasPrev() Returns true if there exists a number in the traversal to
  the left of the pointer, otherwise returns false.
* int prev() Moves the pointer to the left, then returns the number at the
  pointer.
Notice that by initializing the pointer to a non-existent smallest number, the
first call to next() will return the smallest element in the BST. You may
assume that next() and prev() calls will always be valid. That is, there will
be at least a next/previous number in the in-order traversal when next()/prev()
is called.

Example 1:
Input: ["BSTIterator", "next", "next", "prev", "next", "hasNext", "next", "next", "next", "hasNext", "hasPrev", "prev", "prev"]
       [[[7, 3, 15, null, null, 9, 20]], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null]]
Output: [null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9]
Explanation:
// The underlined element is where the pointer currently is.
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); // state is   [3, 7, 9, 15, 20]
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 3
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7
bSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 3
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7
bSTIterator.hasNext(); // return true
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 9
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 15
bSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 20
bSTIterator.hasNext(); // return false
bSTIterator.hasPrev(); // return true
bSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 15
bSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 9

Constraints:
* The number of nodes in the tree is in the range [1, 10^5].
* 0 <= Node.val <= 10^6
* At most 10^5 calls will be made to hasNext, next, hasPrev, and prev.

Follow up: Could you solve the problem without precalculating the values of the
           tree?"""

class BSTIterator:

    def __init__(self, root: Optional[TreeNode]):
        self.i = -1
        self.vals = []
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def hasNext(self) -> bool:
        return self.i+1 < len(self.vals) or self.stack

    def next(self) -> int:
        self.i += 1
        if self.i == len(self.vals):
            node = self.stack.pop()
            self.vals.append(node.val)
            node = node.right
            while node:
                self.stack.append(node)
                node = node.left
        return self.vals[self.i]

    def hasPrev(self) -> bool:
        return 0 <= self.i-1

    def prev(self) -> int:
        self.i -= 1
        return self.vals[self.i]


"""1603. Design Parking System (Easy)
Design a parking system for a parking lot. The parking lot has three kinds of
parking spaces: big, medium, and small, with a fixed number of slots for each
size. Implement the ParkingSystem class:
* ParkingSystem(int big, int medium, int small) Initializes object of the
  ParkingSystem class. The number of slots for each parking space are given as
  part of the constructor.
* bool addCar(int carType) Checks whether there is a parking space of carType
  for the car that wants to get into the parking lot. carType can be of three
  kinds: big, medium, or small, which are represented by 1, 2, and 3
  respectively. A car can only park in a parking space of its carType. If there
  is no space available, return false, else park the car in that size space and
  return true.

Example 1:
Input: ["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]
       [[1, 1, 0], [1], [2], [3], [1]]
Output: [null, true, true, false, false]
Explanation:
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // return true because there is 1 available slot for a big car
parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car
parkingSystem.addCar(3); // return false because there is no available slot for a small car
parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.

Constraints:
* 0 <= big, medium, small <= 1000
* carType is 1, 2, or 3
* At most 1000 calls will be made to addCar"""

class ParkingSystem:

    def __init__(self, big: int, medium: int, small: int):
        self.space = [big, medium, small]

    def addCar(self, carType: int) -> bool:
        self.space[carType-1] -= 1 # space taken
        return self.space[carType-1] >= 0


"""1622. Fancy Sequence (Hard)
Write an API that generates fancy sequences using the append, addAll, and
multAll operations. Implement the Fancy class:
* Fancy() Initializes the object with an empty sequence.
* void append(val) Appends an integer val to the end of the sequence.
* void addAll(inc) Increments all existing values in the sequence by an integer
  inc.
* void multAll(m) Multiplies all existing values in the sequence by an integer
  m.
* int getIndex(idx) Gets the current value at index idx (0-indexed) of the
  sequence modulo 10^9 + 7. If the index is greater or equal than the length of
  the sequence, return -1.

Example 1:
Input: ["Fancy", "append", "addAll", "append", "multAll", "getIndex", "addAll", "append", "multAll", "getIndex", "getIndex", "getIndex"]
       [[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]
Output: [null, null, null, null, null, 10, null, null, null, 26, 34, 20]
Explanation
Fancy fancy = new Fancy();
fancy.append(2);   // fancy sequence: [2]
fancy.addAll(3);   // fancy sequence: [2+3] -> [5]
fancy.append(7);   // fancy sequence: [5, 7]
fancy.multAll(2);  // fancy sequence: [5*2, 7*2] -> [10, 14]
fancy.getIndex(0); // return 10
fancy.addAll(3);   // fancy sequence: [10+3, 14+3] -> [13, 17]
fancy.append(10);  // fancy sequence: [13, 17, 10]
fancy.multAll(2);  // fancy sequence: [13*2, 17*2, 10*2] -> [26, 34, 20]
fancy.getIndex(0); // return 26
fancy.getIndex(1); // return 34
fancy.getIndex(2); // return 20

Constraints:
* 1 <= val, inc, m <= 100
* 0 <= idx <= 10^5
* At most 10^5 calls total will be made to append, addAll, multAll, and getIndex."""

class Fancy:

    def __init__(self):
        self.data = []
        self.cmul = [1]
        self.csum = [0]
        self.mod = 1_000_000_007

    def append(self, val: int) -> None:
        self.data.append(val)
        self.cmul.append(self.cmul[-1])
        self.csum.append(self.csum[-1])

    def addAll(self, inc: int) -> None:
        self.csum[-1] += inc

    def multAll(self, m: int) -> None:
        self.cmul[-1] = (self.cmul[-1] * m) % self.mod
        self.csum[-1] = (self.csum[-1] * m) % self.mod

    def getIndex(self, idx: int) -> int:
        if idx < len(self.data):
            ratio = self.cmul[-1] * pow(self.cmul[idx], self.mod-2, self.mod) # Fermat's little theorem
            return ((self.data[idx] - self.csum[idx]) * ratio + self.csum[-1]) % self.mod
        return -1


"""1656. Design an Ordered Stream (Easy)
There are n (id, value) pairs, where id is an integer between 1 and n and value
is a string. No two pairs have the same id. Design a stream that takes the n
pairs in an arbitrary order, and returns the values over several calls in
increasing order of their ids. Implement the OrderedStream class:
* OrderedStream(int n) Constructs the stream to take n values and sets a current
  ptr to 1.
* String[] insert(int id, String value) Stores the new (id, value) pair in the
  stream. After storing the pair:
  + If the stream has stored a pair with id = ptr, then find the longest
    contiguous incrementing sequence of ids starting with id = ptr and return a
    list of the values associated with those ids in order. Then, update ptr to
    the last id + 1.
  + Otherwise, return an empty list.

Example:
Input: ["OrderedStream", "insert", "insert", "insert", "insert", "insert"]
       [[5], [3, "ccccc"], [1, "aaaaa"], [2, "bbbbb"], [5, "eeeee"], [4, "ddddd"]]
Output: [null, [], ["aaaaa"], ["bbbbb", "ccccc"], [], ["ddddd", "eeeee"]]
Explanation:
OrderedStream os= new OrderedStream(5);
os.insert(3, "ccccc"); // Inserts (3, "ccccc"), returns [].
os.insert(1, "aaaaa"); // Inserts (1, "aaaaa"), returns ["aaaaa"].
os.insert(2, "bbbbb"); // Inserts (2, "bbbbb"), returns ["bbbbb", "ccccc"].
os.insert(5, "eeeee"); // Inserts (5, "eeeee"), returns [].
os.insert(4, "ddddd"); // Inserts (4, "ddddd"), returns ["ddddd", "eeeee"].

Constraints:
* 1 <= n <= 1000
* 1 <= id <= n
* value.length == 5
* value consists only of lowercase letters.
* Each call to insert will have a unique id.
* Exactly n calls will be made to insert."""

class OrderedStream:

    def __init__(self, n: int):
        self.data = [None]*n
        self.ptr = 0

    def insert(self, id: int, value: str) -> List[str]:
        id -= 1
        self.data[id] = value
        if id == self.ptr:
            while self.ptr < len(self.data) and self.data[self.ptr]: self.ptr += 1 # update self.ptr
        return self.data[id:self.ptr]


"""1670. Design Front Middle Back Queue (Medium)
Design a queue that supports push and pop operations in the front, middle, and
back. Implement the FrontMiddleBack class:
* FrontMiddleBack() Initializes the queue.
* void pushFront(int val) Adds val to the front of the queue.
* void pushMiddle(int val) Adds val to the middle of the queue.
* void pushBack(int val) Adds val to the back of the queue.
* int popFront() Removes the front element of the queue and returns it. If the
  queue is empty, return -1.
* int popMiddle() Removes the middle element of the queue and returns it. If
  the queue is empty, return -1.
* int popBack() Removes the back element of the queue and returns it. If the
  queue is empty, return -1.
Notice that when there are two middle position choices, the operation is
performed on the frontmost middle position choice. For example:
* Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].
* Popping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].

Example 1:
Input: ["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"]
       [[], [1], [2], [3], [4], [], [], [], [], []]
Output: [null, null, null, null, null, 1, 3, 4, 2, -1]
Explanation:
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // return 1 -> [4, 3, 2]
q.popMiddle();    // return 3 -> [4, 2]
q.popMiddle();    // return 4 -> [2]
q.popBack();      // return 2 -> []
q.popFront();     // return -1 -> [] (The queue is empty)

Constraints:
* 1 <= val <= 10^9
* At most 1000 calls will be made to pushFront, pushMiddle, pushBack, popFront,
  popMiddle, and popBack."""

class FrontMiddleBackQueue:

    def __init__(self):
        self.d0 = deque()
        self.d1 = deque()

    def _balance(self):
        if len(self.d0) > len(self.d1): self.d1.appendleft(self.d0.pop())
        elif len(self.d0) + 1 < len(self.d1): self.d0.append(self.d1.popleft())

    def pushFront(self, val: int) -> None:
        self.d0.appendleft(val)
        self._balance()

    def pushMiddle(self, val: int) -> None:
        self.d0.append(val)
        self._balance()

    def pushBack(self, val: int) -> None:
        self.d1.append(val)
        self._balance()

    def popFront(self) -> int:
        if self.d0:
            ans = self.d0.popleft()
            self._balance()
            return ans
        elif self.d1: return self.d1.pop()
        else: return -1

    def popMiddle(self) -> int:
        if self.d0 and len(self.d0) == len(self.d1): return self.d0.pop()
        elif self.d1: return self.d1.popleft()
        return -1

    def popBack(self) -> int:
        ans = (self.d1 or [-1]).pop()
        self._balance()
        return ans


"""1724. Checking Existence of Edge Length Limited Paths II (Hard)
An undirected graph of n nodes is defined by edgeList, where
edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with
distance disi. Note that there may be multiple edges between two nodes, and
the graph may not be connected. Implement the DistanceLimitedPathsExist
class:
* DistanceLimitedPathsExist(int n, int[][] edgeList) Initializes the class
  with an undirected graph.
* boolean query(int p, int q, int limit) Returns true if there exists a
  path from p to q such that each edge on the path has a distance strictly
  less than limit, and otherwise false.

Example 1:
Input: ["DistanceLimitedPathsExist", "query", "query", "query", "query"]
       [[6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]], [2, 3, 2], [1, 3, 3], [2, 0, 3], [0, 5, 6]]
Output: [null, true, false, true, false]
Explanation:
DistanceLimitedPathsExist distanceLimitedPathsExist = new DistanceLimitedPathsExist(6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]);
distanceLimitedPathsExist.query(2, 3, 2); // return true. There is an edge from 2 to 3 of distance 1, which is less than 2.
distanceLimitedPathsExist.query(1, 3, 3); // return false. There is no way to go from 1 to 3 with distances strictly less than 3.
distanceLimitedPathsExist.query(2, 0, 3); // return true. There is a way to go from 2 to 0 with distance < 3: travel from 2 to 3 to 0.
distanceLimitedPathsExist.query(0, 5, 6); // return false. There are no paths from 0 to 5.

Constraints:
* 2 <= n <= 10^4
* 0 <= edgeList.length <= 10^4
* edgeList[i].length == 3
* 0 <= ui, vi, p, q <= n-1
* ui != vi
* p != q
* 1 <= disi, limit <= 10^9
* At most 104 calls will be made to query."""

class DistanceLimitedPathsExist:

    def find(self, p):
        if p != self.parent[p]:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def __init__(self, n: int, edgeList: List[List[int]]):
        tree = [[] for _ in range(n)] # minimum spanning tree
        self.parent = list(range(n))
        for u, v, w in sorted(edgeList, key=lambda x : x[2]):
            uu, vv = self.find(u), self.find(v)
            if uu != vv:
                tree[u].append((v, w))
                tree[v].append((u, w))
                self.parent[uu] = vv
        self.depth = [-1]*n
        self.lift = [[-1]*32 for _ in range(n)] # binary lifting
        self.weight = [[0]*32 for _ in range(n)]
        for u in range(n):
            if self.depth[u] == -1:
                stack = [(u, -1, 0)]
                while stack:
                    u, p, d = stack.pop()
                    self.depth[u] = d
                    for v, w in tree[u]:
                        if v != p:
                            self.lift[v][0] = u
                            self.weight[v][0] = w
                            for j in range(1, 32):
                                if self.lift[v][j-1] == -1: break
                                self.weight[v][j] = max(self.weight[v][j-1], self.weight[self.lift[v][j-1]][j-1])
                                self.lift[v][j] = self.lift[self.lift[v][j-1]][j-1]
                            stack.append((v, u, d+1))

    def query(self, p: int, q: int, limit: int) -> bool:
        if self.find(p) != self.find(q): return False
        if self.depth[p] > self.depth[q]: p, q = q, p
        wt = 0
        for i in range(32):
            if self.depth[q]-self.depth[p] & 1<<i and 0 <= q:
                wt = max(wt, self.weight[q][i])
                q = self.lift[q][i]
        if p == q: return wt < limit
        for i in range(31, -1, -1):
            if self.lift[p][i] != self.lift[q][i]:
                wt = max(wt, self.weight[p][i], self.weight[q][i])
                p, q = self.lift[p][i], self.lift[q][i]
        return max(wt, self.weight[p][0], self.weight[q][0]) < limit


"""1756. Design Most Recently Used Queue (Medium)
Design a queue-like data structure that moves the most recently used element to
the end of the queue. Implement the MRUQueue class:
* MRUQueue(int n) constructs the MRUQueue with n elements: [1,2,3,...,n].
* fetch(int k) moves the kth element (1-indexed) to the end of the queue and returns it.

Example 1:
Input: ["MRUQueue", "fetch", "fetch", "fetch", "fetch"]
       [[8], [3], [5], [2], [8]]
Output: [null, 3, 6, 2, 2]
Explanation:
MRUQueue mRUQueue = new MRUQueue(8); // Initializes the queue to [1,2,3,4,5,6,7,8].
mRUQueue.fetch(3); // Moves the 3rd element (3) to the end of the queue to become [1,2,4,5,6,7,8,3] and returns it.
mRUQueue.fetch(5); // Moves the 5th element (6) to the end of the queue to become [1,2,4,5,7,8,3,6] and returns it.
mRUQueue.fetch(2); // Moves the 2nd element (2) to the end of the queue to become [1,4,5,7,8,3,6,2] and returns it.
mRUQueue.fetch(8); // The 8th element (2) is already at the end of the queue so just return it.

Constraints:
* 1 <= n <= 2000
* 1 <= k <= n
* At most 2000 calls will be made to fetch.

Follow up: Finding an O(n) algorithm per fetch is a bit easy. Can you find an
           algorithm with a better complexity for each fetch call?"""

from sortedcontainers import SortedList # balanced BST

class MRUQueue:

    def __init__(self, n: int):
        self.data = SortedList((i, i) for i in range(1, n+1))

    def fetch(self, k: int) -> int:
        _, x = self.data.pop(k-1)
        i = self.data[-1][0] + 1 if self.data else 0
        self.data.add((i, x))
        return x


"""1797. Design Authentication Manager (Medium)
There is an authentication system that works with authentication tokens. For
each session, the user will receive a new authentication token that will expire
timeToLive seconds after the currentTime. If the token is renewed, the expiry
time will be extended to expire timeToLive seconds after the (potentially
different) currentTime. Implement the AuthenticationManager class:
* AuthenticationManager(int timeToLive) constructs the AuthenticationManager
  and sets the timeToLive.
* generate(string tokenId, int currentTime) generates a new token with the
  given tokenId at the given currentTime in seconds.
* renew(string tokenId, int currentTime) renews the unexpired token with the
  given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.
* countUnexpiredTokens(int currentTime) returns the number of unexpired tokens
  at the given currentTime.
Note that if a token expires at time t, and another action happens on time t
(renew or countUnexpiredTokens), the expiration takes place before the other
actions.

Example 1:
Input: ["AuthenticationManager", "renew", "generate", "countUnexpiredTokens", "generate", "renew", "renew", "countUnexpiredTokens"]
       [[5], ["aaa", 1], ["aaa", 2], [6], ["bbb", 7], ["aaa", 8], ["bbb", 10], [15]]
Output: [null, null, null, 1, null, null, null, 0]
Explanation:
AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.
authenticationManager.renew("aaa", 1); // No token exists with tokenId "aaa" at time 1, so nothing happens.
authenticationManager.generate("aaa", 2); // Generates a new token with tokenId "aaa" at time 2.
authenticationManager.countUnexpiredTokens(6); // The token with tokenId "aaa" is the only unexpired one at time 6, so return 1.
authenticationManager.generate("bbb", 7); // Generates a new token with tokenId "bbb" at time 7.
authenticationManager.renew("aaa", 8); // The token with tokenId "aaa" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.
authenticationManager.renew("bbb", 10); // The token with tokenId "bbb" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.
authenticationManager.countUnexpiredTokens(15); // The token with tokenId "bbb" expires at time 15, and the token with tokenId "aaa" expired at time 7, so currently no token is unexpired, so return 0.

Constraints:
* 1 <= timeToLive <= 10^8
* 1 <= currentTime <= 10^8
* 1 <= tokenId.length <= 5
* tokenId consists only of lowercase letters.
* All calls to generate will contain unique values of tokenId.
* The values of currentTime across all the function calls will be strictly increasing.
* At most 2000 calls will be made to all functions combined."""

class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.timeToLive = timeToLive
        self.tokens = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.tokens[tokenId] = currentTime + self.timeToLive

    def renew(self, tokenId: str, currentTime: int) -> None:
        if tokenId in self.tokens and self.tokens[tokenId] > currentTime:
            self.tokens[tokenId] = currentTime + self.timeToLive

    def countUnexpiredTokens(self, currentTime: int) -> int:
        for token in self.tokens.copy():
            if self.tokens[token] <= currentTime: # not expired yet
                self.tokens.pop(token)
        return len(self.tokens)


"""1825. Finding MK Average (Hard)
You are given two integers, m and k, and a stream of integers. You are tasked
to implement a data structure that calculates the MKAverage for the stream.
The MKAverage can be calculated using these steps:
* If the number of the elements in the stream is less than m you should
  consider the MKAverage to be -1. Otherwise, copy the last m elements of the
  stream to a separate container.
* Remove the smallest k elements and the largest k elements from the container.
* Calculate the average value for the rest of the elements rounded down to the
  nearest integer.

Implement the MKAverage class:
* MKAverage(int m, int k) Initializes the MKAverage object with an empty stream
  and the two integers m and k.
* void addElement(int num) Inserts a new element num into the stream.
* int calculateMKAverage() Calculates and returns the MKAverage for the current
  stream rounded down to the nearest integer.

Example 1:
Input
["MKAverage", "addElement", "addElement", "calculateMKAverage", "addElement", "calculateMKAverage", "addElement", "addElement", "addElement", "calculateMKAverage"]
[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]
Output
[null, null, null, -1, null, 3, null, null, null, 5]

Explanation
MKAverage obj = new MKAverage(3, 1);
obj.addElement(3);        // current elements are [3]
obj.addElement(1);        // current elements are [3,1]
obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist.
obj.addElement(10);       // current elements are [3,1,10]
obj.calculateMKAverage(); // The last 3 elements are [3,1,10].
                          // After removing smallest and largest 1 element the container will be [3].
                          // The average of [3] equals 3/1 = 3, return 3
obj.addElement(5);        // current elements are [3,1,10,5]
obj.addElement(5);        // current elements are [3,1,10,5,5]
obj.addElement(5);        // current elements are [3,1,10,5,5,5]
obj.calculateMKAverage(); // The last 3 elements are [5,5,5].
                          // After removing smallest and largest 1 element the container will be [5].
                          // The average of [5] equals 5/1 = 5, return 5

Constraints:
* 3 <= m <= 10^5
* 1 <= k*2 < m
* 1 <= num <= 10^5
* At most 10^5 calls will be made to addElement and calculateMKAverage."""

"""
class Fenwick:

    def __init__(self, n: int):
        self.nums = [0]*(n+1)

    def sum(self, k: int) -> int:
        k += 1
        ans = 0
        while k:
            ans += self.nums[k]
            k &= k-1 # unset last set bit
        return ans

    def add(self, k: int, x: int) -> None:
        k += 1
        while k < len(self.nums):
            self.nums[k] += x
            k += k & -k
"""

class MKAverage:

    def __init__(self, m: int, k: int):
        self.m = m
        self.k = k
        self.data = deque()
        self.value = Fenwick(10**5+1)
        self.index = Fenwick(10**5+1)

    def addElement(self, num: int) -> None:
        self.data.append(num)
        self.value.add(num, num)
        self.index.add(num, 1)
        if len(self.data) > self.m:
            num = self.data.popleft()
            self.value.add(num, -num)
            self.index.add(num, -1)

    def _getindex(self, k):
        lo, hi = 0, 10**5 + 1
        while lo < hi:
            mid = lo + hi >> 1
            if self.index.sum(mid) < k: lo = mid + 1
            else: hi = mid
        return lo

    def calculateMKAverage(self) -> int:
        if len(self.data) < self.m: return -1
        lo = self._getindex(self.k)
        hi = self._getindex(self.m-self.k)
        ans = self.value.sum(hi) - self.value.sum(lo)
        ans += (self.index.sum(lo) - self.k) * lo
        ans -= (self.index.sum(hi) - (self.m-self.k)) * hi
        return ans // (self.m - 2*self.k)


"""1845. Seat Reservation Manager (Medium)
Design a system that manages the reservation state of n seats that are numbered
from 1 to n. Implement the SeatManager class:
* SeatManager(int n) Initializes a SeatManager object that will manage n seats
  numbered from 1 to n. All seats are initially available.
* int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and
  returns its number.
* void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.

Example 1:
Input: ["SeatManager", "reserve", "reserve", "unreserve", "reserve", "reserve", "reserve", "reserve", "unreserve"]
       [[5], [], [], [2], [], [], [], [], [5]]
Output: [null, 1, 2, null, 2, 3, 4, 5, null]
Explanation:
SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.
seatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1.
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5].
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3.
seatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4.
seatManager.reserve();    // The only available seat is seat 5, so return 5.
seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].

Constraints:
* 1 <= n <= 10^5
* 1 <= seatNumber <= n
* For each call to reserve, it is guaranteed that there will be at least one unreserved seat.
* For each call to unreserve, it is guaranteed that seatNumber will be reserved.
* At most 10^5 calls in total will be made to reserve and unreserve."""

class SeatManager:

    def __init__(self, n: int):
        self.pq = list(range(1, n+1))

    def reserve(self) -> int:
        return heappop(self.pq)

    def unreserve(self, seatNumber: int) -> None:
        heappush(self.pq, seatNumber)


"""1865. Finding Pairs With a Certain Sum (Medium)
You are given two integer arrays nums1 and nums2. You are tasked to implement a
data structure that supports queries of two types:
* Add a positive integer to an element of a given index in the array nums2.
* Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given
  value (0 <= i < nums1.length and 0 <= j < nums2.length).

Implement the FindSumPairs class:
* FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object
  with two integer arrays nums1 and nums2.
* void add(int index, int val) Adds val to nums2[index], i.e., apply
  nums2[index] += val.
* int count(int tot) Returns the number of pairs (i, j) such that
  nums1[i] + nums2[j] == tot.

Example 1:
Input: ["FindSumPairs", "count", "add", "count", "count", "add", "add", "count"]
       [[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]
Output: [null, 8, null, 2, 1, null, null, 11]
Explanation:
FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);
findSumPairs.count(7);  // return 8; pairs (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) make 2 + 5 and pairs (5,1), (5,5) make 3 + 4
findSumPairs.add(3, 2); // now nums2 = [1,4,5,4,5,4]
findSumPairs.count(8);  // return 2; pairs (5,2), (5,4) make 3 + 5
findSumPairs.count(4);  // return 1; pair (5,0) makes 3 + 1
findSumPairs.add(0, 1); // now nums2 = [2,4,5,4,5,4]
findSumPairs.add(1, 1); // now nums2 = [2,5,5,4,5,4]
findSumPairs.count(7);  // return 11; pairs (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) make 2 + 5 and pairs (5,3), (5,5) make 3 + 4

Constraints:
* 1 <= nums1.length <= 1000
* 1 <= nums2.length <= 10^5
* 1 <= nums1[i] <= 10^9
* 1 <= nums2[i] <= 10^5
* 0 <= index < nums2.length
* 1 <= val <= 10^5
* 1 <= tot <= 10^9
* At most 1000 calls are made to add and count each."""

class FindSumPairs:

    def __init__(self, nums1: List[int], nums2: List[int]):
        self.nums1 = nums1
        self.nums2 = nums2

        self.freq = defaultdict(int)
        for x in nums2: self.freq[x] += 1

    def add(self, index: int, val: int) -> None:
        self.freq[self.nums2[index]] -= 1
        self.nums2[index] += val
        self.freq[self.nums2[index]] += 1

    def count(self, tot: int) -> int:
        ans = 0
        for x in self.nums1:
            ans += self.freq[tot - x]
        return ans


"""1912. Design Movie Rental System (Hard)
You have a movie renting company consisting of n shops. You want to implement a
renting system that supports searching for, booking, and returning movies. The
system should also support generating a report of the currently rented movies.
Each movie is given as a 2D integer array entries where
entries[i] = [shopi, moviei, pricei] indicates that there is a copy of movie
moviei at shop shopi with a rental price of pricei. Each shop carries at most
one copy of a movie moviei. The system should support the following functions:
* Search: Finds the cheapest 5 shops that have an unrented copy of a given movie.
  The shops should be sorted by price in ascending order, and in case of a tie,
  the one with the smaller shopi should appear first. If there are less than 5
  matching shops, then all of them should be returned. If no shop has an
  unrented copy, then an empty list should be returned.
* Rent: Rents an unrented copy of a given movie from a given shop.
* Drop: Drops off a previously rented copy of a given movie at a given shop.
* Report: Returns the cheapest 5 rented movies (possibly of the same movie ID)
  as a 2D list res where res[j] = [shopj, moviej] describes that the jth
  cheapest rented movie moviej was rented from the shop shopj. The movies in
  res should be sorted by price in ascending order, and in case of a tie, the
  one with the smaller shopj should appear first, and if there is still tie,
  the one with the smaller moviej should appear first. If there are fewer than
  5 rented movies, then all of them should be returned. If no movies are
  currently being rented, then an empty list should be returned.

Implement the MovieRentingSystem class:
* MovieRentingSystem(int n, int[][] entries) Initializes the MovieRentingSystem
  object with n shops and the movies in entries.
* List<Integer> search(int movie) Returns a list of shops that have an unrented
  copy of the given movie as described above.
* void rent(int shop, int movie) Rents the given movie from the given shop.
* void drop(int shop, int movie) Drops off a previously rented movie at the
  given shop.
* List<List<Integer>> report() Returns a list of cheapest rented movies as
  described above.
Note: The test cases will be generated such that rent will only be called if
the shop has an unrented copy of the movie, and drop will only be called if the
shop had previously rented out the movie.

Example 1:
Input: ["MovieRentingSystem", "search", "rent", "rent", "report", "drop", "search"]
       [[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]
Output: [null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]
Explanation:
MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);
movieRentingSystem.search(1);  // return [1, 0, 2], Movies of ID 1 are unrented at shops 1, 0, and 2. Shop 1 is cheapest; shop 0 and 2 are the same price, so order by shop number.
movieRentingSystem.rent(0, 1); // Rent movie 1 from shop 0. Unrented movies at shop 0 are now [2,3].
movieRentingSystem.rent(1, 2); // Rent movie 2 from shop 1. Unrented movies at shop 1 are now [1].
movieRentingSystem.report();   // return [[0, 1], [1, 2]]. Movie 1 from shop 0 is cheapest, followed by movie 2 from shop 1.
movieRentingSystem.drop(1, 2); // Drop off movie 2 at shop 1. Unrented movies at shop 1 are now [1,2].
movieRentingSystem.search(2);  // return [0, 1]. Movies of ID 2 are unrented at shops 0 and 1. Shop 0 is cheapest, followed by shop 1.

Constraints:
* 1 <= n <= 3 * 10^5
* 1 <= entries.length <= 10^5
* 0 <= shopi < n
* 1 <= moviei, pricei <= 10^4
* Each shop carries at most one copy of a movie moviei.
* At most 10^5 calls in total will be made to search, rent, drop and report."""

class MovieRentingSystem:

    def __init__(self, n: int, entries: List[List[int]]):
        self.avail = {}
        self.price = {}
        for shop, movie, price in entries:
            self.price[shop, movie] = price
            self.avail.setdefault(movie, SortedList()).add((price, shop))
        self.rented = SortedList()


    def search(self, movie: int) -> List[int]:
        return [x for _, x in self.avail.get(movie, [])[:5]]


    def rent(self, shop: int, movie: int) -> None:
        price = self.price[shop, movie]
        self.avail[movie].remove((price, shop))
        self.rented.add((price, shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        price = self.price[shop, movie]
        self.avail[movie].add((price, shop))
        self.rented.remove((price, shop, movie))

    def report(self) -> List[List[int]]:
        return [[x, y] for _, x, y in self.rented[:5]]


"""1993. Operations on Tree (Medium)
You are given a tree with n nodes numbered from 0 to n - 1 in the form of a
parent array parent where parent[i] is the parent of the ith node. The root of
the tree is node 0, so parent[0] = -1 since it has no parent. You want to
design a data structure that allows users to lock, unlock, and upgrade nodes in
the tree. The data structure should support the following functions:
* Lock: Locks the given node for the given user and prevents other users from
  locking the same node. You may only lock a node if the node is unlocked.
* Unlock: Unlocks the given node for the given user. You may only unlock a node
  if it is currently locked by the same user.
* Upgrade: Locks the given node for the given user and unlocks all of its
  descendants. You may only upgrade a node if all 3 conditions are true:
  + The node is unlocked,
  + It has at least one locked descendant (by any user), and
  + It does not have any locked ancestors.

Implement the LockingTree class:
* LockingTree(int[] parent) initializes the data structure with the parent
  array.
* lock(int num, int user) returns true if it is possible for the user with id
  user to lock the node num, or false otherwise. If it is possible, the node
  num will become locked by the user with id user.
* unlock(int num, int user) returns true if it is possible for the user with id
  user to unlock the node num, or false otherwise. If it is possible, the node
  num will become unlocked.
* upgrade(int num, int user) returns true if it is possible for the user with
  id user to upgrade the node num, or false otherwise. If it is possible, the
  node num will be upgraded.

Example 1:
Input: ["LockingTree", "lock", "unlock", "unlock", "lock", "upgrade", "lock"]
       [[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
Output: [null, true, false, true, true, true, false]
Explanation:
LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
lockingTree.lock(2, 2);    // return true because node 2 is unlocked.
                           // Node 2 will now be locked by user 2.
lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.
lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.
                           // Node 2 will now be unlocked.
lockingTree.lock(4, 5);    // return true because node 4 is unlocked.
                           // Node 4 will now be locked by user 5.
lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).
                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.
lockingTree.lock(0, 1);    // return false because node 0 is already locked.

Constraints:
* n == parent.length
* 2 <= n <= 2000
* 0 <= parent[i] <= n - 1 for i != 0
* parent[0] == -1
* 0 <= num <= n - 1
* 1 <= user <= 10^4
* parent represents a valid tree.
* At most 2000 calls in total will be made to lock, unlock, and upgrade."""

class LockingTree:

    def __init__(self, parent: List[int]):
        self.parent = parent
        self.tree = [[] for _ in parent]
        for i, x in enumerate(parent):
            if x != -1: self.tree[x].append(i)
        self.locked = {}

    def lock(self, num: int, user: int) -> bool:
        if num in self.locked: return False
        self.locked[num] = user
        return True

    def unlock(self, num: int, user: int) -> bool:
        if self.locked.get(num) != user: return False
        self.locked.pop(num)
        return True

    def upgrade(self, num: int, user: int) -> bool:
        if num in self.locked: return False # check for unlocked

        node = num
        while node != -1:
            if node in self.locked: break # locked ancestor
            node = self.parent[node]
        else:
            stack = [num]
            descendant = []
            while stack:
                node = stack.pop()
                if node in self.locked: descendant.append(node)
                for child in self.tree[node]: stack.append(child)
            if descendant:
                self.locked[num] = user # lock given node
                for node in descendant: self.locked.pop(node) # unlock all descendants
                return True
        return False # locked ancestor


"""2013. Detect Squares (Medium)
You are given a stream of points on the X-Y plane. Design an algorithm that:
* Adds new points from the stream into a data structure. Duplicate points are
  allowed and should be treated as different points.
* Given a query point, counts the number of ways to choose three points from
  the data structure such that the three points and the query point form an
  axis-aligned square with positive area.
An axis-aligned square is a square whose edges are all the same length and are
either parallel or perpendicular to the x-axis and y-axis.

Implement the DetectSquares class:
* DetectSquares() Initializes the object with an empty data structure.
* void add(int[] point) Adds a new point point = [x, y] to the data structure.
* int count(int[] point) Counts the number of ways to form axis-aligned squares
  with point point = [x, y] as described above.

Example 1:
Input: ["DetectSquares", "add", "add", "add", "count", "count", "add", "count"]
       [[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
Output: [null, null, null, null, 1, 0, null, 2]
Explanation:
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // return 1. You can choose:
                               //   - The first, second, and third points
detectSquares.count([14, 8]);  // return 0. The query point cannot form a
                               // square with any points in the data structure.
detectSquares.add([11, 2]);    // Adding duplicate points is allowed.
detectSquares.count([11, 10]); // return 2. You can choose:
                               //   - The first, second, and third points
                               //   - The first, third, and fourth points

Constraints:
* point.length == 2
* 0 <= x, y <= 1000
* At most 5000 calls in total will be made to add and count."""

class DetectSquares:

    def __init__(self):
        self.freq = {}

    def add(self, point: List[int]) -> None:
        point = tuple(point)
        self.freq[point] = 1 + self.freq.get(point, 0)

    def count(self, point: List[int]) -> int:
        ans = 0
        x, y = point
        for xx, yy in self.freq:
            if xx != x and abs(x-xx) == abs(y-yy):
                ans += self.freq[xx, yy] * self.freq.get((xx, y), 0) * self.freq.get((x, yy), 0)
        return ans


"""2034. Stock Price Fluctuation (Medium)
You are given a stream of records about a particular stock. Each record
contains a timestamp and the corresponding price of the stock at that timestamp.
Unfortunately due to the volatile nature of the stock market, the records do
not come in order. Even worse, some records may be incorrect. Another record
with the same timestamp may appear later in the stream correcting the price of
the previous wrong record. Design an algorithm that:
* Updates the price of the stock at a particular timestamp, correcting the
  price from any previous records at the timestamp.
* Finds the latest price of the stock based on the current records. The latest
  price is the price at the latest timestamp recorded.
* Finds the maximum price the stock has been based on the current records.
* Finds the minimum price the stock has been based on the current records.

Implement the StockPrice class:
* StockPrice() Initializes the object with no price records.
* void update(int timestamp, int price) Updates the price of the stock at the
  given timestamp.
* int current() Returns the latest price of the stock.
* int maximum() Returns the maximum price of the stock.
* int minimum() Returns the minimum price of the stock.

Example 1:
Input: ["StockPrice", "update", "update", "current", "maximum", "update", "maximum", "update", "minimum"]
       [[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]
Output: [null, null, null, 5, 10, null, 5, null, 2]
Explanation:
StockPrice stockPrice = new StockPrice();
stockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10].
stockPrice.update(2, 5);  // Timestamps are [1,2] with corresponding prices [10,5].
stockPrice.current();     // return 5, the latest timestamp is 2 with the price being 5.
stockPrice.maximum();     // return 10, the maximum price is 10 at timestamp 1.
stockPrice.update(1, 3);  // The previous timestamp 1 had the wrong price, so it is updated to 3.
                          // Timestamps are [1,2] with corresponding prices [3,5].
stockPrice.maximum();     // return 5, the maximum price is 5 after the correction.
stockPrice.update(4, 2);  // Timestamps are [1,2,4] with corresponding prices [3,5,2].
stockPrice.minimum();     // return 2, the minimum price is 2 at timestamp 4.

Constraints:
* 1 <= timestamp, price <= 10^9
* At most 10^5 calls will be made in total to update, current, maximum, and
  minimum.
* current, maximum, and minimum will be called only after update has been
  called at least once."""

class StockPrice:

    def __init__(self):
        self.mp = {}
        self.maxp = [] # max-heap
        self.minp = [] # min-heap
        self.latest = 0 # latest timestamp

    def update(self, timestamp: int, price: int) -> None:
        self.mp[timestamp] = price
        if self.latest <= timestamp: self.latest = timestamp
        heappush(self.maxp, (-price, timestamp))
        heappush(self.minp, (price, timestamp))

    def current(self) -> int:
        return self.mp[self.latest]

    def maximum(self) -> int:
        while self.mp[self.maxp[0][1]] != -self.maxp[0][0]: heappop(self.maxp)
        return -self.maxp[0][0]

    def minimum(self) -> int:
        while self.mp[self.minp[0][1]] != self.minp[0][0]: heappop(self.minp)
        return self.minp[0][0]


"""2043. Simple Bank System (Medium)
You have been tasked with writing a program for a popular bank that will
automate all its incoming transactions (transfer, deposit, and withdraw). The
bank has n accounts numbered from 1 to n. The initial balance of each account
is stored in a 0-indexed integer array balance, with the (i + 1)th account
having an initial balance of balance[i]. Execute all the valid transactions. A
transaction is valid if:
* The given account number(s) are between 1 and n, and
* The amount of money withdrawn or transferred from is less than or equal to
  the balance of the account.

Implement the Bank class:
* Bank(long[] balance) Initializes the object with the 0-indexed integer array
  balance.
* boolean transfer(int account1, int account2, long money) Transfers money
  dollars from the account numbered account1 to the account numbered account2.
  Return true if the transaction was successful, false otherwise.
* boolean deposit(int account, long money) Deposit money dollars into the
  account numbered account. Return true if the transaction was successful,
  false otherwise.
* boolean withdraw(int account, long money) Withdraw money dollars from the
  account numbered account. Return true if the transaction was successful,
  false otherwise.

Example 1:
Input: ["Bank", "withdraw", "transfer", "deposit", "transfer", "withdraw"]
       [[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]
Output: [null, true, true, true, false, false]
Explanation
Bank bank = new Bank([10, 100, 20, 50, 30]);
bank.withdraw(3, 10);    // return true, account 3 has a balance of $20, so it is valid to withdraw $10.
                         // Account 3 has $20 - $10 = $10.
bank.transfer(5, 1, 20); // return true, account 5 has a balance of $30, so it is valid to transfer $20.
                         // Account 5 has $30 - $20 = $10, and account 1 has $10 + $20 = $30.
bank.deposit(5, 20);     // return true, it is valid to deposit $20 to account 5.
                         // Account 5 has $10 + $20 = $30.
bank.transfer(3, 4, 15); // return false, the current balance of account 3 is $10,
                         // so it is invalid to transfer $15 from it.
bank.withdraw(10, 50);   // return false, it is invalid because account 10 does not exist.

Constraints:
* n == balance.length
* 1 <= n, account, account1, account2 <= 10^5
* 0 <= balance[i], money <= 10^12
* At most 10^4 calls will be made to each function transfer, deposit, withdraw."""

class Bank:

    def __init__(self, balance: List[int]):
        self.balance = balance

    def transfer(self, account1: int, account2: int, money: int) -> bool:
        if self.withdraw(account1, money):
            if self.deposit(account2, money): return True
            self.deposit(account1, money)

    def deposit(self, account: int, money: int) -> bool:
        if 1 <= account <= len(self.balance):
            self.balance[account-1] += money
            return True

    def withdraw(self, account: int, money: int) -> bool:
        if 1 <= account <= len(self.balance) and self.balance[account-1] >= money:
            self.balance[account-1] -= money
            return True


"""2069. Walking Robot Simulation II (Medium)
A width x height grid is on an XY-plane with the bottom-left cell at (0, 0) and
the top-right cell at (width - 1, height - 1). The grid is aligned with the
four cardinal directions ("North", "East", "South", and "West"). A robot is
initially at cell (0, 0) facing direction "East". The robot can be instructed
to move for a specific number of steps. For each step, it does the following.

Attempts to move forward one cell in the direction it is facing.
* If the cell the robot is moving to is out of bounds, the robot instead turns
  90 degrees counterclockwise and retries the step.
* After the robot finishes moving the number of steps required, it stops and
  awaits the next instruction.

Implement the Robot class:
* Robot(int width, int height) Initializes the width x height grid with the
  robot at (0, 0) facing "East".
* void move(int num) Instructs the robot to move forward num steps.
* int[] getPos() Returns the current cell the robot is at, as an array of
  length 2, [x, y].
* String getDir() Returns the current direction of the robot, "North", "East",
  "South", or "West".

Example 1:
Input: ["Robot", "move", "move", "getPos", "getDir", "move", "move", "move", "getPos", "getDir"]
       [[6, 3], [2], [2], [], [], [2], [1], [4], [], []]
Output: [null, null, null, [4, 0], "East", null, null, null, [1, 2], "West"]
Explanation
Robot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East.
robot.move(2);  // It moves two steps East to (2, 0), and faces East.
robot.move(2);  // It moves two steps East to (4, 0), and faces East.
robot.getPos(); // return [4, 0]
robot.getDir(); // return "East"
robot.move(2);  // It moves one step East to (5, 0), and faces East.
                // Moving the next step East would be out of bounds, so it turns and faces North.
                // Then, it moves one step North to (5, 1), and faces North.
robot.move(1);  // It moves one step North to (5, 2), and faces North (not West).
robot.move(4);  // Moving the next step North would be out of bounds, so it turns and faces West.
                // Then, it moves four steps West to (1, 2), and faces West.
robot.getPos(); // return [1, 2]
robot.getDir(); // return "West"

Constraints:
* 2 <= width, height <= 100
* 1 <= num <= 10^5
* At most 10^4 calls in total will be made to move, getPos, and getDir."""

class Robot:

    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.perimeter = 2*(width+height)-4
        self.pos = [0, 0]
        self.dir = [1, 0]

    def move(self, num: int) -> None:
        num %= self.perimeter
        if num == 0 and self.pos == [0, 0] and self.dir == [1, 0]: self.dir = [0, -1] # edge case
        while num:
            if self.dir == [1, 0]: most = self.width - self.pos[0] - 1
            elif self.dir == [0, 1]: most = self.height - self.pos[1] - 1
            elif self.dir == [-1, 0]: most = self.pos[0]
            else: most = self.pos[1]
            step = min(num, most)
            self.pos = [self.pos[0] + self.dir[0]*step, self.pos[1] + self.dir[1]*step]
            if num > most: self.dir = [-self.dir[1], self.dir[0]]
            num -= step

    def getPos(self) -> List[int]:
        return self.pos

    def getDir(self) -> str:
        if self.dir == [1, 0]: return "East"
        if self.dir == [0, 1]: return "North"
        if self.dir == [-1, 0]: return "West"
        return "South"


"""2080. Range Frequency Queries (Medium)
Design a data structure to find the frequency of a given value in a given
subarray. The frequency of a value in a subarray is the number of occurrences
of that value in the subarray. Implement the RangeFreqQuery class:
* RangeFreqQuery(int[] arr) Constructs an instance of the class with the given
  0-indexed integer array arr.
* int query(int left, int right, int value) Returns the frequency of value in
  the subarray arr[left...right].
A subarray is a contiguous sequence of elements within an array.
arr[left...right] denotes the subarray that contains the elements of nums
between indices left and right (inclusive).

Example 1:
Input: ["RangeFreqQuery", "query", "query"]
       [[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
Output: [null, 1, 2]
Explanation:
RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);
rangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4]
rangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array.

Constraints:
* 1 <= arr.length <= 10^5
* 1 <= arr[i], value <= 10^4
* 0 <= left <= right < arr.length
* At most 10^5 calls will be made to query"""

class RangeFreqQuery:

    def __init__(self, arr: List[int]):
        self.loc = defaultdict(list)
        for i, x in enumerate(arr): self.loc[x].append(i)

    def query(self, left: int, right: int, value: int) -> int:
        if value not in self.loc: return 0
        lo = bisect_left(self.loc[value], left)
        hi = bisect_right(self.loc[value], right)
        return hi - lo


"""2102. Sequentially Ordinal Rank Tracker (Hard)
A scenic location is represented by its name and attractiveness score, where
name is a unique string among all locations and score is an integer. Locations
can be ranked from the best to the worst. The higher the score, the better the
location. If the scores of two locations are equal, then the location with the
lexicographically smaller name is better. You are building a system that tracks
the ranking of locations with the system initially starting with no locations.
It supports:
* Adding scenic locations, one at a time.
* Querying the ith best location of all locations already added, where i is the
  number of times the system has been queried (including the current query).
For example, when the system is queried for the 4th time, it returns the 4th
best location of all locations already added. Note that the test data are
generated so that at any time, the number of queries does not exceed the number
of locations added to the system. Implement the SORTracker class:
* SORTracker() Initializes the tracker system.
* void add(string name, int score) Adds a scenic location with name and score
  to the system.
* string get() Queries and returns the ith best location, where i is the number
  of times this method has been invoked (including this invocation).

Example 1:
Input: ["SORTracker", "add", "add", "get", "add", "get", "add", "get", "add", "get", "add", "get", "get"]
       [[], ["bradford", 2], ["branford", 3], [], ["alps", 2], [], ["orland", 2], [], ["orlando", 3], [], ["alpine", 2], [], []]
Output: [null, null, null, "branford", null, "alps", null, "bradford", null, "bradford", null, "bradford", "orland"]
Explanation
SORTracker tracker = new SORTracker(); // Initialize the tracker system.
tracker.add("bradford", 2); // Add location with name="bradford" and score=2 to the system.
tracker.add("branford", 3); // Add location with name="branford" and score=3 to the system.
tracker.get();              // The sorted locations, from best to worst, are: branford, bradford.
                            // Note that branford precedes bradford due to its higher score (3 > 2).
                            // This is the 1st time get() is called, so return the best location: "branford".
tracker.add("alps", 2);     // Add location with name="alps" and score=2 to the system.
tracker.get();              // Sorted locations: branford, alps, bradford.
                            // Note that alps precedes bradford even though they have the same score (2).
                            // This is because "alps" is lexicographically smaller than "bradford".
                            // Return the 2nd best location "alps", as it is the 2nd time get() is called.
tracker.add("orland", 2);   // Add location with name="orland" and score=2 to the system.
tracker.get();              // Sorted locations: branford, alps, bradford, orland.
                            // Return "bradford", as it is the 3rd time get() is called.
tracker.add("orlando", 3);  // Add location with name="orlando" and score=3 to the system.
tracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.
                            // Return "bradford".
tracker.add("alpine", 2);   // Add location with name="alpine" and score=2 to the system.
tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.
                            // Return "bradford".
tracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.
                            // Return "orland".

Constraints:
* name consists of lowercase English letters, and is unique among all locations.
* 1 <= name.length <= 10
* 1 <= score <= 10^5
* At any time, the number of calls to get does not exceed the number of calls
  to add.
* At most 4 * 10^4 calls in total will be made to add and get."""

class SORTracker:

    def __init__(self):
        self.k = 0
        self.data = []

    def add(self, name: str, score: int) -> None:
        insort(self.data, (-score, name))

    def get(self) -> str:
        self.k += 1
        return self.data[self.k-1][1]


"""2227. Encrypt and Decrypt Strings (Hard)
You are given a character array keys containing unique characters and a string
array values containing strings of length 2. You are also given another string
array dictionary that contains all permitted original strings after decryption.
You should implement a data structure that can encrypt or decrypt a 0-indexed
string. A string is encrypted with the following process:
* For each character c in the string, we find the index i satisfying
  keys[i] == c in keys.
* Replace c with values[i] in the string.
Note that in case a character of the string is not present in keys, the
encryption process cannot be carried out, and an empty string "" is returned.

A string is decrypted with the following process:
* For each substring s of length 2 occurring at an even index in the string, we
  find an i such that values[i] == s. If there are multiple valid i, we choose
  any one of them. This means a string could have multiple possible strings it
  can decrypt to.
* Replace s with keys[i] in the string.

Implement the Encrypter class:
* Encrypter(char[] keys, String[] values, String[] dictionary) Initializes the
  Encrypter class with keys, values, and dictionary.
* String encrypt(String word1) Encrypts word1 with the encryption process
  described above and returns the encrypted string.
* int decrypt(String word2) Returns the number of possible strings word2 could
  decrypt to that also appear in dictionary.

Example 1:
Input: ["Encrypter", "encrypt", "decrypt"]
       [[['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]], ["abcd"], ["eizfeiam"]]
Output: [null, "eizfeiam", 2]
Explanation
Encrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]);
encrypter.encrypt("abcd"); // return "eizfeiam".
                           // 'a' maps to "ei", 'b' maps to "zf", 'c' maps to "ei", and 'd' maps to "am".
encrypter.decrypt("eizfeiam"); // return 2.
                              // "ei" can map to 'a' or 'c', "zf" maps to 'b', and "am" maps to 'd'.
                              // Thus, the possible strings after decryption are "abad", "cbad", "abcd", and "cbcd".
                              // 2 of those strings, "abad" and "abcd", appear in dictionary, so the answer is 2.

Constraints:
* 1 <= keys.length == values.length <= 26
* values[i].length == 2
* 1 <= dictionary.length <= 100
* 1 <= dictionary[i].length <= 100
* All keys[i] and dictionary[i] are unique.
* 1 <= word1.length <= 2000
* 1 <= word2.length <= 200
* All word1[i] appear in keys.
* word2.length is even.
* keys, values[i], dictionary[i], word1, and word2 only contain lowercase
  English letters.
* At most 200 calls will be made to encrypt and decrypt in total."""

class Encrypter:

    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):
        self.mp = dict(zip(keys, values))
        self.freq = Counter(map(self.encrypt, dictionary))

    def encrypt(self, word1: str) -> str:
        return ''.join(self.mp.get(ch, "##") for ch in word1)

    def decrypt(self, word2: str) -> int:
        return self.freq[word2]


"""2254. Design Video Sharing Platform (Hard)
You have a video sharing platform where users can upload and delete videos.
Each video is a string of digits, where the ith digit of the string represents
the content of the video at minute i. For example, the first digit represents
the content at minute 0 in the video, the second digit represents the content
at minute 1 in the video, and so on. Viewers of videos can also like and
dislike videos. Internally, the platform keeps track of the number of views,
likes, and dislikes on each video. When a video is uploaded, it is associated
with the smallest available integer videoId starting from 0. Once a video is
deleted, the videoId associated with that video can be reused for another
video. Implement the VideoSharingPlatform class:
* VideoSharingPlatform() Initializes the object.
* int upload(String video) The user uploads a video. Return the videoId
  associated with the video.
* void remove(int videoId) If there is a video associated with videoId, remove
  the video.
* String watch(int videoId, int startMinute, int endMinute) If there is a video
  associated with videoId, increase the number of views on the video by 1 and
  return the substring of the video string starting at startMinute and ending
  at min(endMinute, video.length - 1) (inclusive). Otherwise, return "-1".
* void like(int videoId) Increases the number of likes on the video associated
  with videoId by 1 if there is a video associated with videoId.
* void dislike(int videoId) Increases the number of dislikes on the video
  associated with videoId by 1 if there is a video associated with videoId.
* int[] getLikesAndDislikes(int videoId) Return a 0-indexed integer array
  values of length 2 where values[0] is the number of likes and values[1] is
  the number of dislikes on the video associated with videoId. If there is no
  video associated with videoId, return [-1].
* int getViews(int videoId) Return the number of views on the video associated
  with videoId, if there is no video associated with videoId, return -1.

Example 1:
Input: ["VideoSharingPlatform", "upload", "upload", "remove", "remove", "upload", "watch", "watch", "like", "dislike", "dislike", "getLikesAndDislikes", "getViews"]
       [[], ["123"], ["456"], [4], [0], ["789"], [1, 0, 5], [1, 0, 1], [1], [1], [1], [1], [1]]
Output: [null, 0, 1, null, null, 0, "456", "45", null, null, null, [1, 2], 2]
Explanation
VideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform();
videoSharingPlatform.upload("123");          // The smallest available videoId is 0, so return 0.
videoSharingPlatform.upload("456");          // The smallest available videoId is 1, so return 1.
videoSharingPlatform.remove(4);              // There is no video associated with videoId 4, so do nothing.
videoSharingPlatform.remove(0);              // Remove the video associated with videoId 0.
videoSharingPlatform.upload("789");          // Since the video associated with videoId 0 was deleted,
                                             // 0 is the smallest available videoId, so return 0.
videoSharingPlatform.watch(1, 0, 5);         // The video associated with videoId 1 is "456".
                                             // The video from minute 0 to min(5, 3 - 1) = 2 is "456", so return "453".
videoSharingPlatform.watch(1, 0, 1);         // The video associated with videoId 1 is "456".
                                             // The video from minute 0 to min(1, 3 - 1) = 1 is "45", so return "45".
videoSharingPlatform.like(1);                // Increase the number of likes on the video associated with videoId 1.
videoSharingPlatform.dislike(1);             // Increase the number of dislikes on the video associated with videoId 1.
videoSharingPlatform.dislike(1);             // Increase the number of dislikes on the video associated with videoId 1.
videoSharingPlatform.getLikesAndDislikes(1); // There is 1 like and 2 dislikes on the video associated with videoId 1, so return [1, 2].
videoSharingPlatform.getViews(1);            // The video associated with videoId 1 has 2 views, so return 2.

Example 2:
Input: ["VideoSharingPlatform", "remove", "watch", "like", "dislike", "getLikesAndDislikes", "getViews"]
       [[], [0], [0, 0, 1], [0], [0], [0], [0]]
Output: [null, null, "-1", null, null, [-1], -1]
Explanation
VideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform();
videoSharingPlatform.remove(0);              // There is no video associated with videoId 0, so do nothing.
videoSharingPlatform.watch(0, 0, 1);         // There is no video associated with videoId 0, so return "-1".
videoSharingPlatform.like(0);                // There is no video associated with videoId 0, so do nothing.
videoSharingPlatform.dislike(0);             // There is no video associated with videoId 0, so do nothing.
videoSharingPlatform.getLikesAndDislikes(0); // There is no video associated with videoId 0, so return [-1].
videoSharingPlatform.getViews(0);            // There is no video associated with videoId 0, so return -1.

Constraints:
* 1 <= video.length <= 10^5
* The sum of video.length over all calls to upload does not exceed 10^5
* video consists of digits.
* 0 <= videoId <= 10^5
* 0 <= startMinute < endMinute < 10^5
* startMinute < video.length
* The sum of endMinute - startMinute over all calls to watch does not exceed 10^5.
* At most 10^5 calls in total will be made to all functions."""

class VideoSharingPlatform:

    def __init__(self):
        self.pq = []
        self.videos = []

    def upload(self, video: str) -> int:
        if self.pq: videoId = heappop(self.pq)
        else:
            videoId = len(self.videos)
            self.videos.append([])
        self.videos[videoId] = [video, 0, 0, 0]
        return videoId

    def remove(self, videoId: int) -> None:
        if videoId < len(self.videos) and self.videos[videoId]:
            heappush(self.pq, videoId)
            self.videos[videoId] = None

    def watch(self, videoId: int, startMinute: int, endMinute: int) -> str:
        if videoId < len(self.videos) and self.videos[videoId]:
            self.videos[videoId][1] += 1
            return self.videos[videoId][0][startMinute : endMinute+1]
        return "-1"

    def like(self, videoId: int) -> None:
        if videoId < len(self.videos) and self.videos[videoId]:
            self.videos[videoId][2] += 1

    def dislike(self, videoId: int) -> None:
        if videoId < len(self.videos) and self.videos[videoId]:
            self.videos[videoId][3] += 1

    def getLikesAndDislikes(self, videoId: int) -> List[int]:
        if videoId < len(self.videos) and self.videos[videoId]:
            return self.videos[videoId][2:]
        return [-1]

    def getViews(self, videoId: int) -> int:
        if videoId < len(self.videos) and self.videos[videoId]:
            return self.videos[videoId][1]
        return -1


"""2276. Count Integers in Intervals (Hard)
Given an empty set of intervals, implement a data structure that can:
* Add an interval to the set of intervals.
* Count the number of integers that are present in at least one interval.
Implement the CountIntervals class:
* CountIntervals() Initializes the object with an empty set of intervals.
* void add(int left, int right) Adds the interval [left, right] to the set of
  intervals.
* int count() Returns the number of integers that are present in at least one
  interval.
Note that an interval [left, right] denotes all the integers x where
left <= x <= right.

Example 1:
Input: ["CountIntervals", "add", "add", "count", "add", "count"]
       [[], [2, 3], [7, 10], [], [5, 8], []]
Output: [null, null, null, 6, null, 8]
Explanation
CountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals.
countIntervals.add(2, 3);  // add [2, 3] to the set of intervals.
countIntervals.add(7, 10); // add [7, 10] to the set of intervals.
countIntervals.count();    // return 6
                           // the integers 2 and 3 are present in the interval [2, 3].
                           // the integers 7, 8, 9, and 10 are present in the interval [7, 10].
countIntervals.add(5, 8);  // add [5, 8] to the set of intervals.
countIntervals.count();    // return 8
                           // the integers 2 and 3 are present in the interval [2, 3].
                           // the integers 5 and 6 are present in the interval [5, 8].
                           // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10].
                           // the integers 9 and 10 are present in the interval [7, 10].

Constraints:
* 1 <= left <= right <= 10^9
* At most 10^5 calls in total will be made to add and count.
* At least one call will be made to count."""

class CountIntervals:

    def __init__(self):
        self.cnt = 0
        self.intervals = SortedList()

    def add(self, left: int, right: int) -> None:
        k = self.intervals.bisect_left((left, right))
        while k < len(self.intervals) and self.intervals[k][0] <= right:
            l, r = self.intervals.pop(k)
            self.cnt -= r - l + 1
            right = max(right, r)
        if k and left <= self.intervals[k-1][1]:
            l, r = self.intervals.pop(k-1)
            self.cnt -= r - l + 1
            left = l
            right = max(right, r)
        self.cnt += right - left + 1
        self.intervals.add((left, right))

    def count(self) -> int:
        return self.cnt


"""2286. Booking Concert Tickets in Groups (Hard)
A concert hall has n rows numbered from 0 to n - 1, each with m seats, numbered
from 0 to m - 1. You need to design a ticketing system that can allocate seats
in the following cases:
* If a group of k spectators can sit together in a row.
* If every member of a group of k spectators can get a seat. They may or may
  not sit together.
Note that the spectators are very picky. Hence:
* They will book seats only if each member of their group can get a seat with
  row number less than or equal to maxRow. maxRow can vary from group to group.
* In case there are multiple rows to choose from, the row with the smallest
  number is chosen. If there are multiple seats to choose in the same row, the
  seat with the smallest number is chosen.
Implement the BookMyShow class:
* BookMyShow(int n, int m) Initializes the object with n as number of rows and
  m as number of seats per row.
* int[] gather(int k, int maxRow) Returns an array of length 2 denoting the
  row and seat number (respectively) of the first seat being allocated to the k
  members of the group, who must sit together. In other words, it returns the
  smallest possible r and c such that all [c, c + k - 1] seats are valid and
  empty in row r, and r <= maxRow. Returns [] in case it is not possible to
  allocate seats to the group.
* boolean scatter(int k, int maxRow) Returns true if all k members of the group
  can be allocated seats in rows 0 to maxRow, who may or may not sit together.
  If the seats can be allocated, it allocates k seats to the group with the
  smallest row numbers, and the smallest possible seat numbers in each row.
  Otherwise, returns false.

Example 1:
Input: ["BookMyShow", "gather", "gather", "scatter", "scatter"]
       [[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]
Output: [null, [0, 0], [], true, false]
Explanation
BookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each
bms.gather(4, 0); // return [0, 0]
                  // The group books seats [0, 3] of row 0.
bms.gather(2, 0); // return []
                  // There is only 1 seat left in row 0,
                  // so it is not possible to book 2 consecutive seats.
bms.scatter(5, 1); // return True
                   // The group books seat 4 of row 0 and seats [0, 3] of row 1.
bms.scatter(5, 1); // return False
                   // There is only one seat left in the hall.

Constraints:
* 1 <= n <= 5 * 10^4
* 1 <= m, k <= 10^9
* 0 <= maxRow <= n - 1
* At most 5 * 10^4 calls in total will be made to gather and scatter."""

class SegTree:

    def __init__(self, arr: List[int]):
        """Build the segmentation tree."""
        self.n = n = len(arr)
        self.mtree = [0]*(4*n) # for max
        self.stree = [0]*(4*n) # for sum
        self._build(arr, 0, 0, n)

    def _build(self, arr: List[int], k: int, lo: int, hi: int) -> None:
        """Build segment tree from array."""
        if lo+1 == hi:
            self.mtree[k] = self.stree[k] = arr[lo]
            return
        mid = lo + hi >> 1
        self._build(arr, 2*k+1, lo, mid)
        self._build(arr, 2*k+2, mid, hi)
        self.mtree[k] = max(self.mtree[2*k+1], self.mtree[2*k+2])
        self.stree[k] = self.stree[2*k+1] + self.stree[2*k+2]

    def update(self, i: int, delta: int, k: int, lo: int, hi: int) -> None:
        """Update segment tree when array value at i is incresed by delta."""
        if lo+1 == hi: # leaf node
            self.mtree[k] += delta
            self.stree[k] += delta
            return
        mid = lo + hi >> 1
        if i < mid: self.update(i, delta, 2*k+1, lo, mid)
        else: self.update(i, delta, 2*k+2, mid, hi)
        self.mtree[k] = max(self.mtree[2*k+1], self.mtree[2*k+2])
        self.stree[k] = self.stree[2*k+1] + self.stree[2*k+2]

    def query_max(self, qlo: int, qhi: int, k: int, lo: int, hi: int, val: int) -> int:
        """Query max value from qlo (inclusive) and qhi (exclusive)."""
        if qhi <= lo or  hi <= qlo: return -1
        if qlo <= lo and hi <= qhi:
            if self.mtree[k] < val: return -1
            while lo+1 < hi:
                mid = lo + hi >> 1
                if self.mtree[2*k+1] >= val:
                    k = 2*k+1
                    hi = mid
                else:
                    k = 2*k+2
                    lo = mid
            return lo
        mid = lo + hi >> 1
        ans = self.query_max(qlo, qhi, 2*k+1, lo, mid, val)
        if ans != -1: return ans
        return self.query_max(qlo, qhi, 2*k+2, mid, hi, val)

    def query_sum(self, qlo: int, qhi: int, k: int, lo: int, hi: int, val: int) -> int:
        """Query sum value from qlo (inclusive) and qhi (exclusive)."""
        if qhi <= lo or  hi <= qlo: return 0
        if qlo <= lo and hi <= qhi: return self.stree[k]
        mid = lo + hi >> 1
        return self.query_sum(qlo, qhi, 2*k+1, lo, mid) + self.query_sum(qlo, qhi, 2*k+2, mid, hi)


class BookMyShow:

    def __init__(self, n: int, m: int):
        self.i = 0
        self.n = n
        self.m = m
        self.seats = [m]*n
        self.tree = SegTree(self.seats)

    def gather(self, k: int, maxRow: int) -> List[int]:
        lo = self.tree.query_max(self.i, maxRow+1, 0, 0, self.n, k)
        if lo == -1: return []
        ans = [lo, self.m - self.seats[lo]]
        self.seats[lo] -= k
        self.tree.update(lo, -k, 0, 0, self.n)
        if lo == self.i and self.seats[lo] == 0: self.i += 1
        return ans

    def scatter(self, k: int, maxRow: int) -> bool:
        avail = self.tree.query_sum(self.i, maxRow+1, 0, 0, self.n)
        if avail < k: return False
        lo, hi = self.i, maxRow
        while lo < hi:
            mid = lo + hi >> 1
            y = self.tree.query_sum(self.i, mid+1, 0, 0, self.n)
            if y < k: lo = mid + 1
            else: hi = mid
        k -= self.tree.query_sum(self.i, lo, 0, 0, self.n)
        self.seats[lo] -= k
        self.tree.update(lo, -k, 0, 0, self.n)
        self.i = lo
        if not self.seats[lo]: self.i += 1
        return True


"""2296. Design a Text Editor (Hard)
Design a text editor with a cursor that can do the following:
* Add text to where the cursor is.
* Delete text from where the cursor is (simulating the backspace key).
* Move the cursor either left or right.
When deleting text, only characters to the left of the cursor will be deleted.
The cursor will also remain within the actual text and cannot be moved beyond
it. More formally, we have that 0 <= cursor.position <= currentText.length
always holds. Implement the TextEditor class:
* TextEditor() Initializes the object with empty text.
* void addText(string text) Appends text to where the cursor is. The cursor
  ends to the right of text.
* int deleteText(int k) Deletes k characters to the left of the cursor. Returns
  the number of characters actually deleted.
* string cursorLeft(int k) Moves the cursor to the left k times. Returns the
  last min(10, len) characters to the left of the cursor, where len is the
  number of characters to the left of the cursor.
* string cursorRight(int k) Moves the cursor to the right k times. Returns the
  last min(10, len) characters to the left of the cursor, where len is the
  number of characters to the left of the cursor.

Example 1:
Input: ["TextEditor", "addText", "deleteText", "addText", "cursorRight", "cursorLeft", "deleteText", "cursorLeft", "cursorRight"]
       [[], ["leetcode"], [4], ["practice"], [3], [8], [10], [2], [6]]
Output: [null, null, 4, null, "etpractice", "leet", 4, "", "practi"]
Explanation:
TextEditor textEditor = new TextEditor(); // The current text is "|". (The '|' character represents the cursor)
textEditor.addText("leetcode"); // The current text is "leetcode|".
textEditor.deleteText(4); // return 4
                          // The current text is "leet|".
                          // 4 characters were deleted.
textEditor.addText("practice"); // The current text is "leetpractice|".
textEditor.cursorRight(3); // return "etpractice"
                           // The current text is "leetpractice|".
                           // The cursor cannot be moved beyond the actual text and thus did not move.
                           // "etpractice" is the last 10 characters to the left of the cursor.
textEditor.cursorLeft(8); // return "leet"
                          // The current text is "leet|practice".
                          // "leet" is the last min(10, 4) = 4 characters to the left of the cursor.
textEditor.deleteText(10); // return 4
                           // The current text is "|practice".
                           // Only 4 characters were deleted.
textEditor.cursorLeft(2); // return ""
                          // The current text is "|practice".
                          // The cursor cannot be moved beyond the actual text and thus did not move.
                          // "" is the last min(10, 0) = 0 characters to the left of the cursor.
textEditor.cursorRight(6); // return "practi"
                           // The current text is "practi|ce".
                           // "practi" is the last min(10, 6) = 6 characters to the left of the cursor.

Constraints:
* 1 <= text.length, k <= 40
* text consists of lowercase English letters.
* At most 2 * 10^4 calls in total will be made to addText, deleteText,
  cursorLeft and cursorRight.

Follow-up: Could you find a solution with time complexity of O(k) per call?"""

class TextEditor:

    def __init__(self):
        self.left = []
        self.right = []

    def addText(self, text: str) -> None:
        for ch in text: self.left.append(ch)

    def deleteText(self, k: int) -> int:
        ans = 0
        while self.left and k:
            k -= 1
            self.left.pop()
            ans += 1
        return ans

    def cursorLeft(self, k: int) -> str:
        while k and self.left:
            k -= 1
            self.right.append(self.left.pop())
        return ''.join(self.left[-min(10, len(self.left)):])

    def cursorRight(self, k: int) -> str:
        while k and self.right:
            k -= 1
            self.left.append(self.right.pop())
        return ''.join(self.left[-min(10, len(self.left)):])


"""2336. Smallest Number in Infinite Set (Medium)
You have a set which contains all positive integers [1, 2, 3, 4, 5, ...].
Implement the SmallestInfiniteSet class:
* SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain
  all positive integers.
* int popSmallest() Removes and returns the smallest integer contained in the
  infinite set.
* void addBack(int num) Adds a positive integer num back into the infinite set,
  if it is not already in the infinite set.

Example 1:
Input: ["SmallestInfiniteSet", "addBack", "popSmallest", "popSmallest", "popSmallest", "addBack", "popSmallest", "popSmallest", "popSmallest"]
       [[], [2], [], [], [], [1], [], [], []]
Output: [null, null, 1, 2, 3, null, 1, 4, 5]
Explanation
SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();
smallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.
smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.
smallestInfiniteSet.addBack(1);    // 1 is added back to the set.
smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and
                                   // is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.

Constraints:
* 1 <= num <= 1000
* At most 1000 calls will be made in total to popSmallest and addBack."""

class SmallestInfiniteSet:

    def __init__(self):
        self.x = 1
        self.seen = SortedList()

    def popSmallest(self) -> int:
        if self.seen: return self.seen.pop(0)
        else:
            self.x += 1
            return self.x - 1

    def addBack(self, num: int) -> None:
        if num < self.x and num not in self.seen:
            self.seen.add(num)


"""2349. Design a Number Container System (Medium)
Design a number container system that can do the following:
* Insert or Replace a number at the given index in the system.
* Return the smallest index for the given number in the system.

Implement the NumberContainers class:
* NumberContainers() Initializes the number container system.
* void change(int index, int number) Fills the container at index with the
  number. If there is already a number at that index, replace it.
* int find(int number) Returns the smallest index for the given number, or -1
  if there is no index that is filled by number in the system.

Example 1:
Input: ["NumberContainers", "find", "change", "change", "change", "change", "find", "change", "find"]
       [[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]
Output: [null, -1, null, null, null, null, 1, null, 2]
Explanation:
NumberContainers nc = new NumberContainers();
nc.find(10); // There is no index that is filled with number 10. Therefore, we
             // return -1.
nc.change(2, 10); // Your container at index 2 will be filled with number 10.
nc.change(1, 10); // Your container at index 1 will be filled with number 10.
nc.change(3, 10); // Your container at index 3 will be filled with number 10.
nc.change(5, 10); // Your container at index 5 will be filled with number 10.
nc.find(10); // Number 10 is at the indices 1, 2, 3, and 5. Since the smallest
             // index that is filled with 10 is 1, we return 1.
nc.change(1, 20); // Your container at index 1 will be filled with number 20.
                  // Note that index 1 was filled with 10 and then replaced
                  // with 20.
nc.find(10); // Number 10 is at the indices 2, 3, and 5. The smallest index
             // that is filled with 10 is 2. Therefore, we return 2.

Constraints:
* 1 <= index, number <= 10^9
* At most 105 calls will be made in total to change and find."""

class NumberContainers:

    def __init__(self):
        self.mp = {} # index-to-number
        self.data = defaultdict(SortedList) # number-to-index

    def change(self, index: int, number: int) -> None:
        if index in self.mp: self.data[self.mp[index]].remove(index)
        self.mp[index] = number
        self.data[number].add(index)

    def find(self, number: int) -> int:
        if self.data[number]: return self.data[number][0]
        return -1


"""2353. Design a Food Rating System (Medium)
Design a food rating system that can do the following:
* Modify the rating of a food item listed in the system.
* Return the highest-rated food item for a type of cuisine in the system.
Implement the FoodRatings class:
* FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the
  system. The food items are described by foods, cuisines and ratings, all of
  which have a length of n.
* foods[i] is the name of the ith food,
* cuisines[i] is the type of cuisine of the ith food, and
* ratings[i] is the initial rating of the ith food.
* void changeRating(String food, int newRating) Changes the rating of the food
  item with the name food.
* String highestRated(String cuisine) Returns the name of the food item that
  has the highest rating for the given type of cuisine. If there is a tie,
  return the item with the lexicographically smaller name.
Note that a string x is lexicographically smaller than string y if x comes
before y in dictionary order, that is, either x is a prefix of y, or if i is
the first position such that x[i] != y[i], then x[i] comes before y[i] in
alphabetic order.

Example 1:
Input: ["FoodRatings", "highestRated", "highestRated", "changeRating", "highestRated", "changeRating", "highestRated"]
       [[["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]], ["korean"], ["japanese"], ["sushi", 16], ["japanese"], ["ramen", 16], ["japanese"]]
Output: [null, "kimchi", "ramen", null, "sushi", null, "ramen"]
Explanation:
FoodRatings foodRatings = new FoodRatings(["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]);
foodRatings.highestRated("korean"); // return "kimchi"
                                    // "kimchi" is the highest rated korean food with a rating of 9.
foodRatings.highestRated("japanese"); // return "ramen"
                                      // "ramen" is the highest rated japanese food with a rating of 14.
foodRatings.changeRating("sushi", 16); // "sushi" now has a rating of 16.
foodRatings.highestRated("japanese"); // return "sushi"
                                      // "sushi" is the highest rated japanese food with a rating of 16.
foodRatings.changeRating("ramen", 16); // "ramen" now has a rating of 16.
foodRatings.highestRated("japanese"); // return "ramen"
                                      // Both "sushi" and "ramen" have a rating of 16.
                                      // However, "ramen" is lexicographically smaller than "sushi".

Constraints:
* 1 <= n <= 2 * 10^4
* n == foods.length == cuisines.length == ratings.length
* 1 <= foods[i].length, cuisines[i].length <= 10
* foods[i], cuisines[i] consist of lowercase English letters.
* 1 <= ratings[i] <= 10^8
* All the strings in foods are distinct.
* food will be the name of a food item in the system across all calls to
  changeRating.
* cuisine will be a type of cuisine of at least one food item in the system
  across all calls to highestRated.
* At most 2 * 10^4 calls in total will be made to changeRating and highestRated."""

class FoodRatings:

    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):
        self.mp = {}
        self.data = defaultdict(SortedList)
        for food, cuisine, rating in zip(foods, cuisines, ratings):
            self.mp[food] = (cuisine, rating)
            self.data[cuisine].add((-rating, food))

    def changeRating(self, food: str, newRating: int) -> None:
        cuisine, rating = self.mp[food]
        self.mp[food] = cuisine, newRating
        self.data[cuisine].remove((-rating, food))
        self.data[cuisine].add((-newRating, food))

    def highestRated(self, cuisine: str) -> str:
        return self.data[cuisine][0][1]


"""2408. Design SQL (Medium)
You are given n tables represented with two arrays names and columns, where
names[i] is the name of the ith table and columns[i] is the number of columns
of the ith table. You should be able to perform the following operations:
* Insert a row in a specific table. Each row you insert has an id. The id is
  assigned using an auto-increment method where the id of the first inserted
  row is 1, and the id of each other row inserted into the same table is the id
  of the last inserted row (even if it was deleted) plus one.
* Delete a row from a specific table. Note that deleting a row does not affect
  the id of the next inserted row.
* Select a specific cell from any table and return its value.

Implement the SQL class:
* SQL(String[] names, int[] columns) Creates the n tables.
* void insertRow(String name, String[] row) Adds a row to the table name. It is
  guaranteed that the table will exist, and the size of the array row is equal
  to the number of columns in the table.
* void deleteRow(String name, int rowId) Removes the row rowId from the table
  name. It is guaranteed that the table and row will exist.
* String selectCell(String name, int rowId, int columnId) Returns the value of
  the cell in the row rowId and the column columnId from the table name.

Example 1:
Input: ["SQL", "insertRow", "selectCell", "insertRow", "deleteRow", "selectCell"]
       [[["one", "two", "three"], [2, 3, 1]], ["two", ["first", "second", "third"]], ["two", 1, 3], ["two", ["fourth", "fifth", "sixth"]], ["two", 1], ["two", 2, 2]]
Output:[null, null, "third", null, null, "fifth"]
Explanation
SQL sql = new SQL(["one", "two", "three"], [2, 3, 1]); // creates three tables.
sql.insertRow("two", ["first", "second", "third"]); // adds a row to the table "two". Its id is 1.
sql.selectCell("two", 1, 3); // return "third", finds the value of the third column in the row with id 1 of the table "two".
sql.insertRow("two", ["fourth", "fifth", "sixth"]); // adds another row to the table "two". Its id is 2.
sql.deleteRow("two", 1); // deletes the first row of the table "two". Note that the second row will still have the id 2.
sql.selectCell("two", 2, 2); // return "fifth", finds the value of the second column in the row with id 2 of the table "two".

Constraints:
* n == names.length == columns.length
* 1 <= n <= 10^4
* 1 <= names[i].length, row[i].length, name.length <= 20
* names[i], row[i], and name consist of lowercase English letters.
* 1 <= columns[i] <= 100
* All the strings of names are distinct.
* name exists in the array names.
* row.length equals the number of columns in the chosen table.
* rowId and columnId will be valid.
* At most 250 calls will be made to insertRow and deleteRow.
* At most 10^4 calls will be made to selectCell."""

class SQL:

    def __init__(self, names: List[str], columns: List[int]):
        self.data = {s : [] for s in names}

    def insertRow(self, name: str, row: List[str]) -> None:
        self.data[name].append(row)

    def deleteRow(self, name: str, rowId: int) -> None:
        pass

    def selectCell(self, name: str, rowId: int, columnId: int) -> str:
        return self.data[name][rowId-1][columnId-1]


"""2424. Longest Uploaded Prefix (Medium)
You are given a stream of n videos, each represented by a distinct number from
1 to n that you need to "upload" to a server. You need to implement a data
structure that calculates the length of the longest uploaded prefix at various
points in the upload process. We consider i to be an uploaded prefix if all
videos in the range 1 to i (inclusive) have been uploaded to the server. The
longest uploaded prefix is the maximum value of i that satisfies this
definition. Implement the LUPrefix class:
* LUPrefix(int n) Initializes the object for a stream of n videos.
* void upload(int video) Uploads video to the server.
* int longest() Returns the length of the longest uploaded prefix defined above.

Example 1:
Input:  ["LUPrefix", "upload", "longest", "upload", "longest", "upload", "longest"]
        [[4], [3], [], [1], [], [2], []]
Output: [null, null, 0, null, 1, null, 3]
Explanation
LUPrefix server = new LUPrefix(4);   // Initialize a stream of 4 videos.
server.upload(3);                    // Upload video 3.
server.longest();                    // Since video 1 has not been uploaded yet, there is no prefix.
                                     // So, we return 0.
server.upload(1);                    // Upload video 1.
server.longest();                    // The prefix [1] is the longest uploaded prefix, so we return 1.
server.upload(2);                    // Upload video 2.
server.longest();                    // The prefix [1,2,3] is the longest uploaded prefix, so we return 3.

Constraints:
* 1 <= n <= 10^5
* 1 <= video <= n
* All values of video are distinct.
* At most 2 * 10^5 calls in total will be made to upload and longest.
* At least one call will be made to longest."""

class LUPrefix:

    def __init__(self, n: int):
        self.ans = 0
        self.jump = [[x-1, x+1] for x in range(n+2)]

    def upload(self, video: int) -> None:
        lo, hi = self.jump[video]
        if lo == 0: self.ans = hi-1
        self.jump[lo][1] = hi
        self.jump[hi][0] = lo

    def longest(self) -> int:
        return self.ans


"""2502. Design Memory Allocator (Medium)
You are given an integer n representing the size of a 0-indexed memory array.
All memory units are initially free. You have a memory allocator with the
following functionalities:
* Allocate a block of size consecutive free memory units and assign it the id
  mID.
* Free all memory units with the given id mID.
Note that:
* Multiple blocks can be allocated to the same mID.
* You should free all the memory units with mID, even if they were allocated in
  different blocks.
Implement the Allocator class:
* Allocator(int n) Initializes an Allocator object with a memory array of size
  n.
* int allocate(int size, int mID) Find the leftmost block of size consecutive
  free memory units and allocate it with the id mID. Return the block's first
  index. If such a block does not exist, return -1.
* int free(int mID) Free all memory units with the id mID. Return the number of
  memory units you have freed.

Example 1:
Input: ["Allocator", "allocate", "allocate", "allocate", "free", "allocate", "allocate", "allocate", "free", "allocate", "free"]
       [[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]
Output: [null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]
Explanation:
Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.
loc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.
loc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.
loc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.
loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.
loc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.
loc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.
loc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.
loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.
loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.
loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.

Constraints:
* 1 <= n, size, mID <= 1000
* At most 1000 calls will be made to allocate and free."""

class Allocator:

    def __init__(self, n: int):
        self.memory = [0] * n

    def allocate(self, size: int, mID: int) -> int:
        cnt = 0
        for i, x in enumerate(self.memory):
            if x == 0:
                cnt += 1
                if cnt == size: break
            else: cnt = 0
        else: return -1
        self.memory[i-size+1 : i+1] = [mID]*size
        return i-size+1

    def free(self, mID: int) -> int:
        ans = 0
        for i, x in enumerate(self.memory):
            if x == mID:
                ans += 1
                self.memory[i] = 0
        return ans


"""2526. Find Consecutive Integers from a Data Stream (Medium)
For a stream of integers, implement a data structure that checks if the last k
integers parsed in the stream are equal to value. Implement the DataStream
class:
* DataStream(int value, int k) Initializes the object with an empty integer
  stream and the two integers value and k.
* boolean consec(int num) Adds num to the stream of integers. Returns true if
  the last k integers are equal to value, and false otherwise. If there are
  less than k integers, the condition does not hold true, so returns false.

Example 1:
Input: ["DataStream", "consec", "consec", "consec", "consec"]
       [[4, 3], [4], [4], [4], [3]]
Output: [null, false, false, true, false]
Explanation:
DataStream dataStream = new DataStream(4, 3); //value = 4, k = 3
dataStream.consec(4); // Only 1 integer is parsed, so returns False.
dataStream.consec(4); // Only 2 integers are parsed.
                      // Since 2 is less than k, returns False.
dataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True.
dataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].
                      // Since 3 is not equal to value, it returns False.

Constraints:
* 1 <= value, num <= 10^9
* 1 <= k <= 10^5
* At most 10^5 calls will be made to consec."""

class DataStream:

    def __init__(self, value: int, k: int):
        self.value = value
        self.k = k
        self.cnt = 0

    def consec(self, num: int) -> bool:
        if num == self.value: self.cnt += 1
        else: self.cnt = 0
        return self.cnt >= self.k


"""2642. Design Graph With Shortest Path Calculator (Hard)
There is a directed weighted graph that consists of n nodes numbered from 0 to
n - 1. The edges of the graph are initially represented by the given array
edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge
from fromi to toi with the cost edgeCosti. Implement the Graph class:
* Graph(int n, int[][] edges) initializes the object with n nodes and the given
  edges.
* addEdge(int[] edge) adds an edge to the list of edges where
  edge = [from, to, edgeCost]. It is guaranteed that there is no edge between
  the two nodes before adding this one.
* int shortestPath(int node1, int node2) returns the minimum cost of a path
  from node1 to node2. If no path exists, return -1. The cost of a path is the
  sum of the costs of the edges in the path.

Example 1:
Input: ["Graph", "shortestPath", "shortestPath", "addEdge", "shortestPath"]
[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]
Output: [null, 6, -1, null, 6]
Explanation:
Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);
g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first
                      // diagram above is 3 -> 0 -> 1 -> 2 with a total cost of
                      // 3 + 2 + 1 = 6.
g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.
g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the
                      // second diagram above.
g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is
                      // 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.

Constraints:
* 1 <= n <= 100
* 0 <= edges.length <= n * (n - 1)
* edges[i].length == edge.length == 3
* 0 <= fromi, toi, from, to, node1, node2 <= n - 1
* 1 <= edgeCosti, edgeCost <= 10^6
* There are no repeated edges and no self-loops in the graph at any point.
* At most 100 calls will be made for addEdge.
* At most 100 calls will be made for shortestPath."""

class Graph:

    def __init__(self, n: int, edges: List[List[int]]):
        self.graph = [[] for _ in range(n)]
        for u, v, w in edges:
            self.graph[u].append((v, w))

    def addEdge(self, edge: List[int]) -> None:
        u, v, w = edge
        self.graph[u].append((v, w))

    def shortestPath(self, node1: int, node2: int) -> int:
        pq = [(0, node1)]
        dist = [inf]*len(self.graph)
        dist[node1] = 0
        while pq:
            cost, u = heappop(pq)
            if u == node2: return cost
            for v, w in self.graph[u]:
                if cost + w < dist[v]:
                    dist[v] = cost + w
                    heappush(pq, (cost + w, v))
        return -1


"""2671. Frequency Tracker (Medium)
Design a data structure that keeps track of the values in it and answers some
queries regarding their frequencies. Implement the FrequencyTracker class.
* FrequencyTracker(): Initializes the FrequencyTracker object with an empty
  array initially.
* void add(int number): Adds number to the data structure.
* void deleteOne(int number): Deletes one occurence of number from the data
  structure. The data structure may not contain number, and in this case
  nothing is deleted.
* bool hasFrequency(int frequency): Returns true if there is a number in the
  data structure that occurs frequency number of times, otherwise, it returns
  false.

Example 1:
Input: ["FrequencyTracker", "add", "add", "hasFrequency"]
       [[], [3], [3], [2]]
Output: [null, null, null, true]
Explanation
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.add(3); // The data structure now contains [3]
frequencyTracker.add(3); // The data structure now contains [3, 3]
frequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice

Example 2:
Input: ["FrequencyTracker", "add", "deleteOne", "hasFrequency"]
       [[], [1], [1], [1]]
Output: [null, null, null, false]
Explanation
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.add(1); // The data structure now contains [1]
frequencyTracker.deleteOne(1); // The data structure becomes empty []
frequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty

Example 3:
Input: ["FrequencyTracker", "hasFrequency", "add", "hasFrequency"]
       [[], [2], [3], [1]]
Output: [null, false, null, true]
Explanation
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty
frequencyTracker.add(3); // The data structure now contains [3]
frequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once

Constraints:
* 1 <= number <= 10^5
* 1 <= frequency <= 10^5
* At most, 2 * 10^5 calls will be made to add, deleteOne, and hasFrequency in total."""

class FrequencyTracker:

    def __init__(self):
        self.freq = Counter()
        self.group = defaultdict(set)

    def add(self, number: int) -> None:
        if self.freq[number]: self.group[self.freq[number]].remove(number)
        self.freq[number] += 1
        self.group[self.freq[number]].add(number)

    def deleteOne(self, number: int) -> None:
        if self.freq[number]:
            self.group[self.freq[number]].remove(number)
            self.freq[number] -= 1
            if self.freq[number]: self.group[self.freq[number]].add(number)

    def hasFrequency(self, frequency: int) -> bool:
        return self.group[frequency]


"""3242. Design Neighbor Sum Service (Easy)
You are given a n x n 2D array grid containing distinct elements in the range
[0, n^2 - 1]. Implement the NeighborSum class:
* NeighborSum(int [][]grid) initializes the object.
* int adjacentSum(int value) returns the sum of elements which are adjacent
  neighbors of value, that is either to the top, left, right, or bottom of value
  in grid.
* int diagonalSum(int value) returns the sum of elements which are diagonal
  neighbors of value, that is either to the top-left, top-right, bottom-left, or
  bottom-right of value in grid.

Example 1:
Input:
["NeighborSum", "adjacentSum", "adjacentSum", "diagonalSum", "diagonalSum"]
[[[[0, 1, 2], [3, 4, 5], [6, 7, 8]]], [1], [4], [4], [8]]
Output: [null, 6, 16, 16, 4]

Explanation: The adjacent neighbors of 1 are 0, 2, and 4.
             The adjacent neighbors of 4 are 1, 3, 5, and 7.
             The diagonal neighbors of 4 are 0, 2, 6, and 8.
             The diagonal neighbor of 8 is 4.

Example 2:
Input:
["NeighborSum", "adjacentSum", "diagonalSum"]
[[[[1, 2, 0, 3], [4, 7, 15, 6], [8, 9, 10, 11], [12, 13, 14, 5]]], [15], [9]]
Output: [null, 23, 45]
Explanation: The adjacent neighbors of 15 are 0, 10, 7, and 6.
             The diagonal neighbors of 9 are 4, 12, 14, and 15.

Constraints:
* 3 <= n == grid.length == grid[0].length <= 10
* 0 <= grid[i][j] <= n^2 - 1
* All grid[i][j] are distinct.
* value in adjacentSum and diagonalSum will be in the range [0, n^2 - 1].
* At most 2 * n^2 calls will be made to adjacentSum and diagonalSum."""

class neighborSum:

    def __init__(self, grid: List[List[int]]):
        n = len(grid)
        self.vals = [[0]*(n*n) for _ in range(2)]
        for i in range(n):
            for j in range(n):
                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):
                    if 0 <= ii < n and 0 <= jj < n:
                        self.vals[0][grid[i][j]] += grid[ii][jj]
                for ii, jj in (i-1, j-1), (i-1, j+1), (i+1, j-1), (i+1, j+1):
                    if 0 <= ii < n and 0 <= jj < n:
                        self.vals[1][grid[i][j]] += grid[ii][jj]

    def adjacentSum(self, value: int) -> int:
        return self.vals[0][value]

    def diagonalSum(self, value: int) -> int:
        return self.vals[1][value]
