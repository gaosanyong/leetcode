import java.math.BigInteger;
import java.util.AbstractMap;
import java.util.HashMap;

class Solution {

    /*1. Two Sum (Easy)
    Given an array of integers nums and an integer target, return indices of
    the two numbers such that they add up to target. You may assume that each
    input would have exactly one solution, and you may not use the same element
    twice. You can return the answer in any order.

    Example 1:
    Input: nums = [2,7,11,15], target = 9
    Output: [0,1]
    Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

    Example 2:
    Input: nums = [3,2,4], target = 6
    Output: [1,2]

    Example 3:
    Input: nums = [3,3], target = 6
    Output: [0,1]

    Constraints:
    * 2 <= nums.length <= 10^4
    * -10^9 <= nums[i] <= 10^9
    * -10^9 <= target <= 10^9
    * Only one valid answer exists.

    Follow-up: Can you come up with an algorithm that is less than O(n2) time
               complexity?*/

    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> seen = new HashMap<>();
        for (int i = 0; i < nums.length; ++i) {
            int diff = target - nums[i];
            if (seen.containsKey(diff)) return new int[]{seen.get(diff), i};
            seen.put(nums[i], i);
        }
        return null;
    }


    /*9. Palindrome Number (Easy)
    Given an integer x, return true if x is a palindrome, and false otherwise.

    Example 1:
    Input: x = 121
    Output: true
    Explanation: 121 reads as 121 from left to right and from right to left.

    Example 2:
    Input: x = -121
    Output: false
    Explanation: From left to right, it reads -121. From right to left, it
                 becomes 121-. Therefore it is not a palindrome.

    Example 3:
    Input: x = 10
    Output: false
    Explanation: Reads 01 from right to left. Therefore it is not a palindrome.

    Constraints: -2^31 <= x <= 2^31 - 1

    Follow up: Could you solve it without converting the integer to a string?*/

    public boolean isPalindrome(int x) {
        if (x % 10 == 0 && x != 0 || x < 0) return false;
        int rev = 0;
        for (; x > rev; x /= 10)
            rev = 10*rev + x%10;
        return x == rev || x == rev/10;
    }


    /*13. Roman to Integer (Easy)
    Roman numerals are represented by seven different symbols: I, V, X, L, C, D
    and M.
        Symbol       Value
        I             1
        V             5
        X             10
        L             50
        C             100
        D             500
        M             1000
    For example, 2 is written as II in Roman numeral, just two ones added
    together. 12 is written as XII, which is simply X + II. The number 27 is
    written as XXVII, which is XX + V + II. Roman numerals are usually written
    largest to smallest from left to right. However, the numeral for four is
    not IIII. Instead, the number four is written as IV. Because the one is
    before the five we subtract it making four. The same principle applies to
    the number nine, which is written as IX. There are six instances where
    subtraction is used:
    * I can be placed before V (5) and X (10) to make 4 and 9.
    * X can be placed before L (50) and C (100) to make 40 and 90.
    * C can be placed before D (500) and M (1000) to make 400 and 900.
    Given a roman numeral, convert it to an integer.

    Example 1:
    Input: s = "III"
    Output: 3
    Explanation: III = 3.

    Example 2:
    Input: s = "LVIII"
    Output: 58
    Explanation: L = 50, V= 5, III = 3.

    Example 3:
    Input: s = "MCMXCIV"
    Output: 1994
    Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

    Constraints:
    * 1 <= s.length <= 15
    * s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
    * It is guaranteed that s is a valid roman numeral in the range [1, 3999].*/

    public int romanToInt(String s) {
        HashMap<Character, Integer> mp = new HashMap<>() {{
            put('I', 1);
            put('V', 5);
            put('X', 10);
            put('L', 50);
            put('C', 100);
            put('D', 500);
            put('M', 1000);
        }};
        int ans = 0;
        for (int i = 0; i < s.length(); ++i) {
            if (i+1 < s.length() && mp.get(s.charAt(i)) < mp.get(s.charAt(i+1))) ans -= mp.get(s.charAt(i));
            else ans += mp.get(s.charAt(i));
        }
        return ans;
    }


    /*14. Longest Common Prefix (Easy)
    Write a function to find the longest common prefix string amongst an array
    of strings. If there is no common prefix, return an empty string "".

    Example 1:
    Input: strs = ["flower","flow","flight"]
    Output: "fl"

    Example 2:
    Input: strs = ["dog","racecar","car"]
    Output: ""
    Explanation: There is no common prefix among the input strings.

    Constraints:
    * 1 <= strs.length <= 200
    * 0 <= strs[i].length <= 200
    * strs[i] consists of only lowercase English letters.*/

    public String longestCommonPrefix(String[] strs) {
        String lo = Collections.min(Arrays.asList(strs)), hi = Collections.max(Arrays.asList(strs));
        int i = 0;
        for (; i < lo.length() && i < hi.length() && lo.charAt(i) == hi.charAt(i); ++i);
        return lo.substring(0, i);
    }


    /*20. Valid Parentheses (Easy)
    Given a string s containing just the characters '(', ')', '{', '}', '[' and
    ']', determine if the input string is valid. An input string is valid if:
    * Open brackets must be closed by the same type of brackets.
    * Open brackets must be closed in the correct order.
    * Every close bracket has a corresponding open bracket of the same type.

    Example 1:
    Input: s = "()"
    Output: true

    Example 2:
    Input: s = "()[]{}"
    Output: true

    Example 3:
    Input: s = "(]"
    Output: false

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of parentheses only '()[]{}'.*/

    public boolean isValid(String s) {
        Stack<Character> stk = new Stack<>();
        for (char ch : s.toCharArray()) {
            if (ch == '(') stk.push(')');
            else if (ch == '[') stk.push(']');
            else if (ch == '{') stk.push('}');
            else if (stk.empty() || stk.pop() != ch) return false;
        }
        return stk.empty();
    }


    /*21. Merge Two Sorted Lists (Easy)
    You are given the heads of two sorted linked lists list1 and list2. Merge
    the two lists in a one sorted list. The list should be made by splicing
    together the nodes of the first two lists. Return the head of the merged
    linked list.

    Example 1:
    Input: list1 = [1,2,4], list2 = [1,3,4]
    Output: [1,1,2,3,4,4]

    Example 2:
    Input: list1 = [], list2 = []
    Output: []

    Example 3:
    Input: list1 = [], list2 = [0]
    Output: [0]

    Constraints:
    * The number of nodes in both lists is in the range [0, 50].
    * -100 <= Node.val <= 100
    * Both list1 and list2 are sorted in non-decreasing order.*/

    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(), node = dummy;
        while (list1 != null && list2 != null)
            if (list1.val < list2.val) {
                node = node.next = list1;
                list1 = list1.next;
            } else {
                node = node.next = list2;
                list2 = list2.next;
            }
        if (list1 != null) node.next = list1;
        if (list2 != null) node.next = list2;
        return dummy.next;
    }


    /*26. Remove Duplicates from Sorted Array (Easy)
    Given an integer array nums sorted in non-decreasing order, remove the
    duplicates in-place such that each unique element appears only once. The
    relative order of the elements should be kept the same. Since it is
    impossible to change the length of the array in some languages, you must
    instead have the result be placed in the first part of the array nums. More
    formally, if there are k elements after removing the duplicates, then the
    first k elements of nums should hold the final result. It does not matter
    what you leave beyond the first k elements. Return k after placing the
    final result in the first k slots of nums. Do not allocate extra space for
    another array. You must do this by modifying the input array in-place with
    O(1) extra memory.

    Custom Judge:
    The judge will test your solution with the following code:

    int[] nums = [...]; // Input array
    int[] expectedNums = [...]; // The expected answer with correct length

    int k = removeDuplicates(nums); // Calls your implementation

    assert k == expectedNums.length;
    for (int i = 0; i < k; i++) {
        assert nums[i] == expectedNums[i];
    }
    If all assertions pass, then your solution will be accepted.

    Example 1:
    Input: nums = [1,1,2]
    Output: 2, nums = [1,2,_]
    Explanation: Your function should return k = 2, with the first two elements
                 of nums being 1 and 2 respectively. It does not matter what
                 you leave beyond the returned k (hence they are underscores).

    Example 2:
    Input: nums = [0,0,1,1,1,2,2,3,3,4]
    Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
    Explanation: Your function should return k = 5, with the first five
                 elements of nums being 0, 1, 2, 3, and 4 respectively. It does
                 not matter what you leave beyond the returned k (hence they
                 are underscores).

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * -100 <= nums[i] <= 100
    * nums is sorted in non-decreasing order.*/

    public int removeDuplicates(int[] nums) {
        int k = 0;
        for (int x : nums)
            if (k == 0 || nums[k-1] < x) nums[k++] = x;
        return k;
    }


    /*27. Remove Element (Easy)
    Given an integer array nums and an integer val, remove all occurrences of
    val in nums in-place. The relative order of the elements may be changed.
    Since it is impossible to change the length of the array in some languages,
    you must instead have the result be placed in the first part of the array
    nums. More formally, if there are k elements after removing the duplicates,
    then the first k elements of nums should hold the final result. It does
    not matter what you leave beyond the first k elements. Return k after
    placing the final result in the first k slots of nums. Do not allocate
    extra space for another array. You must do this by modifying the input
    array in-place with O(1) extra memory.

    Custom Judge:
    The judge will test your solution with the following code:

    int[] nums = [...]; // Input array
    int val = ...; // Value to remove
    int[] expectedNums = [...]; // The expected answer with correct length.
                                // It is sorted with no values equaling val.

    int k = removeElement(nums, val); // Calls your implementation

    assert k == expectedNums.length;
    sort(nums, 0, k); // Sort the first k elements of nums
    for (int i = 0; i < actualLength; i++) {
        assert nums[i] == expectedNums[i];
    }
    If all assertions pass, then your solution will be accepted.

    Example 1:
    Input: nums = [3,2,2,3], val = 3
    Output: 2, nums = [2,2,_,_]
    Explanation: Your function should return k = 2, with the first two elements
                 of nums being 2. It does not matter what you leave beyond the
                 returned k (hence they are underscores).

    Example 2:
    Input: nums = [0,1,2,2,3,0,4,2], val = 2
    Output: 5, nums = [0,1,4,0,3,_,_,_]
    Explanation: Your function should return k = 5, with the first five
                 elements of nums containing 0, 0, 1, 3, and 4. Note that the
                 five elements can be returned in any order. It does not matter
                 what you leave beyond the returned k (hence they are
                 underscores).

    Constraints:
    * 0 <= nums.length <= 100
    * 0 <= nums[i] <= 50
    * 0 <= val <= 100*/

    public int removeElement(int[] nums, int val) {
        int k = 0;
        for (int x : nums)
            if (x != val) nums[k++] = x;
        return k;
    }


    /*35. Search Insert Position (Easy)
    Given a sorted array of distinct integers and a target value, return the
    index if the target is found. If not, return the index where it would be if
    it were inserted in order. You must write an algorithm with O(log n)
    runtime complexity.

    Example 1:
    Input: nums = [1,3,5,6], target = 5
    Output: 2

    Example 2:
    Input: nums = [1,3,5,6], target = 2
    Output: 1

    Example 3:
    Input: nums = [1,3,5,6], target = 7
    Output: 4

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^4 <= nums[i] <= 10^4
    * nums contains distinct values sorted in ascending order.
    * -10^4 <= target <= 10^4*/

    public int searchInsert(int[] nums, int target) {
        int k = Arrays.binarySearch(nums, target);
        return k >= 0 ? k : -k-1;
    }


    /*40. Combination Sum II (Medium)
    Given a collection of candidate numbers (candidates) and a target number
    (target), find all unique combinations in candidates where the candidate
    numbers sum to target. Each number in candidates may only be used once in
    the combination. Note: The solution set must not contain duplicate
    combinations.

    Example 1:
    Input: candidates = [10,1,2,7,6,1,5], target = 8
    Output: [[1,1,6],
             [1,2,5],
             [1,7],
             [2,6]]

    Example 2:
    Input: candidates = [2,5,2,1,2], target = 5
    Output: [[1,2,2],
             [5]]

    Constraints:
    * 1 <= candidates.length <= 100
    * 1 <= candidates[i] <= 50
    * 1 <= target <= 30*/

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> ans = new ArrayList();
        List<Integer> stk = new ArrayList();

        class Sol {
            public void fn(int i, int x, boolean prev) {
                if (x == 0) ans.add(new ArrayList(stk));
                else if (i < candidates.length) {
                    if (candidates[i] > x) return;
                    fn(i+1, x, false);
                    if (i == 0 || candidates[i-1] != candidates[i] || prev) {
                        stk.add(candidates[i]);
                        fn(i+1, x-candidates[i], true);
                        stk.remove(stk.size()-1);
                    }
                }
            }
        }

        Sol sol = new Sol();
        sol.fn(0, target, false);
        return ans;
    }


    /*41. First Missing Positive (Hard)
    Given an unsorted integer array nums. Return the smallest positive integer
    that is not present in nums. You must implement an algorithm that runs in
    O(n) time and uses O(1) auxiliary space.

    Example 1:
    Input: nums = [1,2,0]
    Output: 3
    Explanation: The numbers in the range [1,2] are all in the array.

    Example 2:
    Input: nums = [3,4,-1,1]
    Output: 2
    Explanation: 1 is in the array but 2 is missing.

    Example 3:
    Input: nums = [7,8,9,11,12]
    Output: 1
    Explanation: The smallest positive integer 1 is missing.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -2^31 <= nums[i] <= 2^31 - 1*/

    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (var x : nums)
            while (0 < x && x <= n && nums[x-1] != x) {
                int k = x;
                x = nums[x-1];
                nums[k-1] = k;
            }
        for (int i = 0; i < n; ++i)
            if (nums[i] != i+1) return i+1;
        return n+1;
    }


    /*42. Trapping Rain Water (Hard)
    Given n non-negative integers representing an elevation map where the width
    of each bar is 1, compute how much water it can trap after raining.

    Example 1:
    Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
    Output: 6
    Explanation: The above elevation map (black section) is represented by array
                 [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water
                 (blue section) are being trapped.

    Example 2:
    Input: height = [4,2,0,3,2,5]
    Output: 9

    Constraints:
    * n == height.length
    * 1 <= n <= 2 * 10^4
    * 0 <= height[i] <= 10^5*/

    public int trap(int[] height) {
        int ans = 0;
        for (int lo = 0, hi = height.length-1, val = 0; lo < hi; )
            if (height[lo] <= height[hi]) {
                val = Math.max(val, height[lo]);
                ans += val - height[lo++];
            } else {
                val = Math.max(val, height[hi]);
                ans += val - height[hi--];
            }
        return ans;
    }


    /*45. Jump Game II (Medium)
    You are given a 0-indexed array of integers nums of length n. You are
    initially positioned at nums[0]. Each element nums[i] represents the
    maximum length of a forward jump from index i. In other words, if you are
    at nums[i], you can jump to any nums[i + j] where:
    * 0 <= j <= nums[i] and
    * i + j < n
    Return the minimum number of jumps to reach nums[n - 1]. The test cases are
    generated such that you can reach nums[n - 1].

    Example 1:
    Input: nums = [2,3,1,1,4]
    Output: 2
    Explanation: The minimum number of jumps to reach the last index is 2. Jump
                 1 step from index 0 to 1, then 3 steps to the last index.

    Example 2:
    Input: nums = [2,3,0,1,4]
    Output: 2

    Constraints:
    * 1 <= nums.length <= 10^4
    * 0 <= nums[i] <= 1000*/

    public int jump(int[] nums) {
        int ans = 0;
        for (int i = 0, prev = 0, curr = 0; i < nums.length; ++i) {
            if (prev < i) {
                ++ans;
                prev = curr;
            }
            curr = Math.max(curr, i + nums[i]);
        }
        return ans;
    }


    /*48. Rotate Image (Medium)
    You are given an n x n 2D matrix representing an image, rotate the image by
    90 degrees (clockwise). You have to rotate the image in-place, which means
    you have to modify the input 2D matrix directly. DO NOT allocate another 2D
    matrix and do the rotation.

    Example 1:
    Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
    Output: [[7,4,1],[8,5,2],[9,6,3]]

    Example 2:
    Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
    Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

    Constraints:
    * n == matrix.length == matrix[i].length
    * 1 <= n <= 20
    * -1000 <= matrix[i][j] <= 1000*/

    public void rotate(int[][] matrix) {
        int m = matrix.length;
        for (int i = 0; i < m/2; ++i) {
            int[] temp = matrix[i];
            matrix[i] = matrix[m-1-i];
            matrix[m-1-i] = temp;
        }
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < i; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
    }


    /*49. Group Anagrams (Medium)
    Given an array of strings strs, group the anagrams together. You can return
    the answer in any order. An Anagram is a word or phrase formed by
    rearranging the letters of a different word or phrase, typically using all
    the original letters exactly once.

    Example 1:
    Input: strs = ["eat","tea","tan","ate","nat","bat"]
    Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

    Example 2:
    Input: strs = [""]
    Output: [[""]]

    Example 3:
    Input: strs = ["a"]
    Output: [["a"]]

    Constraints:
    * 1 <= strs.length <= 10^4
    * 0 <= strs[i].length <= 100
    * strs[i] consists of lowercase English letters.*/

    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> mp = new HashMap<>();
        for (var s : strs) {
            char[] chs = s.toCharArray();
            Arrays.sort(chs);
            String k = new String(chs);
            mp.putIfAbsent(k, new ArrayList());
            mp.get(k).add(s);
        }
        return new ArrayList<>(mp.values());
    }


    /*55. Jump Game (Medium)
    You are given an integer array nums. You are initially positioned at the
    array's first index, and each element in the array represents your maximum
    jump length at that position. Return true if you can reach the last index,
    or false otherwise.

    Example 1:
    Input: nums = [2,3,1,1,4]
    Output: true
    Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

    Example 2:
    Input: nums = [3,2,1,0,4]
    Output: false
    Explanation: You will always arrive at index 3 no matter what. Its maximum
                 jump length is 0, which makes it impossible to reach the last
                 index.

    Constraints:
    * 1 <= nums.length <= 10^4
    * 0 <= nums[i] <= 10^5*/

    public boolean canJump(int[] nums) {
        for (int i = 0, ii = 0; i < nums.length; ++i) {
            if (ii < i) return false;
            ii = Math.max(ii, i+nums[i]);
        }
        return true;
    }


    /*58. Length of Last Word (Easy)
    Given a string s consisting of words and spaces, return the length of the
    last word in the string. A word is a maximal substring consisting of non-
    space characters only.

    Example 1:
    Input: s = "Hello World"
    Output: 5
    Explanation: The last word is "World" with length 5.

    Example 2:
    Input: s = "   fly me   to   the moon  "
    Output: 4
    Explanation: The last word is "moon" with length 4.

    Example 3:
    Input: s = "luffy is still joyboy"
    Output: 6
    Explanation: The last word is "joyboy" with length 6.

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of only English letters and spaces ' '.
    * There will be at least one word in s.*/

    public int lengthOfLastWord(String s) {
        String[] words = s.split(" ");
        return words[words.length-1].length();
    }


    /*66. Plus One (Easy)
    You are given a large integer represented as an integer array digits, where
    each digits[i] is the ith digit of the integer. The digits are ordered from
    most significant to least significant in left-to-right order. The large
    integer does not contain any leading 0's. Increment the large integer by
    one and return the resulting array of digits.

    Example 1:
    Input: digits = [1,2,3]
    Output: [1,2,4]
    Explanation: The array represents the integer 123. Incrementing by one
                 gives 123 + 1 = 124. Thus, the result should be [1,2,4].

    Example 2:
    Input: digits = [4,3,2,1]
    Output: [4,3,2,2]
    Explanation: The array represents the integer 4321. Incrementing by one
                 gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2].

    Example 3:
    Input: digits = [9]
    Output: [1,0]
    Explanation: The array represents the integer 9. Incrementing by one gives
                 9 + 1 = 10. Thus, the result should be [1,0].

    Constraints:
    * 1 <= digits.length <= 100
    * 0 <= digits[i] <= 9
    * digits does not contain any leading 0's.*/

    public int[] plusOne(int[] digits) {
        int carry = 1;
        for (int i = digits.length-1; i >= 0; --i, carry /= 10) {
            carry += digits[i];
            digits[i] = carry % 10;
        }
        if (carry == 0) return digits;
        int[] ans = new int[digits.length+1];
        ans[0] = 1;
        return ans;
    }


    /*67. Add Binary (Easy)
    Given two binary strings a and b, return their sum as a binary string.

    Example 1:
    Input: a = "11", b = "1"
    Output: "100"

    Example 2:
    Input: a = "1010", b = "1011"
    Output: "10101"

    Constraints:
    * 1 <= a.length, b.length <= 10^4
    * a and b consist only of '0' or '1' characters.
    * Each string does not contain leading zeros except for the zero itself.*/

    public String addBinary(String a, String b) {
        StringBuilder ans = new StringBuilder();
        for (int i = a.length()-1, j = b.length()-1, carry = 0; 0 <= i || 0 <= j || carry > 0; carry /= 2) {
            if (0 <= i) carry += a.charAt(i--) - '0';
            if (0 <= j) carry += b.charAt(j--) - '0';
            ans.append(carry % 2);
        }
        return ans.reverse().toString();
    }


    /*69. Sqrt(x) (Easy)
    Given a non-negative integer x, return the square root of x rounded down to
    the nearest integer. The returned integer should be non-negative as well.
    You must not use any built-in exponent function or operator. For example,
    do not use pow(x, 0.5) in c++ or x ** 0.5 in python.

    Example 1:
    Input: x = 4
    Output: 2
    Explanation: The square root of 4 is 2, so we return 2.

    Example 2:
    Input: x = 8
    Output: 2
    Explanation: The square root of 8 is 2.82842..., and since we round it down
                 to the nearest integer, 2 is returned.

    Constraints: 0 <= x <= 2^31 - 1*/

    public int mySqrt(int x) {
        long ans = x;
        while (ans * ans > x)
            ans = (ans + x/ans)/2;
        return (int) ans;
    }


    /*70. Climbing Stairs (Easy)
    You are climbing a staircase. It takes n steps to reach the top. Each time
    you can either climb 1 or 2 steps. In how many distinct ways can you climb
    to the top?

    Example 1:
    Input: n = 2
    Output: 2
    Explanation: There are two ways to climb to the top.
                 1. 1 step + 1 step
                 2. 2 steps

    Example 2:
    Input: n = 3
    Output: 3
    Explanation: There are three ways to climb to the top.
                 1. 1 step + 1 step + 1 step
                 2. 1 step + 2 steps
                 3. 2 steps + 1 step

    Constraints: 1 <= n <= 45*/

    public int climbStairs(int n) {
        int f0 = 1, f1 = 1;
        for (int i = 1; i <= n-1; ++i) {
            int ff = f0;
            f0 = f1;
            f1 = ff + f1;
        }
        return f1;
    }


    /*72. Edit Distance (Hard)
    Given two strings word1 and word2, return the minimum number of operations
    required to convert word1 to word2. You have the following three operations
    permitted on a word:
    * Insert a character
    * Delete a character
    * Replace a character

    Example 1:
    Input: word1 = "horse", word2 = "ros"
    Output: 3
    Explanation: horse -> rorse (replace 'h' with 'r')
                 rorse -> rose (remove 'r')
                 rose -> ros (remove 'e')

    Example 2:
    Input: word1 = "intention", word2 = "execution"
    Output: 5
    Explanation: intention -> inention (remove 't')
                 inention -> enention (replace 'i' with 'e')
                 enention -> exention (replace 'n' with 'x')
                 exention -> exection (replace 'n' with 'c')
                 exection -> execution (insert 'u')

    Constraints:
    * 0 <= word1.length, word2.length <= 500
    * word1 and word2 consist of lowercase English letters.*/

    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[][] dp = new int[m+1][n+1];
        for (int i = 0; i < m; ++i) dp[i][n] = m-i;
        for (int j = 0; j < n; ++j) dp[m][j] = n-j;
        for (int i  = m-1; i >= 0; --i)
            for (int j = n-1; j >= 0; --j)
                if (word1.charAt(i) == word2.charAt(j)) dp[i][j] = dp[i+1][j+1];
                else dp[i][j] = 1 + Math.min(dp[i+1][j], Math.min(dp[i+1][j+1], dp[i][j+1]));
        return dp[0][0];
    }


    /*75. Sort Colors (Medium)
    Given an array nums with n objects colored red, white, or blue, sort them
    in-place so that objects of the same color are adjacent, with the colors in
    the order red, white, and blue. We will use the integers 0, 1, and 2 to
    represent the color red, white, and blue, respectively. You must solve this
    problem without using the library's sort function.

    Example 1:
    Input: nums = [2,0,2,1,1,0]
    Output: [0,0,1,1,2,2]

    Example 2:
    Input: nums = [2,0,1]
    Output: [0,1,2]

    Constraints:
    * n == nums.length
    * 1 <= n <= 300
    * nums[i] is either 0, 1, or 2.

    Follow up: Could you come up with a one-pass algorithm using only constant
               extra space?*/

    public void sortColors(int[] nums) {
        int lo = 0, mid = 0, hi = nums.length-1;
        while (mid <= hi)
            if (nums[mid] == 0) {
                int temp = nums[lo];
                nums[lo++] = nums[mid];
                nums[mid++] = temp;
            } else if (nums[mid] == 1) ++mid;
            else {
                int temp = nums[mid];
                nums[mid] = nums[hi];
                nums[hi--] = temp;
            }
    }


    /*78. Subsets (Medium)
    Given an integer array nums of unique elements, return all possible subsets
    (the power set). The solution set must not contain duplicate subsets. Return
    the solution in any order.

    Example 1:
    Input: nums = [1,2,3]
    Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

    Example 2:
    Input: nums = [0]
    Output: [[],[0]]

    Constraints:
    * 1 <= nums.length <= 10
    * -10 <= nums[i] <= 10
    * All the numbers of nums are unique.*/

    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList();
        for (int m = 0, n = nums.length; m < 1<<n; ++m) {
            List<Integer> seq = new ArrayList();
            for (int i = 0; i < n; ++i)
                if ((m & 1<<i) > 0) seq.add(nums[i]);
            ans.add(seq);
        }
        return ans;
    }


    /*79. Word Search (Medium)
    Given an m x n grid of characters board and a string word, return true if
    word exists in the grid. The word can be constructed from letters of
    sequentially adjacent cells, where adjacent cells are horizontally or
    vertically neighboring. The same letter cell may not be used more than once.

    Example 1:
    Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]],
           word = "ABCCED"
    Output: true

    Example 2:
    Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]],
           word = "SEE"
    Output: true

    Example 3:
    Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]],
           word = "ABCB"
    Output: false

    Constraints:
    * m == board.length
    * n = board[i].length
    * 1 <= m, n <= 6
    * 1 <= word.length <= 15
    * board and word consists of only lowercase and uppercase English letters.

    Follow up: Could you use search pruning to make your solution faster with a
               larger board?*/

    public boolean exist(char[][] board, String word) {
        int m = board.length, n = board[0].length;

        class Solve {
            private boolean fn(int i, int j, int k) {
                if (k+1 == word.length()) return true;
                board[i][j] ^= 128;
                for (var elem : new int[][]{{i-1, j}, {i, j-1}, {i, j+1}, {i+1, j}}) {
                    int ii = elem[0], jj = elem[1];
                    if (0 <= ii && ii < board.length && 0 <= jj && jj < board[0].length && board[ii][jj] == word.charAt(k+1) && fn(ii, jj, k+1))
                        return true;
                }
                board[i][j] ^= 128;
                return false;
            }
        }

        Solve sol = new Solve();
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (board[i][j] == word.charAt(0) && sol.fn(i, j, 0))
                    return true;
        return false;
    }


    /*83. Remove Duplicates from Sorted List (Easy)
    Given the head of a sorted linked list, delete all duplicates such that
    each element appears only once. Return the linked list sorted as well.

    Example 1:
    Input: head = [1,1,2]
    Output: [1,2]

    Example 2:
    Input: head = [1,1,2,3,3]
    Output: [1,2,3]

    Constraints:
    * The number of nodes in the list is in the range [0, 300].
    * -100 <= Node.val <= 100
    * The list is guaranteed to be sorted in ascending order.*/

    public ListNode deleteDuplicates(ListNode head) {
        ListNode node = head;
        while (node != null)
            if (node.next != null && node.val == node.next.val) node.next = node.next.next;
            else node = node.next;
        return head;
    }


    /*88. Merge Sorted Array (Easy)
    You are given two integer arrays nums1 and nums2, sorted in non-decreasing
    order, and two integers m and n, representing the number of elements in
    nums1 and nums2 respectively. Merge nums1 and nums2 into a single array
    sorted in non-decreasing order. The final sorted array should not be
    returned by the function, but instead be stored inside the array nums1. To
    accommodate this, nums1 has a length of m + n, where the first m elements
    denote the elements that should be merged, and the last n elements are set
    to 0 and should be ignored. nums2 has a length of n.

    Example 1:
    Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
    Output: [1,2,2,3,5,6]
    Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result
                 of the merge is [1,2,2,3,5,6] with the underlined elements
                 coming from nums1.

    Example 2:
    Input: nums1 = [1], m = 1, nums2 = [], n = 0
    Output: [1]
    Explanation: The arrays we are merging are [1] and []. The result of the
                 merge is [1].

    Example 3:
    Input: nums1 = [0], m = 0, nums2 = [1], n = 1
    Output: [1]
    Explanation: The arrays we are merging are [] and [1]. The result of the
                 merge is [1]. Note that because m = 0, there are no elements
                 in nums1. The 0 is only there to ensure the merge result can
                 fit in nums1.

    Constraints:
    * nums1.length == m + n
    * nums2.length == n
    * 0 <= m, n <= 200
    * 1 <= m + n <= 200
    * -10^9 <= nums1[i], nums2[j] <= 10^9

    Follow up: Can you come up with an algorithm that runs in O(m + n) time?*/

    public void merge(int[] nums1, int m, int[] nums2, int n) {
        while (n > 0)
            if (m > 0 && nums1[m-1] >= nums2[n-1]) nums1[m+n-1] = nums1[--m];
            else nums1[m+n-1] = nums2[--n];
    }


    /*94. Binary Tree Inorder Traversal (Easy)
    Given the root of a binary tree, return the inorder traversal of its nodes'
    values.

    Example 1:
    Input: root = [1,null,2,3]
    Output: [1,3,2]

    Example 2:
    Input: root = []
    Output: []

    Example 3:
    Input: root = [1]
    Output: [1]

    Constraints:
    * The number of nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100

    Follow up: Recursive solution is trivial, could you do it iteratively?*/

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList();
        TreeNode node = root;
        Stack<TreeNode> stack = new Stack();
        while (node != null || !stack.isEmpty())
            if (node != null) {
                stack.push(node);
                node = node.left;
            } else {
                node = stack.pop();
                ans.add(node.val);
                node = node.right;
            }
        return ans;
    }


    /*100. Same Tree (Easy)
    Given the roots of two binary trees p and q, write a function to check if
    they are the same or not. Two binary trees are considered the same if they
    are structurally identical, and the nodes have the same value.

    Example 1:
    Input: p = [1,2,3], q = [1,2,3]
    Output: true

    Example 2:
    Input: p = [1,2], q = [1,null,2]
    Output: false

    Example 3:
    Input: p = [1,2,1], q = [1,1,2]
    Output: false

    Constraints:
    * The number of nodes in both trees is in the range [0, 100].
    * -10^4 <= Node.val <= 10^4*/

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null || q == null) return p == q;
        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }


    /*101. Symmetric Tree (Easy)
    Given the root of a binary tree, check whether it is a mirror of itself
    (i.e., symmetric around its center).

    Example 1:
    Input: root = [1,2,2,3,4,4,3]
    Output: true

    Example 2:
    Input: root = [1,2,2,null,3,null,3]
    Output: false

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * -100 <= Node.val <= 100

    Follow up: Could you solve it both recursively and iteratively?*/

    public boolean isSymmetric(TreeNode root) {
        Stack<Pair<TreeNode, TreeNode>> stk = new Stack();
        stk.push(new Pair(root, root));
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            TreeNode left = elem.getKey(), right = elem.getValue();
            if (right == null || left.val != right.val) return false;
            if (left.left != null) stk.push(new Pair(left.left, right.right));
            if (left.right != null) stk.push(new Pair(left.right, right.left));
        }
        return true;
    }


    /*104. Maximum Depth of Binary Tree (Easy)
    Given the root of a binary tree, return its maximum depth. A binary tree's
    maximum depth is the number of nodes along the longest path from the root
    node down to the farthest leaf node.

    Example 1:
        3
       / \
      9  20
        /  \
       15   7
    Input: root = [3,9,20,null,null,15,7]
    Output: 3

    Example 2:
    Input: root = [1,null,2]
    Output: 2

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * -100 <= Node.val <= 100*/

    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }



    /*108. Convert Sorted Array to Binary Search Tree (Easy)
    Given an integer array nums where the elements are sorted in ascending
    order, convert it to a height-balanced binary search tree.

    Example 1:
    Input: nums = [-10,-3,0,5,9]
           0
          / \
        -3   9
        /   /
      -10  5
    Output: [0,-3,9,-10,null,5]
           0
          / \
        -10  5
          \   \
          -3   9
    Explanation: [0,-10,5,null,-3,null,9] is also accepted:

    Example 2:
    Input: nums = [1,3]
    Output: [3,1]
           3  1
          /    \
         1      3
    Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.

    Constraints:
    * 1 <= nums.length <= 10^4
    * -10^4 <= nums[i] <= 10^4
    * nums is sorted in a strictly increasing order.*/

    public TreeNode sortedArrayToBST(int[] nums) {
        TreeNode root = null;
        Stack<Object[]> stk = new Stack();
        stk.push(new Object[]{null, 0, nums.length, false});
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            TreeNode node = (TreeNode) elem[0];
            int lo = (int) elem[1], hi = (int) elem[2];
            boolean tf = (boolean) elem[3];
            if (lo < hi) {
                int mid = lo + (hi - lo)/2;
                if (root == null) node = root = new TreeNode(nums[mid]);
                else if (tf) node = node.right = new TreeNode(nums[mid]);
                else node = node.left = new TreeNode(nums[mid]);
                stk.push(new Object[]{node, lo, mid, false});
                stk.push(new Object[]{node, mid+1, hi, true});
            }
        }
        return root;
    }


    /*110. Balanced Binary Tree (Easy)
    Given a binary tree, determine if it is height-balanced.

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
        3
       / \
      9  20
        /  \
       15   7
    Output: true

    Example 2:
    Input: root = [1,2,2,3,3,null,null,4,4]
           1
          / \
         2   2
        / \
       3   3
      / \
     4   4
    Output: false

    Example 3:
    Input: root = []
    Output: true

    Constraints:
    * The number of nodes in the tree is in the range [0, 5000].
    * -10^4 <= Node.val <= 10^4*/

    public boolean isBalanced(TreeNode root) {
        Map<TreeNode, Pair<Boolean, Integer>> mp = new HashMap(); mp.put(null, new Pair(true, 0));
        TreeNode node = root, prev = null;
        Stack<TreeNode> stk = new Stack();
        while (node != null || !stk.isEmpty()) {
            if (node != null) {
                stk.push(node);
                node = node.left;
            } else {
                node = stk.peek();
                if (node.right != null && node.right != prev) node = node.right;
                else {
                    boolean b0 = mp.get(node.left).getKey(), b1 = mp.get(node.right).getKey();
                    int d0 = mp.get(node.left).getValue(), d1 = mp.get(node.right).getValue();
                    boolean b = b0 && b1 && Math.abs(d0-d1) <= 1;
                    int d = 1 + Math.max(d0, d1);
                    mp.put(node, new Pair(b, d));
                    stk.pop();
                    prev = node;
                    node = null;
                }
            }
        }
        return mp.get(root).getKey();
    }


    /*111. Minimum Depth of Binary Tree (Easy)
    Given a binary tree, find its minimum depth. The minimum depth is the
    number of nodes along the shortest path from the root node down to the
    nearest leaf node. Note: A leaf is a node with no children.

    Example 1:
    Input: root = [3,9,20,null,null,15,7]
    Output: 2

    Example 2:
    Input: root = [2,null,3,null,4,null,5,null,6]
    Output: 5

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^5].
    * -1000 <= Node.val <= 1000*/

    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        int left = minDepth(root.left), right = minDepth(root.right);
        return left > 0 && right > 0 ? 1 + Math.min(left, right) : 1 + Math.max(left, right);
    }


    /*121. Best Time to Buy and Sell Stock (Easy)
    You are given an array prices where prices[i] is the price of a given stock
    on the ith day. You want to maximize your profit by choosing a single day
    to buy one stock and choosing a different day in the future to sell that
    stock. Return the maximum profit you can achieve from this transaction. If
    you cannot achieve any profit, return 0.

    Example 1:
    Input: prices = [7,1,5,3,6,4]
    Output: 5
    Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6),
                 profit = 6-1 = 5. Note that buying on day 2 and selling on day
                 1 is not allowed because you must buy before you sell.

    Example 2:
    Input: prices = [7,6,4,3,1]
    Output: 0
    Explanation: In this case, no transactions are done and the max profit = 0.

    Constraints:
    * 1 <= prices.length <= 10^5
    * 0 <= prices[i] <= 10^4*/

    public int maxProfit(int[] prices) {
        int buy = Integer.MAX_VALUE, sell = 0;
        for (var x : prices) {
            buy = Math.min(buy, x);
            sell = Math.max(sell, x - buy);
        }
        return sell;
    }


    /*129. Sum Root to Leaf Numbers (Medium)
    You are given the root of a binary tree containing digits from 0 to 9 only.
    Each root-to-leaf path in the tree represents a number.
    * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
    Return the total sum of all root-to-leaf numbers. Test cases are generated
    so that the answer will fit in a 32-bit integer. A leaf node is a node with
    no children.

    Example 1:
    Input: root = [1,2,3]
    Output: 25
    Explanation: The root-to-leaf path 1->2 represents the number 12. The
                 root-to-leaf path 1->3 represents the number 13. Therefore,
                 sum = 12 + 13 = 25.

    Example 2:
    Input: root = [4,9,0,5,1]
    Output: 1026
    Explanation: The root-to-leaf path 4->9->5 represents the number 495. The
                 root-to-leaf path 4->9->1 represents the number 491. The
                 root-to-leaf path 4->0 represents the number 40. Therefore,
                 sum = 495 + 491 + 40 = 1026.

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * 0 <= Node.val <= 9
    * The depth of the tree will not exceed 10.*/

    public int sumNumbers(TreeNode root) {
        int ans = 0;
        Stack<Pair<TreeNode, Integer>> stk = new Stack();
        stk.push(new Pair(root, 0));
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            TreeNode node = elem.getKey();
            int val = elem.getValue();
            val = 10*val + node.val;
            if (node.left == null && node.right == null) ans += val;
            if (node.left != null) stk.push(new Pair(node.left, val));
            if (node.right != null) stk.push(new Pair(node.right, val));
        }
        return ans;
    }


    /*131. Palindrome Partitioning (Medium)
    Given a string s, partition s such that every substring of the partition is
    a palindrome. Return all possible palindrome partitioning of s.

    Example 1:
    Input: s = "aab"
    Output: [["a","a","b"],["aa","b"]]

    Example 2:
    Input: s = "a"
    Output: [["a"]]

    Constraints:
    * 1 <= s.length <= 16
    * s contains only lowercase English letters.*/

    public List<List<String>> partition(String s) {
        int n = s.length();
        List<Integer>[] part = new List[n];
        for (int i = 0; i < n; ++i)
            part[i] = new ArrayList();
        for (int i = 0; i < 2*n-1; ++i)
            for (int lo = i/2, hi = (i+1)/2; 0 <= lo && hi < n && s.charAt(lo) == s.charAt(hi); --lo, ++hi)
                part[lo].add(hi+1);
        List<List<String>> ans = new ArrayList();

        class Solve {
            public void fn(int i, List<String> seq) {
                if (i == n) ans.add(new ArrayList(seq));
                else
                    for (var j : part[i]) {
                        seq.add(s.substring(i, j));
                        fn(j, seq);
                        seq.remove(seq.size()-1);
                    }
            }
        }

        List<String> seq = new ArrayList();
        Solve sol = new Solve();
        sol.fn(0, seq);
        return ans;
    }


    /*141. Linked List Cycle (Easy)
    Given head, the head of a linked list, determine if the linked list has a
    cycle in it. There is a cycle in a linked list if there is some node in the
    list that can be reached again by continuously following the next pointer.
    Internally, pos is used to denote the index of the node that tail's next
    pointer is connected to. Note that pos is not passed as a parameter. Return
    true if there is a cycle in the linked list. Otherwise, return false.

    Example 1:
    Input: head = [3,2,0,-4], pos = 1
    Output: true
    Explanation: There is a cycle in the linked list, where the tail connects to
                 the 1st node (0-indexed).

    Example 2:
    Input: head = [1,2], pos = 0
    Output: true
    Explanation: There is a cycle in the linked list, where the tail connects to
                 the 0th node.

    Example 3:
    Input: head = [1], pos = -1
    Output: false
    Explanation: There is no cycle in the linked list.

    Constraints:
    * The number of the nodes in the list is in the range [0, 10^4].
    * -10^5 <= Node.val <= 10^5
    * pos is -1 or a valid index in the linked-list.

    Follow up: Can you solve it using O(1) (i.e. constant) memory?*/

    public boolean hasCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) return true;
        }
        return false;
    }


    /*142. Linked List Cycle II (Medium)
    Given the head of a linked list, return the node where the cycle begins. If
    there is no cycle, return null. There is a cycle in a linked list if there
    is some node in the list that can be reached again by continuously
    following the next pointer. Internally, pos is used to denote the index of
    the node that tail's next pointer is connected to (0-indexed). It is -1 if
    there is no cycle. Note that pos is not passed as a parameter. Do not
    modify the linked list.

    Example 1:
    Input: head = [3,2,0,-4], pos = 1
    Output: tail connects to node index 1
    Explanation: There is a cycle in the linked list, where tail connects to
                 the second node.

    Example 2:
    Input: head = [1,2], pos = 0
    Output: tail connects to node index 0
    Explanation: There is a cycle in the linked list, where tail connects to
                 the first node.

    Example 3:
    Input: head = [1], pos = -1
    Output: no cycle
    Explanation: There is no cycle in the linked list.

    Constraints:
    * The number of the nodes in the list is in the range [0, 10^4].
    * -10^5 <= Node.val <= 10^5
    * pos is -1 or a valid index in the linked-list.

    Follow up: Can you solve it using O(1) (i.e. constant) memory?*/

    public ListNode detectCycle(ListNode head) {
        for (ListNode fast = head, slow = head; fast != null && fast.next != null; ) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                for (fast = head; fast != slow; fast = fast.next, slow = slow.next);
                return slow;
            }
        }
        return null;
    }


    /*144. Binary Tree Preorder Traversal (Easy)
    Given the root of a binary tree, return the preorder traversal of its nodes'
    values.

    Example 1:
    Input: root = [1,null,2,3]
    Output: [1,2,3]

    Example 2:
    Input: root = []
    Output: []

    Example 3:
    Input: root = [1]
    Output: [1]

    Constraints:
    * The number of nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100

    Follow up: Recursive solution is trivial, could you do it iteratively?*/

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList();
        Stack<TreeNode> stk = new Stack(); stk.push(root);
        while (!stk.isEmpty()) {
            var node = stk.pop();
            if (node != null) {
                ans.add(node.val);
                if (node.right != null) stk.push(node.right);
                if (node.left != null) stk.push(node.left);
            }
        }
        return ans;
    }


    /*145. Binary Tree Postorder Traversal (Easy)
    Given the root of a binary tree, return the postorder traversal of its
    nodes' values.

    Example 1:
    Input: root = [1,null,2,3]
    Output: [3,2,1]

    Example 2:
    Input: root = []
    Output: []

    Example 3:
    Input: root = [1]
    Output: [1]

    Constraints:
    * The number of the nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100

    Follow up: Recursive solution is trivial, could you do it iteratively?*/

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        TreeNode prev = null, node = root;
        while (node != null || !stk.isEmpty())
            if (node != null) {
                stk.push(node);
                node = node.left;
            } else {
                node = stk.peek();
                if (node.right != null && prev != node.right) node = node.right;
                else {
                    ans.add(node.val);
                    stk.pop();
                    prev = node;
                    node = null;
                }
            }
        return ans;
    }


    /*149. Max Points on a Line (Hard)
    Given an array of points where points[i] = [xi, yi] represents a point on
    the X-Y plane, return the maximum number of points that lie on the same
    straight line.

    Example 1:
    Input: points = [[1,1],[2,2],[3,3]]
    Output: 3

    Example 2:
    Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
    Output: 4

    Constraints:
    * 1 <= points.length <= 300
    * points[i].length == 2
    * -10^4 <= xi, yi <= 10^4
    * All the points are unique.*/

    public int maxPoints(int[][] points) {
        int ans = 1;
        for (int i = 0, n = points.length; i < n; ++i) {
            int x = points[i][0], y = points[i][1];
            Map<Pair<Integer, Integer>, Integer> freq = new HashMap();
            for (int ii = i+1; ii < n; ++ii) {
                int dx = points[i][0] - points[ii][0], dy = points[i][1] - points[ii][1], g = dx;
                for(int gg = dy; gg != 0; ) {
                    int tmp = g; g = gg; gg = tmp % gg;
                }
                dx /= g;
                dy /= g;
                if (dx == 0) dy = Math.abs(dy);
                var p = new Pair(dx, dy);
                freq.merge(p, 1, Integer::sum);
                ans = Math.max(ans, freq.get(p) + 1);
            }
        }
        return ans;
    }


    /*160. Intersection of Two Linked Lists (Easy)
    Given the heads of two singly linked-lists headA and headB, return the node
    at which the two lists intersect. If the two linked lists have no
    intersection at all, return null. For example, the following two linked
    lists begin to intersect at node c1:

         a1 - a2
                \
                 c1 - c2 - c3
                /
    b1 - b2 - b3

    The test cases are generated such that there are no cycles anywhere in the
    entire linked structure. Note that the linked lists must retain their
    original structure after the function returns.

    Custom Judge:
    The inputs to the judge are given as follows (your program is not given
    these inputs):
    * intersectVal - The value of the node where the intersection occurs. This
      is 0 if there is no intersected node.
    * listA - The first linked list.
    * listB - The second linked list.
    * skipA - The number of nodes to skip ahead in listA (starting from the
      head) to get to the intersected node.
    * skipB - The number of nodes to skip ahead in listB (starting from the
      head) to get to the intersected node.
    The judge will then create the linked structure based on these inputs and
    pass the two heads, headA and headB to your program. If you correctly
    return the intersected node, then your solution will be accepted.

    Example 1:
    Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
    Output: Intersected at '8'
    Explanation: The intersected node's value is 8 (note that this must not be
                 0 if the two lists intersect). From the head of A, it reads as
                 [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5].
                 There are 2 nodes before the intersected node in A; There are
                 3 nodes before the intersected node in B.
                 - Note that the intersected node's value is not 1 because the
                   nodes with value 1 in A and B (2nd node in A and 3rd node in
                   B) are different node references. In other words, they point
                   to two different locations in memory, while the nodes with
                   value 8 in A and B (3rd node in A and 4th node in B) point
                   to the same location in memory.

    Example 2:
    Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
    Output: Intersected at '2'
    Explanation: The intersected node's value is 2 (note that this must not be
                 0 if the two lists intersect). From the head of A, it reads as
                 [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There
                 are 3 nodes before the intersected node in A; There are 1 node
                 before the intersected node in B.

    Example 3:
    Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
    Output: No intersection
    Explanation: From the head of A, it reads as [2,6,4]. From the head of B,
                 it reads as [1,5]. Since the two lists do not intersect,
                 intersectVal must be 0, while skipA and skipB can be arbitrary
                 values. Explanation: The two lists do not intersect, so return
                 null.

    Constraints:
    * The number of nodes of listA is in the m.
    * The number of nodes of listB is in the n.
    * 1 <= m, n <= 3 * 10^4
    * 1 <= Node.val <= 10^5
    * 0 <= skipA < m
    * 0 <= skipB < n
    * intersectVal is 0 if listA and listB do not intersect.
    * intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect.

    Follow up: Could you write a solution that runs in O(m + n) time and use
               only O(1) memory?*/

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode nodeA = headA, nodeB = headB;
        while (nodeA != nodeB) {
            nodeA = nodeA == null ? headB : nodeA.next;
            nodeB = nodeB == null ? headA : nodeB.next;
        }
        return nodeA;
    }


    /*163. Missing Ranges (Easy)
    You are given an inclusive range [lower, upper] and a sorted unique integer
    array nums, where all elements are in the inclusive range. A number x is
    considered missing if x is in the range [lower, upper] and x is not in nums.
    Return the smallest sorted list of ranges that cover every missing number
    exactly. That is, no element of nums is in any of the ranges, and each
    missing number is in one of the ranges. Each range [a,b] in the list should
    be output as:
    * "a->b" if a != b
    * "a" if a == b

    Example 1:
    Input: nums = [0,1,3,50,75], lower = 0, upper = 99
    Output: ["2","4->49","51->74","76->99"]
    Explanation: The ranges are: [2,2] --> "2"
                                 [4,49] --> "4->49"
                                 [51,74] --> "51->74"
                                 [76,99] --> "76->99"

    Example 2:
    Input: nums = [-1], lower = -1, upper = -1
    Output: []
    Explanation: There are no missing ranges since there are no missing numbers.

    Constraints:
    * -10^9 <= lower <= upper <= 10^9
    * 0 <= nums.length <= 100
    * lower <= nums[i] <= upper
    * All the values of nums are unique.*/

    public List<String> findMissingRanges(int[] nums, int lower, int upper) {
        List<String> ans = new ArrayList();
        int prev = lower;
        for (var x : nums) {
            if (prev < x) ans.add(prev == x-1 ? String.valueOf(prev) : String.format("%d->%d", prev, x-1));
            prev = x+1;
        }
        if (prev <= upper) ans.add(prev == upper ? String.valueOf(upper) : String.format("%d->%d", prev, upper));
        return ans;
    }


    /*165. Compare Version Numbers (Medium)
    Given two version numbers, version1 and version2, compare them. Version
    numbers consist of one or more revisions joined by a dot '.'. Each revision
    consists of digits and may contain leading zeros. Every revision contains at
    least one character. Revisions are 0-indexed from left to right, with the
    leftmost revision being revision 0, the next revision being revision 1, and
    so on. For example 2.5.33 and 0.1 are valid version numbers. To compare
    version numbers, compare their revisions in left-to-right order. Revisions
    are compared using their integer value ignoring any leading zeros. This
    means that revisions 1 and 001 are considered equal. If a version number
    does not specify a revision at an index, then treat the revision as 0. For
    example, version 1.0 is less than version 1.1 because their revision 0s are
    the same, but their revision 1s are 0 and 1 respectively, and 0 < 1. Return
    the following:
    * If version1 < version2, return -1.
    * If version1 > version2, return 1.
    * Otherwise, return 0.

    Example 1:
    Input: version1 = "1.01", version2 = "1.001"
    Output: 0
    Explanation: Ignoring leading zeroes, both "01" and "001" represent the same
                 integer "1".

    Example 2:
    Input: version1 = "1.0", version2 = "1.0.0"
    Output: 0
    Explanation: version1 does not specify revision 2, which means it is treated
                 as "0".

    Example 3:
    Input: version1 = "0.1", version2 = "1.1"
    Output: -1
    Explanation: version1's revision 0 is "0", while version2's revision 0 is
                 "1". 0 < 1, so version1 < version2.

    Constraints:
    * 1 <= version1.length, version2.length <= 500
    * version1 and version2 only contain digits and '.'.
    * version1 and version2 are valid version numbers.
    * All the given revisions in version1 and version2 can be stored in a 32-bit
      integer.*/

    public int compareVersion(String version1, String version2) {
        String[] vals1 = version1.split("\\."), vals2 = version2.split("\\.");
        for (int i = 0, n1 = vals1.length, n2 = vals2.length; i < n1 || i < n2; ++i) {
            int v1 = i < n1 ? Integer.parseInt(vals1[i]) : 0;
            int v2 = i < n2 ? Integer.parseInt(vals2[i]) : 0;
            if (v1 < v2) return -1;
            else if (v1 > v2) return 1;
        }
        return 0;
    }


    /*168. Excel Sheet Column Title (Easy)
    Given an integer columnNumber, return its corresponding column title as it
    appears in an Excel sheet. For example:
        A -> 1
        B -> 2
        C -> 3
        ...
        Z -> 26
        AA -> 27
        AB -> 28
        ...

    Example 1:
    Input: columnNumber = 1
    Output: "A"

    Example 2:
    Input: columnNumber = 28
    Output: "AB"

    Example 3:
    Input: columnNumber = 701
    Output: "ZY"

    Constraints: 1 <= columnNumber <= 2^31 - 1*/

    public String convertToTitle(int columnNumber) {
        StringBuilder ans = new StringBuilder();
        for (; columnNumber > 0; columnNumber /= 26) {
            int x = --columnNumber % 26;
            ans.append((char) (x+'A'));
        }
        ans.reverse();
        return ans.toString();
    }


    /*169. Majority Element (Easy)
    Given an array nums of size n, return the majority element. The majority
    element is the element that appears more than ⌊n / 2⌋ times. You may assume
    that the majority element always exists in the array.

    Example 1:
    Input: nums = [3,2,3]
    Output: 3

    Example 2:
    Input: nums = [2,2,1,1,1,2,2]
    Output: 2

    Constraints:
    * n == nums.length
    * 1 <= n <= 5 * 10^4
    * -10^9 <= nums[i] <= 10^9

    Follow-up: Could you solve the problem in linear time and in O(1) space?*/

    public int majorityElement(int[] nums) {
        /*Boyer-Moore majority vote algo*/
        int ans = 0, vote = 0;
        for (var x : nums) {
            if (vote == 0) ans = x;
            if (x == ans) ++vote;
            else --vote;
        }
        return ans;
    }


    /*171. Excel Sheet Column Number (Easy)
    Given a string columnTitle that represents the column title as appears in
    an Excel sheet, return its corresponding column number. For example:
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28
    ...

    Example 1:
    Input: columnTitle = "A"
    Output: 1

    Example 2:
    Input: columnTitle = "AB"
    Output: 28

    Example 3:
    Input: columnTitle = "ZY"
    Output: 701

    Constraints:
    * 1 <= columnTitle.length <= 7
    * columnTitle consists only of uppercase English letters.
    * columnTitle is in the range ["A", "FXSHRXW"].*/

    public int titleToNumber(String columnTitle) {
        int ans = 0;
        for (var ch : columnTitle.toCharArray())
            ans = 26*ans + (ch - 'A' + 1);
        return ans;
    }


    /*179. Largest Number (Medium)
    Given a list of non-negative integers nums, arrange them such that they form
    the largest number and return it. Since the result may be very large, so you
    need to return a string instead of an integer.

    Example 1:
    Input: nums = [10,2]
    Output: "210"

    Example 2:
    Input: nums = [3,30,34,5,9]
    Output: "9534330"

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 10^9*/

    public String largestNumber(int[] nums) {
        List<String> vals = new ArrayList<>();
        for (var x : nums)
            vals.add(String.valueOf(x));
        vals.sort((x, y) -> (y+x).compareTo(x+y));
        String ans = String.join("", vals).replaceFirst("^0+(?!$)", "");
        return ans.isEmpty() ? "0" : ans;
    }


    /*190. Reverse Bits (Easy)
    Reverse bits of a given 32 bits unsigned integer.
    Note:
    * Note that in some languages, such as Java, there is no unsigned integer
      type. In this case, both input and output will be given as a signed
      integer type. They should not affect your implementation, as the integer's
      internal binary representation is the same, whether it is signed or
      unsigned.
    * In Java, the compiler represents the signed integers using 2's complement
      notation. Therefore, in Example 2 above, the input represents the signed
      integer -3 and the output represents the signed integer -1073741825.

    Example 1:
    Input: n = 00000010100101000001111010011100
    Output:    964176192 (00111001011110000010100101000000)
    Explanation: The input binary string 00000010100101000001111010011100
                 represents the unsigned integer 43261596, so return 964176192
                 which its binary representation is
                 00111001011110000010100101000000.

    Example 2:
    Input: n = 11111111111111111111111111111101
    Output:   3221225471 (10111111111111111111111111111111)
    Explanation: The input binary string 11111111111111111111111111111101
                 represents the unsigned integer 4294967293, so return
                 3221225471 which its binary representation is
                 10111111111111111111111111111111.

    Constraints: The input must be a binary string of length 32

    Follow up: If this function is called many times, how would you optimize
               it?*/

    public int reverseBits(int n) {
        int ans = 0;
        for (int i = 0; i < 32; ++i, n >>= 1)
            ans = (ans<<1) + (n & 1);
        return ans;
    }


    /*191. Number of 1 Bits (Easy)
    Write a function that takes an unsigned integer and returns the number of
    '1' bits it has (also known as the Hamming weight).

    Note:
    * Note that in some languages, such as Java, there is no unsigned integer
      type. In this case, the input will be given as a signed integer type. It
      should not affect your implementation, as the integer's internal binary
      representation is the same, whether it is signed or unsigned.
    * In Java, the compiler represents the signed integers using 2's complement
      notation. Therefore, in Example 3, the input represents the signed
      integer. -3.

    Example 1:
    Input: n = 00000000000000000000000000001011
    Output: 3
    Explanation: The input binary string 00000000000000000000000000001011 has a
                 total of three '1' bits.

    Example 2:
    Input: n = 00000000000000000000000010000000
    Output: 1
    Explanation: The input binary string 00000000000000000000000010000000 has a
                 total of one '1' bit.

    Example 3:
    Input: n = 11111111111111111111111111111101
    Output: 31
    Explanation: The input binary string 11111111111111111111111111111101 has a
                 total of thirty one '1' bits.

    Constraints: The input must be a binary string of length 32.

    Follow up: If this function is called many times, how would you optimize it?*/

    public int hammingWeight(int n) {
        /* Brian Kernighan’s Algo */
        int ans = 0;
        for (; n != 0; ++ans, n &= n-1);
        return ans;
    }


    /*214. Shortest Palindrome (Hard)
    You are given a string s. You can convert s to a palindrome by adding
    characters in front of it. Return the shortest palindrome you can find by
    performing this transformation.

    Example 1:
    Input: s = "aacecaaa"
    Output: "aaacecaaa"

    Example 2:
    Input: s = "abcd"
    Output: "dcbabcd"

    Constraints:
    * 0 <= s.length <= 5 * 10^4
    * s consists of lowercase English letters only.*/

    public String shortestPalindrome(String s) {
        String ss = s + "#" + new StringBuilder(s).reverse().toString();
        int n = ss.length();
        int[] lps = new int[n];
        int k = 0;
        for (int i = 1; i < n; ++i) {
            while (k > 0 && ss.charAt(k) != ss.charAt(i)) k = lps[k-1];
            if (ss.charAt(k) == ss.charAt(i)) ++k;
            lps[i] = k;
        }
        return new StringBuilder(s.substring(k)).reverse().toString() + s;
    }


    /*200. Number of Islands (Medium)
    Given an m x n 2D binary grid grid which represents a map of '1's (land) and
    '0's (water), return the number of islands. An island is surrounded by water
    and is formed by connecting adjacent lands horizontally or vertically. You
    may assume all four edges of the grid are all surrounded by water.

    Example 1:
    Input: grid = [
      ["1","1","1","1","0"],
      ["1","1","0","1","0"],
      ["1","1","0","0","0"],
      ["0","0","0","0","0"]
    ]
    Output: 1

    Example 2:
    Input: grid = [
      ["1","1","0","0","0"],
      ["1","1","0","0","0"],
      ["0","0","1","0","0"],
      ["0","0","0","1","1"]
    ]
    Output: 3

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 300
    * grid[i][j] is '0' or '1'.*/

    public int numIslands(char[][] grid) {
        int ans = 0, m = grid.length, n = grid[0].length;
        int[] dir = new int[]{1, 0, -1, 0, 1};
        Stack<int[]> stk = new Stack();
        for (int r = 0; r < m; ++r)
            for (int c = 0; c < n; ++c)
                if (grid[r][c] == '1') {
                    ++ans;
                    grid[r][c] = '0';
                    stk.push(new int[]{r, c});
                    while (!stk.isEmpty()) {
                        var elem = stk.pop();
                        int i = elem[0], j = elem[1];
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] == '1') {
                                grid[ii][jj] = '0';
                                stk.push(new int[]{ii, jj});
                            }
                        }
                    }
                }
        return ans;
    }


    /*226. Invert Binary Tree (Easy)
    Given the root of a binary tree, invert the tree, and return its root.

    Example 1:
    Input: root = [4,2,7,1,3,6,9]
    Output: [4,7,2,9,6,3,1]

    Example 2:
    Input: root = [2,1,3]
    Output: [2,3,1]

    Example 3:
    Input: root = []
    Output: []

    Constraints:
    * The number of nodes in the tree is in the range [0, 100].
    * -100 <= Node.val <= 100*/

    public TreeNode invertTree(TreeNode root) {
        if (root != null) {
            Stack<TreeNode> stk = new Stack();
            stk.push(root);
            while (!stk.isEmpty()) {
                var node = stk.pop();
                TreeNode temp = node.left;
                node.left = node.right;
                node.right = temp;
                if (node.left != null) stk.push(node.left);
                if (node.right != null) stk.push(node.right);
            }
        }
        return root;
    }


    /*231. Power of Two (Easy)
    Given an integer n, return true if it is a power of two. Otherwise, return
    false. An integer n is a power of two, if there exists an integer x such
    that n == 2^x.

    Example 1:
    Input: n = 1
    Output: true
    Explanation: 20 = 1

    Example 2:
    Input: n = 16
    Output: true
    Explanation: 24 = 16

    Example 3:
    Input: n = 3
    Output: false

    Constraints: -2^31 <= n <= 2^31 - 1

    Follow up: Could you solve it without loops/recursion?*/

    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n&(n-1)) == 0;
    }


    /*237. Delete Node in a Linked List (Medium)
    There is a singly-linked list head and we want to delete a node node in it.
    You are given the node to be deleted node. You will not be given access to
    the first node of head. All the values of the linked list are unique, and it
    is guaranteed that the given node node is not the last node in the linked
    list. Delete the given node. Note that by deleting the node, we do not mean
    removing it from memory. We mean:
    * The value of the given node should not exist in the linked list.
    * The number of nodes in the linked list should decrease by one.
    * All the values before node should be in the same order.
    * All the values after node should be in the same order.
    Custom testing:
    * For the input, you should provide the entire linked list head and the node
      to be given node. node should not be the last node of the list and should
      be an actual node in the list.
    * We will build the linked list and pass the node to your function.
    * The output will be the entire list after calling your function.

    Example 1:
    Input: head = [4,5,1,9], node = 5
    Output: [4,1,9]
    Explanation: You are given the second node with value 5, the linked list
                 should become 4 -> 1 -> 9 after calling your function.

    Example 2:
    Input: head = [4,5,1,9], node = 1
    Output: [4,5,9]
    Explanation: You are given the third node with value 1, the linked list
                 should become 4 -> 5 -> 9 after calling your function.

    Constraints:
    * The number of the nodes in the given list is in the range [2, 1000].
    * -1000 <= Node.val <= 1000
    * The value of each node in the list is unique.
    * The node to be deleted is in the list and is not a tail node.*/

    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }


    /*238. Product of Array Except Self (Medium)
    Given an integer array nums, return an array answer such that answer[i] is
    equal to the product of all the elements of nums except nums[i]. The product
    of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
    You must write an algorithm that runs in O(n) time and without using the
    division operation.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: [24,12,8,6]

    Example 2:
    Input: nums = [-1,1,0,-3,3]
    Output: [0,0,9,0,0]

    Constraints:
    * 2 <= nums.length <= 10^5
    * -30 <= nums[i] <= 30
    * The product of any prefix or suffix of nums is guaranteed to fit in a 32-
      bit integer.

    Follow up: Can you solve the problem in O(1) extra space complexity? (The
               output array does not count as extra space for space complexity
               analysis.)*/

    public int[] productExceptSelf(int[] nums) {
        int n = nums.length, prefix = 1, suffix = 1;
        int[] ans = new int[n];
        Arrays.fill(ans, 1);
        for (int i = 0; i < n; ++i) {
            ans[i] *= prefix;
            ans[n-1-i] *= suffix;
            prefix *= nums[i];
            suffix *= nums[n-1-i];
        }
        return ans;
    }


    /*245. Shortest Word Distance III (Medium)
    Given an array of strings wordsDict and two strings that already exist in
    the array word1 and word2, return the shortest distance between the
    occurrence of these two words in the list. Note that word1 and word2 may be
    the same. It is guaranteed that they represent two individual words in the
    list.

    Example 1:
    Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "coding"
    Output: 1

    Example 2:
    Input: wordsDict = ["practice", "makes", "perfect", "coding", "makes"], word1 = "makes", word2 = "makes"
    Output: 3

    Constraints:
    * 1 <= wordsDict.length <= 10^5
    * 1 <= wordsDict[i].length <= 10
    * wordsDict[i] consists of lowercase English letters.
    * word1 and word2 are in wordsDict.*/

    public int shortestWordDistance(String[] wordsDict, String word1, String word2) {
        int n = wordsDict.length, ans = n, i1 = n, i2 = 2*n;
        for (int i = 0; i < n; ++i) {
            if (wordsDict[i].equals(word1)) i1 = word1.equals(word2) ? i2 : i;
            if (wordsDict[i].equals(word2)) i2 = i;
            ans = Math.min(ans, Math.abs(i1-i2));
        }
        return ans;
    }


    /*260. Single Number III (Medium)
    Given an integer array nums, in which exactly two elements appear only once
    and all the other elements appear exactly twice. Find the two elements that
    appear only once. You can return the answer in any order. You must write an
    algorithm that runs in linear runtime complexity and uses only constant
    extra space.

    Example 1:
    Input: nums = [1,2,1,3,2,5]
    Output: [3,5]
    Explanation:  [5, 3] is also a valid answer.

    Example 2:
    Input: nums = [-1,0]
    Output: [-1,0]

    Example 3:
    Input: nums = [0,1]
    Output: [1,0]

    Constraints:
    * 2 <= nums.length <= 3 * 10^4
    * -2^31 <= nums[i] <= 2^31 - 1
    * Each integer in nums will appear twice, only two integers will appear once.*/

    public int[] singleNumber(int[] nums) {
        int val = IntStream.of(nums).reduce(0, (x, y) -> x^y);
        val &= -val;
        int[] ans = new int[2];
        for (var x : nums)
            if ((x & val) > 0) ans[0] ^= x;
            else ans[1] ^= x;
        return ans;
    }


    /*264. Ugly Number II (Medium)
    An ugly number is a positive integer whose prime factors are limited to 2,
    3, and 5. Given an integer n, return the nth ugly number.

    Example 1:
    Input: n = 10
    Output: 12
    Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first
                 10 ugly numbers.

    Example 2:
    Input: n = 1
    Output: 1
    Explanation: 1 has no prime factors, therefore all of its prime factors are
                 limited to 2, 3, and 5.

    Constraints: 1 <= n <= 1690*/

    public int nthUglyNumber(int n) {
        int[] ans = new int[n]; ans[0] = 1;
        for (int i = 1, p2 = 0, p3 = 0, p5 = 0; i < n; ++i) {
            int cand = Math.min(2*ans[p2], Math.min(3*ans[p3], 5*ans[p5]));
            ans[i] = cand;
            if (2*ans[p2] == cand) ++p2;
            if (3*ans[p3] == cand) ++p3;
            if (5*ans[p5] == cand) ++p5;
        }
        return ans[n-1];
    }


    /*279. Perfect Squares (Medium)
    Given an integer n, return the least number of perfect square numbers that
    sum to n. A perfect square is an integer that is the square of an integer;
    in other words, it is the product of some integer with itself. For example,
    1, 4, 9, and 16 are perfect squares while 3 and 11 are not.

    Example 1:
    Input: n = 12
    Output: 3
    Explanation: 12 = 4 + 4 + 4.

    Example 2:
    Input: n = 13
    Output: 2
    Explanation: 13 = 4 + 9.

    Constraints: 1 <= n <= 10^4*/

    public int numSquares(int n) {
        if (Math.pow((int) Math.sqrt(n), 2) == n) return 1;
        for (int i = 1; i <= Math.sqrt(n); ++i)
            if (Math.pow((int) Math.sqrt(n-i*i), 2) == n-i*i) return 2;
        for (; n % 4 == 0; n /= 4);
        return n % 8 != 7 ? 3 : 4;
    }


    /*280. Wiggle Sort (Medium)
    Given an integer array nums, reorder it such that
    nums[0] <= nums[1] >= nums[2] <= nums[3].... You may assume the input array
    always has a valid answer.

    Example 1:
    Input: nums = [3,5,2,1,6,4]
    Output: [3,5,1,6,2,4]
    Explanation: [1,6,2,5,3,4] is also accepted.

    Example 2:
    Input: nums = [6,6,5,6,3,8]
    Output: [6,6,5,6,3,8]

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 0 <= nums[i] <= 10^4
    * It is guaranteed that there will be an answer for the given input nums.

    Follow up: Could you solve the problem in O(n) time complexity?*/

    public void wiggleSort(int[] nums) {
        for (int i = 0; i < nums.length-1; ++i)
            if (i%2 == 1 && nums[i] < nums[i+1] || i%2 == 0 && nums[i] > nums[i+1]) {
                int temp = nums[i];
                nums[i] = nums[i+1];
                nums[i+1] = temp;
            }
    }


    /*305. Number of Islands II (Hard)
    You are given an empty 2D binary grid grid of size m x n. The grid
    represents a map where 0's represent water and 1's represent land.
    Initially, all the cells of grid are water cells (i.e., all the cells are
    0's). We may perform an add land operation which turns the water at
    position into a land. You are given an array positions where
    positions[i] = [ri, ci] is the position (ri, ci) at which we should operate
    the ith operation. Return an array of integers answer where answer[i] is
    the number of islands after turning the cell (ri, ci) into a land. An
    island is surrounded by water and is formed by connecting adjacent lands
    horizontally or vertically. You may assume all four edges of the grid are
    all surrounded by water.

    Example 1:
    Input: m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]
    Output: [1,1,2,3]
    Explanation: Initially, the 2d grid is filled with water.
                 - Operation #1: addLand(0, 0) turns the water at grid[0][0]
                                 into a land. We have 1 island.
                 - Operation #2: addLand(0, 1) turns the water at grid[0][1]
                                 into a land. We still have 1 island.
                 - Operation #3: addLand(1, 2) turns the water at grid[1][2]
                                 into a land. We have 2 islands.
                 - Operation #4: addLand(2, 1) turns the water at grid[2][1]
                                 into a land. We have 3 islands.

    Example 2:
    Input: m = 1, n = 1, positions = [[0,0]]
    Output: [1]

    Constraints:
    * 1 <= m, n, positions.length <= 10^4
    * 1 <= m * n <= 10^4
    * positions[i].length == 2
    * 0 <= ri < m
    * 0 <= ci < n

    Follow up: Could you solve it in time complexity O(k log(mn)), where
               k == positions.length?*/

    private static int find(int p, int[] parent) {
        if (p != parent[p])
            parent[p] = find(parent[p], parent);
        return parent[p];
    }

    public List<Integer> numIslands2(int m, int n, int[][] positions) {
        int[] parent = new int[m*n];
        for (int i = 0; i < m*n; ++i) parent[i] = i;
        List<Integer> ans = new ArrayList();
        boolean[][] seen = new boolean[m][n];
        int prefix = 0;
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        for (var position : positions) {
            int i = position[0], j = position[1];
            if (!seen[i][j]) {
                ++prefix;
                seen[i][j] = true;
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && seen[ii][jj]) {
                        int p = find(i*n + j, parent), pp = find(ii*n + jj, parent);
                        if (p != pp) {
                            --prefix;
                            parent[p] = pp;
                        }
                    }
                }
            }
            ans.add(prefix);
        }
        return ans;
    }


    /*310. Minimum Height Trees (Medium)
    A tree is an undirected graph in which any two vertices are connected by
    exactly one path. In other words, any connected graph without simple cycles
    is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of
    n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected
    edge between the two nodes ai and bi in the tree, you can choose any node of
    the tree as the root. When you select a node x as the root, the result tree
    has height h. Among all possible rooted trees, those with minimum height
    (i.e. min(h))  are called minimum height trees (MHTs). Return a list of all
    MHTs' root labels. You can return the answer in any order. The height of a
    rooted tree is the number of edges on the longest downward path between the
    root and a leaf.

    Example 1:
    Input: n = 4, edges = [[1,0],[1,2],[1,3]]
    Output: [1]
    Explanation: As shown, the height of the tree is 1 when the root is the node
                 with label 1 which is the only MHT.

    Example 2:
    Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
    Output: [3,4]

    Constraints:
    * 1 <= n <= 2 * 10^4
    * edges.length == n - 1
    * 0 <= ai, bi < n
    * ai != bi
    * All the pairs (ai, bi) are distinct.
    * The given input is guaranteed to be a tree and there will be no repeated edges.*/

    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        Set<Integer>[] graph = new Set[n];
        for (int u = 0; u < n; ++u)
            graph[u] = new HashSet();
        for (var e : edges) {
            int u = e[0], v = e[1];
            graph[u].add(v);
            graph[v].add(u);
        }
        Queue<Integer> q = new LinkedList();
        for (int u = 0; u < n; ++u)
            if (graph[u].size() <= 1) q.add(u);
        while (n > 2) {
            n -= q.size();
            for (int sz = q.size(); sz > 0; --sz) {
                int u = q.poll();
                int v = graph[u].iterator().next();
                graph[v].remove(u);
                if (graph[v].size() == 1) q.add(v);
            }
        }
        return new ArrayList(q);
    }


    /*330. Patching Array (Hard)
    Given a sorted integer array nums and an integer n, add/patch elements to
    the array such that any number in the range [1, n] inclusive can be formed
    by the sum of some elements in the array. Return the minimum number of
    patches required.

    Example 1:
    Input: nums = [1,3], n = 6
    Output: 1
    Explanation: Combinations of nums are [1], [3], [1,3], which form possible
                 sums of: 1, 3, 4. Now if we add/patch 2 to nums, the
                 combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
                 Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range
                 [1, 6]. So we only need 1 patch.

    Example 2:
    Input: nums = [1,5,10], n = 20
    Output: 2
    Explanation: The two patches can be [2, 4].

    Example 3:
    Input: nums = [1,2,2], n = 5
    Output: 0

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^4
    * nums is sorted in ascending order.
    * 1 <= n <= 2^31 - 1*/

    public int minPatches(int[] nums, int n) {
        int ans = 0;
        long prefix = 0;
        for (int k = 0; prefix < n; )
            if (k < nums.length && nums[k] <= prefix+1)
                prefix += nums[k++];
            else {
                ++ans;
                prefix += prefix+1;
            }
        return ans;
    }


    /*350. Intersection of Two Arrays II (Easy)
    Given two integer arrays nums1 and nums2, return an array of their
    intersection. Each element in the result must appear as many times as it
    shows in both arrays and you may return the result in any order.

    Example 1:
    Input: nums1 = [1,2,2,1], nums2 = [2,2]
    Output: [2,2]

    Example 2:
    Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
    Output: [4,9]
    Explanation: [9,4] is also accepted.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 1000
    * 0 <= nums1[i], nums2[i] <= 1000

    Follow up:
    * What if the given array is already sorted? How would you optimize your
      algorithm?
    * What if nums1's size is small compared to nums2's size? Which algorithm is
      better?
    * What if elements of nums2 are stored on disk, and the memory is limited
      such that you cannot load all elements into the memory at once?*/

    public int[] intersect(int[] nums1, int[] nums2) {
        Map<Integer, Integer> freq = new HashMap();
        for (var x : nums1)
            freq.merge(x, 1, Integer::sum);
        List<Integer> ans = new ArrayList();
        for (var x : nums2)
            if (freq.getOrDefault(x, 0) > 0) {
                ans.add(x);
                freq.merge(x, -1, Integer::sum);
            }
        return ans.stream().mapToInt(Integer::intValue).toArray();
    }


    /*358. Rearrange String k Distance Apart (Hard)
    Given a string s and an integer k, rearrange s such that the same
    characters are at least distance k from each other. If it is not possible
    to rearrange the string, return an empty string "".

    Example 1:
    Input: s = "aabbcc", k = 3
    Output: "abcabc"
    Explanation: The same letters are at least a distance of 3 from each other.

    Example 2:
    Input: s = "aaabc", k = 3
    Output: ""
    Explanation: It is not possible to rearrange the string.

    Example 3:
    Input: s = "aaadbbcc", k = 2
    Output: "abacabcd"
    Explanation: The same letters are at least a distance of 2 from each other.

    Constraints:
    * 1 <= s.length <= 3 * 10^5
    * s consists of only lowercase English letters.
    * 0 <= k <= s.length*/

    public String rearrangeString(String s, int k) {
        StringBuilder ans = new StringBuilder();
        int[] freq = new int[26], prev = new int[26];
        for (var ch : s.toCharArray()) ++freq[ch - 'a'];
        Arrays.fill(prev, -k);
        for (int i = 0; i < s.length(); ++i) {
            int m = -1;
            for (int c = 0; c < 26; ++c)
                if (freq[c] > 0 && (m == -1 || freq[c] > freq[m]) && i - prev[c] >= k) m = c;
            if (m == -1) return "";
            ans.append((char)('a' + m));
            --freq[m];
            prev[m] = i;
        }
        return ans.toString();
    }


    /*386. Lexicographical Numbers (Medium)
    Given an integer n, return all the numbers in the range [1, n] sorted in
    lexicographical order. You must write an algorithm that runs in O(n) time
    and uses O(1) extra space.

    Example 1:
    Input: n = 13
    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]

    Example 2:
    Input: n = 2
    Output: [1,2]

    Constraints: 1 <= n <= 5 * 10^4*/

    public List<Integer> lexicalOrder(int n) {
        List<Integer> ans = new ArrayList<>();
        int v = 1;
        for (int i = 0; i < n; ++i) {
            ans.add(v);
            if (10*v <= n) v *= 10;
            else {
                while (v % 10 == 9 || v == n) v /= 10;
                ++v;
            }
        }
        return ans;
    }


    /*387. First Unique Character in a String (Easy)
    Given a string s, find the first non-repeating character in it and return
    its index. If it does not exist, return -1.

    Example 1:
    Input: s = "leetcode"
    Output: 0

    Example 2:
    Input: s = "loveleetcode"
    Output: 2

    Example 3:
    Input: s = "aabb"
    Output: -1

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of only lowercase English letters.*/

    public int firstUniqChar(String s) {
        int[] freq = new int[26];
        for (char c : s.toCharArray()) ++freq[c - 97];
        for (int i = 0; i < s.length(); i++)
            if (freq[s.charAt(i)-97] == 1) return i;
        return -1;
    }


    /*402. Remove K Digits (Medium)
    Given string num representing a non-negative integer num, and an integer k,
    return the smallest possible integer after removing k digits from num.

    Example 1:
    Input: num = "1432219", k = 3
    Output: "1219"
    Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219
                 which is the smallest.

    Example 2:
    Input: num = "10200", k = 1
    Output: "200"
    Explanation: Remove the leading 1 and the number is 200. Note that the
                 output must not contain leading zeroes.

    Example 3:
    Input: num = "10", k = 2
    Output: "0"
    Explanation: Remove all the digits from the number and it is left with
                 nothing which is 0.

    Constraints:
    * 1 <= k <= num.length <= 10^5
    * num consists of only digits.
    * num does not have any leading zeros except for the zero itself.*/

    public String removeKdigits(String num, int k) {
        List<Character> ans = new ArrayList();
        for (var ch : num.toCharArray()) {
            while (k > 0 && ans.size() > 0 && ans.get(ans.size()-1) > ch) {
                --k;
                ans.remove(ans.size()-1);
            }
            if (ans.size() > 0 || ch != '0') ans.add(ch);
        }
        while (k-- > 0 && ans.size() > 0)
            ans.remove(ans.size()-1);
        return ans.size() > 0 ? ans.stream().map(String::valueOf).collect(Collectors.joining()) : "0";
    }


    /*409. Longest Palindrome (Easy)
    Given a string s which consists of lowercase or uppercase letters, return
    the length of the longest palindrome that can be built with those letters.
    Letters are case sensitive, for example, "Aa" is not considered a palindrome.

    Example 1:
    Input: s = "abccccdd"
    Output: 7
    Explanation: One longest palindrome that can be built is "dccaccd", whose
                 length is 7.

    Example 2:
    Input: s = "a"
    Output: 1
    Explanation: The longest palindrome that can be built is "a", whose length
                 is 1.

    Constraints:
    * 1 <= s.length <= 2000
    * s consists of lowercase and/or uppercase English letters only.*/

    public int longestPalindrome(String s) {
        Map<Character, Integer> freq = new HashMap();
        for (var ch : s.toCharArray())
            freq.merge(ch, 1, Integer::sum);
        int ans = 0, odd = 0;
        for (var v : freq.values()) {
            ans += v/2*2;
            if ((v&1) > 0) odd = 1;
        }
        return ans + odd;
    }


    /*427. Construct Quad Tree (Medium)
    Given a n * n matrix grid of 0's and 1's only. We want to represent the
    grid with a Quad-Tree. Return the root of the Quad-Tree representing the
    grid. Notice that you can assign the value of a node to True or False when
    isLeaf is False, and both are accepted in the answer. A Quad-Tree is a tree
    data structure in which each internal node has exactly four children.
    Besides, each node has two attributes:
    * val: True if the node represents a grid of 1's or False if the node
      represents a grid of 0's.
    * isLeaf: True if the node is leaf node on the tree or False if the node
      has the four children.
    class Node {
        public boolean val;
        public boolean isLeaf;
        public Node topLeft;
        public Node topRight;
        public Node bottomLeft;
        public Node bottomRight;
    }
    We can construct a Quad-Tree from a two-dimensional area using the
    following steps:
    * If the current grid has the same value (i.e all 1's or all 0's) set
      isLeaf True and set val to the value of the grid and set the four
      children to Null and stop.
    * If the current grid has different values, set isLeaf to False and set val
      to any value and divide the current grid into four sub-grids as shown in
      the photo.
    * Recurse for each of the children with the proper sub-grid.
    If you want to know more about the Quad-Tree, you can refer to the wiki.
    Quad-Tree format:
    * The output represents the serialized format of a Quad-Tree using level
      order traversal, where null signifies a path terminator where no node
      exists below.
    * It is very similar to the serialization of the binary tree. The only
      difference is that the node is represented as a list [isLeaf, val].
    * If the value of isLeaf or val is True we represent it as 1 in the list
      [isLeaf, val] and if the value of isLeaf or val is False we represent it
      as 0.

    Example 1:
    Input: grid = [[0,1],[1,0]]
    Output: [[0,1],[1,0],[1,1],[1,1],[1,0]]
    Explanation: The explanation of this example is shown below: Notice that 0
                 represnts False and 1 represents True in the photo
                 representing the Quad-Tree.

    Example 2:
    Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]
    Output: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
    Explanation: All values in the grid are not the same. We divide the grid
                 into four sub-grids. The topLeft, bottomLeft and bottomRight
                 each has the same value. The topRight have different values so
                 we divide it into 4 sub-grids where each has the same value.
                 Explanation is shown in the photo below:

    Constraints:
    * n == grid.length == grid[i].length
    * n == 2x where 0 <= x <= 6*/

    private Node fn(int i, int ii, int j, int jj, int[][] prefix, int[][] grid) {
        int diff = prefix[ii][jj] - prefix[i][jj] - prefix[ii][j] + prefix[i][j];
        if (diff == 0 || diff == (ii-i)*(jj-j)) return new Node(grid[i][j] == 1 ? true : false, true);
        Node tl = fn(i, (i+ii)/2, j, (j+jj)/2, prefix, grid);
        Node tr = fn(i, (i+ii)/2, (j+jj)/2, jj, prefix, grid);
        Node bl = fn((i+ii)/2, ii, j, (j+jj)/2, prefix, grid);
        Node br = fn((i+ii)/2, ii, (j+jj)/2, jj, prefix, grid);
        return new Node(false, false, tl, tr, bl, br);
    }

    public Node construct(int[][] grid) {
        int n = grid.length;
        int[][] prefix = new int[n+1][n+1];
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                prefix[i+1][j+1] = prefix[i][j+1] + prefix[i+1][j] - prefix[i][j] + grid[i][j];
        return fn(0, n, 0, n, prefix, grid);
    }


    /*442. Find All Duplicates in an Array (Medium)
    Given an integer array nums of length n where all the integers of nums are
    in the range [1, n] and each integer appears once or twice, return an array
    of all the integers that appears twice. You must write an algorithm that
    runs in O(n) time and uses only constant extra space.

    Example 1:
    Input: nums = [4,3,2,7,8,2,3,1]
    Output: [2,3]

    Example 2:
    Input: nums = [1,1,2]
    Output: [1]

    Example 3:
    Input: nums = [1]
    Output: []

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= n
    * Each element in nums appears once or twice.*/

    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> ans = new ArrayList();
        for (var x : nums) {
            x = Math.abs(x);
            if (nums[x-1] < 0) ans.add(x);
            nums[x-1] *= -1;
        }
        return ans;
    }


    /*452. Minimum Number of Arrows to Burst Balloons (Medium)
    There are some spherical balloons taped onto a flat wall that represents
    the XY-plane. The balloons are represented as a 2D integer array points
    where points[i] = [xstart, xend] denotes a balloon whose horizontal
    diameter stretches between xstart and xend. You do not know the exact
    y-coordinates of the balloons. Arrows can be shot up directly vertically
    (in the positive y-direction) from different points along the x-axis. A
    balloon with xstart and xend is burst by an arrow shot at x if
    xstart <= x <= xend. There is no limit to the number of arrows that can be
    shot. A shot arrow keeps traveling up infinitely, bursting any balloons in
    its path. Given the array points, return the minimum number of arrows that
    must be shot to burst all balloons.

    Example 1:
    Input: points = [[10,16],[2,8],[1,6],[7,12]]
    Output: 2
    Explanation: The balloons can be burst by 2 arrows:
                 - Shoot an arrow at x = 6, bursting the balloons [2,8] and
                   [1,6].
                 - Shoot an arrow at x = 11, bursting the balloons [10,16] and
                   [7,12].

    Example 2:
    Input: points = [[1,2],[3,4],[5,6],[7,8]]
    Output: 4
    Explanation: One arrow needs to be shot for each balloon for a total of 4
                 arrows.

    Example 3:
    Input: points = [[1,2],[2,3],[3,4],[4,5]]
    Output: 2
    Explanation: The balloons can be burst by 2 arrows:
                 - Shoot an arrow at x = 2, bursting the balloons [1,2] and
                   [2,3].
                 - Shoot an arrow at x = 4, bursting the balloons [3,4] and
                   [4,5].

    Constraints:
    * 1 <= points.length <= 10^5
    * points[i].length == 2
    * -2^31 <= xstart < xend <= 2^31 - 1*/

    public int findMinArrowShots(int[][] points) {
        int ans = 0;
        long prev = Long.MIN_VALUE;
        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));
        for (var p : points)
            if (prev < p[0]) {
                ++ans;
                prev = p[1];
            }
        return ans;
    }


    /*463. Island Perimeter (Easy)
    You are given row x col grid representing a map where grid[i][j] = 1
    represents land and grid[i][j] = 0 represents water. Grid cells are
    connected horizontally/vertically (not diagonally). The grid is completely
    surrounded by water, and there is exactly one island (i.e., one or more
    connected land cells). The island doesn't have "lakes", meaning the water
    inside isn't connected to the water around the island. One cell is a square
    with side length 1. The grid is rectangular, width and height don't exceed
    100. Determine the perimeter of the island.

    Example 1:
    Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
    Output: 16
    Explanation: The perimeter is the 16 yellow stripes in the image above.

    Example 2:
    Input: grid = [[1]]
    Output: 4

    Example 3:
    Input: grid = [[1,0]]
    Output: 4

    Constraints:
    * row == grid.length
    * col == grid[i].length
    * 1 <= row, col <= 100
    * grid[i][j] is 0 or 1.
    * There is exactly one island in grid.*/

    public int islandPerimeter(int[][] grid) {
        int ans = 0;
        for (int i = 0; i < grid.length; ++i)
            for (int j = 0; j < grid[i].length; ++j)
                if (grid[i][j] == 1) {
                    ans += 4;
                    if (i > 0 && grid[i-1][j] == 1) ans -= 2;
                    if (j > 0 && grid[i][j-1] == 1) ans -= 2;
                }
        return ans;
    }


    /*476. Number Complement (Easy)
    The complement of an integer is the integer you get when you flip all the
    0's to 1's and all the 1's to 0's in its binary representation. For example,
    The integer 5 is "101" in binary and its complement is "010" which is the
    integer 2. Given an integer num, return its complement.

    Example 1:
    Input: num = 5
    Output: 2
    Explanation: The binary representation of 5 is 101 (no leading zero bits),
                 and its complement is 010. So you need to output 2.

    Example 2:
    Input: num = 1
    Output: 0
    Explanation: The binary representation of 1 is 1 (no leading zero bits), and
                 its complement is 0. So you need to output 0.

    Constraints: 1 <= num < 2^31

    Note: This question is the same as 1009:
          https://leetcode.com/problems/complement-of-base-10-integer/*/

    public int findComplement(int num) {
        int mask = 1;
        while (mask < num) mask = mask << 1 | 1;
        return mask ^ num;
    }


    /*502. IPO (Hard)
    Suppose LeetCode will start its IPO soon. In order to sell a good price of
    its shares to Venture Capital, LeetCode would like to work on some projects
    to increase its capital before the IPO. Since it has limited resources, it
    can only finish at most k distinct projects before the IPO. Help LeetCode
    design the best way to maximize its total capital after finishing at most k
    distinct projects. You are given n projects where the ith project has a
    pure profit profits[i] and a minimum capital of capital[i] is needed to
    start it. Initially, you have w capital. When you finish a project, you
    will obtain its pure profit and the profit will be added to your total
    capital. Pick a list of at most k distinct projects from given projects to
    maximize your final capital, and return the final maximized capital. The
    answer is guaranteed to fit in a 32-bit signed integer.

    Example 1:
    Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
    Output: 4
    Explanation: Since your initial capital is 0, you can only start the
                 project indexed 0. After finishing it you will obtain profit 1
                 and your capital becomes 1. With capital 1, you can either
                 start the project indexed 1 or the project indexed 2. Since
                 you can choose at most 2 projects, you need to finish the
                 project indexed 2 to get the maximum capital. Therefore,
                 output the final maximized capital, which is 0 + 1 + 3 = 4.

    Example 2:
    Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
    Output: 6

    Constraints:
    * 1 <= k <= 10^5
    * 0 <= w <= 10^9
    * n == profits.length
    * n == capital.length
    * 1 <= n <= 10^5
    * 0 <= profits[i] <= 10^4
    * 0 <= capital[i] <= 10^9*/

    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int n = profits.length;
        int[][] aug = new int[n][2];
        for (int i = 0; i < n; ++i) {
            aug[i][0] = capital[i];
            aug[i][1] = profits[i];
        }
        Arrays.sort(aug, (a, b) -> Integer.compare(a[0], b[0]));
        Queue<Integer> pq = new PriorityQueue<>((a, b) -> Integer.compare(b, a));
        for (int i = 0; k > 0; --k) {
            for (; i < n && aug[i][0] <= w; ++i) pq.add(aug[i][1]);
            if (!pq.isEmpty()) w += pq.poll();
        }
        return w;
    }


    /*506. Relative Ranks (Easy)
    You are given an integer array score of size n, where score[i] is the score
    of the ith athlete in a competition. All the scores are guaranteed to be
    unique. The athletes are placed based on their scores, where the 1st place
    athlete has the highest score, the 2nd place athlete has the 2nd highest
    score, and so on. The placement of each athlete determines their rank:
    * The 1st place athlete's rank is "Gold Medal".
    * The 2nd place athlete's rank is "Silver Medal".
    * The 3rd place athlete's rank is "Bronze Medal".
    * For the 4th place to the nth place athlete, their rank is their placement
      number (i.e., the xth place athlete's rank is "x").
    Return an array answer of size n where answer[i] is the rank of the ith
    athlete.

    Example 1:
    Input: score = [5,4,3,2,1]
    Output: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
    Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].

    Example 2:
    Input: score = [10,3,8,9,4]
    Output: ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
    Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].

    Constraints:
    * n == score.length
    * 1 <= n <= 10^4
    * 0 <= score[i] <= 10^6
    * All the values in score are unique.*/

    public String[] findRelativeRanks(int[] score) {
        int n = score.length;
        Integer[] vals = IntStream.range(0, n).boxed().toArray(Integer[]::new);
        Arrays.sort(vals, (i, j) -> Integer.compare(score[j], score[i]));
        String[] ans = new String[n], medals = {"Gold Medal", "Silver Medal", "Bronze Medal"};
        for (int i = 0; i < n; ++i) {
            if (i <= 2) ans[vals[i]] = medals[i];
            else ans[vals[i]] = String.valueOf(i+1);
        }
        return ans;
    }


    /*513. Find Bottom Left Tree Value (Medium)
    Given the root of a binary tree, return the leftmost value in the last row
    of the tree.

    Example 1:
    Input: root = [2,1,3]

          2
         / \
        1   3

    Output: 1

    Example 2:
    Input: root = [1,2,3,4,null,5,6,null,null,7]

            1
           / \
          2   3
         /   / \
        4   5   6
           /
          7

    Output: 7

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * -2^31 <= Node.val <= 2^31 - 1*/

    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> q = new LinkedList();
        q.add(root);
        TreeNode node = new TreeNode();
        while (!q.isEmpty())
            for (int sz = q.size(); sz > 0; --sz) {
                node = q.poll();
                if (node.right != null) q.add(node.right);
                if (node.left != null) q.add(node.left);
            }
        return node.val;
    }


    /*516. Longest Palindromic Subsequence (Medium)
    Given a string s, find the longest palindromic subsequence's length in s. A
    subsequence is a sequence that can be derived from another sequence by
    deleting some or no elements without changing the order of the remaining
    elements.

    Example 1:
    Input: s = "bbbab"
    Output: 4
    Explanation: One possible longest palindromic subsequence is "bbbb".

    Example 2:
    Input: s = "cbbd"
    Output: 2
    Explanation: One possible longest palindromic subsequence is "bb".

    Constraints:
    * 1 <= s.length <= 1000
    * s consists only of lowercase English letters.*/

    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = n-1; i >= 0; --i) {
            dp[i][i] = 1;
            for (int j = i+1; j < n; ++j)
                if (s.charAt(i) == s.charAt(j)) dp[i][j] = 2 + dp[i+1][j-1];
                else dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
        }
        return dp[0][n-1];
    }


    /*523. Continuous Subarray Sum (Medium)
    Given an integer array nums and an integer k, return true if nums has a good
    subarray or false otherwise. A good subarray is a subarray where:
    * its length is at least two, and
    * the sum of the elements of the subarray is a multiple of k.
    Note that:
    * A subarray is a contiguous part of the array.
    * An integer x is a multiple of k if there exists an integer n such that
      x = n * k. 0 is always a multiple of k.

    Example 1:
    Input: nums = [23,2,4,6,7], k = 6
    Output: true
    Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up
                 to 6.

    Example 2:
    Input: nums = [23,2,6,4,7], k = 6
    Output: true
    Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose
                 elements sum up to 42. 42 is a multiple of 6 because 42 = 7 * 6
                 and 7 is an integer.

    Example 3:
    Input: nums = [23,2,6,4,7], k = 13
    Output: false

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 0 <= sum(nums[i]) <= 2^31 - 1
    * 1 <= k <= 2^31 - 1*/

    public boolean checkSubarraySum(int[] nums, int k) {
        Set<Integer> seen = new HashSet();
        int prefix = 0, prev = 0;
        for (var x : nums) {
            prefix = (prefix+x) % k;
            if (seen.contains(prefix)) return true;
            seen.add(prev);
            prev = prefix;
        }
        return false;
    }


    /*539. Minimum Time Difference (Medium)
    Given a list of 24-hour clock time points in "HH:MM" format, return the
    minimum minutes difference between any two time-points in the list.

    Example 1:
    Input: timePoints = ["23:59","00:00"]
    Output: 1

    Example 2:
    Input: timePoints = ["00:00","23:59","00:00"]
    Output: 0

    Constraints:
    * 2 <= timePoints.length <= 2 * 10^4
    * timePoints[i] is in the format "HH:MM".*/

    public int findMinDifference(List<String> timePoints) {
        List<Integer> vals = new ArrayList<>();
        for (var t : timePoints) {
            int h = Integer.valueOf(t.substring(0, 2)), m = Integer.valueOf(t.substring(3));
            vals.add(60*h + m);
        }
        Collections.sort(vals);
        vals.add(vals.get(0) + 1440);
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i < vals.size(); ++i)
            ans = Math.min(ans, vals.get(i) - vals.get(i-1));
        return ans;
    }


    /*540. Single Element in a Sorted Array (Medium)
    You are given a sorted array consisting of only integers where every
    element appears exactly twice, except for one element which appears exactly
    once. Return the single element that appears only once. Your solution must
    run in O(log n) time and O(1) space.

    Example 1:
    Input: nums = [1,1,2,3,3,4,4,8,8]
    Output: 2

    Example 2:
    Input: nums = [3,3,7,7,10,11,11]
    Output: 10

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5*/

    public int singleNonDuplicate(int[] nums) {
        int lo = 0, hi = nums.length-1;
        while (lo < hi) {
            int mid = lo + (hi-lo)/2;
            if (nums[mid] == nums[mid^1]) lo = mid+1;
            else hi = mid;
        }
        return nums[lo];
    }


    /*548. Split Array with Equal Sum (Hard)
    Given an integer array nums of length n, return true if there is a triplet
    (i, j, k) which satisfies the following conditions:
    * 0 < i, i + 1 < j, j + 1 < k < n - 1
    * The sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and
      (k + 1, n - 1) is equal.
    A subarray (l, r) represents a slice of the original array starting from
    the element indexed l to the element indexed r.

    Example 1:
    Input: nums = [1,2,1,2,1,2,1]
    Output: true
    Explanation: i = 1, j = 3, k = 5.
                 sum(0, i - 1) = sum(0, 0) = 1
                 sum(i + 1, j - 1) = sum(2, 2) = 1
                 sum(j + 1, k - 1) = sum(4, 4) = 1
                 sum(k + 1, n - 1) = sum(6, 6) = 1

    Example 2:
    Input: nums = [1,2,1,2,1,2,1,2]
    Output: false

    Constraints:
    * n == nums.length
    * 1 <= n <= 2000
    * -10^6 <= nums[i] <= 10^6*/

    public boolean splitArray(int[] nums) {
        int n = nums.length;
        int[] prefix = new int[n+1];
        for (int i = 0; i < n; ++i) prefix[i+1] = prefix[i] + nums[i];
        for (int j = 0; j < n; ++j) {
            Set<Integer> seen = new HashSet();
            for (int i = 1; i+1 < j; ++i)
                if (prefix[i] == prefix[j] - prefix[i+1]) seen.add(prefix[i]);
            for (int k = j+2; k+1 < n; ++k)
                if (prefix[k] - prefix[j+1] == prefix[n] - prefix[k+1] && seen.contains(prefix[k] - prefix[j+1])) return true;
        }
        return false;
    }


    /*567. Permutation in String (Medium)
    Given two strings s1 and s2, return true if s2 contains a permutation of s1,
    or false otherwise. In other words, return true if one of s1's permutations
    is the substring of s2.

    Example 1:
    Input: s1 = "ab", s2 = "eidbaooo"
    Output: true
    Explanation: s2 contains one permutation of s1 ("ba").

    Example 2:
    Input: s1 = "ab", s2 = "eidboaoo"
    Output: false

    Constraints:
    * 1 <= s1.length, s2.length <= 10^4
    * s1 and s2 consist of lowercase English letters.*/

    public boolean checkInclusion(String s1, String s2) {
        int[] freq = new int[26];
        for (var ch : s1.toCharArray()) ++freq[ch - 'a'];
        int bal = 0;
        for (int i = 0; i < 26; ++i)
            if (freq[i] > 0) ++bal;
        for (int i = 0, n = s1.length(); i < s2.length(); ++i) {
            if (freq[s2.charAt(i)-'a'] == 0) ++bal;
            if (--freq[s2.charAt(i)-'a'] == 0) --bal;
            if (i >= n) {
                if (freq[s2.charAt(i-n)-'a'] == 0) ++bal;
                if (++freq[s2.charAt(i-n)-'a'] == 0) --bal;
            }
            if (bal == 0) return true;
        }
        return false;
    }


    /*590. N-ary Tree Postorder Traversal (Easy)
    Given the root of an n-ary tree, return the postorder traversal of its
    nodes' values. Nary-Tree input serialization is represented in their level
    order traversal. Each group of children is separated by the null value (See
    examples)

    Example 1:
    Input: root = [1,null,3,2,4,null,5,6]
    Output: [5,6,3,2,4,1]

    Example 2:
    Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]

    Constraints:
    * The number of nodes in the tree is in the range [0, 10^4].
    * 0 <= Node.val <= 10^4
    * The height of the n-ary tree is less than or equal to 1000.

    Follow up: Recursive solution is trivial, could you do it iteratively?*/

    public List<Integer> postorder(Node root) {
        List<Integer> ans = new ArrayList();
        if (root != null) {
            Stack<Node> stk = new Stack(); stk.push(root);
            Node prev = null;
            while (!stk.isEmpty()) {
                var node = stk.peek();
                if (!node.children.isEmpty() && prev != node.children.get(node.children.size()-1))
                    for (int i = node.children.size()-1; i >= 0; --i)
                        stk.push(node.children.get(i));
                else {
                    ans.add(node.val);
                    stk.pop();
                    prev = node;
                }
            }
        }
        return ans;
    }


    /*616. Add Bold Tag in String (Medium)
    You are given a string s and an array of strings words. You should add a
    closed pair of bold tag <b> and </b> to wrap the substrings in s that exist
    in words.
    * If two such substrings overlap, you should wrap them together with only
      one pair of closed bold-tag.
    * If two substrings wrapped by bold tags are consecutive, you should
      combine them.
    Return s after adding the bold tags.

    Example 1:
    Input: s = "abcxyz123", words = ["abc","123"]
    Output: "<b>abc</b>xyz<b>123</b>"
    Explanation: The two strings of words are substrings of s as following:
                 "abcxyz123". We add <b> before each substring and </b> after
                 each substring.

    Example 2:
    Input: s = "aaabbb", words = ["aa","b"]
    Output: "<b>aaabbb</b>"
    Explanation: "aa" appears as a substring two times: "aaabbb" and "aaabbb".
                 "b" appears as a substring three times: "aaabbb", "aaabbb",
                 and "aaabbb". We add <b> before each substring and </b> after
                 each substring: "<b>a<b>a</b>a</b><b>b</b><b>b</b><b>b</b>".
                 Since the first two <b>'s overlap, we merge them:
                 "<b>aaa</b><b>b</b><b>b</b><b>b</b>". Since now the four <b>'s
                 are consecuutive, we merge them: "<b>aaabbb</b>".

    Constraints:
    * 1 <= s.length <= 1000
    * 0 <= words.length <= 100
    * 1 <= words[i].length <= 1000
    * s and words[i] consist of English letters and digits.
    * All the values of words are unique.

    Note: This question is the same as 758:
          https://leetcode.com/problems/bold-words-in-string/*/

    public String addBoldTag(String s, String[] words) {
        int[] line = new int[s.length()+1];
        for (String word : words) {
            for (int k = -1; true; ) {
                k = s.indexOf(word, ++k);
                if (k == -1) break;
                ++line[k];
                --line[k+word.length()];
            }
        }
        StringBuilder ans = new StringBuilder();
        for (int i = 0, prefix = 0; i < s.length(); ++i) {
            if (prefix == 0 && prefix+line[i] > 0) ans.append("<b>");
            ans.append(s.charAt(i));
            prefix += line[i];
            if (prefix > 0 && prefix+line[i+1] == 0) ans.append("</b>");
        }
        return ans.toString();
    }


    /*623. Add One Row to Tree (Medium)
    Given the root of a binary tree and two integers val and depth, add a row of
    nodes with value val at the given depth depth. Note that the root node is at
    depth 1. The adding rule is:
    * Given the integer depth, for each not null tree node cur at the depth
      depth - 1, create two tree nodes with value val as cur's left subtree root
      and right subtree root.
    * cur's original left subtree should be the left subtree of the new left
      subtree root.
    * cur's original right subtree should be the right subtree of the new right
      subtree root.
    * If depth == 1 that means there is no depth depth - 1 at all, then create a
      tree node with value val as the new root of the whole original tree, and
      the original tree is the new root's left subtree.

    Example 1:
    Input: root = [4,2,6,3,1,5], val = 1, depth = 2
    Output: [4,1,1,2,null,null,6,3,1,5]

    Example 2:
    Input: root = [4,2,null,3,1], val = 1, depth = 3
    Output: [4,2,null,1,1,3,null,null,1]

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^4].
    * The depth of the tree is in the range [1, 10^4].
    * -100 <= Node.val <= 100
    * -10^5 <= val <= 10^5
    * 1 <= depth <= the depth of tree + 1*/

    public TreeNode addOneRow(TreeNode root, int val, int depth) {
        if (depth == 1) return new TreeNode(val, root, null);
        Queue<TreeNode> q = new LinkedList();
        q.add(root);
        for (; !q.isEmpty() && depth-1 > 1; --depth) {
            for (int sz = q.size(); sz > 0; --sz) {
                TreeNode node = q.poll();
                if (node.left != null) q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
        }
        while (!q.isEmpty()) {
            TreeNode node = q.poll();
            node.left = new TreeNode(val, node.left, null);
            node.right = new TreeNode(val, null, node.right);
        }
        return root;
    }


    /*624. Maximum Distance in Arrays (Medium)
    You are given m arrays, where each array is sorted in ascending order. You
    can pick up two integers from two different arrays (each array picks one)
    and calculate the distance. We define the distance between two integers a
    and b to be their absolute difference |a - b|. Return the maximum distance.

    Example 1:
    Input: arrays = [[1,2,3],[4,5],[1,2,3]]
    Output: 4
    Explanation: One way to reach the maximum distance 4 is to pick 1 in the
                 first or third array and pick 5 in the second array.

    Example 2:
    Input: arrays = [[1],[1]]
    Output: 0

    Constraints:
    * m == arrays.length
    * 2 <= m <= 10^5
    * 1 <= arrays[i].length <= 500
    * -10^4 <= arrays[i][j] <= 10^4
    * arrays[i] is sorted in ascending order.
    * There will be at most 10^5 integers in all the arrays.*/

    public int maxDistance(List<List<Integer>> arrays) {
        int ans = 0, small = 100_000, large = -100_000;
        for (var array : arrays) {
            int n = array.size();
            ans = Math.max(ans, Math.max(large - array.get(0), array.get(n-1) - small));
            small = Math.min(small, array.get(0));
            large = Math.max(large, array.get(n-1));
        }
        return ans;
    }


    /*633. Sum of Square Numbers (Medium)
    Given a non-negative integer c, decide whether there're two integers a and b
    such that a2 + b2 = c.

    Example 1:
    Input: c = 5
    Output: true
    Explanation: 1 * 1 + 2 * 2 = 5

    Example 2:
    Input: c = 3
    Output: false

    Constraints: 0 <= c <= 2^31 - 1*/

    public boolean judgeSquareSum(int c) {
        /*Fermat theorem on sum of two squares*/
        for (int x = 2; x*x <= c; ++x)
            if (c % x == 0) {
                int mult = 0;
                for (; c % x == 0; ++mult, c /= x);
                if (x % 4 == 3 && mult % 2 == 1) return false;
            }
        return c % 4 != 3;
    }


    /*644. Maximum Average Subarray II (Hard)
    You are given an integer array nums consisting of n elements, and an
    integer k. Find a contiguous subarray whose length is greater than or equal
    to k that has the maximum average value and return this value. Any answer
    with a calculation error less than 10-5 will be accepted.

    Example 1:
    Input: nums = [1,12,-5,-6,50,3], k = 4
    Output: 12.75000
    Explanation: - When the length is 4, averages are [0.5, 12.75, 10.5] and
                   the maximum average is 12.75
                 - When the length is 5, averages are [10.4, 10.8] and the
                   maximum average is 10.8
                 - When the length is 6, averages are [9.16667] and the maximum
                   average is 9.16667
                 The maximum average is when we choose a subarray of length 4
                 (i.e., the sub array [12, -5, -6, 50]) which has the max
                 average 12.75, so we return 12.75. Note that we do not
                 consider the subarrays of length < 4.

    Example 2:
    Input: nums = [5], k = 1
    Output: 5.00000

    Constraints:
    * n == nums.length
    * 1 <= k <= n <= 10^4
    * -10^4 <= nums[i] <= 10^4*/

    public double findMaxAverage(int[] nums, int k) {
        double lo = -1e4, hi = 1e4;
        while (lo + 1e-5 <= hi) {
            double mid = (lo + hi)/2, lag = 0, prefix = 0;
            boolean found = false;
            for (int i = 0; i < nums.length; ++i) {
                prefix += nums[i] - mid;
                if (i >= k) lag += nums[i-k] - mid;
                if (lag < 0) {
                    prefix -= lag;
                    lag = 0;
                }
                if (i >= k-1 && prefix >= 0) {found = true; break;}
            }
            if (found) lo = mid;
            else hi = mid;
        }
        return lo;
    }


    /*648. Replace Words (Medium)
    In English, we have a concept called root, which can be followed by some
    other word to form another longer word - let's call this word derivative.
    For example, when the root "help" is followed by the word "ful", we can form
    a derivative "helpful". Given a dictionary consisting of many roots and a
    sentence consisting of words separated by spaces, replace all the
    derivatives in the sentence with the root forming it. If a derivative can be
    replaced by more than one root, replace it with the root that has the
    shortest length. Return the sentence after the replacement.

    Example 1:
    Input: dictionary = ["cat","bat","rat"],
           sentence = "the cattle was rattled by the battery"
    Output: "the cat was rat by the bat"

    Example 2:
    Input: dictionary = ["a","b","c"],
           sentence = "aadsfasf absbs bbab cadsfafs"
    Output: "a a b c"

    Constraints:
    * 1 <= dictionary.length <= 1000
    * 1 <= dictionary[i].length <= 100
    * dictionary[i] consists of only lower-case letters.
    * 1 <= sentence.length <= 106
    * sentence consists of only lower-case letters and spaces.
    * The number of words in sentence is in the range [1, 1000]
    * The length of each word in sentence is in the range [1, 1000]
    * Every two consecutive words in sentence will be separated by exactly one
      space.
    * sentence does not have leading or trailing spaces.

    class TrieNode {
        public TrieNode[] next = new TrieNode[26];
        public String word = "";
    }*/

    public String replaceWords(List<String> dictionary, String sentence) {
        TrieNode trie = new TrieNode();
        for (var word : dictionary) {
            TrieNode node = trie;
            for (var ch : word.toCharArray()) {
                if (node.next[ch-'a'] == null)
                    node.next[ch-'a'] = new TrieNode();
                node = node.next[ch-'a'];
            }
            node.word = word;
        }
        List<String> ans = new ArrayList();
        for (var word : sentence.split(" ")) {
            TrieNode node = trie;
            for (var ch : word.toCharArray()) {
                node = node.next[ch-'a'];
                if (node == null || node.word.length() > 0) {
                    if (node != null) word = node.word;
                    break;
                }
            }
            ans.add(word);
        }
        return String.join(" ", ans);
    }


    /*650. 2 Keys Keyboard (Medium)
    There is only one character 'A' on the screen of a notepad. You can perform
    one of two operations on this notepad for each step:
    * Copy All: You can copy all the characters present on the screen (a partial
      copy is not allowed).
    * Paste: You can paste the characters which are copied last time.
    Given an integer n, return the minimum number of operations to get the
    character 'A' exactly n times on the screen.

    Example 1:
    Input: n = 3
    Output: 3
    Explanation: Initially, we have one character 'A'.
                 - In step 1, we use Copy All operation.
                 - In step 2, we use Paste operation to get 'AA'.
                 - In step 3, we use Paste operation to get 'AAA'.

    Example 2:
    Input: n = 1
    Output: 0

    Constraints: 1 <= n <= 1000*/

    public int minSteps(int n) {
        int[] dp = IntStream.range(0, n+1).toArray();
        dp[1] = 0;
        for (int x = 2; x <= n; ++x)
            for (int p = 2; p <= Math.sqrt(x); ++p)
                if (x % p == 0)
                    dp[x] = Math.min(dp[x], dp[x/p] + p);
        return dp[n];
    }


    /*656. Coin Path (Hard)
    You are given an integer array coins (1-indexed) of length n and an integer
    maxJump. You can jump to any index i of the array coins if coins[i] != -1
    and you have to pay coins[i] when you visit index i. In addition to that,
    if you are currently at index i, you can only jump to any index i + k where
    i + k <= n and k is a value in the range [1, maxJump]. You are initially
    positioned at index 1 (coins[1] is not -1). You want to find the path that
    reaches index n with the minimum cost. Return an integer array of the
    indices that you will visit in order so that you can reach index n with the
    minimum cost. If there are multiple paths with the same cost, return the
    lexicographically smallest such path. If it is not possible to reach index
    n, return an empty array. A path p1 = [Pa1, Pa2, ..., Pax] of length x is
    lexicographically smaller than p2 = [Pb1, Pb2, ..., Pbx] of length y, if
    and only if at the first j where Paj and Pbj differ, Paj < Pbj; when no
    such j exists, then x < y.

    Example 1:
    Input: coins = [1,2,4,-1,2], maxJump = 2
    Output: [1,3,5]

    Example 2:
    Input: coins = [1,2,4,-1,2], maxJump = 1
    Output: []

    Constraints:
    * 1 <= coins.length <= 1000
    * -1 <= coins[i] <= 100
    * coins[1] != -1
    * 1 <= maxJump <= 100*/

    public List<Integer> cheapestJump(int[] coins, int maxJump) {
        int n = coins.length;
        int[] dp = new int[n];
        Arrays.fill(dp, -1);
        if (coins[n-1] != -1) dp[n-1] = coins[n-1];
        int[] jump = new int[n];
        Arrays.fill(jump, -1);
        for (int i = n-2; i >= 0; --i)
            if (coins[i] != -1)
                for (int ii = Math.min(n-1, i+maxJump); ii > i; --ii)
                    if (dp[ii] != -1) {
                        int cand = coins[i] + dp[ii];
                        if (dp[i] == -1 || cand <= dp[i]) {
                            dp[i] = cand;
                            jump[i] = ii;
                        }
                    }
        List<Integer> ans = new ArrayList();
        if (dp[0] != -1)
            for (int i = 0; i >= 0; i = jump[i])
                ans.add(i+1);
        return ans;
    }


    /*660. Remove 9 (Hard)
    Start from integer 1, remove any integer that contains 9 such as 9, 19, 29...
    Now, you will have a new integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...].
    Given an integer n, return the nth (1-indexed) integer in the new sequence.

    Example 1:
    Input: n = 9
    Output: 10

    Example 2:
    Input: n = 10
    Output: 11

    Constraints: 1 <= n <= 8 * 10^8*/

    public int newInteger(int n) {
        int ans = 0;
        for (int base = 1; n > 0; base *= 10) {
            ans = n%9 * base + ans;
            n /= 9;
        }
        return ans;
    }


    /*662. Maximum Width of Binary Tree (Medium)
    Given the root of a binary tree, return the maximum width of the given tree.
    The maximum width of a tree is the maximum width among all levels. The
    width of one level is defined as the length between the end-nodes (the
    leftmost and rightmost non-null nodes), where the null nodes between the
    end-nodes that would be present in a complete binary tree extending down to
    that level are also counted into the length calculation. It is guaranteed
    that the answer will in the range of a 32-bit signed integer.

    Example 1:
    Input: root = [1,3,2,5,3,null,9]
    Output: 4
    Explanation: The maximum width exists in the third level with length 4 (5,3,null,9).

    Example 2:
    Input: root = [1,3,2,5,null,null,9,6,null,7]
    Output: 7
    Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).

    Example 3:
    Input: root = [1,3,2,5]
    Output: 2
    Explanation: The maximum width exists in the second level with length 2 (3,2).

    Constraints:
    * The number of nodes in the tree is in the range [1, 3000].
    * -100 <= Node.val <= 100*/

    public int widthOfBinaryTree(TreeNode root) {
        int ans = 0;
        Deque<Map.Entry<TreeNode, Integer>> q = new LinkedList();
        q.add(new AbstractMap.SimpleEntry(root, 0));
        while (!q.isEmpty()) {
            ans = Math.max(ans, q.getLast().getValue() - q.peek().getValue() + 1);
            for (int sz = q.size(); sz > 0; --sz) {
                var elem = q.poll();
                TreeNode node = elem.getKey();
                int x = elem.getValue();
                if (node.left != null) q.add(new AbstractMap.SimpleEntry(node.left, 2*x));
                if (node.right != null) q.add(new AbstractMap.SimpleEntry(node.right, 2*x+1));
            }
        }
        return ans;
    }


    /*664. Strange Printer (Hard)
    There is a strange printer with the following two special properties:
    * The printer can only print a sequence of the same character each time.
    * At each turn, the printer can print new characters starting from and
      ending at any place and will cover the original existing characters.
    Given a string s, return the minimum number of turns the printer needed to
    print it.

    Example 1:
    Input: s = "aaabbb"
    Output: 2
    Explanation: Print "aaa" first and then print "bbb".

    Example 2:
    Input: s = "aba"
    Output: 2
    Explanation: Print "aaa" first and then print "b" from the second place of
                 the string, which will cover the existing character 'a'.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters.*/

    public int strangePrinter(String s) {
        int n = s.length();
        int[][] dp = new int[n+1][n+1];
        for (int i = 0; i < n; ++i)
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        for (int i = n-1; i >= 0; --i) {
            dp[i][i] = 0;
            for (int j = i+1; j <= n; ++j) {
                dp[i][j] = 1 + dp[i+1][j];
                for (int k = i+1; k < j; ++k)
                    if (s.charAt(i) == s.charAt(k))
                        dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j]);
            }
        }
        return dp[0][n];
    }


    /*678. Valid Parenthesis String (Medium)
    Given a string s containing only three types of characters: '(', ')' and
    '*', return true if s is valid. The following rules define a valid string:
    * Any left parenthesis '(' must have a corresponding right parenthesis ')'.
    * Any right parenthesis ')' must have a corresponding left parenthesis '('.
    * Left parenthesis '(' must go before the corresponding right parenthesis
      ')'.
    * '*' could be treated as a single right parenthesis ')' or a single left
      parenthesis '(' or an empty string "".

    Example 1:
    Input: s = "()"
    Output: true

    Example 2:
    Input: s = "(*)"
    Output: true

    Example 3:
    Input: s = "(*))"
    Output: true

    Constraints:
    * 1 <= s.length <= 100
    * s[i] is '(', ')' or '*'.*/

    public boolean checkValidString(String s) {
        int lower = 0, upper = 0;
        for (var ch : s.toCharArray()) {
            if (ch == '(') ++lower;
            else if (lower > 0) --lower;
            if (ch == '(' || ch == '*') ++upper;
            else --upper;
            if (upper < 0) return false;
        }
        return lower == 0;
    }


    /*683. K Empty Slots (Hard)
    You have n bulbs in a row numbered from 1 to n. Initially, all the bulbs
    are turned off. We turn on exactly one bulb every day until all bulbs are
    on after n days. You are given an array bulbs of length n where
    bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at
    position x where i is 0-indexed and x is 1-indexed. Given an integer k,
    return the minimum day number such that there exists two turned on bulbs
    that have exactly k bulbs between them that are all turned off. If there
    isn't such day, return -1.

    Example 1:
    Input: bulbs = [1,3,2], k = 1
    Output: 2
    Explanation: - On the first day: bulbs[0] = 1, first bulb is turned on:
                   [1,0,0]
                 - On the second day: bulbs[1] = 3, third bulb is turned on:
                   [1,0,1]
                 - On the third day: bulbs[2] = 2, second bulb is turned on:
                   [1,1,1]
                 We return 2 because on the second day, there were two on
                 bulbs with one off bulb between them.

    Example 2:
    Input: bulbs = [1,2,3], k = 1
    Output: -1

    Constraints:
    * n == bulbs.length
    * 1 <= n <= 2 * 10^4
    * 1 <= bulbs[i] <= n
    * bulbs is a permutation of numbers from 1 to n.
    * 0 <= k <= 2 * 10^4*/

    public int kEmptySlots(int[] bulbs, int k) {
        int n = bulbs.length, ans = Integer.MAX_VALUE;
        int[] days = new int[n];
        for (int i = 0; i < n; ++i) days[bulbs[i]-1] = i+1;
        for (int i = 0, lo = 0, hi = k+1; hi < n; ++i)
            if (days[lo] > days[i] || days[i] < days[hi] || i == hi) {
                if (i == hi) ans = Math.min(ans, Math.max(days[lo], days[hi]));
                lo = i;
                hi = i+k+1;
            }
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }


    /*711. Number of Distinct Islands II (Hard)
    You are given an m x n binary matrix grid. An island is a group of 1's
    (representing land) connected 4-directionally (horizontal or vertical.) You
    may assume all four edges of the grid are surrounded by water. An island is
    considered to be the same as another if they have the same shape, or have
    the same shape after rotation (90, 180, or 270 degrees only) or reflection
    (left/right direction or up/down direction). Return the number of distinct
    islands.

    Example 1:
    Input: grid = [[1,1,0,0,0],[1,0,0,0,0],[0,0,0,0,1],[0,0,0,1,1]]
    Output: 1
    Explanation: The two islands are considered the same because if we make a
                 180 degrees clockwise rotation on the first island, then two
                 islands will have the same shapes.

    Example 2:
    Input: grid = [[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]
    Output: 1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * grid[i][j] is either 0 or 1.*/

    public int numDistinctIslands2(int[][] grid) {
        int ans = 0, m = grid.length, n = grid[0].length;
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        Set<String> seen = new HashSet();
        for (int r = 0; r < m; ++r)
            for (int c = 0; c < n; ++c)
                if (grid[r][c] == 1) {
                    List<int[]>[] vals = new ArrayList[8];
                    for (int k = 0; k < 8; ++k) vals[k] = new ArrayList();
                    grid[r][c] = 0;
                    Stack<int[]> stk = new Stack();
                    stk.add(new int[]{r, c});
                    while (!stk.isEmpty()) {
                        var elem = stk.pop();
                        int i = elem[0], j = elem[1];
                        int[][] d = new int[][]{{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
                        for (int k = 0; k < 4; ++k) {
                            vals[k].add(new int[]{i*d[k][0], j*d[k][1]});
                            vals[k+4].add(new int[]{j*d[k][0], i*d[k][1]});
                        }
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] == 1) {
                                grid[ii][jj] = 0;
                                stk.add(new int[]{ii, jj});
                            }
                        }
                    }
                    boolean found = false;
                    Set<String> temp = new HashSet();
                    for (int k = 0; k < 8; ++k) {
                        int mx = Integer.MAX_VALUE, my = Integer.MAX_VALUE;
                        for (var elem : vals[k]) {
                            mx = Math.min(mx, elem[0]);
                            my = Math.min(my, elem[1]);
                        }
                        for (int i = 0; i < vals[k].size(); ++i) {
                            vals[k].get(i)[0] -= mx;
                            vals[k].get(i)[1] -= my;
                        }
                        Collections.sort(vals[k], (a, b) -> (a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1])));
                        StringBuilder sb = new StringBuilder();
                        for (var elem : vals[k])
                            sb.append(elem[0] + "," + elem[1] + ";");
                        String key = sb.toString();
                        if (seen.contains(key)) {
                            found = true;
                            break;
                        }
                        temp.add(key);
                    }
                    if (!found) {
                        ++ans;
                        for (var v : temp) seen.add(v);
                    }
                }
        return ans;
    }


    /*713. Subarray Product Less Than K (Medium)
    Given an array of integers nums and an integer k, return the number of
    contiguous subarrays where the product of all the elements in the subarray
    is strictly less than k.

    Example 1:
    Input: nums = [10,5,2,6], k = 100
    Output: 8
    Explanation: The 8 subarrays that have product less than 100 are:
                 [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
                 Note that [10, 5, 2] is not included as the product of 100 is
                 not strictly less than k.

    Example 2:
    Input: nums = [1,2,3], k = 0
    Output: 0

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * 1 <= nums[i] <= 1000
    * 0 <= k <= 10^6*/

    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int ans = 0, prod = 1;
        for (int i = 0, ii = 0; i < nums.length; ++i) {
            prod *= nums[i];
            while (ii <= i && prod >= k)
                prod /= nums[ii++];
            ans += i-ii+1;
        }
        return ans;
    }


    /*725. Split Linked List in Parts (Medium)
    Given the head of a singly linked list and an integer k, split the linked
    list into k consecutive linked list parts. The length of each part should be
    as equal as possible: no two parts should have a size differing by more than
    one. This may lead to some parts being null. The parts should be in the
    order of occurrence in the input list, and parts occurring earlier should
    always have a size greater than or equal to parts occurring later. Return an
    array of the k parts.

    Example 1:
    Input: head = [1,2,3], k = 5
    Output: [[1],[2],[3],[],[]]
    Explanation: The first element output[0] has output[0].val = 1,
                 output[0].next = null. The last element output[4] is null, but
                 its string representation as a ListNode is [].

    Example 2:
    Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3
    Output: [[1,2,3,4],[5,6,7],[8,9,10]]
    Explanation: The input has been split into consecutive parts with size
                 difference at most 1, and earlier parts are a larger size than
                 the later parts.

    Constraints:
    * The number of nodes in the list is in the range [0, 1000].
    * 0 <= Node.val <= 1000
    * 1 <= k <= 50*/

    public ListNode[] splitListToParts(ListNode head, int k) {
        int sz = 0;
        for (ListNode node = head; node != null; node = node.next, ++sz);

        int q = sz/k, r = sz%k;
        ListNode[] ans = new ListNode[k];
        ListNode node = head;
        for (int i = 0; i < k; ++i) {
            ans[i] = node;
            for (int v = i < r ? q : q-1; v > 0; --v)
                node = node.next;
            if (node != null) {
                ListNode temp = node.next;
                node.next = null;
                node = temp;
            }
        }
        return ans;
    }


    /*727. Minimum Window Subsequence (Hard)
    Given strings s1 and s2, return the minimum contiguous substring part of s1,
    so that s2 is a subsequence of the part. If there is no such window in s1
    that covers all characters in s2, return the empty string "". If there are
    multiple such minimum-length windows, return the one with the left-most
    starting index.

    Example 1:
    Input: s1 = "abcdebdde", s2 = "bde"
    Output: "bcde"
    Explanation: "bcde" is the answer because it occurs before "bdde" which has
                 the same length. "deb" is not a smaller window because the
                 elements of s2 in the window must occur in order.

    Example 2:
    Input: s1 = "jmeqksfrsdcmsiwvaovztaqenprpvnbstl", s2 = "u"
    Output: ""

    Constraints:
    * 1 <= s1.length <= 2 * 10^4
    * 1 <= s2.length <= 100
    * s1 and s2 consist of lowercase English letters.*/

    public String minWindow(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; ++i) Arrays.fill(dp[i], -1);
        if (s1.charAt(0) == s2.charAt(0)) dp[0][0] = 0;
        for (int i = 1; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (s1.charAt(i) == s2.charAt(j))
                    if (j > 0) dp[i][j] = dp[i-1][j-1];
                    else dp[i][j] = i;
                else dp[i][j] = dp[i-1][j];
        String ans = "";
        for (int i = 0; i < m; ++i) {
            int k = dp[i][n-1];
            if (k != -1 && (ans.equals("") || i-k+1 < ans.length())) ans = s1.substring(k, i+1);
        }
        return ans;
    }


    /*734. Sentence Similarity (Easy)
    We can represent a sentence as an array of words, for example, the sentence
    "I am happy with leetcode" can be represented as
    arr = ["I","am",happy","with","leetcode"]. Given two sentences sentence1
    and sentence2 each represented as a string array and given an array of
    string pairs similarPairs where similarPairs[i] = [xi, yi] indicates that
    the two words xi and yi are similar. Return true if sentence1 and sentence2
    are similar, or false if they are not similar. Two sentences are similar if:
    * They have the same length (i.e., the same number of words)
    * sentence1[i] and sentence2[i] are similar.
    Notice that a word is always similar to itself, also notice that the
    similarity relation is not transitive. For example, if the words a and b
    are similar, and the words b and c are similar, a and c are not necessarily
    similar.

    Example 1:
    Input: sentence1 = ["great","acting","skills"],
           sentence2 = ["fine","drama","talent"],
           similarPairs = [["great","fine"],["drama","acting"],["skills","talent"]]
    Output: true
    Explanation: The two sentences have the same length and each word i of
                 sentence1 is also similar to the corresponding word in
                 sentence2.

    Example 2:
    Input: sentence1 = ["great"], sentence2 = ["great"], similarPairs = []
    Output: true
    Explanation: A word is similar to itself.

    Example 3:
    Input: sentence1 = ["great"],
           sentence2 = ["doubleplus","good"],
           similarPairs = [["great","doubleplus"]]
    Output: false
    Explanation: As they don't have the same length, we return false.

    Constraints:
    * 1 <= sentence1.length, sentence2.length <= 1000
    * 1 <= sentence1[i].length, sentence2[i].length <= 20
    * sentence1[i] and sentence2[i] consist of English letters.
    * 0 <= similarPairs.length <= 1000
    * similarPairs[i].length == 2
    * 1 <= xi.length, yi.length <= 20
    * xi and yi consist of lower-case and upper-case English letters.
    * All the pairs (xi, yi) are distinct.*/

    public boolean areSentencesSimilar(String[] sentence1, String[] sentence2, List<List<String>> similarPairs) {
        if (sentence1.length != sentence2.length) return false;
        Map<String, Set<String>> mp = new HashMap();
        for (var p : similarPairs) {
            mp.putIfAbsent(p.get(0), new HashSet());
            mp.putIfAbsent(p.get(1), new HashSet());
            mp.get(p.get(0)).add(p.get(1));
            mp.get(p.get(1)).add(p.get(0));
        }
        for (int i = 0; i < sentence1.length; ++i)
            if (!sentence1[i].equals(sentence2[i]) && (!mp.containsKey(sentence1[i]) || !mp.get(sentence1[i]).contains(sentence2[i]))) return false;
        return true;
    }


    /*751. IP to CIDR (Medium)
    An IP address is a formatted 32-bit unsigned integer where each group of 8
    bits is printed as a decimal number and the dot character '.' splits the
    groups. For example, the binary number 00001111 10001000 11111111 01101011
    (spaces added for clarity) formatted as an IP address would be
    "15.136.255.107". A CIDR block is a format used to denote a specific set of
    IP addresses. It is a string consisting of a base IP address, followed by a
    slash, followed by a prefix length k. The addresses it covers are all the
    IPs whose first k bits are the same as the base IP address. For example,
    "123.45.67.89/20" is a CIDR block with a prefix length of 20. Any IP
    address whose binary representation matches
    01111011 00101101 0100xxxx xxxxxxxx, where x can be either 0 or 1, is in
    the set covered by the CIDR block. You are given a start IP address ip and
    the number of IP addresses we need to cover n. Your goal is to use as few
    CIDR blocks as possible to cover all the IP addresses in the inclusive
    range [ip, ip + n - 1] exactly. No other IP addresses outside of the range
    should be covered. Return the shortest list of CIDR blocks that covers the
    range of IP addresses. If there are multiple answers, return any of them.

    Example 1:
    Input: ip = "255.0.0.7", n = 10
    Output: ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
    Explanation: The IP addresses that need to be covered are:
                 - 255.0.0.7  -> 11111111 00000000 00000000 00000111
                 - 255.0.0.8  -> 11111111 00000000 00000000 00001000
                 - 255.0.0.9  -> 11111111 00000000 00000000 00001001
                 - 255.0.0.10 -> 11111111 00000000 00000000 00001010
                 - 255.0.0.11 -> 11111111 00000000 00000000 00001011
                 - 255.0.0.12 -> 11111111 00000000 00000000 00001100
                 - 255.0.0.13 -> 11111111 00000000 00000000 00001101
                 - 255.0.0.14 -> 11111111 00000000 00000000 00001110
                 - 255.0.0.15 -> 11111111 00000000 00000000 00001111
                 - 255.0.0.16 -> 11111111 00000000 00000000 00010000
                 The CIDR block "255.0.0.7/32" covers the first address. The
                 CIDR block "255.0.0.8/29" covers the middle 8 addresses
                 (binary format of 11111111 00000000 00000000 00001xxx). The
                 CIDR block "255.0.0.16/32" covers the last address. Note that
                 while the CIDR block "255.0.0.0/28" does cover all the
                 addresses, it also includes addresses outside of the range, so
                 we cannot use it.

    Example 2:
    Input: ip = "117.145.102.62", n = 8
    Output: ["117.145.102.62/31","117.145.102.64/30","117.145.102.68/31"]

    Constraints:
    * 7 <= ip.length <= 15
    * ip is a valid IPv4 on the form "a.b.c.d" where a, b, c, and d are
      integers in the range [0, 255].
    * 1 <= n <= 1000
    * Every implied address ip + x (for x < n) will be a valid IPv4 address.*/

    public List<String> ipToCIDR(String ip, int n) {
        int val = 0;
        for (var x : ip.split("\\."))
            val = (val << 8) | Integer.valueOf(x);
        List<String> ans = new ArrayList();
        for (int i = 0; n > 0; n -= 1<<i, val += 1<<i) {
            for (i = 0; i < 32 && (val & 1<<i) == 0 && (1<<i+1) <= n; ++i);
            StringBuilder elem = new StringBuilder();
            for (int k = 24; k >= 0; k -= 8) {
                elem.append(Integer.toString(val >> k & 0xFF));
                if (k > 0) elem.append(".");
            }
            ans.add(elem + "/" + Integer.toString(32-i));
        }
        return ans;
    }


    /*758. Bold Words in String (Medium)
    Given an array of keywords words and a string s, make all appearances of
    all keywords words[i] in s bold. Any letters between <b> and </b> tags
    become bold. Return s after adding the bold tags. The returned string
    should use the least number of tags possible, and the tags should form a
    valid combination.

    Example 1:
    Input: words = ["ab","bc"], s = "aabcd"
    Output: "a<b>abc</b>d"
    Explanation: Note that returning "a<b>a<b>b</b>c</b>d" would use more tags,
                 so it is incorrect.

    Example 2:
    Input: words = ["ab","cb"], s = "aabcd"
    Output: "a<b>ab</b>cd"

    Constraints:
    * 1 <= s.length <= 500
    * 0 <= words.length <= 50
    * 1 <= words[i].length <= 10
    * s and words[i] consist of lowercase English letters.

    Note: This question is the same as 616:
          https://leetcode.com/problems/add-bold-tag-in-string/*/

    public String boldWords(String[] words, String s) {
        int[] line = new int[s.length()+1];
        for (String word : words) {
            for (int k = -1; true; ) {
                k = s.indexOf(word, ++k);
                if (k == -1) break;
                ++line[k];
                --line[k+word.length()];
            }
        }
        StringBuilder ans = new StringBuilder();
        for (int i = 0, prefix = 0; i < s.length(); ++i) {
            if (prefix == 0 && prefix+line[i] > 0) ans.append("<b>");
            ans.append(s.charAt(i));
            prefix += line[i];
            if (prefix > 0 && prefix+line[i+1] == 0) ans.append("</b>");
        }
        return ans.toString();
    }


    /*759. Employee Free Time (Hard)
    We are given a list schedule of employees, which represents the working
    time for each employee. Each employee has a list of non-overlapping
    Intervals, and these intervals are in sorted order. Return the list of
    finite intervals representing common, positive-length free time for all
    employees, also in sorted order. (Even though we are representing Intervals
    in the form [x, y], the objects inside are Intervals, not lists or arrays.
    For example, schedule[0][0].start = 1, schedule[0][0].end = 2, and
    schedule[0][0][0] is not defined).  Also, we wouldn't include intervals
    like [5, 5] in our answer, as they have zero length.

    Example 1:
    Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
    Output: [[3,4]]
    Explanation: There are a total of three employees, and all common free time
                 intervals would be [-inf, 1], [3, 4], [10, inf]. We discard
                 any intervals that contain inf as they aren't finite.

    Example 2:
    Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
    Output: [[5,6],[7,9]]

    Constraints:
    * 1 <= schedule.length , schedule[i].length <= 50
    * 0 <= schedule[i].start < schedule[i].end <= 10^8*/

    public List<Interval> employeeFreeTime(List<List<Interval>> schedule) {
        List<int[]> line = new ArrayList();
        for (var elem : schedule)
            for (var x : elem) {
                line.add(new int[] {x.start, 1});
                line.add(new int[] {x.end, -1});
            }
        Collections.sort(line, (a, b) -> (a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1])));
        List<Interval> ans = new ArrayList();
        int prev = Integer.MIN_VALUE, prefix = 0;
        for (int i = 0; i < line.size(); ) {
            int k = line.get(i)[0];
            if (prefix == 0 && prev > Integer.MIN_VALUE) ans.add(new Interval(prev, k));
            for (int ii = i; i < line.size() && line.get(ii)[0] == line.get(i)[0]; ++i)
                prefix += line.get(i)[1];
            if (prefix == 0) prev = k;
        }
        return ans;
    }


    /*772. Basic Calculator III (Hard)
    Implement a basic calculator to evaluate a simple expression string. The
    expression string contains only non-negative integers, '+', '-', '*', '/'
    operators, and open '(' and closing parentheses ')'. The integer division
    should truncate toward zero. You may assume that the given expression is
    always valid. All intermediate results will be in the range of
    [-2^31, 2^31 - 1]. Note: You are not allowed to use any built-in function
    which evaluates strings as mathematical expressions, such as eval().

    Example 1:
    Input: s = "1+1"
    Output: 2

    Example 2:
    Input: s = "6-4/2"
    Output: 4

    Example 3:
    Input: s = "2*(5+5*2)/3+(6/2+8)"
    Output: 21

    Constraints:
    * 1 <= s <= 10^4
    * s consists of digits, '+', '-', '*', '/', '(', and ')'.
    * s is a valid expression.*/

    public int calculate(String s) {
        s = "(" + s + ")";
        Map<Character, Integer> precedence = new HashMap();
        precedence.put('(', 0);
        precedence.put(')', 1);
        precedence.put('+', 1);
        precedence.put('-', 1);
        precedence.put('*', 2);
        precedence.put('/', 2);
        Stack<Character> ops = new Stack();
        List<String> postfix = new ArrayList();
        for (int i = 0, v = 0; i < s.length(); ++i) {
            if ('0' <= s.charAt(i) && s.charAt(i) <= '9') v = 10*v + s.charAt(i) - '0';
            else {
                if (i > 0 && '0' <= s.charAt(i-1) && s.charAt(i-1) <= '9') postfix.add(Integer.toString(v));
                v = 0;
                if (s.charAt(i) == '(') ops.push(s.charAt(i));
                else {
                    while (!ops.isEmpty() && precedence.get(ops.peek()) >= precedence.get(s.charAt(i)))
                        postfix.add(String.valueOf(ops.pop()));
                    if (s.charAt(i) == ')') ops.pop();
                    else ops.push(s.charAt(i));
                }
            }
        }
        Stack<Integer> stk = new Stack();
        for (var v : postfix) {
            if (v.equals("+") || v.equals("-") || v.equals("*") || v.equals("/")) {
                int y = stk.pop(), x = stk.pop();
                if (v.equals("+")) x += y;
                else if (v.equals("-")) x -= y;
                else if (v.equals("*")) x *= y;
                else x /= y;
                stk.push(x);
            } else stk.push(Integer.parseInt(v));
        }
        return stk.pop();
    }


    /*774. Minimize Max Distance to Gas Station (Hard)
    You are given an integer array stations that represents the positions of
    the gas stations on the x-axis. You are also given an integer k. You should
    add k new gas stations. You can add the stations anywhere on the x-axis,
    and not necessarily on an integer position. Let penalty() be the maximum
    distance between adjacent gas stations after adding the k new stations.
    Return the smallest possible value of penalty(). Answers within 10^-6 of
    the actual answer will be accepted.

    Example 1:
    Input: stations = [1,2,3,4,5,6,7,8,9,10], k = 9
    Output: 0.50000

    Example 2:
    Input: stations = [23,24,36,39,46,56,57,65,84,98], k = 1
    Output: 14.00000

    Constraints:
    * 10 <= stations.length <= 2000
    * 0 <= stations[i] <= 10^8
    * stations is sorted in a strictly increasing order.
    * 1 <= k <= 10^6*/

    public double minmaxGasDist(int[] stations, int k) {
        int n = stations.length;
        double lo = 0, hi = stations[n-1] - stations[0];
        while (lo + 1e-6 < hi) {
            double mid = (lo + hi)/2;
            int kk = 0;
            for (int i = 0; i < n-1; ++i)
                kk += (int) (stations[i+1]-stations[i])/mid;
            if (kk <= k) hi = mid;
            else lo = mid;
        }
        return lo;
    }


    /*783. Minimum Distance Between BST Nodes (Easy)
    Given the root of a Binary Search Tree (BST), return the minimum difference
    between the values of any two different nodes in the tree.

    Example 1:
    Input: root = [4,2,6,1,3]
    Output: 1

    Example 2:
    Input: root = [1,0,48,null,null,12,49]
    Output: 1

    Constraints:
    * The number of nodes in the tree is in the range [2, 100].
    * 0 <= Node.val <= 10^5

    Note: This question is the same as 530:
          https://leetcode.com/problems/minimum-absolute-difference-in-bst/*/

    public int minDiffInBST(TreeNode root) {
        int ans = Integer.MAX_VALUE, prev = -1;
        TreeNode node = root;
        Stack<TreeNode> stk = new Stack();
        while (node != null || !stk.isEmpty())
            if (node != null) {
                stk.add(node);
                node = node.left;
            } else {
                node = stk.pop();
                if (prev >= 0) ans = Math.min(ans, node.val - prev);
                prev = node.val;
                node = node.right;
            }
        return ans;
    }


    /*786. K-th Smallest Prime Fraction (Medium)
    You are given a sorted integer array arr containing 1 and prime numbers,
    where all the integers of arr are unique. You are also given an integer k.
    For every i and j where 0 <= i < j < arr.length, we consider the fraction
    arr[i] / arr[j]. Return the kth smallest fraction considered. Return your
    answer as an array of integers of size 2, where answer[0] == arr[i] and
    answer[1] == arr[j].

    Example 1:
    Input: arr = [1,2,3,5], k = 3
    Output: [2,5]
    Explanation: The fractions to be considered in sorted order are:
                 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.
                 The third fraction is 2/5.

    Example 2:
    Input: arr = [1,7], k = 1
    Output: [1,7]

    Constraints:
    * 2 <= arr.length <= 1000
    * 1 <= arr[i] <= 3 * 104
    * arr[0] == 1
    * arr[i] is a prime number for i > 0.
    * All the numbers of arr are unique and sorted in strictly increasing order.
    * 1 <= k <= arr.length * (arr.length - 1) / 2

    Follow up: Can you solve the problem with better than O(n2) complexity?*/

    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        int n = arr.length;
        Queue<int[]> pq = new PriorityQueue<>(
            (x, y) -> Integer.compare(arr[x[0]]*arr[y[1]], arr[x[1]]*arr[y[0]])
        );
        for (int i = 0; i < n-1; ++i)
            pq.add(new int[]{i, n-1});
        int i = 0, j = 0;
        while (k-- > 0) {
            var elem = pq.poll();
            i = elem[0];
            j = elem[1];
            if (i < j-1) pq.add(new int[]{i, j-1});
        }
        return new int[]{arr[i], arr[j]};
    }


    /*787. Cheapest Flights Within K Stops (Medium)
    There are n cities connected by some number of flights. You are given an
    array flights where flights[i] = [fromi, toi, pricei] indicates that there
    is a flight from city fromi to city toi with cost pricei. You are also
    given three integers src, dst, and k, return the cheapest price from src to
    dst with at most k stops. If there is no such route, return -1.

    Example 1:
    Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1
    Output: 700
    Explanation: The graph is shown above. The optimal path with at most 1 stop
                 from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
                 Note that the path through cities [0,1,2,3] is cheaper but is
                 invalid because it uses 2 stops.

    Example 2:
    Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
    Output: 200
    Explanation: The graph is shown above. The optimal path with at most 1 stop
                 from city 0 to 2 is marked in red and has cost 100 + 100 = 200.

    Example 3:
    Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
    Output: 500
    Explanation: The graph is shown above. The optimal path with no stops from
                 city 0 to 2 is marked in red and has cost 500.

    Constraints:
    * 1 <= n <= 100
    * 0 <= flights.length <= (n * (n - 1) / 2)
    * flights[i].length == 3
    * 0 <= fromi, toi < n
    * fromi != toi
    * 1 <= pricei <= 10^4
    * There will not be any multiple flights between two cities.
    * 0 <= src, dst, k < n
    * src != dst*/

    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        List<int[]>[] graph = new ArrayList[n];
        for (int i = 0; i < n; ++i) graph[i] = new ArrayList();
        for (var f : flights)
            graph[f[0]].add(new int[] {f[1], f[2]});
        Queue<int[]> pq = new PriorityQueue<>((a, b)->Integer.compare(a[0], b[0]));
        pq.add(new int[] {0, src, 0});
        int[][] dist = new int[n][2];
        for (int i = 0; i < n; ++i)
            if (i != src) dist[i][0] = dist[i][1] = Integer.MAX_VALUE;
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            int p = elem[0], u = elem[1], x = elem[2];
            if (u == dst) return p;
            if (x <= k)
                for (var v : graph[u])
                    if (p+v[1] < dist[v[0]][0] || x+1 < dist[v[0]][1]) {
                        pq.add(new int[] {p+v[1], v[0], x+1});
                        if (p+v[1] < dist[v[0]][0] || p+v[1] == dist[v[0]][0] && x+1 < dist[v[0]][1]) {
                            dist[v[0]][0] = p+v[1];
                            dist[v[0]][1] = x+1;
                        }
                    }
        }
        return -1;
    }


    /*826. Most Profit Assigning Work (Medium)
    You have n jobs and m workers. You are given three arrays: difficulty,
    profit, and worker where:
    * difficulty[i] and profit[i] are the difficulty and the profit of the ith
      job, and
    * worker[j] is the ability of jth worker (i.e., the jth worker can only
      complete a job with difficulty at most worker[j]).
    Every worker can be assigned at most one job, but one job can be completed
    multiple times.
    * For example, if three workers attempt the same job that pays $1, then the
      total profit will be $3. If a worker cannot complete any job, their profit
      is $0.
    Return the maximum profit we can achieve after assigning the workers to the
    jobs.

    Example 1:
    Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
    Output: 100
    Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get
                 a profit of [20,20,30,30] separately.

    Example 2:
    Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
    Output: 0

    Constraints:
    * n == difficulty.length
    * n == profit.length
    * m == worker.length
    * 1 <= n, m <= 10^4
    * 1 <= difficulty[i], profit[i], worker[i] <= 10^5*/

    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
        int n = difficulty.length;
        int[][] job = new int[n][2];
        for (int i = 0; i < n; ++i) {
            job[i][0] = difficulty[i];
            job[i][1] = profit[i];
        }
        Arrays.sort(job, (x, y) -> Integer.compare(x[0], y[0]));
        Arrays.sort(worker);
        int ans = 0, k = 0, prefix = 0;
        for (var w : worker) {
            for (; k < n && job[k][0] <= w; ++k)
                prefix = Math.max(prefix, job[k][1]);
            ans += prefix;
        }
        return ans;
    }


    /*834. Sum of Distances in Tree (Hard)
    There is an undirected connected tree with n nodes labeled from 0 to n - 1
    and n - 1 edges. You are given the integer n and the array edges where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. Return an array answer of length n where answer[i] is the sum
    of the distances between the ith node in the tree and all other nodes.

    Example 1:
    Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
    Output: [8,12,6,10,10,10]
    Explanation: The tree is shown above. We can see that dist(0,1) + dist(0,2)
                 + dist(0,3) + dist(0,4) + dist(0,5) equals 1 + 1 + 2 + 2 + 2 =
                 8. Hence, answer[0] = 8, and so on.

    Example 2:
    Input: n = 1, edges = []
    Output: [0]

    Example 3:
    Input: n = 2, edges = [[1,0]]
    Output: [1,1]

    Constraints:
    * 1 <= n <= 3 * 10^4
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * The given input represents a valid tree.*/

    public int[] sumOfDistancesInTree(int n, int[][] edges) {
        List<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; ++i)
            graph[i] = new ArrayList();
        for (var e : edges) {
            int u = e[0], v = e[1];
            graph[u].add(v);
            graph[v].add(u);
        }
        int[] size = new int[n];

        class Solve {
            public int[] fn(int u, int p) {
                int cnt = 0, val = 0;
                for (var v : graph[u])
                    if (v != p) {
                        var elem = fn(v, u);
                        int cc = elem[0], vv = elem[1];
                        cnt += cc;
                        val += cc + vv;
                    }
                size[u] = ++cnt;
                return new int[]{cnt, val};
            }
        }

        int[] ans = new int[n];
        Solve sol = new Solve();
        ans[0] = sol.fn(0, -1)[1];
        Stack<Integer> stk = new Stack();
        stk.push(0);
        while (!stk.isEmpty()) {
            int u = stk.pop();
            for (var v : graph[u])
                if (ans[v] == 0) {
                    ans[v] = ans[u] + n - 2*size[v];
                    stk.push(v);
                }
        }
        return ans;
    }


    /*846. Hand of Straights (Medium)
    Alice has some number of cards and she wants to rearrange the cards into
    groups so that each group is of size groupSize, and consists of groupSize
    consecutive cards. Given an integer array hand where hand[i] is the value
    written on the ith card and an integer groupSize, return true if she can
    rearrange the cards, or false otherwise.

    Example 1:
    Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
    Output: true
    Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]

    Example 2:
    Input: hand = [1,2,3,4,5], groupSize = 4
    Output: false
    Explanation: Alice's hand can not be rearranged into groups of 4.

    Constraints:
    * 1 <= hand.length <= 10^4
    * 0 <= hand[i] <= 10^9
    * 1 <= groupSize <= hand.length

    Note: This question is the same as 1296:
          https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/*/

    public boolean isNStraightHand(int[] hand, int groupSize) {
        TreeMap<Integer, Integer> freq = new TreeMap();
        for (var x : hand)
            freq.merge(x, 1, Integer::sum);
        Queue<int[]> q = new LinkedList();
        int prev = -1, need = 0;
        for (var elem : freq.entrySet()) {
            int x = elem.getKey(), v = elem.getValue();
            if (need > 0 && x > prev+1 || need > v) return false;
            if (v > need) q.add(new int[]{x, v-need});
            prev = x;
            need = v;
            if (!q.isEmpty() && x-q.peek()[0] == groupSize-1) need -= q.poll()[1];
        }
        return need == 0;
    }


    /*857. Minimum Cost to Hire K Workers (Hard)
    There are n workers. You are given two integer arrays quality and wage where
    quality[i] is the quality of the ith worker and wage[i] is the minimum wage
    expectation for the ith worker. We want to hire exactly k workers to form a
    paid group. To hire a group of k workers, we must pay them according to the
    following rules:
    * Every worker in the paid group must be paid at least their minimum wage
      expectation.
    * In the group, each worker's pay must be directly proportional to their
      quality. This means if a worker’s quality is double that of another worker
      in the group, then they must be paid twice as much as the other worker.
    Given the integer k, return the least amount of money needed to form a paid
    group satisfying the above conditions. Answers within 10-5 of the actual
    answer will be accepted.

    Example 1:
    Input: quality = [10,20,5], wage = [70,50,30], k = 2
    Output: 105.00000
    Explanation: We pay 70 to 0th worker and 35 to 2nd worker.

    Example 2:
    Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3
    Output: 30.66667
    Explanation: We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers
                 separately.

    Constraints:
    * n == quality.length == wage.length
    * 1 <= k <= n <= 10^4
    * 1 <= quality[i], wage[i] <= 10^4*/

    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {
        double ans = Double.MAX_VALUE, prefix = 0;
        Queue<Integer> pq = new PriorityQueue<>((x, y) -> Integer.compare(y, x));
        List<int[]> vals = new ArrayList();
        for (int i = 0; i < quality.length; ++i)
            vals.add(new int[]{quality[i], wage[i]});
        Collections.sort(vals, (x, y) -> Integer.compare(x[1]*y[0], y[1]*x[0]));
        for (var elem : vals) {
            int q = elem[0], w = elem[1];
            prefix += q;
            pq.add(q);
            if (pq.size() > k) prefix -= pq.poll();
            if (pq.size() == k) ans = Math.min(ans, prefix*w/q);
        }
        return ans;
    }


    /*860. Lemonade Change (Easy)
    At a lemonade stand, each lemonade costs $5. Customers are standing in a
    queue to buy from you and order one at a time (in the order specified by
    bills). Each customer will only buy one lemonade and pay with either a $5,
    $10, or $20 bill. You must provide the correct change to each customer so
    that the net transaction is that the customer pays $5. Note that you do not
    have any change in hand at first. Given an integer array bills where
    bills[i] is the bill the ith customer pays, return true if you can provide
    every customer with the correct change, or false otherwise.

    Example 1:
    Input: bills = [5,5,5,10,20]
    Output: true
    Explanation: - From the first 3 customers, we collect three $5 bills in
                   order.
                 - From the fourth customer, we collect a $10 bill and give back
                   a $5.
                 - From the fifth customer, we give a $10 bill and a $5 bill.
                 Since all customers got correct change, we output true.

    Example 2:
    Input: bills = [5,5,10,10,20]
    Output: false
    Explanation: - From the first two customers in order, we collect two $5
                   bills.
                 - For the next two customers in order, we collect a $10 bill
                   and give back a $5 bill.
                 - For the last customer, we can not give the change of $15 back
                   because we only have two $10 bills.
                 Since not every customer received the correct change, the
                 answer is false.

    Constraints:
    * 1 <= bills.length <= 10^5
    * bills[i] is either 5, 10, or 20.*/

    public boolean lemonadeChange(int[] bills) {
        int five = 0, ten = 0;
        for (var bill : bills) {
            if (bill == 5) ++five;
            else if (bill == 10) {
                --five;
                ++ten;
            } else if (ten > 0) {
                --five;
                --ten;
            } else five -= 3;
            if (five < 0) return false;
        }
        return true;
    }


    /*861. Score After Flipping Matrix (Medium)
    You are given an m x n binary matrix grid. A move consists of choosing any
    row or column and toggling each value in that row or column (i.e., changing
    all 0's to 1's, and all 1's to 0's). Every row of the matrix is interpreted
    as a binary number, and the score of the matrix is the sum of these numbers.
    Return the highest possible score after making any number of moves
    (including zero moves).

    Example 1:
    Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
    Output: 39
    Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39

    Example 2:
    Input: grid = [[0]]
    Output: 1

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 20
    * grid[i][j] is either 0 or 1.*/

    public int matrixScore(int[][] grid) {
        int m = grid.length, n = grid[0].length, ans = 0;
        for (int j = 0; j < n; ++j) {
            int val = 0;
            for (int i = 0; i < m; ++i)
                if (grid[i][0] == grid[i][j]) ++val;
            val = Math.max(val, m-val);
            ans += val * (1<<n-1-j);
        }
        return ans;
    }


    /*874. Walking Robot Simulation (Medium)
    A robot on an infinite XY-plane starts at point (0, 0) facing north. The
    robot can receive a sequence of these three possible types of commands:
    * -2: Turn left 90 degrees.
    * -1: Turn right 90 degrees.
    * 1 <= k <= 9: Move forward k units, one unit at a time.
    Some of the grid squares are obstacles. The ith obstacle is at grid point
    obstacles[i] = (xi, yi). If the robot runs into an obstacle, then it will
    instead stay in its current location and move on to the next command. Return
    the maximum Euclidean distance that the robot ever gets from the origin
    squared (i.e. if the distance is 5, return 25).

    Note:
    * North means +Y direction.
    * East means +X direction.
    * South means -Y direction.
    * West means -X direction.
    * There can be obstacle in [0,0].

    Example 1:
    Input: commands = [4,-1,3], obstacles = []
    Output: 25
    Explanation: The robot starts at (0, 0):
                 1. Move north 4 units to (0, 4).
                 2. Turn right.
                 3. Move east 3 units to (3, 4).
                 The furthest point the robot ever gets from the origin is
                 (3, 4), which squared is 32 + 42 = 25 units away.

    Example 2:
    Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
    Output: 65
    Explanation: The robot starts at (0, 0):
                 1. Move north 4 units to (0, 4).
                 2. Turn right.
                 3. Move east 1 unit and get blocked by the obstacle at (2, 4),
                    robot is at (1, 4).
                 4. Turn left.
                 5. Move north 4 units to (1, 8).
                 The furthest point the robot ever gets from the origin is
                 (1, 8), which squared is 12 + 82 = 65 units away.

    Example 3:
    Input: commands = [6,-1,-1,6], obstacles = []
    Output: 36
    Explanation: The robot starts at (0, 0):
                 1. Move north 6 units to (0, 6).
                 2. Turn right.
                 3. Turn right.
                 4. Move south 6 units to (0, 0).
                 The furthest point the robot ever gets from the origin is
                 (0, 6), which squared is 62 = 36 units away.

    Constraints:
    * 1 <= commands.length <= 10^4
    * commands[i] is either -2, -1, or an integer in the range [1, 9].
    * 0 <= obstacles.length <= 10^4
    * -3 * 10^4 <= xi, yi <= 3 * 10^4
    * The answer is guaranteed to be less than 2^31.*/

    public int robotSim(int[] commands, int[][] obstacles) {
        int ans = 0, x = 0, y = 0, dx = 0, dy = 1;
        TreeSet<int[]> tabu = new TreeSet<>((arr1, arr2) -> Arrays.compare(arr1, arr2));
        for (var obstacle : obstacles) tabu.add(obstacle);
        for (var command : commands) {
            if (command == -2) { int tmp = dx; dx = -dy; dy = tmp; }
            else if (command == -1) { int tmp = dx; dx = dy; dy = -tmp; }
            else
                while (command-- > 0) {
                    if (tabu.contains(new int[]{x+dx, y+dy})) break;
                    x += dx;
                    y += dy;
                }
            ans = Math.max(ans, x*x + y*y);
        }
        return ans;
    }


    /*881. Boats to Save People (Medium)
    You are given an array people where people[i] is the weight of the ith
    person, and an infinite number of boats where each boat can carry a maximum
    weight of limit. Each boat carries at most two people at the same time,
    provided the sum of the weight of those people is at most limit. Return the
    minimum number of boats to carry every given person.

    Example 1:
    Input: people = [1,2], limit = 3
    Output: 1
    Explanation: 1 boat (1, 2)

    Example 2:
    Input: people = [3,2,2,1], limit = 3
    Output: 3
    Explanation: 3 boats (1, 2), (2) and (3)

    Example 3:
    Input: people = [3,5,3,4], limit = 5
    Output: 4
    Explanation: 4 boats (3), (3), (4), (5)

    Constraints:
    * 1 <= people.length <= 5 * 10^4
    * 1 <= people[i] <= limit <= 3 * 10^4*/

    public int numRescueBoats(int[] people, int limit) {
        Arrays.sort(people);
        int ans = 0;
        for (int lo = 0, hi = people.length-1; lo <= hi; ) {
            if (lo < hi && people[lo] + people[hi] <= limit) ++lo;
            --hi;
            ++ans;
        }
        return ans;
    }


    /*884. Uncommon Words from Two Sentences (Easy)
    A sentence is a string of single-space separated words where each word
    consists only of lowercase letters. A word is uncommon if it appears exactly
    once in one of the sentences, and does not appear in the other sentence.
    Given two sentences s1 and s2, return a list of all the uncommon words. You
    may return the answer in any order.

    Example 1:
    Input: s1 = "this apple is sweet", s2 = "this apple is sour"
    Output: ["sweet","sour"]
    Explanation: The word "sweet" appears only in s1, while the word "sour"
                 appears only in s2.

    Example 2:
    Input: s1 = "apple apple", s2 = "banana"
    Output: ["banana"]

    Constraints:
    * 1 <= s1.length, s2.length <= 200
    * s1 and s2 consist of lowercase English letters and spaces.
    * s1 and s2 do not have leading or trailing spaces.
    * All the words in s1 and s2 are separated by a single space.*/

    public String[] uncommonFromSentences(String s1, String s2) {
        Map<String, Integer> freq = new HashMap<>();
        for (var w : (s1 + " " + s2).split(" "))
            freq.merge(w, 1, Integer::sum);
        return freq.entrySet().stream()
            .filter(e -> e.getValue() == 1)
            .map(e -> e.getKey())
            .toArray(String[]::new);
    }


    /*904. Fruit Into Baskets (Medium)
    You are visiting a farm that has a single row of fruit trees arranged from
    left to right. The trees are represented by an integer array fruits where
    fruits[i] is the type of fruit the ith tree produces. You want to collect
    as much fruit as possible. However, the owner has some strict rules that
    you must follow:
    * You only have two baskets, and each basket can only hold a single type of
      fruit. There is no limit on the amount of fruit each basket can hold.
    * Starting from any tree of your choice, you must pick exactly one fruit
      from every tree (including the start tree) while moving to the right. The
      picked fruits must fit in one of your baskets.
    * Once you reach a tree with fruit that cannot fit in your baskets, you
      must stop.
    Given the integer array fruits, return the maximum number of fruits you can
    pick.

    Example 1:
    Input: fruits = [1,2,1]
    Output: 3
    Explanation: We can pick from all 3 trees.

    Example 2:
    Input: fruits = [0,1,2,2]
    Output: 3
    Explanation: We can pick from trees [1,2,2]. If we had started at the first
                 tree, we would only pick from trees [0,1].

    Example 3:
    Input: fruits = [1,2,3,2,2]
    Output: 4
    Explanation: We can pick from trees [2,3,2,2]. If we had started at the
                 first tree, we would only pick from trees [1,2].

    Constraints:
    * 1 <= fruits.length <= 10^5
    * 0 <= fruits[i] < fruits.length*/

    public int totalFruit(int[] fruits) {
        int ans = 0;
        Map<Integer, Integer> freq = new HashMap();
        for (int i = 0, ii = 0; i < fruits.length; ++i) {
            freq.merge(fruits[i], 1, Integer::sum);
            while (freq.size() > 2) {
                freq.merge(fruits[ii], -1, Integer::sum);
                if (freq.get(fruits[ii]) == 0) freq.remove(fruits[ii]);
                ++ii;
            }
            ans = Math.max(ans, i - ii + 1);
        }
        return ans;
    }


    /*909. Snakes and Ladders (Medium)
    You are given an n x n integer matrix board where the cells are labeled
    from 1 to n2 in a Boustrophedon style starting from the bottom left of the
    board (i.e. board[n - 1][0]) and alternating direction each row. You start
    on square 1 of the board. In each move, starting from square curr, do the
    following:
    * Choose a destination square next with a label in the range
      [curr + 1, min(curr + 6, n2)].
      + This choice simulates the result of a standard 6-sided die roll: i.e.,
        there are always at most 6 destinations, regardless of the size of the
        board.
    * If next has a snake or ladder, you must move to the destination of that
      snake or ladder. Otherwise, you move to next.
    * The game ends when you reach the square n2.
    A board square on row r and column c has a snake or ladder if
    board[r][c] != -1. The destination of that snake or ladder is board[r][c].
    Squares 1 and n2 do not have a snake or ladder. Note that you only take a
    snake or ladder at most once per move. If the destination to a snake or
    ladder is the start of another snake or ladder, you do not follow the
    subsequent snake or ladder.
    * For example, suppose the board is [[-1,4],[-1,3]], and on the first move,
      your destination square is 2. You follow the ladder to square 3, but do
      not follow the subsequent ladder to 4.
    Return the least number of moves required to reach the square n2. If it is
    not possible to reach the square, return -1.

    Example 1:
    Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
    Output: 4
    Explanation: In the beginning, you start at square 1 (at row 5, column 0).
                 You decide to move to square 2 and must take the ladder to
                 square 15. You then decide to move to square 17 and must take
                 the snake to square 13. You then decide to move to square 14
                 and must take the ladder to square 35. You then decide to move
                 to square 36, ending the game. This is the lowest possible
                 number of moves to reach the last square, so return 4.

    Example 2:
    Input: board = [[-1,-1],[-1,3]]
    Output: 1

    Constraints:
    * n == board.length == board[i].length
    * 2 <= n <= 20
    * grid[i][j] is either -1 or in the range [1, n^2].
    * The squares labeled 1 and n2 do not have any ladders or snakes.*/

    public int snakesAndLadders(int[][] board) {
        int n = board.length, ans = 0;
        Queue<Integer> q = new LinkedList();
        q.add(1);
        boolean[] seen = new boolean[n*n];
        seen[0] = true;
        while (!q.isEmpty()) {
            for (int sz = q.size(); sz > 0; --sz) {
                int x = q.poll();
                if (x == n*n) return ans;
                for (int xx = x+1; xx <= x+6 && xx <= n*n; ++xx) {
                    int i = (xx-1)/n, j = (xx-1)%n, jj = i%2 == 1 ? n-1-j : j, val = xx;
                    if (board[n-1-i][jj] != -1) val = board[n-1-i][jj];
                    if (!seen[val-1]) {
                        q.add(val);
                        seen[val-1] = true;
                    }
                }
            }
            ++ans;
        }
        return -1;
    }


    /*912. Sort an Array (Medium)
    Given an array of integers nums, sort the array in ascending order and
    return it. You must solve the problem without using any built-in functions
    in O(nlog(n)) time complexity and with the smallest space complexity
    possible.

    Example 1:
    Input: nums = [5,2,3,1]
    Output: [1,2,3,5]
    Explanation: After sorting the array, the positions of some numbers are not
                 changed (for example, 2 and 3), while the positions of other
                 numbers are changed (for example, 1 and 5).

    Example 2:
    Input: nums = [5,1,1,2,0,0]
    Output: [0,0,1,1,2,5]
    Explanation: Note that the values of nums are not necessairly unique.

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * -5 * 10^4 <= nums[i] <= 5 * 10^4*/

    private void sort(int[] nums, int lo, int hi) {
        if (lo+1 > hi) return;
        int i = lo+1, j = hi-1;
        while (i <= j) {
            if (nums[i] < nums[lo]) ++i;
            else if (nums[j] > nums[lo]) --j;
            else {
                int temp = nums[i];
                nums[i++] = nums[j];
                nums[j--] = temp;
            }
        }
        int temp = nums[lo]; nums[lo] = nums[j]; nums[j] = temp;
        sort(nums, lo, j);
        sort(nums, j+1, hi);
    }

    public int[] sortArray(int[] nums) {
        int n = nums.length;
        Random rand = new Random();
        for (int i = 1; i < n; ++i) {
            int ii = rand.nextInt(i+1);
            int temp = nums[i]; nums[i] = nums[ii]; nums[ii] = temp;
        }
        sort(nums, 0, n);
        return nums;
    }


    /*918. Maximum Sum Circular Subarray (Medium)
    Given a circular integer array nums of length n, return the maximum
    possible sum of a non-empty subarray of nums. A circular array means the
    end of the array connects to the beginning of the array. Formally, the
    next element of nums[i] is nums[(i + 1) % n] and the previous element of
    nums[i] is nums[(i - 1 + n) % n]. A subarray may only include each element
    of the fixed buffer nums at most once. Formally, for a subarray nums[i],
    nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with
    k1 % n == k2 % n.

    Example 1:
    Input: nums = [1,-2,3,-2]
    Output: 3
    Explanation: Subarray [3] has maximum sum 3.

    Example 2:
    Input: nums = [5,-3,5]
    Output: 10
    Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.

    Example 3:
    Input: nums = [-3,-2,-3]
    Output: -2
    Explanation: Subarray [-2] has maximum sum -2.

    Constraints:
    * n == nums.length
    * 1 <= n <= 3 * 10^4
    * -3 * 10^4 <= nums[i] <= 3 * 10^4*/

    public int maxSubarraySumCircular(int[] nums) {
        int large = 0, small = 0, total = 0, most = Integer.MIN_VALUE, least = Integer.MIN_VALUE;
        for (var x : nums) {
            total += x;
            large = Math.max(0, large) + x;
            most  = Math.max(most, large);
            small = Math.max(0, small - x);
            least = Math.max(least, small);
        }
        return most >= 0 ? Math.max(most, total + least) : most;
    }


    /*921. Minimum Add to Make Parentheses Valid (Medium)
    A parentheses string is valid if and only if:
    * It is the empty string,
    * It can be written as AB (A concatenated with B), where A and B are valid
      strings, or
    * It can be written as (A), where A is a valid string.
    You are given a parentheses string s. In one move, you can insert a
    parenthesis at any position of the string.
    * For example, if s = "()))", you can insert an opening parenthesis to be
      "(()))" or a closing parenthesis to be "())))".
    Return the minimum number of moves required to make s valid.

    Example 1:
    Input: s = "())"
    Output: 1

    Example 2:
    Input: s = "((("
    Output: 3

    Constraints:
    * 1 <= s.length <= 1000
    * s[i] is either '(' or ')'.*/

    public int minAddToMakeValid(String s) {
        int left = 0, right = 0;
        for (var ch : s.toCharArray())
            if (ch == '(') ++left;
            else if (left > 0) --left;
            else ++right;
        return left + right;
    }


    /*926. Flip String to Monotone Increasing (Medium)
    A binary string is monotone increasing if it consists of some number of 0's
    (possibly none), followed by some number of 1's (also possibly none). You
    are given a binary string s. You can flip s[i] changing it from 0 to 1 or
    from 1 to 0. Return the minimum number of flips to make s monotone
    increasing.

    Example 1:
    Input: s = "00110"
    Output: 1
    Explanation: We flip the last digit to get 00111.

    Example 2:
    Input: s = "010110"
    Output: 2
    Explanation: We flip to get 011111, or alternatively 000111.

    Example 3:
    Input: s = "00011000"
    Output: 2
    Explanation: We flip to get 00000000.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'.*/

    public int minFlipsMonoIncr(String s) {
        int ones = 0, flip = 0;
        for (var ch : s.toCharArray()) {
            if (ch == '1') ++ones;
            else flip = Math.min(ones, flip+1);
        }
        return flip;
    }


    /*947. Most Stones Removed with Same Row or Column (Medium)
    On a 2D plane, we place n stones at some integer coordinate points. Each
    coordinate point may have at most one stone. A stone can be removed if it
    shares either the same row or the same column as another stone that has not
    been removed. Given an array stones of length n where stones[i] = [xi, yi]
    represents the location of the ith stone, return the largest possible number
    of stones that can be removed.

    Example 1:
    Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
    Output: 5
    Explanation: One way to remove 5 stones is as follows:
                 1. Remove stone [2,2] because it shares the same row as [2,1].
                 2. Remove stone [2,1] because it shares the same column as
                    [0,1].
                 3. Remove stone [1,2] because it shares the same row as [1,0].
                 4. Remove stone [1,0] because it shares the same column as
                    [0,0].
                 5. Remove stone [0,1] because it shares the same row as [0,0].
                 Stone [0,0] cannot be removed since it does not share a
                 row/column with another stone still on the plane.

    Example 2:
    Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
    Output: 3
    Explanation: One way to make 3 moves is as follows:
                 1. Remove stone [2,2] because it shares the same row as [2,0].
                 2. Remove stone [2,0] because it shares the same column as
                    [0,0].
                 3. Remove stone [0,2] because it shares the same row as [0,0].
                 Stones [0,0] and [1,1] cannot be removed since they do not
                 share a row/column with another stone still on the plane.

    Example 3:
    Input: stones = [[0,0]]
    Output: 0
    Explanation: [0,0] is the only stone on the plane, so you cannot remove it.

    Constraints:
    * 1 <= stones.length <= 1000
    * 0 <= xi, yi <= 10^4
    * No two stones are at the same coordinate point.*/

    private int find(int p, Map<Integer, Integer> parent) {
        if (!parent.containsKey(p))
            parent.put(p, p);
        if (p != parent.get(p))
            parent.put(p, find(parent.get(p), parent));
        return parent.get(p);
    }

    public int removeStones(int[][] stones) {
        Map<Integer, Integer> parent = new HashMap<>();
        for (var s : stones) {
            int x = s[0], y = s[1];
            parent.put(find(x, parent), find(-y-1, parent));
        }
        Set<Integer> group = new HashSet<>();
        for (var s : stones)
            group.add(find(s[0], parent));
        return stones.length - group.size();
    }


    /*948. Bag of Tokens (Medium)
    You start with an initial power of power, an initial score of 0, and a bag
    of tokens given as an integer array tokens, where each tokens[i] donates the
    value of tokeni. Your goal is to maximize the total score by strategically
    playing these tokens. In one move, you can play an unplayed token in one of
    the two ways (but not both for the same token):
    * Face-up: If your current power is at least tokens[i], you may play tokeni,
      losing tokens[i] power and gaining 1 score.
    * Face-down: If your current score is at least 1, you may play tokeni,
      gaining tokens[i] power and losing 1 score.
    Return the maximum possible score you can achieve after playing any number
    of tokens.

    Example 1:
    Input: tokens = [100], power = 50
    Output: 0
    Explanation: Since your score is 0 initially, you cannot play the token
                 face-down. You also cannot play it face-up since your power
                 (50) is less than tokens[0] (100).

    Example 2:
    Input: tokens = [200,100], power = 150
    Output: 1
    Explanation: Play token1 (100) face-up, reducing your power to 50 and
                 increasing your score to 1. There is no need to play token0,
                 since you cannot play it face-up to add to your score. The
                 maximum score achievable is 1.

    Example 3:
    Input: tokens = [100,200,300,400], power = 200
    Output: 2
    Explanation: Play the tokens in this order to get a score of 2:
                 - Play token0 (100) face-up, reducing power to 100 and
                   increasing score to 1.
                 - Play token3 (400) face-down, increasing power to 500 and
                   reducing score to 0.
                 - Play token1 (200) face-up, reducing power to 300 and
                   increasing score to 1.
                 - Play token2 (300) face-up, reducing power to 0 and increasing
                   score to 2.
                 - The maximum score achievable is 2.

    Constraints:
    * 0 <= tokens.length <= 1000
    * 0 <= tokens[i], power < 10^4*/

    public int bagOfTokensScore(int[] tokens, int power) {
        Arrays.sort(tokens);
        int ans = 0;
        for (int lo = 0, hi = tokens.length-1; lo <= hi; )
            if (tokens[lo] <= power) {
                ++ans;
                power -= tokens[lo++];
            } else if (ans > 0 && lo < hi) {
                --ans;
                power += tokens[hi--];
            } else break;
        return ans;
    }


    /*950. Reveal Cards In Increasing Order (Medium)
    You are given an integer array deck. There is a deck of cards where every
    card has a unique integer. The integer on the ith card is deck[i]. You can
    order the deck in any order you want. Initially, all the cards start face
    down (unrevealed) in one deck. You will do the following steps repeatedly
    until all cards are revealed:
    * Take the top card of the deck, reveal it, and take it out of the deck.
    * If there are still cards in the deck then put the next top card of the
      deck at the bottom of the deck.
    * If there are still unrevealed cards, go back to step 1. Otherwise, stop.
    Return an ordering of the deck that would reveal the cards in increasing
    order. Note that the first entry in the answer is considered to be the top
    of the deck.

    Example 1:
    Input: deck = [17,13,11,2,3,5,7]
    Output: [2,13,3,11,5,17,7]
    Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order
                 does not matter), and reorder it.
                 After reordering, the deck starts as [2,13,3,11,5,17,7], where
                 2 is the top of the deck.
                 - We reveal 2, and move 13 to the bottom.  The deck is now
                   [3,11,5,17,7,13].
                 - We reveal 3, and move 11 to the bottom.  The deck is now
                   [5,17,7,13,11].
                 - We reveal 5, and move 17 to the bottom.  The deck is now
                   [7,13,11,17].
                 - We reveal 7, and move 13 to the bottom.  The deck is now
                   [11,17,13].
                 - We reveal 11, and move 17 to the bottom.  The deck is now
                   [13,17].
                 - We reveal 13, and move 17 to the bottom.  The deck is now
                   [17].
                 - We reveal 17.
                 Since all the cards revealed are in increasing order, the
                 answer is correct.

    Example 2:
    Input: deck = [1,1000]
    Output: [1,1000]

    Constraints:
    * 1 <= deck.length <= 1000
    * 1 <= deck[i] <= 10^6
    * All the values of deck are unique.*/

    public int[] deckRevealedIncreasing(int[] deck) {
        Deque<Integer> ans = new LinkedList();
        Arrays.sort(deck);
        for (int i = deck.length-1; i >= 0; --i) {
            if (!ans.isEmpty())
                ans.addFirst(ans.pollLast());
            ans.addFirst(deck[i]);
        }
        return ans.stream().mapToInt(Integer::intValue).toArray();
    }


    /*953. Verifying an Alien Dictionary (Easy)
    In an alien language, surprisingly, they also use English lowercase letters,
    but possibly in a different order. The order of the alphabet is some
    permutation of lowercase letters. Given a sequence of words written in the
    alien language, and the order of the alphabet, return true if and only if
    the given words are sorted lexicographically in this alien language.

    Example 1:
    Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
    Output: true
    Explanation: As 'h' comes before 'l' in this language, then the sequence is
                 sorted.

    Example 2:
    Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
    Output: false
    Explanation: As 'd' comes after 'l' in this language, then
                 words[0] > words[1], hence the sequence is unsorted.

    Example 3:
    Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
    Output: false
    Explanation: The first three characters "app" match, and the second string
                 is shorter (in size.) According to lexicographical rules
                 "apple" > "app", because 'l' > '∅', where '∅' is defined as
                 the blank character which is less than any other character
                 (More info).

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 20
    * order.length == 26
    * All characters in words[i] and order are English lowercase letters.*/

    public boolean isAlienSorted(String[] words, String order) {
        int[] mp = new int[26];
        for (int i = 0; i < 26; ++i)
            mp[order.charAt(i)-'a'] = i;
        String prev = "\n";
        for (var word : words) {
            StringBuilder sb = new StringBuilder();
            for (var ch : word.toCharArray())
                sb.append((char) (mp[ch-'a'] + 'a'));
            if (prev.compareTo(sb.toString()) > 0) return false;
            prev = sb.toString();
        }
        return true;
    }


    /*962. Maximum Width Ramp (Medium)
    A ramp in an integer array nums is a pair (i, j) for which i < j and
    nums[i] <= nums[j]. The width of such a ramp is j - i. Given an integer
    array nums, return the maximum width of a ramp in nums. If there is no ramp
    in nums, return 0.

    Example 1:
    Input: nums = [6,0,8,2,1,5]
    Output: 4
    Explanation: The maximum width ramp is achieved at (i, j) = (1, 5):
                 nums[1] = 0 and nums[5] = 5.

    Example 2:
    Input: nums = [9,8,1,0,1,9,4,0,4,1]
    Output: 7
    Explanation: The maximum width ramp is achieved at (i, j) = (2, 9):
                 nums[2] = 1 and nums[9] = 1.

    Constraints:
    * 2 <= nums.length <= 5 * 10^4
    * 0 <= nums[i] <= 5 * 10^4*/

    public int maxWidthRamp(int[] nums) {
        int n = nums.length;
        Stack<Integer> stk = new Stack<>();
        for (int i = 0; i < n; ++i)
            if (stk.isEmpty() || nums[stk.peek()] > nums[i])
                stk.push(i);
        int ans = 0;
        for (int i = n-1; i >= 0; --i)
            while (!stk.isEmpty() && nums[stk.peek()] <= nums[i])
                ans = Math.max(ans, i - stk.pop());
        return ans;
    }


    /*974. Subarray Sums Divisible by K (Medium)
    Given an integer array nums and an integer k, return the number of non-
    empty subarrays that have a sum divisible by k. A subarray is a contiguous
    part of an array.

    Example 1:
    Input: nums = [4,5,0,-2,-3,1], k = 5
    Output: 7
    Explanation: There are 7 subarrays with a sum divisible by k = 5:
                 [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0],
                 [0, -2, -3], [-2, -3]

    Example 2:
    Input: nums = [5], k = 9
    Output: 0

    Constraints:
    * 1 <= nums.length <= 3 * 10^4
    * -10^4 <= nums[i] <= 10^4
    * 2 <= k <= 10^4*/

    public int subarraysDivByK(int[] nums, int k) {
        int ans = 0, prefix = 0;
        int[] freq = new int[k];
        freq[0] = 1;
        for (var x : nums) {
            prefix = (prefix + x%k + k) % k;
            ans += freq[prefix]++;
        }
        return ans;
    }


    /*979. Distribute Coins in Binary Tree (Medium)
    You are given the root of a binary tree with n nodes where each node in the
    tree has node.val coins. There are n coins in total throughout the whole
    tree. In one move, we may choose two adjacent nodes and move one coin from
    one node to another. A move may be from parent to child, or from child to
    parent. Return the minimum number of moves required to make every node have
    exactly one coin.

    Example 1:
    Input: root = [3,0,0]
    Output: 2
    Explanation: From the root of the tree, we move one coin to its left child,
                 and one coin to its right child.

    Example 2:
    Input: root = [0,3,0]
    Output: 3
    Explanation: From the left child of the root, we move two coins to the root
                 [taking two moves]. Then, we move one coin from the root of the
                 tree to the right child.

    Constraints:
    * The number of nodes in the tree is n.
    * 1 <= n <= 100
    * 0 <= Node.val <= n
    * The sum of all Node.val is n.*/

    public int distributeCoins(TreeNode root) {

        class Solve {
            public int[] fn(TreeNode node) {
                if (node == null) return new int[]{0, 0};
                int[] l = fn(node.left);
                int[] r = fn(node.right);
                return new int[]{node.val + l[0] + r[0] - 1, l[1] + r[1] + Math.abs(l[0]) + Math.abs(r[0])};
            }
        }

        Solve sol = new Solve();
        return sol.fn(root)[1];
    }


    /*988. Smallest String Starting From Leaf (Medium)
    You are given the root of a binary tree where each node has a value in the
    range [0, 25] representing the letters 'a' to 'z'. Return the
    lexicographically smallest string that starts at a leaf of this tree and
    ends at the root. As a reminder, any shorter prefix of a string is
    lexicographically smaller. For example, "ab" is lexicographically smaller
    than "aba". A leaf of a node is a node that has no children.

    Example 1:
    Input: root = [0,1,2,3,4,3,4]
    Output: "dba"

    Example 2:
    Input: root = [25,1,3,1,3,0,2]
    Output: "adz"

    Example 3:
    Input: root = [2,2,1,null,1,0,null,0]
    Output: "abc"

    Constraints:
    * The number of nodes in the tree is in the range [1, 8500].
    * 0 <= Node.val <= 25*/

    public String smallestFromLeaf(TreeNode root) {
        Stack<Pair<TreeNode, String>> stk = new Stack();
        stk.add(new Pair(root, ""));
        String ans = "~";
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            TreeNode node = elem.getKey();
            String val = elem.getValue();
            val = String.valueOf((char) ('a' + node.val)) + val;
            if (node.left == null && node.right == null) {
                if (ans.compareTo(val) > 0) ans = val;
            } else {
                if (node.left != null) stk.push(new Pair(node.left, val));
                if (node.right != null) stk.push(new Pair(node.right, val));
            }
        }
        return ans;
    }


    /*989. Add to Array-Form of Integer (Easy)
    The array-form of an integer num is an array representing its digits in
    left to right order. For example, for num = 1321, the array form is
    [1,3,2,1]. Given num, the array-form of an integer, and an integer k,
    return the array-form of the integer num + k.

    Example 1:
    Input: num = [1,2,0,0], k = 34
    Output: [1,2,3,4]
    Explanation: 1200 + 34 = 1234

    Example 2:
    Input: num = [2,7,4], k = 181
    Output: [4,5,5]
    Explanation: 274 + 181 = 455

    Example 3:
    Input: num = [2,1,5], k = 806
    Output: [1,0,2,1]
    Explanation: 215 + 806 = 1021

    Constraints:
    * 1 <= num.length <= 10^4
    * 0 <= num[i] <= 9
    * num does not contain any leading zeros except for the zero itself.
    * 1 <= k <= 10^4*/

    public List<Integer> addToArrayForm(int[] num, int k) {
        List<Integer> ans = Arrays.stream(num).boxed().collect(Collectors.toList());
        Collections.reverse(ans);
        for (int i = 0; k > 0; ++i) {
            if (i == ans.size()) ans.add(0);
            k += ans.get(i);
            ans.set(i, k % 10);
            k /= 10;
        }
        Collections.reverse(ans);
        return ans;
    }


    /*995. Minimum Number of K Consecutive Bit Flips (Hard)
    You are given a binary array nums and an integer k. A k-bit flip is choosing
    a subarray of length k from nums and simultaneously changing every 0 in the
    subarray to 1, and every 1 in the subarray to 0. Return the minimum number
    of k-bit flips required so that there is no 0 in the array. If it is not
    possible, return -1. A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [0,1,0], k = 1
    Output: 2
    Explanation: Flip nums[0], then flip nums[2].

    Example 2:
    Input: nums = [1,1,0], k = 2
    Output: -1
    Explanation: No matter how we flip subarrays of size 2, we cannot make the
                 array become [1,1,1].

    Example 3:
    Input: nums = [0,0,0,1,0,1,1,0], k = 3
    Output: 3
    Explanation: Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]
                 Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]
                 Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= k <= nums.length*/

    public int minKBitFlips(int[] nums, int k) {
        int ans = 0, flip = 0, n = nums.length;
        int[] line = new int[n];
        for (int i = 0; i < n; ++i) {
            if (nums[i] == flip) {
                if (n <= i+k-1) return -1;
                ++ans;
                flip ^= 1;
                line[i+k-1] = 1;
            }
            if (line[i] == 1) flip ^= 1;
        }
        return ans;
    }


    /*997. Find the Town Judge (Easy)
    In a town, there are n people labeled from 1 to n. There is a rumor that
    one of these people is secretly the town judge. If the town judge exists,
    then:
    * The town judge trusts nobody.
    * Everybody (except for the town judge) trusts the town judge.
    * There is exactly one person that satisfies properties 1 and 2.
    You are given an array trust where trust[i] = [ai, bi] representing that
    the person labeled ai trusts the person labeled bi. Return the label of the
    town judge if the town judge exists and can be identified, or return -1
    otherwise.

    Example 1:
    Input: n = 2, trust = [[1,2]]
    Output: 2

    Example 2:
    Input: n = 3, trust = [[1,3],[2,3]]
    Output: 3

    Example 3:
    Input: n = 3, trust = [[1,3],[2,3],[3,1]]
    Output: -1

    Constraints:
    * 1 <= n <= 1000
    * 0 <= trust.length <= 10^4
    * trust[i].length == 2
    * All the pairs of trust are unique.
    * ai != bi
    * 1 <= ai, bi <= n*/

    public int findJudge(int n, int[][] trust) {
        int[] degree = new int[n];
        for (var t : trust) {
            degree[t[0]-1] -= 1;
            degree[t[1]-1] += 1;
        }
        for (int i = 0; i < n; ++i)
            if (degree[i] == n-1) return i+1;
        return -1;
    }


    /*1002. Find Common Characters (Easy)
    Given a string array words, return an array of all characters that show up
    in all strings within the words (including duplicates). You may return the
    answer in any order.

    Example 1:
    Input: words = ["bella","label","roller"]
    Output: ["e","l","l"]

    Example 2:
    Input: words = ["cool","lock","cook"]
    Output: ["c","o"]

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consists of lowercase English letters.*/

    public List<String> commonChars(String[] words) {
        int[] freq = new int[26];
        Arrays.fill(freq, Integer.MAX_VALUE);
        for (var word : words) {
            int[] temp = new int[26];
            for (var ch : word.toCharArray())
                ++temp[ch-'a'];
            for (int i = 0; i < 26; ++i)
                freq[i] = Math.min(freq[i], temp[i]);
        }
        List<String> ans = new ArrayList();
        for (int i = 0; i < 26; ++i)
            while (freq[i]-- > 0)
                ans.add(String.valueOf((char) (i+'a')));
        return ans;
    }


    /*1011. Capacity To Ship Packages Within D Days (Medium)
    A conveyor belt has packages that must be shipped from one port to another
    within days days. The ith package on the conveyor belt has a weight of
    weights[i]. Each day, we load the ship with packages on the conveyor belt
    (in the order given by weights). We may not load more weight than the
    maximum weight capacity of the ship. Return the least weight capacity of
    the ship that will result in all the packages on the conveyor belt being
    shipped within days days.

    Example 1:
    Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
    Output: 15
    Explanation: A ship capacity of 15 is the minimum to ship all the packages
                 in 5 days like this:
                 1st day: 1, 2, 3, 4, 5
                 2nd day: 6, 7
                 3rd day: 8
                 4th day: 9
                 5th day: 10
                 Note that the cargo must be shipped in the order given, so
                 using a ship of capacity 14 and splitting the packages into
                 parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not
                 allowed.

    Example 2:
    Input: weights = [3,2,2,4,1,4], days = 3
    Output: 6
    Explanation: A ship capacity of 6 is the minimum to ship all the packages
                 in 3 days like this:
                 1st day: 3, 2
                 2nd day: 2, 4
                 3rd day: 1, 4

    Example 3:
    Input: weights = [1,2,3,1,1], days = 4
    Output: 3
    Explanation: 1st day: 1
                 2nd day: 2
                 3rd day: 3
                 4th day: 1, 1

    Constraints:
    * 1 <= days <= weights.length <= 5 * 10^4
    * 1 <= weights[i] <= 500*/

    public int shipWithinDays(int[] weights, int days) {
        int lo = 0, hi = 0;
        for (var w : weights) {
            lo = Math.max(lo, w);
            hi += w;
        }
        while (lo < hi) {
            int mid = lo + (hi - lo)/2, cnt = 0, val = hi;
            for (var w : weights) {
                if (val + w > mid) {
                    ++cnt;
                    val = 0;
                }
                val += w;
            }
            if (cnt <= days) hi = mid;
            else lo = mid + 1;
        }
        return lo;
    }


    /*1038. Binary Search Tree to Greater Sum Tree (Medium)
    Given the root of a Binary Search Tree (BST), convert it to a Greater Tree
    such that every key of the original BST is changed to the original key plus
    the sum of all keys greater than the original key in BST. As a reminder, a
    binary search tree is a tree that satisfies these constraints:
    * The left subtree of a node contains only nodes with keys less than the
      node's key.
    * The right subtree of a node contains only nodes with keys greater than the
      node's key.
    * Both the left and right subtrees must also be binary search trees.

    Example 1:
    Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
    Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

    Example 2:
    Input: root = [0,null,1]
    Output: [1,null,1]

    Constraints:
    * The number of nodes in the tree is in the range [1, 100].
    * 0 <= Node.val <= 100
    * All the values in the tree are unique.

    Note: This question is the same as 538:
          https://leetcode.com/problems/convert-bst-to-greater-tree/*/

    public TreeNode bstToGst(TreeNode root) {
        Stack<TreeNode> stk = new Stack();
        int prefix = 0;
        TreeNode node = root;
        while (node != null || !stk.isEmpty())
            if (node != null) {
                stk.push(node);
                node = node.right;
            } else {
                node = stk.pop();
                node.val = prefix = node.val + prefix;
                node = node.left;
            }
        return root;
    }


    /*1046. Last Stone Weight (Easy)
    You are given an array of integers stones where stones[i] is the weight of
    the ith stone. We are playing a game with the stones. On each turn, we
    choose the heaviest two stones and smash them together. Suppose the
    heaviest two stones have weights x and y with x <= y. The result of this
    smash is:
    * If x == y, both stones are destroyed, and
    * If x != y, the stone of weight x is destroyed, and the stone of weight y
      has new weight y - x.
    At the end of the game, there is at most one stone left. Return the weight
    of the last remaining stone. If there are no stones left, return 0.

    Example 1:
    Input: stones = [2,7,4,1,8,1]
    Output: 1
    Explanation: - We combine 7 and 8 to get 1 so the array converts to
                   [2,4,1,1,1] then,
                 - we combine 2 and 4 to get 2 so the array converts to
                   [2,1,1,1] then,
                 - we combine 2 and 1 to get 1 so the array converts to
                   [1,1,1] then,
                 - we combine 1 and 1 to get 0 so the array converts to [1]
                   then that's the value of the last stone.

    Example 2:
    Input: stones = [1]
    Output: 1

    Constraints:
    * 1 <= stones.length <= 30
    * 1 <= stones[i] <= 1000*/

    public int lastStoneWeight(int[] stones) {
        Queue<Integer> pq = new PriorityQueue<>((x, y) -> Integer.compare(y, x));
        for (var x : stones) pq.add(x);
        while (pq.size() > 1) {
            int x = pq.poll(), y = pq.poll();
            if (x > y) pq.add(x-y);
        }
        return pq.size() == 1 ? pq.poll() : 0;
    }


    /*1051. Height Checker (Easy)
    A school is trying to take an annual photo of all the students. The students
    are asked to stand in a single file line in non-decreasing order by height.
    Let this ordering be represented by the integer array expected where
    expected[i] is the expected height of the ith student in line. You are given
    an integer array heights representing the current order that the students
    are standing in. Each heights[i] is the height of the ith student in line
    (0-indexed). Return the number of indices where heights[i] != expected[i].

    Example 1:
    Input: heights = [1,1,4,2,1,3]
    Output: 3
    Explanation: heights:  [1,1,4,2,1,3]
                 expected: [1,1,1,2,3,4]
                 Indices 2, 4, and 5 do not match.

    Example 2:
    Input: heights = [5,1,2,3,4]
    Output: 5
    Explanation: heights:  [5,1,2,3,4]
                 expected: [1,2,3,4,5]
                 All indices do not match.

    Example 3:
    Input: heights = [1,2,3,4,5]
    Output: 0
    Explanation: heights:  [1,2,3,4,5]
                 expected: [1,2,3,4,5]
                 All indices match.

    Constraints:
    * 1 <= heights.length <= 100
    * 1 <= heights[i] <= 100*/

    public int heightChecker(int[] heights) {
        int[] freq = new int[101];
        for (var x : heights) ++freq[x];
        int ans = 0, v = 0;
        for (var x : heights) {
            while (freq[v] == 0) ++v;
            if (x != v) ++ans;
            --freq[v];
        }
        return ans;
    }


    /*1052. Grumpy Bookstore Owner (Medium)
    There is a bookstore owner that has a store open for n minutes. Every
    minute, some number of customers enter the store. You are given an integer
    array customers of length n where customers[i] is the number of the customer
    that enters the store at the start of the ith minute and all those customers
    leave after the end of that minute. On some minutes, the bookstore owner is
    grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the
    bookstore owner is grumpy during the ith minute, and is 0 otherwise. When
    the bookstore owner is grumpy, the customers of that minute are not
    satisfied, otherwise, they are satisfied. The bookstore owner knows a secret
    technique to keep themselves not grumpy for minutes consecutive minutes, but
    can only use it once. Return the maximum number of customers that can be
    satisfied throughout the day.

    Example 1:
    Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3
    Output: 16
    Explanation: The bookstore owner keeps themselves not grumpy for the last 3
                 minutes. The maximum number of customers that can be
                 satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.

    Example 2:
    Input: customers = [1], grumpy = [0], minutes = 1
    Output: 1

    Constraints:
    * n == customers.length == grumpy.length
    * 1 <= minutes <= n <= 2 * 10^4
    * 0 <= customers[i] <= 1000
    * grumpy[i] is either 0 or 1.*/

    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int ans = 0, most = 0;
        for (int i = 0, ii = 0, val = 0; i < customers.length; ++i) {
            if (grumpy[i] == 1) val += customers[i];
            else ans += customers[i];
            if (ii == i-minutes) {
                if (grumpy[ii] == 1) val -= customers[ii];
                ++ii;
            }
            most = Math.max(most, val);
        }
        return ans + most;
    }


    /*1055. Shortest Way to Form String (Medium)
    A subsequence of a string is a new string that is formed from the original
    string by deleting some (can be none) of the characters without disturbing
    the relative positions of the remaining characters. (i.e., "ace" is a
    subsequence of "abcde" while "aec" is not). Given two strings source and
    target, return the minimum number of subsequences of source such that their
    concatenation equals target. If the task is impossible, return -1.

    Example 1:
    Input: source = "abc", target = "abcbc"
    Output: 2
    Explanation: The target "abcbc" can be formed by "abc" and "bc", which are
                 subsequences of source "abc".

    Example 2:
    Input: source = "abc", target = "acdbc"
    Output: -1
    Explanation: The target string cannot be constructed from the subsequences
                 of source string due to the character "d" in target string.

    Example 3:
    Input: source = "xyz", target = "xzyxz"
    Output: 3
    Explanation: The target string can be constructed as follows
                 "xz" + "y" + "xz".

    Constraints:
    * 1 <= source.length, target.length <= 1000
    * source and target consist of lowercase English letters.*/

    public int shortestWay(String source, String target) {
        Map<Character, List<Integer>> locs = new HashMap();
        for (int i = 0; i < source.length(); ++i) {
            locs.putIfAbsent(source.charAt(i), new ArrayList());
            locs.get(source.charAt(i)).add(i);
        }
        int ans = 0, i = 0;
        for (var x : target.toCharArray()) {
            if (!locs.containsKey(x)) return -1;
            int k = Collections.binarySearch(locs.get(x), i);
            if (k < 0) k = -k-1;
            if (k == locs.get(x).size()) {
                k = 0;
                ++ans;
            }
            i = locs.get(x).get(k) + 1;
        }
        return ++ans;
    }


    /*1063. Number of Valid Subarrays (Hard)
    Given an integer array nums, return the number of non-empty subarrays with
    the leftmost element of the subarray not larger than other elements in the
    subarray. A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1,4,2,5,3]
    Output: 11
    Explanation: There are 11 valid subarrays: [1],[4],[2],[5],[3],[1,4],[2,5],
                 [1,4,2],[2,5,3],[1,4,2,5],[1,4,2,5,3].

    Example 2:
    Input: nums = [3,2,1]
    Output: 3
    Explanation: The 3 valid subarrays are: [3],[2],[1].

    Example 3:
    Input: nums = [2,2,2]
    Output: 6
    Explanation: There are 6 valid subarrays: [2],[2],[2],[2,2],[2,2],[2,2,2].

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 0 <= nums[i] <= 10^5*/

    public int validSubarrays(int[] nums) {
        int ans = 0;
        Stack<Integer> stk = new Stack();
        for (var x : nums) {
            while (!stk.isEmpty() && stk.peek() > x) stk.pop();
            stk.push(x);
            ans += stk.size();
        }
        return ans;
    }


    /*1071. Greatest Common Divisor of Strings (Easy)
    For two strings s and t, we say "t divides s" if and only if s = t + ... + t
    (i.e., t is concatenated with itself one or more times). Given two strings
    str1 and str2, return the largest string x such that x divides both str1
    and str2.

    Example 1:
    Input: str1 = "ABCABC", str2 = "ABC"
    Output: "ABC"

    Example 2:
    Input: str1 = "ABABAB", str2 = "ABAB"
    Output: "AB"

    Example 3:
    Input: str1 = "LEET", str2 = "CODE"
    Output: ""

    Constraints:
    * 1 <= str1.length, str2.length <= 1000
    * str1 and str2 consist of English uppercase letters.*/

    public String gcdOfStrings(String str1, String str2) {
        if (!(str1 + str2).equals(str2 + str1)) return "";
        int g = BigInteger.valueOf(str1.length()).gcd(BigInteger.valueOf(str2.length())).intValue();
        return str1.substring(0, g);
    }


    /*1105. Filling Bookcase Shelves (Medium)
    You are given an array books where books[i] = [thicknessi, heighti]
    indicates the thickness and height of the ith book. You are also given an
    integer shelfWidth. We want to place these books in order onto bookcase
    shelves that have a total width shelfWidth. We choose some of the books to
    place on this shelf such that the sum of their thickness is less than or
    equal to shelfWidth, then build another level of the shelf of the bookcase
    so that the total height of the bookcase has increased by the maximum height
    of the books we just put down. We repeat this process until there are no
    more books to place. Note that at each step of the above process, the order
    of the books we place is the same order as the given sequence of books. For
    example, if we have an ordered list of 5 books, we might place the first and
    second book onto the first shelf, the third book on the second shelf, and
    the fourth and fifth book on the last shelf. Return the minimum possible
    height that the total bookshelf can be after placing shelves in this manner.

    Example 1:
    Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4
    Output: 6
    Explanation: The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.
                 Notice that book number 2 does not have to be on the first
                 shelf.

    Example 2:
    Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6
    Output: 4

    Constraints:
    * 1 <= books.length <= 1000
    * 1 <= thicknessi <= shelfWidth <= 1000
    * 1 <= heighti <= 1000*/

    public int minHeightShelves(int[][] books, int shelfWidth) {
        int n = books.length;
        int[] dp = new int[n+1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[n] = 0;
        for (int i = n-1; i >= 0; --i)
            for (int j = i, h = 0, w = 0; j < n; ++j) {
                w += books[j][0];
                if (w <= shelfWidth) {
                    h = Math.max(h, books[j][1]);
                    dp[i] = Math.min(dp[i], h + dp[j+1]);
                }
            }
        return dp[0];
    }


    /*1110. Delete Nodes And Return Forest (Medium)
    Given the root of a binary tree, each node in the tree has a distinct value.
    After deleting all nodes with a value in to_delete, we are left with a
    forest (a disjoint union of trees). Return the roots of the trees in the
    remaining forest. You may return the result in any order.

    Example 1:
    Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
    Output: [[1,2,null,4],[6],[7]]

    Example 2:
    Input: root = [1,2,4,null,3], to_delete = [3]
    Output: [[1,2,4]]

    Constraints:
    * The number of nodes in the given tree is at most 1000.
    * Each node has a distinct value between 1 and 1000.
    * to_delete.length <= 1000
    * to_delete contains distinct values between 1 and 1000.*/

    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
        Set<Integer> tabu = Arrays.stream(to_delete).boxed().collect(Collectors.toSet());
        List<TreeNode> ans = new ArrayList();
        Stack<Pair<TreeNode, Integer>> stk = new Stack();
        stk.push(new Pair(root, -1));
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            TreeNode node = elem.getKey();
            Integer p = elem.getValue();
            if (node.left != null) {
                stk.push(new Pair(node.left, node.val));
                if (tabu.contains(node.left.val)) node.left = null;
            }
            if (node.right != null) {
                stk.push(new Pair(node.right, node.val));
                if (tabu.contains(node.right.val)) node.right = null;
            }
            if ((p == -1 || tabu.contains(p)) && !tabu.contains(node.val))
                ans.add(node);
        }
        return ans;
    }


    /*1121. Divide Array Into Increasing Sequences (Hard)
    Given an integer array nums sorted in non-decreasing order and an integer k,
    return true if this array can be divided into one or more disjoint
    increasing subsequences of length at least k, or false otherwise.

    Example 1:
    Input: nums = [1,2,2,3,3,4,4], k = 3
    Output: true
    Explanation: The array can be divided into two subsequences [1,2,3,4] and
                 [2,3,4] with lengths at least 3 each.

    Example 2:
    Input: nums = [5,6,6,7,8], k = 3
    Output: false
    Explanation: There is no way to divide the array using the conditions
                 required.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * nums is sorted in non-decreasing order.*/

    public boolean canDivideIntoSubsequences(int[] nums, int k) {
        Map<Integer, Integer> freq = new HashMap();
        int m = 0;
        for (var x : nums) {
            freq.merge(x, 1, Integer::sum);
            m = Math.max(m, freq.get(x));
        }
        return m * k <= nums.length;
    }


    /*1122. Relative Sort Array (Easy)
    Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all
    elements in arr2 are also in arr1. Sort the elements of arr1 such that the
    relative ordering of items in arr1 are the same as in arr2. Elements that do
    not appear in arr2 should be placed at the end of arr1 in ascending order.

    Example 1:
    Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
    Output: [2,2,2,1,4,3,3,9,6,7,19]

    Example 2:
    Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
    Output: [22,28,8,6,17,44]

    Constraints:
    * 1 <= arr1.length, arr2.length <= 1000
    * 0 <= arr1[i], arr2[i] <= 1000
    * All the elements of arr2 are distinct.
    * Each arr2[i] is in arr1.*/

    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] freq = new int[1001];
        for (var x : arr1) ++freq[x];
        int i = 0;
        for (var x : arr2)
            while (freq[x]-- > 0)
                arr1[i++] = x;
        for (int x = 0; x <= 1000; ++x)
            while (freq[x]-- > 0)
                arr1[i++] = x;
        return arr1;
    }


    /*1129. Shortest Path with Alternating Colors (Medium)
    You are given an integer n, the number of nodes in a directed graph where
    the nodes are labeled from 0 to n - 1. Each edge is red or blue in this
    graph, and there could be self-edges and parallel edges. You are given two
    arrays redEdges and blueEdges where:
    * redEdges[i] = [ai, bi] indicates that there is a directed red edge from
      node ai to node bi in the graph, and
    * blueEdges[j] = [uj, vj] indicates that there is a directed blue edge from
      node uj to node vj in the graph.
    Return an array answer of length n, where each answer[x] is the length of
    the shortest path from node 0 to node x such that the edge colors alternate
    along the path, or -1 if such a path does not exist.

    Example 1:
    Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []
    Output: [0,1,-1]

    Example 2:
    Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]
    Output: [0,1,-1]

    Constraints:
    * 1 <= n <= 100
    * 0 <= redEdges.length, blueEdges.length <= 400
    * redEdges[i].length == blueEdges[j].length == 2
    * 0 <= ai, bi, uj, vj < n*/

    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        List<int[]>[] graph = new ArrayList[n];
        for (int u = 0; u < n; ++u) graph[u] = new ArrayList();
        for (var e : redEdges) graph[e[0]].add(new int[]{e[1], 0});
        for (var e : blueEdges) graph[e[0]].add(new int[]{e[1], 1});
        Queue<int[]> q = new LinkedList();
        q.add(new int[]{0, 0});
        q.add(new int[]{0, 1});
        int[][] dist = new int[n][2];
        for (int i = 0; i < n; ++i) dist[i][0] = dist[i][1] = Integer.MAX_VALUE;
        for (int k = 0; !q.isEmpty(); ++k)
            for (int sz = q.size(); sz > 0; --sz) {
                var elem = q.poll();
                int u = elem[0], c = elem[1];
                if (dist[u][c] > k) {
                    dist[u][c] = k;
                    for (var v : graph[u])
                        if (v[1] != c) q.add(v);
                }
            }
        int[] ans = new int[n];
        for (int i = 0; i < n; ++i) {
            int v = Math.min(dist[i][0], dist[i][1]);
            ans[i] = v < Integer.MAX_VALUE ? v : -1;
        }
        return ans;
    }


    /*1137. N-th Tribonacci Number (Easy)
    The Tribonacci sequence Tn is defined as follows:
    T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.
    Given n, return the value of Tn.

    Example 1:
    Input: n = 4
    Output: 4
    Explanation: T_3 = 0 + 1 + 1 = 2
                 T_4 = 1 + 1 + 2 = 4

    Example 2:
    Input: n = 25
    Output: 1389537

    Constraints:
    * 0 <= n <= 37
    * The answer is guaranteed to fit within a 32-bit integer, ie.
      answer <= 2^31 - 1.*/

    public int tribonacci(int n) {
        int[] dp = new int[]{0, 1, 1};
        for (int i = 3; i <= n; ++i)
            dp[i%3] = dp[0] + dp[1] + dp[2];
        return dp[n%3];
    }


    /*1140. Stone Game II (Medium)
    Alice and Bob continue their games with piles of stones.  There are a number
    of piles arranged in a row, and each pile has a positive integer number of
    stones piles[i].  The objective of the game is to end with the most stones.
    Alice and Bob take turns, with Alice starting first.  Initially, M = 1. On
    each player's turn, that player can take all the stones in the first X
    remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X). The game
    continues until all the stones have been taken. Assuming Alice and Bob play
    optimally, return the maximum number of stones Alice can get.

    Example 1:
    Input: piles = [2,7,9,4,4]
    Output: 10
    Explanation:  If Alice takes one pile at the beginning, Bob takes two piles,
                  then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10
                  piles in total. If Alice takes two piles at the beginning,
                  then Bob can take all three piles left. In this case, Alice
                  get 2 + 7 = 9 piles in total. So we return 10 since it's
                  larger.

    Example 2:
    Input: piles = [1,2,3,4,5,100]
    Output: 104

    Constraints:
    * 1 <= piles.length <= 100
    * 1 <= piles[i] <= 10^4*/

    public int stoneGameII(int[] piles) {
        int n = piles.length;
        int[] prefix = new int[n+1];
        for (int i = 0; i < n; ++i)
            prefix[i+1] = prefix[i] + piles[i];
        int[][] dp = new int[n+1][n+1];
        for (int i = n-1; i >= 0; --i)
            for (int j = 1; j <= n; ++j)
                for (int ii = i; ii < n && ii < i+2*j; ++ii) {
                    int jj = Math.max(j, ii-i+1);
                    int cand = prefix[n] - prefix[i] - dp[ii+1][jj];
                    dp[i][j] = Math.max(dp[i][j], cand);
                }
        return dp[0][1];
    }


    /*1183. Maximum Number of Ones (Hard)
    Consider a matrix M with dimensions width * height, such that every cell
    has value 0 or 1, and any square sub-matrix of M of size
    sideLength * sideLength has at most maxOnes ones. Return the maximum
    possible number of ones that the matrix M can have.

    Example 1:
    Input: width = 3, height = 3, sideLength = 2, maxOnes = 1
    Output: 4
    Explanation: In a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.
                 The best solution that has 4 ones is:
                 [1,0,1]
                 [0,0,0]
                 [1,0,1]

    Example 2:
    Input: width = 3, height = 3, sideLength = 2, maxOnes = 2
    Output: 6
    Explanation: [1,0,1]
                 [1,0,1]
                 [1,0,1]

    Constraints:
    * 1 <= width, height <= 100
    * 1 <= sideLength <= width, height
    * 0 <= maxOnes <= sideLength * sideLength*/

    public int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {
        if (width < height) { int temp = width; width = height; height = temp; }
        int nw = width/sideLength, rw = width%sideLength, nh = height/sideLength, rh = height%sideLength;
        int ans = nw * nh * maxOnes + (nw + nh + 1) * Math.min(maxOnes, rw * rh);
        maxOnes -= rw * rh;
        if (maxOnes > 0) {
            ans += nw * Math.min(maxOnes, (sideLength - rw) * rh);
            maxOnes -= (sideLength - rw) * rh;
            if (maxOnes > 0) ans += nh * Math.min(maxOnes, rw * (sideLength - rh));
        }
        return ans;
    }


    /*1199. Minimum Time to Build Blocks (Hard)
    You are given a list of blocks, where blocks[i] = t means that the i-th
    block needs t units of time to be built. A block can only be built by
    exactly one worker. A worker can either split into two workers (number of
    workers increases by one) or build a block then go home. Both decisions
    cost some time. The time cost of spliting one worker into two workers is
    given as an integer split. Note that if two workers split at the same time,
    they split in parallel so the cost would be split. Output the minimum time
    needed to build all blocks. Initially, there is only one worker.

    Example 1:
    Input: blocks = [1], split = 1
    Output: 1
    Explanation: We use 1 worker to build 1 block in 1 time unit.

    Example 2:
    Input: blocks = [1,2], split = 5
    Output: 7
    Explanation: We split the worker into 2 workers in 5 time units then assign
                 each of them to a block so the cost is 5 + max(1, 2) = 7.

    Example 3:
    Input: blocks = [1,2,3], split = 1
    Output: 4
    Explanation: Split 1 worker into 2, then assign the first worker to the
                 last block and split the second worker into 2. Then, use the
                 two unassigned workers to build the first two blocks. The cost
                 is 1 + max(3, 1 + max(1, 2)) = 4.

    Constraints:
    * 1 <= blocks.length <= 1000
    * 1 <= blocks[i] <= 10^5
    * 1 <= split <= 100*/

    public int minBuildTime(int[] blocks, int split) {
        Queue<Integer> pq = new PriorityQueue();
        for (var x : blocks) pq.add(x);
        while (pq.size() > 1) {
            pq.poll();
            int v = pq.poll();
            pq.add(v+split);
        }
        return pq.peek();
    }


    /*1208. Get Equal Substrings Within Budget (Medium)
    You are given two strings s and t of the same length and an integer maxCost.
    You want to change s to t. Changing the ith character of s to ith character
    of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII
    values of the characters). Return the maximum length of a substring of s
    that can be changed to be the same as the corresponding substring of t with
    a cost less than or equal to maxCost. If there is no substring from s that
    can be changed to its corresponding substring from t, return 0.

    Example 1:
    Input: s = "abcd", t = "bcdf", maxCost = 3
    Output: 3
    Explanation: "abc" of s can change to "bcd".
    That costs 3, so the maximum length is 3.

    Example 2:
    Input: s = "abcd", t = "cdef", maxCost = 3
    Output: 1
    Explanation: Each character in s costs 2 to change to character in t,  so
                 the maximum length is 1.

    Example 3:
    Input: s = "abcd", t = "acde", maxCost = 0
    Output: 1
    Explanation: You cannot make any change, so the maximum length is 1.

    Constraints:
    * 1 <= s.length <= 10^5
    * t.length == s.length
    * 0 <= maxCost <= 10^6
    * s and t consist of only lowercase English letters.*/

    public int equalSubstring(String s, String t, int maxCost) {
        int ans = 0;
        for (int i = 0, ii = 0, val = 0; i < s.length(); ++i) {
            val += Math.abs(s.charAt(i) - t.charAt(i));
            for (; val > maxCost; ++ii)
                val -= Math.abs(s.charAt(ii) - t.charAt(ii));
            ans = Math.max(ans, i-ii+1);
        }
        return ans;
    }


    /*1216. Valid Palindrome III (Hard)
    Given a string s and an integer k, return true if s is a k-palindrome. A
    string is k-palindrome if it can be transformed into a palindrome by
    removing at most k characters from it.

    Example 1:
    Input: s = "abcdeca", k = 2
    Output: true
    Explanation: Remove 'b' and 'e' characters.

    Example 2:
    Input: s = "abbababa", k = 1
    Output: true

    Constraints:
    * 1 <= s.length <= 1000
    * s consists of only lowercase English letters.
    * 1 <= k <= s.length*/

    public boolean isValidPalindrome(String s, int k) {
        int n = s.length();
        int[][] dp = new int[n+1][n];
        for (int i = n-1; i >= 0; --i) {
            dp[i][i] = 1;
            for (int j = i+1; j < n; ++j)
                if (s.charAt(i) == s.charAt(j)) dp[i][j] = 2 + dp[i+1][j-1];
                else dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
        }
        return dp[0][n-1] >= n-k;
    }


    /*1219. Path with Maximum Gold (Medium)
    In a gold mine grid of size m x n, each cell in this mine has an integer
    representing the amount of gold in that cell, 0 if it is empty. Return the
    maximum amount of gold you can collect under the conditions:
    * Every time you are located in a cell you will collect all the gold in that
      cell.
    * From your position, you can walk one step to the left, right, up, or down.
    * You can't visit the same cell more than once.
    * Never visit a cell with 0 gold.
    * You can start and stop collecting gold from any position in the grid that
      has some gold.

    Example 1:
    Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
    Output: 24
    Explanation: [[0,6,0],
                  [5,8,7],
                  [0,9,0]]
                 Path to get the maximum gold, 9 -> 8 -> 7.

    Example 2:
    Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
    Output: 28
    Explanation: [[1,0,7],
                  [2,0,6],
                  [3,4,5],
                  [0,3,0],
                  [9,0,20]]
                 Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 15
    * 0 <= grid[i][j] <= 100
    * There are at most 25 cells containing gold.*/

    public int getMaximumGold(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[] dir = new int[]{-1, 0, 1, 0, -1};

        class Solve {
            public int fn(int i, int j) {
                int ans = 0, v = grid[i][j];
                grid[i][j] = 0;
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] > 0)
                        ans = Math.max(ans, fn(ii, jj));
                }
                grid[i][j] = v;
                return grid[i][j] + ans;
            }
        }

        int ans = 0;
        Solve sol = new Solve();
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] > 0)
                    ans = Math.max(ans, sol.fn(i, j));
        return ans;
    }


    /*1231. Divide Chocolate (Hard)
    You have one chocolate bar that consists of some chunks. Each chunk has its
    own sweetness given by the array sweetness. You want to share the chocolate
    with your k friends so you start cutting the chocolate bar into k + 1
    pieces using k cuts, each piece consists of some consecutive chunks. Being
    generous, you will eat the piece with the minimum total sweetness and give
    the other pieces to your friends. Find the maximum total sweetness of the
    piece you can get by cutting the chocolate bar optimally.

    Example 1:
    Input: sweetness = [1,2,3,4,5,6,7,8,9], k = 5
    Output: 6
    Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]

    Example 2:
    Input: sweetness = [5,6,7,8,9,1,2,3,4], k = 8
    Output: 1
    Explanation: There is only one way to cut the bar into 9 pieces.

    Example 3:
    Input: sweetness = [1,2,2,1,2,2,1,2,2], k = 2
    Output: 5
    Explanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]

    Constraints:
    * 0 <= k < sweetness.length <= 10^4
    * 1 <= sweetness[i] <= 10^5*/

    public int maximizeSweetness(int[] sweetness, int k) {
        int lo = 0, hi = 1_000_000_000;
        while (lo < hi) {
            int mid = lo + (hi-lo+1)/2, cnt = 0, prefix = 0;
            for (var x : sweetness) {
                prefix += x;
                if (prefix >= mid) {
                    ++cnt;
                    prefix = 0;
                }
            }
            if (cnt < k+1) hi = mid-1;
            else lo = mid;
        }
        return lo;
    }


    /*1246. Palindrome Removal (Hard)
    You are given an integer array arr. In one move, you can select a
    palindromic subarray arr[i], arr[i + 1], ..., arr[j] where i <= j, and
    remove that subarray from the given array. Note that after removing a
    subarray, the elements on the left and on the right of that subarray move
    to fill the gap left by the removal. Return the minimum number of moves
    needed to remove all numbers from the array.

    Example 1:
    Input: arr = [1,2]
    Output: 2

    Example 2:
    Input: arr = [1,3,4,1,5]
    Output: 3
    Explanation: Remove [4] then remove [1,3,1] then remove [5].

    Constraints:
    * 1 <= arr.length <= 100
    * 1 <= arr[i] <= 20*/

    public int minimumMoves(int[] arr) {
        int n = arr.length;
        int[][] dp = new int[n][n+1];
        for (int i = 0; i < n; ++i) Arrays.fill(dp[i], Integer.MAX_VALUE);
        for (int i = n-1; i >= 0; --i)
            for (int j = 0; j <= n; ++j)
                if (i+1 >= j) dp[i][j] = 1;
                else {
                    dp[i][j] = j-i;
                    if (arr[i] == arr[j-1]) dp[i][j] = Math.min(dp[i][j], dp[i+1][j-1]);
                    for (int k = i+1; k < j; ++k)
                        dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);
                }
        return dp[0][n];
    }


    /*1249. Minimum Remove to Make Valid Parentheses (Medium)
    Given a string s of '(' , ')' and lowercase English characters. Your task is
    to remove the minimum number of parentheses ( '(' or ')', in any positions )
    so that the resulting parentheses string is valid and return any valid
    string. Formally, a parentheses string is valid if and only if:
    * It is the empty string, contains only lowercase characters, or
    * It can be written as AB (A concatenated with B), where A and B are valid
      strings, or
    * It can be written as (A), where A is a valid string.

    Example 1:
    Input: s = "lee(t(c)o)de)"
    Output: "lee(t(c)o)de"
    Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.

    Example 2:
    Input: s = "a)b(c)d"
    Output: "ab(c)d"

    Example 3:
    Input: s = "))(("
    Output: ""
    Explanation: An empty string is also valid.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either'(' , ')', or lowercase English letter.*/

    public String minRemoveToMakeValid(String s) {
        Stack<Integer> stk = new Stack();
        StringBuilder sb = new StringBuilder(s);
        for (int i = 0; i < s.length(); ++i)
            if (s.charAt(i) == '(') stk.push(i);
            else if (s.charAt(i) == ')') {
                if (!stk.isEmpty()) stk.pop();
                else sb.setCharAt(i, '\0');
            }
        while (!stk.isEmpty())
            sb.setCharAt(stk.pop(), '\0');
        return sb.toString().replaceAll("\0", "");
    }


    /*1255. Maximum Score Words Formed by Letters (Hard)
    Given a list of words, list of  single letters (might be repeating) and
    score of every character. Return the maximum score of any valid set of words
    formed by using the given letters (words[i] cannot be used two or more
    times). It is not necessary to use all characters in letters and each letter
    can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by
    score[0], score[1], ... , score[25] respectively.

    Example 1:
    Input: words = ["dog","cat","dad","good"],
           letters = ["a","a","c","d","d","d","g","o","o"],
           score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
    Output: 23
    Explanation: Score  a=1, c=9, d=5, g=3, o=2
                 Given letters, we can form the words "dad" (5+1+5) and "good"
                 (3+2+2+5) with a score of 23. Words "dad" and "dog" only get a
                 score of 21.

    Example 2:
    Input: words = ["xxxz","ax","bx","cx"],
           letters = ["z","a","b","c","x","x","x"],
           score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
    Output: 27
    Explanation: Score  a=4, b=4, c=4, x=5, z=10
                 Given letters, we can form the words "ax" (4+5), "bx" (4+5) and
                 "cx" (4+5) with a score of 27. Word "xxxz" only get a score of
                 25.

    Example 3:
    Input: words = ["leetcode"],
           letters = ["l","e","t","c","o","d"],
           score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
    Output: 0
    Explanation: Letter "e" can only be used once.

    Constraints:
    * 1 <= words.length <= 14
    * 1 <= words[i].length <= 15
    * 1 <= letters.length <= 100
    * letters[i].length == 1
    * score.length == 26
    * 0 <= score[i] <= 10
    * words[i], letters[i] contains only lower case English letters.*/

    public int maxScoreWords(String[] words, char[] letters, int[] score) {
        int n = words.length;
        int[] freq = new int[26];
        for (var ch : letters) ++freq[ch-'a'];

        class Solve {
            public int fn(int i, int v) {
                if (i == n) return v;
                int ans = fn(i+1, v);
                boolean valid = true;
                int val = 0;
                for (var ch : words[i].toCharArray()) {
                    if (--freq[ch-'a'] < 0) valid = false;
                    val += score[ch-'a'];
                }
                if (valid)
                    ans = Math.max(ans, fn(i+1, v+val));
                for (var ch : words[i].toCharArray())
                    ++freq[ch-'a'];
                return ans;
            }
        }

        Solve sol = new Solve();
        return sol.fn(0, 0);
    }


    /*1259. Handshakes That Don't Cross (Hard)
    You are given an even number of people numPeople that stand around a circle
    and each person shakes hands with someone else so that there are
    numPeople / 2 handshakes total. Return the number of ways these handshakes
    could occur such that none of the handshakes cross. Since the answer could
    be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: numPeople = 4
    Output: 2
    Explanation: There are two ways to do it, the first way is [(1,2),(3,4)]
                 and the second one is [(2,3),(4,1)].

    Example 2:
    Input: numPeople = 6
    Output: 5

    Constraints:
    * 2 <= numPeople <= 1000
    * numPeople is even.*/

    public int numberOfWays(int numPeople) {
        int mod = 1_000_000_007, n = numPeople/2;
        long[] fact = new long[2*n+1], ifact = new long[n+2], inv = new long[n+2];
        fact[0] = ifact[0] = inv[0] = inv[1] = 1;
        for (int x = 1; x <= 2*n; ++x) {
            if (2 <= x && x <= n+1) inv[x] = mod - mod/x * inv[mod % x] % mod;
            fact[x] = fact[x-1] * x % mod;
            if (x <= n+1) ifact[x] = ifact[x-1] * inv[x] % mod;
        }
        return (int) (fact[2*n] * ifact[n] % mod * ifact[n+1] % mod);
    }


    /*1274. Number of Ships in a Rectangle (Hard)
    (This problem is an interactive problem.) Each ship is located at an
    integer point on the sea represented by a cartesian plane, and each integer
    point may contain at most 1 ship. You have a function
    Sea.hasShips(topRight, bottomLeft) which takes two points as arguments and
    returns true If there is at least one ship in the rectangle represented by
    the two points, including on the boundary. Given two points: the top right
    and bottom left corners of a rectangle, return the number of ships present
    in that rectangle. It is guaranteed that there are at most 10 ships in that
    rectangle. Submissions making more than 400 calls to hasShips will be
    judged Wrong Answer. Also, any solutions that attempt to circumvent the
    judge will result in disqualification.

    Example :
    Input: ships = [[1,1],[2,2],[3,3],[5,5]], topRight = [4,4], bottomLeft = [0,0]
    Output: 3
    Explanation: From [0,0] to [4,4] we can count 3 ships within the range.

    Example 2:
    Input: ans = [[1,1],[2,2],[3,3]], topRight = [1000,1000], bottomLeft = [0,0]
    Output: 3

    Constraints:
    * On the input ships is only given to initialize the map internally. You
      must solve this problem "blindfolded". In other words, you must find the
      answer using the given hasShips API, without knowing the ships position.
    * 0 <= bottomLeft[0] <= topRight[0] <= 1000
    * 0 <= bottomLeft[1] <= topRight[1] <= 1000
    * topRight != bottomLeft*/

    public int countShips(Sea sea, int[] topRight, int[] bottomLeft) {
        if (!sea.hasShips(topRight, bottomLeft)) return 0;
        int x0 = bottomLeft[0], y0 = bottomLeft[1], x1 = topRight[0], y1 = topRight[1];
        if (x0 == x1 && y0 == y1) return 1;
        if (x0 < x1) {
            int mid = (x0 + x1)/2;
            return countShips(sea, topRight, new int[]{mid+1, y0}) + countShips(sea, new int[]{mid, y1}, bottomLeft);
        }
        int mid = (y0 + y1)/2;
        return countShips(sea, topRight, new int[]{x0, mid+1}) + countShips(sea, new int[]{x1, mid}, bottomLeft);
    }


    /*1289. Minimum Falling Path Sum II (Hard)
    Given an n x n integer matrix grid, return the minimum sum of a falling path
    with non-zero shifts. A falling path with non-zero shifts is a choice of
    exactly one element from each row of grid such that no two elements chosen
    in adjacent rows are in the same column.

    Example 1:
    Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 13
    Explanation: The possible falling paths are:
                 [1,5,9], [1,5,7], [1,6,7], [1,6,8],
                 [2,4,8], [2,4,9], [2,6,7], [2,6,8],
                 [3,4,8], [3,4,9], [3,5,7], [3,5,9]
                 The falling path with the smallest sum is [1,5,7], so the
                 answer is 13.

    Example 2:
    Input: grid = [[7]]
    Output: 7

    Constraints:
    * n == grid.length == grid[i].length
    * 1 <= n <= 200
    * -99 <= grid[i][j] <= 99*/

    public int minFallingPathSum(int[][] grid) {
        int n = grid.length, p0 = 0, p1 = 0;
        for (int i = 0; i < n; ++i) {
            int m0 = 10_000_000, m1 = 10_000_000;
            for (int j = 0; j < n; ++j) {
                if (i > 0 && grid[i-1][j] != p0) grid[i][j] += p0;
                else grid[i][j] += p1;
                if (grid[i][j] < m0) {
                    m1 = m0;
                    m0 = grid[i][j];
                } else if (grid[i][j] < m1)
                    m1 = grid[i][j];
            }
            p0 = m0;
            p1 = m1;
        }
        return p0;
    }


    /*1310. XOR Queries of a Subarray (Medium)
    You are given an array arr of positive integers. You are also given the
    array queries where queries[i] = [lefti, righti]. For each query i compute
    the XOR of elements from lefti to righti (that is, arr[lefti] XOR
    arr[lefti + 1] XOR ... XOR arr[righti] ). Return an array answer where
    answer[i] is the answer to the ith query.

    Example 1:
    Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
    Output: [2,7,14,8]
    Explanation: The binary representation of the elements in the array are:
                 1 = 0001
                 3 = 0011
                 4 = 0100
                 8 = 1000
                 The XOR values for queries are:
                 [0,1] = 1 xor 3 = 2
                 [1,2] = 3 xor 4 = 7
                 [0,3] = 1 xor 3 xor 4 xor 8 = 14
                 [3,3] = 8

    Example 2:
    Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
    Output: [8,0,4,4]

    Constraints:
    * 1 <= arr.length, queries.length <= 3 * 10^4
    * 1 <= arr[i] <= 10^9
    * queries[i].length == 2
    * 0 <= lefti <= righti < arr.length*/

    public int[] xorQueries(int[] arr, int[][] queries) {
        int n = arr.length;
        int[] prefix = new int[n+1];
        for (int i = 0; i < n; ++i)
            prefix[i+1] = prefix[i] ^ arr[i];
        int q = queries.length;
        int[] ans = new int[q];
        for (int i = 0; i < q; ++i) {
            int lo = queries[i][0], hi = queries[i][1];
            ans[i] = prefix[lo] ^ prefix[hi+1];
        }
        return ans;
    }


    /*1325. Delete Leaves With a Given Value (Medium)
    Given a binary tree root and an integer target, delete all the leaf nodes
    with value target. Note that once you delete a leaf node with value target,
    if its parent node becomes a leaf node and has the value target, it should
    also be deleted (you need to continue doing that until you cannot).

    Example 1:
    Input: root = [1,2,3,2,null,2,4], target = 2
    Output: [1,null,3,null,4]
    Explanation: Leaf nodes in green with value (target = 2) are removed
                 (Picture in left). After removing, new nodes become leaf nodes
                 with value (target = 2) (Picture in center).

    Example 2:
    Input: root = [1,3,3,3,2], target = 3
    Output: [1,3,null,null,2]

    Example 3:
    Input: root = [1,2,null,2,null,2], target = 2
    Output: [1]
    Explanation: Leaf nodes in green with value (target = 2) are removed at each
                 step.

    Constraints:
    * The number of nodes in the tree is in the range [1, 3000].
    * 1 <= Node.val, target <= 1000*/

    public TreeNode removeLeafNodes(TreeNode root, int target) {
        if (root != null) {
            root.left = removeLeafNodes(root.left, target);
            root.right = removeLeafNodes(root.right, target);
            if (root.left != null || root.right != null || root.val != target) return root;
        }
        return null;
    }


    /*1331. Rank Transform of an Array (Easy)
    Given an array of integers arr, replace each element with its rank. The rank
    represents how large the element is. The rank has the following rules:
    * Rank is an integer starting from 1.
    * The larger the element, the larger the rank. If two elements are equal,
      their rank must be the same.
    * Rank should be as small as possible.

    Example 1:
    Input: arr = [40,10,20,30]
    Output: [4,1,2,3]
    Explanation: 40 is the largest element. 10 is the smallest. 20 is the second
                 smallest. 30 is the third smallest.

    Example 2:
    Input: arr = [100,100,100]
    Output: [1,1,1]
    Explanation: Same elements share the same rank.

    Example 3:
    Input: arr = [37,12,28,9,100,56,80,5,12]
    Output: [5,3,4,2,8,6,7,1,3]

    Constraints:
    * 0 <= arr.length <= 10^5
    * -10^9 <= arr[i] <= 10^9*/

    public int[] arrayRankTransform(int[] arr) {
        int[] vals = arr.clone();
        Arrays.sort(vals);
        Map<Integer, Integer> mp = new HashMap<>();
        for (var x : vals)
            mp.putIfAbsent(x, mp.size()+1);
        return Arrays.stream(arr).map(x -> mp.get(x)).toArray();
    }


    /*1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (Medium)
    There are n cities numbered from 0 to n-1. Given the array edges where
    edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted
    edge between cities fromi and toi, and given the integer distanceThreshold.
    Return the city with the smallest number of cities that are reachable
    through some path and whose distance is at most distanceThreshold, If there
    are multiple such cities, return the city with the greatest number. Notice
    that the distance of a path connecting cities i and j is equal to the sum of
    the edges' weights along that path.

    Example 1:
    Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
    Output: 3
    Explanation: The figure above describes the graph. The neighboring cities at
                 a distanceThreshold = 4 for each city are:
                 City 0 -> [City 1, City 2]
                 City 1 -> [City 0, City 2, City 3]
                 City 2 -> [City 0, City 1, City 3]
                 City 3 -> [City 1, City 2]
                 Cities 0 and 3 have 2 neighboring cities at a
                 distanceThreshold = 4, but we have to return city 3 since it
                 has the greatest number.

    Example 2:
    Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
    Output: 0
    Explanation: The figure above describes the graph. The neighboring cities at
                 a distanceThreshold = 2 for each city are:
                 City 0 -> [City 1]
                 City 1 -> [City 0, City 4]
                 City 2 -> [City 3, City 4]
                 City 3 -> [City 2, City 4]
                 City 4 -> [City 1, City 2, City 3]
                 The city 0 has 1 neighboring city at a distanceThreshold = 2.

    Constraints:
    * 2 <= n <= 100
    * 1 <= edges.length <= n * (n - 1) / 2
    * edges[i].length == 3
    * 0 <= fromi < toi < n
    * 1 <= weighti, distanceThreshold <= 10^4
    * All pairs (fromi, toi) are distinct.*/

    public int findTheCity(int n, int[][] edges, int distanceThreshold) {
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; ++i) {
            Arrays.fill(dist[i], 10_000_000);
            dist[i][i] = 0;
        }
        for (var e : edges) {
            int i = e[0], j = e[1], w = e[2];
            dist[i][j] = dist[j][i] = w;
        }
        for (int k = 0; k < n; ++k)
            for (int i = 0; i < n; ++i)
                for (int j = 0; j < n; ++j)
                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
        int ans = 0, ref = Integer.MAX_VALUE;
        for (int i = 0; i < n; ++i) {
            int cnt = Arrays.stream(dist[i]).reduce(0, (s, d) -> s + (d <= distanceThreshold ? 1 : 0));
            if (cnt <= ref) {
                ans = i;
                ref = cnt;
            }
        }
        return ans;
    }


    /*1367. Linked List in Binary Tree (Medium)
    Given a binary tree root and a linked list with head as the first node.
    Return True if all the elements in the linked list starting from the head
    correspond to some downward path connected in the binary tree otherwise
    return False. In this context downward path means a path that starts at some
    node and goes downwards.

    Example 1:
    Input: head = [4,2,8],
           root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    Output: true
    Explanation: Nodes in blue form a subpath in the binary Tree.

    Example 2:
    Input: head = [1,4,2,6],
           root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    Output: true

    Example 3:
    Input: head = [1,4,2,6,8],
           root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    Output: false
    Explanation: There is no path in the binary tree that contains all the
                 elements of the linked list from head.

    Constraints:
    * The number of nodes in the tree will be in the range [1, 2500].
    * The number of nodes in the list will be in the range [1, 100].
    * 1 <= Node.val <= 100 for each node in the linked list and binary tree.*/

    private boolean dfs(TreeNode node, int k, List<Integer> pattern, int[] lps) {
        if (k == pattern.size()) return true;
        if (node == null) return false;
        while (k > 0 && pattern.get(k) != node.val) k = lps[k-1];
        if (pattern.get(k) == node.val) ++k;
        return dfs(node.left, k, pattern, lps) || dfs(node.right, k, pattern, lps);
    }

    public boolean isSubPath(ListNode head, TreeNode root) {
        List<Integer> pattern = new ArrayList<>();
        for (ListNode node = head; node != null; node = node.next)
            pattern.add(node.val);
        int n = pattern.size();
        int[] lps = new int[n];
        int k = 0;
        for (int i = 1; i < n; ++i) {
            while (k > 0 && pattern.get(k) != pattern.get(i)) k = lps[k-1];
            if (pattern.get(k) == pattern.get(i)) ++k;
            lps[i] = k;
        }
        return dfs(root, 0, pattern, lps);
    }


    /*1371. Find the Longest Substring Containing Vowels in Even Counts (Medium)
    Given the string s, return the size of the longest substring containing each
    vowel an even number of times. That is, 'a', 'e', 'i', 'o', and 'u' must
    appear an even number of times.

    Example 1:
    Input: s = "eleetminicoworoep"
    Output: 13
    Explanation: The longest substring is "leetminicowor" which contains two
                 each of the vowels: e, i and o and zero of the vowels: a and u.

    Example 2:
    Input: s = "leetcodeisgreat"
    Output: 5
    Explanation: The longest substring is "leetc" which contains two e's.

    Example 3:
    Input: s = "bcbcbc"
    Output: 6
    Explanation: In this case, the given string "bcbcbc" is the longest because
                 all vowels: a, e, i, o and u appear zero times.

    Constraints:
    * 1 <= s.length <= 5 x 10^5
    * s contains only lowercase English letters.*/

    public int findTheLongestSubstring(String s) {
        int ans = 0, mask = 0;
        int[] pos = new int[1<<5];
        Arrays.fill(pos, -2); pos[0] = -1;
        String vowels = "aeiou";
        for (int i = 0; i < s.length(); ++i) {
            int k = "aeiou".indexOf(s.charAt(i));
            if (k >= 0) mask ^= 1<<k;
            if (pos[mask] >= -1) ans = Math.max(ans, i - pos[mask]);
            else pos[mask] = i;
        }
        return ans;
    }


    /*1372. Longest ZigZag Path in a Binary Tree (Medium)
    You are given the root of a binary tree. A ZigZag path for a binary tree is
    defined as follow:
    * Choose any node in the binary tree and a direction (right or left).
    * If the current direction is right, move to the right child of the current
      node; otherwise, move to the left child.
    * Change the direction from right to left or from left to right.
    * Repeat the second and third steps until you can't move in the tree.
    Zigzag length is defined as the number of nodes visited - 1. (A single node
    has a length of 0). Return the longest ZigZag path contained in that tree.

    Example 1:
    Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
    Output: 3
    Explanation: Longest ZigZag path in blue nodes (right -> left -> right).

    Example 2:
    Input: root = [1,1,1,null,1,null,null,1,1,null,1]
    Output: 4
    Explanation: Longest ZigZag path in blue nodes (left -> right -> left ->
                 right).

    Example 3:
    Input: root = [1]
    Output: 0

    Constraints:
    * The number of nodes in the tree is in the range [1, 5 * 10^4].
    * 1 <= Node.val <= 100*/

    public int longestZigZag(TreeNode root) {
        int ans = 0;
        Stack<Object[]> stk = new Stack();
        stk.push(new Object[]{root, false, 0});
        stk.push(new Object[]{root, true, 0});
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            TreeNode node = (TreeNode) elem[0];
            boolean left = (boolean) elem[1];
            int val = (int) elem[2];
            ans = Math.max(ans, val);
            if (node.left != null) stk.push(new Object[]{node.left, true, left ? 1 : val+1});
            if (node.right != null) stk.push(new Object[]{node.right, false, left ? val+1 : 1});
        }
        return ans;
    }


    /*1395. Count Number of Teams (Medium)
    There are n soldiers standing in a line. Each soldier is assigned a unique
    rating value. You have to form a team of 3 soldiers amongst them under the
    following rules:
    * Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j],
      rating[k]).
    * A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] >
      rating[j] > rating[k]) where (0 <= i < j < k < n).
    Return the number of teams you can form given the conditions. (soldiers can
    be part of multiple teams).

    Example 1:
    Input: rating = [2,5,3,4,1]
    Output: 3
    Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1),
                 (5,3,1).

    Example 2:
    Input: rating = [2,1,3]
    Output: 0
    Explanation: We can't form any team given the conditions.

    Example 3:
    Input: rating = [1,2,3,4]
    Output: 4

    Constraints:
    * n == rating.length
    * 3 <= n <= 1000
    * 1 <= rating[i] <= 10^5
    * All the integers in rating are unique.*/

    private int fn(List<Integer> vals) {
        int ans = 0, n = vals.size();
        Fenwick mark = new Fenwick(n), pair = new Fenwick(n);
        for (var x : vals) {
            ans += pair.query(x-1);
            mark.add(x, 1);
            pair.add(x, mark.query(x-1));
        }
        return ans;
    }

    public int numTeams(int[] rating) {
        int n = rating.length;
        int[] sort = rating.clone();
        Arrays.sort(sort);
        Map<Integer, Integer> mp = new HashMap();
        for (int i = 0; i < n; ++i)
            mp.put(sort[i], i);
        List<Integer> vals = new ArrayList();
        for (var x : rating)
            vals.add(mp.get(x));
        int ans = fn(vals);
        Collections.reverse(vals);
        ans += fn(vals);
        return ans;
    }


    /*1404. Number of Steps to Reduce a Number in Binary Representation to One (Medium)
    Given the binary representation of an integer as a string s, return the
    number of steps to reduce it to 1 under the following rules:
    * If the current number is even, you have to divide it by 2.
    * If the current number is odd, you have to add 1 to it.
    It is guaranteed that you can always reach one for all test cases.

    Example 1:
    Input: s = "1101"
    Output: 6
    Explanation: "1101" corressponds to number 13 in their decimal representation.
                 Step 1) 13 is odd, add 1 and obtain 14.
                 Step 2) 14 is even, divide by 2 and obtain 7.
                 Step 3) 7 is odd, add 1 and obtain 8.
                 Step 4) 8 is even, divide by 2 and obtain 4.
                 Step 5) 4 is even, divide by 2 and obtain 2.
                 Step 6) 2 is even, divide by 2 and obtain 1.

    Example 2:
    Input: s = "10"
    Output: 1
    Explanation: "10" corressponds to number 2 in their decimal representation.
                 Step 1) 2 is even, divide by 2 and obtain 1.

    Example 3:
    Input: s = "1"
    Output: 0

    Constraints:
    * 1 <= s.length <= 500
    * s consists of characters '0' or '1'
    * s[0] == '1'*/

    public int numSteps(String s) {
        int ans = 0, one = 0;
        for (int i = s.length()-1; i > 0; --i)
            if (s.charAt(i) == '1') {
                ans += 2-one;
                one = 1;
            } else ans += 1+one;
        return ans + one;
    }


    /*1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)
    Given an array of integers arr. We want to select three indices i, j and k
    where (0 <= i < j <= k < arr.length). Let's define a and b as follows:
    * a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
    * b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
    Note that ^ denotes the bitwise-xor operation. Return the number of triplets
    (i, j and k) Where a == b.

    Example 1:
    Input: arr = [2,3,1,6,7]
    Output: 4
    Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)

    Example 2:
    Input: arr = [1,1,1,1,1]
    Output: 10

    Constraints:
    * 1 <= arr.length <= 300
    * 1 <= arr[i] <= 10^8*/

    public int countTriplets(int[] arr) {
        int ans = 0, prefix = 0;
        Map<Integer, int[]> mp = new HashMap();
        mp.put(0, new int[]{0, 1});
        for (int i = 0; i < arr.length; ++i) {
            prefix ^= arr[i];
            int s = 0, c = 0;
            if (mp.containsKey(prefix)) {
                s = mp.get(prefix)[0];
                c = mp.get(prefix)[1];
            }
            ans += c*i - s;
            mp.put(prefix, new int[]{s+i+1, c+1});
        }
        return ans;
    }


    /*1443. Minimum Time to Collect All Apples in a Tree (Medium)
    Given an undirected tree consisting of n vertices numbered from 0 to n-1,
    which has some apples in their vertices. You spend 1 second to walk over
    one edge of the tree. Return the minimum time in seconds you have to spend
    to collect all apples in the tree, starting at vertex 0 and coming back to
    this vertex. The edges of the undirected tree are given in the array edges,
    where edges[i] = [ai, bi] means that exists an edge connecting the vertices
    ai and bi. Additionally, there is a boolean array hasApple, where
    hasApple[i] = true means that vertex i has an apple; otherwise, it does not
    have any apple.

    Example 1:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]],
           hasApple = [false,false,true,false,true,true,false]
    Output: 8
    Explanation: The figure above represents the given tree where red vertices
                 have an apple. One optimal path to collect all apples is shown
                 by the green arrows.

    Example 2:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]],
           hasApple = [false,false,true,false,false,true,false]
    Output: 6
    Explanation: The figure above represents the given tree where red vertices
                 have an apple. One optimal path to collect all apples is shown
                 by the green arrows.

    Example 3:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]],
           hasApple = [false,false,false,false,false,false,false]
    Output: 0

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai < bi <= n - 1
    * fromi < toi
    * hasApple.length == n*/

    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {
        List<Integer>[] tree = new ArrayList[n];
        for (int u = 0; u < n; ++u) tree[u] = new ArrayList();
        for (var e : edges) {
            tree[e[0]].add(e[1]);
            tree[e[1]].add(e[0]);
        }
        int[] ans = new int[n];
        boolean[] seen = new boolean[n];
        Stack<Pair<Integer, Integer>> stk = new Stack(); stk.push(new Pair(0, -1));
        while (!stk.isEmpty()) {
            var elem = stk.peek();
            int u = elem.getKey(), p = elem.getValue();
            if (seen[u]) {
                for (var v : tree[u])
                    if (v != p) ans[u] += ans[v];
                if (u > 0 && (ans[u] > 0 || hasApple.get(u))) ++ans[u];
                stk.pop();
            } else {
                for (var v : tree[u])
                    if (v != p) stk.push(new Pair(v, u));
                seen[u] = true;
            }
        }
        return ans[0]*2;
    }


    /*1460. Make Two Arrays Equal by Reversing Subarrays (Easy)
    You are given two integer arrays of equal length target and arr. In one
    step, you can select any non-empty subarray of arr and reverse it. You are
    allowed to make any number of steps. Return true if you can make arr equal
    to target or false otherwise.

    Example 1:
    Input: target = [1,2,3,4], arr = [2,4,1,3]
    Output: true
    Explanation: You can follow the next steps to convert arr to target:
                 1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]
                 2- Reverse subarray [4,2], arr becomes [1,2,4,3]
                 3- Reverse subarray [4,3], arr becomes [1,2,3,4]
                 There are multiple ways to convert arr to target, this is not
                 the only way to do so.

    Example 2:
    Input: target = [7], arr = [7]
    Output: true
    Explanation: arr is equal to target without any reverses.

    Example 3:
    Input: target = [3,7,9], arr = [3,7,11]
    Output: false
    Explanation: arr does not have value 9 and it can never be converted to
                 target.

    Constraints:
    * target.length == arr.length
    * 1 <= target.length <= 1000
    * 1 <= target[i] <= 1000
    * 1 <= arr[i] <= 1000*/

    public boolean canBeEqual(int[] target, int[] arr) {
        Map<Integer, Integer> freq = new HashMap();
        for (var x : target) freq.merge(x, 1, Integer::sum);
        for (var x : arr) freq.merge(x, -1, Integer::sum);
        return freq.values().stream().allMatch(x -> x == 0);
    }


    /*1470. Shuffle the Array (Easy)
    Given the array nums consisting of 2n elements in the form
    [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form
    [x1,y1,x2,y2,...,xn,yn].

    Example 1:
    Input: nums = [2,5,1,3,4,7], n = 3
    Output: [2,3,5,4,1,7]
    Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is
                 [2,3,5,4,1,7].

    Example 2:
    Input: nums = [1,2,3,4,4,3,2,1], n = 4
    Output: [1,4,2,3,3,2,4,1]

    Example 3:
    Input: nums = [1,1,2,2], n = 2
    Output: [1,2,1,2]

    Constraints:
    * 1 <= n <= 500
    * nums.length == 2n
    * 1 <= nums[i] <= 10^3*/

    public int[] shuffle(int[] nums, int n) {
        int[] ans = new int[2*n];
        for (int i = 0; i < n; ++i) {
            ans[2*i] = nums[i];
            ans[2*i+1] = nums[i+n];
        }
        return ans;
    }


    /*1482. Minimum Number of Days to Make m Bouquets (Medium)
    You are given an integer array bloomDay, an integer m and an integer k. You
    want to make m bouquets. To make a bouquet, you need to use k adjacent
    flowers from the garden. The garden consists of n flowers, the ith flower
    will bloom in the bloomDay[i] and then can be used in exactly one bouquet.
    Return the minimum number of days you need to wait to be able to make m
    bouquets from the garden. If it is impossible to make m bouquets return -1.

    Example 1:
    Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
    Output: 3
    Explanation: Let us see what happened in the first three days. x means
                 flower bloomed and _ means flower did not bloom in the garden.
                 We need 3 bouquets each should contain 1 flower.
                 After day 1: [x, _, _, _, _]   // we can only make one bouquet.
                 After day 2: [x, _, _, _, x]   // we can only make two bouquets.
                 After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The
                                                // answer is 3.

    Example 2:
    Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
    Output: -1
    Explanation: We need 3 bouquets each has 2 flowers, that means we need 6
                 flowers. We only have 5 flowers so it is impossible to get the
                 needed bouquets and we return -1.

    Example 3:
    Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
    Output: 12
    Explanation: We need 2 bouquets each should have 3 flowers. Here is the
                 garden after the 7 and 12 days:
                 After day 7: [x, x, x, x, _, x, x]
                 We can make one bouquet of the first three flowers that
                 bloomed. We cannot make another bouquet from the last three
                 flowers that bloomed because they are not adjacent.
                 After day 12: [x, x, x, x, x, x, x]
                 It is obvious that we can make two bouquets in different ways.

    Constraints:
    * bloomDay.length == n
    * 1 <= n <= 10^5
    * 1 <= bloomDay[i] <= 10^9
    * 1 <= m <= 10^6
    * 1 <= k <= n*/

    public int minDays(int[] bloomDay, int m, int k) {
        if (bloomDay.length < (long) m*k) return -1;
        int lo = 0, hi = Arrays.stream(bloomDay).max().getAsInt();
        while (lo < hi) {
            int mid = lo + (hi-lo)/2;
            int bouquet = 0, flower = 0;
            for (var x : bloomDay) {
                if (x <= mid) ++flower;
                else flower = 0;
                if (flower == k) {
                    flower = 0;
                    ++bouquet;
                }
            }
            if (bouquet >= m) hi = mid;
            else lo = mid + 1;
        }
        return lo;
    }


    /*1508. Range Sum of Sorted Subarray Sums (Medium)
    You are given the array nums consisting of n positive integers. You computed
    the sum of all non-empty continuous subarrays from the array and then sorted
    them in non-decreasing order, creating a new array of n * (n + 1) / 2
    numbers. Return the sum of the numbers from index left to index right
    (indexed from 1), inclusive, in the new array. Since the answer can be a
    huge number return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
    Output: 13
    Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After
                 sorting them in non-decreasing order we have the new array
                 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from
                 index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13.

    Example 2:
    Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
    Output: 6
    Explanation: The given array is the same as example 1. We have the new array
                 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from
                 index le = 3 to ri = 4 is 3 + 3 = 6.

    Example 3:
    Input: nums = [1,2,3,4], n = 4, left = 1, right = 10
    Output: 50

    Constraints:
    * n == nums.length
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 100
    * 1 <= left <= right <= n * (n + 1) / 2*/

    public int rangeSum(int[] nums, int n, int left, int right) {
        Queue<int[]> pq = new PriorityQueue<>((x, y) -> x[0] != y[0] ? Integer.compare(x[0], y[0]) : Integer.compare(x[1], y[1]));
        for (int i = 0; i < n; ++i)
            pq.add(new int[]{nums[i], i});
        long ans = 0;
        for (int k = 1; k <= right; ++k) {
            var elem = pq.poll();
            int x = elem[0], i = elem[1];
            if (k >= left) ans = (ans + x) % 1_000_000_007;
            if (i+1 < n)
                pq.add(new int[]{x + nums[i+1], i+1});
        }
        return (int) ans;
    }


    /*1509. Minimum Difference Between Largest and Smallest Value in Three Moves (Medium)
    You are given an integer array nums. In one move, you can choose one element
    of nums and change it to any value. Return the minimum difference between
    the largest and smallest value of nums after performing at most three moves.

    Example 1:
    Input: nums = [5,3,2,4]
    Output: 0
    Explanation: We can make at most 3 moves.
                 In the first move, change 2 to 3. nums becomes [5,3,3,4].
                 In the second move, change 4 to 3. nums becomes [5,3,3,3].
                 In the third move, change 5 to 3. nums becomes [3,3,3,3].
                 After performing 3 moves, the difference between the minimum
                 and maximum is 3 - 3 = 0.

    Example 2:
    Input: nums = [1,5,0,10,14]
    Output: 1
    Explanation: We can make at most 3 moves.
                 In the first move, change 5 to 0. nums becomes [1,0,0,10,14].
                 In the second move, change 10 to 0. nums becomes [1,0,0,0,14].
                 In the third move, change 14 to 1. nums becomes [1,0,0,0,1].
                 After performing 3 moves, the difference between the minimum
                 and maximum is 1 - 0 = 1. It can be shown that there is no way
                 to make the difference 0 in 3 moves.

    Example 3:
    Input: nums = [3,100,20]
    Output: 0
    Explanation: We can make at most 3 moves.
                 In the first move, change 100 to 7. nums becomes [3,7,20].
                 In the second move, change 20 to 7. nums becomes [3,7,7].
                 In the third move, change 3 to 7. nums becomes [7,7,7].
                 After performing 3 moves, the difference between the minimum
                 and maximum is 7 - 7 = 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    public int minDifference(int[] nums) {
        Arrays.sort(nums);
        int ans = Integer.MAX_VALUE;
        for (int i = 0, n = nums.length; i < 4 && i < n; ++i) {
            int j = Math.max(i, n-4+i);
            ans = Math.min(ans, nums[j]-nums[i]);
        }
        return ans;
    }


    /*1514. Path with Maximum Probability (Medium)
    You are given an undirected weighted graph of n nodes (0-indexed),
    represented by an edge list where edges[i] = [a, b] is an undirected edge
    connecting the nodes a and b with a probability of success of traversing
    that edge succProb[i]. Given two nodes start and end, find the path with the
    maximum probability of success to go from start to end and return its
    success probability. If there is no path from start to end, return 0. Your
    answer will be accepted if it differs from the correct answer by at most
    1e-5.

    Example 1:
    Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
    Output: 0.25000
    Explanation: There are two paths from start to end, one having a probability
                 of success = 0.2 and the other has 0.5 * 0.5 = 0.25.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
    Output: 0.30000

    Example 3:
    Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
    Output: 0.00000
    Explanation: There is no path between 0 and 2.

    Constraints:
    * 2 <= n <= 10^4
    * 0 <= start, end < n
    * start != end
    * 0 <= a, b < n
    * a != b
    * 0 <= succProb.length == edges.length <= 2*10^4
    * 0 <= succProb[i] <= 1
    * There is at most one edge between every two nodes.*/

    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {
        List<Pair<Integer, Double>>[] graph = new List[n];
        for (int u = 0; u < n; ++u)
            graph[u] = new ArrayList<>();
        for (int i = 0; i < edges.length; ++i) {
            int u = edges[i][0], v = edges[i][1];
            graph[u].add(new Pair<>(v, succProb[i]));
            graph[v].add(new Pair<>(u, succProb[i]));
        }
        Queue<Pair<Double, Integer>> pq = new PriorityQueue<>((x, y) -> Double.compare(y.getKey(), x.getKey()));
        pq.add(new Pair<>(1.0, start_node));
        double[] dist = new double[n];
        dist[start_node] = 1;
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            double p = elem.getKey();
            int u = elem.getValue();
            if (u == end_node) return p;
            for (var uu : graph[u]) {
                int v = uu.getKey();
                double x = uu.getValue();
                if (dist[v] < p*x) {
                    dist[v] = p*x;
                    pq.add(new Pair<>(p*x, v));
                }
            }
        }
        return 0;
    }


    /*1516. Move Sub-Tree of N-Ary Tree (Hard)
    Given the root of an N-ary tree of unique values, and two nodes of the tree
    p and q. You should move the subtree of the node p to become a direct child
    of node q. If p is already a direct child of q, do not change anything.
    Node p must be the last child in the children list of node q. Return the
    root of the tree after adjusting it. There are 3 cases for nodes p and q:
    * Node q is in the sub-tree of node p.
    * Node p is in the sub-tree of node q.
    * Neither node p is in the sub-tree of node q nor node q is in the sub-tree
      of node p.
    In cases 2 and 3, you just need to move p (with its sub-tree) to be a child
    of q, but in case 1 the tree may be disconnected, thus you need to
    reconnect the tree again. Please read the examples carefully before solving
    this problem. Nary-Tree input serialization is represented in their level
    order traversal, each group of children is separated by the null value (See
    examples). For example, the above tree is serialized as
    [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].

    Example 1:
    Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 4, q = 1
    Output: [1,null,2,3,4,null,5,null,6,null,7,8]
    Explanation: This example follows the second case as node p is in the sub-
                 tree of node q. We move node p with its sub-tree to be a
                 direct child of node q. Notice that node 4 is the last child
                 of node 1.

    Example 2:
    Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 7, q = 4
    Output: [1,null,2,3,null,4,5,null,6,null,7,8]
    Explanation: Node 7 is already a direct child of node 4. We don't change
                 anything.

    Example 3:
    Input: root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 3, q = 8
    Output: [1,null,2,null,4,5,null,7,8,null,null,null,3,null,6]
    Explanation: This example follows case 3 because node p is not in the sub-
                 tree of node q and vice-versa. We can move node 3 with its
                 sub-tree and make it as node 8's child.

    Constraints:
    * The total number of nodes is between [2, 1000].
    * Each node has a unique value.
    * p != null
    * q != null
    * p and q are two different nodes (i.e. p != q).*/

    public Node moveSubTree(Node root, Node p, Node q) {
        if (!q.children.contains(p)) {
            Map<Node, Node> parent = new HashMap(); parent.put(root, null);
            Stack<Node> stk = new Stack(); stk.push(root);
            while (!stk.isEmpty()) {
                var u = stk.pop();
                for (var v : u.children) {
                    parent.put(v, u);
                    stk.push(v);
                }
            }
            Set<Node> anc = new HashSet();
            for (var n = q; n != null; n = parent.get(n)) anc.add(n);
            if (anc.contains(p)) {
                parent.get(q).children.remove(q);
                if (p == root) root = q;
                else {
                    int i = parent.get(p).children.indexOf(p);
                    parent.get(p).children.set(i, q);
                }
            } else parent.get(p).children.remove(p);
            q.children.add(p);
        }
        return root;
    }


    /*1518. Water Bottles (Easy)
    There are numBottles water bottles that are initially full of water. You can
    exchange numExchange empty water bottles from the market with one full water
    bottle. The operation of drinking a full water bottle turns it into an empty
    bottle. Given the two integers numBottles and numExchange, return the
    maximum number of water bottles you can drink.

    Example 1:
    Input: numBottles = 9, numExchange = 3
    Output: 13
    Explanation: You can exchange 3 empty bottles to get 1 full water bottle.
                 Number of water bottles you can drink: 9 + 3 + 1 = 13.

    Example 2:
    Input: numBottles = 15, numExchange = 4
    Output: 19
    Explanation: You can exchange 4 empty bottles to get 1 full water bottle.
                 Number of water bottles you can drink: 15 + 3 + 1 = 19.

    Constraints:
    * 1 <= numBottles <= 100
    * 2 <= numExchange <= 100*/

    public int numWaterBottles(int numBottles, int numExchange) {
        int ans = 0, empty = 0;
        while (numBottles > 0) {
            ans += numBottles;
            numBottles += empty;
            empty = numBottles % numExchange;
            numBottles /= numExchange;
        }
        return ans;
    }


    /*1519. Number of Nodes in the Sub-Tree With the Same Label (Medium)
    You are given a tree (i.e. a connected, undirected graph that has no cycles)
    consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The
    root of the tree is the node 0, and each node of the tree has a label which
    is a lower-case character given in the string labels (i.e. The node with
    the number i has the label labels[i]). The edges array is given on the form
    edges[i] = [ai, bi], which means there is an edge between nodes ai and bi
    in the tree. Return an array of size n where ans[i] is the number of nodes
    in the subtree of the ith node which have the same label as node i. A
    subtree of a tree T is the tree consisting of a node in T and all of its
    descendant nodes.

    Example 1:
    Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = "abaedcd"
    Output: [2,1,1,1,1,1,1]
    Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label
                 'a' as well, thus the answer is 2. Notice that any node is
                 part of its sub-tree. Node 1 has a label 'b'. The sub-tree of
                 node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have
                 different labels than node 1, the answer is just 1 (the node
                 itself).

    Example 2:
    Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = "bbbb"
    Output: [4,2,1,1]
    Explanation: The sub-tree of node 2 contains only node 2, so the answer is
                 1. The sub-tree of node 3 contains only node 3, so the answer
                 is 1. The sub-tree of node 1 contains nodes 1 and 2, both have
                 label 'b', thus the answer is 2. The sub-tree of node 0
                 contains nodes 0, 1, 2 and 3, all with label 'b', thus the
                 answer is 4.

    Example 3:
    Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = "aabab"
    Output: [3,2,1,1,1]

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * labels.length == n
    * labels is consisting of only of lowercase English letters.*/

    public int[] countSubTrees(int n, int[][] edges, String labels) {
        List<Integer>[] tree = new ArrayList[n];
        for (int u = 0; u < n; ++u) tree[u] = new ArrayList();
        for (var e : edges) {
            tree[e[0]].add(e[1]);
            tree[e[1]].add(e[0]);
        }
        int[] ans = new int[n];
        boolean[] seen = new boolean[n];
        int[][] freq = new int[n][26];
        Stack<Pair<Integer, Integer>> stk = new Stack();
        stk.push(new Pair(0, -1));
        while (!stk.isEmpty()) {
            var elem = stk.peek();
            int u = elem.getKey(), p = elem.getValue();
            if (seen[u]) {
                ++freq[u][labels.charAt(u) - 'a'];
                for (var v : tree[u])
                    if (v != p)
                        for (int i = 0; i < 26; ++i)
                            freq[u][i] += freq[v][i];
                ans[u] = freq[u][labels.charAt(u) - 'a'];
                stk.pop();
            } else {
                for (var v : tree[u])
                    if (v != p) stk.push(new Pair(v, u));
                seen[u] = true;
            }
        }
        return ans;
    }


    /*1523. Count Odd Numbers in an Interval Range (Easy)
    Given two non-negative integers low and high. Return the count of odd
    numbers between low and high (inclusive).

    Example 1:
    Input: low = 3, high = 7
    Output: 3
    Explanation: The odd numbers between 3 and 7 are [3,5,7].

    Example 2:
    Input: low = 8, high = 10
    Output: 1
    Explanation: The odd numbers between 8 and 10 are [9].

    Constraints: 0 <= low <= high <= 10^9*/

    public int countOdds(int low, int high) {
        return (high+1)/2 - low/2;
    }


    /*1530. Number of Good Leaf Nodes Pairs (Medium)
    You are given the root of a binary tree and an integer distance. A pair of
    two different leaf nodes of a binary tree is said to be good if the length
    of the shortest path between them is less than or equal to distance. Return
    the number of good leaf node pairs in the tree.

    Example 1:
    Input: root = [1,2,3,null,4], distance = 3
    Output: 1
    Explanation: The leaf nodes of the tree are 3 and 4 and the length of the
                 shortest path between them is 3. This is the only good pair.

    Example 2:
    Input: root = [1,2,3,4,5,6,7], distance = 3
    Output: 2
    Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The
                 pair [4,6] is not good because the length of ther shortest path
                 between them is 4.

    Example 3:
    Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
    Output: 1
    Explanation: The only good pair is [2,5].

    Constraints:
    * The number of nodes in the tree is in the range [1, 2^10].
    * 1 <= Node.val <= 100
    * 1 <= distance <= 10*/

    int ans = 0;

    private List<Integer> dfs(TreeNode node, int distance) {
        if (node == null) return new ArrayList();
        if (node.left == null && node.right == null) return Arrays.asList(0);
        List<Integer> left = dfs(node.left, distance);
        List<Integer> right = dfs(node.right, distance);
        for (int i = 0, j = right.size()-1; i < left.size(); ++i) {
            for (; 0 <= j && left.get(i) + right.get(j) + 2 > distance; --j);
            ans += j+1;
        }
        List<Integer> out = new ArrayList();
        for (int i = 0, j = 0, m = left.size(), n = right.size(); i < m || j < n; ) {
            if (j == n || i < m && left.get(i) < right.get(j))
                out.add(left.get(i++) + 1);
            else
                out.add(right.get(j++) + 1);
        }
        return out;
    }

    public int countPairs(TreeNode root, int distance) {
        dfs(root, distance);
        return ans;
    }


    /*1539. Kth Missing Positive Number (Easy)
    Given an array arr of positive integers sorted in a strictly increasing
    order, and an integer k. Return the kth positive integer that is missing
    from this array.

    Example 1:
    Input: arr = [2,3,4,7,11], k = 5
    Output: 9
    Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...].
                 The 5th missing positive integer is 9.

    Example 2:
    Input: arr = [1,2,3,4], k = 2
    Output: 6
    Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing
                 positive integer is 6.

    Constraints:
    * 1 <= arr.length <= 1000
    * 1 <= arr[i] <= 1000
    * 1 <= k <= 1000
    * arr[i] < arr[j] for 1 <= i < j <= arr.length

    Follow up: Could you solve this problem in less than O(n) complexity?*/

    public int findKthPositive(int[] arr, int k) {
        int lo = 0, hi = arr.length;
        while (lo < hi){
            int mid = lo + (hi-lo)/2;
            if (arr[mid] - (mid+1) < k) lo = mid+1;
            else hi = mid;
        }
        return lo+k;
    }


    /*1544. Make The String Great (Easy)
    Given a string s of lower and upper case English letters. A good string is a
    string which doesn't have two adjacent characters s[i] and s[i + 1] where:
    * 0 <= i <= s.length - 2
    * s[i] is a lower-case letter and s[i + 1] is the same letter but in
      upper-case or vice-versa.
    To make the string good, you can choose two adjacent characters that make
    the string bad and remove them. You can keep doing this until the string
    becomes good. Return the string after making it good. The answer is
    guaranteed to be unique under the given constraints. Notice that an empty
    string is also good.

    Example 1:
    Input: s = "leEeetcode"
    Output: "leetcode"
    Explanation: In the first step, either you choose i = 1 or i = 2, both will
                 result "leEeetcode" to be reduced to "leetcode".

    Example 2:
    Input: s = "abBAcC"
    Output: ""
    Explanation: We have many possible scenarios, and all lead to the same
                 answer. For example:
                 "abBAcC" --> "aAcC" --> "cC" --> ""
                 "abBAcC" --> "abBA" --> "aA" --> ""

    Example 3:
    Input: s = "s"
    Output: "s"

    Constraints:
    * 1 <= s.length <= 100
    * s contains only lower and upper case English letters.*/

    public String makeGood(String s) {
        StringBuilder ans = new StringBuilder();
        for (var ch : s.toCharArray())
            if (ans.length() > 0 && (ans.charAt(ans.length()-1) ^ 32) == ch) ans.deleteCharAt(ans.length()-1);
            else ans.append(ch);
        return ans.toString();
    }


    /*1548. The Most Similar Path in a Graph (Hard)
    We have n cities and m bi-directional roads where roads[i] = [ai, bi]
    connects city ai with city bi. Each city has a name consisting of exactly
    three upper-case English letters given in the string array names. Starting
    at any city x, you can reach any city y where y != x (i.e., the cities and
    the roads are forming an undirected connected graph). You will be given a
    string array targetPath. You should find a path in the graph of the same
    length and with the minimum edit distance to targetPath. You need to return
    the order of the nodes in the path with the minimum edit distance. The path
    should be of the same length of targetPath and should be valid (i.e., there
    should be a direct road between ans[i] and ans[i + 1]). If there are
    multiple answers return any one of them.

    Example 1:
    Input: n = 5, roads = [[0,2],[0,3],[1,2],[1,3],[1,4],[2,4]], names = ["ATL","PEK","LAX","DXB","HND"], targetPath = ["ATL","DXB","HND","LAX"]
    Output: [0,2,4,2]
    Explanation: [0,2,4,2], [0,3,0,2] and [0,3,1,2] are accepted answers.
                 [0,2,4,2] is equivalent to ["ATL","LAX","HND","LAX"] which has
                           edit distance = 1 with targetPath.
                 [0,3,0,2] is equivalent to ["ATL","DXB","ATL","LAX"] which has
                           edit distance = 1 with targetPath.
                 [0,3,1,2] is equivalent to ["ATL","DXB","PEK","LAX"] which has
                           edit distance = 1 with targetPath.

    Example 2:
    Input: n = 4, roads = [[1,0],[2,0],[3,0],[2,1],[3,1],[3,2]], names = ["ATL","PEK","LAX","DXB"], targetPath = ["ABC","DEF","GHI","JKL","MNO","PQR","STU","VWX"]
    Output: [0,1,0,1,0,1,0,1]
    Explanation: Any path in this graph has edit distance = 8 with targetPath.

    Example 3:
    Input: n = 6, roads = [[0,1],[1,2],[2,3],[3,4],[4,5]], names = ["ATL","PEK","LAX","ATL","DXB","HND"], targetPath = ["ATL","DXB","HND","DXB","ATL","LAX","PEK"]
    Output: [3,4,5,4,3,2,1]
    Explanation: [3,4,5,4,3,2,1] is the only path with edit distance = 0 with
                 targetPath. It's equivalent to
                 ["ATL","DXB","HND","DXB","ATL","LAX","PEK"]

    Constraints:
    * 2 <= n <= 100
    * m == roads.length
    * n - 1 <= m <= (n * (n - 1) / 2)
    * 0 <= ai, bi <= n - 1
    * ai != bi
    * The graph is guaranteed to be connected and each pair of nodes may have
      at most one direct road.
    * names.length == n
    * names[i].length == 3
    * names[i] consists of upper-case English letters.
    * There can be two cities with the same name.
    * 1 <= targetPath.length <= 100
    * targetPath[i].length == 3
    * targetPath[i] consists of upper-case English letters.

    Follow up: If each node can be visited only once in the path, What should
               you change in your solution?*/

    public List<Integer> mostSimilar(int n, int[][] roads, String[] names, String[] targetPath) {
        List<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; ++i) graph[i] = new ArrayList();
        for (var r : roads) {
            graph[r[0]].add(r[1]);
            graph[r[1]].add(r[0]);
        }
        int m = targetPath.length;
        int[][] mp = new int[m][n], dp = new int[m+1][n];
        for (int i = m-1; i >= 0; --i) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
            for (int j = 0; j < n; ++j) {
                for (var k : graph[j])
                    if (dp[i+1][k] < dp[i][j]) {
                        dp[i][j] = dp[i+1][k];
                        mp[i][j] = k;
                    }
                if (!targetPath[i].equals(names[j])) ++dp[i][j];
            }
        }
        int jj = 0;
        for (int j = 0, v = Integer.MAX_VALUE; j < n; ++j)
            if (dp[0][j] < v) {
                jj = j;
                v = dp[0][j];
            }
        List<Integer> ans = new ArrayList();
        for (int i = 0; i < m; ++i) {
            ans.add(jj);
            jj = mp[i][jj];
        }
        return ans;
    }


    /*1550. Three Consecutive Odds (Easy)
    Given an integer array arr, return true if there are three consecutive odd
    numbers in the array. Otherwise, return false.

    Example 1:
    Input: arr = [2,6,4,1]
    Output: false
    Explanation: There are no three consecutive odds.

    Example 2:
    Input: arr = [1,2,34,3,4,5,7,23,12]
    Output: true
    Explanation: [5,7,23] are three consecutive odds.

    Constraints:
    * 1 <= arr.length <= 1000
    * 1 <= arr[i] <= 1000*/

    public boolean threeConsecutiveOdds(int[] arr) {
        int cnt = 0;
        for (var x : arr) {
            if (x % 2 == 1) ++cnt;
            else cnt = 0;
            if (cnt == 3) return true;
        }
        return false;
    }


    /*1552. Magnetic Force Between Two Balls (Medium)
    In the universe Earth C-137, Rick discovered a special form of magnetic
    force between two balls if they are put in his new invented basket. Rick has
    n empty baskets, the ith basket is at position[i], Morty has m balls and
    needs to distribute the balls into the baskets such that the minimum
    magnetic force between any two balls is maximum. Rick stated that magnetic
    force between two different balls at positions x and y is |x - y|. Given the
    integer array position and the integer m. Return the required force.

    Example 1:
    Input: position = [1,2,3,4,7], m = 3
    Output: 3
    Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the
                 magnetic force between ball pairs [3, 3, 6]. The minimum
                 magnetic force is 3. We cannot achieve a larger minimum
                 magnetic force than 3.

    Example 2:
    Input: position = [5,4,3,2,1,1000000000], m = 2
    Output: 999999999
    Explanation: We can use baskets 1 and 1000000000.

    Constraints:
    * n == position.length
    * 2 <= n <= 10^5
    * 1 <= position[i] <= 10^9
    * All integers in position are distinct.
    * 2 <= m <= position.length*/

    public int maxDistance(int[] position, int m) {
        Arrays.sort(position);
        int lo = 1, hi = position[position.length-1] - position[0];
        while (lo < hi) {
            int mid = (lo + hi + 1)/2, cnt = 0, prev = -1_000_000_000;
            for (var x : position)
                if (x - prev >= mid) {
                    ++cnt;
                    prev = x;
                }
            if (cnt >= m) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*1568. Minimum Number of Days to Disconnect Island (Hard)
    You are given an m x n binary grid grid where 1 represents land and 0
    represents water. An island is a maximal 4-directionally (horizontal or
    vertical) connected group of 1's. The grid is said to be connected if we
    have exactly one island, otherwise is said disconnected. In one day, we are
    allowed to change any single land cell (1) into a water cell (0). Return the
    minimum number of days to disconnect the grid.

    Example 1:
    Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
    Output: 2
    Explanation: We need at least 2 days to get a disconnected grid. Change land
                 grid[1][1] and grid[0][2] to water and get 2 disconnected
                 island.

    Example 2:
    Input: grid = [[1,1]]
    Output: 2
    Explanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0
                 islands.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 30
    * grid[i][j] is either 0 or 1.*/

    private int dfs(int[][] grid) {
        int ans = 0, m = grid.length, n = grid[0].length;
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        boolean[][] seen = new boolean[m][n];
        for (int x = 0; x < m; ++x)
            for (int y = 0; y < n; ++y) {
                if (grid[x][y] == 1 && !seen[x][y]) {
                    ++ans;
                    seen[x][y] = true;
                    Stack<int[]> stk = new Stack(); stk.push(new int[]{x, y});
                    while (!stk.isEmpty()) {
                        var elem = stk.pop();
                        int i = elem[0], j = elem[1];
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] == 1 && !seen[ii][jj]){
                                seen[ii][jj] = true;
                                stk.push(new int[]{ii, jj});
                            }
                        }
                    }
                }
            }
        return ans;
    }

    public int minDays(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        if (dfs(grid) != 1) return 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == 1) {
                    grid[i][j] = 0;
                    if (dfs(grid) != 1) return 1;
                    grid[i][j] = 1;
                }
        return 2;
    }


    /*1590. Make Sum Divisible by P (Medium)
    Given an array of positive integers nums, remove the smallest subarray
    (possibly empty) such that the sum of the remaining elements is divisible by
    p. It is not allowed to remove the whole array. Return the length of the
    smallest subarray that you need to remove, or -1 if it's impossible. A
    subarray is defined as a contiguous block of elements in the array.

    Example 1:
    Input: nums = [3,1,4,2], p = 6
    Output: 1
    Explanation: The sum of the elements in nums is 10, which is not divisible
                 by 6. We can remove the subarray [4], and the sum of the
                 remaining elements is 6, which is divisible by 6.

    Example 2:
    Input: nums = [6,3,5,2], p = 9
    Output: 2
    Explanation: We cannot remove a single element to get a sum divisible by 9.
                 The best way is to remove the subarray [5,2], leaving us with
                 [6,3] with sum 9.

    Example 3:
    Input: nums = [1,2,3], p = 3
    Output: 0
    Explanation: Here the sum is 6. which is already divisible by 3. Thus we do
                 not need to remove anything.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= p <= 10^9*/

    public int minSubarray(int[] nums, int p) {
        int ans = nums.length, prefix = 0, total = Arrays.stream(nums).reduce(0, (s, x) -> (s+x) % p);
        Map<Integer, Integer> last = new HashMap<>(); last.put(0, -1);
        for (int i = 0; i < nums.length; ++i) {
            prefix = (prefix + nums[i]) % p;
            last.put(prefix, i);
            int val = ((prefix - total) % p + p) % p;
            if (last.containsKey(val)) ans = Math.min(ans, i - last.get(val));
        }
        return ans < nums.length ? ans : -1;
    }


    /*1597. Build Binary Expression Tree From Infix Expression (Hard)
    A binary expression tree is a kind of binary tree used to represent
    arithmetic expressions. Each node of a binary expression tree has either
    zero or two children. Leaf nodes (nodes with 0 children) correspond to
    operands (numbers), and internal nodes (nodes with 2 children) correspond
    to the operators '+' (addition), '-' (subtraction), '*' (multiplication),
    and '/' (division). For each internal node with operator o, the infix
    expression it represents is (A o B), where A is the expression the left
    subtree represents and B is the expression the right subtree represents.
    You are given a string s, an infix expression containing operands, the
    operators described above, and parentheses '(' and ')'. Return any valid
    binary expression tree, whose in-order traversal reproduces s after
    omitting the parenthesis from it. Please note that order of operations
    applies in s. That is, expressions in parentheses are evaluated first, and
    multiplication and division happen before addition and subtraction.
    Operands must also appear in the same order in both s and the in-order
    traversal of the tree.

    Example 1:
    Input: s = "3*4-2*5"
    Output: [-,*,*,3,4,2,5]
    Explanation: The tree above is the only valid tree whose inorder traversal
                 produces s.

    Example 2:
    Input: s = "2-3/(5*2)+1"
    Output: [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2]
    Explanation: The inorder traversal of the tree above is 2-3/5*2+1 which is
                 the same as s without the parenthesis. The tree also produces
                 the correct result and its operands are in the same order as
                 they appear in s. The tree below is also a valid binary
                 expression tree with the same inorder traversal as s, but it
                 not a valid answer because it does not evaluate to the same
                 value. The third tree below is also not valid. Although it
                 produces the same result and is equivalent to the above trees,
                 its inorder traversal does not produce s and its operands are
                 not in the same order as s.

    Example 3:
    Input: s = "1+2+3+4+5"
    Output: [+,+,5,+,4,null,null,+,3,null,null,1,2]
    Explanation: The tree [+,+,5,+,+,null,null,1,2,3,4] is also one of many
                 other valid trees.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of digits and the characters '+', '-', '*', and '/'.
    * Operands in s are exactly 1 digit.
    * It is guaranteed that s is a valid expression.*/

    public Node expTree(String s) {
        s = "(" + s + ")";
        Map<Character, Integer> precedence = new HashMap();
        precedence.put('(', 0);
        precedence.put(')', 1);
        precedence.put('+', 1);
        precedence.put('-', 1);
        precedence.put('*', 2);
        precedence.put('/', 2);
        Stack<Character> ops = new Stack();
        List<Character> postfix = new ArrayList();
        for (var ch : s.toCharArray())
            if ('0' <= ch && ch <= '9') postfix.add(ch);
            else if (ch == '(') ops.push(ch);
            else {
                while (!ops.isEmpty() && precedence.get(ops.peek()) >= precedence.get(ch))
                    postfix.add(ops.pop());
                if (ch == ')') ops.pop();
                else ops.push(ch);
            }
        Stack<Node> stack = new Stack();
        for (var ch : postfix) {
            Node node = new Node(ch);
            if (ch < '0' || ch > '9') {
                node.right = stack.pop();
                node.left = stack.pop();
            }
            stack.push(node);
        }
        return stack.pop();
    }


    /*1598. Crawler Log Folder (Easy)
    The Leetcode file system keeps a log each time some user performs a change
    folder operation. The operations are described below:
    * "../" : Move to the parent folder of the current folder. (If you are
      already in the main folder, remain in the same folder).
    * "./" : Remain in the same folder.
    * "x/" : Move to the child folder named x (This folder is guaranteed to
      always exist).
    You are given a list of strings logs where logs[i] is the operation
    performed by the user at the ith step. The file system starts in the main
    folder, then the operations in logs are performed. Return the minimum number
    of operations needed to go back to the main folder after the change folder
    operations.

    Example 1:
    Input: logs = ["d1/","d2/","../","d21/","./"]
    Output: 2
    Explanation: Use this change folder operation "../" 2 times and go back to
                 the main folder.

    Example 2:
    Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
    Output: 3

    Example 3:
    Input: logs = ["d1/","../","../","../"]
    Output: 0

    Constraints:
    * 1 <= logs.length <= 10^3
    * 2 <= logs[i].length <= 10
    * logs[i] contains lowercase English letters, digits, '.', and '/'.
    * logs[i] follows the format described in the statement.
    * Folder names consist of lowercase English letters and digits.*/

    public int minOperations(String[] logs) {
        int ans = 0;
        for (var log : logs)
            if (log.equals("./")) continue;
            else if (log.equals("../")) ans = Math.max(0, --ans);
            else ++ans;
        return ans;
    }


    /*1609. Even Odd Tree (Medium)
    A binary tree is named Even-Odd if it meets the following conditions:
    * The root of the binary tree is at level index 0, its children are at level
      index 1, their children are at level index 2, etc.
    * For every even-indexed level, all nodes at the level have odd integer
      values in strictly increasing order (from left to right).
    * For every odd-indexed level, all nodes at the level have even integer
      values in strictly decreasing order (from left to right).
    Given the root of a binary tree, return true if the binary tree is Even-Odd,
    otherwise return false.

    Example 1:
    Input: root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
    Output: true
    Explanation: The node values on each level are:
                 Level 0: [1]
                 Level 1: [10,4]
                 Level 2: [3,7,9]
                 Level 3: [12,8,6,2]
                 Since levels 0 and 2 are all odd and increasing and levels 1
                 and 3 are all even and decreasing, the tree is Even-Odd.

    Example 2:
    Input: root = [5,4,2,3,3,7]
    Output: false
    Explanation: The node values on each level are:
                 Level 0: [5]
                 Level 1: [4,2]
                 Level 2: [3,3,7]
                 Node values in level 2 must be in strictly increasing order, so
                 the tree is not Even-Odd.

    Example 3:
    Input: root = [5,9,1,3,5,7]
    Output: false
    Explanation: Node values in the level 1 should be even integers.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 10^6*/

    public boolean isEvenOddTree(TreeNode root) {
        Queue<TreeNode> q = new LinkedList();
        q.add(root);
        for (int level = 0; !q.isEmpty(); level ^= 1) {
            int prev = level == 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            for (int sz = q.size(); sz > 0; --sz) {
                TreeNode node = q.poll();
                if ((node.val & 1) == level || level == 0 && prev >= node.val || level == 1 && prev <= node.val) return false;
                prev = node.val;
                if (node.left != null) q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
        }
        return true;
    }


    /*1614. Maximum Nesting Depth of the Parentheses (Easy)
    A string is a valid parentheses string (denoted VPS) if it meets one of the
    following:
    * It is an empty string "", or a single character not equal to "(" or ")",
    * It can be written as AB (A concatenated with B), where A and B are VPS's,
      or
    * It can be written as (A), where A is a VPS.
    We can similarly define the nesting depth depth(S) of any VPS S as follows:
    * depth("") = 0
    * depth(C) = 0, where C is a string with a single character not equal to "("
      or ")".
    * depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
    * depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
    For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1,
    and 2), and ")(" and "(()" are not VPS's. Given a VPS represented as string
    s, return the nesting depth of s.

    Example 1:
    Input: s = "(1+(2*3)+((8)/4))+1"
    Output: 3
    Explanation: Digit 8 is inside of 3 nested parentheses in the string.

    Example 2:
    Input: s = "(1)+((2))+(((3)))"
    Output: 3

    Constraints:
    * 1 <= s.length <= 100
    * s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
    * It is guaranteed that parentheses expression s is a VPS.*/

    public int maxDepth(String s) {
        int ans = 0, val = 0;
        for (var ch : s.toCharArray())
            if (ch == '(') ans = Math.max(ans, ++val);
            else if (ch == ')') --val;
        return ans;
    }


    /*1636. Sort Array by Increasing Frequency (Easy)
    Given an array of integers nums, sort the array in increasing order based on
    the frequency of the values. If multiple values have the same frequency,
    sort them in decreasing order. Return the sorted array.

    Example 1:
    Input: nums = [1,1,2,2,2,3]
    Output: [3,1,1,2,2,2]
    Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has
                 a frequency of 3.

    Example 2:
    Input: nums = [2,3,1,3,2]
    Output: [1,3,3,2,2]
    Explanation: '2' and '3' both have a frequency of 2, so they are sorted in
                 decreasing order.

    Example 3:
    Input: nums = [-1,1,-6,4,5,-6,1,4,1]
    Output: [5,-1,4,4,-6,-6,1,1,1]

    Constraints:
    * 1 <= nums.length <= 100
    * -100 <= nums[i] <= 100*/

    public int[] frequencySort(int[] nums) {
        Map<Integer, Integer> freq = new HashMap();
        for (var x : nums)
            freq.merge(x, 1, Integer::sum);
        return Arrays.stream(nums)
            .boxed()
            .sorted((x, y) -> freq.get(x) != freq.get(y) ? Integer.compare(freq.get(x), freq.get(y)) : Integer.compare(y, x))
            .mapToInt(x -> x)
            .toArray();
    }


    /*1653. Minimum Deletions to Make String Balanced (Medium)
    You are given a string s consisting only of characters 'a' and 'b'. You can
    delete any number of characters in s to make s balanced. s is balanced if
    there is no pair of indices (i,j) such that i < j and s[i] = 'b' and
    s[j]= 'a'. Return the minimum number of deletions needed to make s balanced.

    Example 1:
    Input: s = "aababbab"
    Output: 2
    Explanation: You can either:
                 - Delete the characters at 0-indexed positions 2 and 6
                   ("aababbab" -> "aaabbb"), or
                 - Delete the characters at 0-indexed positions 3 and 6
                   ("aababbab" -> "aabbbb").

    Example 2:
    Input: s = "bbaaaaabb"
    Output: 2
    Explanation: The only solution is to delete the first two characters.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is 'a' or 'b'.*/

    public int minimumDeletions(String s) {
        int ans = 0, prefix = 0;
        for (var ch : s.toCharArray())
            if (ch == 'b') ++prefix;
            else ans = Math.min(ans+1, prefix);
        return ans;
    }


    /*1675. Minimize Deviation in Array (Hard)
    You are given an array nums of n positive integers. You can perform two
    types of operations on any element of the array any number of times:
    * If the element is even, divide it by 2.
      + For example, if the array is [1,2,3,4], then you can do this operation
        on the last element, and the array will be [1,2,3,2].
    * If the element is odd, multiply it by 2.
      + For example, if the array is [1,2,3,4], then you can do this operation
        on the first element, and the array will be [2,2,3,4].
    The deviation of the array is the maximum difference between any two
    elements in the array. Return the minimum deviation the array can have
    after performing some number of operations.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 1
    Explanation: You can transform the array to [1,2,3,2], then to [2,2,3,2],
                 then the deviation will be 3 - 2 = 1.

    Example 2:
    Input: nums = [4,1,5,20,3]
    Output: 3
    Explanation: You can transform the array after two operations to
                 [4,2,5,5,3], then the deviation will be 5 - 2 = 3.

    Example 3:
    Input: nums = [2,10,8]
    Output: 3

    Constraints:
    * n == nums.length
    * 2 <= n <= 5 * 10^4
    * 1 <= nums[i] <= 10^9*/

    public int minimumDeviation(int[] nums) {
        Queue<Integer> pq = new PriorityQueue<>((a, b) -> Integer.compare(b, a));
        int lo = Integer.MAX_VALUE;
        for (var x : nums) {
            if (x % 2 == 1) x *= 2;
            pq.add(x);
            lo = Math.min(lo, x);
        }
        int ans = pq.peek() - lo;
        while (pq.peek() % 2 == 0) {
            int val = pq.poll() / 2;
            pq.add(val);
            lo = Math.min(lo, val);
            ans = Math.min(ans, pq.peek() - lo);
        }
        return ans;
    }


    /*1684. Count the Number of Consistent Strings (Easy)
    You are given a string allowed consisting of distinct characters and an
    array of strings words. A string is consistent if all characters in the
    string appear in the string allowed. Return the number of consistent strings
    in the array words.

    Example 1:
    Input: allowed = "ab", words = ["ad","bd","aaab","baa","badab"]
    Output: 2
    Explanation: Strings "aaab" and "baa" are consistent since they only contain
                 characters 'a' and 'b'.

    Example 2:
    Input: allowed = "abc", words = ["a","b","c","ab","ac","bc","abc"]
    Output: 7
    Explanation: All strings are consistent.

    Example 3:
    Input: allowed = "cad", words = ["cc","acd","b","ba","bac","bad","ac","d"]
    Output: 4
    Explanation: Strings "cc", "acd", "ac", and "d" are consistent.

    Constraints:
    * 1 <= words.length <= 10^4
    * 1 <= allowed.length <= 26
    * 1 <= words[i].length <= 10
    * The characters in allowed are distinct.
    * words[i] and allowed contain only lowercase English letters.*/

    public int countConsistentStrings(String allowed, String[] words) {
        int ans = 0;
        for (var word : words)
            if (word.chars().allMatch(ch -> allowed.indexOf(ch) >= 0)) ++ans;
        return ans;
    }


    /*1697. Checking Existence of Edge Length Limited Paths (Hard)
    An undirected graph of n nodes is defined by edgeList, where
    edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with
    distance disi. Note that there may be multiple edges between two nodes.
    Given an array queries, where queries[j] = [pj, qj, limitj], your task is
    to determine for each queries[j] whether there is a path between pj and qj
    such that each edge on the path has a distance strictly less than limitj .
    Return a boolean array answer, where answer.length == queries.length and
    the jth value of answer is true if there is a path for queries[j] is true,
    and false otherwise.

    Example 1:
    Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
    Output: [false,true]
    Explanation: The above figure shows the given graph. Note that there are
                 two overlapping edges between 0 and 1 with distances 2 and 16.
                 For the first query, between 0 and 1 there is no path where
                 each distance is less than 2, thus we return false for this
                 query. For the second query, there is a path (0 -> 1 -> 2) of
                 two edges with distances less than 5, thus we return true for
                 this query.

    Example 2:
    Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
    Output: [true,false]
    Exaplanation: The above figure shows the given graph.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= edgeList.length, queries.length <= 10^5
    * edgeList[i].length == 3
    * queries[j].length == 3
    * 0 <= ui, vi, pj, qj <= n - 1
    * ui != vi
    * pj != qj
    * 1 <= disi, limitj <= 10^9
    * There may be multiple edges between two nodes.*/

    private int find(int p, int[] parent) {
        if (p != parent[p])
            parent[p] = find(parent[p], parent);
        return parent[p];
    }

    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {
        int[] parent = new int[n];
        for (int i = 0; i < n; ++i) parent[i] = i;
        int m = queries.length;
        boolean[] ans = new boolean[m];
        Arrays.sort(edgeList, (a, b) -> Integer.compare(a[2], b[2]));
        int[][] augs = new int[m][4];
        for (int i = 0; i < m; ++i) {
            augs[i][0] = queries[i][0];
            augs[i][1] = queries[i][1];
            augs[i][2] = queries[i][2];
            augs[i][3] = i;
        }
        Arrays.sort(augs, (a, b) -> Integer.compare(a[2], b[2]));
        int ii = 0;
        for (var aug : augs) {
            int p = aug[0], q = aug[1], w = aug[2], i = aug[3];
            for (; ii < edgeList.length && edgeList[ii][2] < w; ++ii) {
                int uu = find(edgeList[ii][0], parent), vv = find(edgeList[ii][1], parent);
                if (uu != vv) parent[uu] = vv;
            }
            if (find(p, parent) == find(q, parent)) ans[i] = true;
        }
        return ans;
    }


    /*1700. Number of Students Unable to Eat Lunch (Easy)
    The school cafeteria offers circular and square sandwiches at lunch break,
    referred to by numbers 0 and 1 respectively. All students stand in a queue.
    Each student either prefers square or circular sandwiches. The number of
    sandwiches in the cafeteria is equal to the number of students. The
    sandwiches are placed in a stack. At each step:
    * If the student at the front of the queue prefers the sandwich on the top
      of the stack, they will take it and leave the queue.
    * Otherwise, they will leave it and go to the queue's end.
    This continues until none of the queue students want to take the top
    sandwich and are thus unable to eat. You are given two integer arrays
    students and sandwiches where sandwiches[i] is the type of the ith sandwich
    in the stack (i = 0 is the top of the stack) and students[j] is the
    preference of the jth student in the initial queue (j = 0 is the front of
    the queue). Return the number of students that are unable to eat.

    Example 1:
    Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
    Output: 0
    Explanation: - Front student leaves the top sandwich and returns to the end
                   of the line making students = [1,0,0,1].
                 - Front student leaves the top sandwich and returns to the end
                   of the line making students = [0,0,1,1].
                 - Front student takes the top sandwich and leaves the line
                   making students = [0,1,1] and sandwiches = [1,0,1].
                 - Front student leaves the top sandwich and returns to the end
                   of the line making students = [1,1,0].
                 - Front student takes the top sandwich and leaves the line
                   making students = [1,0] and sandwiches = [0,1].
                 - Front student leaves the top sandwich and returns to the end
                   of the line making students = [0,1].
                 - Front student takes the top sandwich and leaves the line
                   making students = [1] and sandwiches = [1].
                 - Front student takes the top sandwich and leaves the line
                   making students = [] and sandwiches = [].
                 Hence all students are able to eat.

    Example 2:
    Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
    Output: 3

    Constraints:
    * 1 <= students.length, sandwiches.length <= 100
    * students.length == sandwiches.length
    * sandwiches[i] is 0 or 1.
    * students[i] is 0 or 1.*/

    public int countStudents(int[] students, int[] sandwiches) {
        int prefix = IntStream.of(students).sum();
        for (int i = 0, n = sandwiches.length; i < n; ++i) {
            if (sandwiches[i] == 1 && prefix == 0 || sandwiches[i] == 0 && prefix == n-i) return n-i;
            prefix -= sandwiches[i];
        }
        return 0;
    }


    /*1701. Average Waiting Time (Medium)
    There is a restaurant with a single chef. You are given an array customers,
    where customers[i] = [arrivali, timei]:
    * arrivali is the arrival time of the ith customer. The arrival times are
      sorted in non-decreasing order.
    * timei is the time needed to prepare the order of the ith customer.
    When a customer arrives, he gives the chef his order, and the chef starts
    preparing it once he is idle. The customer waits till the chef finishes
    preparing his order. The chef does not prepare food for more than one
    customer at a time. The chef prepares food for customers in the order they
    were given in the input. Return the average waiting time of all customers.
    Solutions within 10-5 from the actual answer are considered accepted.

    Example 1:
    Input: customers = [[1,2],[2,5],[4,3]]
    Output: 5.00000
    Explanation: 1) The first customer arrives at time 1, the chef takes his
                    order and starts preparing it immediately at time 1, and
                    finishes at time 3, so the waiting time of the first
                    customer is 3 - 1 = 2.
                 2) The second customer arrives at time 2, the chef takes his
                    order and starts preparing it at time 3, and finishes at
                    time 8, so the waiting time of the second customer is
                    8 - 2 = 6.
                 3) The third customer arrives at time 4, the chef takes his
                    order and starts preparing it at time 8, and finishes at
                    time 11, so the waiting time of the third customer is
                    11 - 4 = 7.
                 So the average waiting time = (2 + 6 + 7) / 3 = 5.

    Example 2:
    Input: customers = [[5,2],[5,4],[10,3],[20,1]]
    Output: 3.25000
    Explanation: 1) The first customer arrives at time 5, the chef takes his
                    order and starts preparing it immediately at time 5, and
                    finishes at time 7, so the waiting time of the first
                    customer is 7 - 5 = 2.
                 2) The second customer arrives at time 5, the chef takes his
                    order and starts preparing it at time 7, and finishes at
                    time 11, so the waiting time of the second customer is
                    11 - 5 = 6.
                 3) The third customer arrives at time 10, the chef takes his
                    order and starts preparing it at time 11, and finishes at
                    time 14, so the waiting time of the third customer is
                    14 - 10 = 4.
                 4) The fourth customer arrives at time 20, the chef takes his
                    order and starts preparing it immediately at time 20, and
                    finishes at time 21, so the waiting time of the fourth
                    customer is 21 - 20 = 1.
                 So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.

    Constraints:
    * 1 <= customers.length <= 10^5
    * 1 <= arrivali, timei <= 10^4
    * arrivali <= arrivali+1*/

    public double averageWaitingTime(int[][] customers) {
        double ans = 0;
        int t = 0;
        for (var c : customers) {
            int arrival = c[0], time = c[1];
            t = Math.max(t, arrival) + time;
            ans += t - arrival;
        }
        return ans / customers.length;
    }


    /*1714. Sum Of Special Evenly-Spaced Elements In Array (Hard)
    You are given a 0-indexed integer array nums consisting of n non-negative
    integers. You are also given an array queries, where queries[i] = [xi, yi].
    The answer to the ith query is the sum of all nums[j] where xi <= j < n
    and (j - xi) is divisible by yi. Return an array answer where
    answer.length == queries.length and answer[i] is the answer to the ith
    query modulo 10^9 + 7.

    Example 1:
    Input: nums = [0,1,2,3,4,5,6,7], queries = [[0,3],[5,1],[4,2]]
    Output: [9,18,10]
    Explanation: The answers of the queries are as follows:
                 1) The j indices that satisfy this query are 0, 3, and 6.
                    nums[0] + nums[3] + nums[6] = 9
                 2) The j indices that satisfy this query are 5, 6, and 7.
                    nums[5] + nums[6] + nums[7] = 18
                 3) The j indices that satisfy this query are 4 and 6.
                    nums[4] + nums[6] = 10

    Example 2:
    Input: nums = [100,200,101,201,102,202,103,203], queries = [[0,7]]
    Output: [303]

    Constraints:
    * n == nums.length
    * 1 <= n <= 5 * 10^4
    * 0 <= nums[i] <= 10^9
    * 1 <= queries.length <= 1.5 * 10^5
    * 0 <= xi < n
    * 1 <= yi <= 5 * 10^4*/

    public int[] solve(int[] nums, int[][] queries) {
        final int mod = 1_000_000_007;
        int n = nums.length, r = (int) Math.sqrt(n);
        long[][] dp = new long[n][r];
        for (int i = n-1; i >= 0; --i)
            for (int j = 0; j < r; ++j) {
                dp[i][j] = nums[i];
                if (i+j < n) dp[i][j] = (dp[i][j] + dp[i+j][j]) % mod;
            }
        int[] ans = new int[queries.length];
        for (int i = 0; i < queries.length; ++i) {
            int x = queries[i][0], y = queries[i][1];
            if (y < r) ans[i] = (int) dp[x][y];
            else {
                long val = 0;
                for (int j = x; j < n; j += y) val = (val + nums[j]) % mod;
                ans[i] = (int) val;
            }
        }
        return ans;
    }


    /*1717. Maximum Score From Removing Substrings (Medium）
    You are given a string s and two integers x and y. You can perform two types
    of operations any number of times.
    * Remove substring "ab" and gain x points.
      + For example, when removing "ab" from "cabxbae" it becomes "cxbae".
    * Remove substring "ba" and gain y points.
      + For example, when removing "ba" from "cabxbae" it becomes "cabxe".
    Return the maximum points you can gain after applying the above operations
    on s.

    Example 1:
    Input: s = "cdbcbbaaabab", x = 4, y = 5
    Output: 19
    Explanation: - Remove the "ba" underlined in "cdbcbbaaabab". Now, s =
                   "cdbcbbaaab" and 5 points are added to the score.
                 - Remove the "ab" underlined in "cdbcbbaaab". Now, s =
                   "cdbcbbaa" and 4 points are added to the score.
                 - Remove the "ba" underlined in "cdbcbbaa". Now, s = "cdbcba"
                   and 5 points are added to the score.
                 - Remove the "ba" underlined in "cdbcba". Now, s = "cdbc" and 5
                   points are added to the score.
                 Total score = 5 + 4 + 5 + 5 = 19.

    Example 2:
    Input: s = "aabbaaxybbaabb", x = 5, y = 4
    Output: 20

    Constraints:
    * 1 <= s.length <= 10^5
    * 1 <= x, y <= 10^4
    * s consists of lowercase English letters.*/

    public int maximumGain(String s, int x, int y) {
        char a = 'a', b = 'b';
        if (x < y) {
            int temp = y; y = x; x = temp;
            char t = b; b = a; a = t;
        }
        int ans = 0, ca = 0, cb = 0;
        for (var ch : s.toCharArray())
            if (ch != 'a' && ch != 'b') {
                ans += Math.min(ca, cb) * y;
                ca = cb = 0;
            } else if (ch == b) {
                if (ca > 0) {
                    --ca;
                    ans += x;
                } else ++cb;
            } else ++ca;
        return ans + Math.min(ca, cb)*y;
    }


    /*1750. Minimum Length of String After Deleting Similar Ends (Medium)
    Given a string s consisting only of characters 'a', 'b', and 'c'. You are
    asked to apply the following algorithm on the string any number of times:
    * Pick a non-empty prefix from the string s where all the characters in the
      prefix are equal.
    * Pick a non-empty suffix from the string s where all the characters in this
      suffix are equal.
    * The prefix and the suffix should not intersect at any index.
    * The characters from the prefix and suffix must be the same.
    Delete both the prefix and the suffix. Return the minimum length of s after
    performing the above operation any number of times (possibly zero times).

    Example 1:
    Input: s = "ca"
    Output: 2
    Explanation: You can't remove any characters, so the string stays as is.

    Example 2:
    Input: s = "cabaabac"
    Output: 0
    Explanation: An optimal sequence of operations is:
                 - Take prefix = "c" and suffix = "c" and remove them,
                   s = "abaaba".
                 - Take prefix = "a" and suffix = "a" and remove them,
                   s = "baab".
                 - Take prefix = "b" and suffix = "b" and remove them, s = "aa".
                 - Take prefix = "a" and suffix = "a" and remove them, s = "".

    Example 3:
    Input: s = "aabccabba"
    Output: 3
    Explanation: An optimal sequence of operations is:
                 - Take prefix = "aa" and suffix = "a" and remove them,
                   s = "bccabb".
                 - Take prefix = "b" and suffix = "bb" and remove them,
                   s = "cca".

    Constraints:
    * 1 <= s.length <= 10^5
    * s only consists of characters 'a', 'b', and 'c'.*/

    public int minimumLength(String s) {
        int lo = 0, hi = s.length()-1;
        while (lo < hi && s.charAt(lo) == s.charAt(hi)) {
            char ch = s.charAt(lo);
            for (; lo <= hi && s.charAt(lo) == ch; ++lo);
            for (; lo <= hi && s.charAt(hi) == ch; --hi);
        }
        return hi - lo + 1;
    }


    /*1823. Find the Winner of the Circular Game (Medium)
    There are n friends that are playing a game. The friends are sitting in a
    circle and are numbered from 1 to n in clockwise order. More formally,
    moving clockwise from the ith friend brings you to the (i+1)th friend for
    1 <= i < n, and moving clockwise from the nth friend brings you to the 1st
    friend. The rules of the game are as follows:
    * Start at the 1st friend.
    * Count the next k friends in the clockwise direction including the friend
      you started at. The counting wraps around the circle and may count some
      friends more than once.
    * The last friend you counted leaves the circle and loses the game.
    * If there is still more than one friend in the circle, go back to step 2
      starting from the friend immediately clockwise of the friend who just lost
      and repeat.
    * Else, the last friend in the circle wins the game.
    Given the number of friends, n, and an integer k, return the winner of the
    game.

    Example 1:
    Input: n = 5, k = 2
    Output: 3
    Explanation: Here are the steps of the game:
                 1) Start at friend 1.
                 2) Count 2 friends clockwise, which are friends 1 and 2.
                 3) Friend 2 leaves the circle. Next start is friend 3.
                 4) Count 2 friends clockwise, which are friends 3 and 4.
                 5) Friend 4 leaves the circle. Next start is friend 5.
                 6) Count 2 friends clockwise, which are friends 5 and 1.
                 7) Friend 1 leaves the circle. Next start is friend 3.
                 8) Count 2 friends clockwise, which are friends 3 and 5.
                 9) Friend 5 leaves the circle. Only friend 3 is left, so they
                    are the winner.

    Example 2:
    Input: n = 6, k = 5
    Output: 1
    Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is
                 friend 1.

    Constraints: 1 <= k <= n <= 500

    Follow up: Could you solve this problem in linear time with constant space?*/

    public int findTheWinner(int n, int k) {
        /*Josephus Problem*/
        int ans = 0;
        for (int x = 2; x <= n; ++x)
            ans = (ans + k) % x;
        return ++ans;
    }


    /*1842. Next Palindrome Using Same Digits (Hard)
    You are given a numeric string num, representing a very large palindrome.
    Return the smallest palindrome larger than num that can be created by
    rearranging its digits. If no such palindrome exists, return an empty
    string "". A palindrome is a number that reads the same backward as
    forward.

    Example 1:
    Input: num = "1221"
    Output: "2112"
    Explanation: The next palindrome larger than "1221" is "2112".

    Example 2:
    Input: num = "32123"
    Output: ""
    Explanation: No palindromes larger than "32123" can be made by rearranging the digits.

    Example 3:
    Input: num = "45544554"
    Output: "54455445"
    Explanation: The next palindrome larger than "45544554" is "54455445".

    Constraints:
    * 1 <= num.length <= 10^5
    * num is a palindrome.*/

    public String nextPalindrome(String num) {
        char[] chars = num.toCharArray();
        for (int n = chars.length, i = n/2-2; i >= 0; --i)
            if (chars[i] < chars[i+1]) {
                int ii = i+1;
                for (int j = i+1; j < n/2; ++j)
                    if (chars[i] < chars[j]) ii = j;
                char temp = chars[i];
                chars[i] = chars[ii];
                chars[ii] = temp;
                for (int j = i+1; j < (i+1+n/2)/2; ++j) {
                    temp = chars[j];
                    chars[j] = chars[n/2+i-j];
                    chars[n/2+i-j] = temp;
                }
                for (int j = (n+1)/2; j < n; ++j) chars[j] = chars[n-1-j];
                return String.valueOf(chars);
            }
        return "";
    }


    /*1863. Sum of All Subset XOR Totals (Easy)
    The XOR total of an array is defined as the bitwise XOR of all its elements,
    or 0 if the array is empty.
    * For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
    Given an array nums, return the sum of all XOR totals for every subset of
    nums. Note: Subsets with the same elements should be counted multiple times.
    An array a is a subset of an array b if a can be obtained from b by deleting
    some (possibly zero) elements of b.

    Example 1:
    Input: nums = [1,3]
    Output: 6
    Explanation: The 4 subsets of [1,3] are:
                 - The empty subset has an XOR total of 0.
                 - [1] has an XOR total of 1.
                 - [3] has an XOR total of 3.
                 - [1,3] has an XOR total of 1 XOR 3 = 2.
                 0 + 1 + 3 + 2 = 6

    Example 2:
    Input: nums = [5,1,6]
    Output: 28
    Explanation: The 8 subsets of [5,1,6] are:
                 - The empty subset has an XOR total of 0.
                 - [5] has an XOR total of 5.
                 - [1] has an XOR total of 1.
                 - [6] has an XOR total of 6.
                 - [5,1] has an XOR total of 5 XOR 1 = 4.
                 - [5,6] has an XOR total of 5 XOR 6 = 3.
                 - [1,6] has an XOR total of 1 XOR 6 = 7.
                 - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
                 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

    Example 3:
    Input: nums = [3,4,5,6,7,8]
    Output: 480
    Explanation: The sum of all XOR totals for every subset is 480.

    Constraints:
    * 1 <= nums.length <= 12
    * 1 <= nums[i] <= 20*/

    public int subsetXORSum(int[] nums) {
        return IntStream.of(nums).reduce((x, y) -> x | y).getAsInt() << nums.length-1;
    }


    /*1894. Find the Student that Will Replace the Chalk (Medium)
    There are n students in a class numbered from 0 to n - 1. The teacher will
    give each student a problem starting with the student number 0, then the
    student number 1, and so on until the teacher reaches the student number
    n - 1. After that, the teacher will restart the process, starting with the
    student number 0 again. You are given a 0-indexed integer array chalk and an
    integer k. There are initially k pieces of chalk. When the student number i
    is given a problem to solve, they will use chalk[i] pieces of chalk to solve
    that problem. However, if the current number of chalk pieces is strictly
    less than chalk[i], then the student number i will be asked to replace the
    chalk. Return the index of the student that will replace the chalk pieces.

    Example 1:
    Input: chalk = [5,1,5], k = 22
    Output: 0
    Explanation: The students go in turns as follows:
                 - Student number 0 uses 5 chalk, so k = 17.
                 - Student number 1 uses 1 chalk, so k = 16.
                 - Student number 2 uses 5 chalk, so k = 11.
                 - Student number 0 uses 5 chalk, so k = 6.
                 - Student number 1 uses 1 chalk, so k = 5.
                 - Student number 2 uses 5 chalk, so k = 0.
                 Student number 0 does not have enough chalk, so they will have
                 to replace it.

    Example 2:
    Input: chalk = [3,4,1,2], k = 25
    Output: 1
    Explanation: The students go in turns as follows:
                 - Student number 0 uses 3 chalk so k = 22.
                 - Student number 1 uses 4 chalk so k = 18.
                 - Student number 2 uses 1 chalk so k = 17.
                 - Student number 3 uses 2 chalk so k = 15.
                 - Student number 0 uses 3 chalk so k = 12.
                 - Student number 1 uses 4 chalk so k = 8.
                 - Student number 2 uses 1 chalk so k = 7.
                 - Student number 3 uses 2 chalk so k = 5.
                 - Student number 0 uses 3 chalk so k = 2.
                 Student number 1 does not have enough chalk, so they will have
                 to replace it.

    Constraints:
    * chalk.length == n
    * 1 <= n <= 10^5
    * 1 <= chalk[i] <= 10^5
    * 1 <= k <= 10^9*/

    public int chalkReplacer(int[] chalk, int k) {
        long total = Arrays.stream(chalk).asLongStream().sum();
        k %= total;
        for (int i = 0; i < chalk.length; ++i)
            if ((k -= chalk[i]) < 0) return i;
        return -1;
    }


    /*1905. Count Sub Islands (Medium)
    You are given two m x n binary matrices grid1 and grid2 containing only 0's
    (representing water) and 1's (representing land). An island is a group of
    1's connected 4-directionally (horizontal or vertical). Any cells outside of
    the grid are considered water cells. An island in grid2 is considered a sub-
    island if there is an island in grid1 that contains all the cells that make
    up this island in grid2. Return the number of islands in grid2 that are
    considered sub-islands.

    Example 1:
    Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]],
           grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
    Output: 3
    Explanation: In the picture above, the grid on the left is grid1 and the
                 grid on the right is grid2. The 1s colored red in grid2 are
                 those considered to be part of a sub-island. There are three
                 sub-islands.

    Example 2:
    Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]],
           grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
    Output: 2
    Explanation: In the picture above, the grid on the left is grid1 and the
                 grid on the right is grid2. The 1s colored red in grid2 are
                 those considered to be part of a sub-island. There are two sub-
                 islands.

    Constraints:
    * m == grid1.length == grid2.length
    * n == grid1[i].length == grid2[i].length
    * 1 <= m, n <= 500
    * grid1[i][j] and grid2[i][j] are either 0 or 1.*/

    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int ans = 0, m = grid1.length, n = grid1[0].length;
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        for (int x = 0; x < m; ++x)
            for (int y = 0; y < n; ++y)
                if (grid2[x][y] == 1) {
                    int val = 1;
                    grid2[x][y] = 0;
                    Stack<int[]> stk = new Stack<>(); stk.push(new int[]{x, y});
                    while (!stk.isEmpty()) {
                        var elem = stk.pop();
                        int i = elem[0], j = elem[1];
                        val &= grid1[i][j];
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid2[ii][jj] == 1) {
                                grid2[ii][jj] = 0;
                                stk.push(new int[]{ii, jj});
                            }
                        }
                    }
                    ans += val;
                }
        return ans;
    }


    /*1915. Number of Wonderful Substrings (Medium)
    A wonderful string is a string where at most one letter appears an odd
    number of times. For example, "ccjjc" and "abab" are wonderful, but "ab" is
    not. Given a string word that consists of the first ten lowercase English
    letters ('a' through 'j'), return the number of wonderful non-empty
    substrings in word. If the same substring appears multiple times in word,
    then count each occurrence separately. A substring is a contiguous sequence
    of characters in a string.

    Example 1:
    Input: word = "aba"
    Output: 4
    Explanation: The four wonderful substrings are underlined below:
                 - "aba" -> "a"
                 - "aba" -> "b"
                 - "aba" -> "a"
                 - "aba" -> "aba"

    Example 2:
    Input: word = "aabb"
    Output: 9
    Explanation: The nine wonderful substrings are underlined below:
                 - "aabb" -> "a"
                 - "aabb" -> "aa"
                 - "aabb" -> "aab"
                 - "aabb" -> "aabb"
                 - "aabb" -> "a"
                 - "aabb" -> "abb"
                 - "aabb" -> "b"
                 - "aabb" -> "bb"
                 - "aabb" -> "b"

    Example 3:
    Input: word = "he"
    Output: 2
    Explanation: The two wonderful substrings are underlined below:
                 - "he" -> "h"
                 - "he" -> "e"

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists of lowercase English letters from 'a' to 'j'.*/

    public long wonderfulSubstrings(String word) {
        long ans = 0;
        Map<Integer, Integer> freq = new HashMap();
        freq.put(0, 1);
        int mask = 0;
        for (var ch : word.toCharArray()) {
            mask ^= 1 << ch-'a';
            ans += freq.getOrDefault(mask, 0);
            for (int i = 0; i < 10; ++i)
                ans += freq.getOrDefault(mask^1<<i, 0);
            freq.merge(mask, 1, Integer::sum);
        }
        return ans;
    }


    /*1937. Maximum Number of Points with Cost (Medium)
    You are given an m x n integer matrix points (0-indexed). Starting with 0
    points, you want to maximize the number of points you can get from the
    matrix. To gain points, you must pick one cell in each row. Picking the cell
    at coordinates (r, c) will add points[r][c] to your score. However, you will
    lose points if you pick a cell too far from the cell that you picked in the
    previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1),
    picking cells at coordinates (r, c1) and (r + 1, c2) will subtract
    abs(c1 - c2) from your score. Return the maximum number of points you can
    achieve.

    abs(x) is defined as:
    * x for x >= 0.
    * -x for x < 0.

    Example 1:
    Input: points = [[1,2,3],[1,5,1],[3,1,1]]
    Output: 9
    Explanation: The blue cells denote the optimal cells to pick, which have
                 coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11
                 to your score. However, you must subtract abs(2 - 1) +
                 abs(1 - 0) = 2 from your score. Your final score is 11 - 2 = 9.

    Example 2:
    Input: points = [[1,5],[2,3],[4,2]]
    Output: 11
    Explanation: The blue cells denote the optimal cells to pick, which have
                 coordinates (0, 1), (1, 1), and (2, 0). You add 5 + 3 + 4 = 12
                 to your score. However, you must subtract abs(1 - 1) +
                 abs(1 - 0) = 1 from your score. Your final score is 12 - 1 = 11.

    Constraints:
    * m == points.length
    * n == points[r].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 0 <= points[r][c] <= 10^5*/

    public long maxPoints(int[][] points) {
        int m = points.length, n = points[0].length;
        long[][] dp = new long[m][n];
        dp[0] = Arrays.stream(points[0]).mapToLong(i -> i).toArray();
        for (int i = 1; i < m; ++i) {
            for (int j = n-2; j >= 0; --j)
                dp[i-1][j] = Math.max(dp[i-1][j], dp[i-1][j+1]-1);
            long prefix = 0;
            for (int j = 0; j < n; ++j) {
                dp[i][j] = points[i][j] + Math.max(prefix, dp[i-1][j]);
                prefix = Math.max(prefix, dp[i-1][j])-1;
            }
        }
        return Arrays.stream(dp[m-1]).max().getAsLong();
    }


    /*1942. The Number of the Smallest Unoccupied Chair (Medium)
    There is a party where n friends numbered from 0 to n - 1 are attending.
    There is an infinite number of chairs in this party that are numbered from 0
    to infinity. When a friend arrives at the party, they sit on the unoccupied
    chair with the smallest number.
    * For example, if chairs 0, 1, and 5 are occupied when a friend comes, they
      will sit on chair number 2.
    When a friend leaves the party, their chair becomes unoccupied at the moment
    they leave. If another friend arrives at that same moment, they can sit in
    that chair. You are given a 0-indexed 2D integer array times where
    times[i] = [arrivali, leavingi], indicating the arrival and leaving times of
    the ith friend respectively, and an integer targetFriend. All arrival times
    are distinct. Return the chair number that the friend numbered targetFriend
    will sit on.

    Example 1:
    Input: times = [[1,4],[2,3],[4,6]], targetFriend = 1
    Output: 1
    Explanation: - Friend 0 arrives at time 1 and sits on chair 0.
                 - Friend 1 arrives at time 2 and sits on chair 1.
                 - Friend 1 leaves at time 3 and chair 1 becomes empty.
                 - Friend 0 leaves at time 4 and chair 0 becomes empty.
                 - Friend 2 arrives at time 4 and sits on chair 0.
                 Since friend 1 sat on chair 1, we return 1.

    Example 2:
    Input: times = [[3,10],[1,5],[2,6]], targetFriend = 0
    Output: 2
    Explanation: - Friend 1 arrives at time 1 and sits on chair 0.
                 - Friend 2 arrives at time 2 and sits on chair 1.
                 - Friend 0 arrives at time 3 and sits on chair 2.
                 - Friend 1 leaves at time 5 and chair 0 becomes empty.
                 - Friend 2 leaves at time 6 and chair 1 becomes empty.
                 - Friend 0 leaves at time 10 and chair 2 becomes empty.
                 Since friend 0 sat on chair 2, we return 2.

    Constraints:
    * n == times.length
    * 2 <= n <= 10^4
    * times[i].length == 2
    * 1 <= arrivali < leavingi <= 10^5
    * 0 <= targetFriend <= n - 1
    * Each arrivali time is distinct.*/

    public int smallestChair(int[][] times, int targetFriend) {
        List<int[]> line = new ArrayList<>();
        for (int i = 0; i < times.length; ++i) {
            line.add(new int[]{times[i][0], 1, i});
            line.add(new int[]{times[i][1], 0, i});
        }
        Collections.sort(line, (x, y) -> x[0] != y[0] ? Integer.compare(x[0], y[0]) : Integer.compare(x[1], y[1]));
        int k = 0;
        Map<Integer, Integer> mp = new HashMap<>();
        Queue<Integer> pq = new PriorityQueue<>();
        for (var elem : line) {
            int arrival = elem[1], i = elem[2];
            if (arrival == 1) {
                if (!pq.isEmpty()) mp.put(i, pq.poll());
                else mp.put(i, k++);
                if (i == targetFriend) return mp.get(i);
            } else pq.add(mp.get(i));
        }
        return -1;
    }


    /*1945. Sum of Digits of String After Convert (Easy)
    You are given a string s consisting of lowercase English letters, and an
    integer k. First, convert s into an integer by replacing each letter with
    its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z'
    with 26). Then, transform the integer by replacing it with the sum of its
    digits. Repeat the transform operation k times in total. For example, if
    s = "zbax" and k = 2, then the resulting integer would be 8 by the following
    operations:
    * Convert: "zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124
    * Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
    * Transform #2: 17 ➝ 1 + 7 ➝ 8
    Return the resulting integer after performing the operations described
    above.

    Example 1:
    Input: s = "iiii", k = 1
    Output: 36
    Explanation: The operations are as follows:
                 - Convert: "iiii" ➝ "(9)(9)(9)(9)" ➝ "9999" ➝ 9999
                 - Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36
                 Thus the resulting integer is 36.

    Example 2:
    Input: s = "leetcode", k = 2
    Output: 6
    Explanation: The operations are as follows:
                 - Convert: "leetcode" ➝ "(12)(5)(5)(20)(3)(15)(4)(5)" ➝
                   "12552031545" ➝ 12552031545
                 - Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 +
                   5 + 4 + 5 ➝ 33
                 - Transform #2: 33 ➝ 3 + 3 ➝ 6
                 Thus the resulting integer is 6.

    Example 3:
    Input: s = "zbax", k = 2
    Output: 8

    Constraints:
    * 1 <= s.length <= 100
    * 1 <= k <= 10
    * s consists of lowercase English letters.*/

    public int getLucky(String s, int k) {
        int ans = 0;
        for (var ch : s.toCharArray()) {
            int x = ch - 'a' + 1;
            ans += x/10 + x%10;
        }
        while (--k > 0) {
            int sm = 0;
            for (; ans > 0; ans /= 10) sm += ans % 10;
            ans = sm;
        }
        return ans;
    }


    /*1956. Minimum Time For K Virus Variants to Spread (Hard)
    There are n unique virus variants in an infinite 2D grid. You are given a
    2D array points, where points[i] = [xi, yi] represents a virus originating
    at (xi, yi) on day 0. Note that it is possible for multiple virus variants
    to originate at the same point. Every day, each cell infected with a virus
    variant will spread the virus to all neighboring points in the four
    cardinal directions (i.e. up, down, left, and right). If a cell has
    multiple variants, all the variants will spread without interfering with
    each other. Given an integer k, return the minimum integer number of days
    for any point to contain at least k of the unique virus variants.

    Example 1:
    Input: points = [[1,1],[6,1]], k = 2
    Output: 3
    Explanation: On day 3, points (3,1) and (4,1) will contain both virus
                 variants. Note that these are not the only points that will
                 contain both virus variants.

    Example 2:
    Input: points = [[3,3],[1,2],[9,2]], k = 2
    Output: 2
    Explanation: On day 2, points (1,3), (2,3), (2,2), and (3,2) will contain
                 the first two viruses. Note that these are not the only points
                 that will contain both virus variants.

    Example 3:
    Input: points = [[3,3],[1,2],[9,2]], k = 3
    Output: 4
    Explanation: On day 4, the point (5,2) will contain all 3 viruses. Note
                 that this is not the only point that will contain all 3 virus
                 variants.

    Constraints:
    * n == points.length
    * 2 <= n <= 50
    * points[i].length == 2
    * 1 <= xi, yi <= 100
    * 2 <= k <= n*/

    private boolean fn(int day, int[][] points, int k) {
        Map<Integer, Map<Integer, Integer>> lines = new HashMap();
        for (var p : points) {
            int x = p[0], y = p[1];
            lines.putIfAbsent(x+y-day, new HashMap());
            lines.putIfAbsent(x+y+day, new HashMap());
            lines.putIfAbsent(x+y+day+1, new HashMap());
            lines.get(x+y-day).merge(y-x+day, 0, Integer::sum);
            lines.get(x+y+day).merge(y-x-day, 0, Integer::sum);
            lines.get(x+y+day).merge(y-x+day, 0, Integer::sum);
            lines.get(x+y-day).merge(y-x-day, 1, Integer::sum);
            lines.get(x+y-day).merge(y-x+day+1, -1, Integer::sum);
            lines.get(x+y+day+1).merge(y-x-day, -1, Integer::sum);
            lines.get(x+y+day+1).merge(y-x+day+1, 1, Integer::sum);
        }
        List<Integer> rows = new ArrayList();
        for (var xx : lines.keySet()) rows.add(xx);
        Collections.sort(rows);
        Map<Integer, Integer> line = new HashMap();
        for (var xx : rows) {
            for (var elem : lines.get(xx).entrySet()) {
                int yy = elem.getKey(), vv = elem.getValue();
                line.merge(yy, vv, Integer::sum);
            }
            int prefix = 0;
            List<Integer> keys = new ArrayList();
            for (var yy : line.keySet()) keys.add(yy);
            Collections.sort(keys);
            for (var yy : keys) {
                prefix += line.get(yy);
                if (prefix >= k && ((xx-yy)%2 == 0 || !lines.containsKey(xx+1) || prefix+line.getOrDefault(yy+1, 0) >= k)) return true;
            }
        }
        return false;
    }

    public int minDayskVariants(int[][] points, int k) {
        int lo = 0, hi = 1_000_000_000;
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (fn(mid, points, k)) hi = mid;
            else lo = mid + 1;
        }
        return lo;
    }


    /*1962. Remove Stones to Minimize the Total (Medium)
    You are given a 0-indexed integer array piles, where piles[i] represents
    the number of stones in the ith pile, and an integer k. You should apply
    the following operation exactly k times:
    * Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
    Notice that you can apply the operation on the same pile more than once.
    Return the minimum possible total number of stones remaining after applying
    the k operations. floor(x) is the greatest integer that is smaller than or
    equal to x (i.e., rounds x down).

    Example 1:
    Input: piles = [5,4,9], k = 2
    Output: 12
    Explanation: Steps of a possible scenario are:
                 - Apply the operation on pile 2. The resulting piles are
                   [5,4,5].
                 - Apply the operation on pile 0. The resulting piles are
                   [3,4,5].
                 The total number of stones in [3,4,5] is 12.

    Example 2:
    Input: piles = [4,3,6,7], k = 3
    Output: 12
    Explanation: Steps of a possible scenario are:
                 - Apply the operation on pile 2. The resulting piles are
                   [4,3,3,7].
                 - Apply the operation on pile 3. The resulting piles are
                   [4,3,3,4].
                 - Apply the operation on pile 0. The resulting piles are
                   [2,3,3,4].
                 The total number of stones in [2,3,3,4] is 12.

    Constraints:
    * 1 <= piles.length <= 10^5
    * 1 <= piles[i] <= 10^4
    * 1 <= k <= 10^5*/

    public int minStoneSum(int[] piles, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue(Collections.reverseOrder());
        for (var x : piles) pq.add(x);
        while (k-- > 0) {
            var x = pq.poll();
            x -= x/2;
            pq.add(x);
        }
        int ans = 0;
        while (!pq.isEmpty()) ans += pq.poll();
        return ans;
    }


    /*1963. Minimum Number of Swaps to Make the String Balanced (Medium)
    You are given a 0-indexed string s of even length n. The string consists of
    exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'. A string
    is called balanced if and only if:
    * It is the empty string, or
    * It can be written as AB, where both A and B are balanced strings, or
    * It can be written as [C], where C is a balanced string.
    You may swap the brackets at any two indices any number of times. Return the
    minimum number of swaps to make s balanced.

    Example 1:
    Input: s = "][]["
    Output: 1
    Explanation: You can make the string balanced by swapping index 0 with index
                 3. The resulting string is "[[]]".

    Example 2:
    Input: s = "]]][[["
    Output: 2
    Explanation: You can do the following to make the string balanced:
                 - Swap index 0 with index 4. s = "[]][][".
                 - Swap index 1 with index 5. s = "[[][]]".
                 The resulting string is "[[][]]".

    Example 3:
    Input: s = "[]"
    Output: 0
    Explanation: The string is already balanced.

    Constraints:
    * n == s.length
    * 2 <= n <= 106
    * n is even.
    * s[i] is either '[' or ']'.
    * The number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.*/

    public int minSwaps(String s) {
        int ans = 0, bal = 0;
        for (var ch : s.toCharArray()) {
            if (ch == ']') ++bal;
            else --bal;
            ans = Math.max(ans, bal);
        }
        return ++ans/2;
    }


    /*1971. Find if Path Exists in Graph (Easy)
    There is a bi-directional graph with n vertices, where each vertex is
    labeled from 0 to n - 1 (inclusive). The edges in the graph are represented
    as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-
    directional edge between vertex ui and vertex vi. Every vertex pair is
    connected by at most one edge, and no vertex has an edge to itself. You want
    to determine if there is a valid path that exists from vertex source to
    vertex destination. Given edges and the integers n, source, and destination,
    return true if there is a valid path from source to destination, or false
    otherwise.

    Example 1:
    Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
    Output: true
    Explanation: There are two paths from vertex 0 to vertex 2:
                 - 0 → 1 → 2
                 - 0 → 2

    Example 2:
    Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
    Output: false
    Explanation: There is no path from vertex 0 to vertex 5.

    Constraints:
    * 1 <= n <= 2 * 10^5
    * 0 <= edges.length <= 2 * 10^5
    * edges[i].length == 2
    * 0 <= ui, vi <= n - 1
    * ui != vi
    * 0 <= source, destination <= n - 1
    * There are no duplicate edges.
    * There are no self edges.*/

    public boolean validPath(int n, int[][] edges, int source, int destination) {
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; ++i)
            graph[i] = new ArrayList();
        for (var e : edges) {
            int u = e[0], v = e[1];
            graph[u].add(v);
            graph[v].add(u);
        }
        boolean[] seen = new boolean[n];
        seen[source] = true;
        Stack<Integer> stk = new Stack();
        stk.push(source);
        while (!stk.isEmpty()) {
            int u = stk.pop();
            if (u == destination) return true;
            for (var v : graph[u])
                if (!seen[v]) {
                    seen[v] = true;
                    stk.push(v);
                }
        }
        return false;
    }


    /*1992. Find All Groups of Farmland (Medium)
    You are given a 0-indexed m x n binary matrix land where a 0 represents a
    hectare of forested land and a 1 represents a hectare of farmland. To keep
    the land organized, there are designated rectangular areas of hectares that
    consist entirely of farmland. These rectangular areas are called groups. No
    two groups are adjacent, meaning farmland in one group is not four-
    directionally adjacent to another farmland in a different group. land can be
    represented by a coordinate system where the top left corner of land is
    (0, 0) and the bottom right corner of land is (m-1, n-1). Find the
    coordinates of the top left and bottom right corner of each group of
    farmland. A group of farmland with a top left corner at (r1, c1) and a
    bottom right corner at (r2, c2) is represented by the 4-length array
    [r1, c1, r2, c2]. Return a 2D array containing the 4-length arrays described
    above for each group of farmland in land. If there are no groups of
    farmland, return an empty array. You may return the answer in any order.

    Example 1:
    Input: land = [[1,0,0],[0,1,1],[0,1,1]]
    Output: [[0,0,0,0],[1,1,2,2]]
    Explanation: The first group has a top left corner at land[0][0] and a
                 bottom right corner at land[0][0]. The second group has a top
                 left corner at land[1][1] and a bottom right corner at
                 land[2][2].

    Example 2:
    Input: land = [[1,1],[1,1]]
    Output: [[0,0,1,1]]
    Explanation: The first group has a top left corner at land[0][0] and a
                 bottom right corner at land[1][1].

    Example 3:
    Input: land = [[0]]
    Output: []
    Explanation: There are no groups of farmland.

    Constraints:
    * m == land.length
    * n == land[i].length
    * 1 <= m, n <= 300
    * land consists of only 0's and 1's.
    * Groups of farmland are rectangular in shape.*/

    public int[][] findFarmland(int[][] land) {
        int m = land.length, n = land[0].length;
        List<int[]> ans = new ArrayList();
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                if (land[i][j] == 1) {
                    int ii = i, jj = j;
                    for (; jj < n && land[i][jj] == 1; ++jj);
                    for (; ii < m && land[ii][j] == 1; ++ii)
                        land[ii][j] = -jj;
                    ans.add(new int[]{i, j, ii-1, jj-1});
                }
                if (land[i][j] < 0) j = -land[i][j];
            }
        return ans.toArray(new int[ans.size()][]);
    }


    /*2000. Reverse Prefix of Word (Easy)
    Given a 0-indexed string word and a character ch, reverse the segment of
    word that starts at index 0 and ends at the index of the first occurrence of
    ch (inclusive). If the character ch does not exist in word, do nothing. For
    example, if word = "abcdefd" and ch = "d", then you should reverse the
    segment that starts at 0 and ends at 3 (inclusive). The resulting string
    will be "dcbaefd". Return the resulting string.

    Example 1:
    Input: word = "abcdefd", ch = "d"
    Output: "dcbaefd"
    Explanation: The first occurrence of "d" is at index 3. Reverse the part of
                 word from 0 to 3 (inclusive), the resulting string is "dcbaefd".

    Example 2:
    Input: word = "xyxzxe", ch = "z"
    Output: "zxyxxe"
    Explanation: The first and only occurrence of "z" is at index 3. Reverse the
                 part of word from 0 to 3 (inclusive), the resulting string is
                 "zxyxxe".

    Example 3:
    Input: word = "abcd", ch = "z"
    Output: "abcd"
    Explanation: "z" does not exist in word. You should not do any reverse
                 operation, the resulting string is "abcd".

    Constraints:
    * 1 <= word.length <= 250
    * word consists of lowercase English letters.
    * ch is a lowercase English letter.*/

    public String reversePrefix(String word, char ch) {
        int k = word.indexOf(ch);
        return new StringBuilder(word.substring(0, k+1)).reverse().toString() + word.substring(k+1);
    }


    /*2005. Subtree Removal Game with Fibonacci Tree (Hard)
    A Fibonacci tree is a binary tree created using the order function order(n):
    * order(0) is the empty tree.
    * order(1) is a binary tree with only one node.
    * order(n) is a binary tree that consists of a root node with the left
      subtree as order(n - 2) and the right subtree as order(n - 1).
    Alice and Bob are playing a game with a Fibonacci tree with Alice staring
    first. On each turn, a player selects a node and removes that node and its
    subtree. The player that is forced to delete root loses. Given the integer
    n, return true if Alice wins the game or false if Bob wins, assuming both
    players play optimally. A subtree of a binary tree tree is a tree that
    consists of a node in tree and all of this node's descendants. The tree
    tree could also be considered as a subtree of itself.

    Example 1:
    Input: n = 3
    Output: true
    Explanation: Alice takes the node 1 in the right subtree. Bob takes either
                 the 1 in the left subtree or the 2 in the right subtree. Alice
                 takes whichever node Bob doesn't take. Bob is forced to take
                 the root node 3, so Bob will lose. Return true because Alice
                 wins.

    Example 2:
    Input: n = 1
    Output: false
    Explanation: Alice is forced to take the root node 1, so Alice will lose.
                 Return false because Alice loses.

    Example 3:
    Input: n = 2
    Output: true
    Explanation: Alice takes the node 1. Bob is forced to take the root node 2,
                 so Bob will lose. Return true because Alice wins.

    Constraints: 1 <= n <= 100*/

    public boolean findGameWinner(int n) {
        return (n-1) % 6 > 0;
    }


    /*2028. Find Missing Observations (Medium)
    You have observations of n + m 6-sided dice rolls with each face numbered
    from 1 to 6. n of the observations went missing, and you only have the
    observations of m rolls. Fortunately, you have also calculated the average
    value of the n + m rolls. You are given an integer array rolls of length m
    where rolls[i] is the value of the ith observation. You are also given the
    two integers mean and n. Return an array of length n containing the missing
    observations such that the average value of the n + m rolls is exactly mean.
    If there are multiple valid answers, return any of them. If no such array
    exists, return an empty array. The average value of a set of k numbers is
    the sum of the numbers divided by k. Note that mean is an integer, so the
    sum of the n + m rolls should be divisible by n + m.

    Example 1:
    Input: rolls = [3,2,4,3], mean = 4, n = 2
    Output: [6,6]
    Explanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.

    Example 2:
    Input: rolls = [1,5,6], mean = 3, n = 4
    Output: [2,3,2,2]
    Explanation: The mean of all n + m rolls is
                 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.

    Example 3:
    Input: rolls = [1,2,3,4], mean = 6, n = 4
    Output: []
    Explanation: It is impossible for the mean to be 6 no matter what the 4
                 missing rolls are.

    Constraints:
    * m == rolls.length
    * 1 <= n, m <= 10^5
    * 1 <= rolls[i], mean <= 6*/

    public int[] missingRolls(int[] rolls, int mean, int n) {
        int m = rolls.length;
        int total = mean*(m+n) - Arrays.stream(rolls).sum();
        if (n <= total && total <= 6*n) {
            int q = total/n, r = total%n;
            return IntStream.range(0, n).map(i -> i < r ? q+1 : q).toArray();
        }
        return new int[0];
    }


    /*2037. Minimum Number of Moves to Seat Everyone (Easy)
    There are n seats and n students in a room. You are given an array seats of
    length n, where seats[i] is the position of the ith seat. You are also given
    the array students of length n, where students[j] is the position of the jth
    student. You may perform the following move any number of times:
    * Increase or decrease the position of the ith student by 1 (i.e., moving
      the ith student from position x to x + 1 or x - 1)
    Return the minimum number of moves required to move each student to a seat
    such that no two students are in the same seat. Note that there may be
    multiple seats or students in the same position at the beginning.

    Example 1:
    Input: seats = [3,1,5], students = [2,7,4]
    Output: 4
    Explanation: The students are moved as follows:
                 - The first student is moved from from position 2 to position 1
                   using 1 move.
                 - The second student is moved from from position 7 to position
                   5 using 2 moves.
                 - The third student is moved from from position 4 to position 3
                   using 1 move.
                 In total, 1 + 2 + 1 = 4 moves were used.

    Example 2:
    Input: seats = [4,1,5,9], students = [1,3,2,6]
    Output: 7
    Explanation: The students are moved as follows:
                 - The first student is not moved.
                 - The second student is moved from from position 3 to position
                   4 using 1 move.
                 - The third student is moved from from position 2 to position 5
                   using 3 moves.
                 - The fourth student is moved from from position 6 to position
                   9 using 3 moves.
                 In total, 0 + 1 + 3 + 3 = 7 moves were used.

    Example 3:
    Input: seats = [2,2,6,6], students = [1,3,2,6]
    Output: 4
    Explanation: Note that there are two seats at position 2 and two seats at
                 position 6. The students are moved as follows:
                 - The first student is moved from from position 1 to position 2
                   using 1 move.
                 - The second student is moved from from position 3 to position
                   6 using 3 moves.
                 - The third student is not moved.
                 - The fourth student is not moved.
                 In total, 1 + 3 + 0 + 0 = 4 moves were used.

    Constraints:
    * n == seats.length == students.length
    * 1 <= n <= 100
    * 1 <= seats[i], students[j] <= 100*/

    public int minMovesToSeat(int[] seats, int[] students) {
        Arrays.sort(seats);
        Arrays.sort(students);
        int ans = 0;
        for (int i = 0; i < seats.length; ++i)
            ans += Math.abs(seats[i] - students[i]);
        return ans;
    }


    /*2046. Sort Linked List Already Sorted Using Absolute Values (Medium)
    Given the head of a singly linked list that is sorted in non-decreasing
    order using the absolute values of its nodes, return the list sorted in
    non-decreasing order using the actual values of its nodes.

    Example 1:
    Input: head = [0,2,-5,5,10,-10]
    Output: [-10,-5,0,2,5,10]
    Explanation: The list sorted in non-descending order using the absolute
                 values of the nodes is [0,2,-5,5,10,-10]. The list sorted in
                 non-descending order using the actual values is
                 [-10,-5,0,2,5,10].

    Example 2:
    Input: head = [0,1,2]
    Output: [0,1,2]
    Explanation: The linked list is already sorted in non-decreasing order.

    Example 3:
    Input: head = [1]
    Output: [1]
    Explanation: The linked list is already sorted in non-decreasing order.

    Constraints:
    * The number of nodes in the list is the range [1, 10^5].
    * -5000 <= Node.val <= 5000
    * head is sorted in non-decreasing order using the absolute value of its
      nodes.

    Follow up: Can you think of a solution with O(n) time complexity?*/

    public ListNode sortLinkedList(ListNode head) {
        ListNode prev = head, node = head.next;
        while (node != null)
            if (node.val < 0) {
                prev.next = node.next;
                node.next = head;
                head = node;
                node = prev.next;
            } else {
                prev = node;
                node = node.next;
            }
        return head;
    }


    /*2052. Minimum Cost to Separate Sentence Into Rows (Medium)
    You are given a string sentence containing words separated by spaces, and
    an integer k. Your task is to separate sentence into rows where the number
    of characters in each row is at most k. You may assume that sentence does
    not begin or end with a space, and the words in sentence are separated by a
    single space. You can split sentence into rows by inserting line breaks
    between words in sentence. A word cannot be split between two rows. Each
    word must be used exactly once, and the word order cannot be rearranged.
    Adjacent words in a row should be separated by a single space, and rows
    should not begin or end with spaces. The cost of a row with length n is
    (k - n)2, and the total cost is the sum of the costs for all rows except
    the last one.
    * For example if sentence = "i love leetcode" and k = 12:
      + Separating sentence into "i", "love", and "leetcode" has a cost of
        (12 - 1)2 + (12 - 4)2 = 185.
      + Separating sentence into "i love", and "leetcode" has a cost of
        (12 - 6)2 = 36.
      + Separating sentence into "i", and "love leetcode" is not possible
        because the length of "love leetcode" is greater than k.
    Return the minimum possible total cost of separating sentence into rows.

    Example 1:
    Input: sentence = "i love leetcode", k = 12
    Output: 36
    Explanation: Separating sentence into "i", "love", and "leetcode" has a
                 cost of (12 - 1)^2 + (12 - 4)^2 = 185. Separating sentence
                 into "i love", and "leetcode" has a cost of (12 - 6)^2 = 36.
                 Separating sentence into "i", "love leetcode" is not possible
                 because "love leetcode" has length 13. 36 is the minimum
                 possible total cost so return it.

    Example 2:
    Input: sentence = "apples and bananas taste great", k = 7
    Output: 21
    Explanation: Separating sentence into "apples", "and", "bananas", "taste",
                 and "great" has a cost of
                 (7 - 6)^2 + (7 - 3)^2 + (7 - 7)^2 + (7 - 5)^2 = 21. 21 is the
                 minimum possible total cost so return it.

    Example 3:
    Input: sentence = "a", k = 5
    Output: 0
    Explanation: The cost of the last row is not included in the total cost,
                 and since there is only one row, return 0.

    Constraints:
    * 1 <= sentence.length <= 5000
    * 1 <= k <= 5000
    * The length of each word in sentence is at most k.
    * sentence consists of only lowercase English letters and spaces.
    * sentence does not begin or end with a space.
    * Words in sentence are separated by a single space.*/

    public int minimumCost(String sentence, int k) {
        if (sentence.length() <= k) return 0;
        String[] words = sentence.split(" ");
        int n = words.length;
        int[] dp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[n-1] = 0;
        for (int i = n-2; i >= 0; --i) {
            int prefix = -1;
            for (int j = i; j < n; ++j) {
                prefix += 1 + words[j].length();
                if (prefix <= k) dp[i] = j == n-1 ? 0 : Math.min(dp[i], (prefix-k)*(prefix-k) + dp[j+1]);
                else break;
            }
        }
        return dp[0];
    }


    /*2053. Kth Distinct String in an Array (Easy)
    A distinct string is a string that is present only once in an array. Given
    an array of strings arr, and an integer k, return the kth distinct string
    present in arr. If there are fewer than k distinct strings, return an empty
    string "". Note that the strings are considered in the order in which they
    appear in the array.

    Example 1:
    Input: arr = ["d","b","c","b","c","a"], k = 2
    Output: "a"
    Explanation: The only distinct strings in arr are "d" and "a".
                 "d" appears 1st, so it is the 1st distinct string.
                 "a" appears 2nd, so it is the 2nd distinct string.
                 Since k == 2, "a" is returned.

    Example 2:
    Input: arr = ["aaa","aa","a"], k = 1
    Output: "aaa"
    Explanation: All strings in arr are distinct, so the 1st string "aaa" is
                 returned.

    Example 3:
    Input: arr = ["a","b","a"], k = 3
    Output: ""
    Explanation: The only distinct string is "b". Since there are fewer than 3
                 distinct strings, we return an empty string "".

    Constraints:
    * 1 <= k <= arr.length <= 1000
    * 1 <= arr[i].length <= 5
    * arr[i] consists of lowercase English letters.*/

    public String kthDistinct(String[] arr, int k) {
        Map<String, Integer> freq = new HashMap();
        for (var s : arr)
            freq.merge(s, 1, Integer::sum);
        for (var s : arr)
            if (freq.get(s) == 1 && --k == 0)
                return s;
        return "";
    }


    /*2061. Number of Spaces Cleaning Robot Cleaned (Medium)
    A room is represented by a 0-indexed 2D binary matrix room where a 0
    represents an empty space and a 1 represents a space with an object. The
    top left corner of the room will be empty in all test cases. A cleaning
    robot starts at the top left corner of the room and is facing right. The
    robot will continue heading straight until it reaches the edge of the room
    or it hits an object, after which it will turn 90 degrees clockwise and
    repeat this process. The starting space and all spaces that the robot
    visits are cleaned by it. Return the number of clean spaces in the room if
    the robot runs indefinetely.

    Example 1:
    Input: room = [[0,0,0],[1,1,0],[0,0,0]]
    Output: 7
    Explanation: The robot cleans the spaces at (0, 0), (0, 1), and (0, 2). The
                 robot is at the edge of the room, so it turns 90 degrees
                 clockwise and now faces down. The robot cleans the spaces at
                 (1, 2), and (2, 2). The robot is at the edge of the room, so
                 it turns 90 degrees clockwise and now faces left. The robot
                 cleans the spaces at (2, 1), and (2, 0). The robot has cleaned
                 all 7 empty spaces, so return 7.

    Example 2:
    Input: room = [[0,1,0],[1,0,0],[0,0,0]]
    Output: 1
    Explanation: The robot cleans the space at (0, 0). The robot hits an object,
                 so it turns 90 degrees clockwise and now faces down. The robot
                 hits an object, so it turns 90 degrees clockwise and now faces
                 left. The robot is at the edge of the room, so it turns 90
                 degrees clockwise and now faces up. The robot is at the edge
                 of the room, so it turns 90 degrees clockwise and now faces
                 right. The robot is back at its starting position. The robot
                 has cleaned 1 space, so return 1.

    Constraints:
    * m == room.length
    * n == room[r].length
    * 1 <= m, n <= 300
    * room[r][c] is either 0 or 1.
    * room[0][0] == 0*/

    public int numberOfCleanRooms(int[][] room) {
        int m = room.length, n = room[0].length, ans = 0;
        int[] dir = new int[]{0, 1, 0, -1, 0};
        int[][] seen = new int[m][n];
        for (int i = 0, j = 0, k = 0; (seen[i][j] & 1<<k) == 0; ) {
            if (room[i][j] == 0) {
                ++ans;
                room[i][j] = -1;
            }
            seen[i][j] |= 1<<k;
            int ii = i + dir[k], jj = j + dir[k+1];
            if (0 <= ii && ii < m && 0 <= jj && jj < n && room[ii][jj] != 1) { i = ii; j = jj; }
            else k = (k+1) % 4;
        }
        return ans;
    }


    /*2067. Number of Equal Count Substrings (Medium)
    You are given a 0-indexed string s consisting of only lowercase English
    letters, and an integer count. A substring of s is said to be an equal
    count substring if, for each unique letter in the substring, it appears
    exactly count times in the substring. Return the number of equal count
    substrings in s. A substring is a contiguous non-empty sequence of
    characters within a string.

    Example 1:
    Input: s = "aaabcbbcc", count = 3
    Output: 3
    Explanation: The substring that starts at index 0 and ends at index 2 is
                 "aaa". The letter 'a' in the substring ap`pears exactly 3
                 times. The substring that starts at index 3 and ends at index
                 8 is "bcbbcc". The letters 'b' and 'c' in the substring appear
                 exactly 3 times. The substring that starts at index 0 and ends
                 at index 8 is "aaabcbbcc". The letters 'a', 'b', and 'c' in
                 the substring appear exactly 3 times.

    Example 2:
    Input: s = "abcd", count = 2
    Output: 0
    Explanation: The number of times each letter appears in s is less than
                 count. Therefore, no substrings in s are equal count
                 substrings, so return 0.

    Example 3:
    Input: s = "a", count = 5
    Output: 0
    Explanation: The number of times each letter appears in s is less than
                 count. Therefore, no substrings in s are equal count
                 substrings, so return 0

    Constraints:
    * 1 <= s.length <= 3 * 10^4
    * 1 <= count <= 3 * 10^4
    * s consists only of lowercase English letters.*/

    public int equalCountSubstrings(String s, int count) {
        int ans = 0;
        for (int k = 1; k <= 26; ++k) {
            int[] freq = new int[26];
            int uniq = 0;
            for (int i = 0; i < s.length(); ++i) {
                if(++freq[s.charAt(i)-'a'] == count) ++uniq;
                if (i >= k*count && freq[s.charAt(i-k*count)-'a']-- == count) --uniq;
                if (uniq == k) ++ans;
            }
        }
        return ans;
    }


    /*2077. Paths in Maze That Lead to Same Room (Medium)
    A maze consists of n rooms numbered from 1 to n, and some rooms are
    connected by corridors. You are given a 2D integer array corridors where
    corridors[i] = [room1i, room2i] indicates that there is a corridor
    connecting room1i and room2i, allowing a person in the maze to go from
    room1i to room2i and vice versa. The designer of the maze wants to know
    how confusing the maze is. The confusion score of the maze is the number
    of different cycles of length 3.
    * For example, 1 → 2 → 3 → 1 is a cycle of length 3, but 1 → 2 → 3 → 4 and
      1 → 2 → 3 → 2 → 1 are not.
    Two cycles are considered to be different if one or more of the rooms
    visited in the first cycle is not in the second cycle. Return the confusion
    score of the maze.

    Example 1:
    Input: n = 5, corridors = [[1,2],[5,2],[4,1],[2,4],[3,1],[3,4]]
    Output: 2
    Explanation: One cycle of length 3 is 4 → 1 → 3 → 4, denoted in red. Note
                 that this is the same cycle as 3 → 4 → 1 → 3 or 1 → 3 → 4 → 1
                 because the rooms are the same. Another cycle of length 3 is
                 1 → 2 → 4 → 1, denoted in blue. Thus, there are two different
                 cycles of length 3.

    Example 2:
    Input: n = 4, corridors = [[1,2],[3,4]]
    Output: 0
    Explanation: There are no cycles of length 3.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= corridors.length <= 5 * 10^4
    * corridors[i].length == 2
    * 1 <= room1i, room2i <= n
    * room1i != room2i
    * There are no duplicate corridors.*/

    public int numberOfPaths(int n, int[][] corridors) {
        HashSet<Integer>[] graph = new HashSet[n];
        for (int i = 0; i < n; ++i) graph[i] = new HashSet();
        for (int[] c : corridors) {
            graph[c[0]-1].add(c[1]-1);
            graph[c[1]-1].add(c[0]-1);
        }
        int ans = 0;
        for (int[] c : corridors)
            for (int u : graph[c[0]-1])
                if (graph[c[1]-1].contains(u)) ++ans;
        return ans/3;
    }


    /*2083. Substrings That Begin and End With the Same Letter (Medium)
    You are given a 0-indexed string s consisting of only lowercase English
    letters. Return the number of substrings in s that begin and end with the
    same character. A substring is a contiguous non-empty sequence of
    characters within a string.

    Example 1:
    Input: s = "abcba"
    Output: 7
    Explanation: The substrings of length 1 that start and end with the same
                 letter are: "a", "b", "c", "b", and "a". The substring of
                 length 3 that starts and ends with the same letter is: "bcb".
                 The substring of length 5 that starts and ends with the same
                 letter is: "abcba".

    Example 2:
    Input: s = "abacad"
    Output: 9
    Explanation: The substrings of length 1 that start and end with the same
                 letter are: "a", "b", "a", "c", "a", and "d". The substrings
                 of length 3 that start and end with the same letter are: "aba"
                 and "aca". The substring of length 5 that starts and ends with
                 the same letter is: "abaca".

    Example 3:
    Input: s = "a"
    Output: 1
    Explanation: The substring of length 1 that starts and ends with the same
                 letter is: "a".

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters.*/

    public long numberOfSubstrings(String s) {
        long ans = 0;
        int[] freq = new int[26];
        for (char ch : s.toCharArray())
            ans += ++freq[ch - 'a'];
        return ans;
    }


    /*2098. Subsequence of Size K With the Largest Even Sum (Medium)
    You are given an integer array nums and an integer k. Find the largest even
    sum of any subsequence of nums that has a length of k. Return this sum, or
    -1 if such a sum does not exist. A subsequence is an array that can be
    derived from another array by deleting some or no elements without changing
    the order of the remaining elements.

    Example 1:
    Input: nums = [4,1,5,3,1], k = 3
    Output: 12
    Explanation: The subsequence with the largest possible even sum is [4,5,3].
                 It has a sum of 4 + 5 + 3 = 12.

    Example 2:
    Input: nums = [4,6,2], k = 3
    Output: 12
    Explanation: The subsequence with the largest possible even sum is [4,6,2].
                 It has a sum of 4 + 6 + 2 = 12.

    Example 3:
    Input: nums = [1,3,5], k = 1
    Output: -1
    Explanation: No subsequence of nums with length 1 has an even sum.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5
    * 1 <= k <= nums.length*/

    public long largestEvenSum(int[] nums, int k) {
        long ans = -1, prefix = 0;
        int[] least = new int[]{Integer.MAX_VALUE, Integer.MAX_VALUE};
        Arrays.sort(nums);
        for (int i = 0, n = nums.length; i < n/2; ++i) {
            nums[i] ^= nums[n-1-i];
            nums[n-1-i] ^= nums[i];
            nums[i] ^= nums[n-1-i];
        }
        for (int i = 0; i < nums.length; ++i)
            if (i < k) {
                prefix += nums[i];
                least[nums[i]&1] = Math.min(least[nums[i]&1], nums[i]);
                if (i == k-1 && (prefix&1) == 0) return prefix;
            } else ans = Math.max(ans, prefix - least[1-(nums[i]&1)] + nums[i]);
        return ans;
    }


    /*2107. Number of Unique Flavors After Sharing K Candies (Medium)
    You are given a 0-indexed integer array candies, where candies[i]
    represents the flavor of the ith candy. Your mom wants you to share these
    candies with your little sister by giving her k consecutive candies, but
    you want to keep as many flavors of candies as possible. Return the maximum
    number of unique flavors of candy you can keep after sharing with your
    sister.

    Example 1:
    Input: candies = [1,2,2,3,4,3], k = 3
    Output: 3
    Explanation: Give the candies in the range [1, 3] (inclusive) with flavors
                 [2,2,3]. You can eat candies with flavors [1,4,3]. There are 3
                 unique flavors, so return 3.

    Example 2:
    Input: candies = [2,2,2,2,3,3], k = 2
    Output: 2
    Explanation: Give the candies in the range [3, 4] (inclusive) with flavors
                 [2,3]. You can eat candies with flavors [2,2,2,3]. There are 2
                 unique flavors, so return 2. Note that you can also share the
                 candies with flavors [2,2] and eat the candies with flavors
                 [2,2,3,3].

    Example 3:
    Input: candies = [2,4,5], k = 0
    Output: 3
    Explanation: You do not have to give any candies. You can eat the candies
                 with flavors [2,4,5]. There are 3 unique flavors, so return 3.

    Constraints:
    * 1 <= candies.length <= 10^5
    * 1 <= candies[i] <= 10^5
    * 0 <= k <= candies.length*/

    public int shareCandies(int[] candies, int k) {
        int ans = 0;
        HashMap<Integer, Integer> freq = new HashMap();
        for (int x : candies) freq.merge(x, 1, Integer::sum);
        for (int i = 0; i < candies.length; ++i) {
            freq.merge(candies[i], -1, Integer::sum);
            if (freq.get(candies[i]) == 0) freq.remove(candies[i]);
            if (i >= k) freq.merge(candies[i-k], 1, Integer::sum);
            if (i >= k-1) ans = Math.max(ans, freq.size());
        }
        return ans;
    }


    /*2108. Find First Palindromic String in the Array (Easy)
    Given an array of strings words, return the first palindromic string in the
    array. If there is no such string, return an empty string "". A string is
    palindromic if it reads the same forward and backward.

    Example 1:
    Input: words = ["abc","car","ada","racecar","cool"]
    Output: "ada"
    Explanation: The first string that is palindromic is "ada". Note that
                 "racecar" is also palindromic, but it is not the first.

    Example 2:
    Input: words = ["notapalindrome","racecar"]
    Output: "racecar"
    Explanation: The first and only string that is palindromic is "racecar".

    Example 3:
    Input: words = ["def","ghi"]
    Output: ""
    Explanation: There are no palindromic strings, so the empty string is
                 returned.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consists only of lowercase English letters.*/

    public String firstPalindrome(String[] words) {
        for (var w : words) {
            String ww = new StringBuilder(w).reverse().toString();
            if (w.equals(ww)) return w;
        }
        return "";
    }


    /*2113. Elements in Array After Removing and Replacing Elements (Medium)
    You are given a 0-indexed integer array nums. Initially on minute 0, the
    array is unchanged. Every minute, the leftmost element in nums is removed
    until no elements remain. Then, every minute, one element is appended to
    the end of nums, in the order they were removed in, until the original
    array is restored. This process repeats indefinitely.
    * For example, the array [0,1,2] would change as follows: [0,1,2] → [1,2]
      → [2] → [] → [0] → [0,1] → [0,1,2] → [1,2] → [2] → [] → [0] → [0,1]
      → [0,1,2] → ...
    You are also given a 2D integer array queries of size n where
    queries[j] = [timej, indexj]. The answer to the jth query is:
    * nums[indexj] if indexj < nums.length at minute timej
    * -1 if indexj >= nums.length at minute timej
    Return an integer array ans of size n where ans[j] is the answer to the jth
    query.

    Example 1:
    Input: nums = [0,1,2], queries = [[0,2],[2,0],[3,2],[5,0]]
    Output: [2,2,-1,0]
    Explanation: Minute 0: [0,1,2] - All elements are in the nums.
                 Minute 1: [1,2]   - The leftmost element, 0, is removed.
                 Minute 2: [2]     - The leftmost element, 1, is removed.
                 Minute 3: []      - The leftmost element, 2, is removed.
                 Minute 4: [0]     - 0 is added to the end of nums.
                 Minute 5: [0,1]   - 1 is added to the end of nums.
                 At minute 0, nums[2] is 2.
                 At minute 2, nums[0] is 2.
                 At minute 3, nums[2] does not exist.
                 At minute 5, nums[0] is 0.

    Example 2:
    Input: nums = [2], queries = [[0,0],[1,0],[2,0],[3,0]]
    Output: [2,-1,2,-1]
    Explanation: Minute 0: [2] - All elements are in the nums.
                 Minute 1: []  - The leftmost element, 2, is removed.
                 Minute 2: [2] - 2 is added to the end of nums.
                 Minute 3: []  - The leftmost element, 2, is removed.
                 At minute 0, nums[0] is 2.
                 At minute 1, nums[0] does not exist.
                 At minute 2, nums[0] is 2.
                 At minute 3, nums[0] does not exist.

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 100
    * n == queries.length
    * 1 <= n <= 10^5
    * queries[j].length == 2
    * 0 <= timej <= 10^5
    * 0 <= indexj < nums.length*/

    public int[] elementInNums(int[] nums, int[][] queries) {
        int[] ans = new int[queries.length];
        for (int i = 0; i < queries.length; ++i) {
            int t = queries[i][0], k = queries[i][1];
            t %= 2*nums.length;
            if (t < nums.length-k) ans[i] = nums[k+t];
            else if (t <= nums.length+k) ans[i] = -1;
            else ans[i] = nums[k];
        }
        return ans;
    }


    /*2123. Minimum Operations to Remove Adjacent Ones in Matrix (Hard)
    You are given a 0-indexed binary matrix grid. In one operation, you can
    flip any 1 in grid to be 0. A binary matrix is well-isolated if there is no
    1 in the matrix that is 4-directionally connected (i.e., horizontal and
    vertical) to another 1. Return the minimum number of operations to make
    grid well-isolated.

    Example 1:
    Input: grid = [[1,1,0],[0,1,1],[1,1,1]]
    Output: 3
    Explanation: Use 3 operations to change grid[0][1], grid[1][2], and
                 grid[2][1] to 0. After, no more 1's are 4-directionally
                 connected and grid is well-isolated.

    Example 2:
    Input: grid = [[0,0,0],[0,0,0],[0,0,0]]
    Output: 0
    Explanation: There are no 1's in grid and it is well-isolated. No
                 operations were done so return 0.

    Example 3:
    Input: grid = [[0,1],[1,0]]
    Output: 0
    Explanation: None of the 1's are 4-directionally connected and grid is
                 well-isolated. No operations were done so return 0.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 300
    * grid[i][j] is either 0 or 1.*/

    private boolean dfs(int i, int j, int x, int[][] grid, int[][] match, int[][] seen) {
        /* Return true if an augmenting path is found via Hungarian algo. */
        int m = grid.length, n = grid[0].length;
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        for (int k = 0; k < 4; ++k) {
            int ii = i + dir[k], jj = j + dir[k+1];
            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] == 1 && seen[ii][jj] != x) {
                seen[ii][jj] = x;
                if (match[ii][jj] == -1 || dfs(match[ii][jj]/n, match[ii][jj]%n, x, grid, match, seen)) {
                    match[ii][jj] = i*n + j;
                    match[i][j] = ii*n + jj;
                    return true;
                }
            }
        }
        return false;
    }

    public int minimumOperations(int[][] grid) {
        int m = grid.length, n = grid[0].length, ans = 0;
        int[][] match = new int[m][n], seen = new int[m][n];
        for (int i = 0; i < m; ++i) {
            Arrays.fill(match[i], -1);
            Arrays.fill(seen[i], -1);
        }
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == 1 && (i+j)%2 == 1 && match[i][j] == -1 && dfs(i, j, seen[i][j] = i*n+j, grid, match, seen))
                    ++ans;
        }
        return ans;
    }


    /*2134. Minimum Swaps to Group All 1's Together II (Medium)
    A swap is defined as taking two distinct positions in an array and swapping
    the values in them. A circular array is defined as an array where we
    consider the first element and the last element to be adjacent. Given a
    binary circular array nums, return the minimum number of swaps required to
    group all 1's present in the array together at any location.

    Example 1:
    Input: nums = [0,1,0,1,1,0,0]
    Output: 1
    Explanation: Here are a few of the ways to group all the 1's together:
                 - [0,0,1,1,1,0,0] using 1 swap.
                 - [0,1,1,1,0,0,0] using 1 swap.
                 - [1,1,0,0,0,0,1] using 2 swaps (using the circular property of
                   the array).
                 There is no way to group all 1's together with 0 swaps. Thus,
                 the minimum number of swaps required is 1.

    Example 2:
    Input: nums = [0,1,1,1,0,0,1,1,0]
    Output: 2
    Explanation: Here are a few of the ways to group all the 1's together:
                 - [1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular
                   property of the array).
                 - [1,1,1,1,1,0,0,0,0] using 2 swaps.
                 There is no way to group all 1's together with 0 or 1 swaps.
                 Thus, the minimum number of swaps required is 2.

    Example 3:
    Input: nums = [1,1,0,0,1]
    Output: 0
    Explanation: All the 1's are already grouped together due to the circular
                 property of the array. Thus, the minimum number of swaps
                 required is 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1.*/

    public int minSwaps(int[] nums) {
        int ans = Integer.MAX_VALUE, ones = Arrays.stream(nums).reduce(0, (s, x) -> s + x);
        for (int i = 0, n = nums.length, prefix = 0; i < n+ones; ++i) {
            prefix += nums[i % n];
            if (i >= ones) prefix -= nums[(i-ones) % n];
            ans = Math.min(ans, ones - prefix);
        }
        return ans;
    }


    /*2143. Choose Numbers From Two Arrays in Range (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2 of length n. A
    range [l, r] (inclusive) where 0 <= l <= r < n is balanced if:
    * For every i in the range [l, r], you pick either nums1[i] or nums2[i].
    * The sum of the numbers you pick from nums1 equals to the sum of the
      numbers you pick from nums2 (the sum is considered to be 0 if you pick no
      numbers from an array).
    Two balanced ranges from [l1, r1] and [l2, r2] are considered to be
    different if at least one of the following is true:
    * l1 != l2
    * r1 != r2
    * nums1[i] is picked in the first range, and nums2[i] is picked in the
      second range or vice versa for at least one i.
    Return the number of different ranges that are balanced. Since the answer
    may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums1 = [1,2,5], nums2 = [2,6,3]
    Output: 3
    Explanation: The balanced ranges are:
                 - [0, 1] where we choose nums2[0], and nums1[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 2 = 2.
                 - [0, 2] where we choose nums1[0], nums2[1], and nums1[2].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 1 + 5 = 6.
                 - [0, 2] where we choose nums1[0], nums1[1], and nums2[2].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 1 + 2 = 3.
                 Note that the second and third balanced ranges are different.
                 In the second balanced range, we choose nums2[1] and in the
                 third balanced range, we choose nums1[1].

    Example 2:
    Input: nums1 = [0,1], nums2 = [1,0]
    Output: 4
    Explanation: The balanced ranges are:
                 - [0, 0] where we choose nums1[0].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 0 = 0.
                 - [1, 1] where we choose nums2[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 0 = 0.
                 - [0, 1] where we choose nums1[0] and nums2[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 0 = 0.
                 - [0, 1] where we choose nums2[0] and nums1[1].
                   The sum of the numbers chosen from nums1 equals the sum of
                   the numbers chosen from nums2: 1 = 1.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 100
    * 0 <= nums1[i], nums2[i] <= 100*/

    public int countSubranges(int[] nums1, int[] nums2) {
        final int mod = 1_000_000_007;
        long ans = 0;
        Map<Integer, Long> freq = new HashMap();
        for (int i = 0; i < nums1.length; ++i) {
            Map<Integer, Long> ff = new HashMap();
            ff.merge(nums1[i], 1l, Long::sum);
            ff.merge(-nums2[i], 1l, Long::sum);
            for (var elem : freq.entrySet()) {
                int k = elem.getKey();
                long v = elem.getValue();
                ff.put(k+nums1[i], (ff.getOrDefault(k+nums1[i], 0l) + v) % mod);
                ff.put(k-nums2[i], (ff.getOrDefault(k-nums2[i], 0l) + v) % mod);
            }
            freq = ff;
            ans = (ans + freq.getOrDefault(0, 0l)) % mod;
        }
        return (int) ans;
    }


    /*2149. Rearrange Array Elements by Sign (Medium)
    You are given a 0-indexed integer array nums of even length consisting of an
    equal number of positive and negative integers. You should rearrange the
    elements of nums such that the modified array follows the given conditions:
    * Every consecutive pair of integers have opposite signs.
    * For all integers with the same sign, the order in which they were present
      in nums is preserved.
    * The rearranged array begins with a positive integer.
    Return the modified array after rearranging the elements to satisfy the
    aforementioned conditions.

    Example 1:
    Input: nums = [3,1,-2,-5,2,-4]
    Output: [3,-2,1,-5,2,-4]
    Explanation: The positive integers in nums are [3,1,2]. The negative
                 integers are [-2,-5,-4]. The only possible way to rearrange
                 them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
                 Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4],
                 [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one
                 or more conditions.

    Example 2:
    Input: nums = [-1,1]
    Output: [1,-1]
    Explanation: 1 is the only positive integer and -1 the only negative integer
                 in nums. So nums is rearranged to [1,-1].

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * nums.length is even
    * 1 <= |nums[i]| <= 10^5
    * nums consists of equal number of positive and negative integers.*/

    public int[] rearrangeArray(int[] nums) {
        int[] ans = new int[nums.length];
        int p = 0, n = 1;
        for (var x : nums)
            if (x > 0) {
                ans[p] = x;
                p += 2;
            } else {
                ans[n] = x;
                n += 2;
            }
        return ans;
    }


    /*2152. Minimum Number of Lines to Cover Points (Medium)
    You are given an array points where points[i] = [xi, yi] represents a point
    on an X-Y plane. Straight lines are going to be added to the X-Y plane,
    such that every point is covered by at least one line. Return the minimum
    number of straight lines needed to cover all the points.

    Example 1:
    Input: points = [[0,1],[2,3],[4,5],[4,3]]
    Output: 2
    Explanation: The minimum number of straight lines needed is two. One
                 possible solution is to add:
                 - One line connecting the point at (0, 1) to the point at
                   (4, 5).
                 - Another line connecting the point at (2, 3) to the point at
                   (4, 3).

    Example 2:
    Input: points = [[0,2],[-2,-2],[1,4]]
    Output: 1
    Explanation: The minimum number of straight lines needed is one. The only
                 solution is to add:
                 - One line connecting the point at (-2, -2) to the point at
                   (1, 4).

    Constraints:
    * 1 <= points.length <= 10
    * points[i].length == 2
    * -100 <= xi, yi <= 100
    * All the points are unique.*/

    public int minimumLines(int[][] points) {
        int n = points.length;
        int[][] mask = new int[n][n];
        for (int i = 0; i < n; ++i)
            for (int j = i+1; j < n; ++j) {
                mask[i][j] ^= (1<<i) ^ (1<<j);
                for (int k = j+1; k < n; ++k)
                    if ((points[i][0]-points[j][0])*(points[i][1]-points[k][1]) == (points[i][1]-points[j][1])*(points[i][0]-points[k][0])) mask[i][j] ^= 1<<k;
            }
        int[] dp = new int[1<<n];
        Arrays.fill(dp, n/2+1);
        dp[0] = 0;
        for (int m = 1; m < (1<<n); ++m) {
            int bits = 0;
            for (int mm = m; mm > 0; ++bits, mm &= mm-1);
            if (bits <= 2) dp[m] = 1;
            else {
                int i = 0;
                for (; i < n; ++i)
                    if ((m & (1<<i)) > 0) break;
                for (int j = i+1; j < n; ++j)
                    if ((m & (1<<j)) > 0) dp[m] = Math.min(dp[m], 1+dp[m^mask[i][j]]);
            }
        }
        return dp[(1<<n)-1];
    }


    /*2158. Amount of New Area Painted Each Day (Hard)
    There is a long and thin painting that can be represented by a number line.
    You are given a 0-indexed 2D integer array paint of length n, where
    paint[i] = [starti, endi]. This means that on the ith day you need to paint
    the area between starti and endi. Painting the same area multiple times
    will create an uneven painting so you only want to paint each area of the
    painting at most once. Return an integer array worklog of length n, where
    worklog[i] is the amount of new area that you painted on the ith day.

    Example 1:
    Input: paint = [[1,4],[4,7],[5,8]]
    Output: [3,3,1]
    Explanation: On day 0, paint everything between 1 and 4. The amount of new
                 area painted on day 0 is 4 - 1 = 3. On day 1, paint everything
                 between 4 and 7. The amount of new area painted on day 1 is
                 7 - 4 = 3. On day 2, paint everything between 7 and 8.
                 Everything between 5 and 7 was already painted on day 1. The
                 amount of new area painted on day 2 is 8 - 7 = 1.

    Example 2:
    Input: paint = [[1,4],[5,8],[4,7]]
    Output: [3,3,1]
    Explanation: On day 0, paint everything between 1 and 4. The amount of new
                 area painted on day 0 is 4 - 1 = 3. On day 1, paint everything
                 between 5 and 8. The amount of new area painted on day 1 is
                 8 - 5 = 3. On day 2, paint everything between 4 and 5.
                 Everything between 5 and 7 was already painted on day 1. The
                 amount of new area painted on day 2 is 5 - 4 = 1.

    Example 3:
    Input: paint = [[1,5],[2,4]]
    Output: [4,0]
    Explanation: On day 0, paint everything between 1 and 5. The amount of new
                 area painted on day 0 is 5 - 1 = 4. On day 1, paint nothing
                 because everything between 2 and 4 was already painted on day
                 0. The amount of new area painted on day 1 is 0.

    Constraints:
    * 1 <= paint.length <= 10^5
    * paint[i].length == 2
    * 0 <= starti < endi <= 5 * 10^4*/

    public int[] amountPainted(int[][] paint) {
        int n = paint.length;
        int[] ans = new int[n];
        TreeMap<Integer, Integer> tree = new TreeMap();
        for (int i = 0; i < n; ++i) {
            int x = paint[i][0], y = paint[i][1], diff = 0;
            var p = tree.floorEntry(x);
            if (p != null && x < p.getValue()) {
                int xx = p.getKey(), yy = p.getValue();
                x = Math.min(x, xx);
                y = Math.max(y, yy);
                diff -= yy - xx;
                tree.remove(p.getKey());
            }
            p = tree.ceilingEntry(x);
            while (p != null && p.getKey() < y) {
                int xx = p.getKey(), yy = p.getValue();
                y = Math.max(y, yy);
                diff -= yy - xx;
                tree.remove(p.getKey());
                p = tree.ceilingEntry(x);
            }
            ans[i] = y - x + diff;
            tree.put(x, y);
        }
        return ans;
    }


    /*2187. Minimum Time to Complete Trips (Medium)
    You are given an array time where time[i] denotes the time taken by the ith
    bus to complete one trip. Each bus can make multiple trips successively;
    that is, the next trip can start immediately after completing the current
    trip. Also, each bus operates independently; that is, the trips of one bus
    do not influence the trips of any other bus. You are also given an integer
    totalTrips, which denotes the number of trips all buses should make in
    total. Return the minimum time required for all buses to complete at least
    totalTrips trips.

    Example 1:
    Input: time = [1,2,3], totalTrips = 5
    Output: 3
    Explanation: - At time t = 1, the number of trips completed by each bus are
                   [1,0,0]. The total number of trips completed is
                   1 + 0 + 0 = 1.
                 - At time t = 2, the number of trips completed by each bus are
                   [2,1,0]. The total number of trips completed is
                   2 + 1 + 0 = 3.
                 - At time t = 3, the number of trips completed by each bus are
                   [3,1,1]. The total number of trips completed is
                   3 + 1 + 1 = 5.
                 So the minimum time needed for all buses to complete at least
                 5 trips is 3.

    Example 2:
    Input: time = [2], totalTrips = 1
    Output: 2
    Explanation: There is only one bus, and it will complete its first trip at
                 t = 2. So the minimum time needed to complete 1 trip is 2.

    Constraints:
    * 1 <= time.length <= 10^5
    * 1 <= time[i], totalTrips <= 10^7*/

    public long minimumTime(int[] time, int totalTrips) {
        long lo = 0, hi = 100_000_000_000_000l;
        while (lo < hi) {
            long mid = lo + (hi-lo)/2, val = 0;
            for (var x : time) val += mid/x;
            if (val < totalTrips) lo = mid+1;
            else hi = mid;
        }
        return lo;
    }


    /*2189. Number of Ways to Build House of Cards (Medium)
    You are given an integer n representing the number of playing cards you
    have. A house of cards meets the following conditions:
    * A house of cards consists of one or more rows of triangles and horizontal
      cards.
    * Triangles are created by leaning two cards against each other.
    * One card must be placed horizontally between all adjacent triangles in a
      row.
    * Any triangle on a row higher than the first must be placed on a
      horizontal card from the previous row.
    * Each triangle is placed in the leftmost available spot in the row.
    Return the number of distinct house of cards you can build using all n
    cards. Two houses of cards are considered distinct if there exists a row
    where the two houses contain a different number of cards.

    Example 1:
    Input: n = 16
    Output: 2
    Explanation: The two valid houses of cards are shown. The third house of
                 cards in the diagram is not valid because the rightmost
                 triangle on the top row is not placed on top of a horizontal
                 card.

    Example 2:
    Input: n = 2
    Output: 1
    Explanation: The one valid house of cards is shown.

    Example 3:
    Input: n = 4
    Output: 0
    Explanation: The three houses of cards in the diagram are not valid. The
                 first house of cards needs a horizontal card placed between
                 the two triangles. The second house of cards uses 5 cards. The
                 third house of cards uses 2 cards.

    Constraints: 1 <= n <= 500*/

    public int houseOfCards(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        for (int x = 2; x <= n; x += 3)
            for (int i = n; i >= x; --i)
                dp[i] += dp[i-x];
        return dp[n];
    }


    /*2196. Create Binary Tree From Descriptions (Medium)
    You are given a 2D integer array descriptions where descriptions[i] =
    [parenti, childi, isLefti] indicates that parenti is the parent of childi in
    a binary tree of unique values. Furthermore,
    * If isLefti == 1, then childi is the left child of parenti.
    * If isLefti == 0, then childi is the right child of parenti.
    Construct the binary tree described by descriptions and return its root. The
    test cases will be generated such that the binary tree is valid.

    Example 1:
    Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]
    Output: [50,20,80,15,17,19]
    Explanation: The root node is the node with value 50 since it has no parent.
                 The resulting binary tree is shown in the diagram.

    Example 2:
    Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]]
    Output: [1,2,null,null,3,4]
    Explanation: The root node is the node with value 1 since it has no parent.
                 The resulting binary tree is shown in the diagram.

    Constraints:
    * 1 <= descriptions.length <= 10^4
    * descriptions[i].length == 3
    * 1 <= parenti, childi <= 10^5
    * 0 <= isLefti <= 1
    * The binary tree described by descriptions is valid.*/

    public TreeNode createBinaryTree(int[][] descriptions) {
        Map<Integer, TreeNode> mp = new HashMap();
        Set<Integer> child = new HashSet();
        for (var d : descriptions) {
            int p = d[0], c = d[1], left = d[2];
            if (!mp.containsKey(p)) mp.put(p, new TreeNode(p));
            if (!mp.containsKey(c)) mp.put(c, new TreeNode(c));
            if (left == 1) mp.get(p).left = mp.get(c);
            else mp.get(p).right = mp.get(c);
            child.add(c);
        }
        for (var d : descriptions)
            if (!child.contains(d[0]))
                return mp.get(d[0]);
        return null;
    }


    /*2198. Number of Single Divisor Triplets (Medium)
    You are given a 0-indexed array of positive integers nums. A triplet of
    three distinct indices (i, j, k) is called a single divisor triplet of nums
    if nums[i] + nums[j] + nums[k] is divisible by exactly one of nums[i],
    nums[j], or nums[k]. Return the number of single divisor triplets of nums.

    Example 1:
    Input: nums = [4,6,7,3,2]
    Output: 12
    Explanation: The triplets (0, 3, 4), (0, 4, 3), (3, 0, 4), (3, 4, 0),
                 (4, 0, 3), and (4, 3, 0) have the values of [4, 3, 2] (or a
                 permutation of [4, 3, 2]). 4 + 3 + 2 = 9 which is only
                 divisible by 3, so all such triplets are single divisor
                 triplets. The triplets (0, 2, 3), (0, 3, 2), (2, 0, 3),
                 (2, 3, 0), (3, 0, 2), and (3, 2, 0) have the values of
                 [4, 7, 3] (or a permutation of [4, 7, 3]). 4 + 7 + 3 = 14
                 which is only divisible by 7, so all such triplets are single
                 divisor triplets. There are 12 single divisor triplets in
                 total.

    Example 2:
    Input: nums = [1,2,2]
    Output: 6
    Explanation: The triplets (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0),
                 (2, 0, 1), and (2, 1, 0) have the values of [1, 2, 2] (or a
                 permutation of [1, 2, 2]). 1 + 2 + 2 = 5 which is only
                 divisible by 1, so all such triplets are single divisor
                 triplets. There are 6 single divisor triplets in total.

    Example 3:
    Input: nums = [1,1,1]
    Output: 0
    Explanation: There are no single divisor triplets. Note that (0, 1, 2) is
                 not a single divisor triplet because
                 nums[0] + nums[1] + nums[2] = 3 and 3 is divisible by nums[0],
                 nums[1], and nums[2].

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 100*/

    public long singleDivisorTriplet(int[] nums) {
        int[] freq = new int[101];
        for (int x : nums) ++freq[x];
        long ans = 0;
        for (int i = 1; i <= 100; ++i)
            for (int j = i; freq[i] > 0 && j <= 100; ++j)
                for (int k = j; freq[j] > 0 && k <= 100; ++k)
                    if (freq[k] > 0) {
                        int total = i + j + k;
                        if ((total%i > 0 ? 1 : 0) + (total%j > 0 ? 1 : 0) + (total%k > 0 ? 1 : 0) == 2)
                            if (i == j) ans += (long) freq[i]*(freq[j]-1)/2*freq[k];
                            else if (j == k) ans += (long) freq[i]*freq[j]*(freq[k]-1)/2;
                            else ans += (long) freq[i]*freq[j]*freq[k];
                    }
        return ans*6;
    }


    /*2204. Distance to a Cycle in Undirected Graph (Hard)
    You are given a positive integer n representing the number of nodes in a
    connected undirected graph containing exactly one cycle. The nodes are
    numbered from 0 to n - 1 (inclusive). You are also given a 2D integer array
    edges, where edges[i] = [node1i, node2i] denotes that there is a
    bidirectional edge connecting node1i and node2i in the graph. The distance
    between two nodes a and b is defined to be the minimum number of edges that
    are needed to go from a to b. Return an integer array answer of size n,
    where answer[i] is the minimum distance between the ith node and any node
    in the cycle.

    Example 1:
    Input: n = 7, edges = [[1,2],[2,4],[4,3],[3,1],[0,1],[5,2],[6,5]]
    Output: [1,0,0,0,0,1,2]
    Explanation: The nodes 1, 2, 3, and 4 form the cycle.
                 The distance from 0 to 1 is 1.
                 The distance from 1 to 1 is 0.
                 The distance from 2 to 2 is 0.
                 The distance from 3 to 3 is 0.
                 The distance from 4 to 4 is 0.
                 The distance from 5 to 2 is 1.
                 The distance from 6 to 2 is 2.

    Example 2:
    Input: n = 9, edges = [[0,1],[1,2],[0,2],[2,6],[6,7],[6,8],[0,3],[3,4],[3,5]]
    Output: [0,0,0,1,2,2,1,2,2]
    Explanation: The nodes 0, 1, and 2 form the cycle.
                 The distance from 0 to 0 is 0.
                 The distance from 1 to 1 is 0.
                 The distance from 2 to 2 is 0.
                 The distance from 3 to 1 is 1.
                 The distance from 4 to 1 is 2.
                 The distance from 5 to 1 is 2.
                 The distance from 6 to 2 is 1.
                 The distance from 7 to 2 is 2.
                 The distance from 8 to 2 is 2.

    Constraints:
    * 3 <= n <= 10^5
    * edges.length == n
    * edges[i].length == 2
    * 0 <= node1i, node2i <= n - 1
    * node1i != node2i
    * The graph is connected.
    * The graph has exactly one cycle.
    * There is at most one edge between any pair of vertices.*/

    public int[] distanceToCycle(int n, int[][] edges) {
        List<Integer>[] graph = new ArrayList[n];
        for (int u = 0; u < n; ++u)
            graph[u] = new ArrayList();
        for (var e : edges) {
            graph[e[0]].add(e[1]);
            graph[e[1]].add(e[0]);
        }
        Stack<Integer> stk = new Stack();
        int[] degree = new int[n];
        for (int u = 0; u < n; ++u) {
            degree[u] = graph[u].size();
            if (degree[u] == 1) stk.push(u);
        }
        while (!stk.isEmpty()) {
            var u = stk.pop();
            for (var v : graph[u])
                if (degree[v] > 1 && --degree[v] == 1) stk.push(v);
        }
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        Queue<Integer> q = new LinkedList();
        for (int u = 0; u < n; ++u)
            if (degree[u] > 1) {
                q.add(u);
                ans[u] = 0;
            }
        for (int val = 1; !q.isEmpty(); ++val)
            for (int sz = q.size(); sz > 0; --sz) {
                var u = q.poll();
                for (var v : graph[u])
                    if (ans[v] == -1) {
                        q.add(v);
                        ans[v] = val;
                    }
            }
        return ans;
    }


    /*2220. Minimum Bit Flips to Convert Number (Easy)
    A bit flip of a number x is choosing a bit in the binary representation of x
    and flipping it from either 0 to 1 or 1 to 0.
    * For example, for x = 7, the binary representation is 111 and we may choose
      any bit (including any leading zeros not shown) and flip it. We can flip
      the first bit from the right to get 110, flip the second bit from the
      right to get 101, flip the fifth bit from the right (a leading zero) to
      get 10111, etc.
    Given two integers start and goal, return the minimum number of bit flips to
    convert start to goal.

    Example 1:
    Input: start = 10, goal = 7
    Output: 3
    Explanation: The binary representation of 10 and 7 are 1010 and 0111
                 respectively. We can convert 10 to 7 in 3 steps:
                 - Flip the first bit from the right: 1010 -> 1011.
                 - Flip the third bit from the right: 1011 -> 1111.
                 - Flip the fourth bit from the right: 1111 -> 0111.
                 It can be shown we cannot convert 10 to 7 in less than 3 steps.
                 Hence, we return 3.

    Example 2:
    Input: start = 3, goal = 4
    Output: 3
    Explanation: The binary representation of 3 and 4 are 011 and 100
                 respectively. We can convert 3 to 4 in 3 steps:
                 - Flip the first bit from the right: 011 -> 010.
                 - Flip the second bit from the right: 010 -> 000.
                 - Flip the third bit from the right: 000 -> 100.
                 It can be shown we cannot convert 3 to 4 in less than 3 steps.
                 Hence, we return 3.

    Constraints: 0 <= start, goal <= 10^9*/

    public int minBitFlips(int start, int goal) {
        return Integer.bitCount(start ^ goal);
    }


    /*2247. Maximum Cost of Trip With K Highways (Hard)
    A series of highways connect n cities numbered from 0 to n - 1. You are
    given a 2D integer array highways where highways[i] = [city1i, city2i, tolli]
    indicates that there is a highway that connects city1i and city2i, allowing
    a car to go from city1i to city2i and vice versa for a cost of tolli. You
    are also given an integer k. You are going on a trip that crosses exactly k
    highways. You may start at any city, but you may only visit each city at
    most once during your trip. Return the maximum cost of your trip. If there
    is no trip that meets the requirements, return -1.

    Example 1:
    Input: n = 5, highways = [[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]], k = 3
    Output: 17
    Explanation: One possible trip is to go from 0 -> 1 -> 4 -> 3. The cost of
                 this trip is 4 + 11 + 2 = 17. Another possible trip is to go
                 from 4 -> 1 -> 2 -> 3. The cost of this trip is
                 11 + 3 + 3 = 17. It can be proven that 17 is the maximum
                 possible cost of any valid trip. Note that the trip
                 4 -> 1 -> 0 -> 1 is not allowed because you visit the city 1
                 twice.

    Example 2:
    Input: n = 4, highways = [[0,1,3],[2,3,2]], k = 2
    Output: -1
    Explanation: There are no valid trips of length 2, so return -1.

    Constraints:
    * 2 <= n <= 15
    * 1 <= highways.length <= 50
    * highways[i].length == 3
    * 0 <= city1i, city2i <= n - 1
    * city1i != city2i
    * 0 <= tolli <= 100
    * 1 <= k <= 50
    * There are no duplicate highways.*/

    public int maximumCost(int n, int[][] highways, int k) {
        List<Pair<Integer, Integer>>[] graph = new ArrayList[n];
        for (int u = 0; u < n; ++u) graph[u] = new ArrayList();
        for (var h : highways) {
            graph[h[0]].add(new Pair(h[1], h[2]));
            graph[h[1]].add(new Pair(h[0], h[2]));
        }
        int[][] dp = new int[n][1<<n];
        for (var row : dp) Arrays.fill(row, Integer.MIN_VALUE);
        for (int m = (1<<n)-1; m >= 0; --m)
            for (int u = 0; u < n; ++u)
                if ((m & 1<<u) > 0) {
                    int cnt = Integer.bitCount(m);
                    if (cnt == k+1) dp[u][m] = 0;
                    else if (cnt < k+1)
                        for (var elem : graph[u]) {
                            int v = elem.getKey(), w = elem.getValue();
                            if ((m & 1<<v) == 0) dp[u][m] = Math.max(dp[u][m], w + dp[v][m ^ 1<<v]);
                        }
                }
        int ans = -1;
        for (int u = 0; u < n; ++u) ans = Math.max(ans, dp[u][1<<u]);
        return ans;
    }


    /*2263. Make Array Non-decreasing or Non-increasing (Hard)
    You are given a 0-indexed integer array nums. In one operation, you can:
    * Choose an index i in the range 0 <= i < nums.length
    * Set nums[i] to nums[i] + 1 or nums[i] - 1
    Return the minimum number of operations to make nums non-decreasing or non-
    increasing.

    Example 1:
    Input: nums = [3,2,4,5,0]
    Output: 4
    Explanation: One possible way to turn nums into non-increasing order is to:
                 - Add 1 to nums[1] once so that it becomes 3.
                 - Subtract 1 from nums[2] once so it becomes 3.
                 - Subtract 1 from nums[3] twice so it becomes 3.
                 After doing the 4 operations, nums becomes [3,3,3,3,0] which
                 is in non-increasing order. Note that it is also possible to
                 turn nums into [4,4,4,4,0] in 4 operations. It can be proven
                 that 4 is the minimum number of operations needed.

    Example 2:
    Input: nums = [2,2,3,4]
    Output: 0
    Explanation: nums is already in non-decreasing order, so no operations are
                 needed and we return 0.

    Example 3:
    Input: nums = [0]
    Output: 0
    Explanation: nums is already in non-decreasing order, so no operations are
                 needed and we return 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] <= 1000

    Follow up: Can you solve it in O(n*log(n)) time complexity?*/

    private int fn(int[] nums) {
        Queue<Integer> pq = new PriorityQueue(Collections.reverseOrder());
        int ans = 0;
        for (var x : nums) {
            if (!pq.isEmpty() && x < pq.peek()) {
                ans += pq.poll() - x;
                pq.add(x);
            }
            pq.add(x);
        }
        return ans;
    }

    public int convertArray(int[] nums) {
        int ans = fn(nums);
        for (int i = 0, n = nums.length; i < n/2; ++i) {
            int temp = nums[i];
            nums[i] = nums[n-1-i];
            nums[n-1-i] = temp;
        }
        return Math.min(ans, fn(nums));
    }


    /*2277. Closest Node to Path in Tree (Hard)
    You are given a positive integer n representing the number of nodes in a
    tree, numbered from 0 to n - 1 (inclusive). You are also given a 2D integer
    array edges of length n - 1, where edges[i] = [node1i, node2i] denotes that
    there is a bidirectional edge connecting node1i and node2i in the tree. You
    are given a 0-indexed integer array query of length m where
    query[i] = [starti, endi, nodei] means that for the ith query, you are
    tasked with finding the node on the path from starti to endi that is
    closest to nodei. Return an integer array answer of length m, where
    answer[i] is the answer to the ith query.

    Example 1:
    Input: n = 7, edges = [[0,1],[0,2],[0,3],[1,4],[2,5],[2,6]], query = [[5,3,4],[5,3,6]]
    Output: [0,2]
    Explanation: The path from node 5 to node 3 consists of the nodes 5, 2, 0,
                 and 3. The distance between node 4 and node 0 is 2. Node 0 is
                 the node on the path closest to node 4, so the answer to the
                 first query is 0. The distance between node 6 and node 2 is 1.
                 Node 2 is the node on the path closest to node 6, so the
                 answer to the second query is 2.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2]], query = [[0,1,2]]
    Output: [1]
    Explanation: The path from node 0 to node 1 consists of the nodes 0, 1. The
                 distance between node 2 and node 1 is 1. Node 1 is the node on
                 the path closest to node 2, so the answer to the first query
                 is 1.

    Example 3:
    Input: n = 3, edges = [[0,1],[1,2]], query = [[0,0,0]]
    Output: [0]
    Explanation: The path from node 0 to node 0 consists of the node 0. Since 0
                 is the only node on the path, the answer to the first query is
                 0.

    Constraints:
    * 1 <= n <= 1000
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= node1i, node2i <= n - 1
    * node1i != node2i
    * 1 <= query.length <= 1000
    * query[i].length == 3
    * 0 <= starti, endi, nodei <= n - 1
    * The graph is a tree.*/

    private int lca(int u, int v, int[] depth, int[][] lift) {
        if (depth[u] > depth[v]) { int tmp = u; u = v; v = tmp; }
        for (int i = 0; i < 32; ++i)
            if ((depth[v] - depth[u] & 1<<i) > 0) v = lift[v][i];
        if (u == v) return u;
        for (int i = 31; i >= 0; --i)
            if (lift[u][i] != lift[v][i]) {
                u = lift[u][i];
                v = lift[v][i];
            }
        return lift[u][0];
    }

    public int[] closestNode(int n, int[][] edges, int[][] query) {
        List<Integer>[] tree = new ArrayList[n];
        for (int i = 0; i < n; ++i) tree[i] = new ArrayList();
        for (var e : edges) {
            tree[e[0]].add(e[1]);
            tree[e[1]].add(e[0]);
        }
        int[][] lift = new int[n][32];
        for (int i = 0; i < n; ++i) Arrays.fill(lift[i], -1);
        int[] depth = new int[n];
        Arrays.fill(depth, -1);
        Stack<int[]> stk = new Stack();
        stk.add(new int[] {0, -1, 0});
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            int u = elem[0], p = elem[1], d = elem[2];
            depth[u] = d;
            for (var v : tree[u])
                if (v != p) {
                    lift[v][0] = u;
                    for (int j = 1; j < 32 && lift[v][j-1] != -1; ++j)
                        lift[v][j] = lift[lift[v][j-1]][j-1];
                    stk.add(new int[] {v, u, d+1});
                }
        }
        int[] ans = new int[query.length];
        for (int i = 0; i < query.length; ++i) {
            int x = lca(query[i][0], query[i][1], depth, lift), y = lca(query[i][1], query[i][2], depth, lift), z = lca(query[i][2], query[i][0], depth, lift);
            if (depth[x] < depth[y]) x = y;
            if (depth[x] < depth[z]) x = z;
            ans[i] = x;
        }
        return ans;
    }


    /*2279. Maximum Bags With Full Capacity of Rocks (Medium)
    You have n bags numbered from 0 to n - 1. You are given two 0-indexed
    integer arrays capacity and rocks. The ith bag can hold a maximum of
    capacity[i] rocks and currently contains rocks[i] rocks. You are also given
    an integer additionalRocks, the number of additional rocks you can place in
    any of the bags. Return the maximum number of bags that could have full
    capacity after placing the additional rocks in some bags.

    Example 1:
    Input: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2
    Output: 3
    Explanation: Place 1 rock in bag 0 and 1 rock in bag 1. The number of rocks
                 in each bag are now [2,3,4,4]. Bags 0, 1, and 2 have full
                 capacity. There are 3 bags at full capacity, so we return 3.
                 It can be shown that it is not possible to have more than 3
                 bags at full capacity. Note that there may be other ways of
                 placing the rocks that result in an answer of 3.

    Example 2:
    Input: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100
    Output: 3
    Explanation: Place 8 rocks in bag 0 and 2 rocks in bag 2. The number of
                 rocks in each bag are now [10,2,2]. Bags 0, 1, and 2 have full
                 capacity. There are 3 bags at full capacity, so we return 3.
                 It can be shown that it is not possible to have more than 3
                 bags at full capacity. Note that we did not use all of the
                 additional rocks.

    Constraints:
    * n == capacity.length == rocks.length
    * 1 <= n <= 5 * 10^4
    * 1 <= capacity[i] <= 10^9
    * 0 <= rocks[i] <= capacity[i]
    * 1 <= additionalRocks <= 10^9*/

    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {
        int[] diff = new int[capacity.length];
        for (int i = 0; i < capacity.length; ++i) diff[i] = capacity[i] - rocks[i];
        Arrays.sort(diff);
        int ans = 0;
        for (var x : diff)
            if (x <= additionalRocks) {
                ++ans;
                additionalRocks -= x;
            }
        return ans;
    }


    /*2307. Check for Contradictions in Equations (Hard)
    You are given a 2D array of strings equations and an array of real numbers
    values, where equations[i] = [Ai, Bi] and values[i] means that
    Ai / Bi = values[i]. Determine if there exists a contradiction in the
    equations. Return true if there is a contradiction, or false otherwise.

    Note:
    * When checking if two numbers are equal, check that their absolute
      difference is less than 10-5.
    * The testcases are generated such that there are no cases targeting
      precision, i.e. using double is enough to solve the problem.

    Example 1:
    Input: equations = [["a","b"],["b","c"],["a","c"]], values = [3,0.5,1.5]
    Output: false
    Explanation: The given equations are: a / b = 3, b / c = 0.5, a / c = 1.5
                 There are no contradictions in the equations. One possible
                 assignment to satisfy all equations is: a = 3, b = 1 and c = 2.

    Example 2:
    Input: equations = [["le","et"],["le","code"],["code","et"]], values = [2,5,0.5]
    Output: true
    Explanation: The given equations are: le / et = 2, le / code = 5,
                 code / et = 0.5 Based on the first two equations, we get
                 code / et = 0.4. Since the third equation is
                 code / et = 0.5, we get a contradiction.

    Constraints:
    * 1 <= equations.length <= 100
    * equations[i].length == 2
    * 1 <= Ai.length, Bi.length <= 5
    * Ai, Bi consist of lowercase English letters.
    * equations.length == values.length
    * 0.0 < values[i] <= 10.0
    * values[i] has a maximum of 2 decimal places.*/

    public boolean checkContradictions(List<List<String>> equations, double[] values) {
        Set<String> node = new HashSet();
        Map<String, List<Pair<String, Double>>> graph = new HashMap();
        for (int i = 0; i < equations.size(); ++i) {
            String u = equations.get(i).get(0), v = equations.get(i).get(1);
            node.add(u);
            node.add(v);
            if (!graph.containsKey(u)) graph.put(u, new ArrayList());
            if (!graph.containsKey(v)) graph.put(v, new ArrayList());
            graph.get(u).add(new Pair(v, values[i]));
            graph.get(v).add(new Pair(u, 1/values[i]));
        }
        Map<String, Double> vals = new HashMap();
        for (var u : node)
            if (!vals.containsKey(u)) {
                Stack<String> stk = new Stack(); stk.push(u);
                vals.put(u, 1.);
                while (!stk.isEmpty()) {
                    var x = stk.pop();
                    for (var elem : graph.get(x)) {
                        String v = elem.getKey();
                        Double w = elem.getValue();
                        if (vals.containsKey(v)) {
                            if (Math.abs(vals.get(v) - vals.get(x)/w) > 1e-5*vals.get(v)) return true;
                        } else {
                            stk.push(v);
                            vals.put(v, vals.get(x)/w);
                        }
                    }
                }
            }
        return false;
    }


    /*2326. Spiral Matrix IV (Medium)
    You are given two integers m and n, which represent the dimensions of a
    matrix. You are also given the head of a linked list of integers. Generate
    an m x n matrix that contains the integers in the linked list presented in
    spiral order (clockwise), starting from the top-left of the matrix. If there
    are remaining empty spaces, fill them with -1. Return the generated matrix.

    Example 1:
    Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
    Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
    Explanation: The diagram above shows how the values are printed in the
                 matrix. Note that the remaining spaces in the matrix are filled
                 with -1.

    Example 2:
    Input: m = 1, n = 4, head = [0,1,2]
    Output: [[0,1,2,-1]]
    Explanation: The diagram above shows how the values are printed from left to
                 right in the matrix. The last space in the matrix is set to -1.

    Constraints:
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * The number of nodes in the list is in the range [1, m * n].
    * 0 <= Node.val <= 1000*/

    public int[][] spiralMatrix(int m, int n, ListNode head) {
        int[][] ans = new int[m][n];
        for (int i = 0; i < m; ++i) Arrays.fill(ans[i], -1);
        ListNode node = head;
        for (int i = 0, j = 0, di = 0, dj = 1; node != null; i += di, j += dj, node = node.next) {
            ans[i][j] = node.val;
            if (!(0 <= i+di && i+di < m && 0 <= j+dj && j+dj < n && ans[i+di][j+dj] == -1)) {
                int temp = di;
                di = dj;
                dj = -temp;
            }
        }
        return ans;
    }


    /*2331. Evaluate Boolean Binary Tree (Easy)
    You are given the root of a full binary tree with the following properties:
    * Leaf nodes have either the value 0 or 1, where 0 represents False and 1
      represents True.
    * Non-leaf nodes have either the value 2 or 3, where 2 represents the
      boolean OR and 3 represents the boolean AND.
    The evaluation of a node is as follows:
    * If the node is a leaf node, the evaluation is the value of the node, i.e.
      True or False.
    * Otherwise, evaluate the node's two children and apply the boolean
      operation of its value with the children's evaluations.
    Return the boolean result of evaluating the root node. A full binary tree is
    a binary tree where each node has either 0 or 2 children. A leaf node is a
    node that has zero children.

    Example 1:
    Input: root = [2,1,3,null,null,0,1]
    Output: true
    Explanation: The above diagram illustrates the evaluation process.
                 The AND node evaluates to False AND True = False.
                 The OR node evaluates to True OR False = True.
                 The root node evaluates to True, so we return true.

    Example 2:
    Input: root = [0]
    Output: false
    Explanation: The root node is a leaf node and it evaluates to false, so we
                 return false.

    Constraints:
    * The number of nodes in the tree is in the range [1, 1000].
    * 0 <= Node.val <= 3
    * Every node has either 0 or 2 children.
    * Leaf nodes have a value of 0 or 1.
    * Non-leaf nodes have a value of 2 or 3.*/

    public boolean evaluateTree(TreeNode root) {
        Map<TreeNode, Boolean> mp = new HashMap();
        Stack<TreeNode> stk = new Stack();
        TreeNode prev = null, node = root;
        while (node != null || !stk.isEmpty())
            if (node != null) {
                stk.push(node);
                node = node.left;
            } else {
                node = stk.peek();
                if (node.right != null && node.right != prev) node = node.right;
                else {
                    if (node.left == null && node.right == null) mp.put(node, node.val != 0);
                    else if (node.val == 2) mp.put(node, mp.get(node.left) || mp.get(node.right));
                    else mp.put(node, mp.get(node.left) && mp.get(node.right));
                    stk.pop();
                    prev = node;
                    node = null;
                }
            }
        return mp.get(root);
    }


    /*2359. Find Closest Node to Given Two Nodes (Medium)
    You are given a directed graph of n nodes numbered from 0 to n - 1, where
    each node has at most one outgoing edge. The graph is represented with a
    given 0-indexed array edges of size n, indicating that there is a directed
    edge from node i to node edges[i]. If there is no outgoing edge from i,
    then edges[i] == -1. You are also given two integers node1 and node2.
    Return the index of the node that can be reached from both node1 and node2,
    such that the maximum between the distance from node1 to that node, and
    from node2 to that node is minimized. If there are multiple answers, return
    the node with the smallest index, and if no possible answer exists, return
    -1. Note that edges may contain cycles.

    Example 1:
    Input: edges = [2,2,3,-1], node1 = 0, node2 = 1
    Output: 2
    Explanation: The distance from node 0 to node 2 is 1, and the distance from
                 node 1 to node 2 is 1. The maximum of those two distances is 1.
                 It can be proven that we cannot get a node with a smaller
                 maximum distance than 1, so we return node 2.

    Example 2:
    Input: edges = [1,2,-1], node1 = 0, node2 = 2
    Output: 2
    Explanation: The distance from node 0 to node 2 is 2, and the distance from
                 node 2 to itself is 0. The maximum of those two distances is 2.
                 It can be proven that we cannot get a node with a smaller
                 maximum distance than 2, so we return node 2.

    Constraints:
    * n == edges.length
    * 2 <= n <= 10^5
    * -1 <= edges[i] < n
    * edges[i] != i
    * 0 <= node1, node2 < n*/

    private static int[] bfs(int u, int[] edges) {
        int[] dist = new int[edges.length];
        Arrays.fill(dist, Integer.MAX_VALUE);
        for (int k = 0; u != -1 && dist[u] == Integer.MAX_VALUE; ++k, u = edges[u])
            dist[u] = k;
        return dist;
    }

    public int closestMeetingNode(int[] edges, int node1, int node2) {
        int ans = -1, small = Integer.MAX_VALUE;
        int[] dist1 = bfs(node1, edges), dist2 = bfs(node2, edges);
        for (int i = 0, n = edges.length; i < n; ++i) {
            int cand = Math.max(dist1[i], dist2[i]);
            if (cand < small) {
                ans = i;
                small = cand;
            }
        }
        return ans;
    }


    /*2370. Longest Ideal Subsequence (Medium)
    You are given a string s consisting of lowercase letters and an integer k.
    We call a string t ideal if the following conditions are satisfied:
    * t is a subsequence of the string s.
    * The absolute difference in the alphabet order of every two adjacent
      letters in t is less than or equal to k.
    Return the length of the longest ideal string. A subsequence is a string
    that can be derived from another string by deleting some or no characters
    without changing the order of the remaining characters. Note that the
    alphabet order is not cyclic. For example, the absolute difference in the
    alphabet order of 'a' and 'z' is 25, not 1.

    Example 1:
    Input: s = "acfgbd", k = 2
    Output: 4
    Explanation: The longest ideal string is "acbd". The length of this string
                 is 4, so 4 is returned. Note that "acfgbd" is not ideal because
                 'c' and 'f' have a difference of 3 in alphabet order.

    Example 2:
    Input: s = "abcd", k = 3
    Output: 4
    Explanation: The longest ideal string is "abcd". The length of this string
                 is 4, so 4 is returned.

    Constraints:
    * 1 <= s.length <= 10^5
    * 0 <= k <= 25
    * s consists of lowercase English letters.*/

    public int longestIdealString(String s, int k) {
        int[] dp = new int[26];
        for (var ch : s.toCharArray()) {
            int x = ch - 'a', most = 0;
            for (int i = Math.max(0, x-k); i < 26 && i <= x+k; ++i)
                most = Math.max(most, dp[i]);
            dp[x] = 1 + most;
        }
        return Arrays.stream(dp).max().getAsInt();
    }


    /*2392. Build a Matrix With Conditions (Hard)
    You are given a positive integer k. You are also given:
    * a 2D integer array rowConditions of size n where
      rowConditions[i] = [abovei, belowi], and
    * a 2D integer array colConditions of size m where
      colConditions[i] = [lefti, righti].
    The two arrays contain integers from 1 to k. You have to build a k x k
    matrix that contains each of the numbers from 1 to k exactly once. The
    remaining cells should have the value 0. The matrix should also satisfy the
    following conditions:
    * The number abovei should appear in a row that is strictly above the row at
      which the number belowi appears for all i from 0 to n - 1.
    * The number lefti should appear in a column that is strictly left of the
      column at which the number righti appears for all i from 0 to m - 1.
    Return any matrix that satisfies the conditions. If no answer exists, return
    an empty matrix.

    Example 1:
    Input: k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]
    Output: [[3,0,0],[0,0,1],[0,2,0]]
    Explanation: The diagram above shows a valid example of a matrix that
                 satisfies all the conditions.
                 The row conditions are the following:
                 - Number 1 is in row 1, and number 2 is in row 2, so 1 is above
                   2 in the matrix.
                 - Number 3 is in row 0, and number 2 is in row 2, so 3 is above
                   2 in the matrix.
                 The column conditions are the following:
                 - Number 2 is in column 1, and number 1 is in column 2, so 2 is
                   left of 1 in the matrix.
                 - Number 3 is in column 0, and number 2 is in column 1, so 3 is
                   left of 2 in the matrix.
                 Note that there may be multiple correct answers.

    Example 2:
    Input: k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]
    Output: []
    Explanation: From the first two conditions, 3 has to be below 1 but the
                 third conditions needs 3 to be above 1 to be satisfied. No
                 matrix can satisfy all the conditions, so we return the empty
                 matrix.

    Constraints:
    * 2 <= k <= 400
    * 1 <= rowConditions.length, colConditions.length <= 10^4
    * rowConditions[i].length == colConditions[i].length == 2
    * 1 <= abovei, belowi, lefti, righti <= k
    * abovei != belowi
    * lefti != righti*/

    private List<Integer> fn(int k, int[][] edges) {
        int[] degree = new int[k];
        List<Integer>[] graph = new ArrayList[k];
        for (int u = 0; u < k; ++u)
            graph[u] = new ArrayList();
        for (var e : edges) {
            int u = e[0]-1, v = e[1]-1;
            graph[u].add(v);
            ++degree[v];
        }
        Queue<Integer> q = new LinkedList();
        List<Integer> ans = new ArrayList();
        for (int u = 0; u < k; ++u)
            if (degree[u] == 0)
                q.add(u);
        while (!q.isEmpty()) {
            int u = q.poll();
            ans.add(u);
            for (var v : graph[u])
                if (--degree[v] == 0)
                    q.add(v);
        }
        return ans;
    }

    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {
        List<Integer> row = fn(k, rowConditions), col = fn(k, colConditions);
        if (row.size() < k || col.size() < k) return new int[0][0];
        int[][] ans = new int[k][k];
        int[] rmap = new int[k], cmap = new int[k];
        for (int i = 0; i < k; ++i)
            rmap[row.get(i)] = cmap[col.get(i)] = i;
        for (int x = 0; x < k; ++x)
            ans[rmap[x]][cmap[x]] = x+1;
        return ans;
    }


    /*2418. Sort the People (Easy)
    You are given an array of strings names, and an array heights that consists
    of distinct positive integers. Both arrays are of length n. For each index
    i, names[i] and heights[i] denote the name and height of the ith person.
    Return names sorted in descending order by the people's heights.

    Example 1:
    Input: names = ["Mary","John","Emma"], heights = [180,165,170]
    Output: ["Mary","Emma","John"]
    Explanation: Mary is the tallest, followed by Emma and John.

    Example 2:
    Input: names = ["Alice","Bob","Bob"], heights = [155,185,150]
    Output: ["Bob","Alice","Bob"]
    Explanation: The first Bob is the tallest, followed by Alice and the second
                 Bob.

    Constraints:
    * n == names.length == heights.length
    * 1 <= n <= 10^3
    * 1 <= names[i].length <= 20
    * 1 <= heights[i] <= 10^5
    * names[i] consists of lower and upper case English letters.
    * All the values of heights are distinct.*/

    public String[] sortPeople(String[] names, int[] heights) {
        int n = names.length;
        Pair<Integer, String>[] hn = new Pair[n];
        for (int i = 0; i < n; ++i)
            hn[i] = new Pair(heights[i], names[i]);
        Arrays.sort(hn, (x, y) -> Integer.compare(y.getKey(), x.getKey()));
        String[] ans = new String[n];
        for (int i = 0; i < n; ++i)
            ans[i] = hn[i].getValue();
        return ans;
    }


    /*2416. Sum of Prefix Scores of Strings (Hard)
    You are given an array words of size n consisting of non-empty strings. We
    define the score of a string word as the number of strings words[i] such
    that word is a prefix of words[i].
    * For example, if words = ["a", "ab", "abc", "cab"], then the score of "ab"
      is 2, since "ab" is a prefix of both "ab" and "abc".
    Return an array answer of size n where answer[i] is the sum of scores of
    every non-empty prefix of words[i]. Note that a string is considered as a
    prefix of itself.

    Example 1:
    Input: words = ["abc","ab","bc","b"]
    Output: [5,4,3,2]
    Explanation: The answer for each string is the following:
                 - "abc" has 3 prefixes: "a", "ab", and "abc".
                 - There are 2 strings with the prefix "a", 2 strings with the
                   prefix "ab", and 1 string with the prefix "abc".
                 The total is answer[0] = 2 + 2 + 1 = 5.
                 - "ab" has 2 prefixes: "a" and "ab".
                 - There are 2 strings with the prefix "a", and 2 strings with
                   the prefix "ab".
                 The total is answer[1] = 2 + 2 = 4.
                 - "bc" has 2 prefixes: "b" and "bc".
                 - There are 2 strings with the prefix "b", and 1 string with
                   the prefix "bc".
                 The total is answer[2] = 2 + 1 = 3.
                 - "b" has 1 prefix: "b".
                 - There are 2 strings with the prefix "b".
                 The total is answer[3] = 2.

    Example 2:
    Input: words = ["abcd"]
    Output: [4]
    Explanation: "abcd" has 4 prefixes: "a", "ab", "abc", and "abcd". Each
                 prefix has a score of one, so the total is
                 answer[0] = 1 + 1 + 1 + 1 = 4.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 1000
    * words[i] consists of lowercase English letters.

    class TrieNode {
        TrieNode[] child = new TrieNode[26];
        int cnt = 0;
    }*/

    public int[] sumPrefixScores(String[] words) {
        TrieNode trie = new TrieNode();
        for (var word : words) {
            TrieNode node = trie;
            for (var ch : word.toCharArray()) {
                int c = ch - 'a';
                if (node.child[c] == null) node.child[c] = new TrieNode();
                node = node.child[c];
                ++node.cnt;
            }
        }
        List<Integer> ans = new ArrayList<>();
        for (var word : words) {
            int val = 0;
            TrieNode node = trie;
            for (var ch : word.toCharArray()) {
                int c = ch - 'a';
                node = node.child[c];
                val += node.cnt;
            }
            ans.add(val);
        }
        return ans.stream().mapToInt(Integer::intValue).toArray();
    }


    /*2419. Longest Subarray With Maximum Bitwise AND (Medium)
    You are given an integer array nums of size n. Consider a non-empty subarray
    from nums that has the maximum possible bitwise AND. In other words, let k
    be the maximum value of the bitwise AND of any subarray of nums. Then, only
    subarrays with a bitwise AND equal to k should be considered. Return the
    length of the longest such subarray. The bitwise AND of an array is the
    bitwise AND of all the numbers in it. A subarray is a contiguous sequence of
    elements within an array.

    Example 1:
    Input: nums = [1,2,3,3,2,2]
    Output: 2
    Explanation: The maximum possible bitwise AND of a subarray is 3. The
                 longest subarray with that value is [3,3], so we return 2.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 1
    Explanation: The maximum possible bitwise AND of a subarray is 4. The
                 longest subarray with that value is [4], so we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    public int longestSubarray(int[] nums) {
        int ans = 0, cnt = 0, most = Arrays.stream(nums).max().getAsInt();
        for (var x : nums)
            if (x == most) ans = Math.max(ans, ++cnt);
            else cnt = 0;
        return ans;
    }


    /*2441. Largest Positive Integer That Exists With Its Negative (Easy)
    Given an integer array nums that does not contain any zeros, find the
    largest positive integer k such that -k also exists in the array. Return the
    positive integer k. If there is no such integer, return -1.

    Example 1:
    Input: nums = [-1,2,-3,3]
    Output: 3
    Explanation: 3 is the only valid k we can find in the array.

    Example 2:
    Input: nums = [-1,10,6,7,-7,1]
    Output: 7
    Explanation: Both 1 and 7 have their corresponding negative values in the
                 array. 7 has a larger value.

    Example 3:
    Input: nums = [-10,8,6,7,-2,-3]
    Output: -1
    Explanation: There is no a single valid k, we return -1.

    Constraints:
    * 1 <= nums.length <= 1000
    * -1000 <= nums[i] <= 1000
    * nums[i] != 0*/

    public int findMaxK(int[] nums) {
        int ans = -1;
        Set<Integer> seen = new HashSet();
        for (int x : nums) {
            if (seen.contains(-x)) ans = Math.max(ans, Math.abs(x));
            seen.add(x);
        }
        return ans;
    }


    /*2444. Count Subarrays With Fixed Bounds (Hard)
    You are given an integer array nums and two integers minK and maxK. A
    fixed-bound subarray of nums is a subarray that satisfies the following
    conditions:
    * The minimum value in the subarray is equal to minK.
    * The maximum value in the subarray is equal to maxK.
    Return the number of fixed-bound subarrays. A subarray is a contiguous part
    of an array.

    Example 1:
    Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5
    Output: 2
    Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2].

    Example 2:
    Input: nums = [1,1,1,1], minK = 1, maxK = 1
    Output: 10
    Explanation: Every subarray of nums is a fixed-bound subarray. There are 10
                 possible subarrays.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i], minK, maxK <= 10^6*/

    public long countSubarrays(int[] nums, int minK, int maxK) {
        long ans = 0;
        for (int i = 0, ii = -1, imin = -1, imax = -1; i < nums.length; ++i) {
            if (minK <= nums[i] && nums[i] <= maxK) {
                if (minK == nums[i]) imin = i;
                if (maxK == nums[i]) imax = i;
                ans += Math.max(0, Math.min(imax, imin) - ii);
            } else ii = i;
        }
        return ans;
    }


    /*2477. Minimum Fuel Cost to Report to the Capital (Medium)
    There is a tree (i.e., a connected, undirected graph with no cycles)
    structure country network consisting of n cities numbered from 0 to n - 1
    and exactly n - 1 roads. The capital city is city 0. You are given a 2D
    integer array roads where roads[i] = [ai, bi] denotes that there exists a
    bidirectional road connecting cities ai and bi. There is a meeting for the
    representatives of each city. The meeting is in the capital city. There is
    a car in each city. You are given an integer seats that indicates the
    number of seats in each car. A representative can use the car in their city
    to travel or change the car and ride with another representative. The cost
    of traveling between two cities is one liter of fuel. Return the minimum
    number of liters of fuel to reach the capital city.

    Example 1:
    Input: roads = [[0,1],[0,2],[0,3]], seats = 5
    Output: 3
    Explanation: - Representative1 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative2 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative3 goes directly to the capital with 1 liter of
                   fuel.
                 It costs 3 liters of fuel at minimum. It can be proven that 3
                 is the minimum number of liters of fuel needed.

    Example 2:
    Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
    Output: 7
    Explanation: - Representative2 goes directly to city 3 with 1 liter of fuel.
                 - Representative2 and representative3 go together to city 1
                   with 1 liter of fuel.
                 - Representative2 and representative3 go together to the
                   capital with 1 liter of fuel.
                 - Representative1 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative5 goes directly to the capital with 1 liter of
                   fuel.
                 - Representative6 goes directly to city 4 with 1 liter of fuel.
                 - Representative4 and representative6 go together to the
                   capital with 1 liter of fuel.
                 It costs 7 liters of fuel at minimum. It can be proven that 7
                 is the minimum number of liters of fuel needed.

    Example 3:
    Input: roads = [], seats = 1
    Output: 0
    Explanation: No representatives need to travel to the capital city.

    Constraints:
    * 1 <= n <= 10^5
    * roads.length == n - 1
    * roads[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * roads represents a valid tree.
    * 1 <= seats <= 10^5*/

    private long[] dfs(int u, int p, int seats, List<Integer>[] graph) {
        long ans = 0, ppl = 1;
        for (var v : graph[u]) {
            if (v != p) {
                var val = dfs(v, u, seats, graph);
                ppl += val[0];
                ans += val[1];
            }
        }
        if (u > 0) ans += (ppl + seats - 1) / seats;
        return new long[]{ppl, ans};
    }

    public long minimumFuelCost(int[][] roads, int seats) {
        int n = roads.length+1;
        List<Integer>[] graph = new ArrayList[n];
        for (int u = 0; u < n; ++u) graph[u] = new ArrayList();
        for (var r : roads) {
            graph[r[0]].add(r[1]);
            graph[r[1]].add(r[0]);
        }
        return dfs(0, -1, seats, graph)[1];
    }


    /*2479. Maximum XOR of Two Non-Overlapping Subtrees (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. The root of the tree is the node labeled 0. Each node has an
    associated value. You are given an array values of length n, where values[i]
    is the value of the ith node. Select any two non-overlapping subtrees. Your
    score is the bitwise XOR of the sum of the values within those subtrees.
    Return the maximum possible score you can achieve. If it is impossible to
    find two nonoverlapping subtrees, return 0.

    Note that:
    * The subtree of a node is the tree consisting of that node and all of its
      descendants.
    * Two subtrees are non-overlapping if they do not share any common node.

    Example 1:
    Input: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5]
    Output: 24
    Explanation: Node 1's subtree has sum of values 16, while node 2's subtree
                 has sum of values 8, so choosing these nodes will yield a
                 score of 16 XOR 8 = 24. It can be proved that is the maximum
                 possible score we can obtain.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2]], values = [4,6,1]
    Output: 0
    Explanation: There is no possible way to select two non-overlapping
                 subtrees, so we just return 0.

    Constraints:
    * 2 <= n <= 5 * 10^4
    * edges.length == n - 1
    * 0 <= ai, bi < n
    * values.length == n
    * 1 <= values[i] <= 10^9
    * It is guaranteed that edges represents a valid tree.*/

    class TrieNode {
        public TrieNode[] child = new TrieNode[] {null, null};
        public long val = 0;
    }

    private long dfs(int u, int p, int[] values, long[] sum, List<Integer>[] tree) {
        sum[u] = values[u];
        for (var v : tree[u])
            if (v != p) sum[u] += dfs(v, u, values, sum, tree);
        return sum[u];
    }

    private long calc(int u, int p, TrieNode trie, long[] sum, List<Integer>[] tree) {
        long ans = 0;
        if (trie.child[0] != null || trie.child[1] != null) {
            TrieNode node = trie;
            for (int i = 45; i >= 0; --i) {
                int b = (int) (sum[u] >> i) & 1;
                if (node.child[1-b] != null) node = node.child[1-b];
                else node = node.child[b];
            }
            ans = node.val ^ sum[u];
        }
        for (var v : tree[u])
            if (v != p) ans = Math.max(ans, calc(v, u, trie, sum, tree));
        TrieNode node = trie;
        for (int i = 45; i >= 0; --i) {
            int b = (int) (sum[u] >> i) & 1;
            if (node.child[b] == null) node.child[b] = new TrieNode();
            node = node.child[b];
        }
        node.val = sum[u];
        return ans;
    }

    public long maxXor(int n, int[][] edges, int[] values) {
        List<Integer>[] tree = new ArrayList[n];
        for (int u = 0; u < n; ++u) tree[u] = new ArrayList();
        for (var e : edges) {
            tree[e[0]].add(e[1]);
            tree[e[1]].add(e[0]);
        }

        long[] sum = new long[n];
        dfs(0, -1, values, sum, tree);

        TrieNode trie = new TrieNode();
        return calc(0, -1, trie, sum, tree);
    }


    /*2481. Minimum Cuts to Divide a Circle (Easy)
    A valid cut in a circle can be:
    * A cut that is represented by a straight line that touches two points on
      the edge of the circle and passes through its center, or
    * A cut that is represented by a straight line that touches one point on
      the edge of the circle and its center.
    Some valid and invalid cuts are shown in the figures below. Given the
    integer n, return the minimum number of cuts needed to divide a circle into
    n equal slices.

    Example 1:
    Input: n = 4
    Output: 2
    Explanation: The above figure shows how cutting the circle twice through
                 the middle divides it into 4 equal slices.

    Example 2:
    Input: n = 3
    Output: 3
    Explanation: At least 3 cuts are needed to divide the circle into 3 equal
                 slices. It can be shown that less than 3 cuts cannot result in
                 3 slices of equal size and shape. Also note that the first cut
                 will not divide the circle into distinct parts.

    Constraints: 1 <= n <= 100*/

    public int numberOfCuts(int n) {
        if (n == 1) return 0;
        return n%2 == 1 ? n : n/2;
    }


    /*2482. Difference Between Ones and Zeros in Row and Column (Medium)
    You are given a 0-indexed m x n binary matrix grid. A 0-indexed m x n
    difference matrix diff is created with the following procedure:
    * Let the number of ones in the ith row be onesRowi.
    * Let the number of ones in the jth column be onesColj.
    * Let the number of zeros in the ith row be zerosRowi.
    * Let the number of zeros in the jth column be zerosColj.
    * diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
    Return the difference matrix diff.

    Example 1:
    Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
    Output: [[0,0,4],[0,0,4],[-2,-2,2]]
    Explanation: - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0
                   = 2 + 1 - 1 - 2 = 0
                 - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1
                   = 2 + 1 - 1 - 2 = 0
                 - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2
                   = 2 + 3 - 1 - 0 = 4
                 - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0
                   = 2 + 1 - 1 - 2 = 0
                 - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1
                   = 2 + 1 - 1 - 2 = 0
                 - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2
                   = 2 + 3 - 1 - 0 = 4
                 - diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0
                   = 1 + 1 - 2 - 2 = -2
                 - diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1
                   = 1 + 1 - 2 - 2 = -2
                 - diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2
                   = 1 + 3 - 2 - 0 = 2

    Example 2:
    Input: grid = [[1,1,1],[1,1,1]]
    Output: [[5,5,5],[5,5,5]]
    Explanation: - diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0
                   = 3 + 2 - 0 - 0 = 5
                 - diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1
                   = 3 + 2 - 0 - 0 = 5
                 - diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2
                   = 3 + 2 - 0 - 0 = 5
                 - diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0
                   = 3 + 2 - 0 - 0 = 5
                 - diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1
                   = 3 + 2 - 0 - 0 = 5
                 - diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2
                   = 3 + 2 - 0 - 0 = 5

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * grid[i][j] is either 0 or 1.*/

    public int[][] onesMinusZeros(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[] row = new int[m], col = new int[n];
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                row[i] += grid[i][j];
                col[j] += grid[i][j];
            }
        int[][] ans = new int[m][n];
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                ans[i][j] = 2*row[i] + 2*col[j] - m - n;
        return ans;
    }


    /*2483. Minimum Penalty for a Shop (Medium)
    You are given the customer visit log of a shop represented by a 0-indexed
    string customers consisting only of characters 'N' and 'Y':
    * if the ith character is 'Y', it means that customers come at the ith hour
    * whereas 'N' indicates that no customers come at the ith hour.
    If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated
    as follows:
    * For every hour when the shop is open and no customers come, the penalty
      increases by 1.
    * For every hour when the shop is closed and customers come, the penalty
      increases by 1.
    Return the earliest hour at which the shop must be closed to incur a
    minimum penalty. Note that if a shop closes at the jth hour, it means the
    shop is closed at the hour j.

    Example 1:
    Input: customers = "YYNY"
    Output: 2
    Explanation: - Closing the shop at the 0th hour incurs in 1+1+0+1 = 3
                   penalty.
                 - Closing the shop at the 1st hour incurs in 0+1+0+1 = 2
                   penalty.
                 - Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1
                   penalty.
                 - Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2
                   penalty.
                 - Closing the shop at the 4th hour incurs in 0+0+1+0 = 1
                   penalty.
                 Closing the shop at 2nd or 4th hour gives a minimum penalty.
                 Since 2 is earlier, the optimal closing time is 2.

    Example 2:
    Input: customers = "NNNNN"
    Output: 0
    Explanation: It is best to close the shop at the 0th hour as no customers
                 arrive.

    Example 3:
    Input: customers = "YYYY"
    Output: 4
    Explanation: It is best to close the shop at the 4th hour as customers
                 arrive at each hour.

    Constraints:
    * 1 <= customers.length <= 10^5
    * customers consists only of characters 'Y' and 'N'.*/

    public int bestClosingTime(String customers) {
        int ans = 0, prefix = (int) customers.chars().filter(ch -> ch =='Y').count(), least = prefix;
        for (int i = 0; i < customers.length(); ++i) {
            if (customers.charAt(i) == 'N') ++prefix;
            else --prefix;
            if (prefix < least) {
                ans = i+1;
                least = prefix;
            }
        }
        return ans;
    }


    /*2484. Count Palindromic Subsequences (Hard)
    Given a string of digits s, return the number of palindromic subsequences
    of s having length 5. Since the answer may be very large, return it modulo
    10^9 + 7.

    Note:
    * A string is palindromic if it reads the same forward and backward.
    * A subsequence is a string that can be derived from another string by
      deleting some or no characters without changing the order of the
      remaining characters.

    Example 1:
    Input: s = "103301"
    Output: 2
    Explanation: There are 6 possible subsequences of length 5: "10330","10331",
                 "10301","10301","13301","03301". Two of them (both equal to
                 "10301") are palindromic.

    Example 2:
    Input: s = "0000000"
    Output: 21
    Explanation: All 21 subsequences are "00000", which is palindromic.

    Example 3:
    Input: s = "9999900000"
    Output: 2
    Explanation: The only two palindromic subsequences are "99999" and "00000".

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of digits.*/

    public int countPalindromes(String s) {
        final int mod = 1_000_000_007;
        long ans = 0;
        for (int x = 0; x <= 9; ++x)
            for (int y = 0; y <= 9; ++y) {
                int[] pattern = new int[] {x, y, 0, y, x};
                long[] dp = new long[6];
                dp[5] = 1;
                for (int i = 0; i < s.length(); ++i)
                    for (int j = 0; j < 5; ++j)
                        if (s.charAt(i) == pattern[j] + '0' || j == 2) dp[j] = (dp[j] + dp[j+1]) % mod;
                ans = (ans + dp[0]) % mod;
            }
        return (int) ans;
    }


    /*2485. Find the Pivot Integer (Easy)
    Given a positive integer n, find the pivot integer x such that:
    * The sum of all elements between 1 and x inclusively equals the sum of all
      elements between x and n inclusively.
    Return the pivot integer x. If no such integer exists, return -1. It is
    guaranteed that there will be at most one pivot index for the given input.

    Example 1:
    Input: n = 8
    Output: 6
    Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.

    Example 2:
    Input: n = 1
    Output: 1
    Explanation: 1 is the pivot integer since: 1 = 1.

    Example 3:
    Input: n = 4
    Output: -1
    Explanation: It can be proved that no such integer exist.

    Constraints: 1 <= n <= 1000*/

    public int pivotInteger(int n) {
        int total = n*(n+1)/2, val = (int) Math.sqrt(total);
        return Math.pow(val, 2) == total ? val : -1;
    }


    /*2486. Append Characters to String to Make Subsequence (Medium)
    You are given two strings s and t consisting of only lowercase English
    letters. Return the minimum number of characters that need to be appended
    to the end of s so that t becomes a subsequence of s. A subsequence is a
    string that can be derived from another string by deleting some or no
    characters without changing the order of the remaining characters.

    Example 1:
    Input: s = "coaching", t = "coding"
    Output: 4
    Explanation: Append the characters "ding" to the end of s so that
                 s = "coachingding". Now, t is a subsequence of s
                 ("coachingding"). It can be shown that appending any 3
                 characters to the end of s will never make t a subsequence.

    Example 2:
    Input: s = "abcde", t = "a"
    Output: 0
    Explanation: t is already a subsequence of s ("abcde").

    Example 3:
    Input: s = "z", t = "abcde"
    Output: 5
    Explanation: Append the characters "abcde" to the end of s so that
                 s = "zabcde". Now, t is a subsequence of s ("zabcde"). It can
                 be shown that appending any 4 characters to the end of s will
                 never make t a subsequence.

    Constraints:
    * 1 <= s.length, t.length <= 10^5
    * s and t consist only of lowercase English letters.*/

    public int appendCharacters(String s, String t) {
        int i = 0;
        for (char ch : s.toCharArray())
            if (i < t.length() && ch == t.charAt(i)) ++i;
        return t.length()-i;
    }


    /*2487. Remove Nodes From Linked List (Medium)
    You are given the head of a linked list. Remove every node which has a node
    with a strictly greater value anywhere to the right side of it. Return the
    head of the modified linked list.

    Example 1:
    Input: head = [5,2,13,3,8]
    Output: [13,8]
    Explanation: The nodes that should be removed are 5, 2 and 3.
                 - Node 13 is to the right of node 5.
                 - Node 13 is to the right of node 2.
                 - Node 8 is to the right of node 3.

    Example 2:
    Input: head = [1,1,1,1]
    Output: [1,1,1,1]
    Explanation: Every node has value 1, so no nodes are removed.

    Constraints:
    * The number of the nodes in the given list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5*/

    public ListNode removeNodes(ListNode head) {
        Deque<ListNode> stk = new ArrayDeque();
        for (ListNode node = head; node != null; node = node.next) {
            while (!stk.isEmpty() && stk.peekLast().val < node.val) stk.pollLast();
            if (!stk.isEmpty()) stk.peekLast().next = node;
            stk.addLast(node);
        }
        return stk.peekFirst();
    }


    /*2488. Count Subarrays With Median K (Hard)
    You are given an array nums of size n consisting of distinct integers from
    1 to n and a positive integer k. Return the number of non-empty subarrays
    in nums that have a median equal to k.

    Note:
    * The median of an array is the middle element after sorting the array in
      ascending order. If the array is of even length, the median is the left
      middle element.
      + For example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1]
        is 4.
    * A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [3,2,1,4,5], k = 4
    Output: 3
    Explanation: The subarrays that have a median equal to 4 are: [4], [4,5]
                 and [1,4,5].

    Example 2:
    Input: nums = [2,3,1], k = 3
    Output: 1
    Explanation: [3] is the only subarray that has a median equal to 3.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * 1 <= nums[i], k <= n
    * The integers in nums are distinct.*/

    public int countSubarrays(int[] nums, int k) {
        Map<Integer, Integer> freq = new HashMap<>();
        freq.put(0, 1);
        int ans = 0, diff = 0;
        boolean found = false;
        for (int x : nums) {
            if (x < k) --diff;
            else if (x > k) ++diff;
            else found = true;
            if (found) ans += freq.getOrDefault(diff, 0) + freq.getOrDefault(diff-1, 0);
            else freq.merge(diff, 1, Integer::sum);
        }
        return ans;
    }


    /*2489. Number of Substrings With Fixed Ratio (Medium)
    You are given a binary string s, and two integers num1 and num2. num1 and
    num2 are coprime numbers. A ratio substring is a substring of s where the
    ratio between the number of 0's and the number of 1's in the substring is
    exactly num1 : num2.
    * For example, if num1 = 2 and num2 = 3, then "01011" and "1110000111" are
      ratio substrings, while "11000" is not.
    Return the number of non-empty ratio substrings of s.

    Note that:
    * A substring is a contiguous sequence of characters within a string.
    * Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the
      greatest common divisor of x and y.

    Example 1:
    Input: s = "0110011", num1 = 1, num2 = 2
    Output: 4
    Explanation: There exist 4 non-empty ratio substrings.
                 - The substring s[0..2]: "0110011". It contains one 0 and two
                   1's. The ratio is 1 : 2.
                 - The substring s[1..4]: "0110011". It contains one 0 and two
                   1's. The ratio is 1 : 2.
                 - The substring s[4..6]: "0110011". It contains one 0 and two
                   1's. The ratio is 1 : 2.
                 - The substring s[1..6]: "0110011". It contains two 0's and
                   four 1's. The ratio is 2 : 4 == 1 : 2.
                 It can be shown that there are no more ratio substrings.

    Example 2:
    Input: s = "10101", num1 = 3, num2 = 1
    Output: 0
    Explanation: There is no ratio substrings of s. We return 0.

    Constraints:
    * 1 <= s.length <= 10^5
    * 1 <= num1, num2 <= s.length
    * num1 and num2 are coprime integers.*/

    public long fixedRatio(String s, int num1, int num2) {
        HashMap<Long, Integer> freq = new HashMap<>(); freq.put(0l, 1);
        long ans = 0, prefix = 0;
        for (char ch : s.toCharArray()) {
            if (ch == '0') prefix += num2;
            else prefix -= num1;
            ans += freq.getOrDefault(prefix, 0);
            freq.merge(prefix, 1, Integer::sum);
        }
        return ans;
    }


    /*2491. Divide Players Into Teams of Equal Skill (Medium)
    You are given a positive integer array skill of even length n where skill[i]
    denotes the skill of the ith player. Divide the players into n / 2 teams of
    size 2 such that the total skill of each team is equal. The chemistry of a
    team is equal to the product of the skills of the players on that team.
    Return the sum of the chemistry of all the teams, or return -1 if there is
    no way to divide the players into teams such that the total skill of each
    team is equal.

    Example 1:
    Input: skill = [3,2,5,1,3,4]
    Output: 22
    Explanation: Divide the players into the following teams: (1, 5), (2, 4),
                 (3, 3), where each team has a total skill of 6. The sum of the
                 chemistry of all the teams is:
                 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.

    Example 2:
    Input: skill = [3,4]
    Output: 12
    Explanation: The two players form a team with a total skill of 7. The
                 chemistry of the team is 3 * 4 = 12.

    Example 3:
    Input: skill = [1,1,2,3]
    Output: -1
    Explanation: There is no way to divide the players into teams such that the
                 total skill of each team is equal.

    Constraints:
    * 2 <= skill.length <= 10^5
    * skill.length is even.
    * 1 <= skill[i] <= 1000*/

    public long dividePlayers(int[] skill) {
        int val = 2*Arrays.stream(skill).sum() / skill.length;
        long ans = 0;
        HashMap<Integer, Integer> freq = new HashMap<>();
        for (int x : skill) freq.merge(x, 1, Integer::sum);
        for (var elem : freq.entrySet()) {
            int k = elem.getKey(), v = elem.getValue();
            if (v != freq.getOrDefault(val-k, 0)) return -1;
            ans += (long) k*(val-k)*v;
        }
        return ans/2;
    }


    /*2492. Minimum Score of a Path Between Two Cities (Medium)
    You are given a positive integer n representing n cities numbered from 1 to
    n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei]
    indicates that there is a bidirectional road between cities ai and bi with
    a distance equal to distancei. The cities graph is not necessarily
    connected. The score of a path between two cities is defined as the minimum
    distance of a road in this path. Return the minimum possible score of a
    path between cities 1 and n.

    Note:
    * A path is a sequence of roads between two cities.
    * It is allowed for a path to contain the same road multiple times, and you
      can visit cities 1 and n multiple times along the path.
    * The test cases are generated such that there is at least one path between
      1 and n.

    Example 1:
    Input: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]
    Output: 5
    Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 ->
                 4. The score of this path is min(9,5) = 5. It can be shown
                 that no other path has less score.

    Example 2:
    Input: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]
    Output: 2
    Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 ->
                 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= roads.length <= 10^5
    * roads[i].length == 3
    * 1 <= ai, bi <= n
    * ai != bi
    * 1 <= distancei <= 10^4
    * There are no repeated edges.
    * There is at least one path between 1 and n.*/

    private int find(int p, int[] parent) {
        if (p != parent[p]) parent[p] = find(parent[p], parent);
        return parent[p];
    }

    public int minScore(int n, int[][] roads) {
        int[] parent = IntStream.rangeClosed(0, n-1).toArray();
        int[] mp = new int[n];
        Arrays.fill(mp, Integer.MAX_VALUE);
        for (int[] r : roads) {
            int u = find(r[0]-1, parent), v = find(r[1]-1, parent);
            parent[u] = v;
            mp[u] = mp[v] = Math.min(mp[u], Math.min(mp[v], r[2]));
        }
        return find(0, parent) == find(n-1, parent) ? mp[find(0, parent)] : -1;
    }


    /*2495. Number of Subarrays Having Even Product (Medium)
    Given a 0-indexed integer array nums, return the number of subarrays of
    nums having an even product.

    Example 1:
    Input: nums = [9,6,7,13]
    Output: 6
    Explanation: There are 6 subarrays with an even product:
                 - nums[0..1] = 9 * 6 = 54.
                 - nums[0..2] = 9 * 6 * 7 = 378.
                 - nums[0..3] = 9 * 6 * 7 * 13 = 4914.
                 - nums[1..1] = 6.
                 - nums[1..2] = 6 * 7 = 42.
                 - nums[1..3] = 6 * 7 * 13 = 546.

    Example 2:
    Input: nums = [7,3,5]
    Output: 0
    Explanation: There are no subarrays with an even product.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    public long evenProduct(int[] nums) {
        long ans = 0;
        for (int i = 0, val = 0; i < nums.length; ++i) {
            if (nums[i] % 2 == 0) val = i+1;
            ans += val;
        }
        return ans;
    }


    /*2496. Maximum Value of a String in an Array (Easy)
    The value of an alphanumeric string can be defined as:
    * The numeric representation of the string in base 10, if it comprises of
      digits only.
    * The length of the string, otherwise.
    Given an array strs of alphanumeric strings, return the maximum value of
    any string in strs.

    Example 1:
    Input: strs = ["alic3","bob","3","4","00000"]
    Output: 5
    Explanation: - "alic3" consists of both letters and digits, so its value is
                   its length, i.e. 5.
                 - "bob" consists only of letters, so its value is also its
                   length, i.e. 3.
                 - "3" consists only of digits, so its value is its numeric
                   equivalent, i.e. 3.
                 - "4" also consists only of digits, so its value is 4.
                 - "00000" consists only of digits, so its value is 0.
                 Hence, the maximum value is 5, of "alic3".

    Example 2:
    Input: strs = ["1","01","001","0001"]
    Output: 1
    Explanation: Each string in the array has value 1. Hence, we return 1.

    Constraints:
    * 1 <= strs.length <= 100
    * 1 <= strs[i].length <= 9
    * strs[i] consists of only lowercase English letters and digits.*/

    public int maximumValue(String[] strs) {
        int ans = 0;
        for (String s : strs)
            if (s.matches("[0-9]+")) ans = Math.max(ans, Integer.valueOf(s));
            else ans = Math.max(ans, s.length());
        return ans;
    }


    /*2497. Maximum Star Sum of a Graph (Medium)
    There is an undirected graph consisting of n nodes numbered from 0 to n - 1.
    You are given a 0-indexed integer array vals of length n where vals[i]
    denotes the value of the ith node. You are also given a 2D integer array
    edges where edges[i] = [ai, bi] denotes that there exists an undirected
    edge connecting nodes ai and bi. A star graph is a subgraph of the given
    graph having a center node containing 0 or more neighbors. In other words,
    it is a subset of edges of the given graph such that there exists a common
    node for all edges. The image below shows star graphs with 3 and 4
    neighbors respectively, centered at the blue node. The star sum is the sum
    of the values of all the nodes present in the star graph. Given an integer
    k, return the maximum star sum of a star graph containing at most k edges.

    Example 1:
    Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2
    Output: 16
    Explanation: The above diagram represents the input graph. The star graph
                 with the maximum star sum is denoted by blue. It is centered
                 at 3 and includes its neighbors 1 and 4. It can be shown it is
                 not possible to get a star graph with a sum greater than 16.

    Example 2:
    Input: vals = [-5], edges = [], k = 0
    Output: -5
    Explanation: There is only one possible star graph, which is node 0 itself.
                 Hence, we return -5.

    Constraints:
    * n == vals.length
    * 1 <= n <= 10^5
    * -10^4 <= vals[i] <= 10^4
    * 0 <= edges.length <= min(n * (n - 1) / 2, 10^5)
    * edges[i].length == 2
    * 0 <= ai, bi <= n - 1
    * ai != bi
    * 0 <= k <= n - 1*/

    public int maxStarSum(int[] vals, int[][] edges, int k) {
        int n = vals.length;
        List<Integer>[] graph = new ArrayList[n];
        for (int u = 0; u < n; ++u) graph[u] = new ArrayList();
        for (int[] e : edges) {
            graph[e[0]].add(e[1]);
            graph[e[1]].add(e[0]);
        }
        int ans = Integer.MIN_VALUE;
        for (int u = 0; u < n; ++u) {
            int cand = vals[u];
            if (graph[u].size() > k) Collections.sort(graph[u], (a, b) -> vals[b] - vals[a]);
            for (int v = 0; v < k && v < graph[u].size(); ++v)
                cand += Math.max(0, vals[graph[u].get(v)]);
            ans = Math.max(ans, cand);
        }
        return ans;
    }


    /*2498. Frog Jump II (Medium)
    You are given a 0-indexed integer array stones sorted in strictly
    increasing order representing the positions of stones in a river. A frog,
    initially on the first stone, wants to travel to the last stone and then
    return to the first stone. However, it can jump to any stone at most once.
    The length of a jump is the absolute difference between the position of the
    stone the frog is currently on and the position of the stone to which the
    frog jumps. More formally, if the frog is at stones[i] and is jumping to
    stones[j], the length of the jump is |stones[i] - stones[j]|. The cost of a
    path is the maximum length of a jump among all jumps in the path. Return
    the minimum cost of a path for the frog.

    Example 1:
    Input: stones = [0,2,5,6,7]
    Output: 5
    Explanation: The above figure represents one of the optimal paths the frog
                 can take. The cost of this path is 5, which is the maximum
                 length of a jump. Since it is not possible to achieve a cost
                 of less than 5, we return it.

    Example 2:
    Input: stones = [0,3,9]
    Output: 9
    Explanation: The frog can jump directly to the last stone and come back to
                 the first stone. In this case, the length of each jump will be
                 9. The cost for the path will be max(9, 9) = 9. It can be
                 shown that this is the minimum achievable cost.

    Constraints:
    * 2 <= stones.length <= 10^5
    * 0 <= stones[i] <= 10^9
    * stones[0] == 0
    * stones is sorted in a strictly increasing order.*/

    public int maxJump(int[] stones) {
        int ans = stones[1];
        for (int i = 2; i < stones.length; ++i)
            ans = Math.max(ans, stones[i] - stones[i-2]);
        return ans;
    }


    /*2499. Minimum Total Cost to Make Arrays Unequal (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2, of equal length
    n. In one operation, you can swap the values of any two indices of nums1.
    The cost of this operation is the sum of the indices. Find the minimum
    total cost of performing the given operation any number of times such that
    nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the
    operations. Return the minimum total cost such that nums1 and nums2 satisfy
    the above condition. In case it is not possible, return -1.

    Example 1:
    Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]
    Output: 10
    Explanation: One of the ways we can perform the operations is:
                 - Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3.
                   Now, nums1 = [4,2,3,1,5]
                 - Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3.
                   Now, nums1 = [4,3,2,1,5].
                 - Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4.
                   Now, nums1 =[5,3,2,1,4].
                 We can see that for each index i, nums1[i] != nums2[i]. The
                 cost required here is 10. Note that there are other ways to
                 swap values, but it can be proven that it is not possible to
                 obtain a cost less than 10.

    Example 2:
    Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]
    Output: 10
    Explanation: One of the ways we can perform the operations is:
                 - Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5.
                   Now, nums1 = [2,2,1,2,3].
                 - Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5.
                   Now, nums1 = [2,3,1,2,2].
                 The total cost needed here is 10, which is the minimum
                 possible.

    Example 3:
    Input: nums1 = [1,2,2], nums2 = [1,2,2]
    Output: -1
    Explanation: It can be shown that it is not possible to satisfy the given
                 conditions irrespective of the number of operations we
                 perform. Hence, we return -1.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= n*/

    public long minimumTotalCost(int[] nums1, int[] nums2) {
        int n = nums1.length, total = 0;
        int[] freq = new int[n+1];
        long ans = 0;
        for (int i = 0; i < n; ++i)
            if (nums1[i] == nums2[i]) {
                ++freq[nums1[i]];
                ++total;
                ans += i;
            }
        int most = 0, key = 0;
        for (int i = 0; i <= n; ++i)
            if (freq[i] > most) {
                key = i;
                most = freq[i];
            }
        for (int i = 0; i < n && 2*most > total; ++i)
            if (nums1[i] != nums2[i] && key != nums1[i] && key != nums2[i]) {
                ++total;
                ans += i;
            }
        return 2*most <= total ? ans : -1;
    }


    /*2500. Delete Greatest Value in Each Row (Easy)
    You are given an m x n matrix grid consisting of positive integers. Perform
    the following operation until grid becomes empty:
    * Delete the element with the greatest value from each row. If multiple
      such elements exist, delete any of them.
    * Add the maximum of deleted elements to the answer.
    Note that the number of columns decreases by one after each operation.
    Return the answer after performing the operations described above.

    Example 1:
    Input: grid = [[1,2,4],[3,3,1]]
    Output: 8
    Explanation: The diagram above shows the removed values in each step.
                 - In the first operation, we remove 4 from the first row and 3
                   from the second row (notice that, there are two cells with
                   value 3 and we can remove any of them). We add 4 to the
                   answer.
                 - In the second operation, we remove 2 from the first row and
                   3 from the second row. We add 3 to the answer.
                 - In the third operation, we remove 1 from the first row and 1
                   from the second row. We add 1 to the answer.
                 The final answer = 4 + 3 + 1 = 8.

    Example 2:
    Input: grid = [[10]]
    Output: 10
    Explanation: The diagram above shows the removed values in each step.
                 - In the first operation, we remove 10 from the first row. We
                   add 10 to the answer.
                 The final answer = 10.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * 1 <= grid[i][j] <= 100*/

    public int deleteGreatestValue(int[][] grid) {
        for (int[] row : grid) Arrays.sort(row);
        int ans = 0;
        for (int j = 0; j < grid[0].length; ++j) {
            int cand = 0;
            for (int i = 0; i < grid.length; ++i)
                cand = Math.max(cand, grid[i][j]);
            ans += cand;
        }
        return ans;
    }


    /*2501. Longest Square Streak in an Array (Medium)
    You are given an integer array nums. A subsequence of nums is called a
    square streak if:
    * The length of the subsequence is at least 2, and
    * after sorting the subsequence, each element (except the first element) is
      the square of the previous number.
    Return the length of the longest square streak in nums, or return -1 if
    there is no square streak. A subsequence is an array that can be derived
    from another array by deleting some or no elements without changing the
    order of the remaining elements.

    Example 1:
    Input: nums = [4,3,6,16,8,2]
    Output: 3
    Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes
                 [2,4,16].
                 - 4 = 2 * 2.
                 - 16 = 4 * 4.
                 Therefore, [4,16,2] is a square streak. It can be shown that
                 every subsequence of length 4 is not a square streak.

    Example 2:
    Input: nums = [2,3,5,6,7]
    Output: -1
    Explanation: There is no square streak in nums so return -1.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 2 <= nums[i] <= 10^5*/

    public int longestSquareStreak(int[] nums) {
        int[] dp = new int[100_001];
        Arrays.sort(nums);
        int ans = 0;
        for (int x : nums) {
            dp[x] = Math.max(1, dp[x]);
            int v = (int) Math.sqrt(x);
            if (v*v == x) dp[x] = 1 + dp[v];
            ans = Math.max(ans, dp[x]);
        }
        return ans > 1 ? ans : -1;
    }


    /*2503. Maximum Number of Points From Grid Queries (Hard)
    You are given an m x n integer matrix grid and an array queries of size k.
    Find an array answer of size k such that for each integer queres[i] you
    start in the top left cell of the matrix and repeat the following process:
    * If queries[i] is strictly greater than the value of the current cell that
      you are in, then you get one point if it is your first time visiting this
      cell, and you can move to any adjacent cell in all 4 directions: up, down,
      left, and right.
    * Otherwise, you do not get any points, and you end this process.
    After the process, answer[i] is the maximum number of points you can get.
    Note that for each query you are allowed to visit the same cell multiple
    times. Return the resulting array answer.

    Example 1:
    Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]
    Output: [5,8,1]
    Explanation: The diagrams above show which cells we visit to get points for
                 each query.

    Example 2:
    Input: grid = [[5,2,1],[1,1,2]], queries = [3]
    Output: [0]
    Explanation: We can not get any points because the value of the top left
                 cell is already greater than or equal to 3.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 1000
    * 4 <= m * n <= 10^5
    * k == queries.length
    * 1 <= k <= 10^4
    * 1 <= grid[i][j], queries[i] <= 10^6*/

    public int[] maxPoints(int[][] grid, int[] queries) {
        int m = grid.length, n = grid[0].length, prev = Integer.MIN_VALUE, prefix = 0;
        int[][] dir = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};
        Queue<int[]> pq = new PriorityQueue<>((a, b)->(a[0]-b[0]));
        pq.add(new int[]{grid[0][0], 0, 0});
        grid[0][0] = 0;
        List<Integer> keys = new ArrayList();
        List<Integer> vals = new ArrayList();
        while (pq.size() > 0) {
            int[] elem = pq.remove();
            int v = elem[0], i = elem[1], j = elem[2];
            if (prev != v) {
                keys.add(prev);
                vals.add(prefix);
            }
            ++prefix;
            prev = v;
            for (var d : dir) {
                int ii = i + d[0], jj = j + d[1];
                if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] > 0) {
                    int vv = Math.max(v, grid[ii][jj]);
                    pq.add(new int[]{vv, ii, jj});
                    grid[ii][jj] = 0;
                }
            }
        }
        keys.add(prev);
        vals.add(prefix);
        int sz = queries.length;
        int[] ans = new int[sz];
        for (int i = 0; i < sz; ++i) {
            int k = Collections.binarySearch(keys, queries[i]);
            if (k < 0) k = -k-1;
            ans[i] = vals.get(k-1);
        }
        return ans;
    }


    /*2505. Bitwise OR of All Subsequence Sums (Medium)
    Given an integer array nums, return the value of the bitwise OR of the sum
    of all possible subsequences in the array. A subsequence is a sequence that
    can be derived from another sequence by removing zero or more elements
    without changing the order of the remaining elements.

    Example 1:
    Input: nums = [2,1,0,3]
    Output: 7
    Explanation: All possible subsequence sums that we can have are:
                 0, 1, 2, 3, 4, 5, 6. And we have
                 0 OR 1 OR 2 OR 3 OR 4 OR 5 OR 6 = 7, so we return 7.

    Example 2:
    Input: nums = [0,0,0]
    Output: 0
    Explanation: 0 is the only possible subsequence sum we can have, so we
                 return 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9*/

    public long subsequenceSumOr(int[] nums) {
        long ans = 0, prefix = 0;
        for (var x : nums) {
            prefix += x;
            ans |= x | prefix;
        }
        return ans;
    }


    /*2506. Count Pairs Of Similar Strings (Easy)
    You are given a 0-indexed string array words. Two strings are similar if
    they consist of the same characters.
    * For example, "abca" and "cba" are similar since both consist of
      characters 'a', 'b', and 'c'.
    * However, "abacba" and "bcfd" are not similar since they do not consist of
      the same characters.
    Return the number of pairs (i, j) such that 0 <= i < j <= word.length - 1
    and the two strings words[i] and words[j] are similar.

    Example 1:
    Input: words = ["aba","aabb","abcd","bac","aabc"]
    Output: 2
    Explanation: There are 2 pairs that satisfy the conditions:
                 - i = 0 and j = 1 : both words[0] and words[1] only consist of
                   characters 'a' and 'b'.
                 - i = 3 and j = 4 : both words[3] and words[4] only consist of
                   characters 'a', 'b', and 'c'.

    Example 2:
    Input: words = ["aabb","ab","ba"]
    Output: 3
    Explanation: There are 3 pairs that satisfy the conditions:
                 - i = 0 and j = 1 : both words[0] and words[1] only consist of
                   characters 'a' and 'b'.
                 - i = 0 and j = 2 : both words[0] and words[2] only consist of
                   characters 'a' and 'b'.
                 - i = 1 and j = 2 : both words[1] and words[2] only consist of
                   characters 'a' and 'b'.

    Example 3:
    Input: words = ["nba","cba","dba"]
    Output: 0
    Explanation: Since there does not exist any pair that satisfies the
                 conditions, we return 0.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] consist of only lowercase English letters.*/

    public int similarPairs(String[] words) {
        int ans = 0;
        HashMap<Integer, Integer> freq = new HashMap();
        for (var word : words) {
            int mask = 0;
            for (var ch : word.toCharArray())
                mask |= 1<<ch-'a';
            ans += freq.getOrDefault(mask, 0);
            freq.merge(mask, 1, Integer::sum);
        }
        return ans;
    }


    /*2507. Smallest Value After Replacing With Sum of Prime Factors (Medium)
    You are given a positive integer n. Continuously replace n with the sum of
    its prime factors.
    * Note that if a prime factor divides n multiple times, it should be
      included in the sum as many times as it divides n.
    Return the smallest value n will take on.

    Example 1:
    Input: n = 15
    Output: 5
    Explanation: Initially, n = 15.
                 15 = 3 * 5, so replace n with 3 + 5 = 8.
                 8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.
                 6 = 2 * 3, so replace n with 2 + 3 = 5.
                 5 is the smallest value n will take on.

    Example 2:
    Input: n = 3
    Output: 3
    Explanation: Initially, n = 3. 3 is the smallest value n will take on.

    Constraints: 2 <= n <= 10^5*/

    public int smallestValue(int n) {
        while (true) {
            int sm = 0;
            for (int f = 2, nn = n; f <= nn; ++f)
                for (; nn % f == 0; nn /= f, sm += f);
            if (sm == n) break;
            n = sm;
        }
        return n;
    }


    /*2508. Add Edges to Make Degrees of All Nodes Even (Hard)
    There is an undirected graph consisting of n nodes numbered from 1 to n.
    You are given the integer n and a 2D array edges where edges[i] = [ai, bi]
    indicates that there is an edge between nodes ai and bi. The graph can be
    disconnected. You can add at most two additional edges (possibly none) to
    this graph so that there are no repeated edges and no self-loops. Return
    true if it is possible to make the degree of each node in the graph even,
    otherwise return false. The degree of a node is the number of edges
    connected to it.

    Example 1:
    Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]
    Output: true
    Explanation: The above diagram shows a valid way of adding an edge. Every
                 node in the resulting graph is connected to an even number of
                 edges.

    Example 2:
    Input: n = 4, edges = [[1,2],[3,4]]
    Output: true
    Explanation: The above diagram shows a valid way of adding two edges.

    Example 3:
    Input: n = 4, edges = [[1,2],[1,3],[1,4]]
    Output: false
    Explanation: It is not possible to obtain a valid graph with adding at most
                 2 edges.

    Constraints:
    * 3 <= n <= 10^5
    * 2 <= edges.length <= 10^5
    * edges[i].length == 2
    * 1 <= ai, bi <= n
    * ai != bi
    * There are no repeated edges.*/

    public boolean isPossible(int n, List<List<Integer>> edges) {
        HashSet<Integer>[] graph = new HashSet[n];
        for (int i = 0; i < n; ++i) graph[i] = new HashSet();
        for (var e : edges) {
            graph[e.get(0)-1].add(e.get(1)-1);
            graph[e.get(1)-1].add(e.get(0)-1);
        }
        List<Integer> odd = new ArrayList();
        for (int i = 0; i < n; ++i)
            if (graph[i].size() % 2 == 1) odd.add(i);
        if (odd.size() == 2) {
            for (int i = 0; i < n; ++i)
                if (!graph[i].contains(odd.get(0)) && !graph[i].contains(odd.get(1))) return true;
            return false;
        }
        if (odd.size() == 4)
            return !graph[odd.get(0)].contains(odd.get(1)) && !graph[odd.get(2)].contains(odd.get(3))
                || !graph[odd.get(0)].contains(odd.get(2)) && !graph[odd.get(1)].contains(odd.get(3))
                || !graph[odd.get(0)].contains(odd.get(3)) && !graph[odd.get(1)].contains(odd.get(2));
        return odd.size() == 0;
    }


    /*2509. Cycle Length Queries in a Tree (Hard)
    You are given an integer n. There is a complete binary tree with 2n - 1
    nodes. The root of that tree is the node with the value 1, and every node
    with a value val in the range [1, 2n - 1 - 1] has two children where:
    * The left node has the value 2 * val, and
    * The right node has the value 2 * val + 1.
    You are also given a 2D integer array queries of length m, where
    queries[i] = [ai, bi]. For each query, solve the following problem:
    * Add an edge between the nodes with values ai and bi.
    * Find the length of the cycle in the graph.
    * Remove the added edge between nodes with values ai and bi.
    Note that:
    * A cycle is a path that starts and ends at the same node, and each edge in
      the path is visited only once.
    * The length of a cycle is the number of edges visited in the cycle.
    * There could be multiple edges between two nodes in the tree after adding
      the edge of the query.
    Return an array answer of length m where answer[i] is the answer to the ith
    query.

    Example 1:
    Input: n = 3, queries = [[5,3],[4,7],[2,3]]
    Output: [4,5,3]
    Explanation: The diagrams above show the tree of 23 - 1 nodes. Nodes
                 colored in red describe the nodes in the cycle after adding
                 the edge.
                 - After adding the edge between nodes 3 and 5, the graph
                   contains a cycle of nodes [5,2,1,3]. Thus answer to the
                   first query is 4. We delete the added edge and process the
                   next query.
                 - After adding the edge between nodes 4 and 7, the graph
                   contains a cycle of nodes [4,2,1,3,7]. Thus answer to the
                   second query is 5. We delete the added edge and process the
                   next query.
                 - After adding the edge between nodes 2 and 3, the graph
                   contains a cycle of nodes [2,1,3]. Thus answer to the third
                   query is 3. We delete the added edge.

    Example 2:
    Input: n = 2, queries = [[1,2]]
    Output: [2]
    Explanation: The diagram above shows the tree of 22 - 1 nodes. Nodes
                 colored in red describe the nodes in the cycle after adding
                 the edge.
                 - After adding the edge between nodes 1 and 2, the graph
                   contains a cycle of nodes [2,1]. Thus answer for the first
                   query is 2. We delete the added edge.

    Constraints:
    * 2 <= n <= 30
    * m == queries.length
    * 1 <= m <= 10^5
    * queries[i].length == 2
    * 1 <= ai, bi <= 2n - 1
    * ai != bi*/

    public int[] cycleLengthQueries(int n, int[][] queries) {
        int[] ans = new int[queries.length];
        for (int i = 0; i < queries.length; ++i) {
            int dist = 1;
            for (int u = queries[i][0], v = queries[i][1]; u != v; u /= 2, ++dist)
                if (u < v) { int tmp = v; v = u; u = tmp; }
            ans[i] = dist;
        }
        return ans;
    }


    /*2510. Check if There is a Path With Equal Number of 0's And 1's (Medium)
    You are given a 0-indexed m x n binary matrix grid. You can move from a
    cell (row, col) to any of the cells (row + 1, col) or (row, col + 1).
    Return true if there is a path from (0, 0) to (m - 1, n - 1) that visits an
    equal number of 0's and 1's. Otherwise return false.

    Example 1:
    Input: grid = [[0,1,0,0],[0,1,0,0],[1,0,1,0]]
    Output: true
    Explanation: The path colored in blue in the above diagram is a valid path
                 because we have 3 cells with a value of 1 and 3 with a value
                 of 0. Since there is a valid path, we return true.

    Example 2:
    Input: grid = [[1,1,0],[0,0,1],[1,0,0]]
    Output: false
    Explanation: There is no path in this grid with an equal number of 0's and
                 1's.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 100
    * grid[i][j] is either 0 or 1.*/

    public boolean isThereAPath(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        if ((m+n) % 2 == 1) {
            int[][] lo = new int[m][n], hi = new int[m][n];
            Arrays.stream(lo).forEach(a -> Arrays.fill(a, Integer.MAX_VALUE));
            Arrays.stream(hi).forEach(a -> Arrays.fill(a, Integer.MIN_VALUE));
            lo[0][0] = hi[0][0] = 2*grid[0][0]-1;
            for (int i = 0; i < m; ++i)
                for (int j = 0; j < n; ++j) {
                    if (i > 0) {
                        lo[i][j] = Math.min(lo[i][j], lo[i-1][j] + 2*grid[i][j]-1);
                        hi[i][j] = Math.max(hi[i][j], hi[i-1][j] + 2*grid[i][j]-1);
                    }
                    if (j > 0) {
                        lo[i][j] = Math.min(lo[i][j], lo[i][j-1] + 2*grid[i][j]-1);
                        hi[i][j] = Math.max(hi[i][j], hi[i][j-1] + 2*grid[i][j]-1);
                    }
                }
            return lo[m-1][n-1] <= 0 && 0 <= hi[m-1][n-1];
        }
        return false;
    }


    /*2511. Maximum Enemy Forts That Can Be Captured (Easy)
    You are given a 0-indexed integer array forts of length n representing the
    positions of several forts. forts[i] can be -1, 0, or 1 where:
    * -1 represents there is no fort at the ith position.
    * 0 indicates there is an enemy fort at the ith position.
    * 1 indicates the fort at the ith the position is under your command.
    Now you have decided to move your army from one of your forts at position i
    to an empty position j such that:
    * 0 <= i, j <= n - 1
    * The army travels over enemy forts only. Formally, for all k where
      min(i,j) < k < max(i,j), forts[k] == 0.
    While moving the army, all the enemy forts that come in the way are
    captured. Return the maximum number of enemy forts that can be captured. In
    case it is impossible to move your army, or you do not have any fort under
    your command, return 0.

    Example 1:
    Input: forts = [1,0,0,-1,0,0,0,0,1]
    Output: 4
    Explanation: - Moving the army from position 0 to position 3 captures 2
                   enemy forts, at 1 and 2.
                 - Moving the army from position 8 to position 3 captures 4
                   enemy forts.
                 Since 4 is the maximum number of enemy forts that can be
                 captured, we return 4.

    Example 2:
    Input: forts = [0,0,1,-1]
    Output: 0
    Explanation: Since no enemy fort can be captured, 0 is returned.

    Constraints:
    * 1 <= forts.length <= 1000
    * -1 <= forts[i] <= 1*/

    public int captureForts(int[] forts) {
        int ans = 0;
        for (int i = 0, ii = 0; i < forts.length; ++i)
            if (forts[i] != 0) {
                if (forts[ii] == -forts[i]) ans = Math.max(ans, i-ii-1);
                ii = i;
            }
        return ans;
    }


    /*2512. Reward Top K Students (Medium)
    You are given two string arrays positive_feedback and negative_feedback,
    containing the words denoting positive and negative feedback, respectively.
    Note that no word is both positive and negative. Initially every student
    has 0 points. Each positive word in a feedback report increases the points
    of a student by 3, whereas each negative word decreases the points by 1.
    You are given n feedback reports, represented by a 0-indexed string array
    report and a 0-indexed integer array student_id, where student_id[i]
    represents the ID of the student who has received the feedback report
    report[i]. The ID of each student is unique. Given an integer k, return
    the top k students after ranking them in non-increasing order by their
    points. In case more than one student has the same points, the one with the
    lower ID ranks higher.

    Example 1:
    Input: positive_feedback = ["smart","brilliant","studious"],
           negative_feedback = ["not"],
           report = ["this student is studious","the student is smart"],
           student_id = [1,2], k = 2
    Output: [1,2]
    Explanation: Both the students have 1 positive feedback and 3 points but
                 since student 1 has a lower ID he ranks higher.

    Example 2:
    Input: positive_feedback = ["smart","brilliant","studious"],
           negative_feedback = ["not"],
           report = ["this student is not studious","the student is smart"],
           student_id = [1,2], k = 2
    Output: [2,1]
    Explanation: - The student with ID 1 has 1 positive feedback and 1 negative
                   feedback, so he has 3-1=2 points.
                 - The student with ID 2 has 1 positive feedback, so he has 3
                   points.
                 Since student 2 has more points, [2,1] is returned.

    Constraints:
    * 1 <= positive_feedback.length, negative_feedback.length <= 10^4
    * 1 <= positive_feedback[i].length, negative_feedback[j].length <= 100
    * Both positive_feedback[i] and negative_feedback[j] consists of lowercase
      English letters.
    * No word is present in both positive_feedback and negative_feedback.
    * n == report.length == student_id.length
    * 1 <= n <= 10^4
    * report[i] consists of lowercase English letters and spaces ' '.
    * There is a single space between consecutive words of report[i].
    * 1 <= report[i].length <= 100
    * 1 <= student_id[i] <= 10^9
    * All the values of student_id[i] are unique.
    * 1 <= k <= n*/

    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {
        Set<String> positive = new HashSet(Arrays.asList(positive_feedback)), negative = new HashSet(Arrays.asList(negative_feedback));
        Map<Integer, Integer> mp = new HashMap();
        for (int i = 0; i < report.length; ++i) {
            int point = 0;
            for (var word : report[i].split(" ")) {
                if (positive.contains(word)) point += 3;
                else if (negative.contains(word)) --point;
            }
            mp.put(student_id[i], point);
        }
        List<Integer> vals = new ArrayList();
        for (var elem : mp.entrySet()) vals.add(elem.getKey());
        Collections.sort(vals, (a, b)->(mp.get(a) != mp.get(b) ? Integer.compare(mp.get(b), mp.get(a)) : Integer.compare(a, b)));
        List<Integer> ans = new ArrayList();
        for (int i = 0; i < k; ++i) ans.add(vals.get(i));
        return ans;
    }


    /*2513. Minimize the Maximum of Two Arrays (Medium)
    We have two arrays arr1 and arr2 which are initially empty. You need to add
    positive integers to them such that they satisfy all the following
    conditions:
    * arr1 contains uniqueCnt1 distinct positive integers, each of which is not
      divisible by divisor1.
    * arr2 contains uniqueCnt2 distinct positive integers, each of which is not
      divisible by divisor2.
    * No integer is present in both arr1 and arr2.
    Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum
    possible maximum integer that can be present in either array.

    Example 1:
    Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3
    Output: 4
    Explanation: We can distribute the first 4 natural numbers into arr1 and
                 arr2. arr1 = [1] and arr2 = [2,3,4]. We can see that both
                 arrays satisfy all the conditions. Since the maximum value is
                 4, we return it.

    Example 2:
    Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1
    Output: 3
    Explanation: Here arr1 = [1,2], and arr2 = [3] satisfy all conditions.
                 Since the maximum value is 3, we return it.

    Example 3:
    Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2
    Output: 15
    Explanation: Here, the final possible arrays can be
                 arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6]. It can be shown
                 that it is not possible to obtain a lower maximum satisfying
                 all conditions.

    Constraints:
    * 2 <= divisor1, divisor2 <= 10^5
    * 1 <= uniqueCnt1, uniqueCnt2 < 10^9
    * 2 <= uniqueCnt1 + uniqueCnt2 <= 10^9*/

    public int minimizeSet(int divisor1, int divisor2, int uniqueCnt1, int uniqueCnt2) {
        int g = divisor1;
        for (int x = divisor2; x > 0; ) {int tmp = g; g = x; x = tmp % x; }
        long lo = 0, hi = Integer.MAX_VALUE, mult = ((long) divisor1*divisor2/g);
        while (lo < hi) {
            long mid = lo + (hi-lo)/2;
            if (uniqueCnt1 <= mid-mid/divisor1 && uniqueCnt2 <= mid-mid/divisor2 && uniqueCnt1+uniqueCnt2 <= mid-mid/mult) hi = mid;
            else lo = mid+1;
        }
        return (int) lo;
    }


    /*2514. Count Anagrams (Hard)
    You are given a string s containing one or more words. Every consecutive
    pair of words is separated by a single space ' '. A string t is an anagram
    of string s if the ith word of t is a permutation of the ith word of s.
    * For example, "acb dfe" is an anagram of "abc def", but "def cab" and
      "adc bef" are not.
    Return the number of distinct anagrams of s. Since the answer may be very
    large, return it modulo 10^9 + 7.

    Example 1:
    Input: s = "too hot"
    Output: 18
    Explanation: Some of the anagrams of the given string are "too hot",
                 "oot hot", "oto toh", "too toh", and "too oht".

    Example 2:
    Input: s = "aa"
    Output: 1
    Explanation: There is only one anagram possible for the given string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters and spaces ' '.
    * There is single space between consecutive words.*/

    public int countAnagrams(String s) {
        final int mod = 1_000_000_007;
        int n = s.length();
        long[] fact = new long[n+1], ifact = new long[n+1], inv = new long[n+1];
        fact[0] = ifact[0] = inv[0] = inv[1] = 1;
        for (int x = 1; x <= n; ++x) {
            if (x >= 2) inv[x] = mod - mod/x * inv[mod%x] % mod;
            fact[x] = fact[x-1] * x % mod;
            ifact[x] = ifact[x-1] * inv[x] % mod;
        }
        long ans = 1;
        for (var word : s.split(" ")) {
            ans = ans * fact[word.length()] % mod;
            int[] freq = new int[26];
            for (var ch : word.toCharArray())  ++freq[ch-'a'];
            for (var x : freq) ans = ans * ifact[x] % mod;
        }
        return (int) ans;
    }


    /*2515. Shortest Distance to Target String in a Circular Array (Easy)
    You are given a 0-indexed circular string array words and a string target.
    A circular array means that the array's end connects to the array's
    beginning.
    * Formally, the next element of words[i] is words[(i + 1) % n] and the
      previous element of words[i] is words[(i - 1 + n) % n], where n is the
      length of words.
    Starting from startIndex, you can move to either the next word or the
    previous word with 1 step at a time. Return the shortest distance needed to
    reach the string target. If the string target does not exist in words,
    return -1.

    Example 1:
    Input: words = ["hello","i","am","leetcode","hello"], target = "hello", startIndex = 1
    Output: 1
    Explanation: We start from index 1 and can reach "hello" by
                 - moving 3 units to the right to reach index 4.
                 - moving 2 units to the left to reach index 4.
                 - moving 4 units to the right to reach index 0.
                 - moving 1 unit to the left to reach index 0.
                 The shortest distance to reach "hello" is 1.

    Example 2:
    Input: words = ["a","b","leetcode"], target = "leetcode", startIndex = 0
    Output: 1
    Explanation: We start from index 0 and can reach "leetcode" by
                 - moving 2 units to the right to reach index 3.
                 - moving 1 unit to the left to reach index 3.
                 The shortest distance to reach "leetcode" is 1.

    Example 3:
    Input: words = ["i","eat","leetcode"], target = "ate", startIndex = 0
    Output: -1
    Explanation: Since "ate" does not exist in words, we return -1.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 100
    * words[i] and target consist of only lowercase English letters.
    * 0 <= startIndex < words.length*/

    public int closetTarget(String[] words, String target, int startIndex) {
        int ans = Integer.MAX_VALUE;
        for (int i = 0, n = words.length; i < n; ++i)
            if (words[i].equals(target)) {
                int cand = Math.abs(i - startIndex);
                ans = Math.min(ans, Math.min(cand, n - cand));
            }
        return ans < Integer.MAX_VALUE ? ans : -1;
    }


    /*2516. Take K of Each Character From Left and Right (Medium)
    You are given a string s consisting of the characters 'a', 'b', and 'c' and
    a non-negative integer k. Each minute, you may take either the leftmost
    character of s, or the rightmost character of s. Return the minimum number
    of minutes needed for you to take at least k of each character, or return
    -1 if it is not possible to take k of each character.

    Example 1:
    Input: s = "aabaaaacaabc", k = 2
    Output: 8
    Explanation: Take three characters from the left of s. You now have two 'a'
                 characters, and one 'b' character. Take five characters from
                 the right of s. You now have four 'a' characters, two 'b'
                 characters, and two 'c' characters. A total of 3 + 5 = 8
                 minutes is needed. It can be proven that 8 is the minimum
                 number of minutes needed.

    Example 2:
    Input: s = "a", k = 1
    Output: -1
    Explanation: It is not possible to take one 'b' or 'c' so return -1.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of only the letters 'a', 'b', and 'c'.
    * 0 <= k <= s.length*/

    public int takeCharacters(String s, int k) {
        int ans = Integer.MAX_VALUE;
        int[] freq= new int[3];
        for (int i = 0, ii = 0, n = s.length(); i < 2*n; ++i) {
            ++freq[s.charAt(i % n) - 'a'];
            while (ii < n && i >= n-1 && freq[s.charAt(ii)-'a'] > k && freq[0] >= k && freq[1] >= k && freq[2] >= k) {
                ans = Math.min(ans, i-ii);
                --freq[s.charAt(ii++) - 'a'];
            }
        }
        return ans <= s.length() ? ans : -1;
    }


    /*2517. Maximum Tastiness of Candy Basket (Medium)
    You are given an array of positive integers price where price[i] denotes
    the price of the ith candy and a positive integer k. The store sells
    baskets of k distinct candies. The tastiness of a candy basket is the
    smallest absolute difference of the prices of any two candies in the basket.
    Return the maximum tastiness of a candy basket.

    Example 1:
    Input: price = [13,5,1,8,21,2], k = 3
    Output: 8
    Explanation: Choose the candies with the prices [13,5,21]. The tastiness of
                 the candy basket is:
                 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8. It can
                 be proven that 8 is the maximum tastiness that can be achieved.

    Example 2:
    Input: price = [1,3,1], k = 2
    Output: 2
    Explanation: Choose the candies with the prices [1,3]. The tastiness of the
                 candy basket is: min(|1 - 3|) = min(2) = 2. It can be proven
                 that 2 is the maximum tastiness that can be achieved.

    Example 3:
    Input: price = [7,7,7,7], k = 2
    Output: 0
    Explanation: Choosing any two distinct candies from the candies we have
                 will result in a tastiness of 0.

    Constraints:
    * 1 <= price.length <= 10^5
    * 1 <= price[i] <= 10^9
    * 2 <= k <= price.length*/

    public int maximumTastiness(int[] price, int k) {
        Arrays.sort(price);
        int n = price.length;
        int lo = 0, hi = price[n-1] - price[0];
        while (lo < hi) {
            int mid = lo + (hi-lo+1)/2, val = price[0], cnt = 0;
            for (var x : price)
                if (x >= val + mid) { ++cnt; val = x; }
            if (cnt >= k-1) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*2518. Number of Great Partitions (Hard)
    You are given an array nums consisting of positive integers and an integer
    k. Partition the array into two ordered groups such that each element is in
    exactly one group. A partition is called great if the sum of elements of
    each group is greater than or equal to k. Return the number of distinct
    great partitions. Since the answer may be too large, return it modulo
    10^9 + 7. Two partitions are considered distinct if some element nums[i] is
    in different groups in the two partitions.

    Example 1:
    Input: nums = [1,2,3,4], k = 4
    Output: 6
    Explanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]),
                 ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and
                 ([4], [1,2,3]).

    Example 2:
    Input: nums = [3,3,3], k = 4
    Output: 0
    Explanation: There are no great partitions for this array.

    Example 3:
    Input: nums = [6,6], k = 2
    Output: 2
    Explanation: We can either put nums[0] in the first partition or in the
                 second partition. The great partitions will be ([6], [6]) and
                 ([6], [6]).

    Constraints:
    * 1 <= nums.length, k <= 1000
    * 1 <= nums[i] <= 10^9*/

    public int countPartitions(int[] nums, int k) {
        final int mod = 1_000_000_007;
        long ans = 1, total = 0;
        long[] dp = new long[k];
        dp[0] = 1;
        for (var x : nums) {
            ans = 2*ans % mod;
            total += x;
            for (int i = k-1-x; i >= 0; --i)
                dp[i+x] = (dp[i] + dp[i+x]) % mod;
        }
        ans -= 2*LongStream.of(dp).sum();
        return total >= 2*k ? (int) (ans % mod + mod) % mod : 0;
    }


    /*2519. Count the Number of K-Big Indices (Hard)
    You are given a 0-indexed integer array nums and a positive integer k. We
    call an index i k-big if the following conditions are satisfied:
    * There exist at least k different indices idx1 such that idx1 < i and
      nums[idx1] < nums[i].
    * There exist at least k different indices idx2 such that idx2 > i and
      nums[idx2] < nums[i].
    Return the number of k-big indices.

    Example 1:
    Input: nums = [2,3,6,5,2,3], k = 2
    Output: 2
    Explanation: There are only two 2-big indices in nums:
                 - i = 2 --> There are two valid idx1: 0 and 1. There are three
                             valid idx2: 2, 3, and 4.
                 - i = 3 --> There are two valid idx1: 0 and 1. There are two
                             valid idx2: 3 and 4.

    Example 2:
    Input: nums = [1,1,1], k = 3
    Output: 0
    Explanation: There are no 3-big indices in nums.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= nums.length*/

    public int kBigIndices(int[] nums, int k) {
        int n = nums.length;
        boolean[] prefix = new boolean[n];
        Queue<Integer> pq = new PriorityQueue(Collections.reverseOrder());
        for (int i = 0; i < n; ++i) {
            if (pq.size() == k && pq.peek() < nums[i]) prefix[i] = true;
            pq.add(nums[i]);
            if (pq.size() > k) pq.poll();
        }
        int ans = 0;
        pq.clear();
        for (int i = n-1; i >= 0; --i) {
            if (pq.size() == k && pq.peek() < nums[i] && prefix[i]) ++ans;
            pq.add(nums[i]);
            if (pq.size() > k) pq.poll();
        }
        return ans;
    }


    /*2520. Count the Digits That Divide a Number (Easy)
    Given an integer num, return the number of digits in num that divide num.
    An integer val divides nums if nums % val == 0.

    Example 1:
    Input: num = 7
    Output: 1
    Explanation: 7 divides itself, hence the answer is 1.

    Example 2:
    Input: num = 121
    Output: 2
    Explanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a
                 digit, we return 2.

    Example 3:
    Input: num = 1248
    Output: 4
    Explanation: 1248 is divisible by all of its digits, hence the answer is 4.

    Constraints:
    * 1 <= num <= 10^9
    * num does not contain 0 as one of its digits.*/

    public int countDigits(int num) {
        int ans = 0;
        for (int n = num; n > 0; n /= 10)
            if (num % (n % 10) == 0) ++ans;
        return ans;
    }


    /*2521. Distinct Prime Factors of Product of Array (Medium)
    Given an array of positive integers nums, return the number of distinct
    prime factors in the product of the elements of nums. Note that:
    * A number greater than 1 is called prime if it is divisible by only 1 and
      itself.
    * An integer val1 is a factor of another integer val2 if val2 / val1 is an
      integer.

    Example 1:
    Input: nums = [2,4,3,7,10,6]
    Output: 4
    Explanation: The product of all the elements in nums is:
                 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2^5 * 3^2 * 5 * 7.
                 There are 4 distinct prime factors so we return 4.

    Example 2:
    Input: nums = [2,4,8,16]
    Output: 1
    Explanation: The product of all the elements in nums is:
                 2 * 4 * 8 * 16 = 1024 = 2^10.
                 There is 1 distinct prime factor so we return 1.

    Constraints:
    * 1 <= nums.length <= 10^4
    * 2 <= nums[i] <= 1000*/

    public int distinctPrimeFactors(int[] nums) {
        HashSet<Integer> seen = new HashSet();
        for (var x : nums) {
            for (int f = 2; f <= Math.sqrt(x); ++f)
                for (; x % f == 0; x /= f)
                    seen.add(f);
            if (1 < x) seen.add(x);
        }
        return seen.size();
    }


    /*2522. Partition String Into Substrings With Values at Most K (Medium)
    You are given a string s consisting of digits from 1 to 9 and an integer k.
    A partition of a string s is called good if:
    * Each digit of s is part of exactly one substring.
    * The value of each substring is less than or equal to k.
    Return the minimum number of substrings in a good partition of s. If no
    good partition of s exists, return -1. Note that:
    * The value of a string is its result when interpreted as an integer. For
      example, the value of "123" is 123 and the value of "1" is 1.
    * A substring is a contiguous sequence of characters within a string.

    Example 1:
    Input: s = "165462", k = 60
    Output: 4
    Explanation: We can partition the string into substrings "16", "54", "6",
                 and "2". Each substring has a value less than or equal to
                 k = 60. It can be shown that we cannot partition the string
                 into less than 4 substrings.

    Example 2:
    Input: s = "238182", k = 5
    Output: -1
    Explanation: There is no good partition for this string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is a digit from '1' to '9'.
    * 1 <= k <= 10^9*/

    public int minimumPartition(String s, int k) {
        int ans = 1;
        long val = 0;
        for (var ch : s.toCharArray()) {
            if (10*val + (ch - '0') > k) {
                ++ans;
                val = 0;
            }
            val = 10*val + (ch - '0');
            if (val > k) return -1;
        }
        return ans;
    }


    /*2523. Closest Prime Numbers in Range (Medium)
    Given two positive integers left and right, find the two integers num1 and
    num2 such that:
    * left <= nums1 < nums2 <= right .
    * nums1 and nums2 are both prime numbers.
    * nums2 - nums1 is the minimum amongst all other pairs satisfying the above
      conditions.
    Return the positive integer array ans = [nums1, nums2]. If there are
    multiple pairs satisfying these conditions, return the one with the minimum
    nums1 value or [-1, -1] if such numbers do not exist. A number greater than
    1 is called prime if it is only divisible by 1 and itself.

    Example 1:
    Input: left = 10, right = 19
    Output: [11,13]
    Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.
                 The closest gap between any pair is 2, which can be achieved
                 by [11,13] or [17,19]. Since 11 is smaller than 17, we return
                 the first pair.

    Example 2:
    Input: left = 4, right = 6
    Output: [-1,-1]
    Explanation: There exists only one prime number in the given range, so the
                 conditions cannot be satisfied.

    Constraints: 1 <= left <= right <= 10^6*/

    public int[] closestPrimes(int left, int right) {
        boolean[] sieve = new boolean[right+1];
        Arrays.fill(sieve, true);
        sieve[0] = sieve[1] = false;
        for (int x = 2; x <= Math.sqrt(right); ++x)
            if (sieve[x])
                for (int xx = x*x; xx <= right; xx +=x)
                    sieve[xx] = false;
        int[] ans = {-1, -1};
        int prev = 0, least = Integer.MAX_VALUE;
        for (int x = left; x <= right; ++x)
            if (sieve[x]) {
                if (prev > 0 && x - prev < least) {
                    ans = new int[]{prev, x};
                    least = x - prev;
                }
                prev = x;
            }
        return ans;
    }


    /*2524. Maximum Frequency Score of a Subarray (Hard)
    You are given an integer array nums and a positive integer k. The frequency
    score of an array is the sum of the distinct values in the array raised to
    the power of their frequencies, taking the sum modulo 10^9 + 7. For example,
    the frequency score of the array [5,4,5,7,4,4] is
    (4^3 + 5^2 + 7^1) modulo (10^9 + 7) = 96. Return the maximum frequency
    score of a subarray of size k in nums. You should maximize the value under
    the modulo and not the actual value. A subarray is a contiguous part of an
    array.

    Example 1:
    Input: nums = [1,1,1,2,1,2], k = 3
    Output: 5
    Explanation: The subarray [2,1,2] has a frequency score equal to 5. It can
                 be shown that it is the maximum frequency score we can have.

    Example 2:
    Input: nums = [1,1,1,1,1,1], k = 4
    Output: 1
    Explanation: All the subarrays of length 4 have a frequency score equal to
                 1.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    // private long pow(long x, int p, int m) {
    //     long ans = 1;
    //     for (; p > 0; p >>= 1) {
    //         if (p % 2 == 1) ans = ans * x % m;
    //         x = x * x % m;
    //     }
    //     return ans;
    // }

    public int maxFrequencyScore(int[] nums, int k) {
        final int mod = 1_000_000_007;
        long ans = 0, val = 0;
        HashMap<Integer, Integer> freq = new HashMap();
        for (int i = 0; i < nums.length; ++i) {
            if (freq.getOrDefault(nums[i], 0) > 0) val = (val - pow(nums[i], freq.get(nums[i]), mod)) % mod;
            freq.merge(nums[i], 1, Integer::sum);
            val = (val + pow(nums[i], freq.get(nums[i]), mod)) % mod;
            if (i >= k) {
                val = (val - pow(nums[i-k], freq.get(nums[i-k]), mod)) % mod;
                freq.merge(nums[i-k], -1, Integer::sum);
                if (freq.getOrDefault(nums[i-k], 0) > 0) val = (val + pow(nums[i-k], freq.get(nums[i-k]), mod)) % mod;
            }
            val = (val + mod) % mod;
            if (i >= k-1) ans = Math.max(ans, val);
        }
        return (int) ans;
    }


    /*2525. Categorize Box According to Criteria (Easy)
    Given four integers length, width, height, and mass, representing the
    dimensions and mass of a box, respectively, return a string representing
    the category of the box.
    * The box is "Bulky" if:
      + Any of the dimensions of the box is greater or equal to 10^4.
      + Or, the volume of the box is greater or equal to 10^9.
    * If the mass of the box is greater or equal to 100, it is "Heavy".
    * If the box is both "Bulky" and "Heavy", then its category is "Both".
    * If the box is neither "Bulky" nor "Heavy", then its category is "Neither".
    * If the box is "Bulky" but not "Heavy", then its category is "Bulky".
    * If the box is "Heavy" but not "Bulky", then its category is "Heavy".
    Note that the volume of the box is the product of its length, width and
    height.

    Example 1:
    Input: length = 1000, width = 35, height = 700, mass = 300
    Output: "Heavy"
    Explanation: None of the dimensions of the box is greater or equal to 10^4.
                 Its volume = 24500000 <= 10^9. So it cannot be categorized as
                 "Bulky". However mass >= 100, so the box is "Heavy". Since the
                 box is not "Bulky" but "Heavy", we return "Heavy".

    Example 2:
    Input: length = 200, width = 50, height = 800, mass = 50
    Output: "Neither"
    Explanation: None of the dimensions of the box is greater or equal to 10^4.
                 Its volume = 8 * 10^6 <= 10^9. So it cannot be categorized as
                 "Bulky". Its mass is also less than 100, so it cannot be
                 categorized as "Heavy" either.  Since its neither of the two
                 above categories, we return "Neither".

    Constraints:
    * 1 <= length, width, height <= 10^5
    * 1 <= mass <= 10^3*/

    public String categorizeBox(int length, int width, int height, int mass) {
        boolean bulky = Math.max(length, Math.max(width, height)) >= 1e4 || (long) length*width*height >= 1e9, heavy = mass >= 100;
        if (bulky && heavy) return "Both";
        if (bulky) return "Bulky";
        if (heavy) return "Heavy";
        return "Neither";
    }


    /*2527. Find Xor-Beauty of Array (Medium)
    You are given a 0-indexed integer array nums. The effective value of three
    indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]). The xor-
    beauty of the array is the XORing of the effective values of all the
    possible triplets of indices (i, j, k) where 0 <= i, j, k < n. Return the
    xor-beauty of nums. Note that:
    * val1 | val2 is bitwise OR of val1 and val2.
    * val1 & val2 is bitwise AND of val1 and val2.

    Example 1:
    Input: nums = [1,4]
    Output: 5
    Explanation: The triplets and their corresponding effective values are
                 listed below:
                 - (0,0,0) with effective value ((1 | 1) & 1) = 1
                 - (0,0,1) with effective value ((1 | 1) & 4) = 0
                 - (0,1,0) with effective value ((1 | 4) & 1) = 1
                 - (0,1,1) with effective value ((1 | 4) & 4) = 4
                 - (1,0,0) with effective value ((4 | 1) & 1) = 1
                 - (1,0,1) with effective value ((4 | 1) & 4) = 4
                 - (1,1,0) with effective value ((4 | 4) & 1) = 0
                 - (1,1,1) with effective value ((4 | 4) & 4) = 4
                 Xor-beauty of array will be bitwise XOR of all beauties =
                 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.

    Example 2:
    Input: nums = [15,45,20,2,34,35,5,44,32,30]
    Output: 34
    Explanation: The xor-beauty of the given array is 34.

    Constraints:
    1 <= nums.length <= 10^5
    1 <= nums[i] <= 10^9*/

    public int xorBeauty(int[] nums) {
        int val = 0;
        for (int x : nums) val ^= x;
        return (val | val) & val;
    }


    /*2528. Maximize the Minimum Powered City (Hard)
    You are given a 0-indexed integer array stations of length n, where
    stations[i] represents the number of power stations in the ith city. Each
    power station can provide power to every city in a fixed range. In other
    words, if the range is denoted by r, then a power station at city i can
    provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.
    * Note that |x| denotes absolute value. For example, |7 - 5| = 2 and
      |3 - 10| = 7.
    The power of a city is the total number of power stations it is being
    provided power from. The government has sanctioned building k more power
    stations, each of which can be built in any city, and have the same range
    as the pre-existing ones. Given the two integers r and k, return the
    maximum possible minimum power of a city, if the additional power stations
    are built optimally. Note that you can build the k power stations in
    multiple cities.

    Example 1:
    Input: stations = [1,2,4,5,0], r = 1, k = 2
    Output: 5
    Explanation: One of the optimal ways is to install both the power stations
                 at city 1. So stations will become [1,4,4,5,0].
                 - City 0 is provided by 1 + 4 = 5 power stations.
                 - City 1 is provided by 1 + 4 + 4 = 9 power stations.
                 - City 2 is provided by 4 + 4 + 5 = 13 power stations.
                 - City 3 is provided by 5 + 4 = 9 power stations.
                 - City 4 is provided by 5 + 0 = 5 power stations.
                 So the minimum power of a city is 5. Since it is not possible
                 to obtain a larger power, we return 5.

    Example 2:
    Input: stations = [4,4,4,4], r = 0, k = 3
    Output: 4
    Explanation: It can be proved that we cannot make the minimum power of a
                 city greater than 4.

    Constraints:
    * n == stations.length
    * 1 <= n <= 10^5
    * 0 <= stations[i] <= 10^5
    * 0 <= r <= n - 1
    * 0 <= k <= 10^9*/

    public long maxPower(int[] stations, int r, int k) {
        int n = stations.length;
        long lo = 0, hi = k + Arrays.stream(stations).asLongStream().sum();
        while (lo < hi) {
            long mid = lo + (hi-lo+1)/2, prefix = 0;
            int kk = k;
            int[] ss = stations.clone();
            boolean ok = true;
            for (int i = 0; i < n+r; ++i) {
                if (i < n) prefix += ss[i];
                if (i >= 2*r+1) prefix -= ss[i-2*r-1];
                if (i >= r && prefix < mid) {
                    if (kk < mid - prefix) {
                        ok = false;
                        break;
                    }
                    kk -= mid - prefix;
                    if (i < n) ss[i] += mid - prefix;
                    prefix = mid;
                }
            }
            if (ok) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }


    /*2529. Maximum Count of Positive Integer and Negative Integer (Easy)
    Given an array nums sorted in non-decreasing order, return the maximum
    between the number of positive integers and the number of negative integers.
    In other words, if the number of positive integers in nums is pos and the
    number of negative integers is neg, then return the maximum of pos and neg.
    Note that 0 is neither positive nor negative.

    Example 1:
    Input: nums = [-2,-1,-1,1,2,3]
    Output: 3
    Explanation: There are 3 positive integers and 3 negative integers. The
                 maximum count among them is 3.

    Example 2:
    Input: nums = [-3,-2,-1,0,0,1,2]
    Output: 3
    Explanation: There are 2 positive integers and 3 negative integers. The
                 maximum count among them is 3.

    Example 3:
    Input: nums = [5,20,66,1314]
    Output: 4
    Explanation: There are 4 positive integers and 0 negative integers. The
                 maximum count among them is 4.

    Constraints:
    * 1 <= nums.length <= 2000
    * -2000 <= nums[i] <= 2000
    * nums is sorted in a non-decreasing order.

    private static int bisect_left(int[] nums, int target) {
        int lo = 0, hi = nums.length;
        while (lo < hi) {
            int mid = lo + (hi - lo)/2;
            if (nums[mid] < target) lo = mid+1;
            else hi = mid;
        }
        return lo;
    }*/

    public int maximumCount(int[] nums) {
        int neg = bisect_left(nums, 0), pos = nums.length - bisect_left(nums, 1);
        return Math.max(neg, pos);
    }


    /*2530. Maximal Score After Applying K Operations (Medium)
    You are given a 0-indexed integer array nums and an integer k. You have a
    starting score of 0. In one operation:
    * choose an index i such that 0 <= i < nums.length,
    * increase your score by nums[i], and
    * replace nums[i] with ceil(nums[i] / 3).
    Return the maximum possible score you can attain after applying exactly k
    operations. The ceiling function ceil(val) is the least integer greater
    than or equal to val.

    Example 1:
    Input: nums = [10,10,10,10,10], k = 5
    Output: 50
    Explanation: Apply the operation to each array element exactly once. The
                 final score is 10 + 10 + 10 + 10 + 10 = 50.

    Example 2:
    Input: nums = [1,10,3,3,3], k = 3
    Output: 17
    Explanation: You can do the following operations:
                 Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your
                              score increases by 10.
                 Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your
                              score increases by 4.
                 Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your
                              score increases by 3.
                 The final score is 10 + 4 + 3 = 17.

    Constraints:
    * 1 <= nums.length, k <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public long maxKelements(int[] nums, int k) {
        long ans = 0;
        PriorityQueue<Integer> pq = new PriorityQueue(Collections.reverseOrder());
        for (int x : nums) pq.add(x);
        while (k-- > 0) {
            int val = pq.poll();
            ans += val;
            pq.add((val+2)/3);
        }
        return ans;
    }


    /*2531. Make Number of Distinct Characters Equal (Medium)
    You are given two 0-indexed strings word1 and word2. A move consists of
    choosing two indices i and j such that 0 <= i < word1.length and
    0 <= j < word2.length and swapping word1[i] with word2[j]. Return true if
    it is possible to get the number of distinct characters in word1 and word2
    to be equal with exactly one move. Return false otherwise.

    Example 1:
    Input: word1 = "ac", word2 = "b"
    Output: false
    Explanation: Any pair of swaps would yield two distinct characters in the
                 first string, and one in the second string.

    Example 2:
    Input: word1 = "abcc", word2 = "aab"
    Output: true
    Explanation: We swap index 2 of the first string with index 0 of the second
                 string. The resulting strings are word1 = "abac" and
                 word2 = "cab", which both have 3 distinct characters.

    Example 3:
    Input: word1 = "abcde", word2 = "fghij"
    Output: true
    Explanation: Both resulting strings will have 5 distinct characters,
                 regardless of which indices we swap.

    Constraints:
    * 1 <= word1.length, word2.length <= 10^5
    * word1 and word2 consist of only lowercase English letters.*/

    public boolean isItPossible(String word1, String word2) {
        HashMap<Character, Integer> freq1 = new HashMap(), freq2 = new HashMap();
        for (var ch : word1.toCharArray()) freq1.merge(ch, 1, Integer::sum);
        for (var ch : word2.toCharArray()) freq2.merge(ch, 1, Integer::sum);
        int sz1 = freq1.size(), sz2 = freq2.size();
        for (char c1 = 'a'; c1 <= 'z'; ++c1)
            for (char c2 = 'a'; c2 <= 'z'; ++c2)
                if (freq1.getOrDefault(c1, 0) > 0 && freq2.getOrDefault(c2, 0) > 0)
                    if (c1 == c2) {
                        if (sz1 == sz2) return true;
                    } else {
                        int cnt1 = sz1, cnt2 = sz2;
                        if (freq1.getOrDefault(c1, 0) == 1) --cnt1;
                        if (freq1.getOrDefault(c2, 0) == 0) ++cnt1;
                        if (freq2.getOrDefault(c1, 0) == 0) ++cnt2;
                        if (freq2.getOrDefault(c2, 0) == 1) --cnt2;
                        if (cnt1 == cnt2) return true;
                    }
        return false;
    }


    /*2532. Time to Cross a Bridge (Hard)
    There are k workers who want to move n boxes from an old warehouse to a new
    one. You are given the two integers n and k, and a 2D integer array time of
    size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].
    The warehouses are separated by a river and connected by a bridge. The old
    warehouse is on the right bank of the river, and the new warehouse is on
    the left bank of the river. Initially, all k workers are waiting on the
    left side of the bridge. To move the boxes, the ith worker (0-indexed) can :
    * Cross the bridge from the left bank (new warehouse) to the right bank
      (old warehouse) in leftToRighti minutes.
    * Pick a box from the old warehouse and return to the bridge in pickOldi
      minutes. Different workers can pick up their boxes simultaneously.
    * Cross the bridge from the right bank (old warehouse) to the left bank
      (new warehouse) in rightToLefti minutes.
    * Put the box in the new warehouse and return to the bridge in putNewi
      minutes. Different workers can put their boxes simultaneously.
    A worker i is less efficient than a worker j if either condition is met:
    * leftToRighti + rightToLefti > leftToRightj + rightToLeftj
    * leftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j
    The following rules regulate the movement of the workers through the bridge :
    * If a worker x reaches the bridge while another worker y is crossing the
      bridge, x waits at their side of the bridge.
    * If the bridge is free, the worker waiting on the right side of the bridge
      gets to cross the bridge. If more than one worker is waiting on the right
      side, the one with the lowest efficiency crosses first.
    * If the bridge is free and no worker is waiting on the right side, and at
      least one box remains at the old warehouse, the worker on the left side
      of the river gets to cross the bridge. If more than one worker is waiting
      on the left side, the one with the lowest efficiency crosses first.
    Return the instance of time at which the last worker reaches the left bank
    of the river after all n boxes have been put in the new warehouse.

    Example 1:
    Input: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]
    Output: 6
    Explanation: From 0 to 1: worker 2 crosses the bridge from the left bank to
                              the right bank.
                 From 1 to 2: worker 2 picks up a box from the old warehouse.
                 From 2 to 6: worker 2 crosses the bridge from the right bank
                              to the left bank.
                 From 6 to 7: worker 2 puts a box at the new warehouse.
                 The whole process ends after 7 minutes. We return 6 because
                 the problem asks for the instance of time at which the last
                 worker reaches the left bank.

    Example 2:
    Input: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]
    Output: 50
    Explanation: From 0  to 10: worker 1 crosses the bridge from the left bank
                                to the right bank.
                 From 10 to 20: worker 1 picks up a box from the old warehouse.
                 From 10 to 11: worker 0 crosses the bridge from the left bank
                                to the right bank.
                 From 11 to 20: worker 0 picks up a box from the old warehouse.
                 From 20 to 30: worker 1 crosses the bridge from the right bank
                                to the left bank.
                 From 30 to 40: worker 1 puts a box at the new warehouse.
                 From 30 to 31: worker 0 crosses the bridge from the right bank
                                to the left bank.
                 From 31 to 39: worker 0 puts a box at the new warehouse.
                 From 39 to 40: worker 0 crosses the bridge from the left bank
                                to the right bank.
                 From 40 to 49: worker 0 picks up a box from the old warehouse.
                 From 49 to 50: worker 0 crosses the bridge from the right bank
                                to the left bank.
                 From 50 to 58: worker 0 puts a box at the new warehouse.
                 The whole process ends after 58 minutes. We return 50 because
                 the problem asks for the instance of time at which the last
                 worker reaches the left bank.

    Constraints:
    * 1 <= n, k <= 10^4
    * time.length == k
    * time[i].length == 4
    * 1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000*/

    public int findCrossingTime(int n, int k, int[][] time) {
        int ans = 0, free = 0;
        PriorityQueue<int[]> l = new PriorityQueue<>((a, b)->(a[0]-b[0]));
        PriorityQueue<int[]> r = new PriorityQueue<>((a, b)->(a[0]-b[0]));
        PriorityQueue<int[]> ll = new PriorityQueue<>((a, b)->(a[0] != b[0] ? b[0]-a[0] : b[1]-a[1]));
        PriorityQueue<int[]> rr = new PriorityQueue<>((a, b)->(a[0] != b[0] ? b[0]-a[0] : b[1]-a[1]));
        for (int i = 0; i < time.length; ++i)
            ll.add(new int[]{time[i][0]+time[i][2], i});
        while (n > 0 || r.size() > 0 || rr.size() > 0) {
            if (rr.isEmpty() && (r.isEmpty() || r.peek()[0] > free) && (n == 0 || ll.isEmpty() && (l.isEmpty() || l.peek()[0] > free))) {
                int cand = Integer.MAX_VALUE;
                if (n > 0 && l.size() > 0) cand = Math.min(cand, l.peek()[0]);
                if (r.size() > 0) cand = Math.min(cand, r.peek()[0]);
                free = cand;
            }
            while (l.size() > 0 && l.peek()[0] <= free) {
                int i = l.poll()[1];
                ll.add(new int[] {time[i][0] + time[i][2], i});
            }
            while (r.size() > 0 && r.peek()[0] <= free) {
                int i = r.poll()[1];
                rr.add(new int[] {time[i][0] + time[i][2], i});
            }
            if (rr.size() > 0) {
                int i = rr.poll()[1];
                free += time[i][2];
                if (n > 0) l.add(new int[] {free+time[i][3], i});
                else ans = Math.max(ans, free);
            } else {
                int i = ll.poll()[1];
                free += time[i][0];
                r.add(new int[] {free+time[i][1], i});
                --n;
            }
        }
        return ans;
    }


    /*2533. Number of Good Binary Strings (Medium)
    You are given four integers minLenght, maxLength, oneGroup and zeroGroup. A
    binary string is good if it satisfies the following conditions:
    * The length of the string is in the range [minLength, maxLength].
    * The size of each block of consecutive 1's is a multiple of oneGroup.
      + For example in a binary string 00110111100 sizes of each block of
        consecutive ones are [2,4].
    * The size of each block of consecutive 0's is a multiple of zeroGroup.
      + For example, in a binary string 00110111100 sizes of each block of
        consecutive ones are [2,1,2].
    Return the number of good binary strings. Since the answer may be too large,
    return it modulo 10^9 + 7. Note that 0 is considered a multiple of all the
    numbers.

    Example 1:
    Input: minLength = 2, maxLength = 3, oneGroup = 1, zeroGroup = 2
    Output: 5
    Explanation: There are 5 good binary strings in this example: "00", "11",
                 "001", "100", and "111". It can be proven that there are only
                 5 good strings satisfying all conditions.

    Example 2:
    Input: minLength = 4, maxLength = 4, oneGroup = 4, zeroGroup = 3
    Output: 1
    Explanation: There is only 1 good binary string in this example: "1111". It
                 can be proven that there is only 1 good string satisfying all
                 conditions.

    Constraints:
    * 1 <= minLength <= maxLength <= 10^5
    * 1 <= oneGroup, zeroGroup <= maxLength*/

    public int goodBinaryStrings(int minLength, int maxLength, int oneGroup, int zeroGroup) {
        long[] dp = new long[maxLength+1];
        for (int i = maxLength; i >= 0; --i) {
            if (minLength <= i) ++dp[i];
            if (i + oneGroup <= maxLength) dp[i] = (dp[i] + dp[i+oneGroup]) % 1_000_000_007;
            if (i + zeroGroup <= maxLength) dp[i] = (dp[i] + dp[i+zeroGroup]) % 1_000_000_007;
        }
        return (int) dp[0];
    }


    /*2534. Time Taken to Cross the Door (Hard)
    There are n persons numbered from 0 to n - 1 and a door. Each person can
    enter or exit through the door once, taking one second. You are given a
    non-decreasing integer array arrival of size n, where arrival[i] is the
    arrival time of the ith person at the door. You are also given an array
    state of size n, where state[i] is 0 if person i wants to enter through the
    door or 1 if they want to exit through the door. If two or more persons
    want to use the door at the same time, they follow the following rules:
    * If the door was not used in the previous second, then the person who
      wants to exit goes first.
    * If the door was used in the previous second for entering, the person who
      wants to enter goes first.
    * If the door was used in the previous second for exiting, the person who
      wants to exit goes first.
    * If multiple persons want to go in the same direction, the person with the
      smallest index goes first.
    Return an array answer of size n where answer[i] is the second at which the
    ith person crosses the door.

    Note that:
    * Only one person can cross the door at each second.
    * A person may arrive at the door and wait without entering or exiting to
      follow the mentioned rules.

    Example 1:
    Input: arrival = [0,1,1,2,4], state = [0,1,0,0,1]
    Output: [0,3,1,2,4]
    Explanation: At each second we have the following:
                 - At t = 0: Person 0 is the only one who wants to enter, so
                             they just enter through the door.
                 - At t = 1: Person 1 wants to exit, and person 2 wants to
                             enter. Since the door was used the previous second
                             for entering, person 2 enters.
                 - At t = 2: Person 1 still wants to exit, and person 3 wants
                             to enter. Since the door was used the previous
                             second for entering, person 3 enters.
                 - At t = 3: Person 1 is the only one who wants to exit, so
                             they just exit through the door.
                 - At t = 4: Person 4 is the only one who wants to exit, so
                             they just exit through the door.

    Example 2:
    Input: arrival = [0,0,0], state = [1,0,1]
    Output: [0,2,1]
    Explanation: At each second we have the following:
                 - At t = 0: Person 1 wants to enter while persons 0 and 2 want
                             to exit. Since the door was not used in the
                             previous second, the persons who want to exit get
                             to go first. Since person 0 has a smaller index,
                             they exit first.
                 - At t = 1: Person 1 wants to enter, and person 2 wants to
                             exit. Since the door was used in the previous
                             second for exiting, person 2 exits.
                 - At t = 2: Person 1 is the only one who wants to enter, so
                             they just enter through the door.

    Constraints:
    * n == arrival.length == state.length
    * 1 <= n <= 10^5
    * 0 <= arrival[i] <= n
    * arrival is sorted in non-decreasing order.
    * state[i] is either 0 or 1.*/

    public int[] timeTaken(int[] arrival, int[] state) {
        int n = arrival.length;
        int[] ans = new int[n];
        Deque<Integer> qin = new ArrayDeque<>(), qout = new ArrayDeque<>();
        boolean enter = false;
        for (int i = 0, time = 0; i < n || !qin.isEmpty() || !qout.isEmpty(); ) {
            if (i == n || time < arrival[i]) {
                if (!qin.isEmpty() || !qout.isEmpty()) {
                    if (!qin.isEmpty() && (qout.isEmpty() || enter)) {
                        ans[qin.pollFirst()] = time++;
                        enter = true;
                    } else {
                        ans[qout.pollFirst()] = time++;
                        enter = false;
                    }
                } else {
                    if (time+1 <= arrival[i]) enter = false;
                    time = arrival[i];
                }
            }
            for (; i < n && time == arrival[i]; ++i) {
                if (state[i] == 0) qin.addLast(i);
                else qout.addLast(i);
            }
        }
        return ans;
    }


    /*2535. Difference Between Element Sum and Digit Sum of an Array (Easy)
    You are given a positive integer array nums.
    * The element sum is the sum of all the elements in nums.
    * The digit sum is the sum of all the digits (not necessarily distinct)
      that appear in nums.
    Return the absolute difference between the element sum and digit sum of
    nums. Note that the absolute difference between two integers x and y is
    defined as |x - y|.

    Example 1:
    Input: nums = [1,15,6,3]
    Output: 9
    Explanation: The element sum of nums is 1 + 15 + 6 + 3 = 25. The digit sum
                 of nums is 1 + 1 + 5 + 6 + 3 = 16. The absolute difference
                 between the element sum and digit sum is |25 - 16| = 9.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: The element sum of nums is 1 + 2 + 3 + 4 = 10. The digit sum
                 of nums is 1 + 2 + 3 + 4 = 10. The absolute difference between
                 the element sum and digit sum is |10 - 10| = 0.

    Constraints:
    * 1 <= nums.length <= 2000
    * 1 <= nums[i] <= 2000*/

    public int differenceOfSum(int[] nums) {
        int ans = 0;
        for (int x : nums) {
            ans += x;
            for (; x > 0; x /= 10)
                ans -= x % 10;
        }
        return ans;
    }


    /*2536. Increment Submatrices by One (Medium)
    You are given a positive integer n, indicating that we initially have an
    n x n 0-indexed integer matrix mat filled with zeroes. You are also given a
    2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i],
    you should do the following operation:
    * Add 1 to every element in the submatrix with the top left corner
      (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1
      to mat[x][y] for for all row1i <= x <= row2i and col1i <= y <= col2i.
    Return the matrix mat after performing every query.

    Example 1:
    Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]
    Output: [[1,1,0],[1,2,1],[0,1,1]]
    Explanation: The diagram above shows the initial matrix, the matrix after
                 the first query, and the matrix after the second query.
                 - In the first query, we add 1 to every element in the
                   submatrix with the top left corner (1, 1) and bottom right
                   corner (2, 2).
                 - In the second query, we add 1 to every element in the
                   submatrix with the top left corner (0, 0) and bottom right
                   corner (1, 1).

    Example 2:
    Input: n = 2, queries = [[0,0,1,1]]
    Output: [[1,1],[1,1]]
    Explanation: The diagram above shows the initial matrix and the matrix
                 after the first query.
                 - In the first query we add 1 to every element in the matrix.

    Constraints:
    * 1 <= n <= 500
    * 1 <= queries.length <= 10^4
    * 0 <= row1i <= row2i < n
    * 0 <= col1i <= col2i < n*/

    public int[][] rangeAddQueries(int n, int[][] queries) {
        int[][] ans = new int[n][n];
        for (int[] q : queries) {
            int i = q[0], j = q[1], ii = q[2], jj = q[3];
            ++ans[i][j];
            if (ii+1 < n) --ans[ii+1][j];
            if (jj+1 < n) --ans[i][jj+1];
            if (ii+1 < n && jj+1 < n) ++ans[ii+1][jj+1];
        }
        for (int i = 0; i < n; ++i) {
            int prefix = 0;
            for (int j = 0; j < n; ++j) {
                prefix += ans[i][j];
                ans[i][j] = prefix;
                if (i > 0) ans[i][j] += ans[i-1][j];
            }
        }
        return ans;
    }


    /*2537. Count the Number of Good Subarrays (Medium)
    Given an integer array nums and an integer k, return the number of good
    subarrays of nums. A subarray arr is good if it there are at least k pairs
    of indices (i, j) such that i < j and arr[i] == arr[j]. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,1,1,1,1], k = 10
    Output: 1
    Explanation: The only good subarray is the array nums itself.

    Example 2:
    Input: nums = [3,1,4,3,2,2,4], k = 2
    Output: 4
    Explanation: There are 4 different good subarrays:
                 - [3,1,4,3,2,2] that has 2 pairs.
                 - [3,1,4,3,2,2,4] that has 3 pairs.
                 - [1,4,3,2,2,4] that has 2 pairs.
                 - [4,3,2,2,4] that has 2 pairs.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i], k <= 10^9*/

    public long countGood(int[] nums, int k) {
        HashMap<Integer, Integer> freq = new HashMap<>();
        long ans = 0;
        for (int i = 0, ii = 0; i < nums.length; ++i) {
            k -= freq.getOrDefault(nums[i], 0);
            freq.put(nums[i], freq.getOrDefault(nums[i], 0)+1);
            for (; k <= 0; ++ii) {
                freq.put(nums[ii], freq.get(nums[ii])-1);
                k += freq.get(nums[ii]);
            }
            ans += ii;
        }
        return ans;
    }


    /*2538. Difference Between Maximum and Minimum Price Sum (Hard)
    There exists an undirected and initially unrooted tree with n nodes indexed
    from 0 to n - 1. You are given the integer n and a 2D integer array edges
    of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge
    between nodes ai and bi in the tree. Each node has an associated price. You
    are given an integer array price, where price[i] is the price of the ith
    node. The price sum of a given path is the sum of the prices of all nodes
    lying on that path. The tree can be rooted at any node root of your choice.
    The incurred cost after choosing root is the difference between the maximum
    and minimum price sum amongst all paths starting at root. Return the
    maximum possible cost amongst all possible root choices.

    Example 1:
    Input: n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]
    Output: 24
    Explanation: The diagram above denotes the tree after rooting it at node 2.
                 The first part (colored in red) shows the path with the
                 maximum price sum. The second part (colored in blue) shows the
                 path with the minimum price sum.
                 - The first path contains nodes [2,1,3,4]: the prices are
                   [7,8,6,10], and the sum of the prices is 31.
                 - The second path contains the node [2] with the price [7].
                 The difference between the maximum and minimum price sum is 24.
                 It can be proved that 24 is the maximum cost.

    Example 2:
    Input: n = 3, edges = [[0,1],[1,2]], price = [1,1,1]
    Output: 2
    Explanation: The diagram above denotes the tree after rooting it at node 0.
                 The first part (colored in red) shows the path with the
                 maximum price sum. The second part (colored in blue) shows the
                 path with the minimum price sum.
                 - The first path contains nodes [0,1,2]: the prices are
                   [1,1,1], and the sum of the prices is 3.
                 - The second path contains node [0] with a price [1].
                 The difference between the maximum and minimum price sum is 2.
                 It can be proved that 2 is the maximum cost.

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * 0 <= ai, bi <= n - 1
    * edges represents a valid tree.
    * price.length == n
    * 1 <= price[i] <= 10^5*/

    long ans = 0;

    private long[] dfs(int u, int p, List<Integer>[] tree, int[] price) {
        long x = price[u], y = 0;
        for (var v : tree[u]) {
            if (v != p) {
                var elem = dfs(v, u, tree, price);
                long xx = elem[0], yy = elem[1];
                ans = Math.max(ans, x + yy);
                ans = Math.max(ans, xx + y);
                x = Math.max(x, xx + price[u]);
                y = Math.max(y, yy + price[u]);
            }
        }
        return new long[]{x, y};
    }

    public long maxOutput(int n, int[][] edges, int[] price) {
        List<Integer>[] tree = new ArrayList[n];
        for (int u = 0; u < n; ++u) tree[u] = new ArrayList();
        for (var e : edges) {
            tree[e[0]].add(e[1]);
            tree[e[1]].add(e[0]);
        }
        dfs(0, -1, tree, price);
        return ans;
    }


    /*2539. Count the Number of Good Subsequences (Medium)
    A subsequence of a string is good if it is not empty and the frequency of
    each one of its characters is the same. Given a string s, return the number
    of good subsequences of s. Since the answer may be too large, return it
    modulo 10^9 + 7. A subsequence is a string that can be derived from another
    string by deleting some or no characters without changing the order of the
    remaining characters.

    Example 1:
    Input: s = "aabb"
    Output: 11
    Explanation: The total number of subsequences is 24. There are five
                 subsequences which are not good: "aabb", "aabb", "aabb",
                 "aabb", and the empty subsequence. Hence, the number of good
                 subsequences is 24-5 = 11.

    Example 2:
    Input: s = "leet"
    Output: 12
    Explanation: There are four subsequences which are not good: "leet", "leet",
                 "leet", and the empty subsequence. Hence, the number of good
                 subsequences is 24-4 = 12.

    Example 3:
    Input: s = "abcd"
    Output: 15
    Explanation: All of the non-empty subsequences are good subsequences.
                 Hence, the number of good subsequences is 24-1 = 15.

    Constraints:
    * 1 <= s.length <= 10^4
    * s consists of only lowercase English letters.*/

    public int countGoodSubsequences(String s) {
        final int mod = 1_000_000_007;
        int[] freq = new int[26];
        for (var ch : s.toCharArray()) ++freq[ch-'a'];
        long[] coef = new long[26], inv = new long[s.length()+1];
        Arrays.fill(coef, 1);
        inv[0] = inv[1] = 1;
        long ans = 0;
        for (int x = 1; x <= s.length(); ++x) {
            long val = 1;
            if (x >= 2) inv[x] = mod - mod/x * inv[mod%x] % mod;
            for (int i = 0; i < 26; ++i) {
                coef[i] = coef[i] * (freq[i]-x+1) % mod;
                coef[i] = coef[i] * inv[x] % mod;
                val = val * (1+coef[i]) % mod;
            }
            ans = (ans + val - 1) % mod;
        }
        return (int) ans;
    }


    /*2540. Minimum Common Value (Easy)
    Given two integer arrays nums1 and nums2, sorted in non-decreasing order,
    return the minimum integer common to both arrays. If there is no common
    integer amongst nums1 and nums2, return -1. Note that an integer is said
    to be common to nums1 and nums2 if both arrays have at least one
    occurrence of that integer.

    Example 1:
    Input: nums1 = [1,2,3], nums2 = [2,4]
    Output: 2
    Explanation: The smallest element common to both arrays is 2, so we return
                 2.

    Example 2:
    Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
    Output: 2
    Explanation: There are two common elements in the array 2 and 3 out of
                 which 2 is the smallest, so 2 is returned.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 10^5
    * 1 <= nums1[i], nums2[j] <= 10^9
    * Both nums1 and nums2 are sorted in non-decreasing order.*/

    public int getCommon(int[] nums1, int[] nums2) {
        for (int i = 0, ii = 0; i < nums1.length && ii < nums2.length; ) {
            if (nums1[i] < nums2[ii]) ++i;
            else if (nums1[i] == nums2[ii]) return nums1[i];
            else ++ii;
        }
        return -1;
    }


    /*2541. Minimum Operations to Make Array Equal II (Medium)
    You are given two integer arrays nums1 and nums2 of equal length n and an
    integer k. You can perform the following operation on nums1:
    * Choose two indexes i and j and increment nums1[i] by k and decrement
      nums1[j] by k. In other words, nums1[i] = nums1[i] + k and
      nums1[j] = nums1[j] - k.
    nums1 is said to be equal to nums2 if for all indices i such that
    0 <= i < n, nums1[i] == nums2[i]. Return the minimum number of operations
    required to make nums1 equal to nums2. If it is impossible to make them
    equal, return -1.

    Example 1:
    Input: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3
    Output: 2
    Explanation: In 2 operations, we can transform nums1 to nums2. 1st
                 operation: i = 2, j = 0. After applying the operation,
                 nums1 = [1,3,4,4]. 2nd operation: i = 2, j = 3. After applying
                 the operation, nums1 = [1,3,7,1]. One can prove that it is
                 impossible to make arrays equal in fewer operations.

    Example 2:
    Input: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1
    Output: -1
    Explanation: It can be proved that it is impossible to make the two arrays
                 equal.

    Constraints:
    * n == nums1.length == nums2.length
    * 2 <= n <= 10^5
    * 0 <= nums1[i], nums2[j] <= 10^9
    * 0 <= k <= 10^5*/

    public long minOperations(int[] nums1, int[] nums2, int k) {
        long ans = 0, total = 0;
        for (int i = 0; i < nums1.length; ++i) {
            int diff = nums1[i] - nums2[i];
            if (k == 0 && diff > 0 || k > 0 && diff % k != 0) return -1;
            if (k > 0) ans += Math.abs(diff) / k;
            total += diff;
        }
        return total == 0 ? ans/2 : -1;
    }


    /*2542. Maximum Subsequence Score (Medium)
    You are given two 0-indexed integer arrays nums1 and nums2 of equal length
    n and a positive integer k. You must choose a subsequence of indices from
    nums1 of length k. For chosen indices i0, i1, ..., ik - 1, your score is
    defined as:
    * The sum of the selected elements from nums1 multiplied with the minimum
      of the selected elements from nums2.
    * It can defined simply as:
      (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).
    Return the maximum possible score. A subsequence of indices of an array is
    a set that can be derived from the set {0, 1, ..., n-1} by deleting some or
    no elements.

    Example 1:
    Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
    Output: 12
    Explanation: The four possible subsequence scores are:
                 - We choose the indices 0, 1, and 2 with
                   score = (1+3+3) * min(2,1,3) = 7.
                 - We choose the indices 0, 1, and 3 with
                   score = (1+3+2) * min(2,1,4) = 6.
                 - We choose the indices 0, 2, and 3 with
                   score = (1+3+2) * min(2,3,4) = 12.
                 - We choose the indices 1, 2, and 3 with
                   score = (3+3+2) * min(1,3,4) = 8.
                 Therefore, we return the max score, which is 12.

    Example 2:
    Input: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1
    Output: 30
    Explanation: Choosing index 2 is optimal:
                 nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible
                 score.

    Constraints:
    * n == nums1.length == nums2.length
    * 1 <= n <= 10^5
    * 0 <= nums1[i], nums2[j] <= 10^5
    * 1 <= k <= n*/

    public long maxScore(int[] nums1, int[] nums2, int k) {
        int n = nums1.length;
        int[][] aug = new int[n][2];
        for (int i = 0; i < n; ++i) {
            aug[i][0] = nums1[i];
            aug[i][1] = nums2[i];
        }
        Arrays.sort(aug, new Comparator<int[]>(){
            public int compare(int[] lhs, int[] rhs) {
                return -Integer.compare(lhs[1], rhs[1]);
            }
        });
        PriorityQueue<Integer> pq = new PriorityQueue();
        long ans = 0, total = 0;
        for (int i = 0; i < aug.length; ++i) {
            total += aug[i][0];
            pq.add(aug[i][0]);
            if (i >= k) total -= pq.poll();
            if (i >= k-1) ans = Math.max(ans, total * aug[i][1]);
        }
        return ans;
    }


    /*2543. Check if Point Is Reachable (Hard)
    There exists an infinitely large grid. You are currently at point (1, 1),
    and you need to reach the point (targetX, targetY) using a finite number of
    steps. In one step, you can move from point (x, y) to any one of the
    following points: (x, y - x)
                      (x - y, y)
                      (2 * x, y)
                      (x, 2 * y)
    Given two integers targetX and targetY representing the X-coordinate and Y-
    coordinate of your final position, return true if you can reach the point
    from (1, 1) using some number of steps, and false otherwise.

    Example 1:
    Input: targetX = 6, targetY = 9
    Output: false
    Explanation: It is impossible to reach (6,9) from (1,1) using any sequence
                 of moves, so false is returned.

    Example 2:
    Input: targetX = 4, targetY = 7
    Output: true
    Explanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) ->
                 (1,7) -> (2,7) -> (4,7).

    Constraints: 1 <= targetX, targetY <= 10^9*/

    public boolean isReachable(int targetX, int targetY) {
        int g = BigInteger.valueOf(targetX).gcd(BigInteger.valueOf(targetY)).intValue();
        return (g & (g-1)) == 0;
    }


    /*2544. Alternating Digit Sum (Easy)
    You are given a positive integer n. Each digit of n has a sign according to
    the following rules:
    * The most significant digit is assigned a positive sign.
    * Each other digit has an opposite sign to its adjacent digits.
    Return the sum of all digits with their corresponding sign.

    Example 1:
    Input: n = 521
    Output: 4
    Explanation: (+5) + (-2) + (+1) = 4.

    Example 2:
    Input: n = 111
    Output: 1
    Explanation: (+1) + (-1) + (+1) = 1.

    Example 3:
    Input: n = 886996
    Output: 0
    Explanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.

    Constraints: 1 <= n <= 10^9*/

    public int alternateDigitSum(int n) {
        int ans = 0, sign = 1;
        for (; n > 0; n /= 10) {
            sign *= -1;
            ans += (n % 10) * sign;
        }
        return ans * sign;
    }


    /*2545. Sort the Students by Their Kth Score (Medium)
    There is a class with m students and n exams. You are given a 0-indexed
    m x n integer matrix score, where each row represents one student and
    score[i][j] denotes the score the ith student got in the jth exam. The
    matrix score contains distinct integers only. You are also given an integer
    k. Sort the students (i.e., the rows of the matrix) by their scores in the
    kth (0-indexed) exam from the highest to the lowest. Return the matrix
    after sorting it.

    Example 1:
    Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
    Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
    Explanation: In the above diagram, S denotes the student, while E denotes
                 the exam.
                 - The student with index 1 scored 11 in exam 2, which is the
                   highest score, so they got first place.
                 - The student with index 0 scored 9 in exam 2, which is the
                   second highest score, so they got second place.
                 - The student with index 2 scored 3 in exam 2, which is the
                   lowest score, so they got third place.

    Example 2:
    Input: score = [[3,4],[5,6]], k = 0
    Output: [[5,6],[3,4]]
    Explanation: In the above diagram, S denotes the student, while E denotes
                 the exam.
                 - The student with index 1 scored 5 in exam 0, which is the
                   highest score, so they got first place.
                 - The student with index 0 scored 3 in exam 0, which is the
                   lowest score, so they got second place.

    Constraints:
    * m == score.length
    * n == score[i].length
    * 1 <= m, n <= 250
    * 1 <= score[i][j] <= 10^5
    * score consists of distinct integers.
    * 0 <= k < n*/

    public int[][] sortTheStudents(int[][] score, int k) {
        Arrays.sort(score, (a, b) -> (b[k] - a[k]));
        return score;
    }


    /*2546. Apply Bitwise Operations to Make Strings Equal (Medium)
    You are given two 0-indexed binary strings s and target of the same length
    n. You can do the following operation on s any number of times:
    * Choose two different indices i and j where 0 <= i, j < n.
    * Simultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR
      s[j]).
    For example, if s = "0110", you can choose i = 0 and j = 2, then
    simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with
    (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = "1110". Return true if
    you can make the string s equal to target, or false otherwise.

    Example 1:
    Input: s = "1010", target = "0110"
    Output: true
    Explanation: We can do the following operations:
                 - Choose i = 2 and j = 0. We have now s = "0010".
                 - Choose i = 2 and j = 1. We have now s = "0110".
                 Since we can make s equal to target, we return true.

    Example 2:
    Input: s = "11", target = "00"
    Output: false
    Explanation: It is not possible to make s equal to target with any number
                 of operations.

    Constraints:
    * n == s.length == target.length
    * 2 <= n <= 10^5
    * s and target consist of only the digits 0 and 1.*/

    public boolean makeStringsEqual(String s, String target) {
        return s.contains("1") == target.contains("1");
    }


    /*2547. Minimum Cost to Split an Array (Hard)
    You are given an integer array nums and an integer k. Split the array into
    some number of non-empty subarrays. The cost of a split is the sum of the
    importance value of each subarray in the split. Let trimmed(subarray) be
    the version of the subarray where all numbers which appear only once are
    removed.
    * For example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].
    The importance value of a subarray is k + trimmed(subarray).length.
    * For example, if a subarray is [1,2,3,3,3,4,4], then
      trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this
      subarray will be k + 5.
    Return the minimum possible cost of a split of nums. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,1,2,1,3,3], k = 2
    Output: 8
    Explanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].
                 The importance value of [1,2] is 2 + (0) = 2.
                 The importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.
                 The cost of the split is 2 + 6 = 8. It can be shown that this
                 is the minimum possible cost among all the possible splits.

    Example 2:
    Input: nums = [1,2,1,2,1], k = 2
    Output: 6
    Explanation: We split nums to have two subarrays: [1,2], [1,2,1].
                 The importance value of [1,2] is 2 + (0) = 2.
                 The importance value of [1,2,1] is 2 + (2) = 4.
                 The cost of the split is 2 + 4 = 6. It can be shown that this
                 is the minimum possible cost among all the possible splits.

    Example 3:
    Input: nums = [1,2,1,2,1], k = 5
    Output: 10
    Explanation: We split nums to have one subarray: [1,2,1,2,1].
                 The importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.
                 The cost of the split is 10. It can be shown that this is the
                 minimum possible cost among all the possible splits.

    Constraints:
    * 1 <= nums.length <= 1000
    * 0 <= nums[i] < nums.length
    * 1 <= k <= 10^9*/

    public int minCost(int[] nums, int k) {
        int n = nums.length;
        int[] dp = new int[n+1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[n] = 0;
        for (int i = n-1; i >= 0; --i) {
            int val = 0;
            int[] freq = new int[n];
            for (int ii = i; ii < n; ++ii) {
                ++freq[nums[ii]];
                if (freq[nums[ii]] == 2) val += 2;
                else if (freq[nums[ii]] > 2) ++val;
                dp[i] = Math.min(dp[i], k + val + dp[ii+1]);
            }
        }
        return dp[0];
    }


    /*2548. Maximum Price to Fill a Bag (Medium)
    You are given a 2D integer array items where items[i] = [pricei, weighti]
    denotes the price and weight of the ith item, respectively. You are also
    given a positive integer capacity. Each item can be divided into two items
    with ratios part1 and part2, where part1 + part2 == 1.
    * The weight of the first item is weighti * part1 and the price of the
      first item is pricei * part1.
    * Similarly, the weight of the second item is weighti * part2 and the price
      of the second item is pricei * part2.
    Return the maximum total price to fill a bag of capacity capacity with
    given items. If it is impossible to fill a bag return -1. Answers within
    10^-5 of the actual answer will be considered accepted.

    Example 1:
    Input: items = [[50,1],[10,8]], capacity = 5
    Output: 55.00000
    Explanation: We divide the 2nd item into two parts with part1 = 0.5 and
                 part2 = 0.5. The price and weight of the 1st item are 5, 4.
                 And similarly, the price and the weight of the 2nd item are
                 5, 4. The array items after operation becomes
                 [[50,1],[5,4],[5,4]]. To fill a bag with capacity 5 we take
                 the 1st element with a price of 50 and the 2nd element with a
                 price of 5. It can be proved that 55.0 is the maximum total
                 price that we can achieve.

    Example 2:
    Input: items = [[100,30]], capacity = 50
    Output: -1.00000
    Explanation: It is impossible to fill a bag with the given item.

    Constraints:
    * 1 <= items.length <= 10^5
    * items[i].length == 2
    * 1 <= pricei, weighti <= 10^4
    * 1 <= capacity <= 10^9*/

    public double maxPrice(int[][] items, int capacity) {
        double ans = 0;
        Arrays.sort(items, (a, b) -> Double.compare((double) b[0]/b[1], (double) a[0]/a[1]));
        for (var item : items) {
            double p = item[0];
            if (item[1] > capacity) p *= (double) capacity/item[1];
            ans += p;
            capacity -= Math.min(item[1], capacity);
            if (capacity == 0) break;
        }
        return capacity == 0 ? ans : -1;
    }


    /*2549. Count Distinct Numbers on Board (Easy)
    You are given a positive integer n, that is initially placed on a board.
    Every day, for 10^9 days, you perform the following procedure:
    * For each number x present on the board, find all numbers 1 <= i <= n such
      that x % i == 1.
    * Then, place those numbers on the board.
    Return the number of distinct integers present on the board after 10^9 days
    have elapsed.

    Note:
    * Once a number is placed on the board, it will remain on it until the end.
    * % stands for the modulo operation. For example, 14 % 3 is 2.

    Example 1:
    Input: n = 5
    Output: 4
    Explanation: Initially, 5 is present on the board. The next day, 2 and 4
                 will be added since 5 % 2 == 1 and 5 % 4 == 1. After that day,
                 3 will be added to the board because 4 % 3 == 1. At the end of
                 a billion days, the distinct numbers on the board will be 2, 3,
                 4, and 5.

    Example 2:
    Input: n = 3
    Output: 2
    Explanation: Since 3 % 2 == 1, 2 will be added to the board. After a
                 billion days, the only two distinct numbers on the board are 2
                 and 3.

    Constraints: 1 <= n <= 100*/

    public int distinctIntegers(int n) {
        return n > 1 ? n-1 : 1;
    }


    /*2550. Count Collisions of Monkeys on a Polygon (Medium)
    There is a regular convex polygon with n vertices. The vertices are labeled
    from 0 to n - 1 in a clockwise direction, and each vertex has exactly one
    monkey. The following figure shows a convex polygon of 6 vertices. Each
    monkey moves simultaneously to a neighboring vertex. A neighboring vertex
    for a vertex i can be:
    * the vertex (i + 1) % n in the clockwise direction, or
    * the vertex (i - 1 + n) % n in the counter-clockwise direction.
    A collision happens if at least two monkeys reside on the same vertex after
    the movement. Return the number of ways the monkeys can move so that at
    least one collision happens. Since the answer may be very large, return it
    modulo 10^9 + 7. Note that each monkey can only move once.

    Example 1:
    Input: n = 3
    Output: 6
    Explanation: There are 8 total possible movements. Two ways such that they
                 collide at some point are:
                 - Monkey 1 moves in a clockwise direction; monkey 2 moves in
                   an anticlockwise direction; monkey 3 moves in a clockwise
                   direction. Monkeys 1 and 2 collide.
                 - Monkey 1 moves in an anticlockwise direction; monkey 2 moves
                   in an anticlockwise direction; monkey 3 moves in a clockwise
                   direction. Monkeys 1 and 3 collide.
                 It can be shown 6 total movements result in a collision.

    Example 2:
    Input: n = 4
    Output: 14
    Explanation: It can be shown that there are 14 ways for the monkeys to
                 collide.

    Constraints: 3 <= n <= 10^9*/

    private static long pow(long x, int p, int mod) {
        long ans = 1;
        for (; p > 0; p >>= 1) {
            if (p % 2 == 1) ans = ans * x % mod;
            x = x * x % mod;
        }
        return ans;
    }

    public int monkeyMove(int n) {
        final int mod = 1_000_000_007;
        return (int) (pow(2, n, mod) - 2 + mod) % mod;
    }


    /*2551. Put Marbles in Bags (Hard)
    You have k bags. You are given a 0-indexed integer array weights where
    weights[i] is the weight of the ith marble. You are also given the integer
    k. Divide the marbles into the k bags according to the following rules:
    * No bag is empty.
    * If the ith marble and jth marble are in a bag, then all marbles with an
      index between the ith and jth indices should also be in that same bag.
    * If a bag consists of all the marbles with an index from i to j
      inclusively, then the cost of the bag is weights[i] + weights[j].
    The score after distributing the marbles is the sum of the costs of all the
    k bags. Return the difference between the maximum and minimum scores among
    marble distributions.

    Example 1:
    Input: weights = [1,3,5,1], k = 2
    Output: 4
    Explanation: The distribution [1],[3,5,1] results in the minimal score of
                 (1+1) + (3+1) = 6. The distribution [1,3],[5,1], results in
                 the maximal score of (1+3) + (5+1) = 10. Thus, we return their
                 difference 10 - 6 = 4.

    Example 2:
    Input: weights = [1, 3], k = 2
    Output: 0
    Explanation: The only distribution possible is [1],[3]. Since both the
                 maximal and minimal score are the same, we return 0.

    Constraints:
    * 1 <= k <= weights.length <= 10^5
    * 1 <= weights[i] <= 10^9*/

    public long putMarbles(int[] weight, int k) {
        if (k == 1) return 0;
        int n = weight.length;
        int[] vals = new int[n-1];
        for (int i = 0; i < n-1; ++i)
            vals[i] = weight[i] + weight[i+1];
        Arrays.sort(vals);
        long diff = 0;
        for (int i = 0; i < k-1; ++i)
            diff += vals[n-2-i] - vals[i];
        return diff;
    }


    /*2552. Count Increasing Quadruplets (Hard)
    Given a 0-indexed integer array nums of size n containing all numbers from
    1 to n, return the number of increasing quadruplets. A quadruplet
    (i, j, k, l) is increasing if:
    * 0 <= i < j < k < l < n, and
    * nums[i] < nums[k] < nums[j] < nums[l].

    Example 1:
    Input: nums = [1,3,2,4,5]
    Output: 2
    Explanation: - When i = 0, j = 1, k = 2, and l = 3,
                   nums[i] < nums[k] < nums[j] < nums[l].
                 - When i = 0, j = 1, k = 2, and l = 4,
                   nums[i] < nums[k] < nums[j] < nums[l].
                 There are no other quadruplets, so we return 2.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: There exists only one quadruplet with i = 0, j = 1, k = 2,
                 l = 3, but since nums[j] < nums[k], we return 0.

    Constraints:
    * 4 <= nums.length <= 4000
    * 1 <= nums[i] <= nums.length
    * All the integers of nums are unique. nums is a permutation.*/

    public long countQuadruplets(int[] nums) {
        long ans = 0;
        long[] dp = new long[nums.length];
        for (int j = 0; j < nums.length; ++j) {
            int prev = 0;
            for (int i = 0; i < j; ++i)
                if (nums[i] < nums[j]) {
                    ++prev;
                    ans += dp[i];
                } else if (nums[i] > nums[j]) dp[i] += prev;
        }
        return ans;
    }


    /*2553. Separate the Digits in an Array (Easy)
    Given an array of positive integers nums, return an array answer that
    consists of the digits of each integer in nums after separating them in the
    same order they appear in nums. To separate the digits of an integer is to
    get all the digits it has in the same order. For example, for the integer
    10921, the separation of its digits is [1,0,9,2,1].

    Example 1:
    Input: nums = [13,25,83,77]
    Output: [1,3,2,5,8,3,7,7]
    Explanation: - The separation of 13 is [1,3].
                 - The separation of 25 is [2,5].
                 - The separation of 83 is [8,3].
                 - The separation of 77 is [7,7].
                 answer = [1,3,2,5,8,3,7,7]. Note that answer contains the
                 separations in the same order.

    Example 2:
    Input: nums = [7,1,3,9]
    Output: [7,1,3,9]
    Explanation: The separation of each integer in nums is itself.
                 answer = [7,1,3,9].

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5*/

    public int[] separateDigits(int[] nums) {
        List<Integer> ans = new ArrayList();
        for (int i = nums.length-1; i >= 0; --i)
            for (int x = nums[i]; x > 0; x /= 10)
                ans.add(x % 10);
        Collections.reverse(ans);
        return ans.stream().mapToInt(i->i).toArray();
    }


    /*2554. Maximum Number of Integers to Choose From a Range I (Medium)
    You are given an integer array banned and two integers n and maxSum. You
    are choosing some number of integers following the below rules:
    * The chosen integers have to be in the range [1, n].
    * Each integer can be chosen at most once.
    * The chosen integers should not be in the array banned.
    * The sum of the chosen integers should not exceed maxSum.
    Return the maximum number of integers you can choose following the
    mentioned rules.

    Example 1:
    Input: banned = [1,6,5], n = 5, maxSum = 6
    Output: 2
    Explanation: You can choose the integers 2 and 4. 2 and 4 are from the
                 range [1, 5], both did not appear in banned, and their sum is
                 6, which did not exceed maxSum.

    Example 2:
    Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1
    Output: 0
    Explanation: You cannot choose any integer while following the mentioned
                 conditions.

    Example 3:
    Input: banned = [11], n = 7, maxSum = 50
    Output: 7
    Explanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7. They are
                 from the range [1, 7], all did not appear in banned, and their
                 sum is 28, which did not exceed maxSum.

    Constraints:
    * 1 <= banned.length <= 10^4
    * 1 <= banned[i], n <= 10^4
    * 1 <= maxSum <= 10^9*/

    public int maxCount(int[] banned, int n, int maxSum) {
        Set<Integer> tabu = new HashSet();
        for (var x : banned) tabu.add(x);
        int ans = 0;
        for (int x = 1; x <= n && x <= maxSum; ++x)
            if (!tabu.contains(x)) {
                maxSum -= x;
                ++ans;
            }
        return ans;
    }


    /*2555. Maximize Win From Two Segments (Medium)
    There are some prizes on the X-axis. You are given an integer array
    prizePositions that is sorted in non-decreasing order, where
    prizePositions[i] is the position of the ith prize. There could be
    different prizes at the same position on the line. You are also given an
    integer k. You are allowed to select two segments with integer endpoints.
    The length of each segment must be k. You will collect all prizes whose
    position falls within at least one of the two selected segments (including
    the endpoints of the segments). The two selected segments may intersect.
    For example if k = 2, you can choose segments [1, 3] and [2, 4], and you
    will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or
    2 <= prizePositions[i] <= 4. Return the maximum number of prizes you can
    win if you choose the two segments optimally.

    Example 1:
    Input: prizePositions = [1,1,2,2,3,3,5], k = 2
    Output: 7
    Explanation: In this example, you can win all 7 prizes by selecting two
                 segments [1, 3] and [3, 5].

    Example 2:
    Input: prizePositions = [1,2,3,4], k = 0
    Output: 2
    Explanation: For this example, one choice for the segments is [3, 3] and
                 [4, 4], and you will be able to get 2 prizes.

    Constraints:
    * 1 <= prizePositions.length <= 10^5
    * 1 <= prizePositions[i] <= 10^9
    * 0 <= k <= 10^9
    * prizePositions is sorted in non-decreasing order.*/

    public int maximizeWin(int[] prizePositions, int k) {
        int ans = 0, n = prizePositions.length;
        int[] dp = new int[n+1];
        for (int i = 0, ii = 0; i < n; ++i) {
            while (prizePositions[i] - prizePositions[ii] > k) ++ii;
            ans = Math.max(ans, dp[ii] + i - ii + 1);
            dp[i+1] = Math.max(dp[i], i - ii + 1);
        }
        return ans;
    }


    /*2556. Disconnect Path in a Binary Matrix by at Most One Flip (Medium)
    You are given a 0-indexed m x n binary matrix grid. You can move from a
    cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that
    has the value 1. The matrix is disconnected if there is no path from
    (0, 0) to (m - 1, n - 1). You can flip the value of at most one (possibly
    none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1). Return
    true if it is possible to make the matrix disconnect or false otherwise.
    Note that flipping a cell changes its value from 0 to 1 or from 1 to 0.

    Example 1:
    Input: grid = [[1,1,1],[1,0,0],[1,1,1]]
    Output: true
    Explanation: We can change the cell shown in the diagram above. There is no
                 path from (0, 0) to (2, 2) in the resulting grid.

    Example 2:
    Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
    Output: false
    Explanation: It is not possible to change at most one cell such that there
                 is not path from (0, 0) to (2, 2).

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 1000
    * 1 <= m * n <= 10^5
    * grid[i][j] is either 0 or 1.
    * grid[0][0] == grid[m - 1][n - 1] == 1*/

    public boolean isPossibleToCutPath(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if ((i > 0 || j > 0) && (i == 0 || grid[i-1][j] == 0) && (j == 0 || grid[i][j-1] == 0)) grid[i][j] = 0;
        for (int i = m-1; i >= 0; --i)
            for (int j = n-1; j >= 0; --j)
                if ((i < m-1 || j < n-1) && (i == m-1 || grid[i+1][j] == 0) && (j == n-1 || grid[i][j+1] == 0)) grid[i][j] = 0;
        int[] freq = new int[m+n-1];
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                freq[i+j] += grid[i][j];
        for (int i = 1; i < m+n-2; ++i)
            if (freq[i] <= 1) return true;
        return false;
    }


    /*2557. Maximum Number of Integers to Choose From a Range II (Medium)
    You are given an integer array banned and two integers n and maxSum. You
    are choosing some number of integers following the below rules:
    * The chosen integers have to be in the range [1, n].
    * Each integer can be chosen at most once.
    * The chosen integers should not be in the array banned.
    * The sum of the chosen integers should not exceed maxSum.
    Return the maximum number of integers you can choose following the
    mentioned rules.

    Example 1:
    Input: banned = [1,4,6], n = 6, maxSum = 4
    Output: 1
    Explanation: You can choose the integer 2 and 3. 2 and 3 are are in the
                 range [1, 6], both do not appear in banned, and their sum is 5,
                 which does not exceed maxSum.

    Example 2:
    Input: banned = [4,3,5,6], n = 7, maxSum = 18
    Output: 3
    Explanation: You can choose the integers 1, 2, 3 and 7. All these integers
                 are in the range [1, 7], all do not appear in banned, and
                 their sum is 13, which does not exceed maxSum.

    Constraints:
    * 1 <= banned.length <= 10^5
    * 1 <= banned[i] <= n <= 10^9
    * 1 <= maxSum <= 10^15*/

    public int maxCount(int[] banned, int n, long maxSum) {
        int lo = 0, hi = n;
        while (lo < hi) {
            int mid = lo + (hi - lo + 1)/2;
            long total = (long) mid*(mid+1)/2;
            for (var x : banned)
                if (x <= mid) total -= x;
            if (total <= maxSum) lo = mid;
            else hi = mid-1;
        }
        int ans = lo;
        for (var x : banned)
            if (x <= lo) --ans;
        return ans;
    }


    /*2558. Take Gifts From the Richest Pile (Easy)
    You are given an integer array gifts denoting the number of gifts in
    various piles. Every second, you do the following:
    * Choose the pile with the maximum number of gifts.
    * If there is more than one pile with the maximum number of gifts, choose
      any.
    * Leave behind the floor of the square root of the number of gifts in the
      pile. Take the rest of the gifts.
    Return the number of gifts remaining after k seconds.

    Example 1:
    Input: gifts = [25,64,9,4,100], k = 4
    Output: 29
    Explanation: The gifts are taken in the following way:
                 - In the first second, the last pile is chosen and 10 gifts
                   are left behind.
                 - Then the second pile is chosen and 8 gifts are left behind.
                 - After that the first pile is chosen and 5 gifts are left
                   behind.
                 - Finally, the last pile is chosen again and 3 gifts are left
                   behind.
                 The final remaining gifts are [5,8,9,4,3], so the total number
                 of gifts remaining is 29.

    Example 2:
    Input: gifts = [1,1,1,1], k = 4
    Output: 4
    Explanation: In this case, regardless which pile you choose, you have to
                 leave behind 1 gift in each pile. That is, you can't take any
                 pile with you. So, the total gifts remaining are 4.

    Constraints:
    * 1 <= gifts.length <= 10^3
    * 1 <= gifts[i] <= 10^9
    * 1 <= k <= 10^3*/

    public long pickGifts(int[] gifts, int k) {
        long ans = 0;
        Queue<Integer> pq = new PriorityQueue(Collections.reverseOrder());
        for (var x : gifts) {
            ans += x;
            pq.add(x);
        }
        while (k-- > 0) {
            int vv = pq.poll(), v = (int) Math.sqrt(vv);
            ans -= vv - v;
            pq.add(v);
        }
        return ans;
    }


    /*2559. Count Vowel Strings in Ranges (Medium)
    You are given a 0-indexed array of strings words and a 2D array of integers
    queries. Each query queries[i] = [li, ri] asks us to find the number of
    strings present in the range li to ri (both inclusive) of words that start
    and end with a vowel. Return an array ans of size queries.length, where
    ans[i] is the answer to the ith query. Note that the vowel letters are
    'a', 'e', 'i', 'o', and 'u'.

    Example 1:
    Input: words = ["aba","bcb","ece","aa","e"], queries = [[0,2],[1,4],[1,1]]
    Output: [2,3,0]
    Explanation: The strings starting and ending with a vowel are "aba", "ece",
                 "aa" and "e". The answer to the query [0,2] is 2 (strings
                 "aba" and "ece").
                 to query [1,4] is 3 (strings "ece", "aa", "e").
                 to query [1,1] is 0.
                 We return [2,3,0].

    Example 2:
    Input: words = ["a","e","i"], queries = [[0,2],[0,1],[2,2]]
    Output: [3,2,1]
    Explanation: Every string satisfies the conditions, so we return [3,2,1].

    Constraints:
    * 1 <= words.length <= 10^5
    * 1 <= words[i].length <= 40
    * words[i] consists only of lowercase English letters.
    * sum(words[i].length) <= 3 * 10^5
    * 1 <= queries.length <= 10^5
    * 0 <= li <= ri < words.length*/

    public int[] vowelStrings(String[] words, int[][] queries) {
        int n = words.length;
        int[] prefix = new int[n+1];
        for (int i = 0; i < n; ++i) {
            prefix[i+1] = prefix[i];
            if ("aeiou".indexOf(words[i].charAt(0)) >= 0 && "aeiou".indexOf(words[i].charAt(words[i].length()-1)) >= 0) ++prefix[i+1];
        }
        int[] ans = new int[queries.length];
        for (int i = 0; i < queries.length; ++i)
            ans[i] = prefix[queries[i][1]+1] - prefix[queries[i][0]];
        return ans;
    }


    /*2560. House Robber IV (Medium)
    There are several consecutive houses along a street, each of which has some
    money inside. There is also a robber, who wants to steal money from the
    homes, but he refuses to steal from adjacent homes. The capability of the
    robber is the maximum amount of money he steals from one house of all the
    houses he robbed. You are given an integer array nums representing how much
    money is stashed in each house. More formally, the ith house from the left
    has nums[i] dollars. You are also given an integer k, representing the
    minimum number of houses the robber will steal from. It is always possible
    to steal at least k houses. Return the minimum capability of the robber out
    of all the possible ways to steal at least k houses.

    Example 1:
    Input: nums = [2,3,5,9], k = 2
    Output: 5
    Explanation: There are three ways to rob at least 2 houses:
                 - Rob the houses at indices 0 and 2. Capability is
                   max(nums[0], nums[2]) = 5.
                 - Rob the houses at indices 0 and 3. Capability is
                   max(nums[0], nums[3]) = 9.
                 - Rob the houses at indices 1 and 3. Capability is
                   max(nums[1], nums[3]) = 9.
                 Therefore, we return min(5, 9, 9) = 5.

    Example 2:
    Input: nums = [2,7,9,3,1], k = 2
    Output: 2
    Explanation: There are 7 ways to rob the houses. The way which leads to
                 minimum capability is to rob the house at index 0 and 4.
                 Return max(nums[0], nums[4]) = 2.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= (nums.length + 1)/2*/

    public int minCapability(int[] nums, int k) {
        int lo = 0, hi = 1_000_000_000;
        while (lo < hi) {
            int mid = (lo + hi)/2, cnt = 0, prev = Integer.MIN_VALUE;
            for (int i = 0; i < nums.length; ++i)
                if (nums[i] <= mid && prev+1 < i) {
                    ++cnt;
                    prev = i;
                }
            if (cnt < k) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*2561. Rearranging Fruits (Hard)
    You have two fruit baskets containing n fruits each. You are given two 0-
    indexed integer arrays basket1 and basket2 representing the cost of fruit
    in each basket. You want to make both baskets equal. To do so, you can use
    the following operation as many times as you want:
    * Chose two indices i and j, and swap the ith fruit of basket1 with the jth
      fruit of basket2.
    * The cost of the swap is min(basket1[i],basket2[j]).
    Two baskets are considered equal if sorting them according to the fruit
    cost makes them exactly the same baskets. Return the minimum cost to make
    both the baskets equal or -1 if impossible.

    Example 1:
    Input: basket1 = [4,2,2,2], basket2 = [1,4,1,2]
    Output: 1
    Explanation: Swap index 1 of basket1 with index 0 of basket2, which has
                 cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2].
                 Rearranging both the arrays makes them equal.

    Example 2:
    Input: basket1 = [2,3,4,1], basket2 = [3,2,5,1]
    Output: -1
    Explanation: It can be shown that it is impossible to make both the baskets
                 equal.

    Constraints:
    * basket1.length == bakste2.length
    * 1 <= basket1.length <= 10^5
    * 1 <= basket1[i],basket2[i] <= 10^9*/

    public long minCost(int[] basket1, int[] basket2) {
        System.out.println(-5%2);
        TreeMap<Integer, Integer> freq = new TreeMap();
        for (var x : basket1) freq.merge(x, 1, Integer::sum);
        for (var x : basket2) freq.merge(x, -1, Integer::sum);
        int total = 0, m = Integer.MAX_VALUE;
        for (var elem : freq.entrySet()) {
            int k = elem.getKey(), v = Math.abs(elem.getValue());
            m = Math.min(m, k);
            if (v%2 == 1) return -1;
            total += v/2;
        }
        total /= 2;
        long ans = 0;
        for (var elem : freq.entrySet()) {
            int k = elem.getKey(), v = Math.abs(elem.getValue());
            v = Math.min(v/2, total);
            ans += (long) v * Math.min(2*m, k);
            total -= v;
        }
        return ans;
    }


    /*2562. Find the Array Concatenation Value (Easy)
    You are given a 0-indexed integer array nums. The concatenation of two
    numbers is the number formed by concatenating their numerals.
    * For example, the concatenation of 15, 49 is 1549.
    The concatenation value of nums is initially equal to 0. Perform this
    operation until nums becomes empty:
    * If there exists more than one number in nums, pick the first element and
      last element in nums respectively and add the value of their
      concatenation to the concatenation value of nums, then delete the first
      and last element from nums.
    * If one element exists, add its value to the concatenation value of nums,
      then delete it.
    Return the concatenation value of the nums.

    Example 1:
    Input: nums = [7,52,2,4]
    Output: 596
    Explanation: Before performing any operation, nums is [7,52,2,4] and
                 concatenation value is 0.
                  - In the first operation:
                 We pick the first element, 7, and the last element, 4. Their
                 concatenation is 74, and we add it to the concatenation value,
                 so it becomes equal to 74. Then we delete them from nums, so
                 nums becomes equal to [52,2].
                  - In the second operation:
                 We pick the first element, 52, and the last element, 2. Their
                 concatenation is 522, and we add it to the concatenation value,
                 so it becomes equal to 596. Then we delete them from the nums,
                 so nums becomes empty. Since the concatenation value is 596 so
                 the answer is 596.

    Example 2:
    Input: nums = [5,14,13,8,12]
    Output: 673
    Explanation: Before performing any operation, nums is [5,14,13,8,12] and
                 concatenation value is 0.
                  - In the first operation:
                 We pick the first element, 5, and the last element, 12. Their
                 concatenation is 512, and we add it to the concatenation value,
                 so it becomes equal to 512. Then we delete them from the nums,
                 so nums becomes equal to [14,13,8].
                  - In the second operation:
                 We pick the first element, 14, and the last element, 8. Their
                 concatenation is 148, and we add it to the concatenation value,
                 so it becomes equal to 660. Then we delete them from the nums,
                 so nums becomes equal to [13].
                  - In the third operation:
                 nums has only one element, so we pick 13 and add it to the
                 concatenation value, so it becomes equal to 673. Then we
                 delete it from nums, so nums become empty. Since the
                 concatenation value is 673 so the answer is 673.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^4*/

    public long findTheArrayConcVal(int[] nums) {
        long ans = 0;
        for (int i = 0, n = nums.length; i < (n+1)/2; ++i)
            if (i == n-1-i) ans += nums[i];
            else {
                int m = 1;
                for (int x = nums[n-1-i]; x > 0; x /= 10, m *= 10);
                ans += m * nums[i] + nums[n-1-i];
            }
        return ans;
    }


    /*2563. Count the Number of Fair Pairs (Medium)
    Given a 0-indexed integer array nums of size n and two integers lower and
    upper, return the number of fair pairs. A pair (i, j) is fair if:
    * 0 <= i < j < n, and
    * lower <= nums[i] + nums[j] <= upper

    Example 1:
    Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6
    Output: 6
    Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and
                 (1,5).

    Example 2:
    Input: nums = [1,7,9,2,5], lower = 11, upper = 11
    Output: 1
    Explanation: There is a single fair pair: (2,3).

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums.length == n
    * -10^9 <= nums[i] <= 10^9
    * -10^9 <= lower <= upper <= 10^9*/

    public long countFairPairs(int[] nums, int lower, int upper) {
        Arrays.sort(nums);
        long ans = 0;
        for (int i = 0, n = nums.length, lo = n-1, hi = n-1; i < n; ++i) {
            while (0 <= hi && nums[i] + nums[hi] > upper) --hi;
            while (0 <= lo && nums[i] + nums[lo] >= lower) --lo;
            ans += hi - lo;
            if (lo < i && i <= hi) --ans;
        }
        return ans/2;
    }


    /*2564. Substring XOR Queries (Medium)
    You are given a binary string s, and a 2D integer array queries where
    queries[i] = [firsti, secondi]. For the ith query, find the shortest
    substring of s whose decimal value, val, yields secondi when bitwise XORed
    with firsti. In other words, val ^ firsti == secondi. The answer to the ith
    query is the endpoints (0-indexed) of the substring [lefti, righti] or
    [-1, -1] if no such substring exists. If there are multiple answers, choose
    the one with the minimum lefti. Return an array ans where
    ans[i] = [lefti, righti] is the answer to the ith query. A substring is a
    contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: s = "101101", queries = [[0,5],[1,2]]
    Output: [[0,2],[2,3]]
    Explanation: For the first query the substring in range [0,2] is "101"
                 which has a decimal value of 5, and 5 ^ 0 = 5, hence the
                 answer to the first query is [0,2]. In the second query, the
                 substring in range [2,3] is "11", and has a decimal value of 3,
                 and 3 ^ 1 = 2. So, [2,3] is returned for the second query.

    Example 2:
    Input: s = "0101", queries = [[12,8]]
    Output: [[-1,-1]]
    Explanation: In this example there is no substring that answers the query,
                 hence [-1,-1] is returned.

    Example 3:
    Input: s = "1", queries = [[4,5]]
    Output: [[0,0]]
    Explanation: For this example, the substring in range [0,0] has a decimal
                 value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].

    Constraints:
    * 1 <= s.length <= 10^4
    * s[i] is either '0' or '1'.
    * 1 <= queries.length <= 10^5
    * 0 <= firsti, secondi <= 10^9*/

    public int[][] substringXorQueries(String s, int[][] queries) {
        Map<Integer, int[]> seen = new HashMap();
        for (int i = 0, n = s.length(); i < n; ++i)
            if (s.charAt(i) == '1') {
                int val = 0;
                for (int j = i; j < n && j < i+30; ++j) {
                    val <<= 1;
                    if (s.charAt(j) == '1') val ^= 1;
                    if (!seen.containsKey(val)) seen.put(val, new int[]{i, j});
                }
            } else if (!seen.containsKey(0)) seen.put(0, new int[]{i, i});
        int[][] ans = new int[queries.length][2];
        for (int i = 0; i < queries.length; ++i)
            ans[i] = seen.getOrDefault(queries[i][0] ^ queries[i][1], new int[]{-1, -1});
        return ans;
    }


    /*2565. Subsequence With the Minimum Score (Hard)
    You are given two strings s and t. You are allowed to remove any number of
    characters from the string t. The score string is 0 if no characters are
    removed from the string t, otherwise:
    * Let left be the minimum index among all removed characters.
    * Let right be the maximum index among all removed characters.
    Then the score of the string is right - left + 1. Return the minimum
    possible score to make t a subsequence of s. A subsequence of a string is a
    new string that is formed from the original string by deleting some (can be
    none) of the characters without disturbing the relative positions of the
    remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec"
    is not).

    Example 1:
    Input: s = "abacaba", t = "bzaa"
    Output: 1
    Explanation: In this example, we remove the character "z" at index 1
                 (0-indexed). The string t becomes "baa" which is a subsequence
                 of the string "abacaba" and the score is 1 - 1 + 1 = 1. It can
                 be proven that 1 is the minimum score that we can achieve.

    Example 2:
    Input: s = "cde", t = "xyz"
    Output: 3
    Explanation: In this example, we remove characters "x", "y" and "z" at
                 indices 0, 1, and 2 (0-indexed). The string t becomes "" which
                 is a subsequence of the string "cde" and the score is
                 2 - 0 + 1 = 3. It can be proven that 3 is the minimum score
                 that we can achieve.

    Constraints:
    * 1 <= s.length, t.length <= 10^5
    * s and t consist of only lowercase English letters.*/

    public int minimumScore(String s, String t) {
        int m = s.length(), n = t.length();
        int[] prefix = new int[m];
        int j = 0;
        for (int i = 0; i < m; ++i) {
            if (j < n && s.charAt(i) == t.charAt(j)) ++j;
            prefix[i] = j;
        }
        int ans = n - j;
        j = n;
        for (int i = m-1; i >= 0; --i) {
            ans = Math.min(ans, Math.max(0, j - prefix[i]));
            if (0 < j && s.charAt(i) == t.charAt(j-1)) --j;
        }
        return Math.min(ans, j);
    }


    /*2566. Maximum Difference by Remapping a Digit (Easy)
    You are given an integer num. You know that Danny Mittal will sneakily
    remap one of the 10 possible digits (0 to 9) to another digit. Return the
    difference between the maximum and minimum values Danny can make by
    remapping exactly one digit in num.

    Notes:
    * When Danny remaps a digit d1 to another digit d2, Danny replaces all
      occurrences of d1 in num with d2.
    * Danny can remap a digit to itself, in which case num does not change.
    * Danny can remap different digits for obtaining minimum and maximum values
      respectively.
    * The resulting number after remapping can contain leading zeroes.
    * We mentioned "Danny Mittal" to congratulate him on being in the top 10 in
      Weekly Contest 326.

    Example 1:
    Input: num = 11891
    Output: 99009
    Explanation: To achieve the maximum value, Danny can remap the digit 1 to
                 the digit 9 to yield 99899. To achieve the minimum value,
                 Danny can remap the digit 1 to the digit 0, yielding 890. The
                 difference between these two numbers is 99009.

    Example 2:
    Input: num = 90
    Output: 99
    Explanation: The maximum value that can be returned by the function is 99
                 (if 0 is replaced by 9) and the minimum value that can be
                 returned by the function is 0 (if 9 is replaced by 0). Thus,
                 we return 99.

    Constraints: 1 <= num <= 10^8*/

    public int findBug(int num) {
        List<Integer> digits = new ArrayList();
        int v = 9, diff = 0;
        for (int x = num; x > 0; x /= 10) {
            int d = x % 10;
            if (d < 9) v = d;
            digits.add(d);
        }
        Collections.reverse(digits);
        for (var x : digits) {
            diff = 10*diff;
            if (x == digits.get(0)) diff += x;
            if (x == v) diff += 9-x;
        }
        return diff;
    }


    /*2567. Minimum Score by Changing Two Elements (Medium)
    You are given a 0-indexed integer array nums.
    * The low score of nums is the minimum value of |nums[i] - nums[j]| over
      all 0 <= i < j < nums.length.
    * The high score of nums is the maximum value of |nums[i] - nums[j]| over
      all 0 <= i < j < nums.length.
    * The score of nums is the sum of the high and low scores of nums.
    To minimize the score of nums, we can change the value of at most two
    elements of nums. Return the minimum possible score after changing the
    value of at most two elements of nums. Note that |x| denotes the absolute
    value of x.

    Example 1:
    Input: nums = [1,4,3]
    Output: 0
    Explanation: Change value of nums[1] and nums[2] to 1 so that nums becomes
                 [1,1,1]. Now, the value of |nums[i] - nums[j]| is always equal
                 to 0, so we return 0 + 0 = 0.

    Example 2:
    Input: nums = [1,4,7,8,5]
    Output: 3
    Explanation: Change nums[0] and nums[1] to be 6. Now nums becomes
                 [6,6,7,8,5]. Our low score is achieved when i = 0 and j = 1,
                 in which case |nums[i] - nums[j]| = |6 - 6| = 0. Our high
                 score is achieved when i = 3 and j = 4, in which case
                 |nums[i] - nums[j]| = |8 - 5| = 3. The sum of our high and low
                 score is 3, which we can prove to be minimal.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public int minimizeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        return Math.min(nums[n-1]-nums[2], Math.min(nums[n-2]-nums[1], nums[n-3]-nums[0]));
    }


    /*2568. Minimum Impossible OR (Medium)
    You are given a 0-indexed integer array nums. We say that an integer x is
    expressible from nums if there exist some integers
    0 <= index1 < index2 < ... < indexk < nums.length for which
    nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an
    integer is expressible if it can be written as the bitwise OR of some
    subsequence of nums. Return the minimum positive non-zero integer that is
    not expressible from nums.

    Example 1:
    Input: nums = [2,1]
    Output: 4
    Explanation: 1 and 2 are already present in the array. We know that 3 is
                 expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is
                 not expressible, we return 4.

    Example 2:
    Input: nums = [5,3,2]
    Output: 1
    Explanation: We can show that 1 is the smallest number that is not
                 expressible.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public int minImpossibleOR(int[] nums) {
        int mask = 0;
        for (var x : nums)
            if ((x & x-1) == 0) mask |= x;
        for (int i = 0; i < 32; ++i)
            if ((mask & 1<<i) == 0) return 1<<i;
        return -1;
    }


    /*2569. Handling Sum Queries After Update (Hard)
    You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries
    of queries. There are three types of queries:
    * For a query of type 1, queries[i] = [1, l, r]. Flip the values from 0 to
      1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-
      indexed.
    * For a query of type 2, queries[i] = [2, p, 0]. For every index 0 <= i < n,
      set nums2[i] = nums2[i] + nums1[i] * p.
    * For a query of type 3, queries[i] = [3, 0, 0]. Find the sum of the
      elements in nums2.
    Return an array containing all the answers to the third type queries.

    Example 1:
    Input: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]
    Output: [3]
    Explanation: After the first query nums1 becomes [1,1,1]. After the second
                 query, nums2 becomes [1,1,1], so the answer to the third query
                 is 3. Thus, [3] is returned.

    Example 2:
    Input: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]
    Output: [5]
    Explanation: After the first query, nums2 remains [5], so the answer to the
                 second query is 5. Thus, [5] is returned.

    Constraints:
    * 1 <= nums1.length,nums2.length <= 10^5
    * nums1.length = nums2.length
    * 1 <= queries.length <= 10^5
    * queries[i].length = 3
    * 0 <= l <= r <= nums1.length - 1
    * 0 <= p <= 10^6
    * 0 <= nums1[i] <= 1
    * 0 <= nums2[i] <= 10^9

class SegTreeLazy {
    private int n = 0;
    private int[] tree, lazy;

    private void build(int[] arr, int k, int lo, int hi) {
        if (lo+1 == hi) tree[k] = arr[lo];
        else {
            int mid = lo + (hi-lo)/2;
            build(arr, 2*k+1, lo, mid);
            build(arr, 2*k+2, mid, hi);
            tree[k] = tree[2*k+1] + tree[2*k+2];
        }
    }

    public SegTreeLazy(int[] arr) {
        n = arr.length;
        tree = new int[4*n];
        lazy = new int[4*n];
        build(arr, 0, 0, n);
    }

    public void update(int qlo, int qhi, int k, int lo, int hi) {
        if (hi == 0) hi = n;
        if (lazy[k] > 0) {
            tree[k] = (hi - lo) - tree[k];
            if (lo+1 < hi) {
                lazy[2*k+1] ^= 1;
                lazy[2*k+2] ^= 1;
            }
            lazy[k] = 0;
        }
        if (lo < hi && qlo < hi && lo < qhi)
            if (qlo <= lo && hi <= qhi) {
                tree[k] = (hi - lo) - tree[k];
                if (lo+1 < hi) {
                    lazy[2*k+1] ^= 1;
                    lazy[2*k+2] ^= 1;
                }
            } else {
                int mid = lo + (hi - lo)/2;
                update(qlo, qhi, 2*k+1, lo, mid);
                update(qlo, qhi, 2*k+2, mid, hi);
                tree[k] = tree[2*k+1] + tree[2*k+2];
            }
    }

    public int query() {
        return tree[0];
    }
}*/

    public long[] handleQuery(int[] nums1, int[] nums2, int[][] queries) {
        SegTreeLazy tree = new SegTreeLazy(nums1);
        List<Long> ans = new ArrayList();
        long val = 0;
        for (var x : nums2) val += x;
        for (var q : queries) {
            if (q[0] == 1) tree.update(q[1], q[2]+1, 0, 0, 0);
            else if (q[0] == 2) val += (long) q[1] * tree.query();
            else ans.add(val);
        }
        return ans.stream().mapToLong(i->i).toArray();
    }


    /*2570. Merge Two 2D Arrays by Summing Values (Easy)
    You are given two 2D integer arrays nums1 and nums2.
    * nums1[i] = [idi, vali] indicate that the number with the id idi has a
      value equal to vali.
    * nums2[i] = [idi, vali] indicate that the number with the id idi has a
      value equal to vali.
    Each array contains unique ids and is sorted in ascending order by id.
    Merge the two arrays into one array that is sorted in ascending order by
    id, respecting the following conditions:
    * Only ids that appear in at least one of the two arrays should be included
      in the resulting array.
    * Each id should be included only once and its value should be the sum of
      the values of this id in the two arrays. If the id does not exist in one
      of the two arrays then its value in that array is considered to be 0.
    Return the resulting array. The returned array must be sorted in ascending
    order by id.

    Example 1:
    Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
    Output: [[1,6],[2,3],[3,2],[4,6]]
    Explanation: The resulting array contains the following:
                 - id = 1, the value of this id is 2 + 4 = 6.
                 - id = 2, the value of this id is 3.
                 - id = 3, the value of this id is 2.
                 - id = 4, the value of this id is 5 + 1 = 6.

    Example 2:
    Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
    Output: [[1,3],[2,4],[3,6],[4,3],[5,5]]
    Explanation: There are no common ids, so we just include each id with its
                 value in the resulting list.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 200
    * nums1[i].length == nums2[j].length == 2
    * 1 <= idi, vali <= 1000
    * Both arrays contain unique ids.
    * Both arrays are in strictly ascending order by id.*/

    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {
        List<int[]> ans = new ArrayList();
        for (int i = 0, j = 0, n1 = nums1.length, n2 = nums2.length; i < n1 || j < n2; )
            if (j == n2 || i < n1 && nums1[i][0] <= nums2[j][0]) ans.add(nums1[i++]);
            else {
                if (i+j > 0 && ans.get(ans.size()-1)[0] == nums2[j][0]) ans.get(ans.size()-1)[1] += nums2[j][1];
                else ans.add(nums2[j]);
                ++j;
            }
        return ans.stream().map(x -> x).toArray(int[][]::new);
    }


    /*2571. Minimum Operations to Reduce an Integer to 0 (Easy)
    You are given a positive integer n, you can do the following operation any
    number of times:
    * Add or subtract a power of 2 from n.
    Return the minimum number of operations to make n equal to 0. A number x is
    power of 2 if x == 2i where i >= 0.

    Example 1:
    Input: n = 39
    Output: 3
    Explanation: We can do the following operations:
                 - Add 20 = 1 to n, so now n = 40.
                 - Subtract 23 = 8 from n, so now n = 32.
                 - Subtract 25 = 32 from n, so now n = 0.
                 It can be shown that 3 is the minimum number of operations we
                 need to make n equal to 0.

    Example 2:
    Input: n = 54
    Output: 3
    Explanation: We can do the following operations:
                 - Add 21 = 2 to n, so now n = 56.
                 - Add 23 = 8 to n, so now n = 64.
                 - Subtract 26 = 64 from n, so now n = 0.
                 So the minimum number of operations is 3.

    Constraints: 1 <= n <= 10^5*/

    public int minOperations(int n) {
        int ans = 0, carry = 0;
        for (; n > 0; n >>= 1) {
            carry += n & 1;
            if (carry == 1) {
                if ((n&2) == 0) carry = 0;
                ++ans;
            } else if (carry == 2) carry = 1;
        }
        return ans + carry;
    }


    /*2572. Count the Number of Square-Free Subsets (Medium)
    You are given a positive integer 0-indexed array nums. A subset of the
    array nums is square-free if the product of its elements is a square-free
    integer. A square-free integer is an integer that is divisible by no square
    number other than 1. Return the number of square-free non-empty subsets of
    the array nums. Since the answer may be too large, return it modulo
    10^9 + 7. A non-empty subset of nums is an array that can be obtained by
    deleting some (possibly none but not all) elements from nums. Two subsets
    are different if and only if the chosen indices to delete are different.

    Example 1:
    Input: nums = [3,4,4,5]
    Output: 3
    Explanation: There are 3 square-free subsets in this example:
                 - The subset consisting of the 0th element [3]. The product of
                   its elements is 3, which is a square-free integer.
                 - The subset consisting of the 3rd element [5]. The product of
                   its elements is 5, which is a square-free integer.
                 - The subset consisting of 0th and 3rd elements [3,5]. The
                   product of its elements is 15, which is a square-free
                   integer.
                 It can be proven that there are no more than 3 square-free
                 subsets in the given array.

    Example 2:
    Input: nums = [1]
    Output: 1
    Explanation: There is 1 square-free subset in this example:
                 - The subset consisting of the 0th element [1]. The product of
                   its elements is 1, which is a square-free integer.
                 It can be proven that there is no more than 1 square-free
                 subset in the given array.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 30*/

    public int squareFreeSubsets(int[] nums) {
        final int mod = 1_000_000_007;
        int[] freq = new int[31], mask = new int[31], primes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
        for (var x : nums) ++freq[x];
        long pow = 1;
        for (long p = freq[1], v = 2; p > 0; p >>= 1, v = v*v % mod)
            if (p % 2 == 1) pow = pow * v % mod;
        for (int x = 2; x <= 30; ++x) {
            int m = 0, v = 1;
            for (int i = 0; i < 10; ++i)
                if (x % primes[i] == 0) {
                    v *= primes[i];
                    m ^= 1<<i;
                }
            if (v == x) mask[x] = m;
        }
        long[][] dp = new long[1<<10][32];
        for (int j = 0; j <= 31; ++j) dp[0][j] = 1;
        for (int i = 1; i < 1<<10; ++i)
            for (int j = 2; j <= 30; ++j)
                for (int jj = j; jj <= 30; ++jj)
                    if (mask[jj] > 0 && (mask[jj] & i) == mask[jj])
                        dp[i][j] = (dp[i][j] + freq[jj] * dp[i^mask[jj]][jj+1]) % mod;
        long ans = 1;
        for (int i = 1; i < 1<<10; ++i)
            ans = (ans + dp[i][2]) % mod;
        return (int) ((ans * pow - 1) % mod);
    }


    /*2573. Find the String with LCP (Hard)
    We define the lcp matrix of any 0-indexed string word of n lowercase
    English letters as an n x n grid such that:
    * lcp[i][j] is equal to the length of the longest common prefix between the
      substrings word[i,n-1] and word[j,n-1].
    Given an n x n matrix lcp, return the alphabetically smallest string word
    that corresponds to lcp. If there is no such string, return an empty string.
    A string a is lexicographically smaller than a string b (of the same length)
    if in the first position where a and b differ, string a has a letter that
    appears earlier in the alphabet than the corresponding letter in b. For
    example, "aabd" is lexicographically smaller than "aaca" because the first
    position they differ is at the third letter, and 'b' comes before 'c'.

    Example 1:
    Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]
    Output: "abab"
    Explanation: lcp corresponds to any 4 letter string with two alternating
                 letters. The lexicographically smallest of them is "abab".

    Example 2:
    Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]
    Output: "aaaa"
    Explanation: lcp corresponds to any 4 letter string with a single distinct
                 letter. The lexicographically smallest of them is "aaaa".

    Example 3:
    Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]
    Output: ""
    Explanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of
                 only a single letter; Thus, no answer exists.

    Constraints:
    * 1 <= n == lcp.length == lcp[i].length <= 1000
    * 0 <= lcp[i][j] <= n*/

    public String findTheString(int[][] lcp) {
        int n = lcp.length;
        char[] ans = new char[n];
        Arrays.fill(ans, '*');
        for (int i = 0, c = 0; i < n; ++i) {
            if (lcp[i][i] != n-i) return "";
            for (int j = i+1; j < n; ++j)
                if (lcp[i][j] != lcp[j][i] || lcp[i][j] > 0 && lcp[i][j] != 1 + (i+1 < n && j+1 < n ? lcp[i+1][j+1] : 0)) return "";
            if (ans[i] == '*') {
                for (int j = i; j < n; ++j)
                    if (lcp[i][j] > 0) {
                        if (ans[j] != '*' || c == 26) return "";
                        ans[j] = (char) ('a' + c);
                    }
                ++c;
            }
        }
        return String.valueOf(ans);
    }


    /*2574. Left and Right Sum Differences (Easy)
    Given a 0-indexed integer array nums, find a 0-indexed integer array answer
    where:
    * answer.length == nums.length.
    * answer[i] = |leftSum[i] - rightSum[i]|.
    Where:
    * leftSum[i] is the sum of elements to the left of the index i in the array
      nums. If there is no such element, leftSum[i] = 0.
    * rightSum[i] is the sum of elements to the right of the index i in the
      array nums. If there is no such element, rightSum[i] = 0.
    Return the array answer.

    Example 1:
    Input: nums = [10,4,8,3]
    Output: [15,1,11,22]
    Explanation: The array leftSum is [0,10,14,22] and the array rightSum is
                 [15,11,3,0]. The array answer is
                 [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].

    Example 2:
    Input: nums = [1]
    Output: [0]
    Explanation: The array leftSum is [0] and the array rightSum is [0]. The
                 array answer is [|0 - 0|] = [0].

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5*/

    public int[] leftRigthDifference(int[] nums) {
        int n = nums.length, diff = IntStream.of(nums).sum();
        int[] ans = new int[n];
        for (int i = 0; i < n; ++i) {
            ans[i] = Math.abs(diff - nums[i]);
            diff -= 2*nums[i];
        }
        return ans;
    }


    /*2575. Find the Divisibility Array of a String (Medium)
    You are given a 0-indexed string word of length n consisting of digits, and
    a positive integer m. The divisibility array div of word is an integer
    array of length n such that:
    * div[i] = 1 if the numeric value of word[0,...,i] is divisible by m, or
    * div[i] = 0 otherwise.
    Return the divisibility array of word.

    Example 1:
    Input: word = "998244353", m = 3
    Output: [1,1,0,0,0,1,1,0,0]
    Explanation: There are only 4 prefixes that are divisible by 3: "9", "99",
                 "998244", and "9982443".

    Example 2:
    Input: word = "1010", m = 10
    Output: [0,1,0,1]
    Explanation: There are only 2 prefixes that are divisible by 10: "10", and
                 "1010".

    Constraints:
    * 1 <= n <= 10^5
    * word.length == n
    * word consists of digits from 0 to 9
    * 1 <= m <= 10^9*/

    public int[] divisibilityArray(String word, int m) {
        int n = word.length();
        int[] ans = new int[n];
        long prefix = 0;
        for (int i = 0; i < n; ++i) {
            prefix = 10*prefix + (word.charAt(i) - '0');
            prefix %= m;
            if (prefix == 0) ans[i] = 1;
        }
        return ans;
    }


    /*2576. Find the Maximum Number of Marked Indices (Medium)
    You are given a 0-indexed integer array nums. Initially, all of the indices
    are unmarked. You are allowed to make this operation any number of times:
    * Pick two different unmarked indices i and j such that
      2 * nums[i] <= nums[j], then mark i and j.
    Return the maximum possible number of marked indices in nums using the
    above operation any number of times.

    Example 1:
    Input: nums = [3,5,2,4]
    Output: 2
    Explanation: In the first operation: pick i = 2 and j = 1, the operation is
                 allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and
                 1. It can be shown that there's no other valid operation so
                 the answer is 2.

    Example 2:
    Input: nums = [9,2,5,4]
    Output: 4
    Explanation: In the first operation: pick i = 3 and j = 0, the operation is
                 allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and
                 0. In the second operation: pick i = 1 and j = 2, the
                 operation is allowed because 2 * nums[1] <= nums[2]. Then mark
                 index 1 and 2. Since there is no other operation, the answer
                 is 4.

    Example 3:
    Input: nums = [7,6,8]
    Output: 0
    Explanation: There is no valid operation to do, so the answer is 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public int maxNumOfMarkedIndices(int[] nums) {
        Arrays.sort(nums);
        int ans = 0;
        for (int n = nums.length, i = n/2-1, j = n-1; i >= 0; --i)
            if (nums[i]*2 <= nums[j]) {
                ans += 2;
                --j;
            }
        return ans;
    }


    /*2577. Minimum Time to Visit a Cell In a Grid (Hard)
    You are given a m x n matrix grid consisting of non-negative integers where
    grid[row][col] represents the minimum time required to be able to visit the
    cell (row, col), which means you can visit the cell (row, col) only when
    the time you visit it is greater than or equal to grid[row][col]. You are
    standing in the top-left cell of the matrix in the 0th second, and you must
    move to any adjacent cell in the four directions: up, down, left, and right.
    Each move you make takes 1 second. Return the minimum time required in
    which you can visit the bottom-right cell of the matrix. If you cannot
    visit the bottom-right cell, then return -1.

    Example 1:
    Input: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
    Output: 7
    Explanation: One of the paths that we can take is the following:
                 - at t = 0, we are on the cell (0,0).
                 - at t = 1, we move to the cell (0,1). It is possible because
                   grid[0][1] <= 1.
                 - at t = 2, we move to the cell (1,1). It is possible because
                   grid[1][1] <= 2.
                 - at t = 3, we move to the cell (1,2). It is possible because
                   grid[1][2] <= 3.
                 - at t = 4, we move to the cell (1,1). It is possible because
                   grid[1][1] <= 4.
                 - at t = 5, we move to the cell (1,2). It is possible because
                   grid[1][2] <= 5.
                 - at t = 6, we move to the cell (1,3). It is possible because
                   grid[1][3] <= 6.
                 - at t = 7, we move to the cell (2,3). It is possible because
                   grid[1][3] <= 7.
                 The final time is 7. It can be shown that it is the minimum
                 time possible.

    Example 2:
    Input: grid = [[0,2,4],[3,2,1],[1,0,4]]
    Output: -1
    Explanation: There is no path from the top left to the bottom-right cell.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 1000
    * 4 <= m * n <= 10^5
    * 0 <= grid[i][j] <= 10^5
    * grid[0][0] == 0*/

    public int minimumTime(int[][] grid) {
        if (grid[0][1] <= 1 || grid[1][0] <= 1) {
            int m = grid.length, n = grid[0].length;
            int[] dir = new int[]{-1, 0, 1, 0, -1};
            Queue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0])); pq.add(new int[]{0, 0, 0});
            int[][] dist = new int[m][n];
            for (int i = 0; i < m; ++i) Arrays.fill(dist[i], Integer.MAX_VALUE);
            dist[0][0] = 0;
            while (!pq.isEmpty()) {
                var elem = pq.poll();
                int x = elem[0], i = elem[1], j = elem[2];
                if (i == m-1 && j == n-1) return x;
                int cnt = 0;
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n) {
                        if (grid[ii][jj] <= x+1) ++cnt;
                        int xx = x + 1 + Math.max(0, (grid[ii][jj] - x)/2*2);
                        if (dist[ii][jj] > xx) {
                            pq.add(new int[]{xx, ii, jj});
                            dist[ii][jj] = xx;
                        }
                    }
                }
                if (cnt == 0) break;
            }
        }
        return -1;
    }


    /*2582. Pass the Pillow (Easy)
    There are n people standing in a line labeled from 1 to n. The first person
    in the line is holding a pillow initially. Every second, the person holding
    the pillow passes it to the next person standing in the line. Once the
    pillow reaches the end of the line, the direction changes, and people
    continue passing the pillow in the opposite direction.
    * For example, once the pillow reaches the nth person they pass it to the
      n - 1th person, then to the n - 2th person and so on.
    Given the two positive integers n and time, return the index of the person
    holding the pillow after time seconds.

    Example 1:
    Input: n = 4, time = 5
    Output: 2
    Explanation: People pass the pillow in the following way:
                 1 -> 2 -> 3 -> 4 -> 3 -> 2. Afer five seconds, the pillow is
                 given to the 2nd person.

    Example 2:
    Input: n = 3, time = 2
    Output: 3
    Explanation: People pass the pillow in the following way: 1 -> 2 -> 3. Afer
                 two seconds, the pillow is given to the 3rd person.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= time <= 1000*/

    public int passThePillow(int n, int time) {
        time %= 2*(n-1);
        if (time > n-1) time = 2*(n-1) - time;
        return time+1;
    }


    /*2583. Kth Largest Sum in a Binary Tree (Medium)
    You are given the root of a binary tree and a positive integer k. The level
    sum in the tree is the sum of the values of the nodes that are on the same
    level. Return the kth largest level sum in the tree (not necessarily
    distinct). If there are fewer than k levels in the tree, return -1. Note
    that two nodes are on the same level if they have the same distance from
    the root.

    Example 1:
    Input: root = [5,8,9,2,1,3,7,4,6], k = 2
    Output: 13
    Explanation: The level sums are the following:
                 - Level 1: 5.
                 - Level 2: 8 + 9 = 17.
                 - Level 3: 2 + 1 + 3 + 7 = 13.
                 - Level 4: 4 + 6 = 10.
                 The 2nd largest level sum is 13.

    Example 2:
    Input: root = [1,2,null,3], k = 1
    Output: 3
    Explanation: The largest level sum is 3.

    Constraints:
    * The number of nodes in the tree is n.
    * 2 <= n <= 10^5
    * 1 <= Node.val <= 10^6
    * 1 <= k <= n*/

    public long kthLargestLevelSum(TreeNode root, int k) {
        List<Long> vals = new ArrayList();
        Stack<Pair<TreeNode, Integer>> stk = new Stack();
        stk.add(new Pair(root, 0));
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            TreeNode node = elem.getKey();
            int i = elem.getValue();
            if (i == vals.size()) vals.add(0l);
            vals.set(i, vals.get(i)+node.val);
            if (node.left != null) stk.add(new Pair(node.left, i+1));
            if (node.right != null) stk.add(new Pair(node.right, i+1));
        }
        if (vals.size() < k) return -1;
        Collections.sort(vals, Collections.reverseOrder());
        return vals.get(k-1);
    }


    /*2584. Split the Array to Make Coprime Products (Medium)
    You are given a 0-indexed integer array nums of length n. A split at an
    index i where 0 <= i <= n - 2 is called valid if the product of the first
    i + 1 elements and the product of the remaining elements are coprime.
    * For example, if nums = [2, 3, 3], then a split at the index i = 0 is
      valid because 2 and 9 are coprime, while a split at the index i = 1 is
      not valid because 6 and 3 are not coprime. A split at the index i = 2 is
      not valid because i == n - 1.
    Return the smallest index i at which the array can be split validly or -1
    if there is no such split. Two values val1 and val2 are coprime if
    gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor
    of val1 and val2.

    Example 1:
    Input: nums = [4,7,8,15,3,5]
    Output: 2
    Explanation: The table above shows the values of the product of the first
                 i + 1 elements, the remaining elements, and their gcd at each
                 index i. The only valid split is at index 2.

    Example 2:
    Input: nums = [4,7,15,8,3,5]
    Output: -1
    Explanation: The table above shows the values of the product of the first
                 i + 1 elements, the remaining elements, and their gcd at each
                 index i. There is no valid split.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^4
    * 1 <= nums[i] <= 10^6*/

    public int findValidSplit(int[] nums) {
        HashMap<Integer, Integer> freq = new HashMap();
        for (var x : nums) {
            for (int p = 2; p <= Math.sqrt(x); ++p)
                for (; x % p == 0; x /= p)
                    freq.merge(p, 1, Integer::sum);
            if (x > 1) freq.merge(x, 1, Integer::sum);
        }
        HashSet<Integer> ovlp = new HashSet();
        for (int i = 0, x = nums[0]; i < nums.length-1; x = nums[++i]) {
            for (int p = 2; p <= Math.sqrt(x); ++p)
                for (; x % p == 0; x /= p) {
                    ovlp.add(p);
                    freq.merge(p, -1, Integer::sum);
                    if (freq.get(p) == 0) ovlp.remove(p);
                }
            if (x > 1) {
                ovlp.add(x);
                freq.merge(x, -1, Integer::sum);
                if (freq.get(x) == 0) ovlp.remove(x);
            }
            if (ovlp.isEmpty()) return i;
        }
        return -1;
    }


    /*2585. Number of Ways to Earn Points (Hard)
    There is a test that has n types of questions. You are given an integer
    target and a 0-indexed 2D integer array types where
    types[i] = [counti, marksi] indicates that there are counti questions of
    the ith type, and each one of them is worth marksi points. Return the
    number of ways you can earn exactly target points in the exam. Since the
    answer may be too large, return it modulo 10^9 + 7. Note that questions of
    the same type are indistinguishable. For example, if there are 3 questions
    of the same type, then solving the 1st and 2nd questions is the same as
    solving the 1st and 3rd questions, or the 2nd and 3rd questions.

    Example 1:
    Input: target = 6, types = [[6,1],[3,2],[2,3]]
    Output: 7
    Explanation: You can earn 6 points in one of the seven ways:
                 - Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6
                 - Solve 4 questions of the 0th type and 1 question of the 1st
                   type: 1 + 1 + 1 + 1 + 2 = 6
                 - Solve 2 questions of the 0th type and 2 questions of the 1st
                   type: 1 + 1 + 2 + 2 = 6
                 - Solve 3 questions of the 0th type and 1 question of the 2nd
                   type: 1 + 1 + 1 + 3 = 6
                 - Solve 1 question of the 0th type, 1 question of the 1st type
                   and 1 question of the 2nd type: 1 + 2 + 3 = 6
                 - Solve 3 questions of the 1st type: 2 + 2 + 2 = 6
                 - Solve 2 questions of the 2nd type: 3 + 3 = 6

    Example 2:
    Input: target = 5, types = [[50,1],[50,2],[50,5]]
    Output: 4
    Explanation: You can earn 5 points in one of the four ways:
                 - Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5
                 - Solve 3 questions of the 0th type and 1 question of the 1st
                   type: 1 + 1 + 1 + 2 = 5
                 - Solve 1 questions of the 0th type and 2 questions of the 1st
                   type: 1 + 2 + 2 = 5
                 - Solve 1 question of the 2nd type: 5

    Example 3:
    Input: target = 18, types = [[6,1],[3,2],[2,3]]
    Output: 1
    Explanation: You can only earn 18 points by answering all questions.

    Constraints:
    * 1 <= target <= 1000
    * n == types.length
    * 1 <= n <= 50
    * types[i].length == 2
    * 1 <= counti, marksi <= 50*/

    public int waysToReachTarget(int target, int[][] types) {
        int n = types.length;
        long[][] dp = new long[target+1][n+1];
        for (int j = 0; j <= n; ++j) dp[0][j] = 1;
        for (int i = 1; i <= target; ++i) {
            for (int j = n-1; j >= 0; --j) {
                int c = types[j][0], m = types[j][1];
                for (int x = 0; x <= c && i-x*m >= 0; ++x)
                    dp[i][j] = (dp[i][j] + dp[i-x*m][j+1]) % 1_000_000_007;
            }
        }
        return (int) dp[target][0];
    }


    /*2586. Count the Number of Vowel Strings in Range (Easy)
    You are given a 0-indexed array of string words and two integers left and
    right. A string is called a vowel string if it starts with a vowel
    character and ends with a vowel character where vowel characters are 'a',
    'e', 'i', 'o', and 'u'. Return the number of vowel strings words[i] where i
    belongs to the inclusive range [left, right].

    Example 1:
    Input: words = ["are","amy","u"], left = 0, right = 2
    Output: 2
    Explanation: - "are" is a vowel string because it starts with 'a' and ends
                   with 'e'.
                 - "amy" is not a vowel string because it does not end with a
                   vowel.
                 - "u" is a vowel string because it starts with 'u' and ends
                   with 'u'.
                 The number of vowel strings in the mentioned range is 2.

    Example 2:
    Input: words = ["hey","aeo","mu","ooo","artro"], left = 1, right = 4
    Output: 3
    Explanation: - "aeo" is a vowel string because it starts with 'a' and ends
                   with 'o'.
                 - "mu" is not a vowel string because it does not start with a
                   vowel.
                 - "ooo" is a vowel string because it starts with 'o' and ends
                   with 'o'.
                 - "artro" is a vowel string because it starts with 'a' and
                   ends with 'o'.
                 The number of vowel strings in the mentioned range is 3.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 10
    * words[i] consists of only lowercase English letters.
    * 0 <= left <= right < words.length*/

    public int vowelStrings(String[] words, int left, int right) {
        int ans = 0;
        for (int i = left; i <= right; ++i)
            if ("aeiou".indexOf(words[i].charAt(0)) != -1 && "aeiou".indexOf(words[i].charAt(words[i].length()-1)) != -1) ++ans;
        return ans;
    }


    /*2587. Rearrange Array to Maximize Prefix Score (Medium)
    You are given a 0-indexed integer array nums. You can rearrange the
    elements of nums to any order (including the given order). Let prefix be
    the array containing the prefix sums of nums after rearranging it. In other
    words, prefix[i] is the sum of the elements from 0 to i in nums after
    rearranging it. The score of nums is the number of positive integers in the
    array prefix. Return the maximum score you can achieve.

    Example 1:
    Input: nums = [2,-1,0,1,-3,3,-3]
    Output: 6
    Explanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].
                 prefix = [2,5,6,5,2,2,-1], so the score is 6. It can be shown
                 that 6 is the maximum score we can obtain.

    Example 2:
    Input: nums = [-2,-3,0]
    Output: 0
    Explanation: Any rearrangement of the array will result in a score of 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^6 <= nums[i] <= 10^6*/

    public int maxScore(int[] nums) {
        long prefix = 0;
        Arrays.sort(nums);
        for (int i = nums.length-1; i >= 0; --i) {
            prefix += nums[i];
            if (prefix <= 0) return nums.length-i-1;
        }
        return nums.length;
    }


    /*2588. Count the Number of Beautiful Subarrays (Medium)
    You are given a 0-indexed integer array nums. In one operation, you can:
    * Choose two different indices i and j such that 0 <= i, j < nums.length.
    * Choose a non-negative integer k such that the kth bit (0-indexed) in the
      binary representation of nums[i] and nums[j] is 1.
    * Subtract 2k from nums[i] and nums[j].
    A subarray is beautiful if it is possible to make all of its elements equal
    to 0 after applying the above operation any number of times. Return the
    number of beautiful subarrays in the array nums. A subarray is a contiguous
    non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [4,3,1,2,4]
    Output: 2
    Explanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and
                 [4,3,1,2,4].
                 - We can make all elements in the subarray [3,1,2] equal to 0
                   in the following way:
                   - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers.
                     The subarray becomes [1, 1, 0].
                   - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers.
                     The subarray becomes [0, 0, 0].
                 - We can make all elements in the subarray [4,3,1,2,4] equal
                   to 0 in the following way:
                   - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both
                     numbers. The subarray becomes [0, 3, 1, 2, 0].
                   - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both
                     numbers. The subarray becomes [0, 2, 0, 2, 0].
                   - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both
                     numbers. The subarray becomes [0, 0, 0, 0, 0].

    Example 2:
    Input: nums = [1,10,4]
    Output: 0
    Explanation: There are no beautiful subarrays in nums.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6*/

    public long beautifulSubarrays(int[] nums) {
        long ans = 0;
        int prefix = 0;
        HashMap<Integer, Integer> freq = new HashMap();
        freq.put(0, 1);
        for (var x : nums) {
            prefix ^= x;
            ans += freq.getOrDefault(prefix, 0);
            freq.merge(prefix, 1, Integer::sum);
        }
        return ans;
    }


    /*2589. Minimum Time to Complete All Tasks (Hard)
    There is a computer that can run an unlimited number of tasks at the same
    time. You are given a 2D integer array tasks where
    tasks[i] = [starti, endi, durationi] indicates that the ith task should run
    for a total of durationi seconds (not necessarily continuous) within the
    inclusive time range [starti, endi]. You may turn on the computer only when
    it needs to run a task. You can also turn it off if it is idle. Return the
    minimum time during which the computer should be turned on to complete all
    tasks.

    Example 1:
    Input: tasks = [[2,3,1],[4,5,1],[1,5,2]]
    Output: 2
    Explanation: - The first task can be run in the inclusive time range [2, 2].
                 - The second task can be run in the inclusive time range [5, 5].
                 - The third task can be run in the two inclusive time ranges
                   [2, 2] and [5, 5].
                 The computer will be on for a total of 2 seconds.

    Example 2:
    Input: tasks = [[1,3,2],[2,5,3],[5,6,2]]
    Output: 4
    Explanation: - The first task can be run in the inclusive time range [2, 3].
                 - The second task can be run in the inclusive time ranges
                   [2, 3] and [5, 5].
                 - The third task can be run in the two inclusive time range
                   [5, 6].
                 The computer will be on for a total of 4 seconds.

    Constraints:
    * 1 <= tasks.length <= 2000
    * tasks[i].length == 3
    * 1 <= starti, endi <= 2000
    * 1 <= durationi <= endi - starti + 1*/

    public int findMinimumTime(int[][] tasks) {
        int[] line = new int[2001];
        Arrays.sort(tasks, (a, b)->Integer.compare(a[1], b[1]));
        for (var t : tasks) {
            int lo = t[0], hi = t[1], time = t[2];
            for (int x = lo; x <= hi && time > 0; ++x) time -= line[x];
            for (int x = hi; x >= lo && time > 0; --x) {
                if (line[x] == 0) {
                    line[x] = 1;
                    --time;
                }
            }
        }
        return Arrays.stream(line).sum();
    }


    /*2591. Distribute Money to Maximum Children (Easy)
    You are given an integer money denoting the amount of money (in dollars)
    that you have and another integer children denoting the number of children
    that you must distribute the money to. You have to distribute the money
    according to the following rules:
    * All money must be distributed.
    * Everyone must receive at least 1 dollar.
    * Nobody receives 4 dollars.
    Return the maximum number of children who may receive exactly 8 dollars if
    you distribute the money according to the aforementioned rules. If there is
    no way to distribute the money, return -1.

    Example 1:
    Input: money = 20, children = 3
    Output: 1
    Explanation: The maximum number of children with 8 dollars will be 1. One
                 of the ways to distribute the money is:
                 - 8 dollars to the first child.
                 - 9 dollars to the second child.
                 - 3 dollars to the third child.
                 It can be proven that no distribution exists such that number
                 of children getting 8 dollars is greater than 1.

    Example 2:
    Input: money = 16, children = 2
    Output: 2
    Explanation: Each child can be given 8 dollars.

    Constraints:
    * 1 <= money <= 200
    * 2 <= children <= 30*/

    public int distMoney(int money, int children) {
        if (money < children) return -1;
        if (money > 8*children) return children-1;
        int ans = (money-children)/7;
        if (ans == children-1 && (money-children) % 7 == 3) --ans;
        return ans;
    }


    /*2592. Maximize Greatness of an Array (Medium)
    You are given a 0-indexed integer array nums. You are allowed to permute
    nums into a new array perm of your choosing. We define the greatness of
    nums be the number of indices 0 <= i < nums.length for which
    perm[i] > nums[i]. Return the maximum possible greatness you can achieve
    after permuting nums.

    Example 1:
    Input: nums = [1,3,5,2,1,3,1]
    Output: 4
    Explanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].
                 At indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we
                 return 4.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 3
    Explanation: We can prove the optimal perm is [2,3,4,1]. At indices = 0, 1,
                 and 2, perm[i] > nums[i]. Hence, we return 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9*/

    public int maximizeGreatness(int[] nums) {
        Arrays.sort(nums);
        int k = 0;
        for (var x : nums)
            if (nums[k] < x) ++k;
        return k;
    }


    /*2593. Find Score of an Array After Marking All Elements (Medium)
    You are given an array nums consisting of positive integers. Starting with
    score = 0, apply the following algorithm:
    * Choose the smallest integer of the array that is not marked. If there is
      a tie, choose the one with the smallest index.
    * Add the value of the chosen integer to score.
    * Mark the chosen element and its two adjacent elements if they exist.
    * Repeat until all the array elements are marked.
    Return the score you get after applying the above algorithm.

    Example 1:
    Input: nums = [2,1,3,4,5,2]
    Output: 7
    Explanation: We mark the elements as follows:
                 - 1 is the smallest unmarked element, so we mark it and its
                   two adjacent elements: [2,1,3,4,5,2].
                 - 2 is the smallest unmarked element, so we mark it and its
                   left adjacent element: [2,1,3,4,5,2].
                 - 4 is the only remaining unmarked element, so we mark it:
                   [2,1,3,4,5,2].
                 Our score is 1 + 2 + 4 = 7.

    Example 2:
    Input: nums = [2,3,5,1,3,2]
    Output: 5
    Explanation: We mark the elements as follows:
                 - 1 is the smallest unmarked element, so we mark it and its
                   two adjacent elements: [2,3,5,1,3,2].
                 - 2 is the smallest unmarked element, since there are two of
                   them, we choose the left-most one, so we mark the one at
                   index 0 and its right adjacent element: [2,3,5,1,3,2].
                 - 2 is the only remaining unmarked element, so we mark it:
                   [2,3,5,1,3,2].
                 Our score is 1 + 2 + 2 = 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    public long findScore(int[] nums) {
        int n = nums.length;
        long ans = 0;
        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));
        for (int i = 0; i < n; ++i)
            pq.add(new int[] {nums[i], i});
        boolean[] mark = new boolean[n];
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            int x = elem[0], i = elem[1];
            if (!mark[i]) {
                ans += x;
                mark[i] = true;
                if (i > 0) mark[i-1] = true;
                if (i+1 < n) mark[i+1] = true;
            }
        }
        return ans;
    }


    /*2594. Minimum Time to Repair Cars (Medium)
    You are given an integer array ranks representing the ranks of some
    mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r
    can repair n cars in r * n2 minutes. You are also given an integer cars
    representing the total number of cars waiting in the garage to be repaired.
    Return the minimum time taken to repair all the cars. Note: All the
    mechanics can repair the cars simultaneously.

    Example 1:
    Input: ranks = [4,2,3,1], cars = 10
    Output: 16
    Explanation: - The first mechanic will repair two cars. The time required
                   is 4 * 2 * 2 = 16 minutes.
                 - The second mechanic will repair two cars. The time required
                   is 2 * 2 * 2 = 8 minutes.
                 - The third mechanic will repair two cars. The time required
                   is 3 * 2 * 2 = 12 minutes.
                 - The fourth mechanic will repair four cars. The time required
                   is 1 * 4 * 4 = 16 minutes.
                 It can be proved that the cars cannot be repaired in less than
                 16 minutes.

    Example 2:
    Input: ranks = [5,1,8], cars = 6
    Output: 16
    Explanation: - The first mechanic will repair one car. The time required is
                   5 * 1 * 1 = 5 minutes.
                 - The second mechanic will repair four cars. The time required
                   is 1 * 4 * 4 = 16 minutes.
                 - The third mechanic will repair one car. The time required is
                   8 * 1 * 1 = 8 minutes.
                 It can be proved that the cars cannot be repaired in less than
                 16 minutes.

    Constraints:
    * 1 <= ranks.length <= 10^5
    * 1 <= ranks[i] <= 100
    * 1 <= cars <= 10^6*/

    public long repairCars(int[] ranks, int cars) {
        long lo = 0, hi = (long) Arrays.stream(ranks).max().getAsInt() * cars * cars;
        while (lo < hi) {
            long mid = lo + (hi - lo)/2, cnt = 0;
            for (var x : ranks) cnt += Math.sqrt(mid/x);
            if (cnt < cars) lo = mid+1;
            else hi = mid;
        }
        return lo;
    }


    /*2595. Number of Even and Odd Bits (Easy)
    You are given a positive integer n. Let even denote the number of even
    indices in the binary representation of n (0-indexed) with value 1. Let odd
    denote the number of odd indices in the binary representation of n
    (0-indexed) with value 1. Return an integer array answer where
    answer = [even, odd].

    Example 1:
    Input: n = 17
    Output: [2,0]
    Explanation: The binary representation of 17 is 10001. It contains 1 on the
                 0th and 4th indices. There are 2 even and 0 odd indices.

    Example 2:
    Input: n = 2
    Output: [0,1]
    Explanation: The binary representation of 2 is 10. It contains 1 on the 1st
                 index. There are 0 even and 1 odd indices.

    Constraints: 1 <= n <= 1000*/

    public int[] evenOddBit(int n) {
        int[] ans = new int[2];
        for (int i = 0; n > 0; n >>= 1, i ^= 1)
            if (n % 2 == 1) ++ans[i];
        return ans;
    }


    /*2596. Check Knight Tour Configuration (Medium)
    There is a knight on an n x n chessboard. In a valid configuration, the
    knight starts at the top-left cell of the board and visits every cell on
    the board exactly once. You are given an n x n integer matrix grid
    consisting of distinct integers from the range [0, n * n - 1] where
    grid[row][col] indicates that the cell (row, col) is the grid[row][col]th
    cell that the knight visited. The moves are 0-indexed. Return true if grid
    represents a valid configuration of the knight's movements or false
    otherwise. Note that a valid knight move consists of moving two squares
    vertically and one square horizontally, or two squares horizontally and one
    square vertically. The figure below illustrates all the possible eight
    moves of a knight from some cell.

    Example 1:
    Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
    Output: true
    Explanation: The above diagram represents the grid. It can be shown that it
                 is a valid configuration.

    Example 2:
    Input: grid = [[0,3,6],[5,8,1],[2,7,4]]
    Output: false
    Explanation: The above diagram represents the grid. The 8th move of the
                 knight is not valid considering its position after the 7th
                 move.

    Constraints:
    * n == grid.length == grid[i].length
    * 3 <= n <= 7
    * 0 <= grid[row][col] < n * n
    * All integers in grid are unique.*/

    public boolean checkValidGrid(int[][] grid) {
        int n = grid.length;
        HashMap<Integer, Pair<Integer, Integer>> loc = new HashMap();
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                loc.put(grid[i][j], new Pair(i, j));
        for (int i = 0, j = 0, ii = 0, jj = 0, x = 1; x < n*n; ++x, ii = i, jj = j) {
            i = loc.get(x).getKey();
            j = loc.get(x).getValue();
            int di = Math.abs(i-ii), dj = Math.abs(j-jj);
            if (!(di == 1 && dj == 2 || di == 2 && dj == 1)) return false;
        }
        return true;
    }


    /*2597. The Number of Beautiful Subsets (Medium)
    You are given an array nums of positive integers and a positive integer k.
    A subset of nums is beautiful if it does not contain two integers with an
    absolute difference equal to k. Return the number of non-empty beautiful
    subsets of the array nums. A subset of nums is an array that can be
    obtained by deleting some (possibly none) elements from nums. Two subsets
    are different if and only if the chosen indices to delete are different.

    Example 1:
    Input: nums = [2,4,6], k = 2
    Output: 4
    Explanation: The beautiful subsets of the array nums are: [2], [4], [6],
                 [2, 6]. It can be proved that there are only 4 beautiful
                 subsets in the array [2,4,6].

    Example 2:
    Input: nums = [1], k = 1
    Output: 1
    Explanation: The beautiful subset of the array nums is [1]. It can be
                 proved that there is only 1 beautiful subset in the array [1].

    Constraints:
    * 1 <= nums.length <= 20
    * 1 <= nums[i], k <= 1000*/

    public int beautifulSubsets(int[] nums, int k) {
        Map<Integer, Integer> freq = new HashMap();
        for (var x : nums) freq.merge(x, 1, Integer::sum);
        Map<Integer, List<Integer>> mp = new HashMap();
        List<Integer> keys = new ArrayList();
        for (var x : freq.keySet()) keys.add(x);
        Collections.sort(keys);
        for (var x : keys) {
            mp.putIfAbsent(x-k, new ArrayList());
            mp.get(x-k).add(x);
            mp.put(x, mp.get(x-k));
            mp.remove(x-k);
        }
        int ans = 1;
        for (var v : mp.values()) {
            int f0 = 1, f1 = 1;
            for (var x : v) {
                int f2 = f0*((int) Math.pow(2, freq.get(x))-1) + f1;
                f0 = f1;
                f1 = f2;
            }
            ans *= f1;
        }
        return ans-1;
    }


    /*2598. Smallest Missing Non-negative Integer After Operations (Medium)
    You are given a 0-indexed integer array nums and an integer value. In one
    operation, you can add or subtract value from any element of nums.
    * For example, if nums = [1,2,3] and value = 2, you can choose to subtract
      value from nums[0] to make nums = [-1,2,3].
    The MEX (minimum excluded) of an array is the smallest missing non-
    negative integer in it.
    * For example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.
    Return the maximum MEX of nums after applying the mentioned operation any
    number of times.

    Example 1:
    Input: nums = [1,-10,7,13,6,8], value = 5
    Output: 4
    Explanation: One can achieve this result by applying the following
                 operations:
                 - Add value to nums[1] twice to make nums = [1,0,7,13,6,8]
                 - Subtract value from nums[2] once to make
                   nums = [1,0,2,13,6,8]
                 - Subtract value from nums[3] twice to make
                   nums = [1,0,2,3,6,8]
                 The MEX of nums is 4. It can be shown that 4 is the maximum
                 MEX we can achieve.

    Example 2:
    Input: nums = [1,-10,7,13,6,8], value = 7
    Output: 2
    Explanation: One can achieve this result by applying the following
                 operation:
                 - subtract value from nums[2] once to make
                   nums = [1,-10,0,13,6,8]
                 The MEX of nums is 2. It can be shown that 2 is the maximum
                 MEX we can achieve.

    Constraints:
    * 1 <= nums.length, value <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    public int findSmallestInteger(int[] nums, int value) {
        HashMap<Integer, Integer> freq = new HashMap();
        for (var x : nums) freq.merge((x % value + value) % value, 1, Integer::sum);
        int k = 0;
        for (int x = 1; x < value; ++x)
            if (freq.getOrDefault(x, 0) < freq.getOrDefault(k, 0))
                k = x;
        return k + freq.getOrDefault(k, 0)*value;
    }


    /*2599. Make the Prefix Sum Non-negative (Medium)
    You are given a 0-indexed integer array nums. You can apply the following
    operation any number of times:
    * Pick any element from nums and put it at the end of nums.
    The prefix sum array of nums is an array prefix of the same length as nums
    such that prefix[i] is the sum of all the integers nums[j] where j is in
    the inclusive range [0, i]. Return the minimum number of operations such
    that the prefix sum array does not contain negative integers. The test
    cases are generated such that it is always possible to make the prefix sum
    array non-negative.

    Example 1:
    Input: nums = [2,3,-5,4]
    Output: 0
    Explanation: we do not need to do any operations. The array is [2,3,-5,4].
                 The prefix sum array is [2, 5, 0, 4].

    Example 2:
    Input: nums = [3,-5,-2,6]
    Output: 1
    Explanation: we can do one operation on index 1. The array after the
                 operation is [3,-2,6,-5]. The prefix sum array is [3, 1, 7, 2].

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    public int makePrefSumNonNegative(int[] nums) {
        List<Integer> vals = new ArrayList();
        for (var x : nums) vals.add(x);
        int ans = 0;
        long prefix = 0;
        Queue<Integer> pq = new PriorityQueue();
        for (int i = 0; i < vals.size(); ++i) {
            prefix += vals.get(i);
            pq.add(vals.get(i));
            if (prefix < 0) {
                ++ans;
                int xx = pq.poll();
                prefix -= xx;
                vals.add(xx);
            }
        }
        return ans;
    }


    /*2600. K Items With the Maximum Sum (Easy)
    There is a bag that consists of items, each item has a number 1, 0, or -1
    written on it. You are given four non-negative integers numOnes, numZeros,
    numNegOnes, and k. The bag initially contains:
    * numOnes items with 1s written on them.
    * numZeroes items with 0s written on them.
    * numNegOnes items with -1s written on them.
    We want to pick exactly k items among the available items. Return the
    maximum possible sum of numbers written on the items.

    Example 1:
    Input: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2
    Output: 2
    Explanation: We have a bag of items with numbers written on them
                 {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and
                 get a sum in a total of 2. It can be proven that 2 is the
                 maximum possible sum.

    Example 2:
    Input: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4
    Output: 3
    Explanation: We have a bag of items with numbers written on them
                 {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1
                 item with 0 written on it, and get a sum in a total of 3. It
                 can be proven that 3 is the maximum possible sum.

    Constraints:
    * 0 <= numOnes, numZeros, numNegOnes <= 50
    * 0 <= k <= numOnes + numZeros + numNegOnes*/

    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        return Math.min(k, Math.min(numOnes, 2*numOnes+numZeros-k));
    }


    /*2601. Prime Subtraction Operation (Medium)
    You are given a 0-indexed integer array nums of length n. You can perform
    the following operation as many times as you want:
    * Pick an index i that you haven’t picked before, and pick a prime p
      strictly less than nums[i], then subtract p from nums[i].
    Return true if you can make nums a strictly increasing array using the
    above operation and false otherwise. A strictly increasing array is an
    array whose each element is strictly greater than its preceding element.

    Example 1:
    Input: nums = [4,9,6,10]
    Output: true
    Explanation: In the first operation: Pick i = 0 and p = 3, and then
                 subtract 3 from nums[0], so that nums becomes [1,9,6,10]. In
                 the second operation: i = 1, p = 7, subtract 7 from nums[1],
                 so nums becomes equal to [1,2,6,10]. After the second
                 operation, nums is sorted in strictly increasing order, so the
                 answer is true.

    Example 2:
    Input: nums = [6,8,11,12]
    Output: true
    Explanation: Initially nums is sorted in strictly increasing order, so we
                 don't need to make any operations.

    Example 3:
    Input: nums = [5,8,3]
    Output: false
    Explanation: It can be proven that there is no way to perform operations to
                 make nums sorted in strictly increasing order, so the answer
                 is false.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000
    * nums.length == n*/

    public boolean primeSubOperation(int[] nums) {
        boolean[] sieve = new boolean[1001];
        Arrays.fill(sieve, true);
        sieve[0] = sieve[1] = false;
        for (int x = 2; x*x <= 1000; ++x)
            if (sieve[x])
                for (int xx = x*x; xx <= 1000; xx += x)
                    sieve[xx] = false;
        int prev = 0;
        for (var x : nums) {
            if (prev >= x) return false;
            int p = x-1;
            for (; p > 0; --p)
                if (sieve[p] && x-p > prev) break;
            prev = x-p;
        }
        return true;
    }


    /*2602. Minimum Operations to Make All Array Elements Equal (Medium)
    You are given an array nums consisting of positive integers. You are also
    given an integer array queries of size m. For the ith query, you want to
    make all of the elements of nums equal to queries[i]. You can perform the
    following operation on the array any number of times:
    * Increase or decrease an element of the array by 1.
    Return an array answer of size m where answer[i] is the minimum number of
    operations to make all elements of nums equal to queries[i]. Note that
    after each query the array is reset to its original state.

    Example 1:
    Input: nums = [3,1,6,8], queries = [1,5]
    Output: [14,10]
    Explanation: For the first query we can do the following operations:
                 - Decrease nums[0] 2 times, so that nums = [1,1,6,8].
                 - Decrease nums[2] 5 times, so that nums = [1,1,1,8].
                 - Decrease nums[3] 7 times, so that nums = [1,1,1,1].
                 So the total number of operations for the first query is
                 2 + 5 + 7 = 14. For the second query we can do the following
                 operations:
                 - Increase nums[0] 2 times, so that nums = [5,1,6,8].
                 - Increase nums[1] 4 times, so that nums = [5,5,6,8].
                 - Decrease nums[2] 1 time, so that nums = [5,5,5,8].
                 - Decrease nums[3] 3 times, so that nums = [5,5,5,5].
                 So the total number of operations for the second query is
                 2 + 4 + 1 + 3 = 10.

    Example 2:
    Input: nums = [2,9,6,3], queries = [10]
    Output: [20]
    Explanation: We can increase each value in the array to 10. The total
                 number of operations will be 8 + 1 + 4 + 7 = 20.

    Constraints:
    * n == nums.length
    * m == queries.length
    * 1 <= n, m <= 10^5
    * 1 <= nums[i], queries[i] <= 10^9*/

    public List<Long> minOperations(int[] nums, int[] queries) {
        Arrays.sort(nums);
        int n = nums.length;
        long[] prefix = new long[n+1];
        for (int i = 0; i < n; ++i)
            prefix[i+1] = prefix[i] + nums[i];
        List<Long> ans = new ArrayList();
        for (var q : queries) {
            int lo = 0, hi = n;
            while (lo < hi) {
                int mid = lo + (hi-lo)/2;
                if (nums[mid] < q) lo = mid+1;
                else hi = mid;
            }
            long val = prefix[n] - 2*prefix[lo] + (long) q*(2*lo - n);
            ans.add(val);
        }
        return ans;
    }


    /*2603. Collect Coins in a Tree (Hard)
    There exists an undirected and unrooted tree with n nodes indexed from 0 to
    n - 1. You are given an integer n and a 2D integer array edges of length
    n - 1, where edges[i] = [ai, bi] indicates that there is an edge between
    nodes ai and bi in the tree. You are also given an array coins of size n
    where coins[i] can be either 0 or 1, where 1 indicates the presence of a
    coin in the vertex i. Initially, you choose to start at any vertex in the
    tree. Then, you can perform the following operations any number of times:
    * Collect all the coins that are at a distance of at most 2 from the
      current vertex, or
    * Move to any adjacent vertex in the tree.
    Find the minimum number of edges you need to go through to collect all the
    coins and go back to the initial vertex. Note that if you pass an edge
    several times, you need to count it into the answer several times.

    Example 1:
    Input: coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]
    Output: 2
    Explanation: Start at vertex 2, collect the coin at vertex 0, move to
                 vertex 3, collect the coin at vertex 5 then move back to
                 vertex 2.

    Example 2:
    Input: coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]
    Output: 2
    Explanation: Start at vertex 0, collect the coins at vertices 4 and 3, move
                 to vertex 2,  collect the coin at vertex 7, then move back to
                 vertex 0.

    Constraints:
    * n == coins.length
    * 1 <= n <= 3 * 10^4
    * 0 <= coins[i] <= 1
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * ai != bi
    * edges represents a valid tree.*/

    public int collectTheCoins(int[] coins, int[][] edges) {
        int n = coins.length;
        Set<Integer>[] tree = new HashSet[n];
        for (int i = 0; i < n; ++i) tree[i] = new HashSet();
        for (var e : edges) {
            tree[e[0]].add(e[1]);
            tree[e[1]].add(e[0]);
        }
        Queue<Integer> leaf = new LinkedList();
        for (int i = 0; i < n; ++i) {
            int u = i;
            while (tree[u].size() == 1 && coins[u] == 0) {
                int v = tree[u].iterator().next();
                tree[u].remove(v);
                tree[v].remove(u);
                u = v;
            }
            if (tree[u].size() == 1) leaf.add(u);
        }
        for (int j = 0; j < 2; ++j) {
            for (int sz = leaf.size(); sz > 0; --sz) {
                int u = leaf.poll();
                if (tree[u].size() == 1) {
                    int v = tree[u].iterator().next();
                    tree[u].remove(v);
                    tree[v].remove(u);
                    if (tree[v].size() == 1) leaf.add(v);
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) ans += tree[i].size();
        return ans;
    }


    /*2604. Minimum Time to Eat All Grains (Hard)
    There are n hens and m grains on a line. You are given the initial
    positions of the hens and the grains in two integer arrays hens and grains
    of size n and m respectively. Any hen can eat a grain if they are on the
    same position. The time taken for this is negligible. One hen can also eat
    multiple grains. In 1 second, a hen can move right or left by 1 unit. The
    hens can move simultaneously and independently of each other. Return the
    minimum time to eat all grains if the hens act optimally.

    Example 1:
    Input: hens = [3,6,7], grains = [2,4,7,9]
    Output: 2
    Explanation: One of the ways hens eat all grains in 2 seconds is described
                 below:
                 - The first hen eats the grain at position 2 in 1 second.
                 - The second hen eats the grain at position 4 in 2 seconds.
                 - The third hen eats the grains at positions 7 and 9 in 2
                   seconds.
                 So, the maximum time needed is 2. It can be proven that the
                 hens cannot eat all grains before 2 seconds.

    Example 2:
    Input: hens = [4,6,109,111,213,215], grains = [5,110,214]
    Output: 1
    Explanation: One of the ways hens eat all grains in 1 second is described
                 below:
                 - The first hen eats the grain at position 5 in 1 second.
                 - The fourth hen eats the grain at position 110 in 1 second.
                 - The sixth hen eats the grain at position 214 in 1 second.
                 - The other hens do not move.
                 So, the maximum time needed is 1.

    Constraints:
    * 1 <= hens.length, grains.length <= 2*10^4
    * 0 <= hens[i], grains[j] <= 10^9*/

    public int minimumTime(int[] hens, int[] grains) {
        Arrays.sort(hens);
        Arrays.sort(grains);
        int lo = 0, hi = 1_000_000_000;
        while (lo < hi) {
            int mid = lo + (hi-lo)/2, i = 0;
            for (var h : hens)
                for (int ii = i; i < grains.length && (grains[i] <= h && h-grains[i] <= mid || h <= grains[ii] && grains[i]-h <= mid || grains[ii] <= h && h <= grains[i] && grains[i]-grains[ii]+Math.min(grains[i]-h, h-grains[ii]) <= mid); ++i);
            if (i == grains.length) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }


    /*2605. Form Smallest Number From Two Digit Arrays (Easy)
    Given two arrays of unique digits nums1 and nums2, return the smallest
    number that contains at least one digit from each array.

    Example 1:
    Input: nums1 = [4,1,3], nums2 = [5,7]
    Output: 15
    Explanation: The number 15 contains the digit 1 from nums1 and the digit 5
                 from nums2. It can be proven that 15 is the smallest number we
                 can have.

    Example 2:
    Input: nums1 = [3,5,2,6], nums2 = [3,1,7]
    Output: 3
    Explanation: The number 3 contains the digit 3 which exists in both arrays.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 9
    * 1 <= nums1[i], nums2[i] <= 9
    * All digits in each array are unique.*/

    public int minNumber(int[] nums1, int[] nums2) {
        int m1 = 0, m2 = 0;
        for (var x : nums1) m1 |= 1 << x;
        for (var x : nums2) m2 |= 1 << x;
        for (int x = 0; x <= 9; ++x)
            if ((m1 & 1<<x) > 0 && (m2 & 1<<x) > 0) return x;
        int d1 = Arrays.stream(nums1).min().getAsInt(), d2 = Arrays.stream(nums2).min().getAsInt();
        return 10*Math.min(d1, d2) + Math.max(d1, d2);
    }


    /*2606. Find the Substring With Maximum Cost (Medium)
    You are given a string s, a string chars of distinct characters and an
    integer array vals of the same length as chars. The cost of the substring
    is the sum of the values of each character in the substring. The cost of an
    empty string is considered 0. The value of the character is defined in the
    following way:
    * If the character is not in the string chars, then its value is its
      corresponding position (1-indexed) in the alphabet.
      + For example, the value of 'a' is 1, the value of 'b' is 2, and so on.
        The value of 'z' is 26.
    * Otherwise, assuming i is the index where the character occurs in the
      string chars, then its value is vals[i].
    Return the maximum cost among all substrings of the string s.

    Example 1:
    Input: s = "adaa", chars = "d", vals = [-1000]
    Output: 2
    Explanation: The value of the characters "a" and "d" is 1 and -1000
                 respectively. The substring with the maximum cost is "aa" and
                 its cost is 1 + 1 = 2. It can be proven that 2 is the maximum
                 cost.

    Example 2:
    Input: s = "abc", chars = "abc", vals = [-1,-1,-1]
    Output: 0
    Explanation: The value of the characters "a", "b" and "c" is -1, -1, and -1
                 respectively. The substring with the maximum cost is the empty
                 substring "" and its cost is 0. It can be proven that 0 is the
                 maximum cost.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consist of lowercase English letters.
    * 1 <= chars.length <= 26
    * chars consist of distinct lowercase English letters.
    * vals.length == chars.length
    * -1000 <= vals[i] <= 1000*/

    public int maximumCostSubstring(String s, String chars, int[] vals) {
        HashMap<Character, Integer> mp = new HashMap();
        for (int i = 0; i < chars.length(); ++i)
            mp.put(chars.charAt(i), vals[i]);
        int ans = 0, val = 0;
        for (var ch : s.toCharArray()) {
            val = Math.max(0, val + mp.getOrDefault(ch, ch - 'a' + 1));
            ans = Math.max(ans, val);
        }
        return ans;
    }


    /*2607. Make K-Subarray Sums Equal (Medium)
    You are given a 0-indexed integer array arr and an integer k. The array arr
    is circular. In other words, the first element of the array is the next
    element of the last element, and the last element of the array is the
    previous element of the first element. You can do the following operation
    any number of times:
    * Pick any element from arr and increase or decrease it by 1.
    Return the minimum number of operations such that the sum of each subarray
    of length k is equal. A subarray is a contiguous part of the array.

    Example 1:
    Input: arr = [1,4,1,3], k = 2
    Output: 1
    Explanation: we can do one operation on index 1 to make its value equal to
                 3. The array after the operation is [1,3,1,3]
                 - Subarray starts at index 0 is [1, 3], and its sum is 4
                 - Subarray starts at index 1 is [3, 1], and its sum is 4
                 - Subarray starts at index 2 is [1, 3], and its sum is 4
                 - Subarray starts at index 3 is [3, 1], and its sum is 4

    Example 2:
    Input: arr = [2,5,5,7], k = 3
    Output: 5
    Explanation: we can do three operations on index 0 to make its value equal
                 to 5 and two operations on index 3 to make its value equal to
                 5. The array after the operations is [5,5,5,5]
                 - Subarray starts at index 0 is [5, 5, 5], and its sum is 15
                 - Subarray starts at index 1 is [5, 5, 5], and its sum is 15
                 - Subarray starts at index 2 is [5, 5, 5], and its sum is 15
                 - Subarray starts at index 3 is [5, 5, 5], and its sum is 15

    Constraints:
    * 1 <= k <= arr.length <= 10^5
    * 1 <= arr[i] <= 10^9*/

    public long makeSubKSumEqual(int[] arr, int k) {
        long ans = 0;
        int n = arr.length, g = n;
        for (int v = k; v > 0; ) {
            int gg = g; g = v; v = gg % v;
        }
        for (int i = 0; i < g; ++i) {
            int[] vals = new int[n/g];
            for (int j = 0; j < n/g; ++j, i = (i+k) % n)
                vals[j] = arr[i];
            Arrays.sort(vals);
            int target = vals[vals.length/2];
            for (var x : vals) ans += Math.abs(x - target);
        }
        return ans;
    }


    /*2608. Shortest Cycle in a Graph (Hard)
    There is a bi-directional graph with n vertices, where each vertex is
    labeled from 0 to n - 1. The edges in the graph are represented by a given
    2D integer array edges, where edges[i] = [ui, vi] denotes an edge between
    vertex ui and vertex vi. Every vertex pair is connected by at most one
    edge, and no vertex has an edge to itself. Return the length of the
    shortest cycle in the graph. If no cycle exists, return -1. A cycle is a
    path that starts and ends at the same node, and each edge in the path is
    used only once.

    Example 1:
    Input: n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]
    Output: 3
    Explanation: The cycle with the smallest length is : 0 -> 1 -> 2 -> 0

    Example 2:
    Input: n = 4, edges = [[0,1],[0,2]]
    Output: -1
    Explanation: There are no cycles in this graph.

    Constraints:
    * 2 <= n <= 1000
    * 1 <= edges.length <= 1000
    * edges[i].length == 2
    * 0 <= ui, vi < n
    * ui != vi
    * There are no repeated edges.*/

    public int findShortestCycle(int n, int[][] edges) {
        List<Integer>[] graph = new ArrayList[n];
        for (int u = 0; u < n; ++u) graph[u] = new ArrayList();
        for (var e : edges) {
            graph[e[0]].add(e[1]);
            graph[e[1]].add(e[0]);
        }
        int ans = Integer.MAX_VALUE;
        for (int x = 0; x < n; ++x) {
            int[] dist = new int[n];
            Arrays.fill(dist, -1);
            Queue<int[]> q = new LinkedList();
            q.add(new int[] {x, -1, 0});
            while (!q.isEmpty()) {
                var elem = q.poll();
                int u = elem[0], p = elem[1], d = elem[2];
                if (dist[u] >= 0) {
                    ans = Math.min(ans, d + dist[u]);
                    break;
                }
                dist[u] = d;
                for (var v : graph[u])
                    if (v != p) q.add(new int[] {v, u, d+1});
            }
        }
        return ans < Integer.MAX_VALUE ? ans : -1;
    }


    /*2609. Find the Longest Balanced Substring of a Binary String (Easy)
    You are given a binary string s consisting only of zeroes and ones. A
    substring of s is considered balanced if all zeroes are before ones and the
    number of zeroes is equal to the number of ones inside the substring.
    Notice that the empty substring is considered a balanced substring. Return
    the length of the longest balanced substring of s. A substring is a
    contiguous sequence of characters within a string.

    Example 1:
    Input: s = "01000111"
    Output: 6
    Explanation: The longest balanced substring is "000111", which has length 6.

    Example 2:
    Input: s = "00111"
    Output: 4
    Explanation: The longest balanced substring is "0011", which has length 4.

    Example 3:
    Input: s = "111"
    Output: 0
    Explanation: There is no balanced substring except the empty substring, so
                 the answer is 0.

    Constraints:
    * 1 <= s.length <= 50
    * '0' <= s[i] <= '1'*/

    public int findTheLongestBalancedSubstring(String s) {
        int ans = 0, val = 0;
        for (int i = 0, ii = 0, n = s.length(); i <= n; ++i)
            if (i == n || i > 0 && s.charAt(i-1) != s.charAt(i)) {
                if (s.charAt(i-1) == '0') val = i - ii;
                else {
                    val = Math.min(val, i-ii);
                    ans = Math.max(2*val, ans);
                }
                ii = i;
            }
        return ans;
    }


    /*2610. Convert an Array Into a 2D Array With Conditions (Medium)
    You are given an integer array nums. You need to create a 2D array from
    nums satisfying the following conditions:
    * The 2D array should contain only the elements of the array nums.
    * Each row in the 2D array contains distinct integers.
    * The number of rows in the 2D array should be minimal.
    Return the resulting array. If there are multiple answers, return any of
    them. Note that the 2D array can have a different number of elements on
    each row.

    Example 1:
    Input: nums = [1,3,4,1,2,3,1]
    Output: [[1,3,4,2],[1,3],[1]]
    Explanation: We can create a 2D array that contains the following rows:
                 - 1,3,4,2
                 - 1,3
                 - 1
                 All elements of nums were used, and each row of the 2D array
                 contains distinct integers, so it is a valid answer. It can be
                 shown that we cannot have less than 3 rows in a valid array.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: [[4,3,2,1]]
    Explanation: All elements of the array are distinct, so we can keep all of
                 them in the first row of the 2D array.

    Constraints:
    * 1 <= nums.length <= 200
    * 1 <= nums[i] <= nums.length*/

    public List<List<Integer>> findMatrix(int[] nums) {
        int m = 0;
        Map<Integer, Integer> freq = new HashMap();
        for (var x : nums) {
            freq.merge(x, 1, Integer::sum);
            m = Math.max(m, freq.get(x));
        }
        List<List<Integer>> ans = new ArrayList();
        for (int i = 0; i < m; ++i) ans.add(new ArrayList());
        for (var elem : freq.entrySet()) {
            int k = elem.getKey(), v = elem.getValue();
            for (int i = 0; i < v; ++i)
                ans.get(i).add(k);
        }
        return ans;
    }


    /*2611. Mice and Cheese (Medium)
    There are two mice and n different types of cheese, each type of cheese
    should be eaten by exactly one mouse. A point of the cheese with index i
    (0-indexed) is:
    * reward1[i] if the first mouse eats it.
    * reward2[i] if the second mouse eats it.
    You are given a positive integer array reward1, a positive integer array
    reward2, and a non-negative integer k. Return the maximum points the mice
    can achieve if the first mouse eats exactly k types of cheese.

    Example 1:
    Input: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2
    Output: 15
    Explanation: In this example, the first mouse eats the 2nd (0-indexed) and
                 the 3rd types of cheese, and the second mouse eats the 0th and
                 the 1st types of cheese. The total points are
                 4 + 4 + 3 + 4 = 15. It can be proven that 15 is the maximum
                 total points that the mice can achieve.

    Example 2:
    Input: reward1 = [1,1], reward2 = [1,1], k = 2
    Output: 2
    Explanation: In this example, the first mouse eats the 0th (0-indexed) and
                 1st types of cheese, and the second mouse does not eat any
                 cheese. The total points are 1 + 1 = 2. It can be proven that
                 2 is the maximum total points that the mice can achieve.

    Constraints:
    * 1 <= n == reward1.length == reward2.length <= 10^5
    * 1 <= reward1[i], reward2[i] <= 1000
    * 0 <= k <= n*/

    public int miceAndCheese(int[] reward1, int[] reward2, int k) {
        int ans = 0;
        for (int i = 0; i < reward1.length; ++i) {
            ans += reward2[i];
            reward1[i] -= reward2[i];
        }
        Arrays.sort(reward1);
        for (int i = 0, n = reward1.length; i < k; ++i) ans += reward1[n-1-i];
        return ans;
    }


    /*2612. Minimum Reverse Operations (Hard)
    You are given an integer n and an integer p in the range [0, n - 1].
    Representing a 0-indexed array arr of length n where all positions are set
    to 0's, except position p which is set to 1. You are also given an integer
    array banned containing some positions from the array. For the ith position
    in banned, arr[banned[i]] = 0, and banned[i] != p. You can perform multiple
    operations on arr. In an operation, you can choose a subarray with size k
    and reverse the subarray. However, the 1 in arr should never go to any of
    the positions in banned. In other words, after each operation
    arr[banned[i]] remains 0. Return an array ans where for each i from
    [0, n - 1], ans[i] is the minimum number of reverse operations needed to
    bring the 1 to position i in arr, or -1 if it is impossible.
    * A subarray is a contiguous non-empty sequence of elements within an array.
    * The values of ans[i] are independent for all i's.
    * The reverse of an array is an array containing the values in reverse
      order.

    Example 1:
    Input: n = 4, p = 0, banned = [1,2], k = 4
    Output: [0,-1,-1,1]
    Explanation: In this case k = 4 so there is only one possible reverse
                 operation we can perform, which is reversing the whole array.
                 Initially, 1 is placed at position 0 so the amount of
                 operations we need for position 0 is 0. We can never place a 1
                 on the banned positions, so the answer for positions 1 and 2
                 is -1. Finally, with one reverse operation we can bring the 1
                 to index 3, so the answer for position 3 is 1.

    Example 2:
    Input: n = 5, p = 0, banned = [2,4], k = 3
    Output: [0,-1,-1,-1,-1]
    Explanation: In this case the 1 is initially at position 0, so the answer
                 for that position is 0. We can perform reverse operations of
                 size 3. The 1 is currently located at position 0, so we need
                 to reverse the subarray [0, 2] for it to leave that position,
                 but reversing that subarray makes position 2 have a 1, which
                 shouldn't happen. So, we can't move the 1 from position 0,
                 making the result for all the other positions -1.

    Example 3:
    Input: n = 4, p = 2, banned = [0,1,3], k = 1
    Output: [-1,-1,0,-1]
    Explanation: In this case we can only perform reverse operations of size 1.
                 So the 1 never changes its position.

    Constraints:
    * 1 <= n <= 10^5
    * 0 <= p <= n - 1
    * 0 <= banned.length <= n - 1
    * 0 <= banned[i] <= n - 1
    * 1 <= k <= n
    * banned[i] != p
    * all values in banned are unique*/

    public int[] minReverseOperations(int n, int p, int[] banned, int k) {
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        boolean[] ban = new boolean[n];
        for (var x : banned) ban[x] = true;
        TreeSet<Integer>[] avail = new TreeSet[2];
        for (int i = 0; i < 2; ++i) avail[i] = new TreeSet();
        for (int i = 0; i < n; ++i)
            if (!ban[i]) avail[i&1].add(i);
        Queue<Integer> q = new LinkedList();
        q.add(p);
        avail[p&1].remove(p);
        for (int val = 0; !q.isEmpty(); ++val)
            for (int sz = q.size(); sz > 0; --sz) {
                var v = q.poll();
                ans[v] = val;
                int lo = Math.abs(v-k+1), hi = n-1-Math.abs(n-v-k);
                Integer x = avail[lo&1].ceiling(lo);
                while (x != null && x <= hi) {
                    q.add(x);
                    avail[lo&1].remove(x);
                    x = avail[lo&1].higher(x);
                }
            }
        return ans;
    }


    /*2613. Beautiful Pairs (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2 of the same
    length. A pair of indices (i,j) is called beautiful if
    |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]| is the smallest amongst all
    possible indices pairs where i < j. Return the beautiful pair. In the case
    that there are multiple beautiful pairs, return the lexicographically
    smallest pair. Note that
    * |x| denotes the absolute value of x.
    * A pair of indices (i1, j1) is lexicographically smaller than (i2, j2) if
      i1 < i2 or i1 == i2 and j1 < j2.

    Example 1:
    Input: nums1 = [1,2,3,2,4], nums2 = [2,3,1,2,3]
    Output: [0,3]
    Explanation: Consider index 0 and index 3. The value of
                 |nums1[i]-nums1[j]| + |nums2[i]-nums2[j]| is 1, which is the
                 smallest value we can achieve.

    Example 2:
    Input: nums1 = [1,2,4,3,2,5], nums2 = [1,4,2,3,5,1]
    Output: [1,4]
    Explanation: Consider index 1 and index 4. The value of
                 |nums1[i]-nums1[j]| + |nums2[i]-nums2[j]| is 1, which is the
                 smallest value we can achieve.

    Constraints:
    * 2 <= nums1.length, nums2.length <= 10^5
    * nums1.length == nums2.length
    * 0 <= nums1i <= nums1.length
    * 0 <= nums2i <= nums2.length*/

    private int[] solve(int lo, int hi, int[][] points) {
        int delta = Integer.MAX_VALUE, i = -1, ii = -1;
        if (lo+2 == hi) {
            delta = Math.abs(points[lo][1] - points[lo+1][1]) + Math.abs(points[lo][2] - points[lo+1][2]);
            i = Math.min(points[lo][0], points[lo+1][0]);
            ii = Math.max(points[lo][0], points[lo+1][0]);
        } else if (lo+2 < hi) {
            int mid = (lo + hi)/2;
            var left = solve(lo, mid, points);
            int ld = left[0], li = left[1], lii = left[2];
            var right = solve(mid, hi, points);
            int rd = right[0], ri = right[1], rii = right[2];
            if (ld < rd || ld == rd && li < ri) { delta = ld; i = li; ii = lii; }
            else { delta = rd; i = ri; ii = rii; }
            int split = points[mid][1];
            List<int[]> strip = new ArrayList();
            for (int k = lo; k < hi; ++k)
                if (split-delta <= points[k][1] && points[k][1] <= split+delta) strip.add(points[k]);
            Collections.sort(strip, (a, b)->Integer.compare(a[2], b[2]));
            for (int k = 0, n = strip.size(); k < n; ++k) {
                int x = strip.get(k)[1], y = strip.get(k)[2];
                for (int kk = k+1; kk < n && kk < k+10; ++kk) {
                    int xx = strip.get(kk)[1], yy = strip.get(kk)[2], cand = Math.abs(x-xx) + Math.abs(y-yy);
                    int j = Math.min(strip.get(k)[0], strip.get(kk)[0]), jj = Math.max(strip.get(k)[0], strip.get(kk)[0]);
                    if (cand < delta || cand == delta && (j < i || j == i && jj < ii)) { delta = cand; i = j; ii = jj; }
                }
            }
        }
        return new int[]{delta, i, ii};
    }

    public int[] beautifulPair(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int[][] points = new int[n][3];
        for (int i = 0; i < n; ++i)
            points[i] = new int[]{i, nums1[i], nums2[i]};
        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));
        var ans = solve(0, n, points);
        return new int[]{ans[1], ans[2]};
    }


    /*2614. Prime In Diagonal (Easy)
    You are given a 0-indexed two-dimensional integer array nums. Return the
    largest prime number that lies on at least one of the diagonals of nums. In
    case, no prime is present on any of the diagonals, return 0. Note that:
    * An integer is prime if it is greater than 1 and has no positive integer
      divisors other than 1 and itself.
    * An integer val is on one of thediagonals of nums if there exists an
      integer i for which nums[i][i] = val or an i for which
      nums[i][nums.length - i - 1]= val.
    In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].

    Example 1:
    Input: nums = [[1,2,3],[5,6,7],[9,10,11]]
    Output: 11
    Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on
                 at least one of the diagonals. Since 11 is the largest prime,
                 we return 11.

    Example 2:
    Input: nums = [[1,2,3],[5,17,7],[9,11,10]]
    Output: 17
    Explanation: The numbers 1, 3, 9, 10, and 17 are all present on at least
                 one of the diagonals. 17 is the largest prime, so we return 17.

    Constraints:
    * 1 <= nums.length <= 300
    * nums.length == numsi.length
    * 1 <= nums[i][j] <= 4*10^6*/

    private boolean fn(int x) {
        if (x == 1) return false;
        for (int p = 2; p <= Math.sqrt(x); ++p)
            if (x % p == 0) return false;
        return true;
    }

    public int diagonalPrime(int[][] nums) {
        int ans = 0;
        for (int i = 0, n = nums.length; i < n; ++i) {
            if (fn(nums[i][i])) ans = Math.max(ans, nums[i][i]);
            if (fn(nums[i][n-1-i])) ans = Math.max(ans, nums[i][n-1-i]);
        }
        return ans;
    }


    /*2615. Sum of Distances (Medium)
    You are given a 0-indexed integer array nums. There exists an array arr of
    length nums.length, where arr[i] is the sum of |i - j| over all j such that
    nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0.
    Return the array arr.

    Example 1:
    Input: nums = [1,3,1,1,2]
    Output: [5,0,3,4,0]
    Explanation: - When i = 0, nums[0] == nums[2] and nums[0] == nums[3].
                 Therefore, arr[0] = |0 - 2| + |0 - 3| = 5.
                 - When i = 1, arr[1] = 0 because there is no other index with
                   value 3.
                 - When i = 2, nums[2] == nums[0] and nums[2] == nums[3].
                   Therefore, arr[2] = |2 - 0| + |2 - 3| = 3.
                 - When i = 3, nums[3] == nums[0] and nums[3] == nums[2].
                   Therefore, arr[3] = |3 - 0| + |3 - 2| = 4.
                 - When i = 4, arr[4] = 0 because there is no other index with
                   value 2.

    Example 2:
    Input: nums = [0,5,3]
    Output: [0,0,0]
    Explanation: Since each element in nums is distinct, arr[i] = 0 for all i.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9*/

    public long[] distance(int[] nums) {
        Map<Integer, List<Integer>> mp = new HashMap();
        for (int i = 0; i < nums.length; ++i) {
            mp.putIfAbsent(nums[i], new ArrayList());
            mp.get(nums[i]).add(i);
        }
        long[] ans = new long[nums.length];
        for (var idx : mp.values()) {
            int n = idx.size();
            long[] prefix = new long[n+1];
            for (int i = 0; i < n; ++i) prefix[i+1] = prefix[i] + idx.get(i);
            for (int i = 0; i < n; ++i)
                ans[idx.get(i)] = prefix[n] - 2*prefix[i] + (long) (2*i - n)*idx.get(i);
        }
        return ans;
    }


    /*2616. Minimize the Maximum Difference of Pairs (Medium)
    You are given a 0-indexed integer array nums and an integer p. Find p pairs
    of indices of nums such that the maximum difference amongst all the pairs
    is minimized. Also, ensure no index appears more than once amongst the p
    pairs. Note that for a pair of elements at the index i and j, the
    difference of this pair is |nums[i] - nums[j]|, where |x| represents the
    absolute value of x. Return the minimum maximum difference among all p
    pairs.

    Example 1:
    Input: nums = [10,1,2,7,1,3], p = 2
    Output: 1
    Explanation: The first pair is formed from the indices 1 and 4, and the
                 second pair is formed from the indices 2 and 5. The maximum
                 difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|)
                 = max(0, 1) = 1. Therefore, we return 1.

    Example 2:
    Input: nums = [4,2,1,2], p = 1
    Output: 0
    Explanation: Let the indices 1 and 3 form a pair. The difference of that
                 pair is |2 - 2| = 0, which is the minimum we can attain.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 0 <= p <= (nums.length)/2*/

    public int minimizeMax(int[] nums, int p) {
        Arrays.sort(nums);
        int lo = 0, hi = 1_000_000_000;
        while (lo < hi) {
            int mid = lo + (hi-lo)/2, cnt = 0;
            for (int i = 0, n = nums.length; i < n; ++i)
                if (i+1 < n && nums[i+1] - nums[i] <= mid) {
                    ++cnt;
                    ++i;
                }
            if (cnt < p) lo = mid+1;
            else hi = mid;
        }
        return lo;
    }


    /*2617. Minimum Number of Visited Cells in a Grid (Hard)
    You are given a 0-indexed m x n integer matrix grid. Your initial position
    is at the top-left cell (0, 0). Starting from the cell (i, j), you can move
    to one of the following cells:
    * Cells (i, k) with j < k <= grid[i][j] + j (rightward movement), or
    * Cells (k, j) with i < k <= grid[i][j] + i (downward movement).
    Return the minimum number of cells you need to visit to reach the bottom-
    right cell (m - 1, n - 1). If there is no valid path, return -1.

    Example 1:
    Input: grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
    Output: 4
    Explanation: The image above shows one of the paths that visits exactly 4 cells.

    Example 2:
    Input: grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
    Output: 3
    Explanation: The image above shows one of the paths that visits exactly 3 cells.

    Example 3:
    Input: grid = [[2,1,0],[1,0,0]]
    Output: -1
    Explanation: It can be proven that no path exists.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 105
    * 1 <= m * n <= 105
    * 0 <= grid[i][j] < m * n
    * grid[m - 1][n - 1] == 0*/

    public int minimumVisitedCells(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        Queue<int[]>[] pqs = new PriorityQueue[n];
        for (int j = 0; j < n; ++j) pqs[j] = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        int[][] dist = new int[m][n];
        for (int i = 0; i < m; ++i) Arrays.fill(dist[i], Integer.MAX_VALUE);
        dist[0][0] = 1;
        for (int i = 0; i < m; ++i) {
            Queue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
            for (int j = 0; j < n; ++j) {
                while (!pq.isEmpty() && pq.peek()[1] < j) pq.poll();
                while (!pqs[j].isEmpty() && pqs[j].peek()[1] < i) pqs[j].poll();
                if (!pq.isEmpty()) dist[i][j] = Math.min(dist[i][j], pq.peek()[0] + 1);
                if (!pqs[j].isEmpty()) dist[i][j] = Math.min(dist[i][j], pqs[j].peek()[0] + 1);
                if (dist[i][j] < Integer.MAX_VALUE) {
                    pq.add(new int[] {dist[i][j], j + grid[i][j]});
                    pqs[j].add(new int[] {dist[i][j], i + grid[i][j]});
                }
            }
        }
        return dist[m-1][n-1] < Integer.MAX_VALUE ? dist[m-1][n-1] : -1;
    }


    /*2638. Count the Number of K-Free Subsets (Medium)
    You are given an integer array nums, which contains distinct elements and
    an integer k. A subset is called a k-Free subset if it contains no two
    elements with an absolute difference equal to k. Notice that the empty set
    is a k-Free subset. Return the number of k-Free subsets of nums. A subset
    of an array is a selection of elements (possibly none) of the array.

    Example 1:
    Input: nums = [5,4,6], k = 1
    Output: 5
    Explanation: There are 5 valid subsets: {}, {5}, {4}, {6} and {4, 6}.

    Example 2:
    Input: nums = [2,3,5,8], k = 5
    Output: 12
    Explanation: There are 12 valid subsets: {}, {2}, {3}, {5}, {8}, {2, 3},
                 {2, 3, 5}, {2, 5}, {2, 5, 8}, {2, 8}, {3, 5} and {5, 8}.

    Example 3:
    Input: nums = [10,5,9,11], k = 20
    Output: 16
    Explanation: All subsets are valid. Since the total count of subsets is
                 2^4 = 16, so the answer is 16.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 1000
    * 1 <= k <= 1000*/

    public long countTheNumOfKFreeSubsets(int[] nums, int k) {
        Arrays.sort(nums);
        Map<Integer, Integer> size = new HashMap();
        int m = 0;
        for (var x : nums) {
            size.put(x, 1 + size.getOrDefault(x-k, 0));
            size.remove(x-k);
            m = Math.max(m, size.get(x));
        }
        long[] fib = new long[m+2];
        fib[0] = fib[1] = 1;
        for (int i = 2; i < m+2; ++i) fib[i] = fib[i-2] + fib[i-1];
        long ans = 1;
        for (var v : size.values())
            ans *= fib[v+1];
        return ans;
    }


    /*2639. Find the Width of Columns of a Grid (Easy)
    You are given a 0-indexed m x n integer matrix grid. The width of a column
    is the maximum length of its integers.
    * For example, if grid = [[-10], [3], [12]], the width of the only column
      is 3 since -10 is of length 3.
    Return an integer array ans of size n where ans[i] is the width of the ith
    column. The length of an integer x with len digits is equal to len if x is
    non-negative, and len + 1 otherwise.

    Example 1:
    Input: grid = [[1],[22],[333]]
    Output: [3]
    Explanation: In the 0th column, 333 is of length 3.

    Example 2:
    Input: grid = [[-15,1,3],[15,7,12],[5,6,-2]]
    Output: [3,1,2]
    Explanation: In the 0th column, only -15 is of length 3.
                 In the 1st column, all integers are of length 1.
                 In the 2nd column, both 12 and -2 are of length 2.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 100
    * -10^9 <= grid[r][c] <= 10^9*/

    public int[] findColumnWidth(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[] ans = new int[n];
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                int val = 0;
                for (int x = grid[i][j]; x != 0; ++val, x /= 10);
                if (grid[i][j] < 0) ++val;
                ans[j] = Math.max(ans[j], Math.max(1, val));
            }
        return ans;
    }


    /*2640. Find the Score of All Prefixes of an Array (Medium)
    We define the conversion array conver of an array arr as follows:
    * conver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum
      value of arr[j] over 0 <= j <= i.
    We also define the score of an array arr as the sum of the values of the
    conversion array of arr. Given a 0-indexed integer array nums of length n,
    return an array ans of length n where ans[i] is the score of the prefix
    nums[0..i].

    Example 1:
    Input: nums = [2,3,7,5,10]
    Output: [4,10,24,36,56]
    Explanation: - For the prefix [2], the conversion array is [4] hence the
                   score is 4
                 - For the prefix [2, 3], the conversion array is [4, 6] hence
                   the score is 10
                 - For the prefix [2, 3, 7], the conversion array is [4, 6, 14]
                   hence the score is 24
                 - For the prefix [2, 3, 7, 5], the conversion array is
                   [4, 6, 14, 12] hence the score is 36
                 - For the prefix [2, 3, 7, 5, 10], the conversion array is
                   [4, 6, 14, 12, 20] hence the score is 56

    Example 2:
    Input: nums = [1,1,2,4,8,16]
    Output: [2,4,8,16,32,64]
    Explanation: - For the prefix [1], the conversion array is [2] hence the
                   score is 2
                 - For the prefix [1, 1], the conversion array is [2, 2] hence
                   the score is 4
                 - For the prefix [1, 1, 2], the conversion array is [2, 2, 4]
                   hence the score is 8
                 - For the prefix [1, 1, 2, 4], the conversion array is
                   [2, 2, 4, 8] hence the score is 16
                 - For the prefix [1, 1, 2, 4, 8], the conversion array is
                   [2, 2, 4, 8, 16] hence the score is 32
                 - For the prefix [1, 1, 2, 4, 8, 16], the conversion array is
                   [2, 2, 4, 8, 16, 32] hence the score is 64

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public long[] findPrefixScore(int[] nums) {
        long[] ans = new long[nums.length];
        long prefix = 0;
        for (int i = 0, most = 0; i < nums.length; ++i) {
            most = Math.max(most, nums[i]);
            prefix += nums[i] + most;
            ans[i] = prefix;
        }
        return ans;
    }



    /*2641. Cousins in Binary Tree II (Medium)
    Given the root of a binary tree, replace the value of each node in the tree
    with the sum of all its cousins' values. Two nodes of a binary tree are
    cousins if they have the same depth with different parents. Return the root
    of the modified tree. Note that the depth of a node is the number of edges
    in the path from the root node to it.

    Example 1:
    Input: root = [5,4,9,1,10,null,7]
    Output: [0,0,0,7,7,null,11]
    Explanation: The diagram above shows the initial binary tree and the binary
                 tree after changing the value of each node.
                 - Node with value 5 does not have any cousins so its sum is 0.
                 - Node with value 4 does not have any cousins so its sum is 0.
                 - Node with value 9 does not have any cousins so its sum is 0.
                 - Node with value 1 has a cousin with value 7 so its sum is 7.
                 - Node with value 10 has a cousin with value 7 so its sum is 7.
                 - Node with value 7 has cousins with values 1 and 10 so its
                   sum is 11.

    Example 2:
    Input: root = [3,1,2]
    Output: [0,0,0]
    Explanation: The diagram above shows the initial binary tree and the binary
                 tree after changing the value of each node.
                 - Node with value 3 does not have any cousins so its sum is 0.
                 - Node with value 1 does not have any cousins so its sum is 0.
                 - Node with value 2 does not have any cousins so its sum is 0.

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^5].
    * 1 <= Node.val <= 10^4*/

    public TreeNode replaceValueInTree(TreeNode root) {
        List<Integer> total = new ArrayList();
        Map<TreeNode, Integer> mp = new HashMap();
        Stack<Object[]> stk = new Stack(); stk.push(new Object[]{root, null, 0});
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            TreeNode node = (TreeNode) elem[0], p = (TreeNode) elem[1];
            int d = (int) elem[2];
            if (total.size() == d) total.add(0);
            total.set(d, total.get(d) + node.val);
            mp.put(p, mp.getOrDefault(p, 0) + node.val);
            if (node.left != null) stk.push(new Object[]{node.left, node, d+1});
            if (node.right != null) stk.push(new Object[]{node.right, node, d+1});
        }
        stk.push(new Object[]{root, null, 0});
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            TreeNode node = (TreeNode) elem[0], p = (TreeNode) elem[1];
            int d = (int) elem[2];
            node.val = total.get(d) - mp.get(p);
            if (node.left != null) stk.push(new Object[]{node.left, node, d+1});
            if (node.right != null) stk.push(new Object[]{node.right, node, d+1});
        }
        return root;
    }


    /*2643. Row With Maximum Ones (Easy)
    Given a m x n binary matrix mat, find the 0-indexed position of the row
    that contains the maximum count of ones, and the number of ones in that row.
    In case there are multiple rows that have the maximum count of ones, the
    row with the smallest row number should be selected. Return an array
    containing the index of the row, and the number of ones in it.

    Example 1:
    Input: mat = [[0,1],[1,0]]
    Output: [0,1]
    Explanation: Both rows have the same number of 1's. So we return the index
                 of the smaller row, 0, and the maximum count of ones (1). So,
                 the answer is [0,1].

    Example 2:
    Input: mat = [[0,0,0],[0,1,1]]
    Output: [1,2]
    Explanation: The row indexed 1 has the maximum count of ones (2). So we
                 return its index, 1, and the count. So, the answer is [1,2].

    Example 3:
    Input: mat = [[0,0],[1,1],[0,0]]
    Output: [1,2]
    Explanation: The row indexed 1 has the maximum count of ones (2). So the
                 answer is [1,2].

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 100
    * mat[i][j] is either 0 or 1.*/

    public int[] rowAndMaximumOnes(int[][] mat) {
        int idx = 0, cnt = 0;
        for (int i = 0; i < mat.length; ++i) {
            int c = 0;
            for (int j = 0; j < mat[i].length; ++j)
                if (mat[i][j] == 1) ++c;
            if (c > cnt) {
                idx = i;
                cnt = c;
            }
        }
        return new int[]{idx, cnt};
    }


    /*2644. Find the Maximum Divisibility Score (Easy)
    You are given two 0-indexed integer arrays nums and divisors. The
    divisibility score of divisors[i] is the number of indices j such that
    nums[j] is divisible by divisors[i]. Return the integer divisors[i] with
    the maximum divisibility score. If there is more than one integer with the
    maximum score, return the minimum of them.

    Example 1:
    Input: nums = [4,7,9,3,9], divisors = [5,2,3]
    Output: 3
    Explanation: The divisibility score for every element in divisors is:
                 - The divisibility score of divisors[0] is 0 since no number
                   in nums is divisible by 5.
                 - The divisibility score of divisors[1] is 1 since nums[0] is
                   divisible by 2.
                 - The divisibility score of divisors[2] is 3 since nums[2],
                   nums[3], and nums[4] are divisible by 3.
                 - Since divisors[2] has the maximum divisibility score, we
                   return it.

    Example 2:
    Input: nums = [20,14,21,10], divisors = [5,7,5]
    Output: 5
    Explanation: The divisibility score for every element in divisors is:
                 - The divisibility score of divisors[0] is 2 since nums[0] and
                   nums[3] are divisible by 5.
                 - The divisibility score of divisors[1] is 2 since nums[1] and
                   nums[2] are divisible by 7.
                 - The divisibility score of divisors[2] is 2 since nums[0] and
                   nums[3] are divisible by 5.
                 Since divisors[0], divisors[1], and divisors[2] all have the
                 maximum divisibility score, we return the minimum of them
                 (i.e., divisors[2]).

    Example 3:
    Input: nums = [12], divisors = [10,16]
    Output: 10
    Explanation: The divisibility score for every element in divisors is:
                 - The divisibility score of divisors[0] is 0 since no number
                   in nums is divisible by 10.
                 - The divisibility score of divisors[1] is 0 since no number
                   in nums is divisible by 16.
                 Since divisors[0] and divisors[1] both have the maximum
                 divisibility score, we return the minimum of them (i.e.,
                 divisors[0]).

    Constraints:
    * 1 <= nums.length, divisors.length <= 1000
    * 1 <= nums[i], divisors[i] <= 10^9*/

    public int maxDivScore(int[] nums, int[] divisors) {
        int ans = 0, most = -1;
        for (var d : divisors) {
            int cnt = 0;
            for (var n : nums)
                if (n % d == 0) ++cnt;
            if (cnt > most || cnt == most && d < ans) {
                ans = d;
                most = cnt;
            }
        }
        return ans;
    }


    /*2645. Minimum Additions to Make Valid String (Medium)
    Given a string word to which you can insert letters "a", "b" or "c"
    anywhere and any number of times, return the minimum number of letters that
    must be inserted so that word becomes valid. A string is called valid if it
    can be formed by concatenating the string "abc" several times.

    Example 1:
    Input: word = "b"
    Output: 2
    Explanation: Insert the letter "a" right before "b", and the letter "c"
                 right next to "a" to obtain the valid string "abc".

    Example 2:
    Input: word = "aaa"
    Output: 6
    Explanation: Insert letters "b" and "c" next to each "a" to obtain the
                 valid string "abcabcabc".

    Example 3:
    Input: word = "abc"
    Output: 0
    Explanation: word is already valid. No modifications are needed.

    Constraints:
    * 1 <= word.length <= 50
    * word consists of letters "a", "b" and "c" only.*/

    public int addMinimum(String word) {
        int ans = 0, cnt = 3;
        for (int i = 0; i < word.length(); ++i, --cnt) {
            if (i > 0 && word.charAt(i-1) >= word.charAt(i)) {
                ans += cnt;
                cnt = 3;
            }
        }
        return ans + cnt;
    }


    /*2646. Minimize the Total Price of the Trips (Hard)
    There exists an undirected and unrooted tree with n nodes indexed from 0 to
    n - 1. You are given the integer n and a 2D integer array edges of length
    n - 1, where edges[i] = [ai, bi] indicates that there is an edge between
    nodes ai and bi in the tree. Each node has an associated price. You are
    given an integer array price, where price[i] is the price of the ith node.
    The price sum of a given path is the sum of the prices of all nodes lying
    on that path. Additionally, you are given a 2D integer array trips, where
    trips[i] = [starti, endi] indicates that you start the ith trip from the
    node starti and travel to the node endi by any path you like. Before
    performing your first trip, you can choose some non-adjacent nodes and
    halve the prices. Return the minimum total price sum to perform all the
    given trips.

    Example 1:
    Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]
    Output: 23
    Explanation: The diagram above denotes the tree after rooting it at node 2.
                 The first part shows the initial tree and the second part
                 shows the tree after choosing nodes 0, 2, and 3, and making
                 their price half.
                 - For the 1st trip, we choose path [0,1,3]. The price sum of
                   that path is 1 + 2 + 3 = 6.
                 - For the 2nd trip, we choose path [2,1]. The price sum of
                   that path is 2 + 5 = 7.
                 - For the 3rd trip, we choose path [2,1,3]. The price sum of
                   that path is 5 + 2 + 3 = 10.
                 The total price sum of all trips is 6 + 7 + 10 = 23. It can be
                 proven, that 23 is the minimum answer that we can achieve.

    Example 2:
    Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]
    Output: 1
    Explanation: The diagram above denotes the tree after rooting it at node 0.
                 The first part shows the initial tree and the second part
                 shows the tree after choosing node 0, and making its price
                 half.
                 - For the 1st trip, we choose path [0]. The price sum of that
                   path is 1.
                 The total price sum of all trips is 1. It can be proven, that
                 1 is the minimum answer that we can achieve.

    Constraints:
    * 1 <= n <= 50
    * edges.length == n - 1
    * 0 <= ai, bi <= n - 1
    * edges represents a valid tree.
    * price.length == n
    * price[i] is an even integer.
    * 1 <= price[i] <= 1000
    * 1 <= trips.length <= 100
    * 0 <= starti, endi <= n - 1*/

    private int[] dfs(int u, int p, List<Integer>[] tree, int[] price, int[] freq) {
        int full = 0, half = 0;
        for (var v : tree[u])
            if (v != p) {
                int[] ans = dfs(v, u, tree, price, freq);
                full += ans[0];
                half += Math.min(ans[0], ans[1]);
            }
        return new int[]{price[u]*freq[u] + half, price[u]*freq[u]/2 + full};
    }

    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {
        List<Integer>[] tree = new ArrayList[n];
        for (int u = 0; u < n; ++u) tree[u] = new ArrayList();
        for (var e : edges) {
            tree[e[0]].add(e[1]);
            tree[e[1]].add(e[0]);
        }
        int[] freq = new int[n];
        for (var t : trips) {
            Queue<int[]> q = new LinkedList();
            q.add(new int[]{t[0], -1});
            Map<Integer, Integer> parent = new HashMap();
            parent.put(t[0], -1);
            while (!q.isEmpty()) {
                var elem = q.poll();
                int u = elem[0], p = elem[1];
                if (u == t[1]) break;
                for (var v : tree[u])
                    if (v != p) {
                        q.add(new int[]{v, u});
                        parent.put(v, u);
                    }
            }
            for (int u = t[1]; u >= 0; ++freq[u], u = parent.get(u));
        }

        int[] ans = dfs(0, -1, tree, price, freq);
        return Math.min(ans[0], ans[1]);
    }


    /*2647. Color the Triangle Red (Hard)
    You are given an integer n. Consider an equilateral triangle of side length
    n, broken up into n2 unit equilateral triangles. The triangle has n
    1-indexed rows where the ith row has 2i - 1 unit equilateral triangles.
    The triangles in the ith row are also 1-indexed with coordinates from (i, 1)
    to (i, 2i - 1). The following image shows a triangle of side length 4 with
    the indexing of its triangle. Two triangles are neighbors if they share a
    side. For example:
    * Triangles (1,1) and (2,2) are neighbors
    * Triangles (3,2) and (3,3) are neighbors.
    * Triangles (2,2) and (3,3) are not neighbors because they do not share any
      side.
    Initially, all the unit triangles are white. You want to choose k triangles
    and color them red. We will then run the following algorithm:
    * Choose a white triangle that has at least two red neighbors.
      - If there is no such triangle, stop the algorithm.
    * Color that triangle red.
    * Go to step 1.
    Choose the minimum k possible and set k triangles red before running this
    algorithm such that after the algorithm stops, all unit triangles are
    colored red. Return a 2D list of the coordinates of the triangles that you
    will color red initially. The answer has to be of the smallest size
    possible. If there are multiple valid solutions, return any.

    Example 1:
    Input: n = 3
    Output: [[1,1],[2,1],[2,3],[3,1],[3,5]]
    Explanation: Initially, we choose the shown 5 triangles to be red. Then, we
                 run the algorithm:
                 - Choose (2,2) that has three red neighbors and color it red.
                 - Choose (3,2) that has two red neighbors and color it red.
                 - Choose (3,4) that has three red neighbors and color it red.
                 - Choose (3,3) that has three red neighbors and color it red.
                 It can be shown that choosing any 4 triangles and running the
                 algorithm will not make all triangles red.

    Example 2:
    Input: n = 2
    Output: [[1,1],[2,1],[2,3]]
    Explanation: Initially, we choose the shown 3 triangles to be red. Then, we
                 run the algorithm:
                 - Choose (2,2) that has three red neighbors and color it red.
                 It can be shown that choosing any 2 triangles and running the
                 algorithm will not make all triangles red.

    Constraints: 1 <= n <= 1000*/

    public int[][] colorRed(int n) {
        List<int[]> ans = new ArrayList();
        int p = 0;
        for (int i = n; i >= 1; --i, p = (p+1)%4)
            if (p == 0)
                for (int j = 2*i-1; j >= 1; j -= 2) ans.add(new int[]{i, j});
            else if (p == 1) {
                if (2 <= i) ans.add(new int[]{i, 2});
            } else if (p == 2)
                for (int j = 2*i-1; j >= 3; j -= 2) ans.add(new int[]{i, j});
            else ans.add(new int[]{i, 1});
        if (p == 2 || p == 3) ans.add(new int[]{1, 1});
        Collections.reverse(ans);
        return ans.toArray(new int[0][0]);
    }


    /*2655. Find Maximal Uncovered Ranges (Medium)
    You are given an integer n which is the length of a 0-indexed array nums,
    and a 0-indexed 2D-array ranges, which is a list of sub-ranges of nums
    (sub-ranges may overlap). Each row ranges[i] has exactly 2 cells:
    * ranges[i][0], which shows the start of the ith range (inclusive)
    * ranges[i][1], which shows the end of the ith range (inclusive)
    These ranges cover some cells of nums and leave some cells uncovered. Your
    task is to find all of the uncovered ranges with maximal length. Return a
    2D-array answer of the uncovered ranges, sorted by the starting point in
    ascending order. By all of the uncovered ranges with maximal length, we
    mean satisfying two conditions:
    * Each uncovered cell should belong to exactly one sub-range
    * There should not exist two ranges (l1, r1) and (l2, r2) such that
      r1 + 1 = l2

    Example 1:
    Input: n = 10, ranges = [[3,5],[7,8]]
    Output: [[0,2],[6,6],[9,9]]
    Explanation: The ranges (3, 5) and (7, 8) are covered, so if we simplify
                 the array nums to a binary array where 0 shows an uncovered
                 cell and 1 shows a covered cell, the array becomes
                 [0,0,0,1,1,1,0,1,1,0] in which we can observe that the ranges
                 (0, 2), (6, 6) and (9, 9) aren't covered.

    Example 2:
    Input: n = 3, ranges = [[0,2]]
    Output: []
    Explanation: In this example, the whole of the array nums is covered and
                 there are no uncovered cells so the output is an empty array.

    Example 3:
    Input: n = 7, ranges = [[2,4],[0,3]]
    Output: [[5,6]]
    Explanation: The ranges (0, 3) and (2, 4) are covered, so if we simplify
                 the array nums to a binary array where 0 shows an uncovered
                 cell and 1 shows a covered cell, the array becomes
                 [1,1,1,1,1,0,0] in which we can observe that the range
                 (5, 6) is uncovered.

    Constraints:
    * 1 <= n <= 10^9
    * 0 <= ranges.length <= 10^6
    * ranges[i].length = 2
    * 0 <= ranges[i][j] <= n - 1
    * ranges[i][0] <= ranges[i][1]*/

    public int[][] findMaximalUncoveredRanges(int n, int[][] ranges) {
        Arrays.sort(ranges, (x, y)->Integer.compare(x[1], y[1]));
        Stack<int[]> stk = new Stack();
        for (var r : ranges) {
            while (!stk.isEmpty() && r[0] <= stk.peek()[1]) {
                var elem = stk.pop();
                r[0] = Math.min(r[0], elem[0]);
            }
            stk.add(r);
        }
        List<int[]> ans = new ArrayList();
        int prev = 0;
        for (var elem : stk) {
            if (prev < elem[0]) ans.add(new int[]{prev, elem[0]-1});
            prev = Math.max(prev, elem[1]+1);
        }
        if (prev <= n-1) ans.add(new int[]{prev, n-1});
        return ans.toArray(new int[0][0]);
    }


    /*2656. Maximum Sum With Exactly K Elements (Easy)
    You are given a 0-indexed integer array nums and an integer k. Your task is
    to perform the following operation exactly k times in order to maximize
    your score:
    * Select an element m from nums.
    * Remove the selected element m from the array.
    * Add a new element with a value of m + 1 to the array.
    * Increase your score by m.
    Return the maximum score you can achieve after performing the operation
    exactly k times.

    Example 1:
    Input: nums = [1,2,3,4,5], k = 3
    Output: 18
    Explanation: We need to choose exactly 3 elements from nums to maximize the
                 sum.
                 - For the first iteration, we choose 5. Then sum is 5 and
                   nums = [1,2,3,4,6]
                 - For the second iteration, we choose 6. Then sum is 5 + 6 and
                   nums = [1,2,3,4,7]
                 - For the third iteration, we choose 7. Then sum is
                   5 + 6 + 7 = 18 and nums = [1,2,3,4,8]
                 So, we will return 18. It can be proven, that 18 is the
                 maximum answer that we can achieve.

    Example 2:
    Input: nums = [5,5,5], k = 2
    Output: 11
    Explanation: We need to choose exactly 2 elements from nums to maximize the
                 sum.
                 - For the first iteration, we choose 5. Then sum is 5 and
                   nums = [5,5,6]
                 - For the second iteration, we choose 6. Then sum is
                   5 + 6 = 11 and nums = [5,5,7]
                 So, we will return 11. It can be proven, that 11 is the
                 maximum answer that we can achieve.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= k <= 100*/

    public int maximizeSum(int[] nums, int k) {
        int m = Arrays.stream(nums).max().getAsInt();
        return k*(2*m+k-1)/2;
    }


    /*2657. Find the Prefix Common Array of Two Arrays (Medium)
    You are given two 0-indexed integer permutations A and B of length n. A
    prefix common array of A and B is an array C such that C[i] is equal to the
    count of numbers that are present at or before the index i in both A and B.
    Return the prefix common array of A and B. A sequence of n integers is
    called a permutation if it contains all integers from 1 to n exactly once.

    Example 1:
    Input: A = [1,3,2,4], B = [3,1,2,4]
    Output: [0,2,3,4]
    Explanation: At i = 0: no number is common, so C[0] = 0.
                 At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
                 At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
                 At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.

    Example 2:
    Input: A = [2,3,1], B = [3,1,2]
    Output: [0,1,3]
    Explanation: At i = 0: no number is common, so C[0] = 0.
                 At i = 1: only 3 is common in A and B, so C[1] = 1.
                 At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.

    Constraints:
    * 1 <= A.length == B.length == n <= 50
    * 1 <= A[i], B[i] <= n
    * It is guaranteed that A and B are both a permutation of n integers.*/

    public int[] findThePrefixCommonArray(int[] A, int[] B) {
        int n = A.length;
        int[] ans = new int[n], seen = new int[n];
        for (int i = 0, prefix = 0; i < n; ++i) {
            if (++seen[A[i]-1] == 0) ++prefix;
            if (--seen[B[i]-1] == 0) ++prefix;
            ans[i] = prefix;
        }
        return ans;
    }


    /*2658. Maximum Number of Fish in a Grid (Hard)
    You are given a 0-indexed 2D matrix grid of size m x n, where (r, c)
    represents:
    * A land cell if grid[r][c] = 0, or
    * A water cell containing grid[r][c] fish, if grid[r][c] > 0.
    A fisher can start at any water cell (r, c) and can do the following
    operations any number of times:
    * Catch all the fish at cell (r, c), or
    * Move to any adjacent water cell.
    Return the maximum number of fish the fisher can catch if he chooses his
    starting cell optimally, or 0 if no water cell exists. An adjacent cell of
    the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or
    (r - 1, c) if it exists.

    Example 1:
    Input: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]
    Output: 7
    Explanation: The fisher can start at cell (1,3) and collect 3 fish, then
                 move to cell (2,3) and collect 4 fish.

    Example 2:
    Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]
    Output: 1
    Explanation: The fisher can start at cells (0,0) or (3,3) and collect a
                 single fish.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 10
    * 0 <= grid[i][j] <= 10*/

    public int findMaxFish(int[][] grid) {
        int ans = 0, m = grid.length, n = grid[0].length;
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        Stack<int[]> stk = new Stack();
        for (int r = 0; r < m; ++r)
            for (int c = 0; c < n; ++c)
                if (grid[r][c] > 0) {
                    int cand = grid[r][c];
                    stk.push(new int[]{r, c});
                    grid[r][c] = 0;
                    while (!stk.isEmpty()) {
                        var elem = stk.pop();
                        int i = elem[0], j = elem[1];
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[ii][jj] > 0) {
                                cand += grid[ii][jj];
                                stk.push(new int[]{ii, jj});
                                grid[ii][jj] = 0;
                            }
                        }
                    }
                    ans = Math.max(ans, cand);
                }
        return ans;
    }


    /*2659. Make Array Empty (Hard)
    You are given an integer array nums containing distinct numbers, and you
    can perform the following operations until the array is empty:
    * If the first element has the smallest value, remove it
    * Otherwise, put the first element at the end of the array.
    Return an integer denoting the number of operations it takes to make nums
    empty.

    Example 1:
    Input: nums = [3,4,-1]
    Output: 5
    Operation   Array
            1   [4, -1, 3]
            2   [-1, 3, 4]
            3   [3, 4]
            4   [4]
            5   []

    Example 2:
    Input: nums = [1,2,4,3]
    Output: 5
    Operation   Array
            1   [2, 4, 3]
            2   [4, 3]
            3   [3, 4]
            4   [4]
            5   []

    Example 3:
    Input: nums = [1,2,3]
    Output: 3
    Operation   Array
            1   [2, 3]
            2   [3]
            3   []

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9
    * All values in nums are distinct.*/

    public long countOperationsToEmptyArray(int[] nums) {
        int n = nums.length;
        long ans = n;
        Map<Integer, Integer> loc = new HashMap();
        for (int i = 0; i < n; ++i) loc.put(nums[i], i);
        Arrays.sort(nums);
        for (int i = 1; i < n; ++i)
            if (loc.get(nums[i-1]) > loc.get(nums[i])) ans += n-i;
        return ans;
    }


    /*2660. Determine the Winner of a Bowling Game (Easy)
    You are given two 0-indexed integer arrays player1 and player2, that
    represent the number of pins that player 1 and player 2 hit in a bowling
    game, respectively. The bowling game consists of n turns, and the number of
    pins in each turn is exactly 10. Assume a player hit xi pins in the ith
    turn. The value of the ith turn for the player is:
    * 2xi if the player hit 10 pins in any of the previous two turns.
    * Otherwise, It is xi.
    The score of the player is the sum of the values of their n turns. Return
    * 1 if the score of player 1 is more than the score of player 2,
    * 2 if the score of player 2 is more than the score of player 1, and
    * 0 in case of a draw.

    Example 1:
    Input: player1 = [4,10,7,9], player2 = [6,5,2,3]
    Output: 1
    Explanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.
                 The score of player2 is 6 + 5 + 2 + 3 = 16.
                 Score of player1 is more than the score of player2, so,
                 player1 is the winner, and the answer is 1.

    Example 2:
    Input: player1 = [3,5,7,6], player2 = [8,10,10,2]
    Output: 2
    Explanation: The score of player1 is 3 + 5 + 7 + 6 = 21.
                 The score of player2 is 8 + 10 + 2*10 + 2*2 = 42.
                 Score of player2 is more than the score of player1, so,
                 player2 is the winner, and the answer is 2.

    Example 3:
    Input: player1 = [2,3], player2 = [4,1]
    Output: 0
    Explanation: The score of player1 is 2 + 3 = 5
                 The score of player2 is 4 + 1 = 5
                 The score of player1 equals to the score of player2, so,
                 there is a draw, and the answer is 0.

    Constraints:
    * n == player1.length == player2.length
    * 1 <= n <= 1000
    * 0 <= player1[i], player2[i] <= 10*/

    private static int calc(int[] player) {
        int ans = 0;
        for (int i = 0; i < player.length; ++i) {
            ans += player[i];
            if (i >= 1 && player[i-1] == 10 || i >= 2 && player[i-2] == 10) ans += player[i];
        }
        return ans;
    }

    public int isWinner(int[] player1, int[] player2) {
        int diff = calc(player1) - calc(player2);
        return diff > 0 ? 1 : diff < 0 ? 2 : 0;
    }


    /*2661. First Completely Painted Row or Column (Medium)
    You are given a 0-indexed integer array arr, and an m x n integer matrix
    mat. arr and mat both contain all the integers in the range [1, m * n].
    Go through each index i in arr starting from index 0 and paint the cell in
    mat containing the integer arr[i]. Return the smallest index i at which
    either a row or a column will be completely painted in mat.

    Example 1:
    image explanation for example 1
    Input: arr = [1,3,4,2], mat = [[1,4],[2,3]]
    Output: 2
    Explanation: The moves are shown in order, and both the first row and
                 second column of the matrix become fully painted at arr[2].

    Example 2:
    image explanation for example 2
    Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]
    Output: 3
    Explanation: The second column becomes fully painted at arr[3].

    Constraints:
    * m == mat.length
    * n = mat[i].length
    * arr.length == m * n
    * 1 <= m, n <= 10^5
    * 1 <= m * n <= 10^5
    * 1 <= arr[i], mat[r][c] <= m * n
    * All the integers of arr are unique.
    * All the integers of mat are unique.*/

    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[][] loc = new int[m*n][2];
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                loc[mat[i][j]-1][0] = i;
                loc[mat[i][j]-1][1] = j;
            }
        int[] rows = new int[m], cols = new int[n];
        for (int k = 0; k < arr.length; ++k) {
            int i = loc[arr[k]-1][0], j = loc[arr[k]-1][1];
            if (++rows[i] == n || ++cols[j] == m) return k;
        }
        return -1;
    }


    /*2662. Minimum Cost of a Path With Special Roads (Medium)
    You are given an array start where start = [startX, startY] represents your
    initial position (startX, startY) in a 2D space. You are also given the
    array target where target = [targetX, targetY] represents your target
    position (targetX, targetY). The cost of going from a position (x1, y1) to
    any other position in the space (x2, y2) is |x2 - x1| + |y2 - y1|. There
    are also some special roads. You are given a 2D array specialRoads where
    specialRoads[i] = [x1i, y1i, x2i, y2i, costi] indicates that the ith
    special road can take you from (x1i, y1i) to (x2i, y2i) with a cost equal
    to costi. You can use each special road any number of times. Return the
    minimum cost required to go from (startX, startY) to (targetX, targetY).

    Example 1:
    Input: start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]
    Output: 5
    Explanation: The optimal path from (1,1) to (4,5) is the following:
                 - (1,1) -> (1,2). This move has a cost of |1 - 1| + |2 - 1| = 1.
                 - (1,2) -> (3,3). This move uses the first special edge, the
                   cost is 2.
                 - (3,3) -> (3,4). This move has a cost of |3 - 3| + |4 - 3| = 1.
                 - (3,4) -> (4,5). This move uses the second special edge, the
                   cost is 1.
                 So the total cost is 1 + 2 + 1 + 1 = 5. It can be shown that
                 we cannot achieve a smaller total cost than 5.

    Example 2:
    Input: start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]
    Output: 7
    Explanation: It is optimal to not use any special edges and go directly
                 from the starting to the ending position with a cost
                 |5 - 3| + |7 - 2| = 7.

    Constraints:
    * start.length == target.length == 2
    * 1 <= startX <= targetX <= 10^5
    * 1 <= startY <= targetY <= 10^5
    * 1 <= specialRoads.length <= 200
    * specialRoads[i].length == 5
    * startX <= x1i, x2i <= targetX
    * startY <= y1i, y2i <= targetY
    * 1 <= costi <= 10^5*/

    public int minimumCost(int[] start, int[] target, int[][] specialRoads) {
        long m = 100001;
        Map<Long, List<long[]>> mp = new HashMap();
        mp.put(target[0]*m + target[1], new ArrayList());
        mp.get(target[0]*m + target[1]).add(new long[]{0, 0});
        for (var x : specialRoads) {
            if (!mp.containsKey(x[0]*m + x[1])) mp.put(x[0]*m + x[1], new ArrayList());
            mp.get(x[0]*m + x[1]).add(new long[]{x[2]*m + x[3], x[4]});
        }
        Map<Long, Long> dist = new HashMap();
        dist.put(start[0]*m + start[1], 0l);
        Queue<long[]> pq = new PriorityQueue<>((a, b)->Long.compare(a[0], b[0]));
        pq.add(new long[]{0, start[0]*m + start[1]});
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            long d = elem[0], x = elem[1];
            if (x == target[0]*m + target[1]) return (int) d;
            if (mp.containsKey(x))
                for (var p : mp.get(x)) {
                    long xx = p[0], dd = d + p[1];
                    if (!dist.containsKey(xx) || dd < dist.get(xx)) {
                        dist.put(xx, dd);
                        pq.add(new long[]{dd, xx});
                    }
                }
            for (var xx : mp.keySet()) {
                long dd = d + Math.abs(xx%m - x%m) + Math.abs(xx/m - x/m);
                if (!dist.containsKey(xx) || dd < dist.get(xx)) {
                    dist.put(xx, dd);
                    pq.add(new long[] {dd, xx});
                }
            }
        }
        return -1;
    }


    /*2663. Lexicographically Smallest Beautiful String (Hard)
    A string is beautiful if:
    * It consists of the first k letters of the English lowercase alphabet.
    * It does not contain any substring of length 2 or more which is a
      palindrome.
    You are given a beautiful string s of length n and a positive integer k.
    Return the lexicographically smallest string of length n, which is larger
    than s and is beautiful. If there is no such string, return an empty string.
    A string a is lexicographically larger than a string b (of the same length)
    if in the first position where a and b differ, a has a character strictly
    larger than the corresponding character in b.
    * For example, "abcd" is lexicographically larger than "abcc" because the
      first position they differ is at the fourth character, and d is greater
      than c.

    Example 1:
    Input: s = "abcz", k = 26
    Output: "abda"
    Explanation: The string "abda" is beautiful and lexicographically larger
                 than the string "abcz". It can be proven that there is no
                 string that is lexicographically larger than the string
                 "abcz", beautiful, and lexicographically smaller than the
                 string "abda".

    Example 2:
    Input: s = "dc", k = 4
    Output: ""
    Explanation: It can be proven that there is no string that is
                 lexicographically larger than the string "dc" and is
                 beautiful.

    Constraints:
    * 1 <= n == s.length <= 10^5
    * 4 <= k <= 26
    * s is a beautiful string.*/

    public String smallestBeautifulString(String s, int k) {
        StringBuilder sb = new StringBuilder(s);
        for (int n = sb.length(), i = n-1; i >= 0; --i)
            for (char c = (char) (sb.charAt(i)+1); c < 'a'+k; ++c)
                if ((i == 0 || s.charAt(i-1) != c) && (i <= 1 || sb.charAt(i-2) != c)) {
                    sb.setCharAt(i, c);
                    for (int ii = i+1; ii < n; ++ii)
                        for (char cc = 'a'; cc < 'a'+k; ++cc)
                            if (cc != sb.charAt(ii-1) && (ii == 1 || cc != sb.charAt(ii-2))) {
                                sb.setCharAt(ii, cc);
                                break;
                            }
                    return sb.toString();
                }
        return "";
    }


    /*2664. The Knight’s Tour (Medium)
    Given two positive integers m and n which are the height and width of a
    0-indexed 2D-array board, a pair of positive integers (r, c) which is the
    starting position of the knight on the board. Your task is to find an order
    of movements for the knight, in a manner that every cell of the board gets
    visited exactly once (the starting cell is considered visited and you
    shouldn't visit it again). Return the array board in which the cells'
    values show the order of visiting the cell starting from 0 (the initial
    place of the knight). Note that a knight can move from cell (r1, c1) to
    cell (r2, c2) if 0 <= r2 <= m - 1 and 0 <= c2 <= n - 1 and
    min(abs(r1 - r2), abs(c1 - c2)) = 1 and max(abs(r1 - r2), abs(c1 - c2)) = 2.

    Example 1:
    Input: m = 1, n = 1, r = 0, c = 0
    Output: [[0]]
    Explanation: There is only 1 cell and the knight is initially on it so
                 there is only a 0 inside the 1x1 grid.

    Example 2:
    Input: m = 3, n = 4, r = 0, c = 0
    Output: [[0,3,6,9],[11,8,1,4],[2,5,10,7]]
    Explanation: By the following order of movements we can visit the entire
                 board. (0,0)->(1,2)->(2,0)->(0,1)->(1,3)->(2,1)->(0,2)->(2,3)
                 ->(1,1)->(0,3)->(2,2)->(1,0)

    Constraints:
    * 1 <= m, n <= 5
    * 0 <= r <= m - 1
    * 0 <= c <= n - 1
    * The inputs will be generated such that there exists at least one possible
      order of movements with the given condition*/

    private boolean fn(int i, int j, int k, int m, int n, int[][] board) {
        if (k == m*n) return true;
        int[][] dir = new int[][]{{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};
        for (var d : dir) {
            int ii = i + d[0], jj = j + d[1];
            if (0 <= ii && ii < m && 0 <= jj && jj < n && board[ii][jj] == -1) {
                board[ii][jj] = k;
                if (fn(ii, jj, k+1, m, n, board)) return true;
                board[ii][jj] = -1;
            }
        }
        return false;
    }

    public int[][] tourOfKnight(int m, int n, int r, int c) {
        int[][] board = new int[m][n];
        for (int i = 0; i < m; ++i) Arrays.fill(board[i], -1);
        board[r][c] = 0;
        fn(r, c, 1, m, n, board);
        return board;
    }


    /*2670. Find the Distinct Difference Array (Easy)
    You are given a 0-indexed array nums of length n. The distinct difference
    array of nums is an array diff of length n such that diff[i] is equal to
    the number of distinct elements in the suffix nums[i + 1, ..., n - 1]
    subtracted from the number of distinct elements in the prefix
    nums[0, ..., i]. Return the distinct difference array of nums. Note that
    nums[i, ..., j] denotes the subarray of nums starting at index i and
    ending at index j inclusive. Particularly, if i > j then nums[i, ..., j]
    denotes an empty subarray.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: [-3,-1,1,3,5]
    Explanation: - For index i = 0, there is 1 element in the prefix and 4
                   distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.
                 - For index i = 1, there are 2 distinct elements in the prefix
                   and 3 distinct elements in the suffix. Thus,
                   diff[1] = 2 - 3 = -1.
                 - For index i = 2, there are 3 distinct elements in the prefix
                   and 2 distinct elements in the suffix. Thus,
                   diff[2] = 3 - 2 = 1.
                 - For index i = 3, there are 4 distinct elements in the prefix
                   and 1 distinct element in the suffix. Thus,
                   diff[3] = 4 - 1 = 3.
                 - For index i = 4, there are 5 distinct elements in the prefix
                   and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.

    Example 2:
    Input: nums = [3,2,3,4,2]
    Output: [-2,-1,0,2,3]
    Explanation: - For index i = 0, there is 1 element in the prefix and 3
                   distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.
                 - For index i = 1, there are 2 distinct elements in the prefix
                   and 3 distinct elements in the suffix. Thus,
                   diff[1] = 2 - 3 = -1.
                 - For index i = 2, there are 2 distinct elements in the prefix
                   and 2 distinct elements in the suffix. Thus,
                   diff[2] = 2 - 2 = 0.
                 - For index i = 3, there are 3 distinct elements in the prefix
                   and 1 distinct element in the suffix. Thus,
                   diff[3] = 3 - 1 = 2.
                 - For index i = 4, there are 3 distinct elements in the prefix
                   and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.

    Constraints:
    * 1 <= n == nums.length <= 50
    * 1 <= nums[i] <= 50*/

    public int[] distinctDifferenceArray(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        Set<Integer> prefix = new HashSet();
        Map<Integer, Integer> suffix = new HashMap();
        for (var x : nums) suffix.merge(x, 1, Integer::sum);
        for (int i = 0; i < n; ++i) {
            prefix.add(nums[i]);
            suffix.merge(nums[i], -1, Integer::sum);
            if (suffix.get(nums[i]) == 0) suffix.remove(nums[i]);
            ans[i] = prefix.size() - suffix.size();
        }
        return ans;
    }


    /*2672. Number of Adjacent Elements With the Same Color (Medium)
    There is a 0-indexed array nums of length n. Initially, all elements are
    uncolored (has a value of 0). You are given a 2D integer array queries
    where queries[i] = [indexi, colori]. For each query, you color the index
    indexi with the color colori in the array nums. Return an array answer of
    the same length as queries where answer[i] is the number of adjacent
    elements with the same color after the ith query. More formally, answer[i]
    is the number of indices j, such that 0 <= j < n - 1 and
    nums[j] == nums[j + 1] and nums[j] != 0 after the ith query.

    Example 1:
    Input: n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]
    Output: [0,1,1,0,2]
    Explanation: Initially array nums = [0,0,0,0], where 0 denotes uncolored
                 elements of the array.
                 - After the 1st query nums = [2,0,0,0]. The count of adjacent
                   elements with the same color is 0.
                 - After the 2nd query nums = [2,2,0,0]. The count of adjacent
                   elements with the same color is 1.
                 - After the 3rd query nums = [2,2,0,1]. The count of adjacent
                   elements with the same color is 1.
                 - After the 4th query nums = [2,1,0,1]. The count of adjacent
                   elements with the same color is 0.
                 - After the 5th query nums = [2,1,1,1]. The count of adjacent
                   elements with the same color is 2.

    Example 2:
    Input: n = 1, queries = [[0,100000]]
    Output: [0]
    Explanation: Initially array nums = [0], where 0 denotes uncolored elements
                 of the array.
                 - After the 1st query nums = [100000]. The count of adjacent
                   elements with the same color is 0.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= indexi <= n - 1
    * 1 <=  colori <= 10^5*/

    public int[] colorTheArray(int n, int[][] queries) {
        List<Integer> ans = new ArrayList();
        int[] nums = new int[n];
        int cnt = 0;
        for (var q : queries) {
            int i = q[0], x = q[1];
            if (i > 0 && nums[i] > 0 && nums[i-1] == nums[i]) --cnt;
            if (i+1 < n && nums[i] > 0 && nums[i] == nums[i+1]) --cnt;
            nums[i] = x;
            if (i > 0 && nums[i-1] == nums[i]) ++cnt;
            if (i+1 < n && nums[i] == nums[i+1]) ++cnt;
            ans.add(cnt);
        }
        return ans.stream().mapToInt(i -> i).toArray();
    }


    /*2673. Make Costs of Paths Equal in a Binary Tree (Medium)
    You are given an integer n representing the number of nodes in a perfect
    binary tree consisting of nodes numbered from 1 to n. The root of the tree
    is node 1 and each node i in the tree has two children where the left child
    is the node 2 * i and the right child is 2 * i + 1. Each node in the tree
    also has a cost represented by a given 0-indexed integer array cost of size
    n where cost[i] is the cost of node i + 1. You are allowed to increment the
    cost of any node by 1 any number of times. Return the minimum number of
    increments you need to make the cost of paths from the root to each leaf
    node equal.

    Note:
    * A perfect binary tree is a tree where each node, except the leaf nodes,
      has exactly 2 children.
    * The cost of a path is the sum of costs of nodes in the path.

    Example 1:
    Input: n = 7, cost = [1,5,2,2,3,3,1]
    Output: 6
    Explanation: We can do the following increments:
                 - Increase the cost of node 4 one time.
                 - Increase the cost of node 3 three times.
                 - Increase the cost of node 7 two times.
                 Each path from the root to a leaf will have a total cost of 9.
                 The total increments we did is 1 + 3 + 2 = 6. It can be shown
                 that this is the minimum answer we can achieve.

    Example 2:
    Input: n = 3, cost = [5,3,3]
    Output: 0
    Explanation: The two paths already have equal total costs, so no increments
                 are needed.

    Constraints:
    * 3 <= n <= 10^5
    * n + 1 is a power of 2
    * cost.length == n
    * 1 <= cost[i] <= 10^4*/

    public int minIncrements(int n, int[] cost) {
        int ans = 0;
        for (int i = n/2-1; i >= 0; --i) {
            ans += Math.abs(cost[2*i+1] - cost[2*i+2]);
            cost[i] += Math.max(cost[2*i+1], cost[2*i+2]);
        }
        return ans;
    }


    /*2674. Split a Circular Linked Listn (Medium)
    Given a circular linked list list of positive integers, your task is to
    split it into 2 circular linked lists so that the first one contains the
    first half of the nodes in list (exactly ceil(list.length / 2) nodes) in the
    same order they appeared in list, and the second one contains the rest of
    the nodes in list in the same order they appeared in list. Return an array
    answer of length 2 in which the first element is a circular linked list
    representing the first half and the second element is a circular linked list
    representing the second half. A circular linked list is a normal linked list
    with the only difference being that the last node's next node, is the first
    node.

    Example 1:
    Input: nums = [1,5,7]
    Output: [[1,5],[7]]
    Explanation: The initial list has 3 nodes so the first half would be the
                 first 2 elements since ceil(3 / 2) = 2 and the rest which is 1
                 node is in the second half.

    Example 2:
    Input: nums = [2,6,1,5]
    Output: [[2,6],[1,5]]
    Explanation: The initial list has 4 nodes so the first half would be the
                 first 2 elements since ceil(4 / 2) = 2 and the rest which is 2
                 nodes are in the second half.

    Constraints:
    * The number of nodes in list is in the range [2, 10^5]
    * 0 <= Node.val <= 10^9
    * LastNode.next = FirstNode where LastNode is the last node of the list and
      FirstNode is the first one*/

    public ListNode[] splitCircularLinkedList(ListNode list) {
        ListNode fast = list, slow = list;
        while (fast.next != list && fast.next.next != list) {
            fast = fast.next.next;
            slow = slow.next;
        }
        if (fast.next != list) fast = fast.next;
        ListNode head = slow.next;
        slow.next = list;
        fast.next = head;
        return new ListNode[]{list, head};
    }


    /*2678. Number of Senior Citizens (Easy)
    You are given a 0-indexed array of strings details. Each element of details
    provides information about a given passenger compressed into a string of
    length 15. The system is such that:
    * The first ten characters consist of the phone number of passengers.
    * The next character denotes the gender of the person.
    * The following two characters are used to indicate the age of the person.
    * The last two characters determine the seat allotted to that person.
    Return the number of passengers who are strictly more than 60 years old.

    Example 1:
    Input: details = ["7868190130M7522","5303914400F9211","9273338290F4010"]
    Output: 2
    Explanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40.
                 Thus, there are 2 people who are over 60 years old.

    Example 2:
    Input: details = ["1313579440F2036","2921522980M5644"]
    Output: 0
    Explanation: None of the passengers are older than 60.

    Constraints:
    * 1 <= details.length <= 100
    * details[i].length == 15
    * details[i] consists of digits from '0' to '9'.
    * details[i][10] is either 'M' or 'F' or 'O'.
    * The phone numbers and seat numbers of the passengers are distinct.*/

    public int countSeniors(String[] details) {
        return Arrays.stream(details)
            .map(d -> Integer.parseInt(d.substring(11, 13)))
            .reduce(0, (s, x) -> s + (x > 60 ? 1 : 0));
    }


    /*2689. Extract Kth Character From The Rope Tree (Easy)
    You are given the root of a binary tree and an integer k. Besides the left
    and right children, every node of this tree has two other properties, a
    string node.val containing only lowercase English letters (possibly empty)
    and a non-negative integer node.len. There are two types of nodes in this tree:
    * Leaf: These nodes have no children, node.len = 0, and node.val is some
      non-empty string.
    * Internal: These nodes have at least one child (also at most two children),
      node.len > 0, and node.val is an empty string.
    The tree described above is called a Rope binary tree. Now we define S[node]
    recursively as follows:
    * If node is some leaf node, S[node] = node.val,
    * Otherwise if node is some internal node,
      S[node] = concat(S[node.left], S[node.right]) and
      S[node].length = node.len.
    Return k-th character of the string S[root]. Note: If s and p are two
    strings, concat(s, p) is a string obtained by concatenating p to s. For
    example, concat("ab", "zz") = "abzz".

    Example 1:
    Input: root = [10,4,"abcpoe","g","rta"], k = 6
    Output: "b"
    Explanation: In the picture below, we put an integer on internal nodes that
                 represents node.len, and a string on leaf nodes that represents
                 node.val. You can see that
                 S[root] = concat(concat("g", "rta"), "abcpoe") = "grtaabcpoe".
                 So S[root][5], which represents 6th character of it, is equal
                 to "b".

    Example 2:
    Input: root = [12,6,6,"abc","efg","hij","klm"], k = 3
    Output: "c"
    Explanation: In the picture below, we put an integer on internal nodes that
                 represents node.len, and a string on leaf nodes that represents
                 node.val. You can see that
                 S[root] = concat(concat("abc", "efg"), concat("hij", "klm")) =
                 "abcefghijklm". So S[root][2], which represents the 3rd
                 character of it, is equal to "c".

    Example 3:
    Input: root = ["ropetree"], k = 8
    Output: "e"
    Explanation: In the picture below, we put an integer on internal nodes that
                 represents node.len, and a string on leaf nodes that represents
                 node.val. You can see that S[root] = "ropetree". So S[root][7],
                 which represents 8th character of it, is equal to "e".

    Constraints:
    * The number of nodes in the tree is in the range [1, 10^3]
    * node.val contains only lowercase English letters
    * 0 <= node.val.length <= 50
    * 0 <= node.len <= 10^4
    * for leaf nodes, node.len = 0 and node.val is non-empty
    * for internal nodes, node.len > 0 and node.val is empty
    * 1 <= k <= S[root].length*/

    public char getKthCharacter(RopeTreeNode root, int k) {
        RopeTreeNode node = root;
        while (node.len > 0) {
            int val = node.left != null ? Math.max(node.left.len, node.left.val.length()) : 0;
            if (val >= k) node = node.left;
            else {
                k -= val;
                node = node.right;
            }
        }
        return node.val.charAt(k-1);
    }


    /*2696. Minimum String Length After Removing Substrings (Easy)
    You are given a string s consisting only of uppercase English letters. You
    can apply some operations to this string where, in one operation, you can
    remove any occurrence of one of the substrings "AB" or "CD" from s. Return
    the minimum possible length of the resulting string that you can obtain.
    Note that the string concatenates after removing the substring and could
    produce new "AB" or "CD" substrings.

    Example 1:
    Input: s = "ABFCACDB"
    Output: 2
    Explanation: We can do the following operations:
    - Remove the substring "ABFCACDB", so s = "FCACDB".
    - Remove the substring "FCACDB", so s = "FCAB".
    - Remove the substring "FCAB", so s = "FC".
    So the resulting length of the string is 2.
    It can be shown that it is the minimum length that we can obtain.

    Example 2:
    Input: s = "ACBBD"
    Output: 5
    Explanation: We cannot do any operations on the string so the length remains
                 the same.

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of uppercase English letters.*/

    public int minLength(String s) {
        Stack<Character> stk = new Stack<>();
        for (var ch : s.toCharArray())
            if (ch == 'B' && !stk.isEmpty() && stk.peek() == 'A') stk.pop();
            else if (ch == 'D' && !stk.isEmpty() && stk.peek() == 'C') stk.pop();
            else stk.push(ch);
        return stk.size();
    }


    /*2699. Modify Graph Edge Weights (Hard)
    You are given an undirected weighted connected graph containing n nodes
    labeled from 0 to n - 1, and an integer array edges where
    edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and
    bi with weight wi. Some edges have a weight of -1 (wi = -1), while others
    have a positive weight (wi > 0). Your task is to modify all edges with a
    weight of -1 by assigning them positive integer values in the range
    [1, 2 * 10^9] so that the shortest distance between the nodes source and
    destination becomes equal to an integer target. If there are multiple
    modifications that make the shortest distance between source and destination
    equal to target, any of them will be considered correct. Return an array
    containing all edges (even unmodified ones) in any order if it is possible
    to make the shortest distance from source to destination equal to target, or
    an empty array if it's impossible. Note: You are not allowed to modify the
    weights of edges with initial positive weights.

    Example 1:
    Input: n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5
    Output: [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]
    Explanation: The graph above shows a possible modification to the edges,
                 making the distance from 0 to 1 equal to 5.

    Example 2:
    Input: n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6
    Output: []
    Explanation: The graph above contains the initial edges. It is not possible
                 to make the distance from 0 to 2 equal to 6 by modifying the
                 edge with weight -1. So, an empty array is returned.

    Example 3:
    Input: n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6
    Output: [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]
    Explanation: The graph above shows a modified graph having the shortest
                 distance from 0 to 2 as 6.

    Constraints:
    * 1 <= n <= 100
    * 1 <= edges.length <= n * (n - 1) / 2
    * edges[i].length == 3
    * 0 <= ai, bi < n
    * wi = -1 or 1 <= wi <= 10^7
    * ai != bi
    * 0 <= source, destination < n
    * source != destination
    * 1 <= target <= 10^9
    * The graph is connected, and there are no self-loops or repeated edges*/

    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {
        int[][] graph = new int[n][n];
        for (var e : edges)
            graph[e[0]][e[1]] = graph[e[1]][e[0]] = e[2];
        int[] orig = new int[n];
        Arrays.fill(orig, Integer.MAX_VALUE);
        orig[source] = 0;
        Queue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        pq.add(new int[]{0, source});
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            int d = elem[0], u = elem[1];
            if (d == orig[u]) {
                for (int v = 0; v < n; ++v) {
                    int w = graph[u][v];
                    if (w > 0 && w != -1 && d+w < orig[v]) {
                        orig[v] = d+w;
                        pq.add(new int[]{orig[v], v});
                    }
                }
            }
        }
        if (orig[destination] < target) return new int[][]{};
        if (orig[destination] == target) {
            for (int i = 0; i < edges.length; ++i)
                if (edges[i][2] == -1) edges[i][2] = 2_000_000_000;
            return edges;
        }
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;
        int[] parent = new int[n];
        Arrays.fill(parent, -1);
        pq.add(new int[]{0, source});
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            int d = elem[0], u = elem[1];
            if (u == destination) {
                if (d > target) return new int[][]{};
                break;
            }
            if (d == dist[u]) {
                for (int v = 0; v < n; ++v) {
                    int w = graph[u][v];
                    if (w != 0) {
                        int dd = w == -1 ? d+1 : d+w;
                        if (dd < dist[v]) {
                            dist[v] = dd;
                            parent[v] = u;
                            pq.add(new int[]{dd, v});
                        }
                    }
                }
            }
        }
        for (int u = destination; u >= 0 && parent[u] >= 0; u = parent[u]) {
            int p = parent[u];
            if (graph[p][u] == -1) {
                if (orig[p] < target) {
                    graph[p][u] = graph[u][p] = target - orig[p];
                    break;
                }
                graph[p][u] = graph[u][p] = 1;
            }
            target -= graph[u][p];
        }
        for (int i = 0; i < edges.length; ++i) {
            int u = edges[i][0], v = edges[i][1], w = edges[i][2];
            if (graph[u][v] == -1) edges[i][2] = 2_000_000_000;
            else edges[i][2] = graph[u][v];
        }
        return edges;
    }


    /*2707. Extra Characters in a String (Medium)
    You are given a 0-indexed string s and a dictionary of words dictionary. You
    have to break s into one or more non-overlapping substrings such that each
    substring is present in dictionary. There may be some extra characters in s
    which are not present in any of the substrings. Return the minimum number of
    extra characters left over if you break up s optimally.

    Example 1:
    Input: s = "leetscode", dictionary = ["leet","code","leetcode"]
    Output: 1
    Explanation: We can break s in two substrings: "leet" from index 0 to 3 and
                 "code" from index 5 to 8. There is only 1 unused character (at
                 index 4), so we return 1.

    Example 2:
    Input: s = "sayhelloworld", dictionary = ["hello","world"]
    Output: 3
    Explanation: We can break s in two substrings: "hello" from index 3 to 7 and
                 "world" from index 8 to 12. The characters at indices 0, 1, 2
                 are not used in any substring and thus are considered as extra
                 characters. Hence, we return 3.

    Constraints:
    * 1 <= s.length <= 50
    * 1 <= dictionary.length <= 50
    * 1 <= dictionary[i].length <= 50
    * dictionary[i] and s consists of only lowercase English letters
    * dictionary contains distinct words

    class TrieNode {
        public TrieNode[] child = new TrieNode[26];
        public TrieNode output = null;
        public TrieNode parent = null;
        public TrieNode suffix = null;
        public String word;
    }

    public class AhoCorasick {
        public TrieNode root = new TrieNode();

        public void build(String[] patterns) {
            for (var pattern : patterns) {
                TrieNode node = root;
                for (var ch : pattern.toCharArray()) {
                    int c = (int) (ch - 'a');
                    if (node.child[c] == null) {
                        node.child[c] = new TrieNode();
                        node.child[c].parent = node;
                    }
                    node = node.child[c];
                }
                node.word = pattern;
            }
            Queue<TrieNode> q = new LinkedList<>(); q.add(root);
            while (!q.isEmpty())
                for (int sz = q.size(); sz > 0; --sz) {
                    TrieNode node = q.poll();
                    for (int i = 0; i < 26; ++i) {
                        TrieNode child = node.child[i], suffix = node.suffix;
                        if (child != null) {
                            while (suffix != null && suffix.child[i] == null)
                                suffix = suffix.suffix;
                            if (suffix != null) {
                                child.suffix = suffix.child[i];
                                if (child.suffix.word != null) child.output =child.suffix;
                                else child.output = child.suffix.output;
                            } else {
                                child.output = null;
                                child.suffix = root;
                            }
                            q.add(child);
                        }
                    }
                }
        }

        public Map<String, List<Integer>> match(String text) {
            Map<String, List<Integer>> ans = new HashMap<>();
            TrieNode node = root;
            for (int i = 0; i < text.length(); ++i) {
                char ch = text.charAt(i);
                int c = (int) (ch - 'a');
                while (node.child[c] == null && node.suffix != null)
                    node = node.suffix;
                if (node.child[c] != null) node = node.child[c];
                for (TrieNode output = node; output != null; output = output.output)
                    if (output.word != null) {
                        String pattern = output.word;
                        if (!ans.containsKey(pattern))
                            ans.put(pattern, new ArrayList<>());
                        ans.get(pattern).add(i-pattern.length()+1);
                    }
            }
            return ans;
        }
    }*/

    public int minExtraChar(String s, String[] dictionary) {
        AhoCorasick trie = new AhoCorasick();
        trie.build(dictionary);
        Map<Integer, List<String>> mp = new HashMap<>();
        Map<String, List<Integer>> match = trie.match(s);
        for (var k : match.keySet()) {
            List<Integer> v = match.get(k);
            for (var i : match.get(k)) {
                if (!mp.containsKey(i))
                    mp.put(i, new ArrayList<>());
                mp.get(i).add(k);
            }
        }
        int n = s.length();
        int[] dp = new int[n+1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[n] = 0;
        for (int i = n-1; i >= 0; --i) {
            dp[i] = dp[i+1] + 1;
            if (mp.containsKey(i))
                for (var k : mp.get(i))
                    dp[i] = Math.min(dp[i], dp[i+k.length()]);
        }
        return dp[0];
    }


    /*2728. Count Houses in a Circular Street (Easy)
    You are given an object street of class Street that represents a circular
    street and a positive integer k which represents a maximum bound for the
    number of houses in that street (in other words, the number of houses is
    less than or equal to k). Houses' doors could be open or closed initially.
    Initially, you are standing in front of a door to a house on this street.
    Your task is to count the number of houses in the street. The class Street
    contains the following functions which may help you:
    * void openDoor(): Open the door of the house you are in front of.
    * void closeDoor(): Close the door of the house you are in front of.
    * boolean isDoorOpen(): Returns true if the door of the current house is
      open and false otherwise.
    * void moveRight(): Move to the right house.
    * void moveLeft(): Move to the left house.
    Return ans which represents the number of houses on this street.

    Example 1:
    Input: street = [0,0,0,0], k = 10
    Output: 4
    Explanation: There are 4 houses, and all their doors are closed. The number
                 of houses is less than k, which is 10.

    Example 2:
    Input: street = [1,0,1,1,0], k = 5
    Output: 5
    Explanation: There are 5 houses, and the doors of the 1st, 3rd, and 4th
                 house (moving in the right direction) are open, and the rest
                 are closed. The number of houses is equal to k, which is 5.

    Constraints:
    * n == number of houses
    * 1 <= n <= k <= 10^3*/

    public int houseCount(Street street, int k) {
        for (; k > 0; --k) {
            street.openDoor();
            street.moveRight();
        }
        int ans = 0;
        for (; street.isDoorOpen(); ++ans) {
            street.closeDoor();
            street.moveRight();
        }
        return ans;
    }


    /*2729. Check if The Number is Fascinating (Easy)
    You are given an integer n that consists of exactly 3 digits. We call the
    number n fascinating if, after the following modification, the resulting
    number contains all the digits from 1 to 9 exactly once and does not contain
    any 0's:
    * Concatenate n with the numbers 2 * n and 3 * n.
    Return true if n is fascinating, or false otherwise. Concatenating two
    numbers means joining them together. For example, the concatenation of 121
    and 371 is 121371.

    Example 1:
    Input: n = 192
    Output: true
    Explanation: We concatenate the numbers n = 192 and 2 * n = 384 and
                 3 * n = 576. The resulting number is 192384576. This number
                 contains all the digits from 1 to 9 exactly once.

    Example 2:
    Input: n = 100
    Output: false
    Explanation: We concatenate the numbers n = 100 and 2 * n = 200 and
                 3 * n = 300. The resulting number is 100200300. This number
                 does not satisfy any of the conditions.

    Constraints: 100 <= n <= 999*/

    public boolean isFascinating(int n) {
        Set<Character> seen = new HashSet();
        for (int x = n; x <= 3*n; x += n) {
            if (x >= 1000) return false;
            for (var ch : String.valueOf(x).toCharArray()) seen.add(ch);
        }
        return seen.size() == 9 && !seen.contains('0');
    }


    /*2730. Find the Longest Semi-Repetitive Substring (Medium)
    You are given a digit string s that consists of digits from 0 to 9. A string
    is called semi-repetitive if there is at most one adjacent pair of the same
    digit. For example, "0010", "002020", "0123", "2002", and "54944" are semi-
    repetitive while the following are not: "00101022" (adjacent same digit
    pairs are 00 and 22), and "1101234883" (adjacent same digit pairs are 11 and
    88). Return the length of the longest semi-repetitive substring of s.

    Example 1:
    Input: s = "52233"
    Output: 4
    Explanation: The longest semi-repetitive substring is "5223". Picking the
                 whole string "52233" has two adjacent same digit pairs 22 and
                 33, but at most one is allowed.

    Example 2:
    Input: s = "5494"
    Output: 4
    Explanation: s is a semi-repetitive string.

    Example 3:
    Input: s = "1111111"
    Output: 2
    Explanation: The longest semi-repetitive substring is "11". Picking the
                 substring "111" has two adjacent same digit pairs, but at most
                 one is allowed.

    Constraints:
    * 1 <= s.length <= 50
    * '0' <= s[i] <= '9'*/

    public int longestSemiRepetitiveSubstring(String s) {
        int ans = 1;
        for (int i = 1, ii = 0, q = 0; i < s.length(); ++i) {
            if (s.charAt(i-1) == s.charAt(i)) {
                if (q > 0) ii = q;
                q = i;
            }
            ans = Math.max(ans, i-ii+1);
        }
        return ans;
    }


    /*2731. Movement of Robots (Medium)
    Some robots are standing on an infinite number line with their initial
    coordinates given by a 0-indexed integer array nums and will start moving
    once given the command to move. The robots will move a unit distance each
    second. You are given a string s denoting the direction in which robots will
    move on command. 'L' means the robot will move towards the left side or
    negative side of the number line, whereas 'R' means the robot will move
    towards the right side or positive side of the number line. If two robots
    collide, they will start moving in opposite directions. Return the sum of
    distances between all the pairs of robots d seconds after the command. Since
    the sum can be very large, return it modulo 109 + 7.

    Note:
    * For two robots at the index i and j, pair (i,j) and pair (j,i) are
      considered the same pair.
    * When robots collide, they instantly change their directions without
      wasting any time.
    * Collision happens when two robots share the same place in a moment.
      - For example, if a robot is positioned in 0 going to the right and
        another is positioned in 2 going to the left, the next second they'll be
        both in 1 and they will change direction and the next second the first
        one will be in 0, heading left, and another will be in 2, heading right.
      - For example, if a robot is positioned in 0 going to the right and
        another is positioned in 1 going to the left, the next second the first
        one will be in 0, heading left, and another will be in 1, heading right.

    Example 1:
    Input: nums = [-2,0,2], s = "RLL", d = 3
    Output: 8
    Explanation: - After 1 second, the positions are [-1,-1,1]. Now, the robot
                   at index 0 will move left, and the robot at index 1 will move
                   right.
                 - After 2 seconds, the positions are [-2,0,0]. Now, the robot
                   at index 1 will move left, and the robot at index 2 will move
                   right.
                 - After 3 seconds, the positions are [-3,-1,1].
                 - The distance between the robot at index 0 and 1 is
                   abs(-3 - (-1)) = 2.
                 - The distance between the robot at index 0 and 2 is
                   abs(-3 - 1) = 4.
                 - The distance between the robot at index 1 and 2 is
                   abs(-1 - 1) = 2.
                 - The sum of the pairs of all distances = 2 + 4 + 2 = 8.

    Example 2:
    Input: nums = [1,0], s = "RL", d = 2
    Output: 5
    Explanation: - After 1 second, the positions are [2,-1].
                 - After 2 seconds, the positions are [3,-2].
                 The distance between the two robots is abs(-2 - 3) = 5.

    Constraints:
    * 2 <= nums.length <= 10^5
    * -2 * 10^9 <= nums[i] <= 2 * 10^9
    * 0 <= d <= 10^9
    * nums.length == s.length
    * s consists of 'L' and 'R' only
    * nums[i] will be unique.*/

    public int sumDistance(int[] nums, String s, int d) {
        final int mod = 1_000_000_007;
        for (int i = 0; i < nums.length; ++i) {
            if (s.charAt(i) == 'L') nums[i] -= d;
            else nums[i] += d;
        }
        Arrays.sort(nums);
        long ans = 0, prefix = 0;
        for (int i = 0; i < nums.length; ++i) {
            ans = (ans + (long) i*nums[i] - prefix) % mod;
            prefix = (prefix + nums[i]) % mod;
        }
        return (int) ans;
    }


    /*2732. Find a Good Subset of the Matrix (Hard)
    You are given a 0-indexed m x n binary matrix grid. Let us call a non-empty
    subset of rows good if the sum of each column of the subset is at most half
    of the length of the subset. More formally, if the length of the chosen
    subset of rows is k, then the sum of each column should be at most
    floor(k / 2). Return an integer array that contains row indices of a good
    subset sorted in ascending order. If there are multiple good subsets, you
    can return any of them. If there are no good subsets, return an empty array.
    A subset of rows of the matrix grid is any matrix that can be obtained by
    deleting some (possibly none or all) rows from grid.

    Example 1:
    Input: grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]
    Output: [0,1]
    Explanation: We can choose the 0th and 1st rows to create a good subset of rows.
                 The length of the chosen subset is 2.
                 - The sum of the 0th column is 0 + 0 = 0, which is at most half of the length of the subset.
                 - The sum of the 1st column is 1 + 0 = 1, which is at most half of the length of the subset.
                 - The sum of the 2nd column is 1 + 0 = 1, which is at most half of the length of the subset.
                 - The sum of the 3rd column is 0 + 1 = 1, which is at most half of the length of the subset.

    Example 2:
    Input: grid = [[0]]
    Output: [0]
    Explanation: We can choose the 0th row to create a good subset of rows.
                 The length of the chosen subset is 1.
                 - The sum of the 0th column is 0, which is at most half of the length of the subset.

    Example 3:
    Input: grid = [[1,1,1],[1,1,1]]
    Output: []
    Explanation: It is impossible to choose any subset of rows to create a good subset.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m <= 10^4
    * 1 <= n <= 5
    * grid[i][j] is either 0 or 1.*/

    public List<Integer> goodSubsetofBinaryMatrix(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        Map<Integer, Integer> seen = new HashMap<>();
        for (int i = 0; i < m; ++i) {
            int v = 0;
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == 1) v ^= 1<<j;
            if (v == 0) return Arrays.asList(i);
            for (var vv : seen.keySet()) {
                int ii = seen.get(vv);
                if ((vv & v) == 0) return Arrays.asList(ii, i);
            }
            seen.put(v, i);
        }
        return new ArrayList<>();
    }


    /*2733. Neither Minimum nor Maximum (Easy)
    Given an integer array nums containing distinct positive integers, find and
    return any number from the array that is neither the minimum nor the maximum
    value in the array, or -1 if there is no such number. Return the selected
    integer.

    Example 1:
    Input: nums = [3,2,1,4]
    Output: 2
    Explanation: In this example, the minimum value is 1 and the maximum value
                 is 4. Therefore, either 2 or 3 can be valid answers.

    Example 2:
    Input: nums = [1,2]
    Output: -1
    Explanation: Since there is no number in nums that is neither the maximum
                 nor the minimum, we cannot select a number that satisfies the
                 given condition. Therefore, there is no answer.

    Example 3:
    Input: nums = [2,1,3]
    Output: 2
    Explanation: Since 2 is neither the maximum nor the minimum value in nums,
                 it is the only valid answer.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * All values in nums are distinct*/

    public int findNonMinOrMax(int[] nums) {
        if (nums.length < 3) return -1;
        Arrays.sort(nums, 0, 3);
        return nums[1];
    }


    /*2734. Lexicographically Smallest String After Substring Operation (Medium)
    Given a string s consisting of lowercase English letters. Perform the
    following operation:
    * Select any non-empty substring then replace every letter of the substring
      with the preceding letter of the English alphabet. For example, 'b' is
      converted to 'a', and 'a' is converted to 'z'.
    Return the lexicographically smallest string after performing the operation.

    Example 1:
    Input: s = "cbabc"
    Output: "baabc"
    Explanation: Perform the operation on the substring starting at index 0, and
                 ending at index 1 inclusive.

    Example 2:
    Input: s = "aa"
    Output: "az"
    Explanation: Perform the operation on the last letter.

    Example 3:
    Input: s = "acbbc"
    Output: "abaab"
    Explanation: Perform the operation on the substring starting at index 1, and
                 ending at index 4 inclusive.

    Example 4:
    Input: s = "leetcode"
    Output: "kddsbncd"
    Explanation: Perform the operation on the entire string.

    Constraints:
    * 1 <= s.length <= 3 * 10^5
    * s consists of lowercase English letters*/

    public String smallestString(String s) {
        char[] ch = s.toCharArray();
        int i = 0, n = ch.length;
        for (; i < n && ch[i] == 'a'; ++i);
        if (i == n) ch[n-1] = 'z';
        for (; i < n && ch[i] != 'a'; --ch[i], ++i);
        return new String(ch);
    }


    /*2735. Collecting Chocolates (Medium)
    You are given a 0-indexed integer array nums of size n representing the cost
    of collecting different chocolates. The cost of collecting the chocolate at
    the index i is nums[i]. Each chocolate is of a different type, and initially,
    the chocolate at the index i is of ith type. In one operation, you can do
    the following with an incurred cost of x:
    * Simultaneously change the chocolate of ith type to ((i + 1) mod n)th type
      for all chocolates.
    Return the minimum cost to collect chocolates of all types, given that you
    can perform as many operations as you would like.

    Example 1:
    Input: nums = [20,1,15], x = 5
    Output: 13
    Explanation: - Initially, the chocolate types are [0,1,2]. We will buy the
                   1st type of chocolate at a cost of 1.
                 - Now, we will perform the operation at a cost of 5, and the
                   types of chocolates will become [1,2,0]. We will buy the 2nd
                   type of chocolate at a cost of 1.
                 - Now, we will again perform the operation at a cost of 5, and
                   the chocolate types will become [2,0,1]. We will buy the 0th
                   type of chocolate at a cost of 1.
                 Thus, the total cost will become (1 + 5 + 1 + 5 + 1) = 13. We
                 can prove that this is optimal.

    Example 2:
    Input: nums = [1,2,3], x = 4
    Output: 6
    Explanation: We will collect all three types of chocolates at their own
                 price without performing any operations. Therefore, the total
                 cost is 1 + 2 + 3 = 6.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^9
    * 1 <= x <= 10^9*/

    public long minCost(int[] nums, int x) {
        int n = nums.length;
        long[] ans = new long[n];
        for (int i = 0; i < n; ++i) {
            ans[i] += (long) i*x;
            int prefix = nums[i];
            for (int j = 0; j < n; ++j) {
                prefix = Math.min(prefix, nums[(i-j+n)%n]);
                ans[j] += prefix;
            }
        }
        return Arrays.stream(ans).min().getAsLong();
    }


    /*2736. Maximum Sum Queries (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2, each of length
    n, and a 1-indexed 2D array queries where queries[i] = [xi, yi]. For the ith
    query, find the maximum value of nums1[j] + nums2[j] among all indices j
    (0 <= j < n), where nums1[j] >= xi and nums2[j] >= yi, or -1 if there is no
    j satisfying the constraints. Return an array answer where answer[i] is the
    answer to the ith query.

    Example 1:
    Input: nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]
    Output: [6,10,7]
    Explanation: - For the 1st query xi = 4 and yi = 1, we can select index
                   j = 0 since nums1[j] >= 4 and nums2[j] >= 1. The sum
                   nums1[j] + nums2[j] is 6, and we can show that 6 is the
                   maximum we can obtain.
                 - For the 2nd query xi = 1 and yi = 3, we can select index
                   j = 2 since nums1[j] >= 1 and nums2[j] >= 3. The sum
                   nums1[j] + nums2[j] is 10, and we can show that 10 is the
                   maximum we can obtain.
                 - For the 3rd query xi = 2 and yi = 5, we can select index
                   j = 3 since nums1[j] >= 2 and nums2[j] >= 5. The sum
                   nums1[j] + nums2[j] is 7, and we can show that 7 is the
                   maximum we can obtain.
                 Therefore, we return [6,10,7].

    Example 2:
    Input: nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]
    Output: [9,9,9]
    Explanation: For this example, we can use index j = 2 for all the queries
                 since it satisfies the constraints for each query.

    Example 3:
    Input: nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]
    Output: [-1]
    Explanation: There is one query in this example with xi = 3 and yi = 3. For
                 every index, j, either nums1[j] < xi or nums2[j] < yi. Hence,
                 there is no solution.

    Constraints:
    * nums1.length == nums2.length
    * n == nums1.length
    * 1 <= n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^9
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * xi == queries[i][1]
    * yi == queries[i][2]
    * 1 <= xi, yi <= 10^9*/

    public int[] maximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {
        int n = nums1.length, q = queries.length;
        int[][] both = new int[n][2];
        for (int i = 0; i < n; ++i) {
            both[i][0] = nums1[i];
            both[i][1] = nums2[i];
        }
        Arrays.sort(both, Comparator.comparingInt(x -> -x[0]));
        int[] ans = new int[q];
        Integer[] idx = IntStream.range(0, q).boxed().toArray(Integer[]::new);
        Arrays.sort(idx, Comparator.comparingInt(i -> -queries[i][0]));
        TreeMap<Integer, Integer> mp = new TreeMap<>();
        int j = 0;
        for (var i : idx) {
            int x = queries[i][0], y = queries[i][1];
            for (; j < n && both[j][0] >= x; ++j) {
                int key = both[j][1], val = both[j][0] + both[j][1];
                Integer k = mp.ceilingKey(key);
                if (k != null && val <= mp.get(k)) continue;
                for (var p = mp.floorKey(key-1); p != null && mp.get(p) <= val; p = mp.floorKey(key-1))
                    mp.remove(p);
                mp.put(key, val);
            }
            Integer k = mp.ceilingKey(y);
            if (k == null) ans[i] = -1;
            else ans[i] = mp.get(k);
        }
        return ans;
    }


    /*2737. Find the Closest Marked Node (Medium)
    You are given a positive integer n which is the number of nodes of a 0-
    indexed directed weighted graph and a 0-indexed 2D array edges where
    edges[i] = [ui, vi, wi] indicates that there is an edge from node ui to node
    vi with weight wi. You are also given a node s and a node array marked; your
    task is to find the minimum distance from s to any of the nodes in marked.
    Return an integer denoting the minimum distance from s to any node in marked
    or -1 if there are no paths from s to any of the marked nodes.

    Example 1:
    Input: n = 4, edges = [[0,1,1],[1,2,3],[2,3,2],[0,3,4]], s = 0, marked = [2,3]
    Output: 4
    Explanation: There is one path from node 0 (the green node) to node 2 (a red
                 node), which is 0->1->2, and has a distance of 1 + 3 = 4. There
                 are two paths from node 0 to node 3 (a red node), which are
                 0->1->2->3 and 0->3, the first one has a distance of
                 1 + 3 + 2 = 6 and the second one has a distance of 4. The
                 minimum of them is 4.

    Example 2:
    Input: n = 5, edges = [[0,1,2],[0,2,4],[1,3,1],[2,3,3],[3,4,2]], s = 1, marked = [0,4]
    Output: 3
    Explanation: There are no paths from node 1 (the green node) to node 0 (a
                 red node). There is one path from node 1 to node 4 (a red
                 node), which is 1->3->4, and has a distance of 1 + 2 = 3. So
                 the answer is 3.

    Example 3:
    Input: n = 4, edges = [[0,1,1],[1,2,3],[2,3,2]], s = 3, marked = [0,1]
    Output: -1
    Explanation: There are no paths from node 3 (the green node) to any of the
                 marked nodes (the red nodes), so the answer is -1.

    Constraints:
    * 2 <= n <= 500
    * 1 <= edges.length <= 10^4
    * edges[i].length = 3
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * 1 <= edges[i][2] <= 10^6
    * 1 <= marked.length <= n - 1
    * 0 <= s, marked[i] <= n - 1
    * s != marked[i]
    * marked[i] != marked[j] for every i != j
    * The graph might have repeated edges.
    * The graph is generated such that it has no self-loops.*/

    public int minimumDistance(int n, List<List<Integer>> edges, int s, int[] marked) {
        List<int[]>[] graph = new ArrayList[n];
        for (int i = 0; i < n; ++i)
            graph[i] = new ArrayList();
        for (var e : edges) {
            int u = e.get(0), v = e.get(1), w = e.get(2);
            graph[u].add(new int[]{v, w});
        }
        Set seen = new HashSet<>(Arrays.asList(marked));
        for (var x : marked) seen.add(x);
        PriorityQueue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[0], y[0]));
        pq.add(new int[]{0, s});
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[s] = 0;
        while (pq.size() > 0) {
            var elem = pq.poll();
            int x = elem[0], u = elem[1];
            if (seen.contains(u)) return x;
            for (var p : graph[u]) {
                int v = p[0], w = p[1];
                if (x + w < dist[v]) {
                    dist[v] = x + w;
                    pq.add(new int[]{x+w, v});
                }
            }
        }
        return -1;
    }


    /*2739. Total Distance Traveled (Easy)
    A truck has two fuel tanks. You are given two integers, mainTank
    representing the fuel present in the main tank in liters and additionalTank
    representing the fuel present in the additional tank in liters. The truck
    has a mileage of 10 km per liter. Whenever 5 liters of fuel get used up in
    the main tank, if the additional tank has at least 1 liters of fuel, 1
    liters of fuel will be transferred from the additional tank to the main
    tank. Return the maximum distance which can be traveled. Note: Injection
    from the additional tank is not continuous. It happens suddenly and
    immediately for every 5 liters consumed.

    Example 1:
    Input: mainTank = 5, additionalTank = 10
    Output: 60
    Explanation: - After spending 5 litre of fuel, fuel remaining is
                   (5 - 5 + 1) = 1 litre and distance traveled is 50km.
                 - After spending another 1 litre of fuel, no fuel gets injected
                   in the main tank and the main tank becomes empty.
                 Total distance traveled is 60km.

    Example 2:
    Input: mainTank = 1, additionalTank = 2
    Output: 10
    Explanation: After spending 1 litre of fuel, the main tank becomes empty.
                 Total distance traveled is 10km.

    Constraints: 1 <= mainTank, additionalTank <= 100*/

    public int distanceTraveled(int mainTank, int additionalTank) {
        int ans = 0;
        while (mainTank >= 5) {
            int q = mainTank / 5;
            mainTank %= 5;
            ans += 50*q;
            q = Math.min(q, additionalTank);
            mainTank += q;
            additionalTank -= q;
        }
        return ans + 10*mainTank;
    }


    /*2740. Find the Value of the Partition (Medium)
    You are given a positive integer array nums. Partition nums into two arrays,
    nums1 and nums2, such that:
    * Each element of the array nums belongs to either the array nums1 or the
      array nums2.
    * Both arrays are non-empty.
    * The value of the partition is minimized.
    The value of the partition is |max(nums1) - min(nums2)|. Here, max(nums1)
    denotes the maximum element of the array nums1, and min(nums2) denotes the
    minimum element of the array nums2. Return the integer denoting the value of
    such partition.

    Example 1:
    Input: nums = [1,3,2,4]
    Output: 1
    Explanation: We can partition the array nums into nums1 = [1,2] and
                 nums2 = [3,4].
                 - The maximum element of the array nums1 is equal to 2.
                 - The minimum element of the array nums2 is equal to 3.
                 The value of the partition is |2 - 3| = 1. It can be proven
                 that 1 is the minimum value out of all partitions.

    Example 2:
    Input: nums = [100,1,10]
    Output: 9
    Explanation: We can partition the array nums into nums1 = [10] and
                 nums2 = [100,1].
                 - The maximum element of the array nums1 is equal to 10.
                 - The minimum element of the array nums2 is equal to 1.
                 The value of the partition is |10 - 1| = 9. It can be proven
                 that 9 is the minimum value out of all partitions.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public int findValueOfPartition(int[] nums) {
        Arrays.sort(nums);
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length-1; ++i)
            ans = Math.min(ans, nums[i+1]-nums[i]);
        return ans;
    }


    /*2741. Special Permutations (Medium)
    You are given a 0-indexed integer array nums containing n distinct positive
    integers. A permutation of nums is called special if:
    * For all indexes 0 <= i < n - 1, either nums[i] % nums[i+1] == 0 or
      nums[i+1] % nums[i] == 0.
    Return the total number of special permutations. As the answer could be
    large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,3,6]
    Output: 2
    Explanation: [3,6,2] and [2,6,3] are the two special permutations of nums.

    Example 2:
    Input: nums = [1,4,3]
    Output: 2
    Explanation: [3,1,4] and [4,1,3] are the two special permutations of nums.

    Constraints:
    * 2 <= nums.length <= 14
    * 1 <= nums[i] <= 10^9*/

    private int fn(int i, int m, int n, int[] nums, int[][] memo, int mod) {
        if (m+1 == 1<<n) return 1;
        if (memo[i][m] == -1) {
            memo[i][m] = 0;
            for (int j = 0; j < n; ++j)
                if ((m & 1<<j) == 0 && (nums[i]%nums[j] == 0 || nums[j]%nums[i] == 0))
                    memo[i][m] = (memo[i][m] + fn(j, m ^ 1<<j, n, nums, memo, mod)) % mod;
        }
        return memo[i][m];
    }
    public int specialPerm(int[] nums) {
        int mod = 1_000_000_007, n = nums.length;
        int[][] memo = new int[n][1<<n];
        for (int i = 0; i < n; ++i)
            Arrays.fill(memo[i], -1);
        int ans = 0;
        for (int i = 0; i < n; ++i)
            ans = (ans + fn(i, 1<<i, n, nums, memo, mod)) % mod;
        return ans;
    }


    /*2742. Painting the Walls (Hard)
    You are given two 0-indexed integer arrays, cost and time, of size n
    representing the costs and the time taken to paint n different walls
    respectively. There are two painters available:
    * A paid painter that paints the ith wall in time[i] units of time and takes
      cost[i] units of money.
    * A free painter that paints any wall in 1 unit of time at a cost of 0. But
      the free painter can only be used if the paid painter is already occupied.
    Return the minimum amount of money required to paint the n walls.

    Example 1:
    Input: cost = [1,2,3,2], time = [1,2,3,2]
    Output: 3
    Explanation: The walls at index 0 and 1 will be painted by the paid painter,
                 and it will take 3 units of time; meanwhile, the free painter
                 will paint the walls at index 2 and 3, free of cost in 2 units
                 of time. Thus, the total cost is 1 + 2 = 3.

    Example 2:
    Input: cost = [2,3,4,2], time = [1,1,1,1]
    Output: 4
    Explanation: The walls at index 0 and 3 will be painted by the paid painter,
                 and it will take 2 units of time; meanwhile, the free painter
                 will paint the walls at index 1 and 2, free of cost in 2 units
                 of time. Thus, the total cost is 2 + 2 = 4.

    Constraints:
    * 1 <= cost.length <= 500
    * cost.length == time.length
    * 1 <= cost[i] <= 10^6
    * 1 <= time[i] <= 500*/

    public int paintWalls(int[] cost, int[] time) {
        int n = cost.length;
        int[][] dp = new int[n+1][n+1];
        for (int i = 0; i <= n; ++i)
            Arrays.fill(dp[i], 500_000_000);
        for (int i = n-1; i >= 0; --i)
            for (int j = 0; j <= n; ++j) {
                dp[i][j] = dp[i+1][j];
                int cand = cost[i];
                if (j > 1+time[i]) cand += dp[i+1][j-1-time[i]];
                dp[i][j] = Math.min(dp[i][j], cand);
            }
        return dp[0][n];
    }


    /*2743. Count Substrings Without Repeating Character (Medium)
    You are given a string s consisting only of lowercase English letters. We
    call a substring special if it contains no character which has occurred at
    least twice (in other words, it does not contain a repeating character).
    Your task is to count the number of special substrings. For example, in the
    string "pop", the substring "po" is a special substring, however, "pop" is
    not special (since 'p' has occurred twice). Return the number of special
    substrings. A substring is a contiguous sequence of characters within a
    string. For example, "abc" is a substring of "abcd", but "acd" is not.

    Example 1:
    Input: s = "abcd"
    Output: 10
    Explanation: Since each character occurs once, every substring is a special
                 substring. We have 4 substrings of length one, 3 of length two,
                 2 of length three, and 1 substring of length four. So overall
                 there are 4 + 3 + 2 + 1 = 10 special substrings.

    Example 2:
    Input: s = "ooo"
    Output: 3
    Explanation: Any substring with a length of at least two contains a
                 repeating character. So we have to count the number of
                 substrings of length one, which is 3.

    Example 3:
    Input: s = "abab"
    Output: 7
    Explanation: Special substrings are as follows (sorted by their start positions):
                 Special substrings of length 1: "a", "b", "a", "b"
                 Special substrings of length 2: "ab", "ba", "ab"
                 And it can be shown that there are no special substrings with a
                 length of at least three. So the answer would be 4 + 3 = 7.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists of lowercase English letters*/

    public int numberOfSpecialSubstrings(String s) {
        int ans = 0;
        Map<Character, Integer> prev = new HashMap();
        for (int i = 0, ii = -1; i < s.length(); ++i) {
            if (prev.containsKey(s.charAt(i))) ii = Math.max(ii, prev.get(s.charAt(i)));
            prev.put(s.charAt(i), i);
            ans += i-ii;
        }
        return ans;
    }


    /*2744. Find Maximum Number of String Pairs (Easy)
    You are given a 0-indexed array words consisting of distinct strings. The
    string words[i] can be paired with the string words[j] if:
    * The string words[i] is equal to the reversed string of words[j].
    * 0 <= i < j < words.length.
    Return the maximum number of pairs that can be formed from the array words.
    Note that each string can belong in at most one pair.

    Example 1:
    Input: words = ["cd","ac","dc","ca","zz"]
    Output: 2
    Explanation: In this example, we can form 2 pair of strings in the following
                 way:
                 - We pair the 0th string with the 2nd string, as the reversed
                   string of word[0] is "dc" and is equal to words[2].
                 - We pair the 1st string with the 3rd string, as the reversed
                   string of word[1] is "ca" and is equal to words[3].
                 It can be proven that 2 is the maximum number of pairs that can
                 be formed.

    Example 2:
    Input: words = ["ab","ba","cc"]
    Output: 1
    Explanation: In this example, we can form 1 pair of strings in the following
                 way:
                 - We pair the 0th string with the 1st string, as the reversed
                   string of words[1] is "ab" and is equal to words[0].
                 It can be proven that 1 is the maximum number of pairs that can
                 be formed.

    Example 3:
    Input: words = ["aa","ab"]
    Output: 0
    Explanation: In this example, we are unable to form any pair of strings.

    Constraints:
    * 1 <= words.length <= 50
    * words[i].length == 2
    * words consists of distinct strings.
    * words[i] contains only lowercase English letters.*/

    public int maximumNumberOfStringPairs(String[] words) {
        int ans = 0;
        Set<String> seen = new HashSet();
        for (var w : words) {
            var ww = new StringBuilder(w).reverse().toString();
            if (seen.contains(ww)) ++ans;
            seen.add(w);
        }
        return ans;
    }


    /*2745. Construct the Longest New String (Medium)
    You are given three integers x, y, and z. You have x strings equal to "AA",
    y strings equal to "BB", and z strings equal to "AB". You want to choose
    some (possibly all or none) of these strings and concatenate them in some
    order to form a new string. This new string must not contain "AAA" or "BBB"
    as a substring. Return the maximum possible length of the new string. A
    substring is a contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: x = 2, y = 5, z = 1
    Output: 12
    Explanation: We can concactenate the strings "BB", "AA", "BB", "AA", "BB",
                 and "AB" in that order. Then, our new string is "BBAABBAABBAB".
                 That string has length 12, and we can show that it is
                 impossible to construct a string of longer length.

    Example 2:
    Input: x = 3, y = 2, z = 2
    Output: 14
    Explanation: We can concactenate the strings "AB", "AB", "AA", "BB", "AA",
                 "BB", and "AA" in that order. Then, our new string is
                 "ABABAABBAABBAA". That string has length 14, and we can show
                 that it is impossible to construct a string of longer length.

    Constraints: 1 <= x, y, z <= 50*/

    public int longestString(int x, int y, int z) {
        return 2*(Math.min(x+y, 2*Math.min(x, y)+1) + z);
    }


    /*2746. Decremental String Concatenation (Medium)
    You are given a 0-indexed array words containing n strings. Let's define a
    join operation join(x, y) between two strings x and y as concatenating them
    into xy. However, if the last character of x is equal to the first character
    of y, one of them is deleted. For example join("ab", "ba") = "aba" and
    join("ab", "cde") = "abcde". You are to perform n - 1 join operations. Let
    str0 = words[0]. Starting from i = 1 up to i = n - 1, for the ith operation,
    you can do one of the following:
    * Make stri = join(stri - 1, words[i])
    * Make stri = join(words[i], stri - 1)
    Your task is to minimize the length of strn - 1. Return an integer denoting
    the minimum possible length of strn - 1.

    Example 1:
    Input: words = ["aa","ab","bc"]
    Output: 4
    Explanation: In this example, we can perform join operations in the
                 following order to minimize the length of str2:
                 - str0 = "aa"
                 - str1 = join(str0, "ab") = "aab"
                 - str2 = join(str1, "bc") = "aabc"
                 It can be shown that the minimum possible length of str2 is 4.

    Example 2:
    Input: words = ["ab","b"]
    Output: 2
    Explanation: In this example, str0 = "ab", there are two ways to get str1:
                 join(str0, "b") = "ab" or join("b", str0) = "bab".
                 The first string, "ab", has the minimum length. Hence, the
                 answer is 2.

    Example 3:
    Input: words = ["aaa","c","aba"]
    Output: 6
    Explanation: In this example, we can perform join operations in the
                 following order to minimize the length of str2:
                 - str0 = "aaa"
                 - str1 = join(str0, "c") = "aaac"
                 - str2 = join("aba", str1) = "abaaac"
                 It can be shown that the minimum possible length of str2 is 6.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 50
    * Each character in words[i] is an English lowercase letter*/

    private int fn(int i, int s, int e, String[] words, int[][][] memo) {
        if (i == words.length) return 0;
        if (memo[i][s][e] == -1) {
            String w = words[i];
            int sz = w.length();
            int cand1 = fn(i+1, s, w.charAt(sz-1) - 'a', words, memo) - (e == w.charAt(0) - 'a' ? 1 : 0);
            int cand2 = fn(i+1, w.charAt(0) - 'a', e, words, memo) - (w.charAt(sz-1) - 'a' == s ? 1 : 0);
            memo[i][s][e] = sz + Math.min(cand1, cand2);
        }
        return memo[i][s][e];
    }

    public int minimizeConcatenatedLength(String[] words) {
        int n = words.length, sz = words[0].length();
        int[][][] memo = new int[n][26][26];
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < 26; ++j)
                Arrays.fill(memo[i][j], -1);
        return sz + fn(1, words[0].charAt(0) - 'a', words[0].charAt(sz-1) - 'a', words, memo);
    }


    /*2747. Count Zero Request Servers (Medium)
    You are given an integer n denoting the total number of servers and a 2D
    0-indexed integer array logs, where logs[i] = [server_id, time] denotes that
    the server with id server_id received a request at time time. You are also
    given an integer x and a 0-indexed integer array queries. Return a 0-indexed
    integer array arr of length queries.length where arr[i] represents the
    number of servers that did not receive any requests during the time interval
    [queries[i] - x, queries[i]]. Note that the time intervals are inclusive.

    Example 1:
    Input: n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]
    Output: [1,2]
    Explanation:  - For queries[0]: The servers with ids 1 and 2 get requests in
                    the duration of [5, 10]. Hence, only server 3 gets zero
                    requests.
                  - For queries[1]: Only the server with id 2 gets a request in
                    duration of [6,11]. Hence, the servers with ids 1 and 3 are
                    the only servers that do not receive any requests during
                    that time period.

    Example 2:
    Input: n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]
    Output: [0,1]
    Explanation: - For queries[0]: All servers get at least one request in the
                   duration of [1, 3].
                 - For queries[1]: Only server with id 3 gets no request in the
                   duration [2,4].

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= logs.length <= 10^5
    * 1 <= queries.length <= 10^5
    * logs[i].length == 2
    * 1 <= logs[i][0] <= n
    * 1 <= logs[i][1] <= 10^6
    * 1 <= x <= 10^5
    * x < queries[i] <= 10^6*/

    public int[] countServers(int n, int[][] logs, int x, int[] queries) {
        Arrays.sort(logs, (a, b) -> Integer.compare(a[1], b[1]));
        int sz = queries.length;
        int[] ans = new int[sz];
        int[][] aug = new int[sz][2];
        for (int i = 0; i < sz; ++i)
            aug[i] = new int[]{queries[i], i};
        Arrays.sort(aug, (a, b) -> Integer.compare(a[0], b[0]));
        Map<Integer, Integer> freq = new HashMap<>();
        int j = 0, jj = 0;
        for (var v : aug) {
            int q = v[0], i = v[1];
            for (; j < logs.length && logs[j][1] <= q; ++j)
                freq.merge(logs[j][0], 1, Integer::sum);
            for (; jj < logs.length && logs[jj][1] < q-x; ++jj) {
                freq.merge(logs[jj][0], -1, Integer::sum);
                if (freq.get(logs[jj][0]) == 0) freq.remove(logs[jj][0]);
            }
            ans[i] = n - freq.size();
        }
        return ans;
    }


    /*2748. Number of Beautiful Pairs (Easy)
    You are given a 0-indexed integer array nums. A pair of indices i, j where
    0 <= i < j < nums.length is called beautiful if the first digit of nums[i]
    and the last digit of nums[j] are coprime. Return the total number of
    beautiful pairs in nums. Two integers x and y are coprime if there is no
    integer greater than 1 that divides both of them. In other words, x and y
    are coprime if gcd(x, y) == 1, where gcd(x, y) is the greatest common
    divisor of x and y.

    Example 1:
    Input: nums = [2,5,1,4]
    Output: 5
    Explanation: There are 5 beautiful pairs in nums:
                 - When i = 0 and j = 1: the first digit of nums[0] is 2, and
                   the last digit of nums[1] is 5. We can confirm that 2 and 5
                   are coprime, since gcd(2,5) == 1.
                 - When i = 0 and j = 2: the first digit of nums[0] is 2, and
                   the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.
                 - When i = 1 and j = 2: the first digit of nums[1] is 5, and
                   the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.
                 - When i = 1 and j = 3: the first digit of nums[1] is 5, and
                   the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.
                 - When i = 2 and j = 3: the first digit of nums[2] is 1, and
                   the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.
                 Thus, we return 5.

    Example 2:
    Input: nums = [11,21,12]
    Output: 2
    Explanation: There are 2 beautiful pairs:
                 - When i = 0 and j = 1: the first digit of nums[0] is 1, and
                   the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.
                 - When i = 0 and j = 2: the first digit of nums[0] is 1, and
                   the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.
                 Thus, we return 2.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 9999
    * nums[i] % 10 != 0*/

    public int countBeautifulPairs(int[] nums) {
        int ans = 0;
        Map<Integer, Integer> freq = new HashMap<>();
        for (var x : nums) {
            for (int y = 0; y < 10; ++y)
                if (BigInteger.valueOf(x%10).gcd(BigInteger.valueOf(y)).intValue() == 1)
                    ans += freq.getOrDefault(y, 0);
            for (; x >= 10; x /= 10);
            freq.merge(x, 1, Integer::sum);
        }
        return ans;
    }


    /*2749. Minimum Operations to Make the Integer Zero (Medium)
    You are given two integers num1 and num2. In one operation, you can choose
    integer i in the range [0, 60] and subtract 2i + num2 from num1. Return the
    integer denoting the minimum number of operations needed to make num1 equal
    to 0. If it is impossible to make num1 equal to 0, return -1.

    Example 1:
    Input: num1 = 3, num2 = -2
    Output: 3
    Explanation: We can make 3 equal to 0 with the following operations:
                 - We choose i = 2 and substract 22 + (-2) from 3,
                   3 - (4 + (-2)) = 1.
                 - We choose i = 2 and substract 22 + (-2) from 1,
                   1 - (4 + (-2)) = -1.
                 - We choose i = 0 and substract 20 + (-2) from -1,
                   (-1) - (1 + (-2)) = 0.
                 It can be proven, that 3 is the minimum number of operations
                 that we need to perform.

    Example 2:
    Input: num1 = 5, num2 = 7
    Output: -1
    Explanation: It can be proven, that it is impossible to make 5 equal to 0
                 with the given operation.

    Constraints:
    * 1 <= num1 <= 10^9
    * -10^9 <= num2 <= 10^9*/

    public int makeTheIntegerZero(int num1, int num2) {
        for (long i = 1; true; ++i) {
            long diff = num1 - i*num2;
            if (diff <= 0) break;
            if (Long.bitCount(diff) <= i && i <= diff) return (int) i;
        }
        return -1;
    }


    /*2750. Ways to Split Array Into Good Subarrays (Medium)
    You are given a binary array nums. A subarray of an array is good if it
    contains exactly one element with the value 1. Return an integer denoting
    the number of ways to split the array nums into good subarrays. As the
    number may be too large, return it modulo 10^9 + 7. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [0,1,0,0,1]
    Output: 3
    Explanation: There are 3 ways to split nums into good subarrays:
                 - [0,1] [0,0,1]
                 - [0,1,0] [0,1]
                 - [0,1,0,0] [1]

    Example 2:
    Input: nums = [0,1,0]
    Output: 1
    Explanation: There is 1 way to split nums into good subarrays:
                 - [0,1,0]

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1*/

    public int numberOfGoodSubarraySplits(int[] nums) {
        long ans = 0;
        int cnt = 0;
        for (var x : nums)
            if (x == 0) ++cnt;
            else {
                if (ans > 0) ans = ans * (cnt+1) % 1_000_000_007;
                else ans = 1;
                cnt = 0;
            }
        return (int) ans;
    }


    /*2751. Robot Collisions (Hard)
    There are n 1-indexed robots, each having a position on a line, health, and
    movement direction. You are given 0-indexed integer arrays positions,
    healths, and a string directions (directions[i] is either 'L' for left or
    'R' for right). All integers in positions are unique. All robots start
    moving on the line simultaneously at the same speed in their given
    directions. If two robots ever share the same position while moving, they
    will collide. If two robots collide, the robot with lower health is removed
    from the line, and the health of the other robot decreases by one. The
    surviving robot continues in the same direction it was going. If both robots
    have the same health, they are both removed from the line. Your task is to
    determine the health of the robots that survive the collisions, in the same
    order that the robots were given, i.e. final heath of robot 1 (if survived),
    final health of robot 2 (if survived), and so on. If there are no survivors,
    return an empty array. Return an array containing the health of the
    remaining robots (in the order they were given in the input), after no
    further collisions can occur. Note: The positions may be unsorted.

    Example 1:
    Input: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = "RRRRR"
    Output: [2,17,9,15,10]
    Explanation: No collision occurs in this example, since all robots are
                 moving in the same direction. So, the health of the robots in
                 order from the first robot is returned, [2, 17, 9, 15, 10].

    Example 2:
    Input: positions = [3,5,2,6], healths = [10,10,15,12], directions = "RLRL"
    Output: [14]
    Explanation: There are 2 collisions in this example. Firstly, robot 1 and
                 robot 2 will collide, and since both have the same health, they
                 will be removed from the line. Next, robot 3 and robot 4 will
                 collide and since robot 4's health is smaller, it gets removed,
                 and robot 3's health becomes 15 - 1 = 14. Only robot 3 remains,
                 so we return [14].

    Example 3:
    Input: positions = [1,2,5,6], healths = [10,10,11,11], directions = "RLRL"
    Output: []
    Explanation: Robot 1 and robot 2 will collide and since both have the same
                 health, they are both removed. Robot 3 and 4 will collide and
                 since both have the same health, they are both removed. So, we
                 return an empty array, [].

    Constraints:
    * 1 <= positions.length == healths.length == directions.length == n <= 10^5
    * 1 <= positions[i], healths[i] <= 10^9
    * directions[i] == 'L' or directions[i] == 'R'
    * All values in positions are distinct*/

    public int[] survivedRobotsHealths(int[] positions, int[] healths, String directions) {
        int n = positions.length;
        int[][] aug = new int[n][4];
        for (int i = 0; i < n; ++i) {
            aug[i][0] = positions[i];
            aug[i][1] = healths[i];
            aug[i][2] = directions.charAt(i) == 'R' ? 1 : 0;
            aug[i][3] = i;
        }
        Arrays.sort(aug, (a, b) -> Integer.compare(a[0], b[0]));
        int[] ans = new int[n];
        Stack<int[]> stk = new Stack();
        for (var e : aug) {
            int p = e[0], h = e[1], d = e[2], i = e[3];
            if (d == 1) stk.push(new int[]{p, h, d, i});
            else {
                while (stk.size() > 0 && h > 0) {
                    var ee = stk.pop();
                    int pp = ee[0], hh = ee[1], dd = ee[2], ii = ee[3];
                    if (hh < h) --h;
                    else {
                        if (hh > h) stk.push(new int[]{pp, --hh, dd, ii});
                        h = 0;
                    }
                }
                ans[i] = h;
            }
        }
        while (stk.size() > 0) {
            var e = stk.pop();
            ans[e[3]] = e[1];
        }
        return Arrays.stream(ans).filter(x -> x != 0).toArray();
    }


    /*2760. Longest Even Odd Subarray With Threshold (Easy)
    You are given a 0-indexed integer array nums and an integer threshold. Find
    the length of the longest subarray of nums starting at index l and ending at
    index r (0 <= l <= r < nums.length) that satisfies the following conditions:
    * nums[l] % 2 == 0
    * For all indices i in the range [l, r - 1], nums[i] % 2 != nums[i + 1] % 2
    * For all indices i in the range [l, r], nums[i] <= threshold
    Return an integer denoting the length of the longest such subarray. Note: A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [3,2,5,4], threshold = 5
    Output: 3
    Explanation: In this example, we can select the subarray that starts at
                 l = 1 and ends at r = 3 => [2,5,4]. This subarray satisfies the
                 conditions. Hence, the answer is the length of the subarray, 3.
                 We can show that 3 is the maximum possible achievable length.

    Example 2:
    Input: nums = [1,2], threshold = 2
    Output: 1
    Explanation: In this example, we can select the subarray that starts at
                 l = 1 and ends at r = 1 => [2]. It satisfies all the conditions
                 and we can show that 1 is the maximum possible achievable
                 length.

    Example 3:
    Input: nums = [2,3,4,5], threshold = 4
    Output: 3
    Explanation: In this example, we can select the subarray that starts at
                 l = 0 and ends at r = 2 => [2,3,4]. It satisfies all the
                 conditions. Hence, the answer is the length of the subarray, 3.
                 We can show that 3 is the maximum possible achievable length.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= threshold <= 100*/

    public int longestAlternatingSubarray(int[] nums, int threshold) {
        int ans = 0, cnt = 0, prev = -1;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] <= threshold) {
                if (prev == nums[i] % 2) cnt = 0;
                if (nums[i] % 2 == 0 || cnt > 0) ++cnt;
            } else cnt = 0;
            ans = Math.max(ans, cnt);
            prev = nums[i] % 2;
        }
        return ans;
    }


    /*2761. Prime Pairs With Target Sum (Medium)
    You are given an integer n. We say that two integers x and y form a prime
    number pair if:
    * 1 <= x <= y <= n
    * x + y == n
    * x and y are prime numbers
    Return the 2D sorted list of prime number pairs [xi, yi]. The list should be
    sorted in increasing order of xi. If there are no prime number pairs at all,
    return an empty array. Note: A prime number is a natural number greater than
    1 with only two factors, itself and 1.

    Example 1:
    Input: n = 10
    Output: [[3,7],[5,5]]
    Explanation: In this example, there are two prime pairs that satisfy the
                 criteria. These pairs are [3,7] and [5,5], and we return them
                 in the sorted order as described in the problem statement.

    Example 2:
    Input: n = 2
    Output: []
    Explanation: We can show that there is no prime number pair that gives a sum
                 of 2, so we return an empty array.

    Constraints: 1 <= n <= 10^6*/

    public List<List<Integer>> findPrimePairs(int n) {
        boolean[] sieve = new boolean[n+1];
        Arrays.fill(sieve, true);
        sieve[0] = sieve[1] = false;
        for (int x = 0; x*x <= n; ++x)
            if (sieve[x])
                for (int xx = x*x; xx <= n; xx += x)
                    sieve[xx] = false;
        List<List<Integer>> ans = new ArrayList<>();
        for (int x = 0; x <= n/2; ++x)
            if (sieve[x] && sieve[n-x])
                ans.add(Arrays.asList(x, n-x));
        return ans;
    }


    /*2762. Continuous Subarrays (Medium)
    You are given a 0-indexed integer array nums. A subarray of nums is called
    continuous if:
    * Let i, i + 1, ..., j be the indices in the subarray. Then, for each pair
      of indices i <= i1, i2 <= j, 0 <= |nums[i1] - nums[i2]| <= 2.
    Return the total number of continuous subarrays. A subarray is a contiguous
    non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [5,4,2,4]
    Output: 8
    Explanation: - Continuous subarray of size 1: [5], [4], [2], [4].
                 - Continuous subarray of size 2: [5,4], [4,2], [2,4].
                 - Continuous subarray of size 3: [4,2,4].
                 - Thereare no subarrys of size 4.
                 Total continuous subarrays = 4 + 3 + 1 = 8. It can be shown
                 that there are no more continuous subarrays.

    Example 2:
    Input: nums = [1,2,3]
    Output: 6
    Explanation: - Continuous subarray of size 1: [1], [2], [3].
                 - Continuous subarray of size 2: [1,2], [2,3].
                 - Continuous subarray of size 3: [1,2,3].
                 - Total continuous subarrays = 3 + 2 + 1 = 6.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public long continuousSubarrays(int[] nums) {
        Map<Integer, Integer> last = new HashMap<>();
        long ans = 0;
        for (int i = 0, ii = 0; i < nums.length; ++i) {
            Map<Integer, Integer> temp = new HashMap<>();
            for (var k : last.keySet())
                if (Math.abs(nums[i]-k) > 2) ii = Math.max(ii, last.get(k)+1);
                else temp.put(k, last.get(k));
            temp.put(nums[i], i);
            last = temp;
            ans += i-ii+1;
        }
        return ans;
    }


    /*2763. Sum of Imbalance Numbers of All Subarrays (Hard)
    The imbalance number of a 0-indexed integer array arr of length n is defined
    as the number of indices in sarr = sorted(arr) such that:
    * 0 <= i < n - 1, and
    * sarr[i+1] - sarr[i] > 1
    Here, sorted(arr) is the function that returns the sorted version of arr.
    Given a 0-indexed integer array nums, return the sum of imbalance numbers of
    all its subarrays. A subarray is a contiguous non-empty sequence of elements
    within an array.

    Example 1:
    Input: nums = [2,3,1,4]
    Output: 3
    Explanation: There are 3 subarrays with non-zero imbalance numbers:
                 - Subarray [3, 1] with an imbalance number of 1.
                 - Subarray [3, 1, 4] with an imbalance number of 1.
                 - Subarray [1, 4] with an imbalance number of 1.
                 The imbalance number of all other subarrays is 0. Hence, the
                 sum of imbalance numbers of all the subarrays of nums is 3.

    Example 2:
    Input: nums = [1,3,3,3,5]
    Output: 8
    Explanation: There are 7 subarrays with non-zero imbalance numbers:
                 - Subarray [1, 3] with an imbalance number of 1.
                 - Subarray [1, 3, 3] with an imbalance number of 1.
                 - Subarray [1, 3, 3, 3] with an imbalance number of 1.
                 - Subarray [1, 3, 3, 3, 5] with an imbalance number of 2.
                 - Subarray [3, 3, 3, 5] with an imbalance number of 1.
                 - Subarray [3, 3, 5] with an imbalance number of 1.
                 - Subarray [3, 5] with an imbalance number of 1.
                 The imbalance number of all other subarrays is 0. Hence, the
                 sum of imbalance numbers of all the subarrays of nums is 8.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= nums.length*/

    public int sumImbalanceNumbers(int[] nums) {
        int ans = 0, n = nums.length;
        int[] left = new int[n], seen = new int[n+2];
        Arrays.fill(seen, -1);
        for (int i = 0; i < n; ++i) {
            left[i] = Math.max(seen[nums[i]+1], seen[nums[i]]);
            seen[nums[i]] = i;
        }
        Arrays.fill(seen, n);
        for (int i = n-1; i >= 0; --i) {
            ans += (i-left[i]) * (seen[nums[i]+1]-i);
            seen[nums[i]] = i;
        }
        return ans - n*(n+1)/2;
    }


    /*2764. Is Array a Preorder of Some Binary Tree (Medium）
    Given a 0-indexed integer 2D array nodes, your task is to determine if the
    given array represents the preorder traversal of some binary tree. For each
    index i, nodes[i] = [id, parentId], where id is the id of the node at the
    index i and parentId is the id of its parent in the tree (if the node has no
    parent, then parentId == -1). Return true if the given array represents the
    preorder traversal of some tree, and false otherwise. Note: the preorder
    traversal of a tree is a recursive way to traverse a tree in which we first
    visit the current node, then we do the preorder traversal for the left child,
    and finally, we do it for the right child.

    Example 1:
    Input: nodes = [[0,-1],[1,0],[2,0],[3,2],[4,2]]
    Output: true
    Explanation: The given nodes make the tree in the picture below. We can show
                 that this is the preorder traversal of the tree, first we visit
                 node 0, then we do the preorder traversal of the right child
                 which is [1], then we do the preorder traversal of the left
                 child which is [2,3,4].

    Example 2:
    Input: nodes = [[0,-1],[1,0],[2,0],[3,1],[4,1]]
    Output: false
    Explanation: The given nodes make the tree in the picture below. For the
                 preorder traversal, first we visit node 0, then we do the
                 preorder traversal of the right child which is [1,3,4], but we
                 can see that in the given order, 2 comes between 1 and 3, so,
                 it's not the preorder traversal of the tree.

    Constraints:
    * 1 <= nodes.length <= 10^5
    * nodes[i].length == 2
    * 0 <= nodes[i][0] <= 10^5
    * -1 <= nodes[i][1] <= 10^5
    * The input is generated such that nodes make a binary tree.*/

    public boolean isPreorder(List<List<Integer>> nodes) {
        Stack<Integer> stk = new Stack();
        stk.push(-1);
        for (var x : nodes) {
            int n = x.get(0), p = x.get(1);
            while (!stk.isEmpty() && stk.peek() != p) stk.pop();
            if (stk.isEmpty()) return false;
            stk.push(n);
        }
        return true;
    }


    /*2769. Find the Maximum Achievable Number (Easy)
    You are given two integers, num and t. An integer x is called achievable if
    it can become equal to num after applying the following operation no more
    than t times:
    * Increase or decrease x by 1, and simultaneously increase or decrease num
      by 1.
    Return the maximum possible achievable number. It can be proven that there
    exists at least one achievable number.

    Example 1:
    Input: num = 4, t = 1
    Output: 6
    Explanation: The maximum achievable number is x = 6; it can become equal to
                 num after performing this operation:
                 * 1- Decrease x by 1, and increase num by 1. Now, x = 5 and
                 num = 5.
                 It can be proven that there is no achievable number larger
                 than 6.

    Example 2:
    Input: num = 3, t = 2
    Output: 7
    Explanation: The maximum achievable number is x = 7; after performing these
                 operations, x will equal num:
                 * 1- Decrease x by 1, and increase num by 1. Now, x = 6 and
                   num = 4.
                 * 2- Decrease x by 1, and increase num by 1. Now, x = 5 and
                   num = 5.
                 It can be proven that there is no achievable number larger
                 than 7.

    Constraints: 1 <= num, t <= 50*/

    public int theMaximumAchievableX(int num, int t) {
        return num + 2*t;
    }


    /*2770. Maximum Number of Jumps to Reach the Last Index (Medium)
    You are given a 0-indexed array nums of n integers and an integer target.
    You are initially positioned at index 0. In one step, you can jump from
    index i to any index j such that:
    * 0 <= i < j < n
    * -target <= nums[j] - nums[i] <= target
    Return the maximum number of jumps you can make to reach index n - 1. If
    there is no way to reach index n - 1, return -1.

    Example 1:
    Input: nums = [1,3,6,4,1,2], target = 2
    Output: 3
    Explanation: To go from index 0 to index n - 1 with the maximum number of
                 jumps, you can perform the following jumping sequence:
                 - Jump from index 0 to index 1.
                 - Jump from index 1 to index 3.
                 - Jump from index 3 to index 5.
                 It can be proven that there is no other jumping sequence that
                 goes from 0 to n - 1 with more than 3 jumps. Hence, the answer
                 is 3.

    Example 2:
    Input: nums = [1,3,6,4,1,2], target = 3
    Output: 5
    Explanation: To go from index 0 to index n - 1 with the maximum number of
                 jumps, you can perform the following jumping sequence:
                 - Jump from index 0 to index 1.
                 - Jump from index 1 to index 2.
                 - Jump from index 2 to index 3.
                 - Jump from index 3 to index 4.
                 - Jump from index 4 to index 5.
                 It can be proven that there is no other jumping sequence that
                 goes from 0 to n - 1 with more than 5 jumps. Hence, the answer
                 is 5.

    Example 3:
    Input: nums = [1,3,6,4,1,2], target = 0
    Output: -1
    Explanation: It can be proven that there is no jumping sequence that goes
                 from 0 to n - 1. Hence, the answer is -1.

    Constraints:
    * 2 <= nums.length == n <= 1000
    * -10^9 <= nums[i] <= 10^9
    * 0 <= target <= 2 * 10^9*/

    public int maximumJumps(int[] nums, int target) {
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, -1);
        dp[n-1] = 0;
        for (int i = n-2; i >= 0; --i)
            for (int j = i+1; j < n; ++j)
                if (dp[j] != -1 && Math.abs(nums[i]-nums[j]) <= target)
                    dp[i] = Math.max(dp[i], 1+dp[j]);
        return dp[0];
    }


    /*2771. Longest Non-decreasing Subarray From Two Arrays (Medium)
    You are given two 0-indexed integer arrays nums1 and nums2 of length n.
    Let's define another 0-indexed integer array, nums3, of length n. For each
    index i in the range [0, n - 1], you can assign either nums1[i] or nums2[i]
    to nums3[i]. Your task is to maximize the length of the longest non-
    decreasing subarray in nums3 by choosing its values optimally. Return an
    integer representing the length of the longest non-decreasing subarray in
    nums3. Note: A subarray is a contiguous non-empty sequence of elements
    within an array.

    Example 1:
    Input: nums1 = [2,3,1], nums2 = [1,2,1]
    Output: 2
    Explanation: One way to construct nums3 is:
                 nums3 = [nums1[0], nums2[1], nums2[2]] => [2,2,1].
                 The subarray starting from index 0 and ending at index 1,
                 [2,2], forms a non-decreasing subarray of length 2. We can
                 show that 2 is the maximum achievable length.

    Example 2:
    Input: nums1 = [1,3,2,1], nums2 = [2,2,3,4]
    Output: 4
    Explanation: One way to construct nums3 is:
                 nums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] => [1,2,3,4].
                 The entire array forms a non-decreasing subarray of length 4,
                 making it the maximum achievable length.

    Example 3:
    Input: nums1 = [1,1], nums2 = [2,2]
    Output: 2
    Explanation: One way to construct nums3 is:
                 nums3 = [nums1[0], nums1[1]] => [1,1].
                 The entire array forms a non-decreasing subarray of length 2,
                 making it the maximum achievable length.

    Constraints:
    * 1 <= nums1.length == nums2.length == n <= 10^5
    * 1 <= nums1[i], nums2[i] <= 10^9*/

    public int maxNonDecreasingLength(int[] nums1, int[] nums2) {
        int ans = 0, dp1 = 1, dp2 = 1;
        for (int i = 0; i < nums1.length; ++i) {
            int dp11 = 1, dp12 = 1, dp21 = 1, dp22 = 1;
            if (i > 0 && nums1[i-1] <= nums1[i]) dp11 += dp1;
            if (i > 0 && nums2[i-1] <= nums1[i]) dp21 += dp2;
            if (i > 0 && nums1[i-1] <= nums2[i]) dp12 += dp1;
            if (i > 0 && nums2[i-1] <= nums2[i]) dp22 += dp2;
            dp1 = Math.max(dp11, dp21);
            dp2 = Math.max(dp12, dp22);
            ans = Math.max(ans, Math.max(dp1, dp2));
        }
        return ans;
    }


    /*2772. Apply Operations to Make All Array Elements Equal to Zero (Medium)
    You are given a 0-indexed integer array nums and a positive integer k. You
    can apply the following operation on the array any number of times:
    * Choose any subarray of size k from the array and decrease all its
      elements by 1.
    Return true if you can make all the array elements equal to 0, or false
    otherwise. A subarray is a contiguous non-empty part of an array.

    Example 1:
    Input: nums = [2,2,3,1,1,0], k = 3
    Output: true
    Explanation: We can do the following operations:
                 - Choose the subarray [2,2,3]. The resulting array will be
                   nums = [1,1,2,1,1,0].
                 - Choose the subarray [2,1,1]. The resulting array will be
                   nums = [1,1,1,0,0,0].
                 - Choose the subarray [1,1,1]. The resulting array will be
                   nums = [0,0,0,0,0,0].

    Example 2:
    Input: nums = [1,3,1,1], k = 2
    Output: false
    Explanation: It is not possible to make all the array elements equal to 0.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6*/

    public boolean checkArray(int[] nums, int k) {
        int prefix = 0;
        for (int i = 0; i < nums.length; ++i) {
            if (prefix > nums[i]) return false;
            int temp = nums[i];
            nums[i] -= prefix;
            prefix = temp;
            if (i >= k-1) prefix -= nums[i-k+1];
        }
        return prefix == 0;
    }


    /*2778. Sum of Squares of Special Elements (Easy)
    You are given a 1-indexed integer array nums of length n. An element nums[i]
    of nums is called special if i divides n, i.e. n % i == 0. Return the sum
    of the squares of all special elements of nums.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 21
    Explanation: There are exactly 3 special elements in nums: nums[1] since 1
                 divides 4, nums[2] since 2 divides 4, and nums[4] since 4
                 divides 4. Hence, the sum of the squares of all special
                 elements of nums is
                 nums[1] * nums[1] + nums[2] * nums[2] + nums[4] * nums[4] =
                 1 * 1 + 2 * 2 + 4 * 4 = 21.

    Example 2:
    Input: nums = [2,7,1,19,18,3]
    Output: 63
    Explanation: There are exactly 4 special elements in nums: nums[1] since 1
                 divides 6, nums[2] since 2 divides 6, nums[3] since 3 divides
                 6, and nums[6] since 6 divides 6. Hence, the sum of the
                 squares of all special elements of nums is
                 nums[1] * nums[1] + nums[2] * nums[2] + nums[3] * nums[3] +
                 nums[6] * nums[6] = 2 * 2 + 7 * 7 + 1 * 1 + 3 * 3 = 63.

    Constraints:
    * 1 <= nums.length == n <= 50
    * 1 <= nums[i] <= 50*/

    public int sumOfSquares(int[] nums) {
        int ans = 0;
        for (int i = 0, n = nums.length; i < n; ++i)
            if (n % (i+1) == 0) ans += nums[i] * nums[i];
        return ans;
    }


    /*2779. Maximum Beauty of an Array After Applying Operation (Medium)
    You are given a 0-indexed array nums and a non-negative integer k. In one
    operation, you can do the following:
    * Choose an index i that hasn't been chosen before from the range
      [0, nums.length - 1].
    * Replace nums[i] with any integer from the range
      [nums[i] - k, nums[i] + k].
    The beauty of the array is the length of the longest subsequence consisting
    of equal elements. Return the maximum possible beauty of the array nums
    after applying the operation any number of times. Note that you can apply
    the operation to each index only once. A subsequence of an array is a new
    array generated from the original array by deleting some elements (possibly
    none) without changing the order of the remaining elements.

    Example 1:
    Input: nums = [4,6,1,2], k = 2
    Output: 3
    Explanation: In this example, we apply the following operations:
                 - Choose index 1, replace it with 4 (from range [4,8]),
                   nums = [4,4,1,2].
                 - Choose index 3, replace it with 4 (from range [0,4]),
                   nums = [4,4,1,4].
                 After the applied operations, the beauty of the array nums is
                 3 (subsequence consisting of indices 0, 1, and 3). It can be
                 proven that 3 is the maximum possible length we can achieve.

    Example 2:
    Input: nums = [1,1,1,1], k = 10
    Output: 4
    Explanation: In this example we don't have to apply any operations. The
                 beauty of the array nums is 4 (whole array).

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i], k <= 10^5*/

    public int maximumBeauty(int[] nums, int k) {
        Arrays.sort(nums);
        int i = 0, ii = 0;
        for (; i < nums.length; ++i)
            if (nums[i] - nums[ii] > 2*k) ++ii;
        return i - ii;
    }


    /*2780. Minimum Index of a Valid Split (Medium)
    An element x of an integer array arr of length m is dominant if
    freq(x) * 2 > m, where freq(x) is the number of occurrences of x in arr.
    Note that this definition implies that arr can have at most one dominant
    element. You are given a 0-indexed integer array nums of length n with one
    dominant element. You can split nums at an index i into two arrays
    nums[0, ..., i] and nums[i + 1, ..., n - 1], but the split is only valid if:
    * 0 <= i < n - 1
    * nums[0, ..., i], and nums[i + 1, ..., n - 1] have the same dominant
      element.
    Here, nums[i, ..., j] denotes the subarray of nums starting at index i and
    ending at index j, both ends being inclusive. Particularly, if j < i then
    nums[i, ..., j] denotes an empty subarray. Return the minimum index of a
    valid split. If no valid split exists, return -1.

    Example 1:
    Input: nums = [1,2,2,2]
    Output: 2
    Explanation: We can split the array at index 2 to obtain arrays [1,2,2] and
                 [2]. In array [1,2,2], element 2 is dominant since it occurs
                 twice in the array and 2 * 2 > 3. In array [2], element 2 is
                 dominant since it occurs once in the array and 1 * 2 > 1. Both
                 [1,2,2] and [2] have the same dominant element as nums, so
                 this is a valid split. It can be shown that index 2 is the
                 minimum index of a valid split.

    Example 2:
    Input: nums = [2,1,3,1,1,1,7,1,2,1]
    Output: 4
    Explanation: We can split the array at index 4 to obtain arrays [2,1,3,1,1]
                 and [1,7,1,2,1]. In array [2,1,3,1,1], element 1 is dominant
                 since it occurs thrice in the array and 3 * 2 > 5. In array
                 [1,7,1,2,1], element 1 is dominant since it occurs thrice in
                 the array and 3 * 2 > 5. Both [2,1,3,1,1] and [1,7,1,2,1] have
                 the same dominant element as nums, so this is a valid split.
                 It can be shown that index 4 is the minimum index of a valid
                 split.

    Example 3:
    Input: nums = [3,3,3,3,7,2,2]
    Output: -1
    Explanation: It can be shown that there is no valid split.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * nums has exactly one dominant element.*/

    public int minimumIndex(List<Integer> nums) {
        Map<Integer, Integer> freq = new HashMap();
        int k = 0, v = 0;
        for (var x : nums) {
            freq.merge(x, 1, Integer::sum);
            if (freq.get(x) > v) {
                k = x;
                v = freq.get(x);
            }
        }
        for (int i = 0, n = nums.size(), prefix = 0; i < n-1; ++i) {
            if (nums.get(i) == k) ++prefix;
            if (prefix*2 > i+1 && (v-prefix)*2 > n-i-1) return i;
        }
        return -1;
    }


    /*2781. Length of the Longest Valid Substring (Hard)
    You are given a string word and an array of strings forbidden. A string is
    called valid if none of its substrings are present in forbidden. Return the
    length of the longest valid substring of the string word. A substring is a
    contiguous sequence of characters in a string, possibly empty.

    Example 1:
    Input: word = "cbaaaabc", forbidden = ["aaa","cb"]
    Output: 4
    Explanation: There are 9 valid substrings in word: "c", "b", "a", "ba",
                 "aa", "bc", "baa", "aab", and "aabc". The length of the
                 longest valid substring is 4. It can be shown that all other
                 substrings contain either "aaa" or "cb" as a substring.

    Example 2:
    Input: word = "leetcode", forbidden = ["de","le","e"]
    Output: 4
    Explanation: There are 11 valid substrings in word: "l", "t", "c", "o",
                 "d", "tc", "co", "od", "tco", "cod", and "tcod". The length of
                 the longest valid substring is 4. It can be shown that all
                 other substrings contain either "de", "le", or "e" as a
                 substring.

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists only of lowercase English letters.
    * 1 <= forbidden.length <= 10^5
    * 1 <= forbidden[i].length <= 10
    * forbidden[i] consists only of lowercase English letters.*/

    public int longestValidSubstring(String word, List<String> forbidden) {
        Set<String> forbid = new HashSet<>(forbidden);
        int ans = 0, val = 0;
        for (int i = word.length()-1; i >= 0; --i) {
            ++val;
            for (int k = 0; k < 10 && k < val; ++k)
                if (forbid.contains(word.substring(i, i+k+1))) {
                    val = k;
                    break;
                }
            ans = Math.max(ans, val);
        }
        return ans;
    }


    /*2782. Number of Unique Categories (Medium)
    You are given an integer n and an object categoryHandler of class
    CategoryHandler. There are n elements, numbered from 0 to n - 1. Each
    element has a category, and your task is to find the number of unique
    categories. The class CategoryHandler contains the following function, which
    may help you:
    * boolean haveSameCategory(integer a, integer b): Returns true if a and b
      are in the same category and false otherwise. Also, if either a or b is
      not a valid number (i.e. it's greater than or equal to nor less than 0),
      it returns false.
    Return the number of unique categories.

    Example 1:
    Input: n = 6, categoryHandler = [1,1,2,2,3,3]
    Output: 3
    Explanation: There are 6 elements in this example. The first two elements
                 belong to category 1, the second two belong to category 2, and
                 the last two elements belong to category 3. So there are 3
                 unique categories.

    Example 2:
    Input: n = 5, categoryHandler = [1,2,3,4,5]
    Output: 5
    Explanation: There are 5 elements in this example. Each element belongs to a
                 unique category. So there are 5 unique categories.

    Example 3:
    Input: n = 3, categoryHandler = [1,1,1]
    Output: 1
    Explanation: There are 3 elements in this example. All of them belong to one
                 category. So there is only 1 unique category.

    Constraints: 1 <= n <= 100*/

    public int numberOfCategories(int n, CategoryHandler categoryHandler) {
        int ans = 0;
        for (int j = 0; j < n; ++j) {
            boolean found = false;
            for (int i = 0; i < j; ++i)
                if (categoryHandler.haveSameCategory(i, j)) {
                    found = true;
                    break;
                }
            if (!found) ++ans;
        }
        return ans;
    }


    /*2784. Check if Array is Good (Easy)
    You are given an integer array nums. We consider an array good if it is a
    permutation of an array base[n]. base[n] = [1, 2, ..., n - 1, n, n] (in
    other words, it is an array of length n + 1 which contains 1 to n - 1
    exactly once, plus two occurrences of n). For example, base[1] = [1, 1] and
    base[3] = [1, 2, 3, 3]. Return true if the given array is good, otherwise
    return false. Note: A permutation of integers represents an arrangement of
    these numbers.

    Example 1:
    Input: nums = [2, 1, 3]
    Output: false
    Explanation: Since the maximum element of the array is 3, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 3. However, base[3] has four elements but
                 array nums has three. Therefore, it can not be a permutation
                 of base[3] = [1, 2, 3, 3]. So the answer is false.

    Example 2:
    Input: nums = [1, 3, 3, 2]
    Output: true
    Explanation: Since the maximum element of the array is 3, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 3. It can be seen that nums is a permutation
                 of base[3] = [1, 2, 3, 3] (by swapping the second and fourth
                 elements in nums, we reach base[3]). Therefore, the answer is
                 true.

    Example 3:
    Input: nums = [1, 1]
    Output: true
    Explanation: Since the maximum element of the array is 1, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 1. It can be seen that nums is a permutation
                 of base[1] = [1, 1]. Therefore, the answer is true.

    Example 4:
    Input: nums = [3, 4, 4, 1, 2, 1]
    Output: false
    Explanation: Since the maximum element of the array is 4, the only
                 candidate n for which this array could be a permutation of
                 base[n], is n = 4. However, base[4] has five elements but
                 array nums has six. Therefore, it can not be a permutation of
                 base[4] = [1, 2, 3, 4, 4]. So the answer is false.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= num[i] <= 200*/

    public boolean isGood(int[] nums) {
        int n = nums.length-1, cnt = 0;
        for (int i = 0; i <= n && cnt <= n; )
            if (nums[i] == i+1 || i == n && nums[n] == n) ++i;
            else {
                if (nums[i] < 0 || nums[i] > n) return false;
                int ii = nums[i]-1;
                if (nums[i] == n && nums[n] != n) ii = n;
                int temp = nums[i];
                nums[i] = nums[ii];
                nums[ii] = temp;
                ++cnt;
            }
        return 0 < n && cnt <= n;
    }


    /*2785. Sort Vowels in a String (Medium)
    Given a 0-indexed string s, permute s to get a new string t such that:
    * All consonants remain in their original places. More formally, if there
      is an index i with 0 <= i < s.length such that s[i] is a consonant, then
      t[i] = s[i].
    * The vowels must be sorted in the nondecreasing order of their ASCII
      values. More formally, for pairs of indices i, j with
      0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must
      not have a higher ASCII value than t[j].
    Return the resulting string. The vowels are 'a', 'e', 'i', 'o', and 'u',
    and they can appear in lowercase or uppercase. Consonants comprise all
    letters that are not vowels.

    Example 1:
    Input: s = "lEetcOde"
    Output: "lEOtcede"
    Explanation: 'E', 'O', and 'e' are the vowels in s; 'l', 't', 'c', and 'd'
                 are all consonants. The vowels are sorted according to their
                 ASCII values, and the consonants remain in the same places.

    Example 2:
    Input: s = "lYmpH"
    Output: "lYmpH"
    Explanation: There are no vowels in s (all characters in s are consonants),
                 so we return "lYmpH".

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of letters of the English alphabet in uppercase and
      lowercase.*/

    public String sortVowels(String s) {
        StringBuilder sb = new StringBuilder();
        for (var ch : s.toCharArray())
            if ("aeiouAEIOU".indexOf(ch) >= 0) sb.append(ch);
        String vowels = sb.chars().sorted().collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();
        StringBuilder ans = new StringBuilder();
        int i = 0;
        for (var ch : s.toCharArray())
            if ("aeiouAEIOU".indexOf(ch) >= 0) ans.append(vowels.charAt(i++));
            else ans.append(ch);
        return ans.toString();
    }


    /*2786. Visit Array Positions to Maximize Score (Medium)
    You are given a 0-indexed integer array nums and a positive integer x. You
    are initially at position 0 in the array and you can visit other positions
    according to the following rules:
    * If you are currently in position i, then you can move to any position j
      such that i < j.
    * For each position i that you visit, you get a score of nums[i].
    * If you move from a position i to a position j and the parities of nums[i]
      and nums[j] differ, then you lose a score of x.
    Return the maximum total score you can get. Note that initially you have
    nums[0] points.

    Example 1:
    Input: nums = [2,3,6,1,9,2], x = 5
    Output: 13
    Explanation: We can visit the following positions in the array: 0 -> 2 ->
                 3 -> 4. The corresponding values are 2, 6, 1 and 9. Since the
                 integers 6 and 1 have different parities, the move 2 -> 3 will
                 make you lose a score of x = 5. The total score will be:
                 2 + 6 + 1 + 9 - 5 = 13.

    Example 2:
    Input: nums = [2,4,6,8], x = 3
    Output: 20
    Explanation: All the integers in the array have the same parities, so we
                 can visit all of them without losing any score. The total
                 score is: 2 + 4 + 6 + 8 = 20.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i], x <= 10^6*/

    public long maxScore(int[] nums, int x) {
        long[] dp = new long[2];
        Arrays.fill(dp, -x);
        for (int i = 0; i < nums.length; ++i)
            if (i > 0) dp[nums[i]&1] = nums[i] + Math.max(dp[nums[i]&1], dp[nums[i]&1^1]-x);
            else dp[nums[i]&1] = nums[i];
        return Arrays.stream(dp).max().getAsLong();
    }


    /*2787. Ways to Express an Integer as Sum of Powers (Medium)
    Given two positive integers n and x. Return the number of ways n can be
    expressed as the sum of the xth power of unique positive integers, in other
    words, the number of sets of unique integers [n1, n2, ..., nk] where
    n = n1^x + n2^x + ... + nk^x. Since the result can be very large, return it
    modulo 10^9 + 7. For example, if n = 160 and x = 3, one way to express n is
    n = 2^3 + 3^3 + 5^3.

    Example 1:
    Input: n = 10, x = 2
    Output: 1
    Explanation: We can express n as the following: n = 32 + 12 = 10. It can be
                 shown that it is the only way to express 10 as the sum of the
                 2nd power of unique integers.

    Example 2:
    Input: n = 4, x = 1
    Output: 2
    Explanation: We can express n in the following ways:
                 - n = 4^1 = 4.
                 - n = 3^1 + 1^1 = 4.

    Constraints:
    * 1 <= n <= 300
    * 1 <= x <= 5*/

    public int numberOfWays(int n, int x) {
        long[] dp = new long[n+1];
        dp[0] = 1;
        for (int k = 1, v = 1; v <= n; v = (int) Math.pow(++k, x))
            for (int i = n; i >= v; --i)
                dp[i] = (dp[i-v] + dp[i]) % 1_000_000_007;
        return (int) dp[n];
    }


    /*2801. Count Stepping Numbers in Range (Hard)
    Given two positive integers low and high represented as strings, find the
    count of stepping numbers in the inclusive range [low, high]. A stepping
    number is an integer such that all of its adjacent digits have an absolute
    difference of exactly 1. Return an integer denoting the count of stepping
    numbers in the inclusive range [low, high]. Since the answer may be very
    large, return it modulo 10^9 + 7. Note: A stepping number should not have a
    leading zero.

    Example 1:
    Input: low = "1", high = "11"
    Output: 10
    Explanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6,
                 7, 8, 9 and 10. There are a total of 10 stepping numbers in the
                 range. Hence, the output is 10.

    Example 2:
    Input: low = "90", high = "101"
    Output: 2
    Explanation: The stepping numbers in the range [90,101] are 98 and 101.
                 There are a total of 2 stepping numbers in the range. Hence,
                 the output is 2.

    Constraints:
    * 1 <= int(low) <= int(high) < 10^100
    * 1 <= low.length, high.length <= 100
    * low and high consist of only digits.
    * low and high don't have any leading zeros.*/

    private long fn(int i, int p, int lead, int profile, int mod, String num, long[][][][] memo) {
        if (i == num.length()) return 1l;
        if (memo[i][p][lead][profile] == -1) {
            long ans = 0;
            if (lead == 1) {
                int hi = profile == 1 ? num.charAt(i)-'0' : 9;
                for (int x = 0; x <= hi; ++x)
                    ans = (ans + fn(i+1, x, lead == 1 && x == 0 ? 1 : 0, profile == 1 && x == hi ? 1 : 0, mod, num, memo)) % mod;
            } else
                for (int x = p-1; x <= p+1; x += 2)
                    if (0 <= x && x <= 9 && (profile == 1 && x <= num.charAt(i)-'0' || profile == 0))
                        ans = (ans + fn(i+1, x, lead == 1 && x == 0 ? 1 : 0, profile == 1 && x == num.charAt(i)-'0' ? 1 : 0, mod, num, memo)) % mod;
            memo[i][p][lead][profile] = ans;
        }
        return memo[i][p][lead][profile];
    }

    public int countSteppingNumbers(String low, String high) {
        final int mod = 1_000_000_007;
        long[][][][] memo = new long[100][10][2][2];
        for (int i = 0; i < 100; ++i)
            for (int j = 0; j < 10; ++j)
                for (int k = 0; k < 2; ++k)
                    Arrays.fill(memo[i][j][k], -1l);
        long lo = fn(0, 0, 1, 1, mod, low, memo);
        for (int i = 0; i < 100; ++i)
            for (int j = 0; j < 10; ++j)
                for (int k = 0; k < 2; ++k)
                    Arrays.fill(memo[i][j][k], -1l);
        long hi = fn(0, 0, 1, 1, mod, high, memo);
        int check = 1;
        for (int i = 1; i < low.length(); ++i)
            if (Math.abs(low.charAt(i-1) - low.charAt(i)) != 1) check = 0;
        return (int) (mod + (hi - lo + check) % mod) % mod;
    }


    /*2802. Find The K-th Lucky Number (Medium）
    We know that 4 and 7 are lucky digits. Also, a number is called lucky if it
    contains only lucky digits. You are given an integer k, return the kth lucky
    number represented as a string.

    Example 1:
    Input: k = 4
    Output: "47"
    Explanation: The first lucky number is 4, the second one is 7, the third one
                 is 44 and the fourth one is 47.

    Example 2:
    Input: k = 10
    Output: "477"
    Explanation: Here are lucky numbers sorted in increasing order:
                 4, 7, 44, 47, 74, 77, 444, 447, 474, 477. So the 10th lucky
                 number is 477.

    Example 3:
    Input: k = 1000
    Output: "777747447"
    Explanation: It can be shown that the 1000th lucky number is 777747447.

    Constraints: 1 <= k <= 10^9*/

    public String kthLuckyNumber(int k) {
        int n = (int) (Math.log(k+1) / Math.log(2));
        k -= (1<<n)-1;
        StringBuilder ans = new StringBuilder();
        for (int i = n-1; i >= 0; --i)
            if ((k & 1<<i) > 0) ans.append('7');
            else ans.append('4');
        return ans.toString();
    }


    /*2806. Account Balance After Rounded Purchase (Easy)
    Initially, you have a bank account balance of 100 dollars. You are given an
    integer purchaseAmount representing the amount you will spend on a purchase
    in dollars. At the store where you will make the purchase, the purchase
    amount is rounded to the nearest multiple of 10. In other words, you pay a
    non-negative amount, roundedAmount, such that roundedAmount is a multiple
    of 10 and abs(roundedAmount - purchaseAmount) is minimized. If there is
    more than one nearest multiple of 10, the largest multiple is chosen.
    Return an integer denoting your account balance after making a purchase
    worth purchaseAmount dollars from the store. Note: 0 is considered to be a
    multiple of 10 in this problem.

    Example 1:
    Input: purchaseAmount = 9
    Output: 90
    Explanation: In this example, the nearest multiple of 10 to 9 is 10. Hence,
                 your account balance becomes 100 - 10 = 90.

    Example 2:
    Input: purchaseAmount = 15
    Output: 80
    Explanation: In this example, there are two nearest multiples of 10 to 15:
                 10 and 20. So, the larger multiple, 20, is chosen. Hence,
                 your account balance becomes 100 - 20 = 80.

    Constraints: 0 <= purchaseAmount <= 100*/

    public int accountBalanceAfterPurchase(int purchaseAmount) {
        return 100 - (purchaseAmount+5)/10*10;
    }


    /*2807. Insert Greatest Common Divisors in Linked List (Medium)
    Given the head of a linked list head, in which each node contains an
    integer value. Between every pair of adjacent nodes, insert a new node with
    a value equal to the greatest common divisor of them. Return the linked
    list after insertion. The greatest common divisor of two numbers is the
    largest positive integer that evenly divides both numbers.

    Example 1:
    Input: head = [18,6,10,3]
    Output: [18,6,6,2,10,1,3]
    Explanation: The 1st diagram denotes the initial linked list and the 2nd
                 diagram denotes the linked list after inserting the new nodes
                 (nodes in blue are the inserted nodes).
                 - We insert the greatest common divisor of 18 and 6 = 6
                   between the 1st and the 2nd nodes.
                 - We insert the greatest common divisor of 6 and 10 = 2
                   between the 2nd and the 3rd nodes.
                 - We insert the greatest common divisor of 10 and 3 = 1
                   between the 3rd and the 4th nodes.
                 There are no more adjacent nodes, so we return the linked list.

    Example 2:
    Input: head = [7]
    Output: [7]
    Explanation: The 1st diagram denotes the initial linked list and the 2nd
                 diagram denotes the linked list after inserting the new nodes.
                 There are no pairs of adjacent nodes, so we return the initial
                 linked list.

    Constraints:
    * The number of nodes in the list is in the range [1, 5000].
    * 1 <= Node.val <= 1000*/

    public ListNode insertGreatestCommonDivisors(ListNode head) {
        ListNode node = head;
        while (node != null && node.next != null) {
            ListNode temp = new ListNode(BigInteger.valueOf(node.val).gcd(BigInteger.valueOf(node.next.val)).intValue(), node.next);
            node.next = temp;
            node = node.next.next;
        }
        return head;
    }


    /*2808. Minimum Seconds to Equalize a Circular Array (Medium)
    You are given a 0-indexed array nums containing n integers. At each second,
    you perform the following operation on the array:
    * For every index i in the range [0, n - 1], replace nums[i] with either
      nums[i], nums[(i - 1 + n) % n], or nums[(i + 1) % n].
    Note that all the elements get replaced simultaneously. Return the minimum
    number of seconds needed to make all elements in the array nums equal.

    Example 1:
    Input: nums = [1,2,1,2]
    Output: 1
    Explanation: We can equalize the array in 1 second in the following way:
                 - At 1st second, replace values at each index with
                   [nums[3],nums[1],nums[3],nums[3]]. After replacement,
                   nums = [2,2,2,2].
                 It can be proven that 1 second is the minimum amount of
                 seconds needed for equalizing the array.

    Example 2:
    Input: nums = [2,1,3,3,2]
    Output: 2
    Explanation: We can equalize the array in 2 seconds in the following way:
                 - At 1st second, replace values at each index with
                   [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement,
                   nums = [2,3,3,3,3].
                 - At 2nd second, replace values at each index with
                   [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement,
                   nums = [3,3,3,3,3].
                 It can be proven that 2 seconds is the minimum amount of
                 seconds needed for equalizing the array.

    Example 3:
    Input: nums = [5,5,5,5]
    Output: 0
    Explanation: We don't need to perform any operations as all elements in the
                 initial array are the same.

    Constraints:
    * 1 <= n == nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public int minimumSeconds(List<Integer> nums) {
        int ans = Integer.MAX_VALUE, n = nums.size();
        Map<Integer, List<Integer>> pos = new HashMap();
        for (int i = 0; i < n; ++i) {
            pos.putIfAbsent(nums.get(i), new ArrayList());
            pos.get(nums.get(i)).add(i);
        }
        for (var elem : pos.entrySet()) {
            int k = elem.getKey(), cand = 0, prev = -1;
            List<Integer> v = elem.getValue();
            for (var x : v) {
                if (prev >= 0) cand = Math.max(cand, x - prev);
                prev = x;
            }
            cand = Math.max(cand, v.get(0) + n - v.get(v.size()-1));
            ans = Math.min(ans, cand);
        }
        return ans/2;
    }


    /*2809. Minimum Time to Make Array Sum At Most x (Hard)
    You are given two 0-indexed integer arrays nums1 and nums2 of equal length.
    Every second, for all indices 0 <= i < nums1.length, value of nums1[i] is
    incremented by nums2[i]. After this is done, you can do the following
    operation:
    * Choose an index 0 <= i < nums1.length and make nums1[i] = 0.
    You are also given an integer x. Return the minimum time in which you can
    make the sum of all elements of nums1 to be less than or equal to x, or -1
    if this is not possible.

    Example 1:
    Input: nums1 = [1,2,3], nums2 = [1,2,3], x = 4
    Output: 3
    Explanation: For the 1st second, we apply the operation on i = 0. Therefore
                 nums1 = [0,2+2,3+3] = [0,4,6].
                 For the 2nd second, we apply the operation on i = 1. Therefore
                 nums1 = [0+1,0,6+3] = [1,0,9].
                 For the 3rd second, we apply the operation on i = 2. Therefore
                 nums1 = [1+1,0+2,0] = [2,2,0].
                 Now sum of nums1 = 4. It can be shown that these operations
                 are optimal, so we return 3.

    Example 2:
    Input: nums1 = [1,2,3], nums2 = [3,3,3], x = 4
    Output: -1
    Explanation: It can be shown that the sum of nums1 will always be greater
                 than x, no matter which operations are performed.

    Constraints:
    * 1 <= nums1.length <= 10^3
    * 1 <= nums1[i] <= 10^3
    * 0 <= nums2[i] <= 10^3
    * nums1.length == nums2.length
    * 0 <= x <= 10^6*/

    public int minimumTime(List<Integer> nums1, List<Integer> nums2, int x) {
        int n = nums1.size(), s1 = nums1.stream().mapToInt(i -> i).sum(), s2 = nums2.stream().mapToInt(i -> i).sum();
        List<int[]> aug = new ArrayList();
        for (int i = 0; i < n; ++i)
            aug.add(new int[]{nums1.get(i), nums2.get(i)});
        Collections.sort(aug, (a, b) -> Integer.compare(a[1], b[1]));
        int[][] dp = new int[n+1][n+1];
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] + aug.get(i-1)[1]*j + aug.get(i-1)[0]);
        for (int t = 0; t <= n; ++t)
            if (s1 + s2*t - dp[n][t] <= x) return t;
        return -1;
    }


    /*2810. Faulty Keyboard (Easy)
    Your laptop keyboard is faulty, and whenever you type a character 'i' on it,
    it reverses the string that you have written. Typing other characters works
    as expected. You are given a 0-indexed string s, and you type each
    character of s using your faulty keyboard. Return the final string that
    will be present on your laptop screen.

    Example 1:
    Input: s = "string"
    Output: "rtsng"
    Explanation: - After typing first character, the text on the screen is "s".
                 - After the second character, the text is "st".
                 - After the third character, the text is "str".
                 - Since the fourth character is an 'i', the text gets reversed
                 - and becomes "rts".
                 - After the fifth character, the text is "rtsn".
                 - After the sixth character, the text is "rtsng".
                 - Therefore, we return "rtsng".

    Example 2:
    Input: s = "poiinter"
    Output: "ponter"
    Explanation: - After the first character, the text on the screen is "p".
                 - After the second character, the text is "po".
                 - Since the third character you type is an 'i', the text gets
                   reversed and becomes "op".
                 - Since the fourth character you type is an 'i', the text gets
                   reversed and becomes "po".
                 - After the fifth character, the text is "pon".
                 - After the sixth character, the text is "pont".
                 - After the seventh character, the text is "ponte".
                 - After the eighth character, the text is "ponter".
                 - Therefore, we return "ponter".

    Constraints:
    * 1 <= s.length <= 100
    * s consists of lowercase English letters.
    * s[0] != 'i'*/

    public String finalString(String s) {
        Deque<Character> qq = new ArrayDeque();
        boolean flip = false;
        for (var ch : s.toCharArray()) {
            if (ch == 'i') flip = !flip;
            else if (!flip) qq.addLast(ch);
            else qq.addFirst(ch);
        }
        StringBuilder sb = new StringBuilder();
        Iterator<Character> it = qq.iterator();
        if (flip) it = qq.descendingIterator();
        while (it.hasNext())
            sb.append(it.next());
        return sb.toString();
    }


    /*2811. Check if it is Possible to Split Array (Medium)
    You are given an array nums of length n and an integer m. You need to
    determine if it is possible to split the array into n non-empty arrays by
    performing a series of steps. In each step, you can select an existing
    array (which may be the result of previous steps) with a length of at least
    two and split it into two subarrays, if, for each resulting subarray, at
    least one of the following holds:
    * The length of the subarray is one, or
    * The sum of elements of the subarray is greater than or equal to m.
    Return true if you can split the given array into n arrays, otherwise
    return false. Note: A subarray is a contiguous non-empty sequence of
    elements within an array.

    Example 1:
    Input: nums = [2, 2, 1], m = 4
    Output: true
    Explanation: We can split the array into [2, 2] and [1] in the first step.
                 Then, in the second step, we can split [2, 2] into [2] and [2].
                 As a result, the answer is true.

    Example 2:
    Input: nums = [2, 1, 3], m = 5
    Output: false
    Explanation: We can try splitting the array in two different ways: the
                 first way is to have [2, 1] and [3], and the second way is to
                 have [2] and [1, 3]. However, both of these ways are not valid.
                 So, the answer is false.

    Example 3:
    Input: nums = [2, 3, 3, 2, 3], m = 6
    Output: true
    Explanation: We can split the array into [2, 3, 3, 2] and [3] in the first
                 step. Then, in the second step, we can split [2, 3, 3, 2] into
                 [2, 3, 3] and [2]. Then, in the third step, we can split
                 [2, 3, 3] into [2] and [3, 3]. And in the last step we can
                 split [3, 3] into [3] and [3]. As a result, the answer is true.

    Constraints:
    * 1 <= n == nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= m <= 200*/

    public boolean canSplitArray(List<Integer> nums, int m) {
        if (nums.size() <= 2) return true;
        for (int i = 0; i < nums.size()-1; ++i)
            if (nums.get(i) + nums.get(i+1) >= m) return true;
        return false;
    }


    /*2812. Find the Safest Path in a Grid (Medium)
    You are given a 0-indexed 2D matrix grid of size n x n, where (r, c)
    represents:
    * A cell containing a thief if grid[r][c] = 1
    * An empty cell if grid[r][c] = 0
    You are initially positioned at cell (0, 0). In one move, you can move to
    any adjacent cell in the grid, including cells containing thieves. The
    safeness factor of a path on the grid is defined as the minimum manhattan
    distance from any cell in the path to any thief in the grid. Return the
    maximum safeness factor of all paths leading to cell (n - 1, n - 1). An
    adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1),
    (r + 1, c) and (r - 1, c) if it exists. The Manhattan distance between two
    cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes
    the absolute value of val.

    Example 1:
    Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
    Output: 0
    Explanation: All paths from (0, 0) to (n - 1, n - 1) go through the thieves
                 in cells (0, 0) and (n - 1, n - 1).

    Example 2:
    Input: grid = [[0,0,1],[0,0,0],[0,0,0]]
    Output: 2
    Explanation: The path depicted in the picture above has a safeness factor
                 of 2 since:
                 - The closest cell of the path to the thief at cell (0, 2) is
                   cell (0, 0). The distance between them is
                   | 0 - 0 | + | 0 - 2 | = 2.
                 It can be shown that there are no other paths with a higher
                 safeness factor.

    Example 3:
    Input: grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
    Output: 2
    Explanation: The path depicted in the picture above has a safeness factor
                 of 2 since:
                 - The closest cell of the path to the thief at cell (0, 3) is
                   cell (1, 2). The distance between them is
                   | 0 - 1 | + | 3 - 2 | = 2.
                 - The closest cell of the path to the thief at cell (3, 0) is
                   cell (3, 2). The distance between them is
                   | 3 - 3 | + | 0 - 2 | = 2.
                 It can be shown that there are no other paths with a higher
                 safeness factor.

    Constraints:
    * 1 <= grid.length == n <= 400
    * grid[i].length == n
    * grid[i][j] is either 0 or 1.
    * There is at least one thief in the grid.*/

    private boolean check(int mid, int[][] dist, int n) {
        if (dist[0][0] >= mid) {
            int[] dir = {-1, 0, 1, 0, -1};
            boolean[][] seen = new boolean[n][n]; seen[0][0] = true;
            Stack<int[]> stk = new Stack(); stk.push(new int[]{0, 0});
            while (!stk.isEmpty()) {
                var elem = stk.pop();
                int i = elem[0], j = elem[1];
                if (i == n-1 && j == n-1) return true;
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < n && 0 <= jj && jj < n && !seen[ii][jj] && dist[ii][jj] >= mid) {
                        seen[ii][jj] = true;
                        stk.push(new int[]{ii, jj});
                    }
                }
            }
        }
        return false;
    }

    public int maximumSafenessFactor(List<List<Integer>> grid) {
        int n = grid.size();
        int[] dir = {-1, 0, 1, 0, -1};
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; ++i) Arrays.fill(dist[i], -1);
        Queue<int[]> q = new LinkedList();
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (grid.get(i).get(j) == 1) {
                    dist[i][j] = 0;
                    q.add(new int[]{i, j});
                }
        for (int v = 1; !q.isEmpty(); ++v) {
            for (int sz = q.size(); sz > 0; --sz) {
                var elem = q.poll();
                int i = elem[0], j = elem[1];
                for (int k = 0; k < 4; ++k) {
                    int ii = i + dir[k], jj = j + dir[k+1];
                    if (0 <= ii && ii < n && 0 <= jj && jj < n && dist[ii][jj] == -1) {
                        dist[ii][jj] = v;
                        q.add(new int[]{ii, jj});
                    }
                }
            }
        }
        int lo = 0, hi = n;
        while (lo < hi) {
            int mid = lo + (hi - lo + 1)/2;
            if (check(mid, dist, n)) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*2813. Maximum Elegance of a K-Length Subsequence (Hard)
    You are given a 0-indexed 2D integer array items of length n and an integer
    k. items[i] = [profiti, categoryi], where profiti and categoryi denote the
    profit and category of the ith item respectively. Let's define the elegance
    of a subsequence of items as total_profit + distinct_categories2, where
    total_profit is the sum of all profits in the subsequence, and
    distinct_categories is the number of distinct categories from all the
    categories in the selected subsequence. Your task is to find the maximum
    elegance from all subsequences of size k in items. Return an integer
    denoting the maximum elegance of a subsequence of items with size exactly k.
    Note: A subsequence of an array is a new array generated from the original
    array by deleting some elements (possibly none) without changing the
    remaining elements' relative order.

    Example 1:
    Input: items = [[3,2],[5,1],[10,1]], k = 2
    Output: 17
    Explanation: In this example, we have to select a subsequence of size 2. We
                 can select items[0] = [3,2] and items[2] = [10,1]. The total
                 profit in this subsequence is 3 + 10 = 13, and the subsequence
                 contains 2 distinct categories [2,1]. Hence, the elegance is
                 13 + 22 = 17, and we can show that it is the maximum
                 achievable elegance.

    Example 2:
    Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3
    Output: 19
    Explanation: In this example, we have to select a subsequence of size 3. We
                 can select items[0] = [3,1], items[2] = [2,2], and
                 items[3] = [5,3]. The total profit in this subsequence is
                 3 + 2 + 5 = 10, and the subsequence contains 3 distinct
                 categories [1,2,3]. Hence, the elegance is 10 + 32 = 19, and
                 we can show that it is the maximum achievable elegance.

    Example 3:
    Input: items = [[1,1],[2,1],[3,1]], k = 3
    Output: 7
    Explanation: In this example, we have to select a subsequence of size 3. We
                 should select all the items. The total profit will be
                 1 + 2 + 3 = 6, and the subsequence contains 1 distinct
                 category [1]. Hence, the maximum elegance is 6 + 12 = 7.

    Constraints:
    * 1 <= items.length == n <= 10^5
    * items[i].length == 2
    * items[i][0] == profiti
    * items[i][1] == categoryi
    * 1 <= profiti <= 10^9
    * 1 <= categoryi <= n
    * 1 <= k <= n*/

    public long findMaximumElegance(int[][] items, int k) {
        Arrays.sort(items, (a, b) -> Integer.compare(b[0], a[0]));
        long ans = 0, cand = 0;
        Set<Integer> seen = new HashSet();
        Stack<Integer> stk = new Stack();
        for (int i = 0; i < items.length; ++i) {
            int p = items[i][0], c = items[i][1];
            if (i <= k-1 || !seen.contains(c) && !stk.isEmpty()) {
                cand += p;
                if (i >= k) cand -= stk.pop();
                if (seen.contains(c)) stk.push(p);
                seen.add(c);
            }
            ans = Math.max(ans, cand + (long) Math.pow(seen.size(), 2));
        }
        return ans;
    }


    /*2815. Max Pair Sum in an Array (Easy)
    You are given a 0-indexed integer array nums. You have to find the maximum
    sum of a pair of numbers from nums such that the maximum digit in both
    numbers are equal. Return the maximum sum or -1 if no such pair exists.

    Example 1:
    Input: nums = [51,71,17,24,42]
    Output: 88
    Explanation: For i = 1 and j = 2, nums[i] and nums[j] have equal maximum
                 digits with a pair sum of 71 + 17 = 88. For i = 3 and j = 4,
                 nums[i] and nums[j] have equal maximum digits with a pair sum
                 of 24 + 42 = 66. It can be shown that there are no other pairs
                 with equal maximum digits, so the answer is 88.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: -1
    Explanation: No pair exists in nums with equal maximum digits.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 10^4*/

    public int maxSum(int[] nums) {
        int ans = -1;
        int[] seen = new int[10];
        for (var v : nums) {
            int d = 0;
            for (int x = v; x > 0; d = Math.max(d, x % 10), x /= 10);
            if (seen[d] > 0) ans = Math.max(ans, seen[d] + v);
            seen[d] = Math.max(seen[d], v);
        }
        return ans;
    }


    /*2816. Double a Number Represented as a Linked List (Medium)
    You are given the head of a non-empty linked list representing a non-
    negative integer without leading zeroes. Return the head of the linked list
    after doubling it.

    Example 1:
    Input: head = [1,8,9]
    Output: [3,7,8]
    Explanation: The figure above corresponds to the given linked list which
                 represents the number 189. Hence, the returned linked list
                 represents the number 189 * 2 = 378.

    Example 2:
    Input: head = [9,9,9]
    Output: [1,9,9,8]
    Explanation: The figure above corresponds to the given linked list which
                 represents the number 999. Hence, the returned linked list
                 reprersents the number 999 * 2 = 1998.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^4]
    * 0 <= Node.val <= 9
    * The input is generated such that the list represents a number that does
      not have leading zeros, except the number 0 itself.*/

    public ListNode doubleIt(ListNode head) {
        if (head.val >= 5) head = new ListNode(0, head);
        for (ListNode node = head; node != null; node = node.next) {
            node.val = 2*node.val % 10;
            if (node.next != null && node.next.val >= 5) ++node.val;
        }
        return head;
    }


    /*2817. Minimum Absolute Difference Between Elements With Constraint (Medium)
    You are given a 0-indexed integer array nums and an integer x. Find the
    minimum absolute difference between two elements in the array that are at
    least x indices apart. In other words, find two indices i and j such that
    abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized. Return an integer
    denoting the minimum absolute difference between two elements that are at
    least x indices apart.

    Example 1:
    Input: nums = [4,3,2,4], x = 2
    Output: 0
    Explanation: We can select nums[0] = 4 and nums[3] = 4. They are at least 2
                 indices apart, and their absolute difference is the minimum, 0.
                 It can be shown that 0 is the optimal answer.

    Example 2:
    Input: nums = [5,3,2,10,15], x = 1
    Output: 1
    Explanation: We can select nums[1] = 3 and nums[2] = 2. They are at least 1
                 index apart, and their absolute difference is the minimum, 1.
                 It can be shown that 1 is the optimal answer.

    Example 3:
    Input: nums = [1,2,3,4], x = 3
    Output: 3
    Explanation: We can select nums[0] = 1 and nums[3] = 4. They are at least 3
                 indices apart, and their absolute difference is the minimum, 3.
                 It can be shown that 3 is the optimal answer.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 0 <= x < nums.length*/

    public int minAbsoluteDifference(List<Integer> nums, int x) {
        TreeSet<Integer> vals = new TreeSet();
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < nums.size(); ++i) {
            if (i >= x) {
                vals.add(nums.get(i-x));
                Integer lo = vals.floor(nums.get(i));
                if (lo != null) ans = Math.min(ans, nums.get(i) - lo);
                Integer hi = vals.ceiling(nums.get(i));
                if (hi != null) ans = Math.min(ans, hi - nums.get(i));
            }
        }
        return ans;
    }


    /*2818. Apply Operations to Maximize Score (Hard)
    You are given an array nums of n positive integers and an integer k.
    Initially, you start with a score of 1. You have to maximize your score by
    applying the following operation at most k times:
    * Choose any non-empty subarray nums[l, ..., r] that you haven't chosen
      previously.
    * Choose an element x of nums[l, ..., r] with the highest prime score. If
      multiple such elements exist, choose the one with the smallest index.
    * Multiply your score by x.
    Here, nums[l, ..., r] denotes the subarray of nums starting at index l and
    ending at the index r, both ends being inclusive. The prime score of an
    integer x is equal to the number of distinct prime factors of x. For
    example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5. Return
    the maximum possible score after applying at most k operations. Since the
    answer may be large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [8,3,9,3,8], k = 2
    Output: 81
    Explanation: To get a score of 81, we can apply the following operations:
                 - Choose subarray nums[2, ..., 2]. nums[2] is the only element
                   in this subarray. Hence, we multiply the score by nums[2].
                   The score becomes 1 * 9 = 9.
                 - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3]
                   have a prime score of 1, but nums[2] has the smaller index.
                   Hence, we multiply the score by nums[2]. The score becomes
                   9 * 9 = 81.
                 It can be proven that 81 is the highest score one can obtain.

    Example 2:
    Input: nums = [19,12,14,6,10,18], k = 3
    Output: 4788
    Explanation: To get a score of 4788, we can apply the following operations:
                 - Choose subarray nums[0, ..., 0]. nums[0] is the only element
                   in this subarray. Hence, we multiply the score by nums[0].
                   The score becomes 1 * 19 = 19.
                 - Choose subarray nums[5, ..., 5]. nums[5] is the only element
                   in this subarray. Hence, we multiply the score by nums[5].
                   The score becomes 19 * 18 = 342.
                 - Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3]
                   have a prime score of 2, but nums[2] has the smaller index.
                   Hence, we multipy the score by nums[2]. The score becomes
                   342 * 14 = 4788.
                 It can be proven that 4788 is the highest score one can obtain.

    Constraints:
    * 1 <= nums.length == n <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= min(n * (n + 1) / 2, 10^9)*/

    private int powmod(long x, int p, int m) {
        long ans = 1;
        for (; p > 0; p >>= 1) {
            if ((p & 1) == 1) ans = ans * x % m;
            x = x * x % m;
        }
        return (int) ans;
    }

    public int maximumScore(List<Integer> nums, int k) {
        final int MOD = 1_000_000_007;
        int n = nums.size();
        int[][] vals = new int[n][2];
        for (int i = 0; i < n; ++i) {
            int x = nums.get(i), s = 0;
            for (int p = 2, sx = (int) Math.sqrt(x); p <= sx; ++p) {
                if (x % p == 0) ++s;
                for (; x % p == 0; x /= p);
            }
            if (x > 1) ++s;
            vals[i] = new int[]{i, s};
        }
        Arrays.sort(vals, (a, b) -> (a[1] != b[1] ? Integer.compare(b[1], a[1]) : Integer.compare(a[0], b[0])));
        TreeSet<Integer> indices = new TreeSet();
        indices.add(-1);
        indices.add(nums.size());
        Map<Integer, Integer> freq = new HashMap();
        for (var elem : vals) {
            int i = elem[0], lo = indices.floor(i), hi = indices.ceiling(i);
            int left = i - lo, right = hi - i;
            freq.merge(nums.get(i), left * right, Integer::sum);
            indices.add(i);
        }
        long ans = 1;
        int prefix = 0;
        List<int[]> aug = new ArrayList();
        for (var elem : freq.entrySet()) {
            int x = elem.getKey(), v = elem.getValue();
            aug.add(new int[]{x, v});
        }
        Collections.sort(aug, (a, b) -> Integer.compare(b[0], a[0]));
        for (var elem : aug) {
            int x = elem[0], v = elem[1];
            if (prefix < k) {
                ans = ans * powmod(x, Math.min(k - prefix, v), MOD) % MOD;
                prefix += v;
            }
        }
        return (int) ans;
    }


    /*2824. Count Pairs Whose Sum is Less than Target (Easy)
    Given a 0-indexed integer array nums of length n and an integer target,
    return the number of pairs (i, j) where 0 <= i < j < n and
    nums[i] + nums[j] < target.

    Example 1:
    Input: nums = [-1,1,2,3,1], target = 2
    Output: 3
    Explanation: There are 3 pairs of indices that satisfy the conditions in the
                 statement:
                 - (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target
                 - (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target
                 - (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target
                 Note that (0, 3) is not counted since nums[0] + nums[3] is not
                 strictly less than the target.

    Example 2:
    Input: nums = [-6,2,5,-2,-7,-1,3], target = -2
    Output: 10
    Explanation: There are 10 pairs of indices that satisfy the conditions in
                 the statement:
                 - (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target
                 - (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target
                 - (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target
                 - (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target
                 - (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target
                 - (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target
                 - (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target
                 - (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target
                 - (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target
                 - (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target

    Constraints:
    * 1 <= nums.length == n <= 50
    * -50 <= nums[i], target <= 50*/

    public int countPairs(List<Integer> nums, int target) {
        Collections.sort(nums);
        int ans = 0;
        for (int lo = 0, hi = nums.size()-1; lo < hi; )
            if (nums.get(lo) + nums.get(hi) < target) {
                ans += hi - lo;
                ++lo;
            } else --hi;
        return ans;
    }


    /*2828. Check if a String Is an Acronym of Words (Easy)
    Given an array of strings words and a string s, determine if s is an acronym
    of words. The string s is considered an acronym of words if it can be formed
    by concatenating the first character of each string in words in order. For
    example, "ab" can be formed from ["apple", "banana"], but it can't be formed
    from ["bear", "aardvark"]. Return true if s is an acronym of words, and
    false otherwise.

    Example 1:
    Input: words = ["alice","bob","charlie"], s = "abc"
    Output: true
    Explanation: The first character in the words "alice", "bob", and "charlie"
                 are 'a', 'b', and 'c', respectively. Hence, s = "abc" is the
                 acronym.

    Example 2:
    Input: words = ["an","apple"], s = "a"
    Output: false
    Explanation: The first character in the words "an" and "apple" are 'a' and
                 'a', respectively. The acronym formed by concatenating these
                 characters is "aa". Hence, s = "a" is not the acronym.

    Example 3:
    Input: words = ["never","gonna","give","up","on","you"], s = "ngguoy"
    Output: true
    Explanation: By concatenating the first character of the words in the array,
                 we get the string "ngguoy". Hence, s = "ngguoy" is the acronym.

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 10
    * 1 <= s.length <= 100
    * words[i] and s consist of lowercase English letters.*/

    public boolean isAcronym(List<String> words, String s) {
        return words.size() == s.length() && IntStream.range(0, words.size()).allMatch((i) -> words.get(i).charAt(0) == s.charAt(i));
    }


    /*2829. Determine the Minimum Sum of a k-avoiding Array (Medium)
    You are given two integers, n and k. An array of distinct positive integers
    is called a k-avoiding array if there does not exist any pair of distinct
    elements that sum to k. Return the minimum possible sum of a k-avoiding
    array of length n.

    Example 1:
    Input: n = 5, k = 4
    Output: 18
    Explanation: Consider the k-avoiding array [1,2,4,5,6], which has a sum of
                 18. It can be proven that there is no k-avoiding array with a
                 sum less than 18.

    Example 2:
    Input: n = 2, k = 6
    Output: 3
    Explanation: We can construct the array [1,2], which has a sum of 3. It can
                 be proven that there is no k-avoiding array with a sum less
                 than 3.

    Constraints: 1 <= n, k <= 50*/

    public int minimumSum(int n, int k) {
        if (n <= k/2) return n*(n+1)/2;
        return (int) Math.pow(k/2, 2) - k/2*(n+k-1) + n*(n+2*k-1)/2;
    }


    /*2830. Maximize the Profit as the Salesman (Medium)
    You are given an integer n representing the number of houses on a number
    line, numbered from 0 to n - 1. Additionally, you are given a 2D integer
    array offers where offers[i] = [starti, endi, goldi], indicating that ith
    buyer wants to buy all the houses from starti to endi for goldi amount of
    gold. As a salesman, your goal is to maximize your earnings by strategically
    selecting and selling houses to buyers. Return the maximum amount of gold
    you can earn. Note that different buyers can't buy the same house, and some
    houses may remain unsold.

    Example 1:
    Input: n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]
    Output: 3
    Explanation: There are 5 houses numbered from 0 to 4 and there are 3
                 purchase offers. We sell houses in the range [0,0] to 1st buyer
                 for 1 gold and houses in the range [1,3] to 3rd buyer for 2
                 golds. It can be proven that 3 is the maximum amount of gold we
                 can achieve.

    Example 2:
    Input: n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]
    Output: 10
    Explanation: There are 5 houses numbered from 0 to 4 and there are 3
                 purchase offers. We sell houses in the range [0,2] to 2nd buyer
                 for 10 golds. It can be proven that 10 is the maximum amount of
                 gold we can achieve.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= offers.length <= 10^5
    * offers[i].length == 3
    * 0 <= starti <= endi <= n - 1
    * 1 <= goldi <= 10^3*/

    public int maximizeTheProfit(int n, List<List<Integer>> offers) {
        List<int[]>[] mp = new List[n];
        for (int i = 0; i < n; ++i)
            mp[i] = new ArrayList<>();
        for (var offer : offers) {
            int start = offer.get(0), end = offer.get(1), gold = offer.get(2);
            mp[start].add(new int[]{end, gold});
        }
        int[] dp = new int[n+1];
        for (int i = n-1; i >= 0; --i) {
            dp[i] = dp[i+1];
            for (var elem : mp[i]) {
                int j = elem[0], x = elem[1];
                dp[i] = Math.max(dp[i], x + dp[j+1]);
            }
        }
        return dp[0];
    }


    /*2831. Find the Longest Equal Subarray (Medium)
    You are given a 0-indexed integer array nums and an integer k. A subarray is
    called equal if all of its elements are equal. Note that the empty subarray
    is an equal subarray. Return the length of the longest possible equal
    subarray after deleting at most k elements from nums. A subarray is a
    contiguous, possibly empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,3,2,3,1,3], k = 3
    Output: 3
    Explanation: It's optimal to delete the elements at index 2 and index 4.
                 After deleting them, nums becomes equal to [1, 3, 3, 3]. The
                 longest equal subarray starts at i = 1 and ends at j = 3 with
                 length equal to 3. It can be proven that no longer equal
                 subarrays can be created.

    Example 2:
    Input: nums = [1,1,2,2,1,1], k = 2
    Output: 4
    Explanation: It's optimal to delete the elements at index 2 and index 3.
                 After deleting them, nums becomes equal to [1, 1, 1, 1]. The
                 array itself is an equal subarray, so the answer is 4. It can
                 be proven that no longer equal subarrays can be created.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= nums.length
    * 0 <= k <= nums.length*/

    public int longestEqualSubarray(List<Integer> nums, int k) {
        int most = 0;
        Map<Integer, Integer> freq = new HashMap();
        for (int i = 0, ii = 0; i < nums.size(); ++i) {
            freq.merge(nums.get(i), 1, Integer::sum);
            most = Math.max(most, freq.get(nums.get(i)));
            if (i - ii - most >= k) {
                freq.merge(nums.get(ii), -1, Integer::sum);
                ++ii;
            }
        }
        return most;
    }


    /*2832. Maximal Range That Each Element Is Maximum in It (Medium)
    You are given a 0-indexed array nums of distinct integers. Let us define a
    0-indexed array ans of the same length as nums in the following way:
    * ans[i] is the maximum length of a subarray nums[l..r], such that the
      maximum element in that subarray is equal to nums[i].
    Return the array ans. Note that a subarray is a contiguous part of the
    array.

    Example 1:
    Input: nums = [1,5,4,3,6]
    Output: [1,4,2,1,5]
    Explanation: - For nums[0] the longest subarray in which 1 is the maximum is
                   nums[0..0] so ans[0] = 1.
                 - For nums[1] the longest subarray in which 5 is the maximum is
                   nums[0..3] so ans[1] = 4.
                 - For nums[2] the longest subarray in which 4 is the maximum is
                   nums[2..3] so ans[2] = 2.
                 - For nums[3] the longest subarray in which 3 is the maximum is
                   nums[3..3] so ans[3] = 1.
                 - For nums[4] the longest subarray in which 6 is the maximum is
                   nums[0..4] so ans[4] = 5.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: [1,2,3,4,5]
    Explanation: For nums[i] the longest subarray in which it's the maximum is
                 nums[0..i] so ans[i] = i + 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * All elements in nums are distinct.*/

    public int[] maximumLengthOfRanges(int[] nums) {
        int n = nums.length;
        Stack<Integer> stk = new Stack(); stk.push(-1);
        int[] ans = new int[n];
        for (int i = 0; i <= n; ++i) {
            int x = Integer.MAX_VALUE;
            if (i < n) x = nums[i];
            while (stk.size() > 1 && nums[stk.peek()] < x) {
                int ii = stk.pop();
                ans[ii] = i-stk.peek()-1;
            }
            stk.push(i);
        }
        return ans;
    }


    /*2833. Furthest Point From Origin (Easy)
    You are given a string moves of length n consisting only of characters 'L',
    'R', and '_'. The string represents your movement on a number line starting
    from the origin 0. In the ith move, you can choose one of the following
    directions:
    * move to the left if moves[i] = 'L' or moves[i] = '_'
    * move to the right if moves[i] = 'R' or moves[i] = '_'
    Return the distance from the origin of the furthest point you can get to
    after n moves.

    Example 1:
    Input: moves = "L_RL__R"
    Output: 3
    Explanation: The furthest point we can reach from the origin 0 is point -3
                 through the following sequence of moves "LLRLLLR".

    Example 2:
    Input: moves = "_R__LL_"
    Output: 5
    Explanation: The furthest point we can reach from the origin 0 is point -5
                 through the following sequence of moves "LRLLLLL".

    Example 3:
    Input: moves = "_______"
    Output: 7
    Explanation: The furthest point we can reach from the origin 0 is point 7
                 through the following sequence of moves "RRRRRRR".

    Constraints:
    * 1 <= moves.length == n <= 50
    * moves consists only of characters 'L', 'R' and '_'.*/

    public int furthestDistanceFromOrigin(String moves) {
        int L = 0, R = 0;
        for (var ch : moves.toCharArray())
            if (ch == 'L') ++L;
            else if (ch == 'R') ++R;
        return moves.length() - L - R + Math.abs(L - R);
    }


    /*2834. Find the Minimum Possible Sum of a Beautiful Array (Medium)
    You are given positive integers n and target. An array nums is beautiful if
    it meets the following conditions:
    * nums.length == n.
    * nums consists of pairwise distinct positive integers.
    * There doesn't exist two distinct indices, i and j, in the range
      [0, n - 1], such that nums[i] + nums[j] == target.
    Return the minimum possible sum that a beautiful array could have.

    Example 1:
    Input: n = 2, target = 3
    Output: 4
    Explanation: We can see that nums = [1,3] is beautiful.
                 - The array nums has length n = 2.
                 - The array nums consists of pairwise distinct positive integers.
                 - There doesn't exist two distinct indices, i and j, with
                   nums[i] + nums[j] == 3.
                 It can be proven that 4 is the minimum possible sum that a
                 beautiful array could have.

    Example 2:
    Input: n = 3, target = 3
    Output: 8
    Explanation: We can see that nums = [1,3,4] is beautiful.
                 - The array nums has length n = 3.
                 - The array nums consists of pairwise distinct positive integers.
                 - There doesn't exist two distinct indices, i and j, with
                   nums[i] + nums[j] == 3.
                 It can be proven that 8 is the minimum possible sum that a
                 beautiful array could have.

    Example 3:
    Input: n = 1, target = 1
    Output: 1
    Explanation: We can see, that nums = [1] is beautiful.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= target <= 10^5*/

    public long minimumPossibleSum(int n, int target) {
        long m = target/2;
        return n <= m ? (long) n*(n+1)/2 : m*(m+1)/2 + target*(n-m) + (n-m-1)*(n-m)/2;
    }


    /*2835. Minimum Operations to Form Subsequence With Target Sum (Hard)
    You are given a 0-indexed array nums consisting of non-negative powers of 2,
    and an integer target. In one operation, you must apply the following
    changes to the array:
    * Choose any element of the array nums[i] such that nums[i] > 1.
    * Remove nums[i] from the array.
    * Add two occurrences of nums[i] / 2 to the end of nums.
    Return the minimum number of operations you need to perform so that nums
    contains a subsequence whose elements sum to target. If it is impossible to
    obtain such a subsequence, return -1. A subsequence is an array that can be
    derived from another array by deleting some or no elements without changing
    the order of the remaining elements.

    Example 1:
    Input: nums = [1,2,8], target = 7
    Output: 1
    Explanation: In the first operation, we choose element nums[2]. The array
                 becomes equal to nums = [1,2,4,4]. At this stage, nums
                 contains the subsequence [1,2,4] which sums up to 7. It can be
                 shown that there is no shorter sequence of operations that
                 results in a subsequnce that sums up to 7.

    Example 2:
    Input: nums = [1,32,1,2], target = 12
    Output: 2
    Explanation: In the first operation, we choose element nums[1]. The array
                 becomes equal to nums = [1,1,2,16,16]. In the second operation,
                 we choose element nums[3]. The array becomes equal to
                 nums = [1,1,2,16,8,8]. At this stage, nums contains the
                 subsequence [1,1,2,8] which sums up to 12. It can be shown
                 that there is no shorter sequence of operations that results
                 in a subsequence that sums up to 12.

    Example 3:
    Input: nums = [1,32,1], target = 35
    Output: -1
    Explanation: It can be shown that no sequence of operations results in a
                 subsequence that sums up to 35.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 2^30
    * nums consists only of non-negative powers of two.
    * 1 <= target < 2^31*/

    public int minOperations(List<Integer> nums, int target) {
        int ans = 0, ii = -1;
        Map<Integer, Integer> freq = new HashMap();
        for (var x : nums) freq.merge(x, 1, Integer::sum);
        for (int i = 0, cnt = 0; i <= 30; ++i) {
            cnt /= 2;
            cnt += freq.getOrDefault(1<<i, 0);
            if ((target & 1<<i) > 0)
                if (cnt > 0) --cnt;
                else if (ii == -1) ii = i;
            if (cnt > 0 && ii >= 0) {
                ans += i - ii;
                --cnt;
                ii = -1;
            }
        }
        return ii == -1 ? ans : -1;
    }


    /*2836. Maximize Value of Function in a Ball Passing Game (Hard)
    You are given a 0-indexed integer array receiver of length n and an integer
    k. There are n players having a unique id in the range [0, n - 1] who will
    play a ball passing game, and receiver[i] is the id of the player who
    receives passes from the player with id i. Players can pass to themselves,
    i.e. receiver[i] may be equal to i. You must choose one of the n players as
    the starting player for the game, and the ball will be passed exactly k
    times starting from the chosen player. For a chosen starting player having
    id x, we define a function f(x) that denotes the sum of x and the ids of
    all players who receive the ball during the k passes, including repetitions.
    In other words,
    f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver(k)[x].
    Your task is to choose a starting player having id x that maximizes the
    value of f(x). Return an integer denoting the maximum value of the function.
    Note: receiver may contain duplicates.

    Example 1:
    Pass Number Sender ID   Receiver ID x + Receiver IDs
                2
    1   2   1   3
    2   1   0   3
    3   0   2   5
    4   2   1   6
    Input: receiver = [2,0,1], k = 4
    Output: 6
    Explanation: The table above shows a simulation of the game starting with
                 the player having id x = 2. From the table, f(2) is equal to 6.
                 It can be shown that 6 is the maximum achievable value of the
                 function. Hence, the output is 6.

    Example 2:
    Pass Number Sender ID   Receiver ID x + Receiver IDs
                4
    1   4   3   7
    2   3   2   9
    3   2   1   10
    Input: receiver = [1,1,1,2,3], k = 3
    Output: 10
    Explanation: The table above shows a simulation of the game starting with
                 the player having id x = 4. From the table, f(4) is equal to
                 10. It can be shown that 10 is the maximum achievable value of
                 the function. Hence, the output is 10.

    Constraints:
    * 1 <= receiver.length == n <= 10^5
    * 0 <= receiver[i] <= n - 1
    * 1 <= k <= 10^10*/

    public long getMaxFunctionValue(List<Integer> receiver, long k) {
        int n = receiver.size(), m = (int) (Math.log(k)/Math.log(2))+2;
        int[][] lift = new int[n][m];
        for (int x = 0; x < n; ++x) Arrays.fill(lift[x], -1);
        long[][] score = new long[n][m];
        for (int i = 0; i < m; ++i)
            for (int x = 0; x < n; ++x)
                if (i == 0) {
                    lift[x][0] = receiver.get(x);
                    score[x][0] = x;
                } else if (lift[x][i-1] != -1) {
                    lift[x][i] = lift[lift[x][i-1]][i-1];
                    score[x][i] = score[x][i-1] + score[lift[x][i-1]][i-1];
                }
        long ans = 0;
        for (int v = 0; v < n; ++v) {
            long cand = 0;
            for (int i = 0, x = v; i < m; ++i)
                if ((k+1 & 1l<<i) > 0) {
                    cand += score[x][i];
                    x = lift[x][i];
                }
            ans = Math.max(ans, cand);
        }
        return ans;
    }


    /*2838. Maximum Coins Heroes Can Collect (Medium)
    There is a battle and n heroes are trying to defeat m monsters. You are
    given two 1-indexed arrays of positive integers heroes and monsters of
    length n and m, respectively. heroes[i] is the power of ith hero, and
    monsters[i] is the power of ith monster. The ith hero can defeat the jth
    monster if monsters[j] <= heroes[i]. You are also given a 1-indexed array
    coins of length m consisting of positive integers. coins[i] is the number of
    coins that each hero earns after defeating the ith monster. Return an array
    ans of length n where ans[i] is the maximum number of coins that the ith
    hero can collect from this battle.

    Notes
    * The health of a hero doesn't get reduced after defeating a monster.
    * Multiple heroes can defeat a monster, but each monster can be defeated by
      a given hero only once.

    Example 1:
    Input: heroes = [1,4,2], monsters = [1,1,5,2,3], coins = [2,3,4,5,6]
    Output: [5,16,10]
    Explanation: For each hero, we list the index of all the monsters he can
                 defeat:
                 - 1st hero: [1,2] since the power of this hero is 1 and
                             monsters[1], monsters[2] <= 1. So this hero
                             collects coins[1] + coins[2] = 5 coins.
                 - 2nd hero: [1,2,4,5] since the power of this hero is 4 and
                             monsters[1], monsters[2], monsters[4], monsters[5]
                             <= 4. So this hero collects
                             coins[1] + coins[2] + coins[4] + coins[5] = 16 coins.
                 - 3rd hero: [1,2,4] since the power of this hero is 2 and
                             monsters[1], monsters[2], monsters[4] <= 2. So this
                             hero collects coins[1] + coins[2] + coins[4] = 10
                             coins.
                 - So the answer would be [5,16,10].

    Example 2:
    Input: heroes = [5], monsters = [2,3,1,2], coins = [10,6,5,2]
    Output: [23]
    Explanation: This hero can defeat all the monsters since monsters[i] <= 5.
                 So he collects all of the coins:
                 coins[1] + coins[2] + coins[3] + coins[4] = 23, and the answer
                 would be [23].

    Example 3:
    Input: heroes = [4,4], monsters = [5,7,8], coins = [1,1,1]
    Output: [0,0]
    Explanation: In this example, no hero can defeat a monster. So the answer
                 would be [0,0],

    Constraints:
    * 1 <= n == heroes.length <= 10^5
    * 1 <= m == monsters.length <= 10^5
    * coins.length == m
    * 1 <= heroes[i], monsters[i], coins[i] <= 10^9*/

    public long[] maximumCoins(int[] heroes, int[] monsters, int[] coins) {
        int m = monsters.length, n = heroes.length;
        int[][] mc = new int[m][2];
        for (int i = 0; i < m; ++i) {
            mc[i][0] = monsters[i];
            mc[i][1] = coins[i];
        }
        Arrays.sort(mc, (a, b) -> Integer.compare(a[0], b[0]));
        int[][] hi = new int[n][2];
        for (int i = 0; i < n; ++i) {
            hi[i][0] = heroes[i];
            hi[i][1] = i;
        }
        Arrays.sort(hi, (a, b) -> Integer.compare(a[0], b[0]));
        long[] ans = new long[n];
        long prefix = 0;
        for (int i = 0, j = 0; i < n; ++i) {
            for (; j < m && mc[j][0] <= hi[i][0]; ++j)
                prefix += mc[j][1];
            ans[hi[i][1]] = prefix;
        }
        return ans;
    }


    /*2839. Check if Strings Can be Made Equal With Operations I (Easy)
    You are given two strings s1 and s2, both of length 4, consisting of
    lowercase English letters. You can apply the following operation on any of
    the two strings any number of times:
    * Choose any two indices i and j such that j - i = 2, then swap the two
      characters at those indices in the string.
    Return true if you can make the strings s1 and s2 equal, and false
    otherwise.

    Example 1:
    Input: s1 = "abcd", s2 = "cdab"
    Output: true
    Explanation: We can do the following operations on s1:
                 - Choose the indices i = 0, j = 2. The resulting string is
                   s1 = "cbad".
                 - Choose the indices i = 1, j = 3. The resulting string is
                   s1 = "cdab" = s2.

    Example 2:
    Input: s1 = "abcd", s2 = "dacb"
    Output: false
    Explanation: It is not possible to make the two strings equal.

    Constraints:
    * s1.length == s2.length == 4
    * s1 and s2 consist only of lowercase English letters.*/

    public boolean canBeEqual(String s1, String s2) {
        char[] ch = s1.toCharArray();
        if (ch[0] != s2.charAt(0)) { char temp = ch[0]; ch[0] = ch[2]; ch[2] = temp; }
        if (ch[1] != s2.charAt(1)) { char temp = ch[1]; ch[1] = ch[3]; ch[3] = temp; }
        return String.valueOf(ch).equals(s2);
    }


    /*2840. Check if Strings Can be Made Equal With Operations II (Medium)
    You are given two strings s1 and s2, both of length n, consisting of
    lowercase English letters. You can apply the following operation on any of
    the two strings any number of times:
    * Choose any two indices i and j such that i < j and the difference j - i
      is even, then swap the two characters at those indices in the string.
    Return true if you can make the strings s1 and s2 equal, and false
    otherwise.

    Example 1:
    Input: s1 = "abcdba", s2 = "cabdab"
    Output: true
    Explanation: We can apply the following operations on s1:
                 - Choose the indices i = 0, j = 2. The resulting string is
                   s1 = "cbadba".
                 - Choose the indices i = 2, j = 4. The resulting string is
                   s1 = "cbbdaa".
                 - Choose the indices i = 1, j = 5. The resulting string is
                   s1 = "cabdab" = s2.

    Example 2:
    Input: s1 = "abe", s2 = "bea"
    Output: false
    Explanation: It is not possible to make the two strings equal.

    Constraints:
    * n == s1.length == s2.length
    * 1 <= n <= 10^5
    * s1 and s2 consist only of lowercase English letters.*/

    public boolean checkStrings(String s1, String s2) {
        int[] freq = new int[52];
        for (int i = 0; i < s1.length(); ++i) {
            ++freq[s1.charAt(i)-'a' + 26*(i&1)];
            --freq[s2.charAt(i)-'a' + 26*(i&1)];
        }
        for (var x : freq)
            if (x > 0) return false;
        return true;
    }


    /*2841. Maximum Sum of Almost Unique Subarray (Medium)
    You are given an integer array nums and two positive integers m and k.
    Return the maximum sum out of all almost unique subarrays of length k of
    nums. If no such subarray exists, return 0. A subarray of nums is almost
    unique if it contains at least m distinct elements. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [2,6,7,3,1,7], m = 3, k = 4
    Output: 18
    Explanation: There are 3 almost unique subarrays of size k = 4. These
                 subarrays are [2, 6, 7, 3], [6, 7, 3, 1], and [7, 3, 1, 7].
                 Among these subarrays, the one with the maximum sum is
                 [2, 6, 7, 3] which has a sum of 18.

    Example 2:
    Input: nums = [5,9,9,2,4,5,4], m = 1, k = 3
    Output: 23
    Explanation: There are 5 almost unique subarrays of size k. These subarrays
                 are [5, 9, 9], [9, 9, 2], [9, 2, 4], [2, 4, 5], and [4, 5, 4].
                 Among these subarrays, the one with the maximum sum is
                 [5, 9, 9] which has a sum of 23.

    Example 3:
    Input: nums = [1,2,1,2,1,2,1], m = 3, k = 3
    Output: 0
    Explanation: There are no subarrays of size k = 3 that contain at least
                 m = 3 distinct elements in the given array [1,2,1,2,1,2,1].
                 Therefore, no almost unique subarrays exist, and the maximum
                 sum is 0.

    Constraints:
    * 1 <= nums.length <= 2 * 10^4
    * 1 <= m <= k <= nums.length
    * 1 <= nums[i] <= 10^9*/

    public long maxSum(List<Integer> nums, int m, int k) {
        long ans = 0, prefix = 0;
        Map<Integer, Integer> freq = new HashMap();
        for (int i = 0; i < nums.size(); ++i) {
            prefix += nums.get(i);
            freq.merge(nums.get(i), 1, Integer::sum);
            if (i >= k) {
                prefix -= nums.get(i-k);
                freq.merge(nums.get(i-k), -1, Integer::sum);
                if (freq.get(nums.get(i-k)) == 0) freq.remove(nums.get(i-k));
            }
            if (i >= k-1 && freq.size() >= m) ans = Math.max(ans, prefix);
        }
        return ans;
    }


    /*2842. Count K-Subsequences of a String With Maximum Beauty (Hard)
    You are given a string s and an integer k. A k-subsequence is a subsequence
    of s, having length k, and all its characters are unique, i.e., every
    character occurs once. Let f(c) denote the number of times the character c
    occurs in s. The beauty of a k-subsequence is the sum of f(c) for every
    character c in the k-subsequence. For example, consider s = "abbbdd" and
    k = 2:
    * f('a') = 1, f('b') = 3, f('d') = 2
    * Some k-subsequences of s are:
      + "abbbdd" -> "ab" having a beauty of f('a') + f('b') = 4
      + "abbbdd" -> "ad" having a beauty of f('a') + f('d') = 3
      + "abbbdd" -> "bd" having a beauty of f('b') + f('d') = 5
    Return an integer denoting the number of k-subsequences whose beauty is the
    maximum among all k-subsequences. Since the answer may be too large, return
    it modulo 10^9 + 7. A subsequence of a string is a new string formed from
    the original string by deleting some (possibly none) of the characters
    without disturbing the relative positions of the remaining characters.

    Notes
    * f(c) is the number of times a character c occurs in s, not a k-subsequence.
    * Two k-subsequences are considered different if one is formed by an index
      that is not present in the other. So, two k-subsequences may form the
      same string.

    Example 1:
    Input: s = "bcca", k = 2
    Output: 4
    Explanation: From s we have f('a') = 1, f('b') = 1, and f('c') = 2.
                 The k-subsequences of s are:
                 bcca having a beauty of f('b') + f('c') = 3
                 bcca having a beauty of f('b') + f('c') = 3
                 bcca having a beauty of f('b') + f('a') = 2
                 bcca having a beauty of f('c') + f('a') = 3
                 bcca having a beauty of f('c') + f('a') = 3
                 There are 4 k-subsequences that have the maximum beauty, 3.
                 Hence, the answer is 4.

    Example 2:
    Input: s = "abbcd", k = 4
    Output: 2
    Explanation: From s we have f('a') = 1, f('b') = 2, f('c') = 1, and f('d') = 1.
                 The k-subsequences of s are:
                 abbcd having a beauty of f('a') + f('b') + f('c') + f('d') = 5
                 abbcd having a beauty of f('a') + f('b') + f('c') + f('d') = 5
                 There are 2 k-subsequences that have the maximum beauty, 5.
                 Hence, the answer is 2.

    Constraints:
    * 1 <= s.length <= 2 * 10^5
    * 1 <= k <= s.length
    * s consists only of lowercase English letters.*/

    public int countKSubsequencesWithMaxBeauty(String s, int k) {
        int[] freq = new int[26];
        for (var ch : s.toCharArray()) ++freq[ch-'a'];
        Arrays.sort(freq);
        if (k > 26 || freq[26-k] == 0) return 0;
        long ans = 1, comb = 1;
        int bep = freq[26-k], mod = 1_000_000_007, n = 0;
        for (var x : freq) {
            if (x > bep) {
                --k;
                ans = ans * x % mod;
            } else if (x == bep) ++n;
        }
        for (int i = 0; i < k; ++i) {
            comb = comb * (n-i)/(i+1);
            ans = ans * bep % mod;
        }
        return (int) (ans * comb % mod);
    }


    /*2843. Count Symmetric Integers (Easy)
    You are given two positive integers low and high. An integer x consisting
    of 2 * n digits is symmetric if the sum of the first n digits of x is equal
    to the sum of the last n digits of x. Numbers with an odd number of digits
    are never symmetric. Return the number of symmetric integers in the range
    [low, high].

    Example 1:
    Input: low = 1, high = 100
    Output: 9
    Explanation: There are 9 symmetric integers between 1 and 100: 11, 22, 33,
                 44, 55, 66, 77, 88, and 99.

    Example 2:
    Input: low = 1200, high = 1230
    Output: 4
    Explanation: There are 4 symmetric integers between 1200 and 1230: 1203,
                 1212, 1221, and 1230.

    Constraints: 1 <= low <= high <= 10^4*/

    public int countSymmetricIntegers(int low, int high) {
        int ans = 0;
        for (int x = low; x <= high; ++x) {
            String s = String.valueOf(x);
            if (s.length() % 2 == 0) {
                int bal = 0;
                for (int i = 0, n = s.length(); i < n; ++i)
                    if (i < n/2) bal += s.charAt(i)-'a';
                    else bal -= s.charAt(i)-'a';
                if (bal == 0) ++ans;
            }
        }
        return ans;
    }


    /*2844. Minimum Operations to Make a Special Number (Medium)
    You are given a 0-indexed string num representing a non-negative integer.
    In one operation, you can pick any digit of num and delete it. Note that if
    you delete all the digits of num, num becomes 0. Return the minimum number
    of operations required to make num special. An integer x is considered
    special if it is divisible by 25.

    Example 1:
    Input: num = "2245047"
    Output: 2
    Explanation: Delete digits num[5] and num[6]. The resulting number is
                 "22450" which is special since it is divisible by 25. It can
                 be shown that 2 is the minimum number of operations required
                 to get a special number.

    Example 2:
    Input: num = "2908305"
    Output: 3
    Explanation: Delete digits num[3], num[4], and num[6]. The resulting number
                 is "2900" which is special since it is divisible by 25. It can
                 be shown that 3 is the minimum number of operations required
                 to get a special number.

    Example 3:
    Input: num = "10"
    Output: 1
    Explanation: Delete digit num[0]. The resulting number is "0" which is
                 special since it is divisible by 25. It can be shown that 1 is
                 the minimum number of operations required to get a special
                 number.

    Constraints:
    * 1 <= num.length <= 100
    * num only consists of digits '0' through '9'.
    * num does not contain any leading zeros.*/

    public int minimumOperations(String num) {
        int ans = Integer.MAX_VALUE;
        for (var p : new String[]{"00", "25", "50", "75"})
            for (int i = num.length()-1, k = 1, cand = 0; i >= 0; --i) {
                if (p.charAt(k) == num.charAt(i)) --k;
                else ++cand;
                if (k == -1) {
                    ans = Math.min(ans, cand);
                    break;
                }
            }
        return ans < Integer.MAX_VALUE ? ans : num.contains("0") ? num.length()-1 : num.length();
    }


    /*2845. Count of Interesting Subarrays (Medium)
    You are given a 0-indexed integer array nums, an integer modulo, and an
    integer k. Your task is to find the count of subarrays that are interesting.
    A subarray nums[l..r] is interesting if the following condition holds:
    * Let cnt be the number of indices i in the range [l, r] such that
      nums[i] % modulo == k. Then, cnt % modulo == k.
    Return an integer denoting the count of interesting subarrays. Note: A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [3,2,4], modulo = 2, k = 1
    Output: 3
    Explanation: In this example the interesting subarrays are:
                 The subarray nums[0..0] which is [3].
                 - There is only one index, i = 0, in the range [0, 0] that
                   satisfies nums[i] % modulo == k.
                 - Hence, cnt = 1 and cnt % modulo == k.
                 The subarray nums[0..1] which is [3,2].
                 - There is only one index, i = 0, in the range [0, 1] that
                   satisfies nums[i] % modulo == k.
                 - Hence, cnt = 1 and cnt % modulo == k.
                 The subarray nums[0..2] which is [3,2,4].
                 - There is only one index, i = 0, in the range [0, 2] that
                   satisfies nums[i] % modulo == k.
                 - Hence, cnt = 1 and cnt % modulo == k.
                 It can be shown that there are no other interesting subarrays.
                 So, the answer is 3.

    Example 2:
    Input: nums = [3,1,9,6], modulo = 3, k = 0
    Output: 2
    Explanation: In this example the interesting subarrays are:
                 The subarray nums[0..3] which is [3,1,9,6].
                 - There are three indices, i = 0, 2, 3, in the range [0, 3]
                   that satisfy nums[i] % modulo == k.
                 - Hence, cnt = 3 and cnt % modulo == k.
                 The subarray nums[1..1] which is [1].
                 - There is no index, i, in the range [1, 1] that satisfies
                   nums[i] % modulo == k.
                 - Hence, cnt = 0 and cnt % modulo == k.
                 It can be shown that there are no other interesting subarrays.
                 So, the answer is 2.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= modulo <= 10^9
    * 0 <= k < modulo*/

    public long countInterestingSubarrays(List<Integer> nums, int modulo, int k) {
        long ans = 0;
        Map<Integer, Integer> freq = new HashMap();
        freq.put(0, 1);
        int prefix = 0;
        for (var x : nums) {
            if (x % modulo == k) ++prefix;
            prefix %= modulo;
            ans += freq.getOrDefault((prefix-k+modulo) % modulo, 0);
            freq.merge(prefix, 1, Integer::sum);
        }
        return ans;
    }


    /*2846. Minimum Edge Weight Equilibrium Queries in a Tree (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui
    and vi with weight wi in the tree. You are also given a 2D integer array
    queries of length m, where queries[i] = [ai, bi]. For each query, find the
    minimum number of operations required to make the weight of every edge on
    the path from ai to bi equal. In one operation, you can choose any edge of
    the tree and change its weight to any value.

    Note that:
    * Queries are independent of each other, meaning that the tree returns to
      its initial state on each new query.
    * The path from ai to bi is a sequence of distinct nodes starting with node
      ai and ending with node bi such that every two adjacent nodes in the
      sequence share an edge in the tree.
    Return an array answer of length m where answer[i] is the answer to the ith
    query.

    Example 1:
    Input: n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]]
    Output: [0,0,1,3]
    Explanation: In the first query, all the edges in the path from 0 to 3 have
                 a weight of 1. Hence, the answer is 0. In the second query,
                 all the edges in the path from 3 to 6 have a weight of 2.
                 Hence, the answer is 0. In the third query, we change the
                 weight of edge [2,3] to 2. After this operation, all the edges
                 in the path from 2 to 6 have a weight of 2. Hence, the answer
                 is 1. In the fourth query, we change the weights of edges
                 [0,1], [1,2] and [2,3] to 2. After these operations, all the
                 edges in the path from 0 to 6 have a weight of 2. Hence, the
                 answer is 3. For each queries[i], it can be shown that
                 answer[i] is the minimum number of operations needed to
                 equalize all the edge weights in the path from ai to bi.

    Example 2:
    Input: n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]]
    Output: [1,2,2,3]
    Explanation: In the first query, we change the weight of edge [1,3] to 6.
                 After this operation, all the edges in the path from 4 to 6
                 have a weight of 6. Hence, the answer is 1. In the second
                 query, we change the weight of edges [0,3] and [3,1] to 6.
                 After these operations, all the edges in the path from 0 to 4
                 have a weight of 6. Hence, the answer is 2. In the third
                 query, we change the weight of edges [1,3] and [5,2] to 6.
                 After these operations, all the edges in the path from 6 to 5
                 have a weight of 6. Hence, the answer is 2. In the fourth
                 query, we change the weights of edges [0,7], [0,3] and [1,3]
                 to 6. After these operations, all the edges in the path from 7
                 to 4 have a weight of 6. Hence, the answer is 3. For each
                 queries[i], it can be shown that answer[i] is the minimum
                 number of operations needed to equalize all the edge weights
                 in the path from ai to bi.

    Constraints:
    * 1 <= n <= 10^4
    * edges.length == n - 1
    * edges[i].length == 3
    * 0 <= ui, vi < n
    * 1 <= wi <= 26
    * The input is generated such that edges represents a valid tree.
    * 1 <= queries.length == m <= 2 * 10^4
    * queries[i].length == 2
    * 0 <= ai, bi < n*/

    public int[] minOperationsQueries(int n, int[][] edges, int[][] queries) {
        List<int[]>[] tree = new ArrayList[n];
        for (int i = 0; i < n; ++i) tree[i] = new ArrayList();
        for (var edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            tree[u].add(new int[]{v, w});
            tree[v].add(new int[]{u, w});
        }
        int m = (int) (Math.log(n)/Math.log(2)) + 1;
        int[][] lift = new int[n][m], freq = new int[n][27];
        for (int i = 0; i < n; ++i) Arrays.fill(lift[i], -1);
        int[] depth = new int[n];
        Arrays.fill(depth, -1);
        Stack<int[]> stk = new Stack(); stk.add(new int[]{0, -1, 0});
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            int u = elem[0], p = elem[1], d = elem[2];
            depth[u] = d;
            for (var vw : tree[u]) {
                int v = vw[0], w = vw[1];
                if (v != p) {
                    lift[v][0] = u;
                    for (int x = 1; x < 27; ++x) freq[v][x] = freq[u][x];
                    ++freq[v][w];
                    for (int j = 1; j < m; ++j) {
                        if (lift[v][j-1] == -1) break;
                        lift[v][j] = lift[lift[v][j-1]][j-1];
                    }
                    stk.add(new int[]{v, u, d+1});
                }
            }
        }
        List<Integer> ans = new ArrayList();
        for (var q : queries) {
            int u = q[0], v = q[1], uu = u, vv = v, k = 0, sm = 0, mx = 0;
            if (depth[u] > depth[v]) {
                int temp = u; u = v; v = temp;
            }
            for (int i = 0; i < m; ++i)
                if ((depth[v]-depth[u] & 1<<i) > 0) v = lift[v][i];
            if (u == v) k = u;
            else {
                for (int i = m-1; i >= 0; --i)
                    if (lift[u][i] != lift[v][i]) {
                        u = lift[u][i];
                        v = lift[v][i];
                    }
                k = lift[u][0];
            }
            for (int w = 1; w < 27; ++w) {
                int val = freq[uu][w] + freq[vv][w] - 2*freq[k][w];
                sm += val;
                mx = Math.max(mx, val);
            }
            ans.add(sm-mx);
        }
        return ans.stream().mapToInt(i->i).toArray();
    }


    /*2847. Smallest Number With Given Digit Product (Medium)
    Given a positive integer n, return a string representing the smallest
    positive integer such that the product of its digits is equal to n, or "-1"
    if no such number exists.

    Example 1:
    Input: n = 105
    Output: "357"
    Explanation: 3 * 5 * 7 = 105. It can be shown that 357 is the smallest
                 number with a product of digits equal to 105. So the answer
                 would be "105".

    Example 2:
    Input: n = 7
    Output: "7"
    Explanation: Since 7 has only one digit, its product of digits would be 7.
                 We will show that 7 is the smallest number with a product of
                 digits equal to 7. Since the product of numbers 1 to 6 is 1 to
                 6 respectively, so "7" would be the answer.

    Example 3:
    Input: n = 44
    Output: "-1"
    Explanation: It can be shown that there is no number such that its product
                 of digits is equal to 44. So the answer would be "-1".

    Constraints: 1 <= n <= 10^18*/

    public String smallestNumber(long n) {
        if (n == 1) return "1";
        StringBuilder ans = new StringBuilder();
        for (int d = 9; d >= 2; --d)
            for (; n > 0 && n % d == 0; n /= d)
                ans.append((char) (d + '0'));
        if (n > 1) return "-1";
        return ans.reverse().toString();
    }


    /*2852. Sum of Remoteness of All Cells (Medium)
    You are given a 0-indexed matrix grid of order n * n. Each cell in this
    matrix has a value grid[i][j], which is either a positive integer or -1
    representing a blocked cell. You can move from a non-blocked cell to any
    non-blocked cell that shares an edge. For any cell (i, j), we represent its
    remoteness as R[i][j] which is defined as the following:
    * If the cell (i, j) is a non-blocked cell, R[i][j] is the sum of the values
      grid[x][y] such that there is no path from the non-blocked cell (x, y) to
      the cell (i, j).
    * For blocked cells, R[i][j] == 0.
    Return the sum of R[i][j] over all cells.

    Example 1:
    Input: grid = [[-1,1,-1],[5,-1,4],[-1,3,-1]]
    Output: 39
    Explanation: In the picture above, there are four grids. The top-left grid
                 contains the initial values in the grid. Blocked cells are
                 colored black, and other cells get their values as it is in the
                 input. In the top-right grid, you can see the value of R[i][j]
                 for all cells. So the answer would be the sum of them. That is:
                 0 + 12 + 0 + 8 + 0 + 9 + 0 + 10 + 0 = 39. Let's jump on the
                 bottom-left grid in the above picture and calculate R[0][1]
                 (the target cell is colored green). We should sum up the value
                 of cells that can't be reached by the cell (0, 1). These cells
                 are colored yellow in this grid. So R[0][1] = 5 + 4 + 3 = 12.
                 Now let's jump on the bottom-right grid in the above picture
                 and calculate R[1][2] (the target cell is colored green). We
                 should sum up the value of cells that can't be reached by the
                 cell (1, 2). These cells are colored yellow in this grid. So
                 R[1][2] = 1 + 5 + 3 = 9.

    Example 2:
    Input: grid = [[-1,3,4],[-1,-1,-1],[3,-1,-1]]
    Output: 13
    Explanation: In the picture above, there are four grids. The top-left grid
                 contains the initial values in the grid. Blocked cells are
                 colored black, and other cells get their values as it is in the
                 input. In the top-right grid, you can see the value of R[i][j]
                 for all cells. So the answer would be the sum of them. That is:
                 3 + 3 + 0 + 0 + 0 + 0 + 7 + 0 + 0 = 13. Let's jump on the
                 bottom-left grid in the above picture and calculate R[0][2]
                 (the target cell is colored green). We should sum up the value
                 of cells that can't be reached by the cell (0, 2). This cell is
                 colored yellow in this grid. So R[0][2] = 3. Now let's jump on
                 the bottom-right grid in the above picture and calculate
                 R[2][0] (the target cell is colored green). We should sum up
                 the value of cells that can't be reached by the cell (2, 0).
                 These cells are colored yellow in this grid. So
                 R[2][0] = 3 + 4 = 7.

    Example 3:
    Input: grid = [[1]]
    Output: 0
    Explanation: Since there are no other cells than (0, 0), R[0][0] is equal to
                 0. So the sum of R[i][j] over all cells would be 0.

    Constraints:
    * 1 <= n <= 300
    * 1 <= grid[i][j] <= 10^6 or grid[i][j] == -1*/

    public long sumRemoteness(int[][] grid) {
        int[] dir = {-1, 0, 1, 0, -1};
        long ans = 0, value = 0, count = 0;
        for (int r = 0, n = grid.length; r < n; ++r)
            for (int c = 0; c < n; ++c)
                if (grid[r][c] != -1) {
                    long val = grid[r][c], cnt = 1;
                    grid[r][c] = -1;
                    Stack<int[]> stk = new Stack(); stk.push(new int[]{r, c});
                    while (!stk.isEmpty()) {
                        var elem = stk.pop();
                        int i = elem[0], j = elem[1];
                        for (int k = 0; k < 4; ++k) {
                            int ii = i + dir[k], jj = j + dir[k+1];
                            if (0 <= ii && ii < n && 0 <= jj && jj < n && grid[ii][jj] != -1) {
                                val += grid[ii][jj];
                                ++cnt;
                                grid[ii][jj] = -1;
                                stk.push(new int[]{ii, jj});
                            }
                        }
                    }
                    ans -= val*cnt;
                    value += val;
                    count += cnt;
                }
        return ans + value*count;
    }


    /*2855. Minimum Right Shifts to Sort the Array (Easy)
    You are given a 0-indexed array nums of length n containing distinct
    positive integers. Return the minimum number of right shifts required to
    sort nums and -1 if this is not possible. A right shift is defined as
    shifting the element at index i to index (i + 1) % n, for all indices.

    Example 1:
    Input: nums = [3,4,5,1,2]
    Output: 2
    Explanation: After the first right shift, nums = [2,3,4,5,1]. After the
                 second right shift, nums = [1,2,3,4,5]. Now nums is sorted;
                 therefore the answer is 2.

    Example 2:
    Input: nums = [1,3,5]
    Output: 0
    Explanation: nums is already sorted therefore, the answer is 0.

    Example 3:
    Input: nums = [2,1,4]
    Output: -1
    Explanation: It's impossible to sort the array using right shifts.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * nums contains distinct integers.*/

    public int minimumRightShifts(List<Integer> nums) {
        int c = 0, k = 0, n = nums.size();
        for (int i = 0; i < n; ++i)
            if (nums.get(i) > nums.get((i+1)%n)) {
                ++c;
                k = i;
            }
        switch (c) {
            case 0: return 0;
            case 1: return n-1-k;
        }
        return -1;
    }


    /*2856. Minimum Array Length After Pair Removals (Medium)
    Given an integer array num sorted in non-decreasing order. You can perform
    the following operation any number of times:
    * Choose two indices, i and j, where nums[i] < nums[j].
    * Then, remove the elements at indices i and j from nums. The remaining
      elements retain their original order, and the array is re-indexed.
    Return the minimum length of nums after applying the operation zero or more
    times.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation:

    Example 2:
    Input: nums = [1,1,2,2,3,3]
    Output: 0
    Explanation:

    Example 3:
    Input: nums = [1000000000,1000000000]
    Output: 2
    Explanation: Since both numbers are equal, they cannot be removed.

    Example 4:
    Input: nums = [2,3,4,4,4]
    Output: 1
    Explanation:

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * nums is sorted in non-decreasing order.*/

    public int minLengthAfterRemovals(List<Integer> nums) {
        int most = 0, n = nums.size();
        Map<Integer, Integer> freq = new HashMap<>();
        for (var x : nums) {
            freq.merge(x, 1, Integer::sum);
            most = Math.max(most, freq.get(x));
        }
        return 2*most >= n ? 2*most - n : n&1;
    }


    /*2857. Count Pairs of Points With Distance k (Medium)
    You are given a 2D integer array coordinates and an integer k, where
    coordinates[i] = [xi, yi] are the coordinates of the ith point in a 2D
    plane. We define the distance between two points (x1, y1) and (x2, y2) as
    (x1 XOR x2) + (y1 XOR y2) where XOR is the bitwise XOR operation. Return the
    number of pairs (i, j) such that i < j and the distance between points i and
    j is equal to k.

    Example 1:
    Input: coordinates = [[1,2],[4,2],[1,3],[5,2]], k = 5
    Output: 2
    Explanation: We can choose the following pairs:
                 - (0,1): Because we have (1 XOR 4) + (2 XOR 2) = 5.
                 - (2,3): Because we have (1 XOR 5) + (3 XOR 2) = 5.

    Example 2:
    Input: coordinates = [[1,3],[1,3],[1,3],[1,3],[1,3]], k = 0
    Output: 10
    Explanation: Any two chosen pairs will have a distance of 0. There are 10
                 ways to choose two pairs.

    Constraints:
    * 2 <= coordinates.length <= 50000
    * 0 <= xi, yi <= 10^6
    * 0 <= k <= 100*/

    public int countPairs(List<List<Integer>> coordinates, int k) {
        int ans = 0;
        Map<Long, Integer> freq = new HashMap<>();
        for (var coordinate : coordinates) {
            long x = coordinate.get(0), y = coordinate.get(1);
            for (int v = 0; v <= k; ++v) {
                long xx = x ^ v, yy = y ^ (k-v);
                ans += freq.getOrDefault(1000001*xx + yy, 0);
            }
            freq.merge(1000001*x+y, 1, Integer::sum);
        }
        return ans;
    }


    /*2858. Minimum Edge Reversals So Every Node Is Reachable (Hard)
    There is a simple directed graph with n nodes labeled from 0 to n - 1. The
    graph would form a tree if its edges were bi-directional. You are given an
    integer n and a 2D integer array edges, where edges[i] = [ui, vi] represents
    a directed edge going from node ui to node vi. An edge reversal changes the
    direction of an edge, i.e., a directed edge going from node ui to node vi
    becomes a directed edge going from node vi to node ui. For every node i in
    the range [0, n - 1], your task is to independently calculate the minimum
    number of edge reversals required so it is possible to reach any other node
    starting from node i through a sequence of directed edges. Return an integer
    array answer, where answer[i] is the minimum number of edge reversals
    required so it is possible to reach any other node starting from node i
    through a sequence of directed edges.

    Example 1:
    Input: n = 4, edges = [[2,0],[2,1],[1,3]]
    Output: [1,1,0,2]
    Explanation: The image above shows the graph formed by the edges.
                 - For node 0: after reversing the edge [2,0], it is possible to
                   reach any other node starting from node 0. So, answer[0] = 1.
                 - For node 1: after reversing the edge [2,1], it is possible to
                   reach any other node starting from node 1. So, answer[1] = 1.
                 - For node 2: it is already possible to reach any other node
                   starting from node 2. So, answer[2] = 0.
                 - For node 3: after reversing the edges [1,3] and [2,1], it is
                   possible to reach any other node starting from node 3. So,
                   answer[3] = 2.

    Example 2:
    Input: n = 3, edges = [[1,2],[2,0]]
    Output: [2,0,1]
    Explanation: The image above shows the graph formed by the edges.
                 - For node 0: after reversing the edges [2,0] and [1,2], it is
                   possible to reach any other node starting from node 0. So,
                   answer[0] = 2.
                 - For node 1: it is already possible to reach any other node
                   starting from node 1. So, answer[1] = 0.
                 - For node 2: after reversing the edge [1, 2], it is possible
                   to reach any other node starting from node 2. So,
                   answer[2] = 1.

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ui == edges[i][0] < n
    * 0 <= vi == edges[i][1] < n
    * ui != vi
    * The input is generated such that if the edges were bi-directional, the
      graph would be a tree.*/

    private int dfs(int u, int p, Map<Integer, Integer>[] tree, int[] ans) {
        for (var v : tree[u].keySet())
            if (v != p) {
                int x = tree[u].get(v);
                ans[u] += dfs(v, u, tree, ans);
                if (x == -1) ++ans[u];
            }
        return ans[u];
    }

    public int[] minEdgeReversals(int n, int[][] edges) {
        Map<Integer, Integer>[] tree = new Map[n];
        for (int i = 0; i < n; ++i)
            tree[i] = new HashMap<>();
        for (var e : edges) {
            int u = e[0], v = e[1];
            tree[u].put(v, 1);
            tree[v].put(u, -1);
        }
        int[] ans = new int[n];
        dfs(0, -1, tree, ans);
        Stack<int[]> stk = new Stack<>();
        stk.push(new int[]{0, -1});
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            int u = elem[0], p = elem[1];
            for (var v : tree[u].keySet())
                if (v != p) {
                    ans[v] += ans[u] - ans[v] + tree[u].get(v);
                    stk.push(new int[]{v, u});
                }
        }
        return ans;
    }


    /*2859. Sum of Values at Indices With K Set Bits (Easy)
    You are given a 0-indexed integer array nums and an integer k. Return an
    integer that denotes the sum of elements in nums whose corresponding
    indices have exactly k set bits in their binary representation. The set
    bits in an integer are the 1's present when it is written in binary. For
    example, the binary representation of 21 is 10101, which has 3 set bits.

    Example 1:
    Input: nums = [5,10,1,5,2], k = 1
    Output: 13
    Explanation: The binary representation of the indices are:
                 0 = 0002
                 1 = 0012
                 2 = 0102
                 3 = 0112
                 4 = 1002
                 Indices 1, 2, and 4 have k = 1 set bits in their binary
                 representation. Hence, the answer is
                 nums[1] + nums[2] + nums[4] = 13.

    Example 2:
    Input: nums = [4,3,2,1], k = 2
    Output: 1
    Explanation: The binary representation of the indices are:
                 0 = 002
                 1 = 012
                 2 = 102
                 3 = 112
                 Only index 3 has k = 2 set bits in its binary representation.
                 Hence, the answer is nums[3] = 1.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^5
    * 0 <= k <= 10*/

    public int sumIndicesWithKSetBits(List<Integer> nums, int k) {
        int ans = 0;
        for (int i = 0; i < nums.size(); ++i)
            if (Integer.bitCount(i) == k) ans += nums.get(i);
        return ans;
    }


    /*2860. Happy Students (Medium)
    You are given a 0-indexed integer array nums of length n where n is the
    total number of students in the class. The class teacher tries to select a
    group of students so that all the students remain happy. The ith student
    will become happy if one of these two conditions is met:
    * The student is selected and the total number of selected students is
      strictly greater than nums[i].
    * The student is not selected and the total number of selected students is
      strictly less than nums[i].
    Return the number of ways to select a group of students so that everyone
    remains happy.

    Example 1:
    Input: nums = [1,1]
    Output: 2
    Explanation: The two possible ways are:
                 1. The class teacher selects no student.
                 2. The class teacher selects both students to form the group.
                 If the class teacher selects just one student to form a group
                 then the both students will not be happy. Therefore, there are
                 only two possible ways.

    Example 2:
    Input: nums = [6,0,3,3,6,7,2,7]
    Output: 3
    Explanation: The three possible ways are:
                 1. The class teacher selects the student with index = 1 to
                    form the group.
                 2. The class teacher selects the students with
                    index = 1, 2, 3, 6 to form the group.
                 The class teacher selects all the students to form the group.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] < nums.length*/

    public int countWays(List<Integer> nums) {
        int ans = 0;
        Collections.sort(nums);
        for (int i = 0, n = nums.size(); i < n; ++i) {
            if (i == 0 && nums.get(i) > 0) ++ans;
            if (nums.get(i) < i+1 && (i+1 == n || i+1 < nums.get(i+1))) ++ans;
        }
        return ans;
    }


    /*2861. Maximum Number of Alloys (Medium)
    You are the owner of a company that creates alloys using various types of
    metals. There are n different types of metals available, and you have
    access to k machines that can be used to create alloys. Each machine
    requires a specific amount of each metal type to create an alloy. For the
    ith machine to create an alloy, it needs composition[i][j] units of metal
    of type j. Initially, you have stock[i] units of metal type i, and
    purchasing one unit of metal type i costs cost[i] coins. Given integers
    n, k, budget, a 1-indexed 2D array composition, and 1-indexed arrays stock
    and cost, your goal is to maximize the number of alloys the company can
    create while staying within the budget of budget coins. All alloys must be
    created with the same machine. Return the maximum number of alloys that the
    company can create.

    Example 1:
    Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]
    Output: 2
    Explanation: It is optimal to use the 1st machine to create alloys.
                 To create 2 alloys we need to buy the:
                 - 2 units of metal of the 1st type.
                 - 2 units of metal of the 2nd type.
                 - 2 units of metal of the 3rd type.
                 In total, we need 2 * 1 + 2 * 2 + 2 * 3 = 12 coins, which is
                 smaller than or equal to budget = 15. Notice that we have 0
                 units of metal of each type and we have to buy all the
                 required units of metal. It can be proven that we can create
                 at most 2 alloys.

    Example 2:
    Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,100], cost = [1,2,3]
    Output: 5
    Explanation: It is optimal to use the 2nd machine to create alloys.
                 To create 5 alloys we need to buy:
                 - 5 units of metal of the 1st type.
                 - 5 units of metal of the 2nd type.
                 - 0 units of metal of the 3rd type.
                 In total, we need 5 * 1 + 5 * 2 + 0 * 3 = 15 coins, which is
                 smaller than or equal to budget = 15. It can be proven that we
                 can create at most 5 alloys.

    Example 3:
    Input: n = 2, k = 3, budget = 10, composition = [[2,1],[1,2],[1,1]], stock = [1,1], cost = [5,5]
    Output: 2
    Explanation: It is optimal to use the 3rd machine to create alloys.
                 To create 2 alloys we need to buy the:
                 - 1 unit of metal of the 1st type.
                 - 1 unit of metal of the 2nd type.
                 In total, we need 1 * 5 + 1 * 5 = 10 coins, which is smaller
                 than or equal to budget = 10. It can be proven that we can
                 create at most 2 alloys.

    Constraints:
    * 1 <= n, k <= 100
    * 0 <= budget <= 10^8
    * composition.length == k
    * composition[i].length == n
    * 1 <= composition[i][j] <= 100
    * stock.length == cost.length == n
    * 0 <= stock[i] <= 10^8
    * 1 <= cost[i] <= 100*/

    public int maxNumberOfAlloys(int n, int k, int budget, List<List<Integer>> composition, List<Integer> stock, List<Integer> cost) {
        int ans = 0;
        for (var comp : composition) {
            long lo = 0, hi = (long) 2e8;
            while (lo < hi) {
                long mid = lo + (hi-lo+1)/2, spend = 0;
                for (int i = 0; i < n; ++i)
                    spend += Math.max(0l, cost.get(i)*(mid*comp.get(i) - stock.get(i)));
                if (spend <= budget) lo = mid;
                else hi = mid-1;
            }
            ans = Math.max(ans, (int) lo);
        }
        return ans;
    }


    /*2862. Maximum Element-Sum of a Complete Subset of Indices (Hard)
    You are given a 1-indexed array nums of n integers. A set of numbers is
    complete if the product of every pair of its elements is a perfect square.
    For a subset of the indices set {1, 2, ..., n} represented as
    {i1, i2, ..., ik}, we define its element-sum as:
    nums[i1] + nums[i2] + ... + nums[ik]. Return the maximum element-sum of a
    complete subset of the indices set {1, 2, ..., n}. A perfect square is a
    number that can be expressed as the product of an integer by itself.

    Example 1:
    Input: nums = [8,7,3,5,7,2,4,9]
    Output: 16
    Explanation: Apart from the subsets consisting of a single index, there are
                 two other complete subsets of indices: {1,4} and {2,8}.
                 - The sum of the elements corresponding to indices 1 and 4 is
                   equal to nums[1] + nums[4] = 8 + 5 = 13.
                 - The sum of the elements corresponding to indices 2 and 8 is
                   equal to nums[2] + nums[8] = 7 + 9 = 16.
                 Hence, the maximum element-sum of a complete subset of indices
                 is 16.

    Example 2:
    Input: nums = [5,10,3,10,1,13,7,9,4]
    Output: 19
    Explanation: Apart from the subsets consisting of a single index, there are
                 four other complete subsets of indices:
                 {1,4}, {1,9}, {2,8}, {4,9}, and {1,4,9}.
                 - The sum of the elements corresponding to indices 1 and 4 is
                   equal to nums[1] + nums[4] = 5 + 10 = 15.
                 - The sum of the elements corresponding to indices 1 and 9 is
                   equal to nums[1] + nums[9] = 5 + 4 = 9.
                 - The sum of the elements corresponding to indices 2 and 8 is
                   equal to nums[2] + nums[8] = 10 + 9 = 19.
                 - The sum of the elements corresponding to indices 4 and 9 is
                   equal to nums[4] + nums[9] = 10 + 4 = 14.
                 - The sum of the elements corresponding to indices 1, 4, and 9
                   is equal to nums[1] + nums[4] + nums[9] = 5 + 10 + 4 = 19.
                 Hence, the maximum element-sum of a complete subset of indices
                 is 19.

    Constraints:
    * 1 <= n == nums.length <= 10^4
    * 1 <= nums[i] <= 10^9*/

    public long maximumSum(List<Integer> nums) {
        long ans = 0;
        Map<Integer, Long> mp = new HashMap();
        for (int i = 0; i < nums.size(); ++i) {
            int k = i+1;
            for (int v = 2; v*v <= k; ++v)
                while (k % (v*v) == 0) k /= v*v;
            mp.merge(k, (long) nums.get(i), Long::sum);
            ans = Math.max(ans, mp.get(k));
        }
        return ans;
    }


    /*2863. Maximum Length of Semi-Decreasing Subarrays (Medium)
    You are given an integer array nums. Return the length of the longest semi-
    decreasing subarray of nums, and 0 if there are no such subarrays. A
    subarray is a contiguous non-empty sequence of elements within an array. A
    non-empty array is semi-decreasing if its first element is strictly greater
    than its last element.

    Example 1:
    Input: nums = [7,6,5,4,3,2,1,6,10,11]
    Output: 8
    Explanation: Take the subarray [7,6,5,4,3,2,1,6]. The first element is 7 and
                 the last one is 6 so the condition is met. Hence, the answer
                 would be the length of the subarray or 8. It can be shown that
                 there aren't any subarrays with the given condition with a
                 length greater than 8.

    Example 2:
    Input: nums = [57,55,50,60,61,58,63,59,64,60,63]
    Output: 6
    Explanation: Take the subarray [61,58,63,59,64,60]. The first element is 61
                 and the last one is 60 so the condition is met. Hence, the
                 answer would be the length of the subarray or 6. It can be
                 shown that there aren't any subarrays with the given condition
                 with a length greater than 6.

    Example 3:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: Since there are no semi-decreasing subarrays in the given
                 array, the answer is 0.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    public int maxSubarrayLength(int[] nums) {
        Stack<Integer> stk = new Stack();
        for (int i = 0; i < nums.length; ++i)
            if (stk.isEmpty() || nums[stk.peek()] < nums[i])
                stk.push(i);
        int ans = 0;
        for (int i = nums.length-1; i >= 0; --i)
            while (!stk.isEmpty() && nums[stk.peek()] > nums[i])
                ans = Math.max(ans, i - stk.pop() + 1);
        return ans;
    }


    /*2864. Maximum Odd Binary Number (Easy)
    You are given a binary string s that contains at least one '1'. You have to
    rearrange the bits in such a way that the resulting binary number is the
    maximum odd binary number that can be created from this combination. Return
    a string representing the maximum odd binary number that can be created
    from the given combination. Note that the resulting string can have leading
    zeros.

    Example 1:
    Input: s = "010"
    Output: "001"
    Explanation: Because there is just one '1', it must be in the last position.
                 So the answer is "001".

    Example 2:
    Input: s = "0101"
    Output: "1001"
    Explanation: One of the '1's must be in the last position. The maximum
                 number that can be made with the remaining digits is "100". So
                 the answer is "1001".

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of '0' and '1'.
    * s contains at least one '1'.*/

    public String maximumOddBinaryNumber(String s) {
        int ones = (int) s.chars().filter(ch -> ch == '1').count();
        return "1".repeat(ones-1) + "0".repeat(s.length()-ones) + "1";
    }


    /*2865. Beautiful Towers I (Medium)
    You are given a 0-indexed array maxHeights of n integers. You are tasked
    with building n towers in the coordinate line. The ith tower is built at
    coordinate i and has a height of heights[i]. A configuration of towers is
    beautiful if the following conditions hold:
    * 1 <= heights[i] <= maxHeights[i]
    * heights is a mountain array.
    Array heights is a mountain if there exists an index i such that:
    * For all 0 < j <= i, heights[j - 1] <= heights[j]
    * For all i <= k < n - 1, heights[k + 1] <= heights[k]
    Return the maximum possible sum of heights of a beautiful configuration of
    towers.

    Example 1:
    Input: maxHeights = [5,3,4,1,1]
    Output: 13
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [5,3,3,1,1]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 0.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 13.

    Example 2:
    Input: maxHeights = [6,5,3,9,2,7]
    Output: 22
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [3,3,3,9,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 3.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 22.

    Example 3:
    Input: maxHeights = [3,2,5,5,2,3]
    Output: 18
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [2,2,5,5,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 2.
                 Note that, for this configuration, i = 3 can also be
                 considered a peak. It can be shown that there exists no other
                 beautiful configuration with a sum of heights greater than 18.

    Constraints:
    * 1 <= n == maxHeights <= 10^3
    * 1 <= maxHeights[i] <= 10^9*/

    public long maximumSumOfHeights(List<Integer> maxHeights) {
        int n = maxHeights.size();
        long[] prefix = new long[n];
        Stack<Integer> stk = new Stack(); stk.push(-1);
        long val = 0;
        for (int i = 0; i < n; ++i) {
            while (stk.size() > 1 && maxHeights.get(stk.peek()) >= maxHeights.get(i)) {
                var ii = stk.pop();
                val -= (long) (ii - stk.peek())*maxHeights.get(ii);
            }
            val += (long) (i - stk.peek())*maxHeights.get(i);
            prefix[i] = val;
            stk.add(i);
        }
        long ans = 0; val = 0;
        stk.clear(); stk.push(n);
        for (int i = n-1; i >= 0; --i) {
            while (stk.size() > 1 && maxHeights.get(stk.peek()) >= maxHeights.get(i)) {
                var ii = stk.pop();
                val -= (long) (stk.peek() - ii)*maxHeights.get(ii);
            }
            val += (long) (stk.peek() - i)*maxHeights.get(i);
            stk.push(i);
            ans = Math.max(ans, prefix[i] + val - maxHeights.get(i));
        }
        return ans;
    }


    /*2866. Beautiful Towers II (Medium)
    You are given a 0-indexed array maxHeights of n integers. You are tasked
    with building n towers in the coordinate line. The ith tower is built at
    coordinate i and has a height of heights[i]. A configuration of towers is
    beautiful if the following conditions hold:
    * 1 <= heights[i] <= maxHeights[i]
    * heights is a mountain array.
    Array heights is a mountain if there exists an index i such that:
    * For all 0 < j <= i, heights[j - 1] <= heights[j]
    * For all i <= k < n - 1, heights[k + 1] <= heights[k]
    Return the maximum possible sum of heights of a beautiful configuration of
    towers.

    Example 1:
    Input: maxHeights = [5,3,4,1,1]
    Output: 13
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [5,3,3,1,1]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 0.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 13.

    Example 2:
    Input: maxHeights = [6,5,3,9,2,7]
    Output: 22
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [3,3,3,9,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 3.
                 It can be shown that there exists no other beautiful
                 configuration with a sum of heights greater than 22.

    Example 3:
    Input: maxHeights = [3,2,5,5,2,3]
    Output: 18
    Explanation: One beautiful configuration with a maximum sum is
                 heights = [2,2,5,5,2,2]. This configuration is beautiful since:
                 - 1 <= heights[i] <= maxHeights[i]
                 - heights is a mountain of peak i = 2.
                 Note that, for this configuration, i = 3 can also be
                 considered a peak. It can be shown that there exists no other
                 beautiful configuration with a sum of heights greater than 18.

    Constraints:
    * 1 <= n == maxHeights <= 10^5
    * 1 <= maxHeights[i] <= 10^9*/

    public long maximumSumOfHeights(List<Integer> maxHeights) {
        int n = maxHeights.size();
        long[] prefix = new long[n];
        Stack<Integer> stk = new Stack(); stk.push(-1);
        long val = 0;
        for (int i = 0; i < n; ++i) {
            while (stk.size() > 1 && maxHeights.get(stk.peek()) >= maxHeights.get(i)) {
                var ii = stk.pop();
                val -= (long) (ii - stk.peek())*maxHeights.get(ii);
            }
            val += (long) (i - stk.peek())*maxHeights.get(i);
            prefix[i] = val;
            stk.add(i);
        }
        long ans = 0; val = 0;
        stk.clear(); stk.push(n);
        for (int i = n-1; i >= 0; --i) {
            while (stk.size() > 1 && maxHeights.get(stk.peek()) >= maxHeights.get(i)) {
                var ii = stk.pop();
                val -= (long) (stk.peek() - ii)*maxHeights.get(ii);
            }
            val += (long) (stk.peek() - i)*maxHeights.get(i);
            stk.push(i);
            ans = Math.max(ans, prefix[i] + val - maxHeights.get(i));
        }
        return ans;
    }


    /*2867. Count Valid Paths in a Tree (Hard)
    There is an undirected tree with n nodes labeled from 1 to n. You are given
    the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi
    in the tree. Return the number of valid paths in the tree. A path (a, b) is
    valid if there exists exactly one prime number among the node labels in the
    path from a to b.

    Note that:
    * The path (a, b) is a sequence of distinct nodes starting with node a and
      ending with node b such that every two adjacent nodes in the sequence
      share an edge in the tree.
    * Path (a, b) and path (b, a) are considered the same and counted only once.

    Example 1:
    Input: n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]
    Output: 4
    Explanation: The pairs with exactly one prime number on the path between
                 them are:
                 - (1, 2) since the path from 1 to 2 contains prime number 2.
                 - (1, 3) since the path from 1 to 3 contains prime number 3.
                 - (1, 4) since the path from 1 to 4 contains prime number 2.
                 - (2, 4) since the path from 2 to 4 contains prime number 2.
                 It can be shown that there are only 4 valid paths.

    Example 2:
    Input: n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]
    Output: 6
    Explanation: The pairs with exactly one prime number on the path between
                 them are:
                 - (1, 2) since the path from 1 to 2 contains prime number 2.
                 - (1, 3) since the path from 1 to 3 contains prime number 3.
                 - (1, 4) since the path from 1 to 4 contains prime number 2.
                 - (1, 6) since the path from 1 to 6 contains prime number 3.
                 - (2, 4) since the path from 2 to 4 contains prime number 2.
                 - (3, 6) since the path from 3 to 6 contains prime number 3.
                 It can be shown that there are only 6 valid paths.

    Constraints:
    * 1 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 1 <= ui, vi <= n
    * The input is generated such that edges represent a valid tree.*/

    public long countPaths(int n, int[][] edges) {
        boolean[] prime = new boolean[n+1];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int x = 2; x <= Math.sqrt(n); ++x)
            if (prime[x])
                for (int xx = x*x; xx <= n; xx += x)
                    prime[xx] = false;
        List<Integer>[] tree = new ArrayList[n+1];
        for (int i = 0; i <= n; ++i)
            tree[i] = new ArrayList();
        for (var e : edges) {
            tree[e[0]].add(e[1]);
            tree[e[1]].add(e[0]);
        }
        int[] mp = new int[n+1];
        for (int x = 1; x <= n; ++x) mp[x] = x;
        for (int x = 1; x <= n; ++x)
            if (!prime[x] && mp[x] == x) {
                Stack<int[]> stk = new Stack(); stk.push(new int[]{x, -1});
                while (!stk.isEmpty()) {
                    var elem = stk.pop();
                    int u = elem[0], p = elem[1];
                    for (var v : tree[u])
                        if (v != p && !prime[v]) {
                            mp[v] = x;
                            stk.push(new int[]{v, u});
                        }
                }
            }
        Map<Integer, Integer> freq = new HashMap();
        for (var x : mp) freq.merge(x, 1, Integer::sum);
        long ans = 0;
        for (int u = 2; u <= n; ++u)
            if (prime[u]) {
                long cand = 0, prefix = 1;
                for (var v : tree[u])
                    if (!prime[v]) {
                        cand += prefix * freq.get(mp[v]);
                        prefix += freq.get(mp[v]);
                    }
                ans += cand;
            }
        return ans;
    }


    /*2869. Minimum Operations to Collect Elements (Easy)
    You are given an array nums of positive integers and an integer k. In one
    operation, you can remove the last element of the array and add it to your
    collection. Return the minimum number of operations needed to collect
    elements 1, 2, ..., k.

    Example 1:
    Input: nums = [3,1,5,4,2], k = 2
    Output: 4
    Explanation: After 4 operations, we collect elements 2, 4, 5, and 1, in
                 this order. Our collection contains elements 1 and 2. Hence,
                 the answer is 4.

    Example 2:
    Input: nums = [3,1,5,4,2], k = 5
    Output: 5
    Explanation: After 5 operations, we collect elements 2, 4, 5, 1, and 3, in
                 this order. Our collection contains elements 1 through 5.
                 Hence, the answer is 5.

    Example 3:
    Input: nums = [3,2,5,3,1], k = 3
    Output: 4
    Explanation: After 4 operations, we collect elements 1, 3, 5, and 2, in
                 this order. Our collection contains elements 1 through 3.
                 Hence, the answer is 4.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= nums.length
    * 1 <= k <= nums.length
    * The input is generated such that you can collect elements 1, 2, ..., k.*/

    public int minOperations(List<Integer> nums, int k) {
        Long left = (1l<<k) - 1;
        for (int n = nums.size(), i = n-1; i >= 0; --i) {
            if (nums.get(i) <= k && (left & 1l<<nums.get(i)-1) > 0) left ^= 1l<<nums.get(i)-1;
            if (left == 0) return n-i;
        }
        return -1;
    }


    /*2870. Minimum Number of Operations to Make Array Empty (Medium)
    You are given a 0-indexed array nums consisting of positive integers. There
    are two types of operations that you can apply on the array any number of
    times:
    * Choose two elements with equal values and delete them from the array.
    * Choose three elements with equal values and delete them from the array.
    Return the minimum number of operations required to make the array empty,
    or -1 if it is not possible.

    Example 1:
    Input: nums = [2,3,3,2,2,4,2,3,4]
    Output: 4
    Explanation: We can apply the following operations to make the array empty:
                 - Apply the first operation on the elements at indices 0 and 3.
                   The resulting array is nums = [3,3,2,4,2,3,4].
                 - Apply the first operation on the elements at indices 2 and 4.
                   The resulting array is nums = [3,3,4,3,4].
                 - Apply the second operation on the elements at indices 0, 1,
                   and 3. The resulting array is nums = [4,4].
                 - Apply the first operation on the elements at indices 0 and 1.
                   The resulting array is nums = [].
                 It can be shown that we cannot make the array empty in less
                 than 4 operations.

    Example 2:
    Input: nums = [2,1,2,2,3,3]
    Output: -1
    Explanation: It is impossible to empty the array.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    public int minOperations(int[] nums) {
        Map<Integer, Integer> freq = new HashMap();
        for (var x : nums) freq.merge(x, 1, Integer::sum);
        int ans = 0;
        for (var v : freq.values()) {
            if (v == 1) return -1;
            ans += (v + 2)/3;
        }
        return ans;
    }


    /*2871. Split Array Into Maximum Number of Subarrays (Medium)
    You are given an array nums consisting of non-negative integers. We define
    the score of subarray nums[l..r] such that l <= r as
    nums[l] AND nums[l + 1] AND ... AND nums[r] where AND is the bitwise AND
    operation. Consider splitting the array into one or more subarrays such
    that the following conditions are satisfied:
    * Each element of the array belongs to exactly one subarray.
    * The sum of scores of the subarrays is the minimum possible.
    Return the maximum number of subarrays in a split that satisfies the
    conditions above. A subarray is a contiguous part of an array.

    Example 1:
    Input: nums = [1,0,2,0,1,2]
    Output: 3
    Explanation: We can split the array into the following subarrays:
                 - [1,0]. The score of this subarray is 1 AND 0 = 0.
                 - [2,0]. The score of this subarray is 2 AND 0 = 0.
                 - [1,2]. The score of this subarray is 1 AND 2 = 0.
                 The sum of scores is 0 + 0 + 0 = 0, which is the minimum
                 possible score that we can obtain. It can be shown that we
                 cannot split the array into more than 3 subarrays with a total
                 score of 0. So we return 3.

    Example 2:
    Input: nums = [5,7,1,3]
    Output: 1
    Explanation: We can split the array into one subarray: [5,7,1,3] with a
                 score of 1, which is the minimum possible score that we can
                 obtain. It can be shown that we cannot split the array into
                 more than 1 subarray with a total score of 1. So we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6*/

    public int maxSubarrays(int[] nums) {
        int ans = 0, prefix = -1;
        for (var x : nums) {
            prefix &= x;
            if (prefix == 0) {
                ++ans;
                prefix = -1;
            }
        }
        return Math.max(1, ans);
    }


    /*2872. Maximum Number of K-Divisible Components (Hard)
    There is an undirected tree with n nodes labeled from 0 to n - 1. You are
    given the integer n and a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. You are also given a 0-indexed integer array values of length
    n, where values[i] is the value associated with the ith node, and an
    integer k. A valid split of the tree is obtained by removing any set of
    edges, possibly empty, from the tree such that the resulting components all
    have values that are divisible by k, where the value of a connected
    component is the sum of the values of its nodes. Return the maximum number
    of components in any valid split.

    Example 1:
    Input: n = 5, edges = [[0,2],[1,2],[1,3],[2,4]], values = [1,8,1,4,4], k = 6
    Output: 2
    Explanation: We remove the edge connecting node 1 with 2. The resulting
                 split is valid because:
                 - The value of the component containing nodes 1 and 3 is
                   values[1] + values[3] = 12.
                 - The value of the component containing nodes 0, 2, and 4 is
                   values[0] + values[2] + values[4] = 6.
                 It can be shown that no other valid split has more than 2
                 connected components.

    Example 2:
    Input: n = 7, edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [3,0,6,1,5,2,1], k = 3
    Output: 3
    Explanation: We remove the edge connecting node 0 with 2, and the edge
                 connecting node 0 with 1. The resulting split is valid because:
                 - The value of the component containing node 0 is values[0] = 3.
                 - The value of the component containing nodes 2, 5, and 6 is
                   values[2] + values[5] + values[6] = 9.
                 - The value of the component containing nodes 1, 3, and 4 is
                   values[1] + values[3] + values[4] = 6.
                 It can be shown that no other valid split has more than 3
                 connected components.

    Constraints:
    * 1 <= n <= 3 * 10^4
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * values.length == n
    * 0 <= values[i] <= 10^9
    * 1 <= k <= 10^9
    * Sum of values is divisible by k.
    * The input is generated such that edges represents a valid tree.*/

    private long fn(int u, int p, List<Integer>[] tree, int[] values, int k) {
        for (var v : tree[u])
            if (v != p) values[u] = (int) ((values[u] + fn(v, u, tree, values, k)) % k);
        return values[u];
    }

    public int maxKDivisibleComponents(int n, int[][] edges, int[] values, int k) {
        List<Integer>[] tree = new ArrayList[n];
        Arrays.setAll(tree, x -> new ArrayList());
        for (var e : edges) {
            tree[e[0]].add(e[1]);
            tree[e[1]].add(e[0]);
        }
        fn(0, -1, tree, values, k);
        return (int) IntStream.of(values).filter(x -> x % k == 0).count();
    }


    /*2873. Maximum Value of an Ordered Triplet I (Easy)
    You are given a 0-indexed integer array nums. Return the maximum value over
    all triplets of indices (i, j, k) such that i < j < k. If all such triplets
    have a negative value, return 0. The value of a triplet of indices (i, j, k)
    is equal to (nums[i] - nums[j]) * nums[k].

    Example 1:
    Input: nums = [12,6,1,2,7]
    Output: 77
    Explanation: The value of the triplet (0, 2, 4) is
                 (nums[0] - nums[2]) * nums[4] = 77. It can be shown that there
                 are no ordered triplets of indices with a value greater than
                 77.

    Example 2:
    Input: nums = [1,10,3,4,19]
    Output: 133
    Explanation: The value of the triplet (1, 2, 4) is
                 (nums[1] - nums[2]) * nums[4] = 133. It can be shown that
                 there are no ordered triplets of indices with a value greater
                 than 133.

    Example 3:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: The only ordered triplet of indices (0, 1, 2) has a negative
                 value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer
                 would be 0.

    Constraints:
    * 3 <= nums.length <= 100
    * 1 <= nums[i] <= 10^6*/

    public long maximumTripletValue(int[] nums) {
        long ans = 0;
        int diff = 0, prefix = 0;
        for (var x : nums) {
            ans = Math.max(ans, (long) x * diff);
            diff = Math.max(diff, prefix - x);
            prefix = Math.max(prefix, x);
        }
        return ans;
    }


    /*2874. Maximum Value of an Ordered Triplet II (Medium)
    You are given a 0-indexed integer array nums. Return the maximum value over
    all triplets of indices (i, j, k) such that i < j < k. If all such triplets
    have a negative value, return 0. The value of a triplet of indices (i, j, k)
    is equal to (nums[i] - nums[j]) * nums[k].

    Example 1:
    Input: nums = [12,6,1,2,7]
    Output: 77
    Explanation: The value of the triplet (0, 2, 4) is
                 (nums[0] - nums[2]) * nums[4] = 77. It can be shown that there
                 are no ordered triplets of indices with a value greater than
                 77.

    Example 2:
    Input: nums = [1,10,3,4,19]
    Output: 133
    Explanation: The value of the triplet (1, 2, 4) is
                 (nums[1] - nums[2]) * nums[4] = 133. It can be shown that
                 there are no ordered triplets of indices with a value greater
                 than 133.

    Example 3:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: The only ordered triplet of indices (0, 1, 2) has a negative
                 value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer
                 would be 0.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    public long maximumTripletValue(int[] nums) {
        long ans = 0;
        int diff = 0, prefix = 0;
        for (var x : nums) {
            ans = Math.max(ans, (long) x * diff);
            diff = Math.max(diff, prefix - x);
            prefix = Math.max(prefix, x);
        }
        return ans;
    }


    /*2875. Minimum Size Subarray in Infinite Array (Medium)
    You are given a 0-indexed array nums and an integer target. A 0-indexed
    array infinite_nums is generated by infinitely appending the elements of
    nums to itself. Return the length of the shortest subarray of the array
    infinite_nums with a sum equal to target. If there is no such subarray
    return -1.

    Example 1:
    Input: nums = [1,2,3], target = 5
    Output: 2
    Explanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...]. The
                 subarray in the range [1,2], has the sum equal to target = 5
                 and length = 2. It can be proven that 2 is the shortest length
                 of a subarray with sum equal to target = 5.

    Example 2:
    Input: nums = [1,1,1,2,3], target = 4
    Output: 2
    Explanation: In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
                 The subarray in the range [4,5], has the sum equal to
                 target = 4 and length = 2. It can be proven that 2 is the
                 shortest length of a subarray with sum equal to target = 4.

    Example 3:
    Input: nums = [2,4,6,8], target = 3
    Output: -1
    Explanation: In this example infinite_nums = [2,4,6,8,2,4,6,8,...]. It can
                 be proven that there is no subarray with sum equal to
                 target = 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= target <= 10^9*/

    public int minSizeSubarray(int[] nums, int target) {
        long total = 0;
        for (var x : nums) total += x;
        int ans = (int) (target / total) * nums.length, cand = Integer.MAX_VALUE;
        target %= total;
        for (int i = 0, ii = 0, n = nums.length; i < 2*n; ++i) {
            target -= nums[i % n];
            for (; target < 0; ++ii)
                target += nums[ii % n];
            if (target == 0) cand = Math.min(cand, i-ii+1);
        }
        return cand < Integer.MAX_VALUE ? ans + cand : -1;
    }


    /*2876. Count Visited Nodes in a Directed Graph (Hard)
    There is a directed graph consisting of n nodes numbered from 0 to n - 1
    and n directed edges. You are given a 0-indexed array edges where edges[i]
    indicates that there is an edge from node i to node edges[i]. Consider the
    following process on the graph:
    * You start from a node x and keep visiting other nodes through edges until
      you reach a node that you have already visited before on this same
      process.
    Return an array answer where answer[i] is the number of different nodes
    that you will visit if you perform the process starting from node i.

    Example 1:
    Input: edges = [1,2,0,0]
    Output: [3,3,3,4]
    Explanation: We perform the process starting from each node in the
                 following way:
                 - Starting from node 0, we visit the nodes 0 -> 1 -> 2 -> 0.
                   The number of different nodes we visit is 3.
                 - Starting from node 1, we visit the nodes 1 -> 2 -> 0 -> 1.
                   The number of different nodes we visit is 3.
                 - Starting from node 2, we visit the nodes 2 -> 0 -> 1 -> 2.
                   The number of different nodes we visit is 3.
                 - Starting from node 3, we visit the nodes 3 -> 0 -> 1 -> 2 ->
                   0. The number of different nodes we visit is 4.

    Example 2:
    Input: edges = [1,2,3,4,0]
    Output: [5,5,5,5,5]
    Explanation: Starting from any node we can visit every node in the graph in
                 the process.

    Constraints:
    * n == edges.length
    * 2 <= n <= 10^5
    * 0 <= edges[i] <= n - 1
    * edges[i] != i*/

    public int[] countVisitedNodes(List<Integer> edges) {
        int n = edges.size();
        int[] ans = new int[n];
        for (int x = 0; x < n; ++x)
            if (ans[x] == 0) {
                Stack<Integer> stk = new Stack();
                int v = 0, k = x;
                for (; ans[k] == 0; k = edges.get(k)) {
                    ans[k] = --v;
                    stk.push(k);
                }
                for (int pp = k; !stk.isEmpty(); ) {
                    var kk = stk.pop();
                    if (ans[k] > 0) ans[kk] = ans[pp] + 1;
                    else ans[kk] = ans[k] - v + 1;
                    pp = kk;
                }
            }
        return ans;
    }


    /*2892. Minimizing Array After Replacing Pairs With Their Product (Medium)
    Given an integer array nums and an integer k, you can perform the following
    operation on the array any number of times:
    * Select two adjacent elements of the array like x and y, such that
      x * y <= k, and replace both of them with a single element with value
      x * y (e.g. in one operation the array [1, 2, 2, 3] with k = 5 can become
      [1, 4, 3] or [2, 2, 3], but can't become [1, 2, 6]).
    Return the minimum possible length of nums after any number of operations.

    Example 1:
    Input: nums = [2,3,3,7,3,5], k = 20
    Output: 3
    Explanation: We perform these operations:
                 1. [2,3,3,7,3,5] -> [6,3,7,3,5]
                 2. [6,3,7,3,5] -> [18,7,3,5]
                 3. [18,7,3,5] -> [18,7,15]
                 It can be shown that 3 is the minimum length possible to
                 achieve with the given operation.

    Example 2:
    Input: nums = [3,3,3,3], k = 6
    Output: 4
    Explanation: We can't perform any operations since the product of every two
                 adjacent elements is greater than 6. Hence, the answer is 4.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 1 <= k <= 10^9*/

    public int minArrayLength(int[] nums, int k) {
        int ans = 0;
        long prefix = 0;
        for (var x : nums)
            if (x == 0) return 1;
            else if (prefix > 0 && prefix*x <= k) prefix *= x;
            else {
                ++ans;
                prefix = x;
            }
        return ans;
    }


    /*2894. Divisible and Non-divisible Sums Difference (Easy)
    You are given positive integers n and m. Define two integers, num1 and num2,
    as follows:
    * num1: The sum of all integers in the range [1, n] that are not divisible
      by m.
    * num2: The sum of all integers in the range [1, n] that are divisible by m.
    Return the integer num1 - num2.

    Example 1:
    Input: n = 10, m = 3
    Output: 19
    Explanation: In the given example:
                 - Integers in the range [1, 10] that are not divisible by 3
                   are [1,2,4,5,7,8,10], num1 is the sum of those integers = 37.
                 - Integers in the range [1, 10] that are divisible by 3 are
                   [3,6,9], num2 is the sum of those integers = 18.
                 We return 37 - 18 = 19 as the answer.

    Example 2:
    Input: n = 5, m = 6
    Output: 15
    Explanation: In the given example:
                 - Integers in the range [1, 5] that are not divisible by 6 are
                   [1,2,3,4,5], num1 is the sum of those integers = 15.
                 - Integers in the range [1, 5] that are divisible by 6 are [],
                   num2 is the sum of those integers = 0.
                 We return 15 - 0 = 15 as the answer.

    Example 3:
    Input: n = 5, m = 1
    Output: -15
    Explanation: In the given example:
                 - Integers in the range [1, 5] that are not divisible by 1 are
                   [], num1 is the sum of those integers = 0.
                 - Integers in the range [1, 5] that are divisible by 1 are
                   [1,2,3,4,5], num2 is the sum of those integers = 15.
                 We return 0 - 15 = -15 as the answer.

    Constraints: 1 <= n, m <= 1000*/

    public int differenceOfSums(int n, int m) {
        return n*(n+1)/2 - (n/m)*(n/m+1)*m;
    }


    /*2895. Minimum Processing Time (Medium)
    You have n processors each having 4 cores and n * 4 tasks that need to be
    executed such that each core should perform only one task. Given a
    0-indexed integer array processorTime representing the time at which each
    processor becomes available for the first time and a 0-indexed integer
    array tasks representing the time it takes to execute each task, return the
    minimum time when all of the tasks have been executed by the processors.
    Note: Each core executes the task independently of the others.

    Example 1:
    Input: processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]
    Output: 16
    Explanation: It's optimal to assign the tasks at indexes 4, 5, 6, 7 to the
                 first processor which becomes available at time = 8, and the
                 tasks at indexes 0, 1, 2, 3 to the second processor which
                 becomes available at time = 10. Time taken by the first
                 processor to finish execution of all tasks =
                 max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16. Time taken by the second
                 processor to finish execution of all tasks =
                 max(10 + 2, 10 + 2, 10 + 3, 10 + 1) = 13. Hence, it can be
                 shown that the minimum time taken to execute all the tasks is
                 16.

    Example 2:
    Input: processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]
    Output: 23
    Explanation: It's optimal to assign the tasks at indexes 1, 4, 5, 6 to the
                 first processor which becomes available at time = 10, and the
                 tasks at indexes 0, 2, 3, 7 to the second processor which
                 becomes available at time = 20. Time taken by the first
                 processor to finish execution of all tasks =
                 max(10 + 3, 10 + 5, 10 + 8, 10 + 4) = 18. Time taken by the
                 second processor to finish execution of all tasks =
                 max(20 + 2, 20 + 1, 20 + 2, 20 + 3) = 23. Hence, it can be
                 shown that the minimum time taken to execute all the tasks is
                 23.

    Constraints:
    * 1 <= n == processorTime.length <= 25000
    * 1 <= tasks.length <= 10^5
    * 0 <= processorTime[i] <= 10^9
    * 1 <= tasks[i] <= 10^9
    * tasks.length == 4 * n*/

    public int minProcessingTime(List<Integer> processorTime, List<Integer> tasks) {
        Collections.sort(processorTime);
        Collections.sort(tasks, (a, b) -> Integer.compare(b, a));
        int ans = 0;
        for (int i = 0; i < tasks.size(); ++i)
            ans = Math.max(ans, processorTime.get(i/4) + tasks.get(i));
        return ans;
    }


    /*2896. Apply Operations to Make Two Strings Equal (Medium)
    You are given two 0-indexed binary strings s1 and s2, both of length n, and
    a positive integer x. You can perform any of the following operations on
    the string s1 any number of times:
    * Choose two indices i and j, and flip both s1[i] and s1[j]. The cost of
      this operation is x.
    * Choose an index i such that i < n - 1 and flip both s1[i] and s1[i + 1].
      The cost of this operation is 1.
    Return the minimum cost needed to make the strings s1 and s2 equal, or
    return -1 if it is impossible. Note that flipping a character means
    changing it from 0 to 1 or vice-versa.

    Example 1:
    Input: s1 = "1100011000", s2 = "0101001010", x = 2
    Output: 4
    Explanation: We can do the following operations:
                 - Choose i = 3 and apply the second operation. The resulting
                   string is s1 = "1101111000".
                 - Choose i = 4 and apply the second operation. The resulting
                   string is s1 = "1101001000".
                 - Choose i = 0 and j = 8 and apply the first operation. The
                   resulting string is s1 = "0101001010" = s2.
                 The total cost is 1 + 1 + 2 = 4. It can be shown that it is
                 the minimum cost possible.

    Example 2:
    Input: s1 = "10110", s2 = "00011", x = 4
    Output: -1
    Explanation: It is not possible to make the two strings equal.

    Constraints:
    * n == s1.length == s2.length
    * 1 <= n, x <= 500
    * s1 and s2 consist only of the characters '0' and '1'.*/

    public int minOperations(String s1, String s2, int x) {
        List<Integer> diff = new ArrayList();
        for (int i = 0; i < s1.length(); ++i)
            if (s1.charAt(i) != s2.charAt(i)) diff.add(i);
        int n = diff.size();
        if (n%2 == 1) return -1;
        double f0 = 0, f1 = 0;
        for (int i = 0; i < n; ++i) {
            double f2 = f1 + x/2.0;
            if (i > 0) f2 = Math.min(f2, f0 + diff.get(i) - diff.get(i-1));
            f0 = f1;
            f1 = f2;
        }
        return (int) f1;
    }


    /*2897. Apply Operations on Array to Maximize Sum of Squares (Hard)
    You are given a 0-indexed integer array nums and a positive integer k. You
    can do the following operation on the array any number of times:
    * Choose any two distinct indices i and j and simultaneously update the
      values of nums[i] to (nums[i] AND nums[j]) and nums[j] to
      (nums[i] OR nums[j]). Here, OR denotes the bitwise OR operation, and AND
      denotes the bitwise AND operation.
    You have to choose k elements from the final array and calculate the sum of
    their squares. Return the maximum sum of squares you can achieve. Since the
    answer can be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,6,5,8], k = 2
    Output: 261
    Explanation: We can do the following operations on the array:
                 - Choose i = 0 and j = 3, then change nums[0] to (2 AND 8) = 0
                   and nums[3] to (2 OR 8) = 10. The resulting array is
                   nums = [0,6,5,10].
                 - Choose i = 2 and j = 3, then change nums[2] to (5 AND 10) = 0
                   and nums[3] to (5 OR 10) = 15. The resulting array is
                   nums = [0,6,0,15].
                 We can choose the elements 15 and 6 from the final array. The
                 sum of squares is 152 + 62 = 261. It can be shown that this is
                 the maximum value we can get.

    Example 2:
    Input: nums = [4,5,4,7], k = 3
    Output: 90
    Explanation: We do not need to apply any operations. We can choose the
                 elements 7, 5, and 4 with a sum of squares: 72 + 52 + 42 = 90.
                 It can be shown that this is the maximum value we can get.

    Constraints:
    * 1 <= k <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public int maxSum(List<Integer> nums, int k) {
        int[] freq = new int[32];
        for (var x : nums)
            for (int i = 0; i < 32; ++i)
                if ((x & 1<<i) > 0) ++freq[i];
        long ans = 0;
        while (k-- > 0) {
            long val = 0;
            for (int i = 31; i >= 0; --i)
                if (freq[i] > 0) {
                    --freq[i];
                    val ^= 1<<i;
                }
            ans = (ans + val*val) % 1_000_000_007;
        }
        return (int) ans;
    }


    /*2898. Maximum Linear Stock Score (Medium)
    Given a 1-indexed integer array prices, where prices[i] is the price of a
    particular stock on the ith day, your task is to select some of the elements
    of prices such that your selection is linear. A selection indexes, where
    indexes is a 1-indexed integer array of length k which is a subsequence of
    the array [1, 2, ..., n], is linear if:
    * For every 1 < j <= k,
      prices[indexes[j]] - prices[indexes[j - 1]] == indexes[j] - indexes[j - 1].
    A subsequence is an array that can be derived from another array by deleting
    some or no elements without changing the order of the remaining elements.
    The score of a selection indexes, is equal to the sum of the following array:
    [prices[indexes[1]], prices[indexes[2]], ..., prices[indexes[k]]. Return the
    maximum score that a linear selection can have.

    Example 1:
    Input: prices = [1,5,3,7,8]
    Output: 20
    Explanation: We can select the indexes [2,4,5]. We show that our selection
                 is linear:
                 For j = 2, we have:
                 indexes[2] - indexes[1] = 4 - 2 = 2.
                 prices[4] - prices[2] = 7 - 5 = 2.
                 For j = 3, we have:
                 indexes[3] - indexes[2] = 5 - 4 = 1.
                 prices[5] - prices[4] = 8 - 7 = 1.
                 The sum of the elements is:
                 prices[2] + prices[4] + prices[5] = 20.
                 It can be shown that the maximum sum a linear selection can
                 have is 20.

    Example 2:
    Input: prices = [5,6,7,8,9]
    Output: 35
    Explanation: We can select all of the indexes [1,2,3,4,5]. Since each
                 element has a difference of exactly 1 from its previous
                 element, our selection is linear. The sum of all the elements
                 is 35 which is the maximum possible some out of every
                 selection.

    Constraints:
    * 1 <= prices.length <= 10^5
    * 1 <= prices[i] <= 10^9*/

    public long maxScore(int[] prices) {
        Map<Integer, Long> mp = new HashMap();
        for (int i = 0; i < prices.length; ++i)
            mp.merge(prices[i]-i, (long) prices[i], Long::sum);
        return Collections.max(mp.values());
    }


    /*2899. Last Visited Integers (Easy)
    Given a 0-indexed array of strings words where words[i] is either a positive
    integer represented as a string or the string "prev". Start iterating from
    the beginning of the array; for every "prev" string seen in words, find the
    last visited integer in words which is defined as follows:
    * Let k be the number of consecutive "prev" strings seen so far (containing
      the current string). Let nums be the 0-indexed array of integers seen so
      far and nums_reverse be the reverse of nums, then the integer at (k - 1)th
      index of nums_reverse will be the last visited integer for this "prev".
    * If k is greater than the total visited integers, then the last visited
      integer will be -1.
    Return an integer array containing the last visited integers.

    Example 1:
    Input: words = ["1","2","prev","prev","prev"]
    Output: [2,1,-1]
    Explanation: - For "prev" at index = 2, last visited integer will be 2 as
                   here the number of consecutive "prev" strings is 1, and in
                   the array reverse_nums, 2 will be the first element.
                 - For "prev" at index = 3, last visited integer will be 1 as
                   there are a total of two consecutive "prev" strings including
                   this "prev" which are visited, and 1 is the second last
                   visited integer.
                 - For "prev" at index = 4, last visited integer will be -1 as
                   there are a total of three consecutive "prev" strings
                   including this "prev" which are visited, but the total number
                   of integers visited is two.

    Example 2:
    Input: words = ["1","prev","2","prev","prev"]
    Output: [1,2,1]
    Explanation: - For "prev" at index = 1, last visited integer will be 1.
                 - For "prev" at index = 3, last visited integer will be 2.
                 - For "prev" at index = 4, last visited integer will be 1 as
                   there are a total of two consecutive "prev" strings including
                   this "prev" which are visited, and 1 is the second last
                   visited integer.

    Constraints:
    * 1 <= words.length <= 100
    * words[i] == "prev" or 1 <= int(words[i]) <= 100*/

    public List<Integer> lastVisitedIntegers(List<String> words) {
        List<Integer> ans = new ArrayList(), seen = new ArrayList();
        int k = 0;
        for (var w : words)
            if (w == "prev") {
                if (k >= seen.size()) ans.add(-1);
                else ans.add(seen.get(seen.size()-1-k++));
            } else {
                seen.add(Integer.valueOf(w));
                k = 0;
            }
        return ans;
    }


    /*2900. Longest Unequal Adjacent Groups Subsequence I (Easy)
    You are given a string array words and a binary array groups both of length
    n, where words[i] is associated with groups[i]. Your task is to select the
    longest alternating subsequence from words. A subsequence of words is
    alternating if for any two consecutive strings in the sequence, their
    corresponding elements in the binary array groups differ. Essentially, you
    are to choose strings such that adjacent elements have non-matching
    corresponding bits in the groups array. Formally, you need to find the
    longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as
    [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each
    0 <= j < k - 1 and then find the words corresponding to these indices.
    Return the selected subsequence. If there are multiple answers, return any
    of them. Note: The elements in words are distinct.

    Example 1:
    Input: words = ["e","a","b"], groups = [0,0,1]
    Output: ["e","b"]
    Explanation: A subsequence that can be selected is ["e","b"] because
                 groups[0] != groups[2]. Another subsequence that can be
                 selected is ["a","b"] because groups[1] != groups[2]. It can be
                 demonstrated that the length of the longest subsequence of
                 indices that satisfies the condition is 2.

    Example 2:
    Input: words = ["a","b","c","d"], groups = [1,0,1,1]
    Output: ["a","b","c"]
    Explanation: A subsequence that can be selected is ["a","b","c"] because
                 groups[0] != groups[1] and groups[1] != groups[2]. Another
                 subsequence that can be selected is ["a","b","d"] because
                 groups[0] != groups[1] and groups[1] != groups[3]. It can be
                 shown that the length of the longest subsequence of indices
                 that satisfies the condition is 3.

    Constraints:
    * 1 <= n == words.length == groups.length <= 100
    * 1 <= words[i].length <= 10
    * groups[i] is either 0 or 1.
    * words consists of distinct strings.
    * words[i] consists of lowercase English letters.*/

    public List<String> getLongestSubsequence(String[] words, int[] groups) {
        List<String> ans = new ArrayList();
        for (int i = 0; i < words.length; ++i)
            if (i == 0 || groups[i-1] != groups[i])
                ans.add(words[i]);
        return ans;
    }


    /*2913. Subarrays Distinct Element Sum of Squares I (Easy)
    You are given a 0-indexed integer array nums. The distinct count of a
    subarray of nums is defined as:
    * Let nums[i..j] be a subarray of nums consisting of all the indices from i
      to j such that 0 <= i <= j < nums.length. Then the number of distinct
      values in nums[i..j] is called the distinct count of nums[i..j].
    Return the sum of the squares of distinct counts of all subarrays of nums. A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,1]
    Output: 15
    Explanation: Six possible subarrays are:
                 [1]: 1 distinct value
                 [2]: 1 distinct value
                 [1]: 1 distinct value
                 [1,2]: 2 distinct values
                 [2,1]: 2 distinct values
                 [1,2,1]: 2 distinct values
                 The sum of the squares of the distinct counts in all subarrays
                 is equal to 12 + 12 + 12 + 22 + 22 + 22 = 15.

    Example 2:
    Input: nums = [1,1]
    Output: 3
    Explanation: Three possible subarrays are:
                 [1]: 1 distinct value
                 [1]: 1 distinct value
                 [1,1]: 1 distinct value
                 The sum of the squares of the distinct counts in all subarrays
                 is equal to 12 + 12 + 12 = 3.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100*/

    public int sumCounts(List<Integer> nums) {
        int ans = 0;
        for (int i = 0, n = nums.size(); i < n; ++i) {
            Set<Integer> seen = new HashSet();
            for (int j = i; j < n; ++j) {
                seen.add(nums.get(j));
                ans += Math.pow(seen.size(), 2);
            }
        }
        return ans;
    }


    /*2914. Minimum Number of Changes to Make Binary String Beautiful (Medium)
    You are given a 0-indexed binary string s having an even length. A string is
    beautiful if it's possible to partition it into one or more substrings such
    that:
    * Each substring has an even length.
    * Each substring contains only 1's or only 0's.
    You can change any character in s to 0 or 1. Return the minimum number of
    changes required to make the string s beautiful.

    Example 1:
    Input: s = "1001"
    Output: 2
    Explanation: We change s[1] to 1 and s[3] to 0 to get string "1100". It can
                 be seen that the string "1100" is beautiful because we can
                 partition it into "11|00". It can be proven that 2 is the
                 minimum number of changes needed to make the string beautiful.

    Example 2:
    Input: s = "10"
    Output: 1
    Explanation: We change s[1] to 1 to get string "11". It can be seen that the
                 string "11" is beautiful because we can partition it into "11".
                 It can be proven that 1 is the minimum number of changes needed
                 to make the string beautiful.

    Example 3:
    Input: s = "0000"
    Output: 0
    Explanation: We don't need to make any changes as the string "0000" is
                 beautiful already.

    Constraints:
    * 2 <= s.length <= 10^5
    * s has an even length.
    * s[i] is either '0' or '1'.*/

    public int minChanges(String s) {
        int n = s.length();
        return IntStream.range(0, n/2).reduce(0, (v, i) -> v + (s.charAt(2*i) != s.charAt(2*i+1) ? 1 : 0));
    }


    /*2915. Length of the Longest Subsequence That Sums to Target (Medium)
    You are given a 0-indexed array of integers nums, and an integer target.
    Return the length of the longest subsequence of nums that sums up to target.
    If no such subsequence exists, return -1. A subsequence is an array that can
    be derived from another array by deleting some or no elements without
    changing the order of the remaining elements.

    Example 1:
    Input: nums = [1,2,3,4,5], target = 9
    Output: 3
    Explanation: There are 3 subsequences with a sum equal to 9: [4,5], [1,3,5],
                 and [2,3,4]. The longest subsequences are [1,3,5], and [2,3,4].
                 Hence, the answer is 3.

    Example 2:
    Input: nums = [4,1,3,2,1,5], target = 7
    Output: 4
    Explanation: There are 5 subsequences with a sum equal to 7: [4,3], [4,1,2],
                 [4,2,1], [1,1,5], and [1,3,2,1]. The longest subsequence is
                 [1,3,2,1]. Hence, the answer is 4.

    Example 3:
    Input: nums = [1,1,5,4,5], target = 3
    Output: -1
    Explanation: It can be shown that nums has no subsequence that sums up to 3.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 1000
    * 1 <= target <= 1000*/

    public int lengthOfLongestSubsequence(List<Integer> nums, int target) {
        int n = nums.size();
        int[][] dp = new int[n+1][target+1];
        for (int i = 0; i <= n; ++i)
            Arrays.fill(dp[i], Integer.MIN_VALUE);
        dp[n][0] = 0;
        for (int i = n-1; i >= 0; --i)
            for (int j = 0; j <= target; ++j) {
                dp[i][j] = dp[i+1][j];
                if (j >= nums.get(i)) dp[i][j] = Math.max(dp[i][j], 1 + dp[i+1][j-nums.get(i)]);
            }
        return Math.max(-1, dp[0][target]);
    }


    /*2916. Subarrays Distinct Element Sum of Squares II (Hard)
    You are given a 0-indexed integer array nums. The distinct count of a
    subarray of nums is defined as:
    * Let nums[i..j] be a subarray of nums consisting of all the indices from i
      to j such that 0 <= i <= j < nums.length. Then the number of distinct
      values in nums[i..j] is called the distinct count of nums[i..j].
    Return the sum of the squares of distinct counts of all subarrays of nums.
    Since the answer may be very large, return it modulo 10^9 + 7. A subarray is
    a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,1]
    Output: 15
    Explanation: Six possible subarrays are:
                 [1]: 1 distinct value
                 [2]: 1 distinct value
                 [1]: 1 distinct value
                 [1,2]: 2 distinct values
                 [2,1]: 2 distinct values
                 [1,2,1]: 2 distinct values
                 The sum of the squares of the distinct counts in all subarrays
                 is equal to 12 + 12 + 12 + 22 + 22 + 22 = 15.

    Example 2:
    Input: nums = [2,2]
    Output: 3
    Explanation: Three possible subarrays are:
                 [2]: 1 distinct value
                 [2]: 1 distinct value
                 [2,2]: 1 distinct value
                 The sum of the squares of the distinct counts in all subarrays
                 is equal to 12 + 12 + 12 = 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5

class LazySegTreeSum {
    private int n = 0;
    private int mod = 0;
    private long[] lazy;
    private long[] tree;
    private long[] vals;

    public LazySegTreeSum(int n, int mod) {
        this.mod = mod;
        this.n = n;
        lazy = new long[4*n];
        tree = new long[4*n];
        vals = new long[4*n];
    }

    public void increment(int qlo, int qhi, int k, int lo, int hi) {
        if (hi == 0) hi = n;
        if (lazy[k] > 0) {
            vals[k] = (vals[k] + 2*tree[k]*lazy[k] + (hi-lo)*lazy[k]*lazy[k]) % mod;
            tree[k] = (tree[k] + (hi-lo)*lazy[k]) % mod;
            if (lo+1 < hi) {
                lazy[2*k+1] += lazy[k];
                lazy[2*k+2] += lazy[k];
            }
            lazy[k] = 0;
        }
        if (lo < hi && qlo < hi && lo < qhi) {
            if (qlo <= lo && hi <= qhi) {
                vals[k] = (vals[k] + 2*tree[k] + hi-lo) % mod;
                tree[k] = (tree[k] + hi-lo) % mod;
                if (lo+1 < hi) {
                    ++lazy[2*k+1];
                    ++lazy[2*k+2];
                }
            } else {
                int mid = lo + (hi-lo)/2;
                increment(qlo, qhi, 2*k+1, lo, mid);
                increment(qlo, qhi, 2*k+2, mid, hi);
                tree[k] = (tree[2*k+1] + tree[2*k+2]) % mod;
                vals[k] = (vals[2*k+1] + vals[2*k+2]) % mod;
            }
        }
    }

    public long  query(int qlo, int qhi, int k, int lo, int hi) {
        if (hi == 0) hi = n;
        if (lazy[k] > 0) {
            vals[k] = (vals[k] + 2*tree[k]*lazy[k] + (hi-lo)*lazy[k]*lazy[k]) % mod;
            tree[k] = (tree[k] + (hi-lo)*lazy[k]) % mod;
            if (lo+1 < hi) {
                lazy[2*k+1] += lazy[k];
                lazy[2*k+2] += lazy[k];
            }
            lazy[k] = 0;
        }
        if (qhi <= lo || hi <= qlo) return 0;
        if (qlo <= lo && hi <= qhi) return vals[k];
        int mid = lo + (hi-lo)/2;
        return query(qlo, qhi, 2*k+1, lo, mid) + query(qlo, qhi, 2*k+2, mid, hi);
    }
}*/

    public int sumCounts(int[] nums) {
        final int mod = 1_000_000_007, n = nums.length;
        LazySegTreeSum tree = new LazySegTreeSum(n, mod);
        Map<Integer, Integer> last = new HashMap<>();
        long ans = 0;
        for (int i = 0; i < n; ++i) {
            int lo = 0;
            if (last.containsKey(nums[i])) lo = last.get(nums[i]) + 1;
            tree.increment(lo, i+1, 0, 0, n);
            ans = (ans + tree.query(0, i+1, 0, 0, n)) % mod;
            last.put(nums[i], i);
        }
        return (int) ans;
    }


    /*2917. Find the K-or of an Array (Easy)
    You are given a 0-indexed integer array nums, and an integer k. The K-or of
    nums is a non-negative integer that satisfies the following:
    * The ith bit is set in the K-or if and only if there are at least k
      elements of nums in which bit i is set.
    Return the K-or of nums. Note that a bit i is set in x if (2i AND x) == 2i,
    where AND is the bitwise AND operator.

    Example 1:
    Input: nums = [7,12,9,8,9,15], k = 4
    Output: 9
    Explanation: Bit 0 is set at nums[0], nums[2], nums[4], and nums[5].
                 Bit 1 is set at nums[0], and nums[5].
                 Bit 2 is set at nums[0], nums[1], and nums[5].
                 Bit 3 is set at nums[1], nums[2], nums[3], nums[4], and nums[5].
                 Only bits 0 and 3 are set in at least k elements of the array,
                 and bits i >= 4 are not set in any of the array's elements.
                 Hence, the answer is 2^0 + 2^3 = 9.

    Example 2:
    Input: nums = [2,12,1,11,4,5], k = 6
    Output: 0
    Explanation: Since k == 6 == nums.length, the 6-or of the array is equal to
                 the bitwise AND of all its elements. Hence, the answer is 2 AND
                 12 AND 1 AND 11 AND 4 AND 5 = 0.

    Example 3:
    Input: nums = [10,8,5,9,11,6,8], k = 1
    Output: 15
    Explanation: Since k == 1, the 1-or of the array is equal to the bitwise OR
                 of all its elements. Hence, the answer is
                 10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15.

    Constraints:
    * 1 <= nums.length <= 50
    * 0 <= nums[i] < 2^31
    * 1 <= k <= nums.length*/

    public int findKOr(int[] nums, int k) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int freq = 0;
            for (var x : nums)
                if ((x & 1<<i) > 0 && ++freq == k) {
                    ans ^= 1<<i;
                    break;
                }
        }
        return ans;
    }


    /*2918. Minimum Equal Sum of Two Arrays After Replacing Zeros (Medium)
    You are given two arrays nums1 and nums2 consisting of positive integers.
    You have to replace all the 0's in both arrays with strictly positive
    integers such that the sum of elements of both arrays becomes equal. Return
    the minimum equal sum you can obtain, or -1 if it is impossible.

    Example 1:
    Input: nums1 = [3,2,0,1,0], nums2 = [6,5,0]
    Output: 12
    Explanation: We can replace 0's in the following way:
                 - Replace the two 0's in nums1 with the values 2 and 4. The
                   resulting array is nums1 = [3,2,2,1,4].
                 - Replace the 0 in nums2 with the value 1. The resulting array
                   is nums2 = [6,5,1].
                 Both arrays have an equal sum of 12. It can be shown that it is
                 the minimum sum we can obtain.

    Example 2:
    Input: nums1 = [2,0,2,0], nums2 = [1,4]
    Output: -1
    Explanation: It is impossible to make the sum of both arrays equal.

    Constraints:
    * 1 <= nums1.length, nums2.length <= 10^5
    * 0 <= nums1[i], nums2[i] <= 10^6*/

    public long minSum(int[] nums1, int[] nums2) {
        long s1 = 0, s2 = 0;
        int n1 = 0, n2 = 0;
        for (var x : nums1) {
            s1 += Math.max(x, 1);
            if (x == 0) ++n1;
        }
        for (var x : nums2) {
            s2 += Math.max(x, 1);
            if (x == 0) ++n2;
        }
        if (s1 < s2 && n1 == 0 || s2 < s1 && n2 == 0) return -1;
        return Math.max(s1, s2);
    }


    /*2919. Minimum Increment Operations to Make Array Beautiful (Medium)
    You are given a 0-indexed integer array nums having length n, and an integer
    k. You can perform the following increment operation any number of times
    (including zero):
    * Choose an index i in the range [0, n - 1], and increase nums[i] by 1.
    An array is considered beautiful if, for any subarray with a size of 3 or
    more, its maximum element is greater than or equal to k. Return an integer
    denoting the minimum number of increment operations needed to make nums
    beautiful. A subarray is a contiguous non-empty sequence of elements within
    an array.

    Example 1:
    Input: nums = [2,3,0,0,2], k = 4
    Output: 3
    Explanation: We can perform the following increment operations to make nums
                 beautiful:
                 - Choose index i = 1 and increase nums[1] by 1 -> [2,4,0,0,2].
                 - Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,3].
                 - Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,4].
                 The subarrays with a size of 3 or more are: [2,4,0], [4,0,0],
                 [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4]. In all the
                 subarrays, the maximum element is equal to k = 4, so nums is
                 now beautiful. It can be shown that nums cannot be made
                 beautiful with fewer than 3 increment operations. Hence, the
                 answer is 3.

    Example 2:
    Input: nums = [0,1,3,3], k = 5
    Output: 2
    Explanation: We can perform the following increment operations to make nums
                 beautiful:
                 - Choose index i = 2 and increase nums[2] by 1 -> [0,1,4,3].
                 - Choose index i = 2 and increase nums[2] by 1 -> [0,1,5,3].
                 The subarrays with a size of 3 or more are: [0,1,5], [1,5,3],
                 [0,1,5,3]. In all the subarrays, the maximum element is equal
                 to k = 5, so nums is now beautiful. It can be shown that nums
                 cannot be made beautiful with fewer than 2 increment
                 operations. Hence, the answer is 2.

    Example 3:
    Input: nums = [1,1,2], k = 1
    Output: 0
    Explanation: The only subarray with a size of 3 or more in this example is
                 [1,1,2]. The maximum element, 2, is already greater than k = 1,
                 so we don't need any increment operation. Hence, the answer is
                 0.

    Constraints:
    * 3 <= n == nums.length <= 10^5
    * 0 <= nums[i] <= 10^9
    * 0 <= k <= 10^9*/

    public long minIncrementOperations(int[] nums, int k) {
        int n = nums.length;
        long[] dp = new long[n+1];
        for (int i = n-1; i >= 0; --i) {
            dp[i] = Long.MAX_VALUE;
            for (int j = i+1; j <= i+3 && j <= n; ++j)
                dp[i] = Math.min(dp[i], dp[j]);
            dp[i] += Math.max(0, k - nums[i]);
        }
        return Math.min(dp[0], Math.min(dp[1], dp[2]));
    }


    /*2920. Maximum Points After Collecting Coins From All Nodes (Hard)
    There exists an undirected tree rooted at node 0 with n nodes labeled from 0
    to n - 1. You are given a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. You are also given a 0-indexed array coins of size n where
    coins[i] indicates the number of coins in the vertex i, and an integer k.
    Starting from the root, you have to collect all the coins such that the
    coins at a node can only be collected if the coins of its ancestors have
    been already collected. Coins at nodei can be collected in one of the
    following ways:
    * Collect all the coins, but you will get coins[i] - k points. If
      coins[i] - k is negative then you will lose abs(coins[i] - k) points.
    * Collect all the coins, but you will get floor(coins[i] / 2) points. If
      this way is used, then for all the nodej present in the subtree of nodei,
      coins[j] will get reduced to floor(coins[j] / 2).
    Return the maximum points you can get after collecting the coins from all
    the tree nodes.

    Example 1:
    Input: edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5
    Output: 11
    Explanation: - Collect all the coins from node 0 using the first way. Total
                   points = 10 - 5 = 5.
                 - Collect all the coins from node 1 using the first way. Total
                   points = 5 + (10 - 5) = 10.
                 - Collect all the coins from node 2 using the second way so
                   coins left at node 3 will be floor(3 / 2) = 1. Total points
                   = 10 + floor(3 / 2) = 11.
                 - Collect all the coins from node 3 using the second way. Total
                   points = 11 + floor(1 / 2) = 11.
                 It can be shown that the maximum points we can get after
                 collecting coins from all the nodes is 11.

    Example 2:
    Input: edges = [[0,1],[0,2]], coins = [8,4,4], k = 0
    Output: 16
    Explanation: Coins will be collected from all the nodes using the first way.
                 Therefore, total points = (8 - 0) + (4 - 0) + (4 - 0) = 16.

    Constraints:
    * n == coins.length
    * 2 <= n <= 10^5
    * 0 <= coins[i] <= 10^4
    * edges.length == n - 1
    * 0 <= edges[i][0], edges[i][1] < n
    * 0 <= k <= 10^4*/

    private int dfs(int u, int p, int d, int k, int[] coins, List<Integer>[] tree, short[] memo) {
        if (d >= 14 || memo[u] > d) return 0;
        ++memo[u];
        int op1 = 0, op2 = 0;
        for (var v : tree[u])
            if (v != p) {
                op1 += dfs(v, u, d, k, coins, tree, memo);
                op2 += dfs(v, u, d+1, k, coins, tree, memo);
            }
        return Math.max((coins[u]>>d) - k + op1, (coins[u]>>d+1) + op2);
    }

    public int maximumPoints(int[][] edges, int[] coins, int k) {
        int n = 1 + edges.length;
        List<Integer>[] tree = new List[n];
        for (int i = 0; i < n; ++i)
            tree[i] = new ArrayList<>();
        for (var e : edges) {
            int u = e[0], v = e[1];
            tree[u].add(v);
            tree[v].add(u);
        }
        short[] memo = new short[n];
        return dfs(0, -1, 0, k, coins, tree, memo);
    }


    /*2928. Distribute Candies Among Children I (Easy)
    You are given two positive integers n and limit. Return the total number of
    ways to distribute n candies among 3 children such that no child gets more
    than limit candies.

    Example 1:
    Input: n = 5, limit = 2
    Output: 3
    Explanation: There are 3 ways to distribute 5 candies such that no child
                 gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).

    Example 2:
    Input: n = 3, limit = 3
    Output: 10
    Explanation: There are 10 ways to distribute 3 candies such that no child
                 gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1),
                 (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1),
                 (2, 1, 0) and (3, 0, 0).

    Constraints:
    * 1 <= n <= 50
    * 1 <= limit <= 50*/

    public int distributeCandies(int n, int limit) {
        int ans = 0;
        for (int x = 0; x <= limit; ++x)
            for (int y = 0; y <= limit; ++y)
                if (0 <= n-x-y && n-x-y <= limit) ++ans;
        return ans;
    }


    /*2929. Distribute Candies Among Children II (Medium)
    You are given two positive integers n and limit. Return the total number of
    ways to distribute n candies among 3 children such that no child gets more
    than limit candies.

    Example 1:
    Input: n = 5, limit = 2
    Output: 3
    Explanation: There are 3 ways to distribute 5 candies such that no child
                 gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).
    Example 2:
    Input: n = 3, limit = 3
    Output: 10
    Explanation: There are 10 ways to distribute 3 candies such that no child
                 gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1),
                 (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1),
                 (2, 1, 0) and (3, 0, 0).

    Constraints:
    * 1 <= n <= 10^6
    * 1 <= limit <= 10^6*/

    public long distributeCandies(int n, int limit) {
        long ans = 0;
        for (int x = 0; x <= limit; ++x)
            ans += Math.max(0, Math.min(n-x, 2*limit-n+x)+1);
        return ans;
    }


    /*2930. Number of Strings Which Can Be Rearranged to Contain Substring (Medium)
    You are given an integer n. A string s is called good if it contains only
    lowercase English characters and it is possible to rearrange the characters
    of s such that the new string contains "leet" as a substring.

    For example:
    * The string "lteer" is good because we can rearrange it to form "leetr" .
    * "letl" is not good because we cannot rearrange it to contain "leet" as a
      substring.
    Return the total number of good strings of length n. Since the answer may
    be large, return it modulo 10^9 + 7. A substring is a contiguous sequence
    of characters within a string.

    Example 1:
    Input: n = 4
    Output: 12
    Explanation: The 12 strings which can be rearranged to have "leet" as a
                 substring are: "eelt", "eetl", "elet", "elte", "etel", "etle",
                 "leet", "lete", "ltee", "teel", "tele", and "tlee".

    Example 2:
    Input: n = 10
    Output: 83943898
    Explanation: The number of strings with length 10 which can be rearranged
                 to have "leet" as a substring is 526083947580. Hence the
                 answer is 526083947580 % (10^9 + 7) = 83943898.

    Constraints: 1 <= n <= 10^5*/

    private long pow(long x, int p, int m) {
        long ans = 1;
        for (; p > 0; p >>= 1) {
            if (p % 2 == 1) ans = ans * x % m;
            x = x * x % m;
        }
        return ans;
    }

    public int stringCount(int n) {
        final int mod = 1_000_000_007;
        return (int) (((pow(26, n, mod) - (75+n)*pow(25, n-1, mod) + (72+2*n)*pow(24, n-1, mod) - (23+n)*pow(23, n-1, mod)) % mod + mod) % mod);
    }


    /*2931. Maximum Spending After Buying Items (Hard)
    You are given a 0-indexed m * n integer matrix values, representing the
    values of m * n different items in m different shops. Each shop has n items
    where the jth item in the ith shop has a value of values[i][j].
    Additionally, the items in the ith shop are sorted in non-increasing order
    of value. That is, values[i][j] >= values[i][j + 1] for all 0 <= j < n - 1.
    On each day, you would like to buy a single item from one of the shops.
    Specifically, On the dth day you can:
    * Pick any shop i.
    * Buy the rightmost available item j for the price of values[i][j] * d.
      That is, find the greatest index j such that item j was never bought
      before, and buy it for the price of values[i][j] * d.
    Note that all items are pairwise different. For example, if you have bought
    item 0 from shop 1, you can still buy item 0 from any other shop. Return
    the maximum amount of money that can be spent on buying all m * n products.

    Example 1:
    Input: values = [[8,5,2],[6,4,1],[9,7,3]]
    Output: 285
    Explanation: - On the first day, we buy product 2 from shop 1 for a price
                   of values[1][2] * 1 = 1.
                 - On the second day, we buy product 2 from shop 0 for a price
                   of values[0][2] * 2 = 4.
                 - On the third day, we buy product 2 from shop 2 for a price
                   of values[2][2] * 3 = 9.
                 - On the fourth day, we buy product 1 from shop 1 for a price
                   of values[1][1] * 4 = 16.
                 - On the fifth day, we buy product 1 from shop 0 for a price
                   of values[0][1] * 5 = 25.
                 - On the sixth day, we buy product 0 from shop 1 for a price
                   of values[1][0] * 6 = 36.
                 - On the seventh day, we buy product 1 from shop 2 for a price
                   of values[2][1] * 7 = 49.
                 - On the eighth day, we buy product 0 from shop 0 for a price
                   of values[0][0] * 8 = 64.
                 - On the ninth day, we buy product 0 from shop 2 for a price
                   of values[2][0] * 9 = 81.
                 Hence, our total spending is equal to 285. It can be shown
                 that 285 is the maximum amount of money that can be spent
                 buying all m * n products.

    Example 2:
    Input: values = [[10,8,6,4,2],[9,7,5,3,2]]
    Output: 386
    Explanation: - On the first day, we buy product 4 from shop 0 for a price
                   of values[0][4] * 1 = 2.
                 - On the second day, we buy product 4 from shop 1 for a price
                   of values[1][4] * 2 = 4.
                 - On the third day, we buy product 3 from shop 1 for a price of values[1][3] * 3 = 9.
                 - On the fourth day, we buy product 3 from shop 0 for a price of values[0][3] * 4 = 16.
                 - On the fifth day, we buy product 2 from shop 1 for a price of values[1][2] * 5 = 25.
                 - On the sixth day, we buy product 2 from shop 0 for a price of values[0][2] * 6 = 36.
                 - On the seventh day, we buy product 1 from shop 1 for a price of values[1][1] * 7 = 49.
                 - On the eighth day, we buy product 1 from shop 0 for a price of values[0][1] * 8 = 64
                 - On the ninth day, we buy product 0 from shop 1 for a price of values[1][0] * 9 = 81.
                 - On the tenth day, we buy product 0 from shop 0 for a price of values[0][0] * 10 = 100.
                 Hence, our total spending is equal to 386. It can be shown
                 that 386 is the maximum amount of money that can be spent
                 buying all m * n products.

    Constraints:
    * 1 <= m == values.length <= 10
    * 1 <= n == values[i].length <= 10^4
    * 1 <= values[i][j] <= 10^6
    * values[i] are sorted in non-increasing order.*/

    public long maxSpending(int[][] values) {
        int m = values.length, n = values[0].length;
        PriorityQueue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[0], y[0]));
        for (int i = 0; i < m; ++i)
            pq.add(new int[]{values[i][n-1], i, n-1});
        long ans = 0;
        for (int k = 0; k < m*n; ++k) {
            var elem = pq.poll();
            int v = elem[0], i = elem[1], j = elem[2];
            ans += (long) v * (k+1);
            if (j > 0) pq.add(new int[]{values[i][j-1], i, j-1});
        }
        return ans;
    }


    /*2932. Maximum Strong Pair XOR I (Easy)
    You are given a 0-indexed integer array nums. A pair of integers x and y is
    called a strong pair if it satisfies the condition:
    * |x - y| <= min(x, y)
    You need to select two integers from nums such that they form a strong pair
    and their bitwise XOR is the maximum among all strong pairs in the array.
    Return the maximum XOR value out of all possible strong pairs in the array
    nums. Note that you can pick the same integer twice to form a pair.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 7
    Explanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2),
                 (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5)
                 and (5, 5). The maximum XOR possible from these pairs is
                 3 XOR 4 = 7.

    Example 2:
    Input: nums = [10,100]
    Output: 0
    Explanation: There are 2 strong pairs in the array nums: (10, 10) and
                 (100, 100). The maximum XOR possible from these pairs is
                 10 XOR 10 = 0 since the pair (100, 100) also gives
                 100 XOR 100 = 0.

    Example 3:
    Input: nums = [5,6,25,30]
    Output: 7
    Explanation: There are 6 strong pairs in the array nums: (5, 5), (5, 6),
                 (6, 6), (25, 25), (25, 30) and (30, 30). The maximum XOR
                 possible from these pairs is 25 XOR 30 = 7 since the only other
                 non-zero XOR value is 5 XOR 6 = 3.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 100*/

    public int maximumStrongPairXor(int[] nums) {
        int ans = 0;
        for (int i = 0, n = nums.length; i < n; ++i)
            for (int j = i+1; j < n; ++j)
                if (Math.abs(nums[i] - nums[j]) <= Math.min(nums[i], nums[j]))
                    ans = Math.max(ans, nums[i] ^ nums[j]);
        return ans;
    }


    /*2933. High-Access Employees (Medium)
    You are given a 2D 0-indexed array of strings, access_times, with size n.
    For each i where 0 <= i <= n - 1, access_times[i][0] represents the name of
    an employee, and access_times[i][1] represents the access time of that
    employee. All entries in access_times are within the same day. The access
    time is represented as four digits using a 24-hour time format, for example,
    "0800" or "2250". An employee is said to be high-access if he has accessed
    the system three or more times within a one-hour period. Times with exactly
    one hour of difference are not considered part of the same one-hour period.
    For example, "0815" and "0915" are not part of the same one-hour period.
    Access times at the start and end of the day are not counted within the same
    one-hour period. For example, "0005" and "2350" are not part of the same
    one-hour period. Return a list that contains the names of high-access
    employees with any order you want.

    Example 1:
    Input: access_times = [["a","0549"],["b","0457"],["a","0532"],["a","0621"],["b","0540"]]
    Output: ["a"]
    Explanation: "a" has three access times in the one-hour period of
                 [05:32, 06:31] which are 05:32, 05:49, and 06:21. But "b" does
                 not have more than two access times at all. So the answer is
                 ["a"].

    Example 2:
    Input: access_times = [["d","0002"],["c","0808"],["c","0829"],["e","0215"],["d","1508"],["d","1444"],["d","1410"],["c","0809"]]
    Output: ["c","d"]
    Explanation: "c" has three access times in the one-hour period of
                 [08:08, 09:07] which are 08:08, 08:09, and 08:29. "d" has also
                 three access times in the one-hour period of [14:10, 15:09]
                 which are 14:10, 14:44, and 15:08. However, "e" has just one
                 access time, so it can not be in the answer and the final
                 answer is ["c","d"].

    Example 3:
    Input: access_times = [["cd","1025"],["ab","1025"],["cd","1046"],["cd","1055"],["ab","1124"],["ab","1120"]]
    Output: ["ab","cd"]
    Explanation: "ab" has three access times in the one-hour period of
                 [10:25, 11:24] which are 10:25, 11:20, and 11:24. "cd" has also
                 three access times in the one-hour period of [10:25, 11:24]
                 which are 10:25, 10:46, and 10:55. So the answer is ["ab","cd"].

    Constraints:
    * 1 <= access_times.length <= 100
    * access_times[i].length == 2
    * 1 <= access_times[i][0].length <= 10
    * access_times[i][0] consists only of English small letters.
    * access_times[i][1].length == 4
    * access_times[i][1] is in 24-hour time format.
    * access_times[i][1] consists only of '0' to '9'.*/

    public List<String> findHighAccessEmployees(List<List<String>> access_times) {
        Map<String, List<Integer>> mp = new HashMap<>();
        for (var x : access_times) {
            String name = x.get(0), time = x.get(1);
            int t = 60*Integer.valueOf(time.substring(0, 2)) + Integer.valueOf(time.substring(2));
            if (!mp.containsKey(name)) mp.put(name, new ArrayList<>());
            mp.get(name).add(t);
        }
        List<String> ans = new ArrayList<>();
        for (var name : mp.keySet()) {
            List<Integer> times = mp.get(name);
            Collections.sort(times);
            for (int i = 2; i < times.size(); ++i)
                if (times.get(i) - times.get(i-2) < 60) {
                    ans.add(name);
                    break;
                }
        }
        return ans;
    }


    /*2934. Minimum Operations to Maximize Last Elements in Arrays (Medium)
    You are given two 0-indexed integer arrays, nums1 and nums2, both having
    length n. You are allowed to perform a series of operations (possibly none).
    In an operation, you select an index i in the range [0, n - 1] and swap the
    values of nums1[i] and nums2[i]. Your task is to find the minimum number of
    operations required to satisfy the following conditions:
    * nums1[n - 1] is equal to the maximum value among all elements of nums1,
      i.e., nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]).
    * nums2[n - 1] is equal to the maximum value among all elements of nums2,
      i.e., nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]).
    Return an integer denoting the minimum number of operations needed to meet
    both conditions, or -1 if it is impossible to satisfy both conditions.

    Example 1:
    Input: nums1 = [1,2,7], nums2 = [4,5,3]
    Output: 1
    Explanation: In this example, an operation can be performed using index
                 i = 2. When nums1[2] and nums2[2] are swapped, nums1 becomes
                 [1,2,3] and nums2 becomes [4,5,7]. Both conditions are now
                 satisfied. It can be shown that the minimum number of
                 operations needed to be performed is 1. So, the answer is 1.

    Example 2:
    Input: nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]
    Output: 2
    Explanation: In this example, the following operations can be performed:
                 - First operation using index i = 4. When nums1[4] and nums2[4]
                   are swapped, nums1 becomes [2,3,4,5,4], and nums2 becomes
                   [8,8,4,4,9].
                 - Another operation using index i = 3. When nums1[3] and
                   nums2[3] are swapped, nums1 becomes [2,3,4,4,4], and nums2
                   becomes [8,8,4,5,9].
                 Both conditions are now satisfied. It can be shown that the
                 minimum number of operations needed to be performed is 2. So,
                 the answer is 2.

    Example 3:
    Input: nums1 = [1,5,4], nums2 = [2,5,3]
    Output: -1
    Explanation: In this example, it is not possible to satisfy both conditions.
                 So, the answer is -1.

    Constraints:
    * 1 <= n == nums1.length == nums2.length <= 1000
    * 1 <= nums1[i] <= 10^9
    * 1 <= nums2[i] <= 10^9*/

    public int minOperations(int[] nums1, int[] nums2) {
        int yes = 0, no = 0;
        for (int i = 0, n = nums1.length; i < n; ++i) {
            int x1 = nums1[i], x2 = nums2[i];
            if (Math.max(nums1[n-1], nums2[n-1]) < Math.max(x1, x2) || Math.min(nums1[n-1], nums2[n-1]) < Math.min(x1, x2)) return -1;
            if (nums1[n-1] < x1 || nums2[n-1] < x2) ++yes;
            if (nums1[n-1] < x2 || nums2[n-1] < x1) ++no;
        }
        return Math.min(yes, no);
    }


    /*2935. Maximum Strong Pair XOR II (Hard)
    You are given a 0-indexed integer array nums. A pair of integers x and y is
    called a strong pair if it satisfies the condition:
    * |x - y| <= min(x, y)
    You need to select two integers from nums such that they form a strong pair
    and their bitwise XOR is the maximum among all strong pairs in the array.
    Return the maximum XOR value out of all possible strong pairs in the array
    nums. Note that you can pick the same integer twice to form a pair.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 7
    Explanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2),
                 (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5)
                 and (5, 5). The maximum XOR possible from these pairs is
                 3 XOR 4 = 7.

    Example 2:
    Input: nums = [10,100]
    Output: 0
    Explanation: There are 2 strong pairs in the array nums: (10, 10) and
                 (100, 100). The maximum XOR possible from these pairs is
                 10 XOR 10 = 0 since the pair (100, 100) also gives
                 100 XOR 100 = 0.

    Example 3:
    Input: nums = [500,520,2500,3000]
    Output: 1020
    Explanation: There are 6 strong pairs in the array nums: (500, 500),
                 (500, 520), (520, 520), (2500, 2500), (2500, 3000) and
                 (3000, 3000). The maximum XOR possible from these pairs is
                 500 XOR 520 = 1020 since the only other non-zero XOR value is
                 2500 XOR 3000 = 636.

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * 1 <= nums[i] <= 2^20 - 1

    class TrieNode {
        public TrieNode[] child = new TrieNode[2];
        public int count = 0;
        public int value = 0;
    }*/

    public int maximumStrongPairXor(int[] nums) {
        Arrays.sort(nums);
        TrieNode trie = new TrieNode();
        int ans = 0, k = 0;
        for (var x : nums) {
            TrieNode node = trie;
            for (int i = 19; i >= 0; --i) {
                int b = x>>i & 1;
                if (node.child[b] == null)
                    node.child[b] = new TrieNode();
                node = node.child[b];
                ++node.count;
            }
            node.value = x;
            for (; 2*nums[k] < x; ++k) {
                node = trie;
                for (int i = 19; i >= 0; --i) {
                    int b = nums[k]>>i & 1;
                    if (--node.child[b].count == 0) {
                        node.child[b] = null;
                        break;
                    }
                    node = node.child[b];
                }
            }
            node = trie;
            for (int i = 19; i >= 0; --i) {
                int b = x>>i & 1;
                if (node.child[1^b] != null) node = node.child[1^b];
                else node = node.child[b];
            }
            ans = Math.max(ans, x ^ node.value);
        }
        return ans;
    }


    /*2936. Number of Equal Numbers Blocks (Medium)
    You are given a 0-indexed array of integers, nums. The following property
    holds for nums:
    * All occurrences of a value are adjacent. In other words, if there are two
      indices i < j such that nums[i] == nums[j], then for every index k that
      i < k < j, nums[k] == nums[i].
    Since nums is a very large array, you are given an instance of the class
    BigArray which has the following functions:
    * int at(long long index): Returns the value of nums[i].
    * void size(): Returns nums.length.
    Let's partition the array into maximal blocks such that each block contains
    equal values. Return the number of these blocks. Note that if you want to
    test your solution using a custom test, behavior for tests with
    nums.length > 10 is undefined.

    Example 1:
    Input: nums = [3,3,3,3,3]
    Output: 1
    Explanation: There is only one block here which is the whole array (because
                 all numbers are equal) and that is: [3,3,3,3,3]. So the answer
                 would be 1.

    Example 2:
    Input: nums = [1,1,1,3,9,9,9,2,10,10]
    Output: 5
    Explanation: There are 5 blocks here:
    Block number 1: [1,1,1,3,9,9,9,2,10,10]
    Block number 2: [1,1,1,3,9,9,9,2,10,10]
    Block number 3: [1,1,1,3,9,9,9,2,10,10]
    Block number 4: [1,1,1,3,9,9,9,2,10,10]
    Block number 5: [1,1,1,3,9,9,9,2,10,10]
    So the answer would be 5.

    Example 3:
    Input: nums = [1,2,3,4,5,6,7]
    Output: 7
    Explanation: Since all numbers are distinct, there are 7 blocks here and
                 each element representing one block. So the answer would be 7.

    Constraints:
    * 1 <= nums.length <= 10^15
    * 1 <= nums[i] <= 10^9
    * The input is generated such that all equal values are adjacent.
    * The sum of the elements of nums is at most 10^15.*/

    public int countBlocks(BigArray nums) {

        class Solve {
            private int fn(long lo, long hi) {
                if (lo == hi || nums.at(lo) == nums.at(hi)) return 1;
                long mid = lo + (hi - lo)/2;
                int ans = fn(lo, mid) + fn(mid+1, hi);
                if (nums.at(mid) == nums.at(mid+1)) --ans;
                return ans;
            }
        }

        Solve sol = new Solve();
        return sol.fn(0, nums.size()-1);
    }


    /*2937. Make Three Strings Equal (Easy)
    You are given three strings s1, s2, and s3. You have to perform the
    following operation on these three strings as many times as you want. In
    one operation you can choose one of these three strings such that its
    length is at least 2 and delete the rightmost character of it. Return the
    minimum number of operations you need to perform to make the three strings
    equal if there is a way to make them equal, otherwise, return -1.

    Example 1:
    Input: s1 = "abc", s2 = "abb", s3 = "ab"
    Output: 2
    Explanation: Performing operations on s1 and s2 once will lead to three
                 equal strings. It can be shown that there is no way to make
                 them equal with less than two operations.

    Example 2:
    Input: s1 = "dac", s2 = "bac", s3 = "cac"
    Output: -1
    Explanation: Because the leftmost letters of s1 and s2 are not equal, they
                 could not be equal after any number of operations. So the
                 answer is -1.

    Constraints:
    * 1 <= s1.length, s2.length, s3.length <= 100
    * s1, s2 and s3 consist only of lowercase English letters.*/

    public int findMinimumOperations(String s1, String s2, String s3) {
        int i = 0;
        for (int m = Math.min(s1.length(), Math.min(s2.length(), s3.length())); i < m && s1.charAt(i) == s2.charAt(i) && s2.charAt(i) == s3.charAt(i); ++i);
        return i > 0 ? s1.length() + s2.length() + s3.length() - 3*i : -1;
    }


    /*2938. Separate Black and White Balls (Medium)
    There are n balls on a table, each ball has a color black or white. You are
    given a 0-indexed binary string s of length n, where 1 and 0 represent
    black and white balls, respectively. In each step, you can choose two
    adjacent balls and swap them. Return the minimum number of steps to group
    all the black balls to the right and all the white balls to the left.

    Example 1:
    Input: s = "101"
    Output: 1
    Explanation: We can group all the black balls to the right in the following
                 way:
                 - Swap s[0] and s[1], s = "011".
                 Initially, 1s are not grouped together, requiring at least 1
                 step to group them to the right.

    Example 2:
    Input: s = "100"
    Output: 2
    Explanation: We can group all the black balls to the right in the following
                 way:
                 - Swap s[0] and s[1], s = "010".
                 - Swap s[1] and s[2], s = "001".
                 It can be proven that the minimum number of steps needed is 2.

    Example 3:
    Input: s = "0111"
    Output: 0
    Explanation: All the black balls are already grouped to the right.

    Constraints:
    * 1 <= n == s.length <= 10^5
    * s[i] is either '0' or '1'.*/

    public long minimumSteps(String s) {
        long ans = 0;
        int prefix = 0;
        for (var ch : s.toCharArray())
            if (ch == '1') ++prefix;
            else ans += prefix;
        return ans;
    }


    /*2939. Maximum Xor Product (Medium)
    Given three integers a, b, and n, return the maximum value of
    (a XOR x) * (b XOR x) where 0 <= x < 2n. Since the answer may be too large,
    return it modulo 10^9 + 7. Note that XOR is the bitwise XOR operation.

    Example 1:
    Input: a = 12, b = 5, n = 4
    Output: 98
    Explanation: For x = 2, (a XOR x) = 14 and (b XOR x) = 7. Hence,
                 (a XOR x) * (b XOR x) = 98. It can be shown that 98 is the
                 maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.

    Example 2:
    Input: a = 6, b = 7 , n = 5
    Output: 930
    Explanation: For x = 25, (a XOR x) = 31 and (b XOR x) = 30. Hence,
                 (a XOR x) * (b XOR x) = 930. It can be shown that 930 is the
                 maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.

    Example 3:
    Input: a = 1, b = 6, n = 3
    Output: 12
    Explanation: For x = 5, (a XOR x) = 4 and (b XOR x) = 3. Hence,
                 (a XOR x) * (b XOR x) = 12. It can be shown that 12 is the
                 maximum value of (a XOR x) * (b XOR x) for all 0 <= x < 2n.

    Constraints:
    * 0 <= a, b < 2^50
    * 0 <= n <= 50*/

    public int maximumXorProduct(long a, long b, int n) {
        final int mod = 1_000_000_007;
        for (int i = n-1; i >= 0; --i)
            if ((Math.min(a, b) & 1l<<i) == 0) {
                a ^= 1l<<i;
                b ^= 1l<<i;
            }
        return (int) (a % mod * (b % mod) % mod);
    }


    /*2940. Find Building Where Alice and Bob Can Meet (Hard)
    You are given a 0-indexed array heights of positive integers, where
    heights[i] represents the height of the ith building. If a person is in
    building i, they can move to any other building j if and only if i < j and
    heights[i] < heights[j]. You are also given another array queries where
    queries[i] = [ai, bi]. On the ith query, Alice is in building ai while Bob
    is in building bi. Return an array ans where ans[i] is the index of the
    leftmost building where Alice and Bob can meet on the ith query. If Alice
    and Bob cannot move to a common building on query i, set ans[i] to -1.

    Example 1:
    Input: heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]
    Output: [2,5,-1,5,2]
    Explanation: - In the first query, Alice and Bob can move to building 2
                   since heights[0] < heights[2] and heights[1] < heights[2].
                 - In the second query, Alice and Bob can move to building 5
                   since heights[0] < heights[5] and heights[3] < heights[5].
                 - In the third query, Alice cannot meet Bob since Alice cannot
                   move to any other building.
                 - In the fourth query, Alice and Bob can move to building 5
                   since heights[3] < heights[5] and heights[4] < heights[5].
                 - In the fifth query, Alice and Bob are already in the same
                   building.
                 For ans[i] != -1, It can be shown that ans[i] is the leftmost
                 building where Alice and Bob can meet. For ans[i] == -1, It
                 can be shown that there is no building where Alice and Bob can
                 meet.

    Example 2:
    Input: heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]
    Output: [7,6,-1,4,6]
    Explanation: - In the first query, Alice can directly move to Bob's
                   building since heights[0] < heights[7].
                 - In the second query, Alice and Bob can move to building 6
                   since heights[3] < heights[6] and heights[5] < heights[6].
                 - In the third query, Alice cannot meet Bob since Bob cannot
                   move to any other building.
                 - In the fourth query, Alice and Bob can move to building 4
                   since heights[3] < heights[4] and heights[0] < heights[4].
                 - In the fifth query, Alice can directly move to Bob's
                   building since heights[1] < heights[6].
                 For ans[i] != -1, It can be shown that ans[i] is the leftmost
                 building where Alice and Bob can meet. For ans[i] == -1, It
                 can be shown that there is no building where Alice and Bob can
                 meet.

    Constraints:
    * 1 <= heights.length <= 5 * 10^4
    * 1 <= heights[i] <= 10^9
    * 1 <= queries.length <= 5 * 10^4
    * queries[i] = [ai, bi]
    * 0 <= ai, bi <= heights.length - 1*/

    public int[] leftmostBuildingQueries(int[] heights, int[][] queries) {
        int m = heights.length, n = queries.length;
        List<int[]>[] qs = new ArrayList[m];
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        for (int i = 0; i < m; ++i) qs[i] = new ArrayList<>();
        for (int i = 0; i < n; ++i) {
            int a = queries[i][0], b = queries[i][1];
            if (a > b) { var temp = a; a = b; b = temp; }
            if (a == b || heights[a] < heights[b]) ans[i] = b;
            else qs[b].add(new int[]{heights[a], i});
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        for (int k = 0; k < m; ++k) {
            while (!pq.isEmpty() && pq.peek()[0] < heights[k])
                ans[pq.poll()[1]] = k;
            for (var elem : qs[k]) pq.add(elem);
        }
        return ans;
    }


    /*2942. Find Words Containing Character (Easy)
    You are given a 0-indexed array of strings words and a character x. Return
    an array of indices representing the words that contain the character x.
    Note that the returned array may be in any order.

    Example 1:
    Input: words = ["leet","code"], x = "e"
    Output: [0,1]
    Explanation: "e" occurs in both words: "leet", and "code". Hence, we return
                 indices 0 and 1.

    Example 2:
    Input: words = ["abc","bcd","aaaa","cbc"], x = "a"
    Output: [0,2]
    Explanation: "a" occurs in "abc", and "aaaa". Hence, we return indices 0 and
                 2.

    Example 3:
    Input: words = ["abc","bcd","aaaa","cbc"], x = "z"
    Output: []
    Explanation: "z" does not occur in any of the words. Hence, we return an
                 empty array.

    Constraints:
    * 1 <= words.length <= 50
    * 1 <= words[i].length <= 50
    * x is a lowercase English letter.
    * words[i] consists only of lowercase English letters.*/

    public List<Integer> findWordsContaining(String[] words, char x) {
        List<Integer> ans = new ArrayList();
        for (int i = 0; i < words.length; ++i)
            if (words[i].indexOf(x) >= 0) ans.add(i);
        return ans;
    }



    /*2946. Matrix Similarity After Cyclic Shifts (Easy)
    You are given a 0-indexed m x n integer matrix mat and an integer k. You
    have to cyclically right shift odd indexed rows k times and cyclically left
    shift even indexed rows k times. Return true if the initial and final
    matrix are exactly the same and false otherwise.

    Example 1:
    Input: mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2
    Output: true
    Explanation: Initially, the matrix looks like the first figure. Second
                 figure represents the state of the matrix after one right and
                 left cyclic shifts to even and odd indexed rows. Third figure
                 is the final state of the matrix after two cyclic shifts which
                 is similar to the initial matrix. Therefore, return true.

    Example 2:
    Input: mat = [[2,2],[2,2]], k = 3
    Output: true
    Explanation: As all the values are equal in the matrix, even after
                 performing cyclic shifts the matrix will remain the same.
                 Therefeore, we return true.

    Example 3:
    Input: mat = [[1,2]], k = 1
    Output: false
    Explanation: After one cyclic shift, mat = [[2,1]] which is not equal to
                 the initial matrix. Therefore we return false.

    Constraints:
    * 1 <= mat.length <= 25
    * 1 <= mat[i].length <= 25
    * 1 <= mat[i][j] <= 25
    * 1 <= k <= 50*/

    public boolean areSimilar(int[][] mat, int k) {
        for (var row : mat)
            for (int j = 0, n = row.length; j < n; ++j)
                if (row[j] != row[(j+k)%n]) return false;
        return true;
    }


    /*2947. Count Beautiful Substrings I (Medium)
    You are given a string s and a positive integer k. Let vowels and
    consonants be the number of vowels and consonants in a string. A string is
    beautiful if:
    * vowels == consonants.
    * (vowels * consonants) % k == 0, in other terms the multiplication of
      vowels and consonants is divisible by k.
    Return the number of non-empty beautiful substrings in the given string s.
    A substring is a contiguous sequence of characters in a string. Vowel
    letters in English are 'a', 'e', 'i', 'o', and 'u'. Consonant letters in
    English are every letter except vowels.

    Example 1:
    Input: s = "baeyh", k = 2
    Output: 2
    Explanation: There are 2 beautiful substrings in the given string.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["y","h"]). You can see that string "aeyh"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["b","y"]). You can see that string "baey"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 It can be shown that there are only 2 beautiful substrings in
                 the given string.

    Example 2:
    Input: s = "abba", k = 1
    Output: 3
    Explanation: There are 3 beautiful substrings in the given string.
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 2 (["a","a"]),
                   consonants = 2 (["b","b"]).
                 It can be shown that there are only 3 beautiful substrings in
                 the given string.

    Example 3:
    Input: s = "bcdf", k = 1
    Output: 0
    Explanation: There are no beautiful substrings in the given string.

    Constraints:
    * 1 <= s.length <= 1000
    * 1 <= k <= 1000
    * s consists of only English lowercase letters.*/

    public int beautifulSubstrings(String s, int k) {
        int ans = 0;
        for (int i = 0, n = s.length(); i < n; ++i) {
            int vowels = 0, consonants = 0;
            for (int j = i; j < n; ++j) {
                if ("aeiou".indexOf(s.charAt(j)) >= 0) ++vowels;
                else ++consonants;
                if (vowels == consonants && vowels * consonants % k == 0) ++ans;
            }
        }
        return ans;
    }


    /*2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)
    You are given a 0-indexed array of positive integers nums and a positive
    integer limit. In one operation, you can choose any two indices i and j and
    swap nums[i] and nums[j] if |nums[i] - nums[j]| <= limit. Return the
    lexicographically smallest array that can be obtained by performing the
    operation any number of times. An array a is lexicographically smaller than
    an array b if in the first position where a and b differ, array a has an
    element that is less than the corresponding element in b. For example, the
    array [2,10,3] is lexicographically smaller than the array [10,2,3] because
    they differ at index 0 and 2 < 10.

    Example 1:
    Input: nums = [1,5,3,9,8], limit = 2
    Output: [1,3,5,8,9]
    Explanation: Apply the operation 2 times:
                 - Swap nums[1] with nums[2]. The array becomes [1,3,5,9,8]
                 - Swap nums[3] with nums[4]. The array becomes [1,3,5,8,9]
                 We cannot obtain a lexicographically smaller array by applying
                 any more operations. Note that it may be possible to get the
                 same result by doing different operations.

    Example 2:
    Input: nums = [1,7,6,18,2,1], limit = 3
    Output: [1,6,7,18,1,2]
    Explanation: Apply the operation 3 times:
                 - Swap nums[1] with nums[2]. The array becomes [1,6,7,18,2,1]
                 - Swap nums[0] with nums[4]. The array becomes [2,6,7,18,1,1]
                 - Swap nums[0] with nums[5]. The array becomes [1,6,7,18,1,2]
                 We cannot obtain a lexicographically smaller array by applying
                 any more operations.

    Example 3:
    Input: nums = [1,7,28,19,10], limit = 3
    Output: [1,7,28,19,10]
    Explanation: [1,7,28,19,10] is the lexicographically smallest array we can
                 obtain because we cannot apply the operation on any two
                 indices.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= limit <= 10^9*/

    public int[] lexicographicallySmallestArray(int[] nums, int limit) {
        int n = nums.length;
        int[][] vals = new int[n][2];
        for (int i = 0; i < n; ++i) vals[i] = new int[]{nums[i], i};
        Arrays.sort(vals, (x, y) -> Integer.compare(x[0], y[0]));
        List<Integer> idx = new ArrayList();
        for (int k = 0, kk = 0; k < n; ++k) {
            int x = vals[k][0], i = vals[k][1];
            idx.add(i);
            if (k == n-1 || x+limit < vals[k+1][0]) {
                Collections.sort(idx);
                for (int j = 0; j < idx.size(); ++j) nums[idx.get(j)] = vals[kk+j][0];
                idx.clear();
                kk = k+1;
            }
        }
        return nums;
    }


    /*2949. Count Beautiful Substrings II (Hard)
    You are given a string s and a positive integer k. Let vowels and
    consonants be the number of vowels and consonants in a string. A string is
    beautiful if:
    * vowels == consonants.
    * (vowels * consonants) % k == 0, in other terms the multiplication of
      vowels and consonants is divisible by k.
    Return the number of non-empty beautiful substrings in the given string s.
    A substring is a contiguous sequence of characters in a string. Vowel
    letters in English are 'a', 'e', 'i', 'o', and 'u'. Consonant letters in
    English are every letter except vowels.

    Example 1:
    Input: s = "baeyh", k = 2
    Output: 2
    Explanation: There are 2 beautiful substrings in the given string.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["y","h"]). You can see that string "aeyh"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 - Substring "baeyh", vowels = 2 (["a",e"]),
                   consonants = 2 (["b","y"]). You can see that string "baey"
                   is beautiful as vowels == consonants and
                   vowels * consonants % k == 0.
                 It can be shown that there are only 2 beautiful substrings in
                 the given string.

    Example 2:
    Input: s = "abba", k = 1
    Output: 3
    Explanation: There are 3 beautiful substrings in the given string.
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 1 (["a"]), consonants = 1 (["b"]).
                 - Substring "abba", vowels = 2 (["a","a"]), consonants = 2
                   (["b","b"]).
                 It can be shown that there are only 3 beautiful substrings in
                 the given string.

    Example 3:
    Input: s = "bcdf", k = 1
    Output: 0
    Explanation: There are no beautiful substrings in the given string.

    Constraints:
    * 1 <= s.length <= 5 * 10^4
    * 1 <= k <= 1000
    * s consists of only English lowercase letters.*/

    public long beautifulSubstrings(String s, int k) {
        int n = 1;
        for (; n <= k; ++n)
            if (n * n % k == 0) break;
        n *= 2;
        HashMap<Integer, Integer>[] seen = new HashMap[n];
        for (int i = 0; i < n; ++i) seen[i] = new HashMap();
        seen[n-1].put(0, 1);
        long ans = 0;
        for (int i = 0, diff = 0; i < s.length(); ++i) {
            if ("aeiou".indexOf(s.charAt(i)) >= 0) ++diff;
            else --diff;
            ans += seen[i % n].getOrDefault(diff, 0);
            seen[i % n].merge(diff, 1, Integer::sum);
        }
        return ans;
    }


    /*2950. Number of Divisible Substrings (Medium)
    Each character of the English alphabet has been mapped to a digit as shown
    below. A string is divisible if the sum of the mapped values of its
    characters is divisible by its length. Given a string s, return the number
    of divisible substrings of s. A substring is a contiguous non-empty sequence
    of characters within a string.

    Example 1: Substring   Mapped  Sum Length  Divisible?
               a   1   1   1   Yes
               s   7   7   1   Yes
               d   2   2   1   Yes
               f   3   3   1   Yes
               as  1, 7    8   2   Yes
               sd  7, 2    9   2   No
               df  2, 3    5   2   No
               asd 1, 7, 2 10  3   No
               sdf 7, 2, 3 12  3   Yes
               asdf    1, 7, 2, 3  13  4   No
    Input: word = "asdf"
    Output: 6
    Explanation: The table above contains the details about every substring of
                 word, and we can see that 6 of them are divisible.

    Example 2:
    Input: word = "bdh"
    Output: 4
    Explanation: The 4 divisible substrings are: "b", "d", "h", "bdh". It can be
                 shown that there are no other substrings of word that are
                 divisible.

    Example 3:
    Input: word = "abcd"
    Output: 6
    Explanation: The 6 divisible substrings are: "a", "b", "c", "d", "ab", "cd".
                 It can be shown that there are no other substrings of word that
                 are divisible.

    Constraints:
    * 1 <= word.length <= 2000
    * word consists only of lowercase English letters.*/

    public int countDivisibleSubstrings(String word) {
        int ans = 0;
        for (int k = 1; k <= 9; ++k) {
            int prefix = 0;
            Map<Integer, Integer> freq = new HashMap();
            freq.put(0, 1);
            for (int i = 0; i < word.length(); ++i) {
                char ch = word.charAt(i);
                prefix += 2+Math.floor((ch-'a'-2)/3.);
                ans += freq.getOrDefault(prefix - k*(i+1), 0);
                freq.merge(prefix-k*(i+1), 1, Integer::sum);
            }
        }
        return ans;
    }


    /*2955. Number of Same-End Substrings (Medium)
    You are given a 0-indexed string s, and a 2D array of integers queries,
    where queries[i] = [li, ri] indicates a substring of s starting from the
    index li and ending at the index ri (both inclusive), i.e. s[li..ri]. Return
    an array ans where ans[i] is the number of same-end substrings of queries[i].
    A 0-indexed string t of length n is called same-end if it has the same
    character at both of its ends, i.e., t[0] == t[n - 1]. A substring is a
    contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: s = "abcaab", queries = [[0,0],[1,4],[2,5],[0,5]]
    Output: [1,5,5,10]
    Explanation: Here is the same-end substrings of each query:
                 - 1st query: s[0..0] is "a" which has 1 same-end substring: "a".
                 - 2nd query: s[1..4] is "bcaa" which has 5 same-end substrings:
                   "bcaa", "bcaa", "bcaa", "bcaa", "bcaa".
                 - 3rd query: s[2..5] is "caab" which has 5 same-end substrings:
                   "caab", "caab", "caab", "caab", "caab".
                 - 4th query: s[0..5] is "abcaab" which has 10 same-end
                   substrings: "abcaab", "abcaab", "abcaab", "abcaab", "abcaab",
                   "abcaab", "abcaab", "abcaab", "abcaab", "abcaab".

    Example 2:
    Input: s = "abcd", queries = [[0,3]]
    Output: [4]
    Explanation: The only query is s[0..3] which is "abcd". It has 4 same-end
                 substrings: "abcd", "abcd", "abcd", "abcd".

    Constraints:
    * 2 <= s.length <= 3 * 10^4
    * s consists only of lowercase English letters.
    * 1 <= queries.length <= 3 * 10^4
    * queries[i] = [li, ri]
    * 0 <= li <= ri < s.length*/

    public int[] sameEndSubstringCount(String s, int[][] queries) {
        int m = s.length(), n = queries.length;
        int[] ans = new int[n];
        for (var c : "abcdefghijklmnopqrstuvwxyz".toCharArray()) {
            int[] prefix = new int[m+1];
            for (int i = 0; i < s.length(); ++i) {
                prefix[i+1] = prefix[i];
                if (s.charAt(i) == c) ++prefix[i+1];
            }
            for (int i = 0; i < n; ++i) {
                int l = queries[i][0], r = queries[i][1], diff = prefix[r+1] - prefix[l];
                ans[i] += diff*(diff+1)/2;
            }
        }
        return ans;
    }


    /*2956. Find Common Elements Between Two Arrays (Easy)
    You are given two 0-indexed integer arrays nums1 and nums2 of sizes n and m,
    respectively. Consider calculating the following values:
    * The number of indices i such that 0 <= i < n and nums1[i] occurs at least
      once in nums2.
    * The number of indices i such that 0 <= i < m and nums2[i] occurs at least
      once in nums1.
    Return an integer array answer of size 2 containing the two values in the
    above order.

    Example 1:
    Input: nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]
    Output: [3,4]
    Explanation: We calculate the values as follows:
                 - The elements at indices 1, 2, and 3 in nums1 occur at least
                   once in nums2. So the first value is 3.
                 - The elements at indices 0, 1, 3, and 4 in nums2 occur at
                   least once in nums1. So the second value is 4.

    Example 2:
    Input: nums1 = [3,4,2,3], nums2 = [1,5]
    Output: [0,0]
    Explanation: There are no common elements between the two arrays, so the two
                 values will be 0.

    Constraints:
    * n == nums1.length
    * m == nums2.length
    * 1 <= n, m <= 100
    * 1 <= nums1[i], nums2[i] <= 100*/

    public int[] findIntersectionValues(int[] nums1, int[] nums2) {
        int[] ans = new int[2];
        for (var x : nums1)
            if (Arrays.asList(nums2).contains(x)) ++ans[0];
        seen = Arrays.stream(nums1).boxed().collect(Collectors.toSet());
        for (var x : nums2)
            if (seen.contains(x)) ++ans[1];
        return ans;
    }


    /*2957. Remove Adjacent Almost-Equal Characters (Medium)
    You are given a 0-indexed string word. In one operation, you can pick any
    index i of word and change word[i] to any lowercase English letter. Return
    the minimum number of operations needed to remove all adjacent almost-equal
    characters from word. Two characters a and b are almost-equal if a == b or
    a and b are adjacent in the alphabet.

    Example 1:
    Input: word = "aaaaa"
    Output: 2
    Explanation: We can change word into "acaca" which does not have any
                 adjacent almost-equal characters. It can be shown that the
                 minimum number of operations needed to remove all adjacent
                 almost-equal characters from word is 2.

    Example 2:
    Input: word = "abddez"
    Output: 2
    Explanation: We can change word into "ybdoez" which does not have any
                 adjacent almost-equal characters. It can be shown that the
                 minimum number of operations needed to remove all adjacent
                 almost-equal characters from word is 2.

    Example 3:
    Input: word = "zyxyxyz"
    Output: 3
    Explanation: We can change word into "zaxaxaz" which does not have any
                 adjacent almost-equal characters. It can be shown that the
                 minimum number of operations needed to remove all adjacent
                 almost-equal characters from word is 3.

    Constraints:
    * 1 <= word.length <= 100
    * word consists only of lowercase English letters.*/

    public int removeAlmostEqualCharacters(String word) {
        int ans = 0;
        for (int i = 1; i < word.length(); ++i)
            if (Math.abs(word.charAt(i-1) - word.charAt(i)) <= 1) { ++ans; ++i; }
        return ans;
    }


    /*2958. Length of Longest Subarray With at Most K Frequency (Medium)
    You are given an integer array nums and an integer k. The frequency of an
    element x is the number of times it occurs in an array. An array is called
    good if the frequency of each element in this array is less than or equal to
    k. Return the length of the longest good subarray of nums. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,3,1,2,3,1,2], k = 2
    Output: 6
    Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the
                 values 1, 2, and 3 occur at most twice in this subarray. Note
                 that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also
                 good. It can be shown that there are no good subarrays with
                 length more than 6.

    Example 2:
    Input: nums = [1,2,1,2,1,2,1,2], k = 1
    Output: 2
    Explanation: The longest possible good subarray is [1,2] since the values 1
                 and 2 occur at most once in this subarray. Note that the
                 subarray [2,1] is also good. It can be shown that there are no
                 good subarrays with length more than 2.

    Example 3:
    Input: nums = [5,5,5,5,5,5,5], k = 4
    Output: 4
    Explanation: The longest possible good subarray is [5,5,5,5] since the value
                 5 occurs 4 times in this subarray. It can be shown that there
                 are no good subarrays with length more than 4.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= nums.length*/

    public int maxSubarrayLength(int[] nums, int k) {
        Map<Integer, Integer> freq = new HashMap();
        int ans = 0;
        for (int i = 0, ii = 0; i < nums.length; ++i) {
            freq.merge(nums[i], 1, Integer::sum);
            while (freq.get(nums[i]) > k) freq.merge(nums[ii++], -1, Integer::sum);
            ans = Math.max(ans, i-ii+1);
        }
        return ans;
    }


    /*2959. Number of Possible Sets of Closing Branches (Hard)
    There is a company with n branches across the country, some of which are
    connected by roads. Initially, all branches are reachable from each other by
    traveling some roads. The company has realized that they are spending an
    excessive amount of time traveling between their branches. As a result, they
    have decided to close down some of these branches (possibly none). However,
    they want to ensure that the remaining branches have a distance of at most
    maxDistance from each other. The distance between two branches is the
    minimum total traveled length needed to reach one branch from another. You
    are given integers n, maxDistance, and a 0-indexed 2D array roads, where
    roads[i] = [ui, vi, wi] represents the undirected road between branches ui
    and vi with length wi. Return the number of possible sets of closing
    branches, so that any branch has a distance of at most maxDistance from any
    other. Note that, after closing a branch, the company will no longer have
    access to any roads connected to it. Note that, multiple roads are allowed.

    Example 1:
    Input: n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]
    Output: 5
    Explanation: The possible sets of closing branches are:
                 - The set [2], after closing, active branches are [0,1] and
                   they are reachable to each other within distance 2.
                 - The set [0,1], after closing, the active branch is [2].
                 - The set [1,2], after closing, the active branch is [0].
                 - The set [0,2], after closing, the active branch is [1].
                 - The set [0,1,2], after closing, there are no active branches.
                 It can be proven, that there are only 5 possible sets of
                 closing branches.

    Example 2:
    Input: n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]
    Output: 7
    Explanation: The possible sets of closing branches are:
                 - The set [], after closing, active branches are [0,1,2] and
                   they are reachable to each other within distance 4.
                 - The set [0], after closing, active branches are [1,2] and
                   they are reachable to each other within distance 2.
                 - The set [1], after closing, active branches are [0,2] and
                   they are reachable to each other within distance 2.
                 - The set [0,1], after closing, the active branch is [2].
                 - The set [1,2], after closing, the active branch is [0].
                 - The set [0,2], after closing, the active branch is [1].
                 - The set [0,1,2], after closing, there are no active branches.
                 It can be proven, that there are only 7 possible sets of
                 closing branches.

    Example 3:
    Input: n = 1, maxDistance = 10, roads = []
    Output: 2
    Explanation: The possible sets of closing branches are:
                 - The set [], after closing, the active branch is [0].
                 - The set [0], after closing, there are no active branches.
                 It can be proven, that there are only 2 possible sets of
                 closing branches.

    Constraints:
    * 1 <= n <= 10
    * 1 <= maxDistance <= 10^5
    * 0 <= roads.length <= 1000
    * roads[i].length == 3
    * 0 <= ui, vi <= n - 1
    * ui != vi
    * 1 <= wi <= 1000
    * All branches are reachable from each other by traveling some roads.*/

    public int numberOfSets(int n, int maxDistance, int[][] roads) {
        int ans = 0;
        for (int m = 0; m < 1<<n; ++m) {
            int[][] dist = new int[n][n];
            for (int u = 0; u < n; ++u) Arrays.fill(dist[u], 1_000_000);
            for (int u = 0; u < n; ++u)
                if ((m & 1<<u) > 0) dist[u][u] = 0;
            for (var road : roads) {
                int u = road[0], v = road[1], w = road[2];
                if ((m & 1<<u) > 0 && (m & 1<<v) > 0)
                    dist[u][v] = dist[v][u] = Math.min(dist[u][v], w);
            }
            for (int k = 0; k < n; ++k)
                for (int u = 0; u < n; ++u)
                    for (int v = 0; v < n; ++v)
                        dist[u][v] = Math.min(dist[u][v], dist[u][k] + dist[k][v]);
            boolean found = false;
            for (int u = 0; u < n; ++u)
                if ((m & 1<<u) > 0)
                    for (int v = 0; v < n; ++v)
                        if ((m & 1<<v) > 0 && dist[u][v] > maxDistance) found = true;
            if (!found) ++ans;
        }
        return ans;
    }


    /*2960. Count Tested Devices After Test Operations (Easy)
    You are given a 0-indexed integer array batteryPercentages having length n,
    denoting the battery percentages of n 0-indexed devices. Your task is to
    test each device i in order from 0 to n - 1, by performing the following
    test operations:
    * If batteryPercentages[i] is greater than 0:
      + Increment the count of tested devices.
      + Decrease the battery percentage of all devices with indices j in the
        range [i + 1, n - 1] by 1, ensuring their battery percentage never goes
        below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).
      + Move to the next device.
    * Otherwise, move to the next device without performing any test.
    Return an integer denoting the number of devices that will be tested after
    performing the test operations in order.

    Example 1:
    Input: batteryPercentages = [1,1,2,1,3]
    Output: 3
    Explanation: Performing the test operations in order starting from device 0:
                 - At device 1, batteryPercentages [1] == 0, so we move to the
                   next device without testing.
                 - At device 2, batteryPercentages[2] > 0, so there are now 2
                   tested devices, and batteryPercentages becomes [1,0,1,0,1].
                 - At device 3, batteryPercentages [3] == 0, so we move to the
                   next device without testing.
                 - At device 0, batteryPercentages[0] > 0, so there is now 1
                   tested device, and batteryPercentages becomes [1,0,1,0,2].
                 - At device 4, batteryPercentages[4] > 0, so there are now 3
                   tested devices, and batteryPercentages stays the same.
                 So, the answer is 3.

    Example 2:
    Input: batteryPercentages = [0,1,2]
    Output: 2
    Explanation: Performing the test operations in order starting from device 0:
                 - At device 0, batteryPercentages[0] == 0, so we move to the
                   next device without testing.
                 - At device 1, batteryPercentages[1] > 0, so there is now 1
                   tested device, and batteryPercentages becomes [0,1,1].
                 - At device 2, batteryPercentages [2] > 0, so there are now 2
                   tested devices, and batteryPercentages stays the same.
                 So, the answer is 2.

    Constraints:
    * 1 <= n == batteryPercentages.length <= 100
    * 0 <= batteryPercentages[i] <= 100*/

    public int countTestedDevices(int[] batteryPercentages) {
        int ans = 0;
        for (var x : batteryPercentages)
            if (ans < x) ++ans;
        return ans;
    }


    /*2961. Double Modular Exponentiation (Medium)
    You are given a 0-indexed 2D array variables where
    variables[i] = [ai, bi, ci, mi], and an integer target. An index i is good
    if the following formula holds:
    * 0 <= i < variables.length
    * ((aibi % 10)ci) % mi == target
    Return an array consisting of good indices in any order.

    Example 1:
    Input: variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2
    Output: [0,2]
    Explanation: For each index i in the variables array:
                 1) For the index 0, variables[0] = [2,3,3,10],
                    (23 % 10)3 % 10 = 2.
                 2) For the index 1, variables[1] = [3,3,3,1],
                    (33 % 10)3 % 1 = 0.
                 3) For the index 2, variables[2] = [6,1,1,4],
                    (61 % 10)1 % 4 = 2.
                 Therefore we return [0,2] as the answer.

    Example 2:
    Input: variables = [[39,3,1000,1000]], target = 17
    Output: []
    Explanation: For each index i in the variables array:
                 1) For the index 0, variables[0] = [39,3,1000,1000],
                    (393 % 10)1000 % 1000 = 1.
                 Therefore we return [] as the answer.

    Constraints:
    * 1 <= variables.length <= 100
    * variables[i] == [ai, bi, ci, mi]
    * 1 <= ai, bi, ci, mi <= 10^3
    * 0 <= target <= 10^3*/

    private int pow(long x, int p, int m) {
        long ans = 1;
        for (; p > 0; p >>= 1) {
            if ((p & 1) > 0) ans = ans * x % m;
            x = x * x % m;
        }
        return (int) ans;
    }

    public List<Integer> getGoodIndices(int[][] variables, int target) {
        List<Integer> ans = new ArrayList();
        for (int i = 0; i < variables.length; ++i) {
            int a = variables[i][0], b = variables[i][1], c = variables[i][2], m = variables[i][3];
            if (pow(pow(a, b, 10), c, m) == target) ans.add(i);
        }
        return ans;
    }


    /*2962. Count Subarrays Where Max Element Appears at Least K Times (Meidum)
    You are given an integer array nums and a positive integer k. Return the
    number of subarrays where the maximum element of nums appears at least k
    times in that subarray. A subarray is a contiguous sequence of elements
    within an array.

    Example 1:
    Input: nums = [1,3,2,3,3], k = 2
    Output: 6
    Explanation: The subarrays that contain the element 3 at least 2 times are:
                 [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].

    Example 2:
    Input: nums = [1,4,2,1], k = 3
    Output: 0
    Explanation: No subarray contains the element 4 at least 3 times.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6
    * 1 <= k <= 10^5*/

    public long countSubarrays(int[] nums, int k) {
        long ans = 0;
        int m = Arrays.stream(nums).max().getAsInt(), ii = 0, freq = 0;
        for (var x : nums) {
            if (x == m) ++freq;
            while (freq == k)
                if (nums[ii++] == m) --freq;
            ans += ii;
        }
        return ans;
    }


    /*2963. Count the Number of Good Partitions (Hard)
    You are given a 0-indexed array nums consisting of positive integers. A
    partition of an array into one or more contiguous subarrays is called good
    if no two subarrays contain the same number. Return the total number of good
    partitions of nums. Since the answer may be large, return it modulo
    10^9 + 7.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 8
    Explanation: The 8 possible good partitions are: ([1], [2], [3], [4]),
                 ([1], [2], [3,4]), ([1], [2,3], [4]), ([1], [2,3,4]),
                 ([1,2], [3], [4]), ([1,2], [3,4]), ([1,2,3], [4]), and
                 ([1,2,3,4]).

    Example 2:
    Input: nums = [1,1,1,1]
    Output: 1
    Explanation: The only possible good partition is: ([1,1,1,1]).

    Example 3:
    Input: nums = [1,2,1,3]
    Output: 2
    Explanation: The 2 possible good partitions are: ([1,2,1], [3]) and
                 ([1,2,1,3]).

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public int numberOfGoodPartitions(int[] nums) {
        final int mod = 1_000_000_007;
        Map<Integer, Integer> last = new HashMap();
        for (int i = 0; i < nums.length; ++i) last.put(nums[i], i);
        long ans = 1;
        for (int i = 0, ii = 0; i < nums.length; ++i) {
            if (ii < i) ans = ans * 2 % mod;
            ii = Math.max(ii, last.get(nums[i]));
        }
        return (int) ans;
    }


    /*2964. Number of Divisible Triplet Sums (Medium)
    Given a 0-indexed integer array nums and an integer d, return the number of
    triplets (i, j, k) such that i < j < k and
    (nums[i] + nums[j] + nums[k]) % d == 0.

    Example 1:
    Input: nums = [3,3,4,7,8], d = 5
    Output: 3
    Explanation: The triplets which are divisible by 5 are: (0, 1, 2),
                 (0, 2, 4), (1, 2, 4). It can be shown that no other triplet is
                 divisible by 5. Hence, the answer is 3.

    Example 2:
    Input: nums = [3,3,3,3], d = 3
    Output: 4
    Explanation: Any triplet chosen here has a sum of 9, which is divisible by
                 3. Hence, the answer is the total number of triplets which is 4.

    Example 3:
    Input: nums = [3,3,3,3], d = 6
    Output: 0
    Explanation: Any triplet chosen here has a sum of 9, which is not divisible
                 by 6. Hence, the answer is 0.

    Constraints:
    * 1 <= nums.length <= 1000
    * 1 <= nums[i] <= 10^9
    * 1 <= d <= 10^9*/

    public int divisibleTripletCount(int[] nums, int d) {
        int ans = 0;
        for (int i = 0, n = nums.length; i < n; ++i) {
            Map<Integer, Integer> freq = new HashMap();
            for (int ii = i+1; ii < n; ++ii) {
                ans += freq.getOrDefault((d-nums[ii]%d)%d, 0);
                freq.merge((nums[i]+nums[ii])%d, 1, Integer::sum);
            }
        }
        return ans;
    }


    /*2965. Find Missing and Repeated Values (Easy)
    You are given a 0-indexed 2D integer matrix grid of size n * n with values
    in the range [1, n2]. Each integer appears exactly once except a which
    appears twice and b which is missing. The task is to find the repeating and
    missing numbers a and b. Return a 0-indexed integer array ans of size 2
    where ans[0] equals to a and ans[1] equals to b.

    Example 1:
    Input: grid = [[1,3],[2,2]]
    Output: [2,4]
    Explanation: Number 2 is repeated and number 4 is missing so the answer is
                 [2,4].

    Example 2:
    Input: grid = [[9,1,7],[8,9,2],[3,4,6]]
    Output: [9,5]
    Explanation: Number 9 is repeated and number 5 is missing so the answer is
                 [9,5].

    Constraints:
    * 2 <= n == grid.length == grid[i].length <= 50
    * 1 <= grid[i][j] <= n * n
    * For all x that 1 <= x <= n * n there is exactly one x that is not equal to
      any of the grid members.
    * For all x that 1 <= x <= n * n there is exactly one x that is equal to
      exactly two of the grid members.
    * For all x that 1 <= x <= n * n except two of them there is exatly one pair
      of i, j that 0 <= i, j <= n - 1 and grid[i][j] == x.*/

    public int[] findMissingAndRepeatedValues(int[][] grid) {
        long s = 0, s2 = 0, n = grid.length * grid.length;
        for (var row : grid)
            for (var x : row) {
                s += x;
                s2 += x*x;
            }
        int diff = (int) (s - n*(n+1)/2), total = (int) ((s2 - n*(n+1)*(2*n+1)/6) / diff);
        return new int[]{ (total+diff)/2, (total-diff)/2 };
    }


    /*2966. Divide Array Into Arrays With Max Difference (Medium)
    You are given an integer array nums of size n and a positive integer k.
    Divide the array into one or more arrays of size 3 satisfying the following
    conditions:
    * Each element of nums should be in exactly one array.
    * The difference between any two elements in one array is less than or equal
      to k.
    Return a 2D array containing all the arrays. If it is impossible to satisfy
    the conditions, return an empty array. And if there are multiple answers,
    return any of them.

    Example 1:
    Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
    Output: [[1,1,3],[3,4,5],[7,8,9]]
    Explanation: We can divide the array into the following arrays: [1,1,3],
                 [3,4,5] and [7,8,9]. The difference between any two elements in
                 each array is less than or equal to 2. Note that the order of
                 elements is not important.

    Example 2:
    Input: nums = [1,3,3,2,7,3], k = 3
    Output: []
    Explanation: It is not possible to divide the array satisfying all the
                 conditions.

    Constraints:
    * n == nums.length
    * 1 <= n <= 10^5
    * n is a multiple of 3.
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= 10^5*/

    public int[][] divideArray(int[] nums, int k) {
        Arrays.sort(nums);
        int n = nums.length;
        int[][] ans = new int[n/3][3];
        for (int i = 2; i < n; i += 3) {
            if (nums[i] - nums[i-2] > k) return new int[0][];
            ans[i/3] = new int[]{ nums[i-2], nums[i-1], nums[i] };
        }
        return ans;
    }


    /*2967. Minimum Cost to Make Array Equalindromic (Medium)
    You are given a 0-indexed integer array nums having length n. You are
    allowed to perform a special move any number of times (including zero) on
    nums. In one special move you perform the following steps in order:
    * Choose an index i in the range [0, n - 1], and a positive integer x.
    * Add |nums[i] - x| to the total cost.
    * Change the value of nums[i] to x.
    A palindromic number is a positive integer that remains the same when its
    digits are reversed. For example, 121, 2552 and 65756 are palindromic
    numbers whereas 24, 46, 235 are not palindromic numbers. An array is
    considered equalindromic if all the elements in the array are equal to an
    integer y, where y is a palindromic number less than 10^9. Return an integer
    denoting the minimum possible total cost to make nums equalindromic by
    performing any number of special moves.

    Example 1:
    Input: nums = [1,2,3,4,5]
    Output: 6
    Explanation: We can make the array equalindromic by changing all elements to
                 3 which is a palindromic number. The cost of changing the array
                 to [3,3,3,3,3] using 4 special moves is given by
                 |1 - 3| + |2 - 3| + |4 - 3| + |5 - 3| = 6. It can be shown that
                 changing all elements to any palindromic number other than 3
                 cannot be achieved at a lower cost.

    Example 2:
    Input: nums = [10,12,13,14,15]
    Output: 11
    Explanation: We can make the array equalindromic by changing all elements to
                 11 which is a palindromic number. The cost of changing the
                 array to [11,11,11,11,11] using 5 special moves is given by
                 |10 - 11| + |12 - 11| + |13 - 11| + |14 - 11| + |15 - 11| = 11.
                 It can be shown that changing all elements to any palindromic
                 number other than 11 cannot be achieved at a lower cost.

    Example 3:
    Input: nums = [22,33,22,33,22]
    Output: 22
    Explanation: We can make the array equalindromic by changing all elements to
                 22 which is a palindromic number. The cost of changing the
                 array to [22,22,22,22,22] using 2 special moves is given by
                 |33 - 22| + |33 - 22| = 22. It can be shown that changing all
                 elements to any palindromic number other than 22 cannot be
                 achieved at a lower cost.

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public long minimumCost(int[] nums) {
        Arrays.sort(nums);
        int median = nums[nums.length/2];
        String digits = String.valueOf(median);
        int n = digits.length();
        String h = digits.substring(0, (n+1)/2), hh = new StringBuilder(h).reverse().toString();
        int val = Integer.parseInt(h + hh.substring(n&1)), cand = 0;
        List<Integer> vals = new ArrayList();
        vals.add(val);
        if (val < median) {
            String t = String.valueOf(Integer.parseInt(h) + 1), tt = new StringBuilder(t).reverse().toString();
            if (t.length() > (n+1)/2) cand = val + 2;
            else cand = Integer.parseInt(t + tt.substring(n&1));
            vals.add(cand);
        } else if (val > median) {
            String t = String.valueOf(Integer.parseInt(h) - 1), tt = new StringBuilder(t).reverse().toString();
            if (t.length() < (n+1)/2 || t.equals("0") && val > 10) cand = val - 2;
            else cand = Integer.parseInt(t + tt.substring(n&1));
            vals.add(cand);
        }
        long ans = Long.MAX_VALUE;
        for (var v : vals) {
            long prefix = 0;
            for (var x : nums)
                prefix += Math.abs(x - v);
            ans = Math.min(ans, prefix);
        }
        return ans;
    }


    /*2968. Apply Operations to Maximize Frequency Score (Hard)
    You are given a 0-indexed integer array nums and an integer k. You can
    perform the following operation on the array at most k times:
    * Choose any index i from the array and increase or decrease nums[i] by 1.
    The score of the final array is the frequency of the most frequent element
    in the array. Return the maximum score you can achieve. The frequency of an
    element is the number of occurences of that element in the array.

    Example 1:
    Input: nums = [1,2,6,4], k = 3
    Output: 3
    Explanation: We can do the following operations on the array:
                 - Choose i = 0, and increase the value of nums[0] by 1. The
                   resulting array is [2,2,6,4].
                 - Choose i = 3, and decrease the value of nums[3] by 1. The
                   resulting array is [2,2,6,3].
                 - Choose i = 3, and decrease the value of nums[3] by 1. The
                   resulting array is [2,2,6,2].
                 The element 2 is the most frequent in the final array so our
                 score is 3. It can be shown that we cannot achieve a better
                 score.

    Example 2:
    Input: nums = [1,4,4,2,4], k = 0
    Output: 3
    Explanation: We cannot apply any operations so our score will be the
                 frequency of the most frequent element in the original array,
                 which is 3.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= 10^14*/

    public int maxFrequencyScore(int[] nums, long k) {
        Arrays.sort(nums);
        int ii = 0;
        for (int i = 0; i < nums.length; ++i) {
            k -= nums[i] - nums[(ii+i) / 2];
            if (k < 0)
                k += nums[(ii+i+1)/2] - nums[ii++];
        }
        return nums.length - ii;
    }


    /*2971. Find Polygon With the Largest Perimeter (Medium)
    You are given an array of positive integers nums of length n. A polygon is a
    closed plane figure that has at least 3 sides. The longest side of a polygon
    is smaller than the sum of its other sides. Conversely, if you have k
    (k >= 3) positive real numbers a1, a2, a3, ..., ak where
    a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there
    always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.
    The perimeter of a polygon is the sum of lengths of its sides. Return the
    largest possible perimeter of a polygon whose sides can be formed from nums,
    or -1 if it is not possible to create a polygon.

    Example 1:
    Input: nums = [5,5,5]
    Output: 15
    Explanation: The only possible polygon that can be made from nums has 3
                 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.

    Example 2:
    Input: nums = [1,12,1,2,5,50,3]
    Output: 12
    Explanation: The polygon with the largest perimeter which can be made from
                 nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is
                 1 + 1 + 2 + 3 + 5 = 12. We cannot have a polygon with either 12
                 or 50 as the longest side because it is not possible to include
                 2 or more smaller sides that have a greater sum than either of
                 them. It can be shown that the largest possible perimeter is 12.

    Example 3:
    Input: nums = [5,5,50]
    Output: -1
    Explanation: There is no possible way to form a polygon from nums, as a
                 polygon has at least 3 sides and 50 > 5 + 5.

    Constraints:
    * 3 <= n <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public long largestPerimeter(int[] nums) {
        long ans = -1, prefix = 0;
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; ++i) {
            if (i >= 2 && prefix > nums[i]) ans = Math.max(ans, prefix + nums[i]);
            prefix += nums[i];
        }
        return ans;
    }


    /*2979. Most Expensive Item That Can Not Be Bought (Medium)
    You are given two distinct prime numbers primeOne and primeTwo. Alice and
    Bob are visiting a market. The market has an infinite number of items, for
    any positive integer x there exists an item whose price is x. Alice wants to
    buy some items from the market to gift to Bob. She has an infinite number of
    coins in the denomination primeOne and primeTwo. She wants to know the most
    expensive item she can not buy to gift to Bob. Return the price of the most
    expensive item which Alice can not gift to Bob.

    Example 1:
    Input: primeOne = 2, primeTwo = 5
    Output: 3
    Explanation: The prices of items which cannot be bought are [1,3]. It can be
                 shown that all items with a price greater than 3 can be bought
                 using a combination of coins of denominations 2 and 5.

    Example 2:
    Input: primeOne = 5, primeTwo = 7
    Output: 23
    Explanation: The prices of items which cannot be bought are
                 [1,2,3,4,6,8,9,11,13,16,18,23]. It can be shown that all items
                 with a price greater than 23 can be bought.

    Constraints:
    * 1 < primeOne, primeTwo < 10^4
    * primeOne, primeTwo are prime numbers.
    * primeOne * primeTwo < 10^5*/

    public int mostExpensiveItem(int primeOne, int primeTwo) {
        return primeOne * primeTwo - primeOne - primeTwo;
    }


    /*2992. Number of Self-Divisible Permutations (Medium)
    Given an integer n, return the number of permutations of the 1-indexed array
    nums = [1, 2, ..., n], such that it's self-divisible. A 1-indexed array a of
    length n is self-divisible if for every 1 <= i <= n, gcd(a[i], i) == 1. A
    permutation of an array is a rearrangement of the elements of that array,
    for example here are all of the permutations of the array [1, 2, 3]:
    * [1, 2, 3]
    * [1, 3, 2]
    * [2, 1, 3]
    * [2, 3, 1]
    * [3, 1, 2]
    * [3, 2, 1]

    Example 1:
    Input: n = 1
    Output: 1
    Explanation: The array [1] has only 1 permutation which is self-divisible.

    Example 2:
    Input: n = 2
    Output: 1
    Explanation: The array [1,2] has 2 permutations and only one of them is
                 self-divisible:
                 * nums = [1,2]: This is not self-divisible since
                   gcd(nums[2], 2) != 1.
                 * nums = [2,1]: This is self-divisible since
                   gcd(nums[1], 1) == 1 and gcd(nums[2], 2) == 1.

    Example 3:
    Input: n = 3
    Output: 3
    Explanation: The array [1,2,3] has 3 self-divisble permutations: [1,3,2],
                 [3,1,2], [2,3,1]. It can be shown that the other 3 permutations
                 are not self-divisible. Hence the answer is 3.

    Constraints: 1 <= n <= 12*/

    public int selfDivisiblePermutationCount(int n) {
        int[][] memo = new int[n+1][1<<n];
        for (int i = 0; i <= n; ++i)
            Arrays.fill(memo[i], -1);

        class Sol {
            private int gcd(int x, int y) {
                while (y > 0) {
                    int temp = x;
                    x = y;
                    y = temp % y;
                }
                return Math.abs(x);
            }

            public int fn(int i, int m) {
                if (i == n) memo[i][m] = 1;
                else {
                    memo[i][m] = 0;
                    for (int x = 0; x < n; ++x)
                        if ((m & 1<<x) == 0 && gcd(i+1, x+1) == 1)
                            memo[i][m] += fn(i+1, m ^ 1<<x);
                }
                return memo[i][m];
            }
        }

        Sol sol = new Sol();
        return sol.fn(0, 0);
    }


    /*2996. Smallest Missing Integer Greater Than Sequential Prefix Sum (Easy)
    You are given a 0-indexed array of integers nums. A prefix nums[0..i] is
    sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In
    particular, the prefix consisting only of nums[0] is sequential. Return the
    smallest integer x missing from nums such that x is greater than or equal to
    the sum of the longest sequential prefix.

    Example 1:
    Input: nums = [1,2,3,2,5]
    Output: 6
    Explanation: The longest sequential prefix of nums is [1,2,3] with a sum of
                 6. 6 is not in the array, therefore 6 is the smallest missing
                 integer greater than or equal to the sum of the longest
                 sequential prefix.

    Example 2:
    Input: nums = [3,4,5,1,12,14,13]
    Output: 15
    Explanation: The longest sequential prefix of nums is [3,4,5] with a sum of
                 12. 12, 13, and 14 belong to the array while 15 does not.
                 Therefore 15 is the smallest missing integer greater than or
                 equal to the sum of the longest sequential prefix.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50*/

    public int missingInteger(int[] nums) {
        int prefix = 0;
        for (int i = 0; i < nums.length && (i == 0 || nums[i] == 1 + nums[i-1]); ++i)
            prefix += nums[i];
        Set<Integer> seen = new HashSet(Arrays.stream(nums).boxed().collect(Collectors.toSet()));
        while (seen.contains(prefix)) ++prefix;
        return prefix;
    }


    /*2997. Minimum Number of Operations to Make Array XOR Equal to K (Medium)
    You are given a 0-indexed integer array nums and a positive integer k. You
    can apply the following operation on the array any number of times:
    * Choose any element of the array and flip a bit in its binary
      representation. Flipping a bit means changing a 0 to 1 or vice versa.
    Return the minimum number of operations required to make the bitwise XOR of
    all elements of the final array equal to k. Note that you can flip leading
    zero bits in the binary representation of elements. For example, for the
    number (101)2 you can flip the fourth bit and obtain (1101)2.

    Example 1:
    Input: nums = [2,1,3,4], k = 1
    Output: 2
    Explanation: We can do the following operations:
                 - Choose element 2 which is 3 == (011)2, we flip the first bit
                   and we obtain (010)2 == 2. nums becomes [2,1,2,4].
                 - Choose element 0 which is 2 == (010)2, we flip the third bit
                   and we obtain (110)2 = 6. nums becomes [6,1,2,4].
                 The XOR of elements of the final array is
                 (6 XOR 1 XOR 2 XOR 4) == 1 == k. It can be shown that we cannot
                 make the XOR equal to k in less than 2 operations.

    Example 2:
    Input: nums = [2,0,2,0], k = 0
    Output: 0
    Explanation: The XOR of elements of the array is
                 (2 XOR 0 XOR 2 XOR 0) == 0 == k. So no operation is needed.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^6
    * 0 <= k <= 10^6*/

    public int minOperations(int[] nums, int k) {
        return Integer.bitCount(IntStream.of(nums).reduce(k, (x, y) -> x^y));
    }


    /*2998. Minimum Number of Operations to Make X and Y Equal (Medium)
    You are given two positive integers x and y. In one operation, you can do
    one of the four following operations:
    * Divide x by 11 if x is a multiple of 11.
    * Divide x by 5 if x is a multiple of 5.
    * Decrement x by 1.
    * Increment x by 1.
    Return the minimum number of operations required to make x and y equal.

    Example 1:
    Input: x = 26, y = 1
    Output: 3
    Explanation: We can make 26 equal to 1 by applying the following operations:
                 1. Decrement x by 1
                 2. Divide x by 5
                 3. Divide x by 5
                 It can be shown that 3 is the minimum number of operations
                 required to make 26 equal to 1.

    Example 2:
    Input: x = 54, y = 2
    Output: 4
    Explanation: We can make 54 equal to 2 by applying the following operations:
                 1. Increment x by 1
                 2. Divide x by 11
                 3. Divide x by 5
                 4. Increment x by 1
                 It can be shown that 4 is the minimum number of operations
                 required to make 54 equal to 2.

    Example 3:
    Input: x = 25, y = 30
    Output: 5
    Explanation: We can make 25 equal to 30 by applying the following operations:
                 1. Increment x by 1
                 2. Increment x by 1
                 3. Increment x by 1
                 4. Increment x by 1
                 5. Increment x by 1
                 It can be shown that 5 is the minimum number of operations
                 required to make 25 equal to 30.

    Constraints: 1 <= x, y <= 10^4*/

    public int minimumOperationsToMakeEqual(int x, int y) {
        if (x <= y) return y - x;
        int ans = x - y;
        for (var v : new int[]{5, 11}) {
            ans = Math.min(ans, minimumOperationsToMakeEqual(x/v, y) + 1 + x % v);
            ans = Math.min(ans, minimumOperationsToMakeEqual(x/v+1, y) + 1 + v - x % v);
        }
        return ans;
    }


    /*2999. Count the Number of Powerful Integers (Hard)
    You are given three integers start, finish, and limit. You are also given a
    0-indexed string s representing a positive integer. A positive integer x is
    called powerful if it ends with s (in other words, s is a suffix of x) and
    each digit in x is at most limit. Return the total number of powerful
    integers in the range [start..finish]. A string x is a suffix of a string y
    if and only if x is a substring of y that starts from some index (including
    0) in y and extends to the index y.length - 1. For example, 25 is a suffix
    of 5125 whereas 512 is not.

    Example 1:
    Input: start = 1, finish = 6000, limit = 4, s = "124"
    Output: 5
    Explanation: The powerful integers in the range [1..6000] are 124, 1124,
                 2124, 3124, and, 4124. All these integers have each digit <= 4,
                 and "124" as a suffix. Note that 5124 is not a powerful integer
                 because the first digit is 5 which is greater than 4. It can be
                 shown that there are only 5 powerful integers in this range.

    Example 2:
    Input: start = 15, finish = 215, limit = 6, s = "10"
    Output: 2
    Explanation: The powerful integers in the range [15..215] are 110 and 210.
                 All these integers have each digit <= 6, and "10" as a suffix.
                 It can be shown that there are only 2 powerful integers in this
                 range.

    Example 3:
    Input: start = 1000, finish = 2000, limit = 4, s = "3000"
    Output: 0
    Explanation: All integers in the range [1000..2000] are smaller than 3000,
                 hence "3000" cannot be a suffix of any integer in this range.

    Constraints:
    * 1 <= start <= finish <= 10^15
    * 1 <= limit <= 9
    * 1 <= s.length <= floor(log10(finish)) + 1
    * s only consists of numeric digits which are at most limit.
    * s does not have leading zeros.*/

    public long numberOfPowerfulInt(long start, long finish, int limit, String s) {

        class Sol {
            public long fn(String val) {
                int n = val.length() - s.length();
                if (n < 0) return 0;
                long[][] dp = new long[n+1][2];
                dp[n][0] = 1;
                if (val.substring(n).compareTo(s) >= 0) dp[n][1] = 1;
                for (int i = n-1; i >= 0; --i) {
                    dp[i][0] = (1 + limit) * dp[i+1][0];
                    if (val.charAt(i)-'0' <= limit) dp[i][1] = (val.charAt(i)-'0')*dp[i+1][0] + dp[i+1][1];
                    else dp[i][1] = (1 + limit) * dp[i+1][0];
                }
                return dp[0][1];
            }
        }

        Sol sol = new Sol();
        return sol.fn(Long.toString(finish)) - sol.fn(Long.toString(start-1));
    }


    /*3004. Maximum Subtree of the Same Color (Medium)
    You are given a 2D integer array edges representing a tree with n nodes,
    numbered from 0 to n - 1, rooted at node 0, where edges[i] = [ui, vi] means
    there is an edge between the nodes vi and ui. You are also given a 0-indexed
    integer array colors of size n, where colors[i] is the color assigned to
    node i. We want to find a node v such that every node in the subtree of v
    has the same color. Return the size of such subtree with the maximum number
    of nodes possible.

    Example 1:
    Input: edges = [[0,1],[0,2],[0,3]], colors = [1,1,2,3]
    Output: 1
    Explanation: Each color is represented as: 1 -> Red, 2 -> Green, 3 -> Blue.
                 We can see that the subtree rooted at node 0 has children with
                 different colors. Any other subtree is of the same color and
                 has a size of 1. Hence, we return 1.

    Example 2:
    Input: edges = [[0,1],[0,2],[0,3]], colors = [1,1,1,1]
    Output: 4
    Explanation: The whole tree has the same color, and the subtree rooted at
                 node 0 has the most number of nodes which is 4. Hence, we
                 return 4.

    Example 3:
    Input: edges = [[0,1],[0,2],[2,3],[2,4]], colors = [1,2,3,3,3]
    Output: 3
    Explanation: Each color is represented as: 1 -> Red, 2 -> Green, 3 -> Blue.
                 We can see that the subtree rooted at node 0 has children with
                 different colors. Any other subtree is of the same color, but
                 the subtree rooted at node 2 has a size of 3 which is the
                 maximum. Hence, we return 3.

    Constraints:
    * n == edges.length + 1
    * 1 <= n <= 5 * 10^4
    * edges[i] == [ui, vi]
    * 0 <= ui, vi < n
    * colors.length == n
    * 1 <= colors[i] <= 10^5
    * The input is generated such that the graph represented by edges is a
      tree.*/

    public int maximumSubtreeSize(int[][] edges, int[] colors) {
        int n = colors.length;
        List<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; ++i)
            graph[i] = new ArrayList();
        for (var e : edges) {
            graph[e[0]].add(e[1]);
            graph[e[1]].add(e[0]);
        }

        class Sol {
            private int[] fn(int u, int p) {
                int most = 0, same = 1, val = 1;
                for (var v : graph[u]) {
                    if (v != p) {
                        int[] elem = fn(v, u);
                        int vv = elem[0], ss = elem[1];
                        if (ss > 0 && colors[u] == colors[v]) val += vv;
                        else same = 0;
                        most = Math.max(most, vv);
                    }
                }
                if (same > 0) most = val;
                return new int[]{most, same};
            }
        }

        Sol sol = new Sol();
        return sol.fn(0, -1)[0];
    }


    /*3005. Count Elements With Maximum Frequency (Easy)
    You are given an array nums consisting of positive integers. Return the
    total frequencies of elements in nums such that those elements all have the
    maximum frequency. The frequency of an element is the number of occurrences
    of that element in the array.

    Example 1:
    Input: nums = [1,2,2,3,1,4]
    Output: 4
    Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum
                 frequency in the array. So the number of elements in the array
                 with maximum frequency is 4.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: 5
    Explanation: All elements of the array have a frequency of 1 which is the
                 maximum. So the number of elements in the array with maximum
                 frequency is 5.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100*/

    public int maxFrequencyElements(int[] nums) {
        Map<Integer, Integer> freq = new HashMap();
        for (var x : nums) freq.merge(x, 1, Integer::sum);
        int ans = 0, m = Integer.MIN_VALUE;
        for (var v : freq.values())
            if (v > m) ans = m = v;
            else if (v == m) ans += v;
        return ans;
    }


    /*3006. Find Beautiful Indices in the Given Array I (Medium)
    You are given a 0-indexed string s, a string a, a string b, and an integer
    k. An index i is beautiful if:
    * 0 <= i <= s.length - a.length
    * s[i..(i + a.length - 1)] == a
    * There exists an index j such that:
      - 0 <= j <= s.length - b.length
      - s[j..(j + b.length - 1)] == b
      - |j - i| <= k
    Return the array that contains beautiful indices in sorted order from
    smallest to largest.

    Example 1:
    Input: s = "isawsquirrelnearmysquirrelhouseohmy", a = "my", b = "squirrel", k = 15
    Output: [16,33]
    Explanation: There are 2 beautiful indices: [16,33].
                 - The index 16 is beautiful as s[16..17] == "my" and there
                   exists an index 4 with s[4..11] == "squirrel" and
                   |16 - 4| <= 15.
                 - The index 33 is beautiful as s[33..34] == "my" and there
                   exists an index 18 with s[18..25] == "squirrel" and
                   |33 - 18| <= 15.
                 Thus we return [16,33] as the result.

    Example 2:
    Input: s = "abcd", a = "a", b = "a", k = 4
    Output: [0]
    Explanation: There is 1 beautiful index: [0].
                 - The index 0 is beautiful as s[0..0] == "a" and there exists
                   an index 0 with s[0..0] == "a" and |0 - 0| <= 4.
                 Thus we return [0] as the result.

    Constraints:
    * 1 <= k <= s.length <= 10^5
    * 1 <= a.length, b.length <= 10
    * s, a, and b contain only lowercase English letters.*/

    public List<Integer> beautifulIndices(String s, String a, String b, int k) {
        List<Integer> ans = new ArrayList();
        for (int i = 0, j = 0, n = s.length(); i+a.length() <= n; ++i) {
            if (s.substring(i, i+a.length()).equals(a)) {
                boolean found = false;
                for (; j+b.length() <= n && j <= i+k; ++j) {
                    if (s.substring(j, j+b.length()).equals(b) && Math.abs(i-j) <= k) {
                        found = true;
                        break;
                    }
                }
                if (found) ans.add(i);
            }
        }
        return ans;
    }


    /*3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)
    You are given an integer k and an integer x. Consider s is the 1-indexed
    binary representation of an integer num. The price of a number num is the
    number of i's such that i % x == 0 and s[i] is a set bit. Return the
    greatest integer num such that the sum of prices of all numbers from 1 to
    num is less than or equal to k.

    Note:
    * In the binary representation of a number set bit is a bit of value 1.
    * The binary representation of a number will be indexed from right to left.
      For example, if s == 11100, s[4] == 1 and s[2] == 0.

    Example 1:
    Input: k = 9, x = 1
    Output: 6
    Explanation: The numbers 1, 2, 3, 4, 5, and 6 can be written in binary
                 representation as "1", "10", "11", "100", "101", and "110"
                 respectively. Since x is equal to 1, the price of each number
                 is the number of its set bits. The number of set bits in these
                 numbers is 9. So the sum of the prices of the first 6 numbers
                 is 9. So the answer is 6.

    Example 2:
    Input: k = 7, x = 2
    Output: 9
    Explanation: Since x is equal to 2, we should just check eventh bits. The
                 second bit of binary representation of numbers 2 and 3 is a set
                 bit. So the sum of their prices is 2. The second bit of binary
                 representation of numbers 6 and 7 is a set bit. So the sum of
                 their prices is 2. The fourth bit of binary representation of
                 numbers 8 and 9 is a set bit but their second bit is not. So
                 the sum of their prices is 2. Numbers 1, 4, and 5 don't have
                 set bits in their eventh bits in their binary representation.
                 So the sum of their prices is 0. The second and the fourth bit
                 of the binary representation of the number 10 are a set bit. So
                 its price is 2. The sum of the prices of the first 9 numbers is
                 6. Because the sum of the prices of the first 10 numbers is 8,
                 the answer is 9.

    Constraints:
    * 1 <= k <= 10^15
    * 1 <= x <= 8*/

    private long fn(long mid, int x) {
        if (mid == 0) return 0l;
        int n = 0;
        for (long m = mid; (m >>= 1) > 0; ++n);
        mid ^= 1l << n;
        return n/x*(long) Math.pow(2, n-1) + fn(mid, x) + ((n+1) % x == 0 ? mid+1 : 0);
    }

    public long findMaximumNumber(long k, int x) {
        long lo = 1, hi = (long) 1e15;
        while (lo < hi) {
            long mid = lo + (hi - lo + 1)/2;
            if (fn(mid, x) <= k) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*3008. Find Beautiful Indices in the Given Array II (Hard)
    You are given a 0-indexed string s, a string a, a string b, and an integer
    k. An index i is beautiful if:
    * 0 <= i <= s.length - a.length
    * s[i..(i + a.length - 1)] == a
    * There exists an index j such that:
      - 0 <= j <= s.length - b.length
      - s[j..(j + b.length - 1)] == b
      - |j - i| <= k
    Return the array that contains beautiful indices in sorted order from
    smallest to largest.

    Example 1:
    Input: s = "isawsquirrelnearmysquirrelhouseohmy", a = "my", b = "squirrel", k = 15
    Output: [16,33]
    Explanation: There are 2 beautiful indices: [16,33].
                 - The index 16 is beautiful as s[16..17] == "my" and there
                   exists an index 4 with s[4..11] == "squirrel" and
                   |16 - 4| <= 15.
                 - The index 33 is beautiful as s[33..34] == "my" and there
                   exists an index 18 with s[18..25] == "squirrel" and
                   |33 - 18| <= 15.
                 Thus we return [16,33] as the result.

    Example 2:
    Input: s = "abcd", a = "a", b = "a", k = 4
    Output: [0]
    Explanation: There is 1 beautiful index: [0].
                 - The index 0 is beautiful as s[0..0] == "a" and there exists
                   an index 0 with s[0..0] == "a" and |0 - 0| <= 4.
                 Thus we return [0] as the result.

    Constraints:
    * 1 <= k <= s.length <= 5 * 10^5
    * 1 <= a.length, b.length <= 5 * 10^5
    * s, a, and b contain only lowercase English letters.*/

    private List<Integer> kmp(String pattern, String text) {
        List<Integer> lps = new ArrayList();
        lps.add(0);
        for (int i = 1, k = 0, n = pattern.length(); i < n; ++i) {
            while (k > 0 && pattern.charAt(k) != pattern.charAt(i)) k = lps.get(k-1);
            if (pattern.charAt(k) == pattern.charAt(i))++k;
            lps.add(k);
        }
        List<Integer> ans = new ArrayList();
        for (int i = 0, k = 0, n = pattern.length(); i < text.length(); ++i) {
            while (k > 0 && (k == n || pattern.charAt(k) != text.charAt(i))) k = lps.get(k-1);
            if (pattern.charAt(k) == text.charAt(i)) ++k;
            if (k == n) ans.add(i-n+1);
        }
        return ans;
    }

    public List<Integer> beautifulIndices(String s, String a, String b, int k) {
        List<Integer> ans = new ArrayList(), vals = kmp(b, s);
        System.out.println(vals.size());
        int j = 0;
        for (var i : kmp(a, s)) {
            boolean found = false;
            for (; j < vals.size() && vals.get(j) <= i+k; ++j)
                if (Math.abs(i-vals.get(j)) <= k) {
                    found = true;
                    break;
                }
            if (found) ans.add(i);
        }
        return ans;
    }


    /*3010. Divide an Array Into Subarrays With Minimum Cost I (Easy)
    You are given an array of integers nums of length n. The cost of an array is
    the value of its first element. For example, the cost of [1,2,3] is 1 while
    the cost of [3,4,1] is 3. You need to divide nums into 3 disjoint contiguous
    subarrays. Return the minimum possible sum of the cost of these subarrays.

    Example 1:
    Input: nums = [1,2,3,12]
    Output: 6
    Explanation: The best possible way to form 3 subarrays is: [1], [2], and
                 [3,12] at a total cost of 1 + 2 + 3 = 6. The other possible
                 ways to form 3 subarrays are:
                 - [1], [2,3], and [12] at a total cost of 1 + 2 + 12 = 15.
                 - [1,2], [3], and [12] at a total cost of 1 + 3 + 12 = 16.

    Example 2:
    Input: nums = [5,4,3]
    Output: 12
    Explanation: The best possible way to form 3 subarrays is: [5], [4], and [3]
                 at a total cost of 5 + 4 + 3 = 12. It can be shown that 12 is
                 the minimum cost achievable.

    Example 3:
    Input: nums = [10,3,1,1]
    Output: 12
    Explanation: The best possible way to form 3 subarrays is: [10,3], [1], and
                 [1] at a total cost of 10 + 1 + 1 = 12. It can be shown that 12
                 is the minimum cost achievable.

    Constraints:
    * 3 <= n <= 50
    * 1 <= nums[i] <= 50*/

    public int minimumCost(int[] nums) {
        int m0 = 50, m1 = 50;
        for (int i = 1; i < nums.length; ++i)
            if (nums[i] < m0) {
                m1 = m0;
                m0 = nums[i];
            } else if (nums[i] < m1) m1 = nums[i];
        return nums[0] + m0 + m1;
    }


    /*3011. Find if Array Can Be Sorted (Medium)
    You are given a 0-indexed array of positive integers nums. In one operation,
    you can swap any two adjacent elements if they have the same number of set
    bits. You are allowed to do this operation any number of times (including
    zero). Return true if you can sort the array, else return false.

    Example 1:
    Input: nums = [8,4,2,30,15]
    Output: true
    Explanation: Let's look at the binary representation of every element. The
                 numbers 2, 4, and 8 have one set bit each with binary
                 representation "10", "100", and "1000" respectively. The
                 numbers 15 and 30 have four set bits each with binary
                 representation "1111" and "11110". We can sort the array using
                 4 operations:
                 - Swap nums[0] with nums[1]. This operation is valid because 8
                   and 4 have one set bit each. The array becomes [4,8,2,30,15].
                 - Swap nums[1] with nums[2]. This operation is valid because 8
                   and 2 have one set bit each. The array becomes [4,2,8,30,15].
                 - Swap nums[0] with nums[1]. This operation is valid because 4
                   and 2 have one set bit each. The array becomes [2,4,8,30,15].
                 - Swap nums[3] with nums[4]. This operation is valid because 30
                   and 15 have four set bits each. The array becomes [2,4,8,15,30].
                 The array has become sorted, hence we return true. Note that
                 there may be other sequences of operations which also sort the
                 array.

    Example 2:
    Input: nums = [1,2,3,4,5]
    Output: true
    Explanation: The array is already sorted, hence we return true.

    Example 3:
    Input: nums = [3,16,8,4,2]
    Output: false
    Explanation: It can be shown that it is not possible to sort the input array
                 using any number of operations.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 2^8*/

    public boolean canSortArray(int[] nums) {
        int bits = 0, curr = 0, prev = 0;
        for (var x : nums) {
            int b = 0;
            for (int xx = x; xx > 0; ++b, xx &= xx-1);
            if (bits != b) {
                bits = b;
                prev = curr;
            }
            if (prev > x) return false;
            curr = Math.max(curr, x);
        }
        return true;
    }


    /*3012. Minimize Length of Array Using Operations (Medium)
    You are given a 0-indexed integer array nums containing positive integers.
    Your task is to minimize the length of nums by performing the following
    operations any number of times (including zero):
    * Select two distinct indices i and j from nums, such that nums[i] > 0 and
      nums[j] > 0.
    * Insert the result of nums[i] % nums[j] at the end of nums.
    * Delete the elements at indices i and j from nums.
    Return an integer denoting the minimum length of nums after performing the
    operation any number of times.

    Example 1:
    Input: nums = [1,4,3,1]
    Output: 1
    Explanation: One way to minimize the length of the array is as follows:
                 - Operation 1: Select indices 2 and 1, insert nums[2] % nums[1]
                   at the end and it becomes [1,4,3,1,3], then delete elements
                   at indices 2 and 1. nums becomes [1,1,3].
                 - Operation 2: Select indices 1 and 2, insert nums[1] % nums[2]
                   at the end and it becomes [1,1,3,1], then delete elements at
                   indices 1 and 2. nums becomes [1,1].
                 - Operation 3: Select indices 1 and 0, insert nums[1] % nums[0]
                   at the end and it becomes [1,1,0], then delete elements at
                   indices 1 and 0. nums becomes [0].
                 The length of nums cannot be reduced further. Hence, the answer
                 is 1. It can be shown that 1 is the minimum achievable length.

    Example 2:
    Input: nums = [5,5,5,10,5]
    Output: 2
    Explanation: One way to minimize the length of the array is as follows:
                 - Operation 1: Select indices 0 and 3, insert nums[0] % nums[3]
                   at the end and it becomes [5,5,5,10,5,5], then delete
                   elements at indices 0 and 3. nums becomes [5,5,5,5].
                 - Operation 2: Select indices 2 and 3, insert nums[2] % nums[3]
                   at the end and it becomes [5,5,5,5,0], then delete elements
                   at indices 2 and 3. nums becomes [5,5,0].
                 - Operation 3: Select indices 0 and 1, insert nums[0] % nums[1]
                   at the end and it becomes [5,5,0,0], then delete elements at
                   indices 0 and 1. nums becomes [0,0].
                 The length of nums cannot be reduced further. Hence, the answer
                 is 2. It can be shown that 2 is the minimum achievable length.

    Example 3:
    Input: nums = [2,3,4]
    Output: 1
    Explanation: One way to minimize the length of the array is as follows:
                 - Operation 1: Select indices 1 and 2, insert nums[1] % nums[2]
                   at the end and it becomes [2,3,4,3], then delete elements at
                   indices 1 and 2. nums becomes [2,3].
                 - Operation 2: Select indices 1 and 0, insert nums[1] % nums[0]
                   at the end and it becomes [2,3,1], then delete elements at
                   indices 1 and 0. nums becomes [1].
                 The length of nums cannot be reduced further. Hence, the answer
                 is 1. It can be shown that 1 is the minimum achievable length.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public int minimumArrayLength(int[] nums) {
        int m = IntStream.of(nums).min().getAsInt(), cnt = 0;
        for (var x : nums)
            if (x % m > 0) return 1;
            else if (x == m) ++cnt;
        return (cnt+1)/2;
    }


    /*3013. Divide an Array Into Subarrays With Minimum Cost II (Hard)
    You are given a 0-indexed array of integers nums of length n, and two
    positive integers k and dist. The cost of an array is the value of its first
    element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is
    3. You need to divide nums into k disjoint contiguous subarrays, such that
    the difference between the starting index of the second subarray and the
    starting index of the kth subarray should be less than or equal to dist. In
    other words, if you divide nums into the subarrays nums[0..(i1 - 1)],
    nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)], then ik-1 - i1 <= dist. Return
    the minimum possible sum of the cost of these subarrays.

    Example 1:
    Input: nums = [1,3,2,6,4,2], k = 3, dist = 3
    Output: 5
    Explanation: The best possible way to divide nums into 3 subarrays is:
                 [1,3], [2,6,4], and [2]. This choice is valid because ik-1 - i1
                 is 5 - 2 = 3 which is equal to dist. The total cost is
                 nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5. It can be
                 shown that there is no possible way to divide nums into 3
                 subarrays at a cost lower than 5.

    Example 2:
    Input: nums = [10,1,2,2,2,1], k = 4, dist = 3
    Output: 15
    Explanation: The best possible way to divide nums into 4 subarrays is:
                 [10], [1], [2], and [2,2,1]. This choice is valid because
                 ik-1 - i1 is 3 - 1 = 2 which is less than dist. The total cost
                 is nums[0] + nums[1] + nums[2] + nums[3] which is
                 10 + 1 + 2 + 2 = 15. The division [10], [1], [2,2,2], and [1]
                 is not valid, because the difference between ik-1 and i1 is
                 5 - 1 = 4, which is greater than dist. It can be shown that
                 there is no possible way to divide nums into 4 subarrays at a
                 cost lower than 15.

    Example 3:
    Input: nums = [10,8,18,9], k = 3, dist = 1
    Output: 36
    Explanation: The best possible way to divide nums into 4 subarrays is:
                 [10], [8], and [18,9]. This choice is valid because ik-1 - i1
                 is 2 - 1 = 1 which is equal to dist.The total cost is
                 nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36. The
                 division [10], [8,18], and [9] is not valid, because the
                 difference between ik-1 and i1 is 3 - 1 = 2, which is greater
                 than dist. It can be shown that there is no possible way to
                 divide nums into 3 subarrays at a cost lower than 36.

    Constraints:
    * 3 <= n <= 10^5
    * 1 <= nums[i] <= 10^9
    * 3 <= k <= n
    * k - 2 <= dist <= n - 2*/

    public long minimumCost(int[] nums, int k, int dist) {
        long ans = Long.MAX_VALUE, count = 0, total = 0;
        TreeMap<Integer, Integer> small = new TreeMap(), large = new TreeMap();
        for (int i = 1; i < nums.length; ++i) {
            if (i > dist+1) {
                int v = nums[i-dist-1];
                if (v <= small.lastKey()) {
                    small.merge(v, -1, Integer::sum);
                    if (small.get(v) == 0) small.remove(v);
                    --count;
                    total -= v;
                    if (!large.isEmpty()) {
                        int key = large.firstKey();
                        small.merge(key, 1, Integer::sum);
                        large.merge(key, -1, Integer::sum);
                        if (large.get(key) == 0) large.remove(key);
                        ++count;
                        total += key;
                    }
                } else {
                    large.merge(v, -1, Integer::sum);
                    if (large.get(v) == 0) large.remove(v);
                }
            }
            ++count;
            small.merge(nums[i], 1, Integer::sum);
            total += nums[i];
            if (count > k-1) {
                int key = small.lastKey();
                small.merge(key, -1, Integer::sum);
                if (small.get(key) == 0) small.remove(key);
                large.merge(key, 1, Integer::sum);
                --count;
                total -= key;
            }
            if (i >= k-1) {
                ans = Math.min(ans, total);
            }
        }
        return nums[0] + ans;
    }


    /*3016. Minimum Number of Pushes to Type Word II (Medium)
    You are given a string word containing lowercase English letters. Telephone
    keypads have keys mapped with distinct collections of lowercase English
    letters, which can be used to form words by pushing them. For example, the
    key 2 is mapped with ["a","b","c"], we need to push the key one time to type
    "a", two times to type "b", and three times to type "c". It is allowed to
    remap the keys numbered 2 to 9 to distinct collections of letters. The keys
    can be remapped to any amount of letters, but each letter must be mapped to
    exactly one key. You need to find the minimum number of times the keys will
    be pushed to type the string word. Return the minimum number of pushes
    needed to type word after remapping the keys. An example mapping of letters
    to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do
    not map to any letters.

    Example 1:
    Input: word = "abcde"
    Output: 5
    Explanation: The remapped keypad given in the image provides the minimum cost.
                 "a" -> one push on key 2
                 "b" -> one push on key 3
                 "c" -> one push on key 4
                 "d" -> one push on key 5
                 "e" -> one push on key 6
                 Total cost is 1 + 1 + 1 + 1 + 1 = 5. It can be shown that no
                 other mapping can provide a lower cost.

    Example 2:
    Input: word = "xyzxyzxyzxyz"
    Output: 12
    Explanation: The remapped keypad given in the image provides the minimum cost.
                 "x" -> one push on key 2
                 "y" -> one push on key 3
                 "z" -> one push on key 4
                 Total cost is 1 * 4 + 1 * 4 + 1 * 4 = 12
                 It can be shown that no other mapping can provide a lower cost.
                 Note that the key 9 is not mapped to any letter: it is not
                 necessary to map letters to every key, but to map all the letters.

    Example 3:
    Input: word = "aabbccddeeffgghhiiiiii"
    Output: 24
    Explanation: The remapped keypad given in the image provides the minimum cost.
                 "a" -> one push on key 2
                 "b" -> one push on key 3
                 "c" -> one push on key 4
                 "d" -> one push on key 5
                 "e" -> one push on key 6
                 "f" -> one push on key 7
                 "g" -> one push on key 8
                 "h" -> two pushes on key 9
                 "i" -> one push on key 9
                 Total cost is 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 +
                 1 * 2 + 2 * 2 + 6 * 1 = 24. It can be shown that no other
                 mapping can provide a lower cost.

    Constraints:
    * 1 <= word.length <= 10^5
    * word consists of lowercase English letters.*/

    public int minimumPushes(String word) {
        int[] freq = new int[26];
        for (var ch : word.toCharArray())
            ++freq[ch - 'a'];
        Arrays.sort(freq);
        int ans = 0;
        for (int i = 0, cnt = 0; i < 26; ++i) {
            if (i % 8 == 0) ++cnt;
            ans += freq[25-i] * cnt;
        }
        return ans;
    }


    /*3019. Number of Changing Keys (Easy)
    You are given a 0-indexed string s typed by a user. Changing a key is
    defined as using a key different from the last used key. For example,
    s = "ab" has a change of a key while s = "bBBb" does not have any. Return
    the number of times the user had to change the key. Note: Modifiers like
    shift or caps lock won't be counted in changing the key that is if a user
    typed the letter 'a' and then the letter 'A' then it will not be considered
    as a changing of key.

    Example 1:
    Input: s = "aAbBcC"
    Output: 2
    Explanation: - From s[0] = 'a' to s[1] = 'A', there is no change of key as
                   caps lock or shift is not counted.
                 - From s[1] = 'A' to s[2] = 'b', there is a change of key.
                 - From s[2] = 'b' to s[3] = 'B', there is no change of key as
                   caps lock or shift is not counted.
                 - From s[3] = 'B' to s[4] = 'c', there is a change of key.
                 - From s[4] = 'c' to s[5] = 'C', there is no change of key as
                   caps lock or shift is not counted.

    Example 2:
    Input: s = "AaAaAaaA"
    Output: 0
    Explanation: There is no change of key since only the letters 'a' and 'A'
                 are pressed which does not require change of key.

    Constraints:
    * 1 <= s.length <= 100
    * s consists of only upper case and lower case English letters.*/

    public int countKeyChanges(String s) {
        int ans = 0;
        for (int i = 1; i < s.length(); ++i)
            if (Character.toLowerCase(s.charAt(i-1)) != Character.toLowerCase(s.charAt(i))) ++ans;
        return ans;
    }


    /*3020. Find the Maximum Number of Elements in Subset (Medium)
    You are given an array of positive integers nums. You need to select a
    subset of nums which satisfies the following condition:
    * You can place the selected elements in a 0-indexed array such that it
      follows the pattern: [x, x2, x4, ..., xk/2, xk, xk/2, ..., x4, x2, x]
      (Note that k can be be any non-negative power of 2). For example,
      [2, 4, 16, 4, 2] and [3, 9, 3] follow the pattern while [2, 4, 8, 4, 2]
      does not.
    Return the maximum number of elements in a subset that satisfies these
    conditions.

    Example 1:
    Input: nums = [5,4,1,2,2]
    Output: 3
    Explanation: We can select the subset {4,2,2}, which can be placed in the
                 array as [2,4,2] which follows the pattern and 22 == 4. Hence
                 the answer is 3.

    Example 2:
    Input: nums = [1,3,2,4]
    Output: 1
    Explanation: We can select the subset {1}, which can be placed in the array
                 as [1] which follows the pattern. Hence the answer is 1. Note
                 that we could have also selected the subsets {2}, {4}, or {3},
                 there may be multiple subsets which provide the same answer.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public int maximumLength(int[] nums) {
        int ans = 0;
        Map<Long, Integer> freq = new HashMap();
        for (var x : nums) freq.merge(x, 1, Integer::sum);
        for (var elem : freq.entrySet()) {

        }
    }


    /*3021. Alice and Bob Playing Flower Game (Medium)
    Alice and Bob are playing a turn-based game on a circular field surrounded
    by flowers. The circle represents the field, and there are x flowers in the
    clockwise direction between Alice and Bob, and y flowers in the anti-
    clockwise direction between them. The game proceeds as follows:
    * Alice takes the first turn.
    * In each turn, a player must choose either the clockwise or anti-clockwise
      direction and pick one flower from that side.
    * At the end of the turn, if there are no flowers left at all, the current
      player captures their opponent and wins the game.
    Given two integers, n and m, the task is to compute the number of possible
    pairs (x, y) that satisfy the conditions:
    * Alice must win the game according to the described rules.
    * The number of flowers x in the clockwise direction must be in the range
      [1,n].
    * The number of flowers y in the anti-clockwise direction must be in the
      range [1,m].
    Return the number of possible pairs (x, y) that satisfy the conditions
    mentioned in the statement.

    Example 1:
    Input: n = 3, m = 2
    Output: 3
    Explanation: The following pairs satisfy conditions described in the
                 statement: (1,2), (3,2), (2,1).

    Example 2:
    Input: n = 1, m = 1
    Output: 0
    Explanation: No pairs satisfy the conditions described in the statement.

    Constraints: 1 <= n, m <= 10^5*/

    public long flowerGame(int n, int m) {
        return (long) m*n/2;
    }


    /*3022. Minimize OR of Remaining Elements Using Operations (Hard)
    You are given a 0-indexed integer array nums and an integer k. In one
    operation, you can pick any index i of nums such that
    0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a single
    occurrence of nums[i] & nums[i + 1], where & represents the bitwise AND
    operator. Return the minimum possible value of the bitwise OR of the
    remaining elements of nums after applying at most k operations.

    Example 1:
    Input: nums = [3,5,3,2,7], k = 2
    Output: 3
    Explanation: Let's do the following operations:
                 1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [1,3,2,7].
                 2. Replace nums[2] and nums[3] with (nums[2] & nums[3]) so that
                    nums becomes equal to [1,3,2].
                 The bitwise-or of the final array is 3. It can be shown that 3
                 is the minimum possible value of the bitwise OR of the
                 remaining elements of nums after applying at most k operations.

    Example 2:
    Input: nums = [7,3,15,14,2,8], k = 4
    Output: 2
    Explanation: Let's do the following operations:
                 1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [3,15,14,2,8].
                 2. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [3,14,2,8].
                 3. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that
                    nums becomes equal to [2,2,8].
                 4. Replace nums[1] and nums[2] with (nums[1] & nums[2]) so that
                    nums becomes equal to [2,0].
                 The bitwise-or of the final array is 2. It can be shown that 2
                 is the minimum possible value of the bitwise OR of the
                 remaining elements of nums after applying at most k operations.

    Example 3:
    Input: nums = [10,7,10,3,9,14,9,4], k = 1
    Output: 15
    Explanation: Without applying any operations, the bitwise-or of nums is 15.
                 It can be shown that 15 is the minimum possible value of the
                 bitwise OR of the remaining elements of nums after applying at
                 most k operations.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] < 2^30
    * 0 <= k < nums.length*/

    public int minOrAfterOperations(int[] nums, int k) {
        int ans = 0, n = nums.length;
        for (int bit = 30; bit >= 0; --bit) {
            int cnt = 0, mask = (1<<30)-1, target = ans | (1<<bit)-1;
            for (var x : nums) {
                mask &= x;
                if ((mask | target) > target) ++cnt;
                else mask = (1<<30)-1;
            }
            if (cnt > k) ans |= 1<<bit;
        }
        return ans;
    }


    /*3023. Find Pattern in Infinite Stream I (Medium)
    You are given a binary array pattern and an object stream of class
    InfiniteStream representing a 0-indexed infinite stream of bits. The class
    InfiniteStream contains the following function:
    * int next(): Reads a single bit (which is either 0 or 1) from the stream
      and returns it.
    Return the first starting index where the pattern matches the bits read from
    the stream. For example, if the pattern is [1, 0], the first match is the
    highlighted part in the stream [0, 1, 0, 1, ...].

    Example 1:
    Input: stream = [1,1,1,0,1,1,1,...], pattern = [0,1]
    Output: 3
    Explanation: The first occurrence of the pattern [0,1] is highlighted in the
                 stream [1,1,1,0,1,...], which starts at index 3.

    Example 2:
    Input: stream = [0,0,0,0,...], pattern = [0]
    Output: 0
    Explanation: The first occurrence of the pattern [0] is highlighted in the
                 stream [0,...], which starts at index 0.

    Example 3:
    Input: stream = [1,0,1,1,0,1,1,0,1,...], pattern = [1,1,0,1]
    Output: 2
    Explanation: The first occurrence of the pattern [1,1,0,1] is highlighted in
                 the stream [1,0,1,1,0,1,...], which starts at index 2.

    Constraints:
    * 1 <= pattern.length <= 100
    * pattern consists only of 0 and 1.
    * stream consists only of 0 and 1.
    * The input is generated such that the pattern's start index exists in the
      first 10^5 bits of the stream.*/

    public int findPattern(InfiniteStream infiniteStream, int[] pattern) {
        int n = pattern.length;
        int[] lps = new int[n];
        for (int i = 1, k = 0; i < n; ++i) {
            while (k > 0 && pattern[k] != pattern[i]) k = lps[k-1];
            if (pattern[k] == pattern[i]) ++k;
            lps[i] = k;
        }
        for (int i = 0, k = 0; true; ++i) {
            int ch = infiniteStream.next();
            while (k > 0 && pattern[k] != ch) k = lps[k-1];
            if (pattern[k] == ch) ++k;
            if (k == n) return i-n+1;
        }
    }


    /*3024. Type of Triangle II (Easy)
    You are given a 0-indexed integer array nums of size 3 which can form the
    sides of a triangle.
    * A triangle is called equilateral if it has all sides of equal length.
    * A triangle is called isosceles if it has exactly two sides of equal length.
    * A triangle is called scalene if all its sides are of different lengths.
    Return a string representing the type of triangle that can be formed or
    "none" if it cannot form a triangle.

    Example 1:
    Input: nums = [3,3,3]
    Output: "equilateral"
    Explanation: Since all the sides are of equal length, therefore, it will
                 form an equilateral triangle.

    Example 2:
    Input: nums = [3,4,5]
    Output: "scalene"
    Explanation: nums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.
                 nums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.
                 nums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3.
                 Since the sum of the two sides is greater than the third side
                 for all three cases, therefore, it can form a triangle. As all
                 the sides are of different lengths, it will form a scalene
                 triangle.

    Constraints:
    * nums.length == 3
    * 1 <= nums[i] <= 100*/

    public String triangleType(int[] nums) {
        Arrays.sort(nums);
        int x = nums[0], y = nums[1], z = nums[2];
        if (x + y <= z) return "none";
        if (x == z) return "equilateral";
        if (x == y || y == z) return "isosceles";
        return "scalene";
    }


    /*3025. Find the Number of Ways to Place People I (Medium)
    You are given a 2D array points of size n x 2 representing integer
    coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. We
    define the right direction as positive x-axis (increasing x-coordinate) and
    the left direction as negative x-axis (decreasing x-coordinate). Similarly,
    we define the up direction as positive y-axis (increasing y-coordinate) and
    the down direction as negative y-axis (decreasing y-coordinate). You have to
    place n people, including Chisato and Takina, at these points such that
    there is exactly one person at every point. Chisato wants to be alone with
    Takina, so Chisato will build a rectangular fence with Chisato's position as
    the upper left corner and Takina's position as the lower right corner of the
    fence (Note that the fence might not enclose any area, i.e. it can be a
    line). If any person other than Chisato and Takina is either inside the
    fence or on the fence, Chisato will be sad. Return the number of pairs of
    points where you can place Chisato and Takina, such that Chisato does not
    become sad on building the fence. Note that Chisato can only build a fence
    with Chisato's position as the upper left corner, and Takina's position as
    the lower right corner. For example, Chisato cannot build either of the
    fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and
    (3, 3), because:
    * With Chisato at (3, 3) and Takina at (1, 1), Chisato's position is not the
      upper left corner and Takina's position is not the lower right corner of
      the fence.
    * With Chisato at (1, 3) and Takina at (1, 1), Takina's position is not the
      lower right corner of the fence.

    Example 1:
    Input: points = [[1,1],[2,2],[3,3]]
    Output: 0
    Explanation: There is no way to place Chisato and Takina such that Chisato
                 can build a fence with Chisato's position as the upper left
                 corner and Takina's position as the lower right corner. Hence
                 we return 0.

    Example 2:
    Input: points = [[6,2],[4,4],[2,6]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (4, 4) and Takina at (6, 2).
                 - Place Chisato at (2, 6) and Takina at (4, 4).
                 You cannot place Chisato at (2, 6) and Takina at (6, 2) because
                 the person at (4, 4) will be inside the fence.

    Example 3:
    Input: points = [[3,1],[1,3],[1,1]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (1, 1) and Takina at (3, 1).
                 - Place Chisato at (1, 3) and Takina at (1, 1).
                 You cannot place Chisato at (1, 3) and Takina at (3, 1) because
                 the person at (1, 1) will be on the fence. Note that it does
                 not matter if the fence encloses any area, the first and second
                 fences in the image are valid.

    Constraints:
    * 2 <= n <= 50
    * points[i].length == 2
    * 0 <= points[i][0], points[i][1] <= 50
    * All points[i] are distinct.*/

    public int numberOfPairs(int[][] points) {
        int ans = 0;
        Arrays.sort(points, (a, b) -> a[0] == b[0] ? Integer.compare(b[1], a[1]) : Integer.compare(a[0], b[0]));
        for (int i = 0, n = points.length; i < n; ++i) {
            int val = Integer.MIN_VALUE;
            for (int ii = i+1; ii < n; ++ii) {
                if (points[i][1] >= points[ii][1] && points[ii][1] > val) {
                    ++ans;
                    val = points[ii][1];
                }
            }
        }
        return ans;
    }


    /*3026. Maximum Good Subarray Sum (Medium)
    You are given an array nums of length n and a positive integer k. A subarray
    of nums is called good if the absolute difference between its first and last
    element is exactly k, in other words, the subarray nums[i..j] is good if
    |nums[i] - nums[j]| == k. Return the maximum sum of a good subarray of nums.
    If there are no good subarrays, return 0.

    Example 1:
    Input: nums = [1,2,3,4,5,6], k = 1
    Output: 11
    Explanation: The absolute difference between the first and last element must
                 be 1 for a good subarray. All the good subarrays are:
                 [1,2], [2,3], [3,4], [4,5], and [5,6]. The maximum subarray sum
                 is 11 for the subarray [5,6].

    Example 2:
    Input: nums = [-1,3,2,4,5], k = 3
    Output: 11
    Explanation: The absolute difference between the first and last element must
                 be 3 for a good subarray. All the good subarrays are: [-1,3,2],
                 and [2,4,5]. The maximum subarray sum is 11 for the subarray
                 [2,4,5].

    Example 3:
    Input: nums = [-1,-2,-3,-4], k = 2
    Output: -6
    Explanation: The absolute difference between the first and last element must
                 be 2 for a good subarray. All the good subarrays are:
                 [-1,-2,-3], and [-2,-3,-4]. The maximum subarray sum is -6 for
                 the subarray [-1,-2,-3].

    Constraints:
    * 2 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9
    * 1 <= k <= 10^9*/

    public long maximumSubarraySum(int[] nums, int k) {
        long ans = Long.MIN_VALUE, prefix = 0;
        Map<Integer, Long> seen = new HashMap();
        for (var x : nums) {
            prefix += x;
            if (seen.containsKey(x-k)) ans = Math.max(ans, prefix - seen.get(x-k));
            if (seen.containsKey(x+k)) ans = Math.max(ans, prefix - seen.get(x+k));
            seen.put(x, Math.min(prefix-x, seen.getOrDefault(x, Long.MAX_VALUE)));
        }
        return ans > Long.MIN_VALUE ? ans : 0;
    }


    /*3027. Find the Number of Ways to Place People II (Hard)
    You are given a 2D array points of size n x 2 representing integer
    coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. We
    define the right direction as positive x-axis (increasing x-coordinate) and
    the left direction as negative x-axis (decreasing x-coordinate). Similarly,
    we define the up direction as positive y-axis (increasing y-coordinate) and
    the down direction as negative y-axis (decreasing y-coordinate). You have to
    place n people, including Chisato and Takina, at these points such that
    there is exactly one person at every point. Chisato wants to be alone with
    Takina, so Chisato will build a rectangular fence with Chisato's position as
    the upper left corner and Takina's position as the lower right corner of the
    fence (Note that the fence might not enclose any area, i.e. it can be a
    line). If any person other than Chisato and Takina is either inside the
    fence or on the fence, Chisato will be sad. Return the number of pairs of
    points where you can place Chisato and Takina, such that Chisato does not
    become sad on building the fence. Note that Chisato can only build a fence
    with Chisato's position as the upper left corner, and Takina's position as
    the lower right corner. For example, Chisato cannot build either of the
    fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and
    (3, 3), because:
    * With Chisato at (3, 3) and Takina at (1, 1), Chisato's position is not the
      upper left corner and Takina's position is not the lower right corner of
      the fence.
    * With Chisato at (1, 3) and Takina at (1, 1), Takina's position is not the
      lower right corner of the fence.

    Example 1:
    Input: points = [[1,1],[2,2],[3,3]]
    Output: 0
    Explanation: There is no way to place Chisato and Takina such that Chisato
                 can build a fence with Chisato's position as the upper left
                 corner and Takina's position as the lower right corner. Hence
                 we return 0.

    Example 2:
    Input: points = [[6,2],[4,4],[2,6]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (4, 4) and Takina at (6, 2).
                 - Place Chisato at (2, 6) and Takina at (4, 4).
                 You cannot place Chisato at (2, 6) and Takina at (6, 2) because
                 the person at (4, 4) will be inside the fence.

    Example 3:
    Input: points = [[3,1],[1,3],[1,1]]
    Output: 2
    Explanation: There are two ways to place Chisato and Takina such that
                 Chisato will not be sad:
                 - Place Chisato at (1, 1) and Takina at (3, 1).
                 - Place Chisato at (1, 3) and Takina at (1, 1).
                 You cannot place Chisato at (1, 3) and Takina at (3, 1) because
                 the person at (1, 1) will be on the fence. Note that it does
                 not matter if the fence encloses any area, the first and second
                 fences in the image are valid.

    Constraints:
    * 2 <= n <= 1000
    * points[i].length == 2
    * -10^9 <= points[i][0], points[i][1] <= 10^9
    * All points[i] are distinct.*/

    public int numberOfPairs(int[][] points) {
        int ans = 0;
        Arrays.sort(points, (a, b) -> a[0] == b[0] ? Integer.compare(b[1], a[1]) : Integer.compare(a[0], b[0]));
        for (int i = 0, n = points.length; i < n; ++i) {
            int val = Integer.MIN_VALUE;
            for (int ii = i+1; ii < n; ++ii) {
                if (points[i][1] >= points[ii][1] && points[ii][1] > val) {
                    ++ans;
                    val = points[ii][1];
                }
            }
        }
        return ans;
    }


    /*3028. Ant on the Boundary (Easy)
    An ant is on a boundary. It sometimes goes left and sometimes right. You are
    given an array of non-zero integers nums. The ant starts reading nums from
    the first element of it to its end. At each step, it moves according to the
    value of the current element:
    * If nums[i] < 0, it moves left by -nums[i] units.
    * If nums[i] > 0, it moves right by nums[i] units.
    Return the number of times the ant returns to the boundary.

    Notes:
    * There is an infinite space on both sides of the boundary.
    * We check whether the ant is on the boundary only after it has moved
      |nums[i]| units. In other words, if the ant crosses the boundary during
      its movement, it does not count.

    Example 1:
    Input: nums = [2,3,-5]
    Output: 1
    Explanation: - After the first step, the ant is 2 steps to the right of the
                   boundary.
                 - After the second step, the ant is 5 steps to the right of the
                   boundary.
                 - After the third step, the ant is on the boundary.
                 So the answer is 1.

    Example 2:
    Input: nums = [3,2,-3,-4]
    Output: 0
    Explanation: - After the first step, the ant is 3 steps to the right of the
                   boundary.
                 - After the second step, the ant is 5 steps to the right of the
                   boundary.
                 - After the third step, the ant is 2 steps to the right of the
                   boundary.
                 - After the fourth step, the ant is 2 steps to the left of the
                   boundary.
                 The ant never returned to the boundary, so the answer is 0.

    Constraints:
    * 1 <= nums.length <= 100
    * -10 <= nums[i] <= 10
    * nums[i] != 0*/

    public int returnToBoundaryCount(int[] nums) {
        int ans = 0, prefix = 0;
        for (var x : nums) {
            prefix += x;
            if (prefix == 0) ++ans;
        }
        return ans;
    }


    /*3029. Minimum Time to Revert Word to Initial State I (Medium)
    You are given a 0-indexed string word and an integer k. At every second, you
    must perform the following operations:
    * Remove the first k characters of word.
    * Add any k characters to the end of word.
    Note that you do not necessarily need to add the same characters that you
    removed. However, you must perform both operations at every second. Return
    the minimum time greater than zero required for word to revert to its
    initial state.

    Example 1:
    Input: word = "abacaba", k = 3
    Output: 2
    Explanation: - At the 1st second, we remove characters "aba" from the prefix
                   of word, and add characters "bac" to the end of word. Thus,
                   word becomes equal to "cababac".
                 - At the 2nd second, we remove characters "cab" from the prefix
                   of word, and add "aba" to the end of word. Thus, word becomes
                   equal to "abacaba" and reverts to its initial state.
                 It can be shown that 2 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 2:
    Input: word = "abacaba", k = 4
    Output: 1
    Explanation: - At the 1st second, we remove characters "abac" from the
                   prefix of word, and add characters "caba" to the end of word.
                   Thus, word becomes equal to "abacaba" and reverts to its
                   initial state.
                 It can be shown that 1 second is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 3:
    Input: word = "abcbabcd", k = 2
    Output: 4
    Explanation: - At every second, we will remove the first 2 characters of
                   word, and add the same characters to the end of word.
                 - After 4 seconds, word becomes equal to "abcbabcd" and reverts
                   to its initial state.
                 It can be shown that 4 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Constraints:
    * 1 <= word.length <= 50
    * 1 <= k <= word.length
    * word consists only of lowercase English letters.*/

    private int[] z_algo(String s) {
        int n = s.length();
        int[] ans = new int[n];
        for (int i = 1, ii = 0, lo = 0, hi = 0; i < n; ++i) {
            if (i <= hi) ii = i - lo;
            if (i + ans[ii] <= hi) ans[i] = ans[ii];
            else {
                lo = i;
                hi = Math.max(hi, i);
                while (hi < n && s.charAt(hi) == s.charAt(hi-lo)) ++hi;
                ans[i] = hi - lo;
                --hi;
            }
        }
        return ans;
    }

    public int minimumTimeToInitialState(String word, int k) {
        int[] z = z_algo(word);
        int i = 0;
        for (int n = word.length(); i*k < n; ++i)
            if (z[i*k] + i*k == n) break;
        return i;
    }


    /*3030. Find the Grid of Region Average (Medium)
    You are given m x n grid image which represents a grayscale image, where
    image[i][j] represents a pixel with intensity in the range [0..255]. You are
    also given a non-negative integer threshold. Two pixels are adjacent if they
    share an edge. A region is a 3 x 3 subgrid where the absolute difference in
    intensity between any two adjacent pixels is less than or equal to threshold.
    All pixels in a region belong to that region, note that a pixel can belong
    to multiple regions. You need to calculate a m x n grid result, where
    result[i][j] is the average intensity of the regions to which image[i][j]
    belongs, rounded down to the nearest integer. If image[i][j] belongs to
    multiple regions, result[i][j] is the average of the rounded-down average
    intensities of these regions, rounded down to the nearest integer. If
    image[i][j] does not belong to any region, result[i][j] is equal to
    image[i][j]. Return the grid result.

    Example 1:
    Input: image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3
    Output: [[9,9,9,9],[9,9,9,9],[9,9,9,9]]
    Explanation: There are two regions as illustrated above. The average
                 intensity of the first region is 9, while the average intensity
                 of the second region is 9.67 which is rounded down to 9. The
                 average intensity of both of the regions is (9 + 9) / 2 = 9. As
                 all the pixels belong to either region 1, region 2, or both of
                 them, the intensity of every pixel in the result is 9. Please
                 note that the rounded-down values are used when calculating the
                 average of multiple regions, hence the calculation is done
                 using 9 as the average intensity of region 2, not 9.67.

    Example 2:
    Input: image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12
    Output: [[25,25,25],[27,27,27],[27,27,27],[30,30,30]]
    Explanation: There are two regions as illustrated above. The average
                 intensity of the first region is 25, while the average
                 intensity of the second region is 30. The average intensity of
                 both of the regions is (25 + 30) / 2 = 27.5 which is rounded
                 down to 27. All the pixels in row 0 of the image belong to
                 region 1, hence all the pixels in row 0 in the result are 25.
                 Similarly, all the pixels in row 3 in the result are 30. The
                 pixels in rows 1 and 2 of the image belong to region 1 and
                 region 2, hence their assigned value is 27 in the result.

    Example 3:
    Input: image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1
    Output: [[5,6,7],[8,9,10],[11,12,13]]
    Explanation: There is only one 3 x 3 subgrid, while it does not have the
                 condition on difference of adjacent pixels, for example, the
                 difference between image[0][0] and image[1][0] is
                 |5 - 8| = 3 > threshold = 1. None of them belong to any valid
                 regions, so the result should be the same as image.

    Constraints:
    * 3 <= n, m <= 500
    * 0 <= image[i][j] <= 255
    * 0 <= threshold <= 255*/

    public int[][] resultGrid(int[][] image, int threshold) {
        int m = image.length, n = image[0].length;
        int[][][] ans = new int[m][n][2];
        for (int i = 0; i < m-2; ++i)
            for (int j = 0; j < n-2; ++j) {
                int diff = 0, total = 0;
                for (int ii = i; ii <= i+2; ++ii)
                    for (int jj = j; jj <= j+2; ++jj) {
                        total += image[ii][jj];
                        if (ii+1 <= i+2) diff = Math.max(diff, Math.abs(image[ii][jj]-image[ii+1][jj]));
                        if (jj+1 <= j+2) diff = Math.max(diff, Math.abs(image[ii][jj]-image[ii][jj+1]));
                    }
                if (diff <= threshold) {
                    for (int ii = i; ii <= i+2; ++ii)
                        for (int jj = j; jj <= j+2; ++jj) {
                            ans[ii][jj][0] += total/9;
                            ans[ii][jj][1] += 1;
                        }
                }
            }
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (ans[i][j][1] > 0)
                    image[i][j] = ans[i][j][0] / ans[i][j][1];
        return image;
    }


    /*3031. Minimum Time to Revert Word to Initial State II (Hard)
    You are given a 0-indexed string word and an integer k. At every second, you
    must perform the following operations:
    * Remove the first k characters of word.
    * Add any k characters to the end of word.
    Note that you do not necessarily need to add the same characters that you
    removed. However, you must perform both operations at every second. Return
    the minimum time greater than zero required for word to revert to its
    initial state.

    Example 1:
    Input: word = "abacaba", k = 3
    Output: 2
    Explanation: - At the 1st second, we remove characters "aba" from the prefix
                   of word, and add characters "bac" to the end of word. Thus,
                   word becomes equal to "cababac".
                 - At the 2nd second, we remove characters "cab" from the prefix
                   of word, and add "aba" to the end of word. Thus, word becomes
                   equal to "abacaba" and reverts to its initial state.
                 It can be shown that 2 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 2:
    Input: word = "abacaba", k = 4
    Output: 1
    Explanation: - At the 1st second, we remove characters "abac" from the
                   prefix of word, and add characters "caba" to the end of word.
                   Thus, word becomes equal to "abacaba" and reverts to its
                   initial state.
                 It can be shown that 1 second is the minimum time greater than
                 zero required for word to revert to its initial state.

    Example 3:
    Input: word = "abcbabcd", k = 2
    Output: 4
    Explanation: - At every second, we will remove the first 2 characters of
                   word, and add the same characters to the end of word.
                 - After 4 seconds, word becomes equal to "abcbabcd" and reverts
                   to its initial state.
                 It can be shown that 4 seconds is the minimum time greater than
                 zero required for word to revert to its initial state.

    Constraints:
    * 1 <= word.length <= 10^6
    * 1 <= k <= word.length
    * word consists only of lowercase English letters.*/

    private int[] z_algo(String s) {
        int n = s.length();
        int[] ans = new int[n];
        for (int i = 1, ii = 0, lo = 0, hi = 0; i < n; ++i) {
            if (i <= hi) ii = i - lo;
            if (i + ans[ii] <= hi) ans[i] = ans[ii];
            else {
                lo = i;
                hi = Math.max(hi, i);
                while (hi < n && s.charAt(hi) == s.charAt(hi-lo)) ++hi;
                ans[i] = hi - lo;
                --hi;
            }
        }
        return ans;
    }

    public int minimumTimeToInitialState(String word, int k) {
        int[] z = z_algo(word);
        int i = 0;
        for (int n = word.length(); i*k < n; ++i)
            if (z[i*k] + i*k == n) break;
        return i;
    }


    /*3032. Count Numbers With Unique Digits II (Easy)
    Given two positive integers a and b, return the count of numbers having
    unique digits in the range [a, b] (inclusive).

    Example 1:
    Input: a = 1, b = 20
    Output: 19
    Explanation: All the numbers in the range [1, 20] have unique digits except
                 11. Hence, the answer is 19.

    Example 2:
    Input: a = 9, b = 19
    Output: 10
    Explanation: All the numbers in the range [9, 19] have unique digits except
                 11. Hence, the answer is 10.

    Example 3:
    Input: a = 80, b = 120
    Output: 27
    Explanation: There are 41 numbers in the range [80, 120], 27 of which have
                 unique digits.

    Constraints: 1 <= a <= b <= 1000*/

    public int numberCount(int a, int b) {
        int ans = 0;
        for (int x = a; x <= b; ++x) {
            boolean found = false;
            for (int xx = x, mask = 0; xx > 0; xx /= 10) {
                int d = xx % 10;
                if ((mask & 1<<d) > 0) {
                    found = true;
                    break;
                }
                mask ^= 1<<d;
            }
            if (!found) ++ans;
        }
        return ans;
    }


    /*3033. Modify the Matrix （Easy）
    Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix
    called answer. Make answer equal to matrix, then replace each element with
    the value -1 with the maximum element in its respective column. Return the
    matrix answer.

    Example 1:
    Input: matrix = [[1,2,-1],[4,-1,6],[7,8,9]]
    Output: [[1,2,9],[4,8,6],[7,8,9]]
    Explanation: The diagram above shows the elements that are changed (in blue).
                 - We replace the value in the cell [1][1] with the maximum
                   value in the column 1, that is 8.
                 - We replace the value in the cell [0][2] with the maximum
                   value in the column 2, that is 9.

    Example 2:
    Input: matrix = [[3,-1],[5,2]]
    Output: [[3,2],[5,2]]
    Explanation: The diagram above shows the elements that are changed (in blue).

    Constraints:
    * m == matrix.length
    * n == matrix[i].length
    * 2 <= m, n <= 50
    * -1 <= matrix[i][j] <= 100
    * The input is generated such that each column contains at least one non-
      negative integer.*/

    public int[][] modifiedMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        for (int j = 0; j < n; ++j) {
            int mv = -1;
            for (int i = 0; i < m; ++i)
                mv = Math.max(mv, matrix[i][j]);
            for (int i = 0; i < m; ++i)
                if (matrix[i][j] == -1) matrix[i][j] = mv;
        }
        return matrix;
    }


    /*3034. Number of Subarrays That Match a Pattern I (Medium)
    You are given a 0-indexed integer array nums of size n, and a 0-indexed
    integer array pattern of size m consisting of integers -1, 0, and 1. A
    subarray nums[i..j] of size m + 1 is said to match the pattern if the
    following conditions hold for each element pattern[k]:
    * nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
    * nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
    * nums[i + k + 1] < nums[i + k] if pattern[k] == -1.
    Return the count of subarrays in nums that match the pattern.

    Example 1:
    Input: nums = [1,2,3,4,5,6], pattern = [1,1]
    Output: 4
    Explanation: The pattern [1,1] indicates that we are looking for strictly
                 increasing subarrays of size 3. In the array nums, the
                 subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this
                 pattern. Hence, there are 4 subarrays in nums that match the
                 pattern.

    Example 2:
    Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
    Output: 2
    Explanation: Here, the pattern [1,0,-1] indicates that we are looking for a
                 sequence where the first number is smaller than the second, the
                 second is equal to the third, and the third is greater than the
                 fourth. In the array nums, the subarrays [1,4,4,1], and
                 [3,5,5,3] match this pattern. Hence, there are 2 subarrays in
                 nums that match the pattern.

    Constraints:
    * 2 <= n == nums.length <= 100
    * 1 <= nums[i] <= 10^9
    * 1 <= m == pattern.length < n
    * -1 <= pattern[i] <= 1*/

    public int countMatchingSubarrays(int[] nums, int[] pattern) {
        int m = pattern.length, n = nums.length;
        int[] text = new int[n-1];
        for (int i = 1; i < n; ++i) {
            int diff = nums[i] - nums[i-1];
            if (diff != 0) diff /= Math.abs(diff);
            text[i-1] = diff;
        }
        int[] lps = new int[m];
        for (int i = 1, k = 0; i < m; ++i) {
            while (k > 0 && pattern[k] != pattern[i]) k = lps[k-1];
            if (pattern[k] == pattern[i]) ++k;
            lps[i] = k;
        }
        int ans = 0;
        for (int i = 0, k = 0; i < n-1; ++i) {
            while (k > 0 && (k == m || pattern[k] != text[i])) k = lps[k-1];
            if (pattern[k] == text[i]) ++k;
            if (k == m) ++ans;
        }
        return ans;
    }


    /*3035. Maximum Palindromes After Operations (Medium)
    You are given a 0-indexed string array words having length n and containing
    0-indexed strings. You are allowed to perform the following operation any
    number of times (including zero):
    * Choose integers i, j, x, and y such that 0 <= i, j < n,
      0 <= x < words[i].length, 0 <= y < words[j].length, and swap the
      characters words[i][x] and words[j][y].
    Return an integer denoting the maximum number of palindromes words can
    contain, after performing some operations. Note: i and j may be equal during
    an operation.

    Example 1:
    Input: words = ["abbb","ba","aa"]
    Output: 3
    Explanation: In this example, one way to get the maximum number of
                 palindromes is:
                 - Choose i = 0, j = 1, x = 0, y = 0, so we swap words[0][0] and
                   words[1][0]. words becomes ["bbbb","aa","aa"].
                 All strings in words are now palindromes. Hence, the maximum
                 number of palindromes achievable is 3.

    Example 2:
    Input: words = ["abc","ab"]
    Output: 2
    Explanation: In this example, one way to get the maximum number of
                 palindromes is:
                 - Choose i = 0, j = 1, x = 1, y = 0, so we
                   words[1][0]. words becomes ["aac","bb"].
                 - Choose i = 0, j = 0, x = 1, y = 2, so we swap words[0][1] and
                   words[0][2]. words becomes ["aca","bb"].
                 Both strings are now palindromes. Hence, the maximum number of
                 palindromes achievable is 2.

    Example 3:
    Input: words = ["cd","ef","a"]
    Output: 1
    Explanation: In this example, there is no need to perform any operation.
                 There is one palindrome in words "a". It can be shown that it
                 is not possible to get more than one palindrome after any
                 number of operations. Hence, the answer is 1.

    Constraints:
    * 1 <= words.length <= 1000
    * 1 <= words[i].length <= 100
    * words[i] consists only of lowercase English letters.*/

    public int maxPalindromesAfterOperations(String[] words) {
        int[] freq = new int[26];
        for (var word : words)
            for (var ch : word.toCharArray())
                ++freq[ch-97];
        int pairs = 0;
        for (var x : freq) pairs += x/2;
        Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));
        for (int i = 0; i < words.length; ++i) {
            pairs -= words[i].length()/2;
            if (pairs < 0) return i;
        }
        return words.length;
    }


    /*3036. Number of Subarrays That Match a Pattern II (Hard)
    You are given a 0-indexed integer array nums of size n, and a 0-indexed
    integer array pattern of size m consisting of integers -1, 0, and 1. A
    subarray nums[i..j] of size m + 1 is said to match the pattern if the
    following conditions hold for each element pattern[k]:
    * nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
    * nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
    * nums[i + k + 1] < nums[i + k] if pattern[k] == -1.
    Return the count of subarrays in nums that match the pattern.

    Example 1:
    Input: nums = [1,2,3,4,5,6], pattern = [1,1]
    Output: 4
    Explanation: The pattern [1,1] indicates that we are looking for strictly
                 increasing subarrays of size 3. In the array nums, the
                 subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this
                 pattern. Hence, there are 4 subarrays in nums that match the
                 pattern.

    Example 2:
    Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
    Output: 2
    Explanation: Here, the pattern [1,0,-1] indicates that we are looking for a
                 sequence where the first number is smaller than the second, the
                 second is equal to the third, and the third is greater than the
                 fourth. In the array nums, the subarrays [1,4,4,1], and
                 [3,5,5,3] match this pattern. Hence, there are 2 subarrays in
                 nums that match the pattern.

    Constraints:
    * 2 <= n == nums.length <= 10^6
    * 1 <= nums[i] <= 10^9
    * 1 <= m == pattern.length < n
    * -1 <= pattern[i] <= 1*/

    public int countMatchingSubarrays(int[] nums, int[] pattern) {
        int m = pattern.length, n = nums.length;
        int[] text = new int[n-1];
        for (int i = 1; i < n; ++i) {
            int diff = nums[i] - nums[i-1];
            if (diff != 0) diff /= Math.abs(diff);
            text[i-1] = diff;
        }
        int[] lps = new int[m];
        for (int i = 1, k = 0; i < m; ++i) {
            while (k > 0 && pattern[k] != pattern[i]) k = lps[k-1];
            if (pattern[k] == pattern[i]) ++k;
            lps[i] = k;
        }
        int ans = 0;
        for (int i = 0, k = 0; i < n-1; ++i) {
            while (k > 0 && (k == m || pattern[k] != text[i])) k = lps[k-1];
            if (pattern[k] == text[i]) ++k;
            if (k == m) ++ans;
        }
        return ans;
    }


    /*3037. Find Pattern in Infinite Stream II (Hard)
    You are given a binary array pattern and an object stream of class
    InfiniteStream representing a 0-indexed infinite stream of bits. The class
    InfiniteStream contains the following function:
    * int next(): Reads a single bit (which is either 0 or 1) from the stream
      and returns it.
    Return the first starting index where the pattern matches the bits read from
    the stream. For example, if the pattern is [1, 0], the first match is the
    highlighted part in the stream [0, 1, 0, 1, ...].

    Example 1:
    Input: stream = [1,1,1,0,1,1,1,...], pattern = [0,1]
    Output: 3
    Explanation: The first occurrence of the pattern [0,1] is highlighted in the
                 stream [1,1,1,0,1,...], which starts at index 3.

    Example 2:
    Input: stream = [0,0,0,0,...], pattern = [0]
    Output: 0
    Explanation: The first occurrence of the pattern [0] is highlighted in the
                 stream [0,...], which starts at index 0.

    Example 3:
    Input: stream = [1,0,1,1,0,1,1,0,1,...], pattern = [1,1,0,1]
    Output: 2
    Explanation: The first occurrence of the pattern [1,1,0,1] is highlighted in
                 the stream [1,0,1,1,0,1,...], which starts at index 2.

    Constraints:
    * 1 <= pattern.length <= 10^4
    * pattern consists only of 0 and 1.
    * stream consists only of 0 and 1.
    * The input is generated such that the pattern's start index exists in the
      first 10^5 bits of the stream.*/

    public int findPattern(InfiniteStream infiniteStream, int[] pattern) {
        int n = pattern.length;
        int[] lps = new int[n];
        for (int i = 1, k = 0; i < n; ++i) {
            while (k > 0 && pattern[k] != pattern[i]) k = lps[k-1];
            if (pattern[k] == pattern[i]) ++k;
            lps[i] = k;
        }
        for (int i = 0, k = 0; ; ++i) {
            int ch = infiniteStream.next();
            while (k > 0 && pattern[k] != ch) k = lps[k-1];
            if (pattern[k] == ch) ++k;
            if (k == n) return i-k+1;
        }
    }


    /*3038. Maximum Number of Operations With the Same Score I (Easy)
    Given an array of integers called nums, you can perform the following
    operation while nums contains at least 2 elements:
    * Choose the first two elements of nums and delete them.
    The score of the operation is the sum of the deleted elements. Your task is
    to find the maximum number of operations that can be performed, such that
    all operations have the same score. Return the maximum number of operations
    possible that satisfy the condition mentioned above.

    Example 1:
    Input: nums = [3,2,1,4,5]
    Output: 2
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [1,4,5].
                 - Delete the first two elements, with score 1 + 4 = 5,
                   nums = [5].
                 We are unable to perform any more operations as nums contain
                 only 1 element.

    Example 2:
    Input: nums = [3,2,6,1,4]
    Output: 1
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [6,1,4].
                 We are unable to perform any more operations as the score of
                 the next operation isn't the same as the previous one.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 1000*/

    public int maxOperations(int[] nums) {
        int ans = 0, score = nums[0] + nums[1];
        for (int i = 0; i+1 < nums.length; i += 2)
            if (nums[i] + nums[i+1] == score) ++ans;
            else break;
        return ans;
    }


    /*3039. Apply Operations to Make String Empty (Medium)
    You are given a string s. Consider performing the following operation until
    s becomes empty:
    * For every alphabet character from 'a' to 'z', remove the first occurrence
      of that character in s (if it exists).
    For example, let initially s = "aabcbbca". We do the following operations:
    * Remove the underlined characters s = "aabcbbca". The resulting string is
      s = "abbca".
    * Remove the underlined characters s = "abbca". The resulting string is
      s = "ba".
    * Remove the underlined characters s = "ba". The resulting string is s = "".
    Return the value of the string s right before applying the last operation.
    In the example above, answer is "ba".

    Example 1:
    Input: s = "aabcbbca"
    Output: "ba"
    Explanation: Explained in the statement.

    Example 2:
    Input: s = "abcd"
    Output: "abcd"
    Explanation: We do the following operation:
                 - Remove the underlined characters s = "abcd". The resulting
                   string is s = "".
                 The string just before the last operation is "abcd".

    Constraints:
    * 1 <= s.length <= 5 * 10^5
    * s consists only of lowercase English letters.*/

    public String lastNonEmptyString(String s) {
        int m = 0;
        Map<Character, Integer> freq = new HashMap<>();
        for (var ch : s.toCharArray()) {
            freq.merge(ch, 1, Integer::sum);
            m = Math.max(m, freq.get(ch));
        }
        StringBuilder ans = new StringBuilder();
        for (int i = s.length()-1; i >= 0; --i) {
            char ch = s.charAt(i);
            if (freq.get(ch) == m) {
                ans.append(ch);
                freq.merge(ch, -1, Integer::sum);
            }
        }
        return ans.reverse().toString();
    }


    /*3040. Maximum Number of Operations With the Same Score II (Medium)
    Given an array of integers called nums, you can perform any of the following
    operation while nums contains at least 2 elements:
    * Choose the first two elements of nums and delete them.
    * Choose the last two elements of nums and delete them.
    * Choose the first and the last elements of nums and delete them.
    The score of the operation is the sum of the deleted elements. Your task is
    to find the maximum number of operations that can be performed, such that
    all operations have the same score. Return the maximum number of operations
    possible that satisfy the condition mentioned above.

    Example 1:
    Input: nums = [3,2,1,2,3,4]
    Output: 3
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [1,2,3,4].
                 - Delete the first and the last elements, with score 1 + 4 = 5,
                   nums = [2,3].
                 - Delete the first and the last elements, with score 2 + 3 = 5,
                   nums = [].
                 We are unable to perform any more operations as nums is empty.

    Example 2:
    Input: nums = [3,2,6,1,4]
    Output: 2
    Explanation: We perform the following operations:
                 - Delete the first two elements, with score 3 + 2 = 5,
                   nums = [6,1,4].
                 - Delete the last two elements, with score 1 + 4 = 5,
                   nums = [6].
                 It can be proven that we can perform at most 2 operations.

    Constraints:
    * 2 <= nums.length <= 2000
    * 1 <= nums[i] <= 1000*/

    private int fn(int i, int j, int t, int[] nums, Map<Integer, int[][]> memo) {
        if (i >= j) return 0;
        if (!memo.containsKey(t)) {
            int n = nums.length;
            memo.put(t, new int[n][n]);
        }
        if (memo.get(t)[i][j] == 0) {
            int ans = 0;
            if (nums[i]+nums[i+1] == t) ans = Math.max(ans, 1+fn(i+2, j, t, nums, memo));
            if (nums[j-1]+nums[j] == t) ans = Math.max(ans, 1+fn(i, j-2, t, nums, memo));
            if (nums[i]+nums[j] == t) ans = Math.max(ans, 1+fn(i+1, j-1, t, nums, memo));
            memo.get(t)[i][j] = ans;
        }
        return memo.get(t)[i][j];
    }

    public int maxOperations(int[] nums) {
        int ans = 0, n = nums.length;
        Map<Integer, int[][]> memo = new HashMap<>();
        for (var t : new int[]{nums[0]+nums[1], nums[n-2]+nums[n-1], nums[0]+nums[n-1]})
            ans = Math.max(ans, fn(0, n-1, t, nums, memo));
        return ans;
    }


    /*3041. Maximize Consecutive Elements in an Array After Modification (Hard)
    You are given a 0-indexed array nums consisting of positive integers.
    Initially, you can increase the value of any element in the array by at most
    1. After that, you need to select one or more elements from the final array
    such that those elements are consecutive when sorted in increasing order.
    For example, the elements [3, 4, 5] are consecutive while [3, 4, 6] and
    [1, 1, 2, 3] are not. Return the maximum number of elements that you can
    select.

    Example 1:
    Input: nums = [2,1,5,1,1]
    Output: 3
    Explanation: We can increase the elements at indices 0 and 3. The resulting
                 array is nums = [3,1,5,2,1]. We select the elements [3,1,5,2,1]
                 and we sort them to obtain [1,2,3], which are consecutive. It
                 can be shown that we cannot select more than 3 consecutive
                 elements.

    Example 2:
    Input: nums = [1,4,7,10]
    Output: 1
    Explanation: The maximum consecutive elements that we can select is 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    public int maxSelectedElements(int[] nums) {
        Arrays.sort(nums);
        int ans = 1, n = nums.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; ++i)
            Arrays.fill(dp[i], 1);
        for (int i = 1; i < n; ++i) {
            if (nums[i-1] + 2 == nums[i]) dp[i][0] = dp[i-1][1] + 1;
            else if (nums[i-1] + 1 == nums[i]) {
                dp[i][0] = dp[i-1][0] + 1;
                dp[i][1] = dp[i-1][1] + 1;
            } else if (nums[i-1] == nums[i]) {
                dp[i][0] = dp[i-1][0];
                dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + 1);
            }
            ans = Math.max(ans, Math.max(dp[i][0], dp[i][1]));
        }
        return ans;
    }


    /*3042. Count Prefix and Suffix Pairs I (Easy)
    You are given a 0-indexed string array words. Let's define a boolean
    function isPrefixAndSuffix that takes two strings, str1 and str2:
    * isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a
      suffix of str2, and false otherwise.
    For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a
    prefix of "ababa" and also a suffix, but isPrefixAndSuffix("abc", "abcd") is
    false. Return an integer denoting the number of index pairs (i, j) such that
    i < j, and isPrefixAndSuffix(words[i], words[j]) is true.

    Example 1:
    Input: words = ["a","aba","ababa","aa"]
    Output: 4
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("a", "aba") is true.
                 - i = 0 and j = 2 because isPrefixAndSuffix("a", "ababa") is
                   true.
                 - i = 0 and j = 3 because isPrefixAndSuffix("a", "aa") is true.
                 - i = 1 and j = 2 because isPrefixAndSuffix("aba", "ababa") is
                   true.
                 Therefore, the answer is 4.

    Example 2:
    Input: words = ["pa","papa","ma","mama"]
    Output: 2
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("pa", "papa") is
                   true.
                 - i = 2 and j = 3 because isPrefixAndSuffix("ma", "mama") is
                   true.
                 Therefore, the answer is 2.

    Example 3:
    Input: words = ["abab","ab"]
    Output: 0
    Explanation: In this example, the only valid index pair is i = 0 and j = 1,
                 and isPrefixAndSuffix("abab", "ab") is false. Therefore, the
                 answer is 0.

    Constraints:
    * 1 <= words.length <= 50
    * 1 <= words[i].length <= 10
    * words[i] consists only of lowercase English letters.*/

    public int countPrefixSuffixPairs(String[] words) {
        int ans = 0;
        for (int i = 0; i < words.length; ++i)
            for (int ii = 0; ii < i; ++ii)
                if (words[i].startsWith(words[ii]) && words[i].endsWith(words[ii])) ++ans;
        return ans;
    }


    /*3043. Find the Length of the Longest Common Prefix (Medium)
    You are given two arrays with positive integers arr1 and arr2. A prefix of a
    positive integer is an integer formed by one or more of its digits, starting
    from its leftmost digit. For example, 123 is a prefix of the integer 12345,
    while 234 is not. A common prefix of two integers a and b is an integer c,
    such that c is a prefix of both a and b. For example, 5655359 and 56554 have
    a common prefix 565 while 1223 and 43456 do not have a common prefix. You
    need to find the length of the longest common prefix between all pairs of
    integers (x, y) such that x belongs to arr1 and y belongs to arr2. Return
    the length of the longest common prefix among all pairs. If no common prefix
    exists among them, return 0.

    Example 1:
    Input: arr1 = [1,10,100], arr2 = [1000]
    Output: 3
    Explanation: There are 3 pairs (arr1[i], arr2[j]):
                 - The longest common prefix of (1, 1000) is 1.
                 - The longest common prefix of (10, 1000) is 10.
                 - The longest common prefix of (100, 1000) is 100.
                 The longest common prefix is 100 with a length of 3.

    Example 2:
    Input: arr1 = [1,2,3], arr2 = [4,4,4]
    Output: 0
    Explanation: There exists no common prefix for any pair (arr1[i], arr2[j]),
                 hence we return 0. Note that common prefixes between elements
                 of the same array do not count.

    Constraints:
    * 1 <= arr1.length, arr2.length <= 5 * 10^4
    * 1 <= arr1[i], arr2[i] <= 10^8

    class TrieNode {
        TrieNode[] child = new TrieNode[10];
    }*/

    public int longestCommonPrefix(int[] arr1, int[] arr2) {
        TrieNode trie = new TrieNode();
        for (var x : arr1) {
            TrieNode node = trie;
            for (char d : String.valueOf(x).toCharArray()) {
                int k = (int) (d - '0');
                if (node.child[k] == null)
                    node.child[k] = new TrieNode();
                node = node.child[k];
            }
        }
        int ans = 0;
        for (var x : arr2) {
            TrieNode node = trie;
            int prefix = 0;
            for (char d : String.valueOf(x).toCharArray()) {
                int k = (int) (d - '0');
                if (node.child[k] == null) break;
                ++prefix;
                node = node.child[k];
            }
            ans = Math.max(ans, prefix);
        }
        return ans;
    }


    /*3044. Most Frequent Prime (Medium)
    You are given a m x n 0-indexed 2D matrix mat. From every cell, you can
    create numbers in the following way:
    * There could be at most 8 paths from the cells namely: east, south-east,
      south, south-west, west, north-west, north, and north-east.
    * Select a path from them and append digits in this path to the number being
      formed by traveling in this direction.
    * Note that numbers are generated at every step, for example, if the digits
      along the path are 1, 9, 1, then there will be three numbers generated
      along the way: 1, 19, 191.
    Return the most frequent prime number greater than 10 out of all the numbers
    created by traversing the matrix or -1 if no such prime number exists. If
    there are multiple prime numbers with the highest frequency, then return the
    largest among them. Note: It is invalid to change the direction during the
    move.

    Example 1:
    Input: mat = [[1,1],[9,9],[1,1]]
    Output: 19
    Explanation: From cell (0,0) there are 3 possible directions and the numbers
                 greater than 10 which can be created in those directions are:
                 East: [11], South-East: [19], South: [19,191].
                 - Numbers greater than 10 created from the cell (0,1) in all
                   possible directions are: [19,191,19,11].
                 - Numbers greater than 10 created from the cell (1,0) in all
                   possible directions are: [99,91,91,91,91].
                 - Numbers greater than 10 created from the cell (1,1) in all
                   possible directions are: [91,91,99,91,91].
                 - Numbers greater than 10 created from the cell (2,0) in all
                   possible directions are: [11,19,191,19].
                 - Numbers greater than 10 created from the cell (2,1) in all
                   possible directions are: [11,19,19,191].
                 The most frequent prime number among all the created numbers is
                 19.

    Example 2:
    Input: mat = [[7]]
    Output: -1
    Explanation: The only number which can be formed is 7. It is a prime number
                 however it is not greater than 10, so return -1.

    Example 3:
    Input: mat = [[9,7,8],[4,6,5],[2,8,6]]
    Output: 97
    Explanation: - Numbers greater than 10 created from the cell (0,0) in all
                   possible directions are: [97,978,96,966,94,942].
                 - Numbers greater than 10 created from the cell (0,1) in all
                   possible directions are: [78,75,76,768,74,79].
                 - Numbers greater than 10 created from the cell (0,2) in all
                   possible directions are: [85,856,86,862,87,879].
                 - Numbers greater than 10 created from the cell (1,0) in all
                   possible directions are: [46,465,48,42,49,47].
                 - Numbers greater than 10 created from the cell (1,1) in all
                   possible directions are: [65,66,68,62,64,69,67,68].
                 - Numbers greater than 10 created from the cell (1,2) in all
                   possible directions are: [56,58,56,564,57,58].
                 - Numbers greater than 10 created from the cell (2,0) in all
                   possible directions are: [28,286,24,249,26,268].
                 - Numbers greater than 10 created from the cell (2,1) in all
                   possible directions are: [86,82,84,86,867,85].
                 - Numbers greater than 10 created from the cell (2,2) in all
                   possible directions are: [68,682,66,669,65,658].
                 The most frequent prime number among all the created numbers is
                 97.

    Constraints:
    * m == mat.length
    * n == mat[i].length
    * 1 <= m, n <= 6
    * 1 <= mat[i][j] <= 9*/

    private boolean check(int x) {
        for (int p = 2; p <= Math.sqrt(x); ++p)
            if (x % p == 0) return false;
        return true;
    }

    public int mostFrequentPrime(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] dir = new int[]{-1, -1, 0, 1, 0, -1, 1, 1, -1};
        int ans = -1;
        Map<Integer, Integer> freq = new HashMap();
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                for (int k = 0; k < 8; ++k) {
                    int di = dir[k], dj = dir[k+1];
                    for (int ii = i, jj = j, prefix = 0; 0 <= ii && ii < m && 0 <= jj && jj < n; ii += di, jj += dj) {
                        prefix = 10*prefix + mat[ii][jj];
                        if (prefix > 10 && check(prefix)) {
                            freq.merge(prefix, 1, Integer::sum);
                            if (ans == -1 || freq.get(ans) < freq.getOrDefault(prefix, 0) || freq.get(ans) == freq.getOrDefault(prefix, 0) && ans < prefix)
                                ans = prefix;
                        }
                    }
                }
        return ans;
    }



    /*3045. Count Prefix and Suffix Pairs II (Hard)
    You are given a 0-indexed string array words. Let's define a boolean
    function isPrefixAndSuffix that takes two strings, str1 and str2:
    * isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a
      suffix of str2, and false otherwise.
    For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a
    prefix of "ababa" and also a suffix, but isPrefixAndSuffix("abc", "abcd") is
    false. Return an integer denoting the number of index pairs (i, j) such that
    i < j, and isPrefixAndSuffix(words[i], words[j]) is true.

    Example 1:
    Input: words = ["a","aba","ababa","aa"]
    Output: 4
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("a", "aba") is true.
                 - i = 0 and j = 2 because isPrefixAndSuffix("a", "ababa") is
                   true.
                 - i = 0 and j = 3 because isPrefixAndSuffix("a", "aa") is true.
                 - i = 1 and j = 2 because isPrefixAndSuffix("aba", "ababa") is
                   true.
                 Therefore, the answer is 4.

    Example 2:
    Input: words = ["pa","papa","ma","mama"]
    Output: 2
    Explanation: In this example, the counted index pairs are:
                 - i = 0 and j = 1 because isPrefixAndSuffix("pa", "papa") is
                   true.
                 - i = 2 and j = 3 because isPrefixAndSuffix("ma", "mama") is
                   true.
                 Therefore, the answer is 2.

    Example 3:
    Input: words = ["abab","ab"]
    Output: 0
    Explanation: In this example, the only valid index pair is i = 0 and j = 1,
                 and isPrefixAndSuffix("abab", "ab") is false. Therefore, the
                 answer is 0.

    Constraints:
    * 1 <= words.length <= 10^5
    * 1 <= words[i].length <= 10^5
    * words[i] consists only of lowercase English letters.
    * The sum of the lengths of all words[i] does not exceed 5 * 10^5.

    class TrieNode {
        public Map<String, TrieNode> child = new HashMap<>();
        public int count = 0;
    }*/

    public long countPrefixSuffixPairs(String[] words) {
        long ans = 0;
        TrieNode trie = new TrieNode();
        for (var w : words) {
            TrieNode node = trie;
            for (int i = 0, n = w.length(); i < n; ++i) {
                String k = "" + w.charAt(i) + w.charAt(n-1-i);
                if (!node.child.containsKey(k))
                    node.child.put(k, new TrieNode());
                node = node.child.get(k);
                ans += node.count;
            }
            ++node.count;
        }
        return ans;
    }


    /*3063. Linked List Frequency (Medium)
    Given the head of a linked list containing k distinct elements, return the
    head to a linked list of length k containing the frequency of each distinct
    element in the given linked list in any order.

    Example 1:
    Input: head = [1,1,1,2,2,3]
    Output: [3,2,1]
    Explanation: There are 3 distinct elements in the list. The frequency of 1
                 is 3, the frequency of 2 is 2 and the frequency of 3 is 1.
                 Hence, we return 3 -> 2 -> 1. Note that 1 -> 2 -> 3,
                 1 -> 3 -> 2, 2 -> 1 -> 3, 2 -> 3 -> 1, and 3 -> 1 -> 2 are also
                 valid answers.

    Example 2:
    Input: head = [1,1,2,2,2]
    Output: [2,3]
    Explanation: There are 2 distinct elements in the list. The frequency of 1
                 is 2 and the frequency of 2 is 3. Hence, we return 2 -> 3.

    Example 3:
    Input: head = [6,5,4,3,2,1]
    Output: [1,1,1,1,1,1]
    Explanation: There are 6 distinct elements in the list. The frequency of
                 each of them is 1. Hence, we return 1 -> 1 -> 1 -> 1 -> 1 -> 1.

    Constraints:
    * The number of nodes in the list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5*/

    public ListNode frequenciesOfElements(ListNode head) {
        ListNode node = new ListNode(), dummy = node;
        for (int prev = 0; head != null; head = head.next) {
            if (prev != head.val)
                node = node.next = new ListNode();
            ++node.val;
            prev = head.val;
        }
        return dummy.next;
    }


    /*3064. Guess the Number Using Bitwise Questions I (Medium)
    There is a number n that you have to find. There is also a pre-defined API
    int commonSetBits(int num), which returns the number of bits where both n
    and num are 1 in that position of their binary representation. In other
    words, it returns the number of set bits in n & num, where & is the bitwise
    AND operator. Return the number n.

    Example 1:
    Input: n = 31
    Output: 31
    Explanation: It can be proven that it's possible to find 31 using the
                 provided API.

    Example 2:
    Input: n = 33
    Output: 33
    Explanation: It can be proven that it's possible to find 33 using the
                 provided API.

    Constraints:
    * 1 <= n <= 2^30 - 1
    * 0 <= num <= 2^30 - 1
    * If you ask for some num out of the given range, the output wouldn't be
      reliable.*/

    public int findNumber() {
        int ans = 0;
        for (int i = 0; i < 30; ++i)
            if (commonSetBits(1<<i) > 0)
                ans ^= 1<<i;
        return ans;
    }


    /*3065. Minimum Operations to Exceed Threshold Value I (Easy)
    You are given a 0-indexed integer array nums, and an integer k. In one
    operation, you can remove one occurrence of the smallest element of nums.
    Return the minimum number of operations needed so that all elements of the
    array are greater than or equal to k.

    Example 1:
    Input: nums = [2,11,10,1,3], k = 10
    Output: 3
    Explanation: After one operation, nums becomes equal to [2, 11, 10, 3].
                 After two operations, nums becomes equal to [11, 10, 3].
                 After three operations, nums becomes equal to [11, 10].
                 At this stage, all the elements of nums are greater than or
                 equal to 10 so we can stop. It can be shown that 3 is the
                 minimum number of operations needed so that all elements of the
                 array are greater than or equal to 10.

    Example 2:
    Input: nums = [1,1,2,4,9], k = 1
    Output: 0
    Explanation: All elements of the array are greater than or equal to 1 so we
                 do not need to apply any operations on nums.

    Example 3:
    Input: nums = [1,1,2,4,9], k = 9
    Output: 4
    Explanation: only a single element of nums is greater than or equal to 9 so
                 we need to apply the operations 4 times on nums.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9
    * The input is generated such that there is at least one index i such that
      nums[i] >= k.*/

    public int minOperations(int[] nums, int k) {
        return (int) Arrays.stream(nums).filter(x -> x < k).count();
    }


    /*3066. Minimum Operations to Exceed Threshold Value II (Medium)
    You are given a 0-indexed integer array nums, and an integer k. In one
    operation, you will:
    * Take the two smallest integers x and y in nums.
    * Remove x and y from nums.
    * Add min(x, y) * 2 + max(x, y) anywhere in the array.
    Note that you can only apply the described operation if nums contains at
    least two elements. Return the minimum number of operations needed so that
    all elements of the array are greater than or equal to k.

    Example 1:
    Input: nums = [2,11,10,1,3], k = 10
    Output: 2
    Explanation: In the first operation, we remove elements 1 and 2, then add
                 1 * 2 + 2 to nums. nums becomes equal to [4, 11, 10, 3]. In the
                 second operation, we remove elements 3 and 4, then add
                 3 * 2 + 4 to nums. nums becomes equal to [10, 11, 10]. At this
                 stage, all the elements of nums are greater than or equal to 10
                 so we can stop. It can be shown that 2 is the minimum number of
                 operations needed so that all elements of the array are greater
                 than or equal to 10.

    Example 2:
    Input: nums = [1,1,2,4,9], k = 20
    Output: 4
    Explanation: After one operation, nums becomes equal to [2, 4, 9, 3].
                 After two operations, nums becomes equal to [7, 4, 9].
                 After three operations, nums becomes equal to [15, 9].
                 After four operations, nums becomes equal to [33].
                 At this stage, all the elements of nums are greater than 20 so
                 we can stop. It can be shown that 4 is the minimum number of
                 operations needed so that all elements of the array are greater
                 than or equal to 20.

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9
    * The input is generated such that an answer always exists. That is, there
      exists some sequence of operations after which all elements of the array
      are greater than or equal to k.*/

    public int minOperations(int[] nums, int k) {
        int n = nums.length;
        Queue<Long> pq = new PriorityQueue();
        for (var x : nums)
            pq.add((long) x);
        while (pq.peek() < k)
            pq.add(2*pq.poll() + pq.poll());
        return n - pq.size();
    }


    /*3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)
    You are given an unrooted weighted tree with n vertices representing servers
    numbered from 0 to n - 1, an array edges where edges[i] = [ai, bi, weighti]
    represents a bidirectional edge between vertices ai and bi of weight
    weighti. You are also given an integer signalSpeed. Two servers a and b are
    connectable through a server c if:
    * a < b, a != c and b != c.
    * The distance from c to a is divisible by signalSpeed.
    * The distance from c to b is divisible by signalSpeed.
    * The path from c to b and the path from c to a do not share any edges.
    Return an integer array count of length n where count[i] is the number of
    server pairs that are connectable through the server i.

    Example 1:
    Input: edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1
    Output: [0,4,6,6,4,0]
    Explanation: Since signalSpeed is 1, count[c] is equal to the number of
                 pairs of paths that start at c and do not share any edges. In
                 the case of the given path graph, count[c] is equal to the
                 number of servers to the left of c multiplied by the servers to
                 the right of c.

    Example 2:
    Input: edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3
    Output: [2,0,0,0,0,0,2]
    Explanation: Through server 0, there are 2 pairs of connectable servers:
                 (4, 5) and (4, 6). Through server 6, there are 2 pairs of
                 connectable servers: (4, 5) and (0, 5). It can be shown that no
                 two servers are connectable through servers other than 0 and 6.

    Constraints:
    * 2 <= n <= 1000
    * edges.length == n - 1
    * edges[i].length == 3
    * 0 <= ai, bi < n
    * edges[i] = [ai, bi, weighti]
    * 1 <= weighti <= 10^6
    * 1 <= signalSpeed <= 106^
    * The input is generated such that edges represents a valid tree.*/

    public int[] countPairsOfConnectableServers(int[][] edges, int signalSpeed) {
        int n = edges.length + 1;
        List<int[]>[] tree = new ArrayList[n];
        for (int i = 0; i < n; ++i)
            tree[i] = new ArrayList();
        for (var e : edges) {
            int u = e[0], v = e[1], w = e[2];
            tree[u].add(new int[] {v, w});
            tree[v].add(new int[] {u, w});
        }
        int[] ans = new int[n];
        for (int x = 0; x < n; ++x) {
            int prefix = 0;
            for (var t : tree[x]) {
                int v = t[0], w = t[1], cnt = 0;
                Stack<int[]> stk = new Stack();
                stk.push(new int[] {x, v, w});
                while (!stk.isEmpty()) {
                    var s = stk.pop();
                    int p = s[0], u = s[1];
                    w = s[2];
                    if (w % signalSpeed == 0) ++cnt;
                    for (var tt : tree[u]) {
                        v = tt[0];
                        int wt = tt[1];
                        if (v != p)
                            stk.push(new int[] {u, v, w+wt});
                    }
                }
                ans[x] += prefix * cnt;
                prefix += cnt;
            }
        }
        return ans;
    }


    /*3068. Find the Maximum Sum of Node Values (Hard)
    There exists an undirected tree with n nodes numbered 0 to n - 1. You are
    given a 0-indexed 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi
    in the tree. You are also given a positive integer k, and a 0-indexed array
    of non-negative integers nums of length n, where nums[i] represents the
    value of the node numbered i. Bogdan wants the sum of values of tree nodes
    to be maximum, for which Bogdan can perform the following operation any
    number of times (including zero) on the tree:
    * Choose any edge [u, v] connecting the nodes u and v, and update their
      values as follows:
      + nums[u] = nums[u] XOR k
      + nums[v] = nums[v] XOR k
    Return the maximum possible sum of the values Bogdan can achieve by
    performing the operation any number of times.

    Example 1:
    Input: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]
    Output: 6
    Explanation: Bogdan can achieve the maximum sum of 6 using a single
                 operation:
                 - Choose the edge [0,2]. nums[0] and nums[2] become:
                   1 XOR 3 = 2, and the array nums becomes: [1,2,1] -> [2,2,2].
                 The total sum of values is 2 + 2 + 2 = 6. It can be shown that
                 6 is the maximum achievable sum of values.

    Example 2:
    Input: nums = [2,3], k = 7, edges = [[0,1]]
    Output: 9
    Explanation: Bogdan can achieve the maximum sum of 9 using a single
                 operation:
                 - Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and
                   nums[1] become: 3 XOR 7 = 4, and the array nums becomes:
                   [2,3] -> [5,4].
                 The total sum of values is 5 + 4 = 9. It can be shown that 9 is
                 the maximum achievable sum of values.

    Example 3:
    Input: nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]]
    Output: 42
    Explanation: The maximum achievable sum is 42 which can be achieved by
                 Bogdan performing no operations.

    Constraints:
    * 2 <= n == nums.length <= 2 * 10^4
    * 1 <= k <= 10^9
    * 0 <= nums[i] <= 10^9
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * The input is generated such that edges represent a valid tree.*/

    public long maximumValueSum(int[] nums, int k, int[][] edges) {
        long ans = 0;
        int cnt = 0, diff = Integer.MAX_VALUE;
        for (var x : nums) {
            int xx = x ^ k;
            if (x < xx) cnt ^= 1;
            ans += Math.max(x, xx);
            diff = Math.min(diff, Math.abs(x-xx));
        }
        return cnt == 1 ? ans - diff : ans;
    }


    /*3074. Apple Redistribution into Boxes (Easy)
    You are given an array apple of size n and an array capacity of size m.
    There are n packs where the ith pack contains apple[i] apples. There are m
    boxes as well, and the ith box has a capacity of capacity[i] apples. Return
    the minimum number of boxes you need to select to redistribute these n packs
    of apples into boxes. Note that, apples from the same pack can be
    distributed into different boxes.

    Example 1:
    Input: apple = [1,3,2], capacity = [4,3,1,5,2]
    Output: 2
    Explanation: We will use boxes with capacities 4 and 5. It is possible to
                 distribute the apples as the total capacity is greater than or
                 equal to the total number of apples.

    Example 2:
    Input: apple = [5,5,5], capacity = [2,4,2,7]
    Output: 4
    Explanation: We will need to use all the boxes.

    Constraints:
    * 1 <= n == apple.length <= 50
    * 1 <= m == capacity.length <= 50
    * 1 <= apple[i], capacity[i] <= 50
    * The input is generated such that it's possible to redistribute packs of
      apples into boxes.*/

    public int minimumBoxes(int[] apple, int[] capacity) {
        int total = IntStream.of(apple).sum();
        Arrays.sort(capacity);
        for (int n = capacity.length, i = n-1; i >= 0; --i) {
            total -= capacity[i];
            if (total <= 0) return n-i;
        }
        return -1;
    }


    /*3075. Maximize Happiness of Selected Children (Medium)
    You are given an array happiness of length n, and a positive integer k.
    There are n children standing in a queue, where the ith child has happiness
    value happiness[i]. You want to select k children from these n children in k
    turns. In each turn, when you select a child, the happiness value of all the
    children that have not been selected till now decreases by 1. Note that the
    happiness value cannot become negative and gets decremented only if it is
    positive. Return the maximum sum of the happiness values of the selected
    children you can achieve by selecting k children.

    Example 1:
    Input: happiness = [1,2,3], k = 2
    Output: 4
    Explanation: We can pick 2 children in the following way:
                 - Pick the child with the happiness value == 3. The happiness
                   value of the remaining children becomes [0,1].
                 - Pick the child with the happiness value == 1. The happiness
                   value of the remaining child becomes [0]. Note that the
                   happiness value cannot become less than 0.
                 The sum of the happiness values of the selected children is
                 3 + 1 = 4.

    Example 2:
    Input: happiness = [1,1,1,1], k = 2
    Output: 1
    Explanation: We can pick 2 children in the following way:
                 - Pick any child with the happiness value == 1. The happiness
                   value of the remaining children becomes [0,0,0].
                 - Pick the child with the happiness value == 0. The happiness
                   value of the remaining child becomes [0,0].
                 The sum of the happiness values of the selected children is
                 1 + 0 = 1.
    Example 3:
    Input: happiness = [2,3,4,5], k = 1
    Output: 5
    Explanation: We can pick 1 child in the following way:
                 - Pick the child with the happiness value == 5. The happiness
                   value of the remaining children becomes [1,2,3].
                 The sum of the happiness values of the selected children is 5.

    Constraints:
    * 1 <= n == happiness.length <= 2 * 10^5
    * 1 <= happiness[i] <= 10^8
    * 1 <= k <= n*/

    public long maximumHappinessSum(int[] happiness, int k) {
        Arrays.sort(happiness);
        long ans = 0;
        for (int n = happiness.length, i = n-1; i >= n-k; --i)
            ans += Math.max(0, happiness[i]+i-n+1);
        return ans;
    }


    /*3076. Shortest Uncommon Substring in an Array (Medium)
    You are given an array arr of size n consisting of non-empty strings. Find a
    string array answer of size n such that:
    * answer[i] is the shortest substring of arr[i] that does not occur as a
      substring in any other string in arr. If multiple such substrings exist,
      answer[i] should be the lexicographically smallest. And if no such
      substring exists, answer[i] should be an empty string.
    Return the array answer.

    Example 1:
    Input: arr = ["cab","ad","bad","c"]
    Output: ["ab","","ba",""]
    Explanation: We have the following:
                 - For the string "cab", the shortest substring that does not
                   occur in any other string is either "ca" or "ab", we choose
                   the lexicographically smaller substring, which is "ab".
                 - For the string "ad", there is no substring that does not
                   occur in any other string.
                 - For the string "bad", the shortest substring that does not
                   occur in any other string is "ba".
                 - For the string "c", there is no substring that does not occur
                   in any other string.

    Example 2:
    Input: arr = ["abc","bcd","abcd"]
    Output: ["","","abcd"]
    Explanation: We have the following:
                 - For the string "abc", there is no substring that does not
                   occur in any other string.
                 - For the string "bcd", there is no substring that does not
                   occur in any other string.
                 - For the string "abcd", the shortest substring that does not
                   occur in any other string is "abcd".

    Constraints:
    * n == arr.length
    * 2 <= n <= 100
    * 1 <= arr[i].length <= 20
    * arr[i] consists only of lowercase English letters.*/

    public String[] shortestSubstrings(String[] arr) {
        Map<String, List<Integer>> seen = new HashMap();
        for (int i = 0; i < arr.length; ++i) {
            String word = arr[i];
            for (int j = 0, n = word.length(); j < n; ++j)
                for (int k = j; k < n; ++k) {
                    String key = word.substring(j, k+1);
                    if (!seen.containsKey(key)) seen.put(key, new ArrayList());
                    if (seen.get(key).isEmpty() || seen.get(key).get(seen.get(key).size()-1) != i) seen.get(key).add(i);
                }
        }
        String[] ans = new String[arr.length];
        Arrays.fill(ans, "");
        for (var elem : seen.entrySet()) {
            String k = elem.getKey();
            List<Integer> v = elem.getValue();
            if (v.size() == 1) {
                int i = v.get(0);
                if (ans[i] == "" || k.length() < ans[i].length() || k.length() == ans[i].length() && k.compareTo(ans[i]) < 0) ans[i] = k;
            }
        }
        return ans;
    }


    /*3077. Maximum Strength of K Disjoint Subarrays (Hard)
    You are given a 0-indexed array of integers nums of length n, and a positive
    odd integer k. The strength of x subarrays is defined as
    strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1
    where sum[i] is the sum of the elements in the ith subarray. Formally,
    strength is sum of (-1)i+1 * sum[i] * (x - i + 1) over all i's such that
    1 <= i <= x. You need to select k disjoint subarrays from nums, such that
    their strength is maximum. Return the maximum possible strength that can be
    obtained. Note that the selected subarrays don't need to cover the entire
    array.

    Example 1:
    Input: nums = [1,2,3,-1,2], k = 3
    Output: 22
    Explanation: The best possible way to select 3 subarrays is: nums[0..2],
                 nums[3..3], and nums[4..4]. The strength is
                 (1 + 2 + 3) * 3 - (-1) * 2 + 2 * 1 = 22.

    Example 2:
    Input: nums = [12,-2,-2,-2,-2], k = 5
    Output: 64
    Explanation: The only possible way to select 5 disjoint subarrays is:
                 nums[0..0], nums[1..1], nums[2..2], nums[3..3], and nums[4..4].
                 The strength is
                 12 * 5 - (-2) * 4 + (-2) * 3 - (-2) * 2 + (-2) * 1 = 64.

    Example 3:
    Input: nums = [-1,-2,-3], k = 1
    Output: -1
    Explanation: The best possible way to select 1 subarray is: nums[0..0]. The
                 strength is -1.

    Constraints:
    * 1 <= n <= 10^4
    * -10^9 <= nums[i] <= 10^9
    * 1 <= k <= n
    * 1 <= n * k <= 10^6
    * k is odd.*/

    public long maximumStrength(int[] nums, int k) {
        int n = nums.length;
        long[][] dp = new long[k+1][2];
        for (int i = 1; i <= k; ++i)
            Arrays.fill(dp[i], (long) -1e17);
        for (int i = n-1; i >= 0; --i)
            for (int j = k; j > 0; --j) {
                long cand = (long) Math.pow(-1, k-j)*nums[i]*j + Math.max(dp[j][1], dp[j-1][0]);
                dp[j][0] = Math.max(cand, dp[j][0]);
                dp[j][1] = Math.max(cand, dp[j-1][0]);
            }
        return dp[k][0];
    }


    /*3079. Find the Sum of Encrypted Integers (Easy)
    You are given an integer array nums containing positive integers. We define
    a function encrypt such that encrypt(x) replaces every digit in x with the
    largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.
    Return the sum of encrypted elements.

    Example 1:
    Input: nums = [1,2,3]
    Output: 6
    Explanation: The encrypted elements are [1,2,3]. The sum of encrypted
                 elements is 1 + 2 + 3 == 6.

    Example 2:
    Input: nums = [10,21,31]
    Output: 66
    Explanation: The encrypted elements are [11,22,33]. The sum of encrypted
                 elements is 11 + 22 + 33 == 66.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 1000*/

    public int sumOfEncryptedInt(int[] nums) {
        int ans = 0;
        for (var x : nums) {
            int most = 0, mul = 0;
            for (; x > 0; x /= 10) {
                most = Math.max(most, x % 10);
                mul = 10*mul + 1;
            }
            ans += most * mul;
        }
        return ans;
    }


    /*3080. Mark Elements on Array by Performing Queries (Medium)
    You are given a 0-indexed array nums of size n consisting of positive
    integers. You are also given a 2D array queries of size m where
    queries[i] = [indexi, ki]. Initially all elements of the array are unmarked.
    You need to apply m queries on the array in order, where on the ith query
    you do the following:
    * Mark the element at index indexi if it is not already marked.
    * Then mark ki unmarked elements in the array with the smallest values. If
      multiple such elements exist, mark the ones with the smallest indices. And
      if less than ki unmarked elements exist, then mark all of them.
    Return an array answer of size m where answer[i] is the sum of unmarked
    elements in the array after the ith query.

    Example 1:
    Input: nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]
    Output: [8,3,0]
    Explanation: We do the following queries on the array:
                 - Mark the element at index 1, and 2 of the smallest unmarked
                   elements with the smallest indices if they exist, the marked
                   elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked
                   elements is 2 + 2 + 3 + 1 = 8.
                 - Mark the element at index 3, since it is already marked we
                   skip it. Then we mark 3 of the smallest unmarked elements
                   with the smallest indices, the marked elements now are
                   nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 3.
                 - Mark the element at index 4, since it is already marked we
                   skip it. Then we mark 2 of the smallest unmarked elements
                   with the smallest indices if they exist, the marked elements
                   now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements
                   is 0.

    Example 2:
    Input: nums = [1,4,2,3], queries = [[0,1]]
    Output: [7]
    Explanation: We do one query which is mark the element at index 0 and mark
                 the smallest element among unmarked elements. The marked
                 elements will be nums = [1,4,2,3], and the sum of unmarked
                 elements is 4 + 3 = 7.

    Constraints:
    * n == nums.length
    * m == queries.length
    * 1 <= m <= n <= 10^5
    * 1 <= nums[i] <= 10^5
    * queries[i].length == 2
    * 0 <= indexi, ki <= n - 1*/

    public long[] unmarkedSumArray(int[] nums, int[][] queries) {
        Queue<int[]> pq = new PriorityQueue<>((x, y) -> x[0] != y[0] ? Integer.compare(x[0], y[0]) : Integer.compare(x[1], y[1]));
        long suffix = 0;
        for (int i = 0; i < nums.length; ++i) {
            suffix += nums[i];
            pq.add(new int[]{nums[i], i});
        }
        int m = queries.length;
        long[] ans = new long[m];
        for (int i = 0; i < m; ++i) {
            int idx = queries[i][0], k = queries[i][1];
            if (nums[idx] > 0) {
                suffix -= nums[idx];
                nums[idx] = 0;
            }
            while (k > 0 && !pq.isEmpty()) {
                int j = pq.poll()[1];
                if (nums[j] > 0) {
                    --k;
                    suffix -= nums[j];
                    nums[j] = 0;
                }
            }
            ans[i] = suffix;
        }
        return ans;
    }


    /*3081. Replace Question Marks in String to Minimize Its Value (Medium)
    You are given a string s. s[i] is either a lowercase English letter or '?'.
    For a string t having length m containing only lowercase English letters, we
    define the function cost(i) for an index i as the number of characters equal
    to t[i] that appeared before it, i.e. in the range [0, i - 1]. The value of
    t is the sum of cost(i) for all indices i. For example, for the string
    t = "aab":
    * cost(0) = 0
    * cost(1) = 1
    * cost(2) = 0
    * Hence, the value of "aab" is 0 + 1 + 0 = 1.
    Your task is to replace all occurrences of '?' in s with any lowercase
    English letter so that the value of s is minimized. Return a string denoting
    the modified string with replaced occurrences of '?'. If there are multiple
    strings resulting in the minimum value, return the lexicographically
    smallest one.

    Example 1:
    Input:  s = "???"
    Output:  "abc"
    Explanation: In this example, we can replace the occurrences of '?' to make
                 s equal to "abc". For "abc", cost(0) = 0, cost(1) = 0, and
                 cost(2) = 0. The value of "abc" is 0. Some other modifications
                 of s that have a value of 0 are "cba", "abz", and, "hey". Among
                 all of them, we choose the lexicographically smallest.

    Example 2:
    Input: s = "a?a?"
    Output: "abac"
    Explanation: In this example, the occurrences of '?' can be replaced to make
                 s equal to "abac". For "abac", cost(0) = 0, cost(1) = 0,
                 cost(2) = 1, and cost(3) = 0. The value of "abac" is 1.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either a lowercase English letter or '?'.*/

    public String minimizeStringValue(String s) {
        List<Integer> loc = new ArrayList();
        int[] freq = new int[26];
        for (int i = 0; i < s.length(); ++i)
            if (s.charAt(i) == '?') loc.add(i);
            else ++freq[s.charAt(i) - 'a'];
        Queue<int[]> pq = new PriorityQueue<>((x, y) -> x[0] != y[0] ? Integer.compare(x[0], y[0]) : Integer.compare(x[1], y[1]));
        for (int i = 0; i < 26; ++i)
            pq.add(new int[]{freq[i], i});
        List<Character> vals = new ArrayList();
        for (var _ : loc) {
            var elem = pq.poll();
            int x = elem[0], c = elem[1];
            vals.add((char) (c + 'a'));
            pq.add(new int[]{x+1, c});
        }
        Collections.sort(vals);
        char[] ans = s.toCharArray();
        for (int i = 0; i < loc.size(); ++i)
            ans[loc.get(i)] = vals.get(i);
        return new String(ans);
    }


    /*3082. Find the Sum of the Power of All Subsequences (Hard)
    You are given an integer array nums of length n and a positive integer k.
    The power of an array of integers is defined as the number of subsequences
    with their sum equal to k. Return the sum of power of all subsequences of
    nums. Since the answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input:  nums = [1,2,3], k = 3
    Output:  6
    Explanation: There are 5 subsequences of nums with non-zero power:
                 - The subsequence [1,2,3] has 2 subsequences with sum == 3:
                   [1,2,3] and [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 - The subsequence [1,2,3] has 1 subsequence with sum == 3:
                   [1,2,3].
                 Hence the answer is 2 + 1 + 1 + 1 + 1 = 6.

    Example 2:
    Input:  nums = [2,3,3], k = 5
    Output:  4
    Explanation: There are 3 subsequences of nums with non-zero power:
                 - The subsequence [2,3,3] has 2 subsequences with sum == 5:
                   [2,3,3] and [2,3,3].
                 - The subsequence [2,3,3] has 1 subsequence with sum == 5:
                   [2,3,3].
                 - The subsequence [2,3,3] has 1 subsequence with sum == 5:
                   [2,3,3].
                 Hence the answer is 2 + 1 + 1 = 4.

    Example 3:
    Input:  nums = [1,2,3], k = 7
    Output:  0
    Explanation: There exists no subsequence with sum 7. Hence all subsequences
                 of nums have power = 0.

    Constraints:
    * 1 <= n <= 100
    * 1 <= nums[i] <= 10^4
    * 1 <= k <= 100*/

    public int sumOfPower(int[] nums, int k) {
        int n = nums.length, mod = 1_000_000_007;
        long[][] dp = new long[n+1][k+1];
        dp[0][0] = 1;
        long[] p2 = new long[n+1];
        p2[0] = 1;
        for (int i = 1; i <= n; ++i)
            p2[i] = p2[i-1] * 2 % mod;
        for (var x : nums)
            for (int i = n; i > 0; --i)
                for (int j = k; j >= x; --j)
                    dp[i][j] = (dp[i][j] + dp[i-1][j-x]) % mod;
        long ans = 0;
        for (int i = 0; i <= n; ++i)
            ans = (ans + dp[i][k] * p2[n-i]) % mod;
        return (int) ans;
    }


    /*3083. Existence of a Substring in a String and Its Reverse (Easy)
    Given a string s, find any substring of length 2 which is also present in
    the reverse of s. Return true if such a substring exists, and false
    otherwise.

    Example 1:
    Input: s = "leetcode"
    Output: true
    Explanation: Substring "ee" is of length 2 which is also present in
                 reverse(s) == "edocteel".

    Example 2:
    Input: s = "abcba"
    Output: true
    Explanation: All of the substrings of length 2 "ab", "bc", "cb", "ba" are
                 also present in reverse(s) == "abcba".

    Example 3:
    Input: s = "abcd"
    Output: false
    Explanation: There is no substring of length 2 in s, which is also present
                 in the reverse of s.

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of lowercase English letters.*/

    public boolean isSubstringPresent(String s) {
        Set<String> seen = new HashSet();
        for (int i = 0; i < s.length()-1; ++i)
            seen.add(s.substring(i, i+2));
        s = new StringBuilder(s).reverse().toString();
        for (int i = 0; i < s.length()-1; ++i)
            if (seen.contains(s.substring(i, i+2))) return true;
        return false;
    }


    /*3084. Count Substrings Starting and Ending with Given Character (Medium)
    You are given a string s and a character c. Return the total number of
    substrings of s that start and end with c.

    Example 1:
    Input: s = "abada", c = "a"
    Output: 6
    Explanation: Substrings starting and ending with "a" are: "abada", "abada",
                 "abada", "abada", "abada", "abada".

    Example 2:
    Input: s = "zzz", c = "z"
    Output: 6
    Explanation: There are a total of 6 substrings in s and all start and end
                 with "z".

    Constraints:
    * 1 <= s.length <= 10^5
    * s and c consist only of lowercase English letters.*/

    public long countSubstrings(String s, char c) {
        long n = s.chars().filter(ch -> ch == c).count();
        return n*(n+1)/2;
    }


    /*3085. Minimum Deletions to Make String K-Special (Medium)
    You are given a string word and an integer k. We consider word to be
    k-special if |freq(word[i]) - freq(word[j])| <= k for all indices i and j in
    the string. Here, freq(x) denotes the frequency of the character x in word,
    and |y| denotes the absolute value of y. Return the minimum number of
    characters you need to delete to make word k-special.

    Example 1:
    Input: word = "aabcaba", k = 0
    Output: 3
    Explanation: We can make word 0-special by deleting 2 occurrences of "a" and
                 1 occurrence of "c". Therefore, word becomes equal to "baba"
                 where freq('a') == freq('b') == 2.

    Example 2:
    Input: word = "dabdcbdcdcd", k = 2
    Output: 2
    Explanation: We can make word 2-special by deleting 1 occurrence of "a" and
                 1 occurrence of "d". Therefore, word becomes equal to
                 "bdcbdcdcd" where freq('b') == 2, freq('c') == 3, and
                 freq('d') == 4.

    Example 3:
    Input: word = "aaabaaa", k = 2
    Output: 1
    Explanation: We can make word 2-special by deleting 1 occurrence of "b".
                 Therefore, word becomes equal to "aaaaaa" where each letter's
                 frequency is now uniformly 6.

    Constraints:
    * 1 <= word.length <= 10^5
    * 0 <= k <= 10^5
    * word consists only of lowercase English letters.*/

    public int minimumDeletions(String word, int k) {
        Map<Character, Integer> mp = new HashMap();
        for (var ch : word.toCharArray())
            mp.merge(ch, 1, Integer::sum);
        Integer[] freq = mp.values().toArray(new Integer[0]);
        Arrays.sort(freq);
        int n = freq.length;
        int[] prefix = new int[n+1];
        for (int i = 0; i < n; ++i)
            prefix[i+1] = prefix[i] + freq[i];
        int ans = Integer.MAX_VALUE;
        for (int i = 0, j = 0; i < n; ++i) {
            for (; j < n && freq[j] - freq[i] <= k; ++j);
            int cand = prefix[i] + prefix[n] - prefix[j] - (n-j)*(freq[i]+k);
            ans = Math.min(ans, cand);
        }
        return ans;
    }


    /*3086. Minimum Moves to Pick K Ones (Hard)
    You are given a binary array nums of length n, a positive integer k and a
    non-negative integer maxChanges. Alice plays a game, where the goal is for
    Alice to pick up k ones from nums using the minimum number of moves. When
    the game starts, Alice picks up any index aliceIndex in the range [0, n - 1]
    and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and
    nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice
    can make any number of moves (including zero) where in each move Alice must
    perform exactly one of the following actions:
    * Select any index j != aliceIndex such that nums[j] == 0 and set
      nums[j] = 1. This action can be performed at most maxChanges times.
    * Select any two adjacent indices x and y (|x - y| == 1) such that
      nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 and
      nums[x] = 0). If y == aliceIndex, Alice picks up the one after this move
      and nums[y] becomes 0.
    Return the minimum number of moves required by Alice to pick exactly k ones.

    Example 1:
    Input: nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1
    Output: 3
    Explanation: Alice can pick up 3 ones in 3 moves, if Alice performs the
                 following actions in each move when standing at
                 aliceIndex == 1:
                 * At the start of the game Alice picks up the one and nums[1]
                   becomes 0. nums becomes [1,1,1,0,0,1,1,0,0,1].
                 * Select j == 2 and perform an action of the first type. nums
                   becomes [1,0,1,0,0,1,1,0,0,1]
                 * Select x == 2 and y == 1, and perform an action of the second
                   type. nums becomes [1,1,0,0,0,1,1,0,0,1]. As y == aliceIndex,
                   Alice picks up the one and nums becomes [1,0,0,0,0,1,1,0,0,1].
                 * Select x == 0 and y == 1, and perform an action of the second
                   type. nums becomes [0,1,0,0,0,1,1,0,0,1]. As y == aliceIndex,
                   Alice picks up the one and nums becomes [0,0,0,0,0,1,1,0,0,1].
                 Note that it may be possible for Alice to pick up 3 ones using
                 some other sequence of 3 moves.

    Example 2:
    Input: nums = [0,0,0,0], k = 2, maxChanges = 3
    Output: 4
    Explanation: Alice can pick up 2 ones in 4 moves, if Alice performs the
                 following actions in each move when standing at
                 aliceIndex == 0:
                 * Select j == 1 and perform an action of the first type. nums
                   becomes [0,1,0,0].
                 * Select x == 1 and y == 0, and perform an action of the second
                   type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks
                   up the one and nums becomes [0,0,0,0].
                 * Select j == 1 again and perform an action of the first type.
                   nums becomes [0,1,0,0].
                 * Select x == 1 and y == 0 again, and perform an action of the
                   second type. nums becomes [1,0,0,0]. As y == aliceIndex,
                   Alice picks up the one and nums becomes [0,0,0,0].

    Constraints:
    * 2 <= n <= 10^5
    * 0 <= nums[i] <= 1
    * 1 <= k <= 10^5
    * 0 <= maxChanges <= 10^5
    * maxChanges + sum(nums) >= k*/

    public long minimumMoves(int[] nums, int k, int maxChanges) {
        int cnt = 0, seq = 0;
        List<Integer> ones = new ArrayList();
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] == 1) {
                ones.add(i);
                ++cnt;
            } else cnt = 0;
            seq = Math.max(seq, cnt);
        }
        seq = Math.min(3, Math.min(k, seq));
        if (seq + maxChanges >= k) return Math.max(0, seq-1) + 2*(k-seq);
        long ans = Long.MAX_VALUE;
        int n = k - maxChanges;
        long[] prefix = new long[ones.size()+1];
        for (int i = 0; i < ones.size(); ++i)
            prefix[i+1] = prefix[i] + ones.get(i);
        for (int i = 0; i < prefix.length-n; ++i) {
            long cand = (prefix[i+n] - prefix[i+(n+1)/2]) - (prefix[i+n/2] - prefix[i]);
            ans = Math.min(ans, cand + 2*maxChanges);
        }
        return ans;
    }


    /*3090. Maximum Length Substring With Two Occurrences (Easy)
    Given a string s, return the maximum length of a substring such that it
    contains at most two occurrences of each character.

    Example 1:
    Input: s = "bcbbbcba"
    Output: 4
    Explanation: The following substring has a length of 4 and contains at most
                 two occurrences of each character: "bcbbbcba".

    Example 2:
    Input: s = "aaaa"
    Output: 2
    Explanation: The following substring has a length of 2 and contains at most
                 two occurrences of each character: "aaaa".

    Constraints:
    * 2 <= s.length <= 100
    * s consists only of lowercase English letters.*/

    public int maximumLengthSubstring(String s) {
        int ans = 0;
        int[] freq = new int[26];
        for (int i = 0, ii = 0; i < s.length(); ++i) {
            ++freq[s.charAt(i)-97];
            while (freq[s.charAt(i)-97] == 3) --freq[s.charAt(ii++)-97];
            ans = Math.max(ans, i-ii+1);
        }
        return ans;
    }


    /*3091. Apply Operations to Make Sum of Array Greater Than or Equal to k (Medium)
    You are given a positive integer k. Initially, you have an array nums = [1].
    You can perform any of the following operations on the array any number of
    times (possibly zero):
    * Choose any element in the array and increase its value by 1.
    * Duplicate any element in the array and add it to the end of the array.
    Return the minimum number of operations required to make the sum of elements
    of the final array greater than or equal to k.

    Example 1:
    Input: k = 11
    Output: 5
    Explanation: We can do the following operations on the array nums = [1]:
                 * Increase the element by 1 three times. The resulting array is
                   nums = [4].
                 * Duplicate the element two times. The resulting array is
                   nums = [4,4,4].
                 The sum of the final array is 4 + 4 + 4 = 12 which is greater
                 than or equal to k = 11. The total number of operations
                 performed is 3 + 2 = 5.

    Example 2:
    Input: k = 1
    Output: 0
    Explanation: The sum of the original array is already greater than or equal
                 to 1, so no operations are needed.

    Constraints: 1 <= k <= 10^5*/

    public int minOperations(int k) {
        int p = (int) Math.sqrt(k), q = (k+p-1)/p;
        return p + q - 2;
    }


    /*3092. Most Frequent IDs (Medium)
    The problem involves tracking the frequency of IDs in a collection that
    changes over time. You have two integer arrays, nums and freq, of equal
    length n. Each element in nums represents an ID, and the corresponding
    element in freq indicates how many times that ID should be added to or
    removed from the collection at each step.
    * Addition of IDs: If freq[i] is positive, it means freq[i] IDs with the
      value nums[i] are added to the collection at step i.
    * Removal of IDs: If freq[i] is negative, it means -freq[i] IDs with the
      value nums[i] are removed from the collection at step i.
    Return an array ans of length n, where ans[i] represents the count of the
    most frequent ID in the collection after the ith step. If the collection is
    empty at any step, ans[i] should be 0 for that step.

    Example 1:
    Input: nums = [2,3,2,1], freq = [3,2,-3,1]
    Output: [3,3,2,2]
    Explanation: * After step 0, we have 3 IDs with the value of 2. So
                   ans[0] = 3.
                 * After step 1, we have 3 IDs with the value of 2 and 2 IDs
                   with the value of 3. So ans[1] = 3.
                 * After step 2, we have 2 IDs with the value of 3. So
                   ans[2] = 2.
                 * After step 3, we have 2 IDs with the value of 3 and 1 ID with
                   the value of 1. So ans[3] = 2.

    Example 2:
    Input: nums = [5,5,3], freq = [2,-2,1]
    Output: [2,0,1]
    Explanation: * After step 0, we have 2 IDs with the value of 5. So
                   ans[0] = 2.
                 * After step 1, there are no IDs. So ans[1] = 0.
                 * After step 2, we have 1 ID with the value of 3. So ans[2] = 1.

    Constraints:
    * 1 <= nums.length == freq.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * -10^5 <= freq[i] <= 10^5
    * freq[i] != 0
    * The input is generated such that the occurrences of an ID will not be
      negative in any step.*/

    public long[] mostFrequentIDs(int[] nums, int[] freq) {
        int n = nums.length;
        Map<Long, Long> cnt = new HashMap();
        Queue<long[]> pq = new PriorityQueue<>((x, y) -> Long.compare(y[0], x[0]));
        long[] ans = new long[n];
        for (int i = 0; i < n; ++i) {
            long x = nums[i], f = freq[i];
            cnt.merge(x, f, Long::sum);
            while (!pq.isEmpty() && cnt.get(pq.peek()[1]) != pq.peek()[0]) pq.poll();
            pq.add(new long[]{cnt.get(x), x});
            ans[i] = pq.peek()[0];
        }
        return ans;
    }


    /*3093. Longest Common Suffix Queries (Hard)
    You are given two arrays of strings wordsContainer and wordsQuery. For each
    wordsQuery[i], you need to find a string from wordsContainer that has the
    longest common suffix with wordsQuery[i]. If there are two or more strings
    in wordsContainer that share the longest common suffix, find the string that
    is the smallest in length. If there are two or more such strings that have
    the same smallest length, find the one that occurred earlier in
    wordsContainer. Return an array of integers ans, where ans[i] is the index
    of the string in wordsContainer that has the longest common suffix with
    wordsQuery[i].

    Example 1:
    Input: wordsContainer = ["abcd","bcd","xbcd"], wordsQuery = ["cd","bcd","xyz"]
    Output: [1,1,1]
    Explanation: Let's look at each wordsQuery[i] separately:
                 - For wordsQuery[0] = "cd", strings from wordsContainer that
                   share the longest common suffix "cd" are at indices 0, 1, and
                   2. Among these, the answer is the string at index 1 because
                   it has the shortest length of 3.
                 - For wordsQuery[1] = "bcd", strings from wordsContainer that
                   share the longest common suffix "bcd" are at indices 0, 1,
                   and 2. Among these, the answer is the string at index 1
                   because it has the shortest length of 3.
                 - For wordsQuery[2] = "xyz", there is no string from
                   wordsContainer that shares a common suffix. Hence the longest
                   common suffix is "", that is shared with strings at index 0,
                   1, and 2. Among these, the answer is the string at index 1
                   because it has the shortest length of 3.

    Example 2:
    Input: wordsContainer = ["abcdefgh","poiuygh","ghghgh"], wordsQuery = ["gh","acbfgh","acbfegh"]
    Output: [2,0,2]
    Explanation: Let's look at each wordsQuery[i] separately:
                 - For wordsQuery[0] = "gh", strings from wordsContainer that
                   share the longest common suffix "gh" are at indices 0, 1, and
                   2. Among these, the answer is the string at index 2 because
                   it has the shortest length of 6.
                 - For wordsQuery[1] = "acbfgh", only the string at index 0
                   shares the longest common suffix "fgh". Hence it is the
                   answer, even though the string at index 2 is shorter.
                 - For wordsQuery[2] = "acbfegh", strings from wordsContainer
                   that share the longest common suffix "gh" are at indices 0,
                   1, and 2. Among these, the answer is the string at index 2
                   because it has the shortest length of 6.

    Constraints:
    * 1 <= wordsContainer.length, wordsQuery.length <= 10^4
    * 1 <= wordsContainer[i].length <= 5 * 10^3
    * 1 <= wordsQuery[i].length <= 5 * 10^3
    * wordsContainer[i] consists only of lowercase English letters.
    * wordsQuery[i] consists only of lowercase English letters.
    * Sum of wordsContainer[i].length is at most 5 * 10^5.
    * Sum of wordsQuery[i].length is at most 5 * 10^5.

    class TrieNode {
        public TrieNode[] next = new TrieNode[26];
        public int idx = -1;
        public int val = -1;
    }*/

    public int[] stringIndices(String[] wordsContainer, String[] wordsQuery) {
        TrieNode trie = new TrieNode();
        for (int i = 0; i < wordsContainer.length; ++i) {
            String word = new StringBuilder(wordsContainer[i]).reverse().toString();
            TrieNode node = trie;
            if (node.val == -1 || word.length() < node.val) {
                node.idx = i;
                node.val = word.length();
            }
            for (var ch : word.toCharArray()) {
                if (node.next[ch-'a'] == null)
                    node.next[ch-'a'] = new TrieNode();
                node = node.next[ch-'a'];
                if (node.val == -1 || word.length() < node.val) {
                    node.idx = i;
                    node.val = word.length();
                }
            }
        }
        int n = wordsQuery.length;
        int[] ans = new int[n];
        for (int i = 0; i < n; ++i) {
            String word = new StringBuilder(wordsQuery[i]).reverse().toString();
            TrieNode node = trie;
            for (var ch : word.toCharArray()) {
                if (node.next[ch-'a'] == null) break;
                node = node.next[ch-'a'];
            }
            ans[i] = node.idx;
        }
        return ans;
    }


    /*3099. Harshad Number (Easy)
    An integer divisible by the sum of its digits is said to be a Harshad
    number. You are given an integer x. Return the sum of the digits of x if x
    is a Harshad number, otherwise, return -1.

    Example 1:
    Input: x = 18
    Output: 9
    Explanation: The sum of digits of x is 9. 18 is divisible by 9. So 18 is a
                 Harshad number and the answer is 9.

    Example 2:
    Input: x = 23
    Output: -1
    Explanation: The sum of digits of x is 5. 23 is not divisible by 5. So 23 is
                 not a Harshad number and the answer is -1.

    Constraints: 1 <= x <= 100*/

    public int sumOfTheDigitsOfHarshadNumber(int x) {
        int val = 0;
        for (int xx = x; xx > 0; xx /= 10)
            val += xx % 10;
        return x % val == 0 ? val : -1;
    }


    /*3100. Water Bottles II (Medium)
    You are given two integers numBottles and numExchange. numBottles represents
    the number of full water bottles that you initially have. In one operation,
    you can perform one of the following operations:
    * Drink any number of full water bottles turning them into empty bottles.
    * Exchange numExchange empty bottles with one full water bottle. Then,
      increase numExchange by one.
    Note that you cannot exchange multiple batches of empty bottles for the same
    value of numExchange. For example, if numBottles == 3 and numExchange == 1,
    you cannot exchange 3 empty water bottles for 3 full bottles. Return the
    maximum number of water bottles you can drink.

    Example 1:
    Input: numBottles = 13, numExchange = 6
    Output: 15
    Explanation: The table above shows the number of full water bottles, empty
                 water bottles, the value of numExchange, and the number of
                 bottles drunk.

    Example 2:
    Input: numBottles = 10, numExchange = 3
    Output: 13
    Explanation: The table above shows the number of full water bottles, empty
                 water bottles, the value of numExchange, and the number of
                 bottles drunk.

    Constraints:
    * 1 <= numBottles <= 100
    * 1 <= numExchange <= 100*/

    public int maxBottlesDrunk(int numBottles, int numExchange) {
        int ans = 0, empty = 0;
        while (numBottles > 0) {
            ans += numBottles;
            empty += numBottles;
            numBottles = 0;
            for (; empty >= numExchange; ++numExchange) {
                empty -= numExchange;
                ++numBottles;
            }
        }
        return ans;
    }


    /*3101. Count Alternating Subarrays (Medium)
    You are given a binary array nums. We call a subarray alternating if no two
    adjacent elements in the subarray have the same value. Return the number of
    alternating subarrays in nums.

    Example 1:
    Input: nums = [0,1,1,1]
    Output: 5
    Explanation: The following subarrays are alternating: [0], [1], [1], [1],
                 and [0,1].

    Example 2:
    Input: nums = [1,0,1,0]
    Output: 10
    Explanation: Every subarray of the array is alternating. There are 10
                 possible subarrays that we can choose.

    Constraints:
    * 1 <= nums.length <= 10^5
    * nums[i] is either 0 or 1.*/

    public long countAlternatingSubarrays(int[] nums) {
        long ans = 0;
        for (int i = 0, cnt = 0; i < nums.length; ++i) {
            if (i > 0 && nums[i-1] == nums[i]) cnt = 0;
            ans += ++cnt;
        }
        return ans;
    }


    /*3102. Minimize Manhattan Distances (Hard)
    You are given a 0-indexed array points representing integer coordinates of
    some points on a 2D plane, where points[i] = [xi, yi]. The distance between
    two points is defined as their Manhattan distance. Return the minimum
    possible value for maximum distance between any two points by removing
    exactly one point.

    Example 1:
    Input: points = [[3,10],[5,15],[10,2],[4,4]]
    Output: 12
    Explanation: The maximum distance after removing each point is the following:
                 - After removing the 0th point the maximum distance is between
                   points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.
                 - After removing the 1st point the maximum distance is between
                   points (3, 10) and (10, 2), which is |3 - 10| + |10 - 2| = 15.
                 - After removing the 2nd point the maximum distance is between
                   points (5, 15) and (4, 4), which is |5 - 4| + |15 - 4| = 12.
                 - After removing the 3rd point the maximum distance is between
                   points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.
                 It can be seen that 12 is the minimum possible maximum distance
                 between any two points after removing exactly one point.

    Example 2:
    Input: points = [[1,1],[1,1],[1,1]]
    Output: 0
    Explanation: It can be seen that removing any of the points results in the
                 maximum distance between any two points of 0.

    Constraints:
    * 3 <= points.length <= 10^5
    * points[i].length == 2=
    * 1 <= points[i][0], points[i][1] <= 10^8*/

    public int minimumDistance(int[][] points) {
        int[][] diff = {{Integer.MAX_VALUE, -1}, {Integer.MAX_VALUE, -1}, {Integer.MIN_VALUE, -1}, {Integer.MIN_VALUE, -1}};
        int[][] summ = {{Integer.MAX_VALUE, -1}, {Integer.MAX_VALUE, -1}, {Integer.MIN_VALUE, -1}, {Integer.MIN_VALUE, -1}};
        for (int i = 0; i < points.length; ++i) {
            int x = points[i][0], y = points[i][1];
            if (x-y <= diff[0][0]) {
                diff[1] = diff[0];
                diff[0] = new int[]{x-y, i};
            } else if (x-y < diff[1][0]) diff[1] = new int[]{x-y, i};
            if (x-y >= diff[3][0]) {
                diff[2] = diff[3];
                diff[3] = new int[]{x-y, i};
            } else if (x-y > diff[2][0]) diff[2] = new int[]{x-y, i};
            if (x+y <= summ[0][0]) {
                summ[1] = summ[0];
                summ[0] = new int[]{x+y, i};
            } else if (x+y < summ[1][0]) summ[1] = new int[]{x+y, i};
            if (x+y >= summ[3][0]) {
                summ[2] = summ[3];
                summ[3] = new int[]{x+y, i};
            } else if (x+y > summ[2][0]) summ[2] = new int[]{x+y, i};
        }
        int[] cand = {diff[0][1], diff[3][1]};
        if (diff[3][0] - diff[0][0] < summ[3][0] - summ[0][0])
            cand = new int[]{summ[0][1], summ[3][1]};
        int ans = Integer.MAX_VALUE;
        for (var x : cand) {
            int val = 0;
            if (summ[0][1] == x) val = Math.max(val, summ[3][0] - summ[1][0]);
            else if (summ[3][1] == x) val = Math.max(val, summ[2][0] - summ[0][0]);
            else val = Math.max(val, summ[3][0] - summ[0][0]);
            if (diff[0][1] == x) val = Math.max(val, diff[3][0] - diff[1][0]);
            else if (diff[3][1] == x) val = Math.max(val, diff[2][0] - diff[0][0]);
            else val = Math.max(val, diff[3][0] - diff[0][0]);
            ans = Math.min(ans, val);
        }
        return ans;
    }


    /*3105. Longest Strictly Increasing or Strictly Decreasing Subarray (Easy)
    You are given an array of integers nums. Return the length of the longest
    subarray of nums which is either strictly increasing or strictly decreasing.

    Example 1:
    Input: nums = [1,4,3,3,2]
    Output: 2
    Explanation: The strictly increasing subarrays of nums are [1], [2], [3],
                 [3], [4], and [1,4]. The strictly decreasing subarrays of nums
                 are [1], [2], [3], [3], [4], [3,2], and [4,3]. Hence, we return
                 2.

    Example 2:
    Input: nums = [3,3,3,3]
    Output: 1
    Explanation: The strictly increasing subarrays of nums are [3], [3], [3],
                 and [3]. The strictly decreasing subarrays of nums are [3],
                 [3], [3], and [3]. Hence, we return 1.

    Example 3:
    Input: nums = [3,2,1]
    Output: 3
    Explanation: The strictly increasing subarrays of nums are [3], [2], and
                 [1]. The strictly decreasing subarrays of nums are [3], [2],
                 [1], [3,2], [2,1], and [3,2,1]. Hence, we return 3.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50*/

    public int longestMonotonicSubarray(int[] nums) {
        int ans = 0;
        for (int i = 0, val = 0; i < nums.length; ++i) {
            if (i >= 1 && nums[i-1] == nums[i]) val = 0;
            else if (i >= 2 && (nums[i-2]-nums[i-1]) * (nums[i-1]-nums[i]) <= 0) val = 1;
            ans = Math.max(ans, ++val);
        }
        return ans;
    }


    /*3106. Lexicographically Smallest String After Operations With Constraint (Medium)
    You are given a string s and an integer k. Define a function
    distance(s1, s2) between two strings s1 and s2 of the same length n as:
    * The sum of the minimum distance between s1[i] and s2[i] when the
      characters from 'a' to 'z' are placed in a cyclic order, for all i in the
      range [0, n - 1].
    For example, distance("ab", "cd") == 4, and distance("a", "z") == 1. You can
    change any letter of s to any other lowercase English letter, any number of
    times. Return a string denoting the lexicographically smallest string t you
    can get after some changes, such that distance(s, t) <= k.

    Example 1:
    Input: s = "zbbz", k = 3
    Output: "aaaz"
    Explanation: Change s to "aaaz". The distance between "zbbz" and "aaaz" is
                 equal to k = 3.

    Example 2:
    Input: s = "xaxcd", k = 4
    Output: "aawcd"
    Explanation: The distance between "xaxcd" and "aawcd" is equal to k = 4.

    Example 3:
    Input: s = "lol", k = 0
    Output: "lol"
    Explanation: It's impossible to change any character as k = 0.

    Constraints:
    * 1 <= s.length <= 100
    * 0 <= k <= 2000
    * s consists only of lowercase English letters.*/

    public String getSmallestString(String s, int k) {
        StringBuilder sb = new StringBuilder(s);
        for (int i = 0; i < s.length(); ++i) {
            int dist = Math.min(s.charAt(i) - 'a', 'z' - s.charAt(i) + 1);
            if (dist <= k) sb.setCharAt(i, 'a');
            else sb.setCharAt(i, (char) (s.charAt(i)-k));
            k -= Math.min(k, dist);
        }
        return sb.toString();
    }


    /*3107. Minimum Operations to Make Median of Array Equal to K (Medium)
    You are given an integer array nums and a non-negative integer k. In one
    operation, you can increase or decrease any element by 1. Return the minimum
    number of operations needed to make the median of nums equal to k. The
    median of an array is defined as the middle element of the array when it is
    sorted in non-decreasing order. If there are two choices for a median, the
    larger of the two values is taken.

    Example 1:
    Input: nums = [2,5,6,8,5], k = 4
    Output: 2
    Explanation: We can subtract one from nums[1] and nums[4] to obtain
                 [2, 4, 6, 8, 4]. The median of the resulting array is equal to
                 k.

    Example 2:
    Input: nums = [2,5,6,8,5], k = 7
    Output: 3
    Explanation: We can add one to nums[1] twice and add one to nums[2] once to
                 obtain [2, 7, 7, 8, 5].

    Example 3:
    Input: nums = [1,2,3,4,5,6], k = 4
    Output: 0
    Explanation: The median of the array is already equal to k.

    Constraints:
    * 1 <= nums.length <= 2 * 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9*/

    public long minOperationsToMakeMedianK(int[] nums, int k) {
        Arrays.sort(nums);
        long ans = 0;
        for (int i = 0, n = nums.length; i < n; ++i)
            if (i < n/2) ans += Math.max(0, nums[i] - k);
            else if (i == n/2) ans += Math.abs(nums[i] - k);
            else ans += Math.max(0, k - nums[i]);
        return ans;
    }


    /*3108. Minimum Cost Walk in Weighted Graph (Hard)
    There is an undirected weighted graph with n vertices labeled from 0 to
    n - 1. You are given the integer n and an array edges, where
    edges[i] = [ui, vi, wi] indicates that there is an edge between vertices ui
    and vi with a weight of wi. A walk on a graph is a sequence of vertices and
    edges. The walk starts and ends with a vertex, and each edge connects the
    vertex that comes before it and the vertex that comes after it. It's
    important to note that a walk may visit the same edge or vertex more than
    once. The cost of a walk starting at node u and ending at node v is defined
    as the bitwise AND of the weights of the edges traversed during the walk. In
    other words, if the sequence of edge weights encountered during the walk is
    w0, w1, w2, ..., wk, then the cost is calculated as w0 & w1 & w2 & ... & wk,
    where & denotes the bitwise AND operator. You are also given a 2D array
    query, where query[i] = [si, ti]. For each query, you need to find the
    minimum cost of the walk starting at vertex si and ending at vertex ti. If
    there exists no such walk, the answer is -1. Return the array answer, where
    answer[i] denotes the minimum cost of a walk for query i.

    Example 1:
    Input: n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]
    Output: [1,-1]
    Explanation: To achieve the cost of 1 in the first query, we need to move on
                 the following edges: 0->1 (weight 7), 1->2 (weight 1),
                 2->1 (weight 1), 1->3 (weight 7). In the second query, there is
                 no walk between nodes 3 and 4, so the answer is -1.

    Example 2:
    Input: n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]
    Output: [0]
    Explanation: To achieve the cost of 0 in the first query, we need to move on
                 the following edges: 1->2 (weight 1), 2->1 (weight 6),
                 1->2 (weight 1).

    Constraints:
    * 1 <= n <= 10^5
    * 0 <= edges.length <= 10^5
    * edges[i].length == 3
    * 0 <= ui, vi <= n - 1
    * ui != vi
    * 0 <= wi <= 10^5
    * 1 <= query.length <= 10^5
    * query[i].length == 2
    * 0 <= si, ti <= n - 1*/

    private int find(int p, int[] parent) {
        if (parent[p] != p)
            parent[p] = find(parent[p], parent);
        return parent[p];
    }

    public int[] minimumCost(int n, int[][] edges, int[][] query) {
        int[] parent = new int[n], weight = new int[n];
        for (int i = 0; i < n; ++i) parent[i] = i;
        Arrays.fill(weight, -1);
        for (var e : edges) {
            int u = find(e[0], parent), v = find(e[1], parent), w = e[2];
            if (u != v) parent[u] = v;
            weight[v] &= weight[u] & w;
        }
        int[] ans = new int[query.length];
        for (int i = 0; i < query.length; ++i) {
            int u = query[i][0], v = query[i][1];
            if (u != v) {
                int uu = find(u, parent), vv = find(v, parent);
                if (uu == vv) ans[i] = weight[uu];
                else ans[i] = -1;
            }
        }
        return ans;
    }


    /*3110. Score of a String (Easy)
    You are given a string s. The score of a string is defined as the sum of the
    absolute difference between the ASCII values of adjacent characters. Return
    the score of s.

    Example 1:
    Input: s = "hello"
    Output: 13
    Explanation: The ASCII values of the characters in s are: 'h' = 104,
                 'e' = 101, 'l' = 108, 'o' = 111. So, the score of s would be
                 |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111|
                 = 3 + 7 + 0 + 3 = 13.

    Example 2:
    Input: s = "zaz"
    Output: 50
    Explanation: The ASCII values of the characters in s are: 'z' = 122,
                 'a' = 97. So, the score of s would be
                 |122 - 97| + |97 - 122| = 25 + 25 = 50.

    Constraints:
    * 2 <= s.length <= 100
    * s consists only of lowercase English letters.*/

    public int scoreOfString(String s) {
        int ans = 0;
        for (int i = 1; i < s.length(); ++i)
            ans += Math.abs(s.charAt(i) - s.charAt(i-1));
        return ans;
    }


    /*3111. Minimum Rectangles to Cover Points (Medium)
    You are given a 2D integer array points, where points[i] = [xi, yi]. You are
    also given an integer w. Your task is to cover all the given points with
    rectangles. Each rectangle has its lower end at some point (x1, 0) and its
    upper end at some point (x2, y2), where x1 <= x2, y2 >= 0, and the condition
    x2 - x1 <= w must be satisfied for each rectangle. A point is considered
    covered by a rectangle if it lies within or on the boundary of the
    rectangle. Return an integer denoting the minimum number of rectangles
    needed so that each point is covered by at least one rectangle. Note: A
    point may be covered by more than one rectangle.

    Example 1:
    Input: points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1
    Output: 2
    Explanation: The image above shows one possible placement of rectangles to
                 cover the points:
                 - A rectangle with a lower end at (1, 0) and its upper end at
                   (2, 8)
                 - A rectangle with a lower end at (3, 0) and its upper end at
                   (4, 8)

    Example 2:
    Input: points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2
    Output: 3
    Explanation: The image above shows one possible placement of rectangles to
                 cover the points:
                 - A rectangle with a lower end at (0, 0) and its upper end at
                   (2, 2)
                 - A rectangle with a lower end at (3, 0) and its upper end at
                   (5, 5)
                 - A rectangle with a lower end at (6, 0) and its upper end at
                   (6, 6)

    Example 3:
    Input: points = [[2,3],[1,2]], w = 0
    Output: 2
    Explanation: The image above shows one possible placement of rectangles to
                 cover the points:
                 - A rectangle with a lower end at (1, 0) and its upper end at
                   (1, 2)
                 - A rectangle with a lower end at (2, 0) and its upper end at
                   (2, 3)

    Constraints:
    * 1 <= points.length <= 10^5
    * points[i].length == 2
    * 0 <= xi == points[i][0] <= 10^9
    * 0 <= yi == points[i][1] <= 10^9
    * 0 <= w <= 10^9
    * All pairs (xi, yi) are distinct.*/

    public int minRectanglesToCoverPoints(int[][] points, int w) {
        Arrays.sort(points, (x, y) -> Integer.compare(x[0], y[0]));
        int ans = 0, prev = Integer.MIN_VALUE;
        for (var p : points)
            if (prev + w < p[0]) {
                ++ans;
                prev = p[0];
            }
        return ans;
    }


    /*3112. Minimum Time to Visit Disappearing Nodes (Medium)
    There is an undirected graph of n nodes. You are given a 2D array edges,
    where edges[i] = [ui, vi, lengthi] describes an edge between node ui and
    node vi with a traversal time of lengthi units. Additionally, you are given
    an array disappear, where disappear[i] denotes the time when the node i
    disappears from the graph and you won't be able to visit it. Notice that the
    graph might be disconnected and might contain multiple edges. Return the
    array answer, with answer[i] denoting the minimum units of time required to
    reach node i from node 0. If node i is unreachable from node 0 then
    answer[i] is -1.

    Example 1:
    Input:  n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]
    Output:  [0,-1,4]
    Explanation: We are starting our journey from node 0, and our goal is to
                 find the minimum time required to reach each node before it
                 disappears.
                 - For node 0, we don't need any time as it is our starting
                   point.
                 - For node 1, we need at least 2 units of time to traverse
                   edges[0]. Unfortunately, it disappears at that moment, so we
                   won't be able to visit it.
                 - For node 2, we need at least 4 units of time to traverse
                   edges[2].

    Example 2:
    Input:  n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]
    Output:  [0,2,3]
    Explanation: We are starting our journey from node 0, and our goal is to
                 find the minimum time required to reach each node before it
                 disappears.
                 - For node 0, we don't need any time as it is the starting
                   point.
                 - For node 1, we need at least 2 units of time to traverse
                   edges[0].
                 - For node 2, we need at least 3 units of time to traverse
                   edges[0] and edges[1].

    Example 3:
    Input: n = 2, edges = [[0,1,1]], disappear = [1,1]
    Output: [0,-1]
    Explanation: Exactly when we reach node 1, it disappears.

    Constraints:
    * 1 <= n <= 5 * 10^4
    * 0 <= edges.length <= 10^5
    * edges[i] == [ui, vi, lengthi]
    * 0 <= ui, vi <= n - 1
    * 1 <= lengthi <= 10^5
    * disappear.length == n
    * 1 <= disappear[i] <= 10^5*/

    public int[] minimumTime(int n, int[][] edges, int[] disappear) {
        List<int[]>[] graph = new ArrayList[n];
        for (int i = 0; i < n; ++i)
            graph[i] = new ArrayList();
        for (var e : edges) {
            int u = e[0], v = e[1], w = e[2];
            graph[u].add(new int[]{v, w});
            graph[v].add(new int[]{u, w});
        }
        Queue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[0], y[0]));
        pq.add(new int[]{0, 0});
        int[] ans = new int[n];
        Arrays.fill(ans, Integer.MAX_VALUE);
        ans[0] = 0;
        while (!pq.isEmpty()) {
            var p = pq.poll();
            int x = p[0], u = p[1];
            if (x == ans[u])
                for (var g : graph[u]) {
                    int v = g[0], w = g[1];
                    if (x+w < disappear[v] && x+w < ans[v]) {
                        ans[v] = x+w;
                        pq.add(new int[]{x+w, v});
                    }
                }
        }
        for (int i = 0; i < n; ++i)
            if (ans[i] == Integer.MAX_VALUE) ans[i] = -1;
        return ans;
    }


    /*3113. Find the Number of Subarrays Where Boundary Elements Are Maximum (Hard)
    You are given an array of positive integers nums. Return the number of
    subarrays of nums, where the first and the last elements of the subarray are
    equal to the largest element in the subarray.

    Example 1:
    Input: nums = [1,4,3,3,2]
    Output: 6
    Explanation: There are 6 subarrays which have the first and the last
                 elements equal to the largest element of the subarray:
                 - subarray [1,4,3,3,2], with its largest element 1. The first
                   element is 1 and the last element is also 1.
                 - subarray [1,4,3,3,2], with its largest element 4. The first
                   element is 4 and the last element is also 4.
                 - subarray [1,4,3,3,2], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [1,4,3,3,2], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [1,4,3,3,2], with its largest element 2. The first
                   element is 2 and the last element is also 2.
                 - subarray [1,4,3,3,2], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 Hence, we return 6.

    Example 2:
    Input: nums = [3,3,3]
    Output: 6
    Explanation: There are 6 subarrays which have the first and the last
                 elements equal to the largest element of the subarray:
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 - subarray [3,3,3], with its largest element 3. The first
                   element is 3 and the last element is also 3.
                 Hence, we return 6.

    Example 3:
    Input: nums = [1]
    Output: 1
    Explanation: There is a single subarray of nums which is [1], with its
                 largest element 1. The first element is 1 and the last element
                 is also 1. Hence, we return 1.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9*/

    public long numberOfSubarrays(int[] nums) {
        int n = nums.length;
        long[] dp = new long[n];
        Arrays.fill(dp, 1);
        Stack<Integer> stk = new Stack();
        for (int i = 0; i < n; ++i) {
            while (!stk.isEmpty() && nums[stk.peek()] <= nums[i]) {
                int ii = stk.pop();
                if (nums[ii] == nums[i]) {
                    dp[i] = dp[ii]+1;
                    break;
                }
            }
            stk.push(i);
        }
        return LongStream.of(dp).sum();
    }


    /*3114. Latest Time You Can Obtain After Replacing Characters (Easy)
    You are given a string s representing a 12-hour format time where some of
    the digits (possibly none) are replaced with a "?". 12-hour times are
    formatted as "HH:MM", where HH is between 00 and 11, and MM is between 00
    and 59. The earliest 12-hour time is 00:00, and the latest is 11:59. You
    have to replace all the "?" characters in s with digits such that the time
    we obtain by the resulting string is a valid 12-hour format time and is the
    latest possible. Return the resulting string.

    Example 1:
    Input: s = "1?:?4"
    Output: "11:54"
    Explanation: The latest 12-hour format time we can achieve by replacing "?"
                 characters is "11:54".

    Example 2:
    Input: s = "0?:5?"
    Output: "09:59"
    Explanation: The latest 12-hour format time we can achieve by replacing "?"
                 characters is "09:59".

    Constraints:
    * s.length == 5
    * s[2] is equal to the character ":".
    * All characters except s[2] are digits or "?" characters.
    * The input is generated such that there is at least one time between
      "00:00" and "11:59" that you can obtain after replacing the "?"
      characters.*/

    public String findLatestTime(String s) {
        char[] ch = s.toCharArray();
        if (ch[0] == '?')
            ch[0] = ch[1] == '?' || ch[1] <= '1' ? '1' : '0';
        if (ch[1] == '?')
            ch[1] = ch[0] == '1' ? '1' : '9';
        if (ch[3] == '?') ch[3] = '5';
        if (ch[4] == '?') ch[4] = '9';
        return String.valueOf(ch);
    }


    /*3115. Maximum Prime Difference (Medium)
    You are given an integer array nums. Return an integer that is the maximum
    distance between the indices of two (not necessarily different) prime
    numbers in nums.

    Example 1:
    Input: nums = [4,2,9,5,3]
    Output: 3
    Explanation: nums[1], nums[3], and nums[4] are prime. So the answer is
                 |4 - 1| = 3.

    Example 2:
    Input: nums = [4,8,2,8]
    Output: 0
    Explanation: nums[2] is prime. Because there is just one prime number, the
                 answer is |2 - 2| = 0.

    Constraints:
    * 1 <= nums.length <= 3 * 10^5
    * 1 <= nums[i] <= 100
    * The input is generated such that the number of prime numbers in the nums
      is at least one.*/

    public int maximumPrimeDifference(int[] nums) {
        boolean[] sieve = new boolean[101];
        Arrays.fill(sieve, true);
        sieve[0] = sieve[1] = false;
        for (int x = 0; x <= 10; ++x)
            if (sieve[x])
                for (int xx = x*x; xx <= 100; xx += x)
                    sieve[xx] = false;
        int lo = -1, hi = -1;
        for (int i = 0; i < nums.length; ++i)
            if (sieve[nums[i]]) {
                if (lo == -1) lo = i;
                hi = i;
            }
        return hi - lo;
    }


    /*3116. Kth Smallest Amount With Single Denomination Combination (Hard)
    You are given an integer array coins representing coins of different
    denominations and an integer k. You have an infinite number of coins of each
    denomination. However, you are not allowed to combine coins of different
    denominations. Return the kth smallest amount that can be made using these
    coins.

    Example 1:
    Input: coins = [3,6,9], k = 3
    Output:  9
    Explanation: The given coins can make the following amounts:
                 Coin 3 produces multiples of 3: 3, 6, 9, 12, 15, etc.
                 Coin 6 produces multiples of 6: 6, 12, 18, 24, etc.
                 Coin 9 produces multiples of 9: 9, 18, 27, 36, etc.
                 All of the coins combined produce: 3, 6, 9, 12, 15, etc.

    Example 2:
    Input: coins = [5,2], k = 7
    Output: 12
    Explanation: The given coins can make the following amounts:
                 Coin 5 produces multiples of 5: 5, 10, 15, 20, etc.
                 Coin 2 produces multiples of 2: 2, 4, 6, 8, 10, 12, etc.
                 All of the coins combined produce: 2, 4, 5, 6, 8, 10, 12, 14,
                 15, etc.

    Constraints:
    * 1 <= coins.length <= 15
    * 1 <= coins[i] <= 25
    * 1 <= k <= 2 * 10^9
    * coins contains pairwise distinct integers.*/

    public long findKthSmallest(int[] coins, int k) {
        int n = coins.length;
        List<Integer>[] comb = new ArrayList[n+1];
        for (int i = 0; i <= n; ++i)
            comb[i] = new ArrayList();
        for (int m = 1; m < 1<<n; ++m) {
            int cnt = 0, v = 1;
            for (int i = 0; i < n; ++i) {
                if ((m & 1<<i) > 0) {
                    ++cnt;
                    int g = BigInteger.valueOf(v).gcd(BigInteger.valueOf(coins[i])).intValue();
                    v *= coins[i]/g;
                }
            }
            comb[cnt].add(v);
        }

        class Solve {
            public long fn(long val) {
                long ans = 0;
                for (int i = 1; i <= n; ++i)
                    for (var v : comb[i])
                        ans -= Math.pow(-1, i)*(val/v);
                return ans;
            }
        }

        long lo = 0, hi = (long) k*coins[0];
        Solve sol = new Solve();
        while (lo < hi) {
            long mid = lo + (hi - lo)/2;
            if (sol.fn(mid) < k) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }


    /*3117. Minimum Sum of Values by Dividing Array (Hard)
    You are given two arrays nums and andValues of length n and m respectively.
    The value of an array is equal to the last element of that array. You have
    to divide nums into m disjoint contiguous subarrays such that for the ith
    subarray [li, ri], the bitwise AND of the subarray elements is equal to
    andValues[i], in other words, nums[li] & nums[li + 1] & ... &
    nums[ri] == andValues[i] for all 1 <= i <= m, where & represents the bitwise
    AND operator. Return the minimum possible sum of the values of the m
    subarrays nums is divided into. If it is not possible to divide nums into m
    subarrays satisfying these conditions, return -1.

    Example 1:
    Input: nums = [1,4,3,3,2], andValues = [0,3,3,2]
    Output: 12
    Explanation: The only possible way to divide nums is:
                 - [1,4] as 1 & 4 == 0.
                 - [3] as the bitwise AND of a single element subarray is that
                   element itself.
                 - [3] as the bitwise AND of a single element subarray is that
                   element itself.
                 - [2] as the bitwise AND of a single element subarray is that
                   element itself.
                 - The sum of the values for these subarrays is
                   4 + 3 + 3 + 2 = 12.

    Example 2:
    Input: nums = [2,3,5,7,7,7,5], andValues = [0,7,5]
    Output: 17
    Explanation: There are three ways to divide nums:
                 - [[2,3,5],[7,7,7],[5]] with the sum of the values
                   5 + 7 + 5 == 17.
                 - [[2,3,5,7],[7,7],[5]] with the sum of the values
                   7 + 7 + 5 == 19.
                 - [[2,3,5,7,7],[7],[5]] with the sum of the values
                   7 + 7 + 5 == 19.
                 - The minimum possible sum of the values is 17.

    Example 3:
    Input: nums = [1,2,3,4], andValues = [2]
    Output: -1
    Explanation: The bitwise AND of the entire array nums is 0. As there is no
                 possible way to divide nums into a single subarray to have the
                 bitwise AND of elements 2, return -1.

    Constraints:
    * 1 <= n == nums.length <= 10^4
    * 1 <= m == andValues.length <= min(n, 10)
    * 1 <= nums[i] < 10^5
    * 0 <= andValues[j] < 10^5*/

    public int minimumValueSum(int[] nums, int[] andValues) {
        int m = nums.length, n = andValues.length, inf = 10_000_000;
        Map<Integer, Integer>[][] memo = new Map[m+1][n+1];
        for (int i = 0; i <= m; ++i)
            for (int j = 0; j <= n; ++j)
                memo[i][j] = new HashMap();

        class Solve {
            public int fn(int i, int j, int mask) {
                if (!memo[i][j].containsKey(mask)) {
                    int val = 0;
                    if (i == m && j == n) val = 0;
                    else if (i == m || j == n) val = inf;
                    else {
                        int mm = mask & nums[i];
                        if (mm < andValues[j]) val = inf;
                        else if (mm == andValues[j]) val = Math.min(fn(i+1, j, mm), nums[i] + fn(i+1, j+1, -1));
                        else val = fn(i+1, j, mm);
                    }
                    memo[i][j].put(mask, val);
                }
                return memo[i][j].get(mask);
            }
        }

        Solve sol = new Solve();
        int ans = sol.fn(0, 0, -1);
        return ans < inf ? ans : -1;
    }


    /*3120. Count the Number of Special Characters I (Easy)
    You are given a string word. A letter is called special if it appears both
    in lowercase and uppercase in word. Return the number of special letters in
    word.

    Example 1:
    Input: word = "aaAbcBC"
    Output: 3
    Explanation: The special characters in word are 'a', 'b', and 'c'.

    Example 2:
    Input: word = "abc"
    Output: 0
    Explanation: No character in word appears in uppercase.

    Example 3:
    Input: word = "abBCab"
    Output: 1
    Explanation: The only special character in word is 'b'.

    Constraints:
    * 1 <= word.length <= 50
    * word consists of only lowercase and uppercase English letters.*/

    public int numberOfSpecialChars(String word) {
        int lower = 0, upper = 0;
        for (var ch : word.toCharArray())
            if (Character.isLowerCase(ch)) lower |= 1 << (ch-'a');
            else upper |= 1 << (ch-'A');
        return Integer.bitCount(lower & upper);
    }


    /*3121. Count the Number of Special Characters II (Medium)
    You are given a string word. A letter c is called special if it appears both
    in lowercase and uppercase in word, and every lowercase occurrence of c
    appears before the first uppercase occurrence of c. Return the number of
    special letters in word.

    Example 1:
    Input: word = "aaAbcBC"
    Output: 3
    Explanation: The special characters are 'a', 'b', and 'c'.

    Example 2:
    Input: word = "abc"
    Output: 0
    Explanation: There are no special characters in word.

    Example 3:
    Input: word = "AbBCab"
    Output: 0
    Explanation: There are no special characters in word.

    Constraints:
    * 1 <= word.length <= 2 * 10^5
    * word consists of only lowercase and uppercase English letters.*/

    public int numberOfSpecialChars(String word) {
        int lower = 0, upper = 0;
        for (var ch : word.toCharArray())
            if (Character.isLowerCase(ch)) {
                lower &= ~(1 << ch-'a');
                lower |= ~upper & 1 << ch-'a';
            } else
                upper |= 1 << ch-'A';
        return Integer.bitCount(lower & upper);
    }


    /*3122. Minimum Number of Operations to Satisfy Conditions (Medium)
    You are given a 2D matrix grid of size m x n. In one operation, you can
    change the value of any cell to any non-negative number. You need to perform
    some operations such that each cell grid[i][j] is:
    * Equal to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it
      exists).
    * Different from the cell to its right, i.e. grid[i][j] != grid[i][j + 1]
      (if it exists).
    Return the minimum number of operations needed.

    Example 1:
    Input: grid = [[1,0,2],[1,0,2]]
    Output: 0
    Explanation: All the cells in the matrix already satisfy the properties.

    Example 2:
    Input: grid = [[1,1,1],[0,0,0]]
    Output: 3
    Explanation: The matrix becomes [[1,0,1],[1,0,1]] which satisfies the
                 properties, by doing these 3 operations:
                 - Change grid[1][0] to 1.
                 - Change grid[0][1] to 0.
                 - Change grid[1][2] to 1.

    Example 3:
    Input: grid = [[1],[2],[3]]
    Output: 2
    Explanation: There is a single column. We can change the value to 1 in each
                 cell using 2 operations.

    Constraints:
    * 1 <= n, m <= 1000
    * 0 <= grid[i][j] <= 9*/

    public int minimumOperations(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[][] dp = new int[10][n+1];
        List<Integer> vals = new ArrayList();
        for (int i = 0; i < 10; ++i)
            vals.add(i);
        for (int j = n-1; j >= 0; --j) {
            int[] freq = new int[10];
            for (int i = 0; i < m; ++i)
                ++freq[grid[i][j]];
            int jj = j+1;
            Collections.sort(vals, (x, y) -> Integer.compare(dp[x][jj], dp[y][jj]));
            for (int x = 0; x < 10; ++x) {
                dp[x][j] = m - freq[x];
                if (x != vals.get(0)) dp[x][j] += dp[vals.get(0)][j+1];
                else dp[x][j] += dp[vals.get(1)][j+1];
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int x = 0; x < 10; ++x)
            ans = Math.min(ans, dp[x][0]);
        return ans;
    }


    /*3123. Find Edges in Shortest Paths (Hard)
    You are given an undirected weighted graph of n nodes numbered from 0 to
    n - 1. The graph consists of m edges represented by a 2D array edges, where
    edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and
    bi with weight wi. Consider all the shortest paths from node 0 to node n - 1
    in the graph. You need to find a boolean array answer where answer[i] is
    true if the edge edges[i] is part of at least one shortest path. Otherwise,
    answer[i] is false. Return the array answer. Note that the graph may not be
    connected.

    Example 1:
    Input: n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]
    Output: [true,true,true,false,true,true,true,false]
    Explanation: The following are all the shortest paths between nodes 0 and 5:
                 - The path 0 -> 1 -> 5: The sum of weights is 4 + 1 = 5.
                 - The path 0 -> 2 -> 3 -> 5: The sum of weights is
                   1 + 1 + 3 = 5.
                 - The path 0 -> 2 -> 3 -> 1 -> 5: The sum of weights is
                   1 + 1 + 2 + 1 = 5.

    Example 2:
    Input: n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]
    Output: [true,false,false,true]
    Explanation: There is one shortest path between nodes 0 and 3, which is the
                 path 0 -> 2 -> 3 with the sum of weights 1 + 2 = 3.

    Constraints:
    * 2 <= n <= 5 * 10^4
    * m == edges.length
    * 1 <= m <= min(5 * 10^4, n * (n - 1) / 2)
    * 0 <= ai, bi < n
    * ai != bi
    * 1 <= wi <= 10^5
    * There are no repeated edges.*/

    class Solution {
        public boolean[] findAnswer(int n, int[][] edges) {
            List<int[]>[] graph = new List[n];
            for (int i = 0; i < n; ++i)
                graph[i] = new ArrayList();
            for (var e : edges) {
                int u = e[0], v = e[1], w = e[2];
                graph[u].add(new int[]{v, w});
                graph[v].add(new int[]{u, w});
            }

            class Solve {
                public int[] fn(int source) {
                    int[] dist = new int[n];
                    Arrays.fill(dist, -1);
                    dist[source] = 0;
                    Queue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[0], y[0]));
                    pq.add(new int[]{0, source});
                    while (!pq.isEmpty()) {
                        var p = pq.poll();
                        int x = p[0], u = p[1];
                        if (dist[u] == x)
                            for (var g : graph[u]) {
                                int v = g[0], w = g[1];
                                if (dist[v] == -1 || x+w < dist[v]) {
                                    dist[v] = x+w;
                                    pq.add(new int[]{x+w, v});
                                }
                            }
                    }
                    return dist;
                }
            }

            Solve sol = new Solve();
            int[] dist0 = sol.fn(0), dist1 = sol.fn(n-1);
            int m = edges.length;
            boolean[] ans = new boolean[m];
            if (dist0[n-1] != -1) {
                for (int i = 0; i < m; ++i) {
                    int[] e = edges[i];
                    int u = e[0], v = e[1], w = e[2];
                    if (dist0[u] != -1 && dist1[v] != -1 && dist0[u]+w+dist1[v] == dist0[n-1] || dist1[u] != -1 && dist0[v] != -1 && dist1[u]+w+dist0[v] == dist0[n-1])
                        ans[i] = true;
                }
            }
            return ans;
        }
    }


    /*3127. Make a Square with the Same Color (Easy)
    You are given a 2D matrix grid of size 3 x 3 consisting only of characters
    'B' and 'W'. Character 'W' represents the white color, and character 'B'
    represents the black color. Your task is to change the color of at most one
    cell so that the matrix has a 2 x 2 square where all cells are of the same
    color. Return true if it is possible to create a 2 x 2 square of the same
    color, otherwise, return false.

    Example 1:
    Input: grid = [["B","W","B"],["B","W","W"],["B","W","B"]]
    Output: true
    Explanation: It can be done by changing the color of the grid[0][2].

    Example 2:
    Input: grid = [["B","W","B"],["W","B","W"],["B","W","B"]]
    Output: false
    Explanation: It cannot be done by changing at most one cell.

    Example 3:
    Input: grid = [["B","W","B"],["B","W","W"],["B","W","W"]]
    Output: true
    Explanation: The grid already contains a 2 x 2 square of the same color.

    Constraints:
    * grid.length == 3
    * grid[i].length == 3
    * grid[i][j] is either 'W' or 'B'.*/

    public boolean canMakeSquare(char[][] grid) {
        int m = grid.length, n = grid[0].length;
        for (int i = 0; i < m-1; ++i)
            for (int j = 0; j < n-1; ++j) {
                int cnt = 0;
                for (int ii = i; ii <= i+1; ++ii)
                    for (int jj = j; jj <= j+1; ++jj)
                        if (grid[ii][jj] == 'B') ++cnt;
                if (cnt != 2) return true;
            }
        return false;
    }


    /*3128. Right Triangles (Medium)
    You are given a 2D boolean matrix grid. Return an integer that is the number
    of right triangles that can be made with the 3 elements of grid such that
    all of them have a value of 1. Note: A collection of 3 elements of grid is a
    right triangle if one of its elements is in the same row with another
    element and in the same column with the third element. The 3 elements do not
    have to be next to each other.

    Example 1: 0   1   0
               0   1   1
               0   1   0
               0   1   0
               0   1   1
               0   1   0
    Input: grid = [[0,1,0],[0,1,1],[0,1,0]]
    Output: 2
    Explanation: There are two right triangles.

    Example 2: 1   0   0   0
               0   1   0   1
               1   0   0   0
    Input: grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]
    Output: 0
    Explanation: There are no right triangles.

    Example 3: 1   0   1
               1   0   0
               1   0   0
               1   0   1
               1   0   0
               1   0   0
    Input: grid = [[1,0,1],[1,0,0],[1,0,0]]
    Output: 2
    Explanation: There are two right triangles.

    Constraints:
    * 1 <= grid.length <= 1000
    * 1 <= grid[i].length <= 1000
    * 0 <= grid[i][j] <= 1*/

    public long numberOfRightTriangles(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[] rows = new int[m], cols = new int[n];
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == 1) {
                    ++rows[i];
                    ++cols[j];
                }
        long ans = 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == 1)
                    ans += (long) (rows[i]-1)*(cols[j]-1);
        return ans;
    }


    /*3129. Find All Possible Stable Binary Arrays I (Medium)
    You are given 3 positive integers zero, one, and limit. A binary array arr
    is called stable if:
    * The number of occurrences of 0 in arr is exactly zero.
    * The number of occurrences of 1 in arr is exactly one.
    * Each subarray of arr with a size greater than limit must contain both 0
      and 1.
    Return the total number of stable binary arrays. Since the answer may be
    very large, return it modulo 10^9 + 7.

    Example 1:
    Input: zero = 1, one = 1, limit = 2
    Output: 2
    Explanation: The two possible stable binary arrays are [1,0] and [0,1], as
                 both arrays have a single 0 and a single 1, and no subarray has
                 a length greater than 2.

    Example 2:
    Input: zero = 1, one = 2, limit = 1
    Output: 1
    Explanation: The only possible stable binary array is [1,0,1]. Note that the
                 binary arrays [1,1,0] and [0,1,1] have subarrays of length 2
                 with identical elements, hence, they are not stable.

    Example 3:
    Input: zero = 3, one = 3, limit = 2
    Output: 14
    Explanation: All the possible stable binary arrays are [0,0,1,0,1,1],
                 [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0],
                 [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0],
                 [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and
                 [1,1,0,1,0,0].

    Constraints: 1 <= zero, one, limit <= 200*/

    public int numberOfStableArrays(int zero, int one, int limit) {
        int mod = 1_000_000_007;
        int[][][] dp = new int[zero+1][one+1][2];
        for (int i = 1; i <= zero && i <= limit; ++i) dp[i][0][0] = 1;
        for (int j = 1; j <= one && j <= limit; ++j) dp[0][j][1] = 1;
        for (int i = 1; i <= zero; ++i)
            for (int j = 1; j <= one; ++j) {
                dp[i][j][0] = (dp[i-1][j][1] + dp[i-1][j][0]) % mod;
                if (i-1-limit >= 0) dp[i][j][0] = ((dp[i][j][0] - dp[i-1-limit][j][1]) % mod + mod) % mod;
                dp[i][j][1] = (dp[i][j-1][0] + dp[i][j-1][1]) % mod;
                if (j-1-limit >= 0) dp[i][j][1] = ((dp[i][j][1] - dp[i][j-1-limit][0]) % mod + mod) % mod;
            }
        return (dp[zero][one][0] + dp[zero][one][1]) % mod;
    }


    /*3130. Find All Possible Stable Binary Arrays II (Hard)
    You are given 3 positive integers zero, one, and limit. A binary array arr
    is called stable if:
    * The number of occurrences of 0 in arr is exactly zero.
    * The number of occurrences of 1 in arr is exactly one.
    * Each subarray of arr with a size greater than limit must contain both 0
      and 1.
    Return the total number of stable binary arrays. Since the answer may be
    very large, return it modulo 10^9 + 7.

    Example 1:
    Input: zero = 1, one = 1, limit = 2
    Output: 2
    Explanation: The two possible stable binary arrays are [1,0] and [0,1].

    Example 2:
    Input: zero = 1, one = 2, limit = 1
    Output: 1
    Explanation: The only possible stable binary array is [1,0,1].

    Example 3:
    Input: zero = 3, one = 3, limit = 2
    Output: 14
    Explanation: All the possible stable binary arrays are [0,0,1,0,1,1],
                 [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0],
                 [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0],
                 [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and
                 [1,1,0,1,0,0].

    Constraints: 1 <= zero, one, limit <= 1000*/

    public int numberOfStableArrays(int zero, int one, int limit) {
        int mod = 1_000_000_007;
        int[][][] dp = new int[zero+1][one+1][2];
        for (int i = 1; i <= zero && i <= limit; ++i) dp[i][0][0] = 1;
        for (int j = 1; j <= one && j <= limit; ++j) dp[0][j][1] = 1;
        for (int i = 1; i <= zero; ++i)
            for (int j = 1; j <= one; ++j) {
                dp[i][j][0] = (dp[i-1][j][1] + dp[i-1][j][0]) % mod;
                if (i-1-limit >= 0) dp[i][j][0] = ((dp[i][j][0] - dp[i-1-limit][j][1]) % mod + mod) % mod;
                dp[i][j][1] = (dp[i][j-1][0] + dp[i][j-1][1]) % mod;
                if (j-1-limit >= 0) dp[i][j][1] = ((dp[i][j][1] - dp[i][j-1-limit][0]) % mod + mod) % mod;
            }
        return (dp[zero][one][0] + dp[zero][one][1]) % mod;
    }


    /*3131. Find the Integer Added to Array I (Easy)
    You are given two arrays of equal length, nums1 and nums2. Each element in
    nums1 has been increased (or decreased in the case of negative) by an
    integer, represented by the variable x. As a result, nums1 becomes equal to
    nums2. Two arrays are considered equal when they contain the same integers
    with the same frequencies. Return the integer x.

    Example 1:
    Input: nums1 = [2,6,4], nums2 = [9,7,5]
    Output: 3
    Explanation: The integer added to each element of nums1 is 3.

    Example 2:
    Input: nums1 = [10], nums2 = [5]
    Output: -5
    Explanation: The integer added to each element of nums1 is -5.

    Example 3:
    Input: nums1 = [1,1,1,1], nums2 = [1,1,1,1]
    Output: 0
    Explanation: The integer added to each element of nums1 is 0.

    Constraints:
    * 1 <= nums1.length == nums2.length <= 100
    * 0 <= nums1[i], nums2[i] <= 1000
    * The test cases are generated in a way that there is an integer x such that
      nums1 can become equal to nums2 by adding x to each element of nums1.*/

    public int addedInteger(int[] nums1, int[] nums2) {
        return Arrays.stream(nums2).min().getAsInt() - Arrays.stream(nums1).min().getAsInt();
    }


    /*3132. Find the Integer Added to Array II (Medium)
    You are given two integer arrays nums1 and nums2. From nums1 two elements
    have been removed, and all other elements have been increased (or decreased
    in the case of negative) by an integer, represented by the variable x. As a
    result, nums1 becomes equal to nums2. Two arrays are considered equal when
    they contain the same integers with the same frequencies. Return the minimum
    possible integer x that achieves this equivalence.

    Example 1:
    Input: nums1 = [4,20,16,12,8], nums2 = [14,18,10]
    Output: -2
    Explanation: After removing elements at indices [0,4] and adding -2, nums1
                 becomes [18,14,10].

    Example 2:
    Input: nums1 = [3,5,5,3], nums2 = [7,7]
    Output: 2
    Explanation: After removing elements at indices [0,3] and adding 2, nums1
                 becomes [7,7].

    Constraints:
    * 3 <= nums1.length <= 200
    * nums2.length == nums1.length - 2
    * 0 <= nums1[i], nums2[i] <= 1000
    * The test cases are generated in a way that there is an integer x such that
      nums1 can become equal to nums2 by removing two elements and adding x to
      each element of nums1.*/

    public int minimumAddedInteger(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int ans = Integer.MAX_VALUE;
        for (int x = 0, n = nums1.length; x < n; ++x)
            for (int y = x+1; y < n; ++y) {
                boolean found = false;
                int seen = Integer.MIN_VALUE;
                for (int i = 0, j = 0; i < n; ++i) {
                    if (i != x && i != y) {
                        int diff = nums2[j] - nums1[i];
                        if (seen == Integer.MIN_VALUE) seen = diff;
                        else if (seen != diff) {
                            found = true;
                            break;
                        }
                        ++j;
                    }
                }
                if (!found) ans = Math.min(ans, seen);
            }
        return ans;
    }


    /*3133. Minimum Array End (Medium)
    You are given two integers n and x. You have to construct an array of
    positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1]
    is greater than nums[i], and the result of the bitwise AND operation between
    all elements of nums is x. Return the minimum possible value of nums[n - 1].

    Example 1:
    Input: n = 3, x = 4
    Output: 6
    Explanation: nums can be [4,5,6] and its last element is 6.

    Example 2:
    Input: n = 2, x = 7
    Output: 15
    Explanation: nums can be [7,15] and its last element is 15.

    Constraints: 1 <= n, x <= 10^8*/

    public long minEnd(int n, int x) {
        --n;
        long ans = x;
        for (int i = 0; n > 0; ++i)
            if ((x & 1l<<i) == 0) {
                if ((n & 1) > 0) ans ^= 1l << i;
                n >>= 1;
            }
        return ans;
    }


    /*3134. Find the Median of the Uniqueness Array (Hard)
    You are given an integer array nums. The uniqueness array of nums is the
    sorted array that contains the number of distinct elements of all the
    subarrays of nums. In other words, it is a sorted array consisting of
    distinct(nums[i..j]), for all 0 <= i <= j < nums.length. Here,
    distinct(nums[i..j]) denotes the number of distinct elements in the subarray
    that starts at index i and ends at index j. Return the median of the
    uniqueness array of nums. Note that the median of an array is defined as the
    middle element of the array when it is sorted in non-decreasing order. If
    there are two choices for a median, the smaller of the two values is taken.

    Example 1:
    Input: nums = [1,2,3]
    Output: 1
    Explanation: The uniqueness array of nums is [distinct(nums[0..0]),
                 distinct(nums[1..1]), distinct(nums[2..2]),
                 distinct(nums[0..1]), distinct(nums[1..2]),
                 distinct(nums[0..2])] which is equal to [1, 1, 1, 2, 2, 3]. The
                 uniqueness array has a median of 1. Therefore, the answer is 1.

    Example 2:
    Input: nums = [3,4,3,4,5]
    Output: 2
    Explanation: The uniqueness array of nums is
                 [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]. The uniqueness
                 array has a median of 2. Therefore, the answer is 2.

    Example 3:
    Input: nums = [4,3,5,4]
    Output: 2
    Explanation: The uniqueness array of nums is [1, 1, 1, 1, 2, 2, 2, 3, 3, 3].
                 The uniqueness array has a median of 2. Therefore, the answer
                 is 2.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    public int medianOfUniquenessArray(int[] nums) {
        int n = nums.length, lo = 0, hi = n;
        while (lo < hi) {
            int mid = lo + (hi-lo)/2;
            long val = 0;
            Map<Integer, Integer> freq = new HashMap();
            for (int i = 0, ii = 0; i < n; ++i) {
                freq.merge(nums[i], 1, Integer::sum);
                for (; freq.size() > mid; ++ii) {
                    freq.merge(nums[ii], -1, Integer::sum);
                    if (freq.get(nums[ii]) == 0) freq.remove(nums[ii]);
                }
                val += i-ii+1;
            }
            if (val < ((long) n*(n+1)/2+1)/2) lo = mid+1;
            else hi = mid;
        }
        return lo;
    }


    /*3146. Permutation Difference between Two Strings (Easy)
    You are given two strings s and t such that every character occurs at most
    once in s and t is a permutation of s. The permutation difference between s
    and t is defined as the sum of the absolute difference between the index of
    the occurrence of each character in s and the index of the occurrence of the
    same character in t. Return the permutation difference between s and t.

    Example 1:
    Input: s = "abc", t = "bac"
    Output: 2
    Explanation: For s = "abc" and t = "bac", the permutation difference of s
                 and t is equal to the sum of:
                 - The absolute difference between the index of the occurrence
                   of "a" in s and the index of the occurrence of "a" in t.
                 - The absolute difference between the index of the occurrence
                   of "b" in s and the index of the occurrence of "b" in t.
                 - The absolute difference between the index of the occurrence
                   of "c" in s and the index of the occurrence of "c" in t.
                 - That is, the permutation difference between s and t is equal
                   to |0 - 1| + |1 - 0| + |2 - 2| = 2.

    Example 2:
    Input: s = "abcde", t = "edbac"
    Output: 12
    Explanation: The permutation difference between s and t is equal to
                 |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12.

    Constraints:
    * 1 <= s.length <= 26
    * Each character occurs at most once in s.
    * t is a permutation of s.
    * s consists only of lowercase English letters.*/

    public int findPermutationDifference(String s, String t) {
        int[] loc = new int[26];
        for (int i = 0; i < s.length(); ++i)
            loc[s.charAt(i) - 'a'] = i;
        int ans = 0;
        for (int i = 0; i < t.length(); ++i)
            ans += Math.abs(i - loc[t.charAt(i) - 'a']);
        return ans;
    }


    /*3147. Taking Maximum Energy From the Mystic Dungeon (Medium)
    In a mystic dungeon, n magicians are standing in a line. Each magician has
    an attribute that gives you energy. Some magicians can give you negative
    energy, which means taking energy from you. You have been cursed in such a
    way that after absorbing energy from magician i, you will be instantly
    transported to magician (i + k). This process will be repeated until you
    reach the magician where (i + k) does not exist. In other words, you will
    choose a starting point and then teleport with k jumps until you reach the
    end of the magicians' sequence, absorbing all the energy during the journey.
    You are given an array energy and an integer k. Return the maximum possible
    energy you can gain.

    Example 1:
    Input:  energy = [5,2,-10,-5,1], k = 3
    Output: 3
    Explanation: We can gain a total energy of 3 by starting from magician 1
                 absorbing 2 + 1 = 3.

    Example 2:
    Input: energy = [-2,-3,-1], k = 2
    Output: -1
    Explanation: We can gain a total energy of -1 by starting from magician 2.

    Constraints:
    * 1 <= energy.length <= 10^5
    * -1000 <= energy[i] <= 1000
    * 1 <= k <= energy.length - 1*/

    public int maximumEnergy(int[] energy, int k) {
        int[] dp = new int[k];
        Arrays.fill(dp, Integer.MIN_VALUE);
        for (int i = 0; i < energy.length; ++i)
            dp[i % k] = Math.max(0, dp[i % k]) + energy[i];
        return IntStream.of(dp).max().getAsInt();
    }


    /*3148. Maximum Difference Score in a Grid (Medium)
    You are given an m x n matrix grid consisting of positive integers. You can
    move from a cell in the matrix to any other cell that is either to the
    bottom or to the right (not necessarily adjacent). The score of a move from
    a cell with the value c1 to a cell with the value c2 is c2 - c1. You can
    start at any cell, and you have to make at least one move. Return the
    maximum total score you can achieve.

    Example 1:
    Input: grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]
    Output: 9
    Explanation: We start at the cell (0, 1), and we perform the following moves:
                 - Move from the cell (0, 1) to (2, 1) with a score of 7 - 5 = 2.
                 - Move from the cell (2, 1) to (2, 2) with a score of 14 - 7 = 7.
                 The total score is 2 + 7 = 9.

    Example 2:
    Input: grid = [[4,3,2],[3,2,1]]
    Output: -1
    Explanation: We start at the cell (0, 0), and we perform one move: (0, 0) to
                 (0, 1). The score is 3 - 4 = -1.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 2 <= m, n <= 1000
    * 4 <= m * n <= 10^5
    * 1 <= grid[i][j] <= 10^5*/

    public int maxScore(List<List<Integer>> grid) {
        int m = grid.size(), n = grid.get(0).size();
        int ans = Integer.MIN_VALUE;
        int[][] prefix = new int[m+1][n+1];
        for (int i = 0; i <= m; ++i)
            Arrays.fill(prefix[i], Integer.MAX_VALUE);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                int val = Math.min(prefix[i+1][j], prefix[i][j+1]);
                ans = Math.max(ans, grid.get(i).get(j) - val);
                prefix[i+1][j+1] = Math.min(grid.get(i).get(j), val);
            }
        return ans;
    }


    /*3149. Find the Minimum Cost Array Permutation (Hard)
    You are given an array nums which is a permutation of [0, 1, 2, ..., n - 1].
    The score of any permutation of [0, 1, 2, ..., n - 1] named perm is defined
    as:
    * score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ...
      + |perm[n - 1] - nums[perm[0]]|
    Return the permutation perm which has the minimum possible score. If
    multiple permutations exist with this score, return the one that is
    lexicographically smallest among them.

    Example 1:
    Input: nums = [1,0,2]
    Output: [0,1,2]
    Explanation: The lexicographically smallest permutation with minimum cost is
                 [0,1,2]. The cost of this permutation is
                 |0 - 0| + |1 - 2| + |2 - 1| = 2.

    Example 2:
    Input: nums = [0,2,1]
    Output: [0,2,1]
    Explanation: The lexicographically smallest permutation with minimum cost is
                 [0,2,1]. The cost of this permutation is
                 |0 - 1| + |2 - 2| + |1 - 0| = 2.

    Constraints:
    * 2 <= n == nums.length <= 14
    * nums is a permutation of [0, 1, 2, ..., n - 1].*/

    public int[] findPermutation(int[] nums) {
        int n = nums.length;
        int[][] dp = new int[1<<n][n], jump = new int[1<<n][n];
        for (int i = 0; i < 1<<n; ++i)
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        for (int m = (1<<n)-1; m > 0; --m) {
            int i = 0;
            for (int mm = m; mm > 0; mm &= mm-1, ++i);
            for (int p = 0; p < n; ++p)
                if (i == n) dp[m][p] = Math.abs(p - nums[0]);
                else
                    for (int k = 0; k < n; ++k)
                        if ((m & 1<<k) == 0) {
                            int cand = Math.abs(p - nums[k]) + dp[m^1<<k][k];
                            if (cand < dp[m][p]) {
                                dp[m][p] = cand;
                                jump[m][p] = k;
                            }
                        }
        }
        int[] ans = new int[n];
        for (int i = 1, m = 1; i < n; ++i) {
            int k = jump[m][ans[i-1]];
            ans[i] = k;
            m ^= 1<<k;
        }
        return ans;
    }


    /*3151. Special Array I (Easy)
    An array is considered special if every pair of its adjacent elements
    contains two numbers with different parity. You are given an array of
    integers nums. Return true if nums is a special array, otherwise, return
    false.

    Example 1:
    Input: nums = [1]
    Output: true
    Explanation: There is only one element. So the answer is true.

    Example 2:
    Input: nums = [2,1,4]
    Output: true
    Explanation: There is only two pairs: (2,1) and (1,4), and both of them
                 contain numbers with different parity. So the answer is true.

    Example 3:
    Input: nums = [4,3,1,6]
    Output: false
    Explanation: nums[1] and nums[2] are both odd. So the answer is false.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100*/

    public boolean isArraySpecial(int[] nums) {
        for (int i = 1; i < nums.length; ++i)
            if ((nums[i-1]-nums[i])%2 == 0) return false;
        return true;
    }


    /*3152. Special Array II (Medium)
    An array is considered special if every pair of its adjacent elements
    contains two numbers with different parity. You are given an array of
    integer nums and a 2D integer matrix queries, where for
    queries[i] = [fromi, toi] your task is to check that subarray
    nums[fromi..toi] is special or not. Return an array of booleans answer such
    that answer[i] is true if nums[fromi..toi] is special.

    Example 1:
    Input: nums = [3,4,1,2,6], queries = [[0,4]]
    Output: [false]
    Explanation: The subarray is [3,4,1,2,6]. 2 and 6 are both even.

    Example 2:
    Input: nums = [4,3,1,6], queries = [[0,2],[2,3]]
    Output: [false,true]
    Explanation: The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to
                 this query is false. The subarray is [1,6]. There is only one
                 pair: (1,6) and it contains numbers with different parity. So
                 the answer to this query is true.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= queries[i][0] <= queries[i][1] <= nums.length - 1*/

    public boolean[] isArraySpecial(int[] nums, int[][] queries) {
        int m = nums.length, n = queries.length;
        int[] dp = new int[m];
        for (int i = 0; i < m; ++i)
            if (i > 0 && (nums[i-1]-nums[i]) % 2 != 0) dp[i] = dp[i-1];
            else dp[i] = i;
        boolean[] ans = new boolean[n];
        IntStream.range(0, n).forEach(i -> ans[i] = queries[i][0] >= dp[queries[i][1]]);
        return ans;
    }


    /*3153. Sum of Digit Differences of All Pairs (Medium)
    You are given an array nums consisting of positive integers where all
    integers have the same number of digits. The digit difference between two
    integers is the count of different digits that are in the same position in
    the two integers. Return the sum of the digit differences between all pairs
    of integers in nums.

    Example 1:
    Input: nums = [13,23,12]
    Output: 4
    Explanation: We have the following:
                 - The digit difference between 13 and 23 is 1.
                 - The digit difference between 13 and 12 is 1.
                 - The digit difference between 23 and 12 is 2.
                 So the total sum of digit differences between all pairs of
                 integers is 1 + 1 + 2 = 4.

    Example 2:
    Input: nums = [10,10,10,10]
    Output: 0
    Explanation: All the integers in the array are the same. So the total sum of
                 digit differences between all pairs of integers will be 0.

    Constraints:
    * 2 <= nums.length <= 10^5
    * 1 <= nums[i] < 10^9
    * All integers in nums have the same number of digits.*/

    public long sumDigitDifferences(int[] nums) {
        long ans = 0;
        for (int n = nums.length; nums[0] > 0; ) {
            int[] freq = new int[10];
            for (int i = 0; i < n; ++i) {
                ++freq[nums[i] % 10];
                nums[i] /= 10;
            }
            ans += IntStream.of(freq).mapToLong((x) -> (long) x*(n-x)).sum();
        }
        return ans/2;
    }


    /*3154. Find Number of Ways to Reach the K-th Stair (Hard)
    You are given a non-negative integer k. There exists a staircase with an
    infinite number of stairs, with the lowest stair numbered 0. Alice has an
    integer jump, with an initial value of 0. She starts on stair 1 and wants to
    reach stair k using any number of operations. If she is on stair i, in one
    operation she can:
    * Go down to stair i - 1. This operation cannot be used consecutively or on
      stair 0.
    * Go up to stair i + 2jump. And then, jump becomes jump + 1.
    Return the total number of ways Alice can reach stair k. Note that it is
    possible that Alice reaches the stair k, and performs some operations to
    reach the stair k again.

    Example 1:
    Input: k = 0
    Output: 2
    Explanation: The 2 possible ways of reaching stair 0 are:
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.

    Example 2:
    Input: k = 1
    Output: 4
    Explanation: The 4 possible ways of reaching stair 1 are:
                 - Alice starts at stair 1. Alice is at stair 1.
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 1.
                 - Alice starts at stair 1.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 2.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 1.
                 - Alice starts at stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 20 stairs
                   to reach stair 1.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 0.
                 - Using an operation of the second type, she goes up 21 stairs
                   to reach stair 2.
                 - Using an operation of the first type, she goes down 1 stair
                   to reach stair 1.

    Constraints: 0 <= k <= 10^9*/

    public int waysToReachStair(int k) {
        int ans = 0;
        for (int jump = 0; jump <= 30; ++jump) {
            int n = jump+1, v = (1<<jump)-k;
            v = Math.min(v, n-v);
            if (v >= 0) {
                long val = 1l;
                for (int i = 0; i < v; ++i) {
                    val *= n-i;
                    val /= i+1;
                }
                ans += (int) val;
            }
        }
        return ans;
    }


    /*3158. Find the XOR of Numbers Which Appear Twice (Easy)
    You are given an array nums, where each number in the array appears either
    once or twice. Return the bitwise XOR of all the numbers that appear twice
    in the array, or 0 if no number appears twice.

    Example 1:
    Input: nums = [1,2,1,3]
    Output: 1
    Explanation: The only number that appears twice in nums is 1.

    Example 2:
    Input: nums = [1,2,3]
    Output: 0
    Explanation: No number appears twice in nums.

    Example 3:
    Input: nums = [1,2,2,1]
    Output: 3
    Explanation: Numbers 1 and 2 appeared twice. 1 XOR 2 == 3.

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50
    * Each number in nums appears either once or twice.*/

    public int duplicateNumbersXOR(int[] nums) {
        int ans = 0;
        long seen = 0;
        for (var x : nums) {
            if ((seen & 1l<<x) > 0) ans ^= x;
            seen ^= 1l<<x;
        }
        return ans;
    }


    /*3159. Find Occurrences of an Element in an Array (Medium)
    You are given an integer array nums, an integer array queries, and an
    integer x. For each queries[i], you need to find the index of the
    queries[i]th occurrence of x in the nums array. If there are fewer than
    queries[i] occurrences of x, the answer should be -1 for that query. Return
    an integer array answer containing the answers to all queries.

    Example 1:
    Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1
    Output: [0,-1,2,-1]
    Explanation: - For the 1st query, the first occurrence of 1 is at index 0.
                 - For the 2nd query, there are only two occurrences of 1 in
                   nums, so the answer is -1.
                 - For the 3rd query, the second occurrence of 1 is at index 2.
                 - For the 4th query, there are only two occurrences of 1 in
                   nums, so the answer is -1.

    Example 2:
    Input: nums = [1,2,3], queries = [10], x = 5
    Output: [-1]
    Explanation: For the 1st query, 5 doesn't exist in nums, so the answer is -1.

    Constraints:
    * 1 <= nums.length, queries.length <= 10^5
    * 1 <= queries[i] <= 10^5
    * 1 <= nums[i], x <= 10^4*/

    public int[] occurrencesOfElement(int[] nums, int[] queries, int x) {
        List<Integer> loc = new ArrayList();
        for (int i = 0; i < nums.length; ++i)
            if (nums[i] == x) loc.add(i);
        int n = queries.length;
        int[] ans = new int[n];
        IntStream.range(0, n).forEach(i -> ans[i] = queries[i] <= loc.size() ? loc.get(queries[i]-1) : -1);
        return ans;
    }


    /*3160. Find the Number of Distinct Colors Among the Balls (Medium)
    You are given an integer limit and a 2D array queries of size n x 2. There
    are limit + 1 balls with distinct labels in the range [0, limit]. Initially,
    all balls are uncolored. For every query in queries that is of the form
    [x, y], you mark ball x with the color y. After each query, you need to find
    the number of distinct colors among the balls. Return an array result of
    length n, where result[i] denotes the number of distinct colors after ith
    query. Note that when answering a query, lack of a color will not be
    considered as a color.

    Example 1:
    Input: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]
    Output: [1,2,2,3]
    Explanation: - After query 0, ball 1 has color 4.
                 - After query 1, ball 1 has color 4, and ball 2 has color 5.
                 - After query 2, ball 1 has color 3, and ball 2 has color 5.
                 - After query 3, ball 1 has color 3, ball 2 has color 5, and
                   ball 3 has color 4.

    Example 2:
    Input: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]
    Output: [1,2,2,3,4]
    Explanation: - After query 0, ball 0 has color 1.
                 - After query 1, ball 0 has color 1, and ball 1 has color 2.
                 - After query 2, ball 0 has color 1, and balls 1 and 2 have
                   color 2.
                 - After query 3, ball 0 has color 1, balls 1 and 2 have color
                   2, and ball 3 has color 4.
                 - After query 4, ball 0 has color 1, balls 1 and 2 have color
                   2, ball 3 has color 4, and ball 4 has color 5.

    Constraints:
    * 1 <= limit <= 10^9
    * 1 <= n == queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= queries[i][0] <= limit
    * 1 <= queries[i][1] <= 10^9*/

    public int[] queryResults(int limit, int[][] queries) {
        int n = queries.length;
        int[] ans = new int[n];
        Map<Integer, Integer> mp = new HashMap(), freq = new HashMap();
        for (int i = 0; i < n; ++i) {
            int b = queries[i][0], c = queries[i][1];
            if (mp.containsKey(b)) {
                freq.merge(mp.get(b), -1, Integer::sum);
                if (freq.get(mp.get(b)) == 0) freq.remove(mp.get(b));
            }
            mp.put(b, c);
            freq.merge(c, 1, Integer::sum);
            ans[i] = freq.size();
        }
        return ans;
    }


    /*3161. Block Placement Queries (Hard）
    There exists an infinite number line, with its origin at 0 and extending
    towards the positive x-axis. You are given a 2D array queries, which
    contains two types of queries:
    * For a query of type 1, queries[i] = [1, x]. Build an obstacle at distance
      x from the origin. It is guaranteed that there is no obstacle at distance
      x when the query is asked.
    * For a query of type 2, queries[i] = [2, x, sz]. Check if it is possible to
      place a block of size sz anywhere in the range [0, x] on the line, such
      that the block entirely lies in the range [0, x]. A block cannot be placed
      if it intersects with any obstacle, but it may touch it. Note that you do
      not actually place the block. Queries are separate.
    Return a boolean array results, where results[i] is true if you can place
    the block specified in the ith query of type 2, and false otherwise.

    Example 1:
    Input: queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]
    Output: [false,true,true]
    Explanation: For query 0, place an obstacle at x = 2. A block of size at
                 most 2 can be placed before x = 3.

    Example 2:
    Input: queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]
    Output: [true,true,false]
    Explanation: - Place an obstacle at x = 7 for query 0. A block of size at
                   most 7 can be placed before x = 7.
                 - Place an obstacle at x = 2 for query 2. Now, a block of size
                   at most 5 can be placed before x = 7, and a block of size at
                   most 2 before x = 2.

    Constraints:
    * 1 <= queries.length <= 15 * 10^4
    * 2 <= queries[i].length <= 3
    * 1 <= queries[i][0] <= 2
    * 1 <= x, sz <= min(5 * 104, 3 * queries.length)
    * The input is generated such that for queries of type 1, no obstacle exists
      at distance x when the query is asked.
    * The input is generated such that there is at least one query of type 2.

    class Fenwick {
        private int[] nums;

        public Fenwick(int n) {
            nums = new int[n+1];
        }

        public void update(int k, int val) {
            for (++k; k < nums.length; k += k & -k)
                nums[k] = Math.max(nums[k], val);
        }

        public int query(int k) {
            int ans = 0;
            for (++k; k > 0; k -= k & -k)
                ans = Math.max(ans, nums[k]);
            return ans;
        }
    }*/

    public List<Boolean> getResults(int[][] queries) {
        TreeSet<Integer> vals = new TreeSet();
        vals.add(0);
        Fenwick tree = new Fenwick(50001);
        List<int[]> part = new ArrayList();
        for (var q : queries)
            if (q[0] == 1) part.add(q);
        Collections.sort(part, (x, y) -> Integer.compare(x[1], y[1]));
        int pp = 0;
        for (var p : part) {
            vals.add(p[1]);
            tree.update(p[1], p[1] - pp);
            pp = p[1];
        }
        List<Boolean> ans = new ArrayList();
        int n = queries.length;
        int[][] rev = new int[n][];
        IntStream.range(0, n).forEach(i -> rev[i] = queries[n-1-i]);
        for (var q : rev) {
            if (q[0] == 1) {
                Integer lo = vals.floor(q[1]-1), hi = vals.ceiling(q[1]+1);
                if (hi != null) tree.update(hi, hi-lo);
                vals.remove(q[1]);
            } else {
                Integer lo = vals.floor(q[1]);
                ans.add(Math.max(tree.query(q[1]), q[1]-lo) >= q[2]);
            }
        }
        Collections.reverse(ans);
        return ans;
    }


    /*3162. Find the Number of Good Pairs I (Easy)
    You are given 2 integer arrays nums1 and nums2 of lengths n and m
    respectively. You are also given a positive integer k. A pair (i, j) is
    called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1,
    0 <= j <= m - 1). Return the total number of good pairs.

    Example 1:
    Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
    Output: 5
    Explanation: The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).

    Example 2:
    Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
    Output: 2
    Explanation: The 2 good pairs are (3, 0) and (3, 1).

    Constraints:
    * 1 <= n, m <= 50
    * 1 <= nums1[i], nums2[j] <= 50
    * 1 <= k <= 50*/

    public int numberOfPairs(int[] nums1, int[] nums2, int k) {
        int ans = 0;
        for (var x : nums1)
            for (var y : nums2)
                if (x % (y*k) == 0) ++ans;
        return ans;
    }


    /*3163. String Compression III (Medium)
    Given a string word, compress it using the following algorithm:
    * Begin with an empty string comp. While word is not empty, use the
      following operation:
      - Remove a maximum length prefix of word made of a single character c
        repeating at most 9 times.
      - Append the length of the prefix followed by c to comp.
    Return the string comp.

    Example 1:
    Input: word = "abcde"
    Output: "1a1b1c1d1e"
    Explanation: Initially, comp = "". Apply the operation 5 times, choosing
                 "a", "b", "c", "d", and "e" as the prefix in each operation.
                 For each prefix, append "1" followed by the character to comp.

    Example 2:
    Input: word = "aaaaaaaaaaaaaabb"
    Output: "9a5a2b"
    Explanation: Initially, comp = "". Apply the operation 3 times, choosing
                 "aaaaaaaaa", "aaaaa", and "bb" as the prefix in each operation.
                 - For prefix "aaaaaaaaa", append "9" followed by "a" to comp.
                 - For prefix "aaaaa", append "5" followed by "a" to comp.
                 - For prefix "bb", append "2" followed by "b" to comp.

    Constraints:
    * 1 <= word.length <= 2 * 10^5
    * word consists only of lowercase English letters.*/

    public String compressedString(String word) {
        StringBuilder ans = new StringBuilder();
        for (int i = 0, ii = 0, n = word.length(); i < n; ++i)
            if (i == n-1 || word.charAt(i) != word.charAt(i+1) || i-ii+1 == 9) {
                ans.append((char) (i-ii+1 + '0'));
                ans.append(word.charAt(i));
                ii = i+1;
            }
        return ans.toString();
    }


    /*3164. Find the Number of Good Pairs II (Medium)
    You are given 2 integer arrays nums1 and nums2 of lengths n and m
    respectively. You are also given a positive integer k. A pair (i, j) is
    called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1,
    0 <= j <= m - 1). Return the total number of good pairs.

    Example 1:
    Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
    Output: 5
    Explanation: The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).

    Example 2:
    Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
    Output: 2
    Explanation: The 2 good pairs are (3, 0) and (3, 1).

    Constraints:
    * 1 <= n, m <= 10^5
    * 1 <= nums1[i], nums2[j] <= 10^6
    * 1 <= k <= 10^3*/

    public long numberOfPairs(int[] nums1, int[] nums2, int k) {
        int m = Arrays.stream(nums1).max().getAsInt();
        Map<Integer, Integer> freq1 = new HashMap<>(), freq2 = new HashMap<>();
        for (var x : nums1)
            if (x % k == 0) freq1.merge(x/k, 1, Integer::sum);
        for (var x : nums2)
            freq2.merge(x, 1, Integer::sum);
        long ans = 0;
        for (var x : freq2.keySet()) {
            int v = freq2.get(x);
            for (int xx = x; xx <= m; xx += x)
                ans += (long) freq1.getOrDefault(xx, 0) * v;
        }
        return ans;
    }


    /*3165. Maximum Sum of Subsequence With Non-adjacent Elements (Hard)
    You are given an array nums consisting of integers. You are also given a 2D
    array queries, where queries[i] = [posi, xi]. For query i, we first set
    nums[posi] equal to xi, then we calculate the answer to query i which is the
    maximum sum of a subsequence of nums where no two adjacent elements are
    selected. Return the sum of the answers to all queries. Since the final
    answer may be very large, return it modulo 10^9 + 7. A subsequence is an
    array that can be derived from another array by deleting some or no elements
    without changing the order of the remaining elements.

    Example 1:
    Input: nums = [3,5,9], queries = [[1,-2],[0,-3]]
    Output: 21
    Explanation: - After the 1st query, nums = [3,-2,9] and the maximum sum of a
                   subsequence with non-adjacent elements is 3 + 9 = 12.
                 - After the 2nd query, nums = [-3,-2,9] and the maximum sum of
                   a subsequence with non-adjacent elements is 9.

    Example 2:
    Input: nums = [0,-1], queries = [[0,-5]]
    Output: 0
    Explanation: After the 1st query, nums = [-5,-1] and the maximum sum of a
                 subsequence with non-adjacent elements is 0 (choosing an empty
                 subsequence).

    Constraints:
    * 1 <= nums.length <= 5 * 10^4
    * -10^5 <= nums[i] <= 10^5
    * 1 <= queries.length <= 5 * 10^4
    * queries[i] == [posi, xi]
    * 0 <= posi <= nums.length - 1
    * -10^5 <= xi <= 10^5

    class SegTree {
        private int mod = 1_000_000_007;
        private int n;
        private long[][] tree;

        private long[] op(long[] left, long[] right) {
            long lv = left[0], ls = left[1], le = left[2], lse = left[3];
            long rv = right[0], rs = right[1], re = right[2], rse = right[3];
            long v = Math.max(le+rv, lv+rs), s = Math.max(ls+rs, lse+rv), e = Math.max(le+re, lv+rse), se = Math.max(lse+re, ls+rse);
            return new long[]{v, s, e, se};
        }

        private void build(int[] arr, int k, int lo, int hi) {
            if (lo+1 == hi) tree[k] = new long[]{Math.max(0, arr[lo]), 0, 0, 0};
            else {
                int mid = lo + (hi-lo)/2;
                build(arr, 2*k+1, lo, mid);
                build(arr, 2*k+2, mid, hi);
                tree[k] = op(tree[2*k+1], tree[2*k+2]);
            }
        }

        public SegTree(int[] arr) {
            n = arr.length;
            tree = new long[4*n][4];
            build(arr, 0, 0, n);
        }

        public void update(int i, int val) {
            update(i, val, 0, 0, n);
        }

        private void update(int i, int val, int k, int lo, int hi) {
            if (lo+1 == hi) tree[k][0] = Math.max(0, val);
            else {
                int mid = lo + (hi-lo)/2;
                if (i < mid) update(i, val, 2*k+1, lo, mid);
                else update(i, val, 2*k+2, mid, hi);
                tree[k] = op(tree[2*k+1], tree[2*k+2]);
            }
        }

        public long[] query(int qlo, int qhi) {
            return query(qlo, qhi, 0, 0, n);
        }

        private long[] query(int qlo, int qhi, int k, int lo, int hi) {
            if (qhi <= lo || hi <= qlo) return new long[]{0, 0, 0, 0};
            if (qlo <= lo && hi <= qhi) return tree[k];
            int mid = lo + (hi-lo)/2;
            return op(query(qlo, qhi, 2*k+1, lo, mid), query(qlo, qhi, 2*k+2, mid, hi));
        }
    }*/

    public int maximumSumSubsequence(int[] nums, int[][] queries) {
        SegTree tree = new SegTree(nums);
        long ans = 0;
        for (var q : queries) {
            int i = q[0], x = q[1];
            tree.update(i, x);
            ans = (ans + tree.query(0, nums.length)[0]) % 1_000_000_007;
        }
        return (int) ans;
    }


    /*3168. Minimum Number of Chairs in a Waiting Room (Easy)
    You are given a string s. Simulate events at each second i:
    * If s[i] == 'E', a person enters the waiting room and takes one of the
      chairs in it.
    * If s[i] == 'L', a person leaves the waiting room, freeing up a chair.
    Return the minimum number of chairs needed so that a chair is available for
    every person who enters the waiting room given that it is initially empty.

    Example 1:
    Input: s = "EEEEEEE"
    Output: 7
    Explanation: After each second, a person enters the waiting room and no
                 person leaves it. Therefore, a minimum of 7 chairs is needed.

    Example 2:
    Input: s = "ELELEEL"
    Output: 2
    Explanation: Let's consider that there are 2 chairs in the waiting room. The
                 table below shows the state of the waiting room at each second.
                 Second  Event   People in the Waiting Room  Available Chairs
                 0   Enter   1   1
                 1   Leave   0   2
                 2   Enter   1   1
                 3   Leave   0   2
                 4   Enter   1   1
                 5   Enter   2   0
                 6   Leave   1   1

    Example 3:
    Input: s = "ELEELEELLL"
    Output: 3
    Explanation: Let's consider that there are 3 chairs in the waiting room. The
                 table below shows the state of the waiting room at each second.
                 Second  Event   People in the Waiting Room  Available Chairs
                 0   Enter   1   2
                 1   Leave   0   3
                 2   Enter   1   2
                 3   Enter   2   1
                 4   Leave   1   2
                 5   Enter   2   1
                 6   Enter   3   0
                 7   Leave   2   1
                 8   Leave   1   2
                 9   Leave   0   3

    Constraints:
    * 1 <= s.length <= 50
    * s consists only of the letters 'E' and 'L'.
    * s represents a valid sequence of entries and exits.*/

    public int minimumChairs(String s) {
        int ans = 0, prefix = 0;
        for (var ch : s.toCharArray()) {
            if (ch == 'E') ++prefix;
            else --prefix;
            ans = Math.max(ans, prefix);
        }
        return ans;
    }


    /*3169. Count Days Without Meetings (Medium)
    You are given a positive integer days representing the total number of days
    an employee is available for work (starting from day 1). You are also given
    a 2D array meetings of size n where, meetings[i] = [start_i, end_i]
    represents the starting and ending days of meeting i (inclusive). Return the
    count of days when the employee is available for work but no meetings are
    scheduled. Note: The meetings may overlap.

    Example 1:
    Input: days = 10, meetings = [[5,7],[1,3],[9,10]]
    Output: 2
    Explanation: There is no meeting scheduled on the 4th and 8th days.

    Example 2:
    Input: days = 5, meetings = [[2,4],[1,3]]
    Output: 1
    Explanation: There is no meeting scheduled on the 5th day.

    Example 3:
    Input: days = 6, meetings = [[1,6]]
    Output: 0
    Explanation: Meetings are scheduled for all working days.

    Constraints:
    * 1 <= days <= 10^9
    * 1 <= meetings.length <= 10^5
    * meetings[i].length == 2
    * 1 <= meetings[i][0] <= meetings[i][1] <= days*/

    public int countDays(int days, int[][] meetings) {
        int ans = 0, prev = 0;
        Arrays.sort(meetings, (x, y) -> Integer.compare(x[0], y[0]));
        for (var m : meetings) {
            int x = m[0], y = m[1];
            ans += Math.max(0, Math.min(x, days)-prev-1);
            prev = Math.max(prev, y);
        }
        return ans + Math.max(0, days-prev);
    }


    /*3170. Lexicographically Minimum String After Removing Stars (Medium)
    You are given a string s. It may contain any number of '*' characters. Your
    task is to remove all '*' characters. While there is a '*', do the following
    operation:
    * Delete the leftmost '*' and the smallest non-'*' character to its left. If
      there are several smallest characters, you can delete any of them.
    Return the lexicographically smallest resulting string after removing all
    '*' characters.

    Example 1:
    Input: s = "aaba*"
    Output: "aab"
    Explanation: We should delete one of the 'a' characters with '*'. If we
                 choose s[3], s becomes the lexicographically smallest.

    Example 2:
    Input: s = "abc"
    Output: "abc"
    Explanation: There is no '*' in the string.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters and '*'.
    * The input is generated such that it is possible to delete all '*'
    characters.*/

    public String clearStars(String s) {
        char[] chs = s.toCharArray();
        Queue<Integer> pq = new PriorityQueue<>((i, j) -> s.charAt(i) != s.charAt(j) ? Character.compare(s.charAt(i), s.charAt(j)) : Integer.compare(j, i));
        for (int i = 0; i < chs.length; ++i)
            if (chs[i] == '*') chs[pq.poll()] = '*';
            else pq.add(i);
        return new String(chs).replaceAll("\\*", "");
    }


    /*3171. Find Subarray With Bitwise AND Closest to K (Hard)
    You are given an array nums and an integer k. You need to find a subarray of
    nums such that the absolute difference between k and the bitwise AND of the
    subarray elements is as small as possible. In other words, select a subarray
    nums[l..r] such that |k - (nums[l] AND nums[l + 1] ... AND nums[r])| is
    minimum. Return the minimum possible value of the absolute difference. A
    subarray is a contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [1,2,4,5], k = 3
    Output: 1
    Explanation: The subarray nums[2..3] has AND value 4, which gives the
                 minimum absolute difference |3 - 4| = 1.

    Example 2:
    Input: nums = [1,2,1,2], k = 2
    Output: 0
    Explanation: The subarray nums[1..1] has AND value 2, which gives the
                 minimum absolute difference |2 - 2| = 0.

    Example 3:
    Input: nums = [1], k = 10
    Output: 9
    Explanation: There is a single subarray with AND value 1, which gives the
                 minimum absolute difference |10 - 1| = 9.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9*/

    public int minimumDifference(int[] nums, int k) {
        int[] freq = new int[30];
        int ans = Integer.MAX_VALUE, mask = (1<<30)-1;
        for (int i = 0, ii = 0; i < nums.length; ++i) {
            for (int j = 0; j < 30; ++j)
                if ((nums[i] & 1<<j) == 0 && freq[j]++ == 0)
                    mask ^= 1<<j;
            ans = Math.min(ans, Math.abs(mask-k));
            for (; ii < i && mask < k; ++ii) {
                for (int j = 0; j < 30; ++j)
                    if ((nums[ii] & 1<<j) == 0 && --freq[j] == 0)
                        mask ^= 1<<j;
                ans = Math.min(ans, Math.abs(mask-k));
            }
        }
        return ans;
    }


    /*3174. Clear Digits (Easy)
    You are given a string s. Your task is to remove all digits by doing this
    operation repeatedly:
    * Delete the first digit and the closest non-digit character to its left.
    Return the resulting string after removing all digits.

    Example 1:
    Input: s = "abc"
    Output: "abc"
    Explanation: There is no digit in the string.

    Example 2:
    Input: s = "cb34"
    Output: ""
    Explanation: First, we apply the operation on s[2], and s becomes "c4". Then
                 we apply the operation on s[1], and s becomes "".

    Constraints:
    * 1 <= s.length <= 100
    * s consists only of lowercase English letters and digits.
    * The input is generated such that it is possible to delete all digits.*/

    public String clearDigits(String s) {
        StringBuilder sb = new StringBuilder();
        for (var ch : s.toCharArray())
            if ('0' <= ch && ch <= '9') sb.setLength(sb.length()-1);
            else sb.append(ch);
        return sb.toString();
    }


    /*3175. Find The First Player to win K Games in a Row (Medium)
    A competition consists of n players numbered from 0 to n - 1. You are given
    an integer array skills of size n and a positive integer k, where skills[i]
    is the skill level of player i. All integers in skills are unique. All
    players are standing in a queue in order from player 0 to player n - 1. The
    competition process is as follows:
    * The first two players in the queue play a game, and the player with the
      higher skill level wins.
    * After the game, the winner stays at the beginning of the queue, and the
      loser goes to the end of it.
    The winner of the competition is the first player who wins k games in a row.
    Return the initial index of the winning player.

    Example 1:
    Input: skills = [4,2,6,3,9], k = 2
    Output: 2
    Explanation: Initially, the queue of players is [0,1,2,3,4]. The following
                 process happens:
                 - Players 0 and 1 play a game, since the skill of player 0 is
                   higher than that of player 1, player 0 wins. The resulting
                   queue is [0,2,3,4,1].
                 - Players 0 and 2 play a game, since the skill of player 2 is
                   higher than that of player 0, player 2 wins. The resulting
                   queue is [2,3,4,1,0].
                 - Players 2 and 3 play a game, since the skill of player 2 is
                   higher than that of player 3, player 2 wins. The resulting
                   queue is [2,4,1,0,3].
                 - Player 2 won k = 2 games in a row, so the winner is player 2.

    Example 2:
    Input: skills = [2,5,4], k = 3
    Output: 1
    Explanation: Initially, the queue of players is [0,1,2]. The following
                 process happens:
                 - Players 0 and 1 play a game, since the skill of player 1 is
                   higher than that of player 0, player 1 wins. The resulting
                   queue is [1,2,0].
                 - Players 1 and 2 play a game, since the skill of player 1 is
                   higher than that of player 2, player 1 wins. The resulting
                   queue is [1,0,2].
                 - Players 1 and 0 play a game, since the skill of player 1 is
                   higher than that of player 0, player 1 wins. The resulting
                   queue is [1,2,0].
                 - Player 1 won k = 3 games in a row, so the winner is player 1.

    Constraints:
    * n == skills.length
    * 2 <= n <= 10^5
    * 1 <= k <= 10^9
    * 1 <= skills[i] <= 10^6
    * All integers in skills are unique.*/

    public int findWinningPlayer(int[] skills, int k) {
        int j = 0;
        for (int i = 1, cnt = 0; i < skills.length && cnt < k; ++i, ++cnt)
            if (skills[j] < skills[i]) {
                j = i;
                cnt = 0;
            }
        return j;
    }


    /*3176. Find the Maximum Length of a Good Subsequence I (Medium)
    You are given an integer array nums and a non-negative integer k. A sequence
    of integers seq is called good if there are at most k indices i in the range
    [0, seq.length - 2] such that seq[i] != seq[i + 1]. Return the maximum
    possible length of a good subsequence of nums.

    Example 1:
    Input: nums = [1,2,1,1,3], k = 2
    Output: 4
    Explanation: The maximum length subsequence is [1,2,1,1,3].

    Example 2:
    Input: nums = [1,2,3,4,5,1], k = 0
    Output: 2
    Explanation: The maximum length subsequence is [1,2,3,4,5,1].

    Constraints:
    * 1 <= nums.length <= 500
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= min(nums.length, 25)*/

    public int maximumLength(int[] nums, int k) {
        Map<Integer, Integer>[] dp = new Map[k+1];
        for (int i = 0; i <= k; ++i)
            dp[i] = new HashMap();
        int[] most = new int[k+1];
        for (var x : nums)
            for (int i = k; i >= 0; --i) {
                dp[i].merge(x, 1, Integer::sum);
                if (i > 0) dp[i].put(x, Math.max(dp[i].get(x), 1 + most[i-1]));
                most[i] = Math.max(most[i], dp[i].get(x));
            }
        return most[k];
    }


    /*3177. Find the Maximum Length of a Good Subsequence II (Hard)
    You are given an integer array nums and a non-negative integer k. A sequence
    of integers seq is called good if there are at most k indices i in the range
    [0, seq.length - 2] such that seq[i] != seq[i + 1]. Return the maximum
    possible length of a good subsequence of nums.

    Example 1:
    Input: nums = [1,2,1,1,3], k = 2
    Output: 4
    Explanation: The maximum length subsequence is [1,2,1,1,3].

    Example 2:
    Input: nums = [1,2,3,4,5,1], k = 0
    Output: 2
    Explanation: The maximum length subsequence is [1,2,3,4,5,1].

    Constraints:
    * 1 <= nums.length <= 5 * 10^3
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= min(50, nums.length)*/

    public int maximumLength(int[] nums, int k) {
        Map<Integer, Integer>[] dp = new Map[k+1];
        for (int i = 0; i <= k; ++i)
            dp[i] = new HashMap();
        int[] most = new int[k+1];
        for (var x : nums)
            for (int i = k; i >= 0; --i) {
                dp[i].merge(x, 1, Integer::sum);
                if (i > 0) dp[i].put(x, Math.max(dp[i].get(x), 1 + most[i-1]));
                most[i] = Math.max(most[i], dp[i].get(x));
            }
        return most[k];
    }


    /*3179. Find the N-th Value After K Seconds (Medium)
    You are given two integers n and k. Initially, you start with an array a of
    n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you
    simultaneously update each element to be the sum of all its preceding
    elements plus the element itself. For example, after one second, a[0]
    remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2],
    and so on. Return the value of a[n - 1] after k seconds. Since the answer
    may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 4, k = 5
    Output: 56
    Explanation: Second  State After
                 0   [1,1,1,1]
                 1   [1,2,3,4]
                 2   [1,3,6,10]
                 3   [1,4,10,20]
                 4   [1,5,15,35]
                 5   [1,6,21,56]

    Example 2:
    Input: n = 5, k = 3
    Output: 35
    Explanation: Second  State After
                 0   [1,1,1,1,1]
                 1   [1,2,3,4,5]
                 2   [1,3,6,10,15]
                 3   [1,4,10,20,35]

    Constraints: 1 <= n, k <= 1000*/

    public int valueAfterKSeconds(int n, int k) {
        long ans = 1;
        long[] inv = new long[k+1];
        inv[0] = inv[1] = 1;
        int mod = 1_000_000_007;
        for (int i = 1; i <= k; ++i) {
            if (i >= 2)
                inv[i] = mod - mod/i * inv[mod % i] % mod;
            ans = ans * (n+k-i) % mod;
            ans = ans * inv[i] % mod;
        }
        return (int) ans;
    }


    /*3184. Count Pairs That Form a Complete Day I (Easy)
    Given an integer array hours representing times in hours, return an integer
    denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms
    a complete day. A complete day is defined as a time duration that is an
    exact multiple of 24 hours. For example, 1 day is 24 hours, 2 days is 48
    hours, 3 days is 72 hours, and so on.

    Example 1:
    Input: hours = [12,12,30,24,24]
    Output: 2
    Explanation: The pairs of indices that form a complete day are (0, 1) and
                 (3, 4).

    Example 2:
    Input: hours = [72,48,24,3]
    Output: 3
    Explanation: The pairs of indices that form a complete day are (0, 1),
                 (0, 2), and (1, 2).

    Constraints:
    * 1 <= hours.length <= 100
    * 1 <= hours[i] <= 10^9*/

    public int countCompleteDayPairs(int[] hours) {
        int ans = 0;
        int[] freq = new int[24];
        for (var h : hours) {
            ans += freq[(24-h%24) % 24];
            ++freq[h % 24];
        }
        return ans;
    }


    /*3185. Count Pairs That Form a Complete Day II (Medium)
    Given an integer array hours representing times in hours, return an integer
    denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms
    a complete day. A complete day is defined as a time duration that is an
    exact multiple of 24 hours. For example, 1 day is 24 hours, 2 days is 48
    hours, 3 days is 72 hours, and so on.

    Example 1:
    Input: hours = [12,12,30,24,24]
    Output: 2
    Explanation: The pairs of indices that form a complete day are (0, 1) and
                 (3, 4).

    Example 2:
    Input: hours = [72,48,24,3]
    Output: 3
    Explanation: The pairs of indices that form a complete day are (0, 1),
                 (0, 2), and (1, 2).

    Constraints:
    * 1 <= hours.length <= 5 * 10^5
    * 1 <= hours[i] <= 10^9*/

    public long countCompleteDayPairs(int[] hours) {
        long ans = 0;
        int[] freq = new int[24];
        for (var h : hours) {
            ans += freq[(24-h%24) % 24];
            ++freq[h % 24];
        }
        return ans;
    }


    /*3186. Maximum Total Damage With Spell Casting (Medium)
    A magician has various spells. You are given an array power, where each
    element represents the damage of a spell. Multiple spells can have the same
    damage value. It is a known fact that if a magician decides to cast a spell
    with a damage of power[i], they cannot cast any spell with a damage of
    power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2. Each spell can be
    cast only once. Return the maximum possible total damage that a magician can
    cast.

    Example 1:
    Input: power = [1,1,3,4]
    Output: 6
    Explanation: The maximum possible damage of 6 is produced by casting spells
                 0, 1, 3 with damage 1, 1, 4.

    Example 2:
    Input: power = [7,1,6,6]
    Output: 13
    Explanation: The maximum possible damage of 13 is produced by casting spells
                 1, 2, 3 with damage 1, 6, 6.

    Constraints:
    * 1 <= power.length <= 10^5
    * 1 <= power[i] <= 10^9*/

    public long maximumTotalDamage(int[] power) {
        Arrays.sort(power);
        long[] dp = new long[power.length];
        long prefix = 0;
        for (int i = 0, j = 0; i < power.length; ++i)
            if (i > 0 && power[i-1] == power[i]) dp[i] = dp[i-1] + power[i];
            else {
                for (; power[j] < power[i]-2; ++j)
                    prefix = Math.max(prefix, dp[j]);
                dp[i] = prefix + power[i];
            }
        return Arrays.stream(dp).max().getAsLong();
    }


    /*3187. Peaks in Array (Hard)
    A peak in an array arr is an element that is greater than its previous and
    next element in arr. You are given an integer array nums and a 2D integer
    array queries. You have to process queries of two types:
    * queries[i] = [1, li, ri], determine the count of peak elements in the
      subarray nums[li..ri].
    * queries[i] = [2, indexi, vali], change nums[indexi] to vali.
    Return an array answer containing the results of the queries of the first
    type in order. Notes:
    * The first and the last element of an array or a subarray cannot be a peak.

    Example 1:
    Input: nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]
    Output: [0]
    Explanation: First query: We change nums[3] to 4 and nums becomes
                 [3,1,4,4,5]. Second query: The number of peaks in the
                 [3,1,4,4,5] is 0.

    Example 2:
    Input: nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]
    Output: [0,1]
    Explanation: First query: nums[2] should become 4, but it is already set to
                 4. Second query: The number of peaks in the [4,1,4] is 0. Third
                 query: The second 4 is a peak in the [4,1,4,2,1].

    Constraints:
    * 3 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i][0] == 1 or queries[i][0] == 2
    * For all i that:
      - queries[i][0] == 1: 0 <= queries[i][1] <= queries[i][2] <= nums.length - 1
      - queries[i][0] == 2: 0 <= queries[i][1] <= nums.length - 1,
    1 <= queries[i][2] <= 10^5

    class Fenwick {
        private int[] nums;

        public Fenwick(int n) {
            nums = new int[n+1];
        }

        public void add(int k, int delta) {
            for (++k; k < nums.length; k += k & -k)
                nums[k] += delta;
        }

        public int query(int k) {
            int ans = 0;
            for (++k; k > 0; k -= k & -k)
                ans += nums[k];
            return ans;
        }
    }*/

    public List<Integer> countOfPeaks(int[] nums, int[][] queries) {
        int n = nums.length;
        Fenwick tree = new Fenwick(n);
        for (int i = 1; i+1 < n; ++i)
            if (nums[i-1] < nums[i] && nums[i] > nums[i+1])
                tree.add(i, 1);
        List<Integer> ans = new ArrayList();
        for (var q : queries) {
            if (q[0] == 1) {
                int lo = q[1], hi = q[2];
                ans.add(tree.query(Math.max(lo, hi-1)) - tree.query(lo));
            } else {
                int k = q[1], v = q[2];
                for (int i = Math.max(1, k-1); i <= k+1 && i+1 < n; ++i)
                    if (nums[i-1] < nums[i] && nums[i] > nums[i+1])
                        tree.add(i, -1);
                nums[k] = v;
                for (int i = Math.max(1, k-1); i <= k+1 && i+1 < n; ++i)
                    if (nums[i-1] < nums[i] && nums[i] > nums[i+1])
                        tree.add(i, 1);
            }
        }
        return ans;
    }


    /*3190. Find Minimum Operations to Make All Elements Divisible by Three (Easy)
    You are given an integer array nums. In one operation, you can add or
    subtract 1 from any element of nums. Return the minimum number of operations
    to make all elements of nums divisible by 3.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 3
    Explanation: All array elements can be made divisible by 3 using 3
                 operations:
                 - Subtract 1 from 1.
                 - Add 1 to 2.
                 - Subtract 1 from 4.

    Example 2:
    Input: nums = [3,6,9]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 50
    * 1 <= nums[i] <= 50*/

    public int minimumOperations(int[] nums) {
        return Arrays.stream(nums).reduce(0, (s, x) -> s + Math.min(x%3, 3-x%3));
    }


    /*3191. Minimum Operations to Make Binary Array Elements Equal to One I (Medium)
    You are given a binary array nums. You can do the following operation on the
    array any number of times (possibly zero):
    * Choose any 3 consecutive elements from the array and flip all of them.
    Flipping an element means changing its value from 0 to 1, and from 1 to 0.
    Return the minimum number of operations required to make all elements in
    nums equal to 1. If it is impossible, return -1.

    Example 1:
    Input: nums = [0,1,1,1,0,0]
    Output: 3
    Explanation: We can do the following operations:
                 - Choose the elements at indices 0, 1 and 2. The resulting
                   array is nums = [1,0,0,1,0,0].
                 - Choose the elements at indices 1, 2 and 3. The resulting
                   array is nums = [1,1,1,0,0,0].
                 - Choose the elements at indices 3, 4 and 5. The resulting
                   array is nums = [1,1,1,1,1,1].

    Example 2:
    Input: nums = [0,1,1,1]
    Output: -1
    Explanation: It is impossible to make all elements equal to 1.

    Constraints:
    * 3 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1*/

    public int minOperations(int[] nums) {
        int ans = 0, flip = 0, n = nums.length;
        int[] line = new int[n];
        for (int i = 0; i < n; ++i) {
            if (line[i] > 0) flip ^= 1;
            nums[i] ^= flip;
            if (nums[i] == 0) {
                if (i+2 >= n) return -1;
                ++ans;
                flip ^= 1;
                if (i+3 < n) line[i+3] = 1;
            }
        }
        return ans;
    }


    /*3192. Minimum Operations to Make Binary Array Elements Equal to One II (Medium)
    You are given a binary array nums. You can do the following operation on
    the array any number of times (possibly zero):
    * Choose any index i from the array and flip all the elements from index i
      to the end of the array.
    Flipping an element means changing its value from 0 to 1, and from 1 to 0.
    Return the minimum number of operations required to make all elements in
    nums equal to 1.

    Example 1:
    Input: nums = [0,1,1,0,1]
    Output: 4
    Explanation: We can do the following operations:
                 - Choose the index i = 1. The resulting array will be
                   nums = [0,0,0,1,0].
                 - Choose the index i = 0. The resulting array will be
                   nums = [1,1,1,0,1].
                 - Choose the index i = 4. The resulting array will be
                   nums = [1,1,1,0,0].
                 - Choose the index i = 3. The resulting array will be
                   nums = [1,1,1,1,1].

    Example 2:
    Input: nums = [1,0,0,0]
    Output: 1
    Explanation: We can do the following operation:
                 - Choose the index i = 1. The resulting array will be
                   nums = [1,1,1,1].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 1*/

    public int minOperations(int[] nums) {
        int ans = 0;
        for (var x : nums)
            if (x == (ans & 1)) ++ans;
        return ans;
    }


    /*3193. Count the Number of Inversions (Hard)
    You are given an integer n and a 2D array requirements, where
    requirements[i] = [endi, cnti] represents the end index and the inversion
    count of each requirement. A pair of indices (i, j) from an integer array
    nums is called an inversion if:
    * i < j and nums[i] > nums[j]
    Return the number of permutations perm of [0, 1, 2, ..., n - 1] such that
    for all requirements[i], perm[0..endi] has exactly cnti inversions. Since
    the answer may be very large, return it modulo 10^9 + 7.

    Example 1:
    Input: n = 3, requirements = [[2,2],[0,0]]
    Output: 2
    Explanation: The two permutations are:
                 - [2, 0, 1]
                   + Prefix [2, 0, 1] has inversions (0, 1) and (0, 2).
                   + Prefix [2] has 0 inversions.
                 - [1, 2, 0]
                   + Prefix [1, 2, 0] has inversions (0, 2) and (1, 2).
                   + Prefix [1] has 0 inversions.

    Example 2:
    Input: n = 3, requirements = [[2,2],[1,1],[0,0]]
    Output: 1
    Explanation: The only satisfying permutation is [2, 0, 1]:
                 - Prefix [2, 0, 1] has inversions (0, 1) and (0, 2).
                 - Prefix [2, 0] has an inversion (0, 1).
                 - Prefix [2] has 0 inversions.

    Example 3:
    Input: n = 2, requirements = [[0,0],[1,0]]
    Output: 1
    Explanation: The only satisfying permutation is [0, 1]:
                 - Prefix [0] has 0 inversions.
                 - Prefix [0, 1] has an inversion (0, 1).

    Constraints:
    * 2 <= n <= 300
    * 1 <= requirements.length <= n
    * requirements[i] = [endi, cnti]
    * 0 <= endi <= n - 1
    * 0 <= cnti <= 400
    * The input is generated such that there is at least one i such that
      endi == n - 1.
    * The input is generated such that all endi are unique.*/

    public int numberOfPermutations(int n, int[][] requirements) {
        int[] line = new int[n];
        Arrays.fill(line, -1);
        int m = 0, mod = 1_000_000_007;
        for (var r : requirements) {
            line[r[0]] = r[1];
            m = Math.max(m, r[1]);
        }
        int[][] dp = new int[n][m+1];
        dp[0][0] = 1;
        for (int i = 0; i < n; ++i) {
            long prefix = 0;
            for (int j = 0; j <= m; ++j) {
                if (i > 0) {
                    prefix += dp[i-1][j];
                    if (j > i) prefix -= dp[i-1][j-1-i];
                    prefix = (mod + prefix % mod) % mod;
                    dp[i][j] = (int) prefix;
                }
                if (line[i] != -1 && line[i] != j) dp[i][j] = 0;
            }
        }
        return dp[n-1][line[n-1]];
    }


    /*3194. Minimum Average of Smallest and Largest Elements (Easy)
    You have an array of floating point numbers averages which is initially
    empty. You are given an array nums of n integers where n is even. You repeat
    the following procedure n / 2 times:
    * Remove the smallest element, minElement, and the largest element
      maxElement, from nums.
    * Add (minElement + maxElement) / 2 to averages.
    Return the minimum element in averages.

    Example 1:
    Input: nums = [7,8,3,4,15,13,4,1]
    Output: 5.5
    Explanation: step  nums                 averages
                 0     [7,8,3,4,15,13,4,1]  []
                 1     [7,8,3,4,13,4]       [8]
                 2     [7,8,4,4]            [8,8]
                 3     [7,4]                [8,8,6]
                 4     []                   [8,8,6,5.5]
                 The smallest element of averages, 5.5, is returned.

    Example 2:
    Input: nums = [1,9,8,3,10,5]
    Output: 5.5
    Explanation: step  nums                 averages
                 0     [1,9,8,3,10,5]       []
                 1     [9,8,3,5]            [5.5]
                 2     [8,5]                [5.5,6]
                 3     []                   [5.5,6,6.5]

    Example 3:
    Input: nums = [1,2,3,7,8,9]
    Output: 5.0
    Explanation: step  nums                 averages
                 0     [1,2,3,7,8,9]        []
                 1     [2,3,7,8]            [5]
                 2     [3,7]                [5,5]
                 3     []                   [5,5,5]

    Constraints:
    * 2 <= n == nums.length <= 50
    * n is even.
    * 1 <= nums[i] <= 50*/

    public double minimumAverage(int[] nums) {
        Arrays.sort(nums);
        double ans = Double.MAX_VALUE;
        for (int lo = 0, hi = nums.length-1; lo < hi; ++lo, --hi)
            ans = Math.min(ans, 0.5*(nums[lo] + nums[hi]));
        return ans;
    }


    /*3195. Find the Minimum Area to Cover All Ones I (Medium)
    You are given a 2D binary array grid. Find a rectangle with horizontal and
    vertical sides with the smallest area, such that all the 1's in grid lie
    inside this rectangle. Return the minimum possible area of the rectangle.

    Example 1:
    Input: grid = [[0,1,0],[1,0,1]]
    Output: 6
    Explanation: The smallest rectangle has a height of 2 and a width of 3, so
                 it has an area of 2 * 3 = 6.

    Example 2:
    Input: grid = [[1,0],[0,0]]
    Output: 1
    Explanation: The smallest rectangle has both height and width 1, so its area
                 is 1 * 1 = 1.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 1000
    * grid[i][j] is either 0 or 1.
    * The input is generated such that there is at least one 1 in grid.*/

    public int minimumArea(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int imin = Integer.MAX_VALUE, imax = Integer.MIN_VALUE, jmin = Integer.MAX_VALUE, jmax = Integer.MIN_VALUE;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                if (grid[i][j] == 1) {
                    imin = Math.min(imin, i);
                    imax = Math.max(imax, i);
                    jmin = Math.min(jmin, j);
                    jmax = Math.max(jmax, j);
                }
        return (imax-imin+1)*(jmax-jmin+1);
    }


    /*3196. Maximize Total Cost of Alternating Subarrays (Medium)
    You are given an integer array nums with length n. The cost of a subarray
    nums[l..r], where 0 <= l <= r < n, is defined as:

    * cost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)r − l

    Your task is to split nums into subarrays such that the total cost of the
    subarrays is maximized, ensuring each element belongs to exactly one
    subarray. Formally, if nums is split into k subarrays, where k > 1, at
    indices i1, i2, ..., ik − 1, where 0 <= i1 < i2 < ... < ik - 1 < n - 1, then
    the total cost will be:

    * cost(0, i1) + cost(i1 + 1, i2) + ... + cost(ik − 1 + 1, n − 1)

    Return an integer denoting the maximum total cost of the subarrays after
    splitting the array optimally. Note: If nums is not split into subarrays,
    i.e. k = 1, the total cost is simply cost(0, n - 1).

    Example 1:
    Input: nums = [1,-2,3,4]
    Output: 10
    Explanation: One way to maximize the total cost is by splitting
                 [1, -2, 3, 4] into subarrays [1, -2, 3] and [4]. The total cost
                 will be (1 + 2 + 3) + 4 = 10.

    Example 2:
    Input: nums = [1,-1,1,-1]
    Output: 4
    Explanation: One way to maximize the total cost is by splitting
                 [1, -1, 1, -1] into subarrays [1, -1] and [1, -1]. The total
                 cost will be (1 + 1) + (1 + 1) = 4.

    Example 3:
    Input: nums = [0]
    Output: 0
    Explanation: We cannot split the array further, so the answer is 0.

    Example 4:
    Input: nums = [1,-1]
    Output: 2
    Explanation: Selecting the whole array gives a total cost of 1 + 1 = 2,
                 which is the maximum.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^9 <= nums[i] <= 10^9*/

    public long maximumTotalCost(int[] nums) {
        long ans = 0, suffix = 0;
        for (int i = nums.length-1; i >= 0; --i) {
            suffix = nums[i] - suffix;
            if (suffix > 0) {
                ans += suffix;
                suffix = 0;
            }
        }
        return ans + suffix;
    }


    /*3197. Find the Minimum Area to Cover All Ones II (Hard)
    You are given a 2D binary array grid. You need to find 3 non-overlapping
    rectangles having non-zero areas with horizontal and vertical sides such
    that all the 1's in grid lie inside these rectangles. Return the minimum
    possible sum of the area of these rectangles. Note that the rectangles are
    allowed to touch.

    Example 1:
    Input: grid = [[1,0,1],[1,1,1]]
    Output: 5
    Explanation: - The 1's at (0, 0) and (1, 0) are covered by a rectangle of
                   area 2.
                 - The 1's at (0, 2) and (1, 2) are covered by a rectangle of
                   area 2.
                 - The 1 at (1, 1) is covered by a rectangle of area 1.

    Example 2:
    Input: grid = [[1,0,1,0],[0,1,0,1]]
    Output: 5
    Explanation: - The 1's at (0, 0) and (0, 2) are covered by a rectangle of
                   area 3.
                 - The 1 at (1, 1) is covered by a rectangle of area 1.
                 - The 1 at (1, 3) is covered by a rectangle of area 1.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 30
    * grid[i][j] is either 0 or 1.
    * The input is generated such that there are at least three 1's in grid.*/

    private int[] fn(int[][] grid) {
        int m = grid.length;
        int[] ans = new int[m-1];
        int imin = 30, jmin = 30, imax = 0, jmax = 0;
        for (int i = 0; i < m-1; ++i) {
            for (int j = 0; j < grid[i].length; ++j)
                if (grid[i][j] == 1) {
                    imin = Math.min(imin, i);
                    jmin = Math.min(jmin, j);
                    imax = Math.max(imax, i);
                    jmax = Math.max(jmax, j);
                }
            int val = 0;
            if (imin <= imax && jmin <= jmax)
                val = (imax-imin+1) * (jmax-jmin+1);
            ans[i] = val;
        }
        return ans;
    }

    private int[][] rotate(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[][] ans = new int[n][m];
        for (int i = 0; i < m/2; ++i) {
            var temp = grid[i]; grid[i] = grid[m-1-i]; grid[m-1-i] = temp;
        }
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                ans[j][i] = grid[i][j];
        return ans;
    }

    public int minimumSum(int[][] grid) {
        int ans = Integer.MAX_VALUE;
        for (int k = 0; k < 4; ++k) {
            int[] half = fn(grid);
            for (int i = 0; i < half.length; ++i) {
                if (half[i] > 0) {
                    int[][] sub = Arrays.copyOfRange(grid, i+1, grid.length);
                    for (int sz = 0; sz < 2; ++sz) {
                        int[] top = fn(sub);
                        for (int r = 0, n = sub.length; r < n/2; ++r) {
                            var temp = sub[r]; sub[r] = sub[n-1-r]; sub[n-1-r] = temp;
                        }
                        int[] bottom = fn(sub);
                        for (int j = 0, n = top.length; j < n; ++j)
                            if (top[j] > 0 && bottom[n-1-j] > 0)
                                ans = Math.min(ans, half[i] + top[j] + bottom[n-1-j]);
                        sub = rotate(sub);
                    }
                }
            }
            grid = rotate(grid);
        }
        return ans;
    }


    /*3200. Maximum Height of a Triangle (Easy)
    You are given two integers red and blue representing the count of red and
    blue colored balls. You have to arrange these balls to form a triangle such
    that the 1st row will have 1 ball, the 2nd row will have 2 balls, the 3rd
    row will have 3 balls, and so on. All the balls in a particular row should
    be the same color, and adjacent rows should have different colors. Return
    the maximum height of the triangle that can be achieved.

    Example 1:
    Input: red = 2, blue = 4
    Output: 3
    Explanation: The only possible arrangement is shown above.

    Example 2:
    Input: red = 2, blue = 1
    Output: 2
    Explanation: The only possible arrangement is shown above.

    Example 3:
    Input: red = 1, blue = 1
    Output: 1

    Example 4:
    Input: red = 10, blue = 1
    Output: 2
    Explanation: The only possible arrangement is shown above.

    Constraints: 1 <= red, blue <= 100*/

    public int maxHeightOfTriangle(int red, int blue) {
        int ans = 0;
        int[][] balls = new int[][]{{red, blue}, {blue, red}};
        for (var ball : balls) {
            int cand = 0;
            for (int k = 1, i = 0; ball[i] >= k; ++k, i ^= 1) {
                ball[i] -= k;
                ++cand;
            }
            ans = Math.max(ans, cand);
        }
        return ans;
    }


    /*3201. Find the Maximum Length of Valid Subsequence I (Medium)
    You are given an integer array nums. A subsequence sub of nums with length x
    is called valid if it satisfies:
    * (sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ...
      == (sub[x - 2] + sub[x - 1]) % 2.
    Return the length of the longest valid subsequence of nums. A subsequence is
    an array that can be derived from another array by deleting some or no
    elements without changing the order of the remaining elements.

    Example 1:
    Input: nums = [1,2,3,4]
    Output: 4
    Explanation: The longest valid subsequence is [1, 2, 3, 4].

    Example 2:
    Input: nums = [1,2,1,1,2,1,2]
    Output: 6
    Explanation: The longest valid subsequence is [1, 2, 1, 2, 1, 2].

    Example 3:
    Input: nums = [1,3]
    Output: 2
    Explanation: The longest valid subsequence is [1, 3].

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * 1 <= nums[i] <= 10^7*/

    public int maximumLength(int[] nums) {
        int[][] dp = new int[2][2];
        for (var x : nums) {
            x %= 2;
            dp[x][0] = 1 + dp[0][x];
            dp[x][1] = 1 + dp[1][x];
        }
        return Math.max(Math.max(dp[0][0], dp[0][1]), Math.max(dp[1][0], dp[1][1]));
    }


    /*3202. Find the Maximum Length of Valid Subsequence II (Medium)
    You are given an integer array nums and a positive integer k. A subsequence
    sub of nums with length x is called valid if it satisfies:
    * (sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k.
    Return the length of the longest valid subsequence of nums.

    Example 1:
    Input: nums = [1,2,3,4,5], k = 2
    Output: 5
    Explanation: The longest valid subsequence is [1, 2, 3, 4, 5].

    Example 2:
    Input: nums = [1,4,2,3,1,4], k = 3
    Output: 4
    Explanation: The longest valid subsequence is [1, 4, 1, 4].

    Constraints:
    * 2 <= nums.length <= 10^3
    * 1 <= nums[i] <= 10^7
    * 1 <= k <= 10^3*/

    public int maximumLength(int[] nums, int k) {
        int[][] dp = new int[k][k];
        for (var x : nums) {
            x %= k;
            for (int y = 0; y < k; ++y)
                dp[x][y] = 1 + dp[y][x];
        }
        return Arrays.stream(dp).flatMapToInt(Arrays::stream).max().getAsInt();
    }


    /*3203. Find Minimum Diameter After Merging Two Trees (Hard)
    There exist two undirected trees with n and m nodes, numbered from 0 to
    n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays
    edges1 and edges2 of lengths n - 1 and m - 1, respectively, where
    edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the first tree and edges2[i] = [ui, vi] indicates that there is an edge
    between nodes ui and vi in the second tree. You must connect one node from
    the first tree with another node from the second tree with an edge. Return
    the minimum possible diameter of the resulting tree. The diameter of a tree
    is the length of the longest path between any two nodes in the tree.

    Example 1:
    Input: edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]
    Output: 3
    Explanation: We can obtain a tree of diameter 3 by connecting node 0 from
                 the first tree with any node from the second tree.

    Example 2:
    Input: edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]
    Output: 5
    Explanation: We can obtain a tree of diameter 5 by connecting node 0 from
                 the first tree with node 0 from the second tree.

    Constraints:
    * 1 <= n, m <= 10^5
    * edges1.length == n - 1
    * edges2.length == m - 1
    * edges1[i].length == edges2[i].length == 2
    * edges1[i] = [ai, bi]
    * 0 <= ai, bi < n
    * edges2[i] = [ui, vi]
    * 0 <= ui, vi < m
    * The input is generated such that edges1 and edges2 represent valid trees.*/

    private int[] bfs(int u, List<Integer>[] graph) {
        int ans = 0;
        Queue<int[]> q = new LinkedList();
        q.add(new int[]{u, -1});
        while (!q.isEmpty()) {
            ++ans;
            for (int sz = q.size(); sz > 0; --sz) {
                var elem = q.poll();
                u = elem[0];
                int p = elem[1];
                for (var v : graph[u])
                    if (v != p)
                        q.add(new int[]{v, u});
            }
        }
        return new int[]{ans-1, u};
    }

    private int fn(int[][] edges) {
        int n = 1 + edges.length;
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; ++i)
            graph[i] = new ArrayList();
        for (var e : edges) {
            int u = e[0], v = e[1];
            graph[u].add(v);
            graph[v].add(u);
        }
        int[] u = bfs(0, graph);
        int[] d = bfs(u[1], graph);
        return d[0];
    }
    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {
        int d1 = fn(edges1), d2 = fn(edges2);
        return Math.max(d1, Math.max(d2, (d1+1)/2 + (d2+1)/2 + 1));
    }


    /*3206. Alternating Groups I (Easy)
    There is a circle of red and blue tiles. You are given an array of integers
    colors. The color of tile i is represented by colors[i]:
    * colors[i] == 0 means that tile i is red.
    * colors[i] == 1 means that tile i is blue.
    Every 3 contiguous tiles in the circle with alternating colors (the middle
    tile has a different color from its left and right tiles) is called an
    alternating group. Return the number of alternating groups. Note that since
    colors represents a circle, the first and the last tiles are considered to
    be next to each other.

    Example 1:
    Input: colors = [1,1,1]
    Output: 0
    Explanation:

    Example 2:
    Input: colors = [0,1,0,0,1]
    Output: 3
    Explanation:
    Alternating groups:

    Constraints:
    * 3 <= colors.length <= 100
    * 0 <= colors[i] <= 1*/

    public int numberOfAlternatingGroups(int[] colors) {
        int ans = 0;
        for (int i = 0, cnt = 0, n = colors.length; i < n+2; ++i) {
            if (i > 0 && colors[(i-1)%n] == colors[i%n]) cnt = 0;
            if (++cnt >= 3) ++ans;
        }
        return ans;
    }


    /*3207. Maximum Points After Enemy Battles (Medium)
    You are given an integer array enemyEnergies denoting the energy values of
    various enemies. You are also given an integer currentEnergy denoting the
    amount of energy you have initially. You start with 0 points, and all the
    enemies are unmarked initially. You can perform either of the following
    operations zero or multiple times to gain points:
    * Choose an unmarked enemy, i, such that currentEnergy >= enemyEnergies[i].
      By choosing this option:
      + You gain 1 point.
      + Your energy is reduced by the enemy's energy, i.e. currentEnergy =
        currentEnergy - enemyEnergies[i].
    * If you have at least 1 point, you can choose an unmarked enemy, i. By
      choosing this option:
      + Your energy increases by the enemy's energy, i.e. currentEnergy =
        currentEnergy + enemyEnergies[i].
      + The enemy i is marked.
    Return an integer denoting the maximum points you can get in the end by
    optimally performing operations.

    Example 1:
    Input: enemyEnergies = [3,2,2], currentEnergy = 2
    Output: 3
    Explanation: The following operations can be performed to get 3 points,
                 which is the maximum:
                 - First operation on enemy 1: points increases by 1, and
                   currentEnergy decreases by 2. So, points = 1, and
                   currentEnergy = 0.
                 - Second operation on enemy 0: currentEnergy increases by 3,
                   and enemy 0 is marked. So, points = 1, currentEnergy = 3, and
                   marked enemies = [0].
                 - First operation on enemy 2: points increases by 1, and
                   currentEnergy decreases by 2. So, points = 2,
                   currentEnergy = 1, and marked enemies = [0].
                 - Second operation on enemy 2: currentEnergy increases by 2,
                   and enemy 2 is marked. So, points = 2, currentEnergy = 3, and
                   marked enemies = [0, 2].
                 - First operation on enemy 1: points increases by 1, and
                   currentEnergy decreases by 2. So, points = 3,
                   currentEnergy = 1, and marked enemies = [0, 2].

    Example 2:
    Input: enemyEnergies = [2], currentEnergy = 10
    Output: 5
    Explanation: Performing the first operation 5 times on enemy 0 results in
                 the maximum number of points.

    Constraints:
    * 1 <= enemyEnergies.length <= 10^5
    * 1 <= enemyEnergies[i] <= 10^9
    * 0 <= currentEnergy <= 10^9*/

    public long maximumPoints(int[] enemyEnergies, int currentEnergy) {
        int m = IntStream.of(enemyEnergies).min().getAsInt();
        if (currentEnergy < m) return 0;
        return (currentEnergy + IntStream.of(enemyEnergies).mapToLong(x -> (long) x).sum() - m)/m;
    }


    /*3208. Alternating Groups II (Medium）
    There is a circle of red and blue tiles. You are given an array of integers
    colors and an integer k. The color of tile i is represented by colors[i]:
    * colors[i] == 0 means that tile i is red.
    * colors[i] == 1 means that tile i is blue.
    An alternating group is every k contiguous tiles in the circle with
    alternating colors (each tile in the group except the first and last one has
    a different color from its left and right tiles). Return the number of
    alternating groups. Note that since colors represents a circle, the first
    and the last tiles are considered to be next to each other.

    Example 1:
    Input: colors = [0,1,0,1,0], k = 3
    Output: 3
    Explanation:
    Alternating groups:

    Example 2:
    Input: colors = [0,1,0,0,1,0,1], k = 6
    Output: 2
    Explanation:
    Alternating groups:

    Example 3:
    Input: colors = [1,1,0,1], k = 4
    Output: 0
    Explanation:

    Constraints:
    * 3 <= colors.length <= 10^5
    * 0 <= colors[i] <= 1
    * 3 <= k <= colors.length*/

    public int numberOfAlternatingGroups(int[] colors, int k) {
        int ans = 0;
        for (int i = 0, cnt = 0, n = colors.length; i < n+k-1; ++i) {
            if (i > 0 && colors[(i-1)%n] == colors[i%n]) cnt = 0;
            if (++cnt >= k) ++ans;
        }
        return ans;
    }


    /*3209. Number of Subarrays With AND Value of K (Hard)
    Given an array of integers nums and an integer k, return the number of
    subarrays of nums where the bitwise AND of the elements of the subarray
    equals k.

    Example 1:
    Input: nums = [1,1,1], k = 1
    Output: 6
    Explanation: All subarrays contain only 1's.

    Example 2:
    Input: nums = [1,1,2], k = 1
    Output: 3
    Explanation: Subarrays having an AND value of 1 are: [1,1,2], [1,1,2], [1,1,2].

    Example 3:
    Input: nums = [1,2,3], k = 2
    Output: 2
    Explanation: Subarrays having an AND value of 2 are: [1,2,3], [1,2,3].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i], k <= 10^9*/

    public long countSubarrays(int[] nums, int k) {
        long ans = 0;
        Map<Integer, Integer> freq = new HashMap();
        for (var x : nums) {
            Map<Integer, Integer> temp = new HashMap();
            if ((k & x) == k) {
                freq.merge(x, 1, Integer::sum);
                for (var elem : freq.entrySet()) {
                    int key = elem.getKey(), val = elem.getValue();
                    temp.merge(key & x, val, Integer::sum);
                }
                ans += temp.getOrDefault(k, 0);
            }
            freq = temp;
        }
        return ans;
    }


    /*3216. Lexicographically Smallest String After a Swap (Easy)
    Given a string s containing only digits, return the lexicographically
    smallest string that can be obtained after swapping adjacent digits in s
    with the same parity at most once. Digits have the same parity if both are
    odd or both are even. For example, 5 and 9, as well as 2 and 4, have the
    same parity, while 6 and 9 do not.

    Example 1:
    Input: s = "45320"
    Output: "43520"
    Explanation: s[1] == '5' and s[2] == '3' both have the same parity, and
                 swapping them results in the lexicographically smallest string.

    Example 2:
    Input: s = "001"
    Output: "001"
    Explanation: There is no need to perform a swap because s is already the
                 lexicographically smallest.

    Constraints:
    * 2 <= s.length <= 100
    * s consists only of digits.*/

    public String getSmallestString(String s) {
        char[] ch = s.toCharArray();
        for (int i = 0; i < s.length()-1; ++i) {
            int v = ch[i]-'0', n = ch[i+1]-'0';
            if ((v - n)%2 == 0 && v > n) {
                char tmp = ch[i];
                ch[i] = ch[i+1];
                ch[i+1] = tmp;
                break;
            }
        }
        return String.valueOf(ch);
    }


    /*3217. Delete Nodes From Linked List Present in Array (Medium)
    You are given an array of integers nums and the head of a linked list.
    Return the head of the modified linked list after removing all nodes from
    the linked list that have a value that exists in nums.

    Example 1:
    Input: nums = [1,2,3], head = [1,2,3,4,5]
    Output: [4,5]
    Explanation: Remove the nodes with values 1, 2, and 3.

    Example 2:
    Input: nums = [1], head = [1,2,1,2,1,2]
    Output: [2,2,2]
    Explanation: Remove the nodes with value 1.

    Example 3:
    Input: nums = [5], head = [1,2,3,4]
    Output: [1,2,3,4]
    Explanation: No node has value 5.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5
    * All elements in nums are unique.
    * The number of nodes in the given list is in the range [1, 10^5].
    * 1 <= Node.val <= 10^5
    * The input is generated such that there is at least one node in the linked
      list that has a value not present in nums.*/

    public ListNode modifiedList(int[] nums, ListNode head) {
        Set<Integer> seen = Arrays.stream(nums).boxed().collect(Collectors.toSet());
        ListNode dummy = new ListNode(0, head);
        for (var node = dummy; node.next != null; )
            if (seen.contains(node.next.val))
                node.next = node.next.next;
            else
                node = node.next;
        return dummy.next;
    }


    /*3218. Minimum Cost for Cutting Cake I (Medium)
    There is an m x n cake that needs to be cut into 1 x 1 pieces. You are given
    integers m, n, and two arrays:
    * horizontalCut of size m - 1, where horizontalCut[i] represents the cost to
      cut along the horizontal line i.
    * verticalCut of size n - 1, where verticalCut[j] represents the cost to cut
      along the vertical line j.
    In one operation, you can choose any piece of cake that is not yet a 1 x 1
    square and perform one of the following cuts:
    * Cut along a horizontal line i at a cost of horizontalCut[i].
    * Cut along a vertical line j at a cost of verticalCut[j].
    After the cut, the piece of cake is divided into two distinct pieces. The
    cost of a cut depends only on the initial cost of the line and does not
    change. Return the minimum total cost to cut the entire cake into 1 x 1
    pieces.

    Example 1:
    Input: m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]
    Output: 13
    Explanation: Perform a cut on the vertical line 0 with cost 5, current total
                 cost is 5.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 The total cost is 5 + 1 + 1 + 3 + 3 = 13.

    Example 2:
    Input: m = 2, n = 2, horizontalCut = [7], verticalCut = [4]
    Output: 15
    Explanation: Perform a cut on the horizontal line 0 with cost 7.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 The total cost is 7 + 4 + 4 = 15.

    Constraints:
    * 1 <= m, n <= 20
    * horizontalCut.length == m - 1
    * verticalCut.length == n - 1
    * 1 <= horizontalCut[i], verticalCut[i] <= 10^3*/

    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {
        int ans = 0;
        Arrays.sort(horizontalCut);
        Arrays.sort(verticalCut);
        int hh = IntStream.of(horizontalCut).sum();
        int vv = IntStream.of(verticalCut).sum();
        int h = horizontalCut.length-1, v = verticalCut.length-1;
        while (h >= 0 || v >= 0)
            if (h < 0 || v >= 0 && verticalCut[v] > horizontalCut[h]) {
                ans += verticalCut[v] + hh;
                vv -= verticalCut[v--];
            } else {
                ans += horizontalCut[h] + vv;
                hh -= horizontalCut[h--];
            }
        return ans;
    }


    /*3219. Minimum Cost for Cutting Cake II (Hard)
    There is an m x n cake that needs to be cut into 1 x 1 pieces. You are given
    integers m, n, and two arrays:
    * horizontalCut of size m - 1, where horizontalCut[i] represents the cost to
      cut along the horizontal line i.
    * verticalCut of size n - 1, where verticalCut[j] represents the cost to cut
      along the vertical line j.
    In one operation, you can choose any piece of cake that is not yet a 1 x 1
    square and perform one of the following cuts:
    * Cut along a horizontal line i at a cost of horizontalCut[i].
    * Cut along a vertical line j at a cost of verticalCut[j].
    After the cut, the piece of cake is divided into two distinct pieces. The
    cost of a cut depends only on the initial cost of the line and does not
    change. Return the minimum total cost to cut the entire cake into 1 x 1
    pieces.

    Example 1:
    Input: m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]
    Output: 13
    Explanation: Perform a cut on the vertical line 0 with cost 5, current total
                 cost is 5.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 0 on 3 x 1 subgrid with
                 cost 1.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 Perform a cut on the horizontal line 1 on 2 x 1 subgrid with
                 cost 3.
                 The total cost is 5 + 1 + 1 + 3 + 3 = 13.

    Example 2:
    Input: m = 2, n = 2, horizontalCut = [7], verticalCut = [4]
    Output: 15
    Explanation: Perform a cut on the horizontal line 0 with cost 7.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost
                 4.
                 The total cost is 7 + 4 + 4 = 15.

    Constraints:
    * 1 <= m, n <= 10^5
    * horizontalCut.length == m - 1
    * verticalCut.length == n - 1
    * 1 <= horizontalCut[i], verticalCut[i] <= 10^3*/

    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {
        long ans = 0;
        Arrays.sort(horizontalCut);
        Arrays.sort(verticalCut);
        long hh = IntStream.of(horizontalCut).mapToLong((x) -> (long) x).sum();
        long vv = IntStream.of(verticalCut).mapToLong((x) -> (long) x).sum();
        int h = horizontalCut.length-1, v = verticalCut.length-1;
        while (h >= 0 || v >= 0)
            if (h < 0 || v >= 0 && verticalCut[v] > horizontalCut[h]) {
                ans += verticalCut[v] + hh;
                vv -= verticalCut[v--];
            } else {
                ans += horizontalCut[h] + vv;
                hh -= horizontalCut[h--];
            }
        return ans;
    }


    /*3222. Find the Winning Player in Coin Game (Easy)
    You are given two positive integers x and y, denoting the number of coins
    with values 75 and 10 respectively. Alice and Bob are playing a game. Each
    turn, starting with Alice, the player must pick up coins with a total value
    115. If the player is unable to do so, they lose the game. Return the name
    of the player who wins the game if both players play optimally.

    Example 1:
    Input: x = 2, y = 7
    Output: "Alice"
    Explanation: The game ends in a single turn:
                 - Alice picks 1 coin with a value of 75 and 4 coins with a value
                   of 10.

    Example 2:
    Input: x = 4, y = 11
    Output: "Bob"
    Explanation: The game ends in 2 turns:
                 - Alice picks 1 coin with a value of 75 and 4 coins with a
                   value of 10.
                 - Bob picks 1 coin with a value of 75 and 4 coins with a value
                   of 10.

    Constraints: 1 <= x, y <= 100*/

    public String losingPlayer(int x, int y) {
        return Math.min(x, y/4) % 2 == 1 ? "Alice" : "Bob";
    }


    /*3223. Minimum Length of String After Operations (Medium)
    You are given a string s. You can perform the following process on s any
    number of times:
    * Choose an index i in the string such that there is at least one character
      to the left of index i that is equal to s[i], and at least one character
      to the right that is also equal to s[i].
    * Delete the closest character to the left of index i that is equal to s[i].
    * Delete the closest character to the right of index i that is equal to s[i].
    Return the minimum length of the final string s that you can achieve.

    Example 1:
    Input: s = "abaacbcbb"
    Output: 5
    Explanation: We do the following operations:
                 - Choose index 2, then remove the characters at indices 0 and
                   3. The resulting string is s = "bacbcbb".
                 - Choose index 3, then remove the characters at indices 0 and
                   5. The resulting string is s = "acbcb".

    Example 2:
    Input: s = "aa"
    Output: 2
    Explanation: We cannot perform any operations, so we return the length of
                 the original string.

    Constraints:
    * 1 <= s.length <= 2 * 10^5
    * s consists only of lowercase English letters.*/

    public int minimumLength(String s) {
        Map<Character, Integer> freq = new HashMap();
        for (var ch : s.toCharArray())
            freq.merge(ch, 1, Integer::sum);
        return freq.values().stream().reduce(0, (x, y) -> x + 2 - y%2);
    }


    /*3224. Minimum Array Changes to Make Differences Equal (Medium)
    You are given an integer array nums of size n where n is even, and an
    integer k. You can perform some changes on the array, where in one change
    you can replace any element in the array with any integer in the range from
    0 to k. You need to perform some changes (possibly none) such that the final
    array satisfies the following condition:
    * There exists an integer X such that abs(a[i] - a[n - i - 1]) = X for all
      (0 <= i < n).
    Return the minimum number of changes required to satisfy the above
    condition.

    Example 1:
    Input: nums = [1,0,1,2,4,3], k = 4
    Output: 2
    Explanation: We can perform the following changes:
                 - Replace nums[1] by 2. The resulting array is
                   nums = [1,2,1,2,4,3].
                 - Replace nums[3] by 3. The resulting array is
                   nums = [1,2,1,3,4,3].
                 The integer X will be 2.

    Example 2:
    Input: nums = [0,1,2,3,3,6,5,4], k = 6
    Output: 2
    Explanation: We can perform the following operations:
                 - Replace nums[3] by 0. The resulting array is
                   nums = [0,1,2,0,3,6,5,4].
                 - Replace nums[4] by 4. The resulting array is
                   nums = [0,1,2,0,4,6,5,4].
                 The integer X will be 4.

    Constraints:
    * 2 <= n == nums.length <= 10^5
    * n is even.
    * 0 <= nums[i] <= k <= 10^5*/

    public int minChanges(int[] nums, int k) {
        int[] line = new int[k+2];
        int n = nums.length;
        for (int i = 0; i < n/2; ++i) {
            if (nums[i] > nums[n-1-i]) {
                int temp = nums[i]; nums[i] = nums[n-1-i]; nums[n-1-i] = temp;
            }
            int diff = nums[n-1-i] - nums[i];
            --line[diff];
            ++line[diff+1];
            diff += Math.max(nums[i], k - nums[n-1-i]);
            ++line[diff+1];
        }
        int ans = n/2;
        for (int x = 0, prefix = n/2; x <= k; ++x) {
            prefix += line[x];
            ans = Math.min(ans, prefix);
        }
        return ans;
    }


    /*3225. Maximum Score From Grid Operations (Hard)
    You are given a 2D matrix grid of size n x n. Initially, all cells of the
    grid are colored white. In one operation, you can select any cell of indices
    (i, j), and color black all the cells of the jth column starting from the
    top row down to the ith row. The grid score is the sum of all grid[i][j]
    such that cell (i, j) is white and it has a horizontally adjacent black
    cell. Return the maximum score that can be achieved after some number of
    operations.

    Example 1:
    Input: grid = [[0,0,0,0,0],[0,0,3,0,0],[0,1,0,0,0],[5,0,0,3,0],[0,0,0,0,2]]
    Output: 11
    Explanation: In the first operation, we color all cells in column 1 down to
                 row 3, and in the second operation, we color all cells in
                 column 4 down to the last row. The score of the resulting grid
                 is grid[3][0] + grid[1][2] + grid[3][3] which is equal to 11.

    Example 2:
    Input: grid = [[10,9,0,0,15],[7,1,0,8,0],[5,20,0,11,0],[0,0,0,1,2],[8,12,1,10,3]]
    Output: 94
    Explanation: We perform operations on 1, 2, and 3 down to rows 1, 4, and 0,
                 respectively. The score of the resulting grid is
                 grid[0][0] + grid[1][0] + grid[2][1] + grid[4][1] + grid[1][3]
                 + grid[2][3] + grid[3][3] + grid[4][3] + grid[0][4] which is
                 equal to 94.

    Constraints:
    * 1 <= n == grid.length <= 100
    * n == grid[i].length
    * 0 <= grid[i][j] <= 10^9*/

    public long maximumScore(int[][] grid) {
        int n = grid.length;
        long[][] prefix = new long[n+1][n], excl = new long[n+1][n], incl = new long[n+1][n];
        for (int j = 0; j < n; ++j) {
            for (int i = 0; i < n; ++i)
                prefix[i+1][j] = prefix[i][j] + grid[i][j];
            if (j > 0) {
                for (int p = 0; p <= n; ++p)
                    for (int c = 0; c <= n; ++c) {
                        long pv = 0, cv = 0;
                        if (c > p) pv = prefix[c][j-1] - prefix[p][j-1];
                        else cv = prefix[p][j] - prefix[c][j];
                        excl[c][j] = Math.max(excl[c][j], Math.max(pv + excl[p][j-1], incl[p][j-1]));
                        incl[c][j] = Math.max(incl[c][j], Math.max(cv + incl[p][j-1], cv + pv + excl[p][j-1]));
                    }
            }
        }
        long ans = 0;
        for (int i = 0; i <= n; ++i)
            ans = Math.max(ans, incl[i][n-1]);
        return ans;
    }


    /*3226. Number of Bit Changes to Make Two Integers Equal (Easy)
    You are given two positive integers n and k. You can choose any bit in the
    binary representation of n that is equal to 1 and change it to 0. Return the
    number of changes needed to make n equal to k. If it is impossible, return
    -1.

    Example 1:
    Input: n = 13, k = 4
    Output: 2
    Explanation: Initially, the binary representations of n and k are
                 n = (1101)2 and k = (0100)2. We can change the first and fourth
                 bits of n. The resulting integer is n = (0100)2 = k.

    Example 2:
    Input: n = 21, k = 21
    Output: 0
    Explanation: n and k are already equal, so no changes are needed.

    Example 3:
    Input: n = 14, k = 13
    Output: -1
    Explanation: It is not possible to make n equal to k.

    Constraints: 1 <= n, k <= 10^6*/

    public int minChanges(int n, int k) {
        return (n & k) == k ? Integer.bitCount(n ^ k) : -1;
    }


    /*3227. Vowels Game in a String (Medium)
    Alice and Bob are playing a game on a string. You are given a string s,
    Alice and Bob will take turns playing the following game where Alice starts
    first:
    * On Alice's turn, she has to remove any non-empty substring from s that
      contains an odd number of vowels.
    * On Bob's turn, he has to remove any non-empty substring from s that
      contains an even number of vowels.
    The first player who cannot make a move on their turn loses the game. We
    assume that both Alice and Bob play optimally. Return true if Alice wins the
    game, and false otherwise. The English vowels are: a, e, i, o, and u.

    Example 1:
    Input: s = "leetcoder"
    Output: true
    Explanation: Alice can win the game as follows:
                 * Alice plays first, she can delete the underlined substring in
                   s = "leetcoder" which contains 3 vowels. The resulting string
                   is s = "der".
                 * Bob plays second, he can delete the underlined substring in
                   s = "der" which contains 0 vowels. The resulting string is
                   s = "er".
                 * Alice plays third, she can delete the whole string s = "er"
                   which contains 1 vowel.
                 * Bob plays fourth, since the string is empty, there is no
                 valid play for Bob. So Alice wins the game.

    Example 2:
    Input: s = "bbcd"
    Output: false
    Explanation: There is no valid play for Alice in her first turn, so Alice
                 loses the game.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters.*/

    public boolean doesAliceWin(String s) {
        for (char ch : "aeiou".toCharArray())
            if (s.indexOf(ch) != -1)
                return true;
        return false;
    }


    /*3228. Maximum Number of Operations to Move Ones to the End (Medium)
    You are given a binary string s. You can perform the following operation on
    the string any number of times:
    * Choose any index i from the string where i + 1 < s.length such that
      s[i] == '1' and s[i + 1] == '0'.
    * Move the character s[i] to the right until it reaches the end of the
      string or another '1'. For example, for s = "010010", if we choose i = 1,
      the resulting string will be s = "000110".
    Return the maximum number of operations that you can perform.

    Example 1:
    Input: s = "1001101"
    Output: 4
    Explanation: We can perform the following operations:
                 Choose index i = 0. The resulting string is s = "0011101".
                 Choose index i = 4. The resulting string is s = "0011011".
                 Choose index i = 3. The resulting string is s = "0010111".
                 Choose index i = 2. The resulting string is s = "0001111".

    Example 2:
    Input: s = "00111"
    Output: 0

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'.*/

    public int maxOperations(String s) {
        int ans = 0, cnt = 0;
        for (int n = s.length(), i = n-1; i >= 0; --i)
            if (s.charAt(i) == '0') {
                if (i+1 == n || s.charAt(i+1) == '1') ++cnt;
            } else ans += cnt;
        return ans;
    }


    /*3229. Minimum Operations to Make Array Equal to Target (Hard)
    You are given two positive integer arrays nums and target, of the same
    length. In a single operation, you can select any subarray of nums and
    increment or decrement each element within that subarray by 1. Return the
    minimum number of operations required to make nums equal to the array
    target.

    Example 1:
    Input: nums = [3,5,1,2], target = [4,6,2,4]
    Output: 2
    Explanation: We will perform the following operations to make nums equal to
                 target:
                - Increment nums[0..3] by 1, nums = [4,6,2,3].
                 - Increment nums[3..3] by 1, nums = [4,6,2,4].

    Example 2:
    Input: nums = [1,3,2], target = [2,1,4]
    Output: 5
    Explanation: We will perform the following operations to make nums equal to
                 target:
                 - Increment nums[0..0] by 1, nums = [2,3,2].
                 - Decrement nums[1..1] by 1, nums = [2,2,2].
                 - Decrement nums[1..1] by 1, nums = [2,1,2].
                 - Increment nums[2..2] by 1, nums = [2,1,3].
                 - Increment nums[2..2] by 1, nums = [2,1,4].

    Constraints:
    * 1 <= nums.length == target.length <= 10^5
    * 1 <= nums[i], target[i] <= 10^8*/

    public long minimumOperations(int[] nums, int[] target) {
        long ans = 0;
        int prev = 0;
        for (int i = 0; i < nums.length; ++i) {
            int diff = target[i] - nums[i];
            ans += Math.max(0, diff - prev);
            prev = diff;
        }
        return ans + Math.max(0, -prev);
    }


    /*3232. Find if Digit Game Can Be Won (Easy)
    You are given an array of positive integers nums. Alice and Bob are playing
    a game. In the game, Alice can choose either all single-digit numbers or all
    double-digit numbers from nums, and the rest of the numbers are given to
    Bob. Alice wins if the sum of her numbers is strictly greater than the sum
    of Bob's numbers. Return true if Alice can win this game, otherwise, return
    false.

    Example 1:
    Input: nums = [1,2,3,4,10]
    Output: false
    Explanation: Alice cannot win by choosing either single-digit or double-
                 digit numbers.

    Example 2:
    Input: nums = [1,2,3,4,5,14]
    Output: true
    Explanation: Alice can win by choosing single-digit numbers which have a sum
                 equal to 15.

    Example 3:
    Input: nums = [5,5,5,25]
    Output: true
    Explanation: Alice can win by choosing double-digit numbers which have a sum
                 equal to 25.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 99*/

    public boolean canAliceWin(int[] nums) {
        int single = 0, total = 0;
        for (var x : nums) {
            if (x < 10) single += x;
            total += x;
        }
        return 2*single != total;
    }


    /*3233. Find the Count of Numbers Which Are Not Special (Medium)
    You are given 2 positive integers l and r. For any number x, all positive
    divisors of x except x are called the proper divisors of x. A number is
    called special if it has exactly 2 proper divisors. For example:
    * The number 4 is special because it has proper divisors 1 and 2.
    * The number 6 is not special because it has proper divisors 1, 2, and 3.
    Return the count of numbers in the range [l, r] that are not special.

    Example 1:
    Input: l = 5, r = 7
    Output: 3
    Explanation: There are no special numbers in the range [5, 7].

    Example 2:
    Input: l = 4, r = 16
    Output: 11
    Explanation: The special numbers in the range [4, 16] are 4 and 9.

    Constraints: 1 <= l <= r <= 10^9*/

    public int nonSpecialCount(int l, int r) {
        int lo = (int) Math.ceil(Math.sqrt(l)), hi = (int) Math.floor(Math.sqrt(r));
        int[] sieve = new int[hi+1];
        Arrays.fill(sieve, 1);
        sieve[0] = sieve[1] = 0;
        for (int x = 2; x <= hi; ++x)
            if (sieve[x] == 1)
                for (int xx = x*x; xx <= hi; xx += x)
                    sieve[xx] = 0;
        int[] sub = Arrays.copyOfRange(sieve, lo, hi+1);
        return r-l+1 - Arrays.stream(sub).reduce(0, (s, x) -> s+x);
    }


    /*3234. Count the Number of Substrings With Dominant Ones (Medium)
    You are given a binary string s. Return the number of substrings with
    dominant ones. A string has dominant ones if the number of ones in the
    string is greater than or equal to the square of the number of zeros in the
    string.

    Example 1:
    Input: s = "00011"
    Output: 5
    Explanation: The substrings with dominant ones are shown in the table below.
                 i   j   s[i..j] Number of Zeros Number of Ones
                 3   3   1   0   1
                 4   4   1   0   1
                 2   3   01  1   1
                 3   4   11  0   2
                 2   4   011 1   2

    Example 2:
    Input: s = "101101"
    Output: 16
    Explanation: The substrings with non-dominant ones are shown in the table
                 below. Since there are 21 substrings total and 5 of them have
                 non-dominant ones, it follows that there are 16 substrings with
                 dominant ones.
                 i   j   s[i..j] Number of Zeros Number of Ones
                 1   1   0   1   0
                 4   4   0   1   0
                 1   4   0110    2   2
                 0   4   10110   2   3
                 1   5   01101   2   3

    Constraints:
    * 1 <= s.length <= 4 * 10^4
    * s consists only of characters '0' and '1'.*/

    public int numberOfSubstrings(String s) {
        int ans = 0;
        for (int n = s.length(), z = 0; z*z < n; ++z) {
            int j = 0, zeroj = 0, k = 0, zerok = 0, onek = 0;
            for (int i = 0; i < n; ++i) {
                if (s.charAt(i) == '0') {
                    ++zeroj;
                    ++zerok;
                } else ++onek;
                for (; zeroj > z; ++j)
                    if (s.charAt(j) == '0') --zeroj;
                for (; zerok > z || k <= i && zerok == z && onek >= zerok*zerok; ++k)
                    if (s.charAt(k) == '0') --zerok;
                    else --onek;
                ans += k - j;
            }
        }
        return ans;
    }


    /*3235. Check if the Rectangle Corner Is Reachable (Hard)
    You are given two positive integers X and Y, and a 2D array circles, where
    circles[i] = [xi, yi, ri] denotes a circle with center at (xi, yi) and
    radius ri. There is a rectangle in the coordinate plane with its bottom left
    corner at the origin and top right corner at the coordinate (X, Y). You need
    to check whether there is a path from the bottom left corner to the top
    right corner such that the entire path lies inside the rectangle, does not
    touch or lie inside any circle, and touches the rectangle only at the two
    corners. Return true if such a path exists, and false otherwise.

    Example 1:
    Input: X = 3, Y = 4, circles = [[2,1,1]]
    Output: true
    Explanation: The black curve shows a possible path between (0, 0) and (3, 4).

    Example 2:
    Input: X = 3, Y = 3, circles = [[1,1,2]]
    Output: false
    Explanation: No path exists from (0, 0) to (3, 3).

    Example 3:
    Input: X = 3, Y = 3, circles = [[2,1,1],[1,2,1]]
    Output: false
    Explanation: No path exists from (0, 0) to (3, 3).

    Constraints:
    * 3 <= X, Y <= 10^9
    * 1 <= circles.length <= 1000
    * circles[i].length == 3
    * 1 <= xi, yi, ri <= 10^9*/

    private int find(int p, int[] parent) {
        if (p != parent[p])
            parent[p] = find(parent[p], parent);
        return parent[p];
    }

    public boolean canReachCorner(int X, int Y, int[][] circles) {
        List<int[]> vals = new ArrayList();
        for (var c : circles) {
            int x = c[0], y = c[1], r = c[2];
            if (Math.pow(x, 2) + Math.pow(y, 2) <= Math.pow(r, 2)) return false;
            if (Math.pow(X-x, 2) + Math.pow(Y-y, 2) <= Math.pow(r, 2)) return false;
            if (x >= X+r || y >= Y+r) continue;
            vals.add(new int[]{x, y, r});
        }
        circles = vals.stream().toArray(int[][]::new);
        int n = circles.length;
        int[] parent = IntStream.range(0, n).toArray();
        for (int i = 0; i < n; ++i)
            parent[i] = i;
        for (int i = 0; i < n; ++i) {
            int xi = circles[i][0], yi = circles[i][1], ri = circles[i][2];
            for (int j = i+1; j < n; ++j) {
                int xj = circles[j][0], yj = circles[j][1], rj = circles[j][2];
                if (Math.pow(xi-xj, 2) + Math.pow(yi-yj, 2) <= Math.pow(ri+rj, 2)) {
                    int ii = find(i, parent), jj = find(j, parent);
                    parent[ii] = jj;
                }
            }
        }
        Map<Integer, List<Integer>> group = new HashMap();
        for (int i = 0; i < n; ++i) {
            int ii = find(i, parent);
            if (!group.containsKey(ii))
                group.put(ii, new ArrayList());
            group.get(ii).add(i);
        }
        for (var grp : group.values()) {
            int xmax = Integer.MIN_VALUE, ymax = Integer.MIN_VALUE, xmin = Integer.MAX_VALUE, ymin = Integer.MAX_VALUE;
            boolean inside = false;
            for (var i : grp) {
                int x = circles[i][0], y = circles[i][1], r = circles[i][2];
                if (0 <= x && x <= X || 0 <= y && y <= Y) inside = true;
                xmax = Math.max(xmax, x+r);
                ymax = Math.max(ymax, y+r);
                xmin = Math.min(xmin, x-r);
                ymin = Math.min(ymin, y-r);
            }
            if (inside) {
                if (xmin <= 0 && xmax >= X) return false;
                if (ymin <= 0 && ymax >= Y) return false;
                if (xmax >= X && ymax >= Y) return false;
                if (xmin <= 0 && ymin <= 0) return false;
            }
        }
        return true;
    }


    /*3238. Find the Number of Winning Players (Easy)
    You are given an integer n representing the number of players in a game and
    a 2D array pick where pick[i] = [xi, yi] represents that the player xi
    picked a ball of color yi. Player i wins the game if they pick strictly more
    than i balls of the same color. In other words,
    * Player 0 wins if they pick any ball.
    * Player 1 wins if they pick at least two balls of the same color.
    * ...
    * Player i wins if they pick at leasti + 1 balls of the same color.
    Return the number of players who win the game. Note that multiple players
    can win the game.

    Example 1:
    Input: n = 4, pick = [[0,0],[1,0],[1,0],[2,1],[2,1],[2,0]]
    Output: 2
    Explanation: Player 0 and player 1 win the game, while players 2 and 3 do
    not win.

    Example 2:
    Input: n = 5, pick = [[1,1],[1,2],[1,3],[1,4]]
    Output: 0
    Explanation: No player wins the game.

    Example 3:
    Input: n = 5, pick = [[1,1],[2,4],[2,4],[2,4]]
    Output: 1
    Explanation: Player 2 wins the game by picking 3 balls with color 4.

    Constraints:
    * 2 <= n <= 10
    * 1 <= pick.length <= 100
    * pick[i].length == 2
    * 0 <= xi <= n - 1
    * 0 <= yi <= 10*/

    public int winningPlayerCount(int n, int[][] pick) {
        int[][] freq = new int[n][11];
        for (var p : pick) {
            int x = p[0], y = p[1];
            ++freq[x][y];
        }
        return (int) IntStream.range(0, n).filter(
            i -> IntStream.of(freq[i]).anyMatch(x -> x >= i+1)
        ).count();
    }


    /*3239. Minimum Number of Flips to Make Binary Grid Palindromic I (Medium)
    You are given an m x n binary matrix grid. A row or column is considered
    palindromic if its values read the same forward and backward. You can flip
    any number of cells in grid from 0 to 1, or from 1 to 0. Return the minimum
    number of cells that need to be flipped to make either all rows palindromic
    or all columns palindromic.

    Example 1:
    Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
    Output: 2
    Explanation: Flipping the highlighted cells makes all the rows palindromic.

    Example 2:
    Input: grid = [[0,1],[0,1],[0,0]]
    Output: 1
    Explanation: Flipping the highlighted cell makes all the columns palindromic.

    Example 3:
    Input: grid = [[1],[0]]
    Output: 0
    Explanation: All rows are already palindromic.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m * n <= 2 * 10^5
    * 0 <= grid[i][j] <= 1*/

    public int minFlips(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int row = 0, col = 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                row += grid[i][j] ^ grid[m-1-i][j];
                col += grid[i][j] ^ grid[i][n-1-j];
            }
        return Math.min(row, col)/2;
    }


    /*3240. Minimum Number of Flips to Make Binary Grid Palindromic II (Medium)
    You are given an m x n binary matrix grid. A row or column is considered
    palindromic if its values read the same forward and backward. You can flip
    any number of cells in grid from 0 to 1, or from 1 to 0. Return the minimum
    number of cells that need to be flipped to make all rows and columns
    palindromic, and the total number of 1's in grid divisible by 4.

    Example 1:
    Input: grid = [[1,0,0],[0,1,0],[0,0,1]]
    Output: 3
    Explanation:

    Example 2:
    Input: grid = [[0,1],[0,1],[0,0]]
    Output: 2
    Explanation:

    Example 3:
    Input: grid = [[1],[1]]
    Output: 2
    Explanation:

    * Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m * n <= 2 * 10^5
    * 0 <= grid[i][j] <= 1*/

    public int minFlips(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int ans = 0, ones = 0;
        if (n % 2 == 1)
            for (int i = 0; i < m/2; ++i) {
                int total = grid[i][n/2] + grid[m-1-i][n/2];
                if (total == 2) ++ones;
                else if (total == 1) ++ans;
            }
        if (m % 2 == 1)
            for (int j = 0; j < n/2; ++j) {
                int total = grid[m/2][j] + grid[m/2][n-1-j];
                if (total == 2) ++ones;
                else if (total == 1) ++ans;
            }
        if (ones % 2 == 1 && ans == 0) ans += 2;
        if (m % 2 == 1 && n % 2 == 1 && grid[m/2][n/2] == 1) ++ans;
        for (int i = 0; i < m/2; ++i)
            for (int j = 0; j < n/2; ++j) {
                int total = grid[i][j] + grid[i][n-1-j] + grid[m-1-i][j] + grid[m-1-i][n-1-j];
                ans += Math.min(total, 4-total);
            }
        return ans;
    }


    /*3241. Time Taken to Mark All Nodes (Hard)
    There exists an undirected tree with n nodes numbered 0 to n - 1. You are
    given a 2D integer array edges of length n - 1, where edges[i] = [ui, vi]
    indicates that there is an edge between nodes ui and vi in the tree.
    Initially, all nodes are unmarked. For each node i:
    * If i is odd, the node will get marked at time x if there is at least one
      node adjacent to it which was marked at time x - 1.
    * If i is even, the node will get marked at time x if there is at least one
      node adjacent to it which was marked at time x - 2.
    Return an array times where times[i] is the time when all nodes get marked
    in the tree, if you mark node i at time t = 0. Note that the answer for each
    times[i] is independent, i.e. when you mark node i all other nodes are
    unmarked.

    Example 1:
    Input: edges = [[0,1],[0,2]]
    Output: [2,4,3]
    Explanation: For i = 0: Node 1 is marked at t = 1, and Node 2 at t = 2.
                 For i = 1: Node 0 is marked at t = 2, and Node 2 at t = 4.
                 For i = 2: Node 0 is marked at t = 2, and Node 1 at t = 3.

    Example 2:
    Input: edges = [[0,1]]
    Output: [1,2]
    Explanation: For i = 0: Node 1 is marked at t = 1.
                 For i = 1: Node 0 is marked at t = 2.

    Example 3:
    Input: edges = [[2,4],[0,1],[2,3],[0,2]]
    Output: [4,6,3,5,5]
    Explanation:

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= edges[i][0], edges[i][1] <= n - 1
    * The input is generated such that edges represents a valid tree.*/

    private int dfs(int u, int p, List<Integer>[] tree, int[][][] vals) {
        for (var v : tree[u])
            if (v != p) {
                int cand = 2 - v%2 + dfs(v, u, tree, vals);
                if (cand > vals[u][0][1]) {
                    vals[u][1] = vals[u][0];
                    vals[u][0] = new int[]{v, cand};
                } else if (cand > vals[u][1][1])
                    vals[u][1] = new int[]{v, cand};
            }
        return vals[u][0][1];
    }

    public int[] timeTaken(int[][] edges) {
        int n = 1 + edges.length;
        List<Integer>[] tree = new List[n];
        for (int i = 0; i < n; ++i)
            tree[i] = new ArrayList();
        for (var e : edges) {
            int u = e[0], v = e[1];
            tree[u].add(v);
            tree[v].add(u);
        }
        int[][][] vals = new int[n][2][2];
        for (int i = 0; i < n; ++i) {
            vals[i][0] = new int[]{-1, 0};
            vals[i][1] = new int[]{-1, 0};
        }
        dfs(0, -1, tree, vals);
        int[] ans = new int[n];
        Stack<int[]> stk = new Stack(); stk.push(new int[]{0, -1, 0});
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            int u = elem[0], p = elem[1], x = elem[2];
            if (x > vals[u][0][1]) {
                vals[u][1] = vals[u][0];
                vals[u][0] = new int[]{p, x};
            } else if (x > vals[u][1][1])
                vals[u][1] = new int[]{p, x};
            ans[u] = vals[u][0][1];
            for (var v : tree[u])
                if (v != p) {
                    int xx = vals[u][0][1];
                    if (v == vals[u][0][0]) xx = vals[u][1][1];
                    stk.push(new int[]{v, u, xx + 2 - u%2});
                }
        }
        return ans;
    }


    /*3243. Shortest Distance After Road Addition Queries I (Medium)
    You are given an integer n and a 2D integer array queries. There are n
    cities numbered from 0 to n - 1. Initially, there is a unidirectional road
    from city i to city i + 1 for all 0 <= i < n - 1. queries[i] = [ui, vi]
    represents the addition of a new unidirectional road from city ui to city
    vi. After each query, you need to find the length of the shortest path from
    city 0 to city n - 1. Return an array answer where for each i in the range
    [0, queries.length - 1], answer[i] is the length of the shortest path from
    city 0 to city n - 1 after processing the first i + 1 queries.

    Example 1:
    Input: n = 5, queries = [[2,4],[0,2],[0,4]]
    Output: [3,2,1]
    Explanation: - After the addition of the road from 2 to 4, the length of the
                   shortest path from 0 to 4 is 3.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path from 0 to 4 is 2.
                 - After the addition of the road from 0 to 4, the length of the
                   shortest path from 0 to 4 is 1.

    Example 2:
    Input: n = 4, queries = [[0,3],[0,2]]
    Output: [1,1]
    Explanation: - After the addition of the road from 0 to 3, the length of the
                   shortest path from 0 to 3 is 1.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path remains 1.

    Constraints:
    * 3 <= n <= 500
    * 1 <= queries.length <= 500
    * queries[i].length == 2
    * 0 <= queries[i][0] < queries[i][1] < n
    * 1 < queries[i][1] - queries[i][0]
    * There are no repeated roads among the queries.*/

    private int bfs(List<Integer>[] graph) {
        Queue<Integer> q = new LinkedList(); q.add(0);
        int n = graph.length;
        boolean[] seen = new boolean[n]; seen[0] = true;
        for (int ans = 0; !q.isEmpty(); ++ans) {
            for (int sz = q.size(); sz > 0; --sz) {
                int u = q.poll();
                if (u == n-1) return ans;
                for (var v : graph[u])
                    if (!seen[v]) {
                        q.add(v);
                        seen[v] = true;
                    }
            }
        }
        return -1;
    }

    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {
        List<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; ++i) {
            graph[i] = new ArrayList();
            if (i+1 < n) graph[i].add(i+1);
        }
        List<Integer> ans = new ArrayList();
        for (var q : queries) {
            int u = q[0], v = q[1];
            graph[u].add(v);
            ans.add(bfs(graph));
        }
        return ans.stream().mapToInt(x -> x).toArray();
    }


    /*3244. Shortest Distance After Road Addition Queries II (Hard)
    You are given an integer n and a 2D integer array queries. There are n
    cities numbered from 0 to n - 1. Initially, there is a unidirectional road
    from city i to city i + 1 for all 0 <= i < n - 1. queries[i] = [ui, vi]
    represents the addition of a new unidirectional road from city ui to city
    vi. After each query, you need to find the length of the shortest path from
    city 0 to city n - 1. There are no two queries such that
    queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]. Return an
    array answer where for each i in the range [0, queries.length - 1],
    answer[i] is the length of the shortest path from city 0 to city n - 1 after
    processing the first i + 1 queries.

    Example 1:
    Input: n = 5, queries = [[2,4],[0,2],[0,4]]
    Output: [3,2,1]
    Explanation: - After the addition of the road from 2 to 4, the length of the
                   shortest path from 0 to 4 is 3.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path from 0 to 4 is 2.
                 - After the addition of the road from 0 to 4, the length of the
                   shortest path from 0 to 4 is 1.

    Example 2:
    Input: n = 4, queries = [[0,3],[0,2]]
    Output: [1,1]
    Explanation: - After the addition of the road from 0 to 3, the length of the
                   shortest path from 0 to 3 is 1.
                 - After the addition of the road from 0 to 2, the length of the
                   shortest path remains 1.

    Constraints:
    * 3 <= n <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= queries[i][0] < queries[i][1] < n
    * 1 < queries[i][1] - queries[i][0]
    * There are no repeated roads among the queries.
    * There are no two queries such that i != j and queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1].*/

    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {
        List<Integer> ans = new ArrayList();
        int[] jump = new int[--n];
        for (int i = 0; i < n; ++i)
            jump[i] = i+1;
        for (var q : queries) {
            int u = q[0], v = q[1];
            for (; jump[u] < v; --n) {
                int temp = jump[u];
                jump[u] = v;
                u = temp;
            }
            ans.add(n);
        }
        return ans.stream().mapToInt(x -> x).toArray();
    }


    /*3245. Alternating Groups III (Hard)
    There are some red and blue tiles arranged circularly. You are given an
    array of integers colors and a 2D integers array queries. The color of tile
    i is represented by colors[i]:
    * colors[i] == 0 means that tile i is red.
    * colors[i] == 1 means that tile i is blue.
    An alternating group is a contiguous subset of tiles in the circle with
    alternating colors (each tile in the group except the first and last one has
    a different color from its adjacent tiles in the group). You have to process
    queries of two types:
    * queries[i] = [1, sizei], determine the count of alternating groups with
      size sizei.
    * queries[i] = [2, indexi, colori], change colors[indexi] to colori.
    Return an array answer containing the results of the queries of the first
    type in order. Note that since colors represents a circle, the first and the
    last tiles are considered to be next to each other.

    Example 1:
    Input: colors = [0,1,1,0,1], queries = [[2,1,0],[1,4]]
    Output: [2]
    Explanation: First query:
                 Change colors[1] to 0.
                 Second query:
                 Count of the alternating groups with size 4:

    Example 2:
    Input: colors = [0,0,1,0,1,1], queries = [[1,3],[2,3,0],[1,5]]
    Output: [2,0]
    Explanation: First query:
                 Count of the alternating groups with size 3:
                 Second query: colors will not change.
                 Third query: There is no alternating group with size 5.

    Constraints:
    * 4 <= colors.length <= 5 * 10^4
    * 0 <= colors[i] <= 1
    * 1 <= queries.length <= 5 * 10^4
    * queries[i][0] == 1 or queries[i][0] == 2
    * For all i that:
    * queries[i][0] == 1: queries[i].length == 2, 3 <= queries[i][1] <= colors.length - 1
    * queries[i][0] == 2: queries[i].length == 3, 0 <= queries[i][1] <= colors.length - 1, 0 <= queries[i][2] <= 1

    class Fenwick {
        private int[] cnts, vals;

        Fenwick(int n) {
            cnts = new int[n+1];
            vals = new int[n+1];
        }

        void add(int k, int v) {
            for (int i = k+1; i < cnts.length; i += i & -i) {
                cnts[i] += v;
                vals[i] += v*k;
            }
        }

        int query(int k, int v) {
            int ans = 0;
            for (int i = k+1; i > 0; i -= i & -i)
                ans += vals[i] - v*cnts[i];
            return ans;
        }
    }*/

    private int dist(int lo, int hi, int n) {
        return lo <= hi ? hi-lo+1 : n+hi-lo+1;
    }

    private void add(int lo, int hi, int n, TreeMap<Integer, Integer> groups, Fenwick fen) {
        groups.put(hi, lo);
        fen.add(dist(lo, hi, n), 1);
    }

    private int[] remove(int i, int n, TreeMap<Integer, Integer> groups, Fenwick fen) {
        Integer hi = groups.ceilingKey(i);
        if (hi == null) hi = groups.firstKey();
        int lo = groups.get(hi);
        groups.remove(hi);
        fen.add(dist(lo, hi, n), -1);
        return new int[]{lo, hi};
    }

    public List<Integer> numberOfAlternatingGroups(int[] colors, int[][] queries) {
        int n = colors.length;
        TreeMap<Integer, Integer> groups = new TreeMap();
        for (int i = 0, j = 0; i < n; i = j+1) {
            for (j = i; j < i+n-1 && colors[j%n] != colors[(j+1)%n]; ++j);
            groups.put(j%n, i);
        }
        Fenwick fen = new Fenwick(n+1);
        for (var elem : groups.entrySet()) {
            int j = elem.getKey(), i = elem.getValue();
            add(i, j, n, groups, fen);
        }
        List<Integer> ans = new ArrayList();
        for (var q : queries) {
            if (q[0] == 1) {
                if (groups.size() == 1 && colors[groups.firstEntry().getKey()] != colors[groups.firstEntry().getValue()]) ans.add(n);
                else {
                    int sz = q[1];
                    ans.add(fen.query(n, sz-1) - fen.query(sz-1, sz-1));
                }
            } else {
                int i = q[1], c = q[2];
                if (colors[i] != c) {
                    colors[i] = c;
                    var elem = remove(i, n, groups, fen);
                    int lo = elem[0], hi = elem[1];
                    if (lo == hi) {
                        if (colors[(i-1+n)%n] != colors[i]) lo = remove((i-1+n)%n, n, groups, fen)[0];
                        if (colors[i] != colors[(i+1)%n] && !groups.isEmpty()) hi = remove((i+1)%n, n, groups, fen)[1];
                        add(lo, hi, n, groups, fen);
                    } else if (lo == i) {
                        add((i+1)%n, hi, n, groups, fen);
                        if (colors[(i-1+n)%n] != colors[i]) lo = remove((i-1+n)%n, n, groups, fen)[0];
                        add(lo, i, n, groups, fen);
                    } else if (i == hi) {
                        add(lo, (i-1+n)%n, n, groups, fen);
                        if (colors[i] != colors[(i+1)%n]) hi = remove((i+1)%n, n, groups, fen)[1];
                        add(i, hi, n, groups, fen);
                    } else {
                        int i0 = (i-1+n)%n, i1 = (i+1)%n;
                        if (dist(lo, hi, n) == n && colors[lo] != colors[hi]) add(i1, i0, n, groups, fen);
                        else {
                            add(lo, i0, n, groups, fen);
                            add(i1, hi, n, groups, fen);
                        }
                        add(i, i, n, groups, fen);
                    }
                }
            }
        }
        return ans;
    }


    /*3248. Snake in Matrix (Easy)
    There is a snake in an n x n matrix grid and can move in four possible
    directions. Each cell in the grid is identified by the position:
    grid[i][j] = (i * n) + j. The snake starts at cell 0 and follows a sequence
    of commands. You are given an integer n representing the size of the grid
    and an array of strings commands where each command[i] is either "UP",
    "RIGHT", "DOWN", and "LEFT". It's guaranteed that the snake will remain
    within the grid boundaries throughout its movement. Return the position of
    the final cell where the snake ends up after executing commands.

    Example 1:
    Input: n = 2, commands = ["RIGHT","DOWN"]
    Output: 3
    Explanation: 0   1
                 2   3
                 0   1
                 2   3
                 0   1
                 2   3

    Example 2:
    Input: n = 3, commands = ["DOWN","RIGHT","UP"]
    Output: 1
    Explanation: 0   1   2
                 3   4   5
                 6   7   8
                 0   1   2
                 3   4   5
                 6   7   8
                 0   1   2
                 3   4   5
                 6   7   8
                 0   1   2
                 3   4   5
                 6   7   8

    Constraints:
    * 2 <= n <= 10
    * 1 <= commands.length <= 100
    * commands consists only of "UP", "RIGHT", "DOWN", and "LEFT".
    * The input is generated such the snake will not move outside of the
      boundaries.*/

    public int finalPositionOfSnake(int n, List<String> commands) {
        int i = 0, j = 0;
        for (var c : commands)
            switch(c) {
                case "UP": --i; break;
                case "RIGHT": ++j; break;
                case "DOWN": ++i; break;
                default: --j;
            }
        return i*n + j;
    }


    /*3249. Count the Number of Good Nodes (Medium)
    There is an undirected tree with n nodes labeled from 0 to n - 1, and rooted
    at node 0. You are given a 2D integer array edges of length n - 1, where
    edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the tree. A node is good if all the subtrees rooted at its children have
    the same size. Return the number of good nodes in the given tree. A subtree
    of treeName is a tree consisting of a node in treeName and all of its
    descendants.

    Example 1:
    Input: edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
    Output: 7
    Explanation: All of the nodes of the given tree are good.

    Example 2:
    Input: edges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]]
    Output: 6
    Explanation: There are 6 good nodes in the given tree. They are colored in
                 the image above.

    Example 3:
    Input: edges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]]
    Output: 12
    Explanation: All nodes except node 9 are good.

    Constraints:
    * 2 <= n <= 10^5
    * edges.length == n - 1
    * edges[i].length == 2
    * 0 <= ai, bi < n
    * The input is generated such that edges represents a valid tree.*/

    public int ans = 0;

    private int dfs(int u, int p, List<Integer>[] tree) {
        Map<Integer, Integer> freq = new HashMap();
        for (var v : tree[u])
            if (v != p)
                freq.merge(dfs(v, u, tree), 1, Integer::sum);
        if (freq.size() <= 1) ++ans;
        return 1 + freq.keySet().stream().reduce(0, (s, k) -> s + k*freq.get(k));
    }

    public int countGoodNodes(int[][] edges) {
        int n = 1 + edges.length;
        List<Integer>[] tree = new List[n];
        for (int u = 0; u < n; ++u)
            tree[u] = new ArrayList();
        for (var e : edges) {
            int u = e[0], v = e[1];
            tree[u].add(v);
            tree[v].add(u);
        }
        dfs(0, -1, tree);
        return ans;
    }


    /*3250. Find the Count of Monotonic Pairs I (Hard)
    You are given an array of positive integers nums of length n. We call a pair
    of non-negative integer arrays (arr1, arr2) monotonic if:
    * The lengths of both arrays are n.
    * arr1 is monotonically non-decreasing, in other words,
      arr1[0] <= arr1[1] <= ... <= arr1[n - 1].
    * arr2 is monotonically non-increasing, in other words,
      arr2[0] >= arr2[1] >= ... >= arr2[n - 1].
    * arr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.
    Return the count of monotonic pairs. Since the answer may be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,3,2]
    Output: 4
    Explanation: The good pairs are:
                 ([0, 1, 1], [2, 2, 1])
                 ([0, 1, 2], [2, 2, 0])
                 ([0, 2, 2], [2, 1, 0])
                 ([1, 2, 2], [1, 1, 0])

    Example 2:
    Input: nums = [5,5,5,5]
    Output: 126

    Constraints:
    * 1 <= n == nums.length <= 2000
    * 1 <= nums[i] <= 50*/

    public int countOfPairs(int[] nums) {
        int n = nums.length;
        long[][] dp = new long[n+1][51];
        Arrays.fill(dp[n], 1);
        for (int i = n-1; i >= 0; --i) {
            int diff = 0;
            if (i > 0) diff = Math.max(0, nums[i] - nums[i-1]);
            for (int j = 50; j >= 0; --j) {
                if (j+1 <= 50) dp[i][j] = dp[i][j+1];
                if (j+diff <= nums[i])
                    dp[i][j] = (dp[i][j] + dp[i+1][j+diff]) % 1_000_000_007;
            }
        }
        return (int) dp[0][0];
    }


    /*3251. Find the Count of Monotonic Pairs II (Hard)
    You are given an array of positive integers nums of length n. We call a pair
    of non-negative integer arrays (arr1, arr2) monotonic if:
    * The lengths of both arrays are n.
    * arr1 is monotonically non-decreasing, in other words,
      arr1[0] <= arr1[1] <= ... <= arr1[n - 1].
    * arr2 is monotonically non-increasing, in other words,
      arr2[0] >= arr2[1] >= ... >= arr2[n - 1].
    * arr1[i] + arr2[i] == nums[i] for all 0 <= i <= n - 1.
    Return the count of monotonic pairs. Since the answer may be very large,
    return it modulo 10^9 + 7.

    Example 1:
    Input: nums = [2,3,2]
    Output: 4
    Explanation: The good pairs are:
                 ([0, 1, 1], [2, 2, 1])
                 ([0, 1, 2], [2, 2, 0])
                 ([0, 2, 2], [2, 1, 0])
                 ([1, 2, 2], [1, 1, 0])

    Example 2:
    Input: nums = [5,5,5,5]
    Output: 126

    Constraints:
    * 1 <= n == nums.length <= 2000
    * 1 <= nums[i] <= 1000*/

    public int countOfPairs(int[] nums) {
        int n = nums.length;
        long[][] dp = new long[n+1][1001];
        Arrays.fill(dp[n], 1);
        for (int i = n-1; i >= 0; --i) {
            int diff = 0;
            if (i > 0) diff = Math.max(0, nums[i] - nums[i-1]);
            for (int j = 1000; j >= 0; --j) {
                if (j+1 <= 1000) dp[i][j] = dp[i][j+1];
                if (j+diff <= nums[i])
                    dp[i][j] = (dp[i][j] + dp[i+1][j+diff]) % 1_000_000_007;
            }
        }
        return (int) dp[0][0];
    }


    /*3254. Find the Power of K-Size Subarrays I (Medium)
    You are given an array of integers nums of length n and a positive integer
    k. The power of an array is defined as:
    * Its maximum element if all of its elements are consecutive and sorted in
      ascending order.
    * -1 otherwise.
    You need to find the power of all subarrays of nums of size k. Return an
    integer array results of size n - k + 1, where results[i] is the power of
    nums[i..(i + k - 1)].

    Example 1:
    Input: nums = [1,2,3,4,3,2,5], k = 3
    Output: [3,4,-1,-1,-1]
    Explanation: There are 5 subarrays of nums of size 3:
                 - [1, 2, 3] with the maximum element 3.
                 - [2, 3, 4] with the maximum element 4.
                 - [3, 4, 3] whose elements are not consecutive.
                 - [4, 3, 2] whose elements are not sorted.
                 - [3, 2, 5] whose elements are not consecutive.

    Example 2:
    Input: nums = [2,2,2,2,2], k = 4
    Output: [-1,-1]

    Example 3:
    Input: nums = [3,2,3,2,3,2], k = 2
    Output: [-1,3,-1,3,-1]

    Constraints:
    * 1 <= n == nums.length <= 500
    * 1 <= nums[i] <= 10^5
    * 1 <= k <= n*/

    public int[] resultsArray(int[] nums, int k) {
        List<Integer> ans = new ArrayList();
        for (int i = 0, cnt = 0; i < nums.length; ++i) {
            if (i > 0 && nums[i-1]+1 != nums[i]) cnt = 0;
            ++cnt;
            if (i >= k-1)
                if (cnt >= k) ans.add(nums[i]);
                else ans.add(-1);
        }
        return ans.stream().mapToInt(i -> i).toArray();
    }


    /*3255. Find the Power of K-Size Subarrays II (Medium)
    You are given an array of integers nums of length n and a positive integer
    k. The power of an array is defined as:
    * Its maximum element if all of its elements are consecutive and sorted in
      ascending order.
    * -1 otherwise.
    You need to find the power of all subarrays of nums of size k. Return an
    integer array results of size n - k + 1, where results[i] is the power of
    nums[i..(i + k - 1)].

    Example 1:
    Input: nums = [1,2,3,4,3,2,5], k = 3
    Output: [3,4,-1,-1,-1]
    Explanation: There are 5 subarrays of nums of size 3:
                 - [1, 2, 3] with the maximum element 3.
                 - [2, 3, 4] with the maximum element 4.
                 - [3, 4, 3] whose elements are not consecutive.
                 - [4, 3, 2] whose elements are not sorted.
                 - [3, 2, 5] whose elements are not consecutive.

    Example 2:
    Input: nums = [2,2,2,2,2], k = 4
    Output: [-1,-1]

    Example 3:
    Input: nums = [3,2,3,2,3,2], k = 2
    Output: [-1,3,-1,3,-1]

    Constraints:
    * 1 <= n == nums.length <= 10^5
    * 1 <= nums[i] <= 10^6
    * 1 <= k <= n*/

    public int[] resultsArray(int[] nums, int k) {
        List<Integer> ans = new ArrayList();
        for (int i = 0, cnt = 0; i < nums.length; ++i) {
            if (i > 0 && nums[i-1]+1 != nums[i]) cnt = 0;
            ++cnt;
            if (i >= k-1)
                if (cnt >= k) ans.add(nums[i]);
                else ans.add(-1);
        }
        return ans.stream().mapToInt(i -> i).toArray();
    }


    /*3256. Maximum Value Sum by Placing Three Rooks I (Hard)
    You are given a m x n 2D array board representing a chessboard, where
    board[i][j] represents the value of the cell (i, j). Rooks in the same row
    or column attack each other. You need to place three rooks on the chessboard
    such that the rooks do not attack each other. Return the maximum sum of the
    cell values on which the rooks are placed.

    Example 1:
    Input: board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]
    Output: 4
    Explanation: We can place the rooks in the cells (0, 2), (1, 3), and (2, 1)
                 for a sum of 1 + 1 + 2 = 4.

    Example 2:
    Input: board = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 15
    Explanation: We can place the rooks in the cells (0, 0), (1, 1), and (2, 2)
                 for a sum of 1 + 5 + 9 = 15.

    Example 3:
    Input: board = [[1,1,1],[1,1,1],[1,1,1]]
    Output: 3
    Explanation: We can place the rooks in the cells (0, 2), (1, 1), and (2, 0)
                 for a sum of 1 + 1 + 1 = 3.

    Constraints:
    * 3 <= m == board.length <= 100
    * 3 <= n == board[i].length <= 100
    * -10^9 <= board[i][j] <= 10^9*/

    public long maximumValueSum(int[][] board) {
        int m = board.length, n = board[0].length;
        List<int[]>[] cols = new List[n];
        for (int i = 0; i < n; ++i)
            cols[i] = new ArrayList<>();
        for (int i = 0; i < m; ++i) {
            int[][] aug = new int[n][2];
            for (int j = 0; j < n; ++j) {
                aug[j][0] = board[i][j];
                aug[j][1] = j;
            }
            Arrays.sort(aug, (x, y) -> Integer.compare(y[0], x[0]));
            for (int k = 0; k < 3; ++k) {
                int x = aug[k][0], j = aug[k][1];
                cols[j].add(new int[]{x, i});
            }
        }
        List<int[]> vals = new ArrayList<>();
        for (int j = 0; j < n; ++j) {
            Collections.sort(cols[j], (x, y) -> Integer.compare(y[0], x[0]));
            for (int k = 0; k < 3 && k < cols[j].size(); ++k) {
                int x = cols[j].get(k)[0], i = cols[j].get(k)[1];
                vals.add(new int[]{x, i, j});
            }
        }
        Collections.sort(vals, (x, y) -> Integer.compare(y[0], x[0]));
        long ans = Long.MIN_VALUE;
        for (int i = 0; i < 9; ++i) {
            int xi = vals.get(i)[0], ii = vals.get(i)[1], ji = vals.get(i)[2];
            for (int j = i+1; j < 9; ++j) {
                int xj = vals.get(j)[0], ij = vals.get(j)[1], jj = vals.get(j)[2];
                if (ii != ij && ji != jj) {
                    for (int k = j+1; k < 9; ++k) {
                        int xk = vals.get(k)[0], ik = vals.get(k)[1], jk = vals.get(k)[2];
                        if (ii != ik && ij != ik && ji != jk && jj != jk)
                            ans = Math.max(ans, (long) xi + xj + xk);
                    }
                }
            }
        }
        return ans;
    }


    /*3257. Maximum Value Sum by Placing Three Rooks II (Hard)
    You are given a m x n 2D array board representing a chessboard, where
    board[i][j] represents the value of the cell (i, j). Rooks in the same row
    or column attack each other. You need to place three rooks on the chessboard
    such that the rooks do not attack each other. Return the maximum sum of the
    cell values on which the rooks are placed.

    Example 1:
    Input: board = [[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]
    Output: 4
    Explanation: We can place the rooks in the cells (0, 2), (1, 3), and (2, 1)
                 for a sum of 1 + 1 + 2 = 4.

    Example 2:
    Input: board = [[1,2,3],[4,5,6],[7,8,9]]
    Output: 15
    Explanation: We can place the rooks in the cells (0, 0), (1, 1), and (2, 2)
                 for a sum of 1 + 5 + 9 = 15.

    Example 3:
    Input: board = [[1,1,1],[1,1,1],[1,1,1]]
    Output: 3
    Explanation: We can place the rooks in the cells (0, 2), (1, 1), and (2, 0)
                 for a sum of 1 + 1 + 1 = 3.

    Constraints:
    * 3 <= m == board.length <= 500
    * 3 <= n == board[i].length <= 500
    * -10^9 <= board[i][j] <= 10^9*/

    public long maximumValueSum(int[][] board) {
        int m = board.length, n = board[0].length;
        List<int[]>[] cols = new List[n];
        for (int i = 0; i < n; ++i)
            cols[i] = new ArrayList<>();
        for (int i = 0; i < m; ++i) {
            int[][] aug = new int[n][2];
            for (int j = 0; j < n; ++j) {
                aug[j][0] = board[i][j];
                aug[j][1] = j;
            }
            Arrays.sort(aug, (x, y) -> Integer.compare(y[0], x[0]));
            for (int k = 0; k < 3; ++k) {
                int x = aug[k][0], j = aug[k][1];
                cols[j].add(new int[]{x, i});
            }
        }
        List<int[]> vals = new ArrayList<>();
        for (int j = 0; j < n; ++j) {
            Collections.sort(cols[j], (x, y) -> Integer.compare(y[0], x[0]));
            for (int k = 0; k < 3 && k < cols[j].size(); ++k) {
                int x = cols[j].get(k)[0], i = cols[j].get(k)[1];
                vals.add(new int[]{x, i, j});
            }
        }
        Collections.sort(vals, (x, y) -> Integer.compare(y[0], x[0]));
        long ans = Long.MIN_VALUE;
        for (int i = 0; i < 9; ++i) {
            int xi = vals.get(i)[0], ii = vals.get(i)[1], ji = vals.get(i)[2];
            for (int j = i+1; j < 9; ++j) {
                int xj = vals.get(j)[0], ij = vals.get(j)[1], jj = vals.get(j)[2];
                if (ii != ij && ji != jj) {
                    for (int k = j+1; k < 9; ++k) {
                        int xk = vals.get(k)[0], ik = vals.get(k)[1], jk = vals.get(k)[2];
                        if (ii != ik && ij != ik && ji != jk && jj != jk)
                            ans = Math.max(ans, (long) xi + xj + xk);
                    }
                }
            }
        }
        return ans;
    }


    /*3258. Count Substrings That Satisfy K-Constraint I (Easy)
    You are given a binary string s and an integer k. A binary string satisfies
    the k-constraint if either of the following conditions holds:
    * The number of 0's in the string is at most k.
    * The number of 1's in the string is at most k.
    Return an integer denoting the number of substrings of s that satisfy the k-
    constraint.

    Example 1:
    Input: s = "10101", k = 1
    Output: 12
    Explanation: Every substring of s except the substrings "1010", "10101", and
                 "0101" satisfies the k-constraint.

    Example 2:
    Input: s = "1010101", k = 2
    Output: 25
    Explanation: Every substring of s except the substrings with a length
                 greater than 5 satisfies the k-constraint.

    Example 3:
    Input: s = "11111", k = 1
    Output: 15
    Explanation: All substrings of s satisfy the k-constraint.

    Constraints:
    * 1 <= s.length <= 50
    * 1 <= k <= s.length
    * s[i] is either '0' or '1'.*/

    public int countKConstraintSubstrings(String s, int k) {
        int ans = 0;
        for (int i = 0, ii = 0, one = 0, zero = 0; i < s.length(); ++i) {
            if (s.charAt(i) == '1') ++one;
            else ++zero;
            for (; one > k && zero > k; ++ii)
                if (s.charAt(ii) == '1') --one;
                else --zero;
            ans += i-ii+1;
        }
        return ans;
    }


    /*3259. Maximum Energy Boost From Two Drinks (Medium)
    You are given two integer arrays energyDrinkA and energyDrinkB of the same
    length n by a futuristic sports scientist. These arrays represent the energy
    boosts per hour provided by two different energy drinks, A and B,
    respectively. You want to maximize your total energy boost by drinking one
    energy drink per hour. However, if you want to switch from consuming one
    energy drink to the other, you need to wait for one hour to cleanse your
    system (meaning you won't get any energy boost in that hour). Return the
    maximum total energy boost you can gain in the next n hours. Note that you
    can start consuming either of the two energy drinks.

    Example 1:
    Input: energyDrinkA = [1,3,1], energyDrinkB = [3,1,1]
    Output: 5
    Explanation: To gain an energy boost of 5, drink only the energy drink A (or
                 only B).

    Example 2:
    Input: energyDrinkA = [4,1,1], energyDrinkB = [1,1,3]
    Output: 7
    Explanation: To gain an energy boost of 7:
                 Drink the energy drink A for the first hour. Switch to the
                 energy drink B and we lose the energy boost of the second hour.
                 Gain the energy boost of the drink B in the third hour.

    Constraints:
    * n == energyDrinkA.length == energyDrinkB.length
    * 3 <= n <= 10^5
    * 1 <= energyDrinkA[i], energyDrinkB[i] <= 10^5*/

    public long maxEnergyBoost(int[] energyDrinkA, int[] energyDrinkB) {
        long[] dp = new long[2];
        for (int i = 0; i < energyDrinkA.length; ++i) {
            long temp = Math.max(dp[0] + energyDrinkA[i], dp[1]);
            dp[1] = Math.max(dp[0], dp[1] + energyDrinkB[i]);
            dp[0] = temp;
        }
        return Math.max(dp[0], dp[1]);
    }


    /*3260. Find the Largest Palindrome Divisible by K (Hard)
    You are given two positive integers n and k. An integer x is called k-
    palindromic if:
    * x is a palindrome.
    * x is divisible by k.
    Return the largest integer having n digits (as a string) that is k-
    palindromic. Note that the integer must not have leading zeros.

    Example 1:
    Input: n = 3, k = 5
    Output: "595"
    Explanation: 595 is the largest k-palindromic integer with 3 digits.

    Example 2:
    Input: n = 1, k = 4
    Output: "8"
    Explanation: 4 and 8 are the only k-palindromic integers with 1 digit.

    Example 3:
    Input: n = 5, k = 6
    Output: "89898"

    Constraints:
    * 1 <= n <= 10^5
    * 1 <= k <= 9*/

    public String largestPalindrome(int n, int k) {
        int[] pw = new int[n];
        pw[0] = 1;
        for (int i = 1; i < n; ++i)
            pw[i] = pw[i-1] * 10 % k;
        boolean[][] dp = new boolean[(n+1)/2][k];
        dp[(n-1)/2][0] = true;
        for (int i = (n-1)/2; i > 0; --i) {
            int coef = pw[i];
            if (i != n-1-i) coef += pw[n-1-i];
            for (int j = 0; j < k; ++j)
                if (dp[i][j])
                    for (int d = 0; d < 10; ++d) {
                        int jj = (j + coef*d) % k;
                        dp[i-1][jj] = true;
                    }
        }
        char[] ans = new char[n];
        Arrays.fill(ans, '9');
        int total = 0;
        for (int i = 0; i <= (n-1)/2; ++i) {
            int coef = pw[i];
            if (i != n-1-i) coef += pw[n-1-i];
            for (int d = 9; d >= 0; --d) {
                int j = ((total - coef*d) % k + k) % k;
                if (dp[i][j]) {
                    ans[i] = ans[n-1-i] = (char) ('0'+d);
                    total = j;
                    break;
                }
            }
        }
        return new String(ans);
    }


    /*3261. Count Substrings That Satisfy K-Constraint II (Hard)
    You are given a binary string s and an integer k. You are also given a 2D
    integer array queries, where queries[i] = [li, ri]. A binary string
    satisfies the k-constraint if either of the following conditions holds:
    * The number of 0's in the string is at most k.
    * The number of 1's in the string is at most k.
    Return an integer array answer, where answer[i] is the number of substrings
    of s[li..ri] that satisfy the k-constraint.

    Example 1:
    Input: s = "0001111", k = 2, queries = [[0,6]]
    Output: [26]
    Explanation: For the query [0, 6], all substrings of s[0..6] = "0001111"
                 satisfy the k-constraint except for the substrings
                 s[0..5] = "000111" and s[0..6] = "0001111".

    Example 2:
    Input: s = "010101", k = 1, queries = [[0,5],[1,4],[2,3]]
    Output: [15,9,3]
    Explanation: The substrings of s with a length greater than 3 do not satisfy
                 the k-constraint.

    Constraints:
    * 1 <= s.length <= 10^5
    * s[i] is either '0' or '1'.
    * 1 <= k <= s.length
    * 1 <= queries.length <= 10^5
    * queries[i] == [li, ri]
    * 0 <= li <= ri < s.length
    * All queries are distinct.*/

    public long[] countKConstraintSubstrings(String s, int k, int[][] queries) {
        int n = s.length();
        long[] prefix = new long[n+1];
        int[] jump = new int[n];
        for (int i = 0, ii = 0, one = 0; i < n; ++i) {
            if (s.charAt(i) == '1') ++one;
            for (; one > k && i-ii-one+1 > k; ++ii)
                if (s.charAt(ii) == '1') --one;
            prefix[i+1] = prefix[i] + (i-ii+1);
            jump[ii] = i;
        }
        if (jump[0] == 0) jump[0] = n;
        for (int i = 1; i < n; ++i)
            if (jump[i] == 0) jump[i] = jump[i-1];
        List<Long> ans = new ArrayList();
        for (var q : queries) {
            int lo = q[0], hi = q[1], mid = Math.min(jump[lo], hi);
            long c = mid-lo+1, cand = c*(c+1)/2;
            if (mid < hi) cand += prefix[hi+1] - prefix[mid+1];
            ans.add(cand);
        }
        return ans.stream().mapToLong(i->i).toArray();
    }


    /*3264. Final Array State After K Multiplication Operations I (Easy)
    You are given an integer array nums, an integer k, and an integer
    multiplier. You need to perform k operations on nums. In each operation:
    * Find the minimum value x in nums. If there are multiple occurrences of the
      minimum value, select the one that appears first.
    * Replace the selected minimum value x with x * multiplier.
    Return an integer array denoting the final state of nums after performing
    all k operations.

    Example 1:
    Input: nums = [2,1,3,5,6], k = 5, multiplier = 2
    Output: [8,4,6,5,6]
    Explanation: Operation           Result
                 After operation 1   [2, 2, 3, 5, 6]
                 After operation 2   [4, 2, 3, 5, 6]
                 After operation 3   [4, 4, 3, 5, 6]
                 After operation 4   [4, 4, 6, 5, 6]
                 After operation 5   [8, 4, 6, 5, 6]

    Example 2:
    Input: nums = [1,2], k = 3, multiplier = 4
    Output: [16,8]
    Explanation: Operation           Result
                 After operation 1   [4, 2]
                 After operation 2   [4, 8]
                 After operation 3   [16, 8]

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= k <= 10
    * 1 <= multiplier <= 5*/

    public int[] getFinalState(int[] nums, int k, int multiplier) {
        while (k-- > 0) {
            int m = Arrays.stream(nums).min().getAsInt();
            int i = IntStream.range(0, nums.length).filter(x -> nums[x] == m).findFirst().orElse(-1);
            nums[i] *= multiplier;
        }
        return nums;
    }


    /*3265. Count Almost Equal Pairs I (Medium)
    You are given an array nums consisting of positive integers. We call two
    integers x and y in this problem almost equal if both integers can become
    equal after performing the following operation at most once:
    * Choose either x or y and swap any two digits within the chosen number.
    Return the number of indices i and j in nums where i < j such that nums[i]
    and nums[j] are almost equal. Note that it is allowed for an integer to have
    leading zeros after performing an operation.

    Example 1:
    Input: nums = [3,12,30,17,21]
    Output: 2
    Explanation: The almost equal pairs of elements are:
                 - 3 and 30. By swapping 3 and 0 in 30, you get 3.
                 - 12 and 21. By swapping 1 and 2 in 12, you get 21.

    Example 2:
    Input: nums = [1,1,1,1,1]
    Output: 10
    Explanation: Every two elements in the array are almost equal.

    Example 3:
    Input: nums = [123,231]
    Output: 0
    Explanation: We cannot swap any two digits of 123 or 231 to reach the other.

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 10^6*/

    public int countPairs(int[] nums) {
        int ans = 0;
        Map<Integer, Integer> freq = new HashMap<>();
        for (var x : nums) {
            ans += freq.getOrDefault(x, 0);
            freq.merge(x, 1, Integer::sum);
            char[] ch = String.format("%06d", x).toCharArray();
            for (int i = 0; i < 6; ++i)
                for (int j = i+1; j < 6; ++j)
                    if (ch[i] != ch[j]) {
                        char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp;
                        int cand = Integer.parseInt(new String(ch));
                        ans += freq.getOrDefault(cand, 0);
                        temp = ch[i]; ch[i] = ch[j]; ch[j] = temp;
                    }
        }
        return ans;
    }


    /*3266. Final Array State After K Multiplication Operations II (Hard)
    You are given an integer array nums, an integer k, and an integer
    multiplier. You need to perform k operations on nums. In each operation:
    * Find the minimum value x in nums. If there are multiple occurrences of the
      minimum value, select the one that appears first.
    * Replace the selected minimum value x with x * multiplier.
    After the k operations, apply modulo 109 + 7 to every value in nums. Return
    an integer array denoting the final state of nums after performing all k
    operations and then applying the modulo.

    Example 1:
    Input: nums = [2,1,3,5,6], k = 5, multiplier = 2
    Output: [8,4,6,5,6]
    Explanation: Operation           Result
                 After operation 1   [2, 2, 3, 5, 6]
                 After operation 2   [4, 2, 3, 5, 6]
                 After operation 3   [4, 4, 3, 5, 6]
                 After operation 4   [4, 4, 6, 5, 6]
                 After operation 5   [8, 4, 6, 5, 6]
                 After applying modulo   [8, 4, 6, 5, 6]

    Example 2:
    Input: nums = [100000,2000], k = 2, multiplier = 1000000
    Output: [999999307,999999993]
    Explanation: Operation               Result
                 After operation 1       [100000, 2000000000]
                 After operation 2       [100000000000, 2000000000]
                 After applying modulo   [999999307, 999999993]

    Constraints:
    * 1 <= nums.length <= 10^4
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9
    * 1 <= multiplier <= 10^6*/

    public int[] getFinalState(int[] nums, int k, int multiplier) {
        if (multiplier == 1) return nums;
        int mod = 1_000_000_007;
        int m = Arrays.stream(nums).max().getAsInt(), n = nums.length;
        Queue<long[]> pq = new PriorityQueue<>((x, y) -> x[0] != y[0] ? Long.compare(x[0], y[0]) : Long.compare(x[1], y[1]));
        for (int i = 0; i < n; ++i)
            pq.add(new long[]{nums[i], i});
        for (; k > 0 && pq.peek()[0]*multiplier <= m; --k) {
            var elem = pq.poll();
            long x = elem[0], i = elem[1];
            pq.add(new long[]{x*multiplier, i});
        }
        List<long[]> vals = new ArrayList<>();
        while (!pq.isEmpty())
            vals.add(pq.poll());
        long q = 1, mul = multiplier;
        for (int p = k/n; p > 0; p >>= 1) {
            if (p % 2 == 1) q = q * mul % mod;
            mul = mul * mul % mod;
        }
        for (var v : vals)
            v[0] = v[0] * q % mod;
        for (int i = 0; i < k%n; ++i)
            vals.get(i)[0] = vals.get(i)[0] * multiplier % mod;
        int[] ans = new int[n];
        for (var v : vals)
            ans[(int) v[1]] = (int) v[0];
        return ans;
    }


    /*3267. Count Almost Equal Pairs II (Hard)
    Attention: In this version, the number of operations that can be performed,
    has been increased to twice. You are given an array nums consisting of
    positive integers. We call two integers x and y almost equal if both
    integers can become equal after performing the following operation at most
    twice:
    * Choose either x or y and swap any two digits within the chosen number.
    Return the number of indices i and j in nums where i < j such that nums[i]
    and nums[j] are almost equal. Note that it is allowed for an integer to have
    leading zeros after performing an operation.

    Example 1:
    Input: nums = [1023,2310,2130,213]
    Output: 4
    Explanation: The almost equal pairs of elements are:
                 - 1023 and 2310. By swapping the digits 1 and 2, and then the
                   digits 0 and 3 in 1023, you get 2310.
                 - 1023 and 213. By swapping the digits 1 and 0, and then the
                   digits 1 and 2 in 1023, you get 0213, which is 213.
                 - 2310 and 213. By swapping the digits 2 and 0, and then the
                   digits 3 and 2 in 2310, you get 0213, which is 213.
                 - 2310 and 2130. By swapping the digits 3 and 1 in 2310, you
                   get 2130.

    Example 2:
    Input: nums = [1,10,100]
    Output: 3
    Explanation: The almost equal pairs of elements are:
                 - 1 and 10. By swapping the digits 1 and 0 in 10, you get 01
                   which is 1.
                 - 1 and 100. By swapping the second 0 with the digit 1 in 100,
                   you get 001, which is 1.
                 - 10 and 100. By swapping the first 0 with the digit 1 in 100,
                   you get 010, which is 10.

    Constraints:
    * 2 <= nums.length <= 5000
    * 1 <= nums[i] < 10^7*/

    public int countPairs(int[] nums) {
        int ans = 0;
        Map<Integer, Integer> freq = new HashMap<>();
        for (var x : nums) freq.merge(x, 1, Integer::sum);
        for (var x : freq.keySet()) {
            ans += freq.get(x) * (freq.get(x)-1);
            char[] ch = String.format("%07d", x).toCharArray();
            Set<Integer> neighbor = new HashSet<>();
            for (int i = 0; i < 7; ++i)
                for (int j = 0; j < 7; ++j)
                    if (ch[i] != ch[j]) {
                        char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp;
                        neighbor.add(Integer.parseInt(String.valueOf(ch)));
                        for (int k = 0; k < 7; ++k)
                            for (int l = k+1; l < 7; ++l)
                                if (ch[k] != ch[l] && (k != i || l != j)) {
                                    temp = ch[k]; ch[k] = ch[l]; ch[l] = temp;
                                    neighbor.add(Integer.parseInt(String.valueOf(ch)));
                                    temp = ch[k]; ch[k] = ch[l]; ch[l] = temp;
                                }
                        temp = ch[i]; ch[i] = ch[j]; ch[j] = temp;
                    }
            for (var y : neighbor)
                if (x != (int) y && freq.containsKey(y))
                    ans += freq.get(x) * freq.get(y);
        }
        return ans/2;
    }


    /*3270. Find the Key of the Numbers (Easy)
    You are given three positive integers num1, num2, and num3. The key of num1,
    num2, and num3 is defined as a four-digit number such that:
    * Initially, if any number has less than four digits, it is padded with
      leading zeros.
    * The ith digit (1 <= i <= 4) of the key is generated by taking the smallest
      digit among the ith digits of num1, num2, and num3.
    Return the key of the three numbers without leading zeros (if any).

    Example 1:
    Input: num1 = 1, num2 = 10, num3 = 1000
    Output: 0
    Explanation: On padding, num1 becomes "0001", num2 becomes "0010", and num3
                 remains "1000".
                 - The 1st digit of the key is min(0, 0, 1).
                 - The 2nd digit of the key is min(0, 0, 0).
                 - The 3rd digit of the key is min(0, 1, 0).
                 - The 4th digit of the key is min(1, 0, 0).
                 Hence, the key is "0000", i.e. 0.

    Example 2:
    Input: num1 = 987, num2 = 879, num3 = 798
    Output: 777

    Example 3:
    Input: num1 = 1, num2 = 2, num3 = 3
    Output: 1

    Constraints: 1 <= num1, num2, num3 <= 9999*/

    public int generateKey(int num1, int num2, int num3) {
        String s1 = String.format("%04d", num1), s2 = String.format("%04d", num2), s3 = String.format("%04d", num3);
        int ans = 0;
        for (int j = 0; j < 4; ++j) {
            char d = (char) Math.min(s1.charAt(j), (char) Math.min(s2.charAt(j), s3.charAt(j)));
            ans = 10*ans + (int) (d - '0');
        }
        return ans;
    }


    /*3271. Hash Divided String (Medium)
    You are given a string s of length n and an integer k, where n is a multiple
    of k. Your task is to hash the string s into a new string called result,
    which has a length of n / k. First, divide s into n / k substrings, each
    with a length of k. Then, initialize result as an empty string. For each
    substring in order from the beginning:
    * The hash value of a character is the index of that character in the
      English alphabet (e.g., 'a' → 0, 'b' → 1, ..., 'z' → 25).
    * Calculate the sum of all the hash values of the characters in the
      substring.
    * Find the remainder of this sum when divided by 26, which is called
      hashedChar.
    * Identify the character in the English lowercase alphabet that corresponds
      to hashedChar.
    * Append that character to the end of result.
    Return result.

    Example 1:
    Input: s = "abcd", k = 2
    Output: "bf"
    Explanation: First substring: "ab", 0 + 1 = 1, 1 % 26 = 1, result[0] = 'b'.
                 Second substring: "cd", 2 + 3 = 5, 5 % 26 = 5, result[1] = 'f'.

    Example 2:
    Input: s = "mxz", k = 3
    Output: "i"
    Explanation: The only substring: "mxz", 12 + 23 + 25 = 60, 60 % 26 = 8,
                 result[0] = 'i'.

    Constraints:
    * 1 <= k <= 100
    * k <= s.length <= 1000
    * s.length is divisible by k.
    * s consists only of lowercase English letters.*/

    public String stringHash(String s, int k) {
        StringBuilder ans = new StringBuilder();
        for (int i = 0, prefix = 0; i < s.length(); ++i) {
            prefix += s.charAt(i) - 'a';
            if ((i+1)%k == 0) {
                ans.append((char) ('a' + prefix%26));
                prefix = 0;
            }
        }
        return ans.toString();
    }


    /*3272. Find the Count of Good Integers (Hard)
    You are given two positive integers n and k. An integer x is called k-
    palindromic if:
    * x is a palindrome.
    * x is divisible by k.
    An integer is called good if its digits can be rearranged to form a k-
    palindromic integer. For example, for k = 2, 2020 can be rearranged to form
    the k-palindromic integer 2002, whereas 1010 cannot be rearranged to form a
    k-palindromic integer. Return the count of good integers containing n digits.
    Note that any integer must not have leading zeros, neither before nor after
    rearrangement. For example, 1010 cannot be rearranged to form 101.

    Example 1:
    Input: n = 3, k = 5
    Output: 27
    Explanation: Some of the good integers are:
                 - 551 because it can be rearranged to form 515.
                 - 525 because it is already k-palindromic.

    Example 2:
    Input: n = 1, k = 4
    Output: 2
    Explanation: The two good integers are 4 and 8.

    Example 3:
    Input: n = 5, k = 6
    Output: 2468

    Constraints:
    * 1 <= n <= 10
    * 1 <= k <= 9*/

    private int multinom(int[] vals) {
        int ans = 1, k = 1;
        for (var v : vals)
            for (int x = 1; x <= v; ++x) {
                ans *= k++;
                ans /= x;
            }
        return ans;
    }

    public long countGoodIntegers(int n, int k) {
        long ans = 0;
        Set<Long> seen = new HashSet<>();
        for (int half = (n+1)/2, v = (int) Math.pow(10, half-1); v < (int) Math.pow(10, half); ++v) {
            long rev = 0, base = 1;
            for (int x = n%2 == 1 ? v/10 : v; x > 0; rev = 10*rev + x%10, x /= 10, base *= 10);
            long cand = v * base + rev;
            if (cand % k == 0) {
                int[] freq = new int[10];
                for (; cand > 0; cand /= 10) ++freq[(int) (cand % 10)];
                long key = IntStream.of(freq).reduce(0, (x, y) -> x = 11*x + y);
                if (!seen.contains(key)) {
                    seen.add(key);
                    int val = multinom(freq);
                    if (freq[0] > 0) {
                        --freq[0];
                        val -= multinom(freq);
                    }
                    ans += val;
                }
            }
        }
        return ans;
    }


    /*3273. Minimum Amount of Damage Dealt to Bob (Hard)
    You are given an integer power and two integer arrays damage and health,
    both having length n. Bob has n enemies, where enemy i will deal Bob
    damage[i] points of damage per second while they are alive (i.e.
    health[i] > 0). Every second, after the enemies deal damage to Bob, he
    chooses one of the enemies that is still alive and deals power points of
    damage to them. Determine the minimum total amount of damage points that
    will be dealt to Bob before all n enemies are dead.

    Example 1:
    Input: power = 4, damage = [1,2,3,4], health = [4,5,6,8]
    Output: 39
    Explanation: - Attack enemy 3 in the first two seconds, after which enemy 3
                   will go down, the number of damage points dealt to Bob is
                   10 + 10 = 20 points.
                 - Attack enemy 2 in the next two seconds, after which enemy 2
                   will go down, the number of damage points dealt to Bob is
                   6 + 6 = 12 points.
                 - Attack enemy 0 in the next second, after which enemy 0 will
                   go down, the number of damage points dealt to Bob is 3 points.
                 - Attack enemy 1 in the next two seconds, after which enemy 1
                   will go down, the number of damage points dealt to Bob is
                   2 + 2 = 4 points.

    Example 2:
    Input: power = 1, damage = [1,1,1,1], health = [1,2,3,4]
    Output: 20
    Explanation: - Attack enemy 0 in the first second, after which enemy 0 will
                   go down, the number of damage points dealt to Bob is 4 points.
                 - Attack enemy 1 in the next two seconds, after which enemy 1
                   will go down, the number of damage points dealt to Bob is
                   3 + 3 = 6 points.
                 - Attack enemy 2 in the next three seconds, after which enemy 2
                   will go down, the number of damage points dealt to Bob is
                   2 + 2 + 2 = 6 points.
                 - Attack enemy 3 in the next four seconds, after which enemy 3
                   will go down, the number of damage points dealt to Bob is
                   1 + 1 + 1 + 1 = 4 points.

    Example 3:
    Input: power = 8, damage = [40], health = [59]
    Output: 320

    Constraints:
    * 1 <= power <= 10^4
    * 1 <= n == damage.length == health.length <= 10^5
    * 1 <= damage[i], health[i] <= 10^4*/

    public long minDamage(int power, int[] damage, int[] health) {
        int n = damage.length;
        int[][] aug = new int[n][2];
        for (int i = 0; i < n; ++i)
            aug[i] = new int[]{damage[i], (health[i]+power-1)/power};
        Arrays.sort(aug, (x, y) -> Integer.compare(x[1]*y[0], x[0]*y[1]));
        long ans = 0, prefix = 0;
        for (var x : aug) {
            int d = x[0], h = x[1];
            prefix += h;
            ans += d*prefix;
        }
        return ans;
    }


    /*3274. Check if Two Chessboard Squares Have the Same Color (Easy)
    You are given two strings, coordinate1 and coordinate2, representing the
    coordinates of a square on an 8 x 8 chessboard. Below is the chessboard for
    reference. Return true if these two squares have the same color and false
    otherwise. The coordinate will always represent a valid chessboard square.
    The coordinate will always have the letter first (indicating its column),
    and the number second (indicating its row).

    Example 1:
    Input: coordinate1 = "a1", coordinate2 = "c3"
    Output: true
    Explanation: Both squares are black.

    Example 2:
    Input: coordinate1 = "a1", coordinate2 = "h3"
    Output: false
    Explanation: Square "a1" is black and "h3" is white.

    Constraints:
    * coordinate1.length == coordinate2.length == 2
    * 'a' <= coordinate1[0], coordinate2[0] <= 'h'
    * '1' <= coordinate1[1], coordinate2[1] <= '8'*/

    public boolean checkTwoChessboards(String coordinate1, String coordinate2) {
        return (coordinate1.charAt(0) + coordinate1.charAt(1)) % 2 == (coordinate2.charAt(0) + coordinate2.charAt(1)) % 2;
    }


    /*3275. K-th Nearest Obstacle Queries (Medium)
    There is an infinite 2D plane. You are given a positive integer k. You are
    also given a 2D array queries, which contains the following queries:
    * queries[i] = [x, y]: Build an obstacle at coordinate (x, y) in the plane.
      It is guaranteed that there is no obstacle at this coordinate when this
      query is made.
    After each query, you need to find the distance of the kth nearest obstacle
    from the origin. Return an integer array results where results[i] denotes
    the kth nearest obstacle after query i, or results[i] == -1 if there are
    less than k obstacles. Note that initially there are no obstacles anywhere.
    The distance of an obstacle at coordinate (x, y) from the origin is given by
    |x| + |y|.

    Example 1:
    Input: queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2
    Output: [-1,7,5,3]
    Explanation: Initially, there are 0 obstacles.
                 - After queries[0], there are less than 2 obstacles.
                 - After queries[1], there are obstacles at distances 3 and 7.
                 - After queries[2], there are obstacles at distances 3, 5, and
                   7.
                 - After queries[3], there are obstacles at distances 3, 3, 5,
                   and 7.

    Example 2:
    Input: queries = [[5,5],[4,4],[3,3]], k = 1
    Output: [10,8,6]
    Explanation: - After queries[0], there is an obstacle at distance 10.
                 - After queries[1], there are obstacles at distances 8 and 10.
                 - After queries[2], there are obstacles at distances 6, 8, and
                   10.

    Constraints:
    * 1 <= queries.length <= 2 * 10^5
    * All queries[i] are unique.
    * -10^9 <= queries[i][0], queries[i][1] <= 10^9
    * 1 <= k <= 10^5*/

    public int[] resultsArray(int[][] queries, int k) {
        int n = queries.length;
        int[] ans = new int[n];
        Queue<Integer> pq = new PriorityQueue<>((x, y) -> Integer.compare(y, x));
        for (int i = 0; i < n; ++i) {
            int x = queries[i][0], y = queries[i][1];
            pq.add(Math.abs(x) + Math.abs(y));
            if (pq.size() > k) pq.poll();
            ans[i] = pq.size() == k ? pq.peek() : -1;
        }
        return ans;
    }


    /*3276. Select Cells in Grid With Maximum Score (Hard)
    You are given a 2D matrix grid consisting of positive integers. You have to
    select one or more cells from the matrix such that the following conditions
    are satisfied:
    * No two selected cells are in the same row of the matrix.
    * The values in the set of selected cells are unique.
    Your score will be the sum of the values of the selected cells. Return the
    maximum score you can achieve.

    Example 1:
    Input: grid = [[1,2,3],[4,3,2],[1,1,1]]
    Output: 8
    Explanation: We can select the cells with values 1, 3, and 4 that are
                 colored above.

    Example 2:
    Input: grid = [[8,7,6],[8,3,2]]
    Output: 15
    Explanation: We can select the cells with values 7 and 8 that are colored
                 above.

    Constraints:
    * 1 <= grid.length, grid[i].length <= 10
    * 1 <= grid[i][j] <= 100*/

    public int maxScore(List<List<Integer>> grid) {
        int m = grid.size(), n = grid.get(0).size();
        int[][] vals = new int[m*n][2];
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j) {
                vals[i*n+j][0] = grid.get(i).get(j);
                vals[i*n+j][1] = i;
            }
        Arrays.sort(vals, (x, y) -> Integer.compare(x[0], y[0]));
        int[][] dp = new int[m*n+1][1<<m];
        for (int i = m*n-1; i >= 0; --i) {
            int v = vals[i][0], k = vals[i][1];
            for (int x = 0; x < (1<<m); ++x) {
                dp[i][x] = dp[i+1][x];
                if ((x & 1<<k) == 0) {
                    int ii = i+1;
                    while (ii < vals.length && vals[ii][0] == vals[i][0]) ++ii;
                    dp[i][x] = Math.max(dp[i][x], v + dp[ii][x ^ 1<<k]);
                }
            }
        }
        return dp[0][0];
    }


    /*3277. Maximum XOR Score Subarray Queries (Hard)
    You are given an array nums of n integers, and a 2D integer array queries of
    size q, where queries[i] = [li, ri]. For each query, you must find the
    maximum XOR score of any subarray of nums[li..ri]. The XOR score of an array
    a is found by repeatedly applying the following operations on a so that only
    one element remains, that is the score:
    * Simultaneously replace a[i] with a[i] XOR a[i + 1] for all indices i
      except the last one.
    * Remove the last element of a.
    Return an array answer of size q where answer[i] is the answer to query i.

    Example 1:
    Input: nums = [2,8,4,32,16,1], queries = [[0,2],[1,4],[0,5]]
    Output: [12,60,60]
    Explanation: - In the first query, nums[0..2] has 6 subarrays [2], [8], [4],
                   [2, 8], [8, 4], and [2, 8, 4] each with a respective XOR
                   score of 2, 8, 4, 10, 12, and 6. The answer for the query is
                   12, the largest of all XOR scores.
                 - In the second query, the subarray of nums[1..4] with the
                   largest XOR score is nums[1..4] with a score of 60.
                 - In the third query, the subarray of nums[0..5] with the
                   largest XOR score is nums[1..4] with a score of 60.

    Example 2:
    Input: nums = [0,7,3,2,8,5,1], queries = [[0,3],[1,5],[2,4],[2,6],[5,6]]
    Output: [7,14,11,14,5]
    Explanation: Index   nums[li..ri]    Maximum XOR Score Subarray  Maximum Subarray XOR Score
                     0   [0, 7, 3, 2]    [7]                         7
                     1   [7, 3, 2, 8, 5] [7, 3, 2, 8]                14
                     2   [3, 2, 8]       [3, 2, 8]                   11
                     3   [3, 2, 8, 5, 1] [2, 8, 5, 1]                14
                     4   [5, 1]          [5]                         5

    Constraints:
    * 1 <= n == nums.length <= 2000
    * 0 <= nums[i] <= 2^31 - 1
    * 1 <= q == queries.length <= 10^5
    * queries[i].length == 2
    * queries[i] = [li, ri]
    * 0 <= li <= ri <= n - 1*/

    public int[] maximumSubarrayXor(int[] nums, int[][] queries) {
        int n = nums.length;
        int[][] dp = new int[n+1][n];
        for (int l = n-1; l >= 0; --l) {
            dp[l][l] = nums[l];
            for (int r = l+1; r < n; ++r)
                dp[l][r] = dp[l][r-1] ^ dp[l+1][r];
        }
        for (int l = 0; l < n; ++l)
            for (int r = l+1; r < n; ++r)
                dp[l][r] = Math.max(dp[l][r], dp[l][r-1]);
        for (int r = 0; r < n; ++r)
            for (int l = r-1; l >= 0; --l)
                dp[l][r] = Math.max(dp[l][r], dp[l+1][r]);
        List<Integer> ans = new ArrayList<>();
        for (var q : queries) {
            int l = q[0], r = q[1];
            ans.add(dp[l][r]);
        }
        return ans.stream().mapToInt(i -> i).toArray();
    }


    /*3280. Convert Date to Binary (Easy)
    You are given a string date representing a Gregorian calendar date in the
    yyyy-mm-dd format. date can be written in its binary representation obtained
    by converting year, month, and day to their binary representations without
    any leading zeroes and writing them down in year-month-day format. Return
    the binary representation of date.

    Example 1:
    Input: date = "2080-02-29"
    Output: "100000100000-10-11101"
    Explanation: 100000100000, 10, and 11101 are the binary representations of
                 2080, 02, and 29 respectively.

    Example 2:
    Input: date = "1900-01-01"
    Output: "11101101100-1-1"
    Explanation: 11101101100, 1, and 1 are the binary representations of 1900,
                 1, and 1 respectively.

    Constraints:
    * date.length == 10
    * date[4] == date[7] == '-', and all other date[i]'s are digits.
    * The input is generated such that date represents a valid Gregorian
      calendar date between Jan 1st, 1900 and Dec 31st, 2100 (both inclusive).*/

    public String convertDateToBinary(String date) {
        String year = date.substring(0, 4), month = date.substring(5, 7), day = date.substring(8, 10);
        year = Integer.toBinaryString(Integer.parseInt(year));
        month = Integer.toBinaryString(Integer.parseInt(month));
        day = Integer.toBinaryString(Integer.parseInt(day));
        return year + "-" + month + "-" + day;
    }


    /*3281. Maximize Score of Numbers in Ranges (Medium)
    You are given an array of integers start and an integer d, representing n
    intervals [start[i], start[i] + d]. You are asked to choose n integers where
    the ith integer must belong to the ith interval. The score of the chosen
    integers is defined as the minimum absolute difference between any two
    integers that have been chosen. Return the maximum possible score of the
    chosen integers.

    Example 1:
    Input: start = [6,0,3], d = 2
    Output: 4
    Explanation: The maximum possible score can be obtained by choosing
                 integers: 8, 0, and 4. The score of these chosen integers is
                 min(|8 - 0|, |8 - 4|, |0 - 4|) which equals 4.

    Example 2:
    Input: start = [2,6,13,13], d = 5
    Output: 5
    Explanation: The maximum possible score can be obtained by choosing
                 integers: 2, 7, 13, and 18. The score of these chosen integers
                 is min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|)
                 which equals 5.

    Constraints:
    * 2 <= start.length <= 10^5
    * 0 <= start[i] <= 10^9
    * 0 <= d <= 10^9*/

    private boolean fn(int mid, int d, int[] start) {
        long x = Long.MIN_VALUE;
        for (var s : start) {
            x += mid;
            if (x > s+d) return false;
            x = Math.max(x, s);
        }
        return true;
    }

    public int maxPossibleScore(int[] start, int d) {
        Arrays.sort(start);
        int lo = 0, hi = 2_000_000_000;
        while (lo < hi) {
            int mid = lo + (hi-lo+1)/2;
            if (fn(mid, d, start)) lo = mid;
            else hi = mid-1;
        }
        return lo;
    }


    /*3282. Reach End of Array With Max Score (Medium)
    You are given an integer array nums of length n. Your goal is to start at
    index 0 and reach index n - 1. You can only jump to indices greater than
    your current index. The score for a jump from index i to index j is
    calculated as (j - i) * nums[i]. Return the maximum possible total score by
    the time you reach the last index.

    Example 1:
    Input: nums = [1,3,1,5]
    Output: 7
    Explanation: First, jump to index 1 and then jump to the last index. The
                 final score is 1 * 1 + 2 * 3 = 7.

    Example 2:
    Input: nums = [4,3,1,3,2]
    Output: 16
    Explanation: Jump directly to the last index. The final score is 4 * 4 = 16.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^5*/

    public long findMaximumScore(List<Integer> nums) {
        long dp = 0;
        int prefix = 0;
        for (var x : nums) {
            dp += prefix;
            prefix = Math.max(prefix, x);
        }
        return dp;
    }


    /*3283. Maximum Number of Moves to Kill All Pawns (Hard)
    There is a 50 x 50 chessboard with one knight and some pawns on it. You are
    given two integers kx and ky where (kx, ky) denotes the position of the
    knight, and a 2D array positions where positions[i] = [xi, yi] denotes the
    position of the pawns on the chessboard. Alice and Bob play a turn-based
    game, where Alice goes first. In each player's turn:
    * The player selects a pawn that still exists on the board and captures it
      with the knight in the fewest possible moves. Note that the player can
      select any pawn, it might not be one that can be captured in the least
      number of moves.
    * In the process of capturing the selected pawn, the knight may pass other
      pawns without capturing them. Only the selected pawn can be captured in
      this turn.
    Alice is trying to maximize the sum of the number of moves made by both
    players until there are no more pawns on the board, whereas Bob tries to
    minimize them. Return the maximum total number of moves made during the game
    that Alice can achieve, assuming both players play optimally. Note that in
    one move, a chess knight has eight possible positions it can move to, as
    illustrated below. Each move is two cells in a cardinal direction, then one
    cell in an orthogonal direction.

    Example 1:
    Input: kx = 1, ky = 1, positions = [[0,0]]
    Output: 4
    Explanation: The knight takes 4 moves to reach the pawn at (0, 0).

    Example 2:
    Input: kx = 0, ky = 2, positions = [[1,1],[2,2],[3,3]]
    Output: 8
    Explanation: - Alice picks the pawn at (2, 2) and captures it in two moves:
                   (0, 2) -> (1, 4) -> (2, 2).
                 - Bob picks the pawn at (3, 3) and captures it in two moves:
                   (2, 2) -> (4, 1) -> (3, 3).
                 - Alice picks the pawn at (1, 1) and captures it in four moves:
                   (3, 3) -> (4, 1) -> (2, 2) -> (0, 3) -> (1, 1).

    Example 3:
    Input: kx = 0, ky = 0, positions = [[1,2],[2,4]]
    Output: 3
    Explanation: - Alice picks the pawn at (2, 4) and captures it in two moves:
                   (0, 0) -> (1, 2) -> (2, 4). Note that the pawn at (1, 2) is
                   not captured.
                 - Bob picks the pawn at (1, 2) and captures it in one move:
                   (2, 4) -> (1, 2).

    Constraints:
    * 0 <= kx, ky <= 49
    * 1 <= positions.length <= 15
    * positions[i].length == 2
    * 0 <= positions[i][0], positions[i][1] <= 49
    * All positions[i] are unique.
    * The input is generated such that positions[i] != [kx, ky] for all
    0 <= i < positions.length.*/

    private int bfs(int i, int j, int[][] positions, int kx, int ky, int[][] dir) {
        Queue<int[]> q = new LinkedList<>(); q.add(positions[i]);
        boolean[][] seen = new boolean[50][50];
        seen[positions[i][0]][positions[i][1]] = true;
        int[] target = j < positions.length ? positions[j] : new int[]{kx, ky};
        for (int step = 0; !q.isEmpty(); ++step)
            for (int sz = q.size(); sz > 0; --sz) {
                var elem = q.poll();
                if (Arrays.equals(elem, target)) return step;
                int x = elem[0], y = elem[1];
                for (int k = 0; k < 8; ++k) {
                    int xx = x + dir[k][0], yy = y + dir[k][1];
                    if (0 <= xx && xx < 50 && 0 <= yy && yy < 50 && !seen[xx][yy]) {
                        q.add(new int[]{xx, yy});
                        seen[xx][yy] = true;
                    }
                }
            }
        return -1;
    }

    public int maxMoves(int kx, int ky, int[][] positions) {
        int n = positions.length;
        int[][] dist = new int[n+1][n+1];
        int[][] dir = new int[][]{{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};
        for (int i = 0; i < n; ++i)
            for (int j = i+1; j <= n; ++j)
                dist[i][j] = dist[j][i] = bfs(i, j, positions, kx, ky, dir);
        int[][][] dp = new int[1<<n][n+1][2];
        for (int m = (1<<n)-2; m >= 0; --m)
            for (int i = 0; i <= n; ++i)
                if ((m & 1<<i) > 0 || i == n) {
                    dp[m][i][0] = 0;
                    dp[m][i][1] = Integer.MAX_VALUE;
                    for (int j = 0; j < n; ++j)
                        if ((m & 1<<j) == 0) {
                            int mm = m ^ 1<<j;
                            dp[m][i][0] = Math.max(dp[m][i][0], dist[i][j] + dp[mm][j][1]);
                            dp[m][i][1] = Math.min(dp[m][i][1], dist[i][j] + dp[mm][j][0]);
                        }
                }
        return dp[0][n][0];
    }


    /*3285. Find Indices of Stable Mountains (Easy)
    There are n mountains in a row, and each mountain has a height. You are
    given an integer array height where height[i] represents the height of
    mountain i, and an integer threshold. A mountain is called stable if the
    mountain just before it (if it exists) has a height strictly greater than
    threshold. Note that mountain 0 is not stable. Return an array containing
    the indices of all stable mountains in any order.

    Example 1:
    Input: height = [1,2,3,4,5], threshold = 2
    Output: [3,4]
    Explanation: - Mountain 3 is stable because height[2] == 3 is greater than
                   threshold == 2.
                 - Mountain 4 is stable because height[3] == 4 is greater than
                   threshold == 2.

    Example 2:
    Input: height = [10,1,10,1,10], threshold = 3
    Output: [1,3]

    Example 3:
    Input: height = [10,1,10,1,10], threshold = 10
    Output: []

    Constraints:
    * 2 <= n == height.length <= 100
    * 1 <= height[i] <= 100
    * 1 <= threshold <= 100*/

    public List<Integer> stableMountains(int[] height, int threshold) {
        return IntStream.range(0, height.length)
            .filter(i -> i > 0 && height[i-1] > threshold)
            .boxed()
            .collect(Collectors.toList());
    }


    /*3286. Find a Safe Walk Through a Grid (Medium)
    You are given an m x n binary matrix grid and an integer health. You start
    on the upper-left corner (0, 0) and would like to get to the lower-right
    corner (m - 1, n - 1). You can move up, down, left, or right from one cell
    to another adjacent cell as long as your health remains positive. Cells
    (i, j) with grid[i][j] = 1 are considered unsafe and reduce your health by
    1. Return true if you can reach the final cell with a health value of 1 or
    more, and false otherwise.

    Example 1:
    Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1
    Output: true
    Explanation: The final cell can be reached safely by walking along the gray
                 cells below.

    Example 2:
    Input: grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3
    Output: false
    Explanation: A minimum of 4 health points is needed to reach the final cell
                 safely.

    Example 3:
    Input: grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5
    Output: true
    Explanation: The final cell can be reached safely by walking along the gray
                 cells below. Any path that does not go through the cell (1, 1)
                 is unsafe since your health will drop to 0 when reaching the
                 final cell.

    Constraints:
    * m == grid.length
    * n == grid[i].length
    * 1 <= m, n <= 50
    * 2 <= m * n
    * 1 <= health <= m + n
    * grid[i][j] is either 0 or 1.*/

    public boolean findSafeWalk(List<List<Integer>> grid, int health) {
        int m = grid.size(), n = grid.get(0).size();
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        int[][] dist = new int[m][n];
        dist[0][0] = health - grid.get(0).get(0);
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{0, 0, dist[0][0]});
        while (!q.isEmpty()) {
            var elem = q.poll();
            int i = elem[0], j = elem[1], h = elem[2];
            if (i == m-1 && j == n-1) return h > 0;
            for (int k = 0; k < 4; ++k) {
                int ii = i + dir[k], jj = j + dir[k+1];
                if (0 <= ii && ii < m && 0 <= jj && jj < n) {
                    int hh = h - grid.get(ii).get(jj);
                    if (dist[ii][jj] < hh) {
                        dist[ii][jj] = hh;
                        q.add(new int[]{ii, jj, hh});
                    }
                }
            }
        }
        return false;
    }


    /*3287. Find the Maximum Sequence Value of Array (Hard)
    You are given an integer array nums and a positive integer k. The value of a
    sequence seq of size 2 * x is defined as:
    * (seq[0] OR seq[1] OR ... OR seq[x - 1]) XOR
      (seq[x] OR seq[x + 1] OR ... OR seq[2 * x - 1]).
    Return the maximum value of any subsequence of nums having size 2 * k.

    Example 1:
    Input: nums = [2,6,7], k = 1
    Output: 5
    Explanation: The subsequence [2, 7] has the maximum value of 2 XOR 7 = 5.

    Example 2:
    Input: nums = [4,2,5,6,7], k = 2
    Output: 2
    Explanation: The subsequence [4, 5, 6, 7] has the maximum value of
                 (4 OR 5) XOR (6 OR 7) = 2.

    Constraints:
    * 2 <= nums.length <= 400
    * 1 <= nums[i] < 27
    * 1 <= k <= nums.length / 2*/

    public int maxValue(int[] nums, int k) {
        int n = nums.length;
        Set<Integer>[] vals = new Set[k+1], left = new Set[n];
        for (int i = 0; i <= k; ++i)
            vals[i] = new HashSet<>();
        vals[0].add(0);
        for (int i = 0; i < n; ++i) {
            left[i] = new HashSet<>();
            for (int j = k-1; j >= 0; --j)
                for (var x : vals[j])
                    vals[j+1].add(x | nums[i]);
            left[i] = new HashSet(vals[k]);
        }
        int ans = 0;
        vals = new Set[k+1];
        for (int i = 0; i <= k;++i)
            vals[i] = new HashSet<>();
        vals[0].add(0);
        for (int i = n-1; i > 0; --i) {
            for (int j = k-1; j >= 0; --j)
                for (var x : vals[j])
                    vals[j+1].add(x | nums[i]);
            for (var l : left[i-1])
                for (var r : vals[k])
                    ans = Math.max(ans, l ^ r);
        }
        return ans;
    }


    /*3288. Length of the Longest Increasing Path (Hard)
    You are given a 2D array of integers coordinates of length n and an integer
    k, where 0 <= k < n.
    coordinates[i] = [xi, yi] indicates the point (xi, yi) in a 2D plane.
    An increasing path of length m is defined as a list of points (x1, y1),
    (x2, y2), (x3, y3), ..., (xm, ym) such that:
    * xi < xi + 1 and yi < yi + 1 for all i where 1 <= i < m.
    * (xi, yi) is in the given coordinates for all i where 1 <= i <= m.
    Return the maximum length of an increasing path that contains coordinates[k].

    Example 1:
    Input: coordinates = [[3,1],[2,2],[4,1],[0,0],[5,3]], k = 1
    Output: 3
    Explanation: (0, 0), (2, 2), (5, 3) is the longest increasing path that
                 contains (2, 2).

    Example 2:
    Input: coordinates = [[2,1],[7,0],[5,6]], k = 2
    Output: 2
    Explanation: (2, 1), (5, 6) is the longest increasing path that contains
                 (5, 6).

    Constraints:
    * 1 <= n == coordinates.length <= 10^5
    * coordinates[i].length == 2
    * 0 <= coordinates[i][0], coordinates[i][1] <= 10^9
    * All elements in coordinates are distinct.
    * 0 <= k <= n - 1*/

    public int maxPathLength(int[][] coordinates, int k) {
        int xk = coordinates[k][0], yk = coordinates[k][1];
        Arrays.sort(coordinates, (x, y) -> x[0] != y[0] ? Integer.compare(x[0], y[0]) : Integer.compare(y[1], x[1]));
        List<Integer> lis = new ArrayList<>();
        for (var c : coordinates) {
            int x = c[0], y = c[1];
            if (x < xk && y < yk || x == xk && y == yk || x > xk && y > yk) {
                int i = Collections.binarySearch(lis, y);
                if (i < 0) i = -i-1;
                if (i == lis.size()) lis.add(y);
                else lis.set(i, y);
            }
        }
        return lis.size();
    }


    /*3289. The Two Sneaky Numbers of Digitville (Easy)
    In the town of Digitville, there was a list of numbers called nums
    containing integers from 0 to n - 1. Each number was supposed to appear
    exactly once in the list, however, two mischievous numbers sneaked in an
    additional time, making the list longer than usual. As the town detective,
    your task is to find these two sneaky numbers. Return an array of size two
    containing the two numbers (in any order), so peace can return to
    Digitville.

    Example 1:
    Input: nums = [0,1,1,0]
    Output: [0,1]
    Explanation: The numbers 0 and 1 each appear twice in the array.

    Example 2:
    Input: nums = [0,3,2,1,3,2]
    Output: [2,3]
    Explanation: The numbers 2 and 3 each appear twice in the array.

    Example 3:
    Input: nums = [7,1,5,4,3,4,6,0,9,5,8,2]
    Output: [4,5]
    Explanation: The numbers 4 and 5 each appear twice in the array.

    Constraints:
    * 2 <= n <= 100
    * nums.length == n + 2
    * 0 <= nums[i] < n
    * The input is generated such that nums contains exactly two repeated
      elements.*/

    public int[] getSneakyNumbers(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (var x : nums)
            freq.merge(x, 1, Integer::sum);
        List<Integer> ans = new ArrayList<>();
        for (var x : freq.keySet())
            if (freq.get(x) == 2) ans.add(x);
        return ans.stream().mapToInt(Integer::intValue).toArray();
    }


    /*3290. Maximum Multiplication Score (Medium)
    You are given an integer array a of size 4 and another integer array b of
    size at least 4. You need to choose 4 indices i0, i1, i2, and i3 from the
    array b such that i0 < i1 < i2 < i3. Your score will be equal to the value
    a[0] * b[i0] + a[1] * b[i1] + a[2] * b[i2] + a[3] * b[i3]. Return the
    maximum score you can achieve.

    Example 1:
    Input: a = [3,2,5,6], b = [2,-6,4,-5,-3,2,-7]
    Output: 26
    Explanation: We can choose the indices 0, 1, 2, and 5. The score will be
                 3 * 2 + 2 * (-6) + 5 * 4 + 6 * 2 = 26.

    Example 2:
    Input: a = [-1,4,5,-2], b = [-5,-1,-3,-2,-4]
    Output: -1
    Explanation: We can choose the indices 0, 1, 3, and 4. The score will be
                 (-1) * (-5) + 4 * (-1) + 5 * (-2) + (-2) * (-4) = -1.

    Constraints:
    * a.length == 4
    * 4 <= b.length <= 10^5
    * -10^5 <= a[i], b[i] <= 10^5*/

    public long maxScore(int[] a, int[] b) {
        int n = b.length;
        long[][] dp = new long[5][n+1];
        for (int i = 0; i < 4; ++i)
            dp[i][n] = -100_000_000_000l;
        for (int i = 3; i >= 0; --i)
            for (int j = n-1; j >= 0; --j)
                dp[i][j] = Math.max(dp[i][j+1], (long) a[i]*b[j] + dp[i+1][j+1]);
        return dp[0][0] > -100_000_000_000l ? dp[0][0] : -1;
    }


    /*3291. Minimum Number of Valid Strings to Form Target I (Medium)
    You are given an array of strings words and a string target. A string x is
    called valid if x is a prefix of any string in words. Return the minimum
    number of valid strings that can be concatenated to form target. If it is
    not possible to form target, return -1. A prefix of a string is a substring
    that starts from the beginning of the string and extends to any point within
    it.

    Example 1:
    Input: words = ["abc","aaaaa","bcdef"], target = "aabcdabc"
    Output: 3
    Explanation: The target string can be formed by concatenating:
                 - Prefix of length 2 of words[1], i.e. "aa".
                 - Prefix of length 3 of words[2], i.e. "bcd".
                 - Prefix of length 3 of words[0], i.e. "abc".

    Example 2:
    Input: words = ["abababab","ab"], target = "ababaababa"
    Output: 2
    Explanation: The target string can be formed by concatenating:
                 - Prefix of length 5 of words[0], i.e. "ababa".
                 - Prefix of length 5 of words[0], i.e. "ababa".

    Example 3:
    Input: words = ["abcdef"], target = "xyz"
    Output: -1

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 5 * 10^3
    * The input is generated such that sum(words[i].length) <= 10^5.
    * words[i] consists only of lowercase English letters.
    * 1 <= target.length <= 5 * 10^3
    * target consists only of lowercase English letters.

    class TrieNode {
        TrieNode[] child = new TrieNode[26];
        String word;
    }*/

    public int minValidStrings(String[] words, String target) {
        TrieNode trie = new TrieNode();
        for (var word : words) {
            TrieNode node = trie;
            for (var ch : word.toCharArray()) {
                if (node.child[ch-'a'] == null)
                    node.child[ch-'a'] = new TrieNode();
                node = node.child[ch-'a'];
            }
            node.word = word;
        }
        int n = target.length();
        int[] dp = new int[n+1];
        Arrays.fill(dp, -1);
        dp[n] = 0;
        for (int i = n-1; i >= 0; --i) {
            TrieNode node = trie;
            for (int j = i; j < n; ++j) {
                if (node.child[target.charAt(j)-'a'] != null) node = node.child[target.charAt(j)-'a'];
                else break;
                if (dp[j+1] >= 0)
                    if (dp[i] == -1) dp[i] = 1 + dp[j+1];
                    else dp[i] = Math.min(dp[i], 1 + dp[j+1]);
            }
        }
        return dp[0];
    }


    /*3292. Minimum Number of Valid Strings to Form Target II (Hard)
    You are given an array of strings words and a string target. A string x is
    called valid if x is a prefix of any string in words. Return the minimum
    number of valid strings that can be concatenated to form target. If it is
    not possible to form target, return -1. A prefix of a string is a substring
    that starts from the beginning of the string and extends to any point within
    it.

    Example 1:
    Input: words = ["abc","aaaaa","bcdef"], target = "aabcdabc"
    Output: 3
    Explanation: The target string can be formed by concatenating:
                 - Prefix of length 2 of words[1], i.e. "aa".
                 - Prefix of length 3 of words[2], i.e. "bcd".
                 - Prefix of length 3 of words[0], i.e. "abc".

    Example 2:
    Input: words = ["abababab","ab"], target = "ababaababa"
    Output: 2
    Explanation: The target string can be formed by concatenating:
                 - Prefix of length 5 of words[0], i.e. "ababa".
                 - Prefix of length 5 of words[0], i.e. "ababa".

    Example 3:
    Input: words = ["abcdef"], target = "xyz"
    Output: -1

    Constraints:
    * 1 <= words.length <= 100
    * 1 <= words[i].length <= 5 * 10^4
    * The input is generated such that sum(words[i].length) <= 10^5.
    * words[i] consists only of lowercase English letters.
    * 1 <= target.length <= 5 * 10^4
    * target consists only of lowercase English letters.

    class TrieNode {
        TrieNode[] child = new TrieNode[26];
        TrieNode parent;
        TrieNode suffix;
        int size = 0;
    }

    class AhoCorasick {
        public TrieNode root = new TrieNode();

        public void build(String[] patterns) {
            for (var pattern : patterns) {
                TrieNode node = root;
                int size = 0;
                for (var ch : pattern.toCharArray()) {
                    int i = ch - 'a';
                    if (node.child[i] == null) {
                        node.child[i] = new TrieNode();
                        node.child[i].parent = node;
                    }
                    node = node.child[i];
                    node.size = ++size;
                }
            }
            Queue<TrieNode> q = new LinkedList<>(); q.add(root);
            while (!q.isEmpty()) {
                for (int sz = q.size(); sz > 0; --sz) {
                    TrieNode node = q.poll();
                    for (int i = 0; i < 26; ++i)
                        if (node.child[i] != null) {
                            TrieNode child = node.child[i], suffix = node.suffix;
                            while (suffix != null && suffix.child[i] == null) suffix = suffix.suffix;
                            if (suffix != null) child.suffix = suffix.child[i];
                            else child.suffix = root;
                            q.add(child);
                        }
                }
            }
        }

        public List<Integer> match(String text) {
            List<Integer> ans = new ArrayList<>();
            TrieNode node = root;
            for (var ch : text.toCharArray()) {
                int i = ch - 'a';
                while (node.child[i] == null && node.suffix != null)
                    node = node.suffix;
                if (node.child[i] != null) node = node.child[i];
                ans.add(node.size);
            }
            return ans;
        }
    }*/

    public int minValidStrings(String[] words, String target) {
        int n = target.length();
        AhoCorasick trie = new AhoCorasick();
        trie.build(words);
        int[] dp = new int[n+1];
        Arrays.fill(dp, -1);
        dp[n] = 0;
        List<Integer> outcome = trie.match(target);
        for (int i = n-1; i >= 0; --i) {
            int x = outcome.get(i);
            if (x == 0) return -1;
            if (dp[i+1] != -1)
                if (dp[i+1-x] == -1) dp[i+1-x] = dp[i+1] + 1;
                else dp[i+1-x] = Math.min(dp[i+1-x], dp[i+1] + 1);
        }
        return dp[0];
    }


    /*3295. Report Spam Message (Medium)
    You are given an array of strings message and an array of strings
    bannedWords. An array of words is considered spam if there are at least two
    words in it that exactly match any word in bannedWords. Return true if the
    array message is spam, and false otherwise.

    Example 1:
    Input: message = ["hello","world","leetcode"], bannedWords = ["world","hello"]
    Output: true
    Explanation: The words "hello" and "world" from the message array both
                 appear in the bannedWords array.

    Example 2:
    Input: message = ["hello","programming","fun"], bannedWords = ["world","programming","leetcode"]
    Output: false
    Explanation: Only one word from the message array ("programming") appears in
                 the bannedWords array.

    Constraints:
    * 1 <= message.length, bannedWords.length <= 10^5
    * 1 <= message[i].length, bannedWords[i].length <= 15
    * message[i] and bannedWords[i] consist only of lowercase English letters.*/

    public boolean reportSpam(String[] message, String[] bannedWords) {
        Set<Integer> seen = new HashSet(Arrays.asList(bannedWords));
        return Arrays.stream(message).filter(m -> seen.contains(m)).count() >= 2;
    }


    /*3296. Minimum Number of Seconds to Make Mountain Height Zero (Medium)
    You are given an integer mountainHeight denoting the height of a mountain.
    You are also given an integer array workerTimes representing the work time
    of workers in seconds. The workers work simultaneously to reduce the height
    of the mountain. For worker i:
    * To decrease the mountain's height by x, it takes
      workerTimes[i] + workerTimes[i] * 2 + ... + workerTimes[i] * x seconds.
      For example:
      - To reduce the height of the mountain by 1, it takes workerTimes[i]
        seconds.
      - To reduce the height of the mountain by 2, it takes
        workerTimes[i] + workerTimes[i] * 2 seconds, and so on.
    Return an integer representing the minimum number of seconds required for
    the workers to make the height of the mountain 0.

    Example 1:
    Input: mountainHeight = 4, workerTimes = [2,1,1]
    Output: 3
    Explanation: One way the height of the mountain can be reduced to 0 is:
                 - Worker 0 reduces the height by 1, taking workerTimes[0] = 2
                   seconds.
                 - Worker 1 reduces the height by 2, taking
                   workerTimes[1] + workerTimes[1] * 2 = 3 seconds.
                 - Worker 2 reduces the height by 1, taking workerTimes[2] = 1
                   second.
                 - Since they work simultaneously, the minimum time needed is
                   max(2, 3, 1) = 3 seconds.

    Example 2:
    Input: mountainHeight = 10, workerTimes = [3,2,2,4]
    Output: 12
    Explanation: - Worker 0 reduces the height by 2, taking
                   workerTimes[0] + workerTimes[0] * 2 = 9 seconds.
                 - Worker 1 reduces the height by 3, taking
                   workerTimes[1] + workerTimes[1] * 2 + workerTimes[1] * 3 = 12
                   seconds.
                 - Worker 2 reduces the height by 3, taking
                   workerTimes[2] + workerTimes[2] * 2 + workerTimes[2] * 3 = 12
                   seconds.
                 - Worker 3 reduces the height by 2, taking
                   workerTimes[3] + workerTimes[3] * 2 = 12 seconds.
                 The number of seconds needed is max(9, 12, 12, 12) = 12 seconds.

    Example 3:
    Input: mountainHeight = 5, workerTimes = [1]
    Output: 15
    Explanation: There is only one worker in this example, so the answer is
                 workerTimes[0] + workerTimes[0] * 2 + workerTimes[0] * 3 +
                 workerTimes[0] * 4 + workerTimes[0] * 5 = 15.

    Constraints:
    * 1 <= mountainHeight <= 10^5
    * 1 <= workerTimes.length <= 10^4
    * 1 <= workerTimes[i] <= 10^6*/

    public long minNumberOfSeconds(int mountainHeight, int[] workerTimes) {
        long ans = 0;
        Queue<long[]> pq = new PriorityQueue<>((x, y) -> Long.compare(x[0], y[0]));
        for (var t : workerTimes)
            pq.add(new long[]{t, t, 1});
        while (mountainHeight-- > 0) {
            var elem = pq.poll();
            long v = elem[0], t = elem[1], i = elem[2];
            ans = Math.max(ans, v);
            pq.add(new long[]{v+t*(i+1), t, i+1});
        }
        return ans;
    }


    /*3297. Count Substrings That Can Be Rearranged to Contain a String I (Medium)
    You are given two strings word1 and word2. A string x is called valid if x
    can be rearranged to have word2 as a prefix. Return the total number of
    valid substrings of word1.

    Example 1:
    Input: word1 = "bcca", word2 = "abc"
    Output: 1
    Explanation: The only valid substring is "bcca" which can be rearranged to
                 "abcc" having "abc" as a prefix.

    Example 2:
    Input: word1 = "abcabc", word2 = "abc"
    Output: 10
    Explanation: All the substrings except substrings of size 1 and size 2 are
                 valid.

    Example 3:
    Input: word1 = "abcabc", word2 = "aaabc"
    Output: 0

    Constraints:
    * 1 <= word1.length <= 10^5
    * 1 <= word2.length <= 10^4
    * word1 and word2 consist only of lowercase English letters.*/

    public long validSubstringCount(String word1, String word2) {
        int[] freq = new int[26];
        for (var ch : word2.toCharArray()) ++freq[ch-'a'];
        long ans = 0;
        int ii = 0, cnt = word2.length();
        for (var ch : word1.toCharArray()) {
            if (freq[ch-'a'] > 0) --cnt;
            --freq[ch-'a'];
            for (; cnt == 0; ++ii) {
                if (freq[word1.charAt(ii)-'a'] == 0) ++cnt;
                ++freq[word1.charAt(ii)-'a'];
            }
            ans += ii;
        }
        return ans;
    }


    /*3298. Count Substrings That Can Be Rearranged to Contain a String II (Hard)
    You are given two strings word1 and word2. A string x is called valid if x
    can be rearranged to have word2 as a prefix. Return the total number of
    valid substrings of word1. Note that the memory limits in this problem are
    smaller than usual, so you must implement a solution with a linear runtime
    complexity.

    Example 1:
    Input: word1 = "bcca", word2 = "abc"
    Output: 1
    Explanation: The only valid substring is "bcca" which can be rearranged to
                 "abcc" having "abc" as a prefix.

    Example 2:
    Input: word1 = "abcabc", word2 = "abc"
    Output: 10
    Explanation: All the substrings except substrings of size 1 and size 2 are
                 valid.

    Example 3:
    Input: word1 = "abcabc", word2 = "aaabc"
    Output: 0

    Constraints:
    * 1 <= word1.length <= 10^6
    * 1 <= word2.length <= 10^4
    * word1 and word2 consist only of lowercase English letters.*/

    public long validSubstringCount(String word1, String word2) {
        int[] freq = new int[26];
        for (var ch : word2.toCharArray()) ++freq[ch-'a'];
        long ans = 0;
        int ii = 0, cnt = word2.length();
        for (var ch : word1.toCharArray()) {
            if (freq[ch-'a'] > 0) --cnt;
            --freq[ch-'a'];
            for (; cnt == 0; ++ii) {
                if (freq[word1.charAt(ii)-'a'] == 0) ++cnt;
                ++freq[word1.charAt(ii)-'a'];
            }
            ans += ii;
        }
        return ans;
    }


    /*3300. Minimum Element After Replacement With Digit Sum (Easy)
    You are given an integer array nums. You replace each element in nums with
    the sum of its digits. Return the minimum element in nums after all
    replacements.

    Example 1:
    Input: nums = [10,12,13,14]
    Output: 1
    Explanation: nums becomes [1, 3, 4, 5] after all replacements, with minimum
                 element 1.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 1
    Explanation: nums becomes [1, 2, 3, 4] after all replacements, with minimum
                 element 1.

    Example 3:
    Input: nums = [999,19,199]
    Output: 10
    Explanation: nums becomes [27, 10, 19] after all replacements, with minimum
                 element 10.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 10^4*/

    public int minElement(int[] nums) {
        int ans = Integer.MAX_VALUE;
        for (var x : nums) {
            int cand = 0;
            for (; x > 0; x /= 10)
                cand += x % 10;
            ans = Math.min(ans, cand);
        }
        return ans;
    }


    /*3301. Maximize the Total Height of Unique Towers (Medium)
    You are given an array maximumHeight, where maximumHeight[i] denotes the
    maximum height the ith tower can be assigned. Your task is to assign a
    height to each tower so that:
    * The height of the ith tower is a positive integer and does not exceed
      maximumHeight[i].
    * No two towers have the same height.
    Return the maximum possible total sum of the tower heights. If it's not
    possible to assign heights, return -1.

    Example 1:
    Input: maximumHeight = [2,3,4,3]
    Output: 10
    Explanation: We can assign heights in the following way: [1, 2, 4, 3].

    Example 2:
    Input: maximumHeight = [15,10]
    Output: 25
    Explanation: We can assign heights in the following way: [15, 10].

    Example 3:
    Input: maximumHeight = [2,2,1]
    Output: -1
    Explanation: It's impossible to assign positive heights to each index so
                 that no two towers have the same height.

    Constraints:
    * 1 <= maximumHeight.length <= 10^5
    * 1 <= maximumHeight[i] <= 10^9*/

    public long maximumTotalSum(int[] maximumHeight) {
        long ans = 0;
        Arrays.sort(maximumHeight);
        int val = Integer.MAX_VALUE;
        for (int i = maximumHeight.length-1; i >= 0; --i) {
            val = Math.min(val, maximumHeight[i]);
            if (val <= 0) return -1;
            ans += val--;
        }
        return ans;
    }


    /*3302. Find the Lexicographically Smallest Valid Sequence (Medium)
    You are given two strings word1 and word2. A string x is called almost equal
    to y if you can change at most one character in x to make it identical to y.
    A sequence of indices seq is called valid if:
    * The indices are sorted in ascending order.
    * Concatenating the characters at these indices in word1 in the same order
      results in a string that is almost equal to word2.
    Return an array of size word2.length representing the lexicographically
    smallest valid sequence of indices. If no such sequence of indices exists,
    return an empty array. Note that the answer must represent the
    lexicographically smallest array, not the corresponding string formed by
    those indices.

    Example 1:
    Input: word1 = "vbcca", word2 = "abc"
    Output: [0,1,2]
    Explanation: The lexicographically smallest valid sequence of indices is
                 [0, 1, 2]:
                 - Change word1[0] to 'a'.
                 - word1[1] is already 'b'.
                 - word1[2] is already 'c'.

    Example 2:
    Input: word1 = "bacdc", word2 = "abc"
    Output: [1,2,4]
    Explanation: The lexicographically smallest valid sequence of indices is
                 [1, 2, 4]:
                 - word1[1] is already 'a'.
                 - Change word1[2] to 'b'.
                 - word1[4] is already 'c'.

    Example 3:
    Input: word1 = "aaaaaa", word2 = "aaabc"
    Output: []
    Explanation: There is no valid sequence of indices.

    Example 4:
    Input: word1 = "abc", word2 = "ab"
    Output: [0,1]

    Constraints:
    * 1 <= word2.length < word1.length <= 3 * 10^5
    * word1 and word2 consist only of lowercase English letters.*/

    public int[] validSequence(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[] last = new int[n];
        Arrays.fill(last, -1);
        for (int i = m-1, j = n-1; i >= 0 && j >= 0; --i)
            if (word1.charAt(i) == word2.charAt(j))
                last[j--] = i ;
        boolean can = true;
        int j = 0;
        List<Integer> ans = new ArrayList<>();
        for (int i = 0; i < m && j < n; ++i)
            if (word1.charAt(i) == word2.charAt(j) || can && (j == n-1 || i+1 <= last[j+1])) {
                if (word1.charAt(i) != word2.charAt(j)) can = false;
                ans.add(i);
                ++j;
            }
        if (j < n) ans.clear();
        return ans.stream().mapToInt(Integer::intValue).toArray();
    }


    /*3303. Find the Occurrence of First Almost Equal Substring (Hard)
    You are given two strings s and pattern. A string x is called almost equal
    to y if you can change at most one character in x to make it identical to y.
    Return the smallest starting index of a substring in s that is almost equal
    to pattern. If no such index exists, return -1. A substring is a contiguous
    non-empty sequence of characters within a string.

    Example 1:
    Input: s = "abcdefg", pattern = "bcdffg"
    Output: 1
    Explanation: The substring s[1..6] == "bcdefg" can be converted to "bcdffg"
                 by changing s[4] to "f".

    Example 2:
    Input: s = "ababbababa", pattern = "bacaba"
    Output: 4
    Explanation: The substring s[4..9] == "bababa" can be converted to "bacaba"
                 by changing s[6] to "c".

    Example 3:
    Input: s = "abcd", pattern = "dba"
    Output: -1

    Example 4:
    Input: s = "dde", pattern = "d"
    Output: 0

    Constraints:
    * 1 <= pattern.length < s.length <= 3 * 10^5
    * s and pattern consist only of lowercase English letters.

    Follow-up: Could you solve the problem if at most k consecutive characters
               can be changed?*/

    private int[] z_algo(String s) {
        int n = s.length();
        int[] ans = new int[n];
        for (int i = 1, ii = 0, lo = 0, hi = 0; i < n; ++i) {
            if (i <= hi) ii = i - lo;
            if (i + ans[ii] <= hi) ans[i] = ans[ii];
            else {
                lo = i;
                hi = Math.max(hi, i);
                while (hi < n && s.charAt(hi) == s.charAt(hi-lo)) ++hi;
                ans[i] = hi - lo;
                --hi;
            }
        }
        return ans;
    }

    public int minStartingIndex(String s, String pattern) {
        int[] prefix = z_algo(pattern + "#" + s);
        int[] suffix = z_algo(new StringBuilder(s + "#" + pattern).reverse().toString());
        for (int i = 0, n = s.length(), k = pattern.length(); i <= n-k; ++i)
            if (prefix[k+i+1] + suffix[n-i+1] >= k-1) return i;
        return -1;
    }


    /*3304. Find the K-th Character in String Game I (Easy)
    Alice and Bob are playing a game. Initially, Alice has a string word = "a".
    You are given a positive integer k. Now Bob will ask Alice to perform the
    following operation forever:
    * Generate a new string by changing each character in word to its next
      character in the English alphabet, and append it to the original word.
    For example, performing the operation on "c" generates "cd" and performing
    the operation on "zb" generates "zbac". Return the value of the kth
    character in word, after enough operations have been done for word to have
    at least k characters. Note that the character 'z' can be changed to 'a' in
    the operation.

    Example 1:
    Input: k = 5
    Output: "b"
    Explanation: Initially, word = "a". We need to do the operation three times:
                 - Generated string is "b", word becomes "ab".
                 - Generated string is "bc", word becomes "abbc".
                 - Generated string is "bccd", word becomes "abbcbccd".

    Example 2:
    Input: k = 10
    Output: "c"

    Constraints: 1 <= k <= 500*/

    public char kthCharacter(int k) {
        return (char) ('a' + Integer.bitCount(k-1) % 26);
    }


    /*3305. Count of Substrings Containing Every Vowel and K Consonants I (Medium)
    You are given a string word and a non-negative integer k. Return the total
    number of substrings of word that contain every vowel ('a', 'e', 'i', 'o',
    and 'u') at least once and exactly k consonants.

    Example 1:
    Input: word = "aeioqq", k = 1
    Output: 0
    Explanation: There is no substring with every vowel.

    Example 2:
    Input: word = "aeiou", k = 0
    Output: 1
    Explanation: The only substring with every vowel and zero consonants is
                 word[0..4], which is "aeiou".

    Example 3:
    Input: word = "ieaouqqieaouqq", k = 1
    Output: 3
    Explanation: The substrings with every vowel and one consonant are:
                 - word[0..5], which is "ieaouq".
                 - word[6..11], which is "qieaou".
                 - word[7..12], which is "ieaouq".

    Constraints:
    * 5 <= word.length <= 250
    * word consists only of lowercase English letters.
    * 0 <= k <= word.length - 5*/

    private int[] fn(String word, int k, BiFunction<Integer, Integer, Boolean> op) {
        List<Integer> ans = new ArrayList<>();
        Map<Character, Integer> vowel = new HashMap<>();
        int consonant = 0, j = 0;
        for (var ch : word.toCharArray()) {
            if ("aeiou".indexOf(ch) >= 0) vowel.merge(ch, 1, Integer::sum);
            else ++consonant;
            for (; vowel.size() == 5 && op.apply(consonant, k); ++j)
                if ("aeiou".indexOf(word.charAt(j)) >= 0) {
                    vowel.merge(word.charAt(j), -1, Integer::sum);
                    if (vowel.get(word.charAt(j)) == 0) vowel.remove(word.charAt(j));
                } else --consonant;
            ans.add(j);
        }
        return ans.stream().mapToInt(Integer::intValue).toArray();
    }

    public int countOfSubstrings(String word, int k) {
        int[] lo = fn(word, k, (x, y) -> x > y), hi = fn(word, k, (x, y) -> x >= y);
        int ans = 0;
        for (int i = 0; i < lo.length; ++i)
            ans += hi[i] - lo[i];
        return ans;
    }

    /*3306. Count of Substrings Containing Every Vowel and K Consonants II (Medium)
    You are given a string word and a non-negative integer k. Return the total
    number of substrings of word that contain every vowel ('a', 'e', 'i', 'o',
    and 'u') at least once and exactly k consonants.

    Example 1:
    Input: word = "aeioqq", k = 1
    Output: 0
    Explanation: There is no substring with every vowel.

    Example 2:
    Input: word = "aeiou", k = 0
    Output: 1
    Explanation: The only substring with every vowel and zero consonants is
                 word[0..4], which is "aeiou".

    Example 3:
    Input: word = "ieaouqqieaouqq", k = 1
    Output: 3
    Explanation: The substrings with every vowel and one consonant are:
                 - word[0..5], which is "ieaouq".
                 - word[6..11], which is "qieaou".
                 - word[7..12], which is "ieaouq".

    Constraints:
    * 5 <= word.length <= 2 * 10^5
    * word consists only of lowercase English letters.
    * 0 <= k <= word.length - 5*/

    private int[] fn(String word, int k, BiFunction<Integer, Integer, Boolean> op) {
        List<Integer> ans = new ArrayList<>();
        Map<Character, Integer> vowel = new HashMap<>();
        int consonant = 0, j = 0;
        for (var ch : word.toCharArray()) {
            if ("aeiou".indexOf(ch) >= 0) vowel.merge(ch, 1, Integer::sum);
            else ++consonant;
            for (; vowel.size() == 5 && op.apply(consonant, k); ++j)
                if ("aeiou".indexOf(word.charAt(j)) >= 0) {
                    vowel.merge(word.charAt(j), -1, Integer::sum);
                    if (vowel.get(word.charAt(j)) == 0) vowel.remove(word.charAt(j));
                } else --consonant;
            ans.add(j);
        }
        return ans.stream().mapToInt(Integer::intValue).toArray();
    }

    public long countOfSubstrings(String word, int k) {
        int[] lo = fn(word, k, (x, y) -> x > y), hi = fn(word, k, (x, y) -> x >= y);
        long ans = 0;
        for (int i = 0; i < lo.length; ++i)
            ans += hi[i] - lo[i];
        return ans;
    }


    /*3307. Find the K-th Character in String Game II (Hard)
    Alice and Bob are playing a game. Initially, Alice has a string word = "a".
    You are given a positive integer k. You are also given an integer array
    operations, where operations[i] represents the type of the ith operation.
    Now Bob will ask Alice to perform all operations in sequence:
    * If operations[i] == 0, append a copy of word to itself.
    * If operations[i] == 1, generate a new string by changing each character in
      word to its next character in the English alphabet, and append it to the
      original word. For example, performing the operation on "c" generates "cd"
      and performing the operation on "zb" generates "zbac".
    Return the value of the kth character in word after performing all the
    operations. Note that the character 'z' can be changed to 'a' in the second
    type of operation.

    Example 1:
    Input: k = 5, operations = [0,0,0]
    Output: "a"
    Explanation: Initially, word == "a". Alice performs the three operations as
                 follows:
                 - Appends "a" to "a", word becomes "aa".
                 - Appends "aa" to "aa", word becomes "aaaa".
                 - Appends "aaaa" to "aaaa", word becomes "aaaaaaaa".

    Example 2:
    Input: k = 10, operations = [0,1,0,1]
    Output: "b"
    Explanation: Initially, word == "a". Alice performs the four operations as
                 follows:
                 - Appends "a" to "a", word becomes "aa".
                 - Appends "bb" to "aa", word becomes "aabb".
                 - Appends "aabb" to "aabb", word becomes "aabbaabb".
                 - Appends "bbccbbcc" to "aabbaabb", word becomes "aabbaabbbbccbbcc".

    Constraints:
    * 1 <= k <= 10^14
    * 1 <= operations.length <= 100
    * operations[i] is either 0 or 1.
    * The input is generated such that word has at least k characters after all
      operations.*/

    public char kthCharacter(long k, int[] operations) {
        --k;
        int cnt = 0;
        for (int i = 0; i < 47 && i < operations.length; ++i)
            if ((k & 1l<<i) > 0)
                cnt += operations[i];
        return (char) ('a' + cnt%26);
    }


    /*3314. Construct the Minimum Bitwise Array I (Easy)
    You are given an array nums consisting of n prime integers. You need to
    construct an array ans of length n, such that, for each index i, the bitwise
    OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR
    (ans[i] + 1) == nums[i]. Additionally, you must minimize each value of
    ans[i] in the resulting array. If it is not possible to find such a value
    for ans[i] that satisfies the condition, then set ans[i] = -1.

    Example 1:
    Input: nums = [2,3,5,7]
    Output: [-1,1,4,3]
    Explanation: * For i = 0, as there is no value for ans[0] that satisfies
                   ans[0] OR (ans[0] + 1) = 2, so ans[0] = -1.
                 * For i = 1, the smallest ans[1] that satisfies ans[1] OR
                   (ans[1] + 1) = 3 is 1, because 1 OR (1 + 1) = 3.
                 * For i = 2, the smallest ans[2] that satisfies ans[2] OR
                   (ans[2] + 1) = 5 is 4, because 4 OR (4 + 1) = 5.
                 * For i = 3, the smallest ans[3] that satisfies ans[3] OR
                   (ans[3] + 1) = 7 is 3, because 3 OR (3 + 1) = 7.

    Example 2:
    Input: nums = [11,13,31]
    Output: [9,12,15]
    Explanation: * For i = 0, the smallest ans[0] that satisfies ans[0] OR
                   (ans[0] + 1) = 11 is 9, because 9 OR (9 + 1) = 11.
                 * For i = 1, the smallest ans[1] that satisfies ans[1] OR
                   (ans[1] + 1) = 13 is 12, because 12 OR (12 + 1) = 13.
                 * For i = 2, the smallest ans[2] that satisfies ans[2] OR
                   (ans[2] + 1) = 31 is 15, because 15 OR (15 + 1) = 31.

    Constraints:
    * 1 <= nums.length <= 100
    * 2 <= nums[i] <= 1000
    * nums[i] is a prime number.*/

    public int[] minBitwiseArray(List<Integer> nums) {
        List<Integer> ans = new ArrayList<>();
        for (var x : nums)
            if ((x & 1) > 0) {
                int xx = x+1, bit = (xx & -xx) >> 1;
                ans.add(x - bit);
            } else ans.add(-1);
        return ans.stream().mapToInt(x -> x).toArray();
    }


    /*3315. Construct the Minimum Bitwise Array II (Medium)
    You are given an array nums consisting of n prime integers. You need to
    construct an array ans of length n, such that, for each index i, the bitwise
    OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR
    (ans[i] + 1) == nums[i]. Additionally, you must minimize each value of
    ans[i] in the resulting array. If it is not possible to find such a value
    for ans[i] that satisfies the condition, then set ans[i] = -1.

    Example 1:
    Input: nums = [2,3,5,7]
    Output: [-1,1,4,3]
    Explanation: * For i = 0, as there is no value for ans[0] that satisfies
                   ans[0] OR (ans[0] + 1) = 2, so ans[0] = -1.
                 * For i = 1, the smallest ans[1] that satisfies ans[1] OR
                   (ans[1] + 1) = 3 is 1, because 1 OR (1 + 1) = 3.
                 * For i = 2, the smallest ans[2] that satisfies ans[2] OR
                   (ans[2] + 1) = 5 is 4, because 4 OR (4 + 1) = 5.
                 * For i = 3, the smallest ans[3] that satisfies ans[3] OR
                   (ans[3] + 1) = 7 is 3, because 3 OR (3 + 1) = 7.

    Example 2:
    Input: nums = [11,13,31]
    Output: [9,12,15]
    Explanation: * For i = 0, the smallest ans[0] that satisfies ans[0] OR
                   (ans[0] + 1) = 11 is 9, because 9 OR (9 + 1) = 11.
                 * For i = 1, the smallest ans[1] that satisfies ans[1] OR
                   (ans[1] + 1) = 13 is 12, because 12 OR (12 + 1) = 13.
                 * For i = 2, the smallest ans[2] that satisfies ans[2] OR
                   (ans[2] + 1) = 31 is 15, because 15 OR (15 + 1) = 31.

    Constraints:
    * 1 <= nums.length <= 100
    * 2 <= nums[i] <= 10^9
    * nums[i] is a prime number.*/

    public int[] minBitwiseArray(List<Integer> nums) {
        List<Integer> ans = new ArrayList<>();
        for (var x : nums)
            if ((x & 1) > 0) {
                int xx = x+1, bit = (xx & -xx) >> 1;
                ans.add(x - bit);
            } else ans.add(-1);
        return ans.stream().mapToInt(x -> x).toArray();
    }


    /*3316. Find Maximum Removals From Source String (Medium)
    You are given a string source of size n, a string pattern that is a
    subsequence of source, and a sorted integer array targetIndices that
    contains distinct numbers in the range [0, n - 1]. We define an operation as
    removing a character at an index idx from source such that:
    * idx is an element of targetIndices.
    * pattern remains a subsequence of source after removing the character.
    Performing an operation does not change the indices of the other characters
    in source. For example, if you remove 'c' from "acb", the character at index
    2 would still be 'b'. Return the maximum number of operations that can be
    performed.

    Example 1:
    Input: source = "abbaa", pattern = "aba", targetIndices = [0,1,2]
    Output: 1
    Explanation: We can't remove source[0] but we can do either of these two
                 operations:
                 * Remove source[1], so that source becomes "a_baa".
                 * Remove source[2], so that source becomes "ab_aa".

    Example 2:
    Input: source = "bcda", pattern = "d", targetIndices = [0,3]
    Output: 2
    Explanation: We can remove source[0] and source[3] in two operations.

    Example 3:
    Input: source = "dda", pattern = "dda", targetIndices = [0,1,2]
    Output: 0
    Explanation: We can't remove any character from source.

    Example 4:
    Input: source = "yeyeykyded", pattern = "yeyyd", targetIndices = [0,2,3,4]
    Output: 2
    Explanation: We can remove source[2] and source[3] in two operations.

    Constraints:
    * 1 <= n == source.length <= 3 * 10^3
    * 1 <= pattern.length <= n
    * 1 <= targetIndices.length <= n
    * targetIndices is sorted in ascending order.
    * The input is generated such that targetIndices contains distinct elements
      in the range [0, n - 1].
    * source and pattern consist only of lowercase English letters.
    * The input is generated such that pattern appears as a subsequence in source.*/

    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int m = source.length(), n = pattern.length();
        Set<Integer> seen = Arrays.stream(targetIndices).boxed().collect(Collectors.toSet());
        int[][] dp = new int[m+1][n+1];
        for (int j = 0; j <= n; ++j)
            dp[m][j] = Integer.MIN_VALUE;
        for (int i = m, k = targetIndices.length-1; i >= 0; --i) {
            if (k >= 0 && i == targetIndices[k]) --k;
            dp[i][n] = targetIndices.length-1-k;
        }
        for (int i = m-1; i >= 0; --i)
            for (int j = n-1; j >= 0; --j)
                if (source.charAt(i) == pattern.charAt(j)) {
                    dp[i][j] = dp[i+1][j+1];
                    if (seen.contains(i)) dp[i][j] = Math.max(dp[i][j], 1+dp[i+1][j]);
                } else {
                    dp[i][j] = dp[i+1][j];
                    if (seen.contains(i)) ++dp[i][j];
                }
        return dp[0][0];
    }


    /*3317. Find the Number of Possible Ways for an Event (Hard)
    You are given three integers n, x, and y. An event is being held for n
    performers. When a performer arrives, they are assigned to one of the x
    stages. All performers assigned to the same stage will perform together as a
    band, though some stages might remain empty. After all performances are
    completed, the jury will award each band a score in the range [1, y]. Return
    the total number of possible ways the event can take place. Since the answer
    may be very large, return it modulo 10^9 + 7. Note that two events are
    considered to have been held differently if either of the following
    conditions is satisfied:
    * Any performer is assigned a different stage.
    * Any band is awarded a different score.

    Example 1:
    Input: n = 1, x = 2, y = 3
    Output: 6
    Explanation: There are 2 ways to assign a stage to the performer. The jury
                 can award a score of either 1, 2, or 3 to the only band.

    Example 2:
    Input: n = 5, x = 2, y = 1
    Output: 32
    Explanation: Each performer will be assigned either stage 1 or stage 2. All
                 bands will be awarded a score of 1.

    Example 3:
    Input: n = 3, x = 3, y = 4
    Output: 684

    Constraints: 1 <= n, x, y <= 1000*/

    public int numberOfWays(int n, int x, int y) {
        final int mod = 1_000_000_007;
        long[][] dp = new long[n+1][x+1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= x && j <= i; ++j)
                dp[i][j] = (dp[i-1][j-1]*(x-j+1)*y + dp[i-1][j]*j) % mod;
        return (int) (LongStream.of(dp[n]).sum() % mod);
    }


    /*3318. Find X-Sum of All K-Long Subarrays I (Easy)
    You are given an array nums of n integers and two integers k and x. The x-
    sum of an array is calculated by the following procedure:
    * Count the occurrences of all elements in the array.
    * Keep only the occurrences of the top x most frequent elements. If two
      elements have the same number of occurrences, the element with the bigger
      value is considered more frequent.
    * Calculate the sum of the resulting array.
    Note that if an array has less than x distinct elements, its x-sum is the
    sum of the array. Return an integer array answer of length n - k + 1 where
    answer[i] is the x-sum of the subarray nums[i..i + k - 1].

    Example 1:
    Input: nums = [1,1,2,2,3,4,2,3], k = 6, x = 2
    Output: [6,10,12]
    Explanation: * For subarray [1, 1, 2, 2, 3, 4], only elements 1 and 2 will
                   be kept in the resulting array. Hence,
                   answer[0] = 1 + 1 + 2 + 2.
                 * For subarray [1, 2, 2, 3, 4, 2], only elements 2 and 4 will
                   be kept in the resulting array. Hence,
                   answer[1] = 2 + 2 + 2 + 4. Note that 4 is kept in the array
                   since it is bigger than 3 and 1 which occur the same number
                   of times.
                 * For subarray [2, 2, 3, 4, 2, 3], only elements 2 and 3 are
                   kept in the resulting array. Hence,
                   answer[2] = 2 + 2 + 2 + 3 + 3.

    Example 2:
    Input: nums = [3,8,7,8,7,5], k = 2, x = 2
    Output: [11,15,15,15,12]
    Explanation: Since k == x, answer[i] is equal to the sum of the subarray
                 nums[i..i + k - 1].

    Constraints:
    * 1 <= n == nums.length <= 50
    * 1 <= nums[i] <= 50
    * 1 <= x <= k <= nums.length*/

    public int[] findXSum(int[] nums, int k, int x) {
        List<Integer> ans = new ArrayList<>();
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < nums.length; ++i) {
            freq.merge(nums[i], 1, Integer::sum);
            if (i >= k) freq.merge(nums[i-k], -1, Integer::sum);
            if (i >= k-1) {
                List<Map.Entry<Integer, Integer>> vals = new ArrayList<>(freq.entrySet());
                Collections.sort(vals, (a, b) -> a.getValue() != b.getValue() ? Integer.compare(b.getValue(), a.getValue()) : Integer.compare(b.getKey(), a.getKey()));
                int cand = 0;
                for (int j = 0; j < x && j < vals.size(); ++j)
                    cand += vals.get(j).getKey() * vals.get(j).getValue();
                ans.add(cand);
            }
        }
        return ans.stream().mapToInt(a -> a).toArray();
    }


    /*3319. K-th Largest Perfect Subtree Size in Binary Tree (Medium)
    You are given the root of a binary tree and an integer k. Return an integer
    denoting the size of the kth largest perfect binary subtree, or -1 if it
    doesn't exist. A perfect binary tree is a tree where all leaves are on the
    same level, and every parent has two children.

    Example 1:
    Input: root = [5,3,6,5,2,5,7,1,8,null,null,6,8], k = 2
    Output: 3
    Explanation: The roots of the perfect binary subtrees are highlighted in
                 black. Their sizes, in non-increasing order are
                 [3, 3, 1, 1, 1, 1, 1, 1]. The 2nd largest size is 3.

    Example 2:
    Input: root = [1,2,3,4,5,6,7], k = 1
    Output: 7
    Explanation: The sizes of the perfect binary subtrees in non-increasing
                 order are [7, 3, 3, 1, 1, 1, 1]. The size of the largest
                 perfect binary subtree is 7.

    Example 3:
    Input: root = [1,2,3,null,4], k = 3
    Output: -1
    Explanation: The sizes of the perfect binary subtrees in non-increasing
                 order are [1, 1]. There are fewer than 3 perfect binary
                 subtrees.

    Constraints:
    * The number of nodes in the tree is in the range [1, 2000].
    * 1 <= Node.val <= 2000
    * 1 <= k <= 1024*/

    private int fn(TreeNode node, List<Integer> vals) {
        if (node == null) return 0;
        int left = fn(node.left, vals), right = fn(node.right, vals);
        if (left == right && left != -1) {
            vals.add(1 + left + right);
            return 1 + left + right;
        }
        return -1;
    }

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        List<Integer> vals = new ArrayList<>();
        fn(root, vals);
        Collections.sort(vals, (x, y) -> Integer.compare(y, x));
        return k <= vals.size() ? vals.get(k-1) : -1;
    }


    /*3320. Count The Number of Winning Sequences (Hard)
    Alice and Bob are playing a fantasy battle game consisting of n rounds where
    they summon one of three magical creatures each round: a Fire Dragon, a
    Water Serpent, or an Earth Golem. In each round, players simultaneously
    summon their creature and are awarded points as follows:
    * If one player summons a Fire Dragon and the other summons an Earth Golem,
      the player who summoned the Fire Dragon is awarded a point.
    * If one player summons a Water Serpent and the other summons a Fire Dragon,
      the player who summoned the Water Serpent is awarded a point.
    * If one player summons an Earth Golem and the other summons a Water
      Serpent, the player who summoned the Earth Golem is awarded a point.
    * If both players summon the same creature, no player is awarded a point.
    You are given a string s consisting of n characters 'F', 'W', and 'E',
    representing the sequence of creatures Alice will summon in each round:
    * If s[i] == 'F', Alice summons a Fire Dragon.
    * If s[i] == 'W', Alice summons a Water Serpent.
    * If s[i] == 'E', Alice summons an Earth Golem.
    Bob’s sequence of moves is unknown, but it is guaranteed that Bob will never
    summon the same creature in two consecutive rounds. Bob beats Alice if the
    total number of points awarded to Bob after n rounds is strictly greater
    than the points awarded to Alice. Return the number of distinct sequences
    Bob can use to beat Alice. Since the answer may be very large, return it
    modulo 10^9 + 7.

    Example 1:
    Input: s = "FFF"
    Output: 3
    Explanation: Bob can beat Alice by making one of the following sequences of
                 moves: "WFW", "FWF", or "WEW". Note that other winning
                 sequences like "WWE" or "EWW" are invalid since Bob cannot make
                 the same move twice in a row.

    Example 2:
    Input: s = "FWEFW"
    Output: 18
    Explanation: Bob can beat Alice by making one of the following sequences of
                 moves: "FWFWF", "FWFWE", "FWEFE", "FWEWE", "FEFWF", "FEFWE",
                 "FEFEW", "FEWFE", "WFEFE", "WFEWE", "WEFWF", "WEFWE", "WEFEF",
                 "WEFEW", "WEWFW", "WEWFE", "EWFWE", or "EWEWE".

    Constraints:
    * 1 <= s.length <= 1000
    * s[i] is one of 'F', 'W', or 'E'.*/

    public int countWinningSequences(String s) {
        final int mod = 1_000_000_007, n = s.length();
        long[][][] dp = new long[n][3][2*n+1];
        for (int i = 0; i < n; ++i) {
            int v = "EFW".indexOf(s.charAt(i));
            for (int j = 0; j < 3; ++j) {
                int diff = (j - v) % 3;
                if (diff == 2) diff = -1;
                if (diff == -2) diff = 1;
                if (i == 0) dp[i][j][n+diff] = 1;
                else
                    for (int p = 0; p < 3; ++p)
                        if (j != p)
                            for (int k = -i; k <= i; ++k)
                                dp[i][j][n+k+diff] = (dp[i][j][n+k+diff] + dp[i-1][p][n+k]) % mod;
            }
        }
        long ans = 0;
        for (int j = 0; j < 3; ++j)
             for (int k = 1; k <= n; ++k)
                 ans = (ans + dp[n-1][j][n+k]) % mod;
        return (int) ans;
    }


    /*3321. Find X-Sum of All K-Long Subarrays II (Hard)
    You are given an array nums of n integers and two integers k and x. The x-
    sum of an array is calculated by the following procedure:
    * Count the occurrences of all elements in the array.
    * Keep only the occurrences of the top x most frequent elements. If two
      elements have the same number of occurrences, the element with the bigger
      value is considered more frequent.
    * Calculate the sum of the resulting array.
    Note that if an array has less than x distinct elements, its x-sum is the
    sum of the array. Return an integer array answer of length n - k + 1 where
    answer[i] is the x-sum of the subarray nums[i..i + k - 1].

    Example 1:
    Input: nums = [1,1,2,2,3,4,2,3], k = 6, x = 2
    Output: [6,10,12]
    Explanation: * For subarray [1, 1, 2, 2, 3, 4], only elements 1 and 2 will
                   be kept in the resulting array. Hence,
                   answer[0] = 1 + 1 + 2 + 2.
                 * For subarray [1, 2, 2, 3, 4, 2], only elements 2 and 4 will
                   be kept in the resulting array. Hence,
                   answer[1] = 2 + 2 + 2 + 4. Note that 4 is kept in the array
                   since it is bigger than 3 and 1 which occur the same number
                   of times.
                 * For subarray [2, 2, 3, 4, 2, 3], only elements 2 and 3 are
                   kept in the resulting array. Hence,
                   answer[2] = 2 + 2 + 2 + 3 + 3.

    Example 2:
    Input: nums = [3,8,7,8,7,5], k = 2, x = 2
    Output: [11,15,15,15,12]
    Explanation: Since k == x, answer[i] is equal to the sum of the subarray
                 nums[i..i + k - 1].

    Constraints:
    * nums.length == n
    * 1 <= n <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= x <= k <= nums.length*/

    public long[] findXSum(int[] nums, int k, int x) {
        Map<Integer, Long> freq = new HashMap<>();
        TreeSet<long[]> top = new TreeSet<>((a, b) -> a[0] != b[0] ? Long.compare(a[0], b[0]) : Long.compare(a[1], b[1]));
        TreeSet<long[]> bottom = new TreeSet<>((a, b) -> a[0] != b[0] ? Long.compare(a[0], b[0]) : Long.compare(a[1], b[1]));
        List<Long> ans = new ArrayList<>();
        long val = 0;
        for (int i = 0; i < nums.length; ++i) {
            int v = nums[i];
            if (freq.getOrDefault(v, 0l) > 0) {
                var elem = new long[] {freq.get(v), v};
                if (freq.get(v) > top.first()[0] || freq.get(v) == top.first()[0] && v >= top.first()[1]) {
                    top.remove(new long[] {freq.get(v), v});
                    val -= freq.get(v) * v;
                } else bottom.remove(new long[] {freq.get(v), v});
            }
            freq.merge(v, 1l, Long::sum);
            top.add(new long[]{freq.get(v), v});
            val += freq.get(v) * v;
            if (top.size() > x) {
                bottom.add(top.first());
                val -= top.first()[0] * top.first()[1];
                top.remove(top.first());
            }
            if (i >= k) {
                int vv = nums[i-k];
                if (freq.get(vv) > top.first()[0] || freq.get(vv) == top.first()[0] && vv >= top.first()[1]) {
                    top.remove(new long[] {freq.get(vv), vv});
                    val -= freq.get(vv) * vv;
                } else bottom.remove(new long[] {freq.get(vv), vv});
                freq.merge(vv, -1l, Long::sum);
                if (freq.get(vv) > 0) bottom.add(new long[] {freq.get(vv), vv});
                if (top.size() < x && !bottom.isEmpty()) {
                    top.add(bottom.last());
                    val += bottom.last()[0] * bottom.last()[1];
                    bottom.remove(bottom.last());
                }
            }
            if (i >= k-1) ans.add(val);
        }
        return ans.stream().mapToLong(i -> i).toArray();
    }


    /*3324. Find the Sequence of Strings Appeared on the Screen (Medium)
    You are given a string target. Alice is going to type target on her computer
    using a special keyboard that has only two keys:
    * Key 1 appends the character "a" to the string on the screen.
    * Key 2 changes the last character of the string on the screen to its next
      character in the English alphabet. For example, "c" changes to "d" and "z"
      changes to "a".
    Note that initially there is an empty string "" on the screen, so she can
    only press key 1. Return a list of all strings that appear on the screen as
    Alice types target, in the order they appear, using the minimum key presses.

    Example 1:
    Input: target = "abc"
    Output: ["a","aa","ab","aba","abb","abc"]
    Explanation: The sequence of key presses done by Alice are:
                 * Press key 1, and the string on the screen becomes "a".
                 * Press key 1, and the string on the screen becomes "aa".
                 * Press key 2, and the string on the screen becomes "ab".
                 * Press key 1, and the string on the screen becomes "aba".
                 * Press key 2, and the string on the screen becomes "abb".
                 * Press key 2, and the string on the screen becomes "abc".

    Example 2:
    Input: target = "he"
    Output: ["a","b","c","d","e","f","g","h","ha","hb","hc","hd","he"]

    Constraints:
    * 1 <= target.length <= 400
    * target consists only of lowercase English letters.*/

    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        String prefix = "";
        for (var ch : target.toCharArray()) {
            for (char x = 'a'; x <= ch; ++x)
                ans.add(prefix + x);
            prefix = prefix + ch;
        }
        return ans;
    }


    /*3325. Count Substrings With K-Frequency Characters I (Medium)
    Given a string s and an integer k, return the total number of substrings of
    s where at least one character appears at least k times.

    Example 1:
    Input: s = "abacb", k = 2
    Output: 4
    Explanation: The valid substrings are:
                 * "aba" (character 'a' appears 2 times).
                 * "abac" (character 'a' appears 2 times).
                 * "abacb" (character 'a' appears 2 times).
                 * "bacb" (character 'b' appears 2 times).

    Example 2:
    Input: s = "abcde", k = 1
    Output: 15
    Explanation: All substrings are valid because every character appears at
                 least once.

    Constraints:
    * 1 <= s.length <= 3000
    * 1 <= k <= s.length
    * s consists only of lowercase English letters.*/

    public int numberOfSubstrings(String s, int k) {
        Map<Character, Integer> freq = new HashMap<>();
        int ans = 0, ii = 0;
        for (var ch : s.toCharArray()) {
            freq.merge(ch, 1, Integer::sum);
            while (freq.get(ch) == k)
                freq.merge(s.charAt(ii++), -1, Integer::sum);
            ans += ii;
        }
        return ans;
    }


    /*3326. Minimum Division Operations to Make Array Non Decreasing (Medium)
    You are given an integer array nums. Any positive divisor of a natural
    number x that is strictly less than x is called a proper divisor of x. For
    example, 2 is a proper divisor of 4, while 6 is not a proper divisor of 6.
    You are allowed to perform an operation any number of times on nums, where
    in each operation you select any one element from nums and divide it by its
    greatest proper divisor. Return the minimum number of operations required to
    make the array non-decreasing. If it is not possible to make the array non-
    decreasing using any number of operations, return -1.

    Example 1:
    Input: nums = [25,7]
    Output: 1
    Explanation: Using a single operation, 25 gets divided by 5 and nums becomes
                 [5, 7].

    Example 2:
    Input: nums = [7,7,6]
    Output: -1

    Example 3:
    Input: nums = [1,1,1,1]
    Output: 0

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^6*/

    public int minOperations(int[] nums) {
        int ans = 0;
        for (int i = nums.length-2; i >= 0; --i)
            while (nums[i] > nums[i+1]) {
                int op = 0;
                for (int cand = 2; cand <= Math.sqrt(nums[i]); ++cand)
                    if (nums[i] % cand == 0) {
                        nums[i] = cand;
                        ++op;
                        break;
                    }
                if (op == 0) return -1;
                ans += op;
            }
        return ans;
    }


    /*3327. Check if DFS Strings Are Palindromes (Hard)
    You are given a tree rooted at node 0, consisting of n nodes numbered from 0
    to n - 1. The tree is represented by an array parent of size n, where
    parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1.
    You are also given a string s of length n, where s[i] is the character
    assigned to node i. Consider an empty string dfsStr, and define a recursive
    function dfs(int x) that takes a node x as a parameter and performs the
    following steps in order:
    * Iterate over each child y of x in increasing order of their numbers, and call dfs(y).
    * Add the character s[x] to the end of the string dfsStr.
    Note that dfsStr is shared across all recursive calls of dfs. You need to
    find a boolean array answer of size n, where for each index i from 0 to
    n - 1, you do the following:
    * Empty the string dfsStr and call dfs(i).
    * If the resulting string dfsStr is a palindrome, then set answer[i] to true.
      Otherwise, set answer[i] to false.
    Return the array answer.

    Example 1:
    Input: parent = [-1,0,0,1,1,2], s = "aababa"
    Output: [true,true,false,true,true,true]
    Explanation: * Calling dfs(0) results in the string dfsStr = "abaaba", which
                   is a palindrome.
                 * Calling dfs(1) results in the string dfsStr = "aba", which is
                   a palindrome.
                 * Calling dfs(2) results in the string dfsStr = "ab", which is
                   not a palindrome.
                 * Calling dfs(3) results in the string dfsStr = "a", which is a
                   palindrome.
                 * Calling dfs(4) results in the string dfsStr = "b", which is a
                   palindrome.
                 * Calling dfs(5) results in the string dfsStr = "a", which is a
                   palindrome.

    Example 2:
    Input: parent = [-1,0,0,0,0], s = "aabcb"
    Output: [true,true,true,true,true]
    Explanation: Every call on dfs(x) results in a palindrome string.

    Constraints:
    * n == parent.length == s.length
    * 1 <= n <= 10^5
    * 0 <= parent[i] <= n - 1 for all i >= 1.
    * parent[0] == -1
    * parent represents a valid tree.
    * s consists only of lowercase English letters.*/

    private void dfs(int u, int p, String s, int[][] pos, StringBuilder vals, List<Integer>[] tree) {
        pos[u][0] = vals.length();
        for (var v : tree[u])
            if (v != p) dfs(v, u, s, pos, vals, tree);
        vals.append(s.charAt(u));
        pos[u][1] = vals.length();
    }

    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        List<Integer>[] tree = new List[n];
        for (int i = 0; i < n; ++i)
            tree[i] = new ArrayList<>();
        for (int i = 0; i < n; ++i)
            if (parent[i] != -1) tree[parent[i]].add(i);
        StringBuilder vals = new StringBuilder();
        int[][] pos = new int[n][2];
        dfs(0, -1, s, pos, vals, tree);

        StringBuilder sb = new StringBuilder("#");
        for (var ch : vals.toString().toCharArray()) {
            sb.append(ch);
            sb.append('#');
        }
        String ss = sb.toString();
        int sz = ss.length(), center = 0, right = 0;
        int[] hlen = new int[sz];
        for (int i = 0; i < sz; ++i) {
            if (i < right) hlen[i] = Math.min(right-i, hlen[2*center-i]);
            while (0 <= i-1-hlen[i] && i+1+hlen[i] < sz && ss.charAt(i-1-hlen[i]) == ss.charAt(i+1+hlen[i])) ++hlen[i];
            if (right < i+hlen[i]) {
                center = i;
                right = i+hlen[i];
            }
        }
        boolean[] ans = new boolean[n];
        for (int i = 0; i < n; ++i) {
            int lo = pos[i][0], hi = pos[i][1];
            ans[i] = hi-lo <= hlen[lo+hi];
        }
        return ans;
    }


    /*3330. Find the Original Typed String I (Easy)
    Alice is attempting to type a specific string on her computer. However, she
    tends to be clumsy and may press a key for too long, resulting in a
    character being typed multiple times. Although Alice tried to focus on her
    typing, she is aware that she may still have done this at most once. You are
    given a string word, which represents the final output displayed on Alice's
    screen. Return the total number of possible original strings that Alice
    might have intended to type.

    Example 1:
    Input: word = "abbcccc"
    Output: 5
    Explanation: The possible strings are: "abbcccc", "abbccc", "abbcc", "abbc",
                 and "abcccc".

    Example 2:
    Input: word = "abcd"
    Output: 1
    Explanation: The only possible string is "abcd".

    Example 3:
    Input: word = "aaaa"
    Output: 4

    Constraints:
    * 1 <= word.length <= 100
    * word consists only of lowercase English letters.*/

    public int possibleStringCount(String word) {
        int ans = 1;
        for (int i = 0, cnt = 0, n = word.length(); i < n; ++i) {
            ++cnt;
            if (i == n-1 || word.charAt(i) != word.charAt(i+1)) {
                ans += cnt - 1;
                cnt = 0;
            }
        }
        return ans;
    }


    /*3331. Find Subtree Sizes After Changes (Medium)
    You are given a tree rooted at node 0 that consists of n nodes numbered from
    0 to n - 1. The tree is represented by an array parent of size n, where
    parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1.
    You are also given a string s of length n, where s[i] is the character
    assigned to node i. We make the following changes on the tree one time
    simultaneously for all nodes x from 1 to n - 1:
    * Find the closest node y to node x such that y is an ancestor of x, and s
      [x] == s[y].
    * If node y does not exist, do nothing.
    * Otherwise, remove the edge between x and its current parent and make node
      y the new parent of x by adding an edge between them.
    Return an array answer of size n where answer[i] is the size of the subtree
    rooted at node i in the final tree.

    Example 1:
    Input: parent = [-1,0,0,1,1,1], s = "abaabc"
    Output: [6,3,1,1,1,1]
    Explanation: The parent of node 3 will change from node 1 to node 0.

    Example 2:
    Input: parent = [-1,0,4,0,1], s = "abbba"
    Output: [5,2,1,1,1]
    Explanation: The following changes will happen at the same time:
                 * The parent of node 4 will change from node 1 to node 0.
                 * The parent of node 2 will change from node 4 to node 1.

    Constraints:
    * n == parent.length == s.length
    * 1 <= n <= 10^5
    * 0 <= parent[i] <= n - 1 for all i >= 1.
    * parent[0] == -1
    * parent represents a valid tree.
    * s consists only of lowercase English letters.*/

    private void fn(int u, int p, String s, Map<Character, Stack<Integer>> mp, Set<Integer>[] tree) {
        if (!mp.containsKey(s.charAt(u))) mp.put(s.charAt(u), new Stack<>());
        Stack<Integer> stk = mp.get(s.charAt(u));
        if (!stk.isEmpty()) {
            tree[p].remove(u);
            tree[stk.peek()].add(u);
        }
        stk.push(u);
        Set<Integer> vals = new HashSet(tree[u]);
        for (var v : vals) fn(v, u, s, mp, tree);
        stk.pop();
    }

    private int dfs(int u, int[] ans, Set<Integer>[] tree) {
        ans[u] = 1;
        for (var v : tree[u])
            ans[u] += dfs(v, ans, tree);
        return ans[u];
    }

    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        Set<Integer>[] tree = new Set[n];
        for (int u = 0; u < n; ++u)
            tree[u] = new HashSet<>();
        for (int u = 0; u < n; ++u)
            if (parent[u] != -1) tree[parent[u]].add(u);
        Map<Character, Stack<Integer>> mp = new HashMap<>();
        fn(0, -1, s, mp, tree);
        int[] ans = new int[n];
        dfs(0, ans, tree);
        return ans;
    }


    /*3332. Maximum Points Tourist Can Earn (Medium)
    You are given two integers, n and k, along with two 2D integer arrays,
    stayScore and travelScore. A tourist is visiting a country with n cities,
    where each city is directly connected to every other city. The tourist's
    journey consists of exactly k 0-indexed days, and they can choose any city
    as their starting point. Each day, the tourist has two choices:
    * Stay in the current city: If the tourist stays in their current city curr
      during day i, they will earn stayScore[i][curr] points.
    * Move to another city: If the tourist moves from their current city curr to
      city dest, they will earn travelScore[curr][dest] points.
    Return the maximum possible points the tourist can earn.

    Example 1:
    Input: n = 2, k = 1, stayScore = [[2,3]], travelScore = [[0,2],[1,0]]
    Output: 3
    Explanation: The tourist earns the maximum number of points by starting in
                 city 1 and staying in that city.

    Example 2:
    Input: n = 3, k = 2, stayScore = [[3,4,2],[2,1,2]], travelScore = [[0,2,1],[2,0,4],[3,2,0]]
    Output: 8
    Explanation: The tourist earns the maximum number of points by starting in
                 city 1, staying in that city on day 0, and traveling to city 2
                 on day 1.

    Constraints:
    * 1 <= n <= 200
    * 1 <= k <= 200
    * n == travelScore.length == travelScore[i].length == stayScore[i].length
    * k == stayScore.length
    * 1 <= stayScore[i][j] <= 100
    * 0 <= travelScore[i][j] <= 100
    * travelScore[i][i] == 0*/

    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k+1][n];
        for (int i = k-1; i >= 0; --i)
            for (int j = 0; j < n; ++j)
                for (int jj = 0; jj < n; ++jj) {
                    int cand = 0;
                    if (j == jj) cand = stayScore[i][j] + dp[i+1][j];
                    else cand = travelScore[j][jj] + dp[i+1][jj];
                    dp[i][j] = Math.max(dp[i][j], cand);
                }
        return Arrays.stream(dp[0]).max().getAsInt();
    }


    /*3333. Find the Original Typed String II (Hard)
    Alice is attempting to type a specific string on her computer. However, she
    tends to be clumsy and may press a key for too long, resulting in a
    character being typed multiple times. You are given a string word, which
    represents the final output displayed on Alice's screen. You are also given
    a positive integer k. Return the total number of possible original strings
    that Alice might have intended to type, if she was trying to type a string
    of size at least k. Since the answer may be very large, return it modulo
    10^9 + 7.

    Example 1:
    Input: word = "aabbccdd", k = 7
    Output: 5
    Explanation: The possible strings are: "aabbccdd", "aabbccd", "aabbcdd",
                 "aabccdd", and "abbccdd".

    Example 2:
    Input: word = "aabbccdd", k = 8
    Output: 1
    Explanation: The only possible string is "aabbccdd".

    Example 3:
    Input: word = "aaabbb", k = 3
    Output: 8

    Constraints:
    * 1 <= word.length <= 5 * 10^5
    * word consists only of lowercase English letters.
    * 1 <= k <= 2000*/

    public int possibleStringCount(String word, int k) {
        final int mod = 1_000_000_007;
        List<Integer> vals = new ArrayList<>();
        long total = 1;
        for (int i = 0, cnt = 0, n = word.length(); i < n; ++i) {
            ++cnt;
            if (i == n-1 || word.charAt(i) != word.charAt(i+1)) {
                total = total * cnt % mod;
                vals.add(cnt);
                cnt = 0;
            }
        }
        int n = vals.size();
        if (n >= k) return (int) total;
        long[][] dp = new long[n+1][k];
        for (int j = 0; j < k; ++j)
            dp[n][j] = 1;
        for (int i = n-1; i >= 0; --i) {
            long prefix = 0;
            for (int j = 0; j < k; ++j) {
                dp[i][j] = prefix;
                prefix = (prefix + dp[i+1][j]) % mod;
                if (j >= vals.get(i)) prefix = (mod + (prefix - dp[i+1][j-vals.get(i)]) % mod) % mod;
            }
        }
        return (int) (mod + (total - dp[0][k-1]) % mod) % mod;
    }


    /*3340. Check Balanced String (Easy)
    You are given a string num consisting of only digits. A string of digits is
    called balanced if the sum of the digits at even indices is equal to the sum
    of digits at odd indices. Return true if num is balanced, otherwise return
    false.

    Example 1:
    Input: num = "1234"
    Output: false
    Explanation: The sum of digits at even indices is 1 + 3 == 4, and the sum of
                 digits at odd indices is 2 + 4 == 6. Since 4 is not equal to 6,
                 num is not balanced.

    Example 2:
    Input: num = "24123"
    Output: true
    Explanation: The sum of digits at even indices is 2 + 1 + 3 == 6, and the
                 sum of digits at odd indices is 4 + 2 == 6. Since both are
                 equal the num is balanced.

    Constraints:
    * 2 <= num.length <= 100
    * num consists of digits only*/

    public boolean isBalanced(String num) {
        int bal = 0;
        for (int i = 0; i < num.length(); ++i)
            if (i % 2 == 1) bal += num.charAt(i) - '0';
            else bal -= num.charAt(i) - '0';
        return bal == 0;
    }


    /*3341. Find Minimum Time to Reach Last Room I (Medium)
    There is a dungeon with n x m rooms arranged as a grid. You are given a 2D
    array moveTime of size n x m, where moveTime[i][j] represents the minimum
    time in seconds when you can start moving to that room. You start from the
    room (0, 0) at time t = 0 and can move to an adjacent room. Moving between
    adjacent rooms takes exactly one second. Return the minimum time to reach
    the room (n - 1, m - 1). Two rooms are adjacent if they share a common wall,
    either horizontally or vertically.

    Example 1:
    Input: moveTime = [[0,4],[4,4]]
    Output: 6
    Explanation: The minimum time required is 6 seconds.
                 * At time t == 4, move from room (0, 0) to room (1, 0) in one
                   second.
                 * At time t == 5, move from room (1, 0) to room (1, 1) in one
                   second.

    Example 2:
    Input: moveTime = [[0,0,0],[0,0,0]]
    Output: 3
    Explanation: The minimum time required is 3 seconds.
                 * At time t == 0, move from room (0, 0) to room (1, 0) in one
                   second.
                 * At time t == 1, move from room (1, 0) to room (1, 1) in one
                   second.
                 * At time t == 2, move from room (1, 1) to room (1, 2) in one
                   second.

    Example 3:
    Input: moveTime = [[0,1],[1,2]]
    Output: 3

    Constraints:
    * 2 <= n == moveTime.length <= 50
    * 2 <= m == moveTime[i].length <= 50
    * 0 <= moveTime[i][j] <= 10^9*/

    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        Queue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[0], y[0]));
        pq.add(new int[]{0, 0, 0});
        int[][] dist = new int[n][m];
        for (int i = 0; i < n; ++i)
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        dist[0][0] = 0;
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            int t = elem[0], i = elem[1], j = elem[2];
            if (i == n-1 && j == m-1) return t;
            for (int k = 0; k < 4; ++k) {
                int ii = i+dir[k], jj = j+dir[k+1];
                if (0 <= ii && ii < n && 0 <= jj && jj < m) {
                    int tt = Math.max(t, moveTime[ii][jj]) + 1;
                    if (tt < dist[ii][jj]) {
                        pq.add(new int[]{tt, ii, jj});
                        dist[ii][jj] = tt;
                    }
                }
            }
        }
        return -1;
    }


    /*3342. Find Minimum Time to Reach Last Room II (Medium)
    There is a dungeon with n x m rooms arranged as a grid. You are given a 2D
    array moveTime of size n x m, where moveTime[i][j] represents the minimum
    time in seconds when you can start moving to that room. You start from the
    room (0, 0) at time t = 0 and can move to an adjacent room. Moving between
    adjacent rooms takes one second for one move and two seconds for the next,
    alternating between the two. Return the minimum time to reach the room
    (n - 1, m - 1). Two rooms are adjacent if they share a common wall, either
    horizontally or vertically.

    Example 1:
    Input: moveTime = [[0,4],[4,4]]
    Output: 7
    Explanation: The minimum time required is 7 seconds.
                 * At time t == 4, move from room (0, 0) to room (1, 0) in one
                   second.
                 * At time t == 5, move from room (1, 0) to room (1, 1) in two
                   seconds.

    Example 2:
    Input: moveTime = [[0,0,0,0],[0,0,0,0]]
    Output: 6
    Explanation: The minimum time required is 6 seconds.
                 * At time t == 0, move from room (0, 0) to room (1, 0) in one
                   second.
                 * At time t == 1, move from room (1, 0) to room (1, 1) in two
                   seconds.
                 * At time t == 3, move from room (1, 1) to room (1, 2) in one
                   second.
                 * At time t == 4, move from room (1, 2) to room (1, 3) in two
                   seconds.

    Example 3:
    Input: moveTime = [[0,1],[1,2]]
    Output: 4

    Constraints:
    * 2 <= n == moveTime.length <= 750
    * 2 <= m == moveTime[i].length <= 750
    * 0 <= moveTime[i][j] <= 10^9*/

    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        Queue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[0], y[0]));
        pq.add(new int[]{0, 0, 0, 0});
        int[][][] dist = new int[n][m][2];
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < m; ++j)
                Arrays.fill(dist[i][j], Integer.MAX_VALUE);
        dist[0][0][0] = 0;
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            int t = elem[0], i = elem[1], j = elem[2], s = elem[3];
            if (i == n-1 && j == m-1) return t;
            for (int k = 0; k < 4; ++k) {
                int ii = i+dir[k], jj = j+dir[k+1];
                if (0 <= ii && ii < n && 0 <= jj && jj < m) {
                    int tt = Math.max(t, moveTime[ii][jj]) + s + 1;
                    if (tt < dist[ii][jj][s^1]) {
                        pq.add(new int[]{tt, ii, jj, s^1});
                        dist[ii][jj][s^1] = tt;
                    }
                }
            }
        }
        return -1;
    }


    /*3343. Count Number of Balanced Permutations (Hard)
    You are given a string num. A string of digits is called balanced if the sum
    of the digits at even indices is equal to the sum of the digits at odd
    indices. Return the number of distinct permutations of num that are
    balanced. Since the answer may be very large, return it modulo 10^9 + 7. A
    permutation is a rearrangement of all the characters of a string.

    Example 1:
    Input: num = "123"
    Output: 2
    Explanation: The distinct permutations of num are "123", "132", "213",
                 "231", "312" and "321". Among them, "132" and "231" are
                 balanced. Thus, the answer is 2.

    Example 2:
    Input: num = "112"
    Output: 1
    Explanation: The distinct permutations of num are "112", "121", and "211".
                 Only "121" is balanced. Thus, the answer is 1.

    Example 3:
    Input: num = "12345"
    Output: 0
    Explanation: None of the permutations of num are balanced, so the answer is
                 0.

    Constraints:
    * 2 <= num.length <= 80
    * num consists of digits '0' to '9' only.*/

    private long fn(int v, int odd, int even, int val, int total, int mod, int[] freq, long[][] choose, long[][][][] memo) {
        if (val > total/2) return 0l;
        if (v == 10) return val == total/2 ? 1l : 0l;
        if (memo[v][odd][even][val] == -1) {
            long ans = 0;
            for (int x = Math.max(0, freq[v]-even); x <= freq[v] && x <= odd; ++x) {
                long cand = choose[odd][x] * choose[even][freq[v]-x] % mod * fn(v+1, odd-x, even-freq[v]+x, val + x*v, total, mod, freq, choose, memo) % mod;
                ans = (ans + cand) % mod;
            }
            memo[v][odd][even][val] = ans;
        }
        return memo[v][odd][even][val];
    }

    public int countBalancedPermutations(String num) {
        int total = num.chars().map(ch -> ch - '0').sum();
        if (total % 2 == 1) return 0;
        int[] freq = new int[10];
        for (var ch : num.toCharArray())
            ++freq[ch - '0'];
        final int mod = 1_000_000_007, n = num.length();
        long[][] choose = new long[n+1][n+1];
        for (int x = 0; x <= n; ++x) {
            choose[x][0] = 1;
            for (int k = 1; k <= x; ++k)
                choose[x][k] = (choose[x-1][k-1] + choose[x-1][k]) % mod;
        }
        long[][][][] memo = new long[10][(n+1)/2+1][n/2+1][total/2+1];
        for (int i = 0; i < 10; ++i)
            for (int j = 0; j <= (n+1)/2; ++j)
                for (int k = 0; k <= n/2; ++k)
                    Arrays.fill(memo[i][j][k], -1);
        return (int) fn(0, (n+1)/2, n/2, 0, total, mod, freq, choose, memo);
    }


    /*3349. Adjacent Increasing Subarrays Detection I (Easy)
    Given an array nums of n integers and an integer k, determine whether there
    exist two adjacent subarrays of length k such that both subarrays are
    strictly increasing. Specifically, check if there are two subarrays starting
    at indices a and b (a < b), where:
    * Both subarrays nums[a..a + k - 1] and nums[b..b + k - 1] are strictly
      increasing.
    * The subarrays must be adjacent, meaning b = a + k.
    Return true if it is possible to find two such subarrays, and false
    otherwise.

    Example 1:
    Input: nums = [2,5,7,8,9,2,3,4,3,1], k = 3
    Output: true
    Explanation: * The subarray starting at index 2 is [7, 8, 9], which is
                   strictly increasing.
                 * The subarray starting at index 5 is [2, 3, 4], which is also
                   strictly increasing.
                 * These two subarrays are adjacent, so the result is true.

    Example 2:
    Input: nums = [1,2,3,4,4,4,4,5,6,7], k = 5
    Output: false

    Constraints:
    * 2 <= nums.length <= 100
    * 1 < 2 * k <= nums.length
    * -1000 <= nums[i] <= 1000*/

    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int prev = 0, cnt = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (i > 0 && nums.get(i-1) >= nums.get(i)) {
                prev = cnt;
                cnt = 0;
            }
            ++cnt;
            if (cnt >= 2*k || prev >= k && cnt >= k) return true;
        }
        return false;
    }


    /*3350. Adjacent Increasing Subarrays Detection II (Medium)
    Given an array nums of n integers, your task is to find the maximum value of
    k for which there exist two adjacent subarrays of length k each, such that
    both subarrays are strictly increasing. Specifically, check if there are two
    subarrays of length k starting at indices a and b (a < b), where:
    * Both subarrays nums[a..a + k - 1] and nums[b..b + k - 1] are strictly
      increasing.
    * The subarrays must be adjacent, meaning b = a + k.
    Return the maximum possible value of k. A subarray is a contiguous non-empty
    sequence of elements within an array.

    Example 1:
    Input: nums = [2,5,7,8,9,2,3,4,3,1]
    Output: 3
    Explanation: * The subarray starting at index 2 is [7, 8, 9], which is
                   strictly increasing.
                 * The subarray starting at index 5 is [2, 3, 4], which is also
                   strictly increasing.
                 * These two subarrays are adjacent, and 3 is the maximum
                   possible value of k for which two such adjacent strictly
                   increasing subarrays exist.

    Example 2:
    Input: nums = [1,2,3,4,4,4,4,5,6,7]
    Output: 2
    Explanation: * The subarray starting at index 0 is [1, 2], which is strictly
                   increasing.
                 * The subarray starting at index 2 is [3, 4], which is also
                   strictly increasing.
                 * These two subarrays are adjacent, and 2 is the maximum
                   possible value of k for which two such adjacent strictly
                   increasing subarrays exist.

    Constraints:
    * 2 <= nums.length <= 2 * 10^5
    * -10^9 <= nums[i] <= 10^9*/

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int ans = 0, prev = 0, cnt = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (i > 0 && nums.get(i-1) >= nums.get(i)) {
                prev = cnt;
                cnt = 0;
            }
            ++cnt;
            ans = Math.max(ans, Math.max(cnt/2, Math.min(prev, cnt)));
        }
        return ans;
    }


    /*3351. Sum of Good Subsequences (Hard)
    You are given an integer array nums. A good subsequence is defined as a
    subsequence of nums where the absolute difference between any two
    consecutive elements in the subsequence is exactly 1. Return the sum of all
    possible good subsequences of nums. Since the answer may be very large,
    return it modulo 10^9 + 7. Note that a subsequence of size 1 is considered
    good by definition.

    Example 1:
    Input: nums = [1,2,1]
    Output: 14
    Explanation: Good subsequences are: [1], [2], [1], [1,2], [2,1], [1,2,1].
                 The sum of elements in these subsequences is 14.

    Example 2:
    Input: nums = [3,4,5]
    Output: 40
    Explanation: Good subsequences are: [3], [4], [5], [3,4], [4,5], [3,4,5].
                 The sum of elements in these subsequences is 40.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5*/

    public int sumOfGoodSubsequences(int[] nums) {
        Map<Integer, Long> cnt = new HashMap<>(), val = new HashMap<>();
        final int mod = 1_000_000_007;
        for (var x : nums) {
            long more = (1 + cnt.getOrDefault(x-1, 0l) + cnt.getOrDefault(x+1, 0l)) % mod;
            cnt.put(x, (cnt.getOrDefault(x, 0l) + more) % mod);
            val.put(x, (val.getOrDefault(x-1, 0l) + val.getOrDefault(x, 0l) + val.getOrDefault(x+1, 0l) + more*x) % mod);
        }
        return (int) val.values().stream().mapToLong(i -> i).reduce(0l, (sum, x) -> (sum + x) % mod);
    }


    /*3352. Count K-Reducible Numbers Less Than N (Hard)
    You are given a binary string s representing a number n in its binary form.
    You are also given an integer k. An integer x is called k-reducible if
    performing the following operation at most k times reduces it to 1:
    * Replace x with the count of set bits in its binary representation.
    For example, the binary representation of 6 is "110". Applying the operation
    once reduces it to 2 (since "110" has two set bits). Applying the operation
    again to 2 (binary "10") reduces it to 1 (since "10" has one set bit).
    Return an integer denoting the number of positive integers less than n that
    are k-reducible. Since the answer may be too large, return it modulo
    10^9 + 7.

    Example 1:
    Input: s = "111", k = 1
    Output: 3
    Explanation: n = 7. The 1-reducible integers less than 7 are 1, 2, and 4.

    Example 2:
    Input: s = "1000", k = 2
    Output: 6
    Explanation: n = 8. The 2-reducible integers less than 8 are 1, 2, 3, 4, 5,
                 and 6.

    Example 3:
    Input: s = "1", k = 3
    Output: 0
    Explanation: There are no positive integers less than n = 1, so the answer
                 is 0.

    Constraints:
    * 1 <= s.length <= 800
    * s has no leading zeros.
    * s consists only of the characters '0' and '1'.
    * 1 <= k <= 5*/

    public int countKReducibleNumbers(String s, int k) {
        final int mod = 1_000_000_007, n = s.length();
        int[] dp = new int[n+1];
        for (int x = 2; x <= n; ++x)
            dp[x] = 1 + dp[Integer.bitCount(x)];

        long[] fact = new long[n+1], ifact = new long[n+1], inv = new long[n+1];
        Arrays.fill(fact, 1);
        Arrays.fill(ifact, 1);
        Arrays.fill(inv, 1);
        for (int x = 1; x <= n; ++x) {
            if (x >= 2) inv[x] = mod - mod/x * inv[mod % x] % mod;
            fact[x] = fact[x-1] * x % mod;
            ifact[x] = ifact[x-1] * inv[x] % mod;
        }

        long ans = 0;
        for (int i = 0, prefix = 0; i < s.length(); ++i)
            if (s.charAt(i) == '1') {
                for (int suffix = 0; suffix < n-i; ++suffix)
                    if (prefix + suffix > 0 && dp[prefix + suffix] + 1 <= k)
                        ans = (ans + fact[n-i-1] * ifact[suffix] % mod * ifact[n-1-i-suffix] % mod) % mod;
                ++prefix;
            }
        return (int) ans;
    }


    /*3354. Make Array Elements Equal to Zero (Easy)
    You are given an integer array nums. Start by selecting a starting position
    curr such that nums[curr] == 0, and choose a movement direction of either
    left or right. After that, you repeat the following process:
    * If curr is out of the range [0, n - 1], this process ends.
    * If nums[curr] == 0, move in the current direction by incrementing curr if
      you are moving right, or decrementing curr if you are moving left.
    * Else if nums[curr] > 0:
      + Decrement nums[curr] by 1.
      + Reverse your movement direction (left becomes right and vice versa).
      + Take a step in your new direction.
    A selection of the initial position curr and movement direction is
    considered valid if every element in nums becomes 0 by the end of the
    process. Return the number of possible valid selections.

    Example 1:
    Input: nums = [1,0,2,0,3]
    Output: 2
    Explanation: The only possible valid selections are the following:
                 * Choose curr = 3, and a movement direction to the left.
                   + [1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,1,0,3] -> [1,0,1,0,3] ->
                     [1,0,1,0,2] -> [1,0,1,0,2] -> [1,0,0,0,2] -> [1,0,0,0,2] ->
                     [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] ->
                     [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] ->
                     [0,0,0,0,0].
                 * Choose curr = 3, and a movement direction to the right.
                   + [1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,2,0,2] -> [1,0,2,0,2] ->
                     [1,0,1,0,2] -> [1,0,1,0,2] -> [1,0,1,0,1] -> [1,0,1,0,1] ->
                     [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,0] -> [1,0,0,0,0] ->
                     [1,0,0,0,0] -> [1,0,0,0,0] -> [0,0,0,0,0].

    Example 2:
    Input: nums = [2,3,4,0,4,1,0]
    Output: 0
    Explanation: There are no possible valid selections.

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 100
    * There is at least one element i where nums[i] == 0.*/

    public int countValidSelections(int[] nums) {
        int ans = 0, n = nums.length;
        int[] prefix = new int[n+1];
        for (int i = 0; i < n; ++i)
            prefix[i+1] = prefix[i] + nums[i];
        for (int i = 0; i < n; ++i)
            if (nums[i] == 0)
                if (prefix[n]-2*prefix[i] == 0) ans += 2;
                else if (Math.abs(prefix[n] - 2*prefix[i]) == 1) ++ans;
        return ans;
    }


    /*3355. Zero Array Transformation I (Medium)
    You are given an integer array nums of length n and a 2D array queries,
    where queries[i] = [li, ri]. For each queries[i]:
    * Select a subset of indices within the range [li, ri] in nums.
    * Decrement the values at the selected indices by 1.
    A Zero Array is an array where all elements are equal to 0. Return true if
    it is possible to transform nums into a Zero Array after processing all the
    queries sequentially, otherwise return false. A subset of an array is a
    selection of elements (possibly none) of the array.

    Example 1:
    Input: nums = [1,0,1], queries = [[0,2]]
    Output: true
    Explanation: For i = 0:
                 * Select the subset of indices as [0, 2] and decrement the
                   values at these indices by 1.
                 * The array will become [0, 0, 0], which is a Zero Array.

    Example 2:
    Input: nums = [4,3,2,1], queries = [[1,3],[0,2]]
    Output: false
    Explanation: For i = 0:
                 * Select the subset of indices as [1, 2, 3] and decrement the
                   values at these indices by 1.
                 * The array will become [4, 2, 1, 0].
                 For i = 1:
                 * Select the subset of indices as [0, 1, 2] and decrement the
                   values at these indices by 1.
                 * The array will become [3, 1, 0, 0], which is not a Zero
                   Array.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= li <= ri < nums.length*/

    public boolean isZeroArray(int[] nums, int[][] queries) {
        int n = nums.length, prefix = 0;
        int[] line = new int[n];
        for (var q : queries) {
            int l = q[0], r = q[1];
            ++line[l];
            if (r+1 < n) --line[r+1];
        }
        for (int i = 0; i < n; ++i) {
            prefix += line[i];
            if (prefix < nums[i]) return false;
        }
        return true;
    }


    /*3356. Zero Array Transformation II (Medium)
    You are given an integer array nums of length n and a 2D array queries where
    queries[i] = [li, ri, vali]. Each queries[i] represents the following action
    on nums:
    * Decrement the value at each index in the range [li, ri] in nums by at most
      vali.
    * The amount by which each value is decremented can be chosen independently
      for each index.
    A Zero Array is an array with all its elements equal to 0. Return the
    minimum possible non-negative value of k, such that after processing the
    first k queries in sequence, nums becomes a Zero Array. If no such k exists,
    return -1.

    Example 1:
    Input: nums = [2,0,2], queries = [[0,2,1],[0,2,1],[1,1,3]]
    Output: 2
    Explanation: For i = 0 (l = 0, r = 2, val = 1):
                 * Decrement values at indices [0, 1, 2] by [1, 0, 1]
                   respectively.
                 * The array will become [1, 0, 1].
                 For i = 1 (l = 0, r = 2, val = 1):
                 * Decrement values at indices [0, 1, 2] by [1, 0, 1]
                   respectively.
                 * The array will become [0, 0, 0], which is a Zero Array.
                   Therefore, the minimum value of k is 2.

    Example 2:
    Input: nums = [4,3,2,1], queries = [[1,3,2],[0,2,1]]
    Output: -1
    Explanation: For i = 0 (l = 1, r = 3, val = 2):
                 * Decrement values at indices [1, 2, 3] by [2, 2, 1]
                   respectively.
                 * The array will become [4, 1, 0, 0].
                 For i = 1 (l = 0, r = 2, val = 1):
                 * Decrement values at indices [0, 1, 2] by [1, 1, 0]
                   respectively.
                 * The array will become [3, 0, 0, 0], which is not a Zero
                   Array.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 5 * 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 3
    * 0 <= li <= ri < nums.length
    * 1 <= vali <= 5*/

    public int minZeroArray(int[] nums, int[][] queries) {
        int n = nums.length;
        int[] line = new int[n+1];
        int j = 0;
        for (int i = 0, prefix = 0; i < n; ++i) {
            prefix += line[i];
            for (; prefix < nums[i] && j < queries.length; ++j) {
                int l = queries[j][0], r = queries[j][1], v = queries[j][2];
                if (i <= r) {
                    line[r+1] -= v;
                    if (l <= i) prefix += v;
                    else line[l] += v;
                }
            }
            if (prefix < nums[i]) return -1;
        }
        return j;
    }


    /*3357. Minimize the Maximum Adjacent Element Difference (Hard)
    You are given an array of integers nums. Some values in nums are missing and
    are denoted by -1. You can choose a pair of positive integers (x, y) exactly
    once and replace each missing element with either x or y. You need to
    minimize the maximum absolute difference between adjacent elements of nums
    after replacements. Return the minimum possible difference.

    Example 1:
    Input: nums = [1,2,-1,10,8]
    Output: 4
    Explanation: By choosing the pair as (6, 7), nums can be changed to
                 [1, 2, 6, 10, 8]. The absolute differences between adjacent
                 elements are:
                 * |1 - 2| == 1
                 * |2 - 6| == 4
                 * |6 - 10| == 4
                 * |10 - 8| == 2

    Example 2:
    Input: nums = [-1,-1,-1]
    Output: 0
    Explanation: By choosing the pair as (4, 4), nums can be changed to
                 [4, 4, 4].

    Example 3:
    Input: nums = [-1,10,-1,8]
    Output: 1
    Explanation: By choosing the pair as (11, 9), nums can be changed to
                 [11, 10, 9, 8].

    Constraints:
    * 2 <= nums.length <= 10^5
    * nums[i] is either -1 or in the range [1, 10^9].*/

    public int minDifference(int[] nums) {
        int n = nums.length, diff = 0, lo = Integer.MAX_VALUE, hi = 0;
        for (int i = 1; i < n; ++i) {
            if (nums[i-1] > 0 && nums[i] > 0) diff = Math.max(diff, Math.abs(nums[i-1]-nums[i]));
            else if (nums[i-1] > 0 || nums[i] > 0) {
                int cand = Math.max(nums[i-1], nums[i]);
                lo = Math.min(lo, cand);
                hi = Math.max(hi, cand);
            }
        }
        int ans = 0, cnt = 0, prev = 0, span = (hi-lo+2)/3;
        for (int i = 0; i < n; ++i) {
            if (nums[i] == -1) ++cnt;
            if (cnt > 0 && (i == n-1 || nums[i] != -1)) {
                int x = Integer.MAX_VALUE, y = 0;
                if (prev > 0) {
                    x = Math.min(x, prev);
                    y = Math.max(y, prev);
                }
                if (nums[i] > 0) {
                    x = Math.min(x, nums[i]);
                    y = Math.max(y, nums[i]);
                }
                int cand = Math.min(hi-x, y-lo);
                if (cnt > 1) cand = Math.min(cand, 2*span);
                ans = Math.max(ans, cand);
                cnt = 0;
            }
            if (nums[i] != -1) prev = nums[i];
        }
        return Math.max(diff, (ans+1)/2);
    }


    /*3360. Stone Removal Game (Easy)
    Alice and Bob are playing a game where they take turns removing stones from
    a pile, with Alice going first.
    * Alice starts by removing exactly 10 stones on her first turn.
    * For each subsequent turn, each player removes exactly 1 fewer stone than
      the previous opponent.
    The player who cannot make a move loses the game. Given a positive integer
    n, return true if Alice wins the game and false otherwise.

    Example 1:
    Input: n = 12
    Output: true
    Explanation: * Alice removes 10 stones on her first turn, leaving 2 stones
                   for Bob.
                 * Bob cannot remove 9 stones, so Alice wins.
    Example 2:
    Input: n = 1
    Output: false
    Explanation: Alice cannot remove 10 stones, so Alice loses.

    Constraints: 1 <= n <= 50*/

    public boolean canAliceWin(int n) {
        for (int i = 10; i > 0; --i) {
            if (i > n) return i % 2 == 1;
            n -= i;
        }
        return true;
    }


    /*3361. Shift Distance Between Two Strings (Medium)
    You are given two strings s and t of the same length, and two integer arrays
    nextCost and previousCost. In one operation, you can pick any index i of s,
    and perform either one of the following actions:
    * Shift s[i] to the next letter in the alphabet. If s[i] == 'z', you should
      replace it with 'a'. This operation costs nextCost[j] where j is the index
      of s[i] in the alphabet.
    * Shift s[i] to the previous letter in the alphabet. If s[i] == 'a', you
      should replace it with 'z'. This operation costs previousCost[j] where j
      is the index of s[i] in the alphabet.
    The shift distance is the minimum total cost of operations required to
    transform s into t. Return the shift distance from s to t.

    Example 1:
    Input: s = "abab",
           t = "baba",
           nextCost = [100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
           previousCost = [1,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    Output: 2
    Explanation: * We choose index i = 0 and shift s[0] 25 times to the previous
                   character for a total cost of 1.
                 * We choose index i = 1 and shift s[1] 25 times to the next
                   character for a total cost of 0.
                 * We choose index i = 2 and shift s[2] 25 times to the previous
                   character for a total cost of 1.
                 * We choose index i = 3 and shift s[3] 25 times to the next
                   character for a total cost of 0.

    Example 2:
    Input: s = "leet",
           t = "code",
           nextCost = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
           previousCost = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    Output: 31
    Explanation: * We choose index i = 0 and shift s[0] 9 times to the previous
                   character for a total cost of 9.
                 * We choose index i = 1 and shift s[1] 10 times to the next
                   character for a total cost of 10.
                 * We choose index i = 2 and shift s[2] 1 time to the previous
                   character for a total cost of 1.
                 * We choose index i = 3 and shift s[3] 11 times to the next
                   character for a total cost of 11.

    Constraints:
    * 1 <= s.length == t.length <= 10^5
    * s and t consist only of lowercase English letters.
    * nextCost.length == previousCost.length == 26
    * 0 <= nextCost[i], previousCost[i] <= 10^9*/

    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long[] nextPref = new long[27], prevPref = new long[27];
        for (int i = 0; i < 26; ++i) {
            nextPref[i+1] = nextPref[i] + nextCost[i];
            prevPref[i+1] = prevPref[i] + previousCost[i];
        }
        long ans = 0;
        for (int i = 0; i < s.length(); ++i) {
            int si = s.charAt(i) - 'a', ti = t.charAt(i) - 'a';
            if (si < ti)
                ans += Math.min(nextPref[ti] - nextPref[si], prevPref[26] - (prevPref[ti+1] - prevPref[si+1]));
            else
                ans += Math.min(prevPref[si+1] - prevPref[ti+1], nextPref[26] - (nextPref[si] - nextPref[ti]));
        }
        return ans;
    }


    /*3362. Zero Array Transformation III (Medium)
    You are given an integer array nums of length n and a 2D array queries where
    queries[i] = [li, ri]. Each queries[i] represents the following action on
    nums:
    * Decrement the value at each index in the range [li, ri] in nums by at most
      1.
    * The amount by which the value is decremented can be chosen independently
      for each index.
    A Zero Array is an array with all its elements equal to 0. Return the
    maximum number of elements that can be removed from queries, such that nums
    can still be converted to a zero array using the remaining queries. If it is
    not possible to convert nums to a zero array, return -1.

    Example 1:
    Input: nums = [2,0,2], queries = [[0,2],[0,2],[1,1]]
    Output: 1
    Explanation: After removing queries[2], nums can still be converted to a
                 zero array.
                 * Using queries[0], decrement nums[0] and nums[2] by 1 and
                   nums[1] by 0.
                 * Using queries[1], decrement nums[0] and nums[2] by 1 and
                   nums[1] by 0.

    Example 2:
    Input: nums = [1,1,1,1], queries = [[1,3],[0,2],[1,3],[1,2]]
    Output: 2
    Explanation: We can remove queries[2] and queries[3].

    Example 3:
    Input: nums = [1,2,3,4], queries = [[0,3]]
    Output: -1
    Explanation: nums cannot be converted to a zero array even after using all
                 the queries.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5
    * 1 <= queries.length <= 10^5
    * queries[i].length == 2
    * 0 <= li <= ri < nums.length*/

    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (x, y) -> x[0] != y[0] ? Integer.compare(x[0], y[0]) : Integer.compare(x[1], y[1]));
        int ans = queries.length, n = nums.length;
        Queue<Integer> pq = new PriorityQueue<>((x, y) -> Integer.compare(y, x));
        int[] line = new int[n+1];
        for (int i = 0, j = 0, prefix = 0; i < n; ++i) {
            while (j < queries.length && queries[j][0] <= i) {
                pq.add(queries[j][1]);
                ++j;
            }
            prefix += line[i];
            while (prefix < nums[i] && !pq.isEmpty()) {
                int r = pq.poll();
                if (r >= i) {
                    --ans;
                    ++prefix;
                    --line[r+1];
                }
            }
            if (prefix < nums[i]) return -1;
        }
        return ans;
    }


    /*3363. Find the Maximum Number of Fruits Collected (Hard)
    There is a game dungeon comprised of n x n rooms arranged in a grid. You are
    given a 2D array fruits of size n x n, where fruits[i][j] represents the
    number of fruits in the room (i, j). Three children will play in the game
    dungeon, with initial positions at the corner rooms (0, 0), (0, n - 1), and
    (n - 1, 0). The children will make exactly n - 1 moves according to the
    following rules to reach the room (n - 1, n - 1):
    * The child starting from (0, 0) must move from their current room (i, j) to
      one of the rooms (i + 1, j + 1), (i + 1, j), and (i, j + 1) if the target
      room exists.
    * The child starting from (0, n - 1) must move from their current room
      (i, j) to one of the rooms (i + 1, j - 1), (i + 1, j), and (i + 1, j + 1)
      if the target room exists.
    * The child starting from (n - 1, 0) must move from their current room
      (i, j) to one of the rooms (i - 1, j + 1), (i, j + 1), and (i + 1, j + 1)
      if the target room exists.
    When a child enters a room, they will collect all the fruits there. If two
    or more children enter the same room, only one child will collect the
    fruits, and the room will be emptied after they leave. Return the maximum
    number of fruits the children can collect from the dungeon.

    Example 1:
    Input: fruits = [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]
    Output: 100
    Explanation: In this example:
                 * The 1st child (green) moves on the path (0,0) -> (1,1) ->
                   (2,2) -> (3, 3).
                 * The 2nd child (red) moves on the path (0,3) -> (1,2) ->
                   (2,3) -> (3, 3).
                 * The 3rd child (blue) moves on the path (3,0) -> (3,1) ->
                   (3,2) -> (3, 3).
                 In total they collect 1 + 6 + 11 + 16 + 4 + 8 + 12 + 13 + 14 +
                 15 = 100 fruits.

    Example 2:
    Input: fruits = [[1,1],[1,1]]
    Output: 4
    Explanation: In this example:
                 * The 1st child moves on the path (0,0) -> (1,1).
                 * The 2nd child moves on the path (0,1) -> (1,1).
                 * The 3rd child moves on the path (1,0) -> (1,1).
                 In total they collect 1 + 1 + 1 + 1 = 4 fruits.

    Constraints:
    * 2 <= n == fruits.length == fruits[i].length <= 1000
    * 0 <= fruits[i][j] <= 1000*/

    public int maxCollectedFruits(int[][] fruits) {
        int diag = 0, lower = 0, upper = 0, n = fruits.length;
        for (int i = 0; i < n; ++i) {
            diag += fruits[i][i];
            for (int j = Math.max(i+1, n-1-i); j < n; ++j) {
                if (i > 0) {
                    int cand = 0;
                    for (int jj = Math.max(j-1, n-i); jj <= j+1 && jj < n; ++jj)
                        cand = Math.max(cand, fruits[i-1][jj]);
                    fruits[i][j] += cand;
                }
                upper = Math.max(upper, fruits[i][j]);
            }
        }
        for (int j = 0; j < n; ++j)
            for (int i = Math.max(j+1, n-1-j); i < n; ++i) {
                if (j > 0) {
                    int cand = 0;
                    for (int ii = Math.max(i-1, n-j); ii <= i+1 && ii < n; ++ii)
                        cand = Math.max(cand, fruits[ii][j-1]);
                    fruits[i][j] += cand;
                }
                lower = Math.max(lower, fruits[i][j]);
            }
        return diag + lower + upper;
    }


    /*3364. Minimum Positive Sum Subarray (Easy)
    You are given an integer array nums and two integers l and r. Your task is
    to find the minimum sum of a subarray whose size is between l and r
    (inclusive) and whose sum is greater than 0. Return the minimum sum of such
    a subarray. If no such subarray exists, return -1. A subarray is a
    contiguous non-empty sequence of elements within an array.

    Example 1:
    Input: nums = [3, -2, 1, 4], l = 2, r = 3
    Output: 1
    Explanation: The subarrays of length between l = 2 and r = 3 where the sum
                 is greater than 0 are:
                 * [3, -2] with a sum of 1
                 * [1, 4] with a sum of 5
                 * [3, -2, 1] with a sum of 2
                 * [-2, 1, 4] with a sum of 3
                 Out of these, the subarray [3, -2] has a sum of 1, which is the
                 smallest positive sum. Hence, the answer is 1.

    Example 2:
    Input: nums = [-2, 2, -3, 1], l = 2, r = 3
    Output: -1
    Explanation: There is no subarray of length between l and r that has a sum
                 greater than 0. So, the answer is -1.

    Example 3:
    Input: nums = [1, 2, 3, 4], l = 2, r = 4
    Output: 3
    Explanation: The subarray [1, 2] has a length of 2 and the minimum sum
                 greater than 0. So, the answer is 3.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= l <= r <= nums.length
    * -1000 <= nums[i] <= 1000*/

    public int minimumSumSubarray(List<Integer> nums, int l, int r) {
        int ans = Integer.MAX_VALUE, n = nums.size();
        int[] prefix = new int[n+1];
        for (int i = 0; i < n; ++i)
            prefix[i+1] = prefix[i] + nums.get(i);
        TreeMap<Integer, Integer> tm = new TreeMap<>();
        for (int i = 0; i < n; ++i) {
            if (i >= l-1) tm.merge(prefix[i-l+1], 1, Integer::sum);
            if (i >= r) {
                tm.merge(prefix[i-r], -1, Integer::sum);
                if (tm.get(prefix[i-r]) == 0) tm.remove(prefix[i-r]);
            }
            Integer v = tm.floorKey(prefix[i+1]-1);
            if (v != null) ans = Math.min(ans, prefix[i+1] - v);
        }
        return ans < Integer.MAX_VALUE ? ans : -1;
    }


    /*3365. Rearrange K Substrings to Form Target String (Medium)
    You are given two strings s and t, both of which are anagrams of each other,
    and an integer k. Your task is to determine whether it is possible to split
    the string s into k equal-sized substrings, rearrange the substrings, and
    concatenate them in any order to create a new string that matches the given
    string t. Return true if this is possible, otherwise, return false. An
    anagram is a word or phrase formed by rearranging the letters of a different
    word or phrase, using all the original letters exactly once. A substring is
    a contiguous non-empty sequence of characters within a string.

    Example 1:
    Input: s = "abcd", t = "cdab", k = 2
    Output: true
    Explanation: Split s into 2 substrings of length 2: ["ab", "cd"].
                 Rearranging these substrings as ["cd", "ab"], and then
                 concatenating them results in "cdab", which matches t.

    Example 2:
    Input: s = "aabbcc", t = "bbaacc", k = 3
    Output: true
    Explanation: Split s into 3 substrings of length 2: ["aa", "bb", "cc"].
                 Rearranging these substrings as ["bb", "aa", "cc"], and then
                 concatenating them results in "bbaacc", which matches t.

    Example 3:
    Input: s = "aabbcc", t = "bbaacc", k = 2
    Output: false
    Explanation: Split s into 2 substrings of length 3: ["aab", "bcc"]. These
                 substrings cannot be rearranged to form t = "bbaacc", so the
                 output is false.

    Constraints:
    * 1 <= s.length == t.length <= 2 * 10^5
    * 1 <= k <= s.length
    * s.length is divisible by k.
    * s and t consist only of lowercase English letters.
    * The input is generated such that s and t are anagrams of each other.*/

    public boolean isPossibleToRearrange(String s, String t, int k) {
        int n = s.length();
        k = n/k;
        Map<String, Integer> freq = new HashMap<>();
        for (int i = 0; i < n; i += k) {
            freq.merge(s.substring(i, i+k), 1, Integer::sum);
            freq.merge(t.substring(i, i+k), -1, Integer::sum);
        }
        return freq.values().stream().allMatch(x -> x == 0);
    }


    /*3366. Minimum Array Sum (Medium)
    You are given an integer array nums and three integers k, op1, and op2. You
    can perform the following operations on nums:
    * Operation 1: Choose an index i and divide nums[i] by 2, rounding up to the
                   nearest whole number. You can perform this operation at most
                   op1 times, and not more than once per index.
    * Operation 2: Choose an index i and subtract k from nums[i], but only if
                   nums[i] is greater than or equal to k. You can perform this
                   operation at most op2 times, and not more than once per
                   index.
    Note: Both operations can be applied to the same index, but at most once
    each. Return the minimum possible sum of all elements in nums after
    performing any number of operations.

    Example 1:
    Input: nums = [2,8,3,19,3], k = 3, op1 = 1, op2 = 1
    Output: 23
    Explanation: * Apply Operation 2 to nums[1] = 8, making nums[1] = 5.
                 * Apply Operation 1 to nums[3] = 19, making nums[3] = 10.
                 * The resulting array becomes [2, 5, 3, 10, 3], which has the
                   minimum possible sum of 23 after applying the operations.

    Example 2:
    Input: nums = [2,4,3], k = 3, op1 = 2, op2 = 1
    Output: 3
    Explanation: * Apply Operation 1 to nums[0] = 2, making nums[0] = 1.
                 * Apply Operation 1 to nums[1] = 4, making nums[1] = 2.
                 * Apply Operation 2 to nums[2] = 3, making nums[2] = 0.
                 * The resulting array becomes [1, 2, 0], which has the minimum
                   possible sum of 3 after applying the operations.

    Constraints:
    * 1 <= nums.length <= 100
    * 0 <= nums[i] <= 10^5
    * 0 <= k <= 10^5
    * 0 <= op1, op2 <= nums.length*/

    public int minArraySum(int[] nums, int v, int op1, int op2) {
        int n = nums.length;
        int[][][] dp = new int[n+1][op1+1][op2+1];
        for (int i = n-1; i >= 0; --i)
            for (int j = 0; j <= op1; ++j)
                for (int k = 0; k <= op2; ++k) {
                    dp[i][j][k] = nums[i] + dp[i+1][j][k];
                    if (j > 0) dp[i][j][k] = Math.min(dp[i][j][k], (nums[i]+1)/2 + dp[i+1][j-1][k]);
                    if (k > 0 && nums[i] >= v) dp[i][j][k] = Math.min(dp[i][j][k], nums[i]-v + dp[i+1][j][k-1]);
                    if (j > 0 && k > 0 && (nums[i]+1)/2 >= v) dp[i][j][k] = Math.min(dp[i][j][k], (nums[i]+1)/2-v + dp[i+1][j-1][k-1]);
                    if (j > 0 && k > 0 && nums[i] >= v) dp[i][j][k] = Math.min(dp[i][j][k], (nums[i]-v+1)/2 + dp[i+1][j-1][k-1]);
                }
        return dp[0][op1][op2];
    }


    /*3367. Maximize Sum of Weights after Edge Removals (Hard)
    There exists an undirected tree with n nodes numbered 0 to n - 1. You are
    given a 2D integer array edges of length n - 1, where
    edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui and
    vi with weight wi in the tree. Your task is to remove zero or more edges
    such that:
    * Each node has an edge with at most k other nodes, where k is given.
    * The sum of the weights of the remaining edges is maximized.
    Return the maximum possible sum of weights for the remaining edges after
    making the necessary removals.

    Example 1:
    Input: edges = [[0,1,4],[0,2,2],[2,3,12],[2,4,6]], k = 2
    Output: 22
    Explanation: Node 2 has edges with 3 other nodes. We remove the edge
                 [0, 2, 2], ensuring that no node has edges with more than k = 2
                 nodes. The sum of weights is 22, and we can't achieve a greater
                 sum. Thus, the answer is 22.

    Example 2:
    Input: edges = [[0,1,5],[1,2,10],[0,3,15],[3,4,20],[3,5,5],[0,6,10]], k = 3
    Output: 65
    Explanation: Since no node has edges connecting it to more than k = 3 nodes,
                 we don't remove any edges. The sum of weights is 65. Thus, the
                 answer is 65.

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= k <= n - 1
    * edges.length == n - 1
    * edges[i].length == 3
    * 0 <= edges[i][0] <= n - 1
    * 0 <= edges[i][1] <= n - 1
    * 1 <= edges[i][2] <= 10^6
    * The input is generated such that edges form a valid tree.*/

    private long[] fn(int u, int p, List<int[]>[] tree, int k) {
        long ans = 0;
        List<Long> diff = new ArrayList<>();
        for (var elem : tree[u]) {
            int v = elem[0], w = elem[1];
            if (v != p) {
                var val = fn(v, u, tree, k);
                ans += val[0];
                diff.add(Math.max(0, w + val[1] - val[0]));
            }
        }
        Collections.sort(diff, (x, y) -> Long.compare(y, x));
        for (int i = 0; i < k && i < diff.size(); ++i)
            ans += diff.get(i);
        return new long[]{ans, ans - (diff.size() >= k ? diff.get(k-1) : 0)};
    }

    public long maximizeSumOfWeights(int[][] edges, int k) {
        int n = edges.length+1;
        List<int[]>[] tree = new List[n];
        for (int i = 0; i < n; ++i)
            tree[i] = new ArrayList<>();
        for (var e : edges) {
            int u = e[0], v = e[1], w = e[2];
            tree[u].add(new int[]{v, w});
            tree[v].add(new int[]{u, w});
        }
        return fn(0, -1, tree, k)[0];
    }


    /*3370. Smallest Number With All Set Bits (Easy)
    You are given a positive number n. Return the smallest number x greater than
    or equal to n, such that the binary representation of x contains only set
    bits. A set bit refers to a bit in the binary representation of a number
    that has a value of 1.

    Example 1:
    Input: n = 5
    Output: 7
    Explanation: The binary representation of 7 is "111".

    Example 2:
    Input: n = 10
    Output: 15
    Explanation: The binary representation of 15 is "1111".

    Example 3:
    Input: n = 3
    Output: 3
    Explanation: The binary representation of 3 is "11".

    Constraints: 1 <= n <= 1000*/

    public int smallestNumber(int n) {
        int sz = (int) (Math.log(n)/Math.log(2)) + 1;
        return (1 << sz) - 1;
    }


    /*3371. Identify the Largest Outlier in an Array (Medium)
    You are given an integer array nums. This array contains n elements, where
    exactly n - 2 elements are special numbers. One of the remaining two
    elements is the sum of these special numbers, and the other is an outlier.
    An outlier is defined as a number that is neither one of the original
    special numbers nor the element representing the sum of those numbers. Note
    that special numbers, the sum element, and the outlier must have distinct
    indices, but may share the same value. Return the largest potential outlier
    in nums.

    Example 1:
    Input: nums = [2,3,5,10]
    Output: 10
    Explanation: The special numbers could be 2 and 3, thus making their sum 5
                 and the outlier 10.

    Example 2:
    Input: nums = [-2,-1,-3,-6,4]
    Output: 4
    Explanation: The special numbers could be -2, -1, and -3, thus making their
                 sum -6 and the outlier 4.

    Example 3:
    Input: nums = [1,1,1,1,1,5,5]
    Output: 5
    Explanation: The special numbers could be 1, 1, 1, 1, and 1, thus making
                 their sum 5 and the other 5 as the outlier.

    Constraints:
    * 3 <= nums.length <= 10^5
    * -1000 <= nums[i] <= 1000
    * The input is generated such that at least one potential outlier exists in
      nums.*/

    public int getLargestOutlier(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (var x : nums)
            freq.merge(x, 1, Integer::sum);
        int ans = Integer.MIN_VALUE, total = IntStream.of(nums).sum();
        for (var x : nums) {
            int cand = total - x;
            if ((cand & 1) == 0) {
                cand >>= 1;
                if (freq.getOrDefault(cand, 0) > 0 && (x != cand || freq.get(cand) >= 2)) ans = Math.max(ans, x);
            }
        }
        return ans;
    }


    /*3372. Maximize the Number of Target Nodes After Connecting Trees I (Medium)
    There exist two undirected trees with n and m nodes, with distinct labels in
    ranges [0, n - 1] and [0, m - 1], respectively. You are given two 2D integer
    arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where
    edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi
    in the first tree and edges2[i] = [ui, vi] indicates that there is an edge
    between nodes ui and vi in the second tree. You are also given an integer k.
    Node u is target to node v if the number of edges on the path from u to v is
    less than or equal to k. Note that a node is always target to itself. Return
    an array of n integers answer, where answer[i] is the maximum possible
    number of nodes target to node i of the first tree if you have to connect
    one node from the first tree to another node in the second tree. Note that
    queries are independent from each other. That is, for every query you will
    remove the added edge before proceeding to the next query.

    Example 1:
    Input: edges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]], k = 2
    Output: [9,7,9,8,8]
    Explanation: * For i = 0, connect node 0 from the first tree to node 0 from
                   the second tree.
                 * For i = 1, connect node 1 from the first tree to node 0 from
                   the second tree.
                 * For i = 2, connect node 2 from the first tree to node 4 from
                   the second tree.
                 * For i = 3, connect node 3 from the first tree to node 4 from
                   the second tree.
                 * For i = 4, connect node 4 from the first tree to node 4 from
                   the second tree.

    Example 2:
    Input: edges1 = [[0,1],[0,2],[0,3],[0,4]], edges2 = [[0,1],[1,2],[2,3]], k = 1
    Output: [6,3,3,3,3]
    Explanation: For every i, connect node i of the first tree with any node of
                 the second tree.

    Constraints:
    * 2 <= n, m <= 1000
    * edges1.length == n - 1
    * edges2.length == m - 1
    * edges1[i].length == edges2[i].length == 2
    * edges1[i] = [ai, bi]
    * 0 <= ai, bi < n
    * edges2[i] = [ui, vi]
    * 0 <= ui, vi < m
    * The input is generated such that edges1 and edges2 represent valid trees.
    * 0 <= k <= 1000*/

    private int[] fn(int[][] edges, int k) {
        int n = edges.length + 1;
        List<Integer>[] tree = new List[n];
        for (int u = 0; u < n; ++u)
            tree[u] = new ArrayList<>();
        for (var e : edges) {
            int u = e[0], v = e[1];
            tree[u].add(v);
            tree[v].add(u);
        }
        int[] ans = new int[n];
        for (int x = 0; x < n; ++x) {
            Stack<int[]> stk = new Stack<>();
            if (0 <= k) stk.push(new int[]{x, -1, 0});
            while (!stk.isEmpty()) {
                var elem = stk.pop();
                int u = elem[0], p = elem[1], d = elem[2];
                ++ans[x];
                for (var v : tree[u])
                    if (v != p && d+1 <= k)
                        stk.push(new int[]{v, u, d+1});
            }
        }
        return ans;
    }

    public int[] maxTargetNodes(int[][] edges1, int[][] edges2, int k) {
        int most = IntStream.of(fn(edges2, k-1)).max().getAsInt();
        return IntStream.of(fn(edges1, k)).map(x -> x + most).toArray();
    }


    /*3373. Maximize the Number of Target Nodes After Connecting Trees II (Hard)
    There exist two undirected trees with n and m nodes, labeled from [0, n - 1]
    and [0, m - 1], respectively. You are given two 2D integer arrays edges1 and
    edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi]
    indicates that there is an edge between nodes ai and bi in the first tree
    and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui
    and vi in the second tree. Node u is target to node v if the number of edges
    on the path from u to v is even. Note that a node is always target to itself.
    Return an array of n integers answer, where answer[i] is the maximum
    possible number of nodes that are target to node i of the first tree if you
    had to connect one node from the first tree to another node in the second
    tree. Note that queries are independent from each other. That is, for every
    query you will remove the added edge before proceeding to the next query.

    Example 1:
    Input: edges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]]
    Output: [8,7,7,8,8]
    Explanation: * For i = 0, connect node 0 from the first tree to node 0 from
                   the second tree.
                 * For i = 1, connect node 1 from the first tree to node 4 from
                   the second tree.
                 * For i = 2, connect node 2 from the first tree to node 7 from
                   the second tree.
                 * For i = 3, connect node 3 from the first tree to node 0 from
                   the second tree.
                 * For i = 4, connect node 4 from the first tree to node 4 from
                   the second tree.

    Example 2:
    Input: edges1 = [[0,1],[0,2],[0,3],[0,4]], edges2 = [[0,1],[1,2],[2,3]]
    Output: [3,6,6,6,6]
    Explanation: For every i, connect node i of the first tree with any node of
                 the second tree.

    Constraints:
    * 2 <= n, m <= 10^5
    * edges1.length == n - 1
    * edges2.length == m - 1
    * edges1[i].length == edges2[i].length == 2
    * edges1[i] = [ai, bi]
    * 0 <= ai, bi < n
    * edges2[i] = [ui, vi]
    * 0 <= ui, vi < m
    * The input is generated such that edges1 and edges2 represent valid trees.*/

    private int[] fn(int[][] edges, int k) {
        int n = edges.length + 1;
        List<Integer>[] tree = new List[n];
        for (int u = 0; u < n; ++u)
            tree[u] = new ArrayList<>();
        for (var e : edges) {
            int u = e[0], v = e[1];
            tree[u].add(v);
            tree[v].add(u);
        }
        int[] ans = new int[n];
        for (int x = 0; x < n; ++x) {
            Stack<int[]> stk = new Stack<>();
            if (0 <= k) stk.push(new int[]{x, -1, 0});
            while (!stk.isEmpty()) {
                var elem = stk.pop();
                int u = elem[0], p = elem[1], d = elem[2];
                ++ans[x];
                for (var v : tree[u])
                    if (v != p && d+1 <= k)
                        stk.push(new int[]{v, u, d+1});
            }
        }
        return ans;
    }

    public int[] maxTargetNodes(int[][] edges1, int[][] edges2, int k) {
        int most = IntStream.of(fn(edges2, k-1)).max().getAsInt();
        return IntStream.of(fn(edges1, k)).map(x -> x + most).toArray();
    }


    /*3375. Minimum Operations to Make Array Values Equal to K (Easy)
    You are given an integer array nums and an integer k. An integer h is called
    valid if all values in the array that are strictly greater than h are
    identical. For example, if nums = [10, 8, 10, 8], a valid integer is h = 9
    because all nums[i] > 9 are equal to 10, but 5 is not a valid integer. You
    are allowed to perform the following operation on nums:
    * Select an integer h that is valid for the current values in nums.
    * For each index i where nums[i] > h, set nums[i] to h.
    Return the minimum number of operations required to make every element in
    nums equal to k. If it is impossible to make all elements equal to k, return
    -1.

    Example 1:
    Input: nums = [5,2,5,4,5], k = 2
    Output: 2
    Explanation: The operations can be performed in order using valid integers 4
                 and then 2.

    Example 2:
    Input: nums = [2,1,2], k = 2
    Output: -1
    Explanation: It is impossible to make all the values equal to 2.

    Example 3:
    Input: nums = [9,7,5,3], k = 1
    Output: 4
    Explanation: The operations can be performed using valid integers in the
                 order 7, 5, 3, and 1.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100
    * 1 <= k <= 100*/

    public int minOperations(int[] nums, int k) {
        Set<Integer> seen = Arrays.stream(nums).boxed().collect(Collectors.toSet());
        int lo = seen.stream().min(Integer::compareTo).orElse(-1);
        return lo < k ? -1 : seen.size() - (lo == k ? 1 : 0);
    }


    /*3376. Minimum Time to Break Locks I (Medium)
    Bob is stuck in a dungeon and must break n locks, each requiring some amount
    of energy to break. The required energy for each lock is stored in an array
    called strength where strength[i] indicates the energy needed to break the
    ith lock. To break a lock, Bob uses a sword with the following
    characteristics:
    * The initial energy of the sword is 0.
    * The initial factor X by which the energy of the sword increases is 1.
    * Every minute, the energy of the sword increases by the current factor X.
    * To break the ith lock, the energy of the sword must reach at least
      strength[i].
    * After breaking a lock, the energy of the sword resets to 0, and the factor
      X increases by a given value K.
    Your task is to determine the minimum time in minutes required for Bob to
    break all n locks and escape the dungeon. Return the minimum time required
    for Bob to break all n locks.

    Example 1:
    Input: strength = [3,4,1], K = 1
    Output: 4
    Explanation: Time    Energy  X   Action  Updated X
                 0   0   1   Nothing 1
                 1   1   1   Break 3rd Lock  2
                 2   2   2   Nothing 2
                 3   4   2   Break 2nd Lock  3
                 4   3   3   Break 1st Lock  3
                 The locks cannot be broken in less than 4 minutes; thus, the
                 answer is 4.

    Example 2:
    Input: strength = [2,5,4], K = 2
    Output: 5
    Explanation: Time    Energy  X   Action  Updated X
                 0   0   1   Nothing 1
                 1   1   1   Nothing 1
                 2   2   1   Break 1st Lock  3
                 3   3   3   Nothing 3
                 4   6   3   Break 2nd Lock  5
                 5   5   5   Break 3rd Lock  7
                 The locks cannot be broken in less than 5 minutes; thus, the
                 answer is 5.

    Constraints:
    * n == strength.length
    * 1 <= n <= 8
    * 1 <= K <= 10
    * 1 <= strength[i] <= 10^6*/

    private int fn(int i, int m, int n, List<Integer> strength, int K, int[][] memo) {
        if (memo[i][m] == -1)
            if (i == n) memo[i][m] = 0;
            else
                for (int j = 0; j < n; ++j)
                    if ((m & 1<<j) == 0) {
                        int cand = (strength.get(j)+i*K)/(1+i*K) + fn(i+1, m ^ 1<<j, n, strength, K, memo);
                        if (memo[i][m] == -1) memo[i][m] = cand;
                        else memo[i][m] = Math.min(memo[i][m], cand);
                    }
        return memo[i][m];
    }

    public int findMinimumTime(List<Integer> strength, int K) {
        int n = strength.size();
        int[][] memo = new int[n+1][1<<n];
        for (int i = 0; i <= n; ++i)
            Arrays.fill(memo[i], -1);
        return fn(0, 0, n, strength, K, memo);
    }


    /*3377. Digit Operations to Make Two Integers Equal (Medium)
    You are given two integers n and m that consist of the same number of
    digits. You can perform the following operations any number of times:
    * Choose any digit from n that is not 9 and increase it by 1.
    * Choose any digit from n that is not 0 and decrease it by 1.
    The integer n must not be a prime number at any point, including its
    original value and after each operation. The cost of a transformation is the
    sum of all values that n takes throughout the operations performed. Return
    the minimum cost to transform n into m. If it is impossible, return -1. A
    prime number is a natural number greater than 1 with only two factors, 1 and
    itself.

    Example 1:
    Input: n = 10, m = 12
    Output: 85
    Explanation: We perform the following operations:
                 - Increase the first digit, now n = 20.
                 - Increase the second digit, now n = 21.
                 - Increase the second digit, now n = 22.
                 - Decrease the first digit, now n = 12.

    Example 2:
    Input: n = 4, m = 8
    Output: -1
    Explanation: It is impossible to make n equal to m.

    Example 3:
    Input: n = 6, m = 2
    Output: -1
    Explanation: Since 2 is already a prime, we can't make n equal to m.

    Constraints:
    * 1 <= n, m < 10^4
    * n and m consist of the same number of digits.*/

    public int minOperations(int n, int m) {
        boolean[] sieve = new boolean[100_000];
        Arrays.fill(sieve, true);
        sieve[0] = sieve[1] = false;
        for (int x = 2; x <= Math.sqrt(100_000); ++x)
            if (sieve[x])
                for (int xx = x*x; xx < 100_000; xx += x)
                    sieve[xx] = false;
        Queue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[0], y[0]));
        Map<Integer, Integer> dist = new HashMap<>();
        if (!sieve[n]) {
            pq.add(new int[]{n, n});
            dist.put(n, n);
        }
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            int cost = elem[0], x = elem[1];
            if (x == m) return cost;
            String s = String.valueOf(x);
            for (int i = 0, d = s.length(); i < d; ++i) {
                if (i > 0 && s.charAt(i) != '0' || i == 0 && s.charAt(i) != '1') {
                    int cand = x - (int) Math.pow(10, d-1-i);
                    if (!sieve[cand] && (!dist.containsKey(cand) || cost+cand < dist.get(cand))) {
                        pq.add(new int[]{cost+cand, cand});
                        dist.put(cand, cost+cand);
                    }
                }
                if (s.charAt(i) != '9') {
                    int cand = x + (int) Math.pow(10, d-1-i);
                    if (!sieve[cand] && (!dist.containsKey(cand) || cost+cand < dist.get(cand))) {
                        pq.add(new int[]{cost+cand, cand});
                        dist.put(cand, cost+cand);
                    }
                }
            }
        }
        return -1;
    }


    /*3378. Count Connected Components in LCM Graph (Hard)
    You are given an array of integers nums of size n and a positive integer
    threshold. There is a graph consisting of n nodes with the ith node having a
    value of nums[i]. Two nodes i and j in the graph are connected via an
    undirected edge if lcm(nums[i], nums[j]) <= threshold. Return the number of
    connected components in this graph. A connected component is a subgraph of a
    graph in which there exists a path between any two vertices, and no vertex
    of the subgraph shares an edge with a vertex outside of the subgraph. The
    term lcm(a, b) denotes the least common multiple of a and b.

    Example 1:
    Input: nums = [2,4,8,3,9], threshold = 5
    Output: 4
    Explanation: The four connected components are (2, 4), (3), (8), (9).

    Example 2:
    Input: nums = [2,4,8,3,9,12], threshold = 10
    Output: 2
    Explanation:  The two connected components are (2, 3, 4, 8, 9), and (12).

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * All elements of nums are unique.
    * 1 <= threshold <= 2 * 10^5*/

    private int find(int p, int[] parent) {
        if (p != parent[p])
            parent[p] = find(parent[p], parent);
        return parent[p];
    }

    public int countComponents(int[] nums, int threshold) {
        int[] parent = IntStream.range(0, threshold+1).toArray();
        for (var x : nums)
            for (int xx = 2*x; xx <= threshold; xx += x)
                parent[find(xx, parent)] = find(x, parent);
        int ans = 0;
        Set<Integer> uniq = new HashSet<>();
        for (var x : nums)
            if (x <= threshold) uniq.add(find(x, parent));
            else ++ans;
        return ans + uniq.size();
    }


    /*3379. Transformed Array (Easy)
    You are given an integer array nums that represents a circular array. Your
    task is to create a new array result of the same size, following these rules:
    For each index i (where 0 <= i < nums.length), perform the following
    independent actions:
    * If nums[i] > 0: Start at index i and move nums[i] steps to the right in
      the circular array. Set result[i] to the value of the index where you land.
    * If nums[i] < 0: Start at index i and move abs(nums[i]) steps to the left
      in the circular array. Set result[i] to the value of the index where you
      land.
    * If nums[i] == 0: Set result[i] to nums[i].
    Return the new array result. Note: Since nums is circular, moving past the
    last element wraps around to the beginning, and moving before the first
    element wraps back to the end.

    Example 1:
    Input: nums = [3,-2,1,1]
    Output: [1,1,1,3]
    Explanation: * For nums[0] that is equal to 3, If we move 3 steps to right,
                   we reach nums[3]. So result[0] should be 1.
                 * For nums[1] that is equal to -2, If we move 2 steps to left,
                   we reach nums[3]. So result[1] should be 1.
                 * For nums[2] that is equal to 1, If we move 1 step to right,
                   we reach nums[3]. So result[2] should be 1.
                 * For nums[3] that is equal to 1, If we move 1 step to right,
                   we reach nums[0]. So result[3] should be 3.

    Example 2:
    Input: nums = [-1,4,-1]
    Output: [-1,-1,4]
    Explanation: * For nums[0] that is equal to -1, If we move 1 step to left,
                   we reach nums[2]. So result[0] should be -1.
                 * For nums[1] that is equal to 4, If we move 4 steps to right,
                   we reach nums[2]. So result[1] should be -1.
                 * For nums[2] that is equal to -1, If we move 1 step to left,
                   we reach nums[1]. So result[2] should be 4.

    Constraints:
    * 1 <= nums.length <= 100
    * -100 <= nums[i] <= 100*/

    public int[] constructTransformedArray(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        for (int i = 0; i < n; ++i)
            ans[i] = nums[(n+(i+nums[i])%n)%n];
        return ans;
    }


    /*3380. Maximum Area Rectangle With Point Constraints I (Medium)
    You are given an array points where points[i] = [xi, yi] represents the
    coordinates of a point on an infinite plane. Your task is to find the
    maximum area of a rectangle that:
    * Can be formed using four of these points as its corners.
    * Does not contain any other point inside or on its border.
    * Has its edges parallel to the axes.
    Return the maximum area that you can obtain or -1 if no such rectangle is
    possible.

    Example 1:
    Input: points = [[1,1],[1,3],[3,1],[3,3]]
    Output: 4
    Explanation: We can make a rectangle with these 4 points as corners and
                 there is no other point that lies inside or on the border.
                 Hence, the maximum possible area would be 4.

    Example 2:
    Input: points = [[1,1],[1,3],[3,1],[3,3],[2,2]]
    Output: -1
    Explanation: There is only one rectangle possible is with points [1,1],
                 [1,3], [3,1] and [3,3] but [2,2] will always lie inside it.
                 Hence, returning -1.

    Example 3:
    Input: points = [[1,1],[1,3],[3,1],[3,3],[1,2],[3,2]]
    Output: 2
    Explanation: The maximum area rectangle is formed by the points [1,3],
                 [1,2], [3,2], [3,3], which has an area of 2. Additionally, the
                 points [1,1], [1,2], [3,1], [3,2] also form a valid rectangle
                 with the same area.

    Constraints:
    * 1 <= points.length <= 10
    * points[i].length == 2
    * 0 <= xi, yi <= 100
    * All the given points are unique.*/

    public int maxRectangleArea(int[][] points) {
        Arrays.sort(points, (x, y) -> x[0] != y[0] ? Integer.compare(x[0], y[0]) : Integer.compare(x[1], y[1]));
        Map<Integer, Integer> last = new HashMap<>();
        int ans = -1, px = -1, py = -1;
        for (var p : points) {
            int x = p[0], y = p[1];
            if (x == px && last.containsKey(y) && last.containsKey(py) && last.get(y) == last.get(py)) {
                int xx = last.get(y);
                boolean found = false;
                for (var pp : points) {
                    int u = pp[0], v = pp[1];
                    if ((u == xx || u == x) && py < v && v < y) found = true;
                    if (xx < u && u < x && (v == py || v == y)) found = true;
                    if (xx < u && u < x && py < v && v < y) found = true;
                    if (found) break;
                }
                if (!found) ans = Math.max(ans, (x-xx)*(y-py));
            }
            last.put(py, px);
            px = x; py = y;
        }
        return ans;
    }


    /*3381. Maximum Subarray Sum With Length Divisible by K (Medium)
    You are given an array of integers nums and an integer k. Return the maximum
    sum of a non-empty subarray of nums, such that the size of the subarray is
    divisible by k. A subarray is a contiguous non-empty sequence of elements
    within an array.

    Example 1:
    Input: nums = [1,2], k = 1
    Output: 3
    Explanation: The subarray [1, 2] with sum 3 has length equal to 2 which is
                 divisible by 1.

    Example 2:
    Input: nums = [-1,-2,-3,-4,-5], k = 4
    Output: -10
    Explanation: The maximum sum subarray is [-1, -2, -3, -4] which has length
                 equal to 4 which is divisible by 4.

    Example 3:
    Input: nums = [-5,1,2,-3,4], k = 2
    Output: 4
    Explanation: The maximum sum subarray is [1, 2, -3, 4] which has length
                 equal to 4 which is divisible by 2.

    Constraints:
    * 1 <= k <= nums.length <= 2 * 10^5
    * -10^9 <= nums[i] <= 10^9*/

    public long maxSubarraySum(int[] nums, int k) {
        long ans = -1_000_000_000_000_000l, prefix = 0;
        long[] seen = new long[k];
        Arrays.fill(seen, 1_000_000_000_000_000l);
        seen[k-1] = 0;
        for (int i = 0; i < nums.length; ++i) {
            prefix += nums[i];
            int ii = i % k;
            ans = Math.max(ans, prefix - seen[ii]);
            seen[ii] = Math.min(seen[ii], prefix);
        }
        return ans;
    }



    /*3382. Maximum Area Rectangle With Point Constraints II (Hard)
    There are n points on an infinite plane. You are given two integer arrays
    xCoord and yCoord where (xCoord[i], yCoord[i]) represents the coordinates of
    the ith point. Your task is to find the maximum area of a rectangle that:
    * Can be formed using four of these points as its corners.
    * Does not contain any other point inside or on its border.
    * Has its edges parallel to the axes.
    Return the maximum area that you can obtain or -1 if no such rectangle is
    possible.

    Example 1:
    Input: xCoord = [1,1,3,3], yCoord = [1,3,1,3]
    Output: 4
    Explanation: We can make a rectangle with these 4 points as corners and
                 there is no other point that lies inside or on the border.
                 Hence, the maximum possible area would be 4.

    Example 2:
    Input: xCoord = [1,1,3,3,2], yCoord = [1,3,1,3,2]
    Output: -1
    Explanation: There is only one rectangle possible is with points [1,1],
                 [1,3], [3,1] and [3,3] but [2,2] will always lie inside it.
                 Hence, returning -1.

    Example 3:
    Input: xCoord = [1,1,3,3,1,3], yCoord = [1,3,1,3,2,2]
    Output: 2
    Explanation: The maximum area rectangle is formed by the points [1,3],
                 [1,2], [3,2], [3,3], which has an area of 2. Additionally, the
                 points [1,1], [1,2], [3,1], [3,2] also form a valid rectangle
                 with the same area.

    Constraints:
    * 1 <= xCoord.length == yCoord.length <= 2 * 10^5
    * 0 <= xCoord[i], yCoord[i] <= 8 * 10^7
    * All the given points are unique.

class SegTree {
    private int n;
    private int[] tree;

    private void build(int[] arr, int k, int lo, int hi) {
        if (lo+1 == hi) tree[k] = arr[lo];
        else {
            int mid = lo + (hi-lo)/2;
            build(arr, 2*k+1, lo, mid);
            build(arr, 2*k+2, mid, hi);
            tree[k] = Math.max(tree[2*k+1], tree[2*k+2]);
        }
    }

    public SegTree(int[] arr) {
        n = arr.length;
        tree = new int[4*n];
        build(arr, 0, 0, n);
    }

    public void update(int i, int val) {
        update(i, val, 0, 0, n);
    }

    private void update(int i, int val, int k, int lo, int hi) {
        if (lo+1 == hi) tree[k] = val;
        else {
            int mid = lo + (hi-lo)/2;
            if (i < mid) update(i, val, 2*k+1, lo, mid);
            else update(i, val, 2*k+2, mid, hi);
            tree[k] = Math.max(tree[2*k+1], tree[2*k+2]);
        }
    }

    public int query(int qlo, int qhi) {
        return query(qlo, qhi, 0, 0, n);
    }

    private int query(int qlo, int qhi, int k, int lo, int hi) {
        if (qhi <= lo || hi <= qlo) return Integer.MIN_VALUE;
        if (qlo <= lo && hi <= qhi) return tree[k];
        int mid = lo + (hi-lo)/2;
        return Math.max(query(qlo, qhi, 2*k+1, lo, mid), query(qlo, qhi, 2*k+2, mid, hi));
    }
}*/

    public long maxRectangleArea(int[] xCoord, int[] yCoord) {
        int n = xCoord.length;
        int[][] points = new int[n][2];
        for (int i = 0; i < n; ++i) {
            points[i][0] = xCoord[i];
            points[i][1] = yCoord[i];
        }
        Arrays.sort(points, (x, y) -> x[0] != y[0] ? Integer.compare(x[0], y[0]) : Integer.compare(x[1], y[1]));
        List<Integer> yvals = new ArrayList<>();
        for (var y : Arrays.stream(yCoord).boxed().collect(Collectors.toSet()))
            yvals.add(y);
        Collections.sort(yvals);
        Map<Integer, Integer> comp = new HashMap<>();
        for (int i = 0; i < yvals.size(); ++i)
            comp.put(yvals.get(i), i);
        Map<Integer, Integer> last = new HashMap<>();
        int[] arr = new int[yvals.size()];
        Arrays.fill(arr, -1);
        SegTree tree = new SegTree(arr);
        long ans = -1;
        int px = -1, py = -1;
        for (var p : points) {
            int x = p[0], y = p[1];
            if (x == px && last.containsKey(y) && last.containsKey(py) && Integer.compare(last.get(y), last.get(py)) == 0) {
                int xx = last.get(y), most = tree.query(comp.get(py)+1, comp.get(y));
                if (most < xx) ans = Math.max(ans, (long) (x-xx)*(y-py));
            }
            if (py >= 0) {
                last.put(py, px);
                tree.update(comp.get(py), px);
            }
            px = x; py = y;
        }
        return ans;
    }


    /*3386. Button with Longest Push Time (Easy)
    You are given a 2D array events which represents a sequence of events where
    a child pushes a series of buttons on a keyboard. Each
    events[i] = [indexi, timei] indicates that the button at index indexi was
    pressed at time timei.
    * The array is sorted in increasing order of time.
    * The time taken to press a button is the difference in time between
      consecutive button presses. The time for the first button is simply the
      time at which it was pressed.
    Return the index of the button that took the longest time to push. If
    multiple buttons have the same longest time, return the button with the
    smallest index.

    Example 1:
    Input: events = [[1,2],[2,5],[3,9],[1,15]]
    Output: 1
    Explanation: * Button with index 1 is pressed at time 2.
                 * Button with index 2 is pressed at time 5, so it took 5 - 2 =
                   3 units of time.
                 * Button with index 3 is pressed at time 9, so it took 9 - 5 =
                   4 units of time.
                 * Button with index 1 is pressed again at time 15, so it took
                   15 - 9 = 6 units of time.

    Example 2:
    Input: events = [[10,5],[1,7]]
    Output: 10
    Explanation: * Button with index 10 is pressed at time 5.
                 * Button with index 1 is pressed at time 7, so it took 7 - 5 =
                   2 units of time.

    Constraints:
    * 1 <= events.length <= 1000
    * events[i] == [indexi, timei]
    * 1 <= indexi, timei <= 10^5
    * The input is generated such that events is sorted in increasing order of
      timei.*/

    public int buttonWithLongestTime(int[][] events) {
        int ans = 0, most = 0, prev = 0;
        for (var e : events) {
            int i = e[0], t = e[1], diff = t - prev;
            if (diff > most || diff == most && i < ans) {
                ans = i;
                most = diff;
            }
            prev = t;
        }
        return ans;
    }


    /*3387. Maximize Amount After Two Days of Conversions (Medium)
    You are given a string initialCurrency, and you start with 1.0 of
    initialCurrency. You are also given four arrays with currency pairs
    (strings) and rates (real numbers):
    * pairs1[i] = [startCurrencyi, targetCurrencyi] denotes that you can convert
      from startCurrencyi to targetCurrencyi at a rate of rates1[i] on day 1.
    * pairs2[i] = [startCurrencyi, targetCurrencyi] denotes that you can convert
      from startCurrencyi to targetCurrencyi at a rate of rates2[i] on day 2.
    * Also, each targetCurrency can be converted back to its corresponding
      startCurrency at a rate of 1 / rate.
    You can perform any number of conversions, including zero, using rates1 on
    day 1, followed by any number of additional conversions, including zero,
    using rates2 on day 2. Return the maximum amount of initialCurrency you can
    have after performing any number of conversions on both days in order. Note:
    Conversion rates are valid, and there will be no contradictions in the rates
    for either day. The rates for the days are independent of each other.

    Example 1:
    Input: initialCurrency = "EUR", pairs1 = [["EUR","USD"],["USD","JPY"]], rates1 = [2.0,3.0], pairs2 = [["JPY","USD"],["USD","CHF"],["CHF","EUR"]], rates2 = [4.0,5.0,6.0]
    Output: 720.00000
    Explanation: To get the maximum amount of EUR, starting with 1.0 EUR:
                 On Day 1:
                 Convert EUR to USD to get 2.0 USD.
                 Convert USD to JPY to get 6.0 JPY.
                 On Day 2:
                 Convert JPY to USD to get 24.0 USD.
                 Convert USD to CHF to get 120.0 CHF.
                 Finally, convert CHF to EUR to get 720.0 EUR.

    Example 2:
    Input: initialCurrency = "NGN", pairs1 = [["NGN","EUR"]], rates1 = [9.0], pairs2 = [["NGN","EUR"]], rates2 = [6.0]
    Output: 1.50000
    Explanation: Converting NGN to EUR on day 1 and EUR to NGN using the inverse
                 rate on day 2 gives the maximum amount.

    Example 3:
    Input: initialCurrency = "USD", pairs1 = [["USD","EUR"]], rates1 = [1.0], pairs2 = [["EUR","JPY"]], rates2 = [10.0]
    Output: 1.00000
    Explanation: In this example, there is no need to make any conversions on
                 either day.

    Constraints:
    * 1 <= initialCurrency.length <= 3
    * initialCurrency consists only of uppercase English letters.
    * 1 <= n == pairs1.length <= 10
    * 1 <= m == pairs2.length <= 10
    * pairs1[i] == [startCurrencyi, targetCurrencyi]
    * pairs2[i] == [startCurrencyi, targetCurrencyi]
    * 1 <= startCurrencyi.length, targetCurrencyi.length <= 3
    * startCurrencyi and targetCurrencyi consist only of uppercase English letters.
    * rates1.length == n
    * rates2.length == m
    * 1.0 <= rates1[i], rates2[i] <= 10.0
    * The input is generated such that there are no contradictions or cycles in
      the conversion graphs for either day.
    * The input is generated such that the output is at most 5 * 10^10.*/

    public double maxAmount(String initialCurrency, List<List<String>> pairs1, double[] rates1, List<List<String>> pairs2, double[] rates2) {
        Map<String, Double> dist = new HashMap<>();
        dist.put(initialCurrency, 1.0);
        List<Pair<List<List<String>>, double[]>> vals = new ArrayList<>();
        vals.add(new Pair<>(pairs1, rates1));
        vals.add(new Pair<>(pairs2, rates2));
        for (var item : vals) {
            var pairs = item.getKey();
            var rates = item.getValue();
            for (var _ : pairs) {
                for (int i = 0; i < pairs.size(); ++i) {
                    String u = pairs.get(i).get(0), v = pairs.get(i).get(1);
                    double r = rates[i];
                    dist.put(u, Math.max(dist.getOrDefault(u, 0.), dist.getOrDefault(v, 0.) / r));
                    dist.put(v, Math.max(dist.getOrDefault(v, 0.), dist.getOrDefault(u, 0.) * r));
                }
            }
        }
        return dist.get(initialCurrency);
    }


    /*3388. Count Beautiful Splits in an Array (Medium)
    You are given an array nums. A split of an array nums is beautiful if:
    * The array nums is split into three subarrays: nums1, nums2, and nums3,
      such that nums can be formed by concatenating nums1, nums2, and nums3 in
      that order.
    * The subarray nums1 is a prefix of nums2 OR nums2 is a prefix of nums3.
    Return the number of ways you can make this split.

    Example 1:
    Input: nums = [1,1,2,1]
    Output: 2
    Explanation: The beautiful splits are:
                 * A split with nums1 = [1], nums2 = [1,2], nums3 = [1].
                 * A split with nums1 = [1], nums2 = [1], nums3 = [2,1].

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 0
    Explanation: There are 0 beautiful splits.

    Constraints:
    * 1 <= nums.length <= 5000
    * 0 <= nums[i] <= 50*/

    public static int[] z_algo(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        for (int i = 1, ii = 0, lo = 0, hi = 0; i < n; ++i) {
            if (i <= hi) ii = i - lo;
            if (i + ans[ii] <= hi) ans[i] = ans[ii];
            else {
                lo = i; hi = Math.max(hi, i);
                while (hi < n && nums[hi] == nums[hi-lo]) ++hi;
                ans[i] = hi - lo;
                --hi;
            }
        }
        return ans;
    }
    public int beautifulSplits(int[] nums) {
        int ans = 0;
        int[] p0 = z_algo(nums);
        for (int i = 1, n = nums.length; i < n; ++i) {
            if (i <= p0[i] && i+p0[i] <= n) ans += n-2*i;
            int[] pi = z_algo(Arrays.copyOfRange(nums, i, n));
            for (int ii = 0; ii < n-i; ++ii)
                if (ii > 0 && ii <= pi[ii] && (i > p0[i] || i <= p0[i] && ii < i)) ++ans;
        }
        return ans;
    }


    /*3389. Minimum Operations to Make Character Frequencies Equal (Hard)
    You are given a string s. A string t is called good if all characters of t
    occur the same number of times. You can perform the following operations any
    number of times:
    * Delete a character from s.
    * Insert a character in s.
    * Change a character in s to its next letter in the alphabet.
    Note that you cannot change 'z' to 'a' using the third operation. Return the
    minimum number of operations required to make s good.

    Example 1:
    Input: s = "acab"
    Output: 1
    Explanation: We can make s good by deleting one occurrence of character 'a'.

    Example 2:
    Input: s = "wddw"
    Output: 0
    Explanation: We do not need to perform any operations since s is initially
                 good.

    Example 3:
    Input: s = "aaabc"
    Output: 2
    Explanation: We can make s good by applying these operations:
                 * Change one occurrence of 'a' to 'b'
                 * Insert one occurrence of 'c' into s

    Constraints:
    * 3 <= s.length <= 2 * 10^4
    * s contains only lowercase English letters.*/

    public int makeStringGood(String s) {
        int[] freq = new int[26];
        int ans = Integer.MAX_VALUE, m = 0;
        for (var ch : s.toCharArray())
            m = Math.max(m, ++freq[ch-'a']);
        for (int k = 0; k <= m; ++k) {
            int[][] dp = new int[27][2];
            for (int i = 25; i >= 0; --i)
                for (int j = 0; j <= 1; ++j) {
                    int credit = 0;
                    if (i > 0 && j > 0)
                        if (freq[i-1] >= k) credit = freq[i-1]-k;
                        else credit = freq[i-1];
                    if (freq[i] >= k) dp[i][j] = freq[i]-k+dp[i+1][1];
                    else {
                        int up = Math.max(0, k-credit-freq[i]) + dp[i+1][0];
                        int dn = freq[i] + dp[i+1][1];
                        dp[i][j] = Math.min(up, dn);
                    }
                }
            ans = Math.min(ans, dp[0][0]);
        }
        return ans;
    }


    /*3392. Count Subarrays of Length Three With a Condition (Easy)
    Given an integer array nums, return the number of subarrays of length 3 such
    that the sum of the first and third numbers equals exactly half of the
    second number.

    Example 1:
    Input: nums = [1,2,1,4,1]
    Output: 1
    Explanation: Only the subarray [1,4,1] contains exactly 3 elements where the
                 sum of the first and third numbers equals half the middle
                 number.

    Example 2:
    Input: nums = [1,1,1]
    Output: 0
    Explanation: [1,1,1] is the only subarray of length 3. However, its first
                 and third numbers do not add to half the middle number.

    Constraints:
    * 3 <= nums.length <= 100
    * -100 <= nums[i] <= 100*/

    public int countSubarrays(int[] nums) {
        int ans = 0;
        for (int i = 0; i < nums.length-2; ++i)
            if (2*(nums[i] + nums[i+2]) == nums[i+1]) ++ans;
        return ans;
    }


    /*3393. Count Paths With the Given XOR Value (Medium)
    You are given a 2D integer array grid with size m x n. You are also given an
    integer k. Your task is to calculate the number of paths you can take from
    the top-left cell (0, 0) to the bottom-right cell (m - 1, n - 1) satisfying
    the following constraints:
    * You can either move to the right or down. Formally, from the cell (i, j)
      you may move to the cell (i, j + 1) or to the cell (i + 1, j) if the
      target cell exists.
    * The XOR of all the numbers on the path must be equal to k.
    Return the total number of such paths. Since the answer can be very large,
    return the result modulo 10^9 + 7.

    Example 1:
    Input: grid = [[2, 1, 5], [7, 10, 0], [12, 6, 4]], k = 11
    Output: 3
    Explanation: The 3 paths are:
                 (0, 0) → (1, 0) → (2, 0) → (2, 1) → (2, 2)
                 (0, 0) → (1, 0) → (1, 1) → (1, 2) → (2, 2)
                 (0, 0) → (0, 1) → (1, 1) → (2, 1) → (2, 2)

    Example 2:
    Input: grid = [[1, 3, 3, 3], [0, 3, 3, 2], [3, 0, 1, 1]], k = 2
    Output: 5
    Explanation: The 5 paths are:
                 (0, 0) → (1, 0) → (2, 0) → (2, 1) → (2, 2) → (2, 3)
                 (0, 0) → (1, 0) → (1, 1) → (2, 1) → (2, 2) → (2, 3)
                 (0, 0) → (1, 0) → (1, 1) → (1, 2) → (1, 3) → (2, 3)
                 (0, 0) → (0, 1) → (1, 1) → (1, 2) → (2, 2) → (2, 3)
                 (0, 0) → (0, 1) → (0, 2) → (1, 2) → (2, 2) → (2, 3)

    Example 3:
    Input: grid = [[1, 1, 1, 2], [3, 0, 3, 2], [3, 0, 2, 2]], k = 10
    Output: 0

    Constraints:
    * 1 <= m == grid.length <= 300
    * 1 <= n == grid[r].length <= 300
    * 0 <= grid[r][c] < 16
    * 0 <= k < 16*/

    public int countPathsWithXorValue(int[][] grid, int k) {
        final int mod = 1_000_000_007, m = grid.length, n = grid[0].length;
        int[] dir = new int[]{1, 0, 1};
        long[][][] freq = new long[m][n][16];
        freq[0][0][grid[0][0]] = 1;
        for (int diag = 0; diag <= m+n-2; ++diag) {
            for (int i = Math.min(m-1, diag); i >= 0 && i >= diag-n+1; --i) {
                int j = diag-i;
                for (int d = 0; d <= 1; ++d) {
                    int ii = i+dir[d], jj = j+dir[d+1];
                    if (0 <= ii && ii < m && 0 <= jj && jj < n)
                        for (int v = 0; v < 16; ++v) {
                            int vv = v ^ grid[ii][jj];
                            freq[ii][jj][vv] = (freq[ii][jj][vv] + freq[i][j][v]) % mod;
                        }
                }
            }
        }
        return (int) freq[m-1][n-1][k];
    }


    /*3394. Check if Grid can be Cut into Sections (Medium)
    You are given an integer n representing the dimensions of an n x n grid,
    with the origin at the bottom-left corner of the grid. You are also given a
    2D array of coordinates rectangles, where rectangles[i] is in the form
    [startx, starty, endx, endy], representing a rectangle on the grid. Each
    rectangle is defined as follows:
    * (startx, starty): The bottom-left corner of the rectangle.
    * (endx, endy): The top-right corner of the rectangle.
    Note that the rectangles do not overlap. Your task is to determine if it is
    possible to make either two horizontal or two vertical cuts on the grid such
    that:
    * Each of the three resulting sections formed by the cuts contains at least
      one rectangle.
    * Every rectangle belongs to exactly one section.
    Return true if such cuts can be made; otherwise, return false.

    Example 1:
    Input: n = 5, rectangles = [[1,0,5,2],[0,2,2,4],[3,2,5,3],[0,4,4,5]]
    Output: true
    Explanation: The grid is shown in the diagram. We can make horizontal cuts
                 at y = 2 and y = 4. Hence, output is true.

    Example 2:
    Input: n = 4, rectangles = [[0,0,1,1],[2,0,3,4],[0,2,2,3],[3,0,4,3]]
    Output: true
    Explanation: We can make vertical cuts at x = 2 and x = 3. Hence, output is
                 true.

    Example 3:
    Input: n = 4, rectangles = [[0,2,2,4],[1,0,3,2],[2,2,3,4],[3,0,4,2],[3,2,4,4]]
    Output: false
    Explanation: We cannot make two horizontal or two vertical cuts that satisfy
                 the conditions. Hence, output is false.

    Constraints:
    * 3 <= n <= 10^9
    * 3 <= rectangles.length <= 10^5
    * 0 <= rectangles[i][0] < rectangles[i][2] <= n
    * 0 <= rectangles[i][1] < rectangles[i][3] <= n
    * No two rectangles overlap.*/

    private boolean check(List<int[]> line) {
        int last = 0, cnt = 0;
        Collections.sort(line, (x, y) -> x[0] != y[0] ? Integer.compare(x[0], y[0]) : Integer.compare(x[1], y[1]));
        for (var elem : line) {
            int lo = elem[0], hi = elem[1];
            if (last <= lo) ++cnt;
            last = Math.max(last, hi);
        }
        return cnt >= 3;
    }

    public boolean checkValidCuts(int n, int[][] rectangles) {
        List<int[]> xs = new ArrayList<>(), ys = new ArrayList<>();
        for (var r : rectangles) {
            xs.add(new int[]{r[0], r[2]});
            ys.add(new int[]{r[1], r[3]});
        }
        return check(xs) || check(ys);
    }


    /*3395. Subsequences with a Unique Middle Mode I (Hard)
    Given an integer array nums, find the number of  subsequences of size 5 of
    nums with a unique middle mode. Since the answer may be very large, return
    it modulo 10^9 + 7. A mode of a sequence of numbers is defined as the
    element that appears the maximum number of times in the sequence. A sequence
    of numbers contains a unique mode if it has only one mode. A sequence of
    numbers seq of size 5 contains a unique middle mode if the middle element
    (seq[2]) is a unique mode.

    Example 1:
    Input: nums = [1,1,1,1,1,1]
    Output: 6
    Explanation: [1, 1, 1, 1, 1] is the only subsequence of size 5 that can be
                 formed, and it has a unique middle mode of 1. This subsequence
                 can be formed in 6 different ways, so the output is 6.

    Example 2:
    Input: nums = [1,2,2,3,3,4]
    Output: 4
    Explanation: [1, 2, 2, 3, 4] and [1, 2, 3, 3, 4] each have a unique middle
                 mode because the number at index 2 has the greatest frequency
                 in the subsequence. [1, 2, 2, 3, 3] does not have a unique
                 middle mode because 2 and 3 appear twice.

    Example 3:
    Input: nums = [0,1,2,3,4,5,6,7,8]
    Output: 0
    Explanation: There is no subsequence of length 5 with a unique middle mode.

    Constraints:
    * 5 <= nums.length <= 1000
    * -10^9 <= nums[i] <= 10^9*/

    private long comb(long x) {
        return x * (x-1)/2;
    }

    public int subsequencesWithMiddleMode(int[] nums) {
        final int n = nums.length, mod = 1_000_000_007;
        Map<Integer, Integer> freq = new HashMap<>(), prefix = new HashMap<>(), suffix = new HashMap<>();
        long ans = 0, pdiff = 0, sdiff = 0;
        for (int i = 0; i < n; ++i) {
            int x = nums[i];
            sdiff += i - suffix.getOrDefault(x, 0);
            suffix.merge(x, 1, Integer::sum);
        }
        for (int i = 0; i < n; ++i) {
            int x = nums[i];
            sdiff -= n-i-suffix.getOrDefault(x, 0);
            suffix.merge(x, -1, Integer::sum);
            long cand = 0;
            if (prefix.containsKey(x)) {
                for (var elem : prefix.entrySet()) {
                    int y = elem.getKey(), v = elem.getValue();
                    if (v > 0 && x != y) {
                        long val = sdiff - suffix.get(x)*(n-i-1-suffix.get(x)) - suffix.get(y)*(n-i-1-suffix.get(y)) + suffix.get(x)*suffix.get(y);
                        cand += val * prefix.get(x) * v;
                    }
                }
            }
            if (suffix.containsKey(x)) {
                for (var elem : suffix.entrySet()) {
                    int y = elem.getKey(), v = elem.getValue();
                    if (v > 0 && x != y) {
                        long val = pdiff - prefix.getOrDefault(x, 0)*(i-prefix.getOrDefault(x, 0)) - prefix.getOrDefault(y, 0)*(i-prefix.getOrDefault(y, 0)) + prefix.getOrDefault(x, 0)*prefix.getOrDefault(y, 0);
                        cand += val * suffix.get(x) * v;
                    }
                }
            }
            cand += comb(prefix.getOrDefault(x, 0))*comb(n-1-i) + prefix.getOrDefault(x, 0)*(i-prefix.getOrDefault(x, 0))*(comb(n-i-1)-comb(n-i-1-suffix.get(x))) + comb(i-prefix.getOrDefault(x, 0))*comb(suffix.get(x));
            ans = (ans + cand) % mod;
            pdiff += i-prefix.getOrDefault(x, 0);
            prefix.merge(x, 1, Integer::sum);
        }
        return (int) ans;
    }


    /*3396. Minimum Number of Operations to Make Elements in Array Distinct (Easy)
    You are given an integer array nums. You need to ensure that the elements in
    the array are distinct. To achieve this, you can perform the following
    operation any number of times:
    * Remove 3 elements from the beginning of the array. If the array has fewer
      than 3 elements, remove all remaining elements.
    Note that an empty array is considered to have distinct elements. Return the
    minimum number of operations needed to make the elements in the array
    distinct.

    Example 1:
    Input: nums = [1,2,3,4,2,3,3,5,7]
    Output: 2
    Explanation: * In the first operation, the first 3 elements are removed,
                   resulting in the array [4, 2, 3, 3, 5, 7].
                 * In the second operation, the next 3 elements are removed,
                   resulting in the array [3, 5, 7], which has distinct elements.
                 Therefore, the answer is 2.

    Example 2:
    Input: nums = [4,5,6,4,4]
    Output: 2
    Explanation: * In the first operation, the first 3 elements are removed,
                   resulting in the array [4, 4].
                 * In the second operation, all remaining elements are removed,
                   resulting in an empty array.
                 Therefore, the answer is 2.

    Example 3:
    Input: nums = [6,7,8,9]
    Output: 0
    Explanation: The array already contains distinct elements. Therefore, the
                 answer is 0.

    Constraints:
    * 1 <= nums.length <= 100
    * 1 <= nums[i] <= 100*/

    public int minimumOperations(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = nums.length-1; i >= 0; --i) {
            freq.merge(nums[i], 1, Integer::sum);
            if (freq.get(nums[i]) == 2) return (i+3)/3;
        }
        return 0;
    }


    /*3397. Maximum Number of Distinct Elements After Operations (Medium)
    You are given an integer array nums and an integer k. You are allowed to
    perform the following operation on each element of the array at most once:
    * Add an integer in the range [-k, k] to the element.
    Return the maximum possible number of distinct elements in nums after
    performing the operations.

    Example 1:
    Input: nums = [1,2,2,3,3,4], k = 2
    Output: 6
    Explanation: nums changes to [-1, 0, 1, 2, 3, 4] after performing operations
                 on the first four elements.

    Example 2:
    Input: nums = [4,4,4,4], k = 1
    Output: 3
    Explanation: By adding -1 to nums[0] and 1 to nums[1], nums changes to
                 [3, 5, 4, 4].

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 0 <= k <= 10^9*/

    public int maxDistinctElements(int[] nums, int k) {
        int ans = 0, prev = Integer.MIN_VALUE;
        Arrays.sort(nums);
        for (var x : nums) {
            int cand = Math.max(prev+1, x-k);
            if (cand <= x+k) {
                ++ans;
                prev = cand;
            }
        }
        return ans;
    }


    /*3398. Smallest Substring With Identical Characters I (Hard)
    You are given a binary string s of length n and an integer numOps. You are
    allowed to perform the following operation on s at most numOps times:
    * Select any index i (where 0 <= i < n) and flip s[i], i.e., if s[i] == '1',
      change s[i] to '0' and vice versa.
    You need to minimize the length of the longest substring of s such that all
    the characters in the substring are identical. Return the minimum length
    after the operations. A substring is a contiguous non-empty sequence of
    characters within a string.

    Example 1:
    Input: s = "000001", numOps = 1
    Output: 2
    Explanation: By changing s[2] to '1', s becomes "001001". The longest
                 substrings with identical characters are s[0..1] and s[3..4].

    Example 2:
    Input: s = "0000", numOps = 2
    Output: 1
    Explanation: By changing s[0] and s[2] to '1', s becomes "1010".

    Example 3:
    Input: s = "0101", numOps = 0
    Output: 1

    Constraints:
    * 1 <= n == s.length <= 1000
    * s consists only of '0' and '1'.
    * 0 <= numOps <= n*/

    public int minLength(String s, int numOps) {
        int n = s.length();
        int one = IntStream.range(0, n).map(i -> Math.abs(s.charAt(i) - '0' - (1&i))).reduce(0, Integer::sum);
        if (Math.min(one, n - one) <= numOps) return 1;
        int lo = 2, hi = n;
        while (lo < hi) {
            int mid = (lo + hi)/2, cnt = 0, need = 0;
            char prev = 0;
            for (int i = 0; i < n; ++i) {
                if (i > 0 && prev != s.charAt(i)) cnt = 0;
                prev = s.charAt(i);
                if (cnt == mid) {
                    if (i+1 < n && s.charAt(i) == s.charAt(i+1))
                        prev = s.charAt(i) == '0' ? '1' : '0';
                    ++need;
                    cnt = 0;
                }
                ++cnt;
            }
            if (need <= numOps) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }


    /*3399. Smallest Substring With Identical Characters II (Hard)
    You are given a binary string s of length n and an integer numOps. You are
    allowed to perform the following operation on s at most numOps times:
    * Select any index i (where 0 <= i < n) and flip s[i]. If s[i] == '1',
      change s[i] to '0' and vice versa.
    You need to minimize the length of the longest substring of s such that all
    the characters in the substring are identical. Return the minimum length
    after the operations. A substring is a contiguous non-empty sequence of
    characters within a string.

    Example 1:
    Input: s = "000001", numOps = 1
    Output: 2
    Explanation: By changing s[2] to '1', s becomes "001001". The longest
                 substrings with identical characters are s[0..1] and s[3..4].

    Example 2:
    Input: s = "0000", numOps = 2
    Output: 1
    Explanation: By changing s[0] and s[2] to '1', s becomes "1010".

    Example 3:
    Input: s = "0101", numOps = 0
    Output: 1

    Constraints:
    * 1 <= n == s.length <= 10^5
    * s consists only of '0' and '1'.
    * 0 <= numOps <= n*/

    public int minLength(String s, int numOps) {
        int n = s.length();
        int one = IntStream.range(0, n).map(i -> Math.abs(s.charAt(i) - '0' - (1&i))).reduce(0, Integer::sum);
        if (Math.min(one, n - one) <= numOps) return 1;
        int lo = 2, hi = n;
        while (lo < hi) {
            int mid = (lo + hi)/2, cnt = 0, need = 0;
            char prev = 0;
            for (int i = 0; i < n; ++i) {
                if (i > 0 && prev != s.charAt(i)) cnt = 0;
                prev = s.charAt(i);
                if (cnt == mid) {
                    if (i+1 < n && s.charAt(i) == s.charAt(i+1))
                        prev = s.charAt(i) == '0' ? '1' : '0';
                    ++need;
                    cnt = 0;
                }
                ++cnt;
            }
            if (need <= numOps) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }


    /*3407. Substring Matching Pattern (Easy)
    You are given a string s and a pattern string p, where p contains exactly
    one '*' character. The '*' in p can be replaced with any sequence of zero or
    more characters. Return true if p can be made a substring of s, and false
    otherwise.

    Example 1:
    Input: s = "leetcode", p = "ee*e"
    Output: true
    Explanation: By replacing the '*' with "tcod", the substring "eetcode"
                 matches the pattern.

    Example 2:
    Input: s = "car", p = "c*v"
    Output: false
    Explanation: There is no substring matching the pattern.

    Example 3:
    Input: s = "luck", p = "u*"
    Output: true
    Explanation: The substrings "u", "uc", and "uck" match the pattern.

    Constraints:
    * 1 <= s.length <= 50
    * 1 <= p.length <= 50
    * s contains only lowercase English letters.
    * p contains only lowercase English letters and exactly one '*'*/

    public boolean hasMatch(String s, String p) {
        int i = p.indexOf('*');
        String prefix = p.substring(0, i), suffix = p.substring(i+1);
        int pi = s.indexOf(prefix), si = s.lastIndexOf(suffix);
        return pi >= 0 && si >= 0 && pi + prefix.length() <= si;
    }


    /*3409. Longest Subsequence With Decreasing Adjacent Difference (Medium)
    You are given an array of integers nums. Your task is to find the length of
    the longest subsequence seq of nums, such that the absolute differences
    between consecutive elements form a non-increasing sequence of integers. In
    other words, for a subsequence seq0, seq1, seq2, ..., seqm of nums,
    |seq1 - seq0| >= |seq2 - seq1| >= ... >= |seqm - seqm - 1|. Return the
    length of such a subsequence.

    Example 1:
    Input: nums = [16,6,3]
    Output: 3
    Explanation: The longest subsequence is [16, 6, 3] with the absolute
                 adjacent differences [10, 3].

    Example 2:
    Input: nums = [6,5,3,4,2,1]
    Output: 4
    Explanation: The longest subsequence is [6, 4, 2, 1] with the absolute
                 adjacent differences [2, 2, 1].

    Example 3:
    Input: nums = [10,20,10,19,10,20]
    Output: 5
    Explanation: The longest subsequence is [10, 20, 10, 19, 10] with the
                 absolute adjacent differences [10, 10, 9, 9].

    Constraints:
    * 2 <= nums.length <= 10^4
    * 1 <= nums[i] <= 300*/

    public int longestSubsequence(int[] nums) {
        int ans = 0, m = IntStream.of(nums).max().getAsInt(), n = nums.length;
        int[] seen = new int[m+1];
        Arrays.fill(seen, -1);
        int[][] dp = new int[n+1][m];
        for (int i = 0; i <= n; ++i)
            Arrays.fill(dp[i], 1);
        for (int i = n-1; i >= 0; --i) {
            for (int j = 0; j < m; ++j) {
                if (j > 0) dp[i][j] = dp[i][j-1];
                for (var x : new int[]{nums[i]-j, nums[i]+j})
                    if (0 <= x && x <= m && seen[x] >= 0) dp[i][j] = Math.max(dp[i][j], 1 + dp[seen[x]][j]);
            }
            seen[nums[i]] = i;
            ans = Math.max(ans, dp[i][m-1]);
        }
        return ans;
    }


    /*3410. Maximize Subarray Sum After Removing All Occurrences of One Element (Hard)
    You are given an integer array nums. You can do the following operation on
    the array at most once:
    * Choose any integer x such that nums remains non-empty on removing all
      occurrences of x.
    * Remove all occurrences of x from the array.
    Return the maximum subarray sum across all possible resulting arrays.

    Example 1:
    Input: nums = [-3,2,-2,-1,3,-2,3]
    Output: 7
    Explanation: We can have the following arrays after at most one operation:
                 * The original array is nums = [-3, 2, -2, -1, 3, -2, 3]. The
                   maximum subarray sum is 3 + (-2) + 3 = 4.
                 * Deleting all occurences of x = -3 results in
                   nums = [2, -2, -1, 3, -2, 3]. The maximum subarray sum is
                   3 + (-2) + 3 = 4.
                 * Deleting all occurences of x = -2 results in
                   nums = [-3, 2, -1, 3, 3]. The maximum subarray sum is
                   2 + (-1) + 3 + 3 = 7.
                 * Deleting all occurences of x = -1 results in
                   nums = [-3, 2, -2, 3, -2, 3]. The maximum subarray sum is
                   3 + (-2) + 3 = 4.
                 * Deleting all occurences of x = 3 results in
                   nums = [-3, 2, -2, -1, -2]. The maximum subarray sum is 2.
                 The output is max(4, 4, 7, 4, 2) = 7.

    Example 2:
    Input: nums = [1,2,3,4]
    Output: 10
    Explanation: It is optimal to not perform any operations.

    Constraints:
    * 1 <= nums.length <= 10^5
    * -10^6 <= nums[i] <= 10^6*/

    public long maxSubarraySum(int[] nums) {
        Map<Integer, Long> mp = new HashMap<>(Map.of(0, 0L));
        long ans = Long.MIN_VALUE, prefix = 0, least = 0;
        for (var x : nums) {
            prefix += x;
            ans = Math.max(ans, prefix - least);
            mp.put(x, Math.min(mp.get(0), mp.getOrDefault(x, 0L)) + x);
            mp.put(0, Math.min(mp.get(0), prefix));
            least = Math.min(least, Math.min(mp.get(0), mp.get(x)));
        }
        return ans;
    }


    /*3411. Maximum Subarray With Equal Products (Easy)
    You are given an array of positive integers nums. An array arr is called
    product equivalent if prod(arr) == lcm(arr) * gcd(arr), where:
    * prod(arr) is the product of all elements of arr.
    * gcd(arr) is the GCD of all elements of arr.
    * lcm(arr) is the LCM of all elements of arr.
    Return the length of the longest product equivalent subarray of nums.

    Example 1:
    Input: nums = [1,2,1,2,1,1,1]
    Output: 5
    Explanation: The longest product equivalent subarray is [1, 2, 1, 1, 1],
                 where prod([1, 2, 1, 1, 1]) = 2, gcd([1, 2, 1, 1, 1]) = 1, and
                 lcm([1, 2, 1, 1, 1]) = 2.

    Example 2:
    Input: nums = [2,3,4,5,6]
    Output: 3
    Explanation: The longest product equivalent subarray is [3, 4, 5].

    Example 3:
    Input: nums = [1,2,3,1,4,5,1]
    Output: 5

    Constraints:
    * 2 <= nums.length <= 100
    * 1 <= nums[i] <= 10*/

    public int maxLength(int[] nums) {
        int ans = 0;
        for (int i = 0, n = nums.length; i < n; ++i) {
            int p = 1, l = 1, g = 0;
            for (int j = i; j < n; ++j) {
                p *= nums[j];
                if (p > 50000) break;
                g = BigInteger.valueOf(g).gcd(BigInteger.valueOf(nums[j])).intValue();
                int temp = BigInteger.valueOf(l).gcd(BigInteger.valueOf(nums[j])).intValue();
                l = l * nums[j] / temp;
                if (p == g*l) ans = Math.max(ans, j-i+1);
            }
        }
        return ans;
    }


    /*3412. Find Mirror Score of a String (Medium)
    You are given a string s. We define the mirror of a letter in the English
    alphabet as its corresponding letter when the alphabet is reversed. For
    example, the mirror of 'a' is 'z', and the mirror of 'y' is 'b'. Initially,
    all characters in the string s are unmarked. You start with a score of 0,
    and you perform the following process on the string s:
    * Iterate through the string from left to right.
    * At each index i, find the closest unmarked index j such that j < i and
      s[j] is the mirror of s[i]. Then, mark both indices i and j, and add the
      value i - j to the total score.
    * If no such index j exists for the index i, move on to the next index
      without making any changes.
    Return the total score at the end of the process.

    Example 1:
    Input: s = "aczzx"
    Output: 5
    Explanation: * i = 0. There is no index j that satisfies the conditions, so
                   we skip.
                 * i = 1. There is no index j that satisfies the conditions, so
                   we skip.
                 * i = 2. The closest index j that satisfies the conditions is
                   j = 0, so we mark both indices 0 and 2, and then add
                   2 - 0 = 2 to the score.
                 * i = 3. There is no index j that satisfies the conditions, so
                   we skip.
                 * i = 4. The closest index j that satisfies the conditions is
                   j = 1, so we mark both indices 1 and 4, and then add
                   4 - 1 = 3 to the score.

    Example 2:
    Input: s = "abcdef"
    Output: 0
    Explanation: For each index i, there is no index j that satisfies the
                 conditions.

    Constraints:
    * 1 <= s.length <= 10^5
    * s consists only of lowercase English letters.*/

    public long calculateScore(String s) {
        long ans = 0;
        Stack<Integer>[] stk = new Stack[26];
        for (int i = 0; i < 26; ++i)
            stk[i] = new Stack<>();
        for (int i = 0; i < s.length(); ++i) {
            int v = s.charAt(i) - 'a';
            if (!stk[25-v].isEmpty()) ans += i - stk[25-v].pop();
            else stk[v].push(i);
        }
        return ans;
    }


    /*3413. Maximum Coins From K Consecutive Bags (Medium)
    There are an infinite amount of bags on a number line, one bag for each
    coordinate. Some of these bags contain coins. You are given a 2D array
    coins, where coins[i] = [li, ri, ci] denotes that every bag from li to ri
    contains ci coins. The segments that coins contain are non-overlapping. You
    are also given an integer k. Return the maximum amount of coins you can
    obtain by collecting k consecutive bags.

    Example 1:
    Input: coins = [[8,10,1],[1,3,2],[5,6,4]], k = 4
    Output: 10
    Explanation: Selecting bags at positions [3, 4, 5, 6] gives the maximum
                 number of coins: 2 + 0 + 4 + 4 = 10.

    Example 2:
    Input: coins = [[1,10,3]], k = 2
    Output: 6
    Explanation: Selecting bags at positions [1, 2] gives the maximum number of
                 coins: 3 + 3 = 6.

    Constraints:
    * 1 <= coins.length <= 10^5
    * 1 <= k <= 10^9
    * coins[i] == [li, ri, ci]
    * 1 <= li <= ri <= 10^9
    * 1 <= ci <= 1000
    * The given segments are non-overlapping.*/

    public long maximumCoins(int[][] coins, int k) {
        int n = coins.length;
        Arrays.sort(coins, (x, y) -> Integer.compare(x[0], y[0]));
        long ans = 0, prefix = 0;
        for (int i = 0, ii = 0; i < n; ++i) {
            long l = coins[i][0], r = coins[i][1], c = coins[i][2];
            prefix += (r-l+1)*c;
            while (coins[ii][1] <= r-k) {
                long ll = coins[ii][0], rr = coins[ii][1], cc = coins[ii][2];
                prefix -= (rr-ll+1)*cc;
                ++ii;
            }
            long cand = prefix - Math.max(0l, r-k-coins[ii][0]+1)*coins[ii][2];
            ans = Math.max(ans, cand);
        }
        prefix = 0;
        for (int i = 0, ii = 0; i < n; ++i) {
            long l = coins[i][0], r = coins[i][1], c = coins[i][2];
            while (ii < n && coins[ii][1] < l+k) {
                long ll = coins[ii][0], rr = coins[ii][1], cc = coins[ii][2];
                prefix += (rr-ll+1)*cc;
                ++ii;
            }
            long cand = prefix;
            if (ii < n) cand += Math.max(0, l+k-coins[ii][0])*coins[ii][2];
            ans = Math.max(ans, cand);
            prefix -= (r-l+1)*c;
        }
        return ans;
    }


    /*3414. Maximum Score of Non-overlapping Intervals (Hard)
    You are given a 2D integer array intervals, where
    intervals[i] = [li, ri, weighti]. Interval i starts at position li and ends
    at ri, and has a weight of weighti. You can choose up to 4 non-overlapping
    intervals. The score of the chosen intervals is defined as the total sum of
    their weights. Return the lexicographically smallest array of at most 4
    indices from intervals with maximum score, representing your choice of non-
    overlapping intervals. Two intervals are said to be non-overlapping if they
    do not share any points. In particular, intervals sharing a left or right
    boundary are considered overlapping.

    Example 1:
    Input: intervals = [[1,3,2],[4,5,2],[1,5,5],[6,9,3],[6,7,1],[8,9,1]]
    Output: [2,3]
    Explanation: You can choose the intervals with indices 2, and 3 with
                 respective weights of 5, and 3.

    Example 2:
    Input: intervals = [[5,8,1],[6,7,7],[4,7,3],[9,10,6],[7,8,2],[11,14,3],[3,5,5]]
    Output: [1,3,5,6]
    Explanation: You can choose the intervals with indices 1, 3, 5, and 6 with
                 respective weights of 7, 6, 3, and 5.

    Constraints:
    * 1 <= intevals.length <= 5 * 10^4
    * intervals[i].length == 3
    * intervals[i] = [li, ri, weighti]
    * 1 <= li <= ri <= 10^9
    * 1 <= weighti <= 10^9*/

    private boolean lessThan(List<Integer> x, List<Integer> y) {
        for (int i = 0; i < x.size() && i < y.size(); ++i)
            if (x.get(i) < y.get(i)) return true;
            else if(x.get(i) > y.get(i)) return false;
        return x.size() <  y.size();
    }

    public int[] maximumWeight(List<List<Integer>> intervals) {
        int n = intervals.size();
        {
            int i = 0;
            for (var interval : intervals)
                interval.add(i++);
        }
        Collections.sort(intervals, (x, y) -> Integer.compare(x.get(0), y.get(0)));
        Pair<Long, List<Integer>>[][] dp = new Pair[n+1][5];
        for (int i = 0; i <= n; ++i)
            for (int j = 0; j < 5; ++j)
                dp[i][j] = new Pair<>(0l, new ArrayList<>());
        for (int i = n-1; i >= 0; --i) {
            int l = intervals.get(i).get(0), r = intervals.get(i).get(1), w = intervals.get(i).get(2), index = intervals.get(i).get(3);
            int lo = 0, hi = n;
            while (lo < hi) {
                int mid = lo + (hi-lo)/2;
                if (intervals.get(mid).get(0) < r+1) lo = mid+1;
                else hi = mid;
            }
            int ii = lo;
            for (int j = 0; j <= 4; ++j) {
                long v = dp[i+1][j].getKey();
                List<Integer> a = dp[i+1][j].getValue();
                for (int jj = 0; jj < j; ++jj) {
                    long vv = dp[ii][jj].getKey();
                    List<Integer> aa = new ArrayList<>(dp[ii][jj].getValue());
                    aa.add(index);
                    Collections.sort(aa);
                    if (w + vv > v || w + vv == v && lessThan(aa, a)) {
                        v = w + vv;
                        a = aa;
                    }
                }
                dp[i][j] = new Pair<>(v, a);
            }
        }
        return dp[0][4].getValue().stream().mapToInt(Integer::intValue).toArray();
    }


    /*3417. Zigzag Grid Traversal With Skip (Easy)
    You are given an m x n 2D array grid of positive integers. Your task is to
    traverse grid in a zigzag pattern while skipping every alternate cell.
    Zigzag pattern traversal is defined as following the below actions:
    * Start at the top-left cell (0, 0).
    * Move right within a row until the end of the row is reached.
    * Drop down to the next row, then traverse left until the beginning of the
      row is reached.
    * Continue alternating between right and left traversal until every row has
      been traversed.
    Note that you must skip every alternate cell during the traversal. Return an
    array of integers result containing, in order, the value of the cells
    visited during the zigzag traversal with skips.

    Example 1:
    Input: grid = [[1,2],[3,4]]
    Output: [1,4]
    Explanation:

    Example 2:
    Input: grid = [[2,1],[2,1],[2,1]]
    Output: [2,1,2]
    Explanation:

    Example 3:
    Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
    Output: [1,3,5,7,9]
    Explanation:

    Constraints:
    * 2 <= n == grid.length <= 50
    * 2 <= m == grid[i].length <= 50
    * 1 <= grid[i][j] <= 2500*/

    public List<Integer> zigzagTraversal(int[][] grid) {
        List<Integer> ans = new ArrayList<>();
        for (int i = 0, j = 0, dj = 1; i < grid.length; ) {
            if ((i+j) % 2 == 0) ans.add(grid[i][j]);
            if (j+dj == -1 || j+dj == grid[i].length) {
                ++i;
                dj *= -1;
            } else j += dj;
        }
        return ans;
    }


    /*3418. Maximum Amount of Money Robot Can Earn (Medium)
    You are given an m x n grid. A robot starts at the top-left corner of the
    grid (0, 0) and wants to reach the bottom-right corner (m - 1, n - 1). The
    robot can move either right or down at any point in time. The grid contains
    a value coins[i][j] in each cell:
    * If coins[i][j] >= 0, the robot gains that many coins.
    * If coins[i][j] < 0, the robot encounters a robber, and the robber steals
      the absolute value of coins[i][j] coins.
    The robot has a special ability to neutralize robbers in at most 2 cells on
    its path, preventing them from stealing coins in those cells. Note: The
    robot's total coins can be negative. Return the maximum profit the robot can
    gain on the route.

    Example 1:
    Input: coins = [[0,1,-1],[1,-2,3],[2,-3,4]]
    Output: 8
    Explanation: An optimal path for maximum coins is:
                 - Start at (0, 0) with 0 coins (total coins = 0).
                 - Move to (0, 1), gaining 1 coin (total coins = 0 + 1 = 1).
                 - Move to (1, 1), where there's a robber stealing 2 coins. The
                   robot uses one neutralization here, avoiding the robbery
                   (total coins = 1).
                 - Move to (1, 2), gaining 3 coins (total coins = 1 + 3 = 4).
                 - Move to (2, 2), gaining 4 coins (total coins = 4 + 4 = 8).

    Example 2:
    Input: coins = [[10,10,10],[10,10,10]]
    Output: 40
    Explanation: An optimal path for maximum coins is:
                 - Start at (0, 0) with 10 coins (total coins = 10).
                 - Move to (0, 1), gaining 10 coins (total coins = 10 + 10 = 20).
                 - Move to (0, 2), gaining another 10 coins (total coins = 20 +
                   10 = 30).
                 - Move to (1, 2), gaining the final 10 coins (total coins = 30
                   + 10 = 40).

    Constraints:
    * m == coins.length
    * n == coins[i].length
    * 1 <= m, n <= 500
    * -1000 <= coins[i][j] <= 1000*/

    public int maximumAmount(int[][] coins) {
        int m = coins.length, n = coins[0].length;
        int[][][] dp = new int[m][n][4];
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                Arrays.fill(dp[i][j], -1_000_000_000);
        dp[0][0][2] = coins[0][0];
        if (coins[0][0] < 0) dp[0][0][1] = 0;
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                for (int k = 0; k <= 2; ++k) {

                    if (i > 0) dp[i][j][k] = Math.max(dp[i][j][k], Math.max(dp[i-1][j][k] + coins[i][j], dp[i-1][j][k+1]));
                    if (j > 0) dp[i][j][k] = Math.max(dp[i][j][k], Math.max(dp[i][j-1][k] + coins[i][j], dp[i][j-1][k+1]));
                }
        return Math.max(dp[m-1][n-1][0], Math.max(dp[m-1][n-1][1], dp[m-1][n-1][2]));
    }


    /*3419. Minimize the Maximum Edge Weight of Graph (Medium)
    You are given two integers, n and threshold, as well as a directed weighted
    graph of n nodes numbered from 0 to n - 1. The graph is represented by a 2D
    integer array edges, where edges[i] = [Ai, Bi, Wi] indicates that there is
    an edge going from node Ai to node Bi with weight Wi. You have to remove
    some edges from this graph (possibly none), so that it satisfies the
    following conditions:
    * Node 0 must be reachable from all other nodes.
    * The maximum edge weight in the resulting graph is minimized.
    * Each node has at most threshold outgoing edges.
    Return the minimum possible value of the maximum edge weight after removing
    the necessary edges. If it is impossible for all conditions to be satisfied,
    return -1.

    Example 1:
    Input: n = 5, edges = [[1,0,1],[2,0,2],[3,0,1],[4,3,1],[2,1,1]], threshold = 2
    Output: 1
    Explanation: Remove the edge 2 -> 0. The maximum weight among the remaining
                 edges is 1.

    Example 2:
    Input: n = 5, edges = [[0,1,1],[0,2,2],[0,3,1],[0,4,1],[1,2,1],[1,4,1]], threshold = 1
    Output: -1
    Explanation: It is impossible to reach node 0 from node 2.

    Example 3:
    Input: n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[3,4,2],[4,0,1]], threshold = 1
    Output: 2
    Explanation: Remove the edges 1 -> 3 and 1 -> 4. The maximum weight among
                 the remaining edges is 2.

    Example 4:
    Input: n = 5, edges = [[1,2,1],[1,3,3],[1,4,5],[2,3,2],[4,0,1]], threshold = 1
    Output: -1

    Constraints:
    * 2 <= n <= 10^5
    * 1 <= threshold <= n - 1
    * 1 <= edges.length <= min(10^5, n * (n - 1) / 2).
    * edges[i].length == 3
    * 0 <= Ai, Bi < n
    * Ai != Bi
    * 1 <= Wi <= 10^6
    * There may be multiple edges between a pair of nodes, but they must have
      unique weights.*/

    public int minMaxWeight(int n, int[][] edges, int threshold) {
        Map<Integer, Integer>[] graph = new Map[n];
        for (int i = 0; i < n; ++i)
            graph[i] = new HashMap<>();
        for (var e : edges) {
            int u = e[0], v = e[1], w = e[2];
            graph[v].put(u, Math.min(graph[v].getOrDefault(u, Integer.MAX_VALUE), w));
        }
        int ans = 0;
        Queue<int[]> pq = new PriorityQueue<>((x, y) -> Integer.compare(x[0], y[0]));
        pq.add(new int[]{0, 0});
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[0] = 0;
        Set<Integer> seen = new HashSet<>();
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            int x = elem[0], v = elem[1];
            seen.add(v);
            if (seen.size() == n) return x;
            if (dist[v] == x) {
                for (var u : graph[v].keySet()) {
                    int w = graph[v].get(u);
                    if (Math.max(x, w) < dist[u]) {
                        pq.add(new int[]{Math.max(x, w), u});
                        dist[u] = Math.max(x, w);
                    }
                }
            }
        }
        return -1;
    }


    /*3420. Count Non-Decreasing Subarrays After K Operations (Hard)
    You are given an array nums of n integers and an integer k. For each
    subarray of nums, you can apply up to k operations on it. In each operation,
    you increment any element of the subarray by 1. Note that each subarray is
    considered independently, meaning changes made to one subarray do not
    persist to another. Return the number of subarrays that you can make non-
    decreasing after performing at most k operations. An array is said to be
    non-decreasing if each element is greater than or equal to its previous
    element, if it exists.

    Example 1:
    Input: nums = [6,3,1,2,4,4], k = 7
    Output: 17
    Explanation: Out of all 21 possible subarrays of nums, only the subarrays
                 [6, 3, 1], [6, 3, 1, 2], [6, 3, 1, 2, 4] and [6, 3, 1, 2, 4, 4]
                 cannot be made non-decreasing after applying up to k = 7
                 operations. Thus, the number of non-decreasing subarrays is
                 21 - 4 = 17.

    Example 2:
    Input: nums = [6,3,1,3,6], k = 4
    Output: 12
    Explanation: The subarray [3, 1, 3, 6] along with all subarrays of nums with
                 three or fewer elements, except [6, 3, 1], can be made non-
                 decreasing after k operations. There are 5 subarrays of a
                 single element, 4 subarrays of two elements, and 2 subarrays of
                 three elements except [6, 3, 1], so there are
                 1 + 5 + 4 + 2 = 12 subarrays that can be made non-decreasing.

    Constraints:
    * 1 <= nums.length <= 10^5
    * 1 <= nums[i] <= 10^9
    * 1 <= k <= 10^9*/

    public long countNonDecreasingSubarrays(int[] nums, int k) {
        long ans = 0, prefix = 0;
        Deque<Integer> q = new LinkedList<>();
        for (int n = nums.length, i = n-1, j = n-1; i >= 0; --i) {
            while (!q.isEmpty() && nums[i] > nums[q.peekFirst()]) {
                int lo = q.pollFirst();
                int hi = q.isEmpty() ? j+1 : q.peekFirst();
                prefix += (long) (hi-lo) * (nums[i]-nums[lo]);
            }
            q.addFirst(i);
            while (prefix > k) {
                if (j == q.peekLast()) q.pollLast();
                else prefix -= nums[q.peekLast()] - nums[j];
                --j;
            }
            ans += j-i+1;
        }
        return ans;
    }
}


/*170. Two Sum III - Data structure design (Easy)
Design a data structure that accepts a stream of integers and checks if it has
a pair of integers that sum up to a particular value. Implement the TwoSum
class:
* TwoSum() Initializes the TwoSum object, with an empty array initially.
* void add(int number) Adds number to the data structure.
* boolean find(int value) Returns true if there exists any pair of numbers
  whose sum is equal to value, otherwise, it returns false.

Example 1:
Input: ["TwoSum", "add", "add", "add", "find", "find"]
       [[], [1], [3], [5], [4], [7]]
Output: [null, null, null, null, true, false]
Explanation
TwoSum twoSum = new TwoSum();
twoSum.add(1);   // [] --> [1]
twoSum.add(3);   // [1] --> [1,3]
twoSum.add(5);   // [1,3] --> [1,3,5]
twoSum.find(4);  // 1 + 3 = 4, return true
twoSum.find(7);  // No two integers sum up to 7, return false

Constraints:
* -10^5 <= number <= 10^5
* -2^31 <= value <= 2^31 - 1
* At most 10^4 calls will be made to add and find.*/

class TwoSum {
    private HashMap<Integer, Integer> freq;

    public TwoSum() {
        freq = new HashMap();
    }

    public void add(int number) {
        freq.merge(number, 1, Integer::sum);
    }

    public boolean find(int value) {
        for (var k : freq.keySet())
            if (freq.containsKey(value - k) && (k != value - k || freq.get(k) > 1)) return true;
        return false;
    }
}


/*308. Range Sum Query 2D - Mutable (Hard)
Given a 2D matrix matrix, handle multiple queries of the following types:
* Update the value of a cell in matrix.
* Calculate the sum of the elements of matrix inside the rectangle defined by
  its upper left corner (row1, col1) and lower right corner (row2, col2).
Implement the NumMatrix class:
* NumMatrix(int[][] matrix) Initializes the object with the integer matrix
  matrix.
* void update(int row, int col, int val) Updates the value of matrix[row][col]
  to be val.
* int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the
  elements of matrix inside the rectangle defined by its upper left corner
  (row1, col1) and lower right corner (row2, col2).

Example 1:
Input: ["NumMatrix", "sumRegion", "update", "sumRegion"]
       [[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [3, 2, 2], [2, 1, 4, 3]]
Output: [null, 8, null, 10]
Explanation:
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e. sum of the left red rectangle)
numMatrix.update(3, 2, 2);       // matrix changes from left image to right image
numMatrix.sumRegion(2, 1, 4, 3); // return 10 (i.e. sum of the right red rectangle)

Constraints:
* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 200
* -1000 <= matrix[i][j] <= 1000
* 0 <= row < m
* 0 <= col < n
* -1000 <= val <= 1000
* 0 <= row1 <= row2 < m
* 0 <= col1 <= col2 < n
* At most 5000 calls will be made to sumRegion and update.*/

class Fenwick2D {
    private int m, n;
    private int[][] nums;

    public Fenwick2D(int m, int n) {
        this.m = m;
        this.n = n;
        nums = new int[m+1][n+1];
    }

    public int query(int i, int j) {
        int ans = 0;
        for (++i, ++j; i > 0; i -= i & -i)
            for (int jj = j; jj > 0; jj -= jj & -jj)
                ans += nums[i][jj];
        return ans;
    }

    public void add(int i, int j, int delta) {
        for (++i, ++j; i <= m; i += i & -i)
            for (int jj = j; jj <= n; jj += jj & -jj)
                nums[i][jj] += delta;
    }
}


class NumMatrix {
    private int m, n;
    private int[][] vals;
    private Fenwick2D tree;

    public NumMatrix(int[][] matrix) {
        m = matrix.length;
        n = matrix[0].length;
        vals = new int[m][n];
        tree = new Fenwick2D(m, n);
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < n; ++j)
                update(i, j, matrix[i][j]);
    }

    public void update(int row, int col, int val) {
        int delta = val - vals[row][col];
        vals[row][col] = val;
        tree.add(row, col, delta);
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        return tree.query(row2, col2) - tree.query(row2, col1-1) - tree.query(row1-1, col2) + tree.query(row1-1, col1-1);
    }
}


/*341. Flatten Nested List Iterator (Medium)
You are given a nested list of integers nestedList. Each element is either an
integer or a list whose elements may also be integers or other lists. Implement
an iterator to flatten it. Implement the NestedIterator class:
* NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with
  the nested list nestedList.
* int next() Returns the next integer in the nested list.
* boolean hasNext() Returns true if there are still some integers in the nested
  list and false otherwise.
Your code will be tested with the following pseudocode:
    initialize iterator with nestedList
    res = []
    while iterator.hasNext()
        append iterator.next() to the end of res
    return res
If res matches the expected flattened list, then your code will be judged as
correct.

Example 1:
Input: nestedList = [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, the order
             of elements returned by next should be: [1,1,2,1,1].

Example 2:
Input: nestedList = [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false, the order
             of elements returned by next should be: [1,4,6].

Constraints:
* 1 <= nestedList.length <= 500
* The values of the integers in the nested list is in the range [-10^6, 10^6].*/

public class NestedIterator implements Iterator<Integer> {
    public Stack<Pair<List<NestedInteger>, Integer>> stk;
    public Integer val;

    public NestedIterator(List<NestedInteger> nestedList) {
        stk = new Stack<>();
        stk.push(new Pair<>(nestedList, 0));
        val = read();
    }

    @Override
    public Integer next() {
        Integer ans = Integer.valueOf(val);
        val = read();
        return ans;
    }

    @Override
    public boolean hasNext() {
        return val != null;
    }

    private Integer read() {
        while (!stk.isEmpty()) {
            var elem = stk.pop();
            List<NestedInteger> data = elem.getKey();
            int i = elem.getValue();
            if (i+1 < data.size()) stk.push(new Pair<>(data, i+1));
            if (data.get(i).isInteger()) return data.get(i).getInteger();
            else if (!data.get(i).getList().isEmpty())
                stk.push(new Pair<>(data.get(i).getList(), 0));
        }
        return null;
    }
}


/*703. Kth Largest Element in a Stream (Easy)
Design a class to find the kth largest element in a stream. Note that it is the
kth largest element in the sorted order, not the kth distinct element. Implement
KthLargest class:
* KthLargest(int k, int[] nums) Initializes the object with the integer k and
  the stream of integers nums.
* int add(int val) Appends the integer val to the stream and returns the element
  representing the kth largest element in the stream.

Example 1:
Input ["KthLargest", "add", "add", "add", "add", "add"]
      [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output [null, 4, 5, 5, 8, 8]
Explanation
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8

Constraints:
* 1 <= k <= 10^4
* 0 <= nums.length <= 10^4
* -10^4 <= nums[i] <= 10^4
* -10^4 <= val <= 10^4
* At most 10^4 calls will be made to add.
* It is guaranteed that there will be at least k elements in the array when you
search for the kth element.*/

class KthLargest {

    private Queue<Integer> pq;
    private int k;

    public KthLargest(int k, int[] nums) {
        pq = new PriorityQueue();
        for (var x : nums) {
            pq.add(x);
            if (pq.size() > k) pq.poll();
        }
        this.k = k;
    }

    public int add(int val) {
        pq.add(val);
        if (pq.size() > k) pq.poll();
        return pq.peek();
    }
}


/*729. My Calendar I (Medium)
You are implementing a program to use as your calendar. We can add a new event
if adding the event will not cause a double booking. A double booking happens
when two events have some non-empty intersection (i.e., some moment is common to
both events.). The event can be represented as a pair of integers start and end
that represents a booking on the half-open interval [start, end), the range of
real numbers x such that start <= x < end. Implement the MyCalendar class:
* MyCalendar() Initializes the calendar object.
* boolean book(int start, int end) Returns true if the event can be added to the
  calendar successfully without causing a double booking. Otherwise, return
  false and do not add the event to the calendar.

Example 1:
Input: ["MyCalendar", "book", "book", "book"]
       [[], [10, 20], [15, 25], [20, 30]]
Output: [null, true, false, true]
Explanation:
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False, It can not be booked because time 15
                         // is already booked by another event.
myCalendar.book(20, 30); // return True, The event can be booked, as the first
                         // event takes every time less than 20, but not
                         including 20.

Constraints:
* 0 <= start < end <= 10^9
* At most 1000 calls will be made to book.*/

class MyCalendar {
    public TreeMap<Integer, Integer> cal;

    public MyCalendar() {
        cal = new TreeMap<>();
    }

    public boolean book(int start, int end) {
        Integer k = cal.floorKey(start);
        if (k != null && cal.get(k) > start) return false;
        k = cal.ceilingKey(start);
        if (k != null && end > k) return false;
        cal.put(start, end);
        return true;
    }
}


/*1724. Checking Existence of Edge Length Limited Paths II (Hard)
An undirected graph of n nodes is defined by edgeList, where
edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with
distance disi. Note that there may be multiple edges between two nodes, and
the graph may not be connected. Implement the DistanceLimitedPathsExist
class:
* DistanceLimitedPathsExist(int n, int[][] edgeList) Initializes the class
  with an undirected graph.
* boolean query(int p, int q, int limit) Returns true if there exists a
  path from p to q such that each edge on the path has a distance strictly
  less than limit, and otherwise false.

Example 1:
Input: ["DistanceLimitedPathsExist", "query", "query", "query", "query"]
       [[6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]], [2, 3, 2], [1, 3, 3], [2, 0, 3], [0, 5, 6]]
Output: [null, true, false, true, false]
Explanation:
DistanceLimitedPathsExist distanceLimitedPathsExist = new DistanceLimitedPathsExist(6, [[0, 2, 4], [0, 3, 2], [1, 2, 3], [2, 3, 1], [4, 5, 5]]);
distanceLimitedPathsExist.query(2, 3, 2); // return true. There is an edge from 2 to 3 of distance 1, which is less than 2.
distanceLimitedPathsExist.query(1, 3, 3); // return false. There is no way to go from 1 to 3 with distances strictly less than 3.
distanceLimitedPathsExist.query(2, 0, 3); // return true. There is a way to go from 2 to 0 with distance < 3: travel from 2 to 3 to 0.
distanceLimitedPathsExist.query(0, 5, 6); // return false. There are no paths from 0 to 5.

Constraints:
* 2 <= n <= 10^4
* 0 <= edgeList.length <= 10^4
* edgeList[i].length == 3
* 0 <= ui, vi, p, q <= n-1
* ui != vi
* p != q
* 1 <= disi, limit <= 10^9
* At most 104 calls will be made to query.*/

class DistanceLimitedPathsExist {
    private int[] depth, parent;
    private int[][] lift, weight;

    private int find(int p) {
        if (p != parent[p])
            parent[p] = find(parent[p]);
        return parent[p];
    }

    public DistanceLimitedPathsExist(int n, int[][] edgeList) {
        List<int[]>[] tree = new ArrayList[n];
        for (int i = 0; i < n; ++i) tree[i] = new ArrayList();
        parent = new int[n];
        for (int i = 0; i < n; ++i) parent[i] = i;
        Arrays.sort(edgeList, (a, b) -> Integer.compare(a[2], b[2]));
        for (var e : edgeList) {
            int uu = find(e[0]), vv = find(e[1]);
            if (uu != vv) {
                tree[e[0]].add(new int[] {e[1], e[2]});
                tree[e[1]].add(new int[] {e[0], e[2]});
                parent[uu] = vv;
            }
        }
        depth = new int[n];
        Arrays.fill(depth, -1);
        lift = new int[n][32];
        for (int i = 0; i < n; ++i) Arrays.fill(lift[i], -1);
        weight = new int[n][32];
        for (int i = 0; i < n; ++i)
            if (depth[i] == -1) {
                Stack<int[]> stk = new Stack();
                stk.add(new int[] {i, -1, 0});
                while (!stk.isEmpty()) {
                    var elem = stk.pop();
                    int u = elem[0], p = elem[1], d = elem[2];
                    depth[u] = d;
                    for (var uu : tree[u]) {
                        int v = uu[0], w = uu[1];
                        if (v != p) {
                            lift[v][0] = u;
                            weight[v][0] = w;
                            for (int j = 1; j < 32 && lift[v][j-1] != -1; ++j) {
                                weight[v][j] = Math.max(weight[v][j-1], weight[lift[v][j-1]][j-1]);
                                lift[v][j] = lift[lift[v][j-1]][j-1];
                            }
                            stk.add(new int[] {v, u, d+1});
                        }
                    }
                }
            }
    }

    public boolean query(int p, int q, int limit) {
        if (find(p) != find(q)) return false;
        if (depth[p] > depth[q]) {
            int tmp = p;
            p = q;
            q = tmp;
        }
        int wt = 0;
        for (int i = 0; i < 32; ++i)
            if ((depth[q]-depth[p] & 1<<i) > 0) {
                wt = Math.max(wt, weight[q][i]);
                q = lift[q][i];
            }
        if (p == q) return wt < limit;
        for (int i = 31; i >= 0; --i)
            if (lift[p][i] != lift[q][i] && 0 <= q) {
                wt = Math.max(wt, Math.max(weight[p][i], weight[q][i]));
                p = lift[p][i];
                q = lift[q][i];
            }
        return Math.max(wt, Math.max(weight[p][0], weight[q][0])) < limit;
    }
}


/*2254. Design Video Sharing Platform (Hard)
You have a video sharing platform where users can upload and delete videos.
Each video is a string of digits, where the ith digit of the string represents
the content of the video at minute i. For example, the first digit represents
the content at minute 0 in the video, the second digit represents the content
at minute 1 in the video, and so on. Viewers of videos can also like and
dislike videos. Internally, the platform keeps track of the number of views,
likes, and dislikes on each video. When a video is uploaded, it is associated
with the smallest available integer videoId starting from 0. Once a video is
deleted, the videoId associated with that video can be reused for another
video. Implement the VideoSharingPlatform class:
* VideoSharingPlatform() Initializes the object.
* int upload(String video) The user uploads a video. Return the videoId
  associated with the video.
* void remove(int videoId) If there is a video associated with videoId, remove
  the video.
* String watch(int videoId, int startMinute, int endMinute) If there is a video
  associated with videoId, increase the number of views on the video by 1 and
  return the substring of the video string starting at startMinute and ending
  at min(endMinute, video.length - 1) (inclusive). Otherwise, return "-1".
* void like(int videoId) Increases the number of likes on the video associated
  with videoId by 1 if there is a video associated with videoId.
* void dislike(int videoId) Increases the number of dislikes on the video
  associated with videoId by 1 if there is a video associated with videoId.
* int[] getLikesAndDislikes(int videoId) Return a 0-indexed integer array
  values of length 2 where values[0] is the number of likes and values[1] is
  the number of dislikes on the video associated with videoId. If there is no
  video associated with videoId, return [-1].
* int getViews(int videoId) Return the number of views on the video associated
  with videoId, if there is no video associated with videoId, return -1.

Example 1:
Input: ["VideoSharingPlatform", "upload", "upload", "remove", "remove", "upload", "watch", "watch", "like", "dislike", "dislike", "getLikesAndDislikes", "getViews"]
       [[], ["123"], ["456"], [4], [0], ["789"], [1, 0, 5], [1, 0, 1], [1], [1], [1], [1], [1]]
Output: [null, 0, 1, null, null, 0, "456", "45", null, null, null, [1, 2], 2]
Explanation
VideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform();
videoSharingPlatform.upload("123");          // The smallest available videoId is 0, so return 0.
videoSharingPlatform.upload("456");          // The smallest available videoId is 1, so return 1.
videoSharingPlatform.remove(4);              // There is no video associated with videoId 4, so do nothing.
videoSharingPlatform.remove(0);              // Remove the video associated with videoId 0.
videoSharingPlatform.upload("789");          // Since the video associated with videoId 0 was deleted,
                                             // 0 is the smallest available videoId, so return 0.
videoSharingPlatform.watch(1, 0, 5);         // The video associated with videoId 1 is "456".
                                             // The video from minute 0 to min(5, 3 - 1) = 2 is "456", so return "453".
videoSharingPlatform.watch(1, 0, 1);         // The video associated with videoId 1 is "456".
                                             // The video from minute 0 to min(1, 3 - 1) = 1 is "45", so return "45".
videoSharingPlatform.like(1);                // Increase the number of likes on the video associated with videoId 1.
videoSharingPlatform.dislike(1);             // Increase the number of dislikes on the video associated with videoId 1.
videoSharingPlatform.dislike(1);             // Increase the number of dislikes on the video associated with videoId 1.
videoSharingPlatform.getLikesAndDislikes(1); // There is 1 like and 2 dislikes on the video associated with videoId 1, so return [1, 2].
videoSharingPlatform.getViews(1);            // The video associated with videoId 1 has 2 views, so return 2.

Example 2:
Input: ["VideoSharingPlatform", "remove", "watch", "like", "dislike", "getLikesAndDislikes", "getViews"]
       [[], [0], [0, 0, 1], [0], [0], [0], [0]]
Output: [null, null, "-1", null, null, [-1], -1]
Explanation
VideoSharingPlatform videoSharingPlatform = new VideoSharingPlatform();
videoSharingPlatform.remove(0);              // There is no video associated with videoId 0, so do nothing.
videoSharingPlatform.watch(0, 0, 1);         // There is no video associated with videoId 0, so return "-1".
videoSharingPlatform.like(0);                // There is no video associated with videoId 0, so do nothing.
videoSharingPlatform.dislike(0);             // There is no video associated with videoId 0, so do nothing.
videoSharingPlatform.getLikesAndDislikes(0); // There is no video associated with videoId 0, so return [-1].
videoSharingPlatform.getViews(0);            // There is no video associated with videoId 0, so return -1.

Constraints:
* 1 <= video.length <= 10^5
* The sum of video.length over all calls to upload does not exceed 10^5
* video consists of digits.
* 0 <= videoId <= 10^5
* 0 <= startMinute < endMinute < 10^5
* startMinute < video.length
* The sum of endMinute - startMinute over all calls to watch does not exceed 10^5.
* At most 10^5 calls in total will be made to all functions.*/

class VideoSharingPlatform {
    private Queue<Integer> pq;
    private List<int[]> stats;
    private List<String> videos;

    public VideoSharingPlatform() {
        pq = new PriorityQueue();
        stats = new ArrayList();
        videos = new ArrayList();
    }

    public int upload(String video) {
        int videoId = videos.size();
        if (pq.size() > 0) {
            videoId = pq.poll();
            videos.set(videoId, video);
        } else {
            stats.add(new int[]{0, 0, 0});
            videos.add(video);
        }
        return videoId;
    }

    public void remove(int videoId) {
        if (videoId < videos.size() && !videos.get(videoId).isEmpty()) {
            pq.add(videoId);
            stats.set(videoId, new int[]{0, 0, 0});
            videos.set(videoId, "");
        }
    }

    public String watch(int videoId, int startMinute, int endMinute) {
        if (videoId < videos.size() && !videos.get(videoId).isEmpty()) {
            ++stats.get(videoId)[0];
            String video = videos.get(videoId);
            return video.substring(startMinute, Math.min(video.length(), endMinute+1));
        }
        return "-1";
    }

    public void like(int videoId) {
        if (videoId < videos.size() && !videos.get(videoId).isEmpty())
            ++stats.get(videoId)[1];
    }

    public void dislike(int videoId) {
        if (videoId < videos.size() && !videos.get(videoId).isEmpty())
            ++stats.get(videoId)[2];
    }

    public int[] getLikesAndDislikes(int videoId) {
        if (videoId < videos.size() && !videos.get(videoId).isEmpty())
            return new int[]{stats.get(videoId)[1], stats.get(videoId)[2]};
        return new int[]{-1};
    }

    public int getViews(int videoId) {
        if (videoId < videos.size() && !videos.get(videoId).isEmpty())
            return stats.get(videoId)[0];
        return -1;
    }
}


/*2502. Design Memory Allocator (Medium)
You are given an integer n representing the size of a 0-indexed memory array.
All memory units are initially free. You have a memory allocator with the
following functionalities:
* Allocate a block of size consecutive free memory units and assign it the id
  mID.
* Free all memory units with the given id mID.
Note that:
* Multiple blocks can be allocated to the same mID.
* You should free all the memory units with mID, even if they were allocated in
  different blocks.
Implement the Allocator class:
* Allocator(int n) Initializes an Allocator object with a memory array of size
  n.
* int allocate(int size, int mID) Find the leftmost block of size consecutive
  free memory units and allocate it with the id mID. Return the block's first
  index. If such a block does not exist, return -1.
* int free(int mID) Free all memory units with the id mID. Return the number of
  memory units you have freed.

Example 1:
Input: ["Allocator", "allocate", "allocate", "allocate", "free", "allocate", "allocate", "allocate", "free", "allocate", "free"]
       [[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]
Output: [null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]
Explanation:
Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.
loc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.
loc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.
loc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.
loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.
loc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.
loc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.
loc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.
loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.
loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.
loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.

Constraints:
* 1 <= n, size, mID <= 1000
* At most 1000 calls will be made to allocate and free.*/

class Allocator {
    private int[] memory;

    public Allocator(int n) {
        memory = new int[n];
    }

    public int allocate(int size, int mID) {
        int cnt = 0;
        for (int i = 0; i < memory.length; ++i) {
            if (memory[i] == 0) {
                if (++cnt == size) {
                    for (int ii = i; ii >= i-size+1; --ii)
                        memory[ii] = mID;
                    return i-size+1;
                }
            } else cnt = 0;
        }
        return -1;
    }

    public int free(int mID) {
        int ans = 0;
        for (int i = 0; i < memory.length; ++i)
            if (memory[i] == mID) {
                ++ans;
                memory[i] = 0;
            }
        return ans;
    }
}


/*2526. Find Consecutive Integers from a Data Stream (Medium)
For a stream of integers, implement a data structure that checks if the last k
integers parsed in the stream are equal to value. Implement the DataStream
class:
* DataStream(int value, int k) Initializes the object with an empty integer
  stream and the two integers value and k.
* boolean consec(int num) Adds num to the stream of integers. Returns true if
  the last k integers are equal to value, and false otherwise. If there are
  less than k integers, the condition does not hold true, so returns false.

Example 1:
Input: ["DataStream", "consec", "consec", "consec", "consec"]
       [[4, 3], [4], [4], [4], [3]]
Output: [null, false, false, true, false]
Explanation:
DataStream dataStream = new DataStream(4, 3); //value = 4, k = 3
dataStream.consec(4); // Only 1 integer is parsed, so returns False.
dataStream.consec(4); // Only 2 integers are parsed.
                      // Since 2 is less than k, returns False.
dataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True.
dataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].
                      // Since 3 is not equal to value, it returns False.

Constraints:
* 1 <= value, num <= 10^9
* 1 <= k <= 10^5
* At most 10^5 calls will be made to consec.*/

class DataStream {
    private int value = 0, k = 0, cnt = 0;

    public DataStream(int value, int k) {
        this.value = value;
        this.k = k;
    }

    public boolean consec(int num) {
        if (value == num) ++cnt;
        else cnt = 0;
        return cnt >= k;
    }
}


/*2642. Design Graph With Shortest Path Calculator (Hard)
There is a directed weighted graph that consists of n nodes numbered from 0 to
n - 1. The edges of the graph are initially represented by the given array
edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge
from fromi to toi with the cost edgeCosti. Implement the Graph class:
* Graph(int n, int[][] edges) initializes the object with n nodes and the given
  edges.
* addEdge(int[] edge) adds an edge to the list of edges where
  edge = [from, to, edgeCost]. It is guaranteed that there is no edge between
  the two nodes before adding this one.
* int shortestPath(int node1, int node2) returns the minimum cost of a path
  from node1 to node2. If no path exists, return -1. The cost of a path is the
  sum of the costs of the edges in the path.

Example 1:
Input: ["Graph", "shortestPath", "shortestPath", "addEdge", "shortestPath"]
[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]
Output: [null, 6, -1, null, 6]
Explanation:
Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);
g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first
                      // diagram above is 3 -> 0 -> 1 -> 2 with a total cost of
                      // 3 + 2 + 1 = 6.
g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.
g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the
                      // second diagram above.
g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is
                      // 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.

Constraints:
* 1 <= n <= 100
* 0 <= edges.length <= n * (n - 1)
* edges[i].length == edge.length == 3
* 0 <= fromi, toi, from, to, node1, node2 <= n - 1
* 1 <= edgeCosti, edgeCost <= 10^6
* There are no repeated edges and no self-loops in the graph at any point.
* At most 100 calls will be made for addEdge.
* At most 100 calls will be made for shortestPath.*/

class Graph {
    private int n;
    private List<int[]>[] graph;

    public Graph(int n, int[][] edges) {
        this.n = n;
        graph = new ArrayList[n];
        for (int i = 0; i < n; ++i)
            graph[i] = new ArrayList();
        for (var e : edges)
            graph[e[0]].add(new int[]{e[1], e[2]});
    }

    public void addEdge(int[] edge) {
        graph[edge[0]].add(new int[]{edge[1], edge[2]});
    }

    public int shortestPath(int node1, int node2) {
        Queue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        pq.add(new int[]{0, node1});
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[node1] = 0;
        while (!pq.isEmpty()) {
            var elem = pq.poll();
            int cost = elem[0], u = elem[1];
            if (u == node2) return cost;
            for (var nei : graph[u]) {
                int v = nei[0], w = nei[1];
                if (cost + w < dist[v]) {
                    dist[v] = cost + w;
                    pq.add(new int[]{cost + w, v});
                }
            }
        }
        return -1;
    }
}


/*2671. Frequency Tracker (Medium)
Design a data structure that keeps track of the values in it and answers some
queries regarding their frequencies. Implement the FrequencyTracker class.
* FrequencyTracker(): Initializes the FrequencyTracker object with an empty
  array initially.
* void add(int number): Adds number to the data structure.
* void deleteOne(int number): Deletes one occurence of number from the data
  structure. The data structure may not contain number, and in this case
  nothing is deleted.
* bool hasFrequency(int frequency): Returns true if there is a number in the
  data structure that occurs frequency number of times, otherwise, it returns
  false.

Example 1:
Input: ["FrequencyTracker", "add", "add", "hasFrequency"]
       [[], [3], [3], [2]]
Output: [null, null, null, true]
Explanation
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.add(3); // The data structure now contains [3]
frequencyTracker.add(3); // The data structure now contains [3, 3]
frequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice

Example 2:
Input: ["FrequencyTracker", "add", "deleteOne", "hasFrequency"]
       [[], [1], [1], [1]]
Output: [null, null, null, false]
Explanation
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.add(1); // The data structure now contains [1]
frequencyTracker.deleteOne(1); // The data structure becomes empty []
frequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty

Example 3:
Input: ["FrequencyTracker", "hasFrequency", "add", "hasFrequency"]
       [[], [2], [3], [1]]
Output: [null, false, null, true]
Explanation
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty
frequencyTracker.add(3); // The data structure now contains [3]
frequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once

Constraints:
* 1 <= number <= 10^5
* 1 <= frequency <= 10^5
* At most, 2 * 10^5 calls will be made to add, deleteOne, and hasFrequency in total.*/

class FrequencyTracker {
    public Map<Integer, Integer> freq;
    public Map<Integer, Set<Integer>> group;

    public FrequencyTracker() {
        freq = new HashMap();
        group = new HashMap();
    }

    public void add(int number) {
        if (freq.getOrDefault(number, 0) > 0) group.get(freq.get(number)).remove(number);
        freq.merge(number, 1, Integer::sum);
        group.putIfAbsent(freq.get(number), new HashSet());
        group.get(freq.get(number)).add(number);
    }

    public void deleteOne(int number) {
        if (freq.getOrDefault(number, 0) > 0) {
            group.get(freq.get(number)).remove(number);
            freq.merge(number, -1, Integer::sum);
            if (freq.get(number) > 0) group.get(freq.get(number)).add(number);
        }
    }

    public boolean hasFrequency(int frequency) {
        return group.containsKey(frequency) && !group.get(frequency).isEmpty();
    }
}


/*3242. Design Neighbor Sum Service (Easy)
You are given a n x n 2D array grid containing distinct elements in the range
[0, n^2 - 1]. Implement the NeighborSum class:
* NeighborSum(int [][]grid) initializes the object.
* int adjacentSum(int value) returns the sum of elements which are adjacent
  neighbors of value, that is either to the top, left, right, or bottom of value
  in grid.
* int diagonalSum(int value) returns the sum of elements which are diagonal
  neighbors of value, that is either to the top-left, top-right, bottom-left, or
  bottom-right of value in grid.

Example 1:
Input:
["NeighborSum", "adjacentSum", "adjacentSum", "diagonalSum", "diagonalSum"]
[[[[0, 1, 2], [3, 4, 5], [6, 7, 8]]], [1], [4], [4], [8]]
Output: [null, 6, 16, 16, 4]

Explanation: The adjacent neighbors of 1 are 0, 2, and 4.
             The adjacent neighbors of 4 are 1, 3, 5, and 7.
             The diagonal neighbors of 4 are 0, 2, 6, and 8.
             The diagonal neighbor of 8 is 4.

Example 2:
Input:
["NeighborSum", "adjacentSum", "diagonalSum"]
[[[[1, 2, 0, 3], [4, 7, 15, 6], [8, 9, 10, 11], [12, 13, 14, 5]]], [15], [9]]
Output: [null, 23, 45]
Explanation: The adjacent neighbors of 15 are 0, 10, 7, and 6.
             The diagonal neighbors of 9 are 4, 12, 14, and 15.

Constraints:
* 3 <= n == grid.length == grid[0].length <= 10
* 0 <= grid[i][j] <= n^2 - 1
* All grid[i][j] are distinct.
* value in adjacentSum and diagonalSum will be in the range [0, n^2 - 1].
* At most 2 * n^2 calls will be made to adjacentSum and diagonalSum.*/

class neighborSum {
    private int[][] vals;

    public neighborSum(int[][] grid) {
        int n = grid.length;
        vals = new int[2][n*n];
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j) {
                for (var elem : new int[][]{{i-1, j}, {i, j-1}, {i, j+1}, {i+1, j}}) {
                    int ii = elem[0], jj = elem[1];
                    if (0 <= ii && ii < n && 0 <= jj && jj < n)
                        vals[0][grid[i][j]] += grid[ii][jj];
                }
                for (var elem : new int[][]{{i-1, j-1}, {i-1, j+1}, {i+1, j-1}, {i+1, j+1}}) {
                    int ii = elem[0], jj = elem[1];
                    if (0 <= ii && ii < n && 0 <= jj && jj < n)
                        vals[1][grid[i][j]] += grid[ii][jj];
                }
            }
    }

    public int adjacentSum(int value) {
        return vals[0][value];
    }

    public int diagonalSum(int value) {
        return vals[1][value];
    }
}


/*3408. Design Task Manager (Medium)
There is a task management system that allows users to manage their tasks,
each associated with a priority. The system should efficiently handle
adding, modifying, executing, and removing tasks. Implement the TaskManager
class:
* TaskManager(vector<vector<int>>& tasks) initializes the task manager with
  a list of user-task-priority triples. Each element in the input list is of
  the form [userId, taskId, priority], which adds a task to the specified
  user with the given priority.
* void add(int userId, int taskId, int priority) adds a task with the
  specified taskId and priority to the user with userId. It is guaranteed
  that taskId does not exist in the system.
* void edit(int taskId, int newPriority) updates the priority of the
  existing taskId to newPriority. It is guaranteed that taskId exists in the
  system.
* void rmv(int taskId) removes the task identified by taskId from the
  system. It is guaranteed that taskId exists in the system.
* int execTop() executes the task with the highest priority across all
  users. If there are multiple tasks with the same highest priority, execute
  the one with the highest taskId. After executing, the taskId is removed
  from the system. Return the userId associated with the executed task. If
  no tasks are available, return -1.
Note that a user may be assigned multiple tasks.

Example 1:
Input: ["TaskManager", "add", "edit", "execTop", "rmv", "add", "execTop"]
       [[[[1, 101, 10], [2, 102, 20], [3, 103, 15]]], [4, 104, 5], [102, 8], [], [101], [5, 105, 15], []]
Output: [null, null, null, 3, null, null, 5]
Explanation * TaskManager taskManager = new TaskManager([[1, 101, 10], [2, 102, 20], [3, 103, 15]]); // Initializes with three tasks for Users 1, 2, and 3.
            * taskManager.add(4, 104, 5); // Adds task 104 with priority 5 for User 4.
            * taskManager.edit(102, 8); // Updates priority of task 102 to 8.
            * taskManager.execTop(); // return 3. Executes task 103 for User 3.
            * taskManager.rmv(101); // Removes task 101 from the system.
            * taskManager.add(5, 105, 15); // Adds task 105 with priority 15 for User 5.
            * taskManager.execTop(); // return 5. Executes task 105 for User 5.

Constraints:
* 1 <= tasks.length <= 105^
* 0 <= userId <= 10^5
* 0 <= taskId <= 10^5
* 0 <= priority <= 10^9
* 0 <= newPriority <= 10^9
* At most 2 * 10^5 calls will be made in total to add, edit, rmv, and
  execTop methods.
* The input is generated such that taskId will be valid.*/

class TaskManager {

    public Map<Integer, int[]> map;
    public TreeSet<int[]> treeSet;

    public TaskManager(List<List<Integer>> tasks) {
        map = new HashMap<>();
        treeSet = new TreeSet<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] x, int[] y) {
                for (int i = 0; i < 3; ++i)
                    if (x[i] != y[i]) return Integer.compare(x[i], y[i]);
                return 0;
            }
        });
        for (var task : tasks) {
            int userId = task.get(0), taskId = task.get(1), priority = task.get(2);
            add(userId, taskId, priority);
        }
    }

    public void add(int userId, int taskId, int priority) {
        map.put(taskId, new int[]{priority, taskId, userId});
        treeSet.add(map.get(taskId));
    }

    public void edit(int taskId, int newPriority) {
        treeSet.remove(map.get(taskId));
        map.get(taskId)[0] = newPriority;
        treeSet.add(map.get(taskId));
    }

    public void rmv(int taskId) {
        treeSet.remove(map.get(taskId));
        map.remove(taskId);
    }

    public int execTop() {
        if (!treeSet.isEmpty()) {
            var item = treeSet.last();
            treeSet.remove(item);
            int taskId = item[1], userId = item[2];
            map.remove(taskId);
            return userId;
        }
        return -1;
    }
}
